URL: http://www.research.digital.com/SRC/personal/heydon/papers/Thesis.ps.Z
Refering-URL: http://www.research.digital.com/SRC/personal/heydon/mirobib.html
Root-URL: http://www.research.digital.com
Title: Processing Visual Specifications of File System Security  
Author: C. Allan Heydon 
Degree: Submitted to  in partial fulfillment of the requirements for the degree of Doctor of Philosophy.  
Note: Copyright c 1991 Clark Allan Heydon, All Rights Reserved This research was sponsored in part by the National Science Foundation under a Presidential Young Investigator Award, Contract CCR-8858087. It was also supported in part by the Avionics Laboratory, Wright Research and Development Center, Aeronautical Systems Division (AFSC), U.S. Air Force, Wright-Patterson AFB, Ohio 45433-6543 under Contract F33615-90-C-1465, ARPA Order No. 7597.  
Address: Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  Carnegie Mellon University  
Date: October 1, 1992  
Pubnum: CMU-CS-91-201  
Abstract-found: 0
Intro-found: 1
Reference: [AB89] <author> Allen L. Ambler and Margaret M. Burnett. </author> <title> Visual Languages and the Conflict Between Single Assignment and Iteration. </title> <booktitle> In Proceedings of the 1989 IEEE Workshop on Visual Languages, </booktitle> <pages> pages 138-143, </pages> <address> Los Alamitos, CA, October 1989. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Significant efforts in this area are reported in a number of excellent collections [CIL86, Cha90c, Cha90b, Gli90a, Gli90b, IJK90, Shu88]. Many of these systems use icons to represent functional <ref> [AB89, Bor89, CGLT86, HTI90] </ref>, object oriented [Rog90], or control-flow [Gli86, KG88] models of program execution. A second distinction is that our system defines a precise semantics for every well-formed picture. In contrast, as Shu points out [Shu88], most visual programming languages described in the literature lack mathematical rigor.
Reference: [AHU74] <author> Alfred V. Aho, John E. Hopcroft, and Jeffrey D. Ullman. </author> <title> The Design and Analysis of Computer Algorithms. </title> <booktitle> Addison-Wesley Series in Computer Science and Information Processing. </booktitle> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, Massachusetts, </address> <year> 1974. </year>
Reference-contexts: If G is acyclic, then the transitive reduction is unique <ref> [AHU74, pg. 219] </ref>. 3.3. A NAIVE ALGORITHM 39 The containment relation on boxes is the ancestor relation on nodes in the containment DAG. Ideally, we would like to compute this relation in O (1) time using a small amount of preprocessing time and a realistic amount of space.
Reference: [Bal88] <author> Robert W. Baldwin. </author> <title> Rule Based Analysis of Computer Security. </title> <type> PhD thesis, </type> <institution> MIT, </institution> <address> Cambridge, MA 02139, </address> <month> March </month> <year> 1988. </year> <note> Tech Report MIT/LCS/TR-401. </note>
Reference-contexts: In Section 7.1, we argue the pros and cons of each approach. Other work in the literature relates indirectly to ours. Baldwin, in his U-Kuang rule-based expert system to find security holes in a Unix system <ref> [Bal88] </ref>, explicitly mentions the need for a better means of specifying a security policy.
Reference: [Ben75] <author> J. Bentley. </author> <title> Multidimensional Binary Search Trees Used for Associative Searching. </title> <journal> Communications of the ACM, </journal> <volume> 18(9) </volume> <pages> 509-511, </pages> <month> September </month> <year> 1975. </year>
Reference-contexts: In the case of discriminator trees, the work of Helm, Marriott, and Odersky [HMO91] suggests that these structures might find application in visual language parsing. Their system currently uses Bentley's kd-Trees <ref> [Ben75] </ref> to store graphical elements for quick access according to bounding box ranges, but discriminator trees might provide it with the flexibility to search over more complicated attribute combinations.
Reference: [Ben84] <author> T. Benzel. </author> <title> Analysis of a Kernel Verification. </title> <booktitle> In Proceedings of the 1984 IEEE Symposium on Security and Privacy, </booktitle> <pages> pages 125-131, </pages> <address> Oakland, CA, </address> <month> May </month> <year> 1984. </year>
Reference-contexts: For example, McLean has shown that the "Basic Security Theorem" of Bell and LaPadula can be adapted to apply to systems that are blatantly insecure [McL85]. 2 Benzel describes the verification of a "secure" operating system kernel in which more covert channels were found by hand than by formal means <ref> [Ben84] </ref>. Our hope is that by using a visual notation, security specifications can be made less error-prone. We suspect that textual and visual techniques are complementary, being more or less suited to different domains. In Section 7.1, we argue the pros and cons of each approach.
Reference: [BL73] <author> D. E. Bell and L. J. LaPadula. </author> <title> Secure Computer Systems: Mathematical Foundations (3 Volumes). </title> <type> Technical Report AD-770 768, </type> <institution> AD-771 543, AD-780 528, The MITRE Corporation, </institution> <address> Box 208, Bedford, MA 01731, </address> <month> November </month> <year> 1973. </year>
Reference-contexts: Other access matrices must be disallowed because they violate a specific security policy. For example, in the military Bell-LaPadula security model <ref> [BL73, Dep85] </ref>, users and files in the operating system are assigned linear security levels (e.g., top secret, secret, not secret); roughly speaking, it is only acceptable for users to write to files at their security level or higher and to read files at their level or lower.
Reference: [BL76] <author> D. E. Bell and L. J. LaPadula. </author> <title> Secure Computer Systems: Unified Exposition and Multics Interpretation. </title> <type> Technical Report AD-A023 588, </type> <institution> The MITRE Corporation, </institution> <address> Box 208, Bedford, MA 01731, </address> <month> March </month> <year> 1976. </year> <note> This report is a summary of three earlier reports by the same authors published in November, 1973 and April, </note> <year> 1974. </year> <title> The numbers of the three reports are AD-770 768, </title> <note> AD-771 543, and AD-780 528. </note>
Reference-contexts: The instance language is designed to address this need. Its intuitive and concise nature makes it possible, even for non-experts, to manage the access rights on a large number of files Policy Specification Previous approaches to specifying security policies have assumed fixed policies <ref> [BL76, Kem82, NBF + 80] </ref>. Our constraint language, on the other hand, provides a flexible way to specify alternative security policies. That flexibility allows us to express a greater variety of security policies than previous policy specification languages. <p> As we stated previously, most of the previous work in security specification is text-based. Bell and LaPadula developed a formal model for a secure system based on finite state machines <ref> [BL76] </ref>, and others have built off this work [McC90, McL90]. There have been at least two extensive efforts to specify, verify, and implement a secure operating system [Kem82, NBF + 80]. Rabin and Tygar also use text-based methods to specify access control in their security toolkit [RT87].
Reference: [Bor89] <author> Kjell Borg. </author> <title> Visual Programming and UNIX. </title> <booktitle> In Proceedings of the 1989 IEEE Workshop on Visual Languages, </booktitle> <pages> pages 74-79, </pages> <address> Los Alamitos, CA, </address> <month> October </month> <year> 1989. </year> <journal> IEEE Computer Society Press. </journal> <volume> 209 210 BIBLIOGRAPHY </volume>
Reference-contexts: Significant efforts in this area are reported in a number of excellent collections [CIL86, Cha90c, Cha90b, Gli90a, Gli90b, IJK90, Shu88]. Many of these systems use icons to represent functional <ref> [AB89, Bor89, CGLT86, HTI90] </ref>, object oriented [Rog90], or control-flow [Gli86, KG88] models of program execution. A second distinction is that our system defines a precise semantics for every well-formed picture. In contrast, as Shu points out [Shu88], most visual programming languages described in the literature lack mathematical rigor.
Reference: [CC90] <author> Gennaro Costagliola and Shi-Kuo Chang. </author> <title> DR Parsers: A Generalization of LR Parsers. </title> <booktitle> In Proceedings of the 1990 IEEE Workshop on Visual Languages, </booktitle> <pages> pages 174-180, </pages> <address> Los Alamitos, CA, October 1990. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: However, this representation lacks essential topological relations between elements such as the arrow connections and the containment relations among boxes. Although general visual language grammars and parsers for extracting such topological relations have been designed and implemented <ref> [CTYY89, Cha90a, CC90, Gol90, GR89, RWIG90] </ref>, they are unnecessary in this case. We therefore assume that an instance picture is represented by entries containing descriptions of box and arrow graphical elements.
Reference: [CGLT86] <author> G. Cattanio, A. Guercio, S. Levialdi, and G. Tortora. IconLisp: </author> <title> An Example of a Visual Programming Language. </title> <booktitle> In Proceedings of the 1986 IEEE Workshop on Visual Languages, </booktitle> <pages> pages 22-25, </pages> <address> Los Alamitos, CA, 1986. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Significant efforts in this area are reported in a number of excellent collections [CIL86, Cha90c, Cha90b, Gli90a, Gli90b, IJK90, Shu88]. Many of these systems use icons to represent functional <ref> [AB89, Bor89, CGLT86, HTI90] </ref>, object oriented [Rog90], or control-flow [Gli86, KG88] models of program execution. A second distinction is that our system defines a precise semantics for every well-formed picture. In contrast, as Shu points out [Shu88], most visual programming languages described in the literature lack mathematical rigor.
Reference: [Cha88] <author> Shi-Kuo Chang. </author> <title> The Design of a Visual Language Compiler. </title> <booktitle> In Proceedings of the 1988 IEEE Workshop on Visual Languages, </booktitle> <pages> pages 84-91, </pages> <address> Los Alamitos, CA, October 1988. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: A second distinction is that our system defines a precise semantics for every well-formed picture. In contrast, as Shu points out [Shu88], most visual programming languages described in the literature lack mathematical rigor. Other researchers | most notably Chang et al <ref> [Cha88, CTYY89] </ref> and Golin, Rubin, and Walker [GR89, RWIG90] | have addressed the problem of building visual language compilers. Our compiler differs from these systems in two ways.
Reference: [Cha90a] <author> S. K. Chang. </author> <title> A Visual Language Compiler for Information Retrieval by Visual Reasoning. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(10) </volume> <pages> 1136-1149, </pages> <month> Octo-ber </month> <year> 1990. </year>
Reference-contexts: However, this representation lacks essential topological relations between elements such as the arrow connections and the containment relations among boxes. Although general visual language grammars and parsers for extracting such topological relations have been designed and implemented <ref> [CTYY89, Cha90a, CC90, Gol90, GR89, RWIG90] </ref>, they are unnecessary in this case. We therefore assume that an instance picture is represented by entries containing descriptions of box and arrow graphical elements.
Reference: [Cha90b] <author> Shi-Kuo Chang, </author> <title> editor. </title> <booktitle> Principles of Visual Programming Systems. </booktitle> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1990. </year> <note> 372 pgs. </note>
Reference-contexts: Finally, it reports on tools which implement these algorithms. Most other work in the field of visual languages differs from ours in that it addresses the domain of computer programming. Significant efforts in this area are reported in a number of excellent collections <ref> [CIL86, Cha90c, Cha90b, Gli90a, Gli90b, IJK90, Shu88] </ref>. Many of these systems use icons to represent functional [AB89, Bor89, CGLT86, HTI90], object oriented [Rog90], or control-flow [Gli86, KG88] models of program execution. A second distinction is that our system defines a precise semantics for every well-formed picture.
Reference: [Cha90c] <author> Shi-Kuo Chang, </author> <title> editor. Visual Languages and Visual Programming. </title> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1990. </year> <note> 340 pgs. </note>
Reference-contexts: Finally, it reports on tools which implement these algorithms. Most other work in the field of visual languages differs from ours in that it addresses the domain of computer programming. Significant efforts in this area are reported in a number of excellent collections <ref> [CIL86, Cha90c, Cha90b, Gli90a, Gli90b, IJK90, Shu88] </ref>. Many of these systems use icons to represent functional [AB89, Bor89, CGLT86, HTI90], object oriented [Rog90], or control-flow [Gli86, KG88] models of program execution. A second distinction is that our system defines a precise semantics for every well-formed picture.
Reference: [CIL86] <author> Shi-Kuo Chang, Tadao Ichikawa, and Panos A. Ligomenides, </author> <title> editors. Visual Languages. </title> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1986. </year> <note> 460 pgs. </note>
Reference-contexts: Finally, it reports on tools which implement these algorithms. Most other work in the field of visual languages differs from ours in that it addresses the domain of computer programming. Significant efforts in this area are reported in a number of excellent collections <ref> [CIL86, Cha90c, Cha90b, Gli90a, Gli90b, IJK90, Shu88] </ref>. Many of these systems use icons to represent functional [AB89, Bor89, CGLT86, HTI90], object oriented [Rog90], or control-flow [Gli86, KG88] models of program execution. A second distinction is that our system defines a precise semantics for every well-formed picture.
Reference: [CLR89] <author> Thomas H. Cormen, Charles Eric. Leiserson, and Ronald L. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> The MIT electrical engineering and computer science series. MIT Press; McGraw-Hill, </publisher> <address> Cambridge, Mass; New York, </address> <year> 1989. </year>
Reference-contexts: Using dynamic hash tables, we can store and retrieve elements from this table in O (1) amortized time <ref> [CLR89, pgs. 367-370] </ref>. However, in the case where A p (s; o) = ;, we must actually compute the minimal witness set. The procedure MinWSet (X,Y ) requires O (j Xjj Y j) time, where X and Y are both witness sets.
Reference: [Cor88] <institution> Claris Corp. Macdraw II, 1988. Computer Program. </institution>
Reference-contexts: By a "smart" graphical editor, we mean a tool that does more than MacDraw and its spinoffs <ref> [Cor88, LV89] </ref>, which provide direct manipulation capabilities on graphical objects. It must also encompass design rules built into the instance language, such as those listed in Table 2.3. For example, when the user drags a box with the mouse, the arrows attached to the box must move as well. <p> The panning mechanism may be provided in the form of scroll-bars, as in MacDraw II <ref> [Cor88] </ref>, or in the form of a "panner gadget", as provided by Idraw [LV89]. The current version of the Miro editor supports several of these features.
Reference: [CTYY89] <author> Shi-kuo Chang, Michael J. Tauber, Bing Yu, and Jing-Sheng Yu. </author> <title> A Visual Language Compiler. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 15(5) </volume> <pages> 506-525, </pages> <month> May </month> <year> 1989. </year>
Reference-contexts: A second distinction is that our system defines a precise semantics for every well-formed picture. In contrast, as Shu points out [Shu88], most visual programming languages described in the literature lack mathematical rigor. Other researchers | most notably Chang et al <ref> [Cha88, CTYY89] </ref> and Golin, Rubin, and Walker [GR89, RWIG90] | have addressed the problem of building visual language compilers. Our compiler differs from these systems in two ways. <p> However, this representation lacks essential topological relations between elements such as the arrow connections and the containment relations among boxes. Although general visual language grammars and parsers for extracting such topological relations have been designed and implemented <ref> [CTYY89, Cha90a, CC90, Gol90, GR89, RWIG90] </ref>, they are unnecessary in this case. We therefore assume that an instance picture is represented by entries containing descriptions of box and arrow graphical elements.
Reference: [Dep85] <institution> Department of Defense. Trusted Computer System Evaluation Criteria. </institution> <type> Technical Report CSC-STD-001-83, </type> <institution> Computer Security Center, Department of Defense, Fort Meade, MD, </institution> <month> March </month> <year> 1985. </year>
Reference-contexts: Other access matrices must be disallowed because they violate a specific security policy. For example, in the military Bell-LaPadula security model <ref> [BL73, Dep85] </ref>, users and files in the operating system are assigned linear security levels (e.g., top secret, secret, not secret); roughly speaking, it is only acceptable for users to write to files at their security level or higher and to read files at their level or lower.
Reference: [FR74] <author> M. J. Fischer and M. O. Rabin. </author> <title> Super-Exponential Complexity of Presburger Arithmetic. </title> <editor> In R. M. Karp, editor, </editor> <booktitle> Complexity of Computation, 1974. Proceedings of SIAM-AMS Symposium in Applied Mathematics. </booktitle> <address> BIBLIOGRAPHY 211 </address>
Reference-contexts: However, even statements in this restricted theory have been proven to require doubly exponential time for verification on a non-deterministic machine <ref> [FR74] </ref>. Despite these complexity results, logicians and computer scientists have attempted to develop automatic theorem provers for restricted logics. People have found it very difficult to build such tools, and there is still much ongoing research in this area.
Reference: [Fra89] <author> Franz Inc. </author> <title> Allegro Common Lisp User Guide, </title> <month> November </month> <year> 1989. </year> <title> Release 3.1, Document Number D-U-00-000-01-91120-0-0. </title>
Reference-contexts: The third line builds the sysname discriminator off a newly created world slot of the type discriminator. Finally, the fourth line attaches a bag to the newly created new-slot slot of the sysname discriminator. 5 In particular, it uses the Allegro CL Flavors package <ref> [Fra89, chapter 9] </ref>. 6 To be precise, two discriminator trees are actually used to store the information required to efficiently iterate over semantic arrows. 98 CHAPTER 5. <p> The extensions forming the IPQL are simply a set of type, macro, and function definitions. In particular, the IPQL's abstract data structures | discriminators, DTs, and iterators | are implemented in an object-oriented extension to Allegro Common Lisp called Flavors <ref> [Fra89, chapter 9] </ref>. We divide the facilities provided by the IPQL into the following three categories: 1) functions for constructing DTs, 2) functions for creating instance picture elements and installing them into the instance picture database represented by previously created DTs, and 3) functions for querying an instance picture database.
Reference: [FZ89] <author> Paul Franchi-Zannettacci. </author> <title> Attribute Specifications for Graphical Interface Generation. </title> <booktitle> In Proceedings of the IFIP 11 th World Computer Congress, </booktitle> <pages> pages 149-155, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: The grammars describing the syntax of the "target" visual language use textual predicates to describe constraints on terminal and non-terminal symbols in the grammar <ref> [FZ89, HMO91, RWIG90] </ref>.
Reference: [GJ79] <author> Michael R. Garey and David S. Johnson. </author> <title> Computers and Intractability: A Guide to the Theory of NP-Completeness. A Series of Books in the Mathematical Sciences. </title> <editor> W. H. </editor> <publisher> Freeman and Company, </publisher> <address> San Francisco, California, </address> <year> 1979. </year>
Reference-contexts: We first describe the formal decision problems necessary for our proof. We then prove the 2 -completeness of both the sub-DAG isomorphism problem and the Restricted Constraint Checking problem. 5.5.1 Problem Descriptions We start with the following canonical p 2 -complete problem <ref> [GJ79] </ref>: 2 -3SAT (a.k.a. <p> These definitions can be found in many standard algorithms texts, e.g., <ref> [GJ79] </ref> and [Tar83]. Definition 9 (Subgraph, Induced Subgraph) Let G = (V; E) be a graph. Then G 0 = (V 0 ; E 0 ) is a subgraph of G, written G 0 G, if V 0 V and E 0 E.
Reference: [Gli86] <author> Ephraim P. Glinert. </author> <title> Towards "Second Generation" Interactive, Graphical Programming Environments. </title> <booktitle> In Proceedings of the 1986 IEEE Workshop on Visual Languages, </booktitle> <pages> pages 61-70, </pages> <address> Los Alamitos, CA, 1986. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Significant efforts in this area are reported in a number of excellent collections [CIL86, Cha90c, Cha90b, Gli90a, Gli90b, IJK90, Shu88]. Many of these systems use icons to represent functional [AB89, Bor89, CGLT86, HTI90], object oriented [Rog90], or control-flow <ref> [Gli86, KG88] </ref> models of program execution. A second distinction is that our system defines a precise semantics for every well-formed picture. In contrast, as Shu points out [Shu88], most visual programming languages described in the literature lack mathematical rigor.
Reference: [Gli90a] <author> Ephraim P. Glinert, </author> <title> editor. Visual Programming Environments: Applications and Issues. </title> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA, </address> <year> 1990. </year> <note> 687 pgs. </note>
Reference-contexts: Finally, it reports on tools which implement these algorithms. Most other work in the field of visual languages differs from ours in that it addresses the domain of computer programming. Significant efforts in this area are reported in a number of excellent collections <ref> [CIL86, Cha90c, Cha90b, Gli90a, Gli90b, IJK90, Shu88] </ref>. Many of these systems use icons to represent functional [AB89, Bor89, CGLT86, HTI90], object oriented [Rog90], or control-flow [Gli86, KG88] models of program execution. A second distinction is that our system defines a precise semantics for every well-formed picture.
Reference: [Gli90b] <author> Ephraim P. Glinert, </author> <title> editor. Visual Programming Environments: Paradigms and Systems. </title> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA, </address> <year> 1990. </year> <note> 661 pgs. </note>
Reference-contexts: Finally, it reports on tools which implement these algorithms. Most other work in the field of visual languages differs from ours in that it addresses the domain of computer programming. Significant efforts in this area are reported in a number of excellent collections <ref> [CIL86, Cha90c, Cha90b, Gli90a, Gli90b, IJK90, Shu88] </ref>. Many of these systems use icons to represent functional [AB89, Bor89, CGLT86, HTI90], object oriented [Rog90], or control-flow [Gli86, KG88] models of program execution. A second distinction is that our system defines a precise semantics for every well-formed picture.
Reference: [GM84] <author> F. T. Grampp and R. H. Morris. </author> <title> Unix Operating System Security. </title> <journal> AT&T Bell Laboratories Technical Journal, </journal> <volume> 63(8) </volume> <pages> 1649-1672, </pages> <month> October </month> <year> 1984. </year> <title> Part 2. </title>
Reference-contexts: In Section 6.5, we present several constraint pictures "written" for Unix. Some of the constraint pictures we present are adapted from previous Miro papers, while others have been "transcribed" from textual security suggestions described by Grampp and Morris in a well-known paper on Unix security <ref> [GM84] </ref>. One important aspect of this section is that it demonstrates the utility and expressive power of the the constraint language. Finally, in Section 6.6, we report how long it takes the constraint checker to check our sample constraints on some of the Unix instance pictures. <p> We have adapted some of these constraints from original constraints suggested in previous Miro papers [HMT + 90, HMT + 90]. The others were suggested in an article on Unix security by Grampp and Morris <ref> [GM84] </ref>; we have simply translated their written security suggestions into constraint pictures. 6.5.1 General Constraint Characteristics We start by stating some general characteristics of our constraints.
Reference: [Gol90] <author> E.J. Golin. </author> <title> A Method for the Specification and Parsing of Visual Languages. </title> <type> PhD thesis, </type> <institution> Brown University, </institution> <year> 1990. </year>
Reference-contexts: However, this representation lacks essential topological relations between elements such as the arrow connections and the containment relations among boxes. Although general visual language grammars and parsers for extracting such topological relations have been designed and implemented <ref> [CTYY89, Cha90a, CC90, Gol90, GR89, RWIG90] </ref>, they are unnecessary in this case. We therefore assume that an instance picture is represented by entries containing descriptions of box and arrow graphical elements.
Reference: [GR89] <author> E. J. Golin and S. P. Reiss. </author> <title> The Specification of Visual Language Syntax. </title> <booktitle> In Proceedings of the 1989 IEEE Workshop on Visual Languages, </booktitle> <pages> pages 105-110, </pages> <address> Los Alamitos, CA, October 1989. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: A second distinction is that our system defines a precise semantics for every well-formed picture. In contrast, as Shu points out [Shu88], most visual programming languages described in the literature lack mathematical rigor. Other researchers | most notably Chang et al [Cha88, CTYY89] and Golin, Rubin, and Walker <ref> [GR89, RWIG90] </ref> | have addressed the problem of building visual language compilers. Our compiler differs from these systems in two ways. First, their research is more concerned with developing general visual language parsers, whereas our compiler reads pictures that explicitly represent topological relations between graphical elements. <p> However, this representation lacks essential topological relations between elements such as the arrow connections and the containment relations among boxes. Although general visual language grammars and parsers for extracting such topological relations have been designed and implemented <ref> [CTYY89, Cha90a, CC90, Gol90, GR89, RWIG90] </ref>, they are unnecessary in this case. We therefore assume that an instance picture is represented by entries containing descriptions of box and arrow graphical elements. <p> The situation is not as uniform in the world of visual languages. There has yet to evolve a single underlying representation for visual languages, although there have been some inroads in this direction <ref> [GR89] </ref>. Until such underpinnings are established, there is little hope for the creation of a universal visual language editor. Instead, visual language developers are forced to build customized editors.
Reference: [Har87] <author> David Harel. Statecharts: </author> <title> A visual formalism for complex systems. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8(3) </volume> <pages> 231-274, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: Note that since we expect constraint language pictures to be small, the issue of scalability is not as important in its case. These three properties drove us in our design. We benefited greatly from the influence of Harel's visual specification languages, statecharts <ref> [Har87, HPSS87] </ref> and higraphs [Har88]. Both of these languages are defined by a formal syntax and semantics. Our visual languages borrow many key elements from the higraph notation. <p> We give a more detailed description of our experiments on a Unix file system in Chapter 6. 1.3 Previous and Related Work As we mentioned previously, the work of David Harel had a large influence on our work <ref> [Har87, Har88] </ref>. Our visual language vocabulary borrows extensively from his.
Reference: [Har88] <author> David Harel. </author> <title> On Visual Formalisms. </title> <journal> Communications of the ACM, </journal> <volume> 31(5) </volume> <pages> 514-530, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: Note that since we expect constraint language pictures to be small, the issue of scalability is not as important in its case. These three properties drove us in our design. We benefited greatly from the influence of Harel's visual specification languages, statecharts [Har87, HPSS87] and higraphs <ref> [Har88] </ref>. Both of these languages are defined by a formal syntax and semantics. Our visual languages borrow many key elements from the higraph notation. For our purposes, the essential property of higraphs is that they depict sets of objects | represented by Venn diagrams | and relations on those sets. <p> We give a more detailed description of our experiments on a Unix file system in Chapter 6. 1.3 Previous and Related Work As we mentioned previously, the work of David Harel had a large influence on our work <ref> [Har87, Har88] </ref>. Our visual language vocabulary borrows extensively from his. <p> The user may also want to see arrows attached to Class II boxes. In this case, we can draw the arrow to some arbitrary point inside the box containing the hidden box, and use a special arrow endpoint notation suggested by Harel <ref> [Har88] </ref> and shown in Figure 7.5. We may want to elide the permission names on such special arrows. To simplify the elision, we may also choose to "coalesce" multiple arrows of the same parity wherever possible. Another way to elide arrows is by their permission value.
Reference: [Has87] <author> Johan Hastad. </author> <title> Computatonal Limitations of Small-Depth Circuits. </title> <booktitle> ACM Doctoral Dissertation Series. </booktitle> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: We exhibit an infinite family of instance pictures, with one instance picture in the family for each size n 2 N. This instance picture family is analogous to the notion of a uniform circuit family <ref> [Has87, Hey90] </ref>. We show that the instance picture in the family with index n requires time to check for ambiguity. This bound applies to all three alternative semantics described in Section 2.3 as well. The instance picture with index n is constructed as follows.
Reference: [Hey90] <author> Allan Heydon. </author> <title> An Introduction to Circuit Complexity and a Guide to Hastad's Proof. </title> <type> Technical Report CMU-CS-90-141-R, </type> <institution> Carnegie Mellon University, School of Computer Science, </institution> <address> 5000 Forbes Ave., Pittsburgh, PA 15213-3890, </address> <month> June </month> <year> 1990. </year> <note> 212 BIBLIOGRAPHY </note>
Reference-contexts: We exhibit an infinite family of instance pictures, with one instance picture in the family for each size n 2 N. This instance picture family is analogous to the notion of a uniform circuit family <ref> [Has87, Hey90] </ref>. We show that the instance picture in the family with index n requires time to check for ambiguity. This bound applies to all three alternative semantics described in Section 2.3 as well. The instance picture with index n is constructed as follows.
Reference: [HLN + 90] <author> D. Harel, H. Lachover, A. Naamad, A. Pnueli, M. Politi, R. Sherman, A. Shtul-Trauring, and M. Trakhtenbrot. STATEMATE: </author> <title> A Working Environment for the Development of Complex Reactive Systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(4), </volume> <month> April </month> <year> 1990. </year> <note> Preliminary version appeared in Proc. 10th International Conference on Software Engineering, </note> <institution> Singapore, </institution> <month> April </month> <year> 1988, </year> <pages> pp. 396406. </pages>
Reference-contexts: When a box is selected and a smart "zoom-out" operation is performed, the bounding box of those boxes directly containing the selected box is computed, and the zoom factor and centering computations are performed on the bounding box as in the smart zoom-in operation. The statemate system <ref> [HLN + 90] </ref> actually supports just such smart zooming operations. In statemate, the zoom-in and -out operations are called "diving" and "surfacing", respectively. By zooming in on parts of a picture, we simultaneously hide parts of the picture outside our interest.
Reference: [HMO91] <author> Richard Helm, Kim Marriott, and Martin Odersky. </author> <title> Building Visual Language Parsers. </title> <booktitle> In Proceedings of CHI, </booktitle> <pages> pages 105-112, </pages> <address> New York, April 28 May 2 1991. </address> <publisher> ACM Press. </publisher>
Reference-contexts: The grammars describing the syntax of the "target" visual language use textual predicates to describe constraints on terminal and non-terminal symbols in the grammar <ref> [FZ89, HMO91, RWIG90] </ref>. <p> Another possible area for future research would be to find alternative applications for our "DFS-like" traversal and our discriminator tree data-structures. In the case of discriminator trees, the work of Helm, Marriott, and Odersky <ref> [HMO91] </ref> suggests that these structures might find application in visual language parsing. Their system currently uses Bentley's kd-Trees [Ben75] to store graphical elements for quick access according to bounding box ranges, but discriminator trees might provide it with the flexibility to search over more complicated attribute combinations.
Reference: [HMT + 89a] <author> Allan Heydon, Mark W. Maimone, J. D. Tygar, Jeannette M. Wing, and Amy Moormann Zaremski. </author> <title> Miro Tools. </title> <booktitle> In Proceedings of the 1989 IEEE Workshop on Visual Languages, </booktitle> <pages> pages 86-91, </pages> <address> Los Alamitos, CA, October 1989. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Central to our work is the design and implementation of efficient algorithms solving these problems. We describe a set of software tools we have developed as part of the Miro system <ref> [HMT + 89a] </ref>, including a visual language compiler. In conjunction with the visual languages themselves, these tools give users an easy way to specify and process security configurations and policies. The dissertation thus makes contributions to two different areas: visual languages and formal security specification. <p> The text file describing these system-specific parameters can be customized easily for new operating systems. We now describe how the various front-end tools are used. Users create and manipulate pictures for both languages with a graphical editor <ref> [HMT + 89a, Zar91] </ref>. The editor implements a 6 CHAPTER 1. <p> This phase of the compilation is relatively straightforward once the compiler has built the structure of the database internally. The back-end Miro tools are the file system prober (described in Chapter 6) and the verifier <ref> [HMT + 89a] </ref> 1 . Both back-end tools are built for the Unix operating system [RT74]. The file system prober searches a specified subtree of a Unix file system, and it creates an instance picture whose protection semantics correspond almost exactly to the access permissions realized by the file system. <p> Until such underpinnings are established, there is little hope for the creation of a universal visual language editor. Instead, visual language developers are forced to build customized editors. The Miro project has also taken this approach by building a direct-manipulation graphical editor for the instance and constraint languages <ref> [HMT + 89a] </ref>. Systems such as the Garnet user-interface development environment [Mye88, Mye89] facilitate such efforts. 3 Since constraint pictures are small, the issue of scale is not as important in the case of the constraint language. 162 CHAPTER 7.
Reference: [HMT + 89b] <author> Allan Heydon, Mark W. Maimone, J. D. Tygar, Jeannette M. Wing, and Amy Moormann Zaremski. </author> <title> Constraining Pictures with Pictures. </title> <booktitle> In Proceedings of the IFIP 11 th World Computer Congress, </booktitle> <pages> pages 157-162, </pages> <address> San Francisco, CA, </address> <month> August </month> <year> 1989. </year>
Reference-contexts: That work forms the basis of the Miro system, as described elsewhere in a series of papers <ref> [TW87, MTW90, HMT + 89b, HMT + 90] </ref>. This thesis builds on that research in several respects. First, it defines a new semantics for the instance language. Second, it describes a new, efficient algorithm for the ambiguity checker. Third, it develops an efficient algorithm for the constraint checker. <p> The constraint language provides a visual way to describe realizable and acceptable configurations by limiting the set of "legal" instance pictures. It was first described in a Miro paper <ref> [HMT + 89b] </ref>. This chapter presents the semantics more formally, and fills in some of the details omitted in that work. A picture drawn in the constraint language (henceforth called a constraint picture or simply a constraint) specifies a (possibly infinite) set of instance pictures.
Reference: [HMT + 90] <author> Allan Heydon, Mark W. Maimone, J. D. Tygar, Jeannette M. Wing, and Amy Moormann Zaremski. </author> <title> Miro: Visual Specification of Security. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(10) </volume> <pages> 1185-1197, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: That work forms the basis of the Miro system, as described elsewhere in a series of papers <ref> [TW87, MTW90, HMT + 89b, HMT + 90] </ref>. This thesis builds on that research in several respects. First, it defines a new semantics for the instance language. Second, it describes a new, efficient algorithm for the ambiguity checker. Third, it develops an efficient algorithm for the constraint checker. <p> We call the resulting semantics the criss-cross equality semantics, and we denote it by R = . This is actually the instance language semantics defined by the Miro group in its most recent publication <ref> [HMT + 90] </ref>. What effect do these changes have on the semantics in practice? Consider the instance picture of Figure 2.12. In this example, group1./ group2. <p> UNIX: A CASE STUDY 6.5 Constraint Picture Files In this section, we describe the constraints that we will use in Section 6.6 to evaluate the performance of the constraint checker. We have adapted some of these constraints from original constraints suggested in previous Miro papers <ref> [HMT + 90, HMT + 90] </ref>. The others were suggested in an article on Unix security by Grampp and Morris [GM84]; we have simply translated their written security suggestions into constraint pictures. 6.5.1 General Constraint Characteristics We start by stating some general characteristics of our constraints.
Reference: [HPSS87] <author> D. Harel, A. Pnueli, J. P. Schmidt, and R. Sherman. </author> <title> On the formal semantics of statecharts. </title> <booktitle> In Proc. 2 nd IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 54-64, </pages> <year> 1987. </year>
Reference-contexts: Note that since we expect constraint language pictures to be small, the issue of scalability is not as important in its case. These three properties drove us in our design. We benefited greatly from the influence of Harel's visual specification languages, statecharts <ref> [Har87, HPSS87] </ref> and higraphs [Har88]. Both of these languages are defined by a formal syntax and semantics. Our visual languages borrow many key elements from the higraph notation.
Reference: [HTI90] <author> M. Hirakawa, M. Tanaka, and T. Ichikawa. </author> <title> An Iconic Programming System, </title> <journal> HI-VISUAL. IEEE Transactions on Software Engineering, </journal> <volume> 16(10) </volume> <pages> 1178-1184, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: Significant efforts in this area are reported in a number of excellent collections [CIL86, Cha90c, Cha90b, Gli90a, Gli90b, IJK90, Shu88]. Many of these systems use icons to represent functional <ref> [AB89, Bor89, CGLT86, HTI90] </ref>, object oriented [Rog90], or control-flow [Gli86, KG88] models of program execution. A second distinction is that our system defines a precise semantics for every well-formed picture. In contrast, as Shu points out [Shu88], most visual programming languages described in the literature lack mathematical rigor.
Reference: [Hub88] <author> David H. Hubel. </author> <title> Eye, Brain, and Vision. </title> <publisher> Scientific American Library, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: Introduction Vision is a remarkable thing. Some scientists estimate that close to 90% of the cerebral cortex in the human brain is devoted to making sense of visual data <ref> [Hub88] </ref>. Given this evidence, it is natural to ask whether our innate visual processing ability can be exploited to make computers easier to use.
Reference: [IJK90] <author> Tadao Ichikawa, Erland Jungert, and Robert R. Korfhage, </author> <title> editors. Visual Languages and Applications. </title> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1990. </year> <note> 352 pgs. </note>
Reference-contexts: Finally, it reports on tools which implement these algorithms. Most other work in the field of visual languages differs from ours in that it addresses the domain of computer programming. Significant efforts in this area are reported in a number of excellent collections <ref> [CIL86, Cha90c, Cha90b, Gli90a, Gli90b, IJK90, Shu88] </ref>. Many of these systems use icons to represent functional [AB89, Bor89, CGLT86, HTI90], object oriented [Rog90], or control-flow [Gli86, KG88] models of program execution. A second distinction is that our system defines a precise semantics for every well-formed picture.
Reference: [Kan89] <author> Gerry Kane. </author> <title> MIPS RISC Architecture. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ 07632, </address> <year> 1989. </year>
Reference-contexts: All of our performance measurements were made on a DECstation 3100 (a PMAX) with 20 megabytes of main memory. This machine has the following general characteristics. It uses a MIPS R2000-A CPU <ref> [Kan89] </ref> running at approximately 17 MHz and rated at approximately 12 MIPS, or 12 times the speed of a VAX 11/780. Because the PMAX does not have DMA, its I/O performance is relatively poor | the maximum I/O bandwidth to disk is only 1.5 megabytes per second.
Reference: [Kem82] <author> Richard A. Kemmerer. </author> <title> Formal Verification of an Operating System Security Kernel. </title> <journal> Computer Science: Systems Programming, </journal> <volume> No. 2. </volume> <publisher> UMI Research Press, </publisher> <address> Ann Arbor, Michigan, </address> <year> 1982. </year> <note> BIBLIOGRAPHY 213 </note>
Reference-contexts: The instance language is designed to address this need. Its intuitive and concise nature makes it possible, even for non-experts, to manage the access rights on a large number of files Policy Specification Previous approaches to specifying security policies have assumed fixed policies <ref> [BL76, Kem82, NBF + 80] </ref>. Our constraint language, on the other hand, provides a flexible way to specify alternative security policies. That flexibility allows us to express a greater variety of security policies than previous policy specification languages. <p> Bell and LaPadula developed a formal model for a secure system based on finite state machines [BL76], and others have built off this work [McC90, McL90]. There have been at least two extensive efforts to specify, verify, and implement a secure operating system <ref> [Kem82, NBF + 80] </ref>. Rabin and Tygar also use text-based methods to specify access control in their security toolkit [RT87]. All of these researchers have based their specification languages in logic, so the specifications are amenable to automatic theorem provers. However, the formal nature of these specifications 10 CHAPTER 1.
Reference: [KG88] <author> Mark E. Kopache and Ephraim P. Glinert. </author> <title> C 2 : A Mixed Textual/Graphical Environment for C. </title> <booktitle> In Proceedings of the 1988 IEEE Workshop on Visual Languages, </booktitle> <pages> pages 231-238, </pages> <address> Los Alamitos, CA, October 1988. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Significant efforts in this area are reported in a number of excellent collections [CIL86, Cha90c, Cha90b, Gli90a, Gli90b, IJK90, Shu88]. Many of these systems use icons to represent functional [AB89, Bor89, CGLT86, HTI90], object oriented [Rog90], or control-flow <ref> [Gli86, KG88] </ref> models of program execution. A second distinction is that our system defines a precise semantics for every well-formed picture. In contrast, as Shu points out [Shu88], most visual programming languages described in the literature lack mathematical rigor.
Reference: [KNR88] <author> Sampath Kannan, Moni Naor, and Steve Rudich. </author> <title> Implicit Representation of Graphs. </title> <booktitle> In Proc. 20 th ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 334-343, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: In the special case where the containment DAG is a tree, it is possible to spend O (n) preprocessing time doing a preorder traversal of the tree such that ancestorship can be decided in O (1) time using only O (n log n) space <ref> [KNR88] </ref>. Unfortunately, this technique does not generalize to arbitrary DAGs. However, there are at least two alternative ways to implement the ancestorship test: 1. The first approach is to compute the transitive closure of the containment DAG.
Reference: [KR78] <author> Brian W. Kernighan and Dennis M. Ritchie. </author> <title> The C Programming Language. </title> <publisher> Prentice-Hall, Inc., </publisher> <year> 1978. </year>
Reference-contexts: By these arguments, we have formally shown that R p (u; f ) = W p (u; f ). We have also argued informally that the algorithm correctly implements the computation of R p (u; f ). 3.4.4 Implementation Our implementation, written in C <ref> [KR78] </ref>, is a program called ambig. It follows the previous description faithfully, but it also includes several optimizations. We first describe how various features of the algorithm are implemented. We then describe the optimizations that have been included in the implementation.
Reference: [Lam71] <author> B. W. Lampson. </author> <title> Protection. </title> <booktitle> In Proceedings Fifth Annual Princeton Conference on Information Science Systems, </booktitle> <pages> pages 437-443, </pages> <year> 1971. </year> <journal> Reprinted in ACM Operating Systems Review, </journal> <volume> Volume 8, Number 1, </volume> <month> (January </month> <year> 1974), </year> <pages> pages 18-24. </pages>
Reference-contexts: Boxes represent users and files; they also group users and files to form a hierarchy. Arrows are either positive or negative; they denote the granting or the denial of access rights, respectively. The semantics of an instance picture is a Lampson access matrix <ref> [Lam71] </ref>, which specifies for every user and file whether access for that user on that file is granted or denied for each access permission. We give a detailed description of the syntax and formal semantics of the instance language in Chapter 2. <p> For all of these reasons, aliases should be used cautiously. 2.2 Semantics The instance language semantics defines a total mapping from well-formed instance pictures to some mathematical "meaning structure". The structure we use is a Lampson access matrix <ref> [Lam71] </ref>. One axis of this matrix is labeled with user names, while the second axis is labeled with file names. Each entry in the matrix is a (possibly empty) set of access permissions.
Reference: [LP81] <author> Harry R. Lewis and Christos H. Papadimitriou. </author> <title> Elements of the Theory of Computation. </title> <booktitle> Prentice-Hall Software Series. </booktitle> <publisher> Prentice-Hall, Inc., </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1981. </year>
Reference-contexts: For example, constraint pictures for Unix would be quite different from those describing the Bell-LaPadula model or Carnegie Mellon's Andrew File System [SHN + 85]. Each constraint picture can be thought of as a pattern for instance pictures, just as a regular expression <ref> [LP81] </ref> is a pattern for character strings. When viewed in that sense, the constraint 65 66 CHAPTER 4.
Reference: [LV89] <author> Mark Linton and John Vlissides. Idraw, </author> <year> 1989. </year> <institution> Computer Program. </institution>
Reference-contexts: By a "smart" graphical editor, we mean a tool that does more than MacDraw and its spinoffs <ref> [Cor88, LV89] </ref>, which provide direct manipulation capabilities on graphical objects. It must also encompass design rules built into the instance language, such as those listed in Table 2.3. For example, when the user drags a box with the mouse, the arrows attached to the box must move as well. <p> The panning mechanism may be provided in the form of scroll-bars, as in MacDraw II [Cor88], or in the form of a "panner gadget", as provided by Idraw <ref> [LV89] </ref>. The current version of the Miro editor supports several of these features.
Reference: [McC90] <author> Daryl McCullough. </author> <title> A Hookup Theorem for Multilevel Security. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(6) </volume> <pages> 563-568, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: As we stated previously, most of the previous work in security specification is text-based. Bell and LaPadula developed a formal model for a secure system based on finite state machines [BL76], and others have built off this work <ref> [McC90, McL90] </ref>. There have been at least two extensive efforts to specify, verify, and implement a secure operating system [Kem82, NBF + 80]. Rabin and Tygar also use text-based methods to specify access control in their security toolkit [RT87].
Reference: [McL85] <author> John McLean. </author> <title> A Comment on the "Basic Security Theorem" of Bell and LaPadula. </title> <journal> Information Processing Letters, </journal> <volume> 20 </volume> <pages> 67-70, </pages> <year> 1985. </year>
Reference-contexts: However, the formal nature of these specifications 10 CHAPTER 1. INTRODUCTION does not lead to absolute security. For example, McLean has shown that the "Basic Security Theorem" of Bell and LaPadula can be adapted to apply to systems that are blatantly insecure <ref> [McL85] </ref>. 2 Benzel describes the verification of a "secure" operating system kernel in which more covert channels were found by hand than by formal means [Ben84]. Our hope is that by using a visual notation, security specifications can be made less error-prone.
Reference: [McL90] <author> John McLean. </author> <title> The Specification and Modeling of Computer Security. </title> <journal> IEEE Computer, </journal> <volume> 23(1) </volume> <pages> 9-16, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: As we stated previously, most of the previous work in security specification is text-based. Bell and LaPadula developed a formal model for a secure system based on finite state machines [BL76], and others have built off this work <ref> [McC90, McL90] </ref>. There have been at least two extensive efforts to specify, verify, and implement a secure operating system [Kem82, NBF + 80]. Rabin and Tygar also use text-based methods to specify access control in their security toolkit [RT87].
Reference: [MS91] <author> Jonathan D. Moffett and Morris S. Sloman. </author> <title> Delegation of Authority. </title> <booktitle> In Second IFIP International Symposium on Integrated Network Management, </booktitle> <pages> pages 595-606. </pages> <publisher> North Holland, </publisher> <month> May </month> <year> 1991. </year>
Reference-contexts: Also, Moffett, Sloman, and Twidle use informal diagrams to illustrate a means for specifying access control and the delegation of the authority to change access rules <ref> [MST90, MS91] </ref>, but they do not give a precise semantics for, or implementation of, the security system described in their work. 1.4 Thesis Outline The remainder of the thesis is organized as follows. <p> another visual "meta-language" be developed for specifying how configurations and policies are allowed to change, and who exactly has the authority to make those changes? We might also investigate visual languages for specifying how authority to change security properties is delegated, analogous to the rule-based specifications of Moffett and Sloman <ref> [MS91] </ref>. 9 If we change the constraint itself, we simply recompile the constraint, an operation taking only seconds, and install that new constraint in the server. 172 CHAPTER 7.
Reference: [MST90] <author> Jonathan Moffett, Morris Sloman, and Kevin Twidle. </author> <title> Specifying Discretionary Access Control Policy for Distributed Systems. </title> <journal> Computer Communications, </journal> <volume> 13(9) </volume> <pages> 571-580, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: Also, Moffett, Sloman, and Twidle use informal diagrams to illustrate a means for specifying access control and the delegation of the authority to change access rules <ref> [MST90, MS91] </ref>, but they do not give a precise semantics for, or implementation of, the security system described in their work. 1.4 Thesis Outline The remainder of the thesis is organized as follows.
Reference: [MTW90] <author> Mark W. Maimone, J. D. Tygar, and Jeannette M. Wing. </author> <title> Formal Semantics for Visual Specification of Security. In S.K. Chang, editor, Visual Languages and Visual Programming. </title> <publisher> Plenum Publishing Corporation, </publisher> <year> 1990. </year> <note> A preliminary version of this paper appeared in Proceedings of the 1988 IEEE Workshop on Visual Languages, </note> <month> October, </month> <year> 1988, </year> <month> pages 45-51. </month> <title> This paper contains mistakes in the definitions of inside and ./. The definitions should read: inside(x) = fbjb 2 BOXES ^ b 6= x ^ members(b) members(x)g and x./y = (x = y _ x 2 crisscrosses(y)). 214 BIBLIOGRAPHY </title>
Reference-contexts: That work forms the basis of the Miro system, as described elsewhere in a series of papers <ref> [TW87, MTW90, HMT + 89b, HMT + 90] </ref>. This thesis builds on that research in several respects. First, it defines a new semantics for the instance language. Second, it describes a new, efficient algorithm for the ambiguity checker. Third, it develops an efficient algorithm for the constraint checker. <p> This definition captures the intuition gleaned from the examples we have considered, including the ambiguous cases. Our presentation borrows heavily from the original instance language semantics <ref> [MTW90] </ref>, but it also differs in substantial ways. For one thing, our presentation defines the semantics at a high level in terms of arrows rather than boxes. Second, we present a semantics that differs substantially from the original semantics. We describe the details of the differences in Section 2.3.3. <p> In this section, we describe some alternative definitions, evaluating their merits relative to the semantics R. We also relate these definitions to the semantics previously defined in the literature <ref> [MTW90] </ref>. We note briefly that all of the alternatives we consider are based solely on topological relations between graphical elements in the instance picture. A broad class of semantics suggest themselves if we were to also consider spatial relationships between elements. <p> That is, the semantics R 1; = is defined by Equation (2.4) using o in place of o. This semantics was the very first one defined for the instance language in the previous Miro work <ref> [MTW90] </ref>. To make the distinctions between these four semantics clear, we give names to the two alternatives in each dimension.
Reference: [Mye88] <author> Brad A. Myers. </author> <title> The Garnet User Interface Development Environment: A Proposal. </title> <type> Technical Report CMU-CS-88-153, </type> <institution> Carnegie Mellon University, School of Computer Science, </institution> <address> 5000 Forbes Ave., Pittsburgh, PA 15213-3890, </address> <month> September </month> <year> 1988. </year>
Reference-contexts: Instead, visual language developers are forced to build customized editors. The Miro project has also taken this approach by building a direct-manipulation graphical editor for the instance and constraint languages [HMT + 89a]. Systems such as the Garnet user-interface development environment <ref> [Mye88, Mye89] </ref> facilitate such efforts. 3 Since constraint pictures are small, the issue of scale is not as important in the case of the constraint language. 162 CHAPTER 7.
Reference: [Mye89] <author> Brad A. Myers et. al. </author> <title> The Garnet Toolkit Reference Manuals: Support for Highly-Interactive, Graphical User Interfaces in Lisp. </title> <type> Technical Report CMU-CS-89-196, </type> <institution> Carnegie Mellon University, School of Computer Science, </institution> <address> 5000 Forbes Ave., Pittsburgh, PA 15213-3890, </address> <month> November </month> <year> 1989. </year>
Reference-contexts: Instead, visual language developers are forced to build customized editors. The Miro project has also taken this approach by building a direct-manipulation graphical editor for the instance and constraint languages [HMT + 89a]. Systems such as the Garnet user-interface development environment <ref> [Mye88, Mye89] </ref> facilitate such efforts. 3 Since constraint pictures are small, the issue of scale is not as important in the case of the constraint language. 162 CHAPTER 7.
Reference: [NBF + 80] <author> P. G. Neumann, R. S. Boyer, R. J. Feiertag, K. N. Levitt, and L. Robinson. </author> <title> A Provably Secure Operating System: The System, Its Applications, and Proofs, Second Edition. </title> <type> Technical Report CSL-116, </type> <institution> SRI, </institution> <month> May </month> <year> 1980. </year>
Reference-contexts: The instance language is designed to address this need. Its intuitive and concise nature makes it possible, even for non-experts, to manage the access rights on a large number of files Policy Specification Previous approaches to specifying security policies have assumed fixed policies <ref> [BL76, Kem82, NBF + 80] </ref>. Our constraint language, on the other hand, provides a flexible way to specify alternative security policies. That flexibility allows us to express a greater variety of security policies than previous policy specification languages. <p> Bell and LaPadula developed a formal model for a secure system based on finite state machines [BL76], and others have built off this work [McC90, McL90]. There have been at least two extensive efforts to specify, verify, and implement a secure operating system <ref> [Kem82, NBF + 80] </ref>. Rabin and Tygar also use text-based methods to specify access control in their security toolkit [RT87]. All of these researchers have based their specification languages in logic, so the specifications are amenable to automatic theorem provers. However, the formal nature of these specifications 10 CHAPTER 1.
Reference: [Nel85] <author> Greg Nelson. Juno, </author> <title> a Constraint-Based Graphics System. </title> <booktitle> ACM Proceedings on Computer Graphics (SIGGRAPH), </booktitle> <volume> 19(3) </volume> <pages> 235-243, </pages> <address> July 1985. San Francisco. </address>
Reference-contexts: This last point brings up another advantage to the visual notation: it alleviates the user from the burden of naming objects. As has been pointed out elsewhere <ref> [Nel85] </ref>, one of the nice features of a visual interface is that it makes names unnecessary: the user need only point at an object with the mouse to refer to it.
Reference: [Rog90] <author> Gregory Scott Rogers. </author> <title> Visual Programming Using Graphics, Relations, and Classes. </title> <type> PhD thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <month> October </month> <year> 1990. </year> <note> Report No. UIUCDCS-R-90-1632. </note>
Reference-contexts: Significant efforts in this area are reported in a number of excellent collections [CIL86, Cha90c, Cha90b, Gli90a, Gli90b, IJK90, Shu88]. Many of these systems use icons to represent functional [AB89, Bor89, CGLT86, HTI90], object oriented <ref> [Rog90] </ref>, or control-flow [Gli86, KG88] models of program execution. A second distinction is that our system defines a precise semantics for every well-formed picture. In contrast, as Shu points out [Shu88], most visual programming languages described in the literature lack mathematical rigor.
Reference: [RT74] <author> D. M. Ritchie and K. Thompson. </author> <title> The UNIX Time-Sharing System. </title> <journal> Communications of the ACM, </journal> <volume> 17(7) </volume> <pages> 365-375, </pages> <month> July </month> <year> 1974. </year>
Reference-contexts: The back-end Miro tools are the file system prober (described in Chapter 6) and the verifier [HMT + 89a] 1 . Both back-end tools are built for the Unix operating system <ref> [RT74] </ref>. The file system prober searches a specified subtree of a Unix file system, and it creates an instance picture whose protection semantics correspond almost exactly to the access permissions realized by the file system. There are, of course, many possible pictures the prober could produce. <p> In particular, we describe the performance of our ambiguity checker and constraint checker tools on pictures representing real Unix file systems and security policies for Unix <ref> [RT74] </ref>. In Chapter 3, we gave asymptotic and expected running times for the ambiguity checker. We found there that the checker is expected to require O (fffi) time and O (ff log fi) space, where ff and fi are the number of subjects and objects, respectively.
Reference: [RT87] <author> M. Rabin and J. D. Tygar. </author> <title> An Integrated Toolkit for Operating System Security. </title> <type> Technical Report TR-05-87, </type> <institution> Aiken Computation Laboratory, Harvard University, </institution> <month> May </month> <year> 1987. </year>
Reference-contexts: That flexibility allows us to express a greater variety of security policies than previous policy specification languages. Configuration Existing security tools giving systems administrators the power to implement a variety of security models on their systems, such as the Integrated Toolkit for Operating System Security (ITOSS) <ref> [RT87] </ref>, lack an easy means for specifying the particular security system they should model. The constraint language can thus be used to configure such existing security systems. 1.2. <p> There have been at least two extensive efforts to specify, verify, and implement a secure operating system [Kem82, NBF + 80]. Rabin and Tygar also use text-based methods to specify access control in their security toolkit <ref> [RT87] </ref>. All of these researchers have based their specification languages in logic, so the specifications are amenable to automatic theorem provers. However, the formal nature of these specifications 10 CHAPTER 1. INTRODUCTION does not lead to absolute security. <p> example, in Unix, a configuration in which one group of users has permission to read a file and a second group of users has permission to write that file cannot be realized (unless one group is either the set of all users or the singleton set of the file's owner) <ref> [RT87] </ref>. Other access matrices must be disallowed because they violate a specific security policy.
Reference: [RWIG90] <author> R. V. Rubin, J. Walker II, and E. J. Golin. </author> <title> Early Experience with the Visual Programmer's Workbench. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(10) </volume> <pages> 1107-1121, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: A second distinction is that our system defines a precise semantics for every well-formed picture. In contrast, as Shu points out [Shu88], most visual programming languages described in the literature lack mathematical rigor. Other researchers | most notably Chang et al [Cha88, CTYY89] and Golin, Rubin, and Walker <ref> [GR89, RWIG90] </ref> | have addressed the problem of building visual language compilers. Our compiler differs from these systems in two ways. First, their research is more concerned with developing general visual language parsers, whereas our compiler reads pictures that explicitly represent topological relations between graphical elements. <p> However, this representation lacks essential topological relations between elements such as the arrow connections and the containment relations among boxes. Although general visual language grammars and parsers for extracting such topological relations have been designed and implemented <ref> [CTYY89, Cha90a, CC90, Gol90, GR89, RWIG90] </ref>, they are unnecessary in this case. We therefore assume that an instance picture is represented by entries containing descriptions of box and arrow graphical elements. <p> The grammars describing the syntax of the "target" visual language use textual predicates to describe constraints on terminal and non-terminal symbols in the grammar <ref> [FZ89, HMO91, RWIG90] </ref>.
Reference: [SHN + 85] <author> M. Satyanarayan, J. Howard, D. Nichols, R. Sidebotham, A. Spector, and M. West. </author> <title> The ITC Distributed File System: </title> <booktitle> Principles and Design. In Tenth Symposium on Operating Systems, </booktitle> <pages> pages 35-50, </pages> <year> 1985. </year>
Reference-contexts: Naturally, policies will vary from one operating system to another. For example, constraint pictures for Unix would be quite different from those describing the Bell-LaPadula model or Carnegie Mellon's Andrew File System <ref> [SHN + 85] </ref>. Each constraint picture can be thought of as a pattern for instance pictures, just as a regular expression [LP81] is a pattern for character strings. When viewed in that sense, the constraint 65 66 CHAPTER 4.
Reference: [Shu88] <author> Nan C. Shu. </author> <title> Visual Programming. </title> <publisher> Van Nostrand Reinhold, </publisher> <address> New York, </address> <year> 1988. </year> <note> 315 pgs. </note>
Reference-contexts: Finally, it reports on tools which implement these algorithms. Most other work in the field of visual languages differs from ours in that it addresses the domain of computer programming. Significant efforts in this area are reported in a number of excellent collections <ref> [CIL86, Cha90c, Cha90b, Gli90a, Gli90b, IJK90, Shu88] </ref>. Many of these systems use icons to represent functional [AB89, Bor89, CGLT86, HTI90], object oriented [Rog90], or control-flow [Gli86, KG88] models of program execution. A second distinction is that our system defines a precise semantics for every well-formed picture. <p> Many of these systems use icons to represent functional [AB89, Bor89, CGLT86, HTI90], object oriented [Rog90], or control-flow [Gli86, KG88] models of program execution. A second distinction is that our system defines a precise semantics for every well-formed picture. In contrast, as Shu points out <ref> [Shu88] </ref>, most visual programming languages described in the literature lack mathematical rigor. Other researchers | most notably Chang et al [Cha88, CTYY89] and Golin, Rubin, and Walker [GR89, RWIG90] | have addressed the problem of building visual language compilers. Our compiler differs from these systems in two ways.
Reference: [Ste90] <author> Guy L. Steele Jr. </author> <title> Common Lisp: The Language. </title> <note> Digital Press, second edition, </note> <year> 1990. </year>
Reference-contexts: The architecture shown in Figure 5.2 on page 87 suggests that the IPQL is a new language, and that the IPQL engine is an interpreter for that language. In truth, our prototype version of the IPQL instead uses the Common Lisp <ref> [Ste90] </ref> interpreter as the IPQL engine, and the IPQL itself is implemented simply as a set of Common Lisp function, macro, and type definitions. Thus, the compiler has the full Common Lisp language at its disposal when it generates "object" code.
Reference: [Str86] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <booktitle> The Addison-Wesley Series in Computer Science. </booktitle> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Menlo Park, CA, </address> <year> 1986. </year> <note> BIBLIOGRAPHY 215 </note>
Reference-contexts: Thus, the compiler has the full Common Lisp language at its disposal when it generates "object" code. The choice of Common Lisp over more efficient object-oriented languages such as C++ <ref> [Str86] </ref> is debatable. Common Lisp was more convenient for our purposes, but it is less efficient. The IPQL uses an object-oriented extension to Allegro Common Lisp. 5 What this means is that abstract data types like discriminator trees and iterators over portions of those trees are first class objects.
Reference: [Tar83] <author> Robert Endre Tarjan. </author> <title> Data Structures and Network Algorithms. </title> <institution> Society for Industrial and Applied Mathematics, </institution> <address> Philadelphia, Pennsylvania, </address> <year> 1983. </year>
Reference-contexts: These definitions can be found in many standard algorithms texts, e.g., [GJ79] and <ref> [Tar83] </ref>. Definition 9 (Subgraph, Induced Subgraph) Let G = (V; E) be a graph. Then G 0 = (V 0 ; E 0 ) is a subgraph of G, written G 0 G, if V 0 V and E 0 E.
Reference: [TR87] <author> Avadis Tevanian Jr. and Richard F. Rashid. </author> <title> MACH: A Basis for Future UNIX Development. </title> <type> Technical Report CMU-CS-87-139, </type> <institution> Carnegie Mellon University, School of Computer Science, </institution> <address> 5000 Forbes Ave., Pittsburgh, PA 15213-3890, </address> <year> 1987. </year>
Reference-contexts: Our PMAX was running a recent (as of October, 1991) version of the Mach 2.5 operating system kernel. Mach is an operating system developed at Carnegie Mellon University <ref> [TR87] </ref>. It is fully compatible with the Unix operating system in the sense that any Unix binary can run without modification under Mach. Moreover, Mach has the ability to simultaneously support multiple file systems, and in particular, it can support Unix file systems.
Reference: [TW87] <author> J. D. Tygar and J. M. Wing. </author> <title> Visual Specification of Security Constraints. </title> <booktitle> In Proceedings of the 1987 IEEE Workshop on Visual Languages, </booktitle> <address> Los Alamitos, CA, August 1987. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: That work forms the basis of the Miro system, as described elsewhere in a series of papers <ref> [TW87, MTW90, HMT + 89b, HMT + 90] </ref>. This thesis builds on that research in several respects. First, it defines a new semantics for the instance language. Second, it describes a new, efficient algorithm for the ambiguity checker. Third, it develops an efficient algorithm for the constraint checker.
Reference: [Ull82] <author> Jeffrey D. Ullman. </author> <booktitle> Principles of Database Systems. Computer Software Engineering Series. </booktitle> <publisher> Computer Science Press, </publisher> <address> Rockville, Maryland, </address> <note> second edition, </note> <year> 1982. </year>
Reference-contexts: In this framework, the process of checking a constraint is simply the process of performing a certain kind of query against a special kind of database. We can extend the analogy further. A typical database management system (DBMS) has several components <ref> [Ull82] </ref>. The structure of the database is specified by a database administrator in some data definition language (DDL). Constructs in a data manipulation language (DML) are then used to insert and remove data from the database.
Reference: [War62] <author> S. Warshall. </author> <title> A Theorem on Boolean Matrices. </title> <journal> Journal of the ACM, </journal> <volume> 9(1) </volume> <pages> 11-12, </pages> <year> 1962. </year>
Reference-contexts: The first approach is to compute the transitive closure of the containment DAG. This technique requires O time and O space to precompute and store the transitive closure in a matrix. These time and space bounds are achieved using a well-known dynamic programming algorithm developed by Warshall <ref> [War62] </ref>. The matrix allows us to decide if b OE b 0 in O (1) time. Unfortunately, the prohibitive space costs of this algorithm make it impractical. Since we require separate matrices for subjects and objects, a more accurate representation of the space cost is O .
Reference: [WK85] <author> Patrick H. Wood and Stephen G. Kochan. </author> <title> UNIX System Security. </title> <publisher> Hayden Books, </publisher> <address> Indianapolis, Indiana, </address> <year> 1985. </year>
Reference-contexts: The best, although informal, descriptions are in the intro entry of section 2 of the Unix user's manual and in a book devoted to Unix security <ref> [WK85] </ref>. At the very least, Appendix D serves as a formal description of the Unix access protection semantics. 6.2 The Experiment In this section, we describe the detailed conditions under which the experiments described in subsequent sections were performed. <p> As we mentioned in that section, these semantics are defined only informally in the Unix man pages and a book on Unix security <ref> [WK85] </ref>. It is important to distinguish between the protection semantics implemented by the Unix kernel, and the security policy specification mechanism supported by the constraint language.
Reference: [Zar91] <author> Amy Moormann Zaremski. </author> <title> A Larch Specification of the Miro Editor. </title> <type> Technical Report CMU-CS-91-111, </type> <institution> Carnegie Mellon University, School of Computer Science, </institution> <address> 5000 Forbes Ave., Pittsburgh, PA 15213-3890, </address> <month> February </month> <year> 1991. </year>
Reference-contexts: The text file describing these system-specific parameters can be customized easily for new operating systems. We now describe how the various front-end tools are used. Users create and manipulate pictures for both languages with a graphical editor <ref> [HMT + 89a, Zar91] </ref>. The editor implements a 6 CHAPTER 1.
References-found: 75

