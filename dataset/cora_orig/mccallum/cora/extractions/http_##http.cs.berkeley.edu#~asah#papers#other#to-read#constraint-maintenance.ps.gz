URL: http://http.cs.berkeley.edu/~asah/papers/other/to-read/constraint-maintenance.ps.gz
Refering-URL: http://http.cs.berkeley.edu/~asah/papers/other/to-read/
Root-URL: http://www.cs.berkeley.edu
Email: ceri@cs.stanford.edu, widom@ibm.com  
Title: Deriving Production Rules for Constraint Maintenance  
Author: Stefano Ceri Jennifer Widom 
Address: 650 Harry Road San Jose, CA 95120  
Affiliation: IBM Almaden Research Center  
Note: Proc. of 1990 VLDB Conference, pages 566-577  
Abstract: Traditionally, integrity constraints in database systems are maintained either by rolling back any transaction that produces an inconsistent state or by disallowing or modifying operations that may produce an inconsistent state. An alternative approach is to provide automatic "repair" of inconsistent states using production rules. For each constraint, a production rule is used to detect constraint violation and to initiate database operations that restore consistency. We describe an SQL-based language for defining integrity constraints and a framework for translating these constraints into constraint-maintaining production rules. Some parts of the translation are automatic while other parts require user intervention. Based on the semantics of our set-oriented production rules language and under certain assumptions, we prove that at the end of each transaction the rules are guaranteed to produce a state satisfying all defined constraints. We apply our approach to a good-sized example. 
Abstract-found: 1
Intro-found: 1
Reference: [ASU86] <author> A.V. Aho, R. Sethi, and J.D. Ullman. </author> <booktitle> Compilers: principles, techniques, and tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: We provide a rigorous description of the labeling process using an attribute grammar|a formalism specifically designed for defining how labels (attributes) are assigned to the nodes of a parse tree <ref> [ASU86] </ref>.
Reference: [BBC80] <author> P.A. Bernstein, </author> <title> B.T. Blaustein, and E.M. Clarke. Fast maintenance of semantic integrity assertions using redundant aggregate data. </title> <booktitle> In Proc. of Sixth VLDB, </booktitle> <pages> pages 126-136, </pages> <month> October </month> <year> 1980. </year>
Reference: [CG88] <author> S. Ceri and F. Garzotto. </author> <title> Specification and management of database integrity constraints through logic programming. </title> <type> Technical Report 88-025, </type> <institution> Dip. di Elettronica, Politecnico di Mi-lano, </institution> <year> 1988. </year>
Reference-contexts: Constraints are represented using Horn logic (again permitting only a subset of arbitrary predicates). Constraint analysis reveals the effects of constraints on object manipulation, determines possible constraint violations, and suggests propagation actions for correcting violations. Several other papers also extend the standard approaches to constraint definition and enforcement. In <ref> [CG88] </ref>, logic programming is used to express and evaluate constraints. At run-time, a given transaction can be checked to verify that it will maintain consistency with respect to a set of constraints. If consistency is not guaranteed, the system can explain which constraints are violated and can suggest compensating actions.
Reference: [CTF88] <author> M.A. Casanova, L. Tucherman, and A.L. Fur-tado. </author> <title> Enforcing inclusion dependencies and referential integrity. </title> <booktitle> In Proc. of Fourteenth VLDB, </booktitle> <pages> pages 38-49, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: In our approach, inconsistent states may occur and are detected, but consistency is restored by issuing corrective actions that depend on the particular constraint violation. Approaches similar to ours are taken in <ref> [CTF88, Mor84, UD90, UD91] </ref>, but in restricted settings. In [CTF88], only referential integrity and inclusion dependency constraints are considered. The user may define compensating actions (drawn from a restricted set) to be executed when constraints are violated. <p> In our approach, inconsistent states may occur and are detected, but consistency is restored by issuing corrective actions that depend on the particular constraint violation. Approaches similar to ours are taken in [CTF88, Mor84, UD90, UD91], but in restricted settings. In <ref> [CTF88] </ref>, only referential integrity and inclusion dependency constraints are considered. The user may define compensating actions (drawn from a restricted set) to be executed when constraints are violated. In [Mor84], the focus is on a very high-level language for expressing inter-relational constraints.
Reference: [CW90] <author> S. Ceri and J. Widom. </author> <title> Deriving production rules for constraint maintenance. </title> <institution> IBM Research Report RJ7348, IBM Almaden Research Center, </institution> <month> March </month> <year> 1990. </year>
Reference-contexts: Study Examples throughout the paper are drawn from a case study concerning a Power Distribution Design System, a database application supporting the design and maintenance of electricity networks. 2 Due to space limitations, only portions of the study are included in this paper; all details appear in the technical report <ref> [CW90] </ref>. Note that many of the constraints considered in the study cannot be supported in conventional database systems. Briefly, a power network connects a collection of plants to a collection of users, possibly through intermediate nodes. The network designer determines the location of plants, nodes, and users. <p> The core of the language is a variation on the usual SQL syntax for predicates, similar to that used in the if clause of our production rules [WF90]. Several advanced features are included, such as boolean types, tuple constructors, and user-defined functions. In <ref> [CW90] </ref>, we also include table expressions (as described with respect to the Star-burst database system in [HFLP89]); space considerations have forced their omission here. In the grammar's productions, we use T i to denote table names, V i to denote table variable names, and C i to denote column names. <p> Note that a given constraint may be expressed in several different ways. We would like our algorithm to produce the same set of invalidating operations for any two equivalent constraints. In the technical report <ref> [CW90] </ref>, we discuss several classes of equivalence, showing that our algorithm does produce equivalent invalidating operations. 4.2 Examples Consider again the constraint "each wire's voltage does not exceed the maximum for its wire type": wire: voltage &gt; any (select max-voltage from wire-type where type = wire.type) The columns appearing in the <p> Other, more complex, labeling optimizations are also possible|there is certainly room for future work here. (For further discussion, see <ref> [CW90] </ref>.) 4.4 Rule Templates and Constraint-Maintaining Rules Once the set of invalidating operations is generated for a given constraint, the system can produce a rule template. The rule components that are completed automatically in the template are the transition predicate and the condition (recall Section 2.2). <p> All cycles except two are clearly not relevant. It is interesting to note, however, that for the two cases in which infinite triggering is possible, this fact was revealed only by formal analysis|we were unaware of the problem in our initial definition of the rules. (See <ref> [CW90] </ref> for details.) 7 We may want to extend our facility to allow multiple rules enforcing a given constraint. This accommodates the possibility that different compensating actions may be appropriate for different invalidating operations. We plan to incorporate this extension. More sophisticated rule analysis is certainly possible. <p> For the optimization, we consider the tables from C's table list, transforming references to these tables appearing in R's condition into references to appropriate transition tables. Here, we consider the case in which the table list contains one table; the generalization to multiple tables is straightforward and appears in <ref> [CW90] </ref>. Consider a rule R derived from a constraint with one table t in its table list. <p> Improvement may also be gained in the rule's action, since references to logical table T inherit the optimization. Correctness of the transformation is proven formally in <ref> [CW90] </ref>. <p> The details are not particularly interesting and therefore are omitted. 9 Invalidating operations on table wire-type have been omitted since, in the case study, this table is considered read-only <ref> [CW90] </ref>. rule analysis, and optimization all are performed prior to system execution. Although execution time is not the focus of our study, we still must ensure that derived rules will behave as desired|that consistency with respect to all constraints is guaranteed. <p> Again, consider an arbitrary initial transition and subsequent rule execution. Since we assume that each transaction begins in a consistent state (the constraint-maintaining rules ensure this for all but some "first" transaction|see <ref> [CW90] </ref> for details), any rollback action trivially guarantees correctness. Thus, assume no rollback action is executed. We again use a sequence model of system execution. In this case, we need not include triggering information, but we do need to include all rules evaluated, not just those whose actions are executed.
Reference: [DE89] <author> L.M.L. Delcambre and J.N. Etheredge. </author> <title> The Relational Production Language: A production language for relational databases. </title> <booktitle> In Expert Database Systems|Proc. from the Second Int. Conference, </booktitle> <pages> pages 333-351. </pages> <address> Ben-jamin/Cummings, </address> <year> 1989. </year>
Reference-contexts: We then provide a framework for translating constraint specifications into production rules that maintain the constraints. Production rules in database systems allow specification of data manipulation operations that are automatically executed whenever certain events occur and/or certain conditions are met <ref> [DE89, Han89,KdMS90,SJGP90,WF90] </ref>. The usefulness of incorporating production rules into database systems is well accepted [EC75,MD89,Mor83], particularly in the context of constraint enforcement. However, we know of no automatic (or semi-automatic) method for specifying general constraints in a high-level, non-procedural language, then deriving lower-level production rules that maintain the constraints.
Reference: [EC75] <author> K.P. Eswaran and D.D. Chamberlin. </author> <title> Functional specifications of a subsystem for data base integrity. </title> <booktitle> In Proc. of First VLDB, </booktitle> <pages> pages 48-67, </pages> <month> September </month> <year> 1975. </year>
Reference: [Han89] <author> E.N. Hanson. </author> <title> An initial report on the design of Ariel: A DBMS with an integrated production rule system. </title> <booktitle> SIGMOD Record, </booktitle> <volume> 18(3) </volume> <pages> 12-19, </pages> <month> September </month> <year> 1989. </year>
Reference: [HFLP89] <author> L.M. Haas, J.C. Freytag, G.M. Lohman, and H. Pirahesh. </author> <title> Extensible query processing in Star-burst. </title> <booktitle> In Proc. of ACM-SIGMOD, </booktitle> <pages> pages 377-388, </pages> <month> May </month> <year> 1989. </year>
Reference-contexts: However, we know of no automatic (or semi-automatic) method for specifying general constraints in a high-level, non-procedural language, then deriving lower-level production rules that maintain the constraints. We describe such a method. The constraint and rule languages we use are based on an extended version of SQL <ref> [HFLP89, IBM88] </ref>, although our work could easily be adapted for alternate languages. <p> Several advanced features are included, such as boolean types, tuple constructors, and user-defined functions. In [CW90], we also include table expressions (as described with respect to the Star-burst database system in <ref> [HFLP89] </ref>); space considerations have forced their omission here. In the grammar's productions, we use T i to denote table names, V i to denote table variable names, and C i to denote column names. Repetition is represented explicitly by enumerating n terms (n &gt; 0).
Reference: [HI85] <author> A. Hsu and T. Imielinski. </author> <title> Integrity checking for multiple updates. </title> <booktitle> In Proc. of ACM-SIGMOD, </booktitle> <pages> pages 152-168, </pages> <month> May </month> <year> 1985. </year>
Reference: [HMN84] <author> L.J. Henschen, W.W. McCune, and S.A. Naqvi. </author> <title> Compiling constraint-checking programs from first-order formulas. </title> <booktitle> In Advances in Database Theory, </booktitle> <volume> Volume 2, </volume> <pages> pages 145-169. </pages> <publisher> Plenum Press, </publisher> <year> 1984. </year>
Reference: [IBM88] <author> IBM Form Number SC26-4348-1. </author> <title> IBM Systems Application Architecture, Common Programming Interface: Data-base Reference, </title> <month> October </month> <year> 1988. </year>
Reference-contexts: However, we know of no automatic (or semi-automatic) method for specifying general constraints in a high-level, non-procedural language, then deriving lower-level production rules that maintain the constraints. We describe such a method. The constraint and rule languages we use are based on an extended version of SQL <ref> [HFLP89, IBM88] </ref>, although our work could easily be adapted for alternate languages.
Reference: [KdMS90] <author> J. Kiernan, C. de Maindreville, and E. Simon. </author> <title> Making deductive databases a practical technology: A step forward. </title> <booktitle> In Proc. of ACM-SIGMOD, </booktitle> <pages> pages 237-246, </pages> <month> May </month> <year> 1990. </year>
Reference: [KP81] <author> S. Koenig and R. Paige. </author> <title> A transformational framework for the automatic control of derived data. </title> <booktitle> In Proc. of Seventh VLDB, </booktitle> <pages> pages 306-318, </pages> <month> September </month> <year> 1981. </year>
Reference: [MD89] <author> D.R. McCarthy and U. Dayal. </author> <title> The architecture of an active database management system. </title> <booktitle> In Proc. of ACM-SIGMOD, </booktitle> <pages> pages 215-224, </pages> <month> May </month> <year> 1989. </year>
Reference: [Mor83] <author> M. Morgenstern. </author> <title> Active databases as a paradigm for enhanced computing environments. </title> <booktitle> In Proc. of Ninth VLDB, </booktitle> <pages> pages 34-42, </pages> <month> October </month> <year> 1983. </year>
Reference: [Mor84] <author> M. Morgenstern. </author> <title> Constraint equations: Declarative expression of constraints with automatic enforcement. </title> <booktitle> In Proc. of Tenth VLDB, </booktitle> <pages> pages 291-300, </pages> <month> August </month> <year> 1984. </year>
Reference-contexts: In our approach, inconsistent states may occur and are detected, but consistency is restored by issuing corrective actions that depend on the particular constraint violation. Approaches similar to ours are taken in <ref> [CTF88, Mor84, UD90, UD91] </ref>, but in restricted settings. In [CTF88], only referential integrity and inclusion dependency constraints are considered. The user may define compensating actions (drawn from a restricted set) to be executed when constraints are violated. <p> Approaches similar to ours are taken in [CTF88, Mor84, UD90, UD91], but in restricted settings. In [CTF88], only referential integrity and inclusion dependency constraints are considered. The user may define compensating actions (drawn from a restricted set) to be executed when constraints are violated. In <ref> [Mor84] </ref>, the focus is on a very high-level language for expressing inter-relational constraints. The set of expressible constraints is a subset of those expressible using arbitrary predicates. In many cases, specific compensating actions may be derived automatically from constraints, subject to certain "hints" provided by the constraint definer.
Reference: [Nic82] <author> J.-M. Nicolas. </author> <title> Logic for improving integrity checking in relational data bases. </title> <journal> Acta Informat-ica, </journal> <volume> 18 </volume> <pages> 227-253, </pages> <year> 1982. </year>
Reference: [QS87] <author> X. Qian and D.R. Smith. </author> <title> Integrity constraint reformulation for efficient validation. </title> <booktitle> In Proc. of Thirteenth VLDB, </booktitle> <pages> pages 417-425, </pages> <month> September </month> <year> 1987. </year>
Reference: [SJGP90] <author> M. Stonebraker, A. Jhingran, J. Goh, and S. Potamianos. </author> <title> On rules, procedures, caching and views in data base systems. </title> <booktitle> In Proc. of ACM-SIGMOD, </booktitle> <pages> pages 281-290, </pages> <month> May </month> <year> 1990. </year>
Reference: [SK84] <author> A. Shepherd and L. Kerschberg. </author> <title> Prism: A knowledge based system for semantic integrity specification and enforcement in database systems. </title> <booktitle> In Proc. of ACM-SIGMOD, </booktitle> <pages> pages 307-314, </pages> <month> May </month> <year> 1984. </year>
Reference-contexts: In [Wal89], constraint definitions include both conditions on the state (which are checked) and additional actions that are automatically executed after certain operations to help maintain consistency. This is similar to defining constraints directly as the rules that enforce them, as in <ref> [SK84] </ref>.
Reference: [SMS87] <author> D. Stemple, S. Mazumdar, and T. Sheard. </author> <title> On the modes and meaning of feedback to transaction designers. </title> <booktitle> In Proc. of ACM-SIGMOD, </booktitle> <pages> pages 374-386, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: At run-time, a given transaction can be checked to verify that it will maintain consistency with respect to a set of constraints. If consistency is not guaranteed, the system can explain which constraints are violated and can suggest compensating actions. A similar approach is described in <ref> [SMS87] </ref>, however this work considers a compile-time rather than run-time environment. When transactions are determined to have potential for constraint violation, feedback is provided to the user in the form of suggested tests and updates to be added to the transaction.
Reference: [Sto75] <author> M. Stonebraker. </author> <title> Implementation of integrity constraints and views by query modification. </title> <booktitle> In Proc. of ACM-SIGMOD, </booktitle> <pages> pages 65-78, </pages> <month> May </month> <year> 1975. </year>
Reference: [UD90] <author> S.D. Urban and M. Desiderio. </author> <title> Translating constraints to rules in CONTEXT: A CONstrainT EXplanation Tool. </title> <type> Manuscript, </type> <year> 1990. </year>
Reference-contexts: In our approach, inconsistent states may occur and are detected, but consistency is restored by issuing corrective actions that depend on the particular constraint violation. Approaches similar to ours are taken in <ref> [CTF88, Mor84, UD90, UD91] </ref>, but in restricted settings. In [CTF88], only referential integrity and inclusion dependency constraints are considered. The user may define compensating actions (drawn from a restricted set) to be executed when constraints are violated.
Reference: [UD91] <author> S.D. Urban and L.M.L. Delcambre. </author> <title> Constraint Analysis: a design process for specifying operations on objects. </title> <journal> To appear in ACM Transactions on Data and Knowledge Engineering, </journal> <year> 1991. </year>
Reference-contexts: In our approach, inconsistent states may occur and are detected, but consistency is restored by issuing corrective actions that depend on the particular constraint violation. Approaches similar to ours are taken in <ref> [CTF88, Mor84, UD90, UD91] </ref>, but in restricted settings. In [CTF88], only referential integrity and inclusion dependency constraints are considered. The user may define compensating actions (drawn from a restricted set) to be executed when constraints are violated.
Reference: [Wal89] <author> J.A. Wald. </author> <title> Implementing constraints in a knowledge base. </title> <booktitle> In Expert Database Systems|Proc. from the Second Int. Conference, </booktitle> <pages> pages 163-183. </pages> <address> Benjamin/Cummings, </address> <year> 1989. </year>
Reference-contexts: A similar approach is described in [SMS87], however this work considers a compile-time rather than run-time environment. When transactions are determined to have potential for constraint violation, feedback is provided to the user in the form of suggested tests and updates to be added to the transaction. In <ref> [Wal89] </ref>, constraint definitions include both conditions on the state (which are checked) and additional actions that are automatically executed after certain operations to help maintain consistency. This is similar to defining constraints directly as the rules that enforce them, as in [SK84].
Reference: [WF90] <author> J. Widom and S.J. Finkelstein. </author> <title> Set-oriented production rules in relational database systems. </title> <booktitle> In Proc. of ACM-SIGMOD, </booktitle> <pages> pages 259-270, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: The production rule language is described in <ref> [WF90] </ref>. Prior familiarity with this rule language is not necessary; an overview is provided. Production rules enforce constraints by issuing actions to correct violation. In many cases, several possible actions may correct a given constraint violation, and which action is most appropriate may depend on the application. <p> Further details and numerous examples 2 This problem was presented to author Ceri by L. Dalle in the context of a joint study between ENEL|the Italian Electric Energy Agency|and the Politecnico di Milano. appear in <ref> [WF90] </ref>. We consider a relational database system with an integrated production rules facility. The system has all the usual database functionality; in addition, a set of production rules may be defined. In general, production rules specify actions to be performed when certain events occur or conditions are met. <p> Otherwise, rule processing terminates when the set of triggered rules is empty or when no triggered rule has a true condition; the entire transaction is then committed. 3 Here, we deviate somewhat from the semantics as presented in <ref> [WF90] </ref>, where a rule is considered with respect to the transition since before its last execution. It should be possible in the rule system to permit both interpretations. 3 Constraint Language We define a general language for expressing integrity constraints. <p> The core of the language is a variation on the usual SQL syntax for predicates, similar to that used in the if clause of our production rules <ref> [WF90] </ref>. Several advanced features are included, such as boolean types, tuple constructors, and user-defined functions. In [CW90], we also include table expressions (as described with respect to the Star-burst database system in [HFLP89]); space considerations have forced their omission here.
References-found: 27

