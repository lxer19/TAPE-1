URL: http://www.cs.colorado.edu/~zorn/cs5535/Fall-1995/projects/brumfield.ps
Refering-URL: http://www.cs.colorado.edu/~zorn/cs5535/Fall-1995/index.html
Root-URL: http://www.cs.colorado.edu
Title: Type Systems In Visual Languages Fundamental Concepts in Programming Languages Project Due:  
Author: Robert L. Brumfield 
Date: SID: 521-39-7831  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Burnett, M., Allean Ambler, </author> <title> Interactive Visual Data Abstraction in a Declarative Visual Programming Language, </title> <journal> Journal of Visual Languages and Computing, 1994, </journal> <volume> n5, </volume> <pages> pp. 29-60. </pages>
Reference-contexts: These languages were originally developed with the intent of instructing novices on the basics of programming. Whereas first attempts at VPLs tended to be simple flowcharting programs, current VPLs offer the ability to express explicit relationships between data by sketching, pointing at them or demonstrating them <ref> [1] </ref>. VPLs attempt to simplify program representation and meaning, while maximizing computational power. One method for accomplishing this, which has not been exhaustively researched, is type representations in these languages. Type systems help assure program correctness by verifying consistent relationships between objects.
Reference: [2] <author> Burnett, M. </author> <title> Types and Type Inference in a Visual Programming Language., </title> <booktitle> 1993 IEEE Symposium on Visual Languages. Bergen, Norway, </booktitle> <pages> pp. </pages> <month> p238-243. </month>
Reference-contexts: In this manner, Forms/3 supports parametric polymorphism. This polymorphism, combined with data abstraction allows an expressive type system. Forms/3 uses the notion of type constraint sets that expands the flexibility of the type system. An example taken from <ref> [2] </ref>, if a type A is the union of types number and text, and a type B is the union of text and stack, then a normal type system would not allow type B to be used for type A. The constraint sets, on the other, handle will allow this. <p> It would seem that imperative languages tend to utilize class or subtype type definitions, representing polymorphism and inheritance structures in a hierarchical manner. Declarative languages tend to rely on implicit parametric polymorphism, visualizing consistency checking in some subtle manner. Burnett <ref> [2] </ref> outlines some goals that type systems should strive for: 1 . The users conceptual model and the concreteness of the programming environment should be preserved. 2 . Any type errors should result in immediate and meaningful feedback. 3 .
Reference: [3] <author> Cardelli, L., P. Wegner, </author> <title> On Understanding Types, Data Abstractions, and Polymorphism, </title> <journal> Computing Surveys. v. </journal> <volume> 17. n.4. </volume> <month> December </month> <year> 1985. </year>
Reference-contexts: VPLs attempt to simplify program representation and meaning, while maximizing computational power. One method for accomplishing this, which has not been exhaustively researched, is type representations in these languages. Type systems help assure program correctness by verifying consistent relationships between objects. As Cardelli et. al. <ref> [3] </ref> write, type systems are like a suit of armor that protects an underlying untyped representation from arbitrary or unintended use. Type systems also allow programmers to encapsulate and formulate information into an abstract representation. Type systems are integral to the concepts of abstract data types and data abstraction. <p> Objects may be typed either explicitly (generally at the beginning of programming blocks) or implicitly (the system needs to infer the type of the object). Polymorphic type systems can be classified in two major ways, universal and ad-hoc polymorphism, each major category has two subcategories <ref> [3] </ref>: (Universal) Parametric Polymorphism - A polymorphic function has a type parameter which determines the type of argument for each application of that function. Also known as generic functions. (Universal) Inclusion Polymorphism - An object can belong to many different classes or types.
Reference: [4] <author> Citrin, W., M. Doherty, and B. Zorn, </author> <title> Formal Semantics of Control Constructs in a Completely Visual Imperative Language, </title> <institution> CU-CS-672-93, University of Colorado, Department of Computer Science, </institution> <month> September </month> <year> 1993. </year>
Reference-contexts: We can also follow Burnetts guidelines, outlined in the previous section, on how type systems should be incorporated into a language. We will examine these items in the context of a new language called VIPR <ref> [4] </ref> , for Visual Imperative PRogramming. VIPR is an imperative language with graphical layout and execution based on Pictoral Janus and semantics similar to C. There are also objectoriented considerations for VIPR in [5].
Reference: [5] <author> Citrin, W., M. Doherty, and B. Zorn, </author> <title> The Design of a Completely Visual ObjectOriented Programming Language, in Visual ObjectOriented Programming, Burnett, </title> <editor> M., A. Goldberg, and T. Lewis, Editors. </editor> <booktitle> 1994, </booktitle> <publisher> Prentice-Hall: </publisher> <address> Englewood Cliffs, NJ. </address>
Reference-contexts: We will examine these items in the context of a new language called VIPR [4] , for Visual Imperative PRogramming. VIPR is an imperative language with graphical layout and execution based on Pictoral Janus and semantics similar to C. There are also objectoriented considerations for VIPR in <ref> [5] </ref>. Currently type information is specified textually, but the goal is to enable programming in a completely visual manner. Producing a type system for this language is one step towards that goal.
Reference: [6] <author> Cox, P.T., F.R. Giles, and T. Pietrzykowski, Prograph: </author> <title> a step towards liberating programming from textual conditioning, </title> <booktitle> IEEE Workshop on Visual Languages, </booktitle> <year> 1989, </year> <pages> 150-156. </pages>
Reference-contexts: The language can minimize some of this by abstracting components. The program is also live as its being developed, this allows the user to see the immediate effect on the work in progress. Prograph <ref> [6] </ref> Prograph is an interpreted pictorial dataflow language, incorporating objectorientation similar to C++ or Smalltalk. The system provides system classes and allows users to create and inherit their own classes .
Reference: [7] <author> Harvey, N., J. Morris, </author> <title> Type Systems for Visual Languages: Simplicity versus Richness, </title> <institution> Department of Computer Science, University of Tasmania, Tasmania, Australia. </institution>
Reference-contexts: Many of these type systems are based on Milners, providing support for tuples, unions, functions, higher order functions and polymorphic types. These include ESTL [12] , CUBE [13,14] , and NL <ref> [7] </ref> . Fabrik [9,11] included a limited interactive polymorphic type system and VisaVis [15] uses an incremental type system with implicit parametric overloading. <p> Type consistency is visually represented as the program is constructed by displaying the inferred types on the input ports. Un-inferred or unknown types appear as an opaque gray cube. Thus, it should be obvious which ports still need inferred types. NL <ref> [7] </ref> NL is a functional visual dataflow language supporting strong, implicit, polymorphic types. An NL program is a directed graph consisting of nodes and arcs. Arcs connect nodes, or nodes and input ports, and carry data items known as tokens.
Reference: [8] <author> Hirakawa, M., M. Tanaka, and T. </author> <title> Ichikawa (1990), An iconic programming system, </title> <journal> HI-VISUAL. IEEE Transaction on Software Engineering 16, </journal> <pages> 1178-1184. </pages>
Reference-contexts: Visual Representation Data types are represented by icons, with slots for a type variable if needed. This slot can be filled in by inference or specified by the user. Inconsistent parts of a program are obvious to the user since those parts are grayed out. HI-VISUAL <ref> [8] </ref> HI-VISUAL is an objectoriented, iconic dataflow language. Programs are generated in HI-VISUAL by applying icons to one another. Each icon encapsulates the data and behavior of an object. Each object tracks the messages it is able to transmit and receive.
Reference: [9] <author> Ingalls, D., Y.Y. Chow, F. ludolph, K. Doyle, </author> <title> Fabrik - A Visual Programming Environment, </title> <booktitle> OOPSLA 88 Proceedings, </booktitle> <pages> pp. 176-190. </pages>
Reference: [10] <author> Kozen, D., T. Teitelbaum, W. Chen, J. Field, W. Pugh, B.V.Zanden, </author> <title> ALEX - an Alexical Programming Language. </title> <booktitle> 1987 IEEE Workshop on Visual Languages. Linkopin, Sweden. </booktitle> <pages> pp. 315-329. </pages>
Reference-contexts: ALEX <ref> [10] </ref> ALEX is a graphical language for high-level parallel programming. The authors claim that, of conventional languages, its closest to FP or other recursive dataflow languages. ALEX allows functions and programs to be constructed by demonstrating how array objects should be manipulated.
Reference: [11] <author> Ludolph, F., Y.Y. Chow, D. Ingalls, S. Wwallace and K. Doyle, </author> <title> The Fabrik programming environment. </title> <booktitle> in: 1988 IEEE Workshop on Visual Languages. </booktitle> <address> Pittsburgh, Pennsylvania, </address> <pages> pp. 222-230. </pages>
Reference: [12] <author> Najork, M.A., E. Golin, </author> <title> Enhancing Show-and-Tell with a polymorphic type system, and higher-order functions, </title> <booktitle> IEEE Workshop on Visual Languages, </booktitle> <address> Skokie, USA, </address> <year> 1990, </year> <pages> pp. 215-220. </pages> <note> Type Systems In Visual Languages December 15, 1995 Robert L. Brumfield Page 12 SID: 521-39-7831 </note>
Reference-contexts: Brumfield Page 2 SID: 521-39-7831 Related Work There are a number of visual languages implementing some form of a type system. Many of these type systems are based on Milners, providing support for tuples, unions, functions, higher order functions and polymorphic types. These include ESTL <ref> [12] </ref> , CUBE [13,14] , and NL [7] . Fabrik [9,11] included a limited interactive polymorphic type system and VisaVis [15] uses an incremental type system with implicit parametric overloading.
Reference: [13] <author> Najork, M.A., </author> <title> S.M. Kaplan, The CUBE Language, </title> <booktitle> IEEE Workshop on Visual Languages, </booktitle> <address> Kobe, Japan, </address> <year> 1991, </year> <pages> pp. 218-225. </pages>
Reference: [14] <author> Najork, M.A., </author> <title> Visual Progrramming in 3-D, </title> <journal> Dr. Dobbs Journal, </journal> <year> 1995, </year> <month> Dec. </month>
Reference: [15] <author> Poswig, J., C. Moragana, </author> <title> Incremental Type Systems and Implicit Parametric Overloading in Visual Languages, </title> <booktitle> 1993 IEEE Symposium on Visual Languages. Bergen, Norway, </booktitle> <pages> pp. 126-133. </pages>
Reference-contexts: Many of these type systems are based on Milners, providing support for tuples, unions, functions, higher order functions and polymorphic types. These include ESTL [12] , CUBE [13,14] , and NL [7] . Fabrik [9,11] included a limited interactive polymorphic type system and VisaVis <ref> [15] </ref> uses an incremental type system with implicit parametric overloading. Forms/3 [1,2] extends data abstraction from traditional models in two ways: (1) it adds graphical representations and interactive behaviors to a types definition; and (2) it is accomplished entirely through visual programming mechanisms. <p> Feedback on type inconsistencies is immediate and programmers may override the inferred type by explicitly indicating a type. N 2 N else N N Fibonacci N Fibonacci - 2 Guard Nodes Block Nodes Type Systems In Visual Languages December 15, 1995 Robert L. Brumfield Page 8 SID: 521-39-7831 VisaVis <ref> [15] </ref> VisaVis is a functional dataflow language. Programs are specified by dragging an icon, known as a key, and dropping it onto possible functions (the keyhole). If the key fits the keyhole, that part of the program is unified. Unmatched parts of the program appear visually raised above the program.
References-found: 15

