URL: http://swarm.cs.wustl.edu/~picco/papers/ma98.mucode.ps.gz
Refering-URL: http://swarm.cs.wustl.edu/~picco/listpub.type.html
Root-URL: 
Email: E-mail: picco@polito.it,  
Phone: Phone: +39-11-5647091, Fax: +39-11-5647099  
Title: Code: A Lightweight and Flexible Mobile Code Toolkit  
Author: Gian Pietro Picco 
Web: Web: http://www.polito.it/~picco  
Address: C.so Duca degli Abruzzi 24, 10129 Torino, Italy  
Affiliation: Dip. Automatica e Informatica, Politecnico di Torino  
Abstract: Although a thorough evaluation of mobile code technology does not exist yet, some studies already evidenced that the powerful (and often heavyweight) abstractions and mechanisms proposed so far are not always flexible enough to fully exploit the benefits of migrating code. Code is a new mobile code toolkit designed to be flexible, extensible, and lightweight. Its small set of abstractions and mechanisms can be used directly by the programmer or composed in higher-level abstractions| mobile agents included. This paper discusses the fundamental concepts and features of Code, together with its rationale and motivation.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A. Acharya, M. Ranganathan, and J. Saltz. Sumatra: </author> <title> A Language for Resource-aware Mobile Programs. In Mobile Object Systems: Towards the Programmable Internet, </title> <booktitle> volume 1222 of LNCS, </booktitle> <pages> pages 111-130. </pages> <publisher> Springer, </publisher> <month> April </month> <year> 1997. </year>
Reference-contexts: In Code, the unit of migration is the group. A group is simply a container for classes and objects. This abstraction is reminiscent of TACOMA briefcases [7] or, more closely, of the object-group abstraction found in Sumatra <ref> [1] </ref>. However, there at least two significant differences: In Sumatra, the classes needed by objects in an object-group are not transferred along with the group, and must be shipped explicitly with a separate downloadClass operation.
Reference: 2. <author> M. Baldi, S. Gai, </author> <title> and G.P. Picco. Exploiting Code Mobility in Decentralized and Flexible Network Management. </title> <booktitle> In Mobile Agents: 1 st International Workshop MA'97, volume 1219 of LNCS, </booktitle> <pages> pages 13-26. </pages> <publisher> Springer, </publisher> <month> April </month> <year> 1997. </year>
Reference-contexts: The goal of this work is to propose a different perspective on the design of language support for mobile code. This is achieved by leveraging off of previous work done by the author in evaluating qualitatively and quantitatively the benefits of mobile code <ref> [2, 3] </ref>, exploiting mobile code in applications [4], and building a conceptual framework for code mobility [6]. The outcome is a proof-of-concept system called Code, a mobile code toolkit for Java conceived to overcome some of the drawbacks of existing mobile code systems (MCS). The paper is structured as follows. <p> To ground the conclusions in the real world rather than in toy examples, these studies focused on the application domain of network management, adopting both a qualitative <ref> [2] </ref> and quantitative [3] style of analysis. In particular, the latter defined an analytical model of a management task and derived criteria to compare the effectiveness of client-server and mobile code in reducing the network traffic generated by management.
Reference: 3. <author> M. </author> <title> Baldi and G.P. Picco. Evaluating the Tradeoffs of Mobile Code Design Paradigms in Network Management Applications. </title> <booktitle> In Proc. of the 20 th Int. Conf. on Software Engineering, </booktitle> <pages> pages 146-155, </pages> <month> April </month> <year> 1998. </year>
Reference-contexts: However, the only pervasive mobile code application is nowadays the execution of applets in a Web browser| a rather limited exploitation of the mobile code potential. Most researchers are in fact focusing on the proposal of new technologies, and only very few studies <ref> [3, 10] </ref> focused on building applications and identifying the benefits and tradeoffs involved. As a consequence, a wider acceptance of code mobility is presently hampered by the fact that the soundness of the abstractions and mechanisms proposed are not verified by quantitative evaluations and experimental evidence. <p> The goal of this work is to propose a different perspective on the design of language support for mobile code. This is achieved by leveraging off of previous work done by the author in evaluating qualitatively and quantitatively the benefits of mobile code <ref> [2, 3] </ref>, exploiting mobile code in applications [4], and building a conceptual framework for code mobility [6]. The outcome is a proof-of-concept system called Code, a mobile code toolkit for Java conceived to overcome some of the drawbacks of existing mobile code systems (MCS). The paper is structured as follows. <p> To ground the conclusions in the real world rather than in toy examples, these studies focused on the application domain of network management, adopting both a qualitative [2] and quantitative <ref> [3] </ref> style of analysis. In particular, the latter defined an analytical model of a management task and derived criteria to compare the effectiveness of client-server and mobile code in reducing the network traffic generated by management. <p> Again, a different set of primitives may be appropriate, even if they are characterized by a lower level of abstraction. Communication performance. As evidenced in <ref> [3] </ref>, the size of the code being moved is a key factor in determining the threshold after which code mobility becomes useful in reducing network traffic|another motivation to avoid abstractions enforcing unnecessary verbosity. However, a key factor affecting performance is also the overhead introduced by communication protocols. <p> Existing systems exploit different solutions that range from the direct use of the Java serialization protocol [14] to the use of protocols for distributed objects [8]. Java Aglets employ an Agent Transfer Protocol (ATP) that, as characterized quantitatively in <ref> [3] </ref>, increases significantly the communication overhead under given conditions. Clearly, the overhead of application protocols should be minimized, and in this respect Java serialization provides a good tradeoff between compactness of the encoding and ease of programming and customizability. Hence, our toolkit is designed around the following principles: 1. Flexibility.
Reference: 4. <author> M. Baldi, G.P. Picco, and F. Risso. </author> <title> Designing a Videoconference System for Active Networks. </title> <note> In this proceedings. </note>
Reference-contexts: This is achieved by leveraging off of previous work done by the author in evaluating qualitatively and quantitatively the benefits of mobile code [2, 3], exploiting mobile code in applications <ref> [4] </ref>, and building a conceptual framework for code mobility [6]. The outcome is a proof-of-concept system called Code, a mobile code toolkit for Java conceived to overcome some of the drawbacks of existing mobile code systems (MCS). The paper is structured as follows. <p> We chose this platform because it is considered by many researchers as one of the most reliable, supported, and complete. However, the aforementioned studies and the mobile code application described in <ref> [4] </ref> evidenced the drawbacks discussed in the following 2 , and gave rationale to the development of Code. <p> The rationale for Code comes from research developed by the author and his colleagues in evaluating the benefits of mobile code in real world application domains. Code is being effectively used to implement applications for active networks <ref> [4] </ref> and network management. The current implementation of Code consists of less than a thousand non-commented source statements, which generate approximately 40Kbytes of bytecode. Additional figures are not yet available, but the use on the field of Code showed that it provides adequate flexibility and a reduction in communication overhead.
Reference: 5. <author> J.D. </author> <title> Case et al. Simple Network Management Protocol. </title> <type> RFC 1157, </type> <month> May </month> <year> 1990. </year>
Reference-contexts: In particular, the latter defined an analytical model of a management task and derived criteria to compare the effectiveness of client-server and mobile code in reducing the network traffic generated by management. The theoretical findings were verified by measuring the performance of a SNMPv1 <ref> [5] </ref> implementation against several mobile code alternatives implemented with the Java Aglets API [9]. We chose this platform because it is considered by many researchers as one of the most reliable, supported, and complete.
Reference: 6. <author> A. Fuggetta, G.P. Picco, and G. Vigna. </author> <title> Understanding Code Mobility. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 24(5) </volume> <pages> 342-361, </pages> <month> May </month> <year> 1998. </year>
Reference-contexts: This is achieved by leveraging off of previous work done by the author in evaluating qualitatively and quantitatively the benefits of mobile code [2, 3], exploiting mobile code in applications [4], and building a conceptual framework for code mobility <ref> [6] </ref>. The outcome is a proof-of-concept system called Code, a mobile code toolkit for Java conceived to overcome some of the drawbacks of existing mobile code systems (MCS). The paper is structured as follows. <p> How to constrain migration of classes with Java Aglets. Lack of flexibility in the strategies for code relocation. According to the taxonomy for code mobility presented in <ref> [6] </ref>, Java Aglets support weak mobility by enabling shipping and fetching of stand-alone code|the aglets. Since the API relies on Java, Aglets support also fetching of code fragments|the aglet classes. However, the strategies that rule class relocation are not completely under the control of the programmer. <p> However, this scheme becomes artificial if only a site must be upgraded; using lower level primitives that deal directly with the relocation of classes is more natural. Similar considerations hold for the implementation of a remote evaluation paradigm <ref> [11, 6] </ref>. In many Java-based systems, the only means to realize it is to create locally and dispatch to destination a mobile agent that has been coded explicitly to handle communication of the remote evaluation results. <p> A Server is an abstraction of the run-time support and represents a computational environment for mobile threads. Upon migration, thread objects retain their data state and lose their execution state. Thus, only weak mobility is supported, through all the mechanisms identified in the taxonomy <ref> [6] </ref>; Code supports code shipping and fetching of both code fragments and stand-alone code, with both synchronous and asynchronous invocation, as well as deferred and immediate execution of mobile code. <p> Finally, the ship method provides relocation of the Group on the Server specified by destination, identified by a pair hostname:port. The dynLink parameter enables dynamic linking of classes from a remote Server, thus providing direct support for a code on demand paradigm <ref> [6] </ref>. This way, the group is allowed to provide just a subset of the classes required for its handling and the execution of the associated thread objects, if any.
Reference: 7. <author> D. Johansen, R. van Renesse, and F. B. Schneider. </author> <title> An Introduction to the TACOMA Distributed System|Version 1.0. </title> <type> Technical Report 95-23, </type> <institution> Tromst and Cornell Univ., </institution> <month> June </month> <year> 1995. </year>
Reference-contexts: However, a package providing the appropriate mechanisms on top of Code is currently under development. In Code, the unit of migration is the group. A group is simply a container for classes and objects. This abstraction is reminiscent of TACOMA briefcases <ref> [7] </ref> or, more closely, of the object-group abstraction found in Sumatra [1]. However, there at least two significant differences: In Sumatra, the classes needed by objects in an object-group are not transferred along with the group, and must be shipped explicitly with a separate downloadClass operation.
Reference: 8. <author> J. Kiniry and D. Zimmerman. </author> <title> A Hands-On Look at Java Mobile Agents. </title> <journal> IEEE Internet Computing, </journal> <volume> 1(4) </volume> <pages> 21-30, </pages> <year> 1997. </year>
Reference-contexts: Along this line, our toolkit can be regarded as the microcode for systems providing higher levels of abstraction, much like the microcode in a processor. 2 Although focused on Java Aglets, most of the remarks apply also to many other Java-based MCSs, like Mole [12] or Odyssey <ref> [8] </ref>. task remotely in a disconnected fashion, without keeping the client connected during task execution. <p> Existing systems exploit different solutions that range from the direct use of the Java serialization protocol [14] to the use of protocols for distributed objects <ref> [8] </ref>. Java Aglets employ an Agent Transfer Protocol (ATP) that, as characterized quantitatively in [3], increases significantly the communication overhead under given conditions.
Reference: 9. <author> D.B. Lange. </author> <title> Java Aglets Application Programming Interface (J-AAPI). </title> <institution> IBM Corp. White Paper, </institution> <month> February </month> <year> 1997. </year>
Reference-contexts: The theoretical findings were verified by measuring the performance of a SNMPv1 [5] implementation against several mobile code alternatives implemented with the Java Aglets API <ref> [9] </ref>. We chose this platform because it is considered by many researchers as one of the most reliable, supported, and complete. However, the aforementioned studies and the mobile code application described in [4] evidenced the drawbacks discussed in the following 2 , and gave rationale to the development of Code.
Reference: 10. <editor> M. Ranganathan et al. </editor> <booktitle> Network-Aware Mobile Programs. In Proc. of the USENIX 1997 Annual Technical Conf., </booktitle> <month> January </month> <year> 1997. </year>
Reference-contexts: However, the only pervasive mobile code application is nowadays the execution of applets in a Web browser| a rather limited exploitation of the mobile code potential. Most researchers are in fact focusing on the proposal of new technologies, and only very few studies <ref> [3, 10] </ref> focused on building applications and identifying the benefits and tradeoffs involved. As a consequence, a wider acceptance of code mobility is presently hampered by the fact that the soundness of the abstractions and mechanisms proposed are not verified by quantitative evaluations and experimental evidence.
Reference: 11. <author> J.W. Stamos and D.K. Gifford. </author> <title> Remote Evaluation. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 12(4) </volume> <pages> 537-565, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: However, this scheme becomes artificial if only a site must be upgraded; using lower level primitives that deal directly with the relocation of classes is more natural. Similar considerations hold for the implementation of a remote evaluation paradigm <ref> [11, 6] </ref>. In many Java-based systems, the only means to realize it is to create locally and dispatch to destination a mobile agent that has been coded explicitly to handle communication of the remote evaluation results.
Reference: 12. <author> M. Straer, J. Baumann, and F. Hohl. </author> <title> Mole|A Java Based Mobile Agent System. </title> <booktitle> In Special Issues in Object-Oriented Programming: Workshop Reader of the 10 th European Conf. on Object-Oriented Programming ECOOP'96, </booktitle> <pages> pages 327-334. </pages> <address> dpunkt, </address> <month> July </month> <year> 1996. </year>
Reference-contexts: Along this line, our toolkit can be regarded as the microcode for systems providing higher levels of abstraction, much like the microcode in a processor. 2 Although focused on Java Aglets, most of the remarks apply also to many other Java-based MCSs, like Mole <ref> [12] </ref> or Odyssey [8]. task remotely in a disconnected fashion, without keeping the client connected during task execution.
Reference: 13. <author> Sun Microsystems. </author> <title> Java Core Reflection, </title> <month> January </month> <year> 1997. </year>
Reference-contexts: The implementation of Code leverages off of some advanced features provided by the Java language. The computation of the class closure employs the reflective features provided by Java <ref> [13] </ref> to retrieve information about the members of a class. However, the Java reflection mechanism cannot detect the need for classes that are declared in method bodies, as exemplified in Section 3.
Reference: 14. <author> Sun Microsystems. </author> <title> Java Object Serialization Specification, </title> <month> February </month> <year> 1997. </year>
Reference-contexts: Network and transport level protocols are usually part of the system requirements, but the language designer retains control on the application level protocol used to transfer mobile code. Existing systems exploit different solutions that range from the direct use of the Java serialization protocol <ref> [14] </ref> to the use of protocols for distributed objects [8]. Java Aglets employ an Agent Transfer Protocol (ATP) that, as characterized quantitatively in [3], increases significantly the communication overhead under given conditions. <p> If MyVar must be transferred as well, it must be added explicitly to the group. Differently from class serialization, managed directly by Code, object serialization relies on Java mechanisms and thus requires the class of the object being inserted in a group to implement the appropriate interfaces defined in <ref> [14] </ref>; an exception is raised otherwise. Java serialization relies on the notion of object closure. The object closure of an object o is constituted by o, by all the objects that are fields of o, by all the objects that are fields of the objects above, and so on, recursively.
Reference: 15. <author> C. Tschudin. </author> <title> An Introduction to the M0 Messenger Language. </title> <institution> Univ. of Geneva, Switzerland, </institution> <year> 1994. </year>
Reference-contexts: The idea of class space is reminiscent of the dictionary concept found in M0 <ref> [15] </ref>, in that it provides direct access to the name space of an executing unit. The coincidence is not by chance. Like M0, Code aims at providing a set of basic abstractions and mechanisms to build higher-level systems.
References-found: 15

