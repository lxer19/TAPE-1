URL: http://www.cs.rice.edu/CS/PLT/Publications/tr91-167.ps.gz
Refering-URL: http://www.cs.rice.edu/CS/PLT/Publications/
Root-URL: 
Title: Observable Sequentiality and Full Abstraction  
Author: Robert Cartwright Matthias Felleisen Robert Cartwright and Matthias Felleisen 
Note: Copyright c fl1992 by  
Date: 91-167  
Address: Houston, TX 77251-1892  
Affiliation: Department of Computer Science Rice University  Rice  
Pubnum: Technical Report CS  
Abstract: A preliminary version of this technical report appeared in the Proceedings of the 19th Annual ACM Symposium on Principles of Programming Languages, January 19-22, 1992, Albuquerque, New Mexico. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Barendregt, </author> <title> H.P. The Lambda Calculus: Its Syntax and Semantics. Revised Edition. </title> <booktitle> Studies in Logic and the Foundations of Mathematics 103. </booktitle> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1984. </year>
Reference-contexts: The proofs for S and K are given in Appendix A. The proof for I closely follows the proof for K. The preceding theorem implies that the fi axiom holds for combinatory terms translated from -abstractions <ref> [1] </ref>. In addition, the extensionality theorem (Theorem 4.11) and the validity of fi axiom imply that the axiom also holds. <p> Both equations can be proved using standard methods <ref> [1] </ref>; the proof of () depends on the extensionality theorem (Theorem 4.11). We can use the fi axiom to prove that T [[Y]] is the tree encoding the least fixed point operator.
Reference: 2. <author> Berry, G. Sequentialite de l'evaluation formelle des -expressions. </author> <booktitle> In Proc. 3rd International Colloquium on Programming, </booktitle> <year> 1978. </year>
Reference-contexts: This definition is based on Vuillemin's definition [26] of sequentiality for first order functions and Berry's generalization <ref> [2] </ref> of Vuillemin's definition to higher types. Plotkin proved that PCF is sequential [18:Activity Lemma] using an operational semantics for PCF that assigns the same meaning to PCF programs as the model C. 3 Observing Sequentiality PCF omits several language constructs that are essential in practical languages.
Reference: 3. <author> Berry, G. </author> <title> Modeles completement adequats et stables des lambda-calculus type. </title> <type> Ph.D. dissertation, </type> <institution> Universite Paris VII, </institution> <year> 1979. </year>
Reference-contexts: Unfortunately, neither Milner's nor Plotkin's result showed how to construct fully abstract denotational models for sequential languages. In a subsequent investigation of sequential languages, Berry and Curien <ref> [3, 4, 6, 8] </ref> constructed models for PCF with more restrictive domains of procedure denotations. Berry eliminated many parallel functions from these domains by forcing functions to be stable.
Reference: 4. <author> Berry, G. and P-L. Curien. </author> <title> Sequential algorithms on concrete data structures. </title> <journal> Theor. Comput. Sci. </journal> <volume> 20, </volume> <year> 1982, </year> <pages> 265-321. </pages>
Reference-contexts: Unfortunately, neither Milner's nor Plotkin's result showed how to construct fully abstract denotational models for sequential languages. In a subsequent investigation of sequential languages, Berry and Curien <ref> [3, 4, 6, 8] </ref> constructed models for PCF with more restrictive domains of procedure denotations. Berry eliminated many parallel functions from these domains by forcing functions to be stable. <p> Berry eliminated many parallel functions from these domains by forcing functions to be stable. This construction eliminated some of the spurious distinctions between phrases in the conventional model, but it introduced some new ones. 2 To address this problem, Berry and Curien <ref> [4, 5] </ref> proposed interpreting procedures as sequential algorithms over concrete domains [14]. Roughly speaking, a concrete domain is a domain that is isomorphic to a domain consisting of potentially infinite trees. A sequential algorithm is a function plus a strategy for evaluating its arguments. <p> In Section 4.2, we prove that there is a one-to-one correspondence between the graphs of observably sequential functions and their tree representations. Decision trees simply identify mathematical structure that is implicitly present in error-sensitive functions. 5 5 Berry and Curien <ref> [4] </ref> previously proposed representing procedures as trees in their work on concrete sequential algorithms. Since their domains do not include error elements, they associate distinct trees with the same function. For example, + l and + r correspond to distinct concrete sequential algorithms but they denote the same function [4:316].
Reference: 5. <author> Berry, G. and P-L. Curien. </author> <title> Theory and practice of sequential algorithms: the kernel of the applicative language cds. In Algebraic Methods in Semantics, edited by J. </title> <editor> Reynolds and M.Nivat. </editor> <publisher> Cambridge University Press. </publisher> <address> London, </address> <year> 1985, </year> <pages> 35-88. </pages>
Reference-contexts: Berry eliminated many parallel functions from these domains by forcing functions to be stable. This construction eliminated some of the spurious distinctions between phrases in the conventional model, but it introduced some new ones. 2 To address this problem, Berry and Curien <ref> [4, 5] </ref> proposed interpreting procedures as sequential algorithms over concrete domains [14]. Roughly speaking, a concrete domain is a domain that is isomorphic to a domain consisting of potentially infinite trees. A sequential algorithm is a function plus a strategy for evaluating its arguments. <p> Since their domains do not include error elements, they associate distinct trees with the same function. For example, + l and + r correspond to distinct concrete sequential algorithms but they denote the same function [4:316]. In this framework, tree representations are intensional. In later work <ref> [5, 8] </ref>, Berry and Curien noted that sequential algorithms can distinguish different algorithms for the same function, but they did not make a connection between intensional procedures and control operators like CATCH. <p> Proof. We have already shown that SPCF is error-sensitive. The remainder of the proof is trivial: simply set D [ ] = (add1 (catch [ ])). SPCF is not the first observably sequential language that has been studied in the context of the full abstraction problem. Berry and Currien <ref> [5] </ref> defined an observably sequential language called CDS0 in their work on sequential algorithms. They also constructed a fully abstract model for CDS0 based on sequential algorithms (which correspond to decision trees without errors), but the model is not extensional because the language is not error-sensitive.
Reference: 6. <author> Berry, G., P-L. Curien, and P.-P. L evy. </author> <title> Full-abstraction of sequential languages: the state of the art. In Algebraic Methods in Semantics, edited by J. </title> <editor> Reynolds and M.Nivat. </editor> <publisher> Cambridge University Press. </publisher> <address> London, </address> <year> 1985, </year> <pages> 89-131. </pages>
Reference-contexts: Unfortunately, neither Milner's nor Plotkin's result showed how to construct fully abstract denotational models for sequential languages. In a subsequent investigation of sequential languages, Berry and Curien <ref> [3, 4, 6, 8] </ref> constructed models for PCF with more restrictive domains of procedure denotations. Berry eliminated many parallel functions from these domains by forcing functions to be stable. <p> However, like Milner's original fully abstract model, Mulmuley's model is "syntactic" in flavor because it relies on a quotient construction based on observational equivalence. For more details on the history of the full abstraction problem for sequential languages, we refer the reader to two extensive surveys <ref> [6, 25] </ref>. 1.2 Summary of Results Fifteen years after Milner's and Plotkin's original work, the fundamental question still remains: Are there fully abstract denotational models for sequential programming lan guages? In this paper, we answer the question affirmatively by showing how to construct a fully abstract denotational model for an observably
Reference: 7. <author> Cartwright, R. and A. Demers. </author> <title> The topology of program termination. </title> <booktitle> In Proc. Symposium on Logic in Computer Science, </booktitle> <year> 1988, </year> <pages> 296-308. </pages> <note> Observable Sequentiality and Full Abstraction 65 </note>
Reference-contexts: In the third and fourth subsections, we assign interpretations to the primitive constants and the combinators of SPCF, and prove the basic equational properties of the tree model. 4.1 Tree Domains A Scott domain is the ideal completion of a finitary basis <ref> [7, 20] </ref>. A finitary basis B is a countable, partially ordered set such that every finite, bounded subset has a least upper bound. The domain D B determined by B is the set of ideals over B; the principal ideals of 16 R. Cartwright, M. <p> The three properties are a consequence of Lemma 4.3 and a general theorem for ideal completions of finitary bases <ref> [7] </ref>.
Reference: 8. <author> Curien, P-L. </author> <title> Categorical Combinators, Sequential Algorithms, </title> <booktitle> and Functional Programming. Research Notes in Theoretical Computer Science. </booktitle> <publisher> Pitman, </publisher> <address> London. </address> <year> 1986. </year> <note> Birkhauser, Revised Edition, to appear. </note>
Reference-contexts: Unfortunately, neither Milner's nor Plotkin's result showed how to construct fully abstract denotational models for sequential languages. In a subsequent investigation of sequential languages, Berry and Curien <ref> [3, 4, 6, 8] </ref> constructed models for PCF with more restrictive domains of procedure denotations. Berry eliminated many parallel functions from these domains by forcing functions to be stable. <p> Since their domains do not include error elements, they associate distinct trees with the same function. For example, + l and + r correspond to distinct concrete sequential algorithms but they denote the same function [4:316]. In this framework, tree representations are intensional. In later work <ref> [5, 8] </ref>, Berry and Curien noted that sequential algorithms can distinguish different algorithms for the same function, but they did not make a connection between intensional procedures and control operators like CATCH.
Reference: 9. <author> Curien, P.-L.. </author> <title> Observable algorithms on concrete data structures. </title> <booktitle> In Proc 7th Symposium on Logic in Computer Science, </booktitle> <year> 1992, </year> <note> to appear. </note>
Reference-contexts: Curien has recently shown that our model for SPCF is indeed closely related to the Berry-Curien model for PCF; the result will appear in a forthcoming paper <ref> [9] </ref>. Observable Sequentiality and Full Abstraction 15 4 The Tree Model A model M of SPCF has essentially the same form as a model of PCF.
Reference: 10. <author> Felleisen, M. </author> <title> The theory and practice of first-class prompts. </title> <booktitle> In Proc. 15th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1988, </year> <pages> 180-190. </pages>
Reference-contexts: Consequently, the decision tree model for PCF is neither extensional nor fully abstract. However, the interesting issue is which practical programming languages with rich control operators are not error-sensitive or observably sequential. At this point we know of one prominent example: sequential languages with control delimiters <ref> [10] </ref>, also referred to as prompts. The task of a control delimiter is to mask any control operation that happens during the dynamic extent of some expression. Some typical examples in practical languages are Lisp's errset, Common Lisp's unwind-protect and ML's wild-card error-handler.
Reference: 11. <author> Felleisen, M. and R. Hieb. </author> <title> The revised report on the syntactic theories of sequential control and state. </title> <type> Technical Report 100, </type> <institution> Rice University, </institution> <month> June </month> <year> 1989. </year> <institution> Theor. Comput. Sci., </institution> <year> 1992, </year> <note> to appear. </note>
Reference-contexts: ; f ))]] j n 2 Ng; T [[M ]]) = apply (T [[Y ]]; T [[M ]]) = T [[apply (Y ; M )]] : To determine the relevant equations for the catch operators and error values, we draw on our operational intuition about the behavior of control operators <ref> [11, 12] </ref>. The key idea is to define a "program counter" for program text corresponding to the obvious reduction semantics for SPCF. This counter determines which term in a program must be evaluated next in order to determine the program's answer. <p> The natural equations for the primitive operations fadd1; sub1; if0; Y; error 1 ; error 2 g, the fi and rules, and the equations for catch completely determine an operational reduction semantics for SPCF <ref> [11, 12] </ref>. The equations also suffice to prove the representability lemma of the following section. Note: call=cc d vs CATCH. As indicated in Section 2, Scheme's original CATCH construct permits the specification of a return value to the "catch label".
Reference: 12. <author> Felleisen, M., D.P. Friedman, E. Kohlbecker, and B. Duba. </author> <title> A syntactic theory of sequential control. </title> <journal> Theor. Comput. Sci. </journal> <volume> 52(3), </volume> <year> 1987, </year> <pages> 205-237. </pages> <note> Preliminary version in: Proc. Symposium on Logic in Computer Science, </note> <year> 1986, </year> <pages> 131-141. </pages>
Reference-contexts: ; f ))]] j n 2 Ng; T [[M ]]) = apply (T [[Y ]]; T [[M ]]) = T [[apply (Y ; M )]] : To determine the relevant equations for the catch operators and error values, we draw on our operational intuition about the behavior of control operators <ref> [11, 12] </ref>. The key idea is to define a "program counter" for program text corresponding to the obvious reduction semantics for SPCF. This counter determines which term in a program must be evaluated next in order to determine the program's answer. <p> The natural equations for the primitive operations fadd1; sub1; if0; Y; error 1 ; error 2 g, the fi and rules, and the equations for catch completely determine an operational reduction semantics for SPCF <ref> [11, 12] </ref>. The equations also suffice to prove the representability lemma of the following section. Note: call=cc d vs CATCH. As indicated in Section 2, Scheme's original CATCH construct permits the specification of a return value to the "catch label".
Reference: 13. <author> Jim, T. and A. Meyer. </author> <title> Full abstraction and the context lemma. </title> <booktitle> In Proc. International Conference on Theoretical Aspects of Computer Software (TACS). Lecture Notes in Computer Science 526. </booktitle> <publisher> Springer Verlag, </publisher> <address> Berlin, </address> <year> 1991, </year> <pages> 131-151. </pages>
Reference-contexts: The construction relies on two closely related insights: 1. In practical languages, a programmer can use run-time errors to observe the order in which a procedure evaluates its arguments. Similarly, many practical languages 2 This observation is due to T. Jim and A. Meyer <ref> [13] </ref>. In the stable function model, two procedures corresponding to the same continuous function can denote inconsistent stable functions. The procedures + l and + r defined in Section 2 have this property.
Reference: 14. <author> Kahn, G. and G. Plotkin. </author> <title> Structures des donnes concretes (Domaines Concretes). </title> <type> IRIA Report 336. </type> <year> 1978. </year>
Reference-contexts: This construction eliminated some of the spurious distinctions between phrases in the conventional model, but it introduced some new ones. 2 To address this problem, Berry and Curien [4, 5] proposed interpreting procedures as sequential algorithms over concrete domains <ref> [14] </ref>. Roughly speaking, a concrete domain is a domain that is isomorphic to a domain consisting of potentially infinite trees. A sequential algorithm is a function plus a strategy for evaluating its arguments.
Reference: 15. <author> Meyer, A. R. and K. Sieber. </author> <title> Towards a fully abstract semantics for local variables. </title> <booktitle> In Proc. 15th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1988, </year> <pages> 191-203. </pages>
Reference-contexts: Consequently, the conventional model for such functional languages fails to identify p i and p. Essentially the same example can be constructed in any practical deterministic programming language where procedures can be passed as parameters <ref> [15, 22] </ref>. For example, in call-by-value languages, the procedures p i can be rewritten so that the parameter f takes constant procedures as arguments and uses these procedures to simulate call-by-name boolean arguments [22]. Indeed, all commonly used deterministic languages are sequential.
Reference: 16. <author> Milner, R. </author> <title> Fully abstract models of typed -calculi. </title> <journal> Theor. Comput. Sci. </journal> <volume> 4, </volume> <year> 1977, </year> <pages> 1-22. </pages>
Reference-contexts: Practical languages eschew parallel operations like parallel-and because they are painful to implement and encourage hideously inefficient programming. Even deterministic languages for parallel machines like C fl [19] are sequential. 1.1 Summary of Previous Work Milner <ref> [16] </ref> and Plotkin [18] were the first researchers to study the full abstraction problem for sequential languages. They focused on constructing fully abstract models for PCF, a call-by-name functional language based on the typed -calculus. The preceding example shows that the continuous function model for PCF is not fully abstract. <p> Some references [18] in the literature define observational equivalence using a separate operational definition of the language L and prove that models for L are adequate. Our definition of observational equivalence, based on Milner's original definition <ref> [16] </ref>, eliminates the need for two different forms of semantics and a proof of adequacy. Both definitions yield the same notion of observational equivalence.
Reference: 17. <author> Mulmuley, K. </author> <title> Full Abstraction and Semantic Equivalences. </title> <type> Ph.D. dissertation, </type> <institution> Carnegie Mellon University, </institution> <address> 1985. </address> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1986. </year>
Reference-contexts: In addition, PCF cannot express all of the observations that characterize sequential algorithms, such as the order of argument evaluation. As a result, the sequential algorithm model for PCF is not fully abstract. Recently, Mulmuley <ref> [17] </ref> generalized Milner's work by showing how to construct a fully abstract model for PCF as a quotient of a conventional model based on lattices instead of cpos. Mulmuley defined a retraction on the conventional model that equates all parallel functions with the "overdefined" element top (&gt;).
Reference: 18. <author> Plotkin, G.D. </author> <title> LCF considered as a programming language. </title> <journal> Theor. Comput. Sci. </journal> <volume> 5, </volume> <year> 1977, </year> <pages> 223-255. </pages>
Reference-contexts: Practical languages eschew parallel operations like parallel-and because they are painful to implement and encourage hideously inefficient programming. Even deterministic languages for parallel machines like C fl [19] are sequential. 1.1 Summary of Previous Work Milner [16] and Plotkin <ref> [18] </ref> were the first researchers to study the full abstraction problem for sequential languages. They focused on constructing fully abstract models for PCF, a call-by-name functional language based on the typed -calculus. The preceding example shows that the continuous function model for PCF is not fully abstract. <p> The same definitions adapt in the obvious way to combinatory terms in L. Observational equivalence depends only on the meanings of programs. Hence, it is independent of the choice of model as long as models agree on the meanings of programs. Some references <ref> [18] </ref> in the literature define observational equivalence using a separate operational definition of the language L and prove that models for L are adequate. Our definition of observational equivalence, based on Milner's original definition [16], eliminates the need for two different forms of semantics and a proof of adequacy. <p> In summary, call=cc d and catch are equally expressive in SPCF. We selected catch as the primitive operation for SPCF for purely technical reasons. Indeed, it is much simpler to program with call=cc d . End of Note. 5 The Full Abstraction Theorem Plotkin <ref> [18] </ref> showed that an extensional model of PCF with parallel operations is fully abstract if the language can define all finite elements in the model. Exactly the same argument applies to SPCF.
Reference: 19. <author> Rose, J.R. and G.L. Steele Jr. </author> <title> C*: An extended C language for data parallel programming. </title> <booktitle> In Proc. Second International Conference on Supercomputing. International Supercomputing Institute, </booktitle> <publisher> Inc. </publisher> <address> (Santa Clara, </address> <booktitle> 1987) Volume II, </booktitle> <pages> 2-16. </pages> <note> Also available as: Technical Report No. </note> <institution> PL87-5, Thinking Machines Corporation, </institution> <year> 1987. </year>
Reference-contexts: In informal terms, a language is sequential if it can be implemented without time-slicing among multiple threads of control. Practical languages eschew parallel operations like parallel-and because they are painful to implement and encourage hideously inefficient programming. Even deterministic languages for parallel machines like C fl <ref> [19] </ref> are sequential. 1.1 Summary of Previous Work Milner [16] and Plotkin [18] were the first researchers to study the full abstraction problem for sequential languages. They focused on constructing fully abstract models for PCF, a call-by-name functional language based on the typed -calculus.
Reference: 20. <author> Scott, D. S. </author> <title> Domains for denotational semantics. </title> <booktitle> In Proc. International Conference on on Automata, Languages, and Programming, Lecture Notes in Mathematics 140, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1982, </year> ??-??. 
Reference-contexts: In the third and fourth subsections, we assign interpretations to the primitive constants and the combinators of SPCF, and prove the basic equational properties of the tree model. 4.1 Tree Domains A Scott domain is the ideal completion of a finitary basis <ref> [7, 20] </ref>. A finitary basis B is a countable, partially ordered set such that every finite, bounded subset has a least upper bound. The domain D B determined by B is the set of ideals over B; the principal ideals of 16 R. Cartwright, M.
Reference: 21. <author> Scott, </author> <title> D.S. Lectures on a Mathematical Theory of Computation. </title> <type> Techn. Monograph PRG-19, </type> <institution> Oxford University Computing Laboratory, Programming Research Group, </institution> <year> 1981. </year>
Reference: 22. <author> Sitaram, D. and M. Felleisen. </author> <title> Reasoning with continuations II: Full abstraction for models of control. </title> <booktitle> In Proc. 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <year> 1990, </year> <pages> 161-175. </pages>
Reference-contexts: Consequently, the conventional model for such functional languages fails to identify p i and p. Essentially the same example can be constructed in any practical deterministic programming language where procedures can be passed as parameters <ref> [15, 22] </ref>. For example, in call-by-value languages, the procedures p i can be rewritten so that the parameter f takes constant procedures as arguments and uses these procedures to simulate call-by-name boolean arguments [22]. Indeed, all commonly used deterministic languages are sequential. <p> For example, in call-by-value languages, the procedures p i can be rewritten so that the parameter f takes constant procedures as arguments and uses these procedures to simulate call-by-name boolean arguments <ref> [22] </ref>. Indeed, all commonly used deterministic languages are sequential. In informal terms, a language is sequential if it can be implemented without time-slicing among multiple threads of control. Practical languages eschew parallel operations like parallel-and because they are painful to implement and encourage hideously inefficient programming. <p> Consequently, a program cannot determine the order of evaluation among the arguments in a procedure application. To express these computations, the program must be able to delimit the dynamic extent of control actions such as errors <ref> [22] </ref>. For this reason, many practical languages include an error handling facility or a non-local control operator. The original version of Scheme [24], for example, contained a lexically-scoped CATCH construct for implementing non-local exits from expressions. <p> Conventional models for languages like SPCF are written in "continuation-passing style" to cope with the behavior of control operators. Since this form of model contains parallel functions, it is not fully abstract for sequential languages <ref> [22] </ref>. To construct a fully abstract model for SPCF, we want to develop a "direct" semantics that interprets procedures as functions. The informal operational semantics of SPCF, notably the catch t operator, suggests that procedure denotations should have more internal structure than function graphs. <p> Languages with control delimiters are designed not to be error-sensitive because the very task of control delimiters is to swallow all errors generated within their dynamic extent. Observable Sequentiality and Full Abstraction 51 Consider the following example. Let PCF 0 be PCF augmented by the control delim iter % <ref> [22] </ref> where % is defined by the equation [[(% e)]] = [[e]] [[e]] 2 N ? i [[e]] = error i 2 E : In PCF 0 , we can define an error-insensitive addition function: + ei = (xy : (+ l (% x) (% y))) = (xy : (+ r
Reference: 23. <author> Steele, G.L., Jr. </author> <title> Common Lisp|The Language. </title> <publisher> Digital Press, </publisher> <year> 1984. </year> <note> 66 R. Cartwright, M. Felleisen </note>
Reference: 24. <author> Steele, G.L., Jr. and G.J. Sussman. </author> <title> The revised report on Scheme, a dialect of Lisp. Memo 452, </title> <publisher> MIT AI-Lab, </publisher> <year> 1978. </year>
Reference-contexts: To express these computations, the program must be able to delimit the dynamic extent of control actions such as errors [22]. For this reason, many practical languages include an error handling facility or a non-local control operator. The original version of Scheme <ref> [24] </ref>, for example, contained a lexically-scoped CATCH construct for implementing non-local exits from expressions.
Reference: 25. <author> Stoughton, A. </author> <title> Fully Abstract Models of Programming Languages. </title> <booktitle> Research Notes in Theoretical Computer Science. </booktitle> <address> Piman, London. </address> <year> 1986. </year>
Reference-contexts: However, like Milner's original fully abstract model, Mulmuley's model is "syntactic" in flavor because it relies on a quotient construction based on observational equivalence. For more details on the history of the full abstraction problem for sequential languages, we refer the reader to two extensive surveys <ref> [6, 25] </ref>. 1.2 Summary of Results Fifteen years after Milner's and Plotkin's original work, the fundamental question still remains: Are there fully abstract denotational models for sequential programming lan guages? In this paper, we answer the question affirmatively by showing how to construct a fully abstract denotational model for an observably
Reference: 26. <author> Vuillemin, J. </author> <title> Proof techniques for recursive programs. </title> <type> IRIA Report. </type> <year> 1973. </year>
Reference-contexts: This definition is based on Vuillemin's definition <ref> [26] </ref> of sequentiality for first order functions and Berry's generalization [2] of Vuillemin's definition to higher types.
References-found: 26

