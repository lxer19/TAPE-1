URL: http://www.cs.ucsd.edu/users/mihir/papers/ro.ps.gz
Refering-URL: http://www.cs.ucsd.edu/users/mihir/papers/ro.html
Root-URL: http://www.cs.ucsd.edu
Email: E-mail: mihir@cs.ucsd.edu  E-mail: rogaway@cs.davis.edu  
Title: Random Oracles are Practical: A Paradigm for Designing Efficient Protocols  
Author: Mihir Bellare Phillip Rogaway 
Address: San Diego, 9500 Gilman Drive, La Jolla, CA 92093.  CA 95616, USA.  
Affiliation: Department of Computer Science Engineering, Mail Code 0114, University of California at  Department of Computer Science, University of California at Davis, Davis,  
Date: November 1993.  October 20, 1995  
Note: Appears in the proceedings of the First ACM Conference on Computer and Communications Se- curity, ACM,  
Abstract: We argue that the random oracle model |where all parties have access to a public random oracle| provides a bridge between cryptographic theory and cryptographic practice. In the paradigm we suggest, a practical protocol P is produced by first devising and proving correct a protocol P R for the random oracle model, and then replacing oracle accesses by the computation of an "appropriately chosen" function h. This paradigm yields protocols much more efficient than standard ones while retaining many of the advantages of provable security. We illustrate these gains for problems including encryption, signatures, and zero-knowledge proofs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Beaver, S. Micali and P. Rogaway, </author> <title> "The round complexity of secure protocols," </title> <booktitle> Proceedings of the 22nd Annual Symposium on Theory of Computing, ACM, </booktitle> <year> 1990. </year>
Reference-contexts: Thus the applicability of the paradigm is restricted to protocols in which the adversary is denied access to the random 2 Personal communication, via S. Micali and S. Rudich. 3 In this application it does not suffice to replace the pseudorandom generator used in <ref> [1] </ref> by a random generator. 4 oracle. 4 Thus in many applications (and the ones of this paper in particular) PRFs don't suffice.
Reference: [2] <author> M. Bellare and S. Micali, </author> <title> "How to sign given any trapdoor permutation," </title> <journal> JACM Vol. </journal> <volume> 39, No. 1, </volume> <pages> 214-233, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: Verification is defined in the obvious way. Another alternative for these functions is apply the construction of <ref> [2, Section 4.2] </ref> to make them uniform. The squaring functions defined in [42, 3] don't have efficiently testable domains but various patches can nonetheless be made. In fact it isn't even necessary for the function to be a permutation; Rabin's squaring function [35] can be patched to work too. Security.
Reference: [3] <author> L. Blum, M. Blum and M. Shub, </author> <title> "A simple unpredictable pseudo-random number generator," </title> <journal> SIAM Journal on Computing Vol. </journal> <volume> 15, No. 2, </volume> <pages> 364-383, </pages> <month> May </month> <year> 1986. </year>
Reference-contexts: For a concrete implantation, f might be squaring <ref> [42, 3] </ref> or RSA [38]. <p> As mentioned before, squaring modulo an appropriate composite number <ref> [42, 3] </ref>, variations of it [26], or RSA [38] are good examples of trapdoor permutations. <p> Verification is defined in the obvious way. Another alternative for these functions is apply the construction of [2, Section 4.2] to make them uniform. The squaring functions defined in <ref> [42, 3] </ref> don't have efficiently testable domains but various patches can nonetheless be made. In fact it isn't even necessary for the function to be a permutation; Rabin's squaring function [35] can be patched to work too. Security.
Reference: [4] <author> M. Blum and S. Goldwasser, </author> <title> "An efficient probabilistic public-key encryption scheme which hides all partial information," </title> <booktitle> Advances in Cryptology - Crypto 84 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 196, </volume> <editor> R. Blakely ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: but, briefly, what is argued there is the following: the first scheme achieves polynomial/semantic security as defined by [24]; the second is secure against chosen-ciphertext attack in the sense of [36] as well as non-malleable in the sense of [13]; and both are significantly more efficient than previous provably-secure schemes <ref> [24, 4, 34, 36, 11, 13] </ref> for the same goals. Justification Of Known Heuristics. <p> This yields an encryption of length O (k jxj), which requires O (jxj) evaluations of f to encrypt and O (jxj) evaluations of f 1 to decrypt, which is not practical. A more efficient construction of Blum and Goldwasser <ref> [4] </ref> yields encryptions of size O (jxj + k) requiring O (jxj) modular squarings operations to encrypt and O (1) modular exponentiations plus O (jxj) modular squaring to decrypt, which is still expensive. <p> Besides hashing of negligible cost, encryption needs one application of f and decryption needs one application of f 1 . Setting f to squaring this means one modular squaring to encrypt and one modular exponentiation to decrypt. This is much more efficient than the scheme of <ref> [4] </ref> discussed above. 7 3.2 Chosen Ciphertext Security Background. Naor and Yung [34] provided a definition of chosen ciphertext security and the first scheme to provably achieve it. Rackoff and Simon [36] suggested a stronger notion and a corresponding solution; another solution was given by De Santis and Persiano [11].
Reference: [5] <author> M. Blum and S. Micali, </author> <title> "How to generate cryptographically strong sequences of pseudorandom bits," </title> <journal> SIAM Journal on Computing, </journal> <volume> Vol. 13, No. 4, </volume> <pages> 850-864, </pages> <month> November </month> <year> 1984. </year>
Reference-contexts: The "basic" security goal of public key encryption finds its formalization in Gold-wasser and Micali's (equivalent) notions of polynomial and semantic security [24]. If B f denotes a hard core predicate for f (cf. <ref> [5, 43, 23] </ref>) then security in the sense of [24] can be achieved by setting E (x) = f (r 1 ) k : : : k f (r jxj ) where each r i is randomly chosen from the domain of f with the restriction that B f (r i
Reference: [6] <author> M. Blum, P. Feldman and S. Micali, </author> <title> "Non-interactive zero knowledge and its applications," </title> <booktitle> Proceedings of the 20th Annual Symposium on Theory of Computing, ACM, </booktitle> <year> 1988. </year>
Reference-contexts: Rackoff and Simon [36] suggested a stronger notion and a corresponding solution; another solution was given by De Santis and Persiano [11]. The last two exploit proofs of knowledge, as suggested earlier by <ref> [17, 6] </ref>. All known schemes provably secure under standard assumptions rely on non-interactive zero-knowledge proofs [7, 16] and are prohibitively inefficient. <p> What follows extends the formulation in the usual interactive setting [25] as well as the formulation in the common random string model <ref> [6, 7] </ref>. Setting. For simplicity we discuss proofs for a language L 2 NP. Fix a NP relation defining L; a witness for the membership of x in L means a string w satisfying (x; w) = 1. <p> Since the random oracle is part of the view, it must also be part of the output of the simulator; i.e. the simulator is allowed to construct a "simulation" of the oracle. This is analogous to non-interactive zero-knowledge <ref> [6, 7] </ref> where the simulator is allowed to construct and output a "simulation" of the common random string. However, the random oracle is an infinite object, and so we can't ask the simulator to output it.
Reference: [7] <author> M. Blum, A. De Santis, S. Micali and G. Persiano, </author> <title> "Non-interactive zero-knowledge proof systems," </title> <journal> SIAM Journal on Computing, </journal> <volume> 20(4), </volume> <month> 1084-1118 (December </month> <year> 1991). </year>
Reference-contexts: Rackoff and Simon [36] suggested a stronger notion and a corresponding solution; another solution was given by De Santis and Persiano [11]. The last two exploit proofs of knowledge, as suggested earlier by [17, 6]. All known schemes provably secure under standard assumptions rely on non-interactive zero-knowledge proofs <ref> [7, 16] </ref> and are prohibitively inefficient. Damg-ard [10] suggests an efficient scheme to achieve the definition of [34], but this scheme is not proven to achieve the definition of [34] and it does not achieve the one of [36] which we are interested in. <p> What follows extends the formulation in the usual interactive setting [25] as well as the formulation in the common random string model <ref> [6, 7] </ref>. Setting. For simplicity we discuss proofs for a language L 2 NP. Fix a NP relation defining L; a witness for the membership of x in L means a string w satisfying (x; w) = 1. <p> Since the random oracle is part of the view, it must also be part of the output of the simulator; i.e. the simulator is allowed to construct a "simulation" of the oracle. This is analogous to non-interactive zero-knowledge <ref> [6, 7] </ref> where the simulator is allowed to construct and output a "simulation" of the common random string. However, the random oracle is an infinite object, and so we can't ask the simulator to output it.
Reference: [8] <author> B. den Boer and A. Bosselaers, </author> <title> "Collisions for the compression function of MD5," </title> <booktitle> Advances in Cryptology - Eurocrypt 93 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 765, </volume> <editor> T. Helleseth ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Trying to overcome difficulties by avoiding a "structured" operation like MD5, one might prefer a "lower level" primitive such as its compression function, : f0; 1g 640 ! f0; 1g 128 . This too does not make a suitable replacement for a random oracle, as <ref> [8] </ref> has demonstrated that collisions can be efficiently found in this map.
Reference: [9] <author> G. Brassard, D. Chaum and C. Cr epeau, </author> <title> "Minimum disclosure proofs of knowledge," </title> <journal> JCSS Vol. </journal> <volume> 37, No. 2, </volume> <pages> 156-189, </pages> <month> October </month> <year> 1988. </year> <month> 14 </month>
Reference-contexts: But at time of instantiation with hash functions running time should be restricted anyway so we make the assumption straight away. Thus we are in the "argument" model of <ref> [9] </ref>. 10 denote the probability that V accepts in an interaction with P a on common input x. In proofs and protocols we'll often abuse notation and work only with whatever prefixes of the infinite string r are relevant. Proof Systems.
Reference: [10] <author> I. Damg -ard, </author> <title> "Towards practical public key cryptosystems secure against chosen ciphertext attacks," </title> <booktitle> Advances in Cryptology - Crypto 91 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 576, </volume> <editor> J. Feigenbaum ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: The last two exploit proofs of knowledge, as suggested earlier by [17, 6]. All known schemes provably secure under standard assumptions rely on non-interactive zero-knowledge proofs [7, 16] and are prohibitively inefficient. Damg-ard <ref> [10] </ref> suggests an efficient scheme to achieve the definition of [34], but this scheme is not proven to achieve the definition of [34] and it does not achieve the one of [36] which we are interested in.
Reference: [11] <author> A. De Santis and G. </author> <title> Persiano, </title> <booktitle> "Zero-knowledge proofs of knowledge without interaction" Proceedings of the 33rd Symposium on Foundations of Computer Science, IEEE, </booktitle> <year> 1992. </year>
Reference-contexts: but, briefly, what is argued there is the following: the first scheme achieves polynomial/semantic security as defined by [24]; the second is secure against chosen-ciphertext attack in the sense of [36] as well as non-malleable in the sense of [13]; and both are significantly more efficient than previous provably-secure schemes <ref> [24, 4, 34, 36, 11, 13] </ref> for the same goals. Justification Of Known Heuristics. <p> Naor and Yung [34] provided a definition of chosen ciphertext security and the first scheme to provably achieve it. Rackoff and Simon [36] suggested a stronger notion and a corresponding solution; another solution was given by De Santis and Persiano <ref> [11] </ref>. The last two exploit proofs of knowledge, as suggested earlier by [17, 6]. All known schemes provably secure under standard assumptions rely on non-interactive zero-knowledge proofs [7, 16] and are prohibitively inefficient.
Reference: [12] <author> W. Diffie and M. E. Hellman, </author> <title> "New directions in cryptography," </title> <journal> IEEE Trans. Info. Theory IT-22, </journal> <month> 644-654 (November </month> <year> 1976). </year>
Reference-contexts: For simplicity we consider adversaries who are nonuniform (polynomial time) algorithms, possibly probabilistic; extensions to the uniform case can be made following [18]. Encryption. We extend the notion of public key encryption <ref> [12] </ref> to the random oracle model.
Reference: [13] <author> D. Dolev, C. Dwork and M. Naor, </author> <title> "Non-malleable cryptography," </title> <booktitle> Proceedings of the 23rd Annual Symposium on Theory of Computing, ACM, </booktitle> <year> 1991. </year>
Reference-contexts: of results, and efficiency comparisons with known schemes see Section 3, but, briefly, what is argued there is the following: the first scheme achieves polynomial/semantic security as defined by [24]; the second is secure against chosen-ciphertext attack in the sense of [36] as well as non-malleable in the sense of <ref> [13] </ref>; and both are significantly more efficient than previous provably-secure schemes [24, 4, 34, 36, 11, 13] for the same goals. Justification Of Known Heuristics. <p> but, briefly, what is argued there is the following: the first scheme achieves polynomial/semantic security as defined by [24]; the second is secure against chosen-ciphertext attack in the sense of [36] as well as non-malleable in the sense of [13]; and both are significantly more efficient than previous provably-secure schemes <ref> [24, 4, 34, 36, 11, 13] </ref> for the same goals. Justification Of Known Heuristics. <p> Call a trapdoor permutation generator G fl uniform if for all k and all (f; f 1 ; d) 2 [G (1 k )] it is the case that d is the uniform distribution on f0; 1g k . 3 Encryption We have relied on definitional work in <ref> [24, 33, 19, 18, 34, 13] </ref>. For simplicity we consider adversaries who are nonuniform (polynomial time) algorithms, possibly probabilistic; extensions to the uniform case can be made following [18]. Encryption. We extend the notion of public key encryption [12] to the random oracle model. <p> This scheme is as efficient as ours, and we believe it has the same security properties. Thus, the random oracle model serves to justify the construction of [44]. 3.3 Non-Malleability Background. The notion of non-malleability was introduced by Dolev, Dwork and Naor <ref> [13] </ref>. Informally, an encryption scheme is non-malleable if you cannot, by witnessing an encryption of a 8 string x, produce the encryption of a related string x 0 . For example, given the encryption of x you shouldn't be able to produce the encryption of x. <p> For example, given the encryption of x you shouldn't be able to produce the encryption of x. The notion extends polynomial security, and in particular the latter is implied by the former. A construction of non-malleable schemes is given in <ref> [13] </ref>. However, this construction is completely impractical, involving huge public keys, computation of multiple signatures, and many non-interactive zero knowledge proofs. Definition. We adapt to the random oracle setting the definition of [13]. <p> A construction of non-malleable schemes is given in <ref> [13] </ref>. However, this construction is completely impractical, involving huge public keys, computation of multiple signatures, and many non-interactive zero knowledge proofs. Definition. We adapt to the random oracle setting the definition of [13]. <p> fl (k)j is negligible, where "(k) = Pr [ R 2 1 ; (E; D) G (1 k ); F R (E); x R (1 k ); E; (x; D R (ff 0 )) = 1 ] ff 0 fl (E; ) : R fl )) = 1 ] See <ref> [13] </ref> for explanations on the intuition underlying this definition, including the restriction on the relation . Encryption by E (x) = f (r) k G (r) x k H (rx). The encryption scheme is the same as that of the previous section. Theorem.
Reference: [14] <author> A. Fiat and A. Shamir, </author> <title> "How to prove yourself: practical solutions to identification and signature problems," </title> <booktitle> Advances in Cryptology - Crypto 86 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 263, </volume> <editor> A. Odlyzko ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference-contexts: It is a thesis of this paper that significant assurance benefits nonetheless remain. The idea of such a paradigm builds on work of Goldreich, Goldwasser and Micali [20, 21] and Fiat-Shamir <ref> [14] </ref>. It is guided by many previous "unjustified" uses of hash functions. Finally, it incorporates viewpoints which, shared and verbally articulated by many members of our community, should be regarded as folklore. In this light, we view our contribution as follows. <p> The first work which explicitly adopts a public random oracle model |all parties, adversary included, can access the oracle| is that of Fiat and Shamir <ref> [14] </ref>. The authors use this model to turn an identification scheme into a digital signature scheme (without "totally" sacrificing rigor in the course of this transformation). M. Blum's aforementioned idea of making interactive proofs non-interactive can be thought of as an extension of the Fiat-Shamir idea.
Reference: [15] <author> U. Feige, A. Fiat and A. Shamir, </author> <title> "Zero knowledge proofs of identity," </title> <journal> Journal of Cryptology, </journal> <volume> Vol. 1, </volume> <pages> pp. </pages> <month> 77-94 </month> <year> (1987). </year>
Reference: [16] <author> U. Feige, D. Lapidot, and A. Shamir, </author> <title> "Multiple non-interactive zero-knowledge proofs based on a single random string," </title> <booktitle> Proceedings of the 31st Symposium on Foundations of Computer Science, IEEE, </booktitle> <year> 1990. </year>
Reference-contexts: Rackoff and Simon [36] suggested a stronger notion and a corresponding solution; another solution was given by De Santis and Persiano [11]. The last two exploit proofs of knowledge, as suggested earlier by [17, 6]. All known schemes provably secure under standard assumptions rely on non-interactive zero-knowledge proofs <ref> [7, 16] </ref> and are prohibitively inefficient. Damg-ard [10] suggests an efficient scheme to achieve the definition of [34], but this scheme is not proven to achieve the definition of [34] and it does not achieve the one of [36] which we are interested in.
Reference: [17] <author> Z. Galil, S. Haber and M. Yung, </author> <title> "Symmetric public key cryptosystems," </title> <type> manuscript, </type> <month> July </month> <year> 1989. </year>
Reference-contexts: Rackoff and Simon [36] suggested a stronger notion and a corresponding solution; another solution was given by De Santis and Persiano [11]. The last two exploit proofs of knowledge, as suggested earlier by <ref> [17, 6] </ref>. All known schemes provably secure under standard assumptions rely on non-interactive zero-knowledge proofs [7, 16] and are prohibitively inefficient.
Reference: [18] <author> O. Goldreich, </author> <title> "A uniform complexity treatment of encryption and zero-knowledge," </title> <journal> Journal of Cryptology, </journal> <volume> Vol. 6, </volume> <pages> pp. </pages> <month> 21-53 </month> <year> (1993). </year>
Reference-contexts: Call a trapdoor permutation generator G fl uniform if for all k and all (f; f 1 ; d) 2 [G (1 k )] it is the case that d is the uniform distribution on f0; 1g k . 3 Encryption We have relied on definitional work in <ref> [24, 33, 19, 18, 34, 13] </ref>. For simplicity we consider adversaries who are nonuniform (polynomial time) algorithms, possibly probabilistic; extensions to the uniform case can be made following [18]. Encryption. We extend the notion of public key encryption [12] to the random oracle model. <p> For simplicity we consider adversaries who are nonuniform (polynomial time) algorithms, possibly probabilistic; extensions to the uniform case can be made following <ref> [18] </ref>. Encryption. We extend the notion of public key encryption [12] to the random oracle model.
Reference: [19] <author> O. Goldreich, </author> <booktitle> "Foundations of cryptography," Class notes, </booktitle> <month> Spring </month> <year> 1989, </year> <institution> Technion University. </institution>
Reference-contexts: Call a trapdoor permutation generator G fl uniform if for all k and all (f; f 1 ; d) 2 [G (1 k )] it is the case that d is the uniform distribution on f0; 1g k . 3 Encryption We have relied on definitional work in <ref> [24, 33, 19, 18, 34, 13] </ref>. For simplicity we consider adversaries who are nonuniform (polynomial time) algorithms, possibly probabilistic; extensions to the uniform case can be made following [18]. Encryption. We extend the notion of public key encryption [12] to the random oracle model.
Reference: [20] <author> O. Goldreich, S. Goldwasser and S. Micali, </author> <title> "How to construct random functions," </title> <journal> Journal of the ACM, </journal> <volume> Vol. 33, No. 4, </volume> <pages> 210-217, </pages> <year> (1986). </year>
Reference-contexts: We stress that the proof is in the random oracle model and the last step is heuristic in nature. It is a thesis of this paper that significant assurance benefits nonetheless remain. The idea of such a paradigm builds on work of Goldreich, Goldwasser and Micali <ref> [20, 21] </ref> and Fiat-Shamir [14]. It is guided by many previous "unjustified" uses of hash functions. Finally, it incorporates viewpoints which, shared and verbally articulated by many members of our community, should be regarded as folklore. In this light, we view our contribution as follows. <p> is possible. 3 Definitions and proofs of these results are omitted for lack of space. 1.3 Background and Related Work The basic idea of proving correct a protocol in a model where the parties have a random oracle and then instantiating that oracle with an appropriate cryptographic primitive originates in <ref> [20, 21] </ref>. The cryptographic primitive suggested and constructed for this purpose by [20] is the pseudo-random function (PRF). For a PRF to retain its properties, however, the seed via which it is specified (and which enables its computation) must remain unknown to the adversary. <p> The cryptographic primitive suggested and constructed for this purpose by <ref> [20] </ref> is the pseudo-random function (PRF). For a PRF to retain its properties, however, the seed via which it is specified (and which enables its computation) must remain unknown to the adversary. <p> A typical theorem would express the advantage an adversary gains in terms of the number of oracle queries which she makes. We know no complexity-theoretic assumption which does a good job of capturing all the nice properties of a public random oracle. Is there a way to extend the <ref> [20] </ref> notion of a pseudorandom function family to an equally useful and compelling notion which involves no hidden randomness? 2 Preliminaries Notation. f0; 1g fl denotes the space of finite binary strings and f0; 1g 1 denotes the space of infinite ones. Strings are finite unless we say otherwise.
Reference: [21] <author> O. Goldreich, S. Goldwasser and S. Micali, </author> <title> "On the cryptographic applications of random functions," </title> <booktitle> Advances in Cryptology - Crypto 84 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 196, </volume> <editor> R. Blakely ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: We stress that the proof is in the random oracle model and the last step is heuristic in nature. It is a thesis of this paper that significant assurance benefits nonetheless remain. The idea of such a paradigm builds on work of Goldreich, Goldwasser and Micali <ref> [20, 21] </ref> and Fiat-Shamir [14]. It is guided by many previous "unjustified" uses of hash functions. Finally, it incorporates viewpoints which, shared and verbally articulated by many members of our community, should be regarded as folklore. In this light, we view our contribution as follows. <p> is possible. 3 Definitions and proofs of these results are omitted for lack of space. 1.3 Background and Related Work The basic idea of proving correct a protocol in a model where the parties have a random oracle and then instantiating that oracle with an appropriate cryptographic primitive originates in <ref> [20, 21] </ref>. The cryptographic primitive suggested and constructed for this purpose by [20] is the pseudo-random function (PRF). For a PRF to retain its properties, however, the seed via which it is specified (and which enables its computation) must remain unknown to the adversary.
Reference: [22] <author> O. Goldreich and H. Krawczyk, </author> <title> "On the composition of zero knowledge proof systems," </title> <booktitle> ICALP 90 Proceedings, Lecture Notes in Computer Science Vol. 443 , M. </booktitle> <editor> Paterson ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Comment. Consider the protocol resulting from instantiating the random oracle in the above with a hash function. It is in the standard (random oracle devoid) model, but note we are not claiming it is ZK in the usual sense. Indeed the result of Goldreich and Krawczyk <ref> [22] </ref> indicates that it is unlikely to be ZK in the usual sense: they show that assuming NP is not in BPP, at least four moves are necessary to give a (black box simulatable, computational) ZK, negligible error proof for an NP-complete language in the standard model. 12 6 Instantiation Expanding
Reference: [23] <author> O. Goldreich and L. Levin, </author> <title> "A hard predicate for all one-way functions," </title> <booktitle> Proceedings of the 21st Annual Symposium on Theory of Computing, ACM, </booktitle> <year> 1989. </year>
Reference-contexts: The "basic" security goal of public key encryption finds its formalization in Gold-wasser and Micali's (equivalent) notions of polynomial and semantic security [24]. If B f denotes a hard core predicate for f (cf. <ref> [5, 43, 23] </ref>) then security in the sense of [24] can be achieved by setting E (x) = f (r 1 ) k : : : k f (r jxj ) where each r i is randomly chosen from the domain of f with the restriction that B f (r i
Reference: [24] <author> S. Goldwasser and S. Micali, </author> <title> "Probabilistic encryption," </title> <journal> J. of Computer and System Sciences 28, </journal> <pages> 270-299, </pages> <month> April </month> <year> 1984. </year>
Reference-contexts: For background, definitions, precise statements of results, and efficiency comparisons with known schemes see Section 3, but, briefly, what is argued there is the following: the first scheme achieves polynomial/semantic security as defined by <ref> [24] </ref>; the second is secure against chosen-ciphertext attack in the sense of [36] as well as non-malleable in the sense of [13]; and both are significantly more efficient than previous provably-secure schemes [24, 4, 34, 36, 11, 13] for the same goals. Justification Of Known Heuristics. <p> but, briefly, what is argued there is the following: the first scheme achieves polynomial/semantic security as defined by [24]; the second is secure against chosen-ciphertext attack in the sense of [36] as well as non-malleable in the sense of [13]; and both are significantly more efficient than previous provably-secure schemes <ref> [24, 4, 34, 36, 11, 13] </ref> for the same goals. Justification Of Known Heuristics. <p> Call a trapdoor permutation generator G fl uniform if for all k and all (f; f 1 ; d) 2 [G (1 k )] it is the case that d is the uniform distribution on f0; 1g k . 3 Encryption We have relied on definitional work in <ref> [24, 33, 19, 18, 34, 13] </ref>. For simplicity we consider adversaries who are nonuniform (polynomial time) algorithms, possibly probabilistic; extensions to the uniform case can be made following [18]. Encryption. We extend the notion of public key encryption [12] to the random oracle model. <p> The "basic" security goal of public key encryption finds its formalization in Gold-wasser and Micali's (equivalent) notions of polynomial and semantic security <ref> [24] </ref>. If B f denotes a hard core predicate for f (cf. [5, 43, 23]) then security in the sense of [24] can be achieved by setting E (x) = f (r 1 ) k : : : k f (r jxj ) where each r i is randomly chosen from <p> The "basic" security goal of public key encryption finds its formalization in Gold-wasser and Micali's (equivalent) notions of polynomial and semantic security <ref> [24] </ref>. If B f denotes a hard core predicate for f (cf. [5, 43, 23]) then security in the sense of [24] can be achieved by setting E (x) = f (r 1 ) k : : : k f (r jxj ) where each r i is randomly chosen from the domain of f with the restriction that B f (r i ) = x i . <p> For example, this is exactly what [39] specifies. The embeddings used in practice usually do not guarantee that x is as hard to find as r x , let alone that all properties of x are hidden. Definition. We adapt the notion of polynomial security <ref> [24] </ref> to the random oracle model. (A similarly-extended notion for semantic security remains equivalent.) A CP-adversary (chosen-plaintext adversary) A is a pair of nonuniform polynomial time algorithms (F; A 1 ), each with access to an oracle.
Reference: [25] <author> S. Goldwasser, S. Micali and C. Rackoff, </author> <title> "The knowledge complexity of interactive proof systems," </title> <journal> SIAM J. of Comp., </journal> <volume> Vol. 18, No. 1, </volume> <pages> pp. 186-208, </pages> <month> February </month> <year> 1989. </year> <month> 15 </month>
Reference-contexts: The transformation is efficient, so that we get non-interactive ZK proofs of complexity equal to interactive ZK ones. 5.1 Definitions Definitions for zero-knowledge in the random oracle model involve a little more than simply "rela-tivizing" the standard ones. What follows extends the formulation in the usual interactive setting <ref> [25] </ref> as well as the formulation in the common random string model [6, 7]. Setting. For simplicity we discuss proofs for a language L 2 NP. Fix a NP relation defining L; a witness for the membership of x in L means a string w satisfying (x; w) = 1.
Reference: [26] <author> S. Goldwasser, S. Micali and R. Rivest, </author> <title> "A digital signature scheme secure against adaptive chosen-message attacks," </title> <journal> SIAM Journal of Computing, </journal> <volume> 17(2) </volume> <pages> 281-308, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: A particular problem might permit the adversary indirect access to the oracle via her interaction with the good parties. 5 Notation for probabilistic algorithms, spaces and experiments follows <ref> [26] </ref>. If A is a probabilistic algorithm then, for any inputs x; y; : : : the notation A (x; y; : : :) refers to the probability space which to the string assigns the probability that A, on input x; y; : : :, outputs . <p> Let f be a function. We extend this notation of <ref> [26] </ref> to define also probability spaces and algorithms via experiments. For example f x S; y T ; : f (x; y; ) g denotes the probability space which to the string assigns the probability Pr [ x S; y T ; : = f (x; y; ) ] . <p> Via all sorts of natural encodings, a single random oracle R can be used to provide as many independent random oracles as one wants. As usual the oracles provided to an algorithm are indicated by superscripts. Sometimes the oracle is understood and omitted from the notation. Trapdoor Permutations. Following <ref> [26] </ref>, a trapdoor permutation generator is a PPT algorithm G fl which on input 1 k outputs (the encoding of) a triple of algorithms (f; f 1 ; d). The first two are deterministic and the last is probabilistic. <p> As mentioned before, squaring modulo an appropriate composite number [42, 3], variations of it <ref> [26] </ref>, or RSA [38] are good examples of trapdoor permutations. <p> Encryption by E (x) = f (r) k G (r) x k H (rx). The encryption scheme is the same as that of the previous section. Theorem. In Appendix A we show that the above scheme is non-malleable. 4 Signatures Definition. We extend the definitions of <ref> [26] </ref> to the random oracle setting. A digital signature scheme is a triple (G; Sign; Verify) of polynomial time algorithms, called the generator, signing algorithm, and verifying algorithm, respectively. The first two are probabilistic and the last two have access to the random oracle. <p> Uniformity: A Technicality. Standard trapdoor permutations (squaring based or RSA) are not uniform and the scheme must be patched to handle them. There are many ways of patching. RSA, and squaring as defined in <ref> [26] </ref>, have dense domains in which membership can be efficiently tested.
Reference: [27] <author> R. Impagliazzo and S. Rudich, </author> <title> "Limits on the provable consequences of one-way permutations," </title> <booktitle> Proceedings of the 21st Annual Symposium on Theory of Computing, ACM, </booktitle> <year> 1989. </year>
Reference-contexts: M. Blum's aforementioned idea of making interactive proofs non-interactive can be thought of as an extension of the Fiat-Shamir idea. An exciting recent result on computationally bounded checking, due to Micali [32], exploits in part this same technique. Impagliazzo and Rudich <ref> [27] </ref> model one-way functions as random oracles. They do this in order to show that proving the existence of a secret key exchange protocol given a black box one-way function is as hard as separating P from NP.
Reference: [28] <author> T. Leighton and S. Micali, </author> <title> "Provably fast and secure digital signature algorithms based on secure hash functions," </title> <type> Manuscript, </type> <month> March </month> <year> 1993. </year>
Reference-contexts: They also use random oracles for positive results; among these, they formalize and prove the existence of a private key cryptosystem in the random oracle model. Concurrent and independent of our work, Leighton and Micali <ref> [28] </ref> view hash functions as public random oracles to justify the security of a new, efficient signature scheme. They use the random oracle model to define and prove exact, non-asymptotic security. <p> Because of the breadth of topics in this paper, history specific to to a particular goal is summarized in the section that describes that goal. 1.4 Future Directions Brought out in only a limited way in the current work, and fully in <ref> [28] </ref>, is the fact that the random oracle model facilitates giving definitions and results precise in the sense of avoiding complexity theory and asymptotics. It is feasible and desirable to make our results precise in this sense.
Reference: [29] <author> T. Leighton and S. Micali, </author> <title> "New approaches to secret key exchange," </title> <booktitle> Advances in Cryptology - Crypto 93 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 773, </volume> <editor> D. Stinson ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Concurrent and independent of our work, Leighton and Micali [28] view hash functions as public random oracles to justify the security of a new, efficient signature scheme. They use the random oracle model to define and prove exact, non-asymptotic security. In another paper <ref> [29] </ref> the same authors use hash functions viewed as random oracles to give new secret key exchange schemes.
Reference: [30] <author> M. Luby and C. Rackoff, </author> <title> "How to construct pseudorandom permutations from pseudorandom functions," </title> <journal> SIAM J. Computation, </journal> <volume> Vol. 17, No. 2, </volume> <month> April </month> <year> 1988. </year>
Reference-contexts: Theorists view a one-way function as a basic object and build pseudo-random functions from them. But in practice, as indicated by Luby and Rackoff <ref> [30, 31] </ref>, the DES provides a pseudorandom function of 64 bits to 64 bits. Ironically, if one needs a practical protocol for a one-way function, likely one would construct it from DES|thereby reducing the "simple" primitive to the "complex" one.
Reference: [31] <author> M. Luby and C. Rackoff, </author> <title> "A study of password security," </title> <type> manuscript. </type>
Reference-contexts: Theorists view a one-way function as a basic object and build pseudo-random functions from them. But in practice, as indicated by Luby and Rackoff <ref> [30, 31] </ref>, the DES provides a pseudorandom function of 64 bits to 64 bits. Ironically, if one needs a practical protocol for a one-way function, likely one would construct it from DES|thereby reducing the "simple" primitive to the "complex" one.
Reference: [32] <author> S. Micali, </author> <type> "CS proofs," Manuscript. </type>
Reference-contexts: M. Blum's aforementioned idea of making interactive proofs non-interactive can be thought of as an extension of the Fiat-Shamir idea. An exciting recent result on computationally bounded checking, due to Micali <ref> [32] </ref>, exploits in part this same technique. Impagliazzo and Rudich [27] model one-way functions as random oracles. They do this in order to show that proving the existence of a secret key exchange protocol given a black box one-way function is as hard as separating P from NP.
Reference: [33] <author> S. Micali, C. Rackoff and B. Sloan, </author> <title> "The notion of security for probabilistic cryptosys-tems," </title> <journal> SIAM J. of Computing, </journal> <month> April </month> <year> 1988. </year>
Reference-contexts: Call a trapdoor permutation generator G fl uniform if for all k and all (f; f 1 ; d) 2 [G (1 k )] it is the case that d is the uniform distribution on f0; 1g k . 3 Encryption We have relied on definitional work in <ref> [24, 33, 19, 18, 34, 13] </ref>. For simplicity we consider adversaries who are nonuniform (polynomial time) algorithms, possibly probabilistic; extensions to the uniform case can be made following [18]. Encryption. We extend the notion of public key encryption [12] to the random oracle model.
Reference: [34] <author> M. Naor and M. Yung, </author> <title> "Public-key cryptosystems provably secure against chosen cipher-text attacks," </title> <booktitle> Proceedings of the 22nd Annual Symposium on Theory of Computing, ACM, </booktitle> <year> 1990. </year>
Reference-contexts: but, briefly, what is argued there is the following: the first scheme achieves polynomial/semantic security as defined by [24]; the second is secure against chosen-ciphertext attack in the sense of [36] as well as non-malleable in the sense of [13]; and both are significantly more efficient than previous provably-secure schemes <ref> [24, 4, 34, 36, 11, 13] </ref> for the same goals. Justification Of Known Heuristics. <p> Call a trapdoor permutation generator G fl uniform if for all k and all (f; f 1 ; d) 2 [G (1 k )] it is the case that d is the uniform distribution on f0; 1g k . 3 Encryption We have relied on definitional work in <ref> [24, 33, 19, 18, 34, 13] </ref>. For simplicity we consider adversaries who are nonuniform (polynomial time) algorithms, possibly probabilistic; extensions to the uniform case can be made following [18]. Encryption. We extend the notion of public key encryption [12] to the random oracle model. <p> Setting f to squaring this means one modular squaring to encrypt and one modular exponentiation to decrypt. This is much more efficient than the scheme of [4] discussed above. 7 3.2 Chosen Ciphertext Security Background. Naor and Yung <ref> [34] </ref> provided a definition of chosen ciphertext security and the first scheme to provably achieve it. Rackoff and Simon [36] suggested a stronger notion and a corresponding solution; another solution was given by De Santis and Persiano [11]. <p> The last two exploit proofs of knowledge, as suggested earlier by [17, 6]. All known schemes provably secure under standard assumptions rely on non-interactive zero-knowledge proofs [7, 16] and are prohibitively inefficient. Damg-ard [10] suggests an efficient scheme to achieve the definition of <ref> [34] </ref>, but this scheme is not proven to achieve the definition of [34] and it does not achieve the one of [36] which we are interested in. A scheme of Zheng and Seberry [44] closely related to ours will be discussed later. Definition. <p> All known schemes provably secure under standard assumptions rely on non-interactive zero-knowledge proofs [7, 16] and are prohibitively inefficient. Damg-ard [10] suggests an efficient scheme to achieve the definition of <ref> [34] </ref>, but this scheme is not proven to achieve the definition of [34] and it does not achieve the one of [36] which we are interested in. A scheme of Zheng and Seberry [44] closely related to ours will be discussed later. Definition. We adapt the definition of [36] to the random oracle setting.
Reference: [35] <author> M. Rabin, </author> <title> "Digitalized signatures and public-key functions as intractable as factorization," </title> <institution> MIT Laboratory for Computer Science TR-212, </institution> <month> January </month> <year> 1979. </year>
Reference-contexts: The squaring functions defined in [42, 3] don't have efficiently testable domains but various patches can nonetheless be made. In fact it isn't even necessary for the function to be a permutation; Rabin's squaring function <ref> [35] </ref> can be patched to work too. Security.
Reference: [36] <author> C. Rackoff and D. Simon, </author> <title> "Non-interactive zero-knowledge proof of knowledge and chosen ciphertext attack," </title> <booktitle> Advances in Cryptology - Crypto 91 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 576, </volume> <editor> J. Feigenbaum ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: For background, definitions, precise statements of results, and efficiency comparisons with known schemes see Section 3, but, briefly, what is argued there is the following: the first scheme achieves polynomial/semantic security as defined by [24]; the second is secure against chosen-ciphertext attack in the sense of <ref> [36] </ref> as well as non-malleable in the sense of [13]; and both are significantly more efficient than previous provably-secure schemes [24, 4, 34, 36, 11, 13] for the same goals. Justification Of Known Heuristics. <p> but, briefly, what is argued there is the following: the first scheme achieves polynomial/semantic security as defined by [24]; the second is secure against chosen-ciphertext attack in the sense of [36] as well as non-malleable in the sense of [13]; and both are significantly more efficient than previous provably-secure schemes <ref> [24, 4, 34, 36, 11, 13] </ref> for the same goals. Justification Of Known Heuristics. <p> This is much more efficient than the scheme of [4] discussed above. 7 3.2 Chosen Ciphertext Security Background. Naor and Yung [34] provided a definition of chosen ciphertext security and the first scheme to provably achieve it. Rackoff and Simon <ref> [36] </ref> suggested a stronger notion and a corresponding solution; another solution was given by De Santis and Persiano [11]. The last two exploit proofs of knowledge, as suggested earlier by [17, 6]. <p> Damg-ard [10] suggests an efficient scheme to achieve the definition of [34], but this scheme is not proven to achieve the definition of [34] and it does not achieve the one of <ref> [36] </ref> which we are interested in. A scheme of Zheng and Seberry [44] closely related to ours will be discussed later. Definition. We adapt the definition of [36] to the random oracle setting. <p> definition of [34], but this scheme is not proven to achieve the definition of [34] and it does not achieve the one of <ref> [36] </ref> which we are interested in. A scheme of Zheng and Seberry [44] closely related to ours will be discussed later. Definition. We adapt the definition of [36] to the random oracle setting. An RS-adversary ("Rackoff-Simon adversary") A is a pair of nonuniform polynomial time algorithms A = (F; A 1 ), each with access to an oracle R and a black box implementation of D R .
Reference: [37] <author> R. Rivest, </author> <title> "The MD5 message-digest algorithm," IETF Network Working Group, </title> <type> RFC 1321, </type> <month> April </month> <year> 1992. </year>
Reference-contexts: Based on the paragraph above, a pseudorandom function on 64-bit strings is an excellent starting point. As we describe below, it seems reasonable to adopt even more generous assumptions. Powerful Primitives. Let us look at a second efficiently-computable primitive: the map h 2 defined by the MD5 algorithm <ref> [37] </ref> restricted to inputs of length 400, say. 1 One has expectations like these of this function: that it is hard to find an x such that h 2 (x) = x; that it is hard to 1 See Section 6 for why we prefer not to use MD5 itself. 2
Reference: [38] <author> R. Rivest, A. Shamir, and L. Adleman, </author> <title> "A method for obtaining digital signatures and public key cryptosystems," </title> <note> CACM 21 (1978). </note>
Reference-contexts: For a concrete implantation, f might be squaring [42, 3] or RSA <ref> [38] </ref>. <p> As mentioned before, squaring modulo an appropriate composite number [42, 3], variations of it [26], or RSA <ref> [38] </ref> are good examples of trapdoor permutations.
Reference: [39] <author> RSA Data Security, Inc., </author> <title> "PKCS #1: RSA Encryption Standard," </title> <month> June </month> <year> 1991. </year>
Reference-contexts: Practioners often embed the message x into an otherwise random value r x and then set E (x) = f (r x ). For example, this is exactly what <ref> [39] </ref> specifies. The embeddings used in practice usually do not guarantee that x is as hard to find as r x , let alone that all properties of x are hidden. Definition.
Reference: [40] <author> P. Rogaway and B. Blakley, </author> <title> "An asymmetric authentication protocol," </title> <journal> IBM Technical Disclosure Bulletin (1993). </journal>
Reference-contexts: Acknowledgments Early discussions with Bob Blakley on the license server problem <ref> [40] </ref> helped crystalize our idea. We got useful suggestions and references from Oded Goldreich, Birgit Pfitzmann, and Steven Rudich. Finally, thanks to the members of the ACM program committee for all of their comments. Work done while the first author was at the IBM T.J.
Reference: [41] <author> G. Tsudik, </author> <title> "Message authentication with one-way hash functions," </title> <booktitle> IEEE INFOCOM '92. </booktitle>
Reference-contexts: A significant amount of care must be taken in choosing a concrete function h to instantiate an oracle. Let us begin with some examples of some things that don't work. Consider first the map MD5. This function does not make a suitable replacement for a random oracle since <ref> [41] </ref> has observed that for any x there is a y such that for any z, MD5 (xyz) can be easily computed given only jxj, MD5 (x), and z. Structure like this shows up in applications; in particular, [41] points out that this means MD5 (ax) cannot be used as a <p> function does not make a suitable replacement for a random oracle since <ref> [41] </ref> has observed that for any x there is a y such that for any z, MD5 (xyz) can be easily computed given only jxj, MD5 (x), and z. Structure like this shows up in applications; in particular, [41] points out that this means MD5 (ax) cannot be used as a message authentication code of string x under key a.
Reference: [42] <author> H. Williams, </author> <title> "A modification of the RSA public key encryption procedure," </title> <journal> IEEE Transactions on Information Theory, </journal> <volume> Vol. IT-26, No. 6, </volume> <month> November </month> <year> 1980. </year>
Reference-contexts: For a concrete implantation, f might be squaring <ref> [42, 3] </ref> or RSA [38]. <p> As mentioned before, squaring modulo an appropriate composite number <ref> [42, 3] </ref>, variations of it [26], or RSA [38] are good examples of trapdoor permutations. <p> Verification is defined in the obvious way. Another alternative for these functions is apply the construction of [2, Section 4.2] to make them uniform. The squaring functions defined in <ref> [42, 3] </ref> don't have efficiently testable domains but various patches can nonetheless be made. In fact it isn't even necessary for the function to be a permutation; Rabin's squaring function [35] can be patched to work too. Security.
Reference: [43] <author> A. </author> <title> Yao , "Theory and applications of trapdoor functions," </title> <booktitle> Proceedings of the 23rd Symposium on Foundations of Computer Science, IEEE, </booktitle> <year> 1982. </year> <month> 16 </month>
Reference-contexts: The "basic" security goal of public key encryption finds its formalization in Gold-wasser and Micali's (equivalent) notions of polynomial and semantic security [24]. If B f denotes a hard core predicate for f (cf. <ref> [5, 43, 23] </ref>) then security in the sense of [24] can be achieved by setting E (x) = f (r 1 ) k : : : k f (r jxj ) where each r i is randomly chosen from the domain of f with the restriction that B f (r i
Reference: [44] <author> Y. Zheng and J. Seberry, </author> <title> "Practical approaches to attaining security against adaptively chosen ciphertext attacks," </title> <booktitle> Advances in Cryptology - Crypto 92 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 740, </volume> <editor> E. Brickell ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1992. </year> <month> 17 </month>
Reference-contexts: Damg-ard [10] suggests an efficient scheme to achieve the definition of [34], but this scheme is not proven to achieve the definition of [34] and it does not achieve the one of [36] which we are interested in. A scheme of Zheng and Seberry <ref> [44] </ref> closely related to ours will be discussed later. Definition. We adapt the definition of [36] to the random oracle setting. <p> Setting f to squaring this means one modular squaring to encrypt and one modular exponentiation to decrypt. This is more efficient than any of the schemes discussed above. Translated into the random oracle model and our notation, the scheme of Zheng and Seberry <ref> [44] </ref> is E fl (x) = f (r) k (G (r) (xH (x))). This scheme is as efficient as ours, and we believe it has the same security properties. Thus, the random oracle model serves to justify the construction of [44]. 3.3 Non-Malleability Background. <p> model and our notation, the scheme of Zheng and Seberry <ref> [44] </ref> is E fl (x) = f (r) k (G (r) (xH (x))). This scheme is as efficient as ours, and we believe it has the same security properties. Thus, the random oracle model serves to justify the construction of [44]. 3.3 Non-Malleability Background. The notion of non-malleability was introduced by Dolev, Dwork and Naor [13]. Informally, an encryption scheme is non-malleable if you cannot, by witnessing an encryption of a 8 string x, produce the encryption of a related string x 0 .
References-found: 44

