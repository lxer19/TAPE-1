URL: ftp://ftp.cs.utexas.edu/pub/predator/wisr-93-p++.ps
Refering-URL: http://www.cs.utexas.edu/users/schwartz/pub.htm
Root-URL: 
Email: Email: fsinghal,batoryg@cs.utexas.edu  
Phone: Tel: (512) 471-9711/9713  
Title: P++: A Language for Large-Scale Reusable Software Components  
Author: Vivek Singhal and Don Batory 
Keyword: open architectures, program families, large-scale reuse, software system synthesis, GenVoca, software system generators. Working Groups: reuse process models; domain analysis/engineering; design guidelines for reuse; reuse and object-oriented methods; tools and environments.  
Note: Appeared in Proceedings of the Sixth Annual Workshop on Software Reuse, Owego, New York, November 1993.  
Address: Austin, Texas 78712  
Affiliation: Department of Computer Sciences The University of Texas at Austin  
Abstract: P++ is a programming language that supports the GenVoca model [BO92], a particular style of software design that is intended for building software system generators. P++ is an enhanced version of C++: it offers linguistic extensions for component encapsulation, abstraction, parameterization, and inheritance, where a component is a subsystem, i.e., a suite of interrelated classes and functions. Workshop Goals: feedback on our research; exposure to other work in software reuse. 
Abstract-found: 1
Intro-found: 1
Reference: [Bat88] <author> Don Batory. </author> <title> Concepts for a DBMS synthesizer. </title> <booktitle> In Proceedings of ACM Principles of Database Systems Conference, </booktitle> <year> 1988. </year>
Reference-contexts: The essential themes that Parnas espoused are present in contemporary software generators; generators formalize the design of software families as open architectures, where software system synthesis and evolution can be quick and inexpensive. Some examples of generators include Genesis (database systems) <ref> [Bat88] </ref>, Avoca (network protocols) [OP92], Ficus (file systems) [HP93], Brale (host-at-sea buoy systems) [Wei90], and Predator (data structures) [BSST93]. Although each of these generators was developed independently and targeted for a different problem domain, all were organized in basically the same way.
Reference: [BO92] <author> Don Batory and Sean O'Malley. </author> <title> The design and implementation of hierarchical software systems with reusable components. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 1(4) </volume> <pages> 355-398, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: Although each of these generators was developed independently and targeted for a different problem domain, all were organized in basically the same way. The GenVoca model captures their common design strategy <ref> [BO92] </ref>: it defines a particular style of designing and organizing reusable components that enables families of software systems to be defined through component composition. An implementation of a GenVoca model is a software system generator for a particular domain.
Reference: [BSST93] <author> Don Batory, Vivek Singhal, Marty Sirkin, and Jeff Thomas. </author> <title> Scalable software libraries. </title> <booktitle> In Proceedings of ACM SIGSOFT '93: Symposium on the Foundations of Software Engineering, </booktitle> <address> Los Angeles, California, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: Some examples of generators include Genesis (database systems) [Bat88], Avoca (network protocols) [OP92], Ficus (file systems) [HP93], Brale (host-at-sea buoy systems) [Wei90], and Predator (data structures) <ref> [BSST93] </ref>. Although each of these generators was developed independently and targeted for a different problem domain, all were organized in basically the same way. <p> Any component belonging to this realm would be a legal value for this parameter (e.g. array, binary tree, or even linked list). Although not obvious, parameterizing collection components by realms forms the basis for generating a vast family of data structures <ref> [BSST93] </ref>. P++'s realm parameterization facility is a powerful language feature for designing and reusing software components: * It encourages the development of components with standardized abstract interfaces. Such components are more likely to be reused because they can be easily interchanged with other components of the same realm [BSST93]. * When <p> data structures <ref> [BSST93] </ref>. P++'s realm parameterization facility is a powerful language feature for designing and reusing software components: * It encourages the development of components with standardized abstract interfaces. Such components are more likely to be reused because they can be easily interchanged with other components of the same realm [BSST93]. * When interchangeable components are available, it is easy to tune the performance of a system: different components can be quickly substituted for one another, thus greatly facilitating the process of finding improved implementations for a system [BSST93]. * P++ integrates component definition and combination features in a single language. <p> they can be easily interchanged with other components of the same realm <ref> [BSST93] </ref>. * When interchangeable components are available, it is easy to tune the performance of a system: different components can be quickly substituted for one another, thus greatly facilitating the process of finding improved implementations for a system [BSST93]. * P++ integrates component definition and combination features in a single language. Other researchers have used module interconnection languages to combine components [PDN86].
Reference: [CS93] <author> L. Coglianese and R. Szymanski. </author> <title> DSSA-ADAGE: An environment for architecture-based avionics development. </title> <booktitle> In Proceedings of AGARD, </booktitle> <year> 1993. </year>
Reference-contexts: A different approach, one that achieves economies of scale, was needed. He argued that since program families are inevitable, designing program families from the beginning is the most cost-effective way to proceed. Recent work on domain-specific software architectures <ref> [CS93, Sof90] </ref> has shown that software system generators offer a promising means of economically building families of large, complex software systems. These generators are domain-specific; they implement models (called domain models) which show how to construct a family of similar software systems by composing reusable, prefabricated components.
Reference: [HP93] <author> John Heidemann and Gerald Popek. </author> <title> File system development with stackable layers. </title> <type> Technical Report CSD-930019, </type> <institution> Department of Computer Science, University of Califor-nia, </institution> <address> Los Angeles, </address> <month> July </month> <year> 1993. </year>
Reference-contexts: The essential themes that Parnas espoused are present in contemporary software generators; generators formalize the design of software families as open architectures, where software system synthesis and evolution can be quick and inexpensive. Some examples of generators include Genesis (database systems) [Bat88], Avoca (network protocols) [OP92], Ficus (file systems) <ref> [HP93] </ref>, Brale (host-at-sea buoy systems) [Wei90], and Predator (data structures) [BSST93]. Although each of these generators was developed independently and targeted for a different problem domain, all were organized in basically the same way.
Reference: [Lis87] <author> Barbara Liskov. </author> <title> Data abstraction and hierarchy. </title> <booktitle> In Addendum to the OOPSLA '87 Conference Proceedings, </booktitle> <pages> pages 17-34, </pages> <month> October </month> <year> 1987. </year>
Reference-contexts: Other researchers have used module interconnection languages to combine components [PDN86]. However, such languages typically are different from the language in which components are written. 2.3 Inheritance Programming languages use inheritance to implement two kinds of hierarchies: implementation hierarchies and type hierarchies <ref> [Lis87] </ref>. Current object-oriented languages usually support implementation hierarchies, where a subclass inherits both the interface and the implementation of the superclass, unless explicitly overridden (overloaded) by the subclass. In contrast, when a language implements type hierarchies, inheritance is being used to support data abstraction.
Reference: [OP92] <author> Sean O'Malley and Larry Peterson. </author> <title> A dynamic network architecture. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 10(2) </volume> <pages> 110-143, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: The essential themes that Parnas espoused are present in contemporary software generators; generators formalize the design of software families as open architectures, where software system synthesis and evolution can be quick and inexpensive. Some examples of generators include Genesis (database systems) [Bat88], Avoca (network protocols) <ref> [OP92] </ref>, Ficus (file systems) [HP93], Brale (host-at-sea buoy systems) [Wei90], and Predator (data structures) [BSST93]. Although each of these generators was developed independently and targeted for a different problem domain, all were organized in basically the same way.
Reference: [Par76] <author> David Parnas. </author> <title> On the design and development of program families. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-2(1):1-9, </volume> <month> March </month> <year> 1976. </year>
Reference-contexts: 1 Background Almost two decades ago, Parnas observed that software design was incorrectly taught as a technique which sought a unique program/solution, because, over its lifetime, the program inevitably would evolve into a family of similar programs <ref> [Par76] </ref>. When programs are not designed for extensibility, the effort and expense needed to modify them is often out of proportion to the changes themselves. A different approach, one that achieves economies of scale, was needed.
Reference: [PDF93] <editor> Ruben Prieto-D iaz and William Frakes, editors. </editor> <booktitle> Advances in Software Reuse: Second International Workshop on Software Reuse. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <year> 1993. </year>
Reference-contexts: Direct source code modification may be appropriate for functions or classes because of their (typically) small code volume; however, this customization technique is rarely effective for components. Component parameterization, which permits an easy and controlled form of modification, is widely believed to be the prescription for successful component customization <ref> [PDF93] </ref>. Contemporary programming languages already offer constant and type parameterization of classes; P++ extends these capabilities to components and realms.
Reference: [PDN86] <author> Ruben Prieto-D iaz and James Neighbors. </author> <title> Module interconnection languages. </title> <journal> Journal of Systems and Software, </journal> <volume> 6(4) </volume> <pages> 307-334, </pages> <month> November </month> <year> 1986. </year>
Reference-contexts: Other researchers have used module interconnection languages to combine components <ref> [PDN86] </ref>. However, such languages typically are different from the language in which components are written. 2.3 Inheritance Programming languages use inheritance to implement two kinds of hierarchies: implementation hierarchies and type hierarchies [Lis87].
Reference: [Sof90] <author> Software Engineering Institute. </author> <booktitle> Proceedings of the Workshop on Domain-Specific Software Architectures, </booktitle> <address> Hidden-Valley, Pennsylvania, </address> <year> 1990. </year>
Reference-contexts: A different approach, one that achieves economies of scale, was needed. He argued that since program families are inevitable, designing program families from the beginning is the most cost-effective way to proceed. Recent work on domain-specific software architectures <ref> [CS93, Sof90] </ref> has shown that software system generators offer a promising means of economically building families of large, complex software systems. These generators are domain-specific; they implement models (called domain models) which show how to construct a family of similar software systems by composing reusable, prefabricated components.

References-found: 11

