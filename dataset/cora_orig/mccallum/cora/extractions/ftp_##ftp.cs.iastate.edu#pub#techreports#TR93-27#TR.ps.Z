URL: ftp://ftp.cs.iastate.edu/pub/techreports/TR93-27/TR.ps.Z
Refering-URL: http://www.cs.iastate.edu/~leavens/main.html
Root-URL: http://www.cs.iastate.edu
Title: An Executable Semantics for a Formalized Data Flow Diagram Specification Language  
Author: Tim Wahls, Albert L. Baker, and Gary T. Leavens 
Keyword: Categories and Subject Descriptors: D.2.1 [Software Engineering] Requirements/Specifications languages; D.2.2 [Software Engineering] Tools and Techniques computer-aided software engineering (CASE); D.2.m [Software Engineering] Miscellaneous rapid prototyping General Terms: Specification, Design, Prototyping, Formal Semantics Additional Key Words and Phrases: Data Flow Diagrams (DFDs), Standard ML, executable specification, literate programming, operational semantics, specification language semantics, RT-SPECS, Structured Analysis (SA)  
Address: 226 Atanasoff Hall  Ames, Iowa 50011-1040, USA  
Affiliation: Department of Computer Science  Iowa Sate University  
Note: TR #93-27 November 1993  Submitted to ACM Transactions on Software Engineering and Methodology. cfl Tim Wahls, 1993. All rights reserved.  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Baker, Albert L. </author> <title> Synthesizing model-oriented and Structured Analysis specifications, </title> <booktitle> Lecture, </booktitle> <year> (1991). </year>
Reference-contexts: j length binary-op ::= +j = j fl j=j mod j [ j " j n j k empty ::= 3 QSize: int Consumed: signal I: real Item: real O: real OutCPIn As as example of an RT-SPECS specification, consider the following specification of a bounded buffer producer/consumer system from <ref> [1] </ref>.
Reference: [2] <author> Coleman, David L. </author> <title> Formalized Structured Analysis specifications, </title> <type> Ph.D. dissertation, </type> <institution> Iowa State University, Ames, Iowa, </institution> <month> 50011, </month> <year> (1991). </year>
Reference-contexts: We conclude with a discussion of of problems remaining in the area of formalizing traditional DFDs, and a description of the advantages of executable semantics/specification. 2 Informal Description of RT-SPECS The description in this section follows that of Coleman <ref> [2] </ref>. The syntax of RT-SPECS is an extension of traditional DFD syntax. <p> The bubble C consumes reals from Item, and signals P that it has done so, using flow Consumed. 2.2 Informal Semantics of RT-SPECS This informal description of RT-SPECS semantics follows the first formalization by Coleman <ref> [2] </ref> and the operational semantics given in Leavens et. al [8] for traditional DFDs. The key concept is that of firing a bubble. Firing is the process in which a bubble reads its inflows and produces onto its outflows. <p> the flow, while writing to a persistent one overwrites any information already present. 1 Thus, a persistent flow is like a variable shared between two 1 The distinction between persistent and consumable flows is closely related to the issue of continuous versus discrete flows found in the traditional DFD literature <ref> [2] </ref> [4] [20]. 4 bubbles, which only the origin bubble can write and only the destination bubble can read. We treat consumable flows as unbounded FIFO queues. <p> Interestingly, a list is sufficient structure here | there is only one reasonable way for the flowenabled components to be related. This is a dramatic simplification of other efforts to capture this notion [7] <ref> [2] </ref>, and is discussed further in the conclusions section. henabling condition declarations i datatype flowenabled = plus of string | minus of string; datatype enabletype = T | flowlist of ((flowenabled list) * preexpr); The second component of a rule (the pre-condition) has the same syntax as the second component of
Reference: [3] <author> Gyorkos, J., Rozman, I. and Welzar, T. </author> <title> Activation and validation of the system specifications, </title> <booktitle> Microprocessing and Microprogramming 31, </booktitle> <address> (April 1991), </address> <publisher> North-Holland, </publisher> <pages> 59 - 64. </pages>
Reference-contexts: This has the advantages of informality and some level of understandability by non-technicians, but is too ambiguous and low-level to be a good specification technique. Another technique is to include in the DFD the actual code implementing a bubble <ref> [3] </ref>. While this is a formal specification, it is not an adequate specification technique, as it is too low-level. A third modification to DFDs describes the functionality of bubbles with a finite state machine.
Reference: [4] <author> Hatley, D. and Pirbhai, E. </author> <title> Strategies for Real-Time System Specification. </title> <publisher> Dorset House, </publisher> <address> New York, </address> <year> 1987. </year>
Reference-contexts: flow, while writing to a persistent one overwrites any information already present. 1 Thus, a persistent flow is like a variable shared between two 1 The distinction between persistent and consumable flows is closely related to the issue of continuous versus discrete flows found in the traditional DFD literature [2] <ref> [4] </ref> [20]. 4 bubbles, which only the origin bubble can write and only the destination bubble can read. We treat consumable flows as unbounded FIFO queues.
Reference: [5] <author> Hayes, I. </author> <title> Specification Case Studies. </title> <booktitle> Prentice-Hall, International Series in Computer Science, </booktitle> <year> 1987. </year>
Reference-contexts: These conditions are written as first order predicate calculus (FOPC) assertions over the values on the inflows and outflows of the bubble. Thus, RT-SPECS has much in common with SPECS (a non-graphical specification language developed at ISU), VDM [6], and Z <ref> [5] </ref> [18] [19] in that specification is done using FOPC pre- and post-conditions. RT-SPECS thus has the formality of these specification techniques, and also the advantage of a graphical notation. 1.3 Goal of this paper The goal of this paper, then, is to provide a formal semantics for RT-SPECS.
Reference: [6] <author> Jones, Cliff B. </author> <title> Systematic Software Development Using VDM. </title> <booktitle> Prentice-Hall, International Series in Computer Science, </booktitle> <year> 1986. </year>
Reference-contexts: These conditions are written as first order predicate calculus (FOPC) assertions over the values on the inflows and outflows of the bubble. Thus, RT-SPECS has much in common with SPECS (a non-graphical specification language developed at ISU), VDM <ref> [6] </ref>, and Z [5] [18] [19] in that specification is done using FOPC pre- and post-conditions.
Reference: [7] <author> Kung, Chenho. </author> <title> Process interface modeling and consistency checking, </title> <journal> The Journal of Systems and Software, </journal> <volume> 15, 2, </volume> <month> (May </month> <year> 1991). </year>
Reference-contexts: Interestingly, a list is sufficient structure here | there is only one reasonable way for the flowenabled components to be related. This is a dramatic simplification of other efforts to capture this notion <ref> [7] </ref> [2], and is discussed further in the conclusions section. henabling condition declarations i datatype flowenabled = plus of string | minus of string; datatype enabletype = T | flowlist of ((flowenabled list) * preexpr); The second component of a rule (the pre-condition) has the same syntax as the second component
Reference: [8] <author> Leavens, Gary T., Wahls, Tim, Baker, Albert L. and Lyle, Kari. </author> <title> A structural operational semantics of firing rules for Structured Analysis style data flow diagrams, </title> <type> Forthcoming, </type> <institution> Iowa State University, Ames, Iowa, </institution> <month> 50010, </month> <year> (1992). </year>
Reference-contexts: The bubble C consumes reals from Item, and signals P that it has done so, using flow Consumed. 2.2 Informal Semantics of RT-SPECS This informal description of RT-SPECS semantics follows the first formalization by Coleman [2] and the operational semantics given in Leavens et. al <ref> [8] </ref> for traditional DFDs. The key concept is that of firing a bubble. Firing is the process in which a bubble reads its inflows and produces onto its outflows. The semantics of firing gives meaning to the firing rules in RT-SPECS, which specify the dynamic behaviour of a DFD. <p> We have investigated formal semantics for bubbles firing concurrently with themselves in a forthcoming work <ref> [8] </ref>, and the application of this work to RT-SPECS is straightforward. Finally, our use of SML demonstrates an unusual and exciting way of doing semantics. <p> require flows to and from it? How cumbersome would this be in practice? How can we handle concurrent access to stores? Is there a good general technique that solves this problem, or must we rely on ad hoc solutions for each store? We have addressed these questions in another work <ref> [8] </ref> by modeling stores as flows with multiple origin and destination bubbles, and expect that this approach will work for RT-SPECS as well. 4.2.2 Research arising from RT-SPECS The problems we have uncovered in formalizing DFDs are perhaps even more interesting than those found in traditional DFDs.
Reference: [9] <author> Lerner, Richard Allen. </author> <title> Specifying Objects of Concurrent Systems, </title> <type> Ph.D. dissertation, </type> <institution> Carnegie Mellon University, </institution> <year> (1991), </year> <journal> Number CMU-CS-91-131. </journal> <volume> 23 </volume>
Reference-contexts: A rule is a triple consisting of an enabling condition, a pre-condition, and a post-condition. The enabling condition resembles the when clause of GCIL <ref> [9] </ref>. hrule declarationi type Rule = (enabletype * preexpr * postexpr); Each of the three conditions is a propositional logic expression written over RT-SPECS types. We now give the SML representations for these expressions, and a brief explanation. We start with tokenexprs, which are token valued expressions.
Reference: [10] <author> Lyle, Kari. </author> <title> Refinement in data flow diagrams, </title> <type> Masters thesis, </type> <institution> Iowa State University, Ames, Iowa, </institution> <month> 50011, </month> <year> (1992). </year>
Reference-contexts: When a bubble in the working state fires, it must fire on the rule it was using when the transition to the working state was made, and must produce its output and change state to idle. Work on refinement notions for RT-SPECS <ref> [10] </ref> has shown that if a bubble is refined to a sub-diagram with several bubbles the sub-diagram can exhibit behaviors that look like reading more than one input before producing output. <p> This informal specification can be directly refined to a formal one | by adding the necessary rules <ref> [10] </ref>. The second result of our work is that we now can produce executable specifications. Thus, the specification is a prototype of the system. Some of the advantages for the specifier and client are: 1. Validating specifications.
Reference: [11] <author> McDonald, C., and Allison, L. </author> <title> Denotational semantics of a command interpreter and their implementation in Standard ML, </title> <journal> The Computer Journal, </journal> <volume> 32, 5, </volume> <month> (October </month> <year> 1989), </year> <pages> 422-431. </pages>
Reference-contexts: Thus, although SML is a programming language, it is also an effective tool for communicating with humans, and we view our work as equal parts executable specification and formal semantics of a specification language. See <ref> [11] </ref> for another example of this style of formal semantics. 5 3.1 Syntax In this section, we give the abstract syntax for RT-SPECS in SML.
Reference: [12] <author> Manna, Zohar., and Pnueli, Amir. </author> <title> The temporal logic of reactive and concurrent systems, </title> <publisher> Springer-Verlag, </publisher> <year> (1992). </year>
Reference-contexts: Extending the idea of invariants, we may eventually want to use temporal logic <ref> [12] </ref> [15] to describe liveness and safety properties of RT-SPECS specifications. Invariants are closely related to expression definitions, which are named, parameterized assertions.
Reference: [13] <author> Paulson, L. C. </author> <title> ML for the Working Programmer. </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, </address> <year> 1991. </year>
Reference-contexts: First we provide an informal syntax and semantics for RT-SPECS to introduce the reader to the language. Then we give a formal syntax and semantics for RT-SPECS, written in the functional programming language Standard ML <ref> [13] </ref>. This provides two distinct semantic views of RT-SPECS: a deno-tational view (if we think of the program as a function mapping an RT-SPECS specification to its meaning), and an operational view obtained by actually running the SML code.
Reference: [14] <author> Peterson, J. L. </author> <title> Petri nets, </title> <journal> ACM Computing Surveys, </journal> <volume> 9, 3, </volume> <month> (September </month> <year> 1977), </year> <pages> 221-252. </pages>
Reference-contexts: The Type field is used to indicate the type of information that may travel on the last field of a flow, Contents. Borrowing from the language of Petri nets <ref> [14] </ref>, we refer to each item of information as a token. The string stored in the Type field of a flow must be written according to the following grammar.
Reference: [15] <author> Pnueli, A. </author> <title> Applications of temporal logic to the specification and verification of reactive systems: a survey of current trends. </title> <booktitle> Current Trends in Concurrency: Overviews and Tutorials, LNCS, </booktitle> <volume> Volume 224, </volume> <editor> de Roever, W. P. Ed., and Rozenberg, G. Ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1986, </year> <pages> 510-584. </pages>
Reference-contexts: Extending the idea of invariants, we may eventually want to use temporal logic [12] <ref> [15] </ref> to describe liveness and safety properties of RT-SPECS specifications. Invariants are closely related to expression definitions, which are named, parameterized assertions.
Reference: [16] <author> Ramsey, Norman. </author> <title> Literate programming tools need not be complex, </title> <note> to appear in IEEE Transactions on Software Engineering. </note>
Reference-contexts: are actually implemented (not just modeled) as a sequence of tokens. 3 hflow declarationi structure Flow : FLOW = struct datatype F = Flow of -Origin:string, Destination:string, Name:string, Type:string, Pers:Persistency, Contents:Token.T homitted flow implementationi end; 2 All SML code in this paper is presented using the literate programming tool Noweb <ref> [16] </ref>. Expressions of the form hdecl i represent parts of the code that are presented elsewhere. The corresponding form hdecli code defines such omitted code.
Reference: [17] <author> Schmidt, David A. </author> <title> Denotational Semantics | A Methodology for Language Development. Wm. </title> <address> C. </address> <publisher> Brown Publishers, </publisher> <address> Dubuque, Iowa. </address> <year> 1986. </year>
Reference: [18] <author> Spivey, J. Michael. </author> <title> The Z Notation: A Reference Manual. </title> <booktitle> Prentice-Hall, International Series in Computer Science, </booktitle> <year> 1989. </year>
Reference-contexts: These conditions are written as first order predicate calculus (FOPC) assertions over the values on the inflows and outflows of the bubble. Thus, RT-SPECS has much in common with SPECS (a non-graphical specification language developed at ISU), VDM [6], and Z [5] <ref> [18] </ref> [19] in that specification is done using FOPC pre- and post-conditions. RT-SPECS thus has the formality of these specification techniques, and also the advantage of a graphical notation. 1.3 Goal of this paper The goal of this paper, then, is to provide a formal semantics for RT-SPECS.
Reference: [19] <author> Spivey, J. </author> <title> An introduction to Z and formal specifications, </title> <journal> Software Engineering Journal, </journal> <month> (January </month> <year> 1989). </year>
Reference-contexts: These conditions are written as first order predicate calculus (FOPC) assertions over the values on the inflows and outflows of the bubble. Thus, RT-SPECS has much in common with SPECS (a non-graphical specification language developed at ISU), VDM [6], and Z [5] [18] <ref> [19] </ref> in that specification is done using FOPC pre- and post-conditions. RT-SPECS thus has the formality of these specification techniques, and also the advantage of a graphical notation. 1.3 Goal of this paper The goal of this paper, then, is to provide a formal semantics for RT-SPECS.
Reference: [20] <author> Ward, Paul T. </author> <title> The transformation schema: an extension of the data flow diagram to represent control and timing, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-12, 2, </volume> <month> (February </month> <year> 1986), </year> <pages> 198-210. </pages>
Reference-contexts: while writing to a persistent one overwrites any information already present. 1 Thus, a persistent flow is like a variable shared between two 1 The distinction between persistent and consumable flows is closely related to the issue of continuous versus discrete flows found in the traditional DFD literature [2] [4] <ref> [20] </ref>. 4 bubbles, which only the origin bubble can write and only the destination bubble can read. We treat consumable flows as unbounded FIFO queues.
Reference: [21] <author> Yourdon, Edward. </author> <title> Modern Structured Analysis. </title> <publisher> Yourdon Press computing series. Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1989. </year> <month> 24 </month>
Reference-contexts: This is clearly insufficient for precisely specifying a real software system. A number of techniques have been used in traditional DFDs to combat this problem. In particular, the functionality of a bubble is often expressed in "Structured English" <ref> [21] </ref>. This has the advantages of informality and some level of understandability by non-technicians, but is too ambiguous and low-level to be a good specification technique. Another technique is to include in the DFD the actual code implementing a bubble [3].
References-found: 21

