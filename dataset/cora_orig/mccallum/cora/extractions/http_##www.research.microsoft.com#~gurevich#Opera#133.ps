URL: http://www.research.microsoft.com/~gurevich/Opera/133.ps
Refering-URL: http://www.research.microsoft.com/~gurevich/annotated.html
Root-URL: http://www.research.microsoft.com
Email: graedel@informatik.rwth-aachen.de  gurevich@umich.edu  hirsch@informatik.rwth-aachen.de  
Title: The Complexity of Query Reliability  
Author: Erich Gradel Yuri Gurevich Colin Hirsch 
Address: Aachen  Michigan  Aachen  
Affiliation: University of Technology  Universtity of  University of Technology  
Abstract: While it was already known that the reliability of quantifier-free queries is computable in polynomial time, we show here that already for conjunctive queries, the reliability may become highly intractable. We exhibit a conjunctive query whose reliability problem is complete for FP #P . We further show, that FP #P is the typical complexity level for the reliability problems of a very large class of queries, including all second-order queries. We study approximation algorithms and prove that the re-liabilities of all polynomial-time evaluable queries can be efficiently approximated by randomized algorithms. Finally we discuss the extension of our approach to the more general metafinite database model where finite relational structures are endowed with functions into an infinite interpreted domain; in addition queries may use aggregate functions like in SQL. Our result that reliability problems of first-order queries have complexity FP #P also holds on this extended model. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> E. Gradel and Y. Gurevich, </author> <title> Metafinite Model Theory, </title> <booktitle> Information and Computation 140 (1998), </booktitle> <pages> 26-81. </pages>
Reference-contexts: We use this theorem to derive a similar result for the problems Prob-kDNF. Theorem 5.3. For all k 2 N, the problem Prob-kDNF admits an FPTRAS. Proof. Let ' be a kDNF formula and let - : fX 1 ; : : : ; X m g ! <ref> [0; 1] </ref> be a probability function on the variables of '. We will transform ('; -) into an appropriate instance ' 00 for #DN F . <p> We will make some modifications in order to obtain a result for all polynomial-time evaluable queries. Lemma 5.11 (Karp, Luby). Let fX i g be a sequence of independent random variables, all identically distributed with values in <ref> [0; 1] </ref> and expectation p := E (X i ) &lt; 0:5 for all i. Then for all " 2 (0; 1), Pr fi fi t fi fi 9 (1p) : Theorem 5.12. Let be a polynomial-time evaluable query. <p> We briefly discuss the extension to a more general setting, where we may also have functions into possibly infinite interpreted domains and aggregates or multiset operations. The formal framework is that of metafinite model theory as presented in <ref> [1] </ref>. As pointed out in [1], we believe that aggregates are adequately modeled by multiset operations. Fix an infinite structure R together with a collection of mul tiset operations. <p> We briefly discuss the extension to a more general setting, where we may also have functions into possibly infinite interpreted domains and aggregates or multiset operations. The formal framework is that of metafinite model theory as presented in <ref> [1] </ref>. As pointed out in [1], we believe that aggregates are adequately modeled by multiset operations. Fix an infinite structure R together with a collection of mul tiset operations. <p> In the terminology of <ref> [1] </ref>, functional databases are a special class of metafinite algebras. A query on databases of this kind is a global function F , associating with A a function F A : A k ! R. <p> A query language can be defined as a calculus of terms, with the proviso, that variables range over the finite set A only (not over R) 4 . 4 As shown in <ref> [1] </ref>, by forbidding the use of variables ranging over the infinite interpreted domains in R, one can avoid most of the inherent evils pertaining to infinite structures. <p> For instance, given a term F (x; y), one defines a new term G (x) of the form P ticular, the operations max and min can be seen as more general variants of existential and universal quantifiers. We refer to <ref> [1] </ref> for a more detailed treatement and examples. Most of the methods and results for the finite relational case go through for metafinite databases. For instance, the reliability of quantifier-free queries is still polynomial-time computable. The reliability of first-order queries is in FP #P . <p> The reliability and the expected error of a query are themselves database queries. In addition to the complexity of the reliability problem we can ask whether the reliability of a query is itself expressible in a given query language. For instance, it is a result in <ref> [1] </ref>, that the reliability of every quantifier-free query over finite relational databases is first-order definable in an appropriate metafinite setting. Similarly the reliability of any first-order or second-order query over finite relational databases is second-order definable in such a setting.
Reference: [2] <author> C. Hirsch, </author> <title> The Reliability of Queries, </title> <booktitle> Diploma Thesis (RWTH-Aachen, </booktitle> <year> 1998). </year>
Reference-contexts: For complexity considerations this gives no essential difference. In particular, Proposition 3.2 holds also for the restricted model. In fact, our proof carries over directly, since the reduction from #Monotone 2-Sat assigns positive error probabilites to positive atomic facts only. For further details, see <ref> [2] </ref>. 4 Second-order queries In this section we prove that the reliability problem is in the class FP #P for all second-order queries.
Reference: [3] <author> D. Johnson, </author> <title> A Catalog of Complexity Classes, </title> <editor> in: J. van Leeuven (Ed.), </editor> <booktitle> Handbook of Theoretical Computer Science, Vol. A: Algorithms and Complexity, </booktitle> <publisher> Else-vier/MIT Press (1990), </publisher> <pages> 67-161. </pages>
Reference-contexts: For many NP-complete decision problems and also for some problems in P, the related problem of counting the number of witnesses (rather than determining whether there exists at least one) is #P-complete. For background on #P we refer to <ref> [3, 7, 11] </ref>. Many query reliability problems are closely related to the class #P, although they technically do not belong to this class, since they are not taking values in N.
Reference: [4] <author> R. Karp and M. Luby, </author> <title> Monte Carlo algorithms for enumeration and reliability problems, </title> <booktitle> Proceedings of the 24th Symposium on Foundations of Computer Science FOCS 1983, </booktitle> <pages> 56-64. </pages>
Reference-contexts: For this problem, we can show the existence of an FPTRAS using a result of Karp and Luby <ref> [4] </ref>. From FPTRAS for the probabilities of existential sentences we obtain a slightly weaker notion of approximability for the reliability of any existential or universal query. This weaker version is sufficient for most practical purposes. We then discuss whether it can be strengthened to an FPTRAS for reliability. Definition 5.1. <p> Relaxing our bound on the allowed error gave us a positive, if weaker, approximability result. We will now derive a similar result for all polynomial-time evaluable queries. The proof is based on methods used in <ref> [4] </ref> for developing an FPTRAS for #DNF. We will make some modifications in order to obtain a result for all polynomial-time evaluable queries. Lemma 5.11 (Karp, Luby). <p> Let be a polynomial-time evaluable query. Then there exists a polynomial-time randomized algorithm M such that for all probabilistic databases D and "; ffi &gt; 0 Pr [jR (D) M (D)j &gt; "] &lt; ffi: Proof. The proof is based on methods used by Karp and Luby in <ref> [4] </ref> for constructing an FPTRAS for #DNF. In case is not a Boolean query we use the same idea as in the proof of Lemma 5.5 and approximate the query reliability using the sum over all approximations for each possible valuation of the free variables, if with stricter bounds.
Reference: [5] <author> V. Lakshmanan and F. Sadri, </author> <title> Probabilistic deductive databases, </title> <booktitle> Proceedings of the International Logic Programming Symposium, </booktitle> <publisher> MIT Press (1994), </publisher> <pages> 197-207. </pages>
Reference-contexts: Notably query decomposition requires an extension to how intermediate results are stored in order to correctly calculate the result probabilities. Lakshmanan and Subrah-manian present another version of probabilistic databases and can even document a successfull implementation [6]. A large number of results specialize on probabilistic deductive databases (see <ref> [5, 10] </ref> for details and further references). 2 Unreliable databases Definition 2.1. An unreliable database is a pair D = (A; ) where D is a finite relational structure and a probability function on the set of atomic statements Ra about A.
Reference: [6] <author> V. Lakshmanan and V. Subrahmanian, Probview, </author> <title> A flexible probabilistic database system, </title> <booktitle> ACM Transactions on Database Systems 22 (1997), </booktitle> <pages> 419-469. </pages>
Reference-contexts: A sound and complete method for evaluating queries is developed. Notably query decomposition requires an extension to how intermediate results are stored in order to correctly calculate the result probabilities. Lakshmanan and Subrah-manian present another version of probabilistic databases and can even document a successfull implementation <ref> [6] </ref>. A large number of results specialize on probabilistic deductive databases (see [5, 10] for details and further references). 2 Unreliable databases Definition 2.1.
Reference: [7] <author> C. Papadimitriou, </author> <title> Computational Complexity, </title> <publisher> Addison-Wesley (1994). </publisher>
Reference-contexts: For many NP-complete decision problems and also for some problems in P, the related problem of counting the number of witnesses (rather than determining whether there exists at least one) is #P-complete. For background on #P we refer to <ref> [3, 7, 11] </ref>. Many query reliability problems are closely related to the class #P, although they technically do not belong to this class, since they are not taking values in N.
Reference: [8] <author> K. Regan and T. Schwentick, </author> <title> On the Power of One Bit of a #P Function, </title> <booktitle> Proceedings of the Fourth Italian Conference on Theoretical Computer Science (1992), </booktitle> <pages> 317-329. </pages>
Reference-contexts: First, it is a well-known result in finite model theory, that the problems expressible in second-order logic are precisely the problems in the polynomial-time hierarchy PH. The second fact is a theorem from structural complexity theory, due to Regan and Schwentick <ref> [8] </ref>, which gives a very special presentation of arbitrary problems in PH in terms of a single bit of a #P-function. Theorem 4.1 (Regan, Schwentick).
Reference: [9] <author> M. de Rougemont, </author> <title> The reliability of queries, </title> <booktitle> Proc. 14th ACM Symp. on Principles of Database Systems PODS (1995), </booktitle> <pages> 286-291. </pages>
Reference-contexts: As we will see below, the probabilities -(B) can be easily calculated, given (A; ) and B. A very similar model has been considered by de Rougemont <ref> [9] </ref>. Suppose that a user is given an unreliable database D = (A; ) and wants to evaluate a query (x). <p> In database terminology, we study the data complexity (rather than the expression complexity or combined complexity) of query reliability. This makes sense since the queries are usually given by small expressions, whereas the size of the databases may be huge. De Rougemont <ref> [9] </ref> proved that the reliability is computable in polynomial time for all quantifier-free queries. He further claimed that the same holds for all first-order queries. <p> It is easy to see that computing H and R is in FP #P for all conjunctive . In fact, we will prove a much more general result below. Remark. The model for unreliable databases studied by de Rougemont <ref> [9] </ref> is slightly different from ours. In his model, only positive data are unreliable. To put it differently, he only considers unreliable databases (A; ) where A j= :Ra implies that (Ra) = 0. For complexity considerations this gives no essential difference.
Reference: [10] <author> V. Subrahmanian, </author> <title> Stable semantics for probabilistic deductive databases, </title> <booktitle> Information and Computation 110(1) (1994), </booktitle> <pages> 42-83. </pages>
Reference-contexts: Notably query decomposition requires an extension to how intermediate results are stored in order to correctly calculate the result probabilities. Lakshmanan and Subrah-manian present another version of probabilistic databases and can even document a successfull implementation [6]. A large number of results specialize on probabilistic deductive databases (see <ref> [5, 10] </ref> for details and further references). 2 Unreliable databases Definition 2.1. An unreliable database is a pair D = (A; ) where D is a finite relational structure and a probability function on the set of atomic statements Ra about A.
Reference: [11] <author> L. Valiant, </author> <title> The complexity of enumeration and reliability problems, </title> <journal> SIAM J. Computing 8 (1979), </journal> <pages> 410-421. </pages>
Reference-contexts: For many NP-complete decision problems and also for some problems in P, the related problem of counting the number of witnesses (rather than determining whether there exists at least one) is #P-complete. For background on #P we refer to <ref> [3, 7, 11] </ref>. Many query reliability problems are closely related to the class #P, although they technically do not belong to this class, since they are not taking values in N. <p> Proof. We will reduce the problem #Monotone 2-Sat to the problem of computing H for a particular conjunctive Boolean query . The problem #Monotone 2-Sat was proved to be #P-complete by Valiant <ref> [11] </ref>. Its input instances are propositional formulae in 2-CNF without negations, i.e. formulae of the form V n i=1 Y i _ Z i where Y i and Z i are propositional variables. The desired answer is the number of satisfying assignments.
Reference: [12] <author> K. Wagner, </author> <title> Some observations on the connection between counting and recursion, </title> <booktitle> Theoretical Computer Science 47 (1986),131-147. </booktitle>
Reference-contexts: It is in FP CH where CH is the so-called counting polynomial hierarchy that has been in troduced and studied by Wagner <ref> [12] </ref>. There are a number of equivalent definitions of the class FP CH ; for instance it is the closure of the polynomial-time computable functions under the #-operation. Other characterizations involve second-order counting quantifiers or closures of some basic arithmetical functions under exponential summation and substitution. <p> Other characterizations involve second-order counting quantifiers or closures of some basic arithmetical functions under exponential summation and substitution. For details we refer to <ref> [12] </ref>. The simple algorithm described above for computing the reliability of first-order queries applies also to second-order queries. It shows that the reliability problem of every second order query is also in FP CH . The following theorem summarizes these results for some particular cases. Theorem 6.2.
Reference: [13] <author> E. Zimanyi, </author> <title> Query evaluation on probabilistic relational databases, </title> <booktitle> Theoretical Computer Science 171 (1997), </booktitle> <pages> 179-219. </pages>
Reference-contexts: Our result that reliability problems typically have complexity FP #P also holds on this extended model. Related Work Considerable research has been conducted on other aspects of probabilistic databases. Zimanyi <ref> [13] </ref> gives an in-depth study of queries and query evaluation methods on probabilistic relational databases, that are given by probabilistic first-order theories. A relational algebra query applied to such a database yields a probabilistic relation, where each tuple is assigned a probability.
References-found: 13

