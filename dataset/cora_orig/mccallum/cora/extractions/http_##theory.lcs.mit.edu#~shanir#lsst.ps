URL: http://theory.lcs.mit.edu/~shanir/lsst.ps
Refering-URL: http://theory.lcs.mit.edu/~shanir/
Root-URL: 
Email: Email: lynch@theory.lcs.mit.edu.  Email: shanir@theory.lcs.mit.edu.  Email: alex@theory.lcs.mit.edu.  Email: danidin@cs.tau.ac.il.  
Title: Counting Networks are Practically Linearizable  
Author: Nancy Lynch Nir Shavit Alex Shvartsman Dan Touitou 
Address: Science.  Technology Square, NE43-340, Cambridge, MA 02139.  Science.  
Affiliation: Massachusetts Institute of Technology, Laboratory for Computer  Massachusetts Institute of Technology and Tel-Aviv University.  MIT Laboratory for Computer Science, 545  Massachusetts Institute of Technology, Laboratory for Computer  -Tel-Aviv University, Department of Computer Science.  
Note: This work was supported by the following contracts: ARPA N00014-92-J-4033 and F19628-95-C-0118, NSF 922124-CCR, and ONR-AFOSR F49620-94-1-01997.  Contact author:  The work of this author was also supported by grant CCR 9520298.  
Abstract: Counting networks are a class of concurrent structures that allow the design of highly scalable concurrent data structures in a way that eliminates sequential bottlenecks and contention. Linearizable counting networks assure that the order of the values returned by the network reflects the real-time order in which they were requested. We argue that in many concurrent systems the worst case scenarios that violate linearizability require a form of timing anomaly that is uncommon in practice. The linear time cost of designing networks that achieve linearizability under all circumstances may thus prove an unnecessary burden on applications that are willing to trade-off occasional non-linearizability for speed and parallelism. This paper presents a very simple measure that is local to the individual links and nodes of the network, and that quantifies the extent to which a network can suffer from timing anomalies and still remain linearizable. Perhaps counter-intuitively, this measure is independent of network depth. We use our measure to mathematically support our experimental results: that in a variety of normal situations tested on a simulated shared memory multiprocessor, the bitonic counting networks of Aspnes, Herlihy, and Shavit are "for all practical purposes" linearizable. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> E. Aharonson and H. Attiya. </author> <title> Counting networks with arbitrary fan out. </title> <booktitle> In Proceedings of the 3 rd Symposium on Discrete Algorithms, </booktitle> <address> Orlando, Florida, </address> <month> Jan-uary </month> <year> 1992. </year> <title> Also: </title> <type> Technical Report 679, </type> <institution> The Technion, </institution> <month> June </month> <year> 1991. </year>
Reference-contexts: Here the behavior is not linearizable because the traversal of the network by T 1 completely precedes T 2 , yet T 2 returns a lower counter value. 2 A common structuring property of almost all published counting networks <ref> [1, 4, 3, 12, 14, 15, 10, 7, 20, 21] </ref> is uniformity: each node of the network lies on some path from inputs to outputs and all paths from inputs to outputs have equal lengths. Our measure is as follows. <p> The full paper will be available on WWW in http://theory.lcs.mit.edu/tds/papers.html. 2 Models and definitions Consider balancing networks consisting of acyclically wired multiple-input-multiple-output balancers or balancing nodes in the style of Aharonson and Attiya <ref> [1] </ref> and Felten, LaMarca, and Ladner [10] (Figure 1). We let x i (respectively y i ) stand for the name of the input port (output port) of a node, and its value for the number of tokens that have entered (exited) via that port.
Reference: [2] <author> A. Agarwal, D. Chaiken, K. Johnson, D. Krantz, J. Kubiatowicz, K. Kurihara, B. Lim, G. Maa, and D. Nussbaum. </author> <title> The MIT Alewife Machine: A Large-Scale Distributed-Memory Multiprocessor. To appear in Scalable Shared Memory Multiprocessors, </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1991. </year> <note> Also as MIT Technical Report MIT/LCS/TM-454, </note> <month> June </month> <year> 1991. </year>
Reference-contexts: We also show (Section 4) that counting (diffracting) trees and bitonic counting networks are not linearizable for c 2 &gt; 2 c 1 , and we exhibit executions with large numbers of non-linearizable operations. Finally, we provide experimental results collected for an Alewife <ref> [2] </ref> shared-memory multiprocessor simulated using Proteus [6], and use the c 2 =c 1 ratio to explain bitonic counting network and diffracting tree lineariz ability properties (Section 5). <p> There are three waves of w=2 tokens out of which w=2 tokens return non-linearizable values. 2 5 Simulation results We empirically evaluated the linearizability of counting networks on a simulated 256 processor distributed-shared-memory machine similar to the MIT Alewife machine <ref> [2] </ref> of Agarwal et al. Our simulations were performed using Proteus , a multiprocessor simulator developed by Brewer, Dellarocas, Colbrook and Weihl [6].
Reference: [3] <author> B. Aiello, R. Venkatesan, and M. Yung. </author> <title> Coins, Weights and Contention in Balancing Networks. </title> <booktitle> In Thirteenth ACM SIGACT-SIGOPS Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1994, </year> <pages> pp. 193-214. </pages>
Reference-contexts: Here the behavior is not linearizable because the traversal of the network by T 1 completely precedes T 2 , yet T 2 returns a lower counter value. 2 A common structuring property of almost all published counting networks <ref> [1, 4, 3, 12, 14, 15, 10, 7, 20, 21] </ref> is uniformity: each node of the network lies on some path from inputs to outputs and all paths from inputs to outputs have equal lengths. Our measure is as follows.
Reference: [4] <author> J. Aspnes, M.P. Herlihy, and N. Shavit. </author> <title> Counting Networks and Multi-Processor Coordination. </title> <booktitle> In Proceedings of the 23rd Annual Symposium on Theory of Computing, </booktitle> <month> May </month> <year> 1991. </year>
Reference-contexts: 1 Introduction Counting networks <ref> [4] </ref> are a class of concurrent structures that allow the design of highly scalable concurrent data structures in a way that eliminates sequential bottlenecks and contention. <p> Linearizable counting lies at the heart of concurrent timestamp generation, as well as concurrent implementations of shared counters, FIFO buffers, priority queues and similar data structures. Unfortunately, for both the bitonic networks of Aspnes, Herlihy, and Shavit <ref> [4] </ref> and the Diffracting Trees of Shavit and Zemach [21], there exist worst case asynchronous schedules in which lin-earizability is violated. <p> Here the behavior is not linearizable because the traversal of the network by T 1 completely precedes T 2 , yet T 2 returns a lower counter value. 2 A common structuring property of almost all published counting networks <ref> [1, 4, 3, 12, 14, 15, 10, 7, 20, 21] </ref> is uniformity: each node of the network lies on some path from inputs to outputs and all paths from inputs to outputs have equal lengths. Our measure is as follows. <p> This timing model is general enough to capture both message passing and shared memory implementations using the same frameworks as <ref> [4, 21] </ref>. We prove (Section 3) the following for any uniform counting network (explicitly constructible or not): * If c 2 2 c 1 then the network is linearizable. <p> This model is consistent with both the message passing and shared memory toggle bit based balancer implementations <ref> [4] </ref>, and diffracting balancers [21], as all can be expressed in terms of balancers with atomic transitions. Balancing or counting operations are processed in the form of tokens that are routed through a network. <p> Together with the definition of linearizability, this leads to the result for uniform networks: Corollary 3.9 Uniform counting networks are lineariz able for c 2 2 c 1 . The next two corollaries instantiate the linearizability result for specific network definitions. Corollary 3.10 Bitonic counting networks <ref> [4] </ref>, periodic counting networks [4], the networks of [14] and [7] are linearizable for c 2 2 c 1 . Corollary 3.11 Counting and diffracting trees [21] and the uniform trees [8] are linearizable for c 2 2 c 1 . <p> The next two corollaries instantiate the linearizability result for specific network definitions. Corollary 3.10 Bitonic counting networks <ref> [4] </ref>, periodic counting networks [4], the networks of [14] and [7] are linearizable for c 2 2 c 1 . Corollary 3.11 Counting and diffracting trees [21] and the uniform trees [8] are linearizable for c 2 2 c 1 . <p> Assuming the lemma holds for some w 2, we now show it holds for networks of width 2w. The inductive step is depicted in Figure 4, and the node and exit labels below refer to the figure. We use the inductive construction of bitonic counting networks as in <ref> [4] </ref>. Bitonic [2w] is made of two Bitonic [w] networks, two Merger [w] merging networks and an additional w balancers. <p> Moreover, for such c 2 and c 1 there exists an execution scenario with 3w=2 tokens such that w=2 tokens result in non-linearizable operations. Proof: The bitonic counting network <ref> [4] </ref> of width w, Bitonic [w] has depth h = log w (log w+1) work consists of two stages, the first stage includes two Bitonic [w=2] networks of depth h 1 = hlog w connected in parallel to the second stage that is the merging network of depth h 2 = <p> The execution is stopped when 5000 operations were performed. The data collected is the non-linearizability ratio, i.e the percentage of non-linearizable operations (see Definition 2.4) among all the operations during the execution. The networks implemented are the diffracting tree [21] and the bitonic counting network <ref> [4] </ref>. Both the network and the tree are of width 32. Every balancer is implemented as a critical section protected by a Mellor-Crummey and Scott (MCS) queue-lock [18] and, in the diffracting tree, using the multi-prism implementation of [20].
Reference: [5] <author> E.A. Brewer, C.N. Dellarocas. </author> <title> Proteus User Documentation. MIT, 545 Technology Square, </title> <address> Cambridge, MA 02139, 0.5 edition, </address> <month> December </month> <year> 1992. </year>
Reference: [6] <author> E.A. Brewer, C.N. Dellarocas, A. Colbrook and W.E. Weihl. Proteus: </author> <title> A High-Performance Parallel-Architecture Simulator. </title> <type> MIT Technical Report /MIT/LCS/TR-561, </type> <month> September </month> <year> 1991. </year>
Reference-contexts: We also show (Section 4) that counting (diffracting) trees and bitonic counting networks are not linearizable for c 2 &gt; 2 c 1 , and we exhibit executions with large numbers of non-linearizable operations. Finally, we provide experimental results collected for an Alewife [2] shared-memory multiprocessor simulated using Proteus <ref> [6] </ref>, and use the c 2 =c 1 ratio to explain bitonic counting network and diffracting tree lineariz ability properties (Section 5). <p> Our simulations were performed using Proteus , a multiprocessor simulator developed by Brewer, Dellarocas, Colbrook and Weihl <ref> [6] </ref>. In our benchmark a certain fraction F = 25%; 50% of the processors waits W = 100; 1000; 10000; 100000 cycles after traversing a node in the net. The execution is stopped when 5000 operations were performed.
Reference: [7] <author> C. Busch and M. Mavronicolas. </author> <title> A Combinatorial Treatment of Balancing Networks. </title> <booktitle> In 13th ACM SIGACT-SIGOPS Symp. on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1994, </year> <pages> pp. 206-215. </pages>
Reference-contexts: Here the behavior is not linearizable because the traversal of the network by T 1 completely precedes T 2 , yet T 2 returns a lower counter value. 2 A common structuring property of almost all published counting networks <ref> [1, 4, 3, 12, 14, 15, 10, 7, 20, 21] </ref> is uniformity: each node of the network lies on some path from inputs to outputs and all paths from inputs to outputs have equal lengths. Our measure is as follows. <p> The next two corollaries instantiate the linearizability result for specific network definitions. Corollary 3.10 Bitonic counting networks [4], periodic counting networks [4], the networks of [14] and <ref> [7] </ref> are linearizable for c 2 2 c 1 . Corollary 3.11 Counting and diffracting trees [21] and the uniform trees [8] are linearizable for c 2 2 c 1 . We now consider the case of c 2 k c 1 for some k 2.
Reference: [8] <author> C. Busch and M. Mavronicolas. </author> <title> New Bounds on Depth and Contention for Counting Networks. </title> <type> preprint, </type> <institution> Univ. of Cyprus, </institution> <month> October </month> <year> 1995. </year>
Reference-contexts: The next two corollaries instantiate the linearizability result for specific network definitions. Corollary 3.10 Bitonic counting networks [4], periodic counting networks [4], the networks of [14] and [7] are linearizable for c 2 2 c 1 . Corollary 3.11 Counting and diffracting trees [21] and the uniform trees <ref> [8] </ref> are linearizable for c 2 2 c 1 . We now consider the case of c 2 k c 1 for some k 2.
Reference: [9] <author> T.H. Cormen, C.E. Leiserson, and R. L. Rivest. </author> <title> Introduction to Algorithms MIT Press, </title> <address> Cambridge MA, </address> <year> 1990. </year>
Reference-contexts: Merger [w] consists of a row of balancers connected to two Merger [w=2] mergers (for details see <ref> [9] </ref>). Note that this inductive construction of the merger is different from, but isomorphic to the construction in Figure 4.
Reference: [10] <author> E.W. Felten, A. LaMarca, R. Ladner. </author> <title> Building Counting Networks from Larger Balancers. </title> <institution> University of Washington T.R. #93-04-09. </institution>
Reference-contexts: Here the behavior is not linearizable because the traversal of the network by T 1 completely precedes T 2 , yet T 2 returns a lower counter value. 2 A common structuring property of almost all published counting networks <ref> [1, 4, 3, 12, 14, 15, 10, 7, 20, 21] </ref> is uniformity: each node of the network lies on some path from inputs to outputs and all paths from inputs to outputs have equal lengths. Our measure is as follows. <p> The full paper will be available on WWW in http://theory.lcs.mit.edu/tds/papers.html. 2 Models and definitions Consider balancing networks consisting of acyclically wired multiple-input-multiple-output balancers or balancing nodes in the style of Aharonson and Attiya [1] and Felten, LaMarca, and Ladner <ref> [10] </ref> (Figure 1). We let x i (respectively y i ) stand for the name of the input port (output port) of a node, and its value for the number of tokens that have entered (exited) via that port.
Reference: [11] <author> A. Gottlieb, B.D. Lubachevsky, and L. Rudolph. </author> <title> Basic techniques for the efficient coordination of very large numbers of cooperating sequential processors. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(2) </volume> <pages> 164-189, </pages> <month> April </month> <year> 1983. </year>
Reference: [12] <author> M.P. Herlihy, N. Shavit, and O. Waarts. </author> <title> Linearizable Counting Networks. </title> <booktitle> In Proceedings of the 32 nd Annual Symposium on Foundations of Computer Science, </booktitle> <year> 1991, </year> <pages> pp. 526-535. </pages> <note> Detailed version with empirical results appeared as MIT/LCS technical manuscript 459, </note> <year> 1991. </year>
Reference-contexts: As explained in [13], lin-earizability generalizes and unifies a number of ad-hoc correctness conditions in the literature, and it is related to (but not identical with) correctness criteria such as sequential consistency [16] and strict serializability [19]. Herlihy, Shavit, and Waarts defined the class of lin-earizable counting networks <ref> [12] </ref>, networks that assure that the order of the values returned by the network reflects the real-time order in which they were requested. Linearizable counting lies at the heart of concurrent timestamp generation, as well as concurrent implementations of shared counters, FIFO buffers, priority queues and similar data structures. <p> Unfortunately, for both the bitonic networks of Aspnes, Herlihy, and Shavit [4] and the Diffracting Trees of Shavit and Zemach [21], there exist worst case asynchronous schedules in which lin-earizability is violated. In <ref> [12] </ref> linear depth linearizable counting network constructions were presented, and it was proven that this depth is inescapable: any low contention counting network that is linearizable in all executions must have linear depth, and hence is bound to have rather poor latency. <p> Here the behavior is not linearizable because the traversal of the network by T 1 completely precedes T 2 , yet T 2 returns a lower counter value. 2 A common structuring property of almost all published counting networks <ref> [1, 4, 3, 12, 14, 15, 10, 7, 20, 21] </ref> is uniformity: each node of the network lies on some path from inputs to outputs and all paths from inputs to outputs have equal lengths. Our measure is as follows.
Reference: [13] <author> M.P. Herlihy and J.M. Wing. </author> <title> Linearizability: A correctness condition for concurrent objects. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(3) </volume> <pages> 463-492, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: A recently developed form of counting network called a Diffracting Tree [21] has been shown to scale especially well, and has low latency since its depth is less than logarithmic in the number of processors n. The notion of linearizability due to Herlihy and Wing <ref> [13] </ref> is the requirement that the values chosen by a concurrent object reflect the real-time order in which they were requested. The use of linearizable data abstractions simplifies both the specification and the proofs of multiple instruction/multiple data (MIMD) shared memory algorithms. As explained in [13], lin-earizability generalizes and unifies a <p> due to Herlihy and Wing <ref> [13] </ref> is the requirement that the values chosen by a concurrent object reflect the real-time order in which they were requested. The use of linearizable data abstractions simplifies both the specification and the proofs of multiple instruction/multiple data (MIMD) shared memory algorithms. As explained in [13], lin-earizability generalizes and unifies a number of ad-hoc correctness conditions in the literature, and it is related to (but not identical with) correctness criteria such as sequential consistency [16] and strict serializability [19]. <p> Q : K fi [1::(h + 1)] ! N is the function such that Q (k; j) is the real time instant when the token k passes through a node in the layer j of the network. Adapting the definition of Herlihy and Wing <ref> [13] </ref> to counting networks: Definition 2.3 A counting network is linearizable if for any execution, when two tokens traverse the network one after another without overlap, the earlier token obtains a smaller value than the later one.
Reference: [14] <author> M. Klugerman and C.G. Plaxton. </author> <title> Small-depth Counting Networks. </title> <booktitle> In ACM Symposium on Theory of Computing (STOC), </booktitle> <year> 1992 </year>
Reference-contexts: Here the behavior is not linearizable because the traversal of the network by T 1 completely precedes T 2 , yet T 2 returns a lower counter value. 2 A common structuring property of almost all published counting networks <ref> [1, 4, 3, 12, 14, 15, 10, 7, 20, 21] </ref> is uniformity: each node of the network lies on some path from inputs to outputs and all paths from inputs to outputs have equal lengths. Our measure is as follows. <p> The next two corollaries instantiate the linearizability result for specific network definitions. Corollary 3.10 Bitonic counting networks [4], periodic counting networks [4], the networks of <ref> [14] </ref> and [7] are linearizable for c 2 2 c 1 . Corollary 3.11 Counting and diffracting trees [21] and the uniform trees [8] are linearizable for c 2 2 c 1 . We now consider the case of c 2 k c 1 for some k 2.
Reference: [15] <author> M. Klugerman, </author> <title> Small-Depth Counting Networks. </title> <type> Ph.D. Thesis, </type> <institution> MIT, </institution> <year> 1994. </year>
Reference-contexts: Here the behavior is not linearizable because the traversal of the network by T 1 completely precedes T 2 , yet T 2 returns a lower counter value. 2 A common structuring property of almost all published counting networks <ref> [1, 4, 3, 12, 14, 15, 10, 7, 20, 21] </ref> is uniformity: each node of the network lies on some path from inputs to outputs and all paths from inputs to outputs have equal lengths. Our measure is as follows.
Reference: [16] <author> L. Lamport. </author> <title> How to make a multiprocessor computer that correctly executes multiprocess programs. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-28(9), </volume> <month> September </month> <year> 1979 </year>
Reference-contexts: As explained in [13], lin-earizability generalizes and unifies a number of ad-hoc correctness conditions in the literature, and it is related to (but not identical with) correctness criteria such as sequential consistency <ref> [16] </ref> and strict serializability [19]. Herlihy, Shavit, and Waarts defined the class of lin-earizable counting networks [12], networks that assure that the order of the values returned by the network reflects the real-time order in which they were requested.
Reference: [17] <author> N.A. Lynch and M.R. Tuttle. </author> <title> Hierarchical Correctness Proofs for Distributed Algorithms. </title> <booktitle> In Sixth ACM SIGACT-SIGOPS Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1987, </year> <pages> pp. 137-151. </pages> <note> Full version available as MIT/LCS/TR-387. </note>
Reference: [18] <author> J.M. Mellor-Crummey and M.L. Scott. </author> <title> Algorithms for Scalable Synchronization on Shared-Memory Multiprocessors. </title> <type> Technical Report 342, </type> <institution> University of Rochester, Rochester, </institution> <address> NY 14627, </address> <month> April </month> <year> 1990. </year>
Reference-contexts: The networks implemented are the diffracting tree [21] and the bitonic counting network [4]. Both the network and the tree are of width 32. Every balancer is implemented as a critical section protected by a Mellor-Crummey and Scott (MCS) queue-lock <ref> [18] </ref> and, in the diffracting tree, using the multi-prism implementation of [20]. This is done to reduce contention on the nodes which would have attenuated the influence of the W -waiting periods on the c2=c1 relation. The results are given in Figures 5 and 6.
Reference: [19] <author> C.H. Papadimitriou. </author> <title> The serializability of concurrent database updates. </title> <journal> Journal of the ACM, </journal> <volume> 26(4) </volume> <pages> 631-653, </pages> <month> October </month> <year> 1979. </year>
Reference-contexts: As explained in [13], lin-earizability generalizes and unifies a number of ad-hoc correctness conditions in the literature, and it is related to (but not identical with) correctness criteria such as sequential consistency [16] and strict serializability <ref> [19] </ref>. Herlihy, Shavit, and Waarts defined the class of lin-earizable counting networks [12], networks that assure that the order of the values returned by the network reflects the real-time order in which they were requested.
Reference: [20] <author> N. Shavit, and D. Touitou. </author> <title> Elimination Trees and the Construction of Pools and Stacks. </title> <booktitle> In Proceedings of the Annual Symposium on Parallel Algorithms and Architectures (SPAA), </booktitle> <month> June </month> <year> 1995. </year>
Reference-contexts: Here the behavior is not linearizable because the traversal of the network by T 1 completely precedes T 2 , yet T 2 returns a lower counter value. 2 A common structuring property of almost all published counting networks <ref> [1, 4, 3, 12, 14, 15, 10, 7, 20, 21] </ref> is uniformity: each node of the network lies on some path from inputs to outputs and all paths from inputs to outputs have equal lengths. Our measure is as follows. <p> Both the network and the tree are of width 32. Every balancer is implemented as a critical section protected by a Mellor-Crummey and Scott (MCS) queue-lock [18] and, in the diffracting tree, using the multi-prism implementation of <ref> [20] </ref>. This is done to reduce contention on the nodes which would have attenuated the influence of the W -waiting periods on the c2=c1 relation. The results are given in Figures 5 and 6. The y-axis shows the non-linearizability ratio.
Reference: [21] <author> N. Shavit and A. Zemach. </author> <title> Diffracting Trees. </title> <booktitle> In Proceedings of the Annual Symposium on Parallel Algorithms and Architectures (SPAA), </booktitle> <month> June </month> <year> 1994. </year> <note> Bitonic Counting Network Diffracting Tree Workload n=4 n=16 n=64 128 n=256 n=4 n=16 n=64 128 n=256 50 % 1000 5.67 5.03 3.70 3.24 2.73 2.06 2.06 1.94 2.01 2.09 100000 483 410.21 280.27 244.34 215.22 115.54 107.39 91.86 96.72 105.62 100 1.45 1.39 1.25 1.22 1.17 1.11 1.11 1.10 1.11 1.11 10000 46.18 40.15 26.67 23.39 19.63 11.67 11.70 10.38 10.97 11.78 </note>
Reference-contexts: 1 Introduction Counting networks [4] are a class of concurrent structures that allow the design of highly scalable concurrent data structures in a way that eliminates sequential bottlenecks and contention. A recently developed form of counting network called a Diffracting Tree <ref> [21] </ref> has been shown to scale especially well, and has low latency since its depth is less than logarithmic in the number of processors n. <p> Linearizable counting lies at the heart of concurrent timestamp generation, as well as concurrent implementations of shared counters, FIFO buffers, priority queues and similar data structures. Unfortunately, for both the bitonic networks of Aspnes, Herlihy, and Shavit [4] and the Diffracting Trees of Shavit and Zemach <ref> [21] </ref>, there exist worst case asynchronous schedules in which lin-earizability is violated. <p> Here the behavior is not linearizable because the traversal of the network by T 1 completely precedes T 2 , yet T 2 returns a lower counter value. 2 A common structuring property of almost all published counting networks <ref> [1, 4, 3, 12, 14, 15, 10, 7, 20, 21] </ref> is uniformity: each node of the network lies on some path from inputs to outputs and all paths from inputs to outputs have equal lengths. Our measure is as follows. <p> This timing model is general enough to capture both message passing and shared memory implementations using the same frameworks as <ref> [4, 21] </ref>. We prove (Section 3) the following for any uniform counting network (explicitly constructible or not): * If c 2 2 c 1 then the network is linearizable. <p> This model is consistent with both the message passing and shared memory toggle bit based balancer implementations [4], and diffracting balancers <ref> [21] </ref>, as all can be expressed in terms of balancers with atomic transitions. Balancing or counting operations are processed in the form of tokens that are routed through a network. <p> The next two corollaries instantiate the linearizability result for specific network definitions. Corollary 3.10 Bitonic counting networks [4], periodic counting networks [4], the networks of [14] and [7] are linearizable for c 2 2 c 1 . Corollary 3.11 Counting and diffracting trees <ref> [21] </ref> and the uniform trees [8] are linearizable for c 2 2 c 1 . We now consider the case of c 2 k c 1 for some k 2. <p> The execution is stopped when 5000 operations were performed. The data collected is the non-linearizability ratio, i.e the percentage of non-linearizable operations (see Definition 2.4) among all the operations during the execution. The networks implemented are the diffracting tree <ref> [21] </ref> and the bitonic counting network [4]. Both the network and the tree are of width 32. Every balancer is implemented as a critical section protected by a Mellor-Crummey and Scott (MCS) queue-lock [18] and, in the diffracting tree, using the multi-prism implementation of [20].
References-found: 21

