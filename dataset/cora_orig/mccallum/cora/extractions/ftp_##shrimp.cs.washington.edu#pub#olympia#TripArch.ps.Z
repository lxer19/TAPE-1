URL: ftp://shrimp.cs.washington.edu/pub/olympia/TripArch.ps.Z
Refering-URL: http://www.cs.washington.edu/homes/hauck/publications.html
Root-URL: 
Title: The Triptych FPGA Architecture  
Author: Gaetano Borriello, Carl Ebeling, Scott Hauck, Steven Burns 
Address: Seattle, WA 98195  
Affiliation: Department of Computer Science and Engineering University of Washington  
Note: to appear in IEEE Transactions on VLSI  
Abstract: Field-programmable gate arrays (FPGAs) are an important implementation medium for digital logic. Unfortunately, they currently suffer from poor silicon area utilization due to routing constraints. In this paper we present Triptych, an FPGA architecture designed to achieve improved logic density with competitive performance. This is done by allowing a permapping tradeoff between logic and routing resources, and with a routing scheme designed to match the structure of typical circuits. We show that this yields a logic density improvement of up to a factor of 3.5 over commercial FPGAs, with comparable performance. We also describe Montage, the first FPGA architecture to fully support asynchronous and synchronous interface circuits.
Abstract-found: 1
Intro-found: 1
Reference: [Algotronix91] <author> Algotronix Limited, </author> <note> CAL1024 Preliminary Datasheet, </note> <year> 1991. </year>
Reference-contexts: Other elements have logic equations for the outputs. 4 Area comparisons with other FPGAs In this section, we present a comparison of the area efficiency of four different FPGA architectures, based on several representative examples. The FPGAs compared are CLIs CFA [Concurrent91], Algotronixs CAL1024 <ref> [Algotronix91] </ref>, the Xilinx 3000 series [Xilinx91], and Triptych (with 3-input, 3-output RLBs). The example circuits were chosen across a wide range of domains, rather than a specific one for which an architecture might have been optimized (e.g., bitserial computations). The circuits were mapped by hand and only optimized for area.
Reference: [Brunvand91] <author> E. Brunvand, </author> <title> Implementing Self-Timed Systems with FPGAs, </title> <booktitle> International Workshop on Field-Programmable Logic and Applications, </booktitle> <address> Oxford, </address> <year> 1991. </year>
Reference-contexts: Unfortunately, an asynchronous designer cannot simply make do with a synchronous FPGA because the constraints on the implementation medium are much more stringent for asynchronous circuits. Note that work has been done on mapping asynchronous circuits to standard FPGAs <ref> [Brunvand91] </ref>, but have difficulty handling the required timing assumptions and mutual exclusion operations.
Reference: [Concurrent91] <institution> Concurrent Logic, Inc., CFA6006 Field Programmable Gate Array, </institution> <month> March </month> <year> 1991. </year>
Reference-contexts: Other elements have logic equations for the outputs. 4 Area comparisons with other FPGAs In this section, we present a comparison of the area efficiency of four different FPGA architectures, based on several representative examples. The FPGAs compared are CLIs CFA <ref> [Concurrent91] </ref>, Algotronixs CAL1024 [Algotronix91], the Xilinx 3000 series [Xilinx91], and Triptych (with 3-input, 3-output RLBs). The example circuits were chosen across a wide range of domains, rather than a specific one for which an architecture might have been optimized (e.g., bitserial computations).
Reference: [Ebergen89] <author> J. C. Ebergen, </author> <title> Translating Programs into Delay-Insensitive Circuits, </title> <institution> Centre for Mathematics and Computer Science, Amsterdam CWI Tract 56, </institution> <year> 1989. </year>
Reference-contexts: Another feature of the Montage FPGA that is very important for the support of asynchronous circuits is the overall routing structure. Some asynchronous design methodologies, including <ref> [Martin89, Ebergen89] </ref>, make assumptions about the delays incurred in wires. Specifically, they assume that some wires are asymmetric isochronic forks, where a signal must reach one destination of the fork before it reaches the other, or symmetric isochronic forks, where the signal must reach all destinations at the same time. <p> a logic RLB, mappings that do not use arbiters or synchronizers will have little or no area penalty due to the inclusion of arbiter RLBs. 3.3 Using Montage To illustrate how well typical asynchronous elements map to Montage, we present all of the basic elements used in Ebergens synthesis methodology <ref> [Ebergen89] </ref> in figure 17. Most of the elements fit compactly into a single RLB, and can be initialized with the built-in circuitry. The Toggle element is a two-output element, and thus required two RLBs (with one extra signal that must be routed outside this mapping).
Reference: [Furtek91] <author> F. Furtek, </author> <type> Personal communication, </type> <month> October </month> <year> 1991. </year>
Reference: [Guibas82] <author> L. J. Guibas and F. M. Liang, </author> <title> Systolic Stacks, Queues, and Counters, </title> <booktitle> Second MIT Conference on Advanced Research in VLSI, </booktitle> <year> 1982. </year>
Reference-contexts: The systolic circuits are two versions of a string comparison circuit that computes the edit distance of two strings [Lipton85], the two versions differing on whether both strings move or if one is fixed in place, as well as a FIFO <ref> [Guibas82] </ref>. The arithmetic circuits chosen are a counter with a 4-stage carry look-ahead and an adder with a 2-stage carry look-ahead.
Reference: [Kean91] <author> T. </author> <title> Kean, </title> <type> Personal communication, </type> <month> October </month> <year> 1991. </year>
Reference: [Lipton85] <author> R. J. Lipton and D. Lopresti, </author> <title> A Systolic Array for Rapid String Comparison, </title> <booktitle> Chapel Hill Conference on VLSI, </booktitle> <year> 1985. </year>
Reference-contexts: They are collected into the following general categories: systolic, arithmetic, linear - growth bit-parallel, exponential-growth bit-parallel, and finite state machines (random logic). The systolic circuits are two versions of a string comparison circuit that computes the edit distance of two strings <ref> [Lipton85] </ref>, the two versions differing on whether both strings move or if one is fixed in place, as well as a FIFO [Guibas82]. The arithmetic circuits chosen are a counter with a 4-stage carry look-ahead and an adder with a 2-stage carry look-ahead.
Reference: [Martin89] <author> A. J. Martin, </author> <title> Programming in VLSI: From Communicating Processes to Delay - Insensitive Circuits, </title> <booktitle> in UT Year of Programming Institute on Concurrent Programming, </booktitle> <editor> C. A. R. Hoare, Ed. </editor> <address> MA: </address> <publisher> Addison-Wesley, </publisher> <pages> pp. 1-64, </pages> <year> 1989. </year>
Reference-contexts: Another feature of the Montage FPGA that is very important for the support of asynchronous circuits is the overall routing structure. Some asynchronous design methodologies, including <ref> [Martin89, Ebergen89] </ref>, make assumptions about the delays incurred in wires. Specifically, they assume that some wires are asymmetric isochronic forks, where a signal must reach one destination of the fork before it reaches the other, or symmetric isochronic forks, where the signal must reach all destinations at the same time.
Reference: [Schlag91] <author> M. Schlag, P. K. Chan, and J. Kong, </author> <title> Empirical Evaluation of Multilevel Logic Minimization Tools for a Field Programmable Gate Array Technology, </title> <booktitle> International Workshop on Field-Programmable Logic and Applications, </booktitle> <address> Oxford, </address> <year> 1991. </year>
Reference-contexts: The resulting scaling factors are contained in table 2. Normalization is also necessary for speed comparisons. We use the delay values provided by the manufacturers (Xilinx values are for the 3020-50 <ref> [Schlag91] </ref>), and scale them based on the feature sizes of the processes used. As shown in [Vuillamy91], FPGA logic speed scales linearly with process size, while routing delay scales quadratically. <p> Thus, the area numbers for Xilinx should be considered as a lower bound, and the mappings may actually require significantly more space. Since we did not do routing, we have no direct method for measuring the speed of Xilinx circuits. However, by using a routing delay model for Xilinx <ref> [Schlag91] </ref>, we were able to compute estimated routing delay, and these numbers were presented in table 5. Second, since all the circuits were mapped by hand, we were able to use only small examples. No comparisons of large, complex random logic circuits are presented.
Reference: [Singh90] <author> S. Singh, J. Rose, D. Lewis, K. Chung, and P. Chow, </author> <title> Optimization of Field - Programmable Gate Array Logic Block Architecture for Speed, </title> <booktitle> Proceedings of the IEEE Custom Integrated Circuits Conference, </booktitle> <month> May </month> <year> 1990. </year>
Reference: [Trimberger91] <author> S. Trimberger, </author> <type> Personal communication, </type> <month> October </month> <year> 1991. </year>
Reference: [Vuillamy91] <author> J. Vuillamy, Z. G. Vranesic, and J. Rose, </author> <title> Performance Evaluation and Enhancement of FPGAs, </title> <booktitle> International Workshop on Field-Programmable Logic and Applications, </booktitle> <address> Oxford, </address> <month> September </month> <year> 1991. </year>
Reference-contexts: The resulting scaling factors are contained in table 2. Normalization is also necessary for speed comparisons. We use the delay values provided by the manufacturers (Xilinx values are for the 3020-50 [Schlag91]), and scale them based on the feature sizes of the processes used. As shown in <ref> [Vuillamy91] </ref>, FPGA logic speed scales linearly with process size, while routing delay scales quadratically.
Reference: [Xilinx91] <author> Xilinx, Inc., </author> <title> The Programmable Gate Array Data Book, </title> <year> 1991. </year>
Reference-contexts: Other elements have logic equations for the outputs. 4 Area comparisons with other FPGAs In this section, we present a comparison of the area efficiency of four different FPGA architectures, based on several representative examples. The FPGAs compared are CLIs CFA [Concurrent91], Algotronixs CAL1024 [Algotronix91], the Xilinx 3000 series <ref> [Xilinx91] </ref>, and Triptych (with 3-input, 3-output RLBs). The example circuits were chosen across a wide range of domains, rather than a specific one for which an architecture might have been optimized (e.g., bitserial computations). The circuits were mapped by hand and only optimized for area.
References-found: 14

