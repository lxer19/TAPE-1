URL: ftp://ftp.cs.washington.edu/pub/ai/fabian_aips96.ps.Z
Refering-URL: http://www.cs.washington.edu/homes/friedman/research.html
Root-URL: 
Email: weld@cs.washington.edu  
Title: Least-Commitment Action Selection  
Author: Marc Friedman and Daniel S. Weld friedman, 
Keyword: Abstraction planning, Causal-link planning  
Address: Box 352350 Seattle, WA 98195-2350  
Affiliation: Department of Computer Science and Engineering University of Washington  
Abstract: partial-order planning algorithms commit to a single producing step when supporting an open condition | even when multiple alternatives exist. Each possibility results in a different child plan, and therefore a branch in the search tree. If the various choices have common features, computation may be duplicated unnecessarily on the various branches. The Fabian planner attempts to avoid such waste. Fabian separates the decision to add a step from the choice of which step to add. Fabian supports an open condition by adding an abstract action to the plan representing the disjunc tion of possible new supporting steps; only later does it refine this choice to a particular concrete action. We show that this abstraction can lead to exponential savings, and argue that in the worst case Fabian never explores more than a slightly larger space of plans than does a traditional planner such as snlp. 
Abstract-found: 1
Intro-found: 1
Reference: <author> Bacchus, F., and Yang, Q. </author> <year> 1994. </year> <title> Downward refinement and the efficiency of hierarchical problem solving. </title> <booktitle> Artificial Intelligence 71 </booktitle> <pages> 43-100. </pages>
Reference-contexts: State abstraction can cause exponential speedup in certain regular domains (Knoblock 1992), but it depends on the downward refinement property to prevent backtracking over abstraction levels. Recently, Backstrom and Jonsson showed that there are domains for which the alpine (Knoblock 1991) and hipoint <ref> (Bacchus & Yang 1994) </ref> algorithms may generate exponentially longer plans than optimal, despite the downward refinement property (Backstrom & Jon sson 1995), because of the requirement that plans build on solutions from previous levels. Fabian's conservative abstractions never overconstrain plans, so Fabian need not backtrack over abstraction decisions.
Reference: <author> Backstrom, C., and Jonsson, P. </author> <year> 1995. </year> <title> Planning with abstraction hierarchies can be exponentially less efficient. </title> <booktitle> In Proc. 15th Int. Joint Conf. on A.I., </booktitle> <pages> 1599-1604. </pages>
Reference-contexts: Recently, Backstrom and Jonsson showed that there are domains for which the alpine (Knoblock 1991) and hipoint (Bacchus & Yang 1994) algorithms may generate exponentially longer plans than optimal, despite the downward refinement property <ref> (Backstrom & Jon sson 1995) </ref>, because of the requirement that plans build on solutions from previous levels. Fabian's conservative abstractions never overconstrain plans, so Fabian need not backtrack over abstraction decisions. Nor does it impose the restrictions of incremental search, as illustrated by our superior complexity results.
Reference: <author> Barrett, A., and Weld, D. </author> <year> 1994. </year> <title> Partial order planning: Evaluating possible efficiency gains. </title> <booktitle> Artificial Intelligence 67(1) </booktitle> <pages> 71-112. </pages>
Reference: <author> Chapman, D. </author> <year> 1987. </year> <title> Planning for conjunctive goals. </title> <booktitle> Artificial Intelligence 32(3) </booktitle> <pages> 333-377. </pages>
Reference: <author> Garey, M., and Johnson, D. </author> <year> 1979. </year> <title> Computers and Intractability: A Guide to the Theory of NP-Completeness. </title> <address> New York: </address> <publisher> W. H. Freeman and Company. </publisher>
Reference-contexts: Finding maximal intersections, on the other hand, is isomorphic to finding S-sets in the version space algorithm for generalization learning (Mitchell 1982). In this case, that algorithm must find graph iso-morphisms as a subroutine, a procedure for which no polynomial-time algorithm is known <ref> (Garey & John-son 1979) </ref>. The version space approach proved too slow in practice for some domains, despite the small size of the conjunctions. Restrictions Fabian only restricts an abstract operator producing the effect used to support an open condition.
Reference: <author> Hanks, S., and Weld, D. S. </author> <year> 1995. </year> <title> A domain-independent algorithm for plan adaptation. </title> <journal> Journal of Artificial Intelligence Research 319-360. </journal> <note> Available via FTP from pub/ai/ at ftp.cs.washington.edu. </note>
Reference: <author> Kambhampati, S.; Knoblock, C.; and Yang, Q. </author> <year> 1995. </year> <title> Planning as refinement search: A unified framework for evaluating design tradeoffs in partial order planning. </title> <booktitle> Artificial Intelligence 76 </booktitle> <pages> 167-238. </pages>
Reference-contexts: Since each partial plan represents a set of totally ordered, completely specified action sequences, the refinement function splits the implicitly represented set along the axis chosen by the flaw selection function <ref> (Kambhampati, Knoblock, & Yang 1995) </ref>. The planner starts from the null plan corresponding to the set of all action sequences, 3 and splits it into ever more constrained sets until it can verify that one contains a solution. <p> Concretization obeys the refinement property: if a partial plan P is concretized to P 0 , then P 0 represents a subset of the ground, totally ordered plans that P represents <ref> (Kambhampati, Knoblock, & Yang 1995) </ref>. Stated another way, concretizing cannot remove constraints from a plan. Design Choices In summary, Fabian reasons about disjunctions of operators by precompiling abstract operators that generalize about domains. But its algorithm is not the only conceivable one.
Reference: <author> Kambhampati, S. </author> <year> 1992. </year> <title> Characterizing multi-contributor causal structures for planning. </title> <booktitle> In Proc. 1st Intl. Conf. on A.I. Planning Systems, </booktitle> <pages> 116-125. </pages>
Reference-contexts: Our work applies the least commitment strategy to the choice of new action to support an open condition. Kambhampati's formulation <ref> (Kambhampati 1992) </ref> of the multi-contributor causal link approach originally introduced in nonlin (Tate 1975) is also similar to our work since it adopts a reduced commitment approach to the specific producer of a causal link; essentially this amounts to supporting a consuming step with a causal link containing a disjunction of
Reference: <author> Knoblock, C. </author> <year> 1991. </year> <title> Automatically Generating Abstractions for Problem Solving. </title> <type> Ph.D. Dissertation, </type> <institution> Carnegie Mellon University. </institution> <note> Available as technical report CMU-CS-91-120. </note>
Reference-contexts: State abstraction can cause exponential speedup in certain regular domains (Knoblock 1992), but it depends on the downward refinement property to prevent backtracking over abstraction levels. Recently, Backstrom and Jonsson showed that there are domains for which the alpine <ref> (Knoblock 1991) </ref> and hipoint (Bacchus & Yang 1994) algorithms may generate exponentially longer plans than optimal, despite the downward refinement property (Backstrom & Jon sson 1995), because of the requirement that plans build on solutions from previous levels.
Reference: <author> Knoblock, C. </author> <year> 1992. </year> <title> An analysis of ABSTRIPS. </title> <booktitle> In Proc. 1st Intl. Conf. on A.I. Planning Systems. </booktitle>
Reference-contexts: Fabian uses abstraction in a way radically different from state-abstraction planners like abstrips (Sacer doti 1974) and abtweak (Yang & Tenenberg 1990), which solve incrementally more and more concrete planning problems using the previous abstraction as a guide. State abstraction can cause exponential speedup in certain regular domains <ref> (Knoblock 1992) </ref>, but it depends on the downward refinement property to prevent backtracking over abstraction levels.
Reference: <author> Kramer, M., and Unger, C. </author> <year> 1993. </year> <title> A generalizing operator abstraction. </title> <booktitle> In Proceedings of the Second European Workshop on Planning. </booktitle>
Reference-contexts: Nor does it impose the restrictions of incremental search, as illustrated by our superior complexity results. Fabian could certainly benefit, though, from the state-abstraction notion of predicate criticality to improve its abstraction decisions. Kramer and Unger <ref> (Kramer & Unger 1993) </ref> considered a form of abstract planning which is conceptually very similar to the Fabian approach. But Kramer and Unger's system used a domain-specific, manually-created hierarchy of abstract operators in contrast to Fabian's automatic compilation algorithm.
Reference: <author> McAllester, D., and Rosenblitt, D. </author> <year> 1991. </year> <title> Systematic nonlinear planning. </title> <booktitle> In Proc. 9th Nat. Conf. on A.I., </booktitle> <pages> 634-639. </pages>
Reference-contexts: Whereas HTN planning systems have shown the importance of delaying step-selection decisions, most of today's popular planning algorithms commit to a single producing step when supporting an open condition, even if multiple alternatives exist. For example, snlp <ref> (McAllester & Rosenblitt 1991) </ref> establishes a plan's open condition by considering both existing plan actions (subject to ordering constraints) and appropriate action-templates. Each option generates a different child plan, and therefore a branch in the search tree.
Reference: <author> Minton, S.; Drummond, M.; Bresina, J.; and Phillips, A. </author> <year> 1992. </year> <title> Total order vs. partial order planning: Factors influencing performance. </title> <booktitle> In Proc. 3rd Int. Conf. on Principles of Knowledge Representation and Reasoning. </booktitle>
Reference: <author> Minton, S.; Bresina, J.; and Drummond, M. </author> <year> 1991. </year> <title> Commitment strategies in planning: A comparative analysis. </title> <booktitle> In Proceedings of IJCAI-91, </booktitle> <pages> 259-265. </pages>
Reference: <author> Mitchell, T. </author> <year> 1982. </year> <title> Generalization as search. </title> <booktitle> Artificial Intelligence 18 </booktitle> <pages> 203-226. </pages>
Reference-contexts: Intersections Fabian uses a fast polynomial-time algorithm to compute conservative intersections of logical conjunctions. Conjuncts must be exactly the same to be in the intersection. Finding maximal intersections, on the other hand, is isomorphic to finding S-sets in the version space algorithm for generalization learning <ref> (Mitchell 1982) </ref>. In this case, that algorithm must find graph iso-morphisms as a subroutine, a procedure for which no polynomial-time algorithm is known (Garey & John-son 1979). The version space approach proved too slow in practice for some domains, despite the small size of the conjunctions.
Reference: <author> Penberthy, J., and Weld, D. </author> <year> 1992. </year> <title> UCPOP: A sound, complete, partial order planner for ADL. </title> <booktitle> In Proc. 3rd Int. Conf. on Principles of Knowledge Representation and Reasoning, </booktitle> <pages> 103-114. </pages> <note> Available via FTP from pub/ai/ at ftp.cs.washington.edu. </note>
Reference-contexts: The 45 degree line divides those problems on which Fabian does better (below) from those problems on which snlp does better (above). The best-fit 5 Fabian is implemented on top of Barrett's ucpop version 4.0 <ref> (Penberthy & Weld 1992) </ref>, which subsumes snlp, running on a Silicon Graphics Indy under Allegro Common Lisp 4.2. Both Fabian and snlp repair unseparable threats before open conditions before abstract flaws, with a LIFO ordering within these groupings.
Reference: <author> Peot, M., and Smith, D. </author> <year> 1993. </year> <title> Threat-removal strategies for partial-order planning. </title> <booktitle> In Proc. 11th Nat. Conf. on A.I., </booktitle> <pages> 492-499. </pages>
Reference-contexts: Multi-contributor causal links merge partial plans containing the same steps but different causal links, while Fabian merges plans with different steps but the same causal links. It would be interesting to combine our approaches. Peot and Smith <ref> (Peot & Smith 1993) </ref> considered different flaw selection strategies for snlp-style planners. They showed that delaying consideration of certain threats could lead to search trees that are sometimes smaller, but never bigger than those of snlp.
Reference: <author> Sacerdoti, E. </author> <year> 1974. </year> <title> Planning in a hierarchy of abstraction spaces. </title> <booktitle> Artificial Intelligence 5 </booktitle> <pages> 115-135. </pages>
Reference: <author> Sacerdoti, E. </author> <year> 1975. </year> <title> The nonlinear nature of plans. </title> <booktitle> In Proceedings of IJCAI-75, </booktitle> <pages> 206-214. </pages>
Reference: <author> Stefik, M. </author> <year> 1981. </year> <title> Planning with constraints (MOL-GEN: </title> <booktitle> Part 1). Artificial Intelligence 14(2) </booktitle> <pages> 111-139. </pages>
Reference: <author> Tate, A. </author> <year> 1975. </year> <title> Interacting goals and their use. </title> <booktitle> In Proceedings of IJCAI-75, </booktitle> <pages> 215-218. </pages>
Reference-contexts: Our work applies the least commitment strategy to the choice of new action to support an open condition. Kambhampati's formulation (Kambhampati 1992) of the multi-contributor causal link approach originally introduced in nonlin <ref> (Tate 1975) </ref> is also similar to our work since it adopts a reduced commitment approach to the specific producer of a causal link; essentially this amounts to supporting a consuming step with a causal link containing a disjunction of concrete steps.
Reference: <author> Veloso, M., and Blythe, J. </author> <year> 1994. </year> <title> Linkability: Examining causal link commitments in partial-order planning. </title> <editor> In Hammond, K., ed., </editor> <booktitle> Proc. 2nd Intl. Conf. on A.I. Planning Systems, </booktitle> <pages> 170-175. </pages> <publisher> AAAI. </publisher>
Reference: <author> Williamson, M., and Hanks, S. </author> <year> 1996. </year> <title> Flaw selection strategies for value-directed planning. </title> <booktitle> In Proc. 3rd Intl. Conf. on A.I. Planning Systems. </booktitle>
Reference-contexts: Since one common form of domain-dependent search control is a careful ordering of operator preconditions combined with a LIFO flaw selection strategy <ref> (Williamson & Hanks 1996) </ref>, Fabian may be harder for users to control. Another caveat concerns the proof's assumption that all Fabian plans have a consistent concretization. This would amount to an NP-complete consistency check at each node, which is not implemented.
Reference: <author> Yang, Q., and Tenenberg, J. </author> <year> 1990. </year> <title> ABTWEAK: Abstracting a nonlinear, least-commitment planner. </title> <booktitle> In Proc. 8th Nat. Conf. on A.I., </booktitle> <pages> 204-209. </pages>
Reference-contexts: Note that the approaches are complementary, since we consider open condition flaws while Peot and Smith addressed threats. Fabian uses abstraction in a way radically different from state-abstraction planners like abstrips (Sacer doti 1974) and abtweak <ref> (Yang & Tenenberg 1990) </ref>, which solve incrementally more and more concrete planning problems using the previous abstraction as a guide. State abstraction can cause exponential speedup in certain regular domains (Knoblock 1992), but it depends on the downward refinement property to prevent backtracking over abstraction levels.
References-found: 24

