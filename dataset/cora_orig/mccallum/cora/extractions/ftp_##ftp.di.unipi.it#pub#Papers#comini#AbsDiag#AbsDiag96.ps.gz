URL: ftp://ftp.di.unipi.it/pub/Papers/comini/AbsDiag/AbsDiag96.ps.gz
Refering-URL: http://www.di.unipi.it/di/groups/lp/papers.html
Root-URL: 
Title: Abstract Diagnosis  
Author: Marco Comini and Giorgio Levi Maria Chiara Meo Giuliana Vitiello 
Keyword: Logic Programming, Declarative diagnosis, Verification, Semantics, Debugging  
Address: Corso Italia 40, 56125 Pisa, Italy  via Vetoio, localita Coppito, 67010 L'Aquila, Italy  Baronissi (Salerno), Italy,  
Affiliation: Dipartimento di Informatica, Universita di Pisa,  Dipartimento di Matematica Pura ed Applicata, Universita di L'Aquila,  Dipartimento di Informatica ed Applicazioni, Universita di Salerno,  
Email: comini, levi@di.unipi.it,  meo@univaq.it,  giuvit@dia.unisa.it  
Web: http://www.di.unipi.it/~comini, levi  http://univaq.it/~meo  
Date: December 10, 1997  
Abstract: We show how declarative diagnosis techniques can be extended to cope with verification of operational properties, such as computed and correct answers, and of abstract properties, such as depth(k) answers and ground-ness dependencies. The extension is achieved by using a simple semantic framework, based on abstract interpretation. The resulting technique (abstract diagnosis) leads to elegant bottom-up and top-down verification methods, which do not require to determine the symptoms in advance, and which are effective in the case of abstract properties described by finite domains. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. R. Apt. </author> <title> Introduction to Logic Programming. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B: Formal Models and Semantics, </booktitle> <pages> pages 495-574. </pages> <publisher> Elsevier and The MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: ! D be a complete observable, G := D; A 1 ; : : : ; A n be an abstract goal, P be a program, z := var (A 1 ; : : : ; A n ) and y i := var (A i ) (for i 2 <ref> [1; n] </ref>). Then 1. ff (OJP K) = O ff JP K, z z z 3. ff (PJP K (I)) = P ff JP K (ff (I)), 4. <p> If, for any i 2 <ref> [1; n] </ref>, var (D i ) " (var (D) [ z) x then D e (D 1 e e D n ) = D e z 6. let x z and n 1. If, for any i 2 [1; n], var (D) " (var (D i ) [ z) x then <p> If, for any i 2 <ref> [1; n] </ref>, var (D i ) " (var (D) [ z) x then D e (D 1 e e D n ) = D e z 6. let x z and n 1. If, for any i 2 [1; n], var (D) " (var (D i ) [ z) x then (D 1 e e D n ) e D = (D 1 e e D n ) e z 7. ff (E) ~ j x = ff (Ej x ) ~ j x , The noetherianity of D <p> ! D be an approximate observable, P be a program, G := D; A 1 ; : : : ; A n be an abstract goal, z := var (A 1 ; : : : ; A n ) and y i := var (A i ) (for i 2 <ref> [1; n] </ref>). Then 1. ff (OJP K) O ff JP K, z z z 3. P ff JP K is continuous on I A (and therefore F ff JP K = P ff JP K"!), 4. P ff JP K = ff ffi PJP K ffi fl, 6. <p> The abstract immediate consequence operator P t k JP K is [ F j c = p (x) E; A 1 ; : : : ; A n is a renamed clause of P , z = var (c), for i 2 <ref> [1; n] </ref>, y i = var (A i ), F = ((fEg k z y 2 z Example 3.9 Consider the program P of Figure 4 and the depth (2) observable. <p> Then the abstract oracle simulation OS ff JK of P is f [ ffeq ! D 0 ; A 1 ; : : : ; A n , c is a renamed clause of P , z = var (c), for i 2 <ref> [1; n] </ref>, y i = var (A i ), D = (ff (fEg) e y 1 I ff (A 1 ) e y 2 e y n I ff (A n )) ~ j x . <p> Then, by Definition 4.8, OS ff JfcgK (p (x)) = f [ ffeq ! c 0 = p (x) E; A 1 ; : : : ; A n is a renamed version of c, z = var (c 0 ), for i 2 <ref> [1; n] </ref>, y i = var (A i ), z z z I ff (A n )) ~ j x . <p> P is acceptable w.r.t. jj and I, if for every clause A B 1 ; : : : ; B n in Ground (P ) the following implication holds, for i 2 <ref> [1; n] </ref>: I j= ^ i1 Most interesting programs are acceptable (all the pure PROLOG programs in [43] are reported in [4] to be acceptable). The same property holds for the wrong versions of acceptable programs provided that the errors do not affect the left-termination property. <p> If for any i 2 <ref> [1; n] </ref>: var (E i ) " (var (E) [ z) x then E (E 1 E n ) = E z and if for any i 2 [1; n]: var (E) " (var (E i ) [ z) x then (E 1 E n ) E = (E 1 E <p> If for any i 2 <ref> [1; n] </ref>: var (E i ) " (var (E) [ z) x then E (E 1 E n ) = E z and if for any i 2 [1; n]: var (E) " (var (E i ) [ z) x then (E 1 E n ) E = (E 1 E n ) z Now, we can prove the theorems. Proof of Theorem 3.2. Point 1 We prove the two inclusions separately. <p> By associativity of and by (A.4), E 2 (E E 0 )j x = (E (f;g E 0 ))j x , where E 0 = E 1 E k . Moreover, by definition of derivation, for any i 2 <ref> [1; k] </ref>: var (E i ) " var (E) fxg and therefore by (A.6), E (f;g E 0 ) = E x x (f;g E 0 ). Then, by the previous results and by (A.5), E 2 (E x x (f;g E 0 )j x )j x . <p> results, together with the additivity of x x , imply that E 2 (E x x OJP K (p (x)))j x and complete the proof of the base case. n &gt; 1 To simplify the notation, let us denote by z, z 0 and y i , for i 2 <ref> [1; n] </ref>, the variables var (A 1 ; : : : ; A n ), var (A 1 ; : : : ; A n1 ) and var (A i ), respectively. Assume that E 2 BJE; A 1 ; : : : ; A n in P K. <p> Let us denote by z and y i the variables var (A 1 ; : : : ; A n ) and var (A i ), for i 2 <ref> [1; n] </ref>, respectively. Assume that E 2 (E z y 1 OJP K (A 1 ) z y n OJP K (A n ))j z . Then, by additivity of , for any i 2 [1; n], there exists E i 2 OJP K (A i ) such that E 2 <p> : : : ; A n ) and var (A i ), for i 2 <ref> [1; n] </ref>, respectively. Assume that E 2 (E z y 1 OJP K (A 1 ) z y n OJP K (A n ))j z . Then, by additivity of , for any i 2 [1; n], there exists E i 2 OJP K (A i ) such that E 2 (E z y 2 z By definition of OJP K, by (A.1) and by associativity of this means that, for any i 2 [1; n], there exists a derivation f;g A i eq P fl <p> Then, by additivity of , for any i 2 <ref> [1; n] </ref>, there exists E i 2 OJP K (A i ) such that E 2 (E z y 2 z By definition of OJP K, by (A.1) and by associativity of this means that, for any i 2 [1; n], there exists a derivation f;g A i eq P fl f;g E i ; , such that E i 2 (f;g E i )j y i and therefore, by additivity of and by (4), E 2 (E z y 2 z = (E z y 2 z (5) where <p> Now observe that, by definition of z y i , we can assume that for any i; j 2 <ref> [1; n] </ref>, i 6= j: var (E) " var (E i ) var (A i ) and var (E i ) " var (E j ) = ;. <p> exists a renamed clause of P , c = p (x) E; A 1 ; : : : ; A n , such that E 0 2 (fEg z y 2 z y n (PJP K"h 1)(A n ))j x , where z = var (c) and for i 2 <ref> [1; n] </ref>, y i = var (A i ). By additivity of z y i and j, for any i 2 [1; n], there exists E i 2 (PJP K"h 1)(A i ) such that E 0 2 (fEg z y 2 z Now observe that, by definition of z y <p> , such that E 0 2 (fEg z y 2 z y n (PJP K"h 1)(A n ))j x , where z = var (c) and for i 2 <ref> [1; n] </ref>, y i = var (A i ). By additivity of z y i and j, for any i 2 [1; n], there exists E i 2 (PJP K"h 1)(A i ) such that E 0 2 (fEg z y 2 z Now observe that, by definition of z y i , we can assume for any i; j 2 [1; n], i 6= j: var (E) " var (E i <p> of z y i and j, for any i 2 <ref> [1; n] </ref>, there exists E i 2 (PJP K"h 1)(A i ) such that E 0 2 (fEg z y 2 z Now observe that, by definition of z y i , we can assume for any i; j 2 [1; n], i 6= j: var (E) " var (E i ) y i and var (E i ) " var (E j ) = ;. By inductive hypothesis, for any i 2 [1; n]: E i 2 OJP K (A i ). <p> observe that, by definition of z y i , we can assume for any i; j 2 <ref> [1; n] </ref>, i 6= j: var (E) " var (E i ) y i and var (E i ) " var (E j ) = ;. By inductive hypothesis, for any i 2 [1; n]: E i 2 OJP K (A i ). <p> then the thesis. h &gt; 1 Assume that there exists a derivation f;g; p (x) ! f;g fE 0 g; A 1 ; : : : ; A n ! fl E; of length h &gt; 1 and let y i = var (A i ), for any i 2 <ref> [1; n] </ref>. By definition, since is associative and by (A.1), there exists a deriva tion f;g; A 1 ; : : : ; A n eq P fl f;g E 0 ; whose length is h 1. <p> = fE 0 g f;g E 0 : (9) Moreover, since the length of the derivation f;g; A 1 ; : : : ; A n eq P E 0 ; is h 1, the same argument used in the proof of Point 1 shows that for any j 2 <ref> [1; n] </ref>, there exists a derivation f;g; A j eq P fl f;g E j ; , whose length is l j h 1, such that f;g E 0 = f;g E 1 E n (10) (var (fE 0 g) [ fxg) " var (E i ) y i and The <p> E 1 E n (10) (var (fE 0 g) [ fxg) " var (E i ) y i and The definition of OJP K, (A.3), the inductive hypothesis and the monotonic-ity of PJP K imply that E i j y i (PJP K"h 1)(A i ), for any i 2 <ref> [1; n] </ref>. <p> ff Jp (x) in P K) A = [ by definition of O ff JP K ] O ff JP K: Point 2 Let z and y i be the variables var (A 1 ; : : : ; A n ) and var (A i ) for i 2 <ref> [1; n] </ref>, respectively. First of all note that since D is finite and relevant w.r.t. z (by ff additivity) there must be a finite and relevant (w.r.t. z) element E 2 E such that ff (E) = D. <p> 3 The following facts hold. ff (PJP K (I)) = [ by definition of PJP K ] ff (p (x): fE j c = p (x) E; A 1 ; : : : ; A n is a renamed clause of P , z = var (c), for i 2 <ref> [1; n] </ref>, y i = var (A i ), y 1 I (A 1 ) z y n I (A n ))j x g) p (x): ff ( fE j c = p (x) E; A 1 ; : : : ; A n is a renamed clause of P , <p> ), y 1 I (A 1 ) z y n I (A n ))j x g) p (x): ff ( fE j c = p (x) E; A 1 ; : : : ; A n is a renamed clause of P , z = var (c), for i 2 <ref> [1; n] </ref>, y i = var (A i ), y 1 I (A 1 ) z y n I (A n ))j x g) p (x): ff ( ffl (D) j c = p (x) E; A 1 ; : : : ; A n is a renamed clause of P <p> y 1 I (A 1 ) z y n I (A n ))j x g) p (x): ff ( ffl (D) j c = p (x) E; A 1 ; : : : ; A n is a renamed clause of P , z = var (c), for i 2 <ref> [1; n] </ref>, y i = var (A i ), y 1 I (A 1 ) z y n I (A n ))j x )g) p (x): ff ( ffl (D) j c = p (x) E; A 1 ; : : : ; A n is a renamed clause of P <p> y 1 I (A 1 ) z y n I (A n ))j x )g) p (x): ff ( ffl (D) j c = p (x) E; A 1 ; : : : ; A n is a renamed clause of P , z = var (c), for i 2 <ref> [1; n] </ref>, y i = var (A i ), z z z = [ by (7) ] [ ffl (D) j c = p (x) E; A 1 ; : : : ; A n is a renamed clause of P , z = var (c), for i 2 [1; n], <p> 2 <ref> [1; n] </ref>, y i = var (A i ), z z z = [ by (7) ] [ ffl (D) j c = p (x) E; A 1 ; : : : ; A n is a renamed clause of P , z = var (c), for i 2 [1; n], y i = var (A i ), z z z = [ by definition of e S ] p (x): fD j c = p (x) E; A 1 ; : : : ; A n is a renamed clause of P , z = var (c), for i <p> y i = var (A i ), z z z = [ by definition of e S ] p (x): fD j c = p (x) E; A 1 ; : : : ; A n is a renamed clause of P , z = var (c), for i 2 <ref> [1; n] </ref>, y i = var (A i ), z z z = [ by definition of PJP K ] P ff JP K (ff (I)): Point 4 Let fI ff i g i2I I A be a chain. <p> K (fl (I ff )))) ~ j x = [ by definition of PJK ] 59 p (x): (ff ( E j c = p (x) E; A 1 ; : : : ; A n is a renamed clause of P , z = var (c), for i 2 <ref> [1; n] </ref>, y i = var (A i ), E = (fEg z y 2 z = [ by definition of fl ] p (x): (ff ( E j c = p (x) E; A 1 ; : : : ; A n is a renamed clause of P , z <p> i ), E = (fEg z y 2 z = [ by definition of fl ] p (x): (ff ( E j c = p (x) E; A 1 ; : : : ; A n is a renamed clause of P , z = var (c), for i 2 <ref> [1; n] </ref>, y i = var (A i ), E = (fEg z y 2 z = [ since y i [ x z, by (1) and (A.5) ] p (x): (ff ( E j c = p (x) E; A 1 ; : : : ; A n is a <p> y 2 z = [ since y i [ x z, by (1) and (A.5) ] p (x): (ff ( E j c = p (x) E; A 1 ; : : : ; A n is a renamed clause of P , z = var (c), for i 2 <ref> [1; n] </ref>, y i = var (A i ), E = (fEg z y 2 z = [ by (3.1) and by definition of e [ ] p (x): D j c = p (x) E; A 1 ; : : : ; A n is a renamed clause of P <p> E = (fEg z y 2 z = [ by (3.1) and by definition of e [ ] p (x): D j c = p (x) E; A 1 ; : : : ; A n is a renamed clause of P , z = var (c), for i 2 <ref> [1; n] </ref>, y i = var (A i ), D = ff ((fEg z y 2 z = [ since ~ j x distributes over sums ] p (x): D j c = p (x) E; A 1 ; : : : ; A n is a renamed clause of P <p> D = ff ((fEg z y 2 z = [ since ~ j x distributes over sums ] p (x): D j c = p (x) E; A 1 ; : : : ; A n is a renamed clause of P , z = var (c), for i 2 <ref> [1; n] </ref>, y i = var (A i ), D = (ff ((fEg z y 2 z = [ by Point 7 of Definition 3.6 ] p (x): D j c = p (x) E; A 1 ; : : : ; A n is a renamed clause of P , <p> ), D = (ff ((fEg z y 2 z = [ by Point 7 of Definition 3.6 ] p (x): D j c = p (x) E; A 1 ; : : : ; A n is a renamed clause of P , z = var (c), for i 2 <ref> [1; n] </ref>, y i = var (A i ), D = (ff (fEg z y 2 z = [ using repeatedly Point 1 of Definition 3.6 and e definition ] p (x): D j c = p (x) E; A 1 ; : : : ; A n is a renamed <p> (fEg z y 2 z = [ using repeatedly Point 1 of Definition 3.6 and e definition ] p (x): D j c = p (x) E; A 1 ; : : : ; A n is a renamed clause of P , z = var (c), for i 2 <ref> [1; n] </ref>, y i = var (A i ), D = (ff (fEg) e y 1 I ff (A 1 ) e y 2 e y n I ff (A n )) ~ j x = [ by P ff JK definition ] P ff JP K (I ff ): Points
Reference: [2] <author> K. R. Apt. </author> <title> From Logic Programming to Prolog. </title> <publisher> Prentice Hall, </publisher> <year> 1997. </year>
Reference-contexts: However an incorrect clause does not always correspond to a bug, * uncovered A -elements always correspond to incompleteness bugs. * there exists no sufficient condition for completeness. The results, even if weaker, are useful and comparable to those obtained by verification techniques (see, for example, <ref> [3, 2] </ref>). In fact, if we consider the 41 case where specifications consist of post-conditions only, both abstract diagno-sis and verification provide a sufficient condition for partial correctness, which is well-assertedness in the case of verification and absence of incorrect clauses in abstract diagnosis.
Reference: [3] <author> K. R. Apt and E. Marchiori. </author> <title> Reasoning about Prolog programs: from modes through types to assertions. </title> <journal> Formal Aspects of Computing, </journal> <volume> 6(6A):743-765, </volume> <year> 1994. </year>
Reference-contexts: However an incorrect clause does not always correspond to a bug, * uncovered A -elements always correspond to incompleteness bugs. * there exists no sufficient condition for completeness. The results, even if weaker, are useful and comparable to those obtained by verification techniques (see, for example, <ref> [3, 2] </ref>). In fact, if we consider the 41 case where specifications consist of post-conditions only, both abstract diagno-sis and verification provide a sufficient condition for partial correctness, which is well-assertedness in the case of verification and absence of incorrect clauses in abstract diagnosis.
Reference: [4] <author> K. R. Apt and D. Pedreschi. </author> <title> Reasoning about termination of pure PRO-LOG programs. </title> <journal> Information and Computation, </journal> <volume> 106(1) </volume> <pages> 109-157, </pages> <year> 1993. </year>
Reference-contexts: However, this property holds for a large class of programs, i.e., for acceptable programs as defined in <ref> [4] </ref>. Acceptable programs are the left-terminating programs, i.e., those programs for which the SLD -derivations of ground goals (via the leftmost selection rule) are finite. Definition 5.7 [4] Let P be a program and B P be its Herbrand base. <p> However, this property holds for a large class of programs, i.e., for acceptable programs as defined in <ref> [4] </ref>. Acceptable programs are the left-terminating programs, i.e., those programs for which the SLD -derivations of ground goals (via the leftmost selection rule) are finite. Definition 5.7 [4] Let P be a program and B P be its Herbrand base. A level mapping for P is a function jj : B P ! N from ground atoms to natural numbers. <p> w.r.t. jj and I, if for every clause A B 1 ; : : : ; B n in Ground (P ) the following implication holds, for i 2 [1; n]: I j= ^ i1 Most interesting programs are acceptable (all the pure PROLOG programs in [43] are reported in <ref> [4] </ref> to be acceptable). The same property holds for the wrong versions of acceptable programs provided that the errors do not affect the left-termination property. One relevant technical property of acceptable programs is that the ground immediate consequence operator has a unique fixpoint [4]. <p> PROLOG programs in [43] are reported in <ref> [4] </ref> to be acceptable). The same property holds for the wrong versions of acceptable programs provided that the errors do not affect the left-termination property. One relevant technical property of acceptable programs is that the ground immediate consequence operator has a unique fixpoint [4]. In the following we show that the same property holds for all the immediate consequence operators P ff JP K, corresponding to complete observables. Before giving the formal proof of the theorem, some additional definitions and lemmata are needed.
Reference: [5] <author> T. Armstrong, K. Marriott, P. Schachte, and H. Stndergaard. </author> <title> Boolean functions for dependency analysis: Algebraic properties and efficient representation. </title> <editor> In B. Le Charlier, editor, </editor> <booktitle> Proc. Static Analysis Symposium, SAS'94, volume 864 of Lecture Notes in Computer Science, </booktitle> <pages> pages 266-280. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Note that the above characterization of approximate observables guarantees the optimality of the abstract immediate consequence operator (see Point 4). 3.4.1 The POS observable for groundness dependencies of computed answers We show now how to model the domain POS, designed for the groundness analysis of logic programs <ref> [19, 36, 5] </ref>. POS is a domain of equivalence classes of propositional formulas, built using the logical connectives $, ^ and _, and ordered by implication. The propositional formulas represent groundness dependencies among variables.
Reference: [6] <author> A. Bossi and N. Cocco. </author> <title> Verifying correctness of logic programs. </title> <editor> In J. Diaz and F. Orejas, editors, </editor> <booktitle> Proc. TAPSOFT'89, </booktitle> <pages> pages 96-110, </pages> <year> 1989. </year>
Reference: [7] <author> A. Bossi, M. Gabbrielli, G. Levi, and M. Martelli. </author> <title> The s-semantics approach: </title> <journal> Theory and applications. Journal of Logic Programming, </journal> <volume> 19-20:149-197, </volume> <year> 1994. </year>
Reference: [8] <author> A. Bossi, M. Gabbrielli, G. Levi, and M. C. Meo. </author> <title> A Compositional Semantics for Logic Programs. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 122(1-2):3-47, </address> <year> 1994. </year>
Reference-contexts: The idea is that of performing the diagnosis in a modular way, i.e., module by module. Modular analysis is usually based on an OR-compositional semantics. For example, the modular analysis framework in [10] is based on the OR-compositional version of the s-semantics <ref> [8] </ref>. Our concrete semantics is not OR-compositional and this is obviously true for all its abstractions. However, we can note that abstract diagnosis does not require to actually compute the abstract semantics, since it is simply based on one application of the abstract immediate consequence operator to the specification.
Reference: [9] <author> K. L. Clark. </author> <title> Predicate logic as a computational formalism. Res. </title> <type> Report DOC 79/59, </type> <institution> Imperial College, Dept. of Computing, </institution> <address> London, </address> <year> 1979. </year>
Reference-contexts: observable) and the observables correct answers and ground instances of computed answers, whose semantics are the atomic logical consequence observables (c-semantics) and the least Her brand model, respectively. 3.3.1 The correct answer observable We show how to obtain a semantics which models correct answers and is isomorphic to the c-semantics <ref> [9, 25] </ref>. A similar construction can be used to define ground correct answers leading to the least Herbrand model semantics. Correct answers are closed under instantiation. This property corresponds to the downward closure of the corresponding equation sets. These sets can be (efficiently) handled with maximal equation sets w.r.t.
Reference: [10] <author> M. Codish, S. K. Debray, and R. Giacobazzi. </author> <title> Compositional Analysis of Modular Logic Programs. </title> <booktitle> In Proc. Twentieth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 451-464. </pages> <publisher> ACM Press, </publisher> <year> 1993. </year>
Reference-contexts: The idea is that of performing the diagnosis in a modular way, i.e., module by module. Modular analysis is usually based on an OR-compositional semantics. For example, the modular analysis framework in <ref> [10] </ref> is based on the OR-compositional version of the s-semantics [8]. Our concrete semantics is not OR-compositional and this is obviously true for all its abstractions. <p> The conclusion is that our theory of abstract diagnosis can directly be applied to modular diagnosis, as we will formally show in the following. We assume a program P to be partitioned into predicate-disjoint modules <ref> [10] </ref>, such that each predicate symbol is completely defined by a single module. 42 Namely, Definition 8.1 A program partitioning P 1 ; : : : ; P n is predicate-disjoint if 8i 6= j: preds (P i ) " preds (P j ) = ;, where preds (P ) =
Reference: [11] <author> M. Comini and G. Levi. </author> <title> An algebraic theory of observables. </title> <editor> In M. Bruynooghe, editor, </editor> <booktitle> Proceedings of the 1994 Int'l Symposium on Logic Programming, </booktitle> <pages> pages 172-186. </pages> <publisher> The MIT Press, </publisher> <year> 1994. </year>
Reference: [12] <author> M. Comini, G. Levi, and M. C. Meo. </author> <title> Compositionality of SLD -derivations and their abstractions. </title> <editor> In J. Lloyd, editor, </editor> <booktitle> Proceedings of the 1995 Int'l Symposium on Logic Programming, </booktitle> <pages> pages 561-575. </pages> <publisher> The MIT Press, </publisher> <year> 1995. </year>
Reference: [13] <author> M. Comini, G. Levi, and M. C. Meo. </author> <title> A theory of ob-servables for logic programs. </title> <note> Submitted for publication. http://www.di.unipi.it/~comini/Papers/, 1996. </note>
Reference: [14] <author> M. Comini, G. Levi, M. C. Meo, and G. Vitiello. </author> <title> Proving properties of logic programs by abstract diagnosis. </title> <editor> In M. Dams, editor, </editor> <title> Analysis and Verification of Multiple-Agent Languages, </title> <booktitle> 5th LOMAPS Workshop, volume 1192 of Lecture Notes in Computer Science, </booktitle> <pages> pages 22-50. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference: [15] <author> M. Comini, G. Levi, and G. Vitiello. </author> <title> Abstract debugging of logic programs. </title> <editor> In L. Fribourg and F. Turini, editors, </editor> <booktitle> Proc. Logic Program Synthesis and Transformation and Metaprogramming in Logic 1994, volume 883 of Lecture Notes in Computer Science, </booktitle> <pages> pages 440-450. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference: [16] <author> M. Comini, G. Levi, and G. Vitiello. </author> <title> Declarative diagnosis revisited. </title> <editor> In J. Lloyd, editor, </editor> <booktitle> Proceedings of the 1995 Int'l Symposium on Logic Programming, </booktitle> <pages> pages 275-287. </pages> <publisher> The MIT Press, </publisher> <year> 1995. </year>
Reference-contexts: We will later consider approximate observables in Section 7. 5 Abstract diagnosis w.r.t. complete observables Remember first that computed answers, correct answers and ground correct answers are all complete observables. Hence, the results of this section apply to the diagnosis w.r.t. computed answers <ref> [16] </ref> and to the declarative diagnoses in [41, 26]. In this section ff will always denote a complete observable. The first theorem shows the relation between partial correctness (Point 1 of Definition 4.1) and absence of incorrect clauses (Definition 4.5).
Reference: [17] <author> M. Comini, G. Levi, and G. Vitiello. </author> <title> Efficient detection of incompleteness errors in the abstract debugging of logic programs. </title> <editor> In M. Ducasse, editor, </editor> <booktitle> Proc. 2nd International Workshop on Automated and Algorithmic Debugging, </booktitle> <address> AADEBUG'95, </address> <year> 1995. </year>
Reference: [18] <author> M. Comini and M. C. Meo. </author> <title> Compositionality properties of SLD -derivations. </title> <booktitle> Theoretical Computer Science, </booktitle> <year> 1997. </year> <note> To appear. </note>
Reference: [19] <author> A. Cortesi, G. File, and W. Winsborough. </author> <title> Prop revisited: Propositional Formula as Abstract Domain for Groundness Analysis. </title> <booktitle> In Proc. Sixth IEEE Symp. on Logic In Computer Science, </booktitle> <pages> pages 322-327. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: Note that the above characterization of approximate observables guarantees the optimality of the abstract immediate consequence operator (see Point 4). 3.4.1 The POS observable for groundness dependencies of computed answers We show now how to model the domain POS, designed for the groundness analysis of logic programs <ref> [19, 36, 5] </ref>. POS is a domain of equivalence classes of propositional formulas, built using the logical connectives $, ^ and _, and ordered by implication. The propositional formulas represent groundness dependencies among variables.
Reference: [20] <author> P. Cousot and R. Cousot. </author> <title> Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fix-points. </title> <booktitle> In Proc. Fourth ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 238-252, </pages> <year> 1977. </year>
Reference: [21] <author> P. Cousot and R. Cousot. </author> <title> Systematic Design of Program Analysis Frameworks. </title> <booktitle> In Proc. Sixth ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 269-282, </pages> <year> 1979. </year>
Reference: [22] <author> W. Drabent and J. Maluszynski. </author> <title> Inductive assertion method for logic programs. </title> <journal> Theoretical Computer Science, </journal> <volume> 59(1) </volume> <pages> 133-155, </pages> <year> 1988. </year>
Reference: [23] <author> W. Drabent, S. Nadjm-Tehrani, and J. Maluszynski. </author> <title> Algorithmic debugging with assertions. </title> <editor> In H. Abramson and M.H. Rogers, editors, </editor> <booktitle> Meta-Programming in Logic Programming, </booktitle> <pages> pages 383-398. </pages> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: In order to tackle the effectivity problem, we need to be able to handle finite specifications. There exist three possible solutions. 30 Assertions A specification can intentionally be defined by assertions, in the style of program verification as first suggested by <ref> [23] </ref>. We will not consider assertions in this paper. Let us just mention that the results in [31] can provide the basis for extending diagnosis to assertions.
Reference: [24] <author> E. Eder. </author> <title> Properties of substitutions and unification. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 1 </volume> <pages> 31-46, </pages> <year> 1985. </year>
Reference: [25] <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> Declarative Modeling of the Operational Behavior of Logic Languages. </title> <journal> Theoretical Computer Science, </journal> <volume> 69(3) </volume> <pages> 289-318, </pages> <year> 1989. </year>
Reference-contexts: observable) and the observables correct answers and ground instances of computed answers, whose semantics are the atomic logical consequence observables (c-semantics) and the least Her brand model, respectively. 3.3.1 The correct answer observable We show how to obtain a semantics which models correct answers and is isomorphic to the c-semantics <ref> [9, 25] </ref>. A similar construction can be used to define ground correct answers leading to the least Herbrand model semantics. Correct answers are closed under instantiation. This property corresponds to the downward closure of the corresponding equation sets. These sets can be (efficiently) handled with maximal equation sets w.r.t.
Reference: [26] <author> G. Ferrand. </author> <title> Error Diagnosis in Logic Programming, an Adaptation of E. Y. Shapiro's Method. </title> <journal> Journal of Logic Programming, </journal> <volume> 4 </volume> <pages> 177-198, </pages> <year> 1987. </year>
Reference-contexts: The following Definition 4.1 extends to abstract diagnosis the definitions given in <ref> [41, 26, 33] </ref> for declarative diagnosis. In the following I ff is the specification of the intended behavior of a program for pure atoms w.r.t. the observable ff. Definition 4.1 Let P be a program and ff be an observable. 1. P is partially correct w.r.t. <p> An incompleteness symptom is an A -element such that I ff and 6 ff (FJP K). Note that a totally correct program has no incorrectness and no incompleteness symptoms. Our incompleteness symptoms are related to the insufficiency symptoms in <ref> [26] </ref>, which are defined by taking gfp PJP K instead of FJP K = lfp PJP K as program semantics. The two definitions, even if different, turn out to be the same for the class of acceptable programs (see Section 5.1). <p> Hence, the results of this section apply to the diagnosis w.r.t. computed answers [16] and to the declarative diagnoses in <ref> [41, 26] </ref>. In this section ff will always denote a complete observable. The first theorem shows the relation between partial correctness (Point 1 of Definition 4.1) and absence of incorrect clauses (Definition 4.5). <p> The converse does not hold, as shown by Example 4.7. Note that, if PJP K has a unique fixpoint, lfp PJP K = gfp PJP K. Hence, under this hypothesis, our incompleteness symptoms are exactly the insufficiency symptoms in <ref> [26] </ref>. Note that the second part of Theorem 5.4 asserts that there might be uncovered A -elements even if there are no incompleteness symptoms.
Reference: [27] <author> G. Ferrand. </author> <title> The notions of symptom and error in declarative diagnosis of logic programs. </title> <editor> In P. A. Fritzson, editor, </editor> <booktitle> Automated and Algorithmic Debugging, Proc. AADEBUG '93, volume 749 of Lecture Notes in Computer Science, </booktitle> <pages> pages 40-57. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <month> 69 </month>
Reference-contexts: Ferrand's choice is motivated by the fact that gfp PJP K is related to finite failures. The approach of using two different semantics for reasoning about incorrectness and incompleteness has been pursued in <ref> [27] </ref>, leading to an elegant uniform (yet non-effective) characterization of correctness and completeness. 19 c1: q (X) :- p (X). It is straightforward to realize that an A -element may sometimes be an incorrectness or incompleteness symptom, just because of another symptom. <p> with (I + ff ; I ff I ff and I The idea is that a partial specification (I + ff ; I ff ) stands for all possible specifi cations I ff which are consistent with (I + ff ; I Positive and negative specifications have been used in <ref> [27] </ref>, for the correct answer observable , with the aim of separately modeling the behavior w.r.t. incorrectness and incompleteness. <p> This would in turn require a specification consisting of a pair of abstractions of the intended concrete semantics. This is an interesting idea for further research that might build upon the already mentioned approach by Ferrand <ref> [27] </ref>, which works with pairs of specifications. 8 Modular abstract diagnosis In modular abstract diagnosis we are concerned with programs composed of separate modules. The idea is that of performing the diagnosis in a modular way, i.e., module by module. Modular analysis is usually based on an OR-compositional semantics.
Reference: [28] <author> R. Giacobazzi and F. Scozzari. </author> <title> Intuitionistic implication in abstract in-terpretation. </title> <editor> In H. Glaser, P. Hartel, and H. Kuchen, editors, </editor> <booktitle> Proceedings of Ninth International Symposium on Programming Languages, Implementations, Logics and Programs PLILP'97, volume 1292 of Lecture Notes in Computer Science, </booktitle> <pages> pages 175-189. </pages> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference: [29] <author> J. L. Lassez, M. J. Maher, and K. Marriott. </author> <title> Unification Revisited. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 587-625. </pages> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, Ca., </address> <year> 1988. </year>
Reference: [30] <author> G. Levi and F. Spoto. </author> <title> A Denotational Semantics for Prolog. </title> <editor> In M. Falaschi, M. Navarro, and A. Policriti, editors, </editor> <booktitle> Proceedings of the APPIA-GULP-PRODE'97 Joint Conference on Declarative Programming, </booktitle> <pages> pages 201-212, </pages> <year> 1997. </year>
Reference-contexts: PROLOG. It is worth noting that this can easily be done, once we have a semantics framework for PROLOG similar to the one we have used here for pure logic programs. Such a framework has indeed already been defined <ref> [30] </ref>. It handles almost all the impure features of PROLOG (including cut). The collecting semantics has all the properties which are relevant to diagnosis, namely the condensing property and the equivalence between operational and denotational denotations. Another relevant issue is related to the abstract operations associated to an observable.
Reference: [31] <author> G. Levi and P. Volpe. </author> <title> A reconstruction of verification techniques by abstract interpretation. In ILPS'97. Workshop on Verification, Model Checking and Abstract Interpretation, </title> <year> 1997. </year>
Reference-contexts: There exist three possible solutions. 30 Assertions A specification can intentionally be defined by assertions, in the style of program verification as first suggested by [23]. We will not consider assertions in this paper. Let us just mention that the results in <ref> [31] </ref> can provide the basis for extending diagnosis to assertions. Partial specifications A specification is a finite subset I + of the intended semantics, plus a finite subset I of the complement of the intended semantics. <p> Since this leads to a further loss of precision, the accuracy of the diagnosis method will of course be affected. The same arguments apply to the case of non-condensing observables. Finally, let us mention that some recent results on the reconstruction of verification techniques by abstract interpretation <ref> [31] </ref> show that it is quite easy to extend abstract diagnosis to specifications consisting of pre- and post-conditions. Handling pre-conditions simply requires the choice of a more concrete collecting semantics, modeling call patterns in addition to computed answers.
Reference: [32] <author> Y. Lichtenstein and E. Y. Shapiro. </author> <title> Abstract algorithmic debugging. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> <booktitle> Proc. Fifth Int'l Conf. and Symp. on Logic Programming, </booktitle> <pages> pages 512-531, </pages> <address> Seattle, </address> <year> 1988. </year>
Reference: [33] <author> J. W. Lloyd. </author> <title> Declarative error diagnosis. </title> <journal> New Generation Computing, </journal> <volume> 5(2) </volume> <pages> 133-154, </pages> <year> 1987. </year>
Reference-contexts: The following Definition 4.1 extends to abstract diagnosis the definitions given in <ref> [41, 26, 33] </ref> for declarative diagnosis. In the following I ff is the specification of the intended behavior of a program for pure atoms w.r.t. the observable ff. Definition 4.1 Let P be a program and ff be an observable. 1. P is partially correct w.r.t.
Reference: [34] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <year> 1987. </year> <note> Second edition. </note>
Reference: [35] <author> P. Mancarella and D. Pedreschi. </author> <title> An Algebra of Logic Programs. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> <booktitle> Proc. Fifth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 1006-1023. </pages> <publisher> The MIT Press, </publisher> <year> 1988. </year>
Reference-contexts: However, we can note that abstract diagnosis does not require to actually compute the abstract semantics, since it is simply based on one application of the abstract immediate consequence operator to the specification. The s-semantics immediate consequence operator is known to be OR-compositional (see for example <ref> [35] </ref>). The same result holds (by definition) for all the abstract immediate consequence operator corresponding to complete and approximate observables. The conclusion is that our theory of abstract diagnosis can directly be applied to modular diagnosis, as we will formally show in the following.
Reference: [36] <author> K. Marriott and H. Stndergaard. </author> <title> Precise and efficient groundness analysis for logic programs. </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <volume> 2(1-4):181-196, </volume> <year> 1993. </year>
Reference-contexts: Note that the above characterization of approximate observables guarantees the optimality of the abstract immediate consequence operator (see Point 4). 3.4.1 The POS observable for groundness dependencies of computed answers We show now how to model the domain POS, designed for the groundness analysis of logic programs <ref> [19, 36, 5] </ref>. POS is a domain of equivalence classes of propositional formulas, built using the logical connectives $, ^ and _, and ordered by implication. The propositional formulas represent groundness dependencies among variables.
Reference: [37] <author> L. Naish. </author> <title> Declarative diagnosis of missing answers. </title> <journal> New Generation Computing, </journal> <volume> 10 </volume> <pages> 255-285, </pages> <year> 1991. </year>
Reference-contexts: In the top-down diagnosis, I ff can more naturally be viewed as an abstract oracle, i.e., it can be implemented by querying the user. Several oracles have been used in declarative debugging (see the discussion in <ref> [37] </ref>). The abstract oracle implementation of I ff can be modeled as a function which, whenever applied to a pure atom (the query to the user), returns the abstraction of the set of all the intended computed answers. <p> They are parametric w.r.t. the observable (the parameter Obs in the two main procedures), whose operations have to be specified in a suitable module. Apart from being generic, the meta-interpreters are very similar to those proposed for declarative diagnosis (see <ref> [37] </ref> for a comprehensive description). The main difference is that they do not need to start from symptoms. In fact, as expected from the definitions in Section 4.2, the oracle simulation just needs to be applied to finitely many pure atomic goals (generated by the call to userdefined/2).
Reference: [38] <author> L. M. Pereira. </author> <title> Rational debugging in logic programming. </title> <editor> In E. Y. Shapiro, editor, </editor> <booktitle> Proceedings of the 3rd International Conference on Logic Programming, volume 225 of Lecture Notes in Computer Science, </booktitle> <pages> pages 203-210. </pages> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference: [39] <author> T. Sato and H. Tamaki. </author> <title> Enumeration of Success Patterns in Logic Programs. </title> <journal> Theoretical Computer Science, </journal> <volume> 34 </volume> <pages> 227-240, </pages> <year> 1984. </year>
Reference: [40] <author> F. Scozzari. </author> <title> Logical optimality of groundness analysis. </title> <editor> In P. Van Hen-tenryck, editor, </editor> <booktitle> Proceedings of International Static Analysis Symposium, SAS'97, volume 1302 of Lecture Notes in Computer Science, </booktitle> <pages> pages 83-97. </pages> <publisher> Springer-Verlag, </publisher> <year> 1997. </year> <month> 70 </month>
Reference: [41] <author> E. Y. Shapiro. </author> <title> Algorithmic program debugging. </title> <booktitle> In Proc. Ninth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 412-531. </pages> <publisher> ACM Press, </publisher> <year> 1982. </year>
Reference-contexts: The following Definition 4.1 extends to abstract diagnosis the definitions given in <ref> [41, 26, 33] </ref> for declarative diagnosis. In the following I ff is the specification of the intended behavior of a program for pure atoms w.r.t. the observable ff. Definition 4.1 Let P be a program and ff be an observable. 1. P is partially correct w.r.t. <p> Once we have the oracle, we can define the abstract oracle simulation, following <ref> [41] </ref>. The oracle simulation allows us to express in a compact way new top-down diagnosis conditions. The oracle simulation performs one step of abstract goal rewriting by using the program clauses and then gets the abstract answers for the resulting abstract goal from the oracle. <p> Hence, the results of this section apply to the diagnosis w.r.t. computed answers [16] and to the declarative diagnoses in <ref> [41, 26] </ref>. In this section ff will always denote a complete observable. The first theorem shows the relation between partial correctness (Point 1 of Definition 4.1) and absence of incorrect clauses (Definition 4.5).
Reference: [42] <author> F. Spoto. </author> <title> Un interprete astratto per programmi logici con cut. In Italian. </title> <note> http://tiramisu.di.unipi.it/~spoto/analyzer95.ps.gz, December 1995. </note>
Reference-contexts: B.3 The POS observable (ff ) The implementation of POS is clearly much more complex than the previous ones. The following programs are essentially an interface plus the POS implementation adapted from an original abstract interpretation framework for PROLOG <ref> [42] </ref>. observableAnswers (pos (subst), A, Epos) :- oracle (pos (subst), A, F), posubToPos (F,Epos). observableClause (pos (subst), A, Epos, B, C) :- observableClause (subst, A, E, B, C), posubEqua ((A:-B), E, F), posubToPos (F,Ebig), varsOf ((A,B),Vars), posProj (Ebig, Vars, Epos). domainBottom (pos (subst), X) :- posBottom (X). 62 domainJoin (pos (subst),
Reference: [43] <author> L. Sterling and E. Y. Shapiro. </author> <title> The Art of Prolog. </title> <publisher> The MIT Press, </publisher> <year> 1986. </year> <month> 71 </month>
Reference-contexts: P is acceptable w.r.t. jj and I, if for every clause A B 1 ; : : : ; B n in Ground (P ) the following implication holds, for i 2 [1; n]: I j= ^ i1 Most interesting programs are acceptable (all the pure PROLOG programs in <ref> [43] </ref> are reported in [4] to be acceptable). The same property holds for the wrong versions of acceptable programs provided that the errors do not affect the left-termination property. One relevant technical property of acceptable programs is that the ground immediate consequence operator has a unique fixpoint [4].
References-found: 43

