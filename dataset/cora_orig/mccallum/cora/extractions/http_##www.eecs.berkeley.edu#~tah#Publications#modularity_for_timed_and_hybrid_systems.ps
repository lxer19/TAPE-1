URL: http://www.eecs.berkeley.edu/~tah/Publications/modularity_for_timed_and_hybrid_systems.ps
Refering-URL: http://www.eecs.berkeley.edu/~tah/Publications/modularity_for_timed_and_hybrid_systems.html
Root-URL: 
Email: Email: falur,tahg@eecs.berkeley.edu  
Title: Modularity for Timed and Hybrid Systems  
Author: Rajeev Alur Thomas A. Henzinger 
Address: Berkeley, CA 94720-1770, U.S.A.  
Affiliation: EECS Department, University of California,  
Abstract: In a trace-based world, the modular specification, verification, and control of live systems require each module to be receptive; that is, each module must be able to meet its liveness assumptions no matter how the other modules behave. In a real-time world, liveness is automatically present in the form of diverging time. The receptiveness condition, then, translates to the requirement that a module must be able to let time diverge no matter how the environment behaves. We study the receptiveness condition for real-time systems by extending the model of reactive modules to timed and hybrid modules. We define the receptiveness of such a module as the existence of a winning strategy in a game of the module against its environment. By solving the game on region graphs, we present an (optimal) EXPTIME algorithm for checking the receptiveness of propositional timed modules. By giving a fixpoint characterization of the game, we present a symbolic procedure for checking the receptiveness of linear hybrid modules. Finally, we present an assume-guarantee principle for reasoning about timed and hybrid modules, and a method for synthesizing receptive controllers of timed and hybrid modules.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Alur, C. Courcoubetis, N. Halbwachs, T.A. Henzinger, P.-H. Ho, X. Nicollin, A. Olivero, J. Sifakis, S. Yovine. </author> <title> The algorithmic analysis of hybrid systems. </title> <journal> Theoretical Computer Science, </journal> <volume> 138 </volume> <pages> 3-34, </pages> <year> 1995. </year>
Reference-contexts: Here, we define and algorithmically analyze a receptiveness game for timed systems that are modeled as discrete systems with clock variables, a la timed automata [2], and for hybrid systems that are modeled as discrete systems with continuous variables, a la hybrid automata <ref> [1] </ref>.
Reference: [2] <author> R. Alur, D.L. Dill. </author> <title> A theory of timed automata. </title> <journal> Theoretical Computer Science, </journal> <volume> 126 </volume> <pages> 183-235, </pages> <year> 1994. </year>
Reference-contexts: In the case of real-time systems, a receptiveness game was first defined for I/O automata [17]. Here, we define and algorithmically analyze a receptiveness game for timed systems that are modeled as discrete systems with clock variables, a la timed automata <ref> [2] </ref>, and for hybrid systems that are modeled as discrete systems with continuous variables, a la hybrid automata [1]. <p> Delay element rational constants. For example, the delay element Delay is a propositional timed module. In a technical sense, propositional timed modules are open versions of timed automata <ref> [2] </ref>. Transition graph of a module. Every module P defines an edge-labeled transition graph whose vertices are the states of P , and whose labels are nonnegative reals that represent the durations of transitions. <p> This is the case, for example, for propositional timed modules, where the procedure can be implemented using existing symbolic model checkers such as KRONOS [14]. Enumerative strategy checking. For every timed automaton, there exists a finite partitioning of the state space called region equivalence <ref> [2] </ref>. The definition of region equivalence carries over straightforwardly to the states and the positions of the atoms of propositional timed modules. For an atom A of a propositional timed module, we write ~ = R A for the region equivalence of A.
Reference: [3] <author> K.R. Apt, N. Francez, S. Katz. </author> <title> Appraising fairness in languages for distributed programming. </title> <journal> Distributed Computing, </journal> <volume> 2 </volume> <pages> 226-241, </pages> <year> 1988. </year>
Reference-contexts: Such a controller, of course, cannot be realized physically. 5 For live closed systems, the appropriate condition is machine closure <ref> [3] </ref>: every finite run can be extended to an infinite live run.
Reference: [4] <author> R. Alur, T.A. Henzinger. </author> <title> Local liveness for compositional modeling of fair reactive systems. In Computer-aided Verification, </title> <publisher> Springer LNCS 939, </publisher> <pages> pp. 166-179, </pages> <year> 1995. </year>
Reference-contexts: These proof obligations, however, are rarely satisfied if the components interact. An assume-guarantee principle allows us to replace (a) and (b) by two weaker obligations, namely, (a 0 ) P 1 kQ 2 Q 1 and (b 0 ) Q 1 kP 2 Q 2 <ref> [25, 8, 4] </ref>. Obligation (a 0 ) asserts that P 1 implements Q 1 , under the hypothesis that its environment behaves like Q 2 , and obligation (b 0 ) asserts that P 2 implements Q 2 , under the hypothesis that its environment behaves like Q 1 .
Reference: [5] <author> R. Alur, T.A. Henzinger. </author> <title> Reactive modules. </title> <booktitle> In Proc. IEEE Symp. Logic in Computer Science, </booktitle> <pages> pp. 207-218, </pages> <year> 1996. </year>
Reference-contexts: The module is called receptive iff in this game, it has a strategy that will never generate a convergent trajectory unless all but finitely many moves are charged to the environment. Since timed and hybrid automata are models for closed systems, we extend the open-system model of reactive modules <ref> [5] </ref> with clock variables, to obtain timed modules, and with continuous variables, to obtain hybrid modules. The formalism of reactive modules was developed for specifying highly heterogeneous systems, with mixed hardware and software components, and mixed synchronous and asynchronous interactions between components. <p> of the nonnegative reals, our motivation and our conclusions apply equally to the digital-clock model, where all time-stamps are truncated to integer values, and a system may prevent time from diverging by insisting on infinitely many moves of delay 0. 2 Timed Modules We extend the model of reactive modules <ref> [5] </ref> to allow for the specification of real-time behavior. Discrete variables vs. clock variables. A timed module P has a finite set of typed variables, denoted X P . Some of the variables are updated in a discrete fashion, and the other variables change continuously when time elapses. <p> If the input changes while the module is unstable, a hazard occurs, and the output may change arbitrarily, independently of the input. Note that if the module is stable or hazardous, any amount of time may elapse. It is easy to describe synchronous gates and latches as modules <ref> [5] </ref>. Asynchronous circuits, then, can be described by combining gates, latches, and delay elements [13]. Propositional timed modules. <p> enumerated), and if the initial actions, the update actions, and the delays of P constrain the clock variables in very restricted ways: in guards and invariants, clocks are compared to rational constants, and in assignments, clocks are either left unchanged or assigned 7 Round-insensitivity is not required for discrete modules <ref> [5] </ref>, but allows the treatment of degenerate, zero duration time rounds as update rounds. 5 module Delay interface out : B external in : B private state : fstable; unstable; hazardg; x : C atom state; out; x awaits in 0 init state 0 := stable; out 0 := in 0 <p> The fourth condition is conventional trace inclusion. It is easy to check that the implementation relation is a preorder (i.e., reflexive and transitive). Parallel composition. Modules can be combined using the three operations of variable renaming, variable hiding, and parallel composition <ref> [5] </ref>. Here, we focus on parallel composition only.
Reference: [6] <author> R. Alur, T.A. Henzinger, P.-H. Ho. </author> <title> Automatic symbolic verification of embedded systems. </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> 22 </volume> <pages> 181-201, </pages> <year> 1996. </year>
Reference-contexts: and hybrid modules; the soundness of the principle depends on the receptiveness of all participating modules. 6 Second, by giving a fixpoint characterization of the receptiveness game, we develop a symbolic procedure for checking the receptiveness of timed and linear hybrid modules (which are closely related to linear hybrid automata <ref> [6] </ref>); this procedure can be easily implemented in existing tools such as KRONOS [14] and HYTECH [19]. <p> In a technical sense, linear hybrid modules are open versions of linear hybrid automata <ref> [6] </ref>. Trace semantics. An X-atom A permits the flow f for X if (f (0); f [wait X A ]; f [ctrX A ]) 2 Flow A .
Reference: [7] <editor> R. Alur, T.A. Henzinger, E.D. Sontag, eds. </editor> <title> Hybrid Systems III: Verification and Control. </title> <publisher> Springer LNCS 1066, </publisher> <year> 1996. </year>
Reference-contexts: 1 Introduction Over the past decade, much research has focused on the modeling and verification of timed systems [12], which have hard real-time constraints, and hybrid systems <ref> [16, 11, 7] </ref>, which contain both discrete and continuous components.
Reference: [8] <author> M. Abadi, L. Lamport. </author> <title> Composing specifications. </title> <journal> ACM Trans. Programming Languages and Systems, </journal> <volume> 15 </volume> <pages> 73-132, </pages> <year> 1993. </year>
Reference-contexts: A proper condition for live open systems, therefore, must take into account adversarial, rather than cooperative, environments. Such a condition, called receptiveness, is best formulated as a game <ref> [13, 8, 17] </ref>: a module is receptive iff in a two-player game against the environment, the module has a strategy to generate an infinite live run. Then, the composition of two receptive modules is again receptive (and machine-closed). <p> These proof obligations, however, are rarely satisfied if the components interact. An assume-guarantee principle allows us to replace (a) and (b) by two weaker obligations, namely, (a 0 ) P 1 kQ 2 Q 1 and (b 0 ) Q 1 kP 2 Q 2 <ref> [25, 8, 4] </ref>. Obligation (a 0 ) asserts that P 1 implements Q 1 , under the hypothesis that its environment behaves like Q 2 , and obligation (b 0 ) asserts that P 2 implements Q 2 , under the hypothesis that its environment behaves like Q 1 .
Reference: [9] <author> M. Abadi, L. Lamport. </author> <title> An old-fashioned recipe for real time. In Real Time: Theory in Practice, </title> <publisher> Springer LNCS 600, </publisher> <pages> pp. 1-27, </pages> <year> 1992. </year>
Reference-contexts: Such a controller, of course, cannot be realized physically. 5 For live closed systems, the appropriate condition is machine closure [3]: every finite run can be extended to an infinite live run. In the case of real-time systems, the machine-closure condition is usually called nonzenoness <ref> [9, 18] </ref>: every finite trajectory can be extended to a divergent trajectory; that is, no matter what the system does, there is always a possibility for time to diverge. Since machine closure is not closed under parallel composition, for live open systems, the appropriate condition becomes trickier. <p> Furthermore, it follows that for propositional timed modules, the problem of checking nonzenoness is complete for PSPACE. Receptive modules. Nonzenoness is an existential property of a module, and hence, it is not preserved under composition <ref> [9, 17] </ref>. A simple case in point is the module Nonreceptive of cooperation of the environment. In particular, if the environment keeps the value of the external variable a always 1, then time cannot progress beyond 2.
Reference: [10] <author> E. Asarin, O. Maler, A. Pnueli. </author> <title> Symbolic controller synthesis for discrete and timed systems. In Hybrid Systems II, </title> <publisher> Springer LNCS 999, </publisher> <pages> pp. 1-20, </pages> <year> 1995. </year>
Reference-contexts: The formalism of reactive modules was developed for specifying highly heterogeneous systems, with mixed hardware and software components, and mixed synchronous and asynchronous interactions between components. We continue this theme 5 To circumvent such absurdities, <ref> [10] </ref> introduce an anti-Zeno constant ffi for controllers, which ensures that a controller cannot act more than once every ffi time units.
Reference: [11] <author> P. Antsaklis, A. Nerode, W. Kohn, S. Sastry, eds. </author> <title> Hybrid Systems II. </title> <publisher> Springer LNCS 999, </publisher> <year> 1995. </year>
Reference-contexts: 1 Introduction Over the past decade, much research has focused on the modeling and verification of timed systems [12], which have hard real-time constraints, and hybrid systems <ref> [16, 11, 7] </ref>, which contain both discrete and continuous components.
Reference: [12] <editor> J.W. de Bakker, K. Huizing, W.-P. de Roever, G. Rozenberg, eds. </editor> <title> Real Time: Theory in Practice. </title> <publisher> Springer LNCS 600, </publisher> <year> 1992. </year>
Reference-contexts: 1 Introduction Over the past decade, much research has focused on the modeling and verification of timed systems <ref> [12] </ref>, which have hard real-time constraints, and hybrid systems [16, 11, 7], which contain both discrete and continuous components.
Reference: [13] <author> D.L. Dill. </author> <title> Trace Theory for Automatic Hierarchical Verification of Speed-independent Circuits. </title> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: A proper condition for live open systems, therefore, must take into account adversarial, rather than cooperative, environments. Such a condition, called receptiveness, is best formulated as a game <ref> [13, 8, 17] </ref>: a module is receptive iff in a two-player game against the environment, the module has a strategy to generate an infinite live run. Then, the composition of two receptive modules is again receptive (and machine-closed). <p> Note that if the module is stable or hazardous, any amount of time may elapse. It is easy to describe synchronous gates and latches as modules [5]. Asynchronous circuits, then, can be described by combining gates, latches, and delay elements <ref> [13] </ref>. Propositional timed modules.
Reference: [14] <author> C. Daws, A. Olivero, S. Tripakis, S. Yovine. </author> <title> The tool KRONOS. In Hybrid Systems III, </title> <publisher> Springer LNCS 1066, </publisher> <pages> pp. 208-219, </pages> <year> 1996. </year>
Reference-contexts: all participating modules. 6 Second, by giving a fixpoint characterization of the receptiveness game, we develop a symbolic procedure for checking the receptiveness of timed and linear hybrid modules (which are closely related to linear hybrid automata [6]); this procedure can be easily implemented in existing tools such as KRONOS <ref> [14] </ref> and HYTECH [19]. <p> The procedure is effective as long as we know how to compute the operator Pre. This is the case, for example, for propositional timed modules, where the procedure can be implemented using existing symbolic model checkers such as KRONOS <ref> [14] </ref>. Enumerative strategy checking. For every timed automaton, there exists a finite partitioning of the state space called region equivalence [2]. The definition of region equivalence carries over straightforwardly to the states and the positions of the atoms of propositional timed modules.
Reference: [15] <author> E.A. Emerson, C. Jutla. </author> <title> The complexity of tree automata and logics of programs. </title> <booktitle> In Proc. IEEE Symp. Foundations of Computer Science, </booktitle> <pages> pp. 328-337, </pages> <year> 1988. </year>
Reference-contexts: This gives a symbolic procedure for solving the supervisory-control problem. Since the complexity of solving a single-pair Streett game on a finite graph is cubic in the number of vertices <ref> [15] </ref>, we have an exponential decision procedure for the supervisory control of propositional timed modules. Theorem 18. Given a receptive propositional timed module P and a set safe of observations of P , the supervisory-control problem (P; safe) is complete for EXPTIME.
Reference: [16] <editor> R.L. Grossman, A. Nerode, A.P. Ravn, H. Rischel, eds. </editor> <title> Hybrid Systems. </title> <publisher> Springer LNCS 736, </publisher> <year> 1993. </year>
Reference-contexts: 1 Introduction Over the past decade, much research has focused on the modeling and verification of timed systems [12], which have hard real-time constraints, and hybrid systems <ref> [16, 11, 7] </ref>, which contain both discrete and continuous components.
Reference: [17] <author> R. Gawlick, R. Segala, J.F. Sogaard-Andersen, N.A. Lynch. </author> <title> Liveness in timed and untimed systems. In Automata, Languages, and Programming, </title> <publisher> Springer LNCS 820, </publisher> <pages> pp. 166-177, </pages> <year> 1994. </year>
Reference-contexts: award CCR-9501708, by the NSF grant CCR-9504469, by the AFOSR contract F49620-93-1-0056, by the ARO MURI grant DAAH-04-96-1-0341, by the ARPA grant NAG2-892, and by the SRC contract 95-DC-324.036. 3 Including most previous work by the authors. 4 A notable exception is the work on timed and hybrid I/O automata <ref> [17, 23] </ref>. the classical zeno paradox: a discrete observer that looks at a runner at times 1=2, 3=4, 7=8, etc., will never observe the runner cross the finishing line. <p> A proper condition for live open systems, therefore, must take into account adversarial, rather than cooperative, environments. Such a condition, called receptiveness, is best formulated as a game <ref> [13, 8, 17] </ref>: a module is receptive iff in a two-player game against the environment, the module has a strategy to generate an infinite live run. Then, the composition of two receptive modules is again receptive (and machine-closed). <p> Then, the composition of two receptive modules is again receptive (and machine-closed). In the case of real-time systems, a receptiveness game was first defined for I/O automata <ref> [17] </ref>. Here, we define and algorithmically analyze a receptiveness game for timed systems that are modeled as discrete systems with clock variables, a la timed automata [2], and for hybrid systems that are modeled as discrete systems with continuous variables, a la hybrid automata [1]. <p> Furthermore, it follows that for propositional timed modules, the problem of checking nonzenoness is complete for PSPACE. Receptive modules. Nonzenoness is an existential property of a module, and hence, it is not preserved under composition <ref> [9, 17] </ref>. A simple case in point is the module Nonreceptive of cooperation of the environment. In particular, if the environment keeps the value of the external variable a always 1, then time cannot progress beyond 2. <p> Consider an X-atom A, and for simplicity, assume that A has no awaited variables. The receptiveness game starts in a reachable state of A. The two players, the protagonist representing the atom, and the antagonist representing the environment, take turns to incrementally produce an !-trajectory of A. Following <ref> [17] </ref>, each round is charged to one of the two players depending on which player blocks the passage of time. Suppose that the current state of the game is s.
Reference: [18] <author> T.A. Henzinger. </author> <title> Sooner is safer than later. </title> <journal> Information Processing Letters, </journal> <volume> 43 </volume> <pages> 135-141, </pages> <year> 1992. </year>
Reference-contexts: Such a controller, of course, cannot be realized physically. 5 For live closed systems, the appropriate condition is machine closure [3]: every finite run can be extended to an infinite live run. In the case of real-time systems, the machine-closure condition is usually called nonzenoness <ref> [9, 18] </ref>: every finite trajectory can be extended to a divergent trajectory; that is, no matter what the system does, there is always a possibility for time to diverge. Since machine closure is not closed under parallel composition, for live open systems, the appropriate condition becomes trickier.
Reference: [19] <author> T.A. Henzinger, P.-H. Ho, H. Wong-Toi. HYTECH: </author> <title> the next generation. </title> <booktitle> In Proc. IEEE Real-time Systems Symp., </booktitle> <pages> pp. 56-65, </pages> <year> 1995. </year>
Reference-contexts: 6 Second, by giving a fixpoint characterization of the receptiveness game, we develop a symbolic procedure for checking the receptiveness of timed and linear hybrid modules (which are closely related to linear hybrid automata [6]); this procedure can be easily implemented in existing tools such as KRONOS [14] and HYTECH <ref> [19] </ref>. <p> Similarly, the fixpoint characterization of the winning condition for the game from Section 3.3 suggests a symbolic procedure for synthesizing receptive controllers for linear hybrid automata. Both procedures, while not guaranteed to terminate, can be implemented using the primitives supplied by the symbolic model checker HYTECH <ref> [19] </ref> for linear hybrid automata. Example: water tanks. The hybrid module TwoTanks of Figure 3 models two water tanks and a common water source that provides water at the rate of 3 units per second.
Reference: [20] <author> T.A. Henzinger, P.W. Kopke. </author> <title> Discrete-time control for rectangular hybrid automata. In Automata, Languages, and Programming, </title> <publisher> Springer LNCS, </publisher> <year> 1997. </year>
Reference-contexts: The procedure is optimal, because already solving finite reachability games on timed automata is EXPTIME-hard <ref> [20] </ref>. Theorem 16. Given an atom A of a propositional timed module, the problem of checking if A is receptive is complete for EXPTIME.
Reference: [21] <author> T.A. Henzinger, X. Nicollin, J. Sifakis, S. Yovine. </author> <title> Symbolic model checking for real-time systems. </title> <journal> Information and Computation, </journal> <volume> 111 </volume> <pages> 193-244, </pages> <year> 1994. </year>
Reference-contexts: Proposition 8. For every nonzeno module P , every trace in L P can be extended to a trace of arbitrary accumulated duration. The symbolic fixpoint-computation procedure of <ref> [21] </ref> for checking if a given timed automaton is nonzeno can be used for timed modules also. Furthermore, it follows that for propositional timed modules, the problem of checking nonzenoness is complete for PSPACE. Receptive modules.
Reference: [22] <author> G. Hoffmann, H. Wong-Toi. </author> <title> The input-output control of real-time discrete-event systems. </title> <booktitle> In Proc. IEEE Real-time Systems Symp., </booktitle> <pages> pp. 256-265, </pages> <year> 1992. </year>
Reference-contexts: Indeed, applied to a timed system that represents the runner and to a control objective that the state finished is never entered, classical control methods yield a controller that prevents the runner from finishing by issuing infinitely many control actions <ref> [22, 24] </ref>. Such a controller, of course, cannot be realized physically. 5 For live closed systems, the appropriate condition is machine closure [3]: every finite run can be extended to an infinite live run.
Reference: [23] <author> N.A. Lynch, R. Segala, F. Vaandrager, H.B. Weinberg. </author> <title> Hybrid I/O Automata. In Hybrid Systems III, </title> <publisher> Springer LNCS 1066, </publisher> <pages> pp. 496-510, </pages> <year> 1996. </year>
Reference-contexts: award CCR-9501708, by the NSF grant CCR-9504469, by the AFOSR contract F49620-93-1-0056, by the ARO MURI grant DAAH-04-96-1-0341, by the ARPA grant NAG2-892, and by the SRC contract 95-DC-324.036. 3 Including most previous work by the authors. 4 A notable exception is the work on timed and hybrid I/O automata <ref> [17, 23] </ref>. the classical zeno paradox: a discrete observer that looks at a runner at times 1=2, 3=4, 7=8, etc., will never observe the runner cross the finishing line.
Reference: [24] <author> O. Maler, A. Pnueli, J. Sifakis. </author> <title> On the synthesis of discrete controllers for timed systems. </title> <booktitle> In Theoretical Aspects of Computer Science, </booktitle> <publisher> Springer LNCS 900, </publisher> <pages> pp. 229-242, </pages> <year> 1995. </year>
Reference-contexts: Indeed, applied to a timed system that represents the runner and to a control objective that the state finished is never entered, classical control methods yield a controller that prevents the runner from finishing by issuing infinitely many control actions <ref> [22, 24] </ref>. Such a controller, of course, cannot be realized physically. 5 For live closed systems, the appropriate condition is machine closure [3]: every finite run can be extended to an infinite live run. <p> This problem, and more general control problems, can be solved using fixpoint computation <ref> [24] </ref>: first, compute the set controllable of states of the module P in which the environment has a winning strategy for the winning condition 2safe; then, construct a module Q that, when composed with P , prevents P from leaving the set controllable.
Reference: [25] <author> A. Pnueli. </author> <title> In transition from global to modular temporal reasoning about programs. In Logics and Models of Concurrent Systems, </title> <publisher> Springer LNCS, </publisher> <pages> pp. 123-144, </pages> <year> 1984. </year>
Reference-contexts: These proof obligations, however, are rarely satisfied if the components interact. An assume-guarantee principle allows us to replace (a) and (b) by two weaker obligations, namely, (a 0 ) P 1 kQ 2 Q 1 and (b 0 ) Q 1 kP 2 Q 2 <ref> [25, 8, 4] </ref>. Obligation (a 0 ) asserts that P 1 implements Q 1 , under the hypothesis that its environment behaves like Q 2 , and obligation (b 0 ) asserts that P 2 implements Q 2 , under the hypothesis that its environment behaves like Q 1 .
Reference: [26] <author> P.J. Ramadge, W.M. Wonham. </author> <title> Supervisory control of a class of discrete-event processes. </title> <journal> SIAM J. Control and Optimization, </journal> <volume> 25 </volume> <pages> 206-230, </pages> <year> 1987. </year>
Reference-contexts: Controller Synthesis for Propositional Timed Modules The supervisory-control problem for modules asks, given a module P (the plant) and a set safe of observations of P , construct a module Q (the supervisor or controller) such that the observations of all reachable states of P kQ are contained in safe <ref> [26] </ref>.
Reference: [27] <author> S. Tasiran, R. Alur, R.P. Kurshan, R.K. Brayton. </author> <title> Verifying abstractions of timed systems. In Concur-rency Theory, </title> <publisher> Springer LNCS 1119, </publisher> <pages> pp. 546-562, </pages> <year> 1996. </year> <month> 15 </month>
Reference-contexts: An observation of P is a valuation for the variables in obsX P . The observation of a state s, then, is the projection s [obs X P ] of s to the observable variables. 6 A more specialized assume-guarantee principle for timed systems was presented in <ref> [27] </ref>. Its soundness follows from syntactic restrictions that ensure receptiveness. 3 Update rounds vs. time rounds. The module P proceeds in a sequence of rounds. The first round is an initialization round, during which the variables in X P are initialized.
References-found: 27

