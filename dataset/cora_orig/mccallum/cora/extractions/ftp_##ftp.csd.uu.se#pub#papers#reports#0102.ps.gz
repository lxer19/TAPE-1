URL: ftp://ftp.csd.uu.se/pub/papers/reports/0102.ps.gz
Refering-URL: http://www.csd.uu.se/papers/reports.html
Root-URL: 
Email: jonas@csd.uu.se  hill@scs.leeds.ac.uk  
Title: Extending Godel for Expressing Restricted Quantifications and Arrays  
Author: Jonas Barklund Patricia M. Hill 
Note: Work supported by EPSRC grant GR/H/79862  
Address: Uppsala University  Leeds  
Affiliation: Computing Science Department  School of Computer Studies University of  
Abstract: UPMAIL Technical Report No. 102 March 22, 1995 ISSN 1100-0686 Abstract The expressiveness of the declarative language Godel can be improved by adding to it bounded quantifications, i.e., quantifications over finite domains, and arrays. Many problems can be expressed more concisely using bounded quantifications than using recursion. Arrays are natural for many applications, e.g., in scientific computing, and are conveniently used in bounded quantifications. Treating bounded quantifications differently from other quantifications also reduces floundering, allows efficient sequential execution and enables efficient parallel execution on various architectures. In extending Godel to allow bounded quantifications, the finiteness condition would be difficult to implement. Thus the extension defined in this paper allows restricted quantifications where the domain can be restricted, but not necessarily finite. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. Arro, J. Barklund, and J. Bevemyr. </author> <title> Parallel bounded quantification|preliminary results. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 28(5) </volume> <pages> 117-124, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: Godel is particularly suitable for parallel implementations, since the semantics is declarative and does not depend on the order of computation. It has been shown that parallel implementations of bounded quantifications can obtain good speed-ups over sequential processing <ref> [1, 4] </ref>. Thus any extension to Godel that enhances the possible exploitation of parallelism in a problem should be explored. Bounded quantifications, as defined by Barklund [2], require the domain of the quantifier to be finite. <p> If this number is known in advance of the execution of the evaluation of a bounded quantification, a parallel compiler can evenly distribute the evaluation of the body of the quantification over the available processors <ref> [1, 4] </ref>. In the extension here for restricted quantifications, arbitrary range formulas are allowed. <p> Many of these could guarantee the domain of the quantifier to be finite and hence ensure that the quantification was bounded. Bounded quantifications using these predicates could have specialised compilation improving the efficiency of execution [3], particularly in the case of parallel implementations <ref> [1, 4] </ref>. The Integers system module provides the Interval predicate. This has three arguments m, i, and n and is more commonly denoted by the range expression m =&lt; i =&lt; n (or variations involving &lt; instead of =&lt;). <p> When translating Godel programs for a system without support for definite iteration, they can be instead be translated to tail-recursive programs [4] and run with reasonable efficiency. It has been shown how Prolog programs with bounded quantifications can be run on both SIMD parallel computers <ref> [1] </ref> and MIMD parallel computers with shared memory [4].
Reference: [2] <author> J. Barklund. </author> <title> Bounded quantifications for iterations and concurrency in logic programming. </title> <journal> New Generation Computing, </journal> <volume> 12(2), </volume> <year> 1994. </year>
Reference-contexts: 1 Introduction A bounded quantification is a quantification that ranges over a finite domain [11]. This form of quantification has been introduced to logic programming <ref> [2, 3, 12] </ref> to enhance expressiveness and enable many repetitive computations to be implemented iteratively rather than by means of recursion. Arrays are a common data structure in mathematics arising in many programming applications. <p> The indices of an array provide an immediate way of referring to specific elements and, through iteration, allow an easy means of processing all the elements. Thus, arrays with bounded quantifications form a useful combination that can significantly increase the expressiveness <ref> [2] </ref> and improve the efficiency of logic programming [3]. Godel [8] is a declarative language in the family of logic programming languages. Declarative programming is concerned with writing what is to be computed rather than how it is done. <p> It has been shown that parallel implementations of bounded quantifications can obtain good speed-ups over sequential processing [1, 4]. Thus any extension to Godel that enhances the possible exploitation of parallelism in a problem should be explored. Bounded quantifications, as defined by Barklund <ref> [2] </ref>, require the domain of the quantifier to be finite. In extending Godel to allow such quantifications, the finiteness condition would be difficult to implement. <p> With eager computation, the body can be computed in parallel, with distinct values for the quantified variables. However, with lazy computation, particularly with the existential quantifier, unnecessary computation of the range formula can be avoided. Barklund <ref> [2] </ref> states that a bounded quantification must have a range formula that is "obviously" true for only a finite number of values of the variables. The word "obvious" is clarified by means of examples. <p> Provided the set of values is finite, and these can be enumerated in an acceptable period of time, the quantifications can be executed. Thus, although the bounded quantifications are required to be as defined <ref> [2] </ref> for maximum efficiency, the more general re 5 stricted quantifications that allow arbitrary range formulas further enhance the expressiveness of the language, while compile-time optimisations may still be applicable. <p> In this section we are interested in another form of this generalisation called arithmetical quantifications which have been introduced into logic programming <ref> [2] </ref>. To clarify the underlying idea, consider the mathematical expression: k X f (i) This can be viewed as a P quantification with the quantified variable i, range formula 1 i k, and body expression f (i). <p> It has been shown <ref> [2, 3, 6] </ref> that a facility for defining and manipulating arrays in a language would be useful and improve its expressiveness. Efficient (constant-time) mechanisms for updating an array have been investigated for logic programming [6].
Reference: [3] <author> J. Barklund and J. Bevemyr. </author> <title> Prolog with arrays and bounded quantification. </title> <editor> In A. Voronkov, editor, </editor> <booktitle> Logic Programming and Automated Reasoning, </booktitle> <pages> pages 28-39. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <booktitle> Proceedings of the 4th International Conference, </booktitle> <address> LPAR'93. </address>
Reference-contexts: 1 Introduction A bounded quantification is a quantification that ranges over a finite domain [11]. This form of quantification has been introduced to logic programming <ref> [2, 3, 12] </ref> to enhance expressiveness and enable many repetitive computations to be implemented iteratively rather than by means of recursion. Arrays are a common data structure in mathematics arising in many programming applications. <p> The indices of an array provide an immediate way of referring to specific elements and, through iteration, allow an easy means of processing all the elements. Thus, arrays with bounded quantifications form a useful combination that can significantly increase the expressiveness [2] and improve the efficiency of logic programming <ref> [3] </ref>. Godel [8] is a declarative language in the family of logic programming languages. Declarative programming is concerned with writing what is to be computed rather than how it is done. <p> Many of these could guarantee the domain of the quantifier to be finite and hence ensure that the quantification was bounded. Bounded quantifications using these predicates could have specialised compilation improving the efficiency of execution <ref> [3] </ref>, particularly in the case of parallel implementations [1, 4]. The Integers system module provides the Interval predicate. This has three arguments m, i, and n and is more commonly denoted by the range expression m =&lt; i =&lt; n (or variations involving &lt; instead of =&lt;). <p> It has been shown <ref> [2, 3, 6] </ref> that a facility for defining and manipulating arrays in a language would be useful and improve its expressiveness. Efficient (constant-time) mechanisms for updating an array have been investigated for logic programming [6]. <p> For example, Warren's abstract Prolog Machine [13] does not contain any such construct but can easily be extended with instructions supporting it <ref> [3] </ref>, as has been done in the Luther abstract machine [5]. The current implementation of Godel compiles Godel programs to Prolog programs, so by translating Godel programs with bounded quantifications to Prolog programs with bounded quantifications, they will be run efficiently.
Reference: [4] <author> J. Barklund and J. Bevemyr. </author> <title> Executing bounded quantifications on shared memory multiprocessors. </title> <editor> In Jaan Penjam, editor, </editor> <booktitle> Proc. Intl. Conf. on Programming Language Implementation and Logic Programming 1993, </booktitle> <volume> LNCS 714, </volume> <pages> pages 302-317, </pages> <address> Berlin, 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Godel is particularly suitable for parallel implementations, since the semantics is declarative and does not depend on the order of computation. It has been shown that parallel implementations of bounded quantifications can obtain good speed-ups over sequential processing <ref> [1, 4] </ref>. Thus any extension to Godel that enhances the possible exploitation of parallelism in a problem should be explored. Bounded quantifications, as defined by Barklund [2], require the domain of the quantifier to be finite. <p> If this number is known in advance of the execution of the evaluation of a bounded quantification, a parallel compiler can evenly distribute the evaluation of the body of the quantification over the available processors <ref> [1, 4] </ref>. In the extension here for restricted quantifications, arbitrary range formulas are allowed. <p> Many of these could guarantee the domain of the quantifier to be finite and hence ensure that the quantification was bounded. Bounded quantifications using these predicates could have specialised compilation improving the efficiency of execution [3], particularly in the case of parallel implementations <ref> [1, 4] </ref>. The Integers system module provides the Interval predicate. This has three arguments m, i, and n and is more commonly denoted by the range expression m =&lt; i =&lt; n (or variations involving &lt; instead of =&lt;). <p> When translating Godel programs for a system without support for definite iteration, they can be instead be translated to tail-recursive programs <ref> [4] </ref> and run with reasonable efficiency. It has been shown how Prolog programs with bounded quantifications can be run on both SIMD parallel computers [1] and MIMD parallel computers with shared memory [4]. <p> programs for a system without support for definite iteration, they can be instead be translated to tail-recursive programs <ref> [4] </ref> and run with reasonable efficiency. It has been shown how Prolog programs with bounded quantifications can be run on both SIMD parallel computers [1] and MIMD parallel computers with shared memory [4].
Reference: [5] <author> J. Bevemyr. </author> <title> The Luther WAM Emulator. </title> <type> UPMAIL Tech. Rep. 72, </type> <institution> Comp. Sci. Dept., Uppsala Univ., </institution> <year> 1992. </year>
Reference-contexts: For example, Warren's abstract Prolog Machine [13] does not contain any such construct but can easily be extended with instructions supporting it [3], as has been done in the Luther abstract machine <ref> [5] </ref>. The current implementation of Godel compiles Godel programs to Prolog programs, so by translating Godel programs with bounded quantifications to Prolog programs with bounded quantifications, they will be run efficiently.
Reference: [6] <author> L.-H. Eriksson and M. Rayner. </author> <title> Incorporating mutable arrays into logic programming. </title> <editor> In S. A. Tarnlund, editor, </editor> <booktitle> Proc. Second Intl. Logic Programming Conf. </booktitle> <institution> Uppsala University, </institution> <year> 1984. </year>
Reference-contexts: We have considered here just the Integers module, but most of the preceding discussion applies equally to the corresponding functions and predicates in the Rationals and Floats modules. 9 4 Arrays An array, as an explicit data structure, was first introduced to logic programming by Eriksson & Rayner <ref> [6] </ref>. It has been shown [2, 3, 6] that a facility for defining and manipulating arrays in a language would be useful and improve its expressiveness. Efficient (constant-time) mechanisms for updating an array have been investigated for logic programming [6]. <p> It has been shown <ref> [2, 3, 6] </ref> that a facility for defining and manipulating arrays in a language would be useful and improve its expressiveness. Efficient (constant-time) mechanisms for updating an array have been investigated for logic programming [6]. <p> structure, was first introduced to logic programming by Eriksson & Rayner <ref> [6] </ref>. It has been shown [2, 3, 6] that a facility for defining and manipulating arrays in a language would be useful and improve its expressiveness. Efficient (constant-time) mechanisms for updating an array have been investigated for logic programming [6]. In Prolog, a limited tool for expressing arrays is provided by the built-in predicates arg and functor. These (or equivalent predicates) are not supported by Godel. In Godel, the type and module system facilitate abstract data types, providing a natural mechanism for defining an array abstract data type.
Reference: [7] <author> P. M. Hill. </author> <title> The completion of typed logic programs and SLDNF-resolution. </title> <editor> In A. Voronkov, editor, </editor> <booktitle> Logic programming and Automated Reasoning, Proceedings of the 4th International Conference LPAR'93; Lecture Notes in Artificial Intelligence 698, pages 182 -193. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: However, the type system has the two conditions, head and transparency that prevent the definition of a generic array with an arbitrary number of dimensions. To define a generic array, the Godel type system would have to be extended and it has been shown <ref> [7] </ref> that such extensions must be made with some care if the intended completion semantics of Godel is to be preserved. Thus, in this paper we describe a more modest extension that allows for arrays of dimension 1, 2, and 3 only.
Reference: [8] <author> P. M. Hill and J. W. Lloyd. </author> <title> The Godel Programming Language. </title> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: Thus, arrays with bounded quantifications form a useful combination that can significantly increase the expressiveness [2] and improve the efficiency of logic programming [3]. Godel <ref> [8] </ref> is a declarative language in the family of logic programming languages. Declarative programming is concerned with writing what is to be computed rather than how it is done. <p> Godel requires that, in a call to Member, the second argument is non-variable. Moreover, both arguments in any call to &lt; should be ground. Thus, in a call to LessAll, if the program is not to flounder, both its arguments must be ground. In the definition of the language <ref> [8] </ref>, the procedural semantics for Godel is not fully specified. The only requirement for any implementation of Godel is that it respects the intended semantics of the logic defined by the completion of the program and the intended meaning of any control annotations. <p> A similar extension to the syntax of first order logic is already allowed in the case of the IF C THEN T ELSE E construct in Godel <ref> [8, page 44] </ref>. (and illustrated in the Gcd example in the next section). In this case, by expressing the logic in this form, the programmer can indicate that the test C need only be evaluated once.
Reference: [9] <author> J. W. Lloyd and R. W. Topor. </author> <title> Making Prolog more expressive. </title> <journal> Journal of Logic Programming, </journal> <volume> 1(3) </volume> <pages> 225-240, </pages> <year> 1984. </year>
Reference-contexts: For example, if the statements and goal are in normal form, then SLDNF-resolution can be used to evaluate the goal. A well-known technique for implementing statements not in normal form, possibly containing quantifiers, is to first transform them to normal clauses using transformations based on the Lloyd-Topor transformations <ref> [9] </ref>. For example, using these transformations, the above definition for LessAll would be transformed to: LessAll (a,x) &lt;- ~ MoreOne (a,x).
Reference: [10] <author> Z. Manna and R. Waldinger. </author> <title> The Logical Basis for Computer Programming. Volume 1: Deductive Reasoning. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1985. </year>
Reference-contexts: In extending Godel to allow such quantifications, the finiteness condition would be difficult to implement. Thus the extension defined in this paper allows restricted quantifications where the domain can be restricted, but where there is no necessity that it is finite. (Such quantifications are similar to relativised quantifications <ref> [10] </ref>.) Of course, for reasons of termination, the programmer should ensure that the domain is finite and hence, bounded, whenever the quantification is actually executed. The paper is organised as follows.
Reference: [11] <author> R. D. Tennent. </author> <title> Semantics of Programming Languages. </title> <booktitle> Prentice-Hall International, </booktitle> <year> 1991. </year> <month> 15 </month>
Reference-contexts: 1 Introduction A bounded quantification is a quantification that ranges over a finite domain <ref> [11] </ref>. This form of quantification has been introduced to logic programming [2, 3, 12] to enhance expressiveness and enable many repetitive computations to be implemented iteratively rather than by means of recursion. Arrays are a common data structure in mathematics arising in many programming applications. <p> In this case, by expressing the logic in this form, the programmer can indicate that the test C need only be evaluated once. If C is true, then T is evaluated and if C is false, then E is evaluated. 3 Arithmetic Quantifications Tennent <ref> [11] </ref> has pointed out that, in a computational context, quantification can be generalised to allow for quantifiers other than the universal and existential quantifiers of predicate calculus. In this section we are interested in another form of this generalisation called arithmetical quantifications which have been introduced into logic programming [2].
Reference: [12] <author> A. Voronkov. </author> <title> Logic programming with bounded quantifiers. </title> <editor> In A. Voronkov, editor, </editor> <booktitle> Logic Programming | 2nd Russian Conf. on Logic Programming, </booktitle> <pages> pages 486-514. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: 1 Introduction A bounded quantification is a quantification that ranges over a finite domain [11]. This form of quantification has been introduced to logic programming <ref> [2, 3, 12] </ref> to enhance expressiveness and enable many repetitive computations to be implemented iteratively rather than by means of recursion. Arrays are a common data structure in mathematics arising in many programming applications.
Reference: [13] <author> D. H. D. Warren. </author> <title> An abstract Prolog instruction set. </title> <type> SRI Tech. Note 309. </type> <institution> SRI Intl., Menlo Park, Calif., </institution> <year> 1983. </year> <month> 16 </month>
Reference-contexts: For example, Warren's abstract Prolog Machine <ref> [13] </ref> does not contain any such construct but can easily be extended with instructions supporting it [3], as has been done in the Luther abstract machine [5].
References-found: 13

