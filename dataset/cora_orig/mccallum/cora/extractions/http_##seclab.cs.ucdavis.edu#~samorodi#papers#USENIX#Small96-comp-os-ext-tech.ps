URL: http://seclab.cs.ucdavis.edu/~samorodi/papers/USENIX/Small96-comp-os-ext-tech.ps
Refering-URL: http://seclab.cs.ucdavis.edu/~samorodi/papers/USENIX/
Root-URL: http://www.cs.ucdavis.edu
Email: Email: office@usenix.org  
Title: A Comparison of OS Extension Technologies  
Phone: 1. Phone: 510 528-8649 2. FAX: 510 548-5738 3.  4.  
Author: Christopher Small and Margo Seltzer 
Affiliation: Harvard University  
Web: WWW URL: http://www.usenix.org  
Date: January 1996  
Note: The following paper was originally published in the Proceedings of the USENIX 1996 Annual Technical Conference San Diego, California,  For more information about USENIX Association contact:  
Abstract-found: 0
Intro-found: 1
Reference: [ACCE86] <author> Accetta, M., Baron, R., Bolosky, W., Golub, D., Rashid, R., Tevanian, A., Young, M., </author> <title> Mach: a New Kernel Foundation for UNIX Development, </title> <booktitle> 1986 Summer USENIX Conference (July 1986). </booktitle>
Reference-contexts: Like Modula-3, Java is designed to reduce or eliminate dangling or stray pointers and safety problems. In this work, we examine the extension technologies being proposed by these systems: unsafe conventional monolithic kernels to microkernel architectures. The Mach microkernel <ref> [ACCE86] </ref> was designed to allow kernel functionality to be moved out of the kernel address space into user-level external servers in order to increase safety, robustness, and exibility.
Reference: [BERS95] <author> Bershad, B., Savage, S., Pardyak, P., Sirer, E. G., Fiuczynski, M., Becker, D., Eggers, S., Chambers, C., </author> <title> Extensibility, Safety, and Performance in the SPIN Operating System, </title> <booktitle> Proceedings of the 15th SOSP, </booktitle> <address> Copper Mountain, CO (December 1995). </address>
Reference-contexts: The performance of interpreted packet filters is close to that of compiled code, but, like HiPEC, the expressiveness is limited to the specific domain. Instead of starting with a minimal language and extending it, the SPIN system <ref> [BERS95] </ref> is written in, and uses as its extension language, Modula-3 [NELS91]. Modula-3 is a strongly-typed, garbage-collected language, designed so that it is impossible for a program to have a dangling pointer to deleted data or to construct a pointer to an arbitrary memory location. <p> Recent research into fast path connections, such as the x-kernel work at Arizona [DRUS93], the video server benchmark of the SPIN operating system <ref> [BERS95] </ref>, and Falls work in decreasing I/O time through use of in-kernel copying [FALL93] show that there is a substantial performance gain from saving copies to and from user-level.
Reference: [CAMP95] <author> Campbell, R., Tan. S.-M., mChoices: </author> <title> An Object-Oriented Multimedia Operating System, </title> <booktitle> Proceedings of HotOS V, </booktitle> <pages> pp. 9094, </pages> <address> Orcas Island, WA (May 1995). </address>
Reference-contexts: Because of the design of the language, code in safe modules is not able to reach outside its bounds and violate the integrity of the program in which it is running. The mChoices operating system <ref> [CAMP95] </ref> proposes using a simple exible scripting language similar to Tcl to aggregate multiple kernel calls or remove control traffic between user-level and kernel-level. <p> This technique, used in awk, sh, and Tcl, leads to a smaller start-up time, with a higher overhead per statement. Because source-interpreted scripting languages are immensely popular, and have been proposed as a vehicle for writing grafts <ref> [CAMP95] </ref>, we include Tcl as one of our tested technologies. 5 Performance Analysis Given the wide range of extension technologies available, it is not obvious which is best in any dimension. In fact, extensible systems are being built that employ nearly every technology described.
Reference: [CAO94] <author> Cao, P., Felten, E., Li, K., </author> <title> Implementation and Performance of Application-Controlled File Caching, </title> <booktitle> Proceedings of the First Usenix Symposium on Operating System Design and Implementation, </booktitle> <pages> pp. 165-177, </pages> <address> Montery, CA (November 1994). </address>
Reference-contexts: There is little or no reason to extend the kernel; nearly all functionality is under the control of the application. Along with adding functionality, extensible systems can provide applications with the ability to override policy decisions. Cao et al. <ref> [CAO94] </ref> motivate this sort of extension by examining the performance improvement achieved by allowing an application to control the buffer cache eviction policy. <p> As each page is processed, its entry is removed from the hot list, so as the simulation runs, the queue grows shorter. We presume that the kernel keeps track of candidate pages and graft-proposed alternates, as in Caos system <ref> [CAO94] </ref>, to ensure that an application does not manipulate the VM system to gain more physical memory than it would receive under the default strategy. This test is not particularly compute-intensive. Instead, it is sensitive to the overhead associated with traversing a list of items.
Reference: [COLU95] <institution> Omniware Technical Overview, Colusa Software, </institution> <note> http://www.colusa.com, (1995). </note> <author> [DEJON93] de Jonge, W., Kaashoek, M. F., Hsieh, W., </author> <title> The Logical Disk: A New Approach to Improving File Systems, </title> <booktitle> Proceedings of the 14th SOSP, </booktitle> <pages> pp. </pages> <note> 1528, Asheville, NC (December 1993). </note>
Reference-contexts: At load time, a linear-time algorithm can be used to guarantee that all memory references in a piece of object code have been correctly sandboxed. Omniware C++ <ref> [COLU95] </ref> is a commercial system that includes a compiler that generates machine independent code. A run-time system translates the machine independent code into native code with software fault isolation instructions and links the code into the executable.
Reference: [DRUS93] <author> Druschel, P., Peterson, L., Fbufs: </author> <title> A High-Bandwidth Cross-Domain Transfer Facility, </title> <booktitle> Proceedings of the 14th SOSP, </booktitle> <pages> pp. </pages> <note> 189202, Asheville, NC (December 1993). </note>
Reference-contexts: Another example of a stream graft is one that takes a data source (e.g. the disk) and, rather than modifying it on the way to application level, writes it elsewhere (e.g. the network). Recent research into fast path connections, such as the x-kernel work at Arizona <ref> [DRUS93] </ref>, the video server benchmark of the SPIN operating system [BERS95], and Falls work in decreasing I/O time through use of in-kernel copying [FALL93] show that there is a substantial performance gain from saving copies to and from user-level.
Reference: [ENGL95] <author> Engler, D., Kaashoek, M. F., and OToole, J., Exokernel: </author> <title> An Operating System Architecture for Application-Level Resource Management, </title> <booktitle> Proceedings of the 15th SOSP, </booktitle> <address> Copper Mountain, CO (December 1995). </address>
Reference-contexts: Measurements of sandboxing have shown it to have a much lower overhead than hardware protection mechanisms (on the order of a few percent). The Exokernel project <ref> [ENGL95] </ref> also strives to reduce the number of user-kernel protection boundary crossings, but it takes a different approach. Rather than support safe downloading of code into the kernel, it moves as much functionality as possible from kernel to user-level.
Reference: [FALL93] <author> Fall, K., Pasquale, J., </author> <title> Exploiting In-Kernel Data Paths to Improve I/O Throughput and CPU Availability, </title> <booktitle> 1993 Winter USENIX Conference, </booktitle> <pages> pp. 327334, </pages> <address> San Diego, </address> <note> CA (January 1993). </note>
Reference-contexts: Recent research into fast path connections, such as the x-kernel work at Arizona [DRUS93], the video server benchmark of the SPIN operating system [BERS95], and Falls work in decreasing I/O time through use of in-kernel copying <ref> [FALL93] </ref> show that there is a substantial performance gain from saving copies to and from user-level. A stream graft that takes its input and directs it to an output connection, perhaps after transforming the data, could be used to build this type of fast path connection.
Reference: [FORD94] <author> Ford, B, Lepreau, J, </author> <title> Evolving Mach 3.0 to a Migrating Thread Model, </title> <booktitle> 1994 Winter USENIX Conference, </booktitle> <pages> pp. 97-114, </pages> <address> San Francisco, </address> <note> CA (January 1994). </note>
Reference: [GOSL95] <author> Gosling, J., McGilton, H., </author> <title> The Java Language Environment, </title> <note> available from http://java.sun.com (May 1995). </note>
Reference-contexts: The Illustra server does not currently protect itself from misbehaved DataBlade code, although Illustra is evaluating software fault isolation techniques. The HotJava Web browser from Sun Microsystems can be extended with applets written in Java, a Modula-3 like language with a C++ syntax <ref> [GOSL95] </ref>. Java code is compiled to a machine-independent byte-code that is downloaded by the HotJava browser and interpreted or compiled into native code on-the-y. Like Modula-3, Java is designed to reduce or eliminate dangling or stray pointers and safety problems.
Reference: [GUIL91] <author> Guillemont, M., Lipkis, J., Orr, D., Rozier, M., </author> <title> A Second-Generation Micro-Kernel Based UNIX; Lessons in Performance and Compatibility, </title> <booktitle> 1991 Winter USENIX Conference, </booktitle> <pages> pp. 1321, </pages> <address> Dallas, TX (January 1991). </address>
Reference-contexts: However, the expense of frequent upcalls to user-level code motivated the current generation of microkernel-based systems, which link server code directly into the kernel address space <ref> [GUIL91] </ref>. The CMU Bridge project follows this model, placing servers in the kernel, but protects the kernel using software fault isolation techniques such as sandboxing [WAHBE93]. Measurements of sandboxing have shown it to have a much lower overhead than hardware protection mechanisms (on the order of a few percent).
Reference: [HOLZE94] <author> Hlze, U., Ungar, D., </author> <title> Optimizing Dynamically-Dispatched Calls with Run-Time Type Feedback, </title> <booktitle> Proceedings of the 1994 SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <address> Orlando, FL (June 1994). </address>
Reference-contexts: The intermediate code could also be used as the input to a runtime code generator. A reasonably fast interpreter runs 10 to 100 times more slowly than compiled code [MAY87]; however, using incremental code generation techniques, performance can approach that of compiled code <ref> [HOLZE94] </ref>. (Note that there is a exible line between generating native code at load time as above and dynamically generating native code from interpreted code.) Java is compiled to a compact byte code for the Java Virtual Machine. As interpreters go, the Java interpreter is fairly fast.
Reference: [ILLU94] <institution> Illustra DataBlade Developers Kit Architecture Manual, Release 1.1, Illustra Information Technologies, </institution> <address> Oakland, CA (1994). </address>
Reference-contexts: Some database servers allow clients to load query or datatype-specific code into the server to improve performance. The Thor database server uses a typesafe language designed for writing extensions [LISK95]; the Illustra database server is extended by writing DataBlades, which add support for new data types to the server <ref> [ILLU94] </ref>. The Illustra server does not currently protect itself from misbehaved DataBlade code, although Illustra is evaluating software fault isolation techniques. The HotJava Web browser from Sun Microsystems can be extended with applets written in Java, a Modula-3 like language with a C++ syntax [GOSL95].
Reference: [LEE94] <author> Lee, C.-H., Chen, M., Chang, R. C., </author> <title> HiPEC: High Performance External Virtual Memory Caching, </title> <booktitle> Proceedings of the First Usenix Symposium on Operating System Design and Implementation, </booktitle> <pages> pp. 153164, </pages> <address> Montery, CA (November 1994). </address>
Reference-contexts: This work showed the benefit of allowing applications to control policy; however, we believe that it is not possible to determine (and implement) all policies a priori; a more general extensibility mechanism is required. The HiPEC system <ref> [LEE94] </ref> is similar to, but more exible than, Caos system. HiPEC allows applications to control VM caching policy using programs written in a simple, assembler-like, interpreted language designed specifically for the task of managing a queue of VM pages.
Reference: [LISK95] <author> Liskov, B., Curtis, D., Day, M., Ghemaway, S., Gruber, R., Johnson. P., Myers, A., </author> <title> Theta Reference Manual, MIT LCS Programming Methodology Group Memo 88 (February 1995). </title>
Reference-contexts: Extension technology is also useful outside the kernel. Some database servers allow clients to load query or datatype-specific code into the server to improve performance. The Thor database server uses a typesafe language designed for writing extensions <ref> [LISK95] </ref>; the Illustra database server is extended by writing DataBlades, which add support for new data types to the server [ILLU94]. The Illustra server does not currently protect itself from misbehaved DataBlade code, although Illustra is evaluating software fault isolation techniques.
Reference: [MAY87] <author> May, C., </author> <title> MIMIC: A Fast System/370 Simulator, </title> <booktitle> Proceedings of the SIGPLAN 87 Symposium on Interpreters and Interpretive Techniques, in SIGPLAN Notices, </booktitle> <volume> 22, 7, </volume> <pages> pp. 1-13, </pages> <address> St. Paul, MN (July 1987). </address>
Reference-contexts: This model allows complete control over the behavior of the extension by implementing only safe operations in the interpreter. The intermediate code could also be used as the input to a runtime code generator. A reasonably fast interpreter runs 10 to 100 times more slowly than compiled code <ref> [MAY87] </ref>; however, using incremental code generation techniques, performance can approach that of compiled code [HOLZE94]. (Note that there is a exible line between generating native code at load time as above and dynamically generating native code from interpreted code.) Java is compiled to a compact byte code for the Java Virtual
Reference: [MCCAN93] <author> McCanne, S., Jacobson, V., </author> <title> The BSD Packet Filter: A New Architecture for User-level Packet Capture, </title> <booktitle> 1993 Winter USENIX Conference, </booktitle> <address> San Diego, </address> <note> CA (January 1993). </note>
Reference-contexts: The language would have to be augmented if it were to be used for other applications. Packet filters are used to demultiplex a stream of network packets by examining the contents of each packet header. Often, packet filters are implemented in a simple interpreted language (e.g. <ref> [MOGUL87, MCCAN93, YUHARA94] </ref>). A special language, designed to efficiently describe packet headers, is used to write packet filters. The performance of interpreted packet filters is close to that of compiled code, but, like HiPEC, the expressiveness is limited to the specific domain.
Reference: [MCVOY96] <author> McVoy, L., Staelin, C., lmbench: </author> <title> Portable Tools for Performance Analysis, </title> <booktitle> 1996 USENIX Conference, </booktitle> <address> San Diego, </address> <note> CA (January 1994). </note>
Reference-contexts: And special thanks to Keith Smith and Chris Thorpe for their help brainstorming and polishing the paper. We are very grateful to Larry McVoy of SGI for use of his lmbench suite <ref> [MCVOY96] </ref>. We used tests lmdd.c,v 1.12 and lat_pagefault.c,v 1.2.
Reference: [MOGUL87] <author> Mogul, J., Rashid, R., Accetta, M., </author> <title> The Packet Filter: An Efficient Mechanism for User-level Network Code, </title> <booktitle> Proceedings of the 11th SOSP, </booktitle> <pages> pp. 3952, </pages> <address> Austin, TX (November 1987). </address>
Reference-contexts: The language would have to be augmented if it were to be used for other applications. Packet filters are used to demultiplex a stream of network packets by examining the contents of each packet header. Often, packet filters are implemented in a simple interpreted language (e.g. <ref> [MOGUL87, MCCAN93, YUHARA94] </ref>). A special language, designed to efficiently describe packet headers, is used to write packet filters. The performance of interpreted packet filters is close to that of compiled code, but, like HiPEC, the expressiveness is limited to the specific domain.
Reference: [NELS91] <editor> Systems Programming with Modula-3, Nelson, G., ed., </editor> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ (1991). </address>
Reference-contexts: The performance of interpreted packet filters is close to that of compiled code, but, like HiPEC, the expressiveness is limited to the specific domain. Instead of starting with a minimal language and extending it, the SPIN system [BERS95] is written in, and uses as its extension language, Modula-3 <ref> [NELS91] </ref>. Modula-3 is a strongly-typed, garbage-collected language, designed so that it is impossible for a program to have a dangling pointer to deleted data or to construct a pointer to an arbitrary memory location. <p> Examining the code generated by the Modula-3 compiler, we found that it includes a runtime check against NIL (location zero) on each pointer access. The code generated on the other platforms (Solaris, Alpha, and HP-UX) does not include explicit NIL checks. The Modula-3 language specification <ref> [NELS91, p. 50] </ref> states that dereferencing NIL should cause a runtime error; on Solaris and Alpha, dereferencing location zero causes a segmentation violation, which is trapped by the Modula-3 runtime system.
Reference: [RFC1321] <author> Rivest, R., </author> <title> The MD5 Message-Digest Algorithm, Network Working Group RFC 1321 (April 1992). </title>
Reference-contexts: A stream graft that takes its input and directs it to an output connection, perhaps after transforming the data, could be used to build this type of fast path connection. Our representative stream graft is an implementation of the MD5 Message-Digest Algorithm <ref> [RFC1321] </ref>, which produces a 128-bit fingerprint of a file. The MD5 fingerprint is both expensive to compute and computationally infeasible to forge.
Reference: [RITCH84] <author> Ritchie, D., </author> <title> A Stream Input-Output System, </title> <journal> AT&T Bell Laboratories Technical Journal, </journal> <volume> 63, </volume> <pages> 8 pp. </pages> <year> 18971910 </year> <month> (October </month> <year> 1984). </year>
Reference-contexts: A standard filesystem could be transformed into a journaling filesystem by inserting into the request stream a graft that journals the changes made to the metadata. The Stream Input-Output System of UNIX <ref> [RITCH84] </ref> decomposed the character I/O system of UNIX into a set of filters. Network and terminal protocols were built up by linking filters into chains.
Reference: [ROSE91] <author> Rosenblum, M., Ousterhout, J., </author> <title> The Design and Implementation of a Log-Structured File System, </title> <booktitle> Proceedings of the 13th SOSP, </booktitle> <pages> pp. 115, </pages> <address> Pacific Grove, CA (October 1991). </address>
Reference-contexts: The LD can be used to transparently replicate data, by writing it in multiple places on the same disk or multiple disks, and speed write performance, by writing logically discontiguous blocks on a physically contiguous region. A log-structured file system <ref> [ROSE91] </ref> can be implemented using a logical disk facility; the filesystem lays out blocks as its sees fit, and the Logical Disk reorders and buffers writes to improve write performance. Our black box test application is a simple logical disk facility that converts random writes to sequential writes.
Reference: [TPCB90] <author> Transaction Processing Performance Council, </author> <title> TPC Benchmark B, Standard Specification, </title> <publisher> Waterside Associates, </publisher> <address> Fremont, CA (1990). </address>
Reference-contexts: If the candidate is on the hot list, the graft searches through the queue for an acceptable page that is not on the applications hot list. This page is returned to the kernel. For this benchmark we model a TPC-B transaction processing benchmark database <ref> [TPCB90] </ref>. The database holds 1,000,000 records in a four-level b-tree; the b-tree has approximately 400 internal pages (16MB) and 50,000 data pages (200 MB).
Reference: [THEK94] <author> Thekkath, C., Levy, H, </author> <title> Hardware and Software Support for Efficient Exception Handling, </title> <booktitle> Proceedings of ASPLOS VI, </booktitle> <pages> pp. 110-119, </pages> <address> San Jose, CA (October 1994). </address>
Reference: [WAHBE93] <author> Wahbe, R., Lucco, S., Anderson, T., Graham, S., </author> <title> Efficient Software-Based Fault Isolation, </title> <booktitle> Proceedings of the 14th SOSP, </booktitle> <pages> pp. </pages> <address> 203216 Asheville, NC (December 1993). </address>
Reference-contexts: The CMU Bridge project follows this model, placing servers in the kernel, but protects the kernel using software fault isolation techniques such as sandboxing <ref> [WAHBE93] </ref>. Measurements of sandboxing have shown it to have a much lower overhead than hardware protection mechanisms (on the order of a few percent). The Exokernel project [ENGL95] also strives to reduce the number of user-kernel protection boundary crossings, but it takes a different approach. <p> By controlling the language (e.g. Modula-3), or the compiler, or by patching the binary code <ref> [WAHBE93] </ref>, we can control the instructions evaluated by the extension. This allows us to ensure that the extension does not read or write outside its bounds, or jump to arbitrary kernel code.

References-found: 26

