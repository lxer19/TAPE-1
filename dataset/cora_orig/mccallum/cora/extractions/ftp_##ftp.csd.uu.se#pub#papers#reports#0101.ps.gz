URL: ftp://ftp.csd.uu.se/pub/papers/reports/0101.ps.gz
Refering-URL: http://www.csd.uu.se/papers/reports.html
Root-URL: 
Email: email anatoli@csd.uu.se  email smith@forge.kiev.ua  email voronkov@csd.uu.se  
Title: Handling Equality in Logic Programming via Basic Folding  
Author: Anatoli Degtyarev Yuri Koval Andrei Voronkov 
Note: Supported by grant from the Swedish Institute and the Swedish Royal Academy of Sciences Partially supported by a grant from the Swedish Royal Academy of Sciences Supported by a TFR grant  
Address: Box 311, S-751 05 Uppsala, Sweden  Vladimirskaya 64 Kiev 252017 Ukraine  Box 311, S-751 05 Uppsala, Sweden  
Affiliation: Computing Science Department Uppsala University  Department of Cybernetics Kiev University  Computing Science Department Uppsala University  
Abstract: UPMAIL Technical Report No. 101 April 11, 1995 Revised June 11, 1997 ISSN 1100-0686 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K.R. Apt. </author> <title> Logic programming. </title> <editor> In J. Van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B: Formal Methods and Semantics, chapter 10, </booktitle> <pages> pages 493-574. </pages> <publisher> Elsevier Science, </publisher> <address> Amsterdam, </address> <year> 1990. </year>
Reference-contexts: By using standard arguments of unification theory <ref> [1] </ref>, one can prove that D 0 5 is a variant of D 5 . In the same way, the ground version of is transformed into a ground version 0 of 0 . <p> By using standard arguments of unification theory <ref> [1] </ref>, one can prove that D 0 5 is a variant of D 5 . In order to complete the proof we note that the new derivation tree has a strictly smaller degree of disorder. The proof that resolution is permutable with equality solution is similar. <p> By standard arguments of the theory of logic programming <ref> [1] </ref> one can prove that there are terms t 1 ; : : : ; t n such that a closure of the form query (t 1 ; : : : ; t n ) is derivable from S 0 by resolutions only. <p> unifiers proves the claim. 3 A unifier of a set of equations fs 1 ' t 1 ; : : : ; s n ' t n g is any substitution such that s i = t i , for all i 2 f1; : : : ; ng (see <ref> [1] </ref>). 37 Appendix C. The proof of completeness 2. Let C 62 S ! .
Reference: [2] <author> L. Bachmair, N. Dershowitz, and D. Plaisted. </author> <title> Completion without failure. </title> <editor> In H. At Kaci and M. Nivat, editors, </editor> <booktitle> Resolution of Equations in Algebraic Structures, </booktitle> <volume> volume 2, </volume> <pages> pages 1-30. </pages> <publisher> Academic Press, </publisher> <year> 1989. </year>
Reference-contexts: This reminds the process of completion of equational theories which can also be characterized as a transformation of an equational theory to a canonical form [32]. As a rule, this kind of processes does not terminate, i.e. one cannot obtain a finite canonical program (see e.g. "unfailing completion" <ref> [2] </ref>). However, any query that is a consequence of the program can be answered at a finite stage of this process by narrowing. For Horn clause theories it has been developed in [38, 24].
Reference: [3] <author> L. Bachmair and H. Ganzinger. </author> <title> Rewrite-based equational theorem proving with selection and simplification. </title> <journal> Journal of Logic and Computation, </journal> <volume> 4(3) </volume> <pages> 217-247, </pages> <year> 1994. </year>
Reference-contexts: The main influence on modern techniques of equational logic programming was made by equational theorem proving methods using refinements of inference in the paramodulation-based calculus via ordering strategies and deletion of redundant clauses. This technique appeared in [37, 55, 39] and has been further developed in <ref> [33, 50, 30, 62, 53, 56, 3, 47] </ref>. In logic programming, it was introduced in many papers, including [21, 57, 60, 36, 25, 49, 24, 26, 45], especially in the framework of integration of logic and functional programming languages. In [14] we introduced a new method called equality elimination. <p> ; u [s 0 ] ' v; T 3 ) 2 LS with the same conditions as for basic right superposition and an additional restriction: the equality symbol ' does not occur in T 2 . (The last condition can be considered as a special case of a selection function <ref> [3] </ref>.) 1 We need one more inference rule. <p> Then there exists a groundable pseudo BR-derivation of " from S. When writing this paper, we had to choose between the use of constraints in the style of [47] or substitutions in the style of <ref> [3] </ref>. The use of ordering constraints would simplify many proofs below based on transformations of derivations. But the definition of the basic folding which is already enough sophisticated would have become even more difficult to understand. As the following example shows, not every BR-derivation is groundable. <p> It is easy to see that the number of applications of superposition in the transformed derivation does not change. The other cases are similar. 2 The difference between BR-derivations and pseudo BR-derivations can be formalized using the selection mechanism of <ref> [3, 5] </ref>. Unfortunately, the results of [3, 5] on the completeness of basic superposition with selection are not immediately applicable to our proofs. Indeed, Lemma C.6 proves admissibility of selection w.r.t. derivations of any closure but not derivations of the empty closure as in [3, 5]. <p> It is easy to see that the number of applications of superposition in the transformed derivation does not change. The other cases are similar. 2 The difference between BR-derivations and pseudo BR-derivations can be formalized using the selection mechanism of <ref> [3, 5] </ref>. Unfortunately, the results of [3, 5] on the completeness of basic superposition with selection are not immediately applicable to our proofs. Indeed, Lemma C.6 proves admissibility of selection w.r.t. derivations of any closure but not derivations of the empty closure as in [3, 5]. <p> formalized using the selection mechanism of <ref> [3, 5] </ref>. Unfortunately, the results of [3, 5] on the completeness of basic superposition with selection are not immediately applicable to our proofs. Indeed, Lemma C.6 proves admissibility of selection w.r.t. derivations of any closure but not derivations of the empty closure as in [3, 5].
Reference: [4] <author> L. Bachmair, H. Ganzinger, C. Lynch, and W. Snyder. </author> <title> Basic paramodulation and superposition. </title> <editor> In D. Kapur, editor, </editor> <booktitle> 11th International Conference on Automated Deduction, volume 607 of Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 462-476, </pages> <address> Saratoga Springs, NY, USA, June 1992. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: In [14] we introduced a new method called equality elimination. This method performs all equality-related reasoning steps before all other inference steps using a special strategy | basic superposition <ref> [46, 4] </ref>. Using solutions to equations provided by basic superposition, we transform a logic program with equality into a logic program without equality. The equality elimination method combines bottom-up solutions of equations with top-down query answering in the transformed logic program. <p> The basic strategy without ordering restrictions has been introduced by the first author in 1979 (published in Russian, see the survey [11]). The motivation was to reduce the search space by restricting the paramodulation at the term level. The basic superposition inference systems have been introduced in <ref> [4, 46] </ref>. The technique of moving all work with equalities in the beginning of inferences has been studied in proof theory for sequent systems without free variables [34, 41, 48].
Reference: [5] <author> L. Bachmair, H. Ganzinger, C. Lynch, and W. Snyder. </author> <title> Basic paramodulation. </title> <journal> Information and Computation, </journal> <volume> 121 </volume> <pages> 172-192, </pages> <year> 1995. </year>
Reference-contexts: We shall always assume that reduction orderings are total on the set T . For the rest of the paper stands for a fixed reduction ordering. Following <ref> [5] </ref> we distinguish terms occurring in the original formula from terms introduced by a substitution by using closures. Definition 3.3 (closure) A closure is a pair C such that 1. <p> When we use a closure C on either side of the symbol `, it can be replaced by the clause C. The basic superposition rules derive closures from closures. They are defined as in <ref> [5] </ref>. We always assume that premises of rules have disjoint variables. As usual, to make variables disjoint we can replace closures by their variants. <p> In order to make the program transformation faster and more efficient we introduced a few simplification rules: Basic subsumption allows to remove closures subsumed by other closures. Basic subsumption is described e.g. in <ref> [5] </ref>. On closures without equality, i.e. clauses used in the resulting program, basic subsumption is equivalent to subsumption (because the resulting closures have no basic positions). Tautology deletion allows to remove closures s ' t T such that s = t (tautologies). <p> One more strategy that can be applied but is not yet implemented is the simplification in the basic setting <ref> [5] </ref>. Currently, our system uses a method for generating initial closures based on the analysis of all complementary pairs of literals [14]. We are going to also include the folklore translation that was used in examples of this paper. <p> It is easy to see that the number of applications of superposition in the transformed derivation does not change. The other cases are similar. 2 The difference between BR-derivations and pseudo BR-derivations can be formalized using the selection mechanism of <ref> [3, 5] </ref>. Unfortunately, the results of [3, 5] on the completeness of basic superposition with selection are not immediately applicable to our proofs. Indeed, Lemma C.6 proves admissibility of selection w.r.t. derivations of any closure but not derivations of the empty closure as in [3, 5]. <p> It is easy to see that the number of applications of superposition in the transformed derivation does not change. The other cases are similar. 2 The difference between BR-derivations and pseudo BR-derivations can be formalized using the selection mechanism of <ref> [3, 5] </ref>. Unfortunately, the results of [3, 5] on the completeness of basic superposition with selection are not immediately applicable to our proofs. Indeed, Lemma C.6 proves admissibility of selection w.r.t. derivations of any closure but not derivations of the empty closure as in [3, 5]. <p> formalized using the selection mechanism of <ref> [3, 5] </ref>. Unfortunately, the results of [3, 5] on the completeness of basic superposition with selection are not immediately applicable to our proofs. Indeed, Lemma C.6 proves admissibility of selection w.r.t. derivations of any closure but not derivations of the empty closure as in [3, 5].
Reference: [6] <author> R. Barbuti, M. Bellia, G. Levi, and M. Martelli. LEAF: </author> <title> a language which integrates logic, equations and functions. </title> <editor> In D. DeGroot and G. Lindstrom, editors, </editor> <booktitle> Logic Programming, Functions, Relations and Equations, </booktitle> <pages> pages 201-238. </pages> <publisher> Prentice Hall, </publisher> <year> 1986. </year>
Reference-contexts: The modification method transforms the original Horn clause program with equality into "flat" Horn clauses without equality. Then one can use the ordinary SLD-resolution as the inference mechanism for the transformed program. In the logic programming community, this method has been considered in <ref> [6, 10, 8, 20] </ref>. Brand does not introduce new defining predicates for equations, he puts the equations themselves into bodies of clauses. After his transformation, he treats the equality predicate as the ordinary binary predicate Eq, defined by the fact Eq (x; x).
Reference: [7] <author> G. Birkhoff. </author> <title> Subdirect unions in universal algebras. </title> <journal> Bull. Amer. Math. Soc., </journal> <volume> 50 </volume> <pages> 764-768, </pages> <year> 1944. </year>
Reference-contexts: By a logic program with equality we understand a Horn clause logic program in which equality may occur both in the heads and in the bodies of clauses. The model-theoretic semantics of such programs is well known since long ago <ref> [7, 43] </ref>. However, there is no generally accepted procedural interpretation. The most natural generalization of SLD-resolution known as SLDE-+ -resolution [23] have been proved in general incomplete in [14]. Various definitions of procedural interpretations are actively studied in the theorem proving and logic programming communities.
Reference: [8] <author> P.G. Bosco, E. Giovanetti, and C. Moiso. </author> <title> Narrowing vs. </title> <journal> SLD-resolution. Theoretical Computer Science, </journal> <volume> 59 </volume> <pages> 3-23, </pages> <year> 1988. </year>
Reference-contexts: The modification method transforms the original Horn clause program with equality into "flat" Horn clauses without equality. Then one can use the ordinary SLD-resolution as the inference mechanism for the transformed program. In the logic programming community, this method has been considered in <ref> [6, 10, 8, 20] </ref>. Brand does not introduce new defining predicates for equations, he puts the equations themselves into bodies of clauses. After his transformation, he treats the equality predicate as the ordinary binary predicate Eq, defined by the fact Eq (x; x).
Reference: [9] <author> D. Brand. </author> <title> Proving theorems with the modification method. </title> <journal> SIAM Journal of Computing, </journal> <volume> 4 </volume> <pages> 412-430, </pages> <year> 1975. </year>
Reference-contexts: : : | : : : ] and a constant [] and use the standard Prolog notation for lists: [s 1 ; : : : ; s n |t] stands for [s 1 | : : : [s n |t] : : : ] 4 The modification method of Brand <ref> [9] </ref> can be considered as a variant of the basic folding. Brand has shown how to get rid of the equality substitution axioms by pulling nonvariable terms out from argument lists. The modification method transforms the original Horn clause program with equality into "flat" Horn clauses without equality. <p> We introduce new predicate symbols which collect substitutions solving equations in the program, similar to "answer literals" introduced in [27]. The idea of introducing new predicate symbols to simulate basic strategy was used in different forms in [58, 14, 13, 12, 15]. The transformation proposed by Brand <ref> [9] </ref> achieves similar aims, but his technique requires transitivity and symmetry axioms to be added explicitly or implicitly, which immediately creates branching in the SLD-tree for the resulting programs. We also note that the ideas of using the basic strategy can be traced to Brand [9]. <p> The transformation proposed by Brand <ref> [9] </ref> achieves similar aims, but his technique requires transitivity and symmetry axioms to be added explicitly or implicitly, which immediately creates branching in the SLD-tree for the resulting programs. We also note that the ideas of using the basic strategy can be traced to Brand [9]. The transformation of programs into the homogeneous form [29, 20] allows one to get rid of the axioms of transitivity and predicate replaceability (i.e. they become "built-in") but the symmetry and the function replaceability axioms remain.
Reference: [10] <author> P.T. Cox and T. Pietrzykowski. </author> <title> Incorporating equality into logic programming via surface deduction. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 31 </volume> <pages> 177-189, </pages> <year> 1986. </year>
Reference-contexts: The modification method transforms the original Horn clause program with equality into "flat" Horn clauses without equality. Then one can use the ordinary SLD-resolution as the inference mechanism for the transformed program. In the logic programming community, this method has been considered in <ref> [6, 10, 8, 20] </ref>. Brand does not introduce new defining predicates for equations, he puts the equations themselves into bodies of clauses. After his transformation, he treats the equality predicate as the ordinary binary predicate Eq, defined by the fact Eq (x; x). <p> The transformation of programs into the homogeneous form [29, 20] allows one to get rid of the axioms of transitivity and predicate replaceability (i.e. they become "built-in") but the symmetry and the function replaceability axioms remain. Flattening transformation of <ref> [10] </ref> is analogous to the TE-transformation by Brand and it subsumes all axioms but reflexivity and symmetry. (Symmetry can further be avoided by, in fact, doubling the number of clauses describing equality.) But as we have already demonstrated in the footnote for Example 6.1, the set of clauses obtained by such
Reference: [11] <author> A. Degtyarev and A. Voronkov. </author> <title> Equality control methods in machine theorem proving. </title> <journal> Cybernetics, </journal> <volume> 22(3) </volume> <pages> 298-307, </pages> <year> 1986. </year>
Reference-contexts: Our approach is very different from the cited papers because we can always obtain a finite program using generation of conditional and recursive rules. The basic strategy without ordering restrictions has been introduced by the first author in 1979 (published in Russian, see the survey <ref> [11] </ref>). The motivation was to reduce the search space by restricting the paramodulation at the term level. The basic superposition inference systems have been introduced in [4, 46].
Reference: [12] <author> A. Degtyarev and A. Voronkov. </author> <title> Equality elimination for the inverse method and extension procedures. In C.S. </title> <editor> Mellish, editor, </editor> <booktitle> Proc. International Joint Conference on Artificial Intelligence (IJCAI), </booktitle> <volume> volume 1, </volume> <pages> pages 342-347, </pages> <address> Montreal, </address> <month> August </month> <year> 1995. </year>
Reference-contexts: We introduce new predicate symbols which collect substitutions solving equations in the program, similar to "answer literals" introduced in [27]. The idea of introducing new predicate symbols to simulate basic strategy was used in different forms in <ref> [58, 14, 13, 12, 15] </ref>. The transformation proposed by Brand [9] achieves similar aims, but his technique requires transitivity and symmetry axioms to be added explicitly or implicitly, which immediately creates branching in the SLD-tree for the resulting programs.
Reference: [13] <author> A. Degtyarev and A. Voronkov. </author> <title> General connections via equality elimination. </title> <editor> In M. De Glas and Z. Pawlak, editors, </editor> <booktitle> Second World Conference on the Fundamentals of Artificial Intelligence (WOCFAI-95), </booktitle> <pages> pages 109-120, </pages> <address> Paris, </address> <month> July </month> <year> 1995. </year> <pages> Angkor. </pages>
Reference-contexts: We introduce new predicate symbols which collect substitutions solving equations in the program, similar to "answer literals" introduced in [27]. The idea of introducing new predicate symbols to simulate basic strategy was used in different forms in <ref> [58, 14, 13, 12, 15] </ref>. The transformation proposed by Brand [9] achieves similar aims, but his technique requires transitivity and symmetry axioms to be added explicitly or implicitly, which immediately creates branching in the SLD-tree for the resulting programs.
Reference: [14] <author> A. Degtyarev and A. Voronkov. </author> <title> A new procedural interpretation of Horn clauses with equality. </title> <editor> In Leon Sterling, editor, </editor> <booktitle> Proceedings of the Twelfth International Conference on Logic Programming, </booktitle> <pages> pages 565-579. </pages> <publisher> The MIT Press, </publisher> <year> 1995. </year>
Reference-contexts: Introduction This paper further develops an approach to logic programming with equality introduced in <ref> [14] </ref>. By a logic program with equality we understand a Horn clause logic program in which equality may occur both in the heads and in the bodies of clauses. The model-theoretic semantics of such programs is well known since long ago [7, 43]. <p> The model-theoretic semantics of such programs is well known since long ago [7, 43]. However, there is no generally accepted procedural interpretation. The most natural generalization of SLD-resolution known as SLDE-+ -resolution [23] have been proved in general incomplete in <ref> [14] </ref>. Various definitions of procedural interpretations are actively studied in the theorem proving and logic programming communities. The main influence on modern techniques of equational logic programming was made by equational theorem proving methods using refinements of inference in the paramodulation-based calculus via ordering strategies and deletion of redundant clauses. <p> In logic programming, it was introduced in many papers, including [21, 57, 60, 36, 25, 49, 24, 26, 45], especially in the framework of integration of logic and functional programming languages. In <ref> [14] </ref> we introduced a new method called equality elimination. This method performs all equality-related reasoning steps before all other inference steps using a special strategy | basic superposition [46, 4]. <p> Applying it into clauses (2.4) and (2.5) yields two new clauses query (x; y) P (f (y)); f (y) ' f (y); E (f (y); x) (2.6) E (x; y) P (y); x ' f (y) (2.7) 1 As we have shown in <ref> [14] </ref>, this program demonstrates the incompleteness of SLDE + -resolution [23] based on complete sets of E-unifiers [51] 4 Anatoli Degtyarev, Yuri Koval', Andrei Voronkov. Handling equality via basic folding. <p> The Basic Folding Section 4 The Basic Folding The basic folding is based on a transformation of sets of closures removing the equality predicate from the program. Unlike the equality elimination method studied in <ref> [14] </ref>, there are strategies for the basic folding which always terminate resulting in a finite program. The essence of the basic folding method is the following. We systematically try to solve equations in the bodies of closures using basic superposition. <p> Another, more complicated way is described in <ref> [14] </ref> and is based on the introduction of new predicate symbols for all complementary pairs of literals in the program. <p> Thus, the difference between the two formulations of completeness is really marginal. In addition, the complete sets of solutions (complete sets of E-unifiers) do not behave well for equational logic programs in general. For example, in <ref> [14] </ref> we show that the minimal model of a program is not a fixpoint when we use complete sets of unifiers in the definition of the immediate consequence operator. <p> We introduce new predicate symbols which collect substitutions solving equations in the program, similar to "answer literals" introduced in [27]. The idea of introducing new predicate symbols to simulate basic strategy was used in different forms in <ref> [58, 14, 13, 12, 15] </ref>. The transformation proposed by Brand [9] achieves similar aims, but his technique requires transitivity and symmetry axioms to be added explicitly or implicitly, which immediately creates branching in the SLD-tree for the resulting programs. <p> One more strategy that can be applied but is not yet implemented is the simplification in the basic setting [5]. Currently, our system uses a method for generating initial closures based on the analysis of all complementary pairs of literals <ref> [14] </ref>. We are going to also include the folklore translation that was used in examples of this paper. The implementation was powerful enough to transform (completely automatically) both examples of our paper. <p> For instance, the program of Example 6.1 had been transformed into a program having a finite SLD-tree. For the program of Example 6.2, the predicate definition of append has been automatically generated. It is interesting that the original folding rule proposed in <ref> [14] </ref> has been strengthened due to analysis of experimental results. The complete listing of both examples is given in Appendices A and B. 25 Appendix A.
Reference: [15] <author> A. Degtyarev and A. Voronkov. </author> <title> Equality elimination for the tableau method. </title> <editor> In J. Calmet and C. Limongelli, editors, </editor> <booktitle> Design and Implementation of Symbolic Computation Systems. International Symposium, DISCO'96, volume 1128 of Lecture Notes in Computer Science, </booktitle> <pages> pages 46-60, </pages> <address> Karlsruhe, Germany, </address> <month> September </month> <year> 1996. </year> <note> 45 Bibliography </note>
Reference-contexts: We introduce new predicate symbols which collect substitutions solving equations in the program, similar to "answer literals" introduced in [27]. The idea of introducing new predicate symbols to simulate basic strategy was used in different forms in <ref> [58, 14, 13, 12, 15] </ref>. The transformation proposed by Brand [9] achieves similar aims, but his technique requires transitivity and symmetry axioms to be added explicitly or implicitly, which immediately creates branching in the SLD-tree for the resulting programs.
Reference: [16] <author> A. Degtyarev and A. Voronkov. </author> <title> Handling equality in logic programs via basic folding. </title> <editor> In R. Dyckhoff, H. Herre, and P. Schroeder-Heister, editors, </editor> <booktitle> Extensions of Logic Programming (5th International Workshop, ELP'96), volume 1050 of Lecture Notes in Computer Science, </booktitle> <pages> pages 119-136, </pages> <address> Leipzig, Germany, </address> <month> March </month> <year> 1996. </year>
Reference-contexts: At the same time, the use of orderings and simplification can significantly reduce both the number of clauses in the final program and the time needed to obtain these clauses. A preliminary version of this paper appeared in <ref> [16] </ref>. 3 Section 2. An Informal Example Section 2 An Informal Example Since the formal definition of the basic folding is a bit tricky, we shall consider the main ideas on an example.
Reference: [17] <author> A. Degtyarev and A. Voronkov. </author> <title> A note on semantics of logics programs with equality based on complete sets of E-unifiers. </title> <journal> Journal of Logic Programming, </journal> <volume> 28(3) </volume> <pages> 207-216, </pages> <month> September </month> <year> 1996. </year>
Reference-contexts: Also, solving equations in a bottom-up way gives a complete procedure for logic programs with equality, while the top-down approach using complete sets of E-unifiers (SLDE + -resolution [22]) is incomplete. An analysis of semantics of logic programs with equality based on complete sets of E-unifiers is contained in <ref> [17] </ref>. Basic superposition used in the equality elimination method makes severe restrictions on equality rules, while preserving completeness. However basic superposition does not guarantee termination | there may be infinite chains of superpositions. <p> Examples Section 6 Examples In examples, we shall often replace closures by their variants. We consider the definition of the basic folding on an example. As we have shown in <ref> [17] </ref>, this example demonstrates the incompleteness of SLDE + -resolution introduced in [23] and based on complete sets of E-unifiers [51]. SLDE + -resolution is an extension of SLD-resolution for logic programs with equality 1 .
Reference: [18] <author> N. Dershowitz and J.-P. Jouannaud. </author> <title> Rewrite systems. </title> <editor> In J. Van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B: Formal Methods and Semantics, chapter 6, </booktitle> <pages> pages 243-309. </pages> <publisher> North Holland, </publisher> <address> Amsterdam, </address> <year> 1990. </year>
Reference-contexts: In addition, SLD-tree for this program and the query query (x; y) is finite. 5 Section 3. Preliminaries Section 3 Preliminaries We present here a brief overview of notions and preliminary definitions necessary for understanding the paper. For a more thorough coverage, see books and overviews <ref> [40, 32, 42, 31, 54, 18, 28] </ref>. We assume the basic knowledge of substitutions and unification. All formulas belong to a fixed signature containing at least one constant and the binary equality symbol '. <p> In this section we shall write closures of the form C " as simply C. Example 6.1 Consider the following program P: v v ' v P (v) query (x; y) f (x x) f (y) ' f (x x) (6.1) Assume that we use lexicographic path ordering <ref> [18] </ref> induced by the precedence relation &gt; f .
Reference: [19] <author> E. Eder. </author> <title> Properties of substitutions and unifications. </title> <journal> Journal of Symbolic Computations, </journal> <volume> 1(1) </volume> <pages> 31-48, </pages> <year> 1985. </year>
Reference-contexts: Condition (3) is introduced to prevent the use of non-equality literals in basic superposition or basic folding introduced below. We make two further conventions of a technical nature. First, we assume that all substitutions be idempotent <ref> [19] </ref>. Second, whenever we use the closure notation C such that dom () 6 var (C), we mean the closure C t , where t is a restriction of on var (C). These two conventions will considerably simplify notation.
Reference: [20] <author> E.W. Elcock. </author> <title> Prolog: Subsumption of equality axioms by the homogeneous form. </title> <journal> Journal of Logic Programming, </journal> <pages> pages 45-56, </pages> <year> 1989. </year>
Reference-contexts: The modification method transforms the original Horn clause program with equality into "flat" Horn clauses without equality. Then one can use the ordinary SLD-resolution as the inference mechanism for the transformed program. In the logic programming community, this method has been considered in <ref> [6, 10, 8, 20] </ref>. Brand does not introduce new defining predicates for equations, he puts the equations themselves into bodies of clauses. After his transformation, he treats the equality predicate as the ordinary binary predicate Eq, defined by the fact Eq (x; x). <p> We also note that the ideas of using the basic strategy can be traced to Brand [9]. The transformation of programs into the homogeneous form <ref> [29, 20] </ref> allows one to get rid of the axioms of transitivity and predicate replaceability (i.e. they become "built-in") but the symmetry and the function replaceability axioms remain.
Reference: [21] <author> L. </author> <title> Fribourg. Oriented equational clauses as a programming language. </title> <journal> Journal of Logic Programming, </journal> <volume> 1 </volume> <pages> 165-177, </pages> <year> 1984. </year>
Reference-contexts: This technique appeared in [37, 55, 39] and has been further developed in [33, 50, 30, 62, 53, 56, 3, 47]. In logic programming, it was introduced in many papers, including <ref> [21, 57, 60, 36, 25, 49, 24, 26, 45] </ref>, especially in the framework of integration of logic and functional programming languages. In [14] we introduced a new method called equality elimination.
Reference: [22] <author> J.H. Gallier and S. Raatz. </author> <title> Extending SLD-resolution methods for Horn clauses with equality based on E-unification. </title> <booktitle> In Symposium on Logic Programming, </booktitle> <pages> pages 168-179, </pages> <year> 1986. </year>
Reference-contexts: Also, solving equations in a bottom-up way gives a complete procedure for logic programs with equality, while the top-down approach using complete sets of E-unifiers (SLDE + -resolution <ref> [22] </ref>) is incomplete. An analysis of semantics of logic programs with equality based on complete sets of E-unifiers is contained in [17]. Basic superposition used in the equality elimination method makes severe restrictions on equality rules, while preserving completeness.
Reference: [23] <author> J.H. Gallier and S. Raatz. </author> <title> Extending SLD-resolution to equational Horn clauses using E-unification. </title> <journal> Journal of Logic Programming, </journal> <volume> 6(3) </volume> <pages> 3-44, </pages> <year> 1989. </year>
Reference-contexts: The model-theoretic semantics of such programs is well known since long ago [7, 43]. However, there is no generally accepted procedural interpretation. The most natural generalization of SLD-resolution known as SLDE-+ -resolution <ref> [23] </ref> have been proved in general incomplete in [14]. Various definitions of procedural interpretations are actively studied in the theorem proving and logic programming communities. <p> clauses (2.4) and (2.5) yields two new clauses query (x; y) P (f (y)); f (y) ' f (y); E (f (y); x) (2.6) E (x; y) P (y); x ' f (y) (2.7) 1 As we have shown in [14], this program demonstrates the incompleteness of SLDE + -resolution <ref> [23] </ref> based on complete sets of E-unifiers [51] 4 Anatoli Degtyarev, Yuri Koval', Andrei Voronkov. Handling equality via basic folding. <p> Examples Section 6 Examples In examples, we shall often replace closures by their variants. We consider the definition of the basic folding on an example. As we have shown in [17], this example demonstrates the incompleteness of SLDE + -resolution introduced in <ref> [23] </ref> and based on complete sets of E-unifiers [51]. SLDE + -resolution is an extension of SLD-resolution for logic programs with equality 1 . In this section we shall write closures of the form C " as simply C.
Reference: [24] <author> H. Ganzinger. </author> <title> A completion procedure for conditional equations. </title> <journal> Journal of Symbolic Computations, </journal> <volume> 11 </volume> <pages> 51-81, </pages> <year> 1991. </year>
Reference-contexts: This technique appeared in [37, 55, 39] and has been further developed in [33, 50, 30, 62, 53, 56, 3, 47]. In logic programming, it was introduced in many papers, including <ref> [21, 57, 60, 36, 25, 49, 24, 26, 45] </ref>, especially in the framework of integration of logic and functional programming languages. In [14] we introduced a new method called equality elimination. <p> However, any query that is a consequence of the program can be answered at a finite stage of this process by narrowing. For Horn clause theories it has been developed in <ref> [38, 24] </ref>. Our approach is very different from the cited papers because we can always obtain a finite program using generation of conditional and recursive rules. The basic strategy without ordering restrictions has been introduced by the first author in 1979 (published in Russian, see the survey [11]).
Reference: [25] <author> E. Giovanetti and C. Moiso. </author> <title> A completeness result for E-unification algorithms based on conditional narrowing. </title> <booktitle> In Proceedings of the Workshop on Foundations of Logic and Functional Programming, volume 306 of Lecture Notes in Computer Science, </booktitle> <pages> pages 151-167. </pages> <publisher> Springer Verlag, </publisher> <year> 1988. </year>
Reference-contexts: This technique appeared in [37, 55, 39] and has been further developed in [33, 50, 30, 62, 53, 56, 3, 47]. In logic programming, it was introduced in many papers, including <ref> [21, 57, 60, 36, 25, 49, 24, 26, 45] </ref>, especially in the framework of integration of logic and functional programming languages. In [14] we introduced a new method called equality elimination.
Reference: [26] <author> J.C. Gonzalez-Moreno, M.T. Hortala-Gonzalez, and M. Rodrguez-Artalejo. </author> <title> On the completeness of narrowing as the operational semantics of functional logic programming. </title> <booktitle> In CSL'92 (Proc. 6th Workshop on Computer Science Logic), volume 702 of Lecture Notes in Computer Science, </booktitle> <pages> pages 216-230. </pages> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: This technique appeared in [37, 55, 39] and has been further developed in [33, 50, 30, 62, 53, 56, 3, 47]. In logic programming, it was introduced in many papers, including <ref> [21, 57, 60, 36, 25, 49, 24, 26, 45] </ref>, especially in the framework of integration of logic and functional programming languages. In [14] we introduced a new method called equality elimination.
Reference: [27] <author> C.C. Green. </author> <title> The Application of Theorem Proving to Question-Answering Systems. </title> <type> PhD thesis, </type> <institution> Computer Science Department, Stanford University, </institution> <month> June </month> <year> 1969. </year>
Reference-contexts: The main logical system described in our paper is very simple. It consists of three inference rules: basic superposition, equality solution and the basic folding. We introduce new predicate symbols which collect substitutions solving equations in the program, similar to "answer literals" introduced in <ref> [27] </ref>. The idea of introducing new predicate symbols to simulate basic strategy was used in different forms in [58, 14, 13, 12, 15].
Reference: [28] <author> M. Hanus. </author> <title> The integration of functions into logic programming: from theory to practice. </title> <journal> Journal of Logic Programming, </journal> <volume> 19,20:583-628, </volume> <year> 1994. </year>
Reference-contexts: The basic folding method is complete and sound for arbitrary logic programs with equality. 2 Anatoli Degtyarev, Yuri Koval', Andrei Voronkov. Handling equality via basic folding. Most existing approaches use special conditions on the set of equations which may occur in programs (see, e.g. the recent survey <ref> [28] </ref>), like confluence and/or termination. Such conditions ensure comparatively efficient operational semantics (e.g. some sophisticated narrowing strategies). Unfortunately, these conditions are not easy to verify. For example, both confluence and termination are not even semi-decidable in general. <p> In addition, SLD-tree for this program and the query query (x; y) is finite. 5 Section 3. Preliminaries Section 3 Preliminaries We present here a brief overview of notions and preliminary definitions necessary for understanding the paper. For a more thorough coverage, see books and overviews <ref> [40, 32, 42, 31, 54, 18, 28] </ref>. We assume the basic knowledge of substitutions and unification. All formulas belong to a fixed signature containing at least one constant and the binary equality symbol '. <p> Thus, it looks like a satisfiability statement. Let us consider this aspect in detail. It was precisely one of the main aims of the basic folding to avoid the generation of all correct answers. The known operational semantics of functional logic programming (see <ref> [28] </ref>) also compute only some answers. The set of computed answer substitutions for the known operational principles of functional logic programs is complete in the sense that for every correct answer substitution there is a computed answer substitution such that E .
Reference: [29] <author> P. </author> <title> Hoddinott and E.W. Elcock. PROLOG: Subsumption of equality axioms by the homogeneous form. </title> <booktitle> In IEEE International Symposium on Logic Programming, </booktitle> <pages> pages 115-126, </pages> <year> 1986. </year>
Reference-contexts: We also note that the ideas of using the basic strategy can be traced to Brand [9]. The transformation of programs into the homogeneous form <ref> [29, 20] </ref> allows one to get rid of the axioms of transitivity and predicate replaceability (i.e. they become "built-in") but the symmetry and the function replaceability axioms remain.
Reference: [30] <author> S. Holldobler. </author> <title> From paramodulation to narrowing. </title> <booktitle> In 5th International Conference on Logic Programming, </booktitle> <pages> pages 327-342, </pages> <year> 1988. </year>
Reference-contexts: The main influence on modern techniques of equational logic programming was made by equational theorem proving methods using refinements of inference in the paramodulation-based calculus via ordering strategies and deletion of redundant clauses. This technique appeared in [37, 55, 39] and has been further developed in <ref> [33, 50, 30, 62, 53, 56, 3, 47] </ref>. In logic programming, it was introduced in many papers, including [21, 57, 60, 36, 25, 49, 24, 26, 45], especially in the framework of integration of logic and functional programming languages. In [14] we introduced a new method called equality elimination.
Reference: [31] <author> S. Holldobler. </author> <title> Foundations of Equational Logic Programming, </title> <booktitle> volume 353 of Lecture Notes in Artificial Intelligence. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1989. </year>
Reference-contexts: In addition, SLD-tree for this program and the query query (x; y) is finite. 5 Section 3. Preliminaries Section 3 Preliminaries We present here a brief overview of notions and preliminary definitions necessary for understanding the paper. For a more thorough coverage, see books and overviews <ref> [40, 32, 42, 31, 54, 18, 28] </ref>. We assume the basic knowledge of substitutions and unification. All formulas belong to a fixed signature containing at least one constant and the binary equality symbol '.
Reference: [32] <author> G. Huet and D.C. Oppen. </author> <title> Equations and rewrite rules. </title> <editor> In R. Book, editor, </editor> <title> Formal Languages: Perspectives and Open Problems. </title> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference-contexts: In addition, SLD-tree for this program and the query query (x; y) is finite. 5 Section 3. Preliminaries Section 3 Preliminaries We present here a brief overview of notions and preliminary definitions necessary for understanding the paper. For a more thorough coverage, see books and overviews <ref> [40, 32, 42, 31, 54, 18, 28] </ref>. We assume the basic knowledge of substitutions and unification. All formulas belong to a fixed signature containing at least one constant and the binary equality symbol '. <p> This reminds the process of completion of equational theories which can also be characterized as a transformation of an equational theory to a canonical form <ref> [32] </ref>. As a rule, this kind of processes does not terminate, i.e. one cannot obtain a finite canonical program (see e.g. "unfailing completion" [2]). However, any query that is a consequence of the program can be answered at a finite stage of this process by narrowing.
Reference: [33] <author> J.M. Hullot. </author> <title> Canonical forms and unification. </title> <booktitle> In 5th CADE, volume 87 of Lecture Notes in Computer Science, </booktitle> <pages> pages 318-334, </pages> <year> 1980. </year>
Reference-contexts: The main influence on modern techniques of equational logic programming was made by equational theorem proving methods using refinements of inference in the paramodulation-based calculus via ordering strategies and deletion of redundant clauses. This technique appeared in [37, 55, 39] and has been further developed in <ref> [33, 50, 30, 62, 53, 56, 3, 47] </ref>. In logic programming, it was introduced in many papers, including [21, 57, 60, 36, 25, 49, 24, 26, 45], especially in the framework of integration of logic and functional programming languages. In [14] we introduced a new method called equality elimination.
Reference: [34] <author> S. Kanger. </author> <title> A simplified proof method for elementary logic. </title> <editor> In J. Siekmann and G. Wrightson, editors, </editor> <booktitle> Automation of Reasoning. Classical Papers on Computational Logic, </booktitle> <volume> volume 1, </volume> <pages> pages 364-371. </pages> <publisher> Springer Verlag, </publisher> <year> 1983. </year> <note> Originally appeared in 1963. </note>
Reference-contexts: The basic superposition inference systems have been introduced in [4, 46]. The technique of moving all work with equalities in the beginning of inferences has been studied in proof theory for sequent systems without free variables <ref> [34, 41, 48] </ref>. The first completeness proof of resolution with paramodulation [52] constructed the closure of the initial set of clauses under paramodulation and factoring, and then established its unsatisfiability in logic without equality. However, this proof used functional reflexivity axioms.
Reference: [35] <author> S. Kaplan. </author> <title> Conditional rewrite rules. </title> <journal> Theoretical Computer Science, </journal> <volume> 33 </volume> <pages> 175-193, </pages> <year> 1984. </year> <note> 46 Anatoli Degtyarev, </note> <author> Yuri Koval', Andrei Voronkov. </author> <title> Handling equality via basic folding. </title>
Reference-contexts: An answer substitution for a query Q gives no information on whether another substitution is also a correct answer (the problem x ' E x may be undecidable, even when ; are ground and E is represented by a canonical conditional term rewrite system without extra variables <ref> [35] </ref>). It means that if we would like to know whether is a correct answer substitution to Q we have to ask the query Q instead.
Reference: [36] <author> S. Kaplan. </author> <title> Simplifying conditional term rewriting systems: Unification, termination and confluence. </title> <journal> Journal of Symbolic Computations, </journal> <volume> 4(3) </volume> <pages> 295-334, </pages> <year> 1987. </year>
Reference-contexts: This technique appeared in [37, 55, 39] and has been further developed in [33, 50, 30, 62, 53, 56, 3, 47]. In logic programming, it was introduced in many papers, including <ref> [21, 57, 60, 36, 25, 49, 24, 26, 45] </ref>, especially in the framework of integration of logic and functional programming languages. In [14] we introduced a new method called equality elimination.
Reference: [37] <author> D. Knuth and P. Bendix. </author> <title> Simple word problems in universal algebras. </title> <editor> In J. Leech, editor, </editor> <booktitle> Computational Problems in Abstract Algebra, </booktitle> <pages> pages 263-297. </pages> <publisher> Pergamon Press, Oxford, </publisher> <year> 1970. </year>
Reference-contexts: The main influence on modern techniques of equational logic programming was made by equational theorem proving methods using refinements of inference in the paramodulation-based calculus via ordering strategies and deletion of redundant clauses. This technique appeared in <ref> [37, 55, 39] </ref> and has been further developed in [33, 50, 30, 62, 53, 56, 3, 47]. In logic programming, it was introduced in many papers, including [21, 57, 60, 36, 25, 49, 24, 26, 45], especially in the framework of integration of logic and functional programming languages.
Reference: [38] <author> E. Kounalis and Rusinowitch. </author> <title> On word problems in Horn theories. </title> <editor> In E. Lusk and R. Overbeek, editors, </editor> <booktitle> 9th CADE, volume 310 of Lecture Notes in Computer Science, </booktitle> <pages> pages 527-537, </pages> <address> Argonne, Illinois, 1988. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: However, any query that is a consequence of the program can be answered at a finite stage of this process by narrowing. For Horn clause theories it has been developed in <ref> [38, 24] </ref>. Our approach is very different from the cited papers because we can always obtain a finite program using generation of conditional and recursive rules. The basic strategy without ordering restrictions has been introduced by the first author in 1979 (published in Russian, see the survey [11]).
Reference: [39] <author> D.S. Lankford. </author> <title> Canonical inference. </title> <type> Technical report, </type> <institution> Department of Mathematics, South-Western University, Georgetown, Texas, </institution> <year> 1975. </year>
Reference-contexts: The main influence on modern techniques of equational logic programming was made by equational theorem proving methods using refinements of inference in the paramodulation-based calculus via ordering strategies and deletion of redundant clauses. This technique appeared in <ref> [37, 55, 39] </ref> and has been further developed in [33, 50, 30, 62, 53, 56, 3, 47]. In logic programming, it was introduced in many papers, including [21, 57, 60, 36, 25, 49, 24, 26, 45], especially in the framework of integration of logic and functional programming languages.
Reference: [40] <author> R.C.T. Lee and C.L. Chang. </author> <title> Symbolic Logic and Mechanical Theorem Proving. </title> <publisher> Academic Press, </publisher> <year> 1973. </year>
Reference-contexts: In addition, SLD-tree for this program and the query query (x; y) is finite. 5 Section 3. Preliminaries Section 3 Preliminaries We present here a brief overview of notions and preliminary definitions necessary for understanding the paper. For a more thorough coverage, see books and overviews <ref> [40, 32, 42, 31, 54, 18, 28] </ref>. We assume the basic knowledge of substitutions and unification. All formulas belong to a fixed signature containing at least one constant and the binary equality symbol '.
Reference: [41] <author> V. Lifschitz. </author> <title> Specialized forms of derivation in predicate calculus with equality and functional symbols (in Russian). </title> <booktitle> In Trudy MIAN, </booktitle> <volume> volume 98, </volume> <pages> pages 5-25. </pages> <year> 1968. </year> <title> English translation in: </title> <booktitle> Proc. </booktitle> <institution> Steklov Institute of Math., AMS, Providence, RI, </institution> <year> 1971. </year>
Reference-contexts: The basic superposition inference systems have been introduced in [4, 46]. The technique of moving all work with equalities in the beginning of inferences has been studied in proof theory for sequent systems without free variables <ref> [34, 41, 48] </ref>. The first completeness proof of resolution with paramodulation [52] constructed the closure of the initial set of clauses under paramodulation and factoring, and then established its unsatisfiability in logic without equality. However, this proof used functional reflexivity axioms.
Reference: [42] <author> J.W. Lloyd. </author> <booktitle> Foundations of Logic Programming (2nd edition). </booktitle> <publisher> Springer Verlag, </publisher> <year> 1987. </year>
Reference-contexts: In addition, SLD-tree for this program and the query query (x; y) is finite. 5 Section 3. Preliminaries Section 3 Preliminaries We present here a brief overview of notions and preliminary definitions necessary for understanding the paper. For a more thorough coverage, see books and overviews <ref> [40, 32, 42, 31, 54, 18, 28] </ref>. We assume the basic knowledge of substitutions and unification. All formulas belong to a fixed signature containing at least one constant and the binary equality symbol '.
Reference: [43] <author> A. Ma lcev. </author> <title> Subdirect products of models. </title> <journal> Dokl. Akad. Nauk SSSR (in Russian), </journal> <volume> 109 </volume> <pages> 264-266, </pages> <year> 1956. </year>
Reference-contexts: By a logic program with equality we understand a Horn clause logic program in which equality may occur both in the heads and in the bodies of clauses. The model-theoretic semantics of such programs is well known since long ago <ref> [7, 43] </ref>. However, there is no generally accepted procedural interpretation. The most natural generalization of SLD-resolution known as SLDE-+ -resolution [23] have been proved in general incomplete in [14]. Various definitions of procedural interpretations are actively studied in the theorem proving and logic programming communities.
Reference: [44] <author> M.H.A. Newman. </author> <title> On theories with combinatorial definition of "equivalence". </title> <journal> Annals of Mathematics, </journal> <volume> 43(2) </volume> <pages> 223-243, </pages> <year> 1942. </year>
Reference-contexts: Then there is a closure D such that C 0 cfl ! D and C 00 mfl ! D, i.e. the following diagram commutes: C C 0 C 00 @ @ @R m fl c fl Proof. Follows the scheme of the proof of <ref> [44] </ref> that any noetherian relation is confluent iff it is locally confluent, using Lemmas C.15 and C.16. 2 Lemma C.18 Let C 1 ; C 2 ; C 3 ; C 0 2 be closures, C 3 be obtained from C 1 ; C 2 by a pseudo application of superposition
Reference: [45] <author> R. Nieuwenhuis. </author> <title> On narrowing, refutation proofs and constraints. </title> <editor> In J. Hsiang, editor, </editor> <booktitle> Rewriting Techniques and Applications, volume 914 of Lecture Notes in Computer Science, </booktitle> <pages> pages 56-70, </pages> <year> 1995. </year>
Reference-contexts: This technique appeared in [37, 55, 39] and has been further developed in [33, 50, 30, 62, 53, 56, 3, 47]. In logic programming, it was introduced in many papers, including <ref> [21, 57, 60, 36, 25, 49, 24, 26, 45] </ref>, especially in the framework of integration of logic and functional programming languages. In [14] we introduced a new method called equality elimination. <p> For example, in [14] we show that the minimal model of a program is not a fixpoint when we use complete sets of unifiers in the definition of the immediate consequence operator. Following <ref> [45] </ref>, we could have changed the completeness statement in a way more traditional for logic programming via answer substitutions using a suitable notion of minimality. However it requires several new notions and a different technique. We plan to further investigate this subject.
Reference: [46] <author> R. Nieuwenhuis and A. Rubio. </author> <title> Basic superposition is complete. </title> <booktitle> In ESOP'92, volume 582 of Lecture Notes in Computer Science, </booktitle> <pages> pages 371-389. </pages> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: In [14] we introduced a new method called equality elimination. This method performs all equality-related reasoning steps before all other inference steps using a special strategy | basic superposition <ref> [46, 4] </ref>. Using solutions to equations provided by basic superposition, we transform a logic program with equality into a logic program without equality. The equality elimination method combines bottom-up solutions of equations with top-down query answering in the transformed logic program. <p> The basic strategy without ordering restrictions has been introduced by the first author in 1979 (published in Russian, see the survey [11]). The motivation was to reduce the search space by restricting the paramodulation at the term level. The basic superposition inference systems have been introduced in <ref> [4, 46] </ref>. The technique of moving all work with equalities in the beginning of inferences has been studied in proof theory for sequent systems without free variables [34, 41, 48].
Reference: [47] <author> R. Nieuwenhuis and A. Rubio. </author> <title> Theorem proving with ordering and equality constrained clauses. </title> <journal> Journal of Symbolic Computations, </journal> <volume> 19 </volume> <pages> 321-351, </pages> <year> 1995. </year>
Reference-contexts: The main influence on modern techniques of equational logic programming was made by equational theorem proving methods using refinements of inference in the paramodulation-based calculus via ordering strategies and deletion of redundant clauses. This technique appeared in [37, 55, 39] and has been further developed in <ref> [33, 50, 30, 62, 53, 56, 3, 47] </ref>. In logic programming, it was introduced in many papers, including [21, 57, 60, 36, 25, 49, 24, 26, 45], especially in the framework of integration of logic and functional programming languages. In [14] we introduced a new method called equality elimination. <p> Then there is a substitution such that C 0 f (i) has the form C " and C is ground. A BR-derivation is groundable iff it has a ground version. A BR-derivation is groundable iff this derivation corresponds to the constraint strategy CS OB of <ref> [47] </ref> in which all equality and ordering constraints (similar to our ordering conditions in Definition 3.6) are inherited. In the proof of Theorem 5.2 given below we use the main result ([47], Theorem 6.14) on the completeness of the CS OB -strategy which can be formulated as follows. <p> Then there exists a groundable pseudo BR-derivation of " from S. When writing this paper, we had to choose between the use of constraints in the style of <ref> [47] </ref> or substitutions in the style of [3]. The use of ordering constraints would simplify many proofs below based on transformations of derivations. But the definition of the basic folding which is already enough sophisticated would have become even more difficult to understand.
Reference: [48] <author> V.P. Orevkov. </author> <title> On nonlengthening applications of equality rules (in Russian). </title> <journal> Zapiski Nauchnyh Semi-narov LOMI, </journal> <volume> 16 </volume> <pages> 152-156, </pages> <year> 1969. </year> <note> English Translation in: Seminars in Mathematics: </note> <institution> Steklov Math. Inst. 16, Consultants Bureau, NY-London, </institution> <year> 1971, </year> <month> p.77-79. </month>
Reference-contexts: The basic superposition inference systems have been introduced in [4, 46]. The technique of moving all work with equalities in the beginning of inferences has been studied in proof theory for sequent systems without free variables <ref> [34, 41, 48] </ref>. The first completeness proof of resolution with paramodulation [52] constructed the closure of the initial set of clauses under paramodulation and factoring, and then established its unsatisfiability in logic without equality. However, this proof used functional reflexivity axioms.
Reference: [49] <author> P. Padawitz. </author> <title> Computing in Horn Clause Theories, </title> <booktitle> volume 16 of EATCS Monographs in Theoretical Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1988. </year>
Reference-contexts: This technique appeared in [37, 55, 39] and has been further developed in [33, 50, 30, 62, 53, 56, 3, 47]. In logic programming, it was introduced in many papers, including <ref> [21, 57, 60, 36, 25, 49, 24, 26, 45] </ref>, especially in the framework of integration of logic and functional programming languages. In [14] we introduced a new method called equality elimination.
Reference: [50] <author> G.E. Peterson. </author> <title> A technique for establishing completeness results in theorem proving with equality. </title> <journal> SIAM Journal of Computing, </journal> <volume> 12(1) </volume> <pages> 82-100, </pages> <year> 1983. </year>
Reference-contexts: The main influence on modern techniques of equational logic programming was made by equational theorem proving methods using refinements of inference in the paramodulation-based calculus via ordering strategies and deletion of redundant clauses. This technique appeared in [37, 55, 39] and has been further developed in <ref> [33, 50, 30, 62, 53, 56, 3, 47] </ref>. In logic programming, it was introduced in many papers, including [21, 57, 60, 36, 25, 49, 24, 26, 45], especially in the framework of integration of logic and functional programming languages. In [14] we introduced a new method called equality elimination.
Reference: [51] <author> G. Plotkin. </author> <title> Building-in equational theories. </title> <editor> In B. Meltzer and D. Michie, editors, </editor> <booktitle> Machine Intelligence, </booktitle> <volume> volume 7, </volume> <pages> pages 73-90. </pages> <publisher> Edinburgh University Press, </publisher> <year> 1972. </year>
Reference-contexts: clauses query (x; y) P (f (y)); f (y) ' f (y); E (f (y); x) (2.6) E (x; y) P (y); x ' f (y) (2.7) 1 As we have shown in [14], this program demonstrates the incompleteness of SLDE + -resolution [23] based on complete sets of E-unifiers <ref> [51] </ref> 4 Anatoli Degtyarev, Yuri Koval', Andrei Voronkov. Handling equality via basic folding. <p> We consider the definition of the basic folding on an example. As we have shown in [17], this example demonstrates the incompleteness of SLDE + -resolution introduced in [23] and based on complete sets of E-unifiers <ref> [51] </ref>. SLDE + -resolution is an extension of SLD-resolution for logic programs with equality 1 . In this section we shall write closures of the form C " as simply C.
Reference: [52] <author> G. Robinson and L. Wos. </author> <title> Completeness of paramodulation. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 34(1) </volume> <pages> 159-160, </pages> <year> 1969. </year>
Reference-contexts: The basic superposition inference systems have been introduced in [4, 46]. The technique of moving all work with equalities in the beginning of inferences has been studied in proof theory for sequent systems without free variables [34, 41, 48]. The first completeness proof of resolution with paramodulation <ref> [52] </ref> constructed the closure of the initial set of clauses under paramodulation and factoring, and then established its unsatisfiability in logic without equality. However, this proof used functional reflexivity axioms. The main logical system described in our paper is very simple.
Reference: [53] <author> M. Rusinowitch. </author> <title> Theorem proving with resolution and superposition: an extension of the Knuth and Bendix completion procedure as a complete set of inference rules. </title> <journal> Journal of Symbolic Computations, </journal> <volume> 11 </volume> <pages> 21-49, </pages> <year> 1991. </year>
Reference-contexts: The main influence on modern techniques of equational logic programming was made by equational theorem proving methods using refinements of inference in the paramodulation-based calculus via ordering strategies and deletion of redundant clauses. This technique appeared in [37, 55, 39] and has been further developed in <ref> [33, 50, 30, 62, 53, 56, 3, 47] </ref>. In logic programming, it was introduced in many papers, including [21, 57, 60, 36, 25, 49, 24, 26, 45], especially in the framework of integration of logic and functional programming languages. In [14] we introduced a new method called equality elimination.
Reference: [54] <author> J.H. Siekmann. </author> <title> An introduction to unification theory. </title> <editor> In R.B. Banerji, editor, </editor> <booktitle> Formal Techniques in Artificial Intelligence, </booktitle> <pages> pages 369-425. </pages> <publisher> Elsevier Science, </publisher> <year> 1990. </year>
Reference-contexts: In addition, SLD-tree for this program and the query query (x; y) is finite. 5 Section 3. Preliminaries Section 3 Preliminaries We present here a brief overview of notions and preliminary definitions necessary for understanding the paper. For a more thorough coverage, see books and overviews <ref> [40, 32, 42, 31, 54, 18, 28] </ref>. We assume the basic knowledge of substitutions and unification. All formulas belong to a fixed signature containing at least one constant and the binary equality symbol '.
Reference: [55] <author> J.R. Slagle. </author> <title> Automated theorem-proving for theories with simplifiers, commutativity and associativity. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 21(4) </volume> <pages> 622-642, </pages> <year> 1974. </year>
Reference-contexts: The main influence on modern techniques of equational logic programming was made by equational theorem proving methods using refinements of inference in the paramodulation-based calculus via ordering strategies and deletion of redundant clauses. This technique appeared in <ref> [37, 55, 39] </ref> and has been further developed in [33, 50, 30, 62, 53, 56, 3, 47]. In logic programming, it was introduced in many papers, including [21, 57, 60, 36, 25, 49, 24, 26, 45], especially in the framework of integration of logic and functional programming languages.
Reference: [56] <author> R. Socher-Ambrosius. </author> <title> A goal-oriented strategy based on completion. </title> <booktitle> In Proc. ALP'92, volume 632 of Lecture Notes in Computer Science, </booktitle> <pages> pages 435-445. </pages> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: The main influence on modern techniques of equational logic programming was made by equational theorem proving methods using refinements of inference in the paramodulation-based calculus via ordering strategies and deletion of redundant clauses. This technique appeared in [37, 55, 39] and has been further developed in <ref> [33, 50, 30, 62, 53, 56, 3, 47] </ref>. In logic programming, it was introduced in many papers, including [21, 57, 60, 36, 25, 49, 24, 26, 45], especially in the framework of integration of logic and functional programming languages. In [14] we introduced a new method called equality elimination.
Reference: [57] <author> M.H. Van Emden and K. Yukawa. </author> <title> Logic programming with equations. </title> <journal> Journal of Logic Programming, </journal> <volume> 4 </volume> <pages> 265-288, </pages> <year> 1987. </year> <note> 47 Bibliography </note>
Reference-contexts: This technique appeared in [37, 55, 39] and has been further developed in [33, 50, 30, 62, 53, 56, 3, 47]. In logic programming, it was introduced in many papers, including <ref> [21, 57, 60, 36, 25, 49, 24, 26, 45] </ref>, especially in the framework of integration of logic and functional programming languages. In [14] we introduced a new method called equality elimination.
Reference: [58] <author> A. Voronkov. </author> <title> Theorem proving in non-standard logics based on the inverse method. </title> <editor> In D. Kapur, editor, </editor> <booktitle> 11th International Conference on Automated Deduction, volume 607 of Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 648-662, </pages> <address> Saratoga Springs, NY, USA, June 1992. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: We introduce new predicate symbols which collect substitutions solving equations in the program, similar to "answer literals" introduced in [27]. The idea of introducing new predicate symbols to simulate basic strategy was used in different forms in <ref> [58, 14, 13, 12, 15] </ref>. The transformation proposed by Brand [9] achieves similar aims, but his technique requires transitivity and symmetry axioms to be added explicitly or implicitly, which immediately creates branching in the SLD-tree for the resulting programs.
Reference: [59] <author> S. Winker. </author> <title> Robbins algebra: Conditions that make a near-boolean algebra boolean. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 6(4) </volume> <pages> 465-489, </pages> <year> 1990. </year>
Reference-contexts: This is not achieved by other methods which try to move all equality reasoning to SLD-resolution. The automatic introduction of new function symbols for defining some useful subterms have been used in automated deduction systems <ref> [59, 61] </ref>. 24 Anatoli Degtyarev, Yuri Koval', Andrei Voronkov. Handling equality via basic folding. Section 8 Implementation Our method is implemented as a program transformation system written in Sicstus Prolog (about 1500 lines of Prolog code).
Reference: [60] <author> A. Yamamoto. </author> <title> A theoretical combination of SLD-resolution and narrowing. </title> <booktitle> In Proc. ICLP'87, </booktitle> <pages> pages 470-487. </pages> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: This technique appeared in [37, 55, 39] and has been further developed in [33, 50, 30, 62, 53, 56, 3, 47]. In logic programming, it was introduced in many papers, including <ref> [21, 57, 60, 36, 25, 49, 24, 26, 45] </ref>, especially in the framework of integration of logic and functional programming languages. In [14] we introduced a new method called equality elimination.
Reference: [61] <author> H. Zhang. </author> <title> Automatic proofs of equality problems in Overbeek's competition. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 11(3) </volume> <pages> 333-351, </pages> <year> 1993. </year>
Reference-contexts: This is not achieved by other methods which try to move all equality reasoning to SLD-resolution. The automatic introduction of new function symbols for defining some useful subterms have been used in automated deduction systems <ref> [59, 61] </ref>. 24 Anatoli Degtyarev, Yuri Koval', Andrei Voronkov. Handling equality via basic folding. Section 8 Implementation Our method is implemented as a program transformation system written in Sicstus Prolog (about 1500 lines of Prolog code).
Reference: [62] <author> H. Zhang and D. Kapur. </author> <title> First-order theorem proving using conditional rewrite rules. </title> <editor> In E. Lusk and R. Overbeek, editors, </editor> <booktitle> 9th International Conference on Automated Deduction, volume 310 of Lecture Notes in Computer Science, </booktitle> <pages> pages 1-20. </pages> <publisher> Springer Verlag, </publisher> <year> 1988. </year>
Reference-contexts: The main influence on modern techniques of equational logic programming was made by equational theorem proving methods using refinements of inference in the paramodulation-based calculus via ordering strategies and deletion of redundant clauses. This technique appeared in [37, 55, 39] and has been further developed in <ref> [33, 50, 30, 62, 53, 56, 3, 47] </ref>. In logic programming, it was introduced in many papers, including [21, 57, 60, 36, 25, 49, 24, 26, 45], especially in the framework of integration of logic and functional programming languages. In [14] we introduced a new method called equality elimination.
References-found: 62

