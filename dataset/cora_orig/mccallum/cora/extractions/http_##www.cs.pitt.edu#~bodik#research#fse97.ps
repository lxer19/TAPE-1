URL: http://www.cs.pitt.edu/~bodik/research/fse97.ps
Refering-URL: http://www.cs.pitt.edu/~bodik/research/fse97.html
Root-URL: 
Title: Refining Data Flow Information using Infeasible Paths  
Author: Rastislav Bodk, Rajiv Gupta, and Mary Lou Soffa 
Address: Pittsburgh, Pittsburgh, PA 15260, USA  
Affiliation: Dept. of Computer Science, University of  
Abstract: Experimental evidence indicates that large programs exhibit significant amount of branch correlation amenable to compile-time detection. Branch correlation gives rise to infeasible paths, which in turn make data flow information overly conservative. For example, def-use pairs that always span infeasible paths cannot be tested by any program input, preventing 100% def-use testing coverage. We present an algorithm for identifying infeasible program paths and a data flow analysis technique that improves the precision of traditional def-use pair analysis by incorporating the information about infeasible paths into the analysis. Infeasible paths are computed using branch correlation analysis, which can be performed either intra- or inter-procedurally. The efficiency of our technique is achieved through demand-driven formulation of both the infeasible paths detection and the def-use pair analysis. Our experiments indicate that even when a simple form of intraprocedural branch correlation is considered, more than 2% of def-use pairs in the SPEC95 benchmark programs can be found infeasible.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A.V. Aho, R. Sethi, J.D. Ullman, </author> <booktitle> Compilers, Principles, Techniques, and Tools, </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: Reaching definitions can be computed either using an exhaustive data flow algorithm (such as iterative) <ref> [1] </ref> or using a demand-driven algorithm [3]. In an exhaustive algorithm, the reaching definitions are computed for all variables at all nodes. In the demand-driven algorithm, the reaching definitions for each variable used in a node are computed.
Reference: 2. <author> R. Bodik, R. Gupta, </author> <title> and M.L. Soffa, "Interprocedural Conditional Branch Elimination," </title> <booktitle> Proceedings of the ACM SIGPLAN '97 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: Experiments show that from 9 to 40 % of conditionals in large programs exhibit correlation that is detectable at compile time <ref> [2] </ref>. This implies that a significant number of infeasible program paths can be detected prior to program execution. <p> Since significantly more correlation can be detected interprocedurally, we have developed both intra- and inter-procedural versions of our analyses. The algorithm for detection of interprocedural branch correlation was originally developed to support a compiler optimization for the elimination of redundant conditional branches <ref> [2] </ref>. We extend the correlation detection algorithm in this paper to identify shortest infeasible paths and to label the control flow graph with these paths. Techniques for static branch correlation detection have also been developed by other researchers [8, 15]. <p> The duality between infeasible and correlated paths allows us to determine the shape and extent of infeasible paths using a branch correlation analysis. We 3 have recently developed such analysis to support the elimination of interprocedu--rally redundant conditional branches <ref> [2] </ref>. Here we summarize its intraprocedural version; please refer to [2] for details of the interprocedural correlation analysis. The goal of the analysis is to find paths along which the outcome of branches can be determined from assertions generated by other program statements. <p> The duality between infeasible and correlated paths allows us to determine the shape and extent of infeasible paths using a branch correlation analysis. We 3 have recently developed such analysis to support the elimination of interprocedu--rally redundant conditional branches <ref> [2] </ref>. Here we summarize its intraprocedural version; please refer to [2] for details of the interprocedural correlation analysis. The goal of the analysis is to find paths along which the outcome of branches can be determined from assertions generated by other program statements. Our algorithm determines the infeasible paths by detecting correlation of each conditional separately. <p> In the remainder of this section we describe the interprocedural versions of both infeasible path analysis and the def-use analysis. Detecting infeasible paths. The interprocedural version of infeasible path analysis from Fig. 1 is based on the algorithm in <ref> [2] </ref>. The extension is based on propagating queries between callers and callees and maintaining appropriate procedure summary nodes. The infeasible path marking algorithm in Fig. 2 does not require changes. Interprocedural Reaching Definitions.
Reference: 3. <author> E. Duesterwald, R. Gupta, </author> <title> and M.L. Soffa, "Interprocedural Data Flow Analysis on Demand," </title> <booktitle> The 22nd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 37-48, </pages> <address> San Francisco, California, </address> <month> January </month> <year> 1995. </year>
Reference-contexts: In summary, the algorithm has two steps, shown in Fig. 1. The backward query propagation algorithm of the first step is based on the demand-driven analysis framework in <ref> [3] </ref>. The algorithm finds correlation for a single conditional node b. Line 1 removes from Q [n] all queries raised during the previous invocation of the algorithm. The initial query q b holds the branch predicate expression and is raised at all predecessors of b at line 2. <p> Reaching definitions can be computed either using an exhaustive data flow algorithm (such as iterative) [1] or using a demand-driven algorithm <ref> [3] </ref>. In an exhaustive algorithm, the reaching definitions are computed for all variables at all nodes. In the demand-driven algorithm, the reaching definitions for each variable used in a node are computed. <p> Due to the many possible subsets of the ipp set, the amount of information to be stored in the summary node is significant. However, since only a fraction of a summary node will likely be referenced, we present in this section the demand-driven defuse analysis based on <ref> [3] </ref>, which achieves efficiency by computing only the needed subset of each summary node.
Reference: 4. <author> E. Duesterwald, R. Gupta, </author> <title> and M.L. Soffa, "A Demand-Driven Analyzer for Data Flow Testing at the Integration Level," </title> <booktitle> International Conference on Software Engineering, </booktitle> <address> Berlin, Germany, </address> <month> March </month> <year> 1996. </year>
Reference-contexts: Since 100% test coverage can rarely be achieved on real programs due to presence of infeasible paths, reducing the number of infeasible def-use pairs increases the confidence in regression testing [11] and integration testing <ref> [4] </ref>. By avoiding the consideration of infeasible paths during static slicing [10, 14, 17], fewer statements are added to the program slice, thus more precisely identifying the potentially erroneous statements. <p> In the demand-driven algorithm, the reaching definitions for each variable used in a node are computed. Recent studies have demonstrated that demand-driven algorithms take less time and space to compute reaching definitions than exhaustive ones, even when the computation of all def-use pairs is required <ref> [4, 12] </ref>. We present in this paper the demand-driven version of def-use analysis. The demand-driven algorithm is presented in Fig. 4. It computes def-use pairs for a variable v used at a node u.
Reference: 5. <author> P.G. Frankl, E.J. Woyeker, </author> <title> "An Applicable Family of Data Flow Testing Criteria," </title> <journal> IEEE Transactions on Software Engineering, pages 1483-1498, </journal> <volume> Vol. 14, No. 10, </volume> <month> October </month> <year> 1988. </year>
Reference-contexts: We should also point out that, while using interproce-dural infeasible paths enables elimination of only a small additional amount of 15 def-use pairs, these def-use pairs are extremely difficult to confirm as infeasible manually because the calling context of procedures must be carefully examined, as reported in <ref> [5] </ref>. Table 2 also presents the cost of our analysis. Since the set of infeasible paths ipp is best implemented by a bit vector, we are interested in the maximum and average size of the present marking sets, across all edges in the control flow graph.
Reference: 6. <author> C. Fraser and D. Hanson, </author> <title> A Retargetable C Compiler: Design and Implementation, </title> <address> Benjamin/Cummings, </address> <year> 1995. </year>
Reference-contexts: An example of interprocedural infeasible paths is shown in Fig. 6. 13 Fig. 6. An example of interprocedural infeasible paths. 5 Experimental Results To measure the cost and benefit of our analysis technique, we implemented the algorithms in our interprocedural compiler which is based on the lcc compiler <ref> [6] </ref>. In this section, we compare the traditional intraprocedural def-use analysis with two configurations of our technique: the intraprocedural def-use analysis utilizing a) intraprocedural and b) inter procedural infeasible paths analysis. The experiments were performed on the integer benchmarks from the SPEC95 suite.
Reference: 7. <author> H.N. Gabow, </author> <title> S.N. Maheshwari, L.J. Osterweil, "On Two Problems in the Generation of Program Test Paths," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. SE-2, No. 3, </volume> <pages> pages 227-231, </pages> <month> September </month> <year> 1976. </year>
Reference-contexts: In path testing, the algorithm for selecting paths to be tested can avoid paths found infeasible due to branch correlation and thus reduce the effort to generate test cases. Typically, such algorithms do not consider infeasible paths <ref> [7, 16] </ref>. In def-use testing, def-use pairs that occur only along infeasible paths can be eliminated from the set of requirements to be covered by test cases.
Reference: 8. <author> R. Gupta and P. Gopinath, </author> <title> "Correlation Analysis Techniques for Refining Execution Time Estimates of Real-Time Applications," </title> <booktitle> 11th IEEE Workshop on Real-Time Operating Systems and Software, </booktitle> <pages> pages 54-58, </pages> <address> Seattle, Washington, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: We extend the correlation detection algorithm in this paper to identify shortest infeasible paths and to label the control flow graph with these paths. Techniques for static branch correlation detection have also been developed by other researchers <ref> [8, 15] </ref>. While these techniques can detect correlated branches, they do not identify the shape of infeasible paths, a requirement for eliminating infeasible def-use pairs. Furthermore, only correlation between pairs of branches is detected, which is not sufficient for identifying 2 some infeasible paths that cross multiple conditionals.
Reference: 9. <author> R. Gupta and M.L. Soffa, </author> <title> "Employing Static Information in the Generation of Test Cases," </title> <journal> Journal of Software Testing, Verification and Reliability, </journal> <volume> Vol. 3, No. 1, </volume> <pages> pages 29-48, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: In data flow testing, imprecision may lead to the selection of definition-use (def-use) pairs which are impossible to test because they lie on infeasible paths. Considerable effort may be wasted in trying to generate input data, either manually or automatically, that traverses the infeasible paths <ref> [9] </ref>. Knowledge about infeasible paths can be used to improve the precision of static analyzers because these paths can be excluded from consideration.
Reference: 10. <author> R. Gupta and M.L. Soffa, </author> <title> "Hybrid Slicing: An Approach for Refining Static Slices Using Dynamic Information," </title> <booktitle> ACM SIGSOFT Third Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 29-40, </pages> <address> Washington, DC, </address> <month> October </month> <year> 1995. </year>
Reference-contexts: Since 100% test coverage can rarely be achieved on real programs due to presence of infeasible paths, reducing the number of infeasible def-use pairs increases the confidence in regression testing [11] and integration testing [4]. By avoiding the consideration of infeasible paths during static slicing <ref> [10, 14, 17] </ref>, fewer statements are added to the program slice, thus more precisely identifying the potentially erroneous statements. In this paper we present a static def-use pair analysis technique that avoids identification of infeasible def-use pairs through detection of branch correlation.
Reference: 11. <author> R. Gupta, M.J. Harrold, </author> <title> and M.L. Soffa, "An Approach to Regression Testing using Slicing," </title> <booktitle> Conference on Software Maintenance, </booktitle> <pages> pages 299-308, </pages> <address> Orlando, Florida, </address> <month> November </month> <year> 1992. </year>
Reference-contexts: Since 100% test coverage can rarely be achieved on real programs due to presence of infeasible paths, reducing the number of infeasible def-use pairs increases the confidence in regression testing <ref> [11] </ref> and integration testing [4]. By avoiding the consideration of infeasible paths during static slicing [10, 14, 17], fewer statements are added to the program slice, thus more precisely identifying the potentially erroneous statements.
Reference: 12. <author> S. Horwitz, T. Reps, and M. Sagiv, </author> <title> "Demand Interprocedural Data Flow Analysis," </title> <booktitle> ACM SIGSOFT Third Symposium on the Foundations of Software Engineering, </booktitle> <address> Washington, DC, </address> <month> October </month> <year> 1995. </year>
Reference-contexts: In the demand-driven algorithm, the reaching definitions for each variable used in a node are computed. Recent studies have demonstrated that demand-driven algorithms take less time and space to compute reaching definitions than exhaustive ones, even when the computation of all def-use pairs is required <ref> [4, 12] </ref>. We present in this paper the demand-driven version of def-use analysis. The demand-driven algorithm is presented in Fig. 4. It computes def-use pairs for a variable v used at a node u.
Reference: 13. <author> L.H. Holley and B.K. Rosen, </author> <title> "Qualified Data Flow Problems," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. SE-7, NO.1, </volume> <month> January </month> <year> 1981 </year>
Reference-contexts: Finally, only correlation along paths that do not cross procedure boundaries is considered in these techniques. Improving the precision of data flow analysis by reducing the impact of infeasible paths has also been considered by Holley and Rosen <ref> [13] </ref>. In their framework, a data flow problem is solved by considering paths feasible under a given set of assertions on variable values. Since this approach tracks the entire program state that might determine the outcome of a conditional branch, it necessarily collects assertions not contributing to the correlation.
Reference: 14. <author> J.R. Lyle and M. Weiser, </author> <title> "Automatic Program Bug Location by Program Slicing," </title> <booktitle> Proc. Second IEEE Symposium on Computers and Applications, </booktitle> <pages> pages 877-883, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: Since 100% test coverage can rarely be achieved on real programs due to presence of infeasible paths, reducing the number of infeasible def-use pairs increases the confidence in regression testing [11] and integration testing [4]. By avoiding the consideration of infeasible paths during static slicing <ref> [10, 14, 17] </ref>, fewer statements are added to the program slice, thus more precisely identifying the potentially erroneous statements. In this paper we present a static def-use pair analysis technique that avoids identification of infeasible def-use pairs through detection of branch correlation.
Reference: 15. <author> F. Mueller and D.B. Whalley, </author> <title> "Avoiding conditional branches by code replication," </title> <booktitle> Proceedings of the ACM SIGPLAN '95 Conference on Programming Language Design and Implementation, SIGPLAN Notices, </booktitle> <volume> 30(6) </volume> <pages> 56-66, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: We extend the correlation detection algorithm in this paper to identify shortest infeasible paths and to label the control flow graph with these paths. Techniques for static branch correlation detection have also been developed by other researchers <ref> [8, 15] </ref>. While these techniques can detect correlated branches, they do not identify the shape of infeasible paths, a requirement for eliminating infeasible def-use pairs. Furthermore, only correlation between pairs of branches is detected, which is not sufficient for identifying 2 some infeasible paths that cross multiple conditionals.
Reference: 16. <author> H.S. Wang and S.R. Hsu, </author> <title> "A Generalized Optimal Path-Selection Model for Structural Program Testing," </title> <journal> The Journal of Systems and Software, </journal> <volume> Vol. 10, </volume> <pages> pages 55-63, </pages> <year> 1989. </year>
Reference-contexts: In path testing, the algorithm for selecting paths to be tested can avoid paths found infeasible due to branch correlation and thus reduce the effort to generate test cases. Typically, such algorithms do not consider infeasible paths <ref> [7, 16] </ref>. In def-use testing, def-use pairs that occur only along infeasible paths can be eliminated from the set of requirements to be covered by test cases.
Reference: 17. <author> M. Weiser, </author> <title> "Program Slicing," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. SE-10, No. 4, </volume> <pages> pages 352-357, </pages> <month> July </month> <year> 1984. </year> <title> 17 This article was processed using the L A T E X macro package with LLNCS style 18 </title>
Reference-contexts: Since 100% test coverage can rarely be achieved on real programs due to presence of infeasible paths, reducing the number of infeasible def-use pairs increases the confidence in regression testing [11] and integration testing [4]. By avoiding the consideration of infeasible paths during static slicing <ref> [10, 14, 17] </ref>, fewer statements are added to the program slice, thus more precisely identifying the potentially erroneous statements. In this paper we present a static def-use pair analysis technique that avoids identification of infeasible def-use pairs through detection of branch correlation. <p> Finally, the def-use pair (2; 12) on y is excluded due to the infeasible path that leads to the true exit of node 7. The demand-driven algorithm which finds the definitions reaching a given use is also useful for determining more precise program slices <ref> [17] </ref>. By repeated application of this algorithm, the data slice corresponding to a given statement node can be easily computed. Due to the refined def-use analysis, this algorithm computes smaller slices than traditional slicing algorithms. Time complexity.
References-found: 17

