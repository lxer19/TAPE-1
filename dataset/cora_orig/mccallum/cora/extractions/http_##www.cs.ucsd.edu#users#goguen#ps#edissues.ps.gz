URL: http://www.cs.ucsd.edu/users/goguen/ps/edissues.ps.gz
Refering-URL: http://www.cs.ucsd.edu/users/goguen/new.html
Root-URL: http://www.cs.ucsd.edu
Title: An Executable Course in the Algebraic Semantics of Imperative Programs  
Author: Grant Malcolm and Joseph A. Goguen 
Affiliation: Programming Research Group, Oxford University  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Roland Backhouse. </author> <title> Program Construction and Verification. </title> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference-contexts: We will see that proofs in the ADS framework can be surprisingly easy. So-called weakest precondition semantics is a well-known variety of axiomatic semantics developed by Edsger Dijkstra [2, 3]. Standard textbooks using this approach have been written by David Gries [14] and Roland Backhouse <ref> [1] </ref>. In this approach, the semantics of programming language constructs is given by axioms which prescribe how those constructs transform predicates on states; thus, this semantics also has a denotational aspect, in that programs denote functions from sets of states to sets of states.
Reference: [2] <author> Edsger Dijkstra. </author> <title> Guarded commands, nondeterminacy and formal derivation of programs. </title> <journal> Communications of the Association for Computing Machinery, </journal> <volume> 18 </volume> <pages> 453-457, </pages> <year> 1975. </year>
Reference-contexts: Another criticism of classical denotational semantics is that it can be very difficult to prove properties of programs in this framework. We will see that proofs in the ADS framework can be surprisingly easy. So-called weakest precondition semantics is a well-known variety of axiomatic semantics developed by Edsger Dijkstra <ref> [2, 3] </ref>. Standard textbooks using this approach have been written by David Gries [14] and Roland Backhouse [1].
Reference: [3] <author> Edsger Dijkstra. </author> <title> A Discipline of Programming. </title> <publisher> Prentice-Hall, </publisher> <year> 1976. </year>
Reference-contexts: Another criticism of classical denotational semantics is that it can be very difficult to prove properties of programs in this framework. We will see that proofs in the ADS framework can be surprisingly easy. So-called weakest precondition semantics is a well-known variety of axiomatic semantics developed by Edsger Dijkstra <ref> [2, 3] </ref>. Standard textbooks using this approach have been written by David Gries [14] and Roland Backhouse [1].
Reference: [4] <author> Erwin Engeler. </author> <title> Structure and meaning of elementary programs. </title> <editor> In Erwin Engeler, editor, </editor> <booktitle> Symposium on Semantics of Algorithmic Languages, </booktitle> <pages> pages 89-101. </pages> <publisher> Springer, </publisher> <year> 1971. </year> <booktitle> Lecture Notes in Mathematics, </booktitle> <volume> Volume 188. </volume>
Reference-contexts: difficulty with weakest preconditions is that the semantics of iteration is rather complicated: in fact, Dijkstra, Gries and others assume that first order logic is adequate, but it seems that infinitary logic (i.e., the logic of infinitely long sentences!) is needed for the weakest preconditions of general iterations (see Engeler <ref> [4] </ref>); alternatively, one might use second order logic, or abandon predicates in favour of sets defined by infinite least upper bounds. In contrast, first order equational logic is sufficient for ADS. Iteration also raises the issues of termination and well-defined values.
Reference: [5] <author> Robert Floyd. </author> <title> Assigning meanings to programs. </title> <editor> In Jacob Schwartz, editor, </editor> <booktitle> Proceedings, Symposia Applied Mathematics, </booktitle> <volume> volume 19, </volume> <pages> pages 19-32. </pages> <publisher> American Mathematical Society, </publisher> <year> 1967. </year>
Reference-contexts: An axiomatic approach using assertions and invariants was pioneered by Alan Turing [26] and John von Neumann [12], and later made more formal by Robert Floyd <ref> [5] </ref> and Tony Hoare [15]. By contrast, denotational approaches build mathematical models of programming language features; these models are called denotations. For example, the denotation of a program might be a partial function from inputs to outputs.
Reference: [6] <author> Joseph Goguen. </author> <title> Theorem Proving and Algebra. MIT, </title> <note> to appear 1996. </note>
Reference-contexts: We find that students manage very well to follow the gist of the example, which provides a 2 Although it is not discussed in the course, it is possible to mechanise this translation using OBJ itself; see <ref> [6] </ref>. 5 good opportunity to illustrate important concepts such as syntax, semantics, and loop invariants, which all play a key role later in the course. The example divides naturally into three parts. <p> This is not emphasised in our course, but it is discussed in <ref> [6] </ref>. 7 th STORE is pr NATOPS . pr QID *(sort Id to Var) . sort Store . op initial : -&gt; Store . op _ [[_]] : Store Var -&gt; Nat . op (_;_:_) : Store Var Nat -&gt; Store . vars X Y : Var . var S :
Reference: [7] <author> Joseph Goguen and Luqi. </author> <title> Formal methods and social context in software development. </title> <editor> In Peter Mosses, Mogens Nielsen, and Michael Schwartzbach, editors, </editor> <booktitle> Proceedings, Sixth International Joint Conference on Theory and Practice of Software Development, </booktitle> <pages> pages 62-81. </pages> <note> Springer-Verlag Lecture Notes in Computer Science 915, </note> <year> 1995. </year>
Reference-contexts: One must learn how to use tools like configuration managers and debuggers. For large programs, one must learn how to work in a team; and for really large projects, management and other social issues are often dominant <ref> [7] </ref>. One must learn discipline and organisation, and how to read and write documentation. One must keep learning new languages, tools, concepts, algorithms, and skills; sometimes one must even invent these things. <p> It is unhealthy to confuse a formal notation with a formal method. A method should say how to do something, whereas a notation allows one to say something <ref> [7] </ref>. Thus, OBJ is only a notation, but using it as described in our course and book gives a method for proving properties of imperative programs.
Reference: [8] <author> Joseph Goguen and Grant Malcolm. </author> <title> Proof of correctness of object representations. </title> <editor> In A. W. Roscoe, editor, </editor> <title> A Classical Mind: essays dedicated to C.A.R. Hoare, </title> <booktitle> chapter 8, </booktitle> <pages> pages 119-142. </pages> <publisher> Prentice-Hall, </publisher> <year> 1994. </year>
Reference-contexts: In recent years, many promising formal methods have arisen from algebraic approaches to semantics. We believe that algebraic approaches tend to be simpler and more tractable, in the sense that they lend themselves readily to formal reasoning, for example in proving the correctness of refinement or implementation <ref> [8, 19] </ref>, or, as in our course on algebraic semantics, in providing a simple yet rigorous foundation for proving correctness of imperative programs. In this section we sketch the main differences between our algebraic semantics, which might be called algebraic denotational semantics (ADS ), and other well established approaches.
Reference: [9] <author> Joseph Goguen and Grant Malcolm. </author> <title> Algebraic Semantics of Imperative Programs. MIT Press, </title> <note> to appear 1996. 15 </note>
Reference-contexts: Our experience teaching a course titled Algebraic Semantics of Imperative Programs suggests that this can significantly enhance learning. This course has developed over the last seven years, during which some form of it was taught once each year; this development has recently culminated in a textbook <ref> [9] </ref>. The course is taught to graduate students from a variety of academic backgrounds beginning their serious study of Computing Science through the "conversion" MSc in Computation programme at Oxford; it could equally well be taught to undergraduates as early as their second year. <p> The result is that ADS provides a simple semantics, unclouded by issues of correctness or termination of programs; and in addition, we are able to use equational logic for a separate, simple treatment of correctness and termination <ref> [9] </ref>. The use of order sorted algebra plays a key role in our treatment of non-terminating programs; see [9] for details. Another issue raised by various axiomatic approaches to the semantics of imperative programs, including weakest preconditions and Hoare et al.'s "Laws of Programming" [16], is non-determinism. <p> provides a simple semantics, unclouded by issues of correctness or termination of programs; and in addition, we are able to use equational logic for a separate, simple treatment of correctness and termination <ref> [9] </ref>. The use of order sorted algebra plays a key role in our treatment of non-terminating programs; see [9] for details. Another issue raised by various axiomatic approaches to the semantics of imperative programs, including weakest preconditions and Hoare et al.'s "Laws of Programming" [16], is non-determinism. <p> Moreover, both the semantics of the language and the correctness proof are executable. The course and the book that developed from it <ref> [9] </ref> give a more encompassing semantics for numbers, as well as for arrays and procedures, and of course, there are many more examples using these and other features.
Reference: [10] <author> Joseph Goguen, James Thatcher, and Eric Wagner. </author> <title> An initial algebra approach to the specifi-cation, correctness and implementation of abstract data types. </title> <type> Technical Report RC 6487, </type> <institution> IBM T.J. Watson Research Center, </institution> <month> October </month> <year> 1976. </year> <title> In Current Trends in Programming Methodology, IV, </title> <editor> Raymond Yeh, editor, </editor> <publisher> Prentice-Hall, </publisher> <year> 1978, </year> <pages> pages 80-149. </pages>
Reference-contexts: of abstract machines: anything that associates values with variables in the way described by the equations is acceptable as a model of this theory, whereas the previous modules, which begin and end with the keywords obj and endo, are intended to denote the `obvious' or `standard' (i.e., technically, the initial <ref> [10] </ref>) model; that is, they are intended to specify the data type of natural numbers.
Reference: [11] <author> Joseph Goguen, Timothy Winkler, Jose Meseguer, Kokichi Futatsugi, and Jean-Pierre Jouan-naud. Introducing OBJ. In Joseph Goguen and Grant Malcolm, </author> <title> editors, Case Studies in Algebraic Specification Using OBJ. </title> <institution> Cambridge University Press, </institution> <note> to appear 1996. Also available as a technical report from SRI International. </note>
Reference-contexts: In both cases, the course work is done on paper, since the semantics of programs and proofs of their properties are presented on paper. By contrast, our Algebraic Semantics of Imperative Programs course uses an executable presentation of program semantics in OBJ <ref> [11] </ref>, an implemented specification language that can be used for theorem proving and rapid prototyping, and which itself has a formal semantics based on equational logic. OBJ is not just another functional programming language, although it does have an executable functional sublanguage.
Reference: [12] <author> Herman Goldstine and John von Neumann. </author> <title> Planning and coding of problems for an electronic computing instrument. </title> <editor> In A. Traub, editor, </editor> <booktitle> Collection Works of J. von Neumann, </booktitle> <pages> pages 80-151. </pages> <publisher> Pergamon, </publisher> <year> 1949. </year> <title> Originally, a report of the U.S. </title> <institution> Ordinance Department. </institution>
Reference-contexts: First order logic, or some variant of it, is the most popular, since this is the logical system most widely used in mathematics and its foundations. An axiomatic approach using assertions and invariants was pioneered by Alan Turing [26] and John von Neumann <ref> [12] </ref>, and later made more formal by Robert Floyd [5] and Tony Hoare [15]. By contrast, denotational approaches build mathematical models of programming language features; these models are called denotations. For example, the denotation of a program might be a partial function from inputs to outputs.
Reference: [13] <author> Michael J.C. Gordon. </author> <title> The Denotational Description of Programming Languages. </title> <publisher> Springer, </publisher> <year> 1979. </year>
Reference-contexts: In this approach, the denotation of a program is constructed by composing the denotations of its parts. Denotational semantics was pioneered by John McCarthy [20], and greatly extended by Christopher Strachey and Dana Scott [24]. In classical denotational semantics (often called Scott-Strachey semantics, see <ref> [25, 13] </ref>), the model of storage can be criticised for being too concrete.
Reference: [14] <editor> David Gries. </editor> <booktitle> The Science of Programming. </booktitle> <publisher> Springer, </publisher> <year> 1981. </year>
Reference-contexts: We will see that proofs in the ADS framework can be surprisingly easy. So-called weakest precondition semantics is a well-known variety of axiomatic semantics developed by Edsger Dijkstra [2, 3]. Standard textbooks using this approach have been written by David Gries <ref> [14] </ref> and Roland Backhouse [1]. In this approach, the semantics of programming language constructs is given by axioms which prescribe how those constructs transform predicates on states; thus, this semantics also has a denotational aspect, in that programs denote functions from sets of states to sets of states. <p> In contrast, first order equational logic is sufficient for ADS. Iteration also raises the issues of termination and well-defined values. In Gries's <ref> [14] </ref> approach to weakest preconditions, a 3-valued logic is used to handle non-termination (VDM [17] also uses a 3-valued logic); however, ADS uses only ordinary 2-valued logic.
Reference: [15] <author> C.A.R. Hoare. </author> <title> An axiomatic basis for computer programming. </title> <journal> Communications of the Association for Computing Machinery, </journal> <volume> 12(10) </volume> <pages> 576-580, </pages> <month> October </month> <year> 1969. </year>
Reference-contexts: An axiomatic approach using assertions and invariants was pioneered by Alan Turing [26] and John von Neumann [12], and later made more formal by Robert Floyd [5] and Tony Hoare <ref> [15] </ref>. By contrast, denotational approaches build mathematical models of programming language features; these models are called denotations. For example, the denotation of a program might be a partial function from inputs to outputs. Usually set theory is used in constructing these denotations, perhaps with some technical constraints, such as continuity.
Reference: [16] <author> C.A.R. Hoare, J. Michael Spivey, Ian Hayes, Jifeng He, Carroll Morgan, A. William Roscoe, Jeffrey Saunders, Ib Sorenson, and Bernard Sufrin. </author> <title> Laws of programming. </title> <journal> Communications of the Association for Computing Machinery, </journal> <volume> 30(8) </volume> <pages> 672-686, </pages> <year> 1987. </year>
Reference-contexts: The use of order sorted algebra plays a key role in our treatment of non-terminating programs; see [9] for details. Another issue raised by various axiomatic approaches to the semantics of imperative programs, including weakest preconditions and Hoare et al.'s "Laws of Programming" <ref> [16] </ref>, is non-determinism. Although programming languages are necessarily deterministic, a "non-deterministic" algorithm can be viewed as an equivalence class of procedures, where each procedure is a refinement, or possible implementation, of the algorithm; this is what we call loose semantics. <p> Alternatively, non-determinism can be seen as a property of specifications in a specification language with a formal notion of one specification being more deterministic than another, as in <ref> [16] </ref>. For simplicity, we avoid both these senses of non-determinism and give a deterministic treatment of deterministic languages. However, ADS can be enriched with additional operations to support a loose semantics for non-determinism, as shown in [18].
Reference: [17] <author> Cliff B. Jones. </author> <title> Systematic Software Development using VDM. </title> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference-contexts: In contrast, first order equational logic is sufficient for ADS. Iteration also raises the issues of termination and well-defined values. In Gries's [14] approach to weakest preconditions, a 3-valued logic is used to handle non-termination (VDM <ref> [17] </ref> also uses a 3-valued logic); however, ADS uses only ordinary 2-valued logic. We believe that ADS gives a simpler treatment of iteration because it distinguishes between the semantics of programs and other properties of programs, such as termination and correctness.
Reference: [18] <author> Grant Malcolm and Joseph Goguen. </author> <title> Algebraic semantics of nondeterministic choice. </title> <type> Technical Report PRG-TR-5-95, </type> <institution> Programming Research Group, Oxford University, </institution> <year> 1995. </year>
Reference-contexts: For simplicity, we avoid both these senses of non-determinism and give a deterministic treatment of deterministic languages. However, ADS can be enriched with additional operations to support a loose semantics for non-determinism, as shown in <ref> [18] </ref>. The main motivations for non-deterministic specification are that it allows postponing design decisions, and that it leads to simple proofs of program correctness. There are even claims that, with the right semantics, algorithm development becomes an easy, near-mechanical process of looking for simple proofs.
Reference: [19] <author> Grant Malcolm and Joseph Goguen. </author> <title> Proving correctness of refinement and implementation. </title> <type> Technical Monograph PRG-114, </type> <institution> Programming Research Group, Oxford University, </institution> <year> 1994. </year>
Reference-contexts: In recent years, many promising formal methods have arisen from algebraic approaches to semantics. We believe that algebraic approaches tend to be simpler and more tractable, in the sense that they lend themselves readily to formal reasoning, for example in proving the correctness of refinement or implementation <ref> [8, 19] </ref>, or, as in our course on algebraic semantics, in providing a simple yet rigorous foundation for proving correctness of imperative programs. In this section we sketch the main differences between our algebraic semantics, which might be called algebraic denotational semantics (ADS ), and other well established approaches.
Reference: [20] <author> John McCarthy. </author> <title> Towards a mathematical science of computation. </title> <booktitle> In Information Processing '62, </booktitle> <pages> pages 21-28. </pages> <publisher> North-Holland, </publisher> <year> 1962. </year> <booktitle> Proceedings of 1962 IFIP Congress. </booktitle>
Reference-contexts: Usually set theory is used in constructing these denotations, perhaps with some technical constraints, such as continuity. In this approach, the denotation of a program is constructed by composing the denotations of its parts. Denotational semantics was pioneered by John McCarthy <ref> [20] </ref>, and greatly extended by Christopher Strachey and Dana Scott [24]. In classical denotational semantics (often called Scott-Strachey semantics, see [25, 13]), the model of storage can be criticised for being too concrete.
Reference: [21] <author> Jose Meseguer. </author> <title> Conditional rewriting logic: Deduction, models and concurrency. </title> <editor> In Stephane Kaplan and Misuhiro Okada, editors, </editor> <booktitle> Conditional and Typed Rewriting Systems, </booktitle> <pages> pages 64-91. </pages> <publisher> Springer, </publisher> <year> 1991. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 516. </volume>
Reference-contexts: Our approach to properties of programs is traditional, in that we use first order logic for preconditions, postconditions, and invariants. This raises the issue of how to handle first order sentences 1 Meseguer's so-called "logical semantics" for the -calculus <ref> [21] </ref> is abstract in a similar way. 4 in the context of an algebraic semantics. Our approach is to use standard rules of deduction to translate first order sentences into sequences of declarations and reductions 2 . Predicates are represented as Bool-valued operations.
Reference: [22] <author> Gordon Plotkin. </author> <title> A structural approach to operational semantics. </title> <type> Technical Report DAIMI FN-19, </type> <institution> Computer Science Department, Aarhus University, </institution> <month> September </month> <year> 1981. </year>
Reference-contexts: An operational semantics describes the meaning of a programming language by describing a way of executing its programs. Often this is done by giving an interpreter or compiler for the language. So-called structured operational semantics (also called natural semantics) <ref> [22] </ref> describes computations by giving formal rules of deduction for steps of computation; this may be considered an abstract interpreter. In axiomatic approaches, programming language features are defined by writing axioms in some logical system.
Reference: [23] <author> John C. Reynolds. </author> <title> The Craft of Programming Languages. </title> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: Furthermore, each kind of variable may have many different types. In general, textbooks on program semantics have not been very rigorous about all this. An exemplary exception is the book by John Reynolds <ref> [23] </ref>. However, such rigour is necessary for our use of OBJ as a meta-language, and also for any discussion of the semantics of procedures with parameters.
Reference: [24] <author> Dana Scott and Christopher Strachey. </author> <title> Towards a mathematical semantics for computer languages. </title> <booktitle> In Proceedings, 21st Symposium on Computers and Automata, </booktitle> <pages> pages 19-46. </pages> <institution> Polytechnic Institute of Brooklyn, </institution> <year> 1971. </year> <note> Also Programming Research Group Technical Monograph PRG-6, </note> <institution> Oxford University. </institution>
Reference-contexts: In this approach, the denotation of a program is constructed by composing the denotations of its parts. Denotational semantics was pioneered by John McCarthy [20], and greatly extended by Christopher Strachey and Dana Scott <ref> [24] </ref>. In classical denotational semantics (often called Scott-Strachey semantics, see [25, 13]), the model of storage can be criticised for being too concrete.
Reference: [25] <author> Joseph Stoy. </author> <title> Denotational Semantics of Programming Languages: The Scott-Strachey Approach to Programming Language Theory. </title> <publisher> MIT, </publisher> <year> 1977. </year> <month> 16 </month>
Reference-contexts: In this approach, the denotation of a program is constructed by composing the denotations of its parts. Denotational semantics was pioneered by John McCarthy [20], and greatly extended by Christopher Strachey and Dana Scott [24]. In classical denotational semantics (often called Scott-Strachey semantics, see <ref> [25, 13] </ref>), the model of storage can be criticised for being too concrete.
Reference: [26] <author> Alan M. </author> <title> Turing. Checking a large routine. In Report of a Conference on High Speed Automatic Calculating Machines, </title> <type> pages 67-69. </type> <institution> University Mathematics Lab, Cambridge University, </institution> <year> 1949. </year> <month> 17 </month>
Reference-contexts: First order logic, or some variant of it, is the most popular, since this is the logical system most widely used in mathematics and its foundations. An axiomatic approach using assertions and invariants was pioneered by Alan Turing <ref> [26] </ref> and John von Neumann [12], and later made more formal by Robert Floyd [5] and Tony Hoare [15]. By contrast, denotational approaches build mathematical models of programming language features; these models are called denotations.
References-found: 26

