URL: ftp://ftp.cs.umd.edu/pub/papers/papers/3687/3687.ps.Z
Refering-URL: http://www.cs.umd.edu/TRs/TR.html
Root-URL: 
Email: fbultan,rich,pughg@cs.umd.edu  
Phone: (301) 405-2710  
Title: Symbolic Model Checking of Infinite State Programs Using Presburger Arithmetic  
Author: Tevfik Bultan, Richard Gerber and William Pugh 
Keyword: Static analysis, symbolic model checking, transition systems, Presburger arithmetic.  
Address: College Park College Park, MD 20742  
Affiliation: Institute for Advanced Computer Studies Department of Computer Science University of Maryland,  
Abstract: Model checking is a powerful technique for analyzing large, finite-state systems. In an infinite transition system, however, many basic properties are undecidable. In this paper we present a new symbolic model checker which conservatively evaluates safety and liveness properties on infinite-state programs. We use Presburger formulas to symbolically encode a program's transition system, as well as its model-checking computations. All fix-point calculations are executed symbolically, and their convergence is guaranteed by using approximation techniques. We demonstrate the promise of this technology on some well-known infinite-state concurrency problems. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Alur, T. A. Henzinger, and P. Ho. </author> <title> Automatic Symbolic Verification of Embedded Systems. </title> <journal> IEEE Transactions on Software Engineering 22(3), </journal> <month> March </month> <year> 1996. </year>
Reference-contexts: Most properties of programs can be formulated as least fixpoints over sets of the program's states, and conservative abstract interpretation provides a way of approximating these fixpoints. Our encoding of program states is similar to that used by Alur et al. in verifying Hybrid systems <ref> [1] </ref>. The fundamental difference is that we encode sets of integers (as opposed to the real numbers used in hybrid systems), and we can thus use Presburger formulas as our symbolic representation. This enables us to state properties such as, x is even, x y + z + 10, etc.
Reference: [2] <author> Gregory R. Andrews, </author> <title> Concurrent Programming, </title> <booktitle> Principles and Practice. 1991, </booktitle> <publisher> The Benjamin/Cummings Publishing Company. </publisher>
Reference-contexts: But perhaps more importantly, one may wish to analyze an algorithm as an abstraction, and prove its correctness in a general sense, for any implementation of integers. In this paper we demonstrate our model checker's effectiveness on some "classical" infinite-state programs, taken from a standard concurrency textbook <ref> [2] </ref>. While relatively small, they possess some interesting subtleties, especially in the tricky way their infinite-state variables influence control flow. Other methods have been proposed to deal with infinite-state programs like these, and we note some of them here. <p> Each event is represented with an enabling condition and an action, where the enabling condition constrains the states in which the event can occur, and the action defines a transformation on the states. Consider the concurrent program shown in Figure 1, which implements the bakery algorithm <ref> [2] </ref> to achieve Data Variables: a; b: integer Control Variables: pc 1 : fT 1 ; W 1 ; C 1 g, pc 2 : fT 2 ; W 2 ; C 2 g Initial Condition: a = b = 0 Events: e T 1 enabled: pc 1 = T 1 <p> Ticket Algorithm. Our exact analyzer diverged when we fed it the so-called ticket algorithm <ref> [2] </ref>, along with its related mutual exclusion property. The program text is presented in Figure 5. In particular, note its similarity to the Bakery example. Both algorithms use a few shared variables to maintain mutual exclusion, and they ensure progress in a similar way.
Reference: [3] <author> Andre Arnold, </author> <title> Finite Transition Systems: Semantics of Communicating Systems, </title> <address> New Jersey, 1994, </address> <publisher> Prentice Hall. </publisher>
Reference-contexts: Unlike Clarke et al [5], we do not require the transition relation X to be total. Rather, our semantics is defined using maximal paths <ref> [3] </ref> (as opposed to infinite paths). A maximal path is one which is either infinite, or it ends with a state that has no successors. Consider the two properties of the bakery algorithm we discussed at the beginning of this section.
Reference: [4] <author> J. R. Burch, E. M. Clarke, K. L. McMillan, D. L. Dill, and L. H. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <booktitle> In Proceedings of the 5th Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 428-439, </pages> <year> 1990. </year>
Reference-contexts: INTRODUCTION In recent years CTL model checking [5] has emerged as a successful method for verifying large finite-state systems <ref> [4, 18] </ref>. Two main reasons behind this success are: (1) many of the properties one wants to check are representable in CTL; and (2) there are efficient procedures to check them. But when transition systems are not restricted to be finite, CTL model checking becomes undecidable. <p> Of course, in any computer system variables are eventually mapped to finite representations. Thus it might be argued that integers can be given a finite range, and programs can then be analyzed as finite-state machines for example, using BDD's <ref> [4, 14] </ref>. For two reasons, however, this may not always be the best way to proceed. First, mapping integer variables and operations to their binary implementations may lead to highly inefficient static analysis.
Reference: [5] <author> E. M. Clarke, E. A. Emerson, and A. P. Sistla. </author> <title> Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> (April </month> <year> 1986). </year>
Reference-contexts: INTRODUCTION In recent years CTL model checking <ref> [5] </ref> has emerged as a successful method for verifying large finite-state systems [4, 18]. Two main reasons behind this success are: (1) many of the properties one wants to check are representable in CTL; and (2) there are efficient procedures to check them. <p> Unlike Clarke et al <ref> [5] </ref>, we do not require the transition relation X to be total. Rather, our semantics is defined using maximal paths [3] (as opposed to infinite paths). A maximal path is one which is either infinite, or it ends with a state that has no successors.
Reference: [6] <author> E. M. Clarke, O. Grumberg, D. E. </author> <title> Long Model checking and abstraction. </title> <booktitle> In Proceedings of the 18th Annual Symposium on Principles of Programming Languages, </booktitle> <pages> pages 343-354, </pages> <year> 1992. </year>
Reference-contexts: Other methods have been proposed to deal with infinite-state programs like these, and we note some of them here. One is to come up with a finite abstraction of the program, and then check the property on the abstraction <ref> [6] </ref>. Of course this requires the user to find the abstraction, and hence is not completely automatable. Another approach is to use a technique like symbolic execution [10, 11], which symbolically generates a program's execution paths.
Reference: [7] <author> D. C. Cooper. </author> <title> Programs for mechanical program verification. </title> <booktitle> In Machine Intelligence 6, </booktitle> <editor> B. Meltzer and D. Michie, editors, </editor> <address> pages 43-59, New York, 1971, </address> <publisher> American Elsevier. </publisher>
Reference-contexts: Our work has some strong historical antecedents. For example, Cooper developed a technique which encodes transition relations as sets of Presburger formulas, and then converts queries about a program's properties to validity checks in the Presburger arithmetic <ref> [7] </ref>. Due to the complexity of general Presburger solvers, how 1 2 ever, proving correctness as single Presburger decision problem is not a method that can scale very well.
Reference: [8] <author> P. Cousot and R. Cousot. </author> <title> Static determination of dynamic properties of programs. </title> <booktitle> In Proceedings of Col-loque International sur la programmation, </booktitle> <month> April </month> <year> 1976. </year>
Reference-contexts: We have found it more beneficial to use model checking as our primary technology, and use a Presburger solver for some subservient set-theoretic computations. Our work was also influenced by known techniques from abstract interpretation <ref> [8] </ref>; specifically, we use some approximation methods first developed for that domain. Most properties of programs can be formulated as least fixpoints over sets of the program's states, and conservative abstract interpretation provides a way of approximating these fixpoints. <p> To generate the ^ Q i 's, we adopt a method developed by Cousot and Cousot, within the framework of abstract interpretation <ref> [8] </ref>. That is, we define an operator called widening, or "5", which majorizes the union computation as follows: For any pair of sets P; P 0 , P [ P 0 P 5 P 0 .
Reference: [9] <author> P. Cousot and N. Halbwachs. </author> <title> Automatic discovery of linear restraints among variables of a program. </title> <booktitle> In Proceedings of the 5th Annual Symposium on Principles of Programming Languages, 1978, </booktitle> <publisher> ACM Press. </publisher>
Reference-contexts: Our goal is to find a widening operator which (1) yields a suitable (i.e., reasonably tight) upper bound for union, and (2) forces the ^ Q i sequence to converge. To do this, we generalize the application of widening used by Cousot and Halbwachs in <ref> [9] </ref>, where the idea is to "guess" the direction of growth in the checker's Q i iterates, and to extend the successive iterates in these directions. <p> However, a program's state space is not always convex; in fact, most (exact) fixpoint computations are composed of a (potentially large) number of disjuncts, each defining a convex polytope. To accommodate this we generalize the widening definition in <ref> [9] </ref> to handle multiple polyhedra. Assume that we have two Presburger sets Q and R, where Q R.
Reference: [10] <author> L. K. </author> <title> Dillon. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(4) </volume> <pages> 643-669, </pages> <month> (October </month> <year> 1990). </year>
Reference-contexts: One is to come up with a finite abstraction of the program, and then check the property on the abstraction [6]. Of course this requires the user to find the abstraction, and hence is not completely automatable. Another approach is to use a technique like symbolic execution <ref> [10, 11] </ref>, which symbolically generates a program's execution paths. In practice, this method may end up generating an infinite number of nodes, and thus never terminate. This limitation can be overcome by having the user specify assertions about a process's behavior, which can be verified locally. <p> In practice, this method may end up generating an infinite number of nodes, and thus never terminate. This limitation can be overcome by having the user specify assertions about a process's behavior, which can be verified locally. Then the local proofs can be checked for cooperation <ref> [10] </ref>. Although the method has the benefit of incrementally proving correctness (as opposed to generating all possible in-terleavings), it relies on users to come up with the right assertions. Our work has some strong historical antecedents.
Reference: [11] <author> S. L. Hantler and J. C. King. </author> <title> An Introduction to proving the correctness of programs. </title> <journal> ACM Computing Surveys 8(3) </journal> <pages> 331-353, </pages> <month> (September </month> <year> 1976). </year>
Reference-contexts: One is to come up with a finite abstraction of the program, and then check the property on the abstraction [6]. Of course this requires the user to find the abstraction, and hence is not completely automatable. Another approach is to use a technique like symbolic execution <ref> [10, 11] </ref>, which symbolically generates a program's execution paths. In practice, this method may end up generating an infinite number of nodes, and thus never terminate. This limitation can be overcome by having the user specify assertions about a process's behavior, which can be verified locally.
Reference: [12] <author> W. Kelly, V. Maslov, W. Pugh, E. Rosser, T. Shpeisman and D. Wonnacott. </author> <title> The Omega Library (version 1.00) Interface Guide. </title> <note> Available at &lt;http://www.cs.umd.edu/projects/omega&gt;. </note>
Reference-contexts: From elementary set theory, we then get the following interpretations: f ^ g = f " g f _ g = f [ g :f = S f To carry these operations out symbolically, we use a toolset called the Omega library <ref> [12] </ref>, which includes a large collection of object classes to manipulate Pres-burger formulas. Of particular use to us are the functions shown in Table 2, which are all implemented as Omega functions. <p> Our method is based on three key concepts: 11 * Symbolically encoding transition relations and state sets in Presburger formulas, which we can ef ficiently manipulate using the Omega library <ref> [12] </ref>. * Partitioning a program's state-space via the control variables, and using the partition classes as repositories for the model checker's formula-labeling com putations. * Approximating fixpoint computations with tech niques that guarantee convergence in finite time.
Reference: [13] <author> D. </author> <title> Kozen Results on the propositional -Calculus, </title> <booktitle> Theoretical Computer Science 27 </booktitle> <pages> 333-354, </pages> <year> (1983). </year>
Reference-contexts: As for 93 and 83, consider the functionals t EF = y: f _ 9 fl y and t AF = y: f _ (8 fl y ^ 9 fl y). The least fixpoints of t EF and t AF are equal to 93f and 83f , respectively <ref> [13] </ref>.
Reference: [14] <author> K. L. McMillan. </author> <title> Symbolic Model Checking: An Approach to the State Explosion Problem. </title> <type> PhD Thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1992. </year> <month> CMU-CS-92-131. </month>
Reference-contexts: Of course, in any computer system variables are eventually mapped to finite representations. Thus it might be argued that integers can be given a finite range, and programs can then be analyzed as finite-state machines for example, using BDD's <ref> [4, 14] </ref>. For two reasons, however, this may not always be the best way to proceed. First, mapping integer variables and operations to their binary implementations may lead to highly inefficient static analysis. <p> Since t EF and t AF are both monotonic, and since we start the sequence with ;, these sequences are non-decreasing. So we can keep iterating until we reach a fixpoint, and when we do, we know that it is the least fixpoint <ref> [14] </ref>. These methods lead directly to the semi-decision procedure shown in Figure 4. Given a program and a tempo ral logic formula, the procedure will (attempt to) symbolically compute the set of program states that satisfy the input formula.
Reference: [15] <author> D. C. Oppen. </author> <title> A 2 2 2 pn Upper Bound on the Complexity of Presburger Arithmetic. </title> <journal> Journal of Computer and System Sciences 16 </journal> <pages> 323-332, </pages> <year> (1978). </year>
Reference-contexts: The set of closed formulas defined by the above grammar forms the theory of integers with addition, called Presburger arithmetic. An important property of Presburger arithmetic is that validity is decidable, i.e., given a closed formula, there are decision procedures which can decide if it is true or false <ref> [15, 16] </ref>. For a given program, its class of state formulas, SF , is the set of Presburger formulas in which all open variables are the variables of the program. In other words, these are exactly the formulas that have an interpreta tion via the program's valuation function, L.
Reference: [16] <author> W. Pugh. </author> <title> The Omega test: a fast and practical integer programming algorithm for dependence analysis. </title> <journal> Com munications of the ACM, </journal> <volume> 8 </volume> <pages> 102-104, </pages> <month> (August </month> <year> 1992). </year>
Reference-contexts: The set of closed formulas defined by the above grammar forms the theory of integers with addition, called Presburger arithmetic. An important property of Presburger arithmetic is that validity is decidable, i.e., given a closed formula, there are decision procedures which can decide if it is true or false <ref> [15, 16] </ref>. For a given program, its class of state formulas, SF , is the set of Presburger formulas in which all open variables are the variables of the program. In other words, these are exactly the formulas that have an interpreta tion via the program's valuation function, L.
Reference: [17] <author> A. Udaya Shankar. </author> <title> An Introduction to Assertional Reasoning for Concurrent Systems. </title> <journal> ACM Computing Sur veys, </journal> <volume> 25(3) </volume> <pages> 225-262, </pages> <month> (September </month> <year> 1993). </year>
Reference-contexts: Finally, we conclude with some discussion on our results. PROGRAMS AND PROPERTIES In this section we define our models for representing programs and properties. We use the event-action language from <ref> [17] </ref> as our syntax for concurrent programs, with a semantics defined in terms of infinite transition systems. For representing temporal properties, we use a variant of CTL, in which the ground propositions are encoded as Presburger formulas.
Reference: [18] <author> J. M. Wing and M. Vaziri-Farahani. </author> <title> Model Checking Software Systems: </title> <booktitle> A Case Study In Proceedings of the Third ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 128-138, </pages> <month> (October </month> <year> 1995). </year>
Reference-contexts: INTRODUCTION In recent years CTL model checking [5] has emerged as a successful method for verifying large finite-state systems <ref> [4, 18] </ref>. Two main reasons behind this success are: (1) many of the properties one wants to check are representable in CTL; and (2) there are efficient procedures to check them. But when transition systems are not restricted to be finite, CTL model checking becomes undecidable.
References-found: 18

