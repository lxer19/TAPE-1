URL: http://www.cs.cornell.edu/Info/People/ergun/spot.ps
Refering-URL: http://www.cs.cornell.edu/Info/People/ergun/research.html
Root-URL: 
Email: Email: ravi@almaden.ibm.com.  
Title: Spot-Checkers  
Author: Funda Ergun Sampath Kannan S Ravi Kumar Ronitt Rubinfeld Mahesh Viswanathan ffergun@saul, kannan@central, maheshv@ 
Address: Philadelphia, PA 19104.  San Jose, CA 95120.  
Affiliation: gradientg.cis.upenn.edu. Department of Computer and Information Science, University of Pennsylvania,  Almaden Research Center,  
Note: Email:  IBM  
Abstract: On Labor Day Weekend, the highway patrol sets up spot-checks at random points on the freeways with the intention of deterring a large fraction of motorists from driving incorrectly. We explore a very similar idea in the context of program checking to ascertain with minimal overhead that a program output is reasonably correct. Our model of spot-checking requires that the spot-checker must run asymptotically much faster than the combined length of the input and output. We then show that the spot-checking model can be applied to problems in a wide range of areas, including problems regarding graphs, sets, and algebra. In particular, we present spot-checkers for sorting, element distinctness, set containment, set equality, total orders, and correctness of group operations. All of our spot-checkers are very simple to state and rely on testing that the input and/or output have certain simple properties that depend on very few bits. Our sorting spot-checker runs in O(log n) time to check the correctness of the output produced by a sorting algorithm on an input consisting of n numbers. We also show that there is an O(1) spot-checker to check a program that determines whether a given relation is close to a total order. We present a technique for testing in almost linear time whether a given operation is close to an associative cancellative operation. fl This work was supported by ONR N00014-97-1-0505, MURI. The second author is also supported by NSF Grant CCR96-19910. The third author is also supported by DARPA/AF F30602-95-1-0047. The fourth author is also supported by the NSF Career grant CCR-9624552 and Alfred P. Sloan Research Award. The fifth author is also supported by ARO DAAH04-95-1-0092. x Email: ronitt@cs.cornell.edu. Department of Computer Science, Cornell University, Ithaca, NY 14853. In this extended abstract we show the checker under the assumption that the input operation is cancellative and leave the general case for the full version of the paper. In contrast, [RaS96] show that quadratic time is necessary and sufficient to test that a given cancellative operation is associative. This method yields a very efficient tester (over small domains) for all functions satisfying associative functional equations [Acz66]. We also extend this result to test in almost linear time whether the given operation is close to a group operation. 
Abstract-found: 1
Intro-found: 1
Reference: [Acz66] <author> J. Aczel. </author> <title> Lectures on Functional Equations and their Applications. </title> <publisher> Academic Press, </publisher> <year> 1966. </year>
Reference-contexts: Though our test yields a weaker conclusion, we also give a self-corrector for the operation ffi 0 , i.e., a method of computing ffi 0 correctly for all inputs in constant time. This method yields a reasonably efficient tester (over small domains) for all functions satisfying associative functional equations <ref> [Acz66] </ref>. RELATIONSHIP TO PROPERTY TESTING. A number of interesting result checkers for various problems have been developed (cf., [BK89, BLR93, EKS97, KS96, AHK95, Kan90, BEG + 91, ABC + 93]). <p> that our results apply to are those satisfying the the associativity equation F [F [x; y]; z] = F [x; F [y; z]], which characterize functions of the form F [x; y] = f (f 1 (x) + f 1 (y)) where f is a continuous and strictly monotone function <ref> [Acz66] </ref>. 4.3 Discarding the Cancellativity Assumption In this section we sketch additional tests required when ffi is not known to be cancellative. The general intuition is that even if the table for ffi is not cancellative, it should still contain a reasonably even distribution of the elements of G.
Reference: [AHK95] <author> L. M. Adleman, M-D. Huang, and K. Kompella. </author> <title> Efficient checkers for number-theoretic computations. Information and Computation, </title> <address> 121(1):93102, </address> <year> 1995 </year>
Reference: [ABC + 93] <author> S. Ar, M. Blum, B. Codenotti, and P. </author> <title> Gem mell. Checking approximate computations over the re-als. </title> <booktitle> Proc. 25th Symposium on Theory of Computing, </booktitle> <pages> pp. 786795, </pages> <year> 1993. </year>
Reference: [ALM + 92] <author> S. Arora, C. Lund, R. Motwani, M. Sudan, and M. Szegedy. </author> <title> Proof verification and hardness of approximation problems. </title> <booktitle> Proc. 33rd Foundations of Computer Science, </booktitle> <pages> pp. 1423, </pages> <year> 1992. </year>
Reference: [AS92] <author> S. Arora and S. Safra. </author> <title> Probabilistic checking of proofs: A new characterization of NP. </title> <booktitle> Proc. 33rd Foundations of Computer Science, </booktitle> <pages> pp. 213, </pages> <year> 1992. </year>
Reference: [BGR96] <author> M. Bellare, J. Garay, T. Rabin. </author> <title> Batch veri fication with applications to cryptography and checking. </title> <booktitle> Proc. Latin American Theoretical Informatics 98, </booktitle> <publisher> Springer LNCS 1830:267288, </publisher> <year> 1998. </year> <title> By the same authors Fast Batch Verification for modular exponentiation and digital signatures. </title> <booktitle> Proceedings of Eurocrypt 98, </booktitle> <publisher> Springer-Verlag LNCS, </publisher> <editor> Editor K. Nyberg, </editor> <year> 1998, </year> <note> to appear. </note>
Reference-contexts: Though efficient, these methods often add small multiplicative factors to the runtime of the programs. Efforts to minimize the overhead due to program checking have been somewhat successful <ref> [BW94, Rub94, BGR96] </ref> for linear functions.
Reference: [BEG + 91] <author> M. Blum, W. Evans, P. Gemmell, S. Kannan, and M. Naor. </author> <title> Checking the correctness of memories. </title> <booktitle> Proc. 32nd Foundations of Computer Science, </booktitle> <pages> pp. 90 99, </pages> <year> 1991. </year>
Reference: [BK89] <author> M. Blum and S. Kannan. </author> <title> Designing programs that check their work. </title> <booktitle> Proc. 21st Symposium on Theory of Computing, </booktitle> <pages> pp. 8697, </pages> <year> 1989. </year>
Reference-contexts: 1 Introduction Ensuring the correctness of computer programs is an important yet difficult task. Program result checking <ref> [BK89] </ref> and self-testing/correcting programs [BLR93, Lip91] make run-time checks to certify that the program is giving the right answer. Though efficient, these methods often add small multiplicative factors to the runtime of the programs.
Reference: [BLR93] <author> M. Blum, M. Luby, and R. Rubinfeld. </author> <title> Self testing/correcting with applications to numerical problems. </title> <journal> J. of Computing and System Sciences, </journal> <volume> 47(3):549 595, </volume> <year> 1993. </year>
Reference-contexts: 1 Introduction Ensuring the correctness of computer programs is an important yet difficult task. Program result checking [BK89] and self-testing/correcting programs <ref> [BLR93, Lip91] </ref> make run-time checks to certify that the program is giving the right answer. Though efficient, these methods often add small multiplicative factors to the runtime of the programs. Efforts to minimize the overhead due to program checking have been somewhat successful [BW94, Rub94, BGR96] for linear functions. <p> In other words, each a 2 G has an inverse and (iii) follows. EQUALITY. Finally, we have to check if ffi 0 is the same as , the specific group operation (equality testing, <ref> [BLR93, Rub94] </ref>). To do this in jGj lg jGj steps, check 8b 2 G; g 2 S G if g ffi 0 b = g b, where the latter is given.
Reference: [BW94] <author> M. Blum and H. Wasserman. </author> <title> Program result checking: A theory of testing meets a test of theory. </title> <booktitle> Proc. 35th Foundations of Computer Science, </booktitle> <pages> pp. 382 392, </pages> <year> 1994. </year>
Reference-contexts: Though efficient, these methods often add small multiplicative factors to the runtime of the programs. Efforts to minimize the overhead due to program checking have been somewhat successful <ref> [BW94, Rub94, BGR96] </ref> for linear functions.
Reference: [BW94] <author> M. Blum and H. Wasserman. </author> <title> Reflections on the Pentium division bug. </title> <booktitle> Proc. 8th Intl. Software Quality Week, </booktitle> <year> 1994. </year>
Reference-contexts: Though efficient, these methods often add small multiplicative factors to the runtime of the programs. Efforts to minimize the overhead due to program checking have been somewhat successful <ref> [BW94, Rub94, BGR96] </ref> for linear functions.
Reference: [CR92] <author> E. </author> <title> Castillo and M.R. </title> <booktitle> Ruiz-Cobo. Functional Equa tions and Modeling in Science and Engineering. </booktitle> <publisher> Marcel Dekker Inc., </publisher> <year> 1992. </year>
Reference: [EKR96] <author> F. Ergun, S. Ravi Kumar, and R. Rubinfeld. </author> <title> Ap proximate checking of polynomials and functional equations. </title> <booktitle> Proc. 37th Foundations of Computer Science, </booktitle> <pages> pp. 592601, </pages> <year> 1996. </year>
Reference: [EKS97] <author> F. Erg un, S. Ravi Kumar, and D. Sivakumar. </author> <title> Self testing without the generator bottleneck. </title> <journal> sicomp, </journal> <note> to appear. </note>
Reference: [GLR + 91] <author> P. Gemmell, R. Lipton, R. Rubinfeld, M. Sudan, and A. Wigderson. </author> <title> Self-testing/correcting for polynomials and for approximate functions. </title> <booktitle> Proc. 23rd Symposium on Theory of Computing, </booktitle> <pages> pp. 3242, </pages> <year> 1991. </year>
Reference: [GGR96] <author> O. Goldreich, S. Goldwasser, and D. Ron. </author> <title> Prop erty testing and its connection to learning and approximation. </title> <booktitle> Proc. 37th Foundations of Computer Science, </booktitle> <pages> pp. 339348, </pages> <year> 1996. </year>
Reference-contexts: For example, efficient property tests that ensure that the program is computing a linear function have been used to construct checkers. In <ref> [GGR96] </ref>, the idea of using property testing directly on the input is first proposed. This idea extended the scope of property testing beyond numeric properties. In [GGR96, GR97], property testing is applied to graph problems such as bipar-titeness and clique number. <p> For example, efficient property tests that ensure that the program is computing a linear function have been used to construct checkers. In [GGR96], the idea of using property testing directly on the input is first proposed. This idea extended the scope of property testing beyond numeric properties. In <ref> [GGR96, GR97] </ref>, property testing is applied to graph problems such as bipar-titeness and clique number. The ideas in this paper are inspired by their work. <p> The ideas in this paper are inspired by their work. For the purposes of this exposition, we give a simplified definition of property testing that captures the common features of the definitions given by <ref> [RS96, Rub94, GGR96] </ref>. Given a domain H and a distribution D over H , a function f is *-close to a function g over D if Pr x2D [f (x) 6= g (x)] *. <p> All previous property testers used a Hamming-like distance func 1 The notation ~ O (n) suppresses polylogarithmic factors of n. 2 In fact, the definition of property testing given by <ref> [GGR96] </ref> is much more general. For example, it allows one to separately consider two different models of the tester's access to f. The first case is when the tester may make queries to f on any input. <p> Our general definition of a distance function allows us to construct spot-checkers for set and list problems such as sorting and element distinctness, where the Hamming distance is not useful. In fact, with a proper distance function, all property testers in <ref> [GGR96] </ref> can be transformed into spot-checkers. One must, however, be careful in choosing the distance function. For instance, consider a program which decides whether an input graph is bipartite or not.
Reference: [GR97] <author> O. Goldreich and D. Ron. </author> <title> Property testing in bounded degree graphs. </title> <booktitle> Proc. 29th Symposium on Theory of Computing, </booktitle> <pages> pp. 406415, </pages> <year> 1997. </year>
Reference-contexts: For example, efficient property tests that ensure that the program is computing a linear function have been used to construct checkers. In [GGR96], the idea of using property testing directly on the input is first proposed. This idea extended the scope of property testing beyond numeric properties. In <ref> [GGR96, GR97] </ref>, property testing is applied to graph problems such as bipar-titeness and clique number. The ideas in this paper are inspired by their work.
Reference: [Kan90] <author> S. Kannan. </author> <title> Program Result Checking with Appli cations. </title> <type> PhD thesis, </type> <institution> U. of California at Berkeley, </institution> <year> 1990. </year>
Reference: [KR98] <author> S. Ravi Kumar and R. Rubinfeld. </author> <title> Testing Abelian Group Operations. </title> <type> Manuscript. </type>
Reference-contexts: The general intuition is that even if the table for ffi is not cancellative, it should still contain a reasonably even distribution of the elements of G. To ensure that, we require the conditions below, which are similar to those given in <ref> [KR98] </ref>, for a small enough * 0 . Note that since * 0 will not be part of the error, we need to change the parameters in the previous tests to accommodate errors due to * 0 in addition to those due to *.
Reference: [KS96] <author> S. Ravi Kumar and D. Sivakumar. </author> <title> Efficient self testing/self-correction of linear recurrences. </title> <booktitle> Proc. 37th Foundations of Computer Science, </booktitle> <pages> pp. 602611, </pages> <year> 1996. </year>
Reference: [Lip91] <author> R. Lipton. </author> <title> New directions in testing. </title> <booktitle> Proc. DI MACS Workshop on Distr. Comp. and Cryptography, </booktitle> <pages> pp. </pages> <address> 191202, </address> <year> 1991. </year>
Reference-contexts: 1 Introduction Ensuring the correctness of computer programs is an important yet difficult task. Program result checking [BK89] and self-testing/correcting programs <ref> [BLR93, Lip91] </ref> make run-time checks to certify that the program is giving the right answer. Though efficient, these methods often add small multiplicative factors to the runtime of the programs. Efforts to minimize the overhead due to program checking have been somewhat successful [BW94, Rub94, BGR96] for linear functions.
Reference: [Rub94] <author> R. Rubinfeld. </author> <title> Robust functional equations with ap plications to self-testing/correcting. </title> <booktitle> Proc. 35th Foundations of Computer Science, </booktitle> <pages> pp. 288299, </pages> <year> 1994. </year>
Reference-contexts: Though efficient, these methods often add small multiplicative factors to the runtime of the programs. Efforts to minimize the overhead due to program checking have been somewhat successful <ref> [BW94, Rub94, BGR96] </ref> for linear functions. <p> The ideas in this paper are inspired by their work. For the purposes of this exposition, we give a simplified definition of property testing that captures the common features of the definitions given by <ref> [RS96, Rub94, GGR96] </ref>. Given a domain H and a distribution D over H , a function f is *-close to a function g over D if Pr x2D [f (x) 6= g (x)] *. <p> In other words, each a 2 G has an inverse and (iii) follows. EQUALITY. Finally, we have to check if ffi 0 is the same as , the specific group operation (equality testing, <ref> [BLR93, Rub94] </ref>). To do this in jGj lg jGj steps, check 8b 2 G; g 2 S G if g ffi 0 b = g b, where the latter is given.
Reference: [RS92] <author> R. Rubinfeld and M. Sudan. </author> <title> Testing polynomial functions efficiently and over rational domains. </title> <booktitle> Proc. 3rd Symposium on Discrete Algorithms, </booktitle> <pages> pp. 2343, </pages> <year> 1992. </year>
Reference: [RS96] <author> R. Rubinfeld and M. Sudan. </author> <title> Robust characteriza tions of polynomials and their applications to program testing. </title> <journal> SIAM J. on Computing, </journal> <volume> 25(2):252271, </volume> <year> 1996. </year>
Reference-contexts: The ideas in this paper are inspired by their work. For the purposes of this exposition, we give a simplified definition of property testing that captures the common features of the definitions given by <ref> [RS96, Rub94, GGR96] </ref>. Given a domain H and a distribution D over H , a function f is *-close to a function g over D if Pr x2D [f (x) 6= g (x)] *.
Reference: [RaS96] <author> S. Rajagopalan and L. Schulman. </author> <title> Verifying iden tities. </title> <booktitle> Proc. 37th Foundations of Computer Science, </booktitle> <pages> pp. 612616, </pages> <year> 1996. </year>
Reference-contexts: One of the techniques that we developed for testing group operations allows us to efficiently test that an operation is associative. Recently in a surprising and elegant result, <ref> [RaS96] </ref> show how to test that operation ffi is associative in O (jDj 2 ) steps, rather than the straightforward O (jDj 3 ). They also show that (jDj 2 ) steps are necessary, even for cancellative operations. <p> The most interesting and challenging part of checking whether a given operation is close to a group is checking for associativity. The first o (jGj 3 ) algorithm for checking if ffi is associative is given in In <ref> [RaS96] </ref>. In particular, their randomized algorithm runs in O (jGj 2 ) steps for cancellative operations. They also give a lower bound which shows that any randomized algorithm required (jGj 2 ) steps to verify associativity, even in the cancellative case.
Reference: [Vai93] <author> F. Vainstein. </author> <title> Algebraic Methods in Hard ware/Software Testing. </title> <type> PhD thesis, </type> <institution> Boston University, </institution> <year> 1993. </year>
References-found: 26

