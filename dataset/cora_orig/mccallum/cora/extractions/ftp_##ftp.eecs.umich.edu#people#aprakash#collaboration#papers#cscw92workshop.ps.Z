URL: ftp://ftp.eecs.umich.edu/people/aprakash/collaboration/papers/cscw92workshop.ps.Z
Refering-URL: http://www.eecs.umich.edu/~aprakash/csrg_pub.html
Root-URL: http://www.cs.umich.edu
Email: Email: aprakash@eecs.umich.edu, mknister@eecs.umich.edu  
Phone: Phone: (313) 763-1585  
Title: Design considerations in choosing operations for building groupware systems  
Author: Atul Prakash Michael J. Knister 
Address: Ann Arbor, MI 48109-2122  
Affiliation: Software Systems Research Laboratory Department of Electrical Engineering and Computer Science University of Michigan,  
Abstract: We have implemented a prototype toolkit, called DistEdit, for building interactive group editors in distributed environments. The toolkit allows different editors (e.g., vi, Emacs) to be used in the same group session. Based on our experience in building the toolkit, we report here some design solutions that are commonly used in single-user editors, but may not necessarily be appropriate in group editors. Furthermore, design of group editors requires a better understanding of the semantics of editing operations than in the corresponding single-user editors. These semantics are useful for providing a variety of services, such as undo, concurrency control, and selective replay. Finally, we point out that implementing high-level actions is much more complex in group editors than in single-user editors because high-level actions may need to be implemented as a transaction to guarantee correct user-level semantics. This position paper is presented in the context of text editors; however, many of the ideas presented here also apply to other types of group editors. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Ellis, C.A., Gibbs, S.J., and Rein, G.L. </author> <title> Group 3 ware: Some Issues and Experiences. </title> <booktitle> Commu--nications of the ACM(January 1991), </booktitle> <pages> 38-58 </pages>
Reference-contexts: Introduction One difficulty in building collaboration systems is that they require solutions to problems in distributed concurrency control, fault-tolerance, user-interfaces, psychology, human factors, and software design <ref> [1] </ref>. The goal of our DistEdit project [3] is to remove most of the concerns of distributed concur-rency control and fault tolerance by providing a library of primitives that can be used to build collaboration tools.
Reference: [2] <author> Ellis, </author> <title> C.A. and Gibbs, S.J. Concurrency Control in Groupware Systems, </title> <booktitle> in Proceedings of the ACM SIGMOD '89 Conference on the Management of Data (Seattle, </booktitle> <address> Washington, May 1989), </address> <publisher> ACM Press, </publisher> <pages> pp. 399-407. </pages>
Reference-contexts: The current version of the DistEdit toolkit provides support for concurrent updates. To keep response time low, any update is performed locally first and then broadcast to other sites. It is well known that concurrent updates can lead to inconsistencies in the buffer state at various sites <ref> [2] </ref>. We are using an efficient locking-based solution which requires locks to be acquired only at the start of an insert/delete but not during an insert/delete. <p> Another reasonable alternative would have been to use a somewhat more complex scheme suggested in <ref> [2] </ref>, which does not require locks. In the following sections, we discuss some of the implementation issues that arose during our work. Choice of document-modifying primitives The issue of choosing a set of document-modifying primitives is not as critical in single-user editors as in group editors. <p> For instance, if a scheme such as that in <ref> [2] </ref> is used to ensure consistency, functions similar to Transpose are required to reorder a pair of operations. <p> Semantics of Primitive Opera tions In group editors, knowing the semantics of primitive operations is more crucial than in single-user editors. Knowing the semantics of the operations is helpful in following services: * Implementing undo in a group environment [4]. * Handling concurrency <ref> [2] </ref>. * Triggers for notification/awareness: A user may be interested in receiving notifications when certain parts of the document change. <p> Also, if an operation is not reversible, it is useful to know that so that the user can be appropriately warned or the document state checkpointed. * Resequencing of operations. Ability to rese-quence operations is needed for ensuring consistency in some protocols <ref> [2] </ref> and also for im plementing undo [4]. * A mapping from an operation to the region it affects in the document. 2 * type of operation: mode-altering, update, nav- igation, or access control. * Computational requirements of an operation and its inverse.
Reference: [3] <author> Knister, M. and Prakash, A. DistEdit: </author> <title> A Distributed Toolkit for Supporting Multiple Group Editors, </title> <booktitle> in Proceedings of the Third Conference on Computer-Supported Cooperative Work, </booktitle> <address> Los Angeles, California, </address> <month> October </month> <year> 1990, </year> <pages> pp. 343-355. </pages>
Reference-contexts: Introduction One difficulty in building collaboration systems is that they require solutions to problems in distributed concurrency control, fault-tolerance, user-interfaces, psychology, human factors, and software design [1]. The goal of our DistEdit project <ref> [3] </ref> is to remove most of the concerns of distributed concur-rency control and fault tolerance by providing a library of primitives that can be used to build collaboration tools.
Reference: [4] <author> Prakash, A. and Knister, M.. </author> <title> Undoing Actions in Collaborative Work. </title> <booktitle> Proceedings of the Fourth Conference on Computer-Supported Cooperative Work, </booktitle> <address> Oct. 31-November 4, 1992, Toronto. </address> <month> 4 </month>
Reference-contexts: Clearly, the amount of work required in implementing the editors can be large if the number of primitives is large and hetero geneity is to be supported. * Undos are much more complex in a group editor <ref> [4] </ref> than in a single-user editor. In particular, the ability to reverse operations and rese-quence them is needed for all the primitive operations. It is much easier to provide this capability if the set of primitive operations is small and of well-defined semantics. <p> Semantics of Primitive Opera tions In group editors, knowing the semantics of primitive operations is more crucial than in single-user editors. Knowing the semantics of the operations is helpful in following services: * Implementing undo in a group environment <ref> [4] </ref>. * Handling concurrency [2]. * Triggers for notification/awareness: A user may be interested in receiving notifications when certain parts of the document change. <p> Also, if an operation is not reversible, it is useful to know that so that the user can be appropriately warned or the document state checkpointed. * Resequencing of operations. Ability to rese-quence operations is needed for ensuring consistency in some protocols [2] and also for im plementing undo <ref> [4] </ref>. * A mapping from an operation to the region it affects in the document. 2 * type of operation: mode-altering, update, nav- igation, or access control. * Computational requirements of an operation and its inverse.
References-found: 4

