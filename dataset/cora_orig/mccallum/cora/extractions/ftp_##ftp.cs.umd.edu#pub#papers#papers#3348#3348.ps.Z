URL: ftp://ftp.cs.umd.edu/pub/papers/papers/3348/3348.ps.Z
Refering-URL: http://www.cs.umd.edu/TRs/TR.html
Root-URL: 
Email: godfrey@cs.umd.edu  
Title: Minimization in Cooperative Response to Failing Database Queries  
Author: Parke Godfrey 
Note: This work was supported by the Air Force Office of Scientific Research under grant AFOSR-91-0350 and by the National Science Foundation under grant IRI-9300691.  
Address: College Park, MD 20742, USA  
Affiliation: Department of Computer Science, University of Maryland,  
Abstract: When a query fails, it is more cooperative to identify the cause of failure, rather than just to report the empty answer set. If there is not a cause for the query's failure, it is worthwhile to report the part of the query which failed. To identify a minimal failing subquery (MFS) of the query is the best way to do this. (This MFS is not unique; there may be many of them.) Likewise, to identify a maximal succeeding subquery (MSS) can help a user to recast a new query that leads to a non-empty answer set. Database systems do not provide the functionality of these types of cooperative responses. This may be, in part, because algorithmic approaches to finding the MFSs and the MSSs to a failing query are not obvious. The search space of subqueries is large. Despite work on MFSs in the past, the algorithmic complexity of these identification problems had remained uncharted. This paper shows the complexity profile of MFS and MSS identification. It is shown that there exists a simple algorithm for finding a MFS or a MSS by asking N subsequent queries, in which N is the length of the query. To find more MFSs (or MSSs) can be hard. It is shown that to find O(N ) MFSs (or MSSs) is NP-hard. To find k MFSs (or MSSs), for a fixed k, remains polynomial. An optimal algorithm for enumerating MFSs and MSSs, ISHMAEL, is developed and presented. The algorithm has ideal performance in enumeration, finding the first answers quickly, and decaying toward intractability in a predictable manner as more answers are found. The complexity results and the algorithmic approaches given in this paper should allow for the construction of MFS and MSS facilities for database systems. These results are relevant to a number of problems outside of databases too, and may find further application. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> N. Belnap and T. Steel. </author> <title> The Logic of Questions and Answers. </title> <publisher> Yale University Press, </publisher> <address> New Haven, CT, </address> <year> 1976. </year>
Reference-contexts: Belnap and Steel considered such issues as related to information systems. They state "A question, Q, presupposes a statement, A, if and only if the truth of A is a logically necessary condition for there being some true answer to Q" <ref> [1] </ref>. This is not as rigid a condition as Strawson's; the query Q is considered to be false if it has any false presuppositions. Grice [23] enumerated a number of maxims to which one ought to adhere in conversation in order to be cooperative.
Reference: [2] <author> T. Bylander, D. Allemang, M. C. Tanner, and J. R. Josephson. </author> <title> The computational complexity of abduction. </title> <journal> Artificial Intelligence, </journal> <volume> 49 </volume> <pages> 25-60, </pages> <year> 1991. </year>
Reference-contexts: Hence the worst-case running time of a mel is (N 2 ). Algorithm a mel is worst-case running time of fi (N 2 ). 2 The recursive descent method employed by a mel is certainly not a new observation. Bylander et al. <ref> [2] </ref> show this algorithm for certain abduction problems, closely related to the MEL problem here, and they show that it is O (N 2 ) to find an answer. 3.3 Finding all MELs It is still not clear, however, what is the best search strategy for finding all the MELs of <p> It should be noted that a similar theorem for a given class of abduction problems is presented by Bylander et al. in <ref> [2] </ref>. The proof of that theorem follows in a very similar manner. <p> Such abduction problems have been explored and classified. (See <ref> [2] </ref>.) We present a proof here for the edification of the reader. Theorem 17. For any given function linear such that O (linear (N )) = O (N ), enumerate (MCS, linear) is NP-hard. Proof. The proof is constructed in the same manner as Proof 11. <p> It would be interesting to explore what further conditions could be placed on which MELs qualify as answers, and still for the problem to stay within the same complexity bounds. Clearly, many desirable conditions push the problem into intractability. In <ref> [2] </ref>, Bylander et al. look into these issues for abduction problems. For instance, if one adds the condition that the answer be an MEL of minimum cardinality, then the problem becomes intractable 36 even to find one. <p> An ISHMAEL-style algorithm can be used for the enumeration. Much work has been done in the domain of abductive reasoning. Many abductive reasoning tasks are more complex than MEL enumeration, but not all. While a fair amount is known about the complexity of abductive reasoning <ref> [2] </ref>, enumeration algorithms such as ISHMAEL may be new to this domain. Algorithms as ISHMAEL may be useful when an enumeration of the possible abductive supports is needed. Interest in minimal failing subqueries came about originally from interest in false presuppositions in natural language dialog.
Reference: [3] <author> W. W. Chu. CoBase: </author> <title> A cooperative database system. </title> <booktitle> In Demolombe and Imielinski [9], </booktitle> <pages> pages 41-73. </pages> <note> To appear. </note>
Reference-contexts: Motro [31] introduces a supposition generalizor into the architecture of his system SEAVE, which decides how to relax atoms. In [13], we consider how to use taxonomic information represented inherently in the rules of a deductive database to relax atoms in queries. Chu et al. <ref> [3, 4] </ref> consider how to extract and employ such taxonomic information in relational database, and have implemented such in their system CoBase. Heuristics and bounds are needed to ensure that the extended lattice to be searched is finite.
Reference: [4] <author> W. W. Chu, Q. Chen, and R.-C. Lee. </author> <title> A structured approach for cooperative query answering. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <year> 1992. </year>
Reference-contexts: Motro [31] introduces a supposition generalizor into the architecture of his system SEAVE, which decides how to relax atoms. In [13], we consider how to use taxonomic information represented inherently in the rules of a deductive database to relax atoms in queries. Chu et al. <ref> [3, 4] </ref> consider how to extract and employ such taxonomic information in relational database, and have implemented such in their system CoBase. Heuristics and bounds are needed to ensure that the extended lattice to be searched is finite.
Reference: [5] <author> P. Cole and J. Morgan, </author> <title> editors. Syntax and Semantics. </title> <publisher> Academic Press, </publisher> <year> 1975. </year>
Reference: [6] <author> A. Colmerauer and J. Pique. </author> <title> About natural logic. </title> <editor> In Gallaire et al. </editor> <volume> [19], </volume> <pages> pages 343-365. </pages>
Reference-contexts: Guarantees can be made that databases answer queries correctly. However, when databases stonewall, their answers are misleading. This commonly happens whenever a query has false presuppositions. Colmerauer and Pique addressed the problem of false presuppositions in their work to translate natural language queries into a logical formalism <ref> [6] </ref>. They employ a three-valued logic that allows a sentence to be marked as undefined when such false presuppositions occur. They translate natural language sentences into a recursive datastructure they call a three branch quantifier tree (3BQ tree).
Reference: [7] <author> F. Corella, S. J. Kaplan, G. Wiederhold, and L. Yesil. </author> <title> Cooperative responses to boolean queries. </title> <booktitle> In First International Conference on Data Engineering, </booktitle> <pages> pages 77-85, </pages> <address> Silver Spring, Maryland, 1984. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: All three of these cooperative behaviors for better response to failing database queries require search for a minimal subquery. It is this search for a minimal that is the focus of this paper. There has been much research on the topic, in particular on finding MFSs <ref> [7, 24, 26, 27, 28, 31, 32] </ref>. This work has not formally addressed the complexity of finding MFSs to queries. The implicit assumption has been that it may cost exponential time in worst case even to find one MFS. <p> This can serve as a tool in correcting possible errors in users' queries, and to give the user information related to the query asked. 6 Corella et al. <ref> [7] </ref> considered finding the MFSs to conjunctive boolean queries for library searches.
Reference: [8] <author> T. H. Cormen, C. E. Leiserson, and R. L. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1991. </year>
Reference-contexts: This last call performs n=2 tests to verify the MEL. 11 The definitions for the asymptotic upper bound (O), the asymptotic lower bound (), and the asymptotic tight bound (fi) employed here are the same as presented in <ref> [8] </ref>. 9 array mel (set) integer Last boolean all mels (Top) f Last := 0 if test (Top) then f all mels true (Top) return true g else return false g all mels true (Set) f Minimal := true foreach Ele 2 Set f if test (Set [Ele]) then f all
Reference: [9] <author> R. Demolombe and T. Imielinski, </author> <title> editors. Non Standard Queries and Answers. </title> <publisher> Oxford University Press, </publisher> <year> 1994. </year> <note> To appear. </note>
Reference: [10] <author> J. A. Fernandez and J. Lobo. </author> <title> A proof procedure for stable theories. </title> <institution> Technical Report UMIACS-TR-93-14 and CS-TR-3034, The University of Maryland Institute for Advanced Computer Studies and the Department of Computer Science, University of Maryland at College Park, </institution> <year> 1993. </year>
Reference-contexts: For certain semantics for logic programs, there exists the need for minimization in the proof procedure. This arises in the deduction of negative information via a non-monotonic rule for negation. This problem is encountered in a proof procedure for stable theories of Fernandez and Lobo <ref> [10] </ref>. The enumeration of (minimal) answers by the proof procedure follows the same complexity as enumerating MELs. In this case, all the answers are desired. An ISHMAEL-style algorithm can be used for the enumeration. Much work has been done in the domain of abductive reasoning.
Reference: [11] <author> W. J. Frawley, G. Piatetsky-Shapiro, and C. J. Matheus. </author> <title> Knowledge discovery in databases: An overview. </title> <note> In Piatetsky-Shapiro and Frawley [33], chapter 1. </note>
Reference-contexts: query fails when evaluated against a database, it may simply be that there is no data which provides an answer, or it may be that this query must fail due to the semantics of the database. (This distinction was drawn in Section 1.) This offers a potential data mining tool <ref> [11, 35] </ref>. Whenever a query fails, but there is no proof that it must fail (guaranteed by the integrity constraints of the database), it is possible that the query represents a missing integrity constraint. Failing queries can be collected and later analyzed, either by a program or a database administrator.
Reference: [12] <author> T. Gaasterland, P. Godfrey, and J. Minker. </author> <title> An overview of cooperative answering. </title> <journal> Journal of Intelligent Information Systems, </journal> <volume> 1(2) </volume> <pages> 123-157, </pages> <year> 1992. </year> <type> Invited paper. </type>
Reference: [13] <author> T. Gaasterland, P. Godfrey, and J. Minker. </author> <title> Relaxation as a platform for cooperative answering. </title> <journal> Journal of Intelligent Information Systems, </journal> <volume> 1 </volume> <pages> 293-321, </pages> <year> 1992. </year>
Reference-contexts: This type of information is not available with databases, and somehow the information has to be manifested. Motro [31] introduces a supposition generalizor into the architecture of his system SEAVE, which decides how to relax atoms. In <ref> [13] </ref>, we consider how to use taxonomic information represented inherently in the rules of a deductive database to relax atoms in queries. Chu et al. [3, 4] consider how to extract and employ such taxonomic information in relational database, and have implemented such in their system CoBase.
Reference: [14] <author> T. Gaasterland, P. Godfrey, and J. Minker. </author> <title> An overview of cooperative answering. </title> <booktitle> In Demolombe and Imielinski [9], </booktitle> <pages> pages 1-39. </pages> <note> Appears orginally as [12]. </note>
Reference-contexts: The cooperative answering system developed by Gal [16] identifies the integrity constraints that guarantee failure, and provides a response to the user based on them. Gal also recognized the need to provide an MCS, but did not address how to identify the minimal subqueries with misconceptions. See the survey <ref> [14] </ref> for more background. In [15, 21] the design and implementation of a cooperative database system are discussed, in which misconception detection and explanation are key components.
Reference: [15] <author> T. Gaasterland, P. Godfrey, J. Minker, and L. Novik. </author> <title> A cooperative answering system. </title> <editor> In A. Voronkov, editor, </editor> <booktitle> Proceedings of the Logic Programming and Automated Reasoning Conference, Lecture Notes in Artificial Intelligence 624, </booktitle> <pages> pages 478-480. </pages> <publisher> Springer-Verlag, </publisher> <address> St. Petersburg, Russia, </address> <month> July </month> <year> 1992. </year>
Reference-contexts: Gal also recognized the need to provide an MCS, but did not address how to identify the minimal subqueries with misconceptions. See the survey [14] for more background. In <ref> [15, 21] </ref> the design and implementation of a cooperative database system are discussed, in which misconception detection and explanation are key components.
Reference: [16] <author> A. Gal. </author> <title> Cooperative Responses in Deductive Databases. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Maryland, College Park, Maryland, </institution> <year> 1988. </year>
Reference-contexts: The realization that a query's failure assured by integrity constraints is more meaningful than just exhaustive failure motivated the work in cooperative answering by Gal and Minker <ref> [16, 17, 18] </ref>. The cooperative answering system developed by Gal [16] identifies the integrity constraints that guarantee failure, and provides a response to the user based on them. Gal also recognized the need to provide an MCS, but did not address how to identify the minimal subqueries with misconceptions. <p> The realization that a query's failure assured by integrity constraints is more meaningful than just exhaustive failure motivated the work in cooperative answering by Gal and Minker [16, 17, 18]. The cooperative answering system developed by Gal <ref> [16] </ref> identifies the integrity constraints that guarantee failure, and provides a response to the user based on them. Gal also recognized the need to provide an MCS, but did not address how to identify the minimal subqueries with misconceptions. See the survey [14] for more background.
Reference: [17] <author> A. Gal and J. Minker. </author> <title> A natural language database interface that provides cooperative answers. </title> <booktitle> Proceedings of the Second Conference on Artificial Intelligence Applications, </booktitle> <month> December 11-13 </month> <year> 1985. </year>
Reference-contexts: The realization that a query's failure assured by integrity constraints is more meaningful than just exhaustive failure motivated the work in cooperative answering by Gal and Minker <ref> [16, 17, 18] </ref>. The cooperative answering system developed by Gal [16] identifies the integrity constraints that guarantee failure, and provides a response to the user based on them. Gal also recognized the need to provide an MCS, but did not address how to identify the minimal subqueries with misconceptions.
Reference: [18] <author> A. Gal and J. Minker. </author> <title> Informative and cooperative answers in databases using integrity constraints. </title> <editor> In V. Dahl and P. Saint-Dizier, editors, </editor> <booktitle> Natural Language Understanding and Logic Programming, </booktitle> <pages> pages 277-300. </pages> <publisher> North Holland, </publisher> <year> 1988. </year>
Reference-contexts: The realization that a query's failure assured by integrity constraints is more meaningful than just exhaustive failure motivated the work in cooperative answering by Gal and Minker <ref> [16, 17, 18] </ref>. The cooperative answering system developed by Gal [16] identifies the integrity constraints that guarantee failure, and provides a response to the user based on them. Gal also recognized the need to provide an MCS, but did not address how to identify the minimal subqueries with misconceptions.
Reference: [19] <editor> H. Gallaire, J. Minker, and J.-M. Nicolas, editors. </editor> <booktitle> Advances in Database Theory, </booktitle> <volume> Volume 1. </volume> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1981. </year> <month> 39 </month>
Reference: [20] <author> M. R. Garey and D. S. Johnson. </author> <title> Computers and Intractability: a Guide to the Theory of NP--Completeness. A Series of Books in the Mathematical Sciences. </title> <editor> W. H. </editor> <publisher> Freeman and Company, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: The proof will encode a CNF propositional theory into a MEL enumeration problem. To determine whether an arbitrary CNF propositional theory is satisfiable, known as the problem SAT, is NP-complete <ref> [20] </ref>. These terms are defined as follows. Definition 7. A propositional theory C is in CNF form when it is of the form C 1 ^ : : : ^ C k . <p> SET-SAT does not appear in Garey and Johnson's catalog of NP-complete problems <ref> [20] </ref>, or elsewhere to the author's knowledge. Thus a proof is provided here. Theorem 21. SET-SAT is coNP-complete. Proof. By reduction of SAT to :SET-SAT. We show SET-SAT is coNP. hL; Di 62 SET-SAT iff 9S L: S 2 factor (L, D).
Reference: [21] <author> P. Godfrey, J. Minker, and L. Novik. </author> <title> An architecture for a cooperative database system. </title> <editor> In W. Litwin and T. Risch, editors, </editor> <booktitle> Proceedings of the First International Conference on Applications of Databases, Lecture Notes in Computer Science 819, </booktitle> <pages> pages 3-24. </pages> <publisher> Springer Verlag, </publisher> <address> Vadstena, Sweden, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: Gal also recognized the need to provide an MCS, but did not address how to identify the minimal subqueries with misconceptions. See the survey [14] for more background. In <ref> [15, 21] </ref> the design and implementation of a cooperative database system are discussed, in which misconception detection and explanation are key components.
Reference: [22] <author> J. Grant and J. Minker. </author> <title> Optimization in deductive and conventional relational data base systems. </title> <editor> In Gallaire et al. </editor> <volume> [19], </volume> <pages> pages 195-234. </pages>
Reference-contexts: Not all failing subqueries should be materialized. There are too many of them, and not all will be used repeatedly as components of other queries. Criteria are needed to decide which to choose. The idea warrants further consideration. Motro further suggests that techniques for optimizing multiple queries <ref> [22, 34] </ref> could be exploited in MFS enumeration as well. In the test used in enumerating MFSs, note that it is not necessary to compute answers for each subquery considered; it is only necessary to compute whether it has an answer. This is an easier computation.
Reference: [23] <author> H. Grice. </author> <title> Logic and conversation. </title> <publisher> In Cole and Morgan [5]. </publisher>
Reference-contexts: This is not as rigid a condition as Strawson's; the query Q is considered to be false if it has any false presuppositions. Grice <ref> [23] </ref> enumerated a number of maxims to which one ought to adhere in conversation in order to be cooperative. He states that an answer to a query should be correct, non-misleading, and relevant. Guarantees can be made that databases answer queries correctly. However, when databases stonewall, their answers are misleading.
Reference: [24] <author> J. M. Janas. </author> <title> On the feasibility of informative answers. </title> <editor> In Gallaire et al. </editor> <volume> [19], </volume> <pages> pages 397-414. </pages>
Reference-contexts: All three of these cooperative behaviors for better response to failing database queries require search for a minimal subquery. It is this search for a minimal that is the focus of this paper. There has been much research on the topic, in particular on finding MFSs <ref> [7, 24, 26, 27, 28, 31, 32] </ref>. This work has not formally addressed the complexity of finding MFSs to queries. The implicit assumption has been that it may cost exponential time in worst case even to find one MFS. <p> In related work, Lee [28] developed a CODASYL database system which detects and presents false presuppositions to database queries. The query language employed is called HI-IQ (HIerarchical Interactive Query language). He too noted the independence of the MFS problem from natural language. Janas <ref> [24] </ref> studied the computational feasibility of reporting the smallest subqueries that fail. If one considers a conjunctive query as a set of atoms to be satisfied, then the subqueries are the elements of the power set. <p> When Last is 0, no MEL has yet been found. The algorithms that have been suggested for MFS search are essentially isomorphic to all mels. Janas presents such an algorithm in <ref> [24] </ref>. His algorithm works top-down and depth-first, and the algorithm continues until all MFSs are found. <p> Much of the work on MFSs in the past has focussed on such heuristics. These heuristics should be re-evaluated in light of the complexity results of MEL enumeration presented in this paper, and with respect to ISHMAEL's search strategy. In particular, heuristics for MFS enumeration are considered here. Janas <ref> [24] </ref> raises the point that, for most queries, many of the potential subqueries need never be considered while searching for MFSs. Definition 27. Two atoms in a query are joined iff they share a variable in common. <p> There are (n (n + 1)=2) + 1 of these (counting ; as connected). A great majority of the subqueries are disjoint. In the limit, the probability that any given subquery is disjoint is one. 17 Janas does not define connected in <ref> [24] </ref> in quite this way, but to the same effect. 31 It is assumed that, in general, a significant number of the subqueries of a query are disjoint. Hence, handling of disjoint queries by decomposing them should speed up the search for MFSs significantly, in average case.
Reference: [25] <editor> A. Joshi, B. Webber, and I. Sag, editors. </editor> <booktitle> Elements of Discourse Understanding. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1981. </year>
Reference: [26] <author> S. J. Kaplan. </author> <title> Appropriate responses to inappropriate questions. </title> <editor> In Joshi et al. </editor> <volume> [25], </volume> <pages> pages 127-144. </pages>
Reference-contexts: All three of these cooperative behaviors for better response to failing database queries require search for a minimal subquery. It is this search for a minimal that is the focus of this paper. There has been much research on the topic, in particular on finding MFSs <ref> [7, 24, 26, 27, 28, 31, 32] </ref>. This work has not formally addressed the complexity of finding MFSs to queries. The implicit assumption has been that it may cost exponential time in worst case even to find one MFS. <p> The student then asks "Who failed CMSC 420 in the fall semester of 1991?" Again, the database returns with the answer "No one." Finally, the student is suspicious and asks "Who taught CMSC 420 in the fall semester of 1991?" The database answers again "No one." Kaplan <ref> [26, 27] </ref> called this behavior stonewalling. If the initial question had been asked to a person instead, he or she would have probably answered immediately with a reply such as "Oh, there was no such course taught last semester." Databases stonewall. <p> They translate natural language sentences into a recursive datastructure they call a three branch quantifier tree (3BQ tree). Fig. 1 shows this representation for the statement "Every student owns a car." In their work, however, they do not develop a means to identify false presuppositions to the user. Kaplan <ref> [26, 27] </ref> may have been the first to note the relevance of false presuppositions to databases. Any subquery of a conjunctive relational query may be considered a presupposition to the query, at least in Belnap's and Steel's view.
Reference: [27] <author> S. J. Kaplan. </author> <title> Cooperative responses from a portable natural language query system. </title> <journal> Artificial Intelligence, </journal> <volume> 19(2) </volume> <pages> 165-187, </pages> <month> Oct. </month> <year> 1982. </year>
Reference-contexts: All three of these cooperative behaviors for better response to failing database queries require search for a minimal subquery. It is this search for a minimal that is the focus of this paper. There has been much research on the topic, in particular on finding MFSs <ref> [7, 24, 26, 27, 28, 31, 32] </ref>. This work has not formally addressed the complexity of finding MFSs to queries. The implicit assumption has been that it may cost exponential time in worst case even to find one MFS. <p> The student then asks "Who failed CMSC 420 in the fall semester of 1991?" Again, the database returns with the answer "No one." Finally, the student is suspicious and asks "Who taught CMSC 420 in the fall semester of 1991?" The database answers again "No one." Kaplan <ref> [26, 27] </ref> called this behavior stonewalling. If the initial question had been asked to a person instead, he or she would have probably answered immediately with a reply such as "Oh, there was no such course taught last semester." Databases stonewall. <p> They translate natural language sentences into a recursive datastructure they call a three branch quantifier tree (3BQ tree). Fig. 1 shows this representation for the statement "Every student owns a car." In their work, however, they do not develop a means to identify false presuppositions to the user. Kaplan <ref> [26, 27] </ref> may have been the first to note the relevance of false presuppositions to databases. Any subquery of a conjunctive relational query may be considered a presupposition to the query, at least in Belnap's and Steel's view. <p> Kaplan <ref> [27] </ref> devises an algorithm similar to Janas's that operates over a query translated into MQL, the query language CO-OP employs internally, but he does not consider the computational issues involved. He points out that his algorithm to find false presuppositions is independent of domain specific knowledge (as is Janas's).
Reference: [28] <author> R. M. Lee. </author> <title> Conversational aspects of database interactions. </title> <booktitle> In Proceedings of the 4th International Conference on Very Large Data Bases, </booktitle> <address> Berlin, </address> <year> 1978. </year>
Reference-contexts: All three of these cooperative behaviors for better response to failing database queries require search for a minimal subquery. It is this search for a minimal that is the focus of this paper. There has been much research on the topic, in particular on finding MFSs <ref> [7, 24, 26, 27, 28, 31, 32] </ref>. This work has not formally addressed the complexity of finding MFSs to queries. The implicit assumption has been that it may cost exponential time in worst case even to find one MFS. <p> CO-OP provides cooperative responses to simple natural language questions, requesting the relevant data from the database. The system was used and tested over a real database from the National Center for Atmospheric Research by both users and programmers. In related work, Lee <ref> [28] </ref> developed a CODASYL database system which detects and presents false presuppositions to database queries. The query language employed is called HI-IQ (HIerarchical Interactive Query language). He too noted the independence of the MFS problem from natural language.
Reference: [29] <author> E. Mays. </author> <title> Correcting misconceptions about database structure. </title> <booktitle> In Proceedings of the CSCSI '80, </booktitle> <year> 1980. </year>
Reference-contexts: Furthermore, by preventing stonewalling, the user is less likely to become frustrated, dissuaded from his or her goal, or even misinformed; so the database system becomes more effective. A number of people have been concerned with how to detect misconceptions in queries. Mays <ref> [29] </ref> explored how to employ the schema information of a relational database in order to correct misconceptions, whenever possible. McCoy [30] used world (or general) knowledge to correct object related misconceptions that a user might have about the properties of a given object or class.
Reference: [30] <author> K. McCoy. </author> <title> Correcting object-related misconceptions. </title> <booktitle> In Proc. </booktitle> <institution> of COLING10, Stanford University, California, </institution> <month> July </month> <year> 1984. </year>
Reference-contexts: A number of people have been concerned with how to detect misconceptions in queries. Mays [29] explored how to employ the schema information of a relational database in order to correct misconceptions, whenever possible. McCoy <ref> [30] </ref> used world (or general) knowledge to correct object related misconceptions that a user might have about the properties of a given object or class.
Reference: [31] <author> A. Motro. SEAVE: </author> <title> A mechanism for verifying user presuppositions in query systems. </title> <journal> ACM Transactions on Office Information Systems, </journal> <volume> 4(4) </volume> <pages> 312-330, </pages> <month> October </month> <year> 1986. </year>
Reference-contexts: All three of these cooperative behaviors for better response to failing database queries require search for a minimal subquery. It is this search for a minimal that is the focus of this paper. There has been much research on the topic, in particular on finding MFSs <ref> [7, 24, 26, 27, 28, 31, 32] </ref>. This work has not formally addressed the complexity of finding MFSs to queries. The implicit assumption has been that it may cost exponential time in worst case even to find one MFS. <p> The MFSs then are just the subqueries which had zero matches. This is intended to help the user to choose among the subqueries to pursue. Motro <ref> [31, 32] </ref> extended on the notion of false presuppositions. Instead of considering only the subqueries of a query, as defined above, he considers certain generalizations of the query as well, which are logical presuppositions to the query. <p> His algorithm works top-down and depth-first, and the algorithm continues until all MFSs are found. The procedural control is that of all mels. 12 Assume that the array mel is dynamically allocated and is not of fixed length. 10 Motro presents an algorithm <ref> [31] </ref> to search his extended lattice for a query to find all maximal failing generalizations of the query. <p> Hence, handling of disjoint queries by decomposing them should speed up the search for MFSs significantly, in average case. Motro <ref> [31] </ref> suggests that certain subqueries be materialized; that is, the query be evaluated and the answer set stored as a table for later use. If a subquery is part of many queries that will be tested, that subquery will need to be recomputed many times. <p> In light of the complexity of MEL enumeration, certain heuristics can now be judged as detrimental. In <ref> [31] </ref>, Motro imposes a bound on the depth of the recursion in searching for maximally generalized failing queries (for which MFSs are a special case). This was to limit the size of the search space, to render it more manageable. <p> In particular, the relaxation operators used to relax given atoms in the query must be provided The step size, or how much to relax a condition, must be determined too. This type of information is not available with databases, and somehow the information has to be manifested. Motro <ref> [31] </ref> introduces a supposition generalizor into the architecture of his system SEAVE, which decides how to relax atoms. In [13], we consider how to use taxonomic information represented inherently in the rules of a deductive database to relax atoms in queries.
Reference: [32] <author> A. Motro. </author> <title> FLEX: A tolerant and cooperative user interface to databases. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(2) </volume> <pages> 231-246, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: All three of these cooperative behaviors for better response to failing database queries require search for a minimal subquery. It is this search for a minimal that is the focus of this paper. There has been much research on the topic, in particular on finding MFSs <ref> [7, 24, 26, 27, 28, 31, 32] </ref>. This work has not formally addressed the complexity of finding MFSs to queries. The implicit assumption has been that it may cost exponential time in worst case even to find one MFS. <p> The MFSs then are just the subqueries which had zero matches. This is intended to help the user to choose among the subqueries to pursue. Motro <ref> [31, 32] </ref> extended on the notion of false presuppositions. Instead of considering only the subqueries of a query, as defined above, he considers certain generalizations of the query as well, which are logical presuppositions to the query.
Reference: [33] <editor> G. Piatetsky-Shapiro and W. J. Frawley, editors. </editor> <title> Knowledge Discovery in Databases. </title> <publisher> AAAI Press and MIT Press, </publisher> <address> Menlo Park, California, </address> <year> 1991. </year>
Reference-contexts: This means that cooperative techniques, such as identifying MFSs and MSSs, will become indispensable in future database systems. With many organizations now owning large, valuable data stores, there is a growing interest in data mining. (See <ref> [33] </ref>.) Data stores are examined for general patterns, which may be characterizations of the data in general. Such a characterization may reflect some hidden semantics of the data at large.
Reference: [34] <author> T. Sellis and S. Shosh. </author> <title> On the multiple-query optimization problem. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(2), </volume> <month> June </month> <year> 1990. </year>
Reference-contexts: Not all failing subqueries should be materialized. There are too many of them, and not all will be used repeatedly as components of other queries. Criteria are needed to decide which to choose. The idea warrants further consideration. Motro further suggests that techniques for optimizing multiple queries <ref> [22, 34] </ref> could be exploited in MFS enumeration as well. In the test used in enumerating MFSs, note that it is not necessary to compute answers for each subquery considered; it is only necessary to compute whether it has an answer. This is an easier computation.
Reference: [35] <author> M. Siegel, E. Sciore, and S. Salveter. </author> <title> Rule discovery for query optimization. </title> <note> In Piatetsky-Shapiro and Frawley [33], chapter 24. </note>
Reference-contexts: query fails when evaluated against a database, it may simply be that there is no data which provides an answer, or it may be that this query must fail due to the semantics of the database. (This distinction was drawn in Section 1.) This offers a potential data mining tool <ref> [11, 35] </ref>. Whenever a query fails, but there is no proof that it must fail (guaranteed by the integrity constraints of the database), it is possible that the query represents a missing integrity constraint. Failing queries can be collected and later analyzed, either by a program or a database administrator.
Reference: [36] <author> P. F. Strawson. </author> <title> Introduction to Logical Theory. </title> <publisher> Methuen, </publisher> <address> London, </address> <year> 1974. </year>
Reference-contexts: They will answer a yes/no question with a yes or a no regardless of whether the answer is misleading. There has been prior interest in such stonewalling behavior (and in avoiding it) within the domain of natural language dialog. Strawson <ref> [36] </ref> claimed that for a statement to have a truth value, it should be necessary that all of its presuppositions be true. A presupposition of a statement is any statement entailed by the original.
Reference: [37] <author> J. D. Ullman. </author> <title> Principles of Database and Knowledge-Base Systems, Volume I. </title> <booktitle> Principles of Computer Science Series. </booktitle> <publisher> Computer Science Press, Incorporated, </publisher> <address> Rockville, Maryland, </address> <year> 1988. </year> <month> 40 </month>
Reference-contexts: Coupled with the knowledge that this is a minimal failing subquery, it is even more informative; for instance, it states implicitly that there are patients with infections. Let DB be a database in DATALOG <ref> [37] </ref>. <p> He notes that this problem is independent of natural language; it is an issue for any formal query language and query answering system. Kaplan built a system called CO-OP (A Cooperative Query System), which couples a natural language query system and a CODASYL database management system, SEED <ref> [37] </ref>. CO-OP provides cooperative responses to simple natural language questions, requesting the relevant data from the database. The system was used and tested over a real database from the National Center for Atmospheric Research by both users and programmers.
References-found: 37

