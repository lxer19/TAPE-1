URL: http://www.cs.mu.oz.au/tr_db/mu_98_03.ps.gz
Refering-URL: http://www.cs.mu.oz.au/tr_db/TR.html
Root-URL: 
Email: (lee@cs.mu.OZ.AU, http://www.cs.mu.oz.au/~lee)  
Title: Mode checking using constrained regular trees  
Author: Lee Naish 
Address: Parkville, Victoria 3052 Australia  
Affiliation: Department of Computer Science University of Melbourne  
Pubnum: Technical Report 98/3  
Abstract: In a previous paper we presented a high level polymorphic mode system for logic programs. In this paper we present an algorithm which checks if a program is well moded, given that is it well-typed in the sense of Mycroft and O'Keefe. A program is well-moded if the set of ground atoms defined by mode declarations is a superset of the success set. The novelty of the algorithm is the expressiveness of the mode declarations. Constrained regular trees are used to define sets of terms and atoms. These are based on polymorphic types but allow set and multiset constraints over type variables. The expressiveness of this domain makes it very promising for many program analysis applications. Complexity is also (exponentially) better than other proposed domains for certain analysis tasks. Keywords: logic programming, modes, types, constrained regular trees, aliasing, linearity, set constraints, multisets 
Abstract-found: 1
Intro-found: 1
Reference: [BLR92] <author> F. Bronsard, T. K. Lakshman, and U. S. Reddy. </author> <title> A framework of directionality for proving termination of logic programs. </title> <booktitle> In Proceedings of the Ninth Joint 14 International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 321-335, </pages> <year> 1992. </year>
Reference: [BM95] <author> J. Boye and J. Maluszynski. </author> <title> Two aspects of directional types. </title> <editor> In Leon Sterling, editor, </editor> <booktitle> Proceedings of the Twelfth International Conference on Logic Programming, </booktitle> <pages> pages 747-761, </pages> <address> Kanagawa, Japan, </address> <month> June </month> <year> 1995. </year>
Reference: [Bry92] <author> Randal Bryant. </author> <title> Symbolic Boolean manipulation with ordered binary-decision diagrams. </title> <journal> ACM Computing Surveys, </journal> <volume> 24(3) </volume> <pages> 293-318, </pages> <year> 1992. </year>
Reference-contexts: It is likely that previously proposed algorithms for checking boolean functions will perform well for problems of this form. For example, the complexity of algorithms based on reduced ordered binary decision diagrams <ref> [Bry92] </ref> [Sch96] are likely to be almost linear in the size of clauses if the size of each declaration is considered constant, and quadratic otherwise.
Reference: [CL96] <author> M. Codish and V. Lagoon. </author> <title> Type dependencies for logic programs using ACI-unification. </title> <booktitle> In Proceedings of the 1996 Israeli Symposium on Theory of Computing and Systems, </booktitle> <pages> pages 136-145. </pages> <publisher> IEEE Press, </publisher> <month> June </month> <year> 1996. </year>
Reference-contexts: Using &lt;-&gt; constraints allows ad hoc polymorphic, further increasing flexibility. In terms of the abstract domain we use for analysis, the most closely related work is that of Codish et al. In <ref> [CL96] </ref> a domain based on associative commutative idempotent (ACI) unification of polymorphic type expressions is presented. Given definitions of types, terms are mapped to type expressions.
Reference: [CLB97] <author> M. Codish, V. Lagoon, and F. Bueno. </author> <title> An algebraic approach to sharing analysis of logic programs. </title> <booktitle> In Proceedings of the Fourth International Static Analysis Symposium (SAS'97), volume 1302 of LNCS, </booktitle> <pages> pages 68-82. </pages> <publisher> Springer-Verlag, </publisher> <month> Sept </month> <year> 1997. </year>
Reference-contexts: By restricting our attention to well-typed programs we have made it easier to support a very expressive type language while retaining relatively simple algorithms (for example, we avoid the need for complicated intersection or unification algorithms). In <ref> [CLB97] </ref> another domain is proposed for sharing analysis which is isomorphic to the set sharing domain [JL92]. A domain based on sets of variables and ACI1-unification is presented then extended to incorporate linearity information (whether a set can contain multiple occurrences of variables).
Reference: [DH88] <author> Roland Dietrich and Frank Hagl. </author> <title> A polymorphic type system with subtypes for prolog. </title> <editor> In H. Ganzinger, editor, </editor> <booktitle> Proceedings of the Second European Symposium on Programming, </booktitle> <pages> pages 79-93, </pages> <address> Nancy, France, </address> <month> March </month> <year> 1988. </year> <note> published as Lecture Notes in Computer Science 300 by Springer-Verlag. </note>
Reference-contexts: Second, dropping the restriction to well-typed programs could be considered. Our mode checking algorithm could be combined with some form of type checking, preferably supporting subtypes (which are closely related to mode information <ref> [DH88] </ref> [RNP92]). Alternatively, arbitrary programs could be allowed. The matching phase of our algorithm would then become substantially more complex, requiring instersection of types in general. The work of Ueda [Ued95] may be useful here.
Reference: [EG96] <author> S. Etalle and M. Gabbrielli. </author> <title> Layered modes. </title> <editor> In F. de Boer and M. Gabbrielli, editors, </editor> <booktitle> Proc. JICSLP'96 Post-Conference Workshop on Verification and Analysis of Logic Programs, </booktitle> <year> 1996. </year> <note> Tehcnical Report TR-96-31, </note> <institution> Dipartimento di Informatica di Pisa. </institution>
Reference-contexts: Layered modes have been proposed as a more flexible alternative to directional types <ref> [EG96] </ref>. Our approach is more flexible still, and similar to the mode segments proposed for Ptah [Som89]. Mode checking of -&gt; constraints is done in a very similar way to =&gt; constraints. It is simplest to consider all non-variable nodes to be labelled. <p> This work does not support polymorphism. Even the work on layered modes <ref> [EG96] </ref> is less flexible than our use of -&gt; constraints. Layered modes assign a directionality (input or output) and a timing to each argument. Output arguments depend on the input arguments with a smaller timing. The timings define a total order for the arguments.
Reference: [JL92] <author> Dean Jacobs and Anno Langen. </author> <title> Static analysis of logic programs for independent and-parallelism. </title> <journal> Journal of Logic Programming, </journal> <volume> 13(2,3):291-314, </volume> <year> 1992. </year>
Reference-contexts: In [CLB97] another domain is proposed for sharing analysis which is isomorphic to the set sharing domain <ref> [JL92] </ref>. A domain based on sets of variables and ACI1-unification is presented then extended to incorporate linearity information (whether a set can contain multiple occurrences of variables). This goes some way towards the multiset information our constraints express: there is a distinction between one occurrence and (possibly) multiple occurrences.
Reference: [Llo84] <author> John W. Lloyd. </author> <booktitle> Foundations of logic programming. Springer series in symbolic computation. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1984. </year>
Reference-contexts: Our polymorphic mode checking algorithm is based on the sufficient condition that M SS (P ) if M T P (M ), where T P is the immediate consequence operator for the program <ref> [Llo84] </ref>. That is, it checks M (the set of ground atoms defined by the mode declarations) is a model of the program. Mergesort with [] replaced with _ and the breadth first traversal code with &lt;==&gt; replaced by &lt;=&gt; are well moded in the sense that M SS (P ).
Reference: [MS93] <author> K. Marriott and H. Stndergaard. </author> <title> Precise and efficient groundness analysis for logic programs. </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <volume> 2(1-4):181-196, </volume> <year> 1993. </year>
Reference-contexts: Mode analysis derives a constraint of the form At+QT &lt;==&gt; As+QT and (exactly) one occurrence of QT can be dropped from both sides. This cannot be done with a set constraint. Similarly, groundness analysis of this program using positive boolean functions <ref> [MS93] </ref> (a domain closely related to set constraints) is unable to establish any relationship between At and As due to the repeated variable QT. :- mode bf (tree (At), list (As)): At &lt;==&gt; As. bf (At, As) :- bfq (s (zero), At.QT, QT, As). % as above using a queue of
Reference: [Nai93] <author> Lee Naish. </author> <title> Coroutining and the construction of terminating logic programs. </title> <journal> Aus-tralian Computer Science Communications, </journal> <volume> 15(1) </volume> <pages> 181-190, </pages> <year> 1993. </year>
Reference-contexts: Any clause containing such a call cannot contribute to the success set so we could conclude that the clause is well moded according to our definition. Cyclic modes are strongly linked to nontermination of programs <ref> [Nai93] </ref> and hence it would also be reasonable to give an error message if such constraints were encountered, or mode checking could simply fail. Our current algorithm simply concludes that (the type variable associated with) A is empty | a valid conclusion in the domain of (finite) multisets.
Reference: [Nai96] <author> Lee Naish. </author> <title> A declarative view of modes. </title> <booktitle> In Proceedings of the 1996 Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 185-199. </pages> <publisher> MIT Press, </publisher> <month> September </month> <year> 1996. </year>
Reference-contexts: 1 Introduction In a previous paper <ref> [Nai96] </ref> we presented a very high level view of modes, showing how mode information can be captured by a set of ground atoms, suggesting an expressive mode declaration language for defining such sets and defining a notion of well-modedness. <p> Consider the normal definition of append, where each argument type is list, in the "forward" mode (input, input, output). In <ref> [Nai96] </ref> this is declared as follows and the corresponding mode set is given below: :- type list ---&gt; [] ; any.list. :- mode append (list, list, ~list). <p> In order to build more flexible 1 mode systems we need more precise mode information. It is therefore important to con-sider expressive languages for defining sets of atoms. The previous work concentrated on parametric polymorphism. The (parametric) polymorphic modes of <ref> [Nai96] </ref> are based on polymorphic types such as list (T), where T is the type of the elements of the list. A formalism called constrained regular trees (see below) allows a non-traditional interpretation of an expression containing type variables. <p> using a queue of trees (Length, [Front|Rest], Rest) :- mode bfq (nat, list (tree (QH)), list (tree (QT)), list (L)): L+QT&lt;==&gt;QH. bfq (zero, Q, Q, []). bfq (s (N), nil.QH, QT, As) :- bfq (N, QH, QT, As). 4 Constrained regular trees Constrained regular trees are defined more formally in <ref> [Nai96] </ref>. Here we describe them by relating them to the more conventional regular trees which are typically used to define types. The traditional way of defining algebraic types can be reconstructed in the constrained regular tree framework to make the sets of terms associated with type parameters more explicit.
Reference: [RNP92] <author> Yann Rouzaud and Lan Nguyen-Phuong. </author> <title> Integrating modes and subtypes into a Prolog type-checker. </title> <booktitle> In Proceedings of the Ninth Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 85-97, </pages> <year> 1992. </year> <month> 15 </month>
Reference-contexts: Second, dropping the restriction to well-typed programs could be considered. Our mode checking algorithm could be combined with some form of type checking, preferably supporting subtypes (which are closely related to mode information [DH88] <ref> [RNP92] </ref>). Alternatively, arbitrary programs could be allowed. The matching phase of our algorithm would then become substantially more complex, requiring instersection of types in general. The work of Ueda [Ued95] may be useful here.
Reference: [Sch96] <author> Peter Schachte. </author> <title> Efficient ROBDD operations for program analysis. </title> <editor> In Kotagiri Ra--mamohanarao, editor, ACSC'96: </editor> <booktitle> Proceedings of the 19 th Australasian Computer Science Conference, </booktitle> <pages> pages 347-356. </pages> <institution> Australian Computer Science Communications, </institution> <year> 1996. </year>
Reference-contexts: It is likely that previously proposed algorithms for checking boolean functions will perform well for problems of this form. For example, the complexity of algorithms based on reduced ordered binary decision diagrams [Bry92] <ref> [Sch96] </ref> are likely to be almost linear in the size of clauses if the size of each declaration is considered constant, and quadratic otherwise.
Reference: [SHC95] <author> Zoltan Somogyi, Fergus J. Henderson, and Thomas Conway. </author> <title> Mercury: an efficient purely declarative logic programming language. </title> <booktitle> In Proceedings of the Australian Computer Science Conference, </booktitle> <pages> pages 499-512, </pages> <address> Glenelg, Australia, </address> <month> February </month> <year> 1995. </year>
Reference-contexts: For example, we can infer that if the first two arguments only contain uniquely referenced terms then the last argument will also have this properly | precisely the information needed for one "unique mode" of append in Mercury <ref> [SHC95] </ref>. The declaration can also be seen as a precise description of the aliasing induced by a call to append, a groundness dependency, a type dependency, et cetera.
Reference: [Som89] <author> Z. Somogyi. </author> <title> A parallel logic programming system based on strong and precise modes. </title> <type> Technical Report 89/4, </type> <institution> Department of Computer Science, University of Melbourne, </institution> <address> Melbourne, Australia, </address> <year> 1989. </year> <type> Ph.D. thesis. </type>
Reference-contexts: Layered modes have been proposed as a more flexible alternative to directional types [EG96]. Our approach is more flexible still, and similar to the mode segments proposed for Ptah <ref> [Som89] </ref>. Mode checking of -&gt; constraints is done in a very similar way to =&gt; constraints. It is simplest to consider all non-variable nodes to be labelled.
Reference: [Ued95] <author> K. Ueda. </author> <title> I/O mode analysis in concurrent logic programming. </title> <editor> In T. Ito and Yonezawa, editors, </editor> <booktitle> Theory and practice of parallel programming, number 907 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1995. </year> <month> 16 </month>
Reference-contexts: Alternatively, arbitrary programs could be allowed. The matching phase of our algorithm would then become substantially more complex, requiring instersection of types in general. The work of Ueda <ref> [Ued95] </ref> may be useful here. This work infers modes in GHC, which is not strongly typed but has in-built constraint on modes due to guards. This mode inference algorithm is almost linear when variables occur at most twice (corresponding to data structures being single threaded).
References-found: 17

