URL: http://www-sal.cs.uiuc.edu/~kamin/dsl/papers/cowan.ps
Refering-URL: http://www-sal.cs.uiuc.edu/~kamin/dsl/index.html
Root-URL: http://www.cs.uiuc.edu
Email: email: fcalton, black, crispin, walpoleg@cse.ogi.edu  email: consel@irisa.fr  
Title: Microlanguages for Operating System Specialization  
Author: Calton Pu, Andrew Black, Crispin Cowan, Jonathan Walpole Charles Consel 
Address: P.O. Box 91000, Portland, OR 97291-1000  Rennes/IRISA  
Affiliation: Dept. of Computer Science and Engineering Oregon Graduate Institute  Dept. of Computer Science University of  
Abstract: Specialization is a technique that has the potential to provide operating system clients with the performance and functionality that they need, while still retaining the advantages of a simple generic code base for the operating system maintainer. However, at present the specialization process is labor-intensive and requires the knowledge of an expert in the domain of application behavior. In order to realize the full advantages of specialization, we believe that the process must be automated. This means building tools for specialization, and also making the domain knowledge explicit in some form or other. A specialization toolkit has been developed jointly at the Oregon Graduate Institute and IRISA, as part of the Syn-thetix project. This paper discusses our preliminary ideas on the use of Microlanguages to describe application be havior and to make that information available to the specialization tools.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B.N. Bershad, C. Chambers, S. Eggers, C. Maeda, D. McNamee, P. Pardyak, S. Savage, and E.G. Sirer. </author> <title> SPIN An Extensible Microkernel for Application-specific Operating System Services. </title> <booktitle> In SIGOPS 1994 European Workshop, </booktitle> <month> February </month> <year> 1994. </year> <note> UW Technical Report 94-03-03. </note>
Reference-contexts: These forces result in uncontrolled growth in the size and complexity of the kernel and the middleware. Specialization of the operating system kernel has emerged as a promising technique for addressing these problems; Synthesis [20, 18], the x-kernel [19], SPIN <ref> [1, 2] </ref>, and Synthetix [7, 21] all allow the introduction of custom or specialized code into the kernel. However, there are two limitations to the wide application of specialization. First, although it has been applied successfully in specific domains, each domain seems different enough to require a large new effort. <p> In this paper we also envisage higher level microlanguages that are designed to describe the needs of the application. A alternative approach to customization has been taken by the SPIN project <ref> [1, 2] </ref>, which provides application programmers with a general-purpose programming language in which they write extensions that are loaded into the kernel. <p> In particular, we intend that low-level microprograms be used to control the Synthetix specialization machinery. Specialization is an implementation technique that has been shown effective in the optimization of kernel calls <ref> [1, 2, 20, 21] </ref>. However, undisciplined use of specialization can increase the complexity of kernel code significantly. <p> The core microlanguage will capture the essential data flow aspects of I/O, while the extensions will represent the peculiarities of each I/O device and usage. 5 Related Work Microprotocolsx-kernel, SPIN: The SPIN project <ref> [1, 2] </ref> is using a safe language for customizing the kernel. Program fragments written in this language are loaded into the kernel address space dynamically, and can affect the kernels behavior in general ways.
Reference: [2] <author> Brian N. Bershad, Stefan Savage, Przemysaw Pardyak, Emin Gun Sirer, Marc Fiuczynski, David Becker, Susan Eggers, and Craig Chambers. </author> <title> Extensibility, Safety and Performance in the SPIN Operating System. </title> <booktitle> In Symposium on Operating Systems Principles (SOSP), </booktitle> <address> Copper Mountain, Colorado, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: These forces result in uncontrolled growth in the size and complexity of the kernel and the middleware. Specialization of the operating system kernel has emerged as a promising technique for addressing these problems; Synthesis [20, 18], the x-kernel [19], SPIN <ref> [1, 2] </ref>, and Synthetix [7, 21] all allow the introduction of custom or specialized code into the kernel. However, there are two limitations to the wide application of specialization. First, although it has been applied successfully in specific domains, each domain seems different enough to require a large new effort. <p> In this paper we also envisage higher level microlanguages that are designed to describe the needs of the application. A alternative approach to customization has been taken by the SPIN project <ref> [1, 2] </ref>, which provides application programmers with a general-purpose programming language in which they write extensions that are loaded into the kernel. <p> In particular, we intend that low-level microprograms be used to control the Synthetix specialization machinery. Specialization is an implementation technique that has been shown effective in the optimization of kernel calls <ref> [1, 2, 20, 21] </ref>. However, undisciplined use of specialization can increase the complexity of kernel code significantly. <p> The core microlanguage will capture the essential data flow aspects of I/O, while the extensions will represent the peculiarities of each I/O device and usage. 5 Related Work Microprotocolsx-kernel, SPIN: The SPIN project <ref> [1, 2] </ref> is using a safe language for customizing the kernel. Program fragments written in this language are loaded into the kernel address space dynamically, and can affect the kernels behavior in general ways.
Reference: [3] <author> D.L. Black, D.B. Golub, D.P. Julin, R.F. Rashid, R.P. Draves, R.W. Dean, A. Forin, J. Barrera, H. Tokuda, G. Malan, and D. Bohman. </author> <title> Microkernel operating system architecture and mach. </title> <booktitle> In Proceedings of the Workshop on Micro-Kernels and Other Kernel Architectures, </booktitle> <pages> pages 11-30, </pages> <address> Seattle, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: Thus the microlanguage approach can be viewed as a particular discipline in the construction of Open Implementations. Modular Operating SystemsMach, Chorus, Choices, Apertos: In response to the saturation of monolithic kernels, one of the most important developments in modern operating systems is the movement towards micro-kernels such as Mach <ref> [3] </ref> and Chorus [22], and more recently, object-oriented operating systems such as Choices [5] and Aper-tos [27]. All of these systems have a high degree of organization and modularity. However, they also suffer performance penalties for this modularity.
Reference: [4] <author> A. Bondorf. </author> <title> Automatic autoprojection of higher order recursive equations. </title> <editor> In N. D. Jones, editor, ESOP'90, </editor> <booktitle> 3 rd European Symposium on Programming, volume 432 of Lecture Notes in Computer Science, </booktitle> <pages> pages 70-87. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: However, existing approaches to partial evaluation identify only two stages at which information becomes available: compile time and run time. This problem is shared by existing partial evaluators such as Mix [14], Schism [8], and Sil-imix <ref> [4] </ref>. In an operating system, many more stages can be identified, including boot time, compile time, and link time. Therefore, we are working on progressive and incremental specialization using information about invariants gathered from a wide range of sources at many stages.
Reference: [5] <author> R.H. Campbell, N. Islam, and P. Madany. </author> <title> Choices, frameworks, and refinement. </title> <journal> Computing Systems, </journal> <volume> 5(3), </volume> <month> Summer </month> <year> 1992. </year>
Reference-contexts: Modular Operating SystemsMach, Chorus, Choices, Apertos: In response to the saturation of monolithic kernels, one of the most important developments in modern operating systems is the movement towards micro-kernels such as Mach [3] and Chorus [22], and more recently, object-oriented operating systems such as Choices <ref> [5] </ref> and Aper-tos [27]. All of these systems have a high degree of organization and modularity. However, they also suffer performance penalties for this modularity.
Reference: [6] <author> C. Consel and O. Danvy. </author> <title> Tutorial notes on partial evaluation. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 493-501, </pages> <year> 1993. </year>
Reference-contexts: However, they also suffer performance penalties for this modularity. More recent research on these systems has been focused on reducing the overhead of this modularity, typically by composing modules into coarser grain modules, and co-locating operating system servers in the kernel address space [11]. Partial Evaluation: Traditional partial evaluation <ref> [6, 15] </ref> specializes a program with respect to some known parts of its input, providing the basis for a simple and automatic approach to program optimization through specialization. However, existing approaches to partial evaluation identify only two stages at which information becomes available: compile time and run time.
Reference: [7] <author> C. Consel, C. Pu, and J. Walpole. </author> <title> Incremental specialization: The key to high performance, modularity and portability in operating systems. </title> <booktitle> In Proceedings of ACM Symposium on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <address> Copenhagen, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: These forces result in uncontrolled growth in the size and complexity of the kernel and the middleware. Specialization of the operating system kernel has emerged as a promising technique for addressing these problems; Synthesis [20, 18], the x-kernel [19], SPIN [1, 2], and Synthetix <ref> [7, 21] </ref> all allow the introduction of custom or specialized code into the kernel. However, there are two limitations to the wide application of specialization. First, although it has been applied successfully in specific domains, each domain seems different enough to require a large new effort.
Reference: [8] <author> Charles Consel. </author> <title> A Tour of Schism: A Partial Evaluation System for Higher-Order Applicative Languages. </title> <booktitle> In Proceedings of ACM Symposium on Partial Evaluation and Semantics-Based Program Manipulation (PEPM'93), </booktitle> <pages> pages 66-77, </pages> <address> Copenhagen, Denmark, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: However, existing approaches to partial evaluation identify only two stages at which information becomes available: compile time and run time. This problem is shared by existing partial evaluators such as Mix [14], Schism <ref> [8] </ref>, and Sil-imix [4]. In an operating system, many more stages can be identified, including boot time, compile time, and link time. Therefore, we are working on progressive and incremental specialization using information about invariants gathered from a wide range of sources at many stages.
Reference: [9] <author> Charles Consel, Luke Hornoff, Jacque Noye, Francois Noel, and Eugen-Nicolae Volanschi. </author> <title> A Uniform Approach for Compile-Time and Run-Time Specialization. </title> <booktitle> In International Workshop on Partial Evaluation, </booktitle> <address> Dagstuhl Castle, Germany, </address> <month> February </month> <year> 1996. </year> <note> Springer-Verlag LNCS. </note>
Reference-contexts: Most of these aspects are integrated in a partial evaluator for C, named Tempo, which enables programs to be specialized both at compile time and run time <ref> [9, 10] </ref>. 6 Summary We have described an approach to designing microlanguages that allow applications to declare their needs to the operating system and to inform the system of their future behavior.
Reference: [10] <author> Charles Consel and Francois Noel. </author> <title> A general approach to run-time specialization and its application to C. </title> <booktitle> In 23rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL'96), </booktitle> <address> St. Peters-burgh Beach, FL, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: Most of these aspects are integrated in a partial evaluator for C, named Tempo, which enables programs to be specialized both at compile time and run time <ref> [9, 10] </ref>. 6 Summary We have described an approach to designing microlanguages that allow applications to declare their needs to the operating system and to inform the system of their future behavior.
Reference: [11] <author> M. Guillemont, J. Lipkis, D. Orr, and M. Rozier. </author> <title> A second-generation micro-kernel based unix: Lessons in performance and compatibility. </title> <booktitle> In Proceedings of the Winter Technical USENIX Conference '91, </booktitle> <address> Dallas, </address> <year> 1991. </year>
Reference-contexts: However, they also suffer performance penalties for this modularity. More recent research on these systems has been focused on reducing the overhead of this modularity, typically by composing modules into coarser grain modules, and co-locating operating system servers in the kernel address space <ref> [11] </ref>. Partial Evaluation: Traditional partial evaluation [6, 15] specializes a program with respect to some known parts of its input, providing the basis for a simple and automatic approach to program optimization through specialization.
Reference: [12] <author> Jon Inouye, Ravindranath Konuru, Jonathan Walpole, and Bart Sears. </author> <title> The Effects of Virtually Addressed Caches on Virtual Memory Design & Performance. </title> <journal> Operating Systems Review, </journal> <volume> 24(4) </volume> <pages> 896-908, </pages> <month> October </month> <year> 1992. </year> <note> Also published as OGI technical report CSE-92-010, ftp://cse.ogi.edu/pub/tech-reports/1992/92-010.ps.gz. </note>
Reference-contexts: buffer, the kernel's file system buffers can be chosen to avoid which then drive a microengine that customizes the behavior of the system collisions in the CPU cache when the data is copied by the read () system call, yielding up to ten times performance improvements in data copying bandwidth <ref> [12, 13] </ref>. Simple striding patterns like these could just as easily be expressed using a grammar or a recurrence relation, which would obviate the need for the explicit loops. However, this is not always the case. Multimedia applications have more complex access patterns.
Reference: [13] <author> Jon Inouye, Jonathan Walpole, and Ke Zhang. </author> <title> Fast Byte Copying: A Re-Evaluation of the Opportunities for Optimization. </title> <type> Report CSE-95-010, </type> <institution> Oregon Graduate Institute, Portland, Oregon, </institution> <month> June </month> <year> 1995. ftp://cse.ogi.edu/pub/tech-reports/1995/95-010.ps.gz. </year>
Reference-contexts: buffer, the kernel's file system buffers can be chosen to avoid which then drive a microengine that customizes the behavior of the system collisions in the CPU cache when the data is copied by the read () system call, yielding up to ten times performance improvements in data copying bandwidth <ref> [12, 13] </ref>. Simple striding patterns like these could just as easily be expressed using a grammar or a recurrence relation, which would obviate the need for the explicit loops. However, this is not always the case. Multimedia applications have more complex access patterns.
Reference: [14] <author> N. D. Jones, P. Sestoft, and H. Sndergaard. </author> <title> Mix: a self-applicable partial evaluator for experiments in compiler generation. </title> <journal> LISP and Symbolic Computation, </journal> <volume> 2(1) </volume> <pages> 9-50, </pages> <year> 1989. </year>
Reference-contexts: However, existing approaches to partial evaluation identify only two stages at which information becomes available: compile time and run time. This problem is shared by existing partial evaluators such as Mix <ref> [14] </ref>, Schism [8], and Sil-imix [4]. In an operating system, many more stages can be identified, including boot time, compile time, and link time. Therefore, we are working on progressive and incremental specialization using information about invariants gathered from a wide range of sources at many stages.
Reference: [15] <author> N.D. Jones, C. Gomard, and P. Sestoft. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, </publisher> <month> June </month> <year> 1993. </year>
Reference-contexts: However, they also suffer performance penalties for this modularity. More recent research on these systems has been focused on reducing the overhead of this modularity, typically by composing modules into coarser grain modules, and co-locating operating system servers in the kernel address space [11]. Partial Evaluation: Traditional partial evaluation <ref> [6, 15] </ref> specializes a program with respect to some known parts of its input, providing the basis for a simple and automatic approach to program optimization through specialization. However, existing approaches to partial evaluation identify only two stages at which information becomes available: compile time and run time.
Reference: [16] <author> Gregor Kiczales. </author> <title> Beyond the Black Box: Open Implementation. </title> <journal> IEEE Software, </journal> <note> January 1996. http://www.parc.xerox.com/spl/projects/oi/ieee-software/. </note>
Reference-contexts: These tactics have appropriately been called hematomas of duplication and coding between the lines <ref> [16] </ref>. These forces result in uncontrolled growth in the size and complexity of the kernel and the middleware. <p> There is no consensus on the appropriate style for the definition of meta-object protocols: should they be highly restricted or should they allow generic programming? Arguments from both sides have been presented in a recent workshop on Open Implementation <ref> [16] </ref>. By calling our approach microlanguage instead of meta-interface or meta-object protocol, we are taking a clear position on the question of meta-interface style. We believe that, at least for critical code such as operating system kernels, application program use of meta-interfaces should be carefully restricted. <p> Thus we see that the x-kernel used what amounts to a single implementation of a low-level microlanguage. Meta-Object Protocols: Microlanguages are also related to Meta-Object Protocols [17] and the recent movement towards Open Implementation <ref> [16] </ref>. In an Open Implementation system, a meta-interface is added to the system's functional interface. The meta-interface is used to direct the underlying implementation to take the most suitable execution path.
Reference: [17] <author> Gregor Kiczales, Jim des Rivieres, and Daniel G. Bobrow. </author> <title> The Art of the Metaobject Protocol. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: Most of the time, the microlanguage does not change the kernel's functional interface. For example, a file system interface will still support read and write. Rather, the microlanguage will address the meta-interface (in the meta-object protocol sense <ref> [17] </ref>) of a system component. Using the microlanguage, the client will tell the operating system how the base functionality will be used. <p> Since the building blocks are relatively simple and static, their combination is the main source of expressiveness. We see microlanguages as a special kind of meta-interface in Meta-Object Protocols <ref> [17] </ref>. While the purpose of meta-object protocols is basically the same as microlanguages, i.e., to give clients more control over the underlying implementation, microlanguages are typically more restrictive by design. <p> Thus we see that the x-kernel used what amounts to a single implementation of a low-level microlanguage. Meta-Object Protocols: Microlanguages are also related to Meta-Object Protocols <ref> [17] </ref> and the recent movement towards Open Implementation [16]. In an Open Implementation system, a meta-interface is added to the system's functional interface. The meta-interface is used to direct the underlying implementation to take the most suitable execution path.
Reference: [18] <author> H. Massalin and C. Pu. </author> <title> Threads and input/output in the Synthesis kernel. </title> <booktitle> In Proceedings of the Twelfth Symposium on Operating Systems Principles, </booktitle> <pages> pages 191-201, </pages> <address> Arizona, </address> <month> December </month> <year> 1989. </year>
Reference-contexts: These tactics have appropriately been called hematomas of duplication and coding between the lines [16]. These forces result in uncontrolled growth in the size and complexity of the kernel and the middleware. Specialization of the operating system kernel has emerged as a promising technique for addressing these problems; Synthesis <ref> [20, 18] </ref>, the x-kernel [19], SPIN [1, 2], and Synthetix [7, 21] all allow the introduction of custom or specialized code into the kernel. However, there are two limitations to the wide application of specialization.
Reference: [19] <author> S. O'Malley and L. Peterson. </author> <title> A dynamic network architecture. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 10(2) </volume> <pages> 110-143, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: These forces result in uncontrolled growth in the size and complexity of the kernel and the middleware. Specialization of the operating system kernel has emerged as a promising technique for addressing these problems; Synthesis [20, 18], the x-kernel <ref> [19] </ref>, SPIN [1, 2], and Synthetix [7, 21] all allow the introduction of custom or specialized code into the kernel. However, there are two limitations to the wide application of specialization. <p> In contrast, microlanguages are designed to encapsulate information about specific application domains, so even though a microlanguage syntax may be small and simple, it typically has deep domain-specific semantics. The x-kernel <ref> [19] </ref> and Horus [26] both achieved clean modular decompositions of the kernel's communication function. The x-kernel carefully analyzed network protocols, dividing them into microprotocols that were composed at runtime to process messages in a flexible and efficient way.
Reference: [20] <author> C. Pu, H. Massalin, and J. Ioannidis. </author> <title> The Synthesis kernel. </title> <journal> Computing Systems, </journal> <volume> 1(1) </volume> <pages> 11-32, </pages> <month> Winter </month> <year> 1988. </year>
Reference-contexts: These tactics have appropriately been called hematomas of duplication and coding between the lines [16]. These forces result in uncontrolled growth in the size and complexity of the kernel and the middleware. Specialization of the operating system kernel has emerged as a promising technique for addressing these problems; Synthesis <ref> [20, 18] </ref>, the x-kernel [19], SPIN [1, 2], and Synthetix [7, 21] all allow the introduction of custom or specialized code into the kernel. However, there are two limitations to the wide application of specialization. <p> In particular, we intend that low-level microprograms be used to control the Synthetix specialization machinery. Specialization is an implementation technique that has been shown effective in the optimization of kernel calls <ref> [1, 2, 20, 21] </ref>. However, undisciplined use of specialization can increase the complexity of kernel code significantly.
Reference: [21] <author> Calton Pu, Tito Autrey, Andrew Black, Charles Consel, Crispin Cowan, Jon Inouye, Lakshmi Kethana, Jonathan Walpole, and Ke Zhang. </author> <title> Optimistic Incremental Specialization: Streamlining a Commercial Operating System. </title> <booktitle> In Symposium on Operating Systems Principles (SOSP), </booktitle> <address> Copper Mountain, Colorado, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: These forces result in uncontrolled growth in the size and complexity of the kernel and the middleware. Specialization of the operating system kernel has emerged as a promising technique for addressing these problems; Synthesis [20, 18], the x-kernel [19], SPIN [1, 2], and Synthetix <ref> [7, 21] </ref> all allow the introduction of custom or specialized code into the kernel. However, there are two limitations to the wide application of specialization. First, although it has been applied successfully in specific domains, each domain seems different enough to require a large new effort. <p> In particular, we intend that low-level microprograms be used to control the Synthetix specialization machinery. Specialization is an implementation technique that has been shown effective in the optimization of kernel calls <ref> [1, 2, 20, 21] </ref>. However, undisciplined use of specialization can increase the complexity of kernel code significantly. <p> with microlanguages, we will use the results to refine the language, the experiment and the system. 3 An Example Microlanguage To illustrate these concepts, we present an example microlanguage designed to describe the needs of a family of applications that use file systems, an area where we have significant experience <ref> [21] </ref>. We start with an application-level microlanguage, and then use a microcompiler to translate this to a system-level microlanguage primarily concerned with customizing OS implementation details.
Reference: [22] <author> M. Rozier, V. Abrossimov, F. Armand, I. Boule, M. Gien, M. Guillemont, F. Herrman, C. Kaiser, S. Langlois, P. Leonard, and W. Neuhauser. </author> <title> Overview of the Chorus distributed operating system. </title> <booktitle> In Proceedings of the Workshop on Micro-Kernels and Other Kernel Architectures, </booktitle> <pages> pages 39-69, </pages> <address> Seattle, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: Modular Operating SystemsMach, Chorus, Choices, Apertos: In response to the saturation of monolithic kernels, one of the most important developments in modern operating systems is the movement towards micro-kernels such as Mach [3] and Chorus <ref> [22] </ref>, and more recently, object-oriented operating systems such as Choices [5] and Aper-tos [27]. All of these systems have a high degree of organization and modularity. However, they also suffer performance penalties for this modularity.
Reference: [23] <author> D. A. Schmidt. </author> <title> Denotational Semantics: a Methodology for Language Development. </title> <publisher> Allyn and Bacon, Inc., </publisher> <year> 1986. </year>
Reference: [24] <author> Richard Staehli, Jonathan Walpole, and David Maier. </author> <title> Quality of Service Specifications for Multimedia Presentations. </title> <journal> Multimedia Systems, </journal> 3(5/6):251-263, November 1995. 
Reference-contexts: Because the frames are variable-sized (depending on the complexity of the image) the access pattern cannot be described using a simple expression; an index file must be used to predict the read size and the stride size. Furthermore, to guarantee Quality-of-Service, frames must be available at specific times <ref> [24] </ref>. Hence, this microprogram also specifies when the data will be read. The following microprogram uses the file descriptor index fd to specify the sequence of frames to read, their offsets in the file fd, and the times at which the read requests will be made.
Reference: [25] <author> R. D. Tennent. </author> <booktitle> Principles of Programming Languages. </booktitle> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference: [26] <author> Robbert van Renesse, Takako M. Hickey, and Kenneth P. Birman. </author> <title> Design and performance of Horus: A lightweight group communications system. </title> <type> Technical Report TR94-1442, </type> <institution> Cornell University, </institution> <address> Ithaca, New York, </address> <month> August </month> <year> 1994. </year>
Reference-contexts: In contrast, microlanguages are designed to encapsulate information about specific application domains, so even though a microlanguage syntax may be small and simple, it typically has deep domain-specific semantics. The x-kernel [19] and Horus <ref> [26] </ref> both achieved clean modular decompositions of the kernel's communication function. The x-kernel carefully analyzed network protocols, dividing them into microprotocols that were composed at runtime to process messages in a flexible and efficient way.
Reference: [27] <author> Y. Yokote. </author> <title> The Apertos reflective operating system: The concept and its implementation. </title> <booktitle> In OOPSLA '92 Conference Proceedings, </booktitle> <address> Vancouver, BC, Canada, </address> <month> October </month> <year> 1993. </year>
Reference-contexts: Modular Operating SystemsMach, Chorus, Choices, Apertos: In response to the saturation of monolithic kernels, one of the most important developments in modern operating systems is the movement towards micro-kernels such as Mach [3] and Chorus [22], and more recently, object-oriented operating systems such as Choices [5] and Aper-tos <ref> [27] </ref>. All of these systems have a high degree of organization and modularity. However, they also suffer performance penalties for this modularity.
References-found: 27

