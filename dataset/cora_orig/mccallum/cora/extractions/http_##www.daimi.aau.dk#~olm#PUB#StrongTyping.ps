URL: http://www.daimi.aau.dk/~olm/PUB/StrongTyping.ps
Refering-URL: http://www.daimi.aau.dk/~olm/PUB/
Root-URL: http://www.daimi.aau.dk
Title: Strong Typing of Object-Oriented Languages Revisited Presented at: Conference on Object-Oriented Programming, Systems, Languages, and
Author: Ole Lehrmann Madsen Boris Magnusson Birger Moller-Pedersen 
Address: bogade 34, DK-8200 Aarhus N, Denmark  PoBox 118, S-221 00 Lund, Sweden  P.O. Box 114, Blindern, N-0314 Oslo 3, Norway  
Affiliation: Computer Science Department, Aarhus University  Department of Computer Science, University of Lund  Norwegian Computing Center  Ottawa, Canada  
Pubnum: SLA/ECOOP'90,  
Email: E-mail: olmadsen@daimi.aau.dk  E-mail: boris@dna.lth.se  E-mail: birger@nr.no  
Phone: Tlf.: +45 89 42 56 70  Tlf.: +46 46 10 80 44  Tlf.: +47 2 45 35 00  
Date: October 1990  21-25 October 1990,  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> P.S. Canning, W.R. Cook, W.L. Hill, </author> <title> W.G. Olthoff: Interfaces for Strongly-Typed Object-Oriented Programming, In OOPSLA'89, Object-Oriented Programming Systems, </title> <journal> Languages and Applications, Sigplan Notices, </journal> <volume> Vol. 24, No. 10, </volume> <month> Oct. </month> <year> 1989 </year>
Reference-contexts: The issue of type checking in languages that has classes with type parameters have recently been the subject of several papers [2, 10, 11]. There has also been proposals for introducing a separate type system supplementary to the subclass hierarchy <ref> [1] </ref>. We will investigate these problems from the point of view taken in the Scandinavian school of object-oriented programming [4, 8, 12]. The class concept was introduced in Simula [3] and its motivation was to model concepts in the application domain. <p> Language constructs which can be used to reduce the amount of run-time checks in certain situations are also discussed. In addition some of the examples from <ref> [1] </ref> are shown in BETA. The notions of qualified references, remote access and reference assignment as described in section 2-4 are the same in BETA and Simula. <p> The reason is that virtual classes and procedures may only be extended in subclasses, and aFixedBusRegister is not a class, but an object. Note that aFixedBusRegister is in fact a type exact reference. 7 Subclassing versus subtyping In <ref> [1] </ref> it is claimed the need for a special interface inheritance hierarchy that is different from the class/subclass hierarchy, and that the interface hierarchy should be used for type checking purposes (and not the class/subclass hierarchy). The following example is the BETA version of some of the examples from [1], and <p> In <ref> [1] </ref> it is claimed the need for a special interface inheritance hierarchy that is different from the class/subclass hierarchy, and that the interface hierarchy should be used for type checking purposes (and not the class/subclass hierarchy). The following example is the BETA version of some of the examples from [1], and it demonstrates that it is possible to use the class/subclass hierarchy for type checking. As the previous examples in this paper it also introduces the need for run-time type checking. <p> This is because we try to compare a Point object and a ColorPoint object by executing the Equal procedure of the ColorPoint object with the Point object as the parameter P. As pointed out in <ref> [1] </ref> this would lead to evaluation of the expression P.c, with P denoting a Point object, and this is invalid because a Point object does not have an attribute c. The following is examples of situations where run-time checking may be avoided by using part objects. <p> Not allowing the type-demands to be strengthened. Adopting this attitude, the definition of class ColorPoint is wrong since it is strengthening the demands on the parameter P of the procedure Equal (and Move as well). This is the attitude taken in <ref> [1] </ref>. It has the effect that the above and many other programs will be illegal. In [1] it is phrased slightly different, the two classes Point and ColorPoint are found not to be type compatible. 2. Introducing references that are type exact. <p> This is the attitude taken in <ref> [1] </ref>. It has the effect that the above and many other programs will be illegal. In [1] it is phrased slightly different, the two classes Point and ColorPoint are found not to be type compatible. 2. Introducing references that are type exact. The effect of this possibility is shown above using part objects. All the expressions above are statically checkable. <p> Although type exact variables is a useful mechanism in many situations, we find it a too strong restriction to be the general case. To conclude this discussion we finally also show the BETA formulation of one other example in <ref> [1] </ref>. 23 Test: proc (# X,Y: ^ Point; enter (X [],Y []) exit X []-&gt;Y.Equal -a run-time check #); Since it is not statically known whether or not X and Y refer to instances of Point or ColorPoint it is necessary to perform a run-time check in the call X []-&gt;Y.Equal.
Reference: [2] <author> W. R. Cook: </author> <title> A Proposal for Making Eiffel Type Safe, </title> <booktitle> In ECOOP'89, European Conference on Object-Oriented Programming, </booktitle> <publisher> Cambridge University Press 1989. </publisher> <pages> 25 </pages>
Reference-contexts: 1 Introduction The purpose of this paper is to contribute to the clarification of typing issues in object-oriented languages. The issue of type checking in languages that has classes with type parameters have recently been the subject of several papers <ref> [2, 10, 11] </ref>. There has also been proposals for introducing a separate type system supplementary to the subclass hierarchy [1]. We will investigate these problems from the point of view taken in the Scandinavian school of object-oriented programming [4, 8, 12]. <p> Parameterized classes in combination with a hierarchical type- system are known to create complicated type checking situations <ref> [2, 10, 11] </ref>. Similar situations can be created with a variety of language constructs in most object-oriented languages. This paper is using the type system of BETA, which extends the type system of Simula, for illustrating the problems. <p> For these situations it works also in practice due to the possibility of dynamically strengthening the qualification of an object. This solution have also been proposed in <ref> [2] </ref> where it is suggested that it should not be allowed to strengthen the type demands in subclasses, but only weakening them. <p> In BETA a virtual class can be fixed in a subclass (see below) with the meaning that a declaration can not be further strengthen in a subclass. <ref> [2] </ref> suggests the technique with weakening the demands to be used also for classes with type parameters. Also here weakening is of questionable practical value. It should be noted that BETA offers this as an alternative, while [2] suggest this to be the only alternative. <p> the meaning that a declaration can not be further strengthen in a subclass. <ref> [2] </ref> suggests the technique with weakening the demands to be used also for classes with type parameters. Also here weakening is of questionable practical value. It should be noted that BETA offers this as an alternative, while [2] suggest this to be the only alternative. The second solution is exemplified with part objects in Beta and the suggested type-enforce rule in Eiffel. One can also consider to introduce a new kind of references which always denote objects belonging to exactly the declared class.
Reference: [3] <author> O.-J. Dahl and K. Nygaard: </author> <title> Simula-67 Common Base Language Pub--lication S-22, </title> <institution> Norwegian Computing Center, </institution> <address> Oslo 70, 72, </address> <month> 84. </month> <title> Current version: Programming Language - Simula, Swedish Standard SS.63.61.14, </title> <publisher> ISBN-91-7162-234-9 </publisher>
Reference-contexts: There has also been proposals for introducing a separate type system supplementary to the subclass hierarchy [1]. We will investigate these problems from the point of view taken in the Scandinavian school of object-oriented programming [4, 8, 12]. The class concept was introduced in Simula <ref> [3] </ref> and its motivation was to model concepts in the application domain. This lead to the introduction of subclassing mechanisms as a means to represent specialization and generalization hierarchies. Inheritance of properties in these hierarchies was the main motivation to introduce subclassing.
Reference: [4] <author> O.-J. Dahl and K. Nygaard: </author> <title> The Development of the Simula Languages, In History of Programming Languages, </title> <editor> ed. R. W. Wexelblat, </editor> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1981. </year>
Reference-contexts: There has also been proposals for introducing a separate type system supplementary to the subclass hierarchy [1]. We will investigate these problems from the point of view taken in the Scandinavian school of object-oriented programming <ref> [4, 8, 12] </ref>. The class concept was introduced in Simula [3] and its motivation was to model concepts in the application domain. This lead to the introduction of subclassing mechanisms as a means to represent specialization and generalization hierarchies. <p> The ability to weaken the type information on an object as in f3g is very usable in order to write general code like queue and list manipulation etc. The problem of managing a queue of Vehicles is described already in <ref> [4] </ref>. The result of a queue operation, like returning the first object, is such a weakly qualified reference. The possibility to explicitly 9 strengthen the type information again (as in f3g) is vital. This gives the programmer the possibility to view an object at different levels of abstraction.
Reference: [5] <author> A. Goldberg and D. Robson: </author> <title> Smalltalk-80: The Language and its Implementation, </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1983. </year>
Reference-contexts: Viewed as a modeling mechanism, subclassing was also taken to define a hierarchical type system. Types are defined explicitly which means that separate classes with the same internal structure define different types. This approach has been followed in Smalltalk <ref> [5] </ref>, Beta [7], C++ [15] and Eiffel [10]. Apart from being used for (1) modeling as originally intended, subclassing has also been used as a means of specifying (2) inheritance of code or "code sharing".
Reference: [6] <author> B.B. Kristensen, O.L. Madsen, B. Moller-Pedersen, K. Nygaard: </author> <title> Syntax Directed Program Modularization, In: Interactive Computing Systems (ed. </title> <editor> P. Degano, E. Sandewall), </editor> <publisher> North-Holland, </publisher> <year> 1983 </year>
Reference-contexts: Even though the BETA approach is to use the class/subclass hierarchy for type checking, this is not the same as to say that we do not want to distinguish between interface and implementation of a class. The language has a separate mechanism for that <ref> [6] </ref>, but this will not be covered here. The example demonstrates that it is possible to let a ColorPoint be a subclass of Point, and still have procedures local to Point, such as e.g. Equal, also work for objects of the subclass.
Reference: [7] <author> B.B. Kristensen, O.L. Madsen, B. Moller-Pedersen: </author> <title> The BETA Programming Language, In: B.D. </title> <editor> Shriver, P.Wegner (ed.), </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: Viewed as a modeling mechanism, subclassing was also taken to define a hierarchical type system. Types are defined explicitly which means that separate classes with the same internal structure define different types. This approach has been followed in Smalltalk [5], Beta <ref> [7] </ref>, C++ [15] and Eiffel [10]. Apart from being used for (1) modeling as originally intended, subclassing has also been used as a means of specifying (2) inheritance of code or "code sharing". <p> In relation to object-oriented programming this distinction is, however, crucial. 6 Classes with "type" parameters Virtual classes in BETA and generic classes in Eiffel makes it possible to define classes parameterized with other classes or types. These are very pow 1 See, however, <ref> [7] </ref> for a more precise description of value assignment 12 erful language mechanisms, but they also complicate the rules for checking the legality of assignments. The following examples show that subclassing and the rules for assignment associated with subclasses may well be used for expressing types of parameters.
Reference: [8] <author> O.L. Madsen and B. Moller-Pedersen: </author> <title> What Object-Oriented Programming may be | and what it does not have to be In ECOOP'88, </title> <booktitle> Euro-pean Conference on Object-Oriented Programming, Lecture Notes In Computer Science, </booktitle> <volume> Vol. 322, </volume> <publisher> Springer Verlag, </publisher> <year> 1988. </year>
Reference-contexts: There has also been proposals for introducing a separate type system supplementary to the subclass hierarchy [1]. We will investigate these problems from the point of view taken in the Scandinavian school of object-oriented programming <ref> [4, 8, 12] </ref>. The class concept was introduced in Simula [3] and its motivation was to model concepts in the application domain. This lead to the introduction of subclassing mechanisms as a means to represent specialization and generalization hierarchies.
Reference: [9] <author> O.L. Madsen and B. Moller-Pedersen: </author> <title> Virtual Classes | A Powerful Mechanism in Object-Oriented Programming, In OOPSLA'89, Object-Oriented Programming Systems, </title> <journal> Languages and Applications, Sigplan Notices, </journal> <volume> Vol. 24, No. 10, </volume> <month> Oct. </month> <year> 1989 </year>
Reference-contexts: This paper is using the type system of BETA, which extends the type system of Simula, for illustrating the problems. The extension allows for classes parameterized with classes (types) by means of so-called virtual classes as described in <ref> [9] </ref>. The type checking problems that arise in such situations are analyzed and alternative solutions are described. It is argued that an approach with a combination of static and dynamic type checking gives a reasonable balance also here, again avoiding a separate type system. <p> The notions of qualified references, remote access and reference assignment as described in section 2-4 are the same in BETA and Simula. The language notation used in this paper is a modified version of BETA similar to the notation used in <ref> [9] </ref>. 4 2 Qualified references Consider the following class hierarchy: Vehicle: class (# owner: @integer; licenseNo: @integer #); Bus: class Vehicle (# noOfSeats: @integer;#); Truck: class Vehicle (# tonnage: @integer #); Car: class Vehicle (# #); aVehicle: ^ Vehicle; aBus: ^ Bus; aTruck: ^ Truck; The classes Bus, Truck, and Car <p> In Point it would be defined as a virtual class, e.g. thisClass: virtual class Point and in ColorPoint it would be extended by thisClass: extended class ColorPoint See <ref> [9] </ref> for a further discussion of this. The above example illustrate the same problem as discussed in section 6. This time the construction ThisClass is the cause of qualification strengthening. The following examples of use of the classes will illustrate the type-checking problems.
Reference: [10] <author> B. Meyer: </author> <title> Object Oriented Software Construction, </title> <publisher> Prentice-Hall 1988 </publisher>
Reference-contexts: 1 Introduction The purpose of this paper is to contribute to the clarification of typing issues in object-oriented languages. The issue of type checking in languages that has classes with type parameters have recently been the subject of several papers <ref> [2, 10, 11] </ref>. There has also been proposals for introducing a separate type system supplementary to the subclass hierarchy [1]. We will investigate these problems from the point of view taken in the Scandinavian school of object-oriented programming [4, 8, 12]. <p> Viewed as a modeling mechanism, subclassing was also taken to define a hierarchical type system. Types are defined explicitly which means that separate classes with the same internal structure define different types. This approach has been followed in Smalltalk [5], Beta [7], C++ [15] and Eiffel <ref> [10] </ref>. Apart from being used for (1) modeling as originally intended, subclassing has also been used as a means of specifying (2) inheritance of code or "code sharing". <p> Parameterized classes in combination with a hierarchical type- system are known to create complicated type checking situations <ref> [2, 10, 11] </ref>. Similar situations can be created with a variety of language constructs in most object-oriented languages. This paper is using the type system of BETA, which extends the type system of Simula, for illustrating the problems.
Reference: [11] <author> B. Meyer: </author> <title> Static Typing for Eiffel. </title> <institution> Interactive Software Engineering Inc., </institution> <month> July 2, </month> <year> 1989 </year>
Reference-contexts: 1 Introduction The purpose of this paper is to contribute to the clarification of typing issues in object-oriented languages. The issue of type checking in languages that has classes with type parameters have recently been the subject of several papers <ref> [2, 10, 11] </ref>. There has also been proposals for introducing a separate type system supplementary to the subclass hierarchy [1]. We will investigate these problems from the point of view taken in the Scandinavian school of object-oriented programming [4, 8, 12]. <p> Parameterized classes in combination with a hierarchical type- system are known to create complicated type checking situations <ref> [2, 10, 11] </ref>. Similar situations can be created with a variety of language constructs in most object-oriented languages. This paper is using the type system of BETA, which extends the type system of Simula, for illustrating the problems. <p> Full dataflow analysis is not possible, but a limited form, only targeted to recognize the case when a reference can be guaranteed to have exactly its declared qualification has been proposed for Eiffel <ref> [11] </ref>. This effect can also be achieved in Beta with part objects that are statically allocated. (See below). In [13] the same effect is achieved for so-called homogeneous variables which are type exact. The type checking problem described above is general and occurs in a couple of different language constructions. <p> All the expressions above are statically checkable. If this is the only alternative we can not write general code managing ColorPoints (and possibly many other sub classes) as Points which is of great practical value. This is also the effect of the suggested restriction for Eiffel <ref> [11] </ref>. The proposal in [13] for homogeneous variables is another example of this. Although type exact variables is a useful mechanism in many situations, we find it a too strong restriction to be the general case.
Reference: [12] <author> K. Nygaard: </author> <title> Basic Concepts in Object Oriented Programming, </title> <journal> Sigplan Notices, </journal> <volume> Vol. 21, No. 10, </volume> <month> 128-132 (October </month> <year> 1986). </year> <month> 26 </month>
Reference-contexts: There has also been proposals for introducing a separate type system supplementary to the subclass hierarchy [1]. We will investigate these problems from the point of view taken in the Scandinavian school of object-oriented programming <ref> [4, 8, 12] </ref>. The class concept was introduced in Simula [3] and its motivation was to model concepts in the application domain. This lead to the introduction of subclassing mechanisms as a means to represent specialization and generalization hierarchies.
Reference: [13] <author> J. Palsberg. M. I. Schwartzbach: </author> <title> Substitution Polymorphism for Object-Oriented Programming, In OOPSLA/ECOOP'90, Object-Oriented Programming Systems, </title> <journal> Languages and Applications, Sigplan Notices, </journal> <year> 1990. </year>
Reference-contexts: This effect can also be achieved in Beta with part objects that are statically allocated. (See below). In <ref> [13] </ref> the same effect is achieved for so-called homogeneous variables which are type exact. The type checking problem described above is general and occurs in a couple of different language constructions. The use of virtual qualification was chosen to illustrate the problem above. <p> If this is the only alternative we can not write general code managing ColorPoints (and possibly many other sub classes) as Points which is of great practical value. This is also the effect of the suggested restriction for Eiffel [11]. The proposal in <ref> [13] </ref> for homogeneous variables is another example of this. Although type exact variables is a useful mechanism in many situations, we find it a too strong restriction to be the general case.
Reference: [14] <author> C. Schaffert et. al: </author> <title> An Introduction to Trellis/Owl, In OOPSLA86, Object-Oriented Programming Systems, </title> <journal> Languages and Applications, Sigplan Notices, </journal> <volume> Vol. 21, No. 11, </volume> <month> Nov. </month> <year> 1986. </year>
Reference-contexts: This solution have also been proposed in [2] where it is suggested that it should not be allowed to strengthen the type demands in subclasses, but only weakening them. Weakening type-constraints is also possible in Trellis/Owl <ref> [14] </ref>, but seems to be of very limited practical value and will in practice mean that a fixed type will be used.
Reference: [15] <author> B. Stroustrup: </author> <title> The C++ Programming Language, </title> <publisher> Addison Wesley, </publisher> <year> 1986. </year>
Reference-contexts: Viewed as a modeling mechanism, subclassing was also taken to define a hierarchical type system. Types are defined explicitly which means that separate classes with the same internal structure define different types. This approach has been followed in Smalltalk [5], Beta [7], C++ <ref> [15] </ref> and Eiffel [10]. Apart from being used for (1) modeling as originally intended, subclassing has also been used as a means of specifying (2) inheritance of code or "code sharing".
Reference: [16] <author> N. </author> <title> Wirth : The Programming Language Pascal, </title> <journal> Acta Informatica 1, </journal> <year> 1971, </year> <pages> 35-63. </pages>
Reference-contexts: A perfectly strongly typed language would exclusively have expressions where its type carries all information about the denoted object. We are not aware of any such object-oriented language although some other languages come close <ref> [16] </ref>. Languages with a hierarchical type system and qualified references serve as a compromise since some, but not necessarily all, operations on an object can be inferred from the qualification of the reference.
References-found: 16

