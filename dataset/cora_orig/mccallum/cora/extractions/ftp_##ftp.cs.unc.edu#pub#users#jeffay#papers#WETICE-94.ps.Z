URL: ftp://ftp.cs.unc.edu/pub/users/jeffay/papers/WETICE-94.ps.Z
Refering-URL: http://www.cs.unc.edu/Research/sw.html
Root-URL: http://www.cs.unc.edu
Email: -menges,jeffay-@cs.unc.edu  
Title: In: Proc., Third Workshop on Enabling Technologies: Infrastructure for Collaborative Inverting X: An Architecture for
Author: John Menges Kevin Jeffay 
Address: Chapel Hill, NC 27599-3175  
Affiliation: Department of Computer Science University of North Carolina at Chapel Hill  
Note: Enterprises, Morgantown, WV, April 1994, IEEE Computer Society Press, pp. 53-64.  
Abstract: Shared window systems have become a popular vehicle for supporting distributed, synchronous collaboration. At present they are difficult to build and they support limited paradigms of multiuser interaction with shared applications. We believe this difficulty is largely due to the inverted nature of the client/server architecture of most distributed window systems. The architecture is inverted in the sense that the user is nearer the server than the client; this hampers attempts to share windows. By comparing the traditional client/server architecture of distributed file systems with the inverted architecture of distributed window systems we argue that it is possible to develop window systems where the user is nearer window system clients than servers, and that this architecture greatly facilitates the sharing of windows among users. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. M. Abdel-Wahab and Mark A. Feit. XTV: </author> <title> A Framework for Sharing X Window Clients in Remote Synchronous Collaboration. </title> <booktitle> In Proceedings of Tricomm 91, </booktitle> <month> April </month> <year> 1991. </year>
Reference-contexts: Sharable widgets could be directly manipulated by applications. 4.2. Shared Window Systems Many attempts have been made to implement window sharing using the X Window System: SharedX [7], Shadows [15], and XTV <ref> [1] </ref>, to name a few. Some are implemented as modified window system libraries; as such they need to be linked into an existing application. Most, however, are implemented as XPSes.
Reference: [2] <author> Hussein M. Abdel-Wahab and Kevin Jeffay. </author> <title> Issues, Problems, and Solutions in Sharing X Clients on Multiple Displays. </title> <journal> Internetworking Research and Practice, </journal> <volume> 5(1), </volume> <month> (March </month> <year> 1994) </year> <month> pp. </month> <pages> 1-15. </pages>
Reference-contexts: Some are implemented as modified window system libraries; as such they need to be linked into an existing application. Most, however, are implemented as XPSes. The problems encountered when designing and implementing X-based shared window systems are many, but they are fairly well known and documented <ref> [15, 16, 9, 10, 2] </ref>. They include both problems regarding design decisions and problems in implementing chosen designs. (Implementability, of course, affects the design decisions that are possible.) Design decisions for shared window systems include: Floor control. Who can interact with a window at a given point in time? Annotation.
Reference: [3] <author> John Eric Baldeschweiler, Thomas Gutekunst, and Bernhard Plattner. </author> <title> A survey of X Protocol Multiplexors. </title> <journal> ACM SIGCOMM Computer Communication Review, </journal> <pages> pages 16-24, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: XPSes can be difficult to design, implement, and maintain. Attempts to date have resulted in systems that are large and complex but low in function and reliability <ref> [3] </ref>. XPEA was developed to provide an organizing framework for the design of XPSes. XPEL supports the XPEA architecture and dramatically simplifies the implementation of XPSes by enabling the programmer to work at a higher level of abstraction and by encouraging code reuse. <p> when they are multiplexed), how can the sequence numbers be kept correct so clients dont get confused? Even though these problems have been known for some time, existing windowsharing systems continue to be large, complex, and unreliable, while they are difficult to use and the features they support are few <ref> [3] </ref>. Why is this the case? We suggest the following three reasons: Lack of a Good XPS Architecture. Even when the set of problems and their solutions are well known, combining them into a functioning shared-window system is complex.
Reference: [4] <author> Goopeel Chung, Kevin Jeffay, and Hussein M. Abdel-Wahab. </author> <title> Dynamic Participation in a Computer-based Conferencing System. </title> <journal> Computer Communications, </journal> <note> 17(1), (January 1994) pp. 7-16. </note>
Reference-contexts: How can a new participant be added to the set of users sharing a set of windows after a conference has begun <ref> [4] </ref>? How can a non-shared window be made sharable (and vice-versa)? How can a user move a window from one display to another (park it and pick it up elsewhere)? These are all similar problems with similar solutions. Heterogeneity. How can we accommodate displays with different capabilities? Window Damage Control.
Reference: [5] <author> Terrence Crowley, Paul Milazzo, Ellie Baker, Harry Forsdick, and Raymond Tomlinson. MMConf: </author> <title> An Infrastructure for Building Shared Multimedia Applications. </title> <booktitle> In CSCW 90 Proceedings, </booktitle> <year> 1990. </year>
Reference-contexts: It is sometimes possible to keep collaboration awareness out of the toolkits programming interface, thus removing it from the application proper. A number of collaboration support systems ( e.g., Rendezvous [17], MMConf <ref> [5] </ref>, and Suite [6]) facilitate the development of collaboration-aware applications via language extensions or toolkits that allow the programmer to develop his applications at a high level of abstraction, leaving details such as synchronization and shared state management to the support system.
Reference: [6] <author> Prasun Dewan and Rajiv Choudhary. </author> <title> Flexible Interface Coupling in a Collaborative System. </title> <booktitle> In Proceedings ACM CHI 91 , pages 41-48, </booktitle> <address> New Orleans, LA, </address> <month> April </month> <year> 1991. </year>
Reference-contexts: It is sometimes possible to keep collaboration awareness out of the toolkits programming interface, thus removing it from the application proper. A number of collaboration support systems ( e.g., Rendezvous [17], MMConf [5], and Suite <ref> [6] </ref>) facilitate the development of collaboration-aware applications via language extensions or toolkits that allow the programmer to develop his applications at a high level of abstraction, leaving details such as synchronization and shared state management to the support system. <p> What should be the cut and paste semantics in a shared window environment? Window Sharing Granularity. Are all the windows associated with an application shared as a unit, or top level windows individually, or all windows individually? Window attribute coupling <ref> [6] </ref>. To what degree is there flexible coupling in the sharing of window attributes, both structural ( e.g., subwindow arrangement) and non-structural (e.g., colors)? Implementation issues include: Latecomers, Spontaneous Sharing, and User Migration.
Reference: [7] <author> P. Gust. </author> <title> Shared X: X in a Distributed Group Work Environment. </title> <note> Unpublished paper presented at the Second Annual X Technical Conference, </note> <month> January </month> <year> 1988. </year>
Reference-contexts: Sharable widgets could be directly manipulated by applications. 4.2. Shared Window Systems Many attempts have been made to implement window sharing using the X Window System: SharedX <ref> [7] </ref>, Shadows [15], and XTV [1], to name a few. Some are implemented as modified window system libraries; as such they need to be linked into an existing application. Most, however, are implemented as XPSes.
Reference: [8] <author> Norman C. Hutchinson and Larry L. Peterson. </author> <title> The x-Kernel: An Architecture f or Implementing Network Protocols. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(1) </volume> <pages> 64-76, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: XPEA is an objectoriented architecture that uses a model of interconnected protocol manipulation filters, like that sometimes used in the implementation of inter-process communication facilities <ref> [12, 8, 14, 18] </ref>. The task of implementing a particular window system capability can be broken down into component tasks performed by small filters. These filters can then be combined in series to accomplish the larger task (Figure 14). <p> It also points the way toward how a complete SDWS might be implemented. 4.2. Other Filter-Based Architectures. Filter-based protocol manipulation systems like XPEL have been used in several inter-process communication (IPC) facility implementations. Three of these are the x-Kernel <ref> [8] </ref>, Packet Filters [14], and Eighth Edition Unix Streams [18]. (For a detailed comparison of XPEL and these systems, see [12].) Briefly, the high-level architectures of all four systems are similar; all use a network of filter-manipulation objects through which message streams are passed and by which they are manipulated.
Reference: [9] <author> J. Chris Lauwers. </author> <title> Collaboration Transparency in Desktop Teleconferencing Environments. </title> <type> Technical Report CSL-TR-90-435, </type> <institution> Computer Systems Laboratory, Departments of Electrical Engineering 11 and Computer Science, Stanford University, Stanford, </institution> <address> California 94305-4055, </address> <month> July </month> <year> 1990. </year>
Reference-contexts: Some are implemented as modified window system libraries; as such they need to be linked into an existing application. Most, however, are implemented as XPSes. The problems encountered when designing and implementing X-based shared window systems are many, but they are fairly well known and documented <ref> [15, 16, 9, 10, 2] </ref>. They include both problems regarding design decisions and problems in implementing chosen designs. (Implementability, of course, affects the design decisions that are possible.) Design decisions for shared window systems include: Floor control. Who can interact with a window at a given point in time? Annotation.
Reference: [10] <author> J. Chris Lauwers and Keith A. Lantz. </author> <title> Collaboration Awareness in Support of Collaboration Transparency: Requirements for the Next Generation of Shared Window Systems. </title> <booktitle> In CHI 90 Proceedings, </booktitle> <year> 1990. </year>
Reference-contexts: Some are implemented as modified window system libraries; as such they need to be linked into an existing application. Most, however, are implemented as XPSes. The problems encountered when designing and implementing X-based shared window systems are many, but they are fairly well known and documented <ref> [15, 16, 9, 10, 2] </ref>. They include both problems regarding design decisions and problems in implementing chosen designs. (Implementability, of course, affects the design decisions that are possible.) Design decisions for shared window systems include: Floor control. Who can interact with a window at a given point in time? Annotation.
Reference: [11] <author> Jin-Kun Lin. </author> <title> Virtual Screen: A Framework for Task Management. </title> <booktitle> In Proceeding s of the Sixth Annual X Technical Conference, </booktitle> <month> January </month> <year> 1992. </year>
Reference-contexts: Can a user make notes over the top of a window? Telepointing. How many pointers are visible to all users? None? One? One per user? Workspace Management. Can shared windows be independently positioned by each user, or is a whole workspace containing multiple windows shared <ref> [11] </ref>? Cut and Paste. What should be the cut and paste semantics in a shared window environment? Window Sharing Granularity. Are all the windows associated with an application shared as a unit, or top level windows individually, or all windows individually? Window attribute coupling [6].
Reference: [12] <author> John Menges. </author> <title> A Comparison of the Architectures of the X Protocol Engine Library and Three Related Systems. </title> <type> Technical Report TR93-047, </type> <institution> University of North Carolina, Chapel Hill, North Carolina, </institution> <month> May </month> <year> 1993. </year>
Reference-contexts: XPEA is an objectoriented architecture that uses a model of interconnected protocol manipulation filters, like that sometimes used in the implementation of inter-process communication facilities <ref> [12, 8, 14, 18] </ref>. The task of implementing a particular window system capability can be broken down into component tasks performed by small filters. These filters can then be combined in series to accomplish the larger task (Figure 14). <p> Other Filter-Based Architectures. Filter-based protocol manipulation systems like XPEL have been used in several inter-process communication (IPC) facility implementations. Three of these are the x-Kernel [8], Packet Filters [14], and Eighth Edition Unix Streams [18]. (For a detailed comparison of XPEL and these systems, see <ref> [12] </ref>.) Briefly, the high-level architectures of all four systems are similar; all use a network of filter-manipulation objects through which message streams are passed and by which they are manipulated. XPEL, because it is the latest of the systems to be designed, makes better use of objectoriented concepts.
Reference: [13] <author> John Menges. </author> <title> The X Engine Library: A C++ Library for Constructing X Pseudo Servers. </title> <booktitle> In Proceedings of the Seventh Annual X Technical Conference , January 1993, </booktitle> <pages> pp. 129-141. </pages>
Reference-contexts: Overall Implementation Strategy We now describe the overall implementation of our SDWS prototype. The system uses the X Protocol Engine Library (XPEL) <ref> [13] </ref>, a C++ class library weve developed for constructing X pseudo-servers (XPSes). The prototype SDWS is built top of the existing X Window System, utilizing existing X clients and servers.
Reference: [14] <author> Jeffrey C. Mogul, Richard F. Rashid, and Michael J. Accetta. </author> <title> The Packet Filter: An Efficient Mechanism for User-level Network Code. </title> <booktitle> In Proceedings of the Eleventh ACM Symposium on Operating System Principles, </booktitle> <pages> pages 39-51, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: XPEA is an objectoriented architecture that uses a model of interconnected protocol manipulation filters, like that sometimes used in the implementation of inter-process communication facilities <ref> [12, 8, 14, 18] </ref>. The task of implementing a particular window system capability can be broken down into component tasks performed by small filters. These filters can then be combined in series to accomplish the larger task (Figure 14). <p> It also points the way toward how a complete SDWS might be implemented. 4.2. Other Filter-Based Architectures. Filter-based protocol manipulation systems like XPEL have been used in several inter-process communication (IPC) facility implementations. Three of these are the x-Kernel [8], Packet Filters <ref> [14] </ref>, and Eighth Edition Unix Streams [18]. (For a detailed comparison of XPEL and these systems, see [12].) Briefly, the high-level architectures of all four systems are similar; all use a network of filter-manipulation objects through which message streams are passed and by which they are manipulated.
Reference: [15] <author> J. F. Patterson. </author> <title> The Good, the Bad, and the Ugly of Window Sharing in X. </title> <booktitle> In Proceedings of the Fourth Annual X Technical Conference, </booktitle> <month> January </month> <year> 1990. </year>
Reference-contexts: Sharable widgets could be directly manipulated by applications. 4.2. Shared Window Systems Many attempts have been made to implement window sharing using the X Window System: SharedX [7], Shadows <ref> [15] </ref>, and XTV [1], to name a few. Some are implemented as modified window system libraries; as such they need to be linked into an existing application. Most, however, are implemented as XPSes. <p> Some are implemented as modified window system libraries; as such they need to be linked into an existing application. Most, however, are implemented as XPSes. The problems encountered when designing and implementing X-based shared window systems are many, but they are fairly well known and documented <ref> [15, 16, 9, 10, 2] </ref>. They include both problems regarding design decisions and problems in implementing chosen designs. (Implementability, of course, affects the design decisions that are possible.) Design decisions for shared window systems include: Floor control. Who can interact with a window at a given point in time? Annotation.
Reference: [16] <author> John F. Patterson. </author> <title> What Does Window Sharing Say About Virtual Terminals? Unpublished paper written at Bellcore. </title>
Reference-contexts: Some are implemented as modified window system libraries; as such they need to be linked into an existing application. Most, however, are implemented as XPSes. The problems encountered when designing and implementing X-based shared window systems are many, but they are fairly well known and documented <ref> [15, 16, 9, 10, 2] </ref>. They include both problems regarding design decisions and problems in implementing chosen designs. (Implementability, of course, affects the design decisions that are possible.) Design decisions for shared window systems include: Floor control. Who can interact with a window at a given point in time? Annotation.
Reference: [17] <author> John F. Patterson, Ralph D. Hill, Steven L. Rohall, and Scott W. Meeks. </author> <title> Rendezvous: An Architecture for Synchronous MultiUser Applications. </title> <booktitle> In CSCW 90 Proceedings, </booktitle> <year> 1990. </year>
Reference-contexts: It is sometimes possible to keep collaboration awareness out of the toolkits programming interface, thus removing it from the application proper. A number of collaboration support systems ( e.g., Rendezvous <ref> [17] </ref>, MMConf [5], and Suite [6]) facilitate the development of collaboration-aware applications via language extensions or toolkits that allow the programmer to develop his applications at a high level of abstraction, leaving details such as synchronization and shared state management to the support system.
Reference: [18] <author> D. L. Presotto and D. M. Ritchie. </author> <title> Interprocess Communication in the Eighth Edition Unix System. </title> <booktitle> In Proceedings of the 1985 USENIX Association Summer Conference, </booktitle> <month> pages 309-316 , June </month> <year> 1985. </year>
Reference-contexts: XPEA is an objectoriented architecture that uses a model of interconnected protocol manipulation filters, like that sometimes used in the implementation of inter-process communication facilities <ref> [12, 8, 14, 18] </ref>. The task of implementing a particular window system capability can be broken down into component tasks performed by small filters. These filters can then be combined in series to accomplish the larger task (Figure 14). <p> It also points the way toward how a complete SDWS might be implemented. 4.2. Other Filter-Based Architectures. Filter-based protocol manipulation systems like XPEL have been used in several inter-process communication (IPC) facility implementations. Three of these are the x-Kernel [8], Packet Filters [14], and Eighth Edition Unix Streams <ref> [18] </ref>. (For a detailed comparison of XPEL and these systems, see [12].) Briefly, the high-level architectures of all four systems are similar; all use a network of filter-manipulation objects through which message streams are passed and by which they are manipulated.
References-found: 18

