URL: http://www.daimi.aau.dk/~mis/typeinf.ps
Refering-URL: http://www.daimi.aau.dk/~mis/teaching.html
Root-URL: http://www.daimi.aau.dk
Email: http://www.daimi.aau.dk/~mis  
Title: Polymorphic Type Inference  
Author: Michael I. Schwartzbach 
Date: March 1995 Preface  
Abstract: In this lecture we will present a tiny functional language and gradually enrich its type system. We shall cover the basic Curry-Hindley system and Wand's constraint-based algorithm for monomorphic type inference; briefly observe the Curry-Howard isomorphism and notice that logical formalism may serve as the inspiration for new type rules; present the polymorphic Milner system and the Damas-Milner algorithm for polymorphic type inference; see the Milner-Mycroft system for polymorphic recursion; and sketch the development of higher type systems. We will touch upon the relationship between types and logic and show how rules from logic may give inspiration for new type rules. En route we shall encounter the curious discovery that two algorithmic problems for type systems, which have been implemented in popular programming languages, have turned out to be respectively complete for exponential time and undecidable. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Luis Damas and Robin Milner. </author> <title> Principal type schemes for functional programming. </title> <booktitle> In 9th Symposium on Principles of Programming Languages, </booktitle> <year> 1982. </year>
Reference-contexts: This is essentially the Damas-Milner <ref> [1] </ref> algorithm from 1982 which is implemented in the ML system. For almost ten years it was folklore that this algorithm had low polynomial time complexity. This also corresponded well with the practical experiences of ML programmers.
Reference: [2] <author> F. Henglein. </author> <title> Type inference with polymorphic recursion. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15, </volume> <year> 1993. </year>
Reference-contexts: A corresponding type inference algorithm must necessarily be more obscure than the earlier one, since the naive expansion of let-definitions may now yield infinite monomorphic versions. Yet, implementations did exist for versions of the ML language. Thus it caused some concern when Henglein <ref> [2] </ref> and Kfoury, Tiuryn, and Urzyczyn [5] in 1990 simultaneously proved that the type inference problem is in fact undecidable. The problem seems to obey the laws of cartoon physics, since people were perfectly happy with the proposed implementations before the undecidability was known.
Reference: [3] <author> P. Kanellakis and J. Mitchell. </author> <title> Polymorphic unification and ML typing. </title> <booktitle> In 16th Symposium on Principles of Programming Languages. </booktitle> <publisher> ACM Press, </publisher> <month> January </month> <year> 1989. </year>
Reference-contexts: His proof is an awesome construction of an ML program that directly simulates a given deterministic Turing machine running in exponential time, and where typability of the program coincides with acceptance by the machine. PSPACE-hardness alone was proved by Kanellakis and Mitchell <ref> [3] </ref> earlier in 1989. In spite of this nasty result, implementations of the ML language seem to be running very well in everyday life. But danger lurks beneath the surface.
Reference: [4] <author> A. J. Kfoury, J. Tiuryn, and P. Urzyczyn. </author> <title> Ml typability is DEXPTIME-complete. </title> <booktitle> In 15th Colloquium on Trees in Algebra and Programming. </booktitle> <publisher> Springer-Verlag, </publisher> <month> May </month> <year> 1990. </year>
Reference-contexts: For almost ten years it was folklore that this algorithm had low polynomial time complexity. This also corresponded well with the practical experiences of ML programmers. This belief was thorougly shattered when Kfoury, Tiuryn, and Urzyczyn <ref> [4] </ref> and Mairson [6] in 1989 simultaneously proved that the polymorphic type inference problem is complete for exponential time. This means that any correct implementation must use an exponential amount of time on 16 infinitely many inputs.
Reference: [5] <author> A. J. Kfoury, J. Tiuryn, and P. Urzyczyn. </author> <title> Type reconstruction in the presence of polymorphic recursion. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15, </volume> <year> 1993. </year>
Reference-contexts: A corresponding type inference algorithm must necessarily be more obscure than the earlier one, since the naive expansion of let-definitions may now yield infinite monomorphic versions. Yet, implementations did exist for versions of the ML language. Thus it caused some concern when Henglein [2] and Kfoury, Tiuryn, and Urzyczyn <ref> [5] </ref> in 1990 simultaneously proved that the type inference problem is in fact undecidable. The problem seems to obey the laws of cartoon physics, since people were perfectly happy with the proposed implementations before the undecidability was known.
Reference: [6] <author> Harry G. Mairson. </author> <title> Decidability of ML typing is complete for deterministic exponential time. </title> <booktitle> In 17th Symposium on Principles of Programming Languages. </booktitle> <publisher> ACM Press, </publisher> <month> January </month> <year> 1990. </year>
Reference-contexts: For almost ten years it was folklore that this algorithm had low polynomial time complexity. This also corresponded well with the practical experiences of ML programmers. This belief was thorougly shattered when Kfoury, Tiuryn, and Urzyczyn [4] and Mairson <ref> [6] </ref> in 1989 simultaneously proved that the polymorphic type inference problem is complete for exponential time. This means that any correct implementation must use an exponential amount of time on 16 infinitely many inputs.
Reference: [7] <author> Robin Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17, </volume> <year> 1978. </year>
Reference: [8] <author> A. Mycroft. </author> <title> Polymorphic type schemes and recursive definitions. </title> <booktitle> In 6th International Conference on Programming. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: However, this can be remedied by a minor change in our type rule. A,f : 8 ff:oe ` e 1 : oe; A,f : 8 ff:oe ` e 2 : o ff 62 A Exercise 8.3 What has been changed in the type rule? 2 This is the Milner-Mycroft <ref> [8] </ref> type system from 1984. A corresponding type inference algorithm must necessarily be more obscure than the earlier one, since the naive expansion of let-definitions may now yield infinite monomorphic versions. Yet, implementations did exist for versions of the ML language.
Reference: [9] <author> M. S. Paterson and M. N. Wegman. </author> <title> Linear unification. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 16, </volume> <year> 1978. </year>
Reference: [10] <author> J. A. Robinson. </author> <title> A machine-oriented logic based on the resolution principle. </title> <journal> Journal of the ACM, </journal> <volume> 12, </volume> <year> 1965. </year>

References-found: 10

