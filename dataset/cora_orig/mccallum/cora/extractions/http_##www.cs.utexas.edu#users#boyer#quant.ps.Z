URL: http://www.cs.utexas.edu/users/boyer/quant.ps.Z
Refering-URL: http://www.cs.utexas.edu/users/moore/publications/index.html
Root-URL: 
Title: The Addition of Bounded Quantification and Partial Functions to A Computational Logic and Its Theorem Prover  
Author: Robert S. Boyer and J Strother Moore 
Address: Austin, Texas 78712  
Affiliation: Institute for Computing Science and Computer Applications The University of Texas at Austin  
Date: January, 1987  
Pubnum: ICSCA-CMP-52  
Abstract: The research reported here was supported by the Venture Research Unit of British Petroleum, Ltd., London, National Science Foundation Grant MCS-8202943, and Office of Naval Research Contract N00014-81-K-0634. 
Abstract-found: 1
Intro-found: 1
Reference: <institution> i Table of Contents </institution>
Reference: 1. <institution> Introduction 1 </institution>
Reference-contexts: The two cases are similar and we show only the case where the condition is non-F. We will transform the left-hand side of our induction conclusion into the right-hand side: (FOR I (CONS K L) COND 'SUM (LIST 'PLUS G H) A) = <ref> [1] </ref> (PLUS (EVAL (LIST 'PLUS G H) s) (FOR I L COND 'SUM (LIST 'PLUS G H) A)) = [2] (PLUS (PLUS (EVAL G s) (EVAL H s)) (FOR I L COND 'SUM (LIST 'PLUS G H) A)) = [3] (PLUS (PLUS (EVAL G s) (EVAL H s)) (PLUS (FOR I <p> This is true because the CDR of a non-LISTP -- and thus of 0 -- is 0. 6 Proof. Assume the contrary; i.e., APP@val (FOPEN)&lt;0,1&gt;, &lt;Y,0&gt;@val (FCLOSE) @val (NE) F. Let s be (LIST (CONS 'X 0) (CONS 'Y Y)). Then c.APP@val (FOPEN)&lt;0,1&gt;, <Y,0>@val (FCLOSE) &gt; <ref> [1] </ref> c.[(IF (EQUAL X 'NIL) Y (CONS (CAR X) (APP (CDR X) Y))),s] &gt; [2] c.[(CONS (CAR X) (APP (CDR X) Y)),s] = [3] c.CONS@val (FOPEN)[(CAR X),s],[(APP (CDR X) Y),s]@val (FCLOSE) = [4] c.CONS@val (FOPEN)[(CAR X),s],APP@val (FOPEN)[(CDR X),s],[Y,s]@val (FC = [5] c.CONS@val (FOPEN)[(CAR X),s],APP (&lt;0,1&gt;,<Y,0>)@val (FCLOSE) &gt; [6] c.APP@val (FOPEN)&lt;0,1&gt;,<Y,0>@val (FCLOSE). <p> Then, appealing to the just derived chain of definedness results we can derive the value of (APP X Y): 27 = <ref> [1] </ref> v.[(IF (EQUAL X 'NIL) Y (CONS (CAR X) (APP (CDR X) Y)))] v.[(CONS (CAR X) (APP (CDR X) Y))] = [3] v.CONS@val (FOPEN)[(CAR X)],[(APP (CDR X) Y)]@val (FCLOSE) = [4] (CONS v.[(CAR X)] v.[(APP (CDR X) Y)]) = [5] (CONS (CAR X) v.[(APP (CDR X) Y)]) = [6] (CONS (CAR
Reference: 2. <author> Background: </author> <title> The Unquantified Logic, Its Theorem Prover and 8 Capabilities 2.1. </title> <booktitle> The Unquantified Logic 9 2.2. The Mechanization of the Unquantified Logic 10 2.3. Capabilities of the Unquantified Theorem Prover 11 </booktitle>
Reference-contexts: We will transform the left-hand side of our induction conclusion into the right-hand side: (FOR I (CONS K L) COND 'SUM (LIST 'PLUS G H) A) = [1] (PLUS (EVAL (LIST 'PLUS G H) s) (FOR I L COND 'SUM (LIST 'PLUS G H) A)) = <ref> [2] </ref> (PLUS (PLUS (EVAL G s) (EVAL H s)) (FOR I L COND 'SUM (LIST 'PLUS G H) A)) = [3] (PLUS (PLUS (EVAL G s) (EVAL H s)) (PLUS (FOR I L COND 'SUM G A) (FOR I L COND 'SUM H A))) = [4] (PLUS (PLUS (EVAL G s) <p> Assume the contrary; i.e., APP@val (FOPEN)&lt;0,1&gt;, &lt;Y,0&gt;@val (FCLOSE) @val (NE) F. Let s be (LIST (CONS 'X 0) (CONS 'Y Y)). Then c.APP@val (FOPEN)&lt;0,1&gt;, <Y,0>@val (FCLOSE) &gt; [1] c.[(IF (EQUAL X 'NIL) Y (CONS (CAR X) (APP (CDR X) Y))),s] &gt; <ref> [2] </ref> c.[(CONS (CAR X) (APP (CDR X) Y)),s] = [3] c.CONS@val (FOPEN)[(CAR X),s],[(APP (CDR X) Y),s]@val (FCLOSE) = [4] c.CONS@val (FOPEN)[(CAR X),s],APP@val (FOPEN)[(CDR X),s],[Y,s]@val (FC = [5] c.CONS@val (FOPEN)[(CAR X),s],APP (&lt;0,1&gt;,<Y,0>)@val (FCLOSE) &gt; [6] c.APP@val (FOPEN)&lt;0,1&gt;,<Y,0>@val (FCLOSE). Step 1 is via the definition of V&C-APPLY.
Reference: 3. <institution> The Formal Definition of V&C 13 3.1. </institution> <note> Explicit Values, Abbreviations and Quotations 13 3.2. The Subfunctions of V&C 15 3.3. The Axiom for V&C 17 3.4. Window Dressings 19 </note>
Reference-contexts: (CONS K L) COND 'SUM (LIST 'PLUS G H) A) = [1] (PLUS (EVAL (LIST 'PLUS G H) s) (FOR I L COND 'SUM (LIST 'PLUS G H) A)) = [2] (PLUS (PLUS (EVAL G s) (EVAL H s)) (FOR I L COND 'SUM (LIST 'PLUS G H) A)) = <ref> [3] </ref> (PLUS (PLUS (EVAL G s) (EVAL H s)) (PLUS (FOR I L COND 'SUM G A) (FOR I L COND 'SUM H A))) = [4] (PLUS (PLUS (EVAL G s) (FOR I L COND 'SUM G A)) (PLUS (EVAL H s) (FOR I L COND 'SUM H A))) = [5] <p> Let s be (LIST (CONS 'X 0) (CONS 'Y Y)). Then c.APP@val (FOPEN)&lt;0,1&gt;, <Y,0>@val (FCLOSE) &gt; [1] c.[(IF (EQUAL X 'NIL) Y (CONS (CAR X) (APP (CDR X) Y))),s] &gt; [2] c.[(CONS (CAR X) (APP (CDR X) Y)),s] = <ref> [3] </ref> c.CONS@val (FOPEN)[(CAR X),s],[(APP (CDR X) Y),s]@val (FCLOSE) = [4] c.CONS@val (FOPEN)[(CAR X),s],APP@val (FOPEN)[(CDR X),s],[Y,s]@val (FC = [5] c.CONS@val (FOPEN)[(CAR X),s],APP (&lt;0,1&gt;,<Y,0>)@val (FCLOSE) &gt; [6] c.APP@val (FOPEN)&lt;0,1&gt;,<Y,0>@val (FCLOSE). Step 1 is via the definition of V&C-APPLY. <p> Then, appealing to the just derived chain of definedness results we can derive the value of (APP X Y): 27 = [1] v.[(IF (EQUAL X 'NIL) Y (CONS (CAR X) (APP (CDR X) Y)))] v.[(CONS (CAR X) (APP (CDR X) Y))] = <ref> [3] </ref> v.CONS@val (FOPEN)[(CAR X)],[(APP (CDR X) Y)]@val (FCLOSE) = [4] (CONS v.[(CAR X)] v.[(APP (CDR X) Y)]) = [5] (CONS (CAR X) v.[(APP (CDR X) Y)]) = [6] (CONS (CAR X) (APPEND (CDR X) Y)) = [7] (APPEND X Y).
Reference: 4. <institution> Theorems about Partial Functions 22 </institution>
Reference-contexts: 'PLUS G H) A)) = [2] (PLUS (PLUS (EVAL G s) (EVAL H s)) (FOR I L COND 'SUM (LIST 'PLUS G H) A)) = [3] (PLUS (PLUS (EVAL G s) (EVAL H s)) (PLUS (FOR I L COND 'SUM G A) (FOR I L COND 'SUM H A))) = <ref> [4] </ref> (PLUS (PLUS (EVAL G s) (FOR I L COND 'SUM G A)) (PLUS (EVAL H s) (FOR I L COND 'SUM H A))) = [5] (PLUS (FOR I (CONS K L) COND 'SUM G A) (FOR I (CONS K L) COND 'SUM H A)). <p> Let s be (LIST (CONS 'X 0) (CONS 'Y Y)). Then c.APP@val (FOPEN)&lt;0,1&gt;, <Y,0>@val (FCLOSE) &gt; [1] c.[(IF (EQUAL X 'NIL) Y (CONS (CAR X) (APP (CDR X) Y))),s] &gt; [2] c.[(CONS (CAR X) (APP (CDR X) Y)),s] = [3] c.CONS@val (FOPEN)[(CAR X),s],[(APP (CDR X) Y),s]@val (FCLOSE) = <ref> [4] </ref> c.CONS@val (FOPEN)[(CAR X),s],APP@val (FOPEN)[(CDR X),s],[Y,s]@val (FC = [5] c.CONS@val (FOPEN)[(CAR X),s],APP (&lt;0,1&gt;,<Y,0>)@val (FCLOSE) &gt; [6] c.APP@val (FOPEN)&lt;0,1&gt;,<Y,0>@val (FCLOSE). Step 1 is via the definition of V&C-APPLY. Step 2 is by the observation that the cost of a defined IF-expression is greater than the cost of the appropriate branch. <p> appealing to the just derived chain of definedness results we can derive the value of (APP X Y): 27 = [1] v.[(IF (EQUAL X 'NIL) Y (CONS (CAR X) (APP (CDR X) Y)))] v.[(CONS (CAR X) (APP (CDR X) Y))] = [3] v.CONS@val (FOPEN)[(CAR X)],[(APP (CDR X) Y)]@val (FCLOSE) = <ref> [4] </ref> (CONS v.[(CAR X)] v.[(APP (CDR X) Y)]) = [5] (CONS (CAR X) v.[(APP (CDR X) Y)]) = [6] (CONS (CAR X) (APPEND (CDR X) Y)) = [7] (APPEND X Y).
Reference: 5. <institution> Proofs about Partial Functions 24 </institution>
Reference-contexts: [3] (PLUS (PLUS (EVAL G s) (EVAL H s)) (PLUS (FOR I L COND 'SUM G A) (FOR I L COND 'SUM H A))) = [4] (PLUS (PLUS (EVAL G s) (FOR I L COND 'SUM G A)) (PLUS (EVAL H s) (FOR I L COND 'SUM H A))) = <ref> [5] </ref> (PLUS (FOR I (CONS K L) COND 'SUM G A) (FOR I (CONS K L) COND 'SUM H A)). Step 1 is the expansion of the definitions of FOR and QUANTIFIER-OPERATION. Step 2 is by EVAL-DISTRIBUTES-OVER-PLUS. Step 3 is the use of the induction hypothesis. <p> Then c.APP@val (FOPEN)&lt;0,1&gt;, <Y,0>@val (FCLOSE) &gt; [1] c.[(IF (EQUAL X 'NIL) Y (CONS (CAR X) (APP (CDR X) Y))),s] &gt; [2] c.[(CONS (CAR X) (APP (CDR X) Y)),s] = [3] c.CONS@val (FOPEN)[(CAR X),s],[(APP (CDR X) Y),s]@val (FCLOSE) = [4] c.CONS@val (FOPEN)[(CAR X),s],APP@val (FOPEN)[(CDR X),s],[Y,s]@val (FC = <ref> [5] </ref> c.CONS@val (FOPEN)[(CAR X),s],APP (&lt;0,1&gt;,<Y,0>)@val (FCLOSE) &gt; [6] c.APP@val (FOPEN)&lt;0,1&gt;,<Y,0>@val (FCLOSE). Step 1 is via the definition of V&C-APPLY. Step 2 is by the observation that the cost of a defined IF-expression is greater than the cost of the appropriate branch. <p> This statement of the theorem suits our current purposes and is easy to prove. 26 [(IF (EQUAL X (QUOTE NIL)) Y (CONS (CAR X) (APP (CDR X) Y)))]@VAL (NE)F [(CONS (CAR X) (APP (CDR X) Y))]@VAL (NE)F [(APP (CDR X) Y)]@VAL (NE)F APP@val (FOPEN)[(CDR X)],[Y]@val (FCLOSE)@VAL (NE)F @VAL (IFF) <ref> [5] </ref> APP@val (FOPEN)&lt;0,1&gt;,<Y,0>@val (FCLOSE)@VAL (NE)F which contradicts APP-0-LOOPS. Step 1 is justified by the fact that the application of a non-SUBRP is defined if and only if the arguments and the body are defined. <p> we can derive the value of (APP X Y): 27 = [1] v.[(IF (EQUAL X 'NIL) Y (CONS (CAR X) (APP (CDR X) Y)))] v.[(CONS (CAR X) (APP (CDR X) Y))] = [3] v.CONS@val (FOPEN)[(CAR X)],[(APP (CDR X) Y)]@val (FCLOSE) = [4] (CONS v.[(CAR X)] v.[(APP (CDR X) Y)]) = <ref> [5] </ref> (CONS (CAR X) v.[(APP (CDR X) Y)]) = [6] (CONS (CAR X) (APPEND (CDR X) Y)) = [7] (APPEND X Y). Step 1 uses the observation that if the application of a non-SUBRP is defined, then its value is the value of the body.
Reference: 6. <institution> EVAL and APPLY 32 </institution>
Reference-contexts: <Y,0>@val (FCLOSE) &gt; [1] c.[(IF (EQUAL X 'NIL) Y (CONS (CAR X) (APP (CDR X) Y))),s] &gt; [2] c.[(CONS (CAR X) (APP (CDR X) Y)),s] = [3] c.CONS@val (FOPEN)[(CAR X),s],[(APP (CDR X) Y),s]@val (FCLOSE) = [4] c.CONS@val (FOPEN)[(CAR X),s],APP@val (FOPEN)[(CDR X),s],[Y,s]@val (FC = [5] c.CONS@val (FOPEN)[(CAR X),s],APP (&lt;0,1&gt;,<Y,0>)@val (FCLOSE) &gt; <ref> [6] </ref> c.APP@val (FOPEN)&lt;0,1&gt;,<Y,0>@val (FCLOSE). Step 1 is via the definition of V&C-APPLY. Step 2 is by the observation that the cost of a defined IF-expression is greater than the cost of the appropriate branch. <p> 27 = [1] v.[(IF (EQUAL X 'NIL) Y (CONS (CAR X) (APP (CDR X) Y)))] v.[(CONS (CAR X) (APP (CDR X) Y))] = [3] v.CONS@val (FOPEN)[(CAR X)],[(APP (CDR X) Y)]@val (FCLOSE) = [4] (CONS v.[(CAR X)] v.[(APP (CDR X) Y)]) = [5] (CONS (CAR X) v.[(APP (CDR X) Y)]) = <ref> [6] </ref> (CONS (CAR X) (APPEND (CDR X) Y)) = [7] (APPEND X Y). Step 1 uses the observation that if the application of a non-SUBRP is defined, then its value is the value of the body. Step 2 uses the corresponding rule for IF.
Reference: 7. <institution> The Definition of the Quantifier Function FOR 35 </institution>
Reference-contexts: (CAR X) (APP (CDR X) Y)))] v.[(CONS (CAR X) (APP (CDR X) Y))] = [3] v.CONS@val (FOPEN)[(CAR X)],[(APP (CDR X) Y)]@val (FCLOSE) = [4] (CONS v.[(CAR X)] v.[(APP (CDR X) Y)]) = [5] (CONS (CAR X) v.[(APP (CDR X) Y)]) = [6] (CONS (CAR X) (APPEND (CDR X) Y)) = <ref> [7] </ref> (APPEND X Y). Step 1 uses the observation that if the application of a non-SUBRP is defined, then its value is the value of the body. Step 2 uses the corresponding rule for IF. Step 3 is by the previously mentioned relation between V&C and V&C-APPLY.
Reference: 8. <institution> Theorems about Quantifiers 35 </institution>
Reference: 9. <institution> The Modified Theorem Prover 37 </institution>
Reference: 10. <institution> Proof of the Binomial Theorem 39 </institution>
Reference: 11. <institution> Conclusion 43 </institution>
References-found: 12

