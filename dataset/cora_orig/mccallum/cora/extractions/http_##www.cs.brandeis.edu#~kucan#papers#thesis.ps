URL: http://www.cs.brandeis.edu/~kucan/papers/thesis.ps
Refering-URL: http://www.cs.brandeis.edu/~kucan/bibliography.html
Root-URL: http://www.cs.brandeis.edu
Title: Metatheorems about Convertibility in Typed Lambda Calculi: Applications to CPS transform and "Free Theorems"  
Author: by Jakov Kucan Albert R. Meyer Hung Cheng 
Degree: Submitted to the Department of Mathematics in partial fulfillment of the requirements for the degree of Doctor of Philosophy at the  All rights reserved. Author  Certified by  Professor of Engineering Thesis Supervisor Accepted by  Chairman, Applied Mathematics Committee  
Date: (1991)  February 1997  October 10, 1996  
Address: (1991) M.A., University of Pennsylvania  
Affiliation: B.S.E., University of Pennsylvania  MASSACHUSETTS INSTITUTE OF TECHNOLOGY  c Massachusetts Institute of Technology 1997.  Department of Mathematics  Hitachi America  
Abstract-found: 0
Intro-found: 0
Reference: [App92] <author> Anrew W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge Universisty Press, </publisher> <year> 1992. </year>
Reference-contexts: Further research led to development of CPS denotational semantics [SW74] (see also [Sto77]), and later categorical semantics of computations [Mog89], as well as compilers based on the CPS transform [Ste78] (see also <ref> [App92] </ref>). In both kinds of applications one of the central goals of the research has been to establish a relationship between original terms and their images under the transform. Motivation: Plotkin [Plo75] has shown that the CPS transform 1 preserves equalities between lambda terms provable in call-by-value calculus v . <p> We point out that the retraction approach only attempts to explain the relation between equivalence classes of direct style and CPS terms. In CPS based compilers, one is also interested in other features of CPS terms, such as their structure and suitability for various optimizations (see <ref> [App92] </ref>). In comparison with the results in [FSDF93, SF92, SW96], which provide more precise relation between terms and their images under the CPS transform in terms of reduction relation, we feel that our result will be of greater importance in studying the semantics of programs.
Reference: [Bar84] <author> Henk P. Barendregt. </author> <title> The Lambda Calculus: Its Syntax and Semantics, </title> <booktitle> volume 103 of Studies in Logic. </booktitle> <publisher> North-Holland Publishing Co., </publisher> <address> Amsterdam, </address> <note> second edition, </note> <year> 1984. </year>
Reference-contexts: M (N ) for (M N ), etc. 5 A reduction relation fl is said to be Church-Rosser if whenever M fl M 1 and M fl M 2 , there is a term M 3 such that M 1 fl M 3 and M 2 fl M 3 (cf. <ref> [Bar84] </ref>). 6 The subject reduction property says that the reduction relation preserves typing sequents, i.e. if .M: and M fl N, then . N: . 1.2. <p> We assume the reader is familiar with untyped -calculus and elementary concepts such as free and bound variables, substitution, parallel substitution, as well as, (ff), (fi) and () axiom schemes. For precise treatment of these notions one is referred to <ref> [Bar84] </ref>. 2.2.1 Untyped -calculus and -theories We work with standard definition of the untyped -calculus with constants. Let C fl be a set of constants and write fl (C fl ) to denote the set of -terms over constants in C fl and an infinite set of -variables. <p> We do not distinguish between ff-equivalent -terms. We use lower-case letters towards the end of the alphabet to denote -variables, and upper-case letters, M , N , etc. to denote arbitrary -terms. Following <ref> [Bar84] </ref> we write fl 0 (C fl ) for 68 CHAPTER 2. ANOTHER LOOK AT "THEOREMS FOR FREE!" the set of all closed -terms over constants in C fl .
Reference: [BB85] <author> Corrado Bohm and Alessandro Berarducci. </author> <title> Automatic synthesis of typed fl-programs on term algebras. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 39(2,3):135-154, </address> <month> August </month> <year> 1985. </year>
Reference-contexts: On the other hand, in the syntactic formulation of free theorems, we need to be precise how we represent datatypes such as lists. For instance, we can use the Bohm-Berarducci <ref> [BB85] </ref> encoding of lists in polymorphic lambda calculus similar to the encoding of natural numbers as Church numerals. Then, the type of lists yields a logical relation quite different from the induction axiom corresponding to Wadler's semantic interpretation of the logical relation on lists. <p> For example, every iterative function on simple data structure is provably total, and in fact, its Bohm-Berarducci representation, which must exist <ref> [BB85] </ref>, represents the proof of its totality [Lei90]. 2.3. THE FUNDAMENTAL THEOREM OF LOGICAL RELATIONS 79 Theorem 2.3.4 (Fundamental Theorem of Logical Relations). <p> Naturally, one could ask whether the free theorems hold independently of the way we defined data structures. For example, datatypes such as lists, natural numbers, trees, etc., can be represented in the pure polymorphic lambda calculus using a generalization of Church numerals <ref> [BB85] </ref>. Do the free theorems hold if we choose to work with these representations? The answer is "yes", but it requires some explaining. Let us illustrate the problem with the example of natural numbers. If we choose to represent natural numbers using the data structure 86 CHAPTER 2. <p> Following <ref> [BB85] </ref> we write for the representation of type , and likewise, M for the representation of term M . For example, consider the Church numerals. <p> 1 x k :y 1 y l :g 1 g m :(g i x 1 x k (y 1 g 1 g m ) (y l g 1 g m )): Assume data structures in the calculus correspond to the class of free algebras for which the Completeness Theorem in <ref> [BB85] </ref> holds. Theorem 2.5.6. Let (fc 1 ; : : : ; c n g; fg 1 : 1 ; : : : ; g m : m g) be a signature of a data structure satisfying the above criterion. <p> Hence, by soundness, R (M ) is true in D. By the above theorem, it suffices to check that, for each base type , the set D 0 Rep () contains only terms representing elements in D 0 . For example the Completeness Theorem <ref> [BB85] </ref> for the Bohm-Berarducci representation would suffice to conclude that this representation preserves the free theorems. While the surjectivness condition in Theorem 2.5.8 is (arguably) more intuitive, we must say it is somewhat stronger than the validity of sequent (y).
Reference: [BFSS90] <author> E. S. Bainbridge, P. J. Freyd, A. Scedrov, and P. J. Scott. </author> <title> Functorial polymor-phism. </title> <journal> Theoretical Computer Science, </journal> <volume> 70(1) </volume> <pages> 35-64, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Intuitively, a polymorphic function is called parametric if it can be described as having a uniform algorithm that works for all types [Str67]. There have been numerous attempts to formulate this notion, for example <ref> [Rey83, BFSS90, MR91, Mai91] </ref>, and in each of these formulations, the parametric functions have the expected properties. Even though there doesn't seem to be a general agreement on the "right" definition of parametricity, it is agreed that the polymorphic -terms denote parametric functions.
Reference: [CP92] <author> Roy L. Crole and Andrew M. Pitts. </author> <title> New foundations for fixpoint computations: </title> <journal> FIX-hyperdoctrines and the FIX-logic. Information and Computation, </journal> <volume> 98(2) </volume> <pages> 171-210, </pages> <month> jun </month> <year> 1992. </year>
Reference-contexts: The other difficulty is determining the correct axiomatization of a fixed-point operator. It appears that the axiom (Y V ) = (V (Y V )) (fix) does not suffice. In models of c , fixed-point operator can be defined using the so called fixpoint object. Crole and Pitts <ref> [CP92] </ref> define such an object in models of c , and discuss a logical system for reasoning about fixpoint computations, which may hold the answer to above questions.
Reference: [Cro93] <author> Roy L. Crole. </author> <title> Categories for Types. </title> <publisher> Cambridge Mathematical Textbooks. Cam-bridge University Press, </publisher> <address> Cambridge, UK, </address> <year> 1993. </year>
Reference-contexts: We now summarize the definitions in a more general setting. The interested reader is also referred to <ref> [Mog88, Mog91, LS86, Cro93, ML71] </ref> for a more detailed discussion. Standard categorical interpretation of functional programs assigns objects to types and morphism to terms. The Cartesian closed structure of a category ensures that (fi) and () axioms are sound. <p> C (with enough structure) can be viewed as a lambda theory, Th (C), called the internal language of the category, and conversely, for every lambda theory, Th, there is a category, Cl (Th), the classifying category of Th, such that the categories Cl (Th (C)) and C are equivalent (see <ref> [Cro93] </ref> and [LS86] for more details). In this sense, the computational lambda calculus, c is the internal language of the initial Kleisli category.
Reference: [Fil94] <author> Andrzej Filinski. </author> <title> Representing monads. </title> <booktitle> In Symposium on Principles of Programming Languages, </booktitle> <pages> pages 446-457, </pages> <address> Portland, Oregon, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: While their version of the Retraction Theorem holds only at base type, this suffices for deriving results by observational congruence as those discussed in Section 1.6. One generalization of the Meyer-Wand Retraction Theorem is given by Filinski <ref> [Fil94] </ref>.
Reference: [Fis72] <author> Michael J. Fischer. </author> <title> Lambda calculus schemata. </title> <booktitle> In Proceedings of An ACM Conference on Proving Assertions About Programs, </booktitle> <pages> pages 104-109, </pages> <address> Las Cruces, NM, 1972. </address> <publisher> ACM. </publisher>
Reference-contexts: The only questionable axiom is (unit), so let us assume that M = (let x=N in x). By the previous lemma, N ] ] ] as desired. The other implication in the theorem follows from the Retraction Theorem (Theorem 1.5.11). 1.3.3 The CPS transform The Fischer-Reynolds <ref> [Fis72, Fis93, Rey72] </ref> continuation-passing style transform comes in several variations: call-by-name, call-by-value, left-to-right and right-to-left. We focus on a 1.3. SOURCE TO SOURCE TRANSFORMS 33 call-by-value variant based on the one defined by Plotkin [Plo75].
Reference: [Fis93] <author> Michael Fischer. </author> <title> Lambda-calculus schemata. </title> <journal> Lisp and Symbolic Computation, </journal> 6(3/4):259-288, November 1993. 
Reference-contexts: The only questionable axiom is (unit), so let us assume that M = (let x=N in x). By the previous lemma, N ] ] ] as desired. The other implication in the theorem follows from the Retraction Theorem (Theorem 1.5.11). 1.3.3 The CPS transform The Fischer-Reynolds <ref> [Fis72, Fis93, Rey72] </ref> continuation-passing style transform comes in several variations: call-by-name, call-by-value, left-to-right and right-to-left. We focus on a 1.3. SOURCE TO SOURCE TRANSFORMS 33 call-by-value variant based on the one defined by Plotkin [Plo75].
Reference: [FSDF93] <author> Cormac Flanagan, Amr Sabry, Bruce F. Duba, and Matthias Felleisen. </author> <title> The essence of compiling with continuations. </title> <journal> SIGPLAN Notices, </journal> <volume> 28(6) </volume> <pages> 237-247, </pages> <month> June </month> <year> 1993. </year> <booktitle> Proceedings of the ACM SIGPLAN '93 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: In CPS based compilers, one is also interested in other features of CPS terms, such as their structure and suitability for various optimizations (see [App92]). In comparison with the results in <ref> [FSDF93, SF92, SW96] </ref>, which provide more precise relation between terms and their images under the CPS transform in terms of reduction relation, we feel that our result will be of greater importance in studying the semantics of programs. We elaborate on an interesting application of the Retraction Theorem. <p> Besides the equational correspondence, they also study the structure of the transform in greater detail (e.g. separating the CPS transform into its generic part and "continuation introduction", overhead of administrative reductions, etc.). A different view of the CPS transform was presented by Flanagan et al. <ref> [FSDF93] </ref>. By observing implementations of typical CPS based compilers they suggest an alternative transformation that combines several phases done by the compiler. Sabry and Wadler [SW96] exhibit an even stronger relation between direct style terms and their CPS forms.
Reference: [Gir71] <author> Jean-Yves Girard. </author> <title> Une extension de l'interpretation de Godel a l'analyse, et son application a l'elimination des coupures dans l'analyse et la theorie des types. </title> <editor> In J. E. Fenstad, editor, </editor> <booktitle> 2 nd Scandinavian Logic Symp., </booktitle> <pages> pages 63-92. </pages> <publisher> North-Holland Publishing Co., </publisher> <year> 1971. </year> <note> 93 94 BIBLIOGRAPHY </note>
Reference-contexts: The method also has roots in Girard's method of Candidats de Reducibilite <ref> [Gir71, Gir72] </ref>. However, it must be pointed out that fore mentioned proof methods are tuned for proving properties of lambda terms in the fi-logic. Since our results hold in the weaker logic of cp (and c ), we take a somewhat less structured approach. 16 CHAPTER 1.
Reference: [Gir72] <author> Jean-Yves Girard. </author> <title> Interpretation fonctionelle et elimination des coupures dans l'arithmetique d'ordre superieure. </title> <type> PhD thesis, </type> <institution> Universite Paris VII, </institution> <year> 1972. </year>
Reference-contexts: The method also has roots in Girard's method of Candidats de Reducibilite <ref> [Gir71, Gir72] </ref>. However, it must be pointed out that fore mentioned proof methods are tuned for proving properties of lambda terms in the fi-logic. Since our results hold in the weaker logic of cp (and c ), we take a somewhat less structured approach. 16 CHAPTER 1. <p> The type inference system F ! +Th is a version of Girard's system F ! <ref> [Gir72] </ref>. In F ! +Th we use implicit typing in the style of Curry, and add an extra typing rule (term-cong) [Mit88]. Moreover, we enrich the set of type constructors with a set of type constructor constants.
Reference: [HD94] <author> John Hatcliff and Olivier Danvy. </author> <title> A generic account of continuation-passing styles. </title> <booktitle> In Proceedings of the 21st Symposium on Principles of Programming Languages, </booktitle> <pages> pages 458-471, </pages> <address> Portland, Oregon, </address> <month> January </month> <year> 1994. </year> <note> ACM. </note>
Reference-contexts: To determine a type of a computation of values of type , let s denote the type of results. Then a continuation must be of type !s and a computation will have type (!s)!s. Many authors, e.g. <ref> [MW85, Wad90, Mog91, HL92, HD94] </ref>, define the type of results to be a fixed (observable) type o. We believe this is not general enough for our purposes. Instead we define the type of computations to be K () = 8s:(!s)!s as above. <p> Wadler defines both, call-by-value and call-by-name variants of the transform. The same transform also appears in [Mog91] as the ffi translation connecting the "computational programming language" (i.e. c ) and the "monadic metalanguage" (i.e. ml ). 10 Furthermore, in <ref> [HD94] </ref>, call-by-value and call-by-name variants of the computational transform appear as call-by-value and call-by-name encodings of programs in Moggi's monadic metalanguage. <p> Theorem 1.3.2 (Sabry-Wadler). cp ` M = N iff ml ` M = N. We point the reader to <ref> [HD94] </ref> and [SW96] for more detailed analysis of the transform T ml . 1.3.2 The modified computational transform In an effort to define a transform, similar to the CT, but mapping cp into a call-by-value calculus, we define the modified computational transform, T ml] , to be a transform from cp <p> A typed versions of the CPS transform has first been studied by Meyer and Wand [MW85] for the simple types, and later by Harper and Lillibridge [HL92] in a polymorphic setting. Our definition differs from the one in this and some other work (e.g. <ref> [Mog88, HD94] </ref>) in the definition of the type of computations. As discussed in Sec tion 1.2.5, the type of computations, K () is defined to be 8s:(!s)!s instead of the more traditional (!o)!o, where o denotes a fixed type of answers. <p> The proof of Sabry Felleisen's [SF92] equational correspondence result (Theorem 1.1.2) yields an inverse to CPS transform, but again, only up to c -equivalence. Similar, but more extensive study of the several variants of the CPS transform has been done by Hatcliff and Danvy <ref> [HD94] </ref>. Besides the equational correspondence, they also study the structure of the transform in greater detail (e.g. separating the CPS transform into its generic part and "continuation introduction", overhead of administrative reductions, etc.). A different view of the CPS transform was presented by Flanagan et al. [FSDF93].
Reference: [HL92] <author> Robert Harper and Mark Lillibridge. </author> <title> Explicit polymorphism and CPS conversion. </title> <type> Technical Report CMU-CS-92-210, </type> <institution> Carnegie Mellon University, </institution> <note> Oc-tober 1992. This is an expanded version of a paper presented at the ACM SIGPLAN/SIGACT Symposium on Principles of Programming Languages, Charleston, SC, </note> <month> January, </month> <year> 1993. </year>
Reference-contexts: To determine a type of a computation of values of type , let s denote the type of results. Then a continuation must be of type !s and a computation will have type (!s)!s. Many authors, e.g. <ref> [MW85, Wad90, Mog91, HL92, HD94] </ref>, define the type of results to be a fixed (observable) type o. We believe this is not general enough for our purposes. Instead we define the type of computations to be K () = 8s:(!s)!s as above. <p> A typed versions of the CPS transform has first been studied by Meyer and Wand [MW85] for the simple types, and later by Harper and Lillibridge <ref> [HL92] </ref> in a polymorphic setting. Our definition differs from the one in this and some other work (e.g. [Mog88, HD94]) in the definition of the type of computations.
Reference: [Lei90] <author> Daniel Leivant. </author> <title> Contracting proof to programs. </title> <editor> In P. Odifreddi, editor, </editor> <booktitle> Logic and Computer Science, volume 31 of APIC Studies in Data Processing, </booktitle> <pages> pages 279-327. </pages> <publisher> Academic Press, </publisher> <year> 1990. </year>
Reference-contexts: we define the unary logical relation, R , in ductively as follows: R t def R c def R ( t) def R (t:t) def R !t def R 8t: def In the above definition, for each c 2 C T , the term D c is defined as in <ref> [Lei90] </ref>. Namely, let (fc 1 ; : : : ; c m g; fg 1 : i ; : : : ; g n : n g) be a signature of a data structure. <p> These relations are, indeed, provable and the Church numeral sz:z and Church successor function nsz:(s (n s z)) represent exactly the proofs of these statements (see <ref> [Lei90] </ref>)! Similarly, if the function symbol add is assigned type Nat!Nat, we need to show that P add ` TT R Nat!Nat (add). Again, the lambda representation of the addition represents the proof of this relation. <p> Moreover, since b ; b ` (C R 1 R l )(g ~x)), we also have b ; ` (C R 1 R l )(g ~x)) from which we conclude ` R (g) by ( I) and (8 I). Remark. Lemma 2.3.3 is an extension of Theorem 3.2 in <ref> [Lei90] </ref> to a more general class of types. Lemma 2.3.3 covers the generators of a data structure. <p> Lemma 2.3.3 covers the generators of a data structure. To say that, for a function symbol f, of type !t , logical relation R !t (f) is provable, assuming equations P f , is to say that f denotes a provably total function from to t <ref> [Lei90] </ref>. We will satisfy ourselves with this criterion for the function symbols included in the calculus, and note that this covers quite a large set of functions used in practice. <p> For example, every iterative function on simple data structure is provably total, and in fact, its Bohm-Berarducci representation, which must exist [BB85], represents the proof of its totality <ref> [Lei90] </ref>. 2.3. THE FUNDAMENTAL THEOREM OF LOGICAL RELATIONS 79 Theorem 2.3.4 (Fundamental Theorem of Logical Relations). Let Th be a - theory, and assume that for every generator of a data structure, g, Type (g) is sound, and all function symbols denote provably total functions.
Reference: [LS86] <author> L. Lambek and P. J. Scott. </author> <title> Introduction to Higher Order Categorical Logic. </title> <publisher> Cambridge University Press, </publisher> <year> 1986. </year>
Reference-contexts: We now summarize the definitions in a more general setting. The interested reader is also referred to <ref> [Mog88, Mog91, LS86, Cro93, ML71] </ref> for a more detailed discussion. Standard categorical interpretation of functional programs assigns objects to types and morphism to terms. The Cartesian closed structure of a category ensures that (fi) and () axioms are sound. <p> enough structure) can be viewed as a lambda theory, Th (C), called the internal language of the category, and conversely, for every lambda theory, Th, there is a category, Cl (Th), the classifying category of Th, such that the categories Cl (Th (C)) and C are equivalent (see [Cro93] and <ref> [LS86] </ref> for more details). In this sense, the computational lambda calculus, c is the internal language of the initial Kleisli category.
Reference: [Mai91] <author> Harry G. Mairson. </author> <title> Outline of a proof theory of parametricity. </title> <editor> In J. Hughes, editor, </editor> <booktitle> Functional Programming Languages and Computer Architecture, volume 523 of LNCS, </booktitle> <pages> pages 313-327. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Such "free theorems" are all instances of parametric behavior of polymorphic functions in a model of polymorphic lambda calculus. In this paper, we propose a syntactic treatment of free theorems inspired by the types-as-propositions paradigm, extending the one developed by Mairson <ref> [Mai91] </ref>. We develop a framework, in which parametric behavior of polymorphic 66 CHAPTER 2. ANOTHER LOOK AT "THEOREMS FOR FREE!" lambda terms is captured by formulae of type theory. This setting allows us to present the free theorems as metatheorems about convertibility. <p> Intuitively, a polymorphic function is called parametric if it can be described as having a uniform algorithm that works for all types [Str67]. There have been numerous attempts to formulate this notion, for example <ref> [Rey83, BFSS90, MR91, Mai91] </ref>, and in each of these formulations, the parametric functions have the expected properties. Even though there doesn't seem to be a general agreement on the "right" definition of parametricity, it is agreed that the polymorphic -terms denote parametric functions. <p> Our definition of logical relations extends the one used by Mairson <ref> [Mai91] </ref> to type theory in order to accommodate higher order, as well as constant, type constructors of the type inference system F ! +Th. <p> to be flT -)o :flz:8P (-)o))-)o : 8S -)o (8x:S (x) 8y:(P S)(y) (P S)(cons x y))) 8S -)o :(P S)(nil) The relation R (List t) (z) is provably equivalent to a more familiar induction axiom 8P:(8xy:T (x) P (y) P (cons x y)) P (nil) P (z) used in <ref> [Mai91] </ref>. The definition of unary logical relations, can be easily modified to obtain a definition of logical relations of any arity. Fix arity k 0, and let -(?) def higher kinds , let -() be defined as before. <p> Then, for any -term M if Th ` fx i : i g . M : then Th; fR i (x i )g ` TT R (M ): Proof: The proof of this lemma is a straight-forward generalization of the proof of Lemma 2.5 in <ref> [Mai91] </ref> to type theory. We would like to reformulate the assumptions of the above lemma in terms of typing constraints. <p> Because of Lemma 2.5.2, it is not necessary to do so, and it suffices to prove sequent (y) only when is a base type. (Lemma 2.5.2 is a generalization of Theorem 3.3 in <ref> [Mai91] </ref>.) Lemma 2.5.2. <p> L: (List r). Then, (M L) = fi (M ((x 1 x k :L) y 1 y k )): Similarly, Proposition 2.1.1 follows from derivation of the corresponding result in <ref> [Mai91] </ref>. Validity of sequent (y) at base types is a sufficient condition for a representation to preserve the free theorems. As wee have seen in the preceding theorem, the proof of the validity of this sequent requires detailed understanding of the particular representation. We 2.6. <p> In particular, we have shown that the Bohm-Berarducci representation of inductive data structures in pure lambda calculus does preserve the free theorems. This also answers the question raised by Mairson <ref> [Mai91] </ref> asking whether induction is necessary to derive free theorems. 92 CHAPTER 2. ANOTHER LOOK AT "THEOREMS FOR FREE!" 2.7 Acknowledgments The credit for the right formulation of the main problem addressed in this chapter should go Albert Meyer.
Reference: [Man76] <author> Ernest G. Manes. </author> <title> Algebraic Theories, volume 26 of Graduate Texts in Mathematics. </title> <publisher> Springer-Verlag, </publisher> <year> 1976. </year>
Reference: [Mey82] <author> Albert R. Meyer. </author> <title> What is a model of the lambda calculus? Information and Control, </title> <booktitle> 52(1) </booktitle> <pages> 87-122, </pages> <month> January </month> <year> 1982. </year>
Reference-contexts: Thus, we can use the same construction as in a set-theoretic model of simply typed lambda calculus to construct a model of type theory. More precisely, let the set I be an environment model of untyped -calculus (as defined in <ref> [Mey82] </ref>) and let O be the two element set fTrue; Falseg. Logical types are given the following interpretation: JoK = O def J-1 )-2 K = J-2 K To give an interpretation of terms we define an environment to be a function mapping variables of type to J-K. <p> Proof: To say that Th j= I M = N in every model I, is to say that M = N is true in every interpretation satisfying equations in Th. Therefore, by the completeness of - convertibility <ref> [Mey82] </ref>, M = N is provable by convertibility, i.e. Th ` M = N . Theorem 2.2.7.
Reference: [Mit88] <author> John C. Mitchell. </author> <title> Polymorphic type inference and containment. </title> <journal> Information and Computation, </journal> <volume> 76 </volume> <pages> 211-249, </pages> <year> 1988. </year>
Reference-contexts: cp T cps T cps] ** ] R K c R L &gt; 1 ZZ 8 Outline of the proof: Our proof method is a generalization of the evaluation semantics developed by McAllester et al. [MKO95], which in turn can be viewed as defining a Mitchell's model of type inference <ref> [Mit88] </ref>. The method also has roots in Girard's method of Candidats de Reducibilite [Gir71, Gir72]. However, it must be pointed out that fore mentioned proof methods are tuned for proving properties of lambda terms in the fi-logic. <p> The type inference system F ! +Th is a version of Girard's system F ! [Gir72]. In F ! +Th we use implicit typing in the style of Curry, and add an extra typing rule (term-cong) <ref> [Mit88] </ref>. Moreover, we enrich the set of type constructors with a set of type constructor constants. The set of type constructors is defined as simply kinded -calculus, over a set of constant type constructors, with base kind ?. <p> The type inference models of the second order polymorphic lambda calculus have been studied in detail by Mitchell <ref> [Mit88] </ref>, and his definitions easily generalize to system F ! +Th. We summarize the main definitions. A type structure, T, is a set theoretic model of simply typed lambda calculus, containing special elements ! T and 8 T . <p> a2U ? D f (a) : (ForAll) We say that a type structure T, a model of untyped lambda calculus D, and a subset function define a model of type inference. 3 We assume D is a model of fi calculus, and thus (Arrow) simplifies conditions (Arrow.1) and (Arrow.2) in <ref> [Mit88] </ref> 2.2. DEFINITIONS 75 2.2.8 Logical Relations Curry-Howard isomorphism gives a bijective correspondence between typed lambda calculus and propositional logic. In this isomorphism, polymorphic types correspond to propositions of higher order logic, and terms correspond to proofs. <p> Assuming that no D (c t 1 t k ) is empty, it is easy to see that this gives us a type inference model. Therefore, assuming Th contains (), we can characterize the sets D as follows (see <ref> [Mit88] </ref>): D 8t: = t D [t=t] : Now consider sets D (c t 1 t k ) , where (c t 1 t k ) is a base type. For simple data structures, we get a clean characterization of the sets D (c t 1 t k ) .
Reference: [MKO95] <author> D. McAllester, J. Kucan, and D. F. Otth. </author> <title> A proof of strong normalization of F 2 , F ! and beyond. </title> <journal> Information and Computation, </journal> <volume> 121(2) </volume> <pages> 193-200, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: state passing style transform, as another special case. cp // T ml T ml] ** cp T cps T cps] ** ] R K c R L &gt; 1 ZZ 8 Outline of the proof: Our proof method is a generalization of the evaluation semantics developed by McAllester et al. <ref> [MKO95] </ref>, which in turn can be viewed as defining a Mitchell's model of type inference [Mit88]. The method also has roots in Girard's method of Candidats de Reducibilite [Gir71, Gir72].
Reference: [ML71] <author> Saunders Mac Lane. </author> <title> Categories for the Working Mathematician, volume 5 of Graduate Texts in Mathematics. </title> <publisher> Springer-Verlag, </publisher> <year> 1971. </year>
Reference-contexts: For completeness, we summarize the main definitions in the Section 1.9.1. A reader is also referred to [Mog88], [Mog91], and <ref> [ML71] </ref> for more details. <p> We now summarize the definitions in a more general setting. The interested reader is also referred to <ref> [Mog88, Mog91, LS86, Cro93, ML71] </ref> for a more detailed discussion. Standard categorical interpretation of functional programs assigns objects to types and morphism to terms. The Cartesian closed structure of a category ensures that (fi) and () axioms are sound.
Reference: [Mog88] <author> Eugenio Moggi. </author> <title> Computational lambda-caluclus and monads. </title> <type> Technical Report ECS-LFCS-88-86, </type> <institution> University of Edinburgh, </institution> <month> October </month> <year> 1988. </year>
Reference-contexts: Note that, while stronger than v , the logic of cp is still sound for call-by-value reasoning, that is, a closed term is equivalent to a value (a variable or a lambda abstraction) under cp if and only if it is equivalent to a value under v <ref> [Mog88] </ref>. Our version of the Retraction Theorem reads as follows. Theorem 1.1.4 (Retraction). <p> Similarly, one can give a functional interpretation of a program that manipulates mutable store by passing the state of the store explicitly in every function call, yielding a state passing style transform. As pointed out by Moggi <ref> [Mog88] </ref>, many other computational effects, such as nondeterminism, divergence, interactive I/O, etc., can be treated in a similar way. Abstracting away from particular properties of each computational effect we arrive at what we call the computational transform. <p> Likewise, each function returns a pair consisting of its result and a new state of the store. A functional program with non-local jumps, can similarly be interpreted in continuation passing style. Monads give a framework, due to Moggi <ref> [Mog88] </ref>, that unifies the ideas used in deno-tational semantics to handle a particular "impure" feature of functional programs. Strictly speaking, a monad (in a category) is a categorical concept, providing the structure needed to give categorical interpretation of functional programs with features like assignment, divergence, exceptions, etc. <p> For completeness, we summarize the main definitions in the Section 1.9.1. A reader is also referred to <ref> [Mog88] </ref>, [Mog91], and [ML71] for more details. <p> Other examples of monads corresponding to divergence, interactive I/O, exceptions, mutable store, etc. can be found in <ref> [Mog88, Mog89, Wad90, Wad95] </ref>. To summarize the above examples, we notice that in each of the examples, the components of the monad and fl satisfy the monad laws. <p> The full computational calculus c is an extension of cp with the term constructors: values V ::= j [M ] terms M ::= : : : j (M ): The types of c are extended with the unary type constructor T , and rules 9 In contrast to <ref> [Mog88, Mog91] </ref>, where cp is presented as a calculus with two kinds of predicates, equality and existence, we only consider equality predicates. An existence predicate asserts that a term has a value, meaning that it has no computational effects. We prefer to define values as a syntactic subclass of terms. <p> Then the second property is obvious. To show the Church-Rosser property we consider the reduction relation defined by reductions (:fi) and (:), and show that it commutes with the let, fi v and v reduction relations as defined in <ref> [Mog88] </ref>. In this work we do not use the full expressive power of c . Using constructors [] and 24 CHAPTER 1. <p> A typed versions of the CPS transform has first been studied by Meyer and Wand [MW85] for the simple types, and later by Harper and Lillibridge [HL92] in a polymorphic setting. Our definition differs from the one in this and some other work (e.g. <ref> [Mog88, HD94] </ref>) in the definition of the type of computations. As discussed in Sec tion 1.2.5, the type of computations, K () is defined to be 8s:(!s)!s instead of the more traditional (!o)!o, where o denotes a fixed type of answers. <p> We now summarize the definitions in a more general setting. The interested reader is also referred to <ref> [Mog88, Mog91, LS86, Cro93, ML71] </ref> for a more detailed discussion. Standard categorical interpretation of functional programs assigns objects to types and morphism to terms. The Cartesian closed structure of a category ensures that (fi) and () axioms are sound. <p> The Cartesian closed structure of a category ensures that (fi) and () axioms are sound. However, in a call-by-value language, these axioms take restricted forms and the Cartesian close structure is no longer appropriate. To capture computational aspects of programs, such as call-by-name and call-by-value evaluation strategies, Moggi <ref> [Mog88] </ref> introduced a framework based on monads. The basic idea behind using monads in a category to interpret programs, is that values are separated from computations.
Reference: [Mog89] <author> Eugenio Moggi. </author> <title> Computational lambda-caluclus and monads. </title> <booktitle> In LICS, </booktitle> <year> 1989. </year>
Reference-contexts: Further research led to development of CPS denotational semantics [SW74] (see also [Sto77]), and later categorical semantics of computations <ref> [Mog89] </ref>, as well as compilers based on the CPS transform [Ste78] (see also [App92]). In both kinds of applications one of the central goals of the research has been to establish a relationship between original terms and their images under the transform. <p> Other examples of monads corresponding to divergence, interactive I/O, exceptions, mutable store, etc. can be found in <ref> [Mog88, Mog89, Wad90, Wad95] </ref>. To summarize the above examples, we notice that in each of the examples, the components of the monad and fl satisfy the monad laws. <p> The logic of cpfi contains the following axioms (taken from <ref> [Mog89] </ref>) Types: ::= j fi Inference Rules: . fi M : ; . fi N : t (fiI) . fi i (M ): i Table 1.14: Extension of a type system with products. hM 1 ; M 2 i = (let x 1 =M 1 in (let x 2 =M 2
Reference: [Mog91] <author> Eugenio Moggi. </author> <title> Notions of computation and monads. </title> <journal> Information and Computation, </journal> <volume> 93(1) </volume> <pages> 55-92, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: For completeness, we summarize the main definitions in the Section 1.9.1. A reader is also referred to [Mog88], <ref> [Mog91] </ref>, and [ML71] for more details. <p> The full computational calculus c is an extension of cp with the term constructors: values V ::= j [M ] terms M ::= : : : j (M ): The types of c are extended with the unary type constructor T , and rules 9 In contrast to <ref> [Mog88, Mog91] </ref>, where cp is presented as a calculus with two kinds of predicates, equality and existence, we only consider equality predicates. An existence predicate asserts that a term has a value, meaning that it has no computational effects. We prefer to define values as a syntactic subclass of terms. <p> We remark that ml is what Moggi <ref> [Mog91] </ref> calls a "monadic metalanguage", but our presentation is more in tune with a functional programming point of view. We define the calculus ml to be an extension of the simply typed fi-calculus, n , with a set of constructs corresponding to an arbitrary monad. <p> To determine a type of a computation of values of type , let s denote the type of results. Then a continuation must be of type !s and a computation will have type (!s)!s. Many authors, e.g. <ref> [MW85, Wad90, Mog91, HL92, HD94] </ref>, define the type of results to be a fixed (observable) type o. We believe this is not general enough for our purposes. Instead we define the type of computations to be K () = 8s:(!s)!s as above. <p> The computational transform was first presented in [Wad90] as an interpretation of programs by means of list comprehension. Wadler defines both, call-by-value and call-by-name variants of the transform. The same transform also appears in <ref> [Mog91] </ref> as the ffi translation connecting the "computational programming language" (i.e. c ) and the "monadic metalanguage" (i.e. ml ). 10 Furthermore, in [HD94], call-by-value and call-by-name variants of the computational transform appear as call-by-value and call-by-name encodings of programs in Moggi's monadic metalanguage. <p> (M in (let T y (N in (x y))) def -0 def (!t ) 0 def fx i : i g = fx i : 0 . cp M : = 0 . ml M : T ( 0 ) Table 1.9: The computational transform T ml . 10 In <ref> [Mog91] </ref>, the ffi translation is defined only for his "simple language", which has no lambda abstractions. 1.3. SOURCE TO SOURCE TRANSFORMS 31 We concentrate on the call-by-value variant of the computational transform as a transform mapping typing sequents of cp into typing sequents of ml . <p> We now summarize the definitions in a more general setting. The interested reader is also referred to <ref> [Mog88, Mog91, LS86, Cro93, ML71] </ref> for a more detailed discussion. Standard categorical interpretation of functional programs assigns objects to types and morphism to terms. The Cartesian closed structure of a category ensures that (fi) and () axioms are sound. <p> The formal definition of a monad in a category C is equivalent to one of a Kleisli triple in a sense that each Kleisli triple over C uniquely determines a monad in C and vice versa (see <ref> [Mog91] </ref>). We find the Kleisli triples more convenient to use. Definition 1.9.1 ([Man76]). <p> Namely, Definition 1.9.3. A strong monad in C is a monad (T; ; ) together with a natural trans formation t A;B : A fi T (B) ! T (A fi B), satisfying certain identities (see <ref> [Mog91] </ref>). Natural transformation t is also called tensorial strength. Definition 1.9.4 ([Mog91]). A c -model is a category C with finite products, a strong monad (T; ; ; t) satisfying the mono requirement (i.e. <p> APPENDIX 59 Other notions of computation, such as partiality, side-effects, exceptions and interactive I/O can also be expressed in terms of monads (see <ref> [Mog91] </ref>).
Reference: [MPS86] <author> David MacQueen, Gordon Plotkin, and Ravi Sethi. </author> <title> An ideal model for recursive polymorphic types. </title> <journal> Information and Control, </journal> 71(1/2):95-130, Octo-ber/November 1986. BIBLIOGRAPHY <volume> 95 </volume>
Reference-contexts: To do so, we define a metric on the space of all type sets so that the resulting metric space is complete. Then we show that each function S:JK-fS=tg is a contraction, and thus, by Banach's Fixed-point Theorem, has a unique fixed point. Mac Queen et al. <ref> [MPS86] </ref> have developed such a framework, of which our development can be viewed as a special case. Namely, our domain consists only of finite elements (typing sequents) ordered under discrete order, thus greatly simplifying general purpose structures used in [MPS86]. <p> Mac Queen et al. <ref> [MPS86] </ref> have developed such a framework, of which our development can be viewed as a special case. Namely, our domain consists only of finite elements (typing sequents) ordered under discrete order, thus greatly simplifying general purpose structures used in [MPS86]. The metric on the space S of all type sets is defined using a rank function. In general, a rank function is any function assigning natural numbers to elements of the domain | in our case typing sequents. Definition 1.5.26. <p> The distance between S and R is defined d (S; R) = 2 c (S;R) : If c (S; R) = 1, we define d (S; R) = 0. The proof that d is a metric on S can be found in <ref> [MPS86] </ref>. Moreover, this construction is a general one for which it can be shown that (S; d) is a complete metric space (see [MPS86]). 1.5. <p> The proof that d is a metric on S can be found in <ref> [MPS86] </ref>. Moreover, this construction is a general one for which it can be shown that (S; d) is a complete metric space (see [MPS86]). 1.5. THE RETRACTION THEOREM 51 Recall that (S; d) is a complete metric space iff every Cauchy sequence in (S; d) has a limit in (S; d). Lemma 1.5.27. The metric space (S; d) is complete. <p> Obviously, the 1.5. THE RETRACTION THEOREM 53 function S:JtK-fS=tg = S:S is not contractive. As discussed in <ref> [MPS86] </ref> (section 5), this is the only problematic case, and for all types that do not contain t:t as a subexpression, JK- is well defined. To remedy this situation, we can either syntactically restrict the set of types, as done in [MPS86], to exclude the ones containing t:t as a subexpression, <p> As discussed in <ref> [MPS86] </ref> (section 5), this is the only problematic case, and for all types that do not contain t:t as a subexpression, JK- is well defined. To remedy this situation, we can either syntactically restrict the set of types, as done in [MPS86], to exclude the ones containing t:t as a subexpression, or we can define the meaning of t:t to be, say, the type set S S.
Reference: [MR] <author> Albert R. Meyer and Jon G. Riecke. </author> <title> Continuations may be unreasonable. </title> <booktitle> In Proceedings of the 1988 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 63-71. </pages>
Reference-contexts: the following questions: * Is there as lambda term P , such that n ` (P M ) = M ? * Is there a lambda term R, such that cp ` (R M ) = M ? The answer to the first question, as shown by Meyer and Riecke <ref> [MR] </ref>, is "no". The Retraction Theorem, which is the main result of this work, answers the second question affirmatively. <p> The retraction approach was first introduced by Meyer and Wand [MW85], and was further explored by Meyer and Riecke in <ref> [MR] </ref>, where the authors point out some of the limitations of the original Meyer-Wand Retraction Theorem. Most notably, the original Retraction Theorem was proved in fi-equational logic which is not sound for call-by-value languages. In [MR], the provable equality is replaced by call-by-value observational congruence. <p> introduced by Meyer and Wand [MW85], and was further explored by Meyer and Riecke in <ref> [MR] </ref>, where the authors point out some of the limitations of the original Meyer-Wand Retraction Theorem. Most notably, the original Retraction Theorem was proved in fi-equational logic which is not sound for call-by-value languages. In [MR], the provable equality is replaced by call-by-value observational congruence. However, authors fail to prove the Retraction Theorem in this setting and, in fact, show that the original retraction pairs defined in [MW85] no longer serve when fi-equational reasoning is replaced with call-by-value observational congruence.
Reference: [MR91] <author> QingMing Ma and John C. Reynolds. </author> <title> Types, abstraction, and parametric poly-morphism, </title> <booktitle> part 2. In Mathematical Foundations of Programming Semantics, </booktitle> <year> 1991. </year>
Reference-contexts: Intuitively, a polymorphic function is called parametric if it can be described as having a uniform algorithm that works for all types [Str67]. There have been numerous attempts to formulate this notion, for example <ref> [Rey83, BFSS90, MR91, Mai91] </ref>, and in each of these formulations, the parametric functions have the expected properties. Even though there doesn't seem to be a general agreement on the "right" definition of parametricity, it is agreed that the polymorphic -terms denote parametric functions.
Reference: [MW85] <author> Albert R. Meyer and Mitchell Wand. </author> <title> Continuation semantics in typed lambda-calculi (summary). </title> <editor> In Rohit Parikh, editor, </editor> <booktitle> Logics of Programs: Proceedings, volume 193 of Lecture Notes in Computer Science, </booktitle> <pages> pages 219-224. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: A version of the Retraction Theorem was first presented by Meyer and Wand <ref> [MW85] </ref> in the following form. Theorem 1.1.3 (Meyer-Wand). For any simple type , there is a term R , such that for a closed term M , of type n ` M = (R M ): 2 In Plotkin's work, v denotes fi v -convertibility, while n denotes fi-convertibility. <p> To determine a type of a computation of values of type , let s denote the type of results. Then a continuation must be of type !s and a computation will have type (!s)!s. Many authors, e.g. <ref> [MW85, Wad90, Mog91, HL92, HD94] </ref>, define the type of results to be a fixed (observable) type o. We believe this is not general enough for our purposes. Instead we define the type of computations to be K () = 8s:(!s)!s as above. <p> A typed versions of the CPS transform has first been studied by Meyer and Wand <ref> [MW85] </ref> for the simple types, and later by Harper and Lillibridge [HL92] in a polymorphic setting. Our definition differs from the one in this and some other work (e.g. [Mog88, HD94]) in the definition of the type of computations. <p> The retraction approach was first introduced by Meyer and Wand <ref> [MW85] </ref>, and was further explored by Meyer and Riecke in [MR], where the authors point out some of the limitations of the original Meyer-Wand Retraction Theorem. Most notably, the original Retraction Theorem was proved in fi-equational logic which is not sound for call-by-value languages. <p> In [MR], the provable equality is replaced by call-by-value observational congruence. However, authors fail to prove the Retraction Theorem in this setting and, in fact, show that the original retraction pairs defined in <ref> [MW85] </ref> no longer serve when fi-equational reasoning is replaced with call-by-value observational congruence. A semantic variation of the retraction approach has been studied by Riecke [Rie93], and later refined by Riecke and Viswanathan [RV95]. The motivation for their work was to isolate side-effects in sequential programs.
Reference: [Plo75] <author> G. D. Plotkin. </author> <title> Call-by-name, call-by-value and the -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1(2) </volume> <pages> 125-159, </pages> <month> December </month> <year> 1975. </year>
Reference-contexts: In both kinds of applications one of the central goals of the research has been to establish a relationship between original terms and their images under the transform. Motivation: Plotkin <ref> [Plo75] </ref> has shown that the CPS transform 1 preserves equalities between lambda terms provable in call-by-value calculus v . Theorem 1.1.1 (Plotkin). <p> We focus on a 1.3. SOURCE TO SOURCE TRANSFORMS 33 call-by-value variant based on the one defined by Plotkin <ref> [Plo75] </ref>. The definition is given in Table 1.11. x = k:k x def (M N ) = k:M (m:N (n:m n k)) def K () = (!)! = - = 0 !K (t 0 ) 0 def i g def Table 1.11: The CPS transform.
Reference: [Rey72] <author> John C. Reynolds. </author> <title> Definitional interpreters for higher-order programming languages. </title> <booktitle> In Proceedings of the ACM National Meeting (Boston, </booktitle> <year> 1972), </year> <pages> pages 717-740, </pages> <year> 1972. </year>
Reference-contexts: The only questionable axiom is (unit), so let us assume that M = (let x=N in x). By the previous lemma, N ] ] ] as desired. The other implication in the theorem follows from the Retraction Theorem (Theorem 1.5.11). 1.3.3 The CPS transform The Fischer-Reynolds <ref> [Fis72, Fis93, Rey72] </ref> continuation-passing style transform comes in several variations: call-by-name, call-by-value, left-to-right and right-to-left. We focus on a 1.3. SOURCE TO SOURCE TRANSFORMS 33 call-by-value variant based on the one defined by Plotkin [Plo75].
Reference: [Rey83] <author> John C. Reynolds. </author> <title> Types, abstraction, and parametric polymorphism. </title> <editor> In R. E. A. Mason, editor, </editor> <booktitle> Information Processing 83, </booktitle> <pages> pages 513-523. </pages> <publisher> IFIP, North-Holland Publishing Co., </publisher> <year> 1983. </year>
Reference-contexts: Intuitively, a polymorphic function is called parametric if it can be described as having a uniform algorithm that works for all types [Str67]. There have been numerous attempts to formulate this notion, for example <ref> [Rey83, BFSS90, MR91, Mai91] </ref>, and in each of these formulations, the parametric functions have the expected properties. Even though there doesn't seem to be a general agreement on the "right" definition of parametricity, it is agreed that the polymorphic -terms denote parametric functions.
Reference: [Rey93] <editor> John C. Reynolds. </editor> <booktitle> The discoveries of continutions. Lisp and Symbolic Computation, </booktitle> <volume> 6(3/4), </volume> <month> November </month> <year> 1993. </year>
Reference-contexts: The Retraction Theorem is proved in the logic of computational lambda calculus for the simply typable terms. 1.1 Introduction The notions of a continuation and a continuation passing style (CPS) transform have been introduced by a number of authors (see <ref> [Rey93] </ref> for a historical overview). The main motivation for the independent developments of these concepts seemed to be twofold: explaining the behavior of imperative features in functional languages, and compilation of programs with higher order procedures.
Reference: [Rie93] <author> Jon G. Riecke. </author> <title> Delimiting scope of side effects. </title> <booktitle> In Proceedings of the 1993 Conference on Functional Programming and Computer Architecture, </booktitle> <pages> pages 146-158. </pages> <publisher> ACM, </publisher> <year> 1993. </year>
Reference-contexts: However, authors fail to prove the Retraction Theorem in this setting and, in fact, show that the original retraction pairs defined in [MW85] no longer serve when fi-equational reasoning is replaced with call-by-value observational congruence. A semantic variation of the retraction approach has been studied by Riecke <ref> [Rie93] </ref>, and later refined by Riecke and Viswanathan [RV95]. The motivation for their work was to isolate side-effects in sequential programs. To apply the reasoning to a call-by-value language, the authors focus on call-by-value PCF.
Reference: [RV95] <author> Jon G. Riecke and Ramesh Viswanathan. </author> <title> Isolating side effects in sequential languages. </title> <booktitle> In In Proceedings of Symposium on Principles of Programming Languages, </booktitle> <year> 1995. </year>
Reference-contexts: We elaborate on an interesting application of the Retraction Theorem. Riecke and Viswanathan <ref> [RV95] </ref> have found a particular use for the retraction-embedding pairs (j ffiR; E ffii ) defined in Section 1.4. <p> Informally, their results can be summarized by saying that a term (encap M ) behaves the same in the extended language as the term M does in the pure language. The development in <ref> [RV95] </ref> depends on fully-abstract least fixed-point models of call-by-value PCF (VPCF). We believe that their results can be shown to hold in a larger class of models by using the stronger equational version of the Retraction Theorem. <p> In particular, cp+K is extended with the control operators callcc and abort, and encap. Let Ch []i be a context in cp , and let C + h []i be a context in cp+K . Then the results analogous to those in <ref> [RV95] </ref> can be stated as follows. Theorem 1.6.1. <p> RELATED WORK 55 The proof relies on the fact that the CPS transform is a transform from cp+K to cp , equational correspondence result, and the Retraction Theorem (see <ref> [RV95] </ref> for details). Analogous result holds for the SPS transform and an extension of the basic programming language with assignment. Remark. <p> Is remains to be investigated how these models relate to those used in <ref> [RV95] </ref>. 1.7 Related Work In this work, we have established a relation between direct style and CPS terms using definable retraction functions. The Retraction Theorem shows that a term can be recovered, up to cp -equivalence, from its image under the CPS transform. <p> A semantic variation of the retraction approach has been studied by Riecke [Rie93], and later refined by Riecke and Viswanathan <ref> [RV95] </ref>. The motivation for their work was to isolate side-effects in sequential programs. To apply the reasoning to a call-by-value language, the authors focus on call-by-value PCF.
Reference: [SF92] <author> Amr Sabry and Mathias Felleisen. </author> <title> Reasoning about programs in continuation-passing style. </title> <type> Technical Report COMP TR 92-180, </type> <institution> Rice University, </institution> <year> 1992. </year>
Reference-contexts: Sabry and Felleisen <ref> [SF92] </ref> strengthened Plotkin's result by extending the logic of v to what turns out to be Moggi's computational lambda calculus cp 3 , to prove the equational correspondence result. Theorem 1.1.2 (Sabry-Felleisen). <p> In CPS based compilers, one is also interested in other features of CPS terms, such as their structure and suitability for various optimizations (see [App92]). In comparison with the results in <ref> [FSDF93, SF92, SW96] </ref>, which provide more precise relation between terms and their images under the CPS transform in terms of reduction relation, we feel that our result will be of greater importance in studying the semantics of programs. We elaborate on an interesting application of the Retraction Theorem. <p> The proof of Sabry Felleisen's <ref> [SF92] </ref> equational correspondence result (Theorem 1.1.2) yields an inverse to CPS transform, but again, only up to c -equivalence. Similar, but more extensive study of the several variants of the CPS transform has been done by Hatcliff and Danvy [HD94].
Reference: [SF93] <author> Amr Sabry and Matthias Felleisen. </author> <title> Reasoning with continuations III: A complete calculus of control. </title> <type> Unpublished manuscript, </type> <year> 1993. </year>
Reference-contexts: Intuitively, the evaluation context specifies the order of evaluation. Using the evaluation context, Sabry and Felleisen <ref> [SF93] </ref> have formulated a set of axioms, equivalent to axioms of c , which are sometimes more convenient to use in proving c identities.
Reference: [Ste78] <author> Guy L. Steele. Rabbit: </author> <title> A compiler for Scheme. </title> <type> Technical Report AI-TR-474, </type> <institution> MIT Artificial Intelligence Laboratory, </institution> <year> 1978. </year>
Reference-contexts: Further research led to development of CPS denotational semantics [SW74] (see also [Sto77]), and later categorical semantics of computations [Mog89], as well as compilers based on the CPS transform <ref> [Ste78] </ref> (see also [App92]). In both kinds of applications one of the central goals of the research has been to establish a relationship between original terms and their images under the transform.
Reference: [Sto77] <author> Joseph E. Stoy. </author> <title> Denotational Semantics: The Scott-Strachey Approach to Programming Language Theory. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1977. </year>
Reference-contexts: The main motivation for the independent developments of these concepts seemed to be twofold: explaining the behavior of imperative features in functional languages, and compilation of programs with higher order procedures. Further research led to development of CPS denotational semantics [SW74] (see also <ref> [Sto77] </ref>), and later categorical semantics of computations [Mog89], as well as compilers based on the CPS transform [Ste78] (see also [App92]). In both kinds of applications one of the central goals of the research has been to establish a relationship between original terms and their images under the transform.
Reference: [Str67] <author> C. </author> <title> Strachey. </title> <booktitle> Fundamental concepts in programming languages. Lecture Notes, Int'l. Summer School in Computer Programming, </booktitle> <address> Copenhagen, </address> <year> 1967., 1967. </year> <note> 96 BIBLIOGRAPHY </note>
Reference-contexts: This theorem, as well as other examples in [Wad89], are all considered manifestations of parametric polymorphism. Intuitively, a polymorphic function is called parametric if it can be described as having a uniform algorithm that works for all types <ref> [Str67] </ref>. There have been numerous attempts to formulate this notion, for example [Rey83, BFSS90, MR91, Mai91], and in each of these formulations, the parametric functions have the expected properties.
Reference: [SW74] <author> C. Strachey and C. P. Wadsworth. </author> <title> Continuations: A mathematical semantics for handling full jumps. </title> <type> Technical Report PRG-11, </type> <institution> Oxford University Computing Laboratory, </institution> <year> 1974. </year>
Reference-contexts: The main motivation for the independent developments of these concepts seemed to be twofold: explaining the behavior of imperative features in functional languages, and compilation of programs with higher order procedures. Further research led to development of CPS denotational semantics <ref> [SW74] </ref> (see also [Sto77]), and later categorical semantics of computations [Mog89], as well as compilers based on the CPS transform [Ste78] (see also [App92]).
Reference: [SW96] <author> Amr Sabry and Philip Wadler. </author> <title> A reflection on call-by-value. </title> <booktitle> In International Conference on Functional Programing, </booktitle> <address> Philadelphia, May 1996. </address> <publisher> ACM Press. </publisher>
Reference-contexts: To show that cp is a correct codomain of the transform, consider Plotkin's indifference result: Theorem 1.1.5 (Plotkin). For any two lambda terms M and N , v ` M = N iff n ` M = N : This theorem, as shown in <ref> [SW96] </ref> can be extended to cp . Theorem 1.1.6 (Sabry-Wadler). <p> Theorem 1.3.2 (Sabry-Wadler). cp ` M = N iff ml ` M = N. We point the reader to [HD94] and <ref> [SW96] </ref> for more detailed analysis of the transform T ml . 1.3.2 The modified computational transform In an effort to define a transform, similar to the CT, but mapping cp into a call-by-value calculus, we define the modified computational transform, T ml] , to be a transform from cp into c <p> In CPS based compilers, one is also interested in other features of CPS terms, such as their structure and suitability for various optimizations (see [App92]). In comparison with the results in <ref> [FSDF93, SF92, SW96] </ref>, which provide more precise relation between terms and their images under the CPS transform in terms of reduction relation, we feel that our result will be of greater importance in studying the semantics of programs. We elaborate on an interesting application of the Retraction Theorem. <p> A different view of the CPS transform was presented by Flanagan et al. [FSDF93]. By observing implementations of typical CPS based compilers they suggest an alternative transformation that combines several phases done by the compiler. Sabry and Wadler <ref> [SW96] </ref> exhibit an even stronger relation between direct style terms and their CPS forms. In particular, they construct an inverse of the CPS transform, as well as the computational transform, so that the transform and its inverse form a reflection.
Reference: [Wad89] <editor> Philip Wadler. </editor> <booktitle> Theorems for free! In 4th International Symposium on Functional Programming Languages and Computer Architecture, </booktitle> <address> London, </address> <month> September </month> <year> 1989. </year>
Reference-contexts: For example, in a well typed program a function cannot be applied to an argument of a wrong type. Thus, types give us certain guarantees about the behavior of well typed programs. What Wadler, in his "Theorems for Free!" paper <ref> [Wad89] </ref>, points out is that not only we know that well type programs will not have any run-time type errors, but we can also infer, from the type of a program, certain identities that the program must satisfy. <p> L: (List (r)): Then equation, (map f (M (x:x) L)) = (M f L): is provable by convertibility in fi-theory. This theorem, as well as other examples in <ref> [Wad89] </ref>, are all considered manifestations of parametric polymorphism. Intuitively, a polymorphic function is called parametric if it can be described as having a uniform algorithm that works for all types [Str67]. <p> All the examples from <ref> [Wad89] </ref> can be expressed in this form. The result of a free theorem is an equation that holds by convertibility form equations in Th. In most of the examples, Th contains only (fi), (), as well as ffi-axioms defining certain functions (e.g. program for map). <p> In most of the examples, Th contains only (fi), (), as well as ffi-axioms defining certain functions (e.g. program for map). However, it may contain additional assumptions as in the example about sort-like functions (see <ref> [Wad89] </ref> and Proposition 2.4.3). All the examples of free theorems are deduced from the Fundamental Theorem using only rules (8 E), ( E) and (Cong).
Reference: [Wad90] <author> Philip Wadler. </author> <title> Comprehending monads. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 2(4) </volume> <pages> 461-493, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: Other examples of monads corresponding to divergence, interactive I/O, exceptions, mutable store, etc. can be found in <ref> [Mog88, Mog89, Wad90, Wad95] </ref>. To summarize the above examples, we notice that in each of the examples, the components of the monad and fl satisfy the monad laws. <p> To determine a type of a computation of values of type , let s denote the type of results. Then a continuation must be of type !s and a computation will have type (!s)!s. Many authors, e.g. <ref> [MW85, Wad90, Mog91, HL92, HD94] </ref>, define the type of results to be a fixed (observable) type o. We believe this is not general enough for our purposes. Instead we define the type of computations to be K () = 8s:(!s)!s as above. <p> Intuitively, the computational transform gives a functional interpretation of call-by-value programs with possible "impure" effects, in the calculus ml . The computational transform was first presented in <ref> [Wad90] </ref> as an interpretation of programs by means of list comprehension. Wadler defines both, call-by-value and call-by-name variants of the transform.
Reference: [Wad95] <author> Philip Wadler. </author> <title> Monads for functional programming. </title> <editor> In J. Jeuring and E Meijer, editors, </editor> <booktitle> Advanced Functional Programming. Proceedings of the Bastard Spring School, </booktitle> <month> May </month> <year> 1995. </year> <note> Springer Verlag Lecture Notes in Computer Science 925. </note>
Reference-contexts: Other examples of monads corresponding to divergence, interactive I/O, exceptions, mutable store, etc. can be found in <ref> [Mog88, Mog89, Wad90, Wad95] </ref>. To summarize the above examples, we notice that in each of the examples, the components of the monad and fl satisfy the monad laws.
References-found: 45

