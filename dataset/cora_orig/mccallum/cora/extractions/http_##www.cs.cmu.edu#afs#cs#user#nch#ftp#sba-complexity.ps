URL: http://www.cs.cmu.edu/afs/cs/user/nch/ftp/sba-complexity.ps
Refering-URL: http://www.cs.cmu.edu/afs/cs/user/nch/ftp/
Root-URL: 
Email: dmac@research.att.com  
Phone: (908)582-5412  
Title: On the Complexity of Set-Based Analysis (1288.232)  
Author: David McAllester, Nevin Heintze 
Web: http://www.ai.mit.edu/people/dam/dam.html  
Address: 600 Mountain Ave Murray Hill N.J. 07974  
Affiliation: AT&T Research  
Abstract: We formally define the set-based abstraction of any language whose operational semantics can be defined by environment evaluation. The Aiken-Wimmers soft type system precisely corresponds to this set-based abstraction under their operational semantics. The Heintze set-based analysis is precisely this set-based abstraction under a different operational semantics. In general, set-based abstraction determines a notion of SBA-safety. Aiken-Wimmers typability is a form of SBA-safety. SBA-safety is decidable in most cases. For monovariant functional programs with shallow case statements SBA-safety is decidable in O(n 3 ) time under any standard operational semantics. We show here that if we allow deep patterns in the case statements of monovariant functional programs the problem of determining SBA-safety becomes complete for deterministic exponential time (under any standard operational semantics). We also systematically characterize the complexity of determining SBA-safety for monovariant programs as a function of the semantics and syntactic complexity of case statements. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aiken and E. Wimmers. </author> <title> Type inclusion constraints and type inference. </title> <booktitle> In Proceedings of the 1993 Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 31-41, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: The programming language ML provides automatic type inference for procedures but requires type declarations for data constructors. Set-based analysis for languages without datatype declarations has been studied both in the context of logic programming [12, 7, 4, 8] and in the context of functional programming <ref> [13, 1, 2, 5] </ref>. Many different analyses have been developed. These approaches all share a common framework in that they assign sets (or types) to program expressions while ignoring correlations. For example, consider a variable x that can take on any integer value. <p> These connections are explored more deeply in [10]. Earlier procedures for determining SBA-safety for programs with deep patterns have been based on general methods of solving set constraints <ref> [1, 2] </ref>. The general set constraint solvers run in nondeterministic exponential time in the worst case. Here we show that the full power of these set constraint solvers is not needed in determining SBA-safety. <p> But we leave the worst case complexity of determining SBA-safety for general polyvariant programs as an open problem. Another important open problem is the in-practice efficiency of determining polyvariant SBA-safety. Constrained types seem to provide a promising practical approach <ref> [1, 2, 15] </ref>. The technical content of this paper is given in the figures and their captions. The body of the paper is used primarily to give examples of the concepts and analyses defined in the figures. Due to space restrictions many of the proofs have been omitted here.
Reference: [2] <author> A. Aiken, E. Wimmers, </author> <title> and T.K. Lakshman. Soft typing with conditional types. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 163-173. </pages> <institution> Association for Computing Machinery, </institution> <year> 1994. </year>
Reference-contexts: The programming language ML provides automatic type inference for procedures but requires type declarations for data constructors. Set-based analysis for languages without datatype declarations has been studied both in the context of logic programming [12, 7, 4, 8] and in the context of functional programming <ref> [13, 1, 2, 5] </ref>. Many different analyses have been developed. These approaches all share a common framework in that they assign sets (or types) to program expressions while ignoring correlations. For example, consider a variable x that can take on any integer value. <p> These connections are explored more deeply in [10]. Earlier procedures for determining SBA-safety for programs with deep patterns have been based on general methods of solving set constraints <ref> [1, 2] </ref>. The general set constraint solvers run in nondeterministic exponential time in the worst case. Here we show that the full power of these set constraint solvers is not needed in determining SBA-safety. <p> But we leave the worst case complexity of determining SBA-safety for general polyvariant programs as an open problem. Another important open problem is the in-practice efficiency of determining polyvariant SBA-safety. Constrained types seem to provide a promising practical approach <ref> [1, 2, 15] </ref>. The technical content of this paper is given in the figures and their captions. The body of the paper is used primarily to give examples of the concepts and analyses defined in the figures. Due to space restrictions many of the proofs have been omitted here.
Reference: [3] <author> R. Amadio and L. Cardelli. </author> <title> Subtyping recursive types. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(4) </volume> <pages> 575-631, </pages> <year> 1993. </year> <note> Also in Proc. POPL91. </note>
Reference-contexts: The analysis is also similar to that of Shivers [16] or Jagannathan and Write [9] but includes data constructors and union types. It can also be viewed as an extension of the recently established equivalence between flow analysis and recursive types in the absence of data constructors <ref> [3, 14, 6, 15] </ref>. These connections are explored more deeply in [10]. Earlier procedures for determining SBA-safety for programs with deep patterns have been based on general methods of solving set constraints [1, 2]. The general set constraint solvers run in nondeterministic exponential time in the worst case.
Reference: [4] <author> Thom Fruhwirth, Ehud Shapiro, Moshe Vardi, and Eyal Yardeni. </author> <title> Logic programs as types for logic programs. </title> <booktitle> In Proceedings, Sixth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 75-83. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: The programming language ML provides automatic type inference for procedures but requires type declarations for data constructors. Set-based analysis for languages without datatype declarations has been studied both in the context of logic programming <ref> [12, 7, 4, 8] </ref> and in the context of functional programming [13, 1, 2, 5]. Many different analyses have been developed. These approaches all share a common framework in that they assign sets (or types) to program expressions while ignoring correlations.
Reference: [5] <author> N. Heintze. </author> <title> Set based analysis of ml programs. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 306-317, </pages> <year> 1994. </year>
Reference-contexts: The programming language ML provides automatic type inference for procedures but requires type declarations for data constructors. Set-based analysis for languages without datatype declarations has been studied both in the context of logic programming [12, 7, 4, 8] and in the context of functional programming <ref> [13, 1, 2, 5] </ref>. Many different analyses have been developed. These approaches all share a common framework in that they assign sets (or types) to program expressions while ignoring correlations. For example, consider a variable x that can take on any integer value. <p> The O (n 3 ) procedure for determining SBA-safety for shallow patterns is based on a flow analysis and is related to the set-based analysis methods of Heintze <ref> [5] </ref>. The analysis is also similar to that of Shivers [16] or Jagannathan and Write [9] but includes data constructors and union types.
Reference: [6] <author> N. Heintze. </author> <title> Control flow analysis and type systems. </title> <booktitle> In Second Static Analysis Symposium (SAS95), </booktitle> <pages> pages 189-206. </pages> <publisher> Springer Verlag, </publisher> <year> 1995. </year> <note> Lecture Notes in Computer Science 983. </note>
Reference-contexts: The analysis is also similar to that of Shivers [16] or Jagannathan and Write [9] but includes data constructors and union types. It can also be viewed as an extension of the recently established equivalence between flow analysis and recursive types in the absence of data constructors <ref> [3, 14, 6, 15] </ref>. These connections are explored more deeply in [10]. Earlier procedures for determining SBA-safety for programs with deep patterns have been based on general methods of solving set constraints [1, 2]. The general set constraint solvers run in nondeterministic exponential time in the worst case.
Reference: [7] <author> N. Heintze and J. Jaffar. </author> <title> A finite presentation theorem for approximating logic programs. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 197-209. </pages> <institution> Association for Computing Machinery, </institution> <year> 1990. </year>
Reference-contexts: The programming language ML provides automatic type inference for procedures but requires type declarations for data constructors. Set-based analysis for languages without datatype declarations has been studied both in the context of logic programming <ref> [12, 7, 4, 8] </ref> and in the context of functional programming [13, 1, 2, 5]. Many different analyses have been developed. These approaches all share a common framework in that they assign sets (or types) to program expressions while ignoring correlations.
Reference: [8] <author> P. Van Hentenryck, A. Cortesi, and B. Le Charlier. </author> <title> Type analysis of prolog using type graphs. </title> <journal> Journal of Logic Programming, </journal> <volume> 22(3), </volume> <month> March </month> <year> 1995. </year> <note> Also in PLDI-94. </note>
Reference-contexts: The programming language ML provides automatic type inference for procedures but requires type declarations for data constructors. Set-based analysis for languages without datatype declarations has been studied both in the context of logic programming <ref> [12, 7, 4, 8] </ref> and in the context of functional programming [13, 1, 2, 5]. Many different analyses have been developed. These approaches all share a common framework in that they assign sets (or types) to program expressions while ignoring correlations.
Reference: [9] <author> S. Jagannathan and A. </author> <title> Write. Effective flow analysis for avoiding run time checks. </title> <booktitle> In Second Static Analysis Symposium (SAS95), </booktitle> <pages> pages 207-224. </pages> <publisher> Springer Verlag, </publisher> <year> 1995. </year> <note> Lecture Notes in Computer Science 983. </note>
Reference-contexts: The O (n 3 ) procedure for determining SBA-safety for shallow patterns is based on a flow analysis and is related to the set-based analysis methods of Heintze [5]. The analysis is also similar to that of Shivers [16] or Jagannathan and Write <ref> [9] </ref> but includes data constructors and union types. It can also be viewed as an extension of the recently established equivalence between flow analysis and recursive types in the absence of data constructors [3, 14, 6, 15]. These connections are explored more deeply in [10].
Reference: [10] <author> D. McAllester. </author> <title> Inferring recursive types. </title> <address> http://www.ai.mit.edu/people/dam/rectypes.ps. </address>
Reference-contexts: It can also be viewed as an extension of the recently established equivalence between flow analysis and recursive types in the absence of data constructors [3, 14, 6, 15]. These connections are explored more deeply in <ref> [10] </ref>. Earlier procedures for determining SBA-safety for programs with deep patterns have been based on general methods of solving set constraints [1, 2]. The general set constraint solvers run in nondeterministic exponential time in the worst case. <p> Given this definition of polyvariant SBA-safety one can consider the question of the computational complexity of determining polyvariant SBA-safety for a variety of programming languages. McAllester has shown <ref> [10] </ref> that even for first order programs with shallow case statements and restricted to procedures of at most one argument, determining SBA-safety is PSPACE-hard. Presumably the problem gets even harder in the worst case when we allow deep patterns. <p> To our knowledge the only result in this are is the theorem that polyvariant SBA-safety for shallow case statements is decidable in exponential time and is PSPACE hard even for first order programs of arity one <ref> [10] </ref>. The second major open problem is harder to state technically. It is the in-practice efficiency of determining SBA-safety. It seems that in practice the presence of deep case statements is not a problem. Monovariant programs, even with deep patterns, can apparently be analyzed in cubic time in practice.
Reference: [11] <author> D. McAllester and N. Heintze. </author> <title> On the complexity of set based analysis. </title> <note> http://www.ai.mit.edu/people/dam/setbased.ps. 11 </note>
Reference-contexts: The body of the paper is used primarily to give examples of the concepts and analyses defined in the figures. Due to space restrictions many of the proofs have been omitted here. However, proofs can be found in the full paper available on the web <ref> [11] </ref>. 2 Results The syntax and semantics of a simple operational language with case statements is given in figure 1. The semantics is given as a set of reduction rules which can be used to reduce a term to a "value" (which is another term). <p> The rules are similar to those of figure 7 but the space of abstract values is expanded to include intersections of program nodes with program patterns and negations of program patterns. Proofs of the other results in figure 6 can be found on the web in the full paper <ref> [11] </ref>. 3 Conclusions This paper contains two significant results.
Reference: [12] <author> P. Mishra. </author> <title> Towards a theory of types in prolog. </title> <booktitle> In International Symposium on Logic Program ming, </booktitle> <pages> pages 289-298. </pages> <publisher> IEEE, </publisher> <year> 1984. </year>
Reference-contexts: The programming language ML provides automatic type inference for procedures but requires type declarations for data constructors. Set-based analysis for languages without datatype declarations has been studied both in the context of logic programming <ref> [12, 7, 4, 8] </ref> and in the context of functional programming [13, 1, 2, 5]. Many different analyses have been developed. These approaches all share a common framework in that they assign sets (or types) to program expressions while ignoring correlations.
Reference: [13] <author> P. Mishra and U. S. Reddy. </author> <title> Declaration-free type checking. </title> <booktitle> In Proceedings of the Twelfth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 7-21. </pages> <publisher> ACM, </publisher> <year> 1985. </year>
Reference-contexts: The programming language ML provides automatic type inference for procedures but requires type declarations for data constructors. Set-based analysis for languages without datatype declarations has been studied both in the context of logic programming [12, 7, 4, 8] and in the context of functional programming <ref> [13, 1, 2, 5] </ref>. Many different analyses have been developed. These approaches all share a common framework in that they assign sets (or types) to program expressions while ignoring correlations. For example, consider a variable x that can take on any integer value.
Reference: [14] <author> J. Palsberg and P. O'Keefe. </author> <title> A type system equivalent to flow analysis. </title> <booktitle> In POPL95, </booktitle> <pages> pages 367-378, </pages> <year> 1995. </year>
Reference-contexts: The analysis is also similar to that of Shivers [16] or Jagannathan and Write [9] but includes data constructors and union types. It can also be viewed as an extension of the recently established equivalence between flow analysis and recursive types in the absence of data constructors <ref> [3, 14, 6, 15] </ref>. These connections are explored more deeply in [10]. Earlier procedures for determining SBA-safety for programs with deep patterns have been based on general methods of solving set constraints [1, 2]. The general set constraint solvers run in nondeterministic exponential time in the worst case.
Reference: [15] <author> J. Palsberg and S. Smith. </author> <title> Constraned types and their expressivelness. </title> <journal> Transactions on Program ming Languages and Systems. </journal> <note> to appear. </note>
Reference-contexts: The analysis is also similar to that of Shivers [16] or Jagannathan and Write [9] but includes data constructors and union types. It can also be viewed as an extension of the recently established equivalence between flow analysis and recursive types in the absence of data constructors <ref> [3, 14, 6, 15] </ref>. These connections are explored more deeply in [10]. Earlier procedures for determining SBA-safety for programs with deep patterns have been based on general methods of solving set constraints [1, 2]. The general set constraint solvers run in nondeterministic exponential time in the worst case. <p> But we leave the worst case complexity of determining SBA-safety for general polyvariant programs as an open problem. Another important open problem is the in-practice efficiency of determining polyvariant SBA-safety. Constrained types seem to provide a promising practical approach <ref> [1, 2, 15] </ref>. The technical content of this paper is given in the figures and their captions. The body of the paper is used primarily to give examples of the concepts and analyses defined in the figures. Due to space restrictions many of the proofs have been omitted here.
Reference: [16] <author> Olin Shivers. </author> <title> Data flow analysis and type recovery in scheme. </title> <editor> In Peter Lee, editor, </editor> <booktitle> Topics in Advanced Language Implementation, </booktitle> <pages> pages 47-87. </pages> <publisher> MIT Press, </publisher> <year> 1991. </year> <month> 12 </month>
Reference-contexts: The O (n 3 ) procedure for determining SBA-safety for shallow patterns is based on a flow analysis and is related to the set-based analysis methods of Heintze [5]. The analysis is also similar to that of Shivers <ref> [16] </ref> or Jagannathan and Write [9] but includes data constructors and union types. It can also be viewed as an extension of the recently established equivalence between flow analysis and recursive types in the absence of data constructors [3, 14, 6, 15]. These connections are explored more deeply in [10].
References-found: 16

