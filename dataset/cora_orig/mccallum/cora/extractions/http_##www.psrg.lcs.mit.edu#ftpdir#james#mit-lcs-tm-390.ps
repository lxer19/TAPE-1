URL: http://www.psrg.lcs.mit.edu/ftpdir/james/mit-lcs-tm-390.ps
Refering-URL: http://www.psrg.lcs.mit.edu/publications.html
Root-URL: 
Email: E-mail: james@zermatt.lcs.mit.edu  
Title: Type Abstraction Rules for References: A Comparison of Four Which Have Achieved Notoriety  
Author: James William O'Toole Jr. 
Keyword: Categories and Subject Descriptions: D.3.1 [Programming Languages] Formal Definitions and Theory; D.3.3 [Programming Languages] Language Constructs: Implicit Typing; D.1.m [Programming Techniques] Miscellaneous: Polymorphic References; General Terms: Languages, Type Theory, Polymor-phism, Reference Values. Additional Key Words and Phrases: type systems, polymorphic references, mutation, effect systems, type inference, type reconstruction, imperative types, weak poly-morphism, Standard ML, FX-89.  
Address: Technology Square, Cambridge, Massachusetts 02139.  
Affiliation: MIT Laboratory for Computer Science, 545  
Note: National Science Foundation Graduate Fellow. This research was supported by the Defense Advanced Research Projects Agency of the Department of Defense and was monitored by the Office of Naval Research under contract number N00014-83-K-0125. Authors' address:  
Abstract: I present four type abstraction rules which have been introduced by various authors to permit polymorphic type safety in the presence of mutable data. Each of the type abstraction rules is discussed in the context of the language in which is was introduced, and the various abstraction rules are compared. 
Abstract-found: 1
Intro-found: 1
Reference: [Damas82] <author> Damas, L., Milner, R., </author> <title> "Principal type-schemes for functional programs", </title> <booktitle> Proceedings of the 9th Annual Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1982, </year> <pages> pages 207-212. </pages>
Reference: [Damas85] <author> Damas, L., </author> <title> "Type Assignment in Programming Lanuages", </title> <type> Ph.D. Thesis CST-33-85, </type> <institution> University of Edinburgh, </institution> <month> April </month> <year> 1985. </year>
Reference-contexts: I call this the "Alloc@T" typing system. This system is essentially the system which is mentioned in <ref> [Damas85] </ref> on pages 90-91, where he observes that attaching sets of types to type arrows will complicate the unification algorithm for types. Damas-III therefore attaches a set of types to type scheme arrows and also a set of types to typing assertions.
Reference: [Gifford87] <author> Gifford, D. K., Jouvelot, P., Lucassen, J. M., Sheldon, M. A., </author> <title> The FX-87 Reference Manual, </title> <address> MIT/LCS/TR-407, </address> <month> October </month> <year> 1987. </year>
Reference: [Hindley69] <author> Hindley, R., </author> <title> "The principal type-scheme of an object in combinatory logic", </title> <journal> Transactions of the American Mathematical Society, </journal> <volume> vol. 146, </volume> <year> 1969, </year> <pages> pages 29-60. </pages>
Reference: [Lucassen87] <author> Lucassen, J. M., </author> <title> Types and Effects: Towards the Integration of Functional and Imperative Programming, </title> <type> Ph.D. Thesis MIT/LCS/TR-408, </type> <institution> Massachusetts Institute of Technology, </institution> <month> September </month> <year> 1987. </year>
Reference: [MacQueen84] <author> MacQueen, D., </author> <title> "Modules for Standard ML", </title> <booktitle> Proceedings of the 1984 ACM Conference on LISP and Functional Programming, </booktitle> <year> 1984, </year> <pages> pages 198-207. </pages>
Reference: [Milner78] <author> Milner, R., </author> <title> "A Theory of Type Polymor-phism in Programming", </title> <journal> Journal of Computer and System Sciences, </journal> <volume> vol. 17, </volume> <year> 1978, </year> <pages> pages 349-375. 8 </pages>
Reference: [Morris68] <author> Morris, J. H., </author> <title> Lambda-Calculus Models of Programming Languages, </title> <institution> Massachusetts Institute of Technology, MAC-TR-57, </institution> <year> 1968. </year>
Reference: [O'Toole89] <author> O'Toole, James William, Jr., </author> <title> Type Reconstruction with First Class Polymorphic Values, </title> <address> MIT/LCS/TM-380, </address> <year> 1989. </year>
Reference: [Tofte87] <author> Tofte, Mads, </author> <title> Operational Semantics and Polymorphic Type Inference, </title> <type> Ph.D. Thesis, </type> <institution> University of Edinburgh, </institution> <year> 1987. </year> <month> 9 </month>
Reference-contexts: When a type scheme is instantiated, only imperative types may be substituted for imperative type variables. An expression is considered to be expansive if its evaluation might expand the domain of the store (i.e., allocate mutable data). The classification adopted in <ref> [Tofte87] </ref> is that let expressions and applications are expansive, but lambda abstractions and variable accesses are not. 3.2 Typing rules The reference creation operator ref is assigned the imperative type 8u:u ! u ref. <p> A x + (x : Clos A t b ) ` e : t A ` (let (x e b ) e) : t 3.3 Applicative Types and FX-89 In FX-89, type abstraction is permitted only when the side-effect specifications ensure that the polymorphic expression is referentially transparent. <ref> [Tofte87] </ref> takes a different approach, based on the concept of applicative types. Tofte classifies certain expressions as expansive, and permits type abstraction of these expressions only with respect to applicative type variables. <p> ) e) : t The reference value constructor ref is assigned the type 8ff 1 :ff 1 ! ff 1 ref . 6 Comparison of Abstraction Rules 6.1 Damas-III &gt; Tofte-applicative (1) let f = let x = (fn x =&gt; x) 1 end in (f 1; f true) end <ref> [Tofte87] </ref> provides this example on page 73. Damas-III can type this system because the let expression defining f is abstractable with respect to the type of y. <p> Tofte-applicative cannot type this system because the one-level analysis reveals merely that the type of y is-or will-be allocated, and the let expression is considered expansive, so the type abstraction is not permitted. 6.2 Tofte-applicative &gt; Damas-III (2) No known example. <ref> [Tofte87] </ref> states on page 73 that an embedding exists. 5 6.3 MacQueen-weak &gt; Tofte-applicative, Damas-III (3) let fold = fn f =&gt; fn i =&gt; fn l =&gt; let data = ref l result = ref i in (while (!data &lt;&gt; []) do (result := f (hd (!data))(!result); data := tl <p> f =&gt; fn i =&gt; fn l =&gt; let data = ref l result = ref i in (while (!data &lt;&gt; []) do (result := f (hd (!data))(!result); data := tl (!data)); !result) end in let fast reverse = fold cons [] in (fast reverse [3,5,7]; fast reverse [true,true,false]) end <ref> [Tofte87] </ref>, Example 4.5, mentioned on page 74.
References-found: 10

