URL: http://www.cs.mu.oz.au/tr_db/mu_96_20.ps.gz
Refering-URL: http://www.cs.mu.oz.au/tr_db/TR.html
Root-URL: 
Title: A Comparison of Three Occur-Check Analysers  
Author: Lobel Crnogorac, Andrew D. Kelly and Harald Stndergaard 
Address: Parkville Vic. 3052 Australia  
Affiliation: Dept. of Computer Science The University of Melbourne  
Pubnum: Technical Report 96/20  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> K. R. Apt and A. Pellegrini. </author> <title> Why the occur-check is not a problem. </title> <editor> In M. Bruynooghe and M. Wirsing, editors, </editor> <booktitle> Proc. PLILP '92, Lecture Notes in Computer Science 631, </booktitle> <pages> pages 69-86. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: This line is sometimes referred to as the NSTO approach (Not Subject To Occur-check). Chadha and Plaisted [5] have suggested two methods based on assigning mode assignments to all predicates in the program, and Apt and Pellegrini <ref> [1, 2] </ref> have independently worked along the same line. <p> We assume that the reader has a basic knowledge of abstract interpretation. The plan of the paper is as follows. In Section 2 we go through a motivating example. Section 3 sketches the mode-based methods proposed by Chadha and Plaisted [5] and Apt and Pellegrini <ref> [1, 2] </ref>. Section 4 sketches the abstract interpretation approach. <p> The idea of the mode-based approaches is to verify syntactic conditions that must hold for a program to be definitely free from occur-check problems. This was pursued by Chadha and Plaisted [5], and independently by Apt and Pellegrini <ref> [1, 2] </ref>. Apt and Pellegrini also described two other mode-based approaches. The common starting point of all mode-based approaches is given by the following definition and Theorem 3.3 below. Definition 3.1 A term or literal is linear if it has no repeated variables. <p> We know that output positions of a body atom are collinear. However, we need an even stronger result, that is, we need to know that when the program is actually executed, all SLD-derivations will be collinear in their output positions. This result follows from the definition of output modes <ref> [1, 2] </ref>. Hence, we can allow output positions to be non-linear in a clause head since we know that during execution, all calls to that clause will be collinear in the output positions. No such guarantee exists for the dk positions. <p> However, practical programs rarely give rise to an excessive number of calling patterns, as witnessed by the quite reasonable analysis times reported in Section 5. 3.4 Apt and Pellegrini's approach Apt and Pellegrini independently discovered three approaches to occur-check analysis <ref> [1, 2] </ref>. They defined the concepts of well-moded, strictly-moded and nicely-moded programs. Their concept of nicely-moded programs is equivalent to Chadha and Plaisted's approach. <p> The result in Example 3.8 is then exactly the least upper bound of f (dk,dk,output), (output,dk,dk)g. 7 Definition 3.9 <ref> [1] </ref> Consider the clause L:- L 1 , : : : , L n . <p> the query ?-app (<ref> [1] </ref>,[2],X) and moding app (input,dk,dk), but there is no possible moding for the query ?-app (X,X,Y). Facts have to satisfy only the condition (3). Hence, a fact is well- moded if every variable in a dk position occurs in an input position of the fact. Theorem 3.10 [1] Let P and G be well-moded. Suppose that the head of every clause in P is collinear in its dk positions. Then P [ fGg is occur-check free. To understand Theorem 3.10 we need to make the observation that during SLD-resolution all derivations are ground in their input positions. <p> The algorithm is not given because of space considerations. Only one moding per predicate is maintained. Therefore, normalisation affects the results considerably. We have also implemented the third approach described by Apt and Pellegrini <ref> [1, 2] </ref>. This approach uses the concept of "strictly-moded" programs and it was implemented on top of the well-modedness analysis in hope of improving it. However, this additional analysis was found not to make any difference on any of the test programs used and we don't discuss it further.
Reference: [2] <author> K. R. Apt and A. Pellegrini. </author> <title> On the occur-check-free Prolog programs. </title> <journal> ACM Trans. Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 687-726, </pages> <year> 1994. </year>
Reference-contexts: This line is sometimes referred to as the NSTO approach (Not Subject To Occur-check). Chadha and Plaisted [5] have suggested two methods based on assigning mode assignments to all predicates in the program, and Apt and Pellegrini <ref> [1, 2] </ref> have independently worked along the same line. <p> Chadha and Plaisted did not implement this method but argued that it would be more precise than their (implemented) "first method". Our experiments verify this. * We have implemented two methods suggested by Apt and Pellegrini, namely one based on "well- modings" and one also taking "strictness" into account <ref> [2] </ref>. Apt and Pellegrini made the simplifying assumption that programs would already be "moded" when presented for analysis, so that analysis would simply consist of checking certain conditions such as the "well-modedness" of a program. This makes a comparison with other, fully automatic, methods hard. <p> We assume that the reader has a basic knowledge of abstract interpretation. The plan of the paper is as follows. In Section 2 we go through a motivating example. Section 3 sketches the mode-based methods proposed by Chadha and Plaisted [5] and Apt and Pellegrini <ref> [1, 2] </ref>. Section 4 sketches the abstract interpretation approach. <p> The idea of the mode-based approaches is to verify syntactic conditions that must hold for a program to be definitely free from occur-check problems. This was pursued by Chadha and Plaisted [5], and independently by Apt and Pellegrini <ref> [1, 2] </ref>. Apt and Pellegrini also described two other mode-based approaches. The common starting point of all mode-based approaches is given by the following definition and Theorem 3.3 below. Definition 3.1 A term or literal is linear if it has no repeated variables. <p> We know that output positions of a body atom are collinear. However, we need an even stronger result, that is, we need to know that when the program is actually executed, all SLD-derivations will be collinear in their output positions. This result follows from the definition of output modes <ref> [1, 2] </ref>. Hence, we can allow output positions to be non-linear in a clause head since we know that during execution, all calls to that clause will be collinear in the output positions. No such guarantee exists for the dk positions. <p> However, practical programs rarely give rise to an excessive number of calling patterns, as witnessed by the quite reasonable analysis times reported in Section 5. 3.4 Apt and Pellegrini's approach Apt and Pellegrini independently discovered three approaches to occur-check analysis <ref> [1, 2] </ref>. They defined the concepts of well-moded, strictly-moded and nicely-moded programs. Their concept of nicely-moded programs is equivalent to Chadha and Plaisted's approach. <p> The algorithm is not given because of space considerations. Only one moding per predicate is maintained. Therefore, normalisation affects the results considerably. We have also implemented the third approach described by Apt and Pellegrini <ref> [1, 2] </ref>. This approach uses the concept of "strictly-moded" programs and it was implemented on top of the well-modedness analysis in hope of improving it. However, this additional analysis was found not to make any difference on any of the test programs used and we don't discuss it further. <p> read 134 440 306 read (Answer) serialize 12 33 21 serialize (L,R) Table 1: The test suite The complexity is exponential, but as for Chadha and Plaisted's second method, real-world programs are analysed in reasonable time, see Section 5. 5 Test results The test programs used by Apt and Pellegrini <ref> [2] </ref> to test their method were all very small. As Apt and Pellegrini did not have an algorithm for generating well-modings of programs, it was not easy for them to compare their results with those of Chadha and Plaisted.
Reference: [3] <author> T. Armstrong, K. Marriott, P. Schachte, and H. Stndergaard. </author> <title> Two classes of boolean functions for dependency analysis. </title> <note> To appear in Science of Computer Programming. </note>
Reference-contexts: and Y are ground." However, a more precise information is possible by keeping track of groundness dependencies such as "if X ever becomes ground, so does Y" or even disjunctive information such as "X or Y is ground." We therefore use a more complex domain, P os, for groundness analysis <ref> [3, 15] </ref>. 2. We work with normalised programs in which all atoms contain variables only, and heads are linear, which simplifies abstract operations significantly. We next look at the two abstract domains used to produce the needed dataflow information. <p> The Boolean functions have been implemented using reduced ordered binary decision diagrams. For details, the reader is referred to Armstrong et al. <ref> [3] </ref> and the references given there. Example 4.1 Consider the program q (U) :- h1;0i p (X,Y), h1;1i U=f (X,Y), h1;2i X=Y. h1;3i p (X,Y) :- h3;0i X=a, h3;1i Y=b. h3;2i We use pairs hi; ji to number program points in the obvious way.
Reference: [4] <author> J. Beer. </author> <title> The occur-check problem revisited. </title> <journal> Journal of Logic Programming, </journal> <volume> 5 </volume> <pages> 243-261, </pages> <year> 1988. </year>
Reference-contexts: To restrict the cost of such tests to preprocessing or compile time, we consider here only static methods (for a dynamic method, see Beer <ref> [4] </ref>). Work on static analysis for occur-check elimination started with Plaisted's [18] suggestion for a family of increasingly precise analyses.
Reference: [5] <author> R. Chadha and D. A. Plaisted. </author> <title> Correctness of unification without occur check in Prolog. </title> <journal> Journal of Logic Programming, </journal> <volume> 18 </volume> <pages> 99-122, </pages> <year> 1994. </year>
Reference-contexts: This line is sometimes referred to as the NSTO approach (Not Subject To Occur-check). Chadha and Plaisted <ref> [5] </ref> have suggested two methods based on assigning mode assignments to all predicates in the program, and Apt and Pellegrini [1, 2] have independently worked along the same line. <p> The contributions offered in this paper are: * We have implemented Chadha and Plaisted's "second method" <ref> [5] </ref>. Chadha and Plaisted did not implement this method but argued that it would be more precise than their (implemented) "first method". <p> All have been tested in identical environments. We assume that the reader has a basic knowledge of abstract interpretation. The plan of the paper is as follows. In Section 2 we go through a motivating example. Section 3 sketches the mode-based methods proposed by Chadha and Plaisted <ref> [5] </ref> and Apt and Pellegrini [1, 2]. Section 4 sketches the abstract interpretation approach. <p> Section 6 contains concluding remarks. 2 palindrome ([Zs|Zs]) reverse ([Zs|Zs],[],[Zs|Zs]) reverse (Zs,[Zs],[Zs|Zs]) fl reverse (Zs,[X,[X|Zs]],[[X|Zs],X|Zs]) reverse ([Zs|Zs],[Zs|Zs]) . . . @ @ 2 A motivating example Consider the following example program, borrowed from Chadha and Plaisted <ref> [5] </ref>. palindrome (Xs) :- reverse (Xs,Xs). % (1) reverse (Xs,Ys) :- reverse (Xs,[],Ys). % (2) reverse ([],Ys,Ys). % (3) reverse ([X|Xs],Ys,Zs) :- reverse (Xs,[X|Ys],Zs). % (4) Which palindrome queries can safely be processed without using the occur-check in unification? It would be useful to be able to deduce automatically that any <p> The idea of the mode-based approaches is to verify syntactic conditions that must hold for a program to be definitely free from occur-check problems. This was pursued by Chadha and Plaisted <ref> [5] </ref>, and independently by Apt and Pellegrini [1, 2]. Apt and Pellegrini also described two other mode-based approaches. The common starting point of all mode-based approaches is given by the following definition and Theorem 3.3 below. Definition 3.1 A term or literal is linear if it has no repeated variables. <p> Example 3.2 The term p (X,Y,Z) is linear. The terms p (X,X), p (X,f (X)) and p (f (X),g (U,X)) are all non-linear. The set fp (X,Y), r (f (Z))g is collinear. The set fp (X), q (X,Y)g is not. Theorem 3.3 <ref> [5] </ref> Suppose we unify terms s and t, where s is linear, and s and t have no variables in common. Then unification without occur-check is equivalent to unification with occur-check. <p> Definition 3.5 <ref> [5] </ref> The k'th argument position of a predicate p is an output position if, in each clause L:- L 1 , : : : , L n . when the predicate of L i is p then for all variables v in the k'th argument of L i : (1) v <p> Also, variables in output positions of L i can be in dk positions of L j for i &lt; j. Finally, output positions of clause heads need not be collinear, and there are no restrictions on output positions of facts. 5 Theorem 3.6 <ref> [5] </ref> Suppose in a Prolog program, the head of a clause C has all dk positions collinear. Then for each call to C, unification without occur-check is equivalent to unification with occur-check. This theorem relaxes the restriction of Theorem 3.3. <p> No such guarantee exists for the dk positions. Thus, we need to make sure that all heads of clauses are collinear in their dk positions. The following example illustrates these concepts and shows the outcome of the algorithm that generates the optimal moding <ref> [5] </ref>. Example 3.7 [18] Consider the program ?- q (X,Y). q (X,Y) :- ancestor (X,Y), ancestor (Y,X). ancestor (father (X),X). ancestor (mother (X),X). ancestor (X,X). The analysis infers these combinations: ancestor (dk,dk) and q (output,output). <p> For example, father (X) and X share a common variable X, and both are deemed dk positions. The analysis concludes that to guarantee soundness, any unifications involving these three clauses will require an occur-check. The following example is a variant of a program from Chadha and Plaisted <ref> [5] </ref>: Example 3.8 Consider the program ?- app (Y,Y,[a,a]), app (X,Y,Y). app ([U|X],Y,[U|Z]) :- app (X,Y,Z). All argument positions of app must be marked dk. <p> In this case no new calling patterns are created, and the final result is f (dk,dk,output), (output,dk,dk)g. In general, finding the set of calling patterns is a fixpoint computation, and Chadha and Plaisted <ref> [5] </ref> give the details of an algorithm. <p> The lack of monotonicity of well-modedness poses problems because it prevents us from defining an optimal moding in the sense of Chadha and Plaisted <ref> [5] </ref>. Apt and Pellegrini have not given an algorithm to generate a well-moding for a program, rather they assume that a moding is provided. This makes it hard to compare their well-moded approach with other approaches. <p> We provide the first comparison that quantifies the merits of the three approaches discussed in this paper, based on a common set of benchmarks. These benchmarks are commonly used to test program analyses for logic programs, and they were also used by Chadha and Plaisted <ref> [5] </ref>. Various statistics about the programs are given in Table 1. The "oc-size" of a program will be explained shortly. The table also shows the queries used. These were also used by Chadha and Plaisted and the small programs (those above the centre line in Table 1) are listed in [5]. <p> <ref> [5] </ref>. Various statistics about the programs are given in Table 1. The "oc-size" of a program will be explained shortly. The table also shows the queries used. These were also used by Chadha and Plaisted and the small programs (those above the centre line in Table 1) are listed in [5]. Before we present the results, we briefly discuss a number of decisions we have had to make, regarding how to measure the accuracy and efficiency of the methods, and how to interpret and compare results in a meaningful way. <p> Table 3 lists a few non-standard queries we have also tested. As could be expected, such queries tend to create problems for the mode-based methods, more so than for the abstract interpretation approach. 2 Note that the numbers given by Chadha and Plaisted <ref> [5] </ref> for CP1 differ from ours, since they count the number of problematic clauses, while we count the number of problematic calling literals.
Reference: [6] <author> M. Codish, D. Dams, and E. Yardeni. </author> <title> Derivation and safety of an abstract unification algorithm for groundness and aliasing analysis. </title> <editor> In K. Furukawa, editor, </editor> <booktitle> Logic Programming: Proc. Eighth Int. Conf., </booktitle> <pages> pages 79-93. </pages> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: For a general introduction to abstract interpretation on logic programs consult [7] or [16]. Stndergaard [19] sketched the manipulations (the abstract versions of unification and composition) of abstract substitutions, including the fixpoint computation necessary to reach a stable and correct set of program point annotations. Codish, Dams and Yardeni <ref> [6] </ref> subsequently provided the details of "abstract unification" and proved its correctness. We have implemented an abstract interpretation-based method which is faithful to the basic ideas in those two papers but differs in two important ways: 1.
Reference: [7] <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation and application to logic programs. </title> <journal> Journal of Logic Programming, </journal> 13(2&3):103-179, 1992. 
Reference-contexts: Therefore, abstract substitutions are often referred to as "annotations" in the remainder of the paper. We assume that the reader is familiar with the basic ideas behind abstract interpretation. For a general introduction to abstract interpretation on logic programs consult <ref> [7] </ref> or [16]. Stndergaard [19] sketched the manipulations (the abstract versions of unification and composition) of abstract substitutions, including the fixpoint computation necessary to reach a stable and correct set of program point annotations. Codish, Dams and Yardeni [6] subsequently provided the details of "abstract unification" and proved its correctness.
Reference: [8] <author> P. Deransart, G. Ferrand, and M. Teguia. </author> <title> NSTO programs (Not Subject To Occur-check). </title> <editor> In V. Saraswat and K. Ueda, editors, </editor> <booktitle> Logic Programming: Proc. 1991 Int. Symp., </booktitle> <pages> pages 533-547. </pages> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: Based on Deransart and Ma luszynski's earlier work [9] on mapping logic programs to attribute grammars, Deransart, Ferrand and Teguia <ref> [8] </ref> have suggested a test which is strong enough to guarantee absence of occur-check problems for any computation rule (in fact for any resolution strategy), and work in this direction was continued by Dumant [10]. This line is sometimes referred to as the NSTO approach (Not Subject To Occur-check).
Reference: [9] <author> P. Deransart and J. Ma luszynski. </author> <title> Relating logic programs and attribute grammars. </title> <journal> Journal of Logic Programming, </journal> <volume> 2(2) </volume> <pages> 119-156, </pages> <year> 1985. </year>
Reference-contexts: Nevertheless, this line of research did not lead to an implementation until now, in spite of the availability of powerful technology in the form of generic abstract interpreters, and groundness and sharing analysers. 1 Instead, simpler methods have been proposed. Based on Deransart and Ma luszynski's earlier work <ref> [9] </ref> on mapping logic programs to attribute grammars, Deransart, Ferrand and Teguia [8] have suggested a test which is strong enough to guarantee absence of occur-check problems for any computation rule (in fact for any resolution strategy), and work in this direction was continued by Dumant [10].
Reference: [10] <author> B. Dumant. </author> <title> Checking the soundness of resolution schemes. </title> <editor> In K. Apt, editor, </editor> <booktitle> Logic Programming: Proc. Joint Int. Conf. Symp., </booktitle> <pages> pages 37-51. </pages> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: Ma luszynski's earlier work [9] on mapping logic programs to attribute grammars, Deransart, Ferrand and Teguia [8] have suggested a test which is strong enough to guarantee absence of occur-check problems for any computation rule (in fact for any resolution strategy), and work in this direction was continued by Dumant <ref> [10] </ref>. This line is sometimes referred to as the NSTO approach (Not Subject To Occur-check). Chadha and Plaisted [5] have suggested two methods based on assigning mode assignments to all predicates in the program, and Apt and Pellegrini [1, 2] have independently worked along the same line.
Reference: [11] <author> M. Hermenegildo, G. Puebla, K. Marriott, and P. Stuckey. </author> <title> Incremental analysis of logic programs. </title> <editor> In L. Sterling, editor, </editor> <booktitle> Logic Programming: Proc. Twelfth Int. Conf., </booktitle> <pages> pages 797-811. </pages> <publisher> MIT Press, </publisher> <year> 1995. </year>
Reference-contexts: Generic analysis engines are not only designed to do many different analyses but also to allow for the easy addition of new analyses. The algorithm used in our analyser was given by Hermenegildo et al. <ref> [11] </ref>. It is incremental, which means it can efficiently handle program transformations including "clause splitting" (see Example 4.4). The algorithm also depends on programs being normalised, as this greatly simplifies the fixpoint algorithm. The analyser has also been used in the optimising compilation of CLP (R) programs [12].
Reference: [12] <author> A. Kelly, A. Macdonald, K. Marriott, H. Stndergaard, P. Stuckey, and R. Yap. </author> <title> An optimizing compiler for CLP(R). </title> <editor> In U. Montanari and F. Rossi, editors, </editor> <booktitle> Principles and Practice of Constraint Programming|CP'95, Lecture Notes in Computer Science 976, </booktitle> <pages> pages 222-239. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: It uses a more sophisticated groundness analysis than was proposed by Stndergaard [19]. Here we have been helped by the availability of state-of-the-art technology for groundness and sharing analysis as used in the latest compilers for (constraint) logic programming languages <ref> [12] </ref>. * We compare the three methods with respect to precision and efficiency. We have tested them on the (standard) set of benchmark programs also used by Chadha and Plaisted. Apt and Pellegrini's method had only been tested on small programs so far. <p> It is incremental, which means it can efficiently handle program transformations including "clause splitting" (see Example 4.4). The algorithm also depends on programs being normalised, as this greatly simplifies the fixpoint algorithm. The analyser has also been used in the optimising compilation of CLP (R) programs <ref> [12] </ref>. The analyser takes a program, initial annotation and a query, and returns the resulting annotated program. The annotated program has descriptions about the P os and Asub information at any program point. The analysis finishes when a fixpoint is found, that is, when all annotations are stable.
Reference: [13] <author> B. Le Charlier and P. Van Hentenryck. </author> <title> Experimental evaluation of a generic abstract interpretation algorithm for Prolog. </title> <journal> ACM Trans. Programming Languages and Systems, </journal> <volume> 16(1) </volume> <pages> 35-101, </pages> <year> 1994. </year> <month> 18 </month>
Reference-contexts: It is a generic tool similar to other analysis engines such as PLAI [17] and GAIA <ref> [13] </ref>. Generic analysis engines are not only designed to do many different analyses but also to allow for the easy addition of new analyses. The algorithm used in our analyser was given by Hermenegildo et al. [11].
Reference: [14] <author> K. Marriott and H. Stndergaard. </author> <title> On Prolog and the occur check problem. </title> <journal> SIGPLAN Notices, </journal> <volume> 24(5) </volume> <pages> 76-82, </pages> <year> 1989. </year>
Reference-contexts: For most implementations this would happen, for example, with the query ?- p (Z,Z) and the above program. Nevertheless, it is a problem that unsound deduction may take place without the slightest warning or indication to a user. Marriott and Stndergaard <ref> [14] </ref> make two observations that emphasise the problem. Firstly, "unification without occur-check" is an ill-defined notion, and Prolog systems do not react to occur- check problems in a uniform way. Secondly, even for pure Prolog, the most basic program transformations are invalid in the absence of occur-checks.
Reference: [15] <author> K. Marriott and H. Stndergaard. </author> <title> Precise and efficient groundness analysis for logic programs. </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <volume> 2 </volume> <pages> 181-196, </pages> <year> 1993. </year>
Reference-contexts: and Y are ground." However, a more precise information is possible by keeping track of groundness dependencies such as "if X ever becomes ground, so does Y" or even disjunctive information such as "X or Y is ground." We therefore use a more complex domain, P os, for groundness analysis <ref> [3, 15] </ref>. 2. We work with normalised programs in which all atoms contain variables only, and heads are linear, which simplifies abstract operations significantly. We next look at the two abstract domains used to produce the needed dataflow information.
Reference: [16] <author> K. Marriott, H. Stndergaard, and N. Jones. </author> <title> Denotational abstract interpretation of logic programs. </title> <journal> ACM Trans. Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 607-648, </pages> <year> 1994. </year>
Reference-contexts: Therefore, abstract substitutions are often referred to as "annotations" in the remainder of the paper. We assume that the reader is familiar with the basic ideas behind abstract interpretation. For a general introduction to abstract interpretation on logic programs consult [7] or <ref> [16] </ref>. Stndergaard [19] sketched the manipulations (the abstract versions of unification and composition) of abstract substitutions, including the fixpoint computation necessary to reach a stable and correct set of program point annotations. Codish, Dams and Yardeni [6] subsequently provided the details of "abstract unification" and proved its correctness.
Reference: [17] <author> K. Muthukumar and M. Hermenegildo. </author> <title> Compile-time derivation of variable dependency using abstract interpretation. </title> <journal> Journal of Logic Programming, </journal> 13(2&3):315-347, 1992. 
Reference-contexts: It is a generic tool similar to other analysis engines such as PLAI <ref> [17] </ref> and GAIA [13]. Generic analysis engines are not only designed to do many different analyses but also to allow for the easy addition of new analyses. The algorithm used in our analyser was given by Hermenegildo et al. [11].
Reference: [18] <author> D. A. Plaisted. </author> <title> The occur-check problem in Prolog. </title> <journal> New Generation Computing, </journal> <volume> 2(4) </volume> <pages> 309-322, </pages> <year> 1984. </year>
Reference-contexts: To restrict the cost of such tests to preprocessing or compile time, we consider here only static methods (for a dynamic method, see Beer [4]). Work on static analysis for occur-check elimination started with Plaisted's <ref> [18] </ref> suggestion for a family of increasingly precise analyses. <p> No such guarantee exists for the dk positions. Thus, we need to make sure that all heads of clauses are collinear in their dk positions. The following example illustrates these concepts and shows the outcome of the algorithm that generates the optimal moding [5]. Example 3.7 <ref> [18] </ref> Consider the program ?- q (X,Y). q (X,Y) :- ancestor (X,Y), ancestor (Y,X). ancestor (father (X),X). ancestor (mother (X),X). ancestor (X,X). The analysis infers these combinations: ancestor (dk,dk) and q (output,output). <p> The Asub domain is useful for many tasks, not just occur-check reduction. In terms of representation, Asub incorporates information about definite independence and linearity by keeping track of the complementary cases, possible sharing and non-linearity. Plaisted <ref> [18] </ref> made the observation that sharing and non-linearity information are most naturally represented in a uniform way.
Reference: [19] <author> H. Stndergaard. </author> <title> An application of abstract interpretation of logic programs: Occur check reduction. </title> <editor> In B. Robinet and R. Wilhelm, editors, </editor> <booktitle> Proc. European Symposium on Programming, Lecture Notes in Computer Science 213, </booktitle> <pages> pages 327-338. </pages> <publisher> Springer-Verlag, </publisher> <year> 1986. </year> <month> 19 </month>
Reference-contexts: We shall later see why these types of information are useful. Plaisted's method assumed a standard computation rule. It was complex and seemed prohibitively difficult to implement. The problem was somewhat helped by Stndergaard's <ref> [19] </ref> suggestion that a slight variant of one of Plaisted's methods could be recast as abstract interpretation. <p> This makes a comparison with other, fully automatic, methods hard. We have therefore implemented an algorithm that generates optimal well-modings. * We have implemented a method using abstract interpretation, following the Plaisted-Stndergaard approach. It uses a more sophisticated groundness analysis than was proposed by Stndergaard <ref> [19] </ref>. Here we have been helped by the availability of state-of-the-art technology for groundness and sharing analysis as used in the latest compilers for (constraint) logic programming languages [12]. * We compare the three methods with respect to precision and efficiency. <p> Consider the unification X=f (Y,Y). This could create an occur-check problem, for example if the current substitution has X bound to f (Z,g (Z)). On the other hand, if X is linear, then no occur-check problem arises. The sharing "abstract domain" we use here is a variant of Asub <ref> [19] </ref>, which allows statements about the possible sharing between two variables, as well as about definite linearity. An abstract domain is simply a representation for the type of information we wish to infer about a program, together with a collection of operations that may be performed on that representation. <p> Therefore, abstract substitutions are often referred to as "annotations" in the remainder of the paper. We assume that the reader is familiar with the basic ideas behind abstract interpretation. For a general introduction to abstract interpretation on logic programs consult [7] or [16]. Stndergaard <ref> [19] </ref> sketched the manipulations (the abstract versions of unification and composition) of abstract substitutions, including the fixpoint computation necessary to reach a stable and correct set of program point annotations. Codish, Dams and Yardeni [6] subsequently provided the details of "abstract unification" and proved its correctness.
References-found: 19

