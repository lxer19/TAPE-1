URL: http://www.cs.utah.edu/~ratan/papers/cav98.ps.gz
Refering-URL: http://www.cs.utah.edu/~ratan/res.html
Root-URL: 
Email: email: ratan@cs.utah.edu  
Title: The `Test Model-checking' Approach to the Verification of Formal Memory Models of Multiprocessors  
Author: Ratan Nalumasu, Rajnish Ghughal, Abdel Mokkedem, and Ganesh Gopalakrishnan 
Keyword: Formal memory models, shared memory multiprocessors, formal testing, model-checking  
Note: Category: A  
Address: Salt Lake City, UT 84112-9205 Contact  
Affiliation: Department of Computer Science, University of Utah,  
Abstract: We offer a solution to the problem of verifying formal memory models of processors by combining the strengths of model-checking and a formal testing procedure for parallel machines. We characterize the formal basis for abstracting the tests into test automata and associated memory rule safety properties whose violations pinpoint the ordering rule being violated. Our experimental results on Verilog models of a commercial split transaction bus demonstrates the ability of our method to effectively debug design models during early stages of their development.
Abstract-found: 1
Intro-found: 1
Reference: [AG96] <author> Sarita V. Adve and Kourosh Gharachorloo. </author> <title> Shared memory consistency models: A tutorial. </title> <journal> Computer, </journal> <volume> 29(12) </volume> <pages> 66-76, </pages> <month> December </month> <year> 1996. </year>
Reference-contexts: 1 Introduction The fundamentally important problem <ref> [AG96] </ref> of verifying whether a given memory system model (or "a memory system") provides a formal memory model (or "memory model") appears in a number of guises. <p> Our results on our model of the HP PA/Runway bus attest to this. So far we have identified the rules and corresponding tests for sequential consistency. We are currently working on identifying similar rules and tests for other well-known formal memory models such as TSO, PSO, and RMO <ref> [AG96] </ref> that are described in the SPARC V9 architecture manual [WG94]. This work may involve defining new rules as well as new tests corresponding to them.
Reference: [BCS96] <author> William R. Bryg, Kenneth K. Chan, and Nicholas S.Fiduccia. </author> <title> A high-performance, low-cost multiprocessor bus for workstations and midrange servers. </title> <journal> Hewlett-Packard Journal, </journal> <pages> pages 18-24, </pages> <month> February </month> <year> 1996. </year>
Reference-contexts: We do not believe that descriptions of this style will scale up. On the other hand, the test model-checking method has not only been able to comfortably handle the memory system defined by the symmetric multiprocessor (SMP) bus called Runway <ref> [BCS96, GGH + 97] </ref> used by Hewlett-Packard in their high-end machines, but also it discovered many subtle bugs in early models describing this bus that we created. Our model includes a number of details such as split transactions, out of order transaction completions, and even an element of speculative execution.
Reference: [CC77] <author> P. Cousot and R. Cousot. </author> <title> Abstract intepretation: a unified lattice model for static analysis of programs by construction or approximation of fixpoints. </title> <booktitle> In Proceedings of 4th POPL, </booktitle> <pages> pages 238-252, </pages> <address> Los Angeles, CA, </address> <publisher> ACM Press, </publisher> <year> 1977. </year>
Reference-contexts: Related Work In [Gra94], abstract interpretation <ref> [CC77] </ref> is employed to reduce infinite-system verification to finite 8CTL fl model-checking. They apply this technique to verify the sequential consistency of lazy caching with unbounded queues.
Reference: [CES86] <author> E. M. Clarke, E. A. Emerson, and A. P. Sistla. </author> <title> Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM TOPLAS, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <year> 1986. </year>
Reference-contexts: Even approaches 1 based on conventional model-checking are impossibly difficult to use in practice. For example, the assertions pertaining to the sequential consistency of lazy caching [Ger95], a simple memory system, expressed in various temporal logics (by [Gra94] in 8CTL fl <ref> [CES86] </ref> and [LLOR97] in TLA [Lam94]) are highly complex. We do not believe that descriptions of this style will scale up.
Reference: [Col] <author> W. W. Collier. </author> <title> Multiprocessor diagnostics. </title> <address> http://www.infomall.org/diagnostics/archtest.html. </address>
Reference-contexts: In this paper we describe such a method called test model-checking. Test model-checking formally adapts to the realm of model-checking a formally based architectural testing method called Archtest. Archtest has been successfully used on a number of commercial multiprocessors <ref> [Col] </ref> by running a suite of test-programs on them. Archtest is an incomplete testing method in that it does not, under all circumstances, detect violations of memory orderings [Col92]. Nevertheless, its tests have been shown to be incisive in practice [Col]. <p> has been successfully used on a number of commercial multiprocessors <ref> [Col] </ref> by running a suite of test-programs on them. Archtest is an incomplete testing method in that it does not, under all circumstances, detect violations of memory orderings [Col92]. Nevertheless, its tests have been shown to be incisive in practice [Col]. Most importantly, the formal theory of memory ordering rules developed by Collier in [Col92] forms the basis for Archtest, which means that whenever a violation is detected by Archtest, there is a formal line of reasoning leading back to the precise cause.
Reference: [Col92] <author> W. W. Collier. </author> <title> Reasoning About Parallel Architectures. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1992. </year>
Reference-contexts: Archtest has been successfully used on a number of commercial multiprocessors [Col] by running a suite of test-programs on them. Archtest is an incomplete testing method in that it does not, under all circumstances, detect violations of memory orderings <ref> [Col92] </ref>. Nevertheless, its tests have been shown to be incisive in practice [Col]. Most importantly, the formal theory of memory ordering rules developed by Collier in [Col92] forms the basis for Archtest, which means that whenever a violation is detected by Archtest, there is a formal line of reasoning leading back <p> Archtest is an incomplete testing method in that it does not, under all circumstances, detect violations of memory orderings <ref> [Col92] </ref>. Nevertheless, its tests have been shown to be incisive in practice [Col]. Most importantly, the formal theory of memory ordering rules developed by Collier in [Col92] forms the basis for Archtest, which means that whenever a violation is detected by Archtest, there is a formal line of reasoning leading back to the precise cause. Being based on Archtest, test model-checking is also incomplete. <p> fashion? We still have not found a satisfactory answer to the first question because the test in [McM93] uses only one location which then couldn't make it a test for sequential consistency; it could plausibly be a test for coherence|which again does not correspond to what Collier formally proves in <ref> [Col92] </ref>. One of our contributions is that we answer these questions by elaborating on the theoretical as well as practical aspects of test model-checking. <p> Second, our method is more useful for CPU designers as it can give feedback during early phases of the design pinpointing which ordering rules are violated (if any). 2 Overview of Archtest Archtest is based on the theory presented in <ref> [Col92] </ref> that formally defines and characterizes architectural rules obeyed by memory subsystems of multiprocessors. Although these rules are elemental, in realistic memory systems the rules manifest in compound form. <p> As suggested in <ref> [Col92] </ref>, we can show that sequential consistency is A (CM P; P O; W A). As [Col92] does not list a single compound test to check for A (CM P; P O; W A), we can use the following two tests that are available: "Test 7" which tests for A (CM <p> As suggested in <ref> [Col92] </ref>, we can show that sequential consistency is A (CM P; P O; W A). As [Col92] does not list a single compound test to check for A (CM P; P O; W A), we can use the following two tests that are available: "Test 7" which tests for A (CM P; RO; W O; W A) and Test 3 which tests for A (CM P; P <p> This combination is exactly equivalent to testing sequential consistency because P O implies RO and W O (as formally defined in <ref> [Col92] </ref>). For every memory system we consider, these two tests are model-checked separately and summarized in Figure 9. 4.2 Serial memory and Lazy caching The serial memory protocol for n processors and a memory is shown in Figure 7. Serial memories are often used to define SC operationally. <p> A very desirable feature one can provide in a tool based on test model-checking is a menu of previously generated test automata for the various compound rules in <ref> [Col92] </ref>, using which designers can probe their model. We now summarize an insidious bug in our models that has been revealed using test model-checking. Description of a Bug: The following bug in our model of Lazy Caching was caught by a violation of Test 4.
Reference: [Cor97] <author> Francisco Corella, </author> <month> April </month> <year> 1997. </year> <title> Invited talk at Computer Hardware Description Languages 1997, Toledo, Spain, on Verifying I/O Systems. </title>
Reference-contexts: CPU designers are interested in knowing whether some of the aggressive execution techniques such as speculative issue of memory operations violate sequential consistency; I/O bus designers are interested in knowing the exact semantics of shared accesses provided by split I/O transactions <ref> [Cor97] </ref>; even language designers of multi-threaded languages such as Java that support shared updates [GJS96] are interested in this problem.
Reference: [DPN93] <author> David L. Dill, Seungjoon Park, and Andreas Nowatzyk. </author> <title> Formal specification of abstract memory models. </title> <editor> In Gaetano Borriello and Carl Ebeling, editors, </editor> <booktitle> Research on Integrated Systems, </booktitle> <pages> pages 38-52. </pages> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: In [PD96], the authors use a method called aggregation on a distributed shared memory coherence protocol used in an experimental multiprocessor, to arrive at a simplified model of system behavior. Their technique involves manual theorem proving. The work in [HMTLB95] as well as <ref> [DPN93] </ref> are aimed at verifying that synchronization routines work correctly under various memory models, where the memory models themselves are described using finite-state operational models. They do not address the problem of establishing the memory models provided by detailed memory subsystem designs, which is our contribution.
Reference: [Ger95] <author> Rob Gerth. </author> <title> Introduction to sequential consistency and the lazy caching algorithm. </title> <booktitle> Distributed Computing, </booktitle> <year> 1995. </year> <month> 11 </month>
Reference-contexts: For example [PD96] involves the use of manually guided mechanical theorem proving. Even approaches 1 based on conventional model-checking are impossibly difficult to use in practice. For example, the assertions pertaining to the sequential consistency of lazy caching <ref> [Ger95] </ref>, a simple memory system, expressed in various temporal logics (by [Gra94] in 8CTL fl [CES86] and [LLOR97] in TLA [Lam94]) are highly complex. We do not believe that descriptions of this style will scale up. <p> Serial memories are often used to define SC operationally. The lazy caching protocol <ref> [Ger95] </ref>, shown in Figure 8, also implements sequential consistency, and is geared towards a bus based architecture. The memory interface still consists of reads and writes; however, caches C i are interposed between the shared memory M em and the processors P i .
Reference: [GGH + 97] <author> G. Gopalakrishnan, R. Ghughal, R. Hosabettu, A. Mokkedem, and R. Nalumasu. </author> <title> For--mal modeling and validation applied to a commercial coherent bus: A case study. </title> <editor> In Hon F. Li and David K. Probst, editors, CHARME, </editor> <address> Montreal, Canada, </address> <year> 1997. </year>
Reference-contexts: We do not believe that descriptions of this style will scale up. On the other hand, the test model-checking method has not only been able to comfortably handle the memory system defined by the symmetric multiprocessor (SMP) bus called Runway <ref> [BCS96, GGH + 97] </ref> used by Hewlett-Packard in their high-end machines, but also it discovered many subtle bugs in early models describing this bus that we created. Our model includes a number of details such as split transactions, out of order transaction completions, and even an element of speculative execution. <p> The behavior of this memory system is described in some detail in <ref> [GGH + 97] </ref>. The complexity of this protocol stems from many sources, a few of which are elaborated here (see [GGH + 97] for more details). First, the queues in the clients introduce decoupled execution, leading to a large number of "otherwise equivalent" states. <p> The behavior of this memory system is described in some detail in <ref> [GGH + 97] </ref>. The complexity of this protocol stems from many sources, a few of which are elaborated here (see [GGH + 97] for more details). First, the queues in the clients introduce decoupled execution, leading to a large number of "otherwise equivalent" states.
Reference: [GJS96] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java T M Language Specification. Sun Microsystems, </title> <address> 1.0 edition, </address> <month> August </month> <year> 1996. </year> <note> appeared also as book with same title in Addison-Wesleys 'The Java Series'. </note>
Reference-contexts: knowing whether some of the aggressive execution techniques such as speculative issue of memory operations violate sequential consistency; I/O bus designers are interested in knowing the exact semantics of shared accesses provided by split I/O transactions [Cor97]; even language designers of multi-threaded languages such as Java that support shared updates <ref> [GJS96] </ref> are interested in this problem. Formal verification methods are ideally suited for this problem because: (i) the semantics of memory orderings are too subtle to be fathomed through informal reasoning alone; (ii) ad hoc testing methods cannot provide assurance that the desired memory model has been implemented.
Reference: [GK94] <author> Phillip B. Gibbons and Ephraim Korach. </author> <title> On testing cache-coherent shared memories. </title> <booktitle> In Proceedings of the 6th Annual Symposium on Parallel Algorithms and Architectures, </booktitle> <pages> pages 177-188, </pages> <address> New York, NY, USA, June 1994. </address> <publisher> ACM Press. </publisher>
Reference-contexts: They do not address the problem of establishing the memory models provided by detailed memory subsystem designs, which is our contribution. In <ref> [GK97, GK94] </ref>, the authors analyze the problem of deciding whether a given set of traces are sequentially consistent. Our approach differs in two respects.
Reference: [GK97] <author> Phillip B. Gibbons and Ephraim Korach. </author> <title> Testing shared memories. </title> <journal> SIAM Journal on Computing, </journal> <volume> 26(4) </volume> <pages> 1208-1244, </pages> <month> August </month> <year> 1997. </year>
Reference-contexts: They do not address the problem of establishing the memory models provided by detailed memory subsystem designs, which is our contribution. In <ref> [GK97, GK94] </ref>, the authors analyze the problem of deciding whether a given set of traces are sequentially consistent. Our approach differs in two respects.
Reference: [Gra94] <author> S. Graf. </author> <title> Verification of a distributed cache memory by using abstractions. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <address> 818:207-??, </address> <year> 1994. </year>
Reference-contexts: For example [PD96] involves the use of manually guided mechanical theorem proving. Even approaches 1 based on conventional model-checking are impossibly difficult to use in practice. For example, the assertions pertaining to the sequential consistency of lazy caching [Ger95], a simple memory system, expressed in various temporal logics (by <ref> [Gra94] </ref> in 8CTL fl [CES86] and [LLOR97] in TLA [Lam94]) are highly complex. We do not believe that descriptions of this style will scale up. <p> Related Work In <ref> [Gra94] </ref>, abstract interpretation [CC77] is employed to reduce infinite-system verification to finite 8CTL fl model-checking. They apply this technique to verify the sequential consistency of lazy caching with unbounded queues. <p> They apply this technique to verify the sequential consistency of lazy caching with unbounded queues. They recognize that to get an exact characterization of sequential consistency involving only the observable event names, one needs full second order logic <ref> [Gra94] </ref>.
Reference: [HB95] <author> R. Hojati and R. Brayton. </author> <title> Automatic datapath abstraction of hardware systems. </title> <booktitle> In Conference on Computer-Aided Verification, </booktitle> <year> 1995. </year>
Reference-contexts: We also assume that the system is address semi-dependent <ref> [HB95] </ref>, i.e. the control logic can at most compare two addresses for equality or inequality and base its actions on the outcome of this test.
Reference: [HMTLB95] <author> R. Hojati, R. Mueller-Thuns, P. Loewenstein, and R. Brayton. </author> <title> Automatic verification of memory systems which service their requests out of order. </title> <booktitle> In CHDL, </booktitle> <pages> pages 623-639, </pages> <year> 1995. </year>
Reference-contexts: In [PD96], the authors use a method called aggregation on a distributed shared memory coherence protocol used in an experimental multiprocessor, to arrive at a simplified model of system behavior. Their technique involves manual theorem proving. The work in <ref> [HMTLB95] </ref> as well as [DPN93] are aimed at verifying that synchronization routines work correctly under various memory models, where the memory models themselves are described using finite-state operational models. They do not address the problem of establishing the memory models provided by detailed memory subsystem designs, which is our contribution.
Reference: [Lam79] <author> Leslie Lamport. </author> <title> How to make a multiprocessor computer that correctly executes mul-tiprocess programs. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 9(29) </volume> <pages> 690-691, </pages> <year> 1979. </year>
Reference-contexts: The Conditions corresponding to each compound memory rule being tested are turned into corresponding memory rule safety properties that are checked by the VIS tool. The reader may take a peek at Section 4.1 to know which compound rules define sequential consistency <ref> [Lam79] </ref>.
Reference: [Lam93] <author> Leslie Lamport. </author> <title> How to make a correct multiprocess program execute correctly on a multiprocessor. </title> <type> Technical report, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: Details of all our experiments can be obtained from the Web [Mok] or by contacting the authors. 4.1 Sequential consistency and serial memory protocol A sequentially consistent memory system <ref> [Lam93] </ref> requires that there be a single self-consistent trace t of memory operations that when projected onto the memory operations of each individual processor P i (R i (a; d) and W i (a; d) for processor i) is according to program order for P i .
Reference: [Lam94] <author> Leslie Lamport. </author> <title> The temporal logic of actions. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 872-923, </pages> <month> May </month> <year> 1994. </year> <note> Also appeared as SRC Research Report 79. </note>
Reference-contexts: Even approaches 1 based on conventional model-checking are impossibly difficult to use in practice. For example, the assertions pertaining to the sequential consistency of lazy caching [Ger95], a simple memory system, expressed in various temporal logics (by [Gra94] in 8CTL fl [CES86] and [LLOR97] in TLA <ref> [Lam94] </ref>) are highly complex. We do not believe that descriptions of this style will scale up.
Reference: [LLOR97] <author> P. Ladkin, L. Lamport, B. Olivier, and D. Roegel. </author> <title> Lazy caching in tla. </title> <booktitle> Distributed Computing, </booktitle> <year> 1997. </year>
Reference-contexts: Even approaches 1 based on conventional model-checking are impossibly difficult to use in practice. For example, the assertions pertaining to the sequential consistency of lazy caching [Ger95], a simple memory system, expressed in various temporal logics (by [Gra94] in 8CTL fl [CES86] and <ref> [LLOR97] </ref> in TLA [Lam94]) are highly complex. We do not believe that descriptions of this style will scale up.
Reference: [McM93] <author> Kenneth L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic Press, </publisher> <year> 1993. </year>
Reference-contexts: For this stronger characterization, the expression of sequential consistency is very complex, as shown in figure 1 (this figure shows only part of their sequential consistency expression). A technique very similar to test model-checking was proposed in <ref> [McM93] </ref> under the section heading `Sequential Consistency'. To give a historic perspective, our test model-checking idea originated in our attempt to answer the following two questions: (i) which memory ordering rule (s) is [McM93] really verifying? (ii) is this a general technique? i.e. can other memory ordering rules be verified in <p> A technique very similar to test model-checking was proposed in <ref> [McM93] </ref> under the section heading `Sequential Consistency'. To give a historic perspective, our test model-checking idea originated in our attempt to answer the following two questions: (i) which memory ordering rule (s) is [McM93] really verifying? (ii) is this a general technique? i.e. can other memory ordering rules be verified in the same fashion? We still have not found a satisfactory answer to the first question because the test in [McM93] uses only one location which then couldn't make it a test for sequential <p> to answer the following two questions: (i) which memory ordering rule (s) is <ref> [McM93] </ref> really verifying? (ii) is this a general technique? i.e. can other memory ordering rules be verified in the same fashion? We still have not found a satisfactory answer to the first question because the test in [McM93] uses only one location which then couldn't make it a test for sequential consistency; it could plausibly be a test for coherence|which again does not correspond to what Collier formally proves in [Col92].
Reference: [Mok] <author> A. Mokkedem. </author> <title> Verification of three memory systems using test model-checking. </title> <address> http://www.cs.utah.edu/~mokkedem/vis/vis.html. </address>
Reference-contexts: These three memory systems are described in some detail below, along with some of the subtle bugs that we could detect using test model-checking. Details of all our experiments can be obtained from the Web <ref> [Mok] </ref> or by contacting the authors. 4.1 Sequential consistency and serial memory protocol A sequentially consistent memory system [Lam93] requires that there be a single self-consistent trace t of memory operations that when projected onto the memory operations of each individual processor P i (R i (a; d) and W i <p> We found a more complex bug in our model of the Runway bus. Details are too involved to report here, but can be easily obtained from the web site <ref> [Mok] </ref>. 10 5 Conclusion and Future Plans We presented a new approach to verify multi-processors for formal memory models, which combines two existing powerful techniques: model-checking, and the testing method of Archtest.
Reference: [PD96] <author> Seungjoon Park and David L. Dill. </author> <title> Verification of FLASH cache coherence protocol by aggregation of distributed transactions. </title> <booktitle> In SPAA, </booktitle> <pages> pages 288-296, </pages> <address> Padua, Italy, </address> <month> June 24-26, </month> <year> 1996. </year>
Reference-contexts: Being based on Archtest, test model-checking is also incomplete. However, none of the (presumed) complete alternatives to date have been shown to be practical for verifying large designs. For example <ref> [PD96] </ref> involves the use of manually guided mechanical theorem proving. Even approaches 1 based on conventional model-checking are impossibly difficult to use in practice. <p> One of our contributions is that we answer these questions by elaborating on the theoretical as well as practical aspects of test model-checking. In <ref> [PD96] </ref>, the authors use a method called aggregation on a distributed shared memory coherence protocol used in an experimental multiprocessor, to arrive at a simplified model of system behavior. Their technique involves manual theorem proving.
Reference: [Ver] <author> Vis-1.2 release. </author> <note> http://www-cad.eecs.berkeley.edu/Respep/Research/vis/index.html. </note>
Reference-contexts: In our experiments, we use the Verilog language supported by VIS <ref> [Ver] </ref> to capture the memory system models as well as the test automata. The Conditions corresponding to each compound memory rule being tested are turned into corresponding memory rule safety properties that are checked by the VIS tool. <p> that this abstraction preserves PO Cross by an argument similar to that for Test 1 and Test 2. 4 Case Studies To demonstrate the effectiveness of our approach, we verified three different memory systems, namely serial memory, lazy caching, and a simplified version of the Runway bus, all using VIS <ref> [Ver] </ref>. These three memory systems are described in some detail below, along with some of the subtle bugs that we could detect using test model-checking.
Reference: [WG94] <author> David L. Weaver and Tom Germond. </author> <title> The SPARC Architecture Manual Version 9. P T R Prentice-Hall, </title> <address> Englewood Cliffs, NJ 07632, USA, </address> <year> 1994. </year> <month> 12 </month>
Reference-contexts: So far we have identified the rules and corresponding tests for sequential consistency. We are currently working on identifying similar rules and tests for other well-known formal memory models such as TSO, PSO, and RMO [AG96] that are described in the SPARC V9 architecture manual <ref> [WG94] </ref>. This work may involve defining new rules as well as new tests corresponding to them. We are currently working to formulate some reasonable assumptions about the memory system model under which the tests administered by our test automata can be rendered complete.
References-found: 25

