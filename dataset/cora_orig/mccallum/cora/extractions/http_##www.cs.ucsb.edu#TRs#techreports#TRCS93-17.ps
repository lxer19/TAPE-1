URL: http://www.cs.ucsb.edu/TRs/techreports/TRCS93-17.ps
Refering-URL: http://www.cs.ucsb.edu/TRs/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Relative Serializability: An Approach for Relaxing the Atomicity of Transactions  
Author: D. Agrawal J. L. Bruno A. El Abbadi V. Krishnaswamy 
Address: Santa Barbara, CA 93106  
Affiliation: Department of Computer Science University of California  
Abstract: In the presence of semantic information, serializability is too strong a correctness criterion and unnecessarily restricts concurrency. We use the semantic information of a transaction to provide different atomicity views of the transaction to other transactions. The proposed approach improves concurrency and allows interleavings among transactions which are non-serializable, but which nonetheless preserve the consistency of the database and are acceptable to the users. We develop a graph-based tool whose acyclicity is both a necessary and sufficient condition for the correctness of an execution. Our theory encompasses earlier proposals that incorporate semantic information of transactions. Furthermore it is the first approach that provides an efficient graph based tool for recognizing correct schedules without imposing any restrictions on the application domain. Our approach is widely applicable to many advanced database applications such as systems with long-lived transactions and collaborative environments.
Abstract-found: 1
Intro-found: 1
Reference: [Bad79] <author> D. Z. Badal. </author> <title> Correctness of Concurrency Control and Implications in Distributed Databases. </title> <booktitle> In IEEE Proceedings of COMPSAC Conference, </booktitle> <pages> pages 588-593, </pages> <month> November </month> <year> 1979. </year>
Reference-contexts: Therefore S rs is relatively serial. 2 The relative serialization graph provides an efficient (polynomial) method for recognizing relatively se-rializable schedules. This graph can be used as the basis for a concurrency control protocol similar to serialization graph testing <ref> [Bad79, Cas81] </ref>. We are currently investigating locking protocols for ensuring relative serializability of transactions with relative atomicity. 4 Related Work The relative atomicity model is a generalization of the traditional absolute atomicity model.
Reference: [BK91] <author> N. S. Barghouti and G. E. Kaiser. </author> <title> Concurrency Control in Advanced Database Applications. </title> <journal> ACM Computing Surveys, </journal> <volume> 23(3) </volume> <pages> 269-318, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: Databases are increasingly used in applications, where transactions may be long lived, or where transactions correspond to executions of various users cooperating with each other, e.g., in design databases, CAD/CAM databases, etc. For such applications serializability is found to be too restrictive <ref> [BK91] </ref>. Researchers, in general, have taken two different approaches to address this problem.
Reference: [BR92] <author> B. R. Badrinath and K. Ramamritham. </author> <title> Semantics-Based Concurrency Control: Beyond Com-mutativity. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 17(1) </volume> <pages> 163-199, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: Researchers, in general, have taken two different approaches to address this problem. Instead of modeling the database as a collection of objects that can only be read or written by transactions, a number of researchers have considered placing more structure on data objects to exploit type specific semantics <ref> [Kor83, SS84, Her86, Wei89, BR92] </ref>. This approach increases concurrency in the system while remaining within the confines of serializability.
Reference: [BSW79] <author> P. A. Bernstein, D. W. Shipman, and W. S. Wong. </author> <title> Formal Aspects of Serializability in Database Concurrency Control. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 5(5) </volume> <pages> 203-216, </pages> <month> May </month> <year> 1979. </year>
Reference-contexts: 1 Introduction The traditional approach for transaction management in multi-user database systems is to maintain entire transactions as single atomic units with respect to each other. Such atomicity of transactions is enforced in most commercial database systems by ensuring that the interleaved execution of concurrent transactions remains serializable <ref> [EGLT76, RSL78, Pap79, BSW79] </ref>. Databases are increasingly used in applications, where transactions may be long lived, or where transactions correspond to executions of various users cooperating with each other, e.g., in design databases, CAD/CAM databases, etc. For such applications serializability is found to be too restrictive [BK91]. <p> In order to relate schedules over the same set of transactions, the notion of conflict between operations is used in concurrency control theory <ref> [Pap79, BSW79] </ref>. Two operations of different transactions conflict if they access the same data object and at least one of them is a write operation. Two schedules are conflict equivalent if they both order conflicting operations in the same manner. <p> If S rs is serial then the lemma is trivially satisfied. If S rs is not serial, assume for contradiction that there does not exist any serial schedule that is conflict equivalent to S rs . Consider the serialization graph SG (S rs ) for S rs <ref> [Pap79, BSW79] </ref>. SG (S rs ) has transactions in T as its nodes and T i ! T k is an edge in SG (S rs ) if an operation of T i conflicts and precedes an operation of T k in S rs . <p> From the definition of relatively serializable schedules and Lemma 1, it is clear that under absolute atomicity, any relatively serializable schedule is equivalent to a serial schedule. Thus, the set of relatively serializable schedules is exactly the same as the set of conflict serializable schedules <ref> [Pap79, BSW79] </ref> under absolute atomicity. <p> We are currently investigating locking protocols for ensuring relative serializability of transactions with relative atomicity. 4 Related Work The relative atomicity model is a generalization of the traditional absolute atomicity model. In particular, our model retains the standard notion of correctness based on on conflict serializability <ref> [Pap79, BSW79] </ref> when the relative atomicity specifications are restricted to specify the traditional transaction model. Although the proposed model is useful in environments where transaction semantics is available, it may as well be used in the standard database systems without jeopardizing correctness.
Reference: [Cas81] <author> M. A. Casanova. </author> <title> The Concurrency Control Problem of Database Systems, </title> <booktitle> volume 116 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1981. </year>
Reference-contexts: Therefore S rs is relatively serial. 2 The relative serialization graph provides an efficient (polynomial) method for recognizing relatively se-rializable schedules. This graph can be used as the basis for a concurrency control protocol similar to serialization graph testing <ref> [Bad79, Cas81] </ref>. We are currently investigating locking protocols for ensuring relative serializability of transactions with relative atomicity. 4 Related Work The relative atomicity model is a generalization of the traditional absolute atomicity model.
Reference: [EGLT76] <author> K. P. Eswaran, J. N. Gray, R. A. Lorie, and I. L. Traiger. </author> <title> The Notions of Consistency and Predicate Locks in a Database System. </title> <journal> Communications of the ACM, </journal> 19(11) 624-633, November 1976. 
Reference-contexts: 1 Introduction The traditional approach for transaction management in multi-user database systems is to maintain entire transactions as single atomic units with respect to each other. Such atomicity of transactions is enforced in most commercial database systems by ensuring that the interleaved execution of concurrent transactions remains serializable <ref> [EGLT76, RSL78, Pap79, BSW79] </ref>. Databases are increasingly used in applications, where transactions may be long lived, or where transactions correspond to executions of various users cooperating with each other, e.g., in design databases, CAD/CAM databases, etc. For such applications serializability is found to be too restrictive [BK91]. <p> In fact, the class of relatively serializable schedules is larger than the class of relatively consistent schedules. The next step, in traditional databases was the development of more efficient locking based protocols such as the two phase locking protocol <ref> [EGLT76] </ref> which recognize subsets of the set of conflict serializable schedules. We are currently developing such efficient, lock based protocols for recognizing relatively serializable executions. We conclude by emphasizing the wide applicability of relative atomicity to many advance database applications.
Reference: [F O89] <author> A. A. Farrag and M. T. Ozsu. </author> <title> Using Semantic Knowledge of Transactions to Increase Concur-rency. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 14(4) </volume> <pages> 503-525, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: This approach increases concurrency in the system while remaining within the confines of serializability. The other approach relaxes the absolute atomicity of transactions and uses the explicit semantics of transactions to allow executions in which a transaction may provide different atomicity views to other transactions <ref> [Gar83, Lyn83, F O89] </ref>. For example, consider a transaction T consisting of database operations o 1 o 2 o 3 . <p> However, Lynch's proposal is comprehensive in that it not only specifies a notion of correctness but also provides a graph-based tool to efficiently recognize correct executions. Farrag and Ozsu <ref> [F O89] </ref> used the notion of breakpoints, which provides maximal freedom for relative atomicity specifications. In addition, they propose a graph which aids in the recognition of executions that are "equivalent" to correct executions. <p> The above specifications could also be specified in terms of transactions types instead of transactions instances as in <ref> [Gar83, F O89] </ref>. However, for simplicity of exposition we will restrict ourselves to relative atomicity in terms of transaction instances [Lyn83]. The relative atomicity specifications can also be specified by using the notion of atomic steps [Gar83] or breakpoints [F O89]. <p> However, for simplicity of exposition we will restrict ourselves to relative atomicity in terms of transaction instances [Lyn83]. The relative atomicity specifications can also be specified by using the notion of atomic steps [Gar83] or breakpoints <ref> [F O89] </ref>. A correct execution in the traditional transaction model requires that all operations of a transaction appear as a single atomic unit. We refer to this as absolute atomicity. <p> T can be defined as follows: Definition 1 S is a relatively atomic schedule over T if for all transactions T i and T l no operation of T i is interleaved with an AtomicU nit (k; T l ; T i ) for any k. 4 Farrag and Ozsu <ref> [F O89] </ref> refer to relatively atomic schedules as correct schedules. Further, they define relatively consistent schedules as the schedules that are conflict equivalent to a relatively atomic schedule. Unfortunately, recognizing the class of relatively consistent schedules is NP-complete [KB92]. <p> Pull Backward Arcs (B-arc). For each D-arc o kl ! o ij we add o kl ! P ullBackward (o ij ; T k ) in E. Lynch [Lyn83] as well as Farrag and Ozsu <ref> [F O89] </ref> use the notion of pushing forward an operation out of an atomic unit. However, neither of them employed the notion of pulling backward an operation out of an atomic unit. <p> Relative atomicity, on the other hand, imposes no constraints on the user specifications. It is easy to construct examples that can be specified using relative atomicity but cannot be specified using multilevel atomicity. We now compare the set of relatively consistent schedules <ref> [F O89] </ref> and the set of relatively serializable schedules under relative atomicity. Since relatively consistent schedules are conflict equivalent to relatively atomic [F O89] schedules and the set of relatively atomic schedules is a subset of the set of relatively serial schedules, it follows that relatively consistent schedules are also relatively <p> We now compare the set of relatively consistent schedules <ref> [F O89] </ref> and the set of relatively serializable schedules under relative atomicity. Since relatively consistent schedules are conflict equivalent to relatively atomic [F O89] schedules and the set of relatively atomic schedules is a subset of the set of relatively serial schedules, it follows that relatively consistent schedules are also relatively serializable. <p> The relationships among the classes described above is given in Figure 5. The inclusions of the sets follow from the definitions. The example given in Figure 4 shows that the set of relatively serializable schedules properly contains the set of relatively consistent schedules defined by Farrag and Ozsu <ref> [F O89] </ref>. There have been other proposals to weaken the atomicity of transactions for improving concurrency. However, these approaches remain within the confines of traditional serializability. Their primary goal is to relax the two phase restriction of strict two phase locking.
Reference: [Gar83] <author> H. Garcia-Molina. </author> <title> Using Semantic Knowledge for Transaction Processing in a Distributed Database. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 8(2) </volume> <pages> 186-213, </pages> <month> June </month> <year> 1983. </year>
Reference-contexts: This approach increases concurrency in the system while remaining within the confines of serializability. The other approach relaxes the absolute atomicity of transactions and uses the explicit semantics of transactions to allow executions in which a transaction may provide different atomicity views to other transactions <ref> [Gar83, Lyn83, F O89] </ref>. For example, consider a transaction T consisting of database operations o 1 o 2 o 3 . <p> If relative atomicity specifications are to be used in practice, we need to develop a theory similar to the traditional serializability theory. Garcia-Molina <ref> [Gar83] </ref> pioneered the effort to use the notion of relative atomicity to increase concurrency in database systems. He proposed grouping transactions into compatibility sets, where transactions in one such set may be arbitrarily interleaved, but transactions in different sets observe each other as single atomic units. <p> The above specifications could also be specified in terms of transactions types instead of transactions instances as in <ref> [Gar83, F O89] </ref>. However, for simplicity of exposition we will restrict ourselves to relative atomicity in terms of transaction instances [Lyn83]. The relative atomicity specifications can also be specified by using the notion of atomic steps [Gar83] or breakpoints [F O89]. <p> However, for simplicity of exposition we will restrict ourselves to relative atomicity in terms of transaction instances [Lyn83]. The relative atomicity specifications can also be specified by using the notion of atomic steps <ref> [Gar83] </ref> or breakpoints [F O89]. A correct execution in the traditional transaction model requires that all operations of a transaction appear as a single atomic unit. We refer to this as absolute atomicity. <p> Although the proposed model is useful in environments where transaction semantics is available, it may as well be used in the standard database systems without jeopardizing correctness. One of the earliest proposals to depart from absolute atomicity of transactions was proposed by Garcia-Molina <ref> [Gar83] </ref>. However, his approach for relaxing atomicity of transactions is a special case of relative atomicity. Although Lynch [Lyn83] proposed relative atomicity, her model is restricted to hierarchical relative atomicity specifications called multilevel atomicity.
Reference: [Her86] <author> M. Herlihy. </author> <title> A Quorum-Consensus Replication Method for Abstract Data Types. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 4(1) </volume> <pages> 32-53, </pages> <month> February </month> <year> 1986. </year>
Reference-contexts: Researchers, in general, have taken two different approaches to address this problem. Instead of modeling the database as a collection of objects that can only be read or written by transactions, a number of researchers have considered placing more structure on data objects to exploit type specific semantics <ref> [Kor83, SS84, Her86, Wei89, BR92] </ref>. This approach increases concurrency in the system while remaining within the confines of serializability.
Reference: [KB92] <author> V. Krishnaswamy and J. Bruno. </author> <title> On the Complexity of Concurrency Control using Semantic Information. </title> <type> Technical Report TRCS 92-21, </type> <institution> Department of Computer Science, University of California, Santa Barbara, </institution> <address> CA 93106, </address> <year> 1992. </year>
Reference-contexts: Unfortunately, the complexity of recognizing relatively consistent executions is NP-Complete <ref> [KB92] </ref>. In this paper, we retain the notion of conflict equivalence and reduce the complexity of this problem by modifying the notion of correct executions. This is in contrast to the traditional approach of strengthening 2 the notion of equivalence for reducing the complexity of the problem 1 . <p> Further, they define relatively consistent schedules as the schedules that are conflict equivalent to a relatively atomic schedule. Unfortunately, recognizing the class of relatively consistent schedules is NP-complete <ref> [KB92] </ref>. To reduce the complexity of recognizing relatively consistent schedules, we modify the definition of correct schedules. We motivate our approach by studying the reason for the NP-Completeness with the above definition of correctness. The complexity result arises due to the ambiguity in ordering non-conflicting operations.
Reference: [Kor83] <author> H. F. Korth. </author> <title> Locking Primitives in a Database System. </title> <journal> Journal of the ACM, </journal> <volume> 30(1) </volume> <pages> 55-79, </pages> <month> January </month> <year> 1983. </year> <month> 13 </month>
Reference-contexts: Researchers, in general, have taken two different approaches to address this problem. Instead of modeling the database as a collection of objects that can only be read or written by transactions, a number of researchers have considered placing more structure on data objects to exploit type specific semantics <ref> [Kor83, SS84, Her86, Wei89, BR92] </ref>. This approach increases concurrency in the system while remaining within the confines of serializability.
Reference: [Kri93] <author> V. Krishnaswamy. </author> <title> Semantics based Concurrency Control. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of California, Santa Barbara, </institution> <year> 1993. </year> <note> In preparation. </note>
Reference-contexts: We say that an operation o of a transaction T j is interleaved with an AtomicU nit (k; T i ; T j ) in a schedule S, if there exist 1 Such an approach is explored in <ref> [Kri93] </ref>. 2 In general, transactions and schedules are permitted to be partially ordered sequences.
Reference: [Lyn83] <author> N. A. Lynch. </author> <title> Multilevel Atomicity ANew Correctness Criterion for Database Concurrency Control. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 8(4) </volume> <pages> 485-502, </pages> <month> December </month> <year> 1983. </year>
Reference-contexts: This approach increases concurrency in the system while remaining within the confines of serializability. The other approach relaxes the absolute atomicity of transactions and uses the explicit semantics of transactions to allow executions in which a transaction may provide different atomicity views to other transactions <ref> [Gar83, Lyn83, F O89] </ref>. For example, consider a transaction T consisting of database operations o 1 o 2 o 3 . <p> The user may specify 1 that T should appear as o 1 o 2 o 3 to T 0 but as o 1 o 2 o 3 to T 00 . Lynch <ref> [Lyn83] </ref> introduced this notion and refers to it as relative atomicity . In [Lyn83], several examples are presented to motivate the advantages of relative atomicity for banking applications and computer-aided design environments. In the banking example, customers are grouped into families each of which shares a common set of accounts. <p> The user may specify 1 that T should appear as o 1 o 2 o 3 to T 0 but as o 1 o 2 o 3 to T 00 . Lynch <ref> [Lyn83] </ref> introduced this notion and refers to it as relative atomicity . In [Lyn83], several examples are presented to motivate the advantages of relative atomicity for banking applications and computer-aided design environments. In the banking example, customers are grouped into families each of which shares a common set of accounts. <p> He proposed grouping transactions into compatibility sets, where transactions in one such set may be arbitrarily interleaved, but transactions in different sets observe each other as single atomic units. Clearly, Garcia-Molina's proposal is a special case of transactions with relative atomicity specifications. Lynch <ref> [Lyn83] </ref> extended Garcia-Molina's specifications from two-level compatibility sets to hierarchically structured interleaving sets, allowing transactions to have varying atomic units relative to each other. Once again, it can be argued that Lynch's hierarchical specifications are restrictive and do not model the general notion of relative atomicity. <p> The above specifications could also be specified in terms of transactions types instead of transactions instances as in [Gar83, F O89]. However, for simplicity of exposition we will restrict ourselves to relative atomicity in terms of transaction instances <ref> [Lyn83] </ref>. The relative atomicity specifications can also be specified by using the notion of atomic steps [Gar83] or breakpoints [F O89]. A correct execution in the traditional transaction model requires that all operations of a transaction appear as a single atomic unit. We refer to this as absolute atomicity. <p> Pull Backward Arcs (B-arc). For each D-arc o kl ! o ij we add o kl ! P ullBackward (o ij ; T k ) in E. Lynch <ref> [Lyn83] </ref> as well as Farrag and Ozsu [F O89] use the notion of pushing forward an operation out of an atomic unit. However, neither of them employed the notion of pulling backward an operation out of an atomic unit. <p> One of the earliest proposals to depart from absolute atomicity of transactions was proposed by Garcia-Molina [Gar83]. However, his approach for relaxing atomicity of transactions is a special case of relative atomicity. Although Lynch <ref> [Lyn83] </ref> proposed relative atomicity, her model is restricted to hierarchical relative atomicity specifications called multilevel atomicity. Lynch has proposed a graph-based tool for efficiently recognizing schedules that are equivalent to multilevel atomic schedules.
Reference: [Pap79] <author> C. H. Papadimitriou. </author> <title> The Serializability of Concurrent Database Updates. </title> <journal> Journal of the ACM, </journal> <volume> 26(4) </volume> <pages> 631-653, </pages> <month> October </month> <year> 1979. </year>
Reference-contexts: 1 Introduction The traditional approach for transaction management in multi-user database systems is to maintain entire transactions as single atomic units with respect to each other. Such atomicity of transactions is enforced in most commercial database systems by ensuring that the interleaved execution of concurrent transactions remains serializable <ref> [EGLT76, RSL78, Pap79, BSW79] </ref>. Databases are increasingly used in applications, where transactions may be long lived, or where transactions correspond to executions of various users cooperating with each other, e.g., in design databases, CAD/CAM databases, etc. For such applications serializability is found to be too restrictive [BK91]. <p> In order to relate schedules over the same set of transactions, the notion of conflict between operations is used in concurrency control theory <ref> [Pap79, BSW79] </ref>. Two operations of different transactions conflict if they access the same data object and at least one of them is a write operation. Two schedules are conflict equivalent if they both order conflicting operations in the same manner. <p> If S rs is serial then the lemma is trivially satisfied. If S rs is not serial, assume for contradiction that there does not exist any serial schedule that is conflict equivalent to S rs . Consider the serialization graph SG (S rs ) for S rs <ref> [Pap79, BSW79] </ref>. SG (S rs ) has transactions in T as its nodes and T i ! T k is an edge in SG (S rs ) if an operation of T i conflicts and precedes an operation of T k in S rs . <p> From the definition of relatively serializable schedules and Lemma 1, it is clear that under absolute atomicity, any relatively serializable schedule is equivalent to a serial schedule. Thus, the set of relatively serializable schedules is exactly the same as the set of conflict serializable schedules <ref> [Pap79, BSW79] </ref> under absolute atomicity. <p> We are currently investigating locking protocols for ensuring relative serializability of transactions with relative atomicity. 4 Related Work The relative atomicity model is a generalization of the traditional absolute atomicity model. In particular, our model retains the standard notion of correctness based on on conflict serializability <ref> [Pap79, BSW79] </ref> when the relative atomicity specifications are restricted to specify the traditional transaction model. Although the proposed model is useful in environments where transaction semantics is available, it may as well be used in the standard database systems without jeopardizing correctness.
Reference: [RSL78] <author> D. J. Rosenkrantz, R. E. Stearns, and P. M. Lewis. </author> <title> System Level Concurrency Control for Distributed Database Systems. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 3(2) </volume> <pages> 178-198, </pages> <month> June </month> <year> 1978. </year>
Reference-contexts: 1 Introduction The traditional approach for transaction management in multi-user database systems is to maintain entire transactions as single atomic units with respect to each other. Such atomicity of transactions is enforced in most commercial database systems by ensuring that the interleaved execution of concurrent transactions remains serializable <ref> [EGLT76, RSL78, Pap79, BSW79] </ref>. Databases are increasingly used in applications, where transactions may be long lived, or where transactions correspond to executions of various users cooperating with each other, e.g., in design databases, CAD/CAM databases, etc. For such applications serializability is found to be too restrictive [BK91].
Reference: [SGMA87] <author> K. M. Salem, H. Garcia-Molina, and R. Alonso. </author> <title> Altruistic Locking: A Strategy for Coping with Long-Lived Transactions. </title> <editor> In D. Gawlick, M. Haynie, and A. Reuter, editors, </editor> <booktitle> Proceedings of the Workshop on High Performance Transaction Processing, volume 359 of Lecture Notes in Computer Science, </booktitle> <pages> pages 175-199. </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: We conclude by emphasizing the wide applicability of relative atomicity to many advance database applications. In particular, we envision relative atomicity to be especially useful for systems with long lived transactions as well as several advanced collaborative database environments. In fact, for long live transactions, Salem, Garcia-Molina and Alonso <ref> [SGMA87] </ref> proposed the use of altruistic locking where a transaction is allowed to explicitly release a lock early so as to allow other transactions to observe it results. In [SGMA87] it is argued and experimentally shown that such locks provide improved performance for long-lived transactions. <p> In fact, for long live transactions, Salem, Garcia-Molina and Alonso <ref> [SGMA87] </ref> proposed the use of altruistic locking where a transaction is allowed to explicitly release a lock early so as to allow other transactions to observe it results. In [SGMA87] it is argued and experimentally shown that such locks provide improved performance for long-lived transactions. Relative atomicity can be viewed as a natural generalization of this approach where different degrees of atomicity are allowed with respect to different transactions.
Reference: [SS84] <author> P. M. Schwarz and A. Z. Spector. </author> <title> Synchronizing Shared Abstract Types. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(3) </volume> <pages> 223-250, </pages> <month> August </month> <year> 1984. </year>
Reference-contexts: Researchers, in general, have taken two different approaches to address this problem. Instead of modeling the database as a collection of objects that can only be read or written by transactions, a number of researchers have considered placing more structure on data objects to exploit type specific semantics <ref> [Kor83, SS84, Her86, Wei89, BR92] </ref>. This approach increases concurrency in the system while remaining within the confines of serializability.
Reference: [SSV92] <author> D. Shasha, E. Simon, and P. Valduriez. </author> <title> Simple Rational Guidance for Chopping Up Transactions. </title> <booktitle> In Proceedings of the 1992 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 298-307, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Shasha et al. <ref> [SSV92] </ref> have proposed a chopping graph to refine user transactions such that only the smaller units of the transactions instead of the entire one need to be executed using strict two phase locking. 5 Discussion In this paper we have developed a theory for relaxing the atomicity of transactions to increase
Reference: [Wei89] <author> W. E. Weihl. </author> <title> Local Atomicity Properties: Modular Concurrency Control for Abstract Data Types. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(2) </volume> <pages> 249-283, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: Researchers, in general, have taken two different approaches to address this problem. Instead of modeling the database as a collection of objects that can only be read or written by transactions, a number of researchers have considered placing more structure on data objects to exploit type specific semantics <ref> [Kor83, SS84, Her86, Wei89, BR92] </ref>. This approach increases concurrency in the system while remaining within the confines of serializability.
Reference: [Wol86] <author> O. Wolfson. </author> <title> An Algorithm for Early Unlocking of Entities in Database Transactions. </title> <journal> Journal of Algorithms, </journal> <volume> 7(1) </volume> <pages> 146-156, </pages> <year> 1986. </year>
Reference-contexts: There have been other proposals to weaken the atomicity of transactions for improving concurrency. However, these approaches remain within the confines of traditional serializability. Their primary goal is to relax the two phase restriction of strict two phase locking. Wolfson <ref> [Wol86, Wol87] </ref> uses preanalysis of read 10 Consider a set of transactions T = fT 1 ; T 2 ; T 3 ; T 4 g where T 1 = w 1 [x]w 1 [y] T 3 = w 3 [t]w 3 [z] Atomicity (T 1 ; T 2 ): w
Reference: [Wol87] <author> O. Wolfson. </author> <title> The Virtues of Locking by Symbolic Names. </title> <journal> Journal of Algorithms, </journal> <volume> 8 </volume> <pages> 536-556, </pages> <year> 1987. </year> <month> 14 </month>
Reference-contexts: There have been other proposals to weaken the atomicity of transactions for improving concurrency. However, these approaches remain within the confines of traditional serializability. Their primary goal is to relax the two phase restriction of strict two phase locking. Wolfson <ref> [Wol86, Wol87] </ref> uses preanalysis of read 10 Consider a set of transactions T = fT 1 ; T 2 ; T 3 ; T 4 g where T 1 = w 1 [x]w 1 [y] T 3 = w 3 [t]w 3 [z] Atomicity (T 1 ; T 2 ): w
References-found: 21

