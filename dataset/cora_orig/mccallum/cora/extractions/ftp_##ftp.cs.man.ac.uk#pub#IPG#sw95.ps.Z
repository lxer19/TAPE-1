URL: ftp://ftp.cs.man.ac.uk/pub/IPG/sw95.ps.Z
Refering-URL: http://www.cs.man.ac.uk/ipg/publications.html
Root-URL: http://www.cs.man.ac.uk
Email: email: j-sa@csm.uwe.ac.uk  email: brian@cs.man.ac.uk  
Title: A Reflexive Formal Software Process Model  
Author: J. Sa B.C. Warboys 
Address: England, Bristol  Manchester, Manchester  
Affiliation: Department of Computing, University of the West of  Department of Computer Science, The University of  
Abstract: In this paper a very simple reflexive formal software development method is described. The method is called OBM which provides a formal specification language. This paper demonstrates that the OBM development method can be defined as a process model in the OBM language. An example is used to illustrate how to develop and modify applications using the OBM development method. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> V. Ambriola and Carlo Montangero. </author> <title> Oikos at the Age of Three. </title> <booktitle> In Proceedings EWSPT'92, volume 635 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: An example of this type of approach is Process Weaver [8]. Another type of approach is incremental definitions. Examples of this type of approach include: tasks in Epos [5], activities in Slang [2], blackboard in Oikos <ref> [1] </ref>. However there is no support for formal reasoning between different levels of abstraction. Since Slang is based on Petri-nets, it should be possible to perform formal reasoning, however, it is not clear to the authors whether such a facility is provided by [2]. <p> Since Slang is based on Petri-nets, it should be possible to perform formal reasoning, however, it is not clear to the authors whether such a facility is provided by [2]. Work on consistency proof for refinement in Oikos is in development <ref> [1, 4] </ref>. In [12], a method based on data flow diagram (DFD) for modelling process interface is defined. Although the method has a formal basis for process decomposition, it provides very limited expressive power. 9 Conclusion This paper has illustrated two main points.
Reference: 2. <author> S. Bandinelli, A. Fuggetta, and S. Grigolli. </author> <title> Process Modelling In-the-Large with SLANG. </title> <booktitle> In Proceedings of the Second International Conference on the Software Process, </booktitle> <address> Berlin, </address> <year> 1993. </year>
Reference-contexts: An example of this type of approach is Process Weaver [8]. Another type of approach is incremental definitions. Examples of this type of approach include: tasks in Epos [5], activities in Slang <ref> [2] </ref>, blackboard in Oikos [1]. However there is no support for formal reasoning between different levels of abstraction. Since Slang is based on Petri-nets, it should be possible to perform formal reasoning, however, it is not clear to the authors whether such a facility is provided by [2]. <p> activities in Slang <ref> [2] </ref>, blackboard in Oikos [1]. However there is no support for formal reasoning between different levels of abstraction. Since Slang is based on Petri-nets, it should be possible to perform formal reasoning, however, it is not clear to the authors whether such a facility is provided by [2]. Work on consistency proof for refinement in Oikos is in development [1, 4]. In [12], a method based on data flow diagram (DFD) for modelling process interface is defined.
Reference: 3. <author> H. Barringer, R. Kuiper, and A. Pnueli. </author> <title> Now you may compose temporal logic specifications. </title> <booktitle> In Proceedings of the 16th A.C.M. Symposium on Theory of Computing, </booktitle> <year> 1984. </year>
Reference-contexts: Among the available formalisms that were suitable for describing such systems, we decided to use temporal logic because it was capable of expressing liveness properties [13]. The particular temporal logic we chose offered a compositional approach <ref> [3] </ref>. Using that approach, a system is considered as a collection of components. Each component is specified as a temporal logic formula. The specification of the overall system is obtained by composing all the component specifications.
Reference: 4. <author> X.J. Chen and C. Montangero. </author> <title> Compositional Refinement in Multiple Blackboard Systems. </title> <booktitle> In ESOP'92 European Symposium on Programming, </booktitle> <month> February. </month>
Reference-contexts: Since Slang is based on Petri-nets, it should be possible to perform formal reasoning, however, it is not clear to the authors whether such a facility is provided by [2]. Work on consistency proof for refinement in Oikos is in development <ref> [1, 4] </ref>. In [12], a method based on data flow diagram (DFD) for modelling process interface is defined. Although the method has a formal basis for process decomposition, it provides very limited expressive power. 9 Conclusion This paper has illustrated two main points.
Reference: 5. <author> R. Conradi et al. </author> <title> Design, Use and Implementation of SPELL, a Language for Software Process Modeling and Evolution. </title> <booktitle> In Proceedings EWSPT'92, volume 635 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Some of these are based on hybrid formalisms that use different notations for large-grain and small-grain aspects of process. An example of this type of approach is Process Weaver [8]. Another type of approach is incremental definitions. Examples of this type of approach include: tasks in Epos <ref> [5] </ref>, activities in Slang [2], blackboard in Oikos [1]. However there is no support for formal reasoning between different levels of abstraction.
Reference: 6. <author> R. Conradi, C. Fernstrom and A. Fuggetta. </author> <title> A Conceptual Framework for Evolving Software Processes. in Software Process Modelling and Technology, </title> <editor> A. Finkelstein, J. Kramer and B. Nuseibeh (Eds.), </editor> <publisher> Research Studies Press, Wiley, </publisher> <year> 1994. </year>
Reference-contexts: The activities for managing a process, e.g. creating or changing, are usually referred to as meta-activities. A process consisting of the meta-activities for a particular process is referred to as a meta-process. As pointed out in <ref> [6] </ref>, since meta-processes are also processes, they themselves also need to be created and controlled. What is this meta-meta-process for producing a meta-process? Potentially, there is an infinite chain of meta-processes. This problem can be avoided if a process provides activities with which to manage itself.
Reference: 7. <author> Mark Dowson. </author> <title> Software Process Themes and Issues. </title> <booktitle> In Proceedings of the Second International Conference on the Software Process. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <year> 1993. </year>
Reference-contexts: This means that by slightly modifying the well known and widely accepted notation pre- and post-conditions, we are able to embed the specification of interference. 8.3 Multiple Levels of Abstractions The need for modelling processes in multiple levels of abstraction has been clearly recognised. Dowson pointed out in <ref> [7] </ref> that modelling formalism should accommodate a wide range of model granularity, and allow the refinement of initially large-grain models to address increasing details. The example above has shown that OBM has achieved this requirement. Several existing approaches also provide means to represent a model in multiple levels of abstraction.
Reference: 8. <author> C. Fernstrom. </author> <title> PROCESS WEAVER: Adding Process Support to UNIX. </title> <booktitle> In Proceedings of the Second International Conference on the Software Process, </booktitle> <address> Berlin, </address> <year> 1993. </year>
Reference-contexts: Several existing approaches also provide means to represent a model in multiple levels of abstraction. Some of these are based on hybrid formalisms that use different notations for large-grain and small-grain aspects of process. An example of this type of approach is Process Weaver <ref> [8] </ref>. Another type of approach is incremental definitions. Examples of this type of approach include: tasks in Epos [5], activities in Slang [2], blackboard in Oikos [1]. However there is no support for formal reasoning between different levels of abstraction.
Reference: 9. <author> M.L.Jaccheri and R.Conradi. </author> <title> Techniques for Process Model Evolution in EPOS. </title> <journal> in IEEE TSE. </journal>
Reference-contexts: A similar comparison is given in subsection 7.4. However it does not provide any mechanism for controlling the meta-process itself. For example, if the meta-process is not suitable for a particular project, what can be done about it? EPOS In <ref> [9] </ref>, a meta-process is defined which is capable of changing different types of models, including the meta-model schema itself. The framework described in [9] does not provide formal support for validation or verification of process evolutions. <p> For example, if the meta-process is not suitable for a particular project, what can be done about it? EPOS In <ref> [9] </ref>, a meta-process is defined which is capable of changing different types of models, including the meta-model schema itself. The framework described in [9] does not provide formal support for validation or verification of process evolutions.
Reference: 10. <author> C.B. Jones, </author> <title> Tentative Steps Toward a Development Method for Interfering Programs, </title> <journal> ACM TOPLAS 5(4), </journal> <year> 1983. </year>
Reference-contexts: Although in this paper, we have not discussed about how to validate or verify process changes, since the OBM language has formal semantics, it is possible to perform formal reasoning in our approach. 8.2 Specification of Interference In <ref> [10] </ref>, a method for specifying concurrent behaviour with possible interference is defined in terms of rely and guarantee conditions. The method is used to specify a system for shared variables. In OBM, communication and interaction between different components can only be achieved via operation calls.
Reference: 11. <author> J.A.Keane, J.Sa and B.C.Warboys, </author> <title> Applying a Concurrent Formal Framework to Process Modelling. </title> <booktitle> In Proceedings of FME'94, </booktitle> <address> Barcelona, </address> <month> October, </month> <year> 1994. </year> <pages> Pages 291-305, </pages> <note> LNCS 873. </note>
Reference-contexts: The behaviour of an abstract object is determined by the execution of its operations. The order of these executions must conform to the operation pattern. The temporal semantics of abstract objects are given in <ref> [11] </ref>. An abstract object may be refined by decomposing it into a number of sub-components. In order to justify the refinement, it is necessary to show that the composition of the sub-components is consistent with the abstract object. <p> A sub-operation pattern may also be a single operation. Given a level i+1 refinement, a level i+1 operation is internal if it is not used in the Operation Refinement part. The consistency checking of refinements is described in <ref> [11] </ref>. A boxed object is used for checking the consistency of refinements. It composes level i+1 components together to show that the composition is consistent with the level i abstract object. A boxed object contains a number of components and a list of internal operations. <p> A boxed object contains a number of components and a list of internal operations. The behaviour of a boxed object is the concurrent executions of all the contained components. The behaviour of the internal operations is not visible. The temporal semantics of boxed objects are defined in <ref> [11] </ref>. 4 The Reflexive OBM Based on the original OBM, a new feature is added so that the OBM development process is reflexive. Each object has two parts: the method part (or the meta-part) and the application part. The method part defines how to develop the object. <p> Verifying the Decomposition The decomposition must be checked for its consistency, i.e. we must prove that the composition of back office and check out is consistent with the supermarket node. This type of proof is described in <ref> [11] </ref>. Figure 5 shows that the supermarket node is performing the verification meta-operation. <p> The proof procedure is defined in <ref> [11] </ref>. 7.5 Changing the Method Part specify; verifyup; (modify + decompose; verifydown)*; changeself; 0 specify; verifyup; (modify + decompose; verifydown)*; changeself; 0 specify; verifyup; (modify + decompose; verifydown)*; changeself; 0 Supermarket CheckoutBack office Fig. 6. <p> The consistency check involves: - re-specify the application part of the node; - re-specify the application part of all the child nodes; prove that the composition of the new child specifications is consistent with the new specification of the node (according to the procedures described in <ref> [11] </ref>). The method part can only be changed if the consistency is maintained. After a changeself , all the child nodes will inherit the new pattern. The currently enabled meta-operation will be identified.
Reference: 12. <author> C. Kung. </author> <title> Process Interface Modelling and Consistency Checking. </title> <journal> Journal of System and Software, </journal> <volume> 15 </volume> <pages> 185-191, </pages> <year> 1991. </year>
Reference-contexts: Since Slang is based on Petri-nets, it should be possible to perform formal reasoning, however, it is not clear to the authors whether such a facility is provided by [2]. Work on consistency proof for refinement in Oikos is in development [1, 4]. In <ref> [12] </ref>, a method based on data flow diagram (DFD) for modelling process interface is defined. Although the method has a formal basis for process decomposition, it provides very limited expressive power. 9 Conclusion This paper has illustrated two main points.
Reference: 13. <author> L. Lamport. </author> <title> What Good is Temporal Logic? In R.E.A. </title> <editor> Mason, editor, </editor> <booktitle> Information Processing 83, </booktitle> <pages> pages 657-668, </pages> <publisher> IFIP, </publisher> <year> 1983. </year>
Reference-contexts: Among the available formalisms that were suitable for describing such systems, we decided to use temporal logic because it was capable of expressing liveness properties <ref> [13] </ref>. The particular temporal logic we chose offered a compositional approach [3]. Using that approach, a system is considered as a collection of components. Each component is specified as a temporal logic formula. The specification of the overall system is obtained by composing all the component specifications.
Reference: 14. <author> J. Sa and B.C. Warboys. </author> <title> Specifying Concurrent Object-based Systems using Combined Specification Notations. </title> <type> Technical Report UMCS-91-9-2, </type> <institution> Department of Computer Science, University of Manchester, </institution> <month> July </month> <year> 1991. </year>
Reference-contexts: The interface of an abstract object consists of a list of provided operations, required operations and an operation pattern defined in terms of the provided operations. Operation patterns are defined using an ordering expression. The detailed definition of ordering expressions can be found in <ref> [14] </ref>. The body of an abstract object consists of a call template for each required operation and a definition for each provided operation which contains its type, i.e. active or passive, its call pattern, and its pre and post-conditions.
Reference: 15. <author> R. Snowdon. </author> <title> An Example of Process Change. </title> <booktitle> In Proceedings EWSPT'92, volume 635 of Lecture Notes in Computer Science, </booktitle> <pages> pages 179-195. </pages> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference: 16. <author> M.Suzuki and T.Katayama. </author> <title> Meta-Operations in the Process Model HFSP for the Dynamics and Flexibility of Software Processes. </title> <booktitle> in Proceedings of the First International Conference on software Processes, </booktitle> <year> 1991, </year> <pages> pages 202-217. </pages>
Reference-contexts: PMMS is very similar to our approach as described above. It is able to change the application model. It is able to change the process itself. There is a PMMS for each new goal, i.e. a new object. However PMMS has no formal foundation. HFSP In <ref> [16] </ref>, a meta-process model, called HFSP, is described. HFSP is a process model which describes software processes as a collection of activities which are characterised by their input and output relationship defined as mathematical functions. Meta-operations are introduced for handling the dynamism and flexibility of software processes.
Reference: 17. <author> B. Warboys. </author> <title> The IPSE2.5 Project: Process Modelling as the Basis for a Support Environment. </title> <booktitle> In Proceedings of the First International Conference on System Development Environment and Factories, </booktitle> <address> Berlin, </address> <month> May </month> <year> 1989 </year>
Reference: 18. <author> P. Wegner, </author> <title> Dimensions of Object-Based Language Design. </title> <booktitle> in OOPSLA'87 Proceedings, </booktitle> <month> October, </month> <year> 1987. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: As a result, we gradually added more and more high level constructs to denote the temporal logic formulae. The collection of constructs was eventually evolved to a high level language with its semantics defined in the temporal logic. According to the definitions given in <ref> [18] </ref>, OBM may be classified as an object-based language. However our motivation for defining OBM was not to provide yet another object-oriented language, but to make it easier to specify systems using temporal logic. In OBM, a process is considered to be composed of components which can be executed concurrently.
References-found: 18

