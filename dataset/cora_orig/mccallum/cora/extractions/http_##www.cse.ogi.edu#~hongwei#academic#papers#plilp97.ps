URL: http://www.cse.ogi.edu/~hongwei/academic/papers/plilp97.ps
Refering-URL: http://www.cse.ogi.edu/~hongwei/academic/publications.html
Root-URL: http://www.cse.ogi.edu
Email: Email: hwxi+@cs.cmu.edu  
Title: Evaluation under -abstraction implement v hd and a call-by-need implementation of v hd can significantly
Author: Hongwei Xi 
Keyword: semantics for v  
Note: can  
Address: 5000 Forbes Avenue Pittsburgh, PA 15213  
Affiliation: Department of Mathematical Sciences Carnegie Mellon University  
Abstract: In light of the usual definition of values [15] as terms in weak head normal form (WHNF), a -abstraction is regarded as a value, and therefore no expressions under -abstraction can get evaluated and the sharing of computation under has to be achieved through program transformations such as -lifting and supercombinators. In this paper we generalise the notion of head normal form (HNF) and introduce the definition of generalised head normal form (GHNF). We then define values as terms in GHNF with flexible heads, and study a call-by-value -calculus v hd corresponding to this new notion of values. After establishing a version of normalisation theorem in v hd , we construct an evaluation function eval v hd for v hd which evaluates under - abstraction. We prove that a program can be evaluated in v if it can be evaluated in the usual -calculus to a term in HNF. We also present an operational hd via a SECD machine. We argue that lazy functional programming languages hd to a term in GHNF if and only
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi, L. Cardelli, P.-L. Curien, and I.-I. Levy (1991), </author> <title> Explicit substitutions, </title> <journal> Journal of Functional Programming, </journal> <volume> 4(1), </volume> <pages> pp. 375-416. </pages>
Reference: [2] <author> S. </author> <title> Abramsky (1990), The lazy lambda calculus. </title> <editor> In D. Turner, editor, </editor> <booktitle> Declarative Programming, </booktitle> <publisher> Addison-Wesley Publishing Company. </publisher>
Reference: [3] <author> Z.M. Ariola, M. Felleisen, J. Maraist, M. Odersky and P. </author> <title> Wadler (1996), A Call-by-Need Lambda Calculus, </title> <booktitle> Proceedings of the 22 nd ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Francisco, </address> <pages> pp. 233-246 </pages>
Reference-contexts: This is justified in most actual implementations which allocate only one cell for cons, representing S as a cyclic data structure. Therefore, the v hd -calculus does not have the deficiency of the call-by-need -calculus <ref> [3] </ref>, where S evaluates to cons (0; S) containing two distinct cons cells. 21 8.3. Primitive Functions Primitive functions have to be handled individually according to their semantics. We use a few examples illustrating our points. <p> We are currently studying on this subject. 9. Related Work v hd is closely related to the weak -calculus in [18] and the call-by-need -calculus in <ref> [3] </ref> in the following sense; we can define a kind of redex as a term of form M (N ) and its contractum as subN *gbd (M ), where M is a term with hd (M ) = 0 and N is a variable or a -abstraction; it can be readily <p> variable or a -abstraction; it can be readily verified that such a form is closed under value substitution if values are defined as variables or -abstractions; we can then define a kind of -calculus corresponding to such redexes; a close correspondence between this -calculus and the -calculi in [18] and <ref> [3] </ref> can be established accordingly. It is this observation that motivates the paper. The problem of sharing evaluation under -abstraction has lead to a great deal of study on -lifting [12] and supercombinators [9] under the title full laziness or maximal laziness.
Reference: [4] <author> H.P. Barendregt, </author> <title> The Lambda Calculus: Its Syntax and Semantics, </title> <publisher> North-Holland, </publisher> <address> Ams-terdam, </address> <year> 1984. </year>
Reference-contexts: The eighth section deals with extensions of v hd with recursion combinators, constructors and primitive operators. The rest of the paper discusses some related work and future directions. 2. Preliminaries We assume a basic familiarity of the reader with the -calculus <ref> [4] </ref>. <p> The notion M fx := N g denotes the result of substituting N for all free occurrences of x in M . We assume Barendregt's variable convention to avoid name collisions and treat ff-conversions implicitly. We also assume some elementary properties of substitution, e.g. the substitution lemma (Lemma 2.1.16 <ref> [4] </ref>). Convention L; M; N range over terms in fl; P ranges over programs; R ranges over various redexes defined below; ; t range over various reduction sequences defined below, and ; stands for an empty reduction sequence. <p> Proof (1) follows from the observation that Rfx := Lg is the head redex in M fx := Lg if R is the head redex in M ; (2) follows from (1); (3) follows from (2). See <ref> [4] </ref> for details. 4 Let us introduce the concept of residuals of fi-redexes. The rigorous definition of this notion can be found in [8]. <p> A version of Lemma 5..3 in which fi v hd -developments are replaced with parallel reductions can also be proven using an argument due to Tait/Martin-Lof <ref> [4] </ref>, which is also the main proof strategy in [15]. <p> Relations between v hd and We prove that a term can be reduced in v hd to a term in GHNF if and only if it can be reduced in the to a term in HNF. The following is Theorem 8.3.11 in <ref> [4] </ref>. Theorem 6..1 Given a term M ; if M !! fi N 1 for some N 1 in HNF then M h !! fi N 2 for some N 2 in HNF. We can then define an evaluation function corresponding to head fi-reduction.
Reference: [5] <author> R. Davies and F. </author> <title> Pfenning (1996), A Modal Analysis of Staged Computation, </title> <booktitle> In Proceedings of the 23 rd ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 206-209 </pages>
Reference-contexts: In some sense, full laziness is really not full when evaluation under is allowed. Another related subject is partial evaluation. We show that eval v hd works well with staged computation <ref> [5] </ref>. Let us define the power function pow as fix (f pn:IF (= (p; 0 ); 1 ; fi (f (n)((p; 1)); n))): Note hd (pow) = h;; Inti. <p> eval v hd (pow ( 0 )) = n:(f:n: 1 )(pow)(n) eval v hd (pow ( 1 )) = n:(n: fi ((f:n: 1 )(pow)(n); n))(n) eval v hd (pow ( 2 )) = n:(n: fi ((n: fi ((f:n: 1 )(pow)(n); n))(n); n))(n) This is very close to Example 2.4 in <ref> [5] </ref>.
Reference: [6] <author> A.J. Field and P.G. </author> <title> Harrison (1988), Functional Programming, </title> <publisher> Addison-Wesley Publishing Company. </publisher>
Reference: [7] <author> J.R. </author> <title> Hindley (1978), Reductions of residuals are finite, </title> <journal> Trans. Amer. Math. Soc. </journal> <volume> 240, </volume> <pages> pp. 345-361. </pages>
Reference-contexts: The finiteness of fi-developments theorem (FD), which states that all fi-developments are finite, can be readily proven using the separation lemma, and such a proof is essentially the same as the one given by Hindley <ref> [7] </ref>.
Reference: [8] <author> G. </author> <title> Huet (1994), Residual Theory in -Calculus: A Formal Development, </title> <journal> Journal of Functional Programming Vol. </journal> <volume> 4, </volume> <pages> pp. 371-394. </pages>
Reference-contexts: See [4] for details. 4 Let us introduce the concept of residuals of fi-redexes. The rigorous definition of this notion can be found in <ref> [8] </ref>. Let R be a set of fi-redexes in a term M , R = (x:M 1 )M 2 in R and M R This fi-reduction step affects fi-redexes R 0 in R in the following ways.
Reference: [9] <author> R.J.M. </author> <title> Hughes (1984), The design and implementation of programming languages, </title> <type> Ph.D. thesis, </type> <institution> University of Oxford. </institution> <month> 25 </month>
Reference-contexts: It is this observation that motivates the paper. The problem of sharing evaluation under -abstraction has lead to a great deal of study on -lifting [12] and supercombinators <ref> [9] </ref> under the title full laziness or maximal laziness. Because of the ability of evaluating under directly, eval v hd can achieve what is beyond the scope of either -lifting or supercombinators.
Reference: [10] <editor> C.K. Holst and C.K. </editor> <title> Gomard (1991), Partial Evaluation is Fuller Laziness, </title> <booktitle> in Proceedings of the Symposium on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <pages> pp. 223-233. </pages>
Reference-contexts: Our work also relates to <ref> [10] </ref>. We show that eval v hd can achieve complete laziness for the following example taken from [10] if we form closures instead of performing substitutions. This cannot be done by an evaluation strategy corresponding to full laziness as mentioned in [10]. <p> Our work also relates to <ref> [10] </ref>. We show that eval v hd can achieve complete laziness for the following example taken from [10] if we form closures instead of performing substitutions. This cannot be done by an evaluation strategy corresponding to full laziness as mentioned in [10]. Here lower case letters are variables and uppercase letters are closed expressions. (f:f (B)(f (C)))((a:z:(g:g (a))(x:x (x)(z)))(A)) We assume that A is already in GHNF. <p> Our work also relates to <ref> [10] </ref>. We show that eval v hd can achieve complete laziness for the following example taken from [10] if we form closures instead of performing substitutions. This cannot be done by an evaluation strategy corresponding to full laziness as mentioned in [10]. Here lower case letters are variables and uppercase letters are closed expressions. (f:f (B)(f (C)))((a:z:(g:g (a))(x:x (x)(z)))(A)) We assume that A is already in GHNF.
Reference: [11] <author> R. Gluck and J. </author> <month> Jtrgensen </month> <year> (1995), </year> <title> Efficient multi-level generating extensions for program specialisation. In S.D. </title> <editor> Swierstra and M. Hermenegildo, editors, </editor> <title> Programming Languages, Implementations Logics and Programs, </title> <publisher> Springer-Verlag LNCS 982, </publisher> <pages> pp. 259-278. </pages>
Reference-contexts: For the following function dotprod which computes the inner product of two vectors of some given length <ref> [11] </ref>, the reader can also verify that eval v hd (dotprod ( n )) is adequately expanded for every n 2 Int.
Reference: [12] <author> T. </author> <title> Johnsson (1985), Lambda lifting: transforming programs to recursive equations, </title> <booktitle> In Proceedings of the Conference on Functional programming Languages and Computer Architecture, Nancy, </booktitle> <pages> pp. 190-203. </pages>
Reference-contexts: It is this observation that motivates the paper. The problem of sharing evaluation under -abstraction has lead to a great deal of study on -lifting <ref> [12] </ref> and supercombinators [9] under the title full laziness or maximal laziness. Because of the ability of evaluating under directly, eval v hd can achieve what is beyond the scope of either -lifting or supercombinators.
Reference: [13] <author> P.J. </author> <title> Landin (1964), The mechanical evaluation of expressions, </title> <journal> BCS Computing Journal 6(4), </journal> <pages> pp. 308-320. </pages>
Reference-contexts: It is straightforward to define ff-conversion on closure bodies, and the equality between bodies is modular ff-conversion. Notice that only terms in GHNF can form closures. This is similar to the definition of closures given by Landin <ref> [13] </ref>, where only -abstractions can form closures. Notice that every environment we can formulate below is of form (x 1 7! CL 1 ; : : : ; x n 7! CL n ), where CL i does not contain any free occurrence of x j for 1 j i.
Reference: [14] <editor> S.L. Peyton Jones (1991), </editor> <title> A fully-lazy lambda lifter in Haskell, </title> <journal> Software practice and experience 21. </journal>
Reference-contexts: This kind of duplication of reductions can be avoided by extracting the maximal-free terms in a function at compile-time <ref> [14] </ref>. However, since evaluation can change the set of free variables in a term, the situation becomes complicated if such a redex is generated at run-time. This makes direct evaluation under -abstraction desirable.
Reference: [15] <author> G.D. </author> <title> Plotkin (1975), Call-by-name, call-by-value and the lambda-calculus, </title> <booktitle> Theoretical Computer Science 1, </booktitle> <pages> pp. 125-159. </pages>
Reference-contexts: However, since evaluation can change the set of free variables in a term, the situation becomes complicated if such a redex is generated at run-time. This makes direct evaluation under -abstraction desirable. Why is a value defined as a -abstraction or a variable in the (usual) call-by-value -calculus v <ref> [15] </ref>? One crucial observation is that this form of values is closed under value substitution. 1 This directly leads to the notion of residuals of fi v -redexes under fi v -reduction and the notion of parallel fi v -reduction, by which it follows that v enjoys the Church-Rosser property and <p> The notion of residuals can play a key role in proofs of Church-Rosser theorem and standardi-sation theorem. Note that -abstractions are closed under substitutions. This naturally yields the definitions of residuals in the call-by-value -calculus v <ref> [15] </ref> in which -abstractions are regarded as values. Fortunately, flexible GHNF is also closed under substitution as proven below, and therefore, is suitable for defining values in this respect. <p> A version of Lemma 5..3 in which fi v hd -developments are replaced with parallel reductions can also be proven using an argument due to Tait/Martin-Lof [4], which is also the main proof strategy in <ref> [15] </ref>. <p> This suggests a new approach to implementing functional programming languages with call-by-name semantics, namely implementing v hd . 7. Operational Semantics This section presents an operational semantics for v hd in the style of <ref> [15] </ref>. An application (M N ) is written as @(M; N ) in this section. We begin with a description of our SECD machine. <p> Now we are ready to present the state transitions of our SECD machine, which are listed in Table 1. var always stands for some fresh variable when Transition 6 is applied. We assume the familiarity of the reader with the notation, which is adopted from <ref> [15] </ref>. <p> With this observation, we can establish the expected relation between Eval v hd and eval v hd . Theorem 7..2 Eval v hd (P ) = eval v hd (P ) for every program P . 20 Proof See the proof of Theorem 1 in <ref> [15] </ref>. We omit a long but straightforward argument here. Like the usual call-by-value SECD machine, the presented SECD machine can be improved in numerous ways. Transition 6 is a serious obstacle to efficiency because of the renaming. We are planning to fix this problem soon.
Reference: [16] <author> Chris Reade (1989), </author> <title> Elements of Functional Programming, </title> <publisher> Addison-Wesley Publishing Company. </publisher>
Reference: [17] <author> H. </author> <title> Xi (1996), Separating developments in -calculus, </title> <type> Technical report, </type> <institution> Department of Mathematical Sciences, Carnegie Mellon University, Pittsburgh. </institution>
Reference-contexts: Given a fi-reduction sequence from M , we say that a fi-redex R in M is involved in if R or one of its residuals gets contracted in . 3. fi-developments In this section, we present some proof techniques handling fi-developments. More details can be found in <ref> [17] </ref>. We will use these techniques to study fi v hd -reduction defined in the next section. <p> Proof This can be proven by an induction on jj, yielding a construction of 1 ; 21 ; : : : ; 2n . A detailed proof can be found in <ref> [17] </ref>. Let sp () stand for [M ] + 1 f* := N g + 21 + + 2n ; and we can easily verify that for every R in M if R is involved in sp () then R is involved in .
Reference: [18] <author> N. </author> <title> Yoshida (1993), Optimal reduction in weak -calculus with shared environments. </title> <booktitle> In Proc. ACM conference on Functional Programming Languages and Computer Architecture, Copenhagen. </booktitle> <pages> 26 </pages>
Reference-contexts: We are currently studying on this subject. 9. Related Work v hd is closely related to the weak -calculus in <ref> [18] </ref> and the call-by-need -calculus in [3] in the following sense; we can define a kind of redex as a term of form M (N ) and its contractum as subN *gbd (M ), where M is a term with hd (M ) = 0 and N is a variable or <p> is a variable or a -abstraction; it can be readily verified that such a form is closed under value substitution if values are defined as variables or -abstractions; we can then define a kind of -calculus corresponding to such redexes; a close correspondence between this -calculus and the -calculi in <ref> [18] </ref> and [3] can be established accordingly. It is this observation that motivates the paper. The problem of sharing evaluation under -abstraction has lead to a great deal of study on -lifting [12] and supercombinators [9] under the title full laziness or maximal laziness.
References-found: 18

