URL: file://ftp.di.unipi.it/pub/Papers/meo/BotSem94.ps.gz
Refering-URL: http://www.di.unipi.it/di/groups/lp/papers.html
Root-URL: 
Title: A Bottom-up Semantics for Constructive Negation  
Author: Annalisa Bossi Massimo Fabris Maria Chiara Meo 
Address: Via Belzoni 7, 35131 Padova, Italy,  Via Belzoni 7, 35131 Padova, Italy,  Corso Italia 40, 56125 Pisa, Italy,  
Affiliation: Dip. di Matematica Pura ed Applicata, Universita di Padova,  Dip. di Matematica Pura ed Applicata, Universita di Padova,  Dipartimento di Informatica, Universita di Pisa,  
Abstract: The constructive negation rule has been introduced by Chan [5, 6] to overcome the main drawbacks of the negation-as-failure rule: the unsoundness of floundering programs and, consequently, the inability of providing answers for non-ground negative queries. In this paper we define a bottom-up semantics for constructive negation which we prove sound and complete with respect to the three-valued completion of the program. The semantics describes answers as well as undefined computations for both positive and negative queries. Its construction closely follows the basic idea of constructive negation whereby answers to a negative query are obtained by negating a frontier of the computation tree for the corresponding positive query. Therefore, the proposed semantics can be considered as a natural base for reasoning on the operational semantics for constructive negation defined in the literature. Moreover, we show how the semantics can be effectively used to perform a bottom-up computation of the answers of a normal query. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Bossi, M. Bugliesi, and M. Fabris. </author> <title> A New Fixpoint Semantics for Prolog. </title> <editor> In D. Warren, editor, </editor> <booktitle> Proceeding of the Tenth Int. Conf. on Logic Programming, ICLP'93, </booktitle> <pages> pages 374-389. </pages> <publisher> The MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: We consider CLP normal programs as defined by [16]. Our denotations (uncertain interpretations) extend both those defined in <ref> [8, 9, 1] </ref> for the semantics of definite programs, and those in [14] for modeling answer constraints in CLP normal programs. They contain four kinds of objects which represent the four different computational aspects of a program we are interested in. <p> This terminates the computation. 5 Comparison with other approaches We comment the information present in our semantics by relating it to some other approaches to constructive negation. We shall give the intuition that [[P ]] CN captures and models computational features (like termination properties or answer substitutions as in <ref> [8, 1] </ref>) of some operational semantics for constructive negation recently proposed. First we consider the operational semantics defined in [5, 22].
Reference: [2] <author> A. Bossi, M. Fabris and M. C. Meo. </author> <title> A Bottom-up Semantics for Constructive Negation. </title> <type> Technical Report N.6, </type> <institution> Universita di Padova, Italy, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: In Section 5 we discuss and compare some other approaches to constructive negation. We dedicate special attention to Drabent's work and those properties of SLDFA-resolution captured by our semantics. Due to the lack of space, all the proofs are omitted; they can be found in <ref> [2] </ref>. 2 Preliminaries We assume the reader is familiar with the basic concept of logic programming. We recall the basic CLP concepts as defined in [16] and [20].
Reference: [3] <author> A. Bottoni, G. Levi. </author> <title> Computing in the Completion. </title> <editor> In D. Sacca, editor, </editor> <booktitle> Proceeding of the Eight Italian Conf. on Logic Programming, </booktitle> <pages> pages 375-389. </pages> <publisher> Mediterranean Press, </publisher> <year> 1993. </year>
Reference-contexts: A second group of methods has been proposed to deal also with infinite trees and it can be understood as using the completion of a program instead of the program itself. The basic concept of <ref> [25, 18, 6, 24, 23, 21, 3, 4] </ref> is, roughly speaking, that in a derivation step for :p ( ~ t) the completed definition of the predicate p is used: literal :p ( ~ t) can be replaced by the negated right hand side of the completed definition of the predicate
Reference: [4] <author> A. Bottoni, G. Levi. </author> <title> The Inverse of Fitting's Functional. </title> <editor> In G. Gottlob, A. Leitsch and D. Mundici, editors, </editor> <booktitle> Proceeding Third Kurt Godel Colloquium, Computational and Proof Theory, KGC'93, </booktitle> <pages> pages 132-143. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: A second group of methods has been proposed to deal also with infinite trees and it can be understood as using the completion of a program instead of the program itself. The basic concept of <ref> [25, 18, 6, 24, 23, 21, 3, 4] </ref> is, roughly speaking, that in a derivation step for :p ( ~ t) the completed definition of the predicate p is used: literal :p ( ~ t) can be replaced by the negated right hand side of the completed definition of the predicate
Reference: [5] <author> D. Chan. </author> <title> Constructive Negation Based on the Completed Database. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> <booktitle> Proc. Fifth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 111-125. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1988. </year>
Reference-contexts: Its main drawback is that computing by negation as failure, actually means testing by negation as failure, that is no answers are produced except for the yes/no ones. To overcome this limitation Chan <ref> [5, 6] </ref> introduced the constructive negation rule which subsumes negation as failure and extends it by allowing non-ground negative subgoals to bind variables in the same way as positive ones. <p> We shall give the intuition that [[P ]] CN captures and models computational features (like termination properties or answer substitutions as in [8, 1]) of some operational semantics for constructive negation recently proposed. First we consider the operational semantics defined in <ref> [5, 22] </ref>.
Reference: [6] <author> D. Chan. </author> <title> An Extension of Constructive Negation and its Application in Coroutin-ing. </title> <editor> In E. Lusk and R. Overbeek, editors, </editor> <booktitle> Proc. North American Conf. on Logic Programming'89, </booktitle> <pages> pages 477-493. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1989. </year>
Reference-contexts: Its main drawback is that computing by negation as failure, actually means testing by negation as failure, that is no answers are produced except for the yes/no ones. To overcome this limitation Chan <ref> [5, 6] </ref> introduced the constructive negation rule which subsumes negation as failure and extends it by allowing non-ground negative subgoals to bind variables in the same way as positive ones. <p> A second group of methods has been proposed to deal also with infinite trees and it can be understood as using the completion of a program instead of the program itself. The basic concept of <ref> [25, 18, 6, 24, 23, 21, 3, 4] </ref> is, roughly speaking, that in a derivation step for :p ( ~ t) the completed definition of the predicate p is used: literal :p ( ~ t) can be replaced by the negated right hand side of the completed definition of the predicate <p> Another extension of <ref> [6, 24] </ref> is that not only literals can be selected but also some negated formula.
Reference: [7] <author> K. L. Clark. </author> <title> Negation as Failure. </title> <editor> In H. Gallaire and J. Minker, editors, </editor> <booktitle> Logic and Data Bases, </booktitle> <pages> pages 293-322. </pages> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: A domain theory axiomatizes the particular domain D on which we wish to compute. We do not make any assumption on . Rather we require that the domain theory T contains the standard theory CET , given in <ref> [7] </ref> to axiomatize unification. Moreover if the set of function symbols is finite we assume the (weak) domain closure axiom (DCA) be added to CET , thus achieving the completeness of the theory CET in the case of a language with finite set of function symbols.
Reference: [8] <author> G. Delzanno and M. Martelli. </author> <title> A bottom-up characterization of finite success. </title> <type> Technical Report, </type> <institution> Universita di Genova, DISI, </institution> <year> 1992. </year>
Reference-contexts: We consider CLP normal programs as defined by [16]. Our denotations (uncertain interpretations) extend both those defined in <ref> [8, 9, 1] </ref> for the semantics of definite programs, and those in [14] for modeling answer constraints in CLP normal programs. They contain four kinds of objects which represent the four different computational aspects of a program we are interested in. <p> This terminates the computation. 5 Comparison with other approaches We comment the information present in our semantics by relating it to some other approaches to constructive negation. We shall give the intuition that [[P ]] CN captures and models computational features (like termination properties or answer substitutions as in <ref> [8, 1] </ref>) of some operational semantics for constructive negation recently proposed. First we consider the operational semantics defined in [5, 22]. <p> Another extension of [6, 24] is that not only literals can be selected but also some negated formula. Both 1 This property follows by the fact that if we deal with definite programs, the functional is equivalent to the one proposed by Delzanno and Martelli in <ref> [8] </ref>. previous rules are defined in details and in fact Chan has already implemented its rule in the Sepia Prolog compiler. Stuckey proves the completeness of his rule (in the more general framework of constraint logic programming) wrt the three-valued consequences of the completion of the program.
Reference: [9] <editor> G. Delzanno and M. Martelli. S-semantica per modellare insiemi di soluzioni. In S. Costantini, editor, </editor> <booktitle> Proc. Seventh Italian Conference on Logic Programming, </booktitle> <pages> pages 191-205, </pages> <year> 1992. </year>
Reference-contexts: We consider CLP normal programs as defined by [16]. Our denotations (uncertain interpretations) extend both those defined in <ref> [8, 9, 1] </ref> for the semantics of definite programs, and those in [14] for modeling answer constraints in CLP normal programs. They contain four kinds of objects which represent the four different computational aspects of a program we are interested in.
Reference: [10] <author> W. Drabent. </author> <title> SLS-resolution without floundering. </title> <editor> In L. M. Pereira and A. Nerode, editors, </editor> <booktitle> Proc. of the Workshop on Logic Programming and Non-monotonic reasoning, </booktitle> <pages> pages 82-98, </pages> <year> 1993. </year>
Reference-contexts: He gave a new operational schema and proved its soundness and completeness with respect to the three-valued completion of the program. Recently, Drabent <ref> [11, 10] </ref> proposed a method for deriving (constrained) answers for (constrained) normal queries in normal programs called SLDFA-resolution, an extension of SLDNF-resolution. The basic notions of SLDFA-resolution are SLDFA-refutation and finitely failed SLDFA-tree; they are mutually defined as the corresponding notions of SLDNF-resolution. <p> Moreover, subqueries can become really very complex, and the method seem to produce a lot of redundant solutions. The method of Chan shares the same problems. A solution to these drawbacks might be found in the approach recently proposed by Drabent <ref> [11, 10] </ref> for arbitrary normal programs. It is based on the construction of failed trees. If finitely failed trees are concerned then it is sound and complete wrt Clark completion in 3-valued logic.
Reference: [11] <author> W. Drabent. </author> <title> What is Failure? An Approach to Constructive Negation. </title> <journal> Acta Infor-matica, </journal> <note> 1993. To appear. </note>
Reference-contexts: He gave a new operational schema and proved its soundness and completeness with respect to the three-valued completion of the program. Recently, Drabent <ref> [11, 10] </ref> proposed a method for deriving (constrained) answers for (constrained) normal queries in normal programs called SLDFA-resolution, an extension of SLDNF-resolution. The basic notions of SLDFA-resolution are SLDFA-refutation and finitely failed SLDFA-tree; they are mutually defined as the corresponding notions of SLDNF-resolution. <p> Moreover, subqueries can become really very complex, and the method seem to produce a lot of redundant solutions. The method of Chan shares the same problems. A solution to these drawbacks might be found in the approach recently proposed by Drabent <ref> [11, 10] </ref> for arbitrary normal programs. It is based on the construction of failed trees. If finitely failed trees are concerned then it is sound and complete wrt Clark completion in 3-valued logic.
Reference: [12] <author> M. </author> <title> Fitting. A Kripke-Kleene semantics for logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 2 </volume> <pages> 295-312, </pages> <year> 1985. </year>
Reference-contexts: On the other hand, the uncertain negative atom can be obtained by negating the success and asserting the divergence. The semantics is obtained by iterating an operator P which maps uncertain interpretations to uncertain interpretations. Our construction agrees with Fitting's P operator <ref> [12] </ref> in the sense that at each iteration step there is a one-to-one correspondence between the solutions represented by the uncertain interpretation and the three-valued interpretation constructed by Fitting's operator. <p> The next proposition shows soundness and completeness of the semantics wrt the completion of the normal program. Let hI ' i be the partial interpretation associated to I ' , namely hI ' i = [I + ][[I ], and P be the operator defined by Fitting <ref> [12] </ref>. We prove that, for any finite k, there is a one-to-one correspondence between h P " ki and P " k. Proposition 4.4 (soundness and completeness) Let P be a normal program and P be Fitting's operator [12]. <p> [I + ][[I ], and P be the operator defined by Fitting <ref> [12] </ref>. We prove that, for any finite k, there is a one-to-one correspondence between h P " ki and P " k. Proposition 4.4 (soundness and completeness) Let P be a normal program and P be Fitting's operator [12]. Then h P " ki = P " k; for any finite k: 4.1 Computing success and failure answers The aim of this section is to show that our semantics can also be used to perform an effective bottom-up computation of the answers of a normal query.
Reference: [13] <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> A new Declarative Semantics for Logic Languages. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> <booktitle> Proc. Fifth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 993-1005. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1988. </year>
Reference-contexts: Comparisons between Drabent's method and those defined by Chan and Stuckey suggest that the first may have practical advantages over the other two. In this paper we follow a semantical approach to constructive negation. We develop a semantics in the style of <ref> [13] </ref>: we construct a denotation which directly characterizes the program behaviour on all most general atomic queries (positive or negative) and contains enough information to represent the program behaviour on all queries. We consider CLP normal programs as defined by [16].
Reference: [14] <author> M. Gabbrielli and G. Levi. </author> <title> Modeling Answer Constraints in Constraint Logic Programs. </title> <editor> In K. Furukawa, editor, </editor> <booktitle> Proc. Eighth Int'l Conf. on Logic Programming, pages 238- 252. </booktitle> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1991. </year>
Reference-contexts: We consider CLP normal programs as defined by [16]. Our denotations (uncertain interpretations) extend both those defined in [8, 9, 1] for the semantics of definite programs, and those in <ref> [14] </ref> for modeling answer constraints in CLP normal programs. They contain four kinds of objects which represent the four different computational aspects of a program we are interested in. Three of them have a logical reading in the three-valued completion of the program. <p> Finally, if ~ is an equivalence relation defined on a set S and S 2 S, we denote by S ~ the equivalence class in S=~ which contains S. 3 Uncertain interpretations We extend the notion of -interpretation as introduced in <ref> [14] </ref> in order to provide three-valued models of the completion of a CLP normal program.
Reference: [15] <author> J. Jaffar and J.-L. Lassez. </author> <title> Constraint Logic Programming. </title> <booktitle> In Proc. Fourteenth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 111-119. </pages> <publisher> ACM, </publisher> <year> 1987. </year>
Reference-contexts: A structure D over the alphabets C and , consists of a non empty set (D) and any interpretation of each function and predicate symbol according to its arity. The structures considered in CLP are the "solution compact" ones as defined in <ref> [16, 15] </ref>. A domain theory T corresponding to the structure D is a first-order consistent theory containing only predicate symbols from C , such that D is a model of T and for every constraint c, D j= c iff T j= c.
Reference: [16] <author> J. Jaffar and J.-L. Lassez. </author> <title> Constraint Logic Programming. </title> <type> Technical Report, </type> <institution> Department of Computer Science, Monash University, </institution> <month> June </month> <year> 1986. </year>
Reference-contexts: We develop a semantics in the style of [13]: we construct a denotation which directly characterizes the program behaviour on all most general atomic queries (positive or negative) and contains enough information to represent the program behaviour on all queries. We consider CLP normal programs as defined by <ref> [16] </ref>. Our denotations (uncertain interpretations) extend both those defined in [8, 9, 1] for the semantics of definite programs, and those in [14] for modeling answer constraints in CLP normal programs. <p> Due to the lack of space, all the proofs are omitted; they can be found in [2]. 2 Preliminaries We assume the reader is familiar with the basic concept of logic programming. We recall the basic CLP concepts as defined in <ref> [16] </ref> and [20]. A first order language is defined on a function symbols set denoted by , a predicate symbols set denoted by and a collection of variables denoted by V . <p> Let F be a set of formulas, we use the notations W V F as shorthands for the formulas ( W V respectively, where, ( W f2; f ) = false and ( V f2; f) = true. Definition 2.1 (CLP normal programs) <ref> [16] </ref> A normal program is a finite set of clauses of the form H c 2 ~ L: where c is a constraint, H (the head) is an atom and ~ L (the body) is a (possibly empty) conjunction of literals. <p> A structure D over the alphabets C and , consists of a non empty set (D) and any interpretation of each function and predicate symbol according to its arity. The structures considered in CLP are the "solution compact" ones as defined in <ref> [16, 15] </ref>. A domain theory T corresponding to the structure D is a first-order consistent theory containing only predicate symbols from C , such that D is a model of T and for every constraint c, D j= c iff T j= c. <p> Analogously, if C = W i2I c i is a possibly infinite disjunction of constraints, T j= C iff 9i 2 I, such that T j= c i . We also introduce the following [ ] operator on constrained atoms, which returns the set of "domain instances". Definition 2.3 <ref> [16] </ref> The set of "domain instances" [c 2 p ( ~ X)] of a constrained atom c 2 p ( ~ X ) is defined as [c 2 p ( ~ X)] = fp ( ~ X) j is a solution of cg: Let S be a set of constrained atoms.
Reference: [17] <author> K. Kunen. </author> <title> Negation in logic programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 4 </volume> <pages> 289-308, </pages> <year> 1987. </year>
Reference-contexts: First of all, a partial interpretation, as defined in <ref> [17] </ref>, is any total function F from the set of all ground atoms into ft; f ; ug, where ft; f ; ug are interpreted as true, false and undefined.
Reference: [18] <author> D. Lugiez. </author> <title> A Deduction Procedure for First Order Programs. </title> <booktitle> In Proc. of Sixth International Conf. on Logic Programming, Lisbon, </booktitle> <pages> pages 585-599, </pages> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: A second group of methods has been proposed to deal also with infinite trees and it can be understood as using the completion of a program instead of the program itself. The basic concept of <ref> [25, 18, 6, 24, 23, 21, 3, 4] </ref> is, roughly speaking, that in a derivation step for :p ( ~ t) the completed definition of the predicate p is used: literal :p ( ~ t) can be replaced by the negated right hand side of the completed definition of the predicate
Reference: [19] <author> P. Mancarella, S. Martini, and D. Pedreschi. </author> <title> Complete Logic Programs with Domain Closure Axiom. </title> <journal> Journal of Logic Programming, </journal> <volume> 5(3) </volume> <pages> 263-276, </pages> <year> 1988. </year>
Reference-contexts: Moreover if the set of function symbols is finite we assume the (weak) domain closure axiom (DCA) be added to CET , thus achieving the completeness of the theory CET in the case of a language with finite set of function symbols. Informally the axiom DCA <ref> [19] </ref> ensures that in the interpretation domain of any model of the theory, every object is a value of a non-variable term. A valuation is a mapping from the variables to D. The notion of valuation is extended in the obvious way to terms and constraints.
Reference: [20] <author> M.J. Maher. </author> <title> Logic Semantics for a Class of Committed-Choice Programs. </title> <booktitle> In Proc. of Fourth International Conf. on Logic Programming, </booktitle> <pages> pages 858-876, </pages> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: Due to the lack of space, all the proofs are omitted; they can be found in [2]. 2 Preliminaries We assume the reader is familiar with the basic concept of logic programming. We recall the basic CLP concepts as defined in [16] and <ref> [20] </ref>. A first order language is defined on a function symbols set denoted by , a predicate symbols set denoted by and a collection of variables denoted by V . <p> Moreover we require that for every constraint c either T j= 9c or T j= :9c (namely, T is satisfaction complete <ref> [20] </ref>). A domain theory axiomatizes the particular domain D on which we wish to compute. We do not make any assumption on . Rather we require that the domain theory T contains the standard theory CET , given in [7] to axiomatize unification.
Reference: [21] <author> J. A. </author> <title> Plaza. Fully Declarative Logic Programming. </title> <booktitle> In Programming Language Implementation and Logic Programming, Proceedings 1992, </booktitle> <pages> pages 415-427, </pages> <publisher> Springer-Verlag, </publisher> <year> 1992, </year> <note> LNCS 631. </note>
Reference-contexts: A second group of methods has been proposed to deal also with infinite trees and it can be understood as using the completion of a program instead of the program itself. The basic concept of <ref> [25, 18, 6, 24, 23, 21, 3, 4] </ref> is, roughly speaking, that in a derivation step for :p ( ~ t) the completed definition of the predicate p is used: literal :p ( ~ t) can be replaced by the negated right hand side of the completed definition of the predicate
Reference: [22] <author> T. Przymusinsky. </author> <title> On Constructive Negation in Logic Programming. </title> <booktitle> In Proc. North American Conference on Logic Programming, Addendum. </booktitle> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: We shall give the intuition that [[P ]] CN captures and models computational features (like termination properties or answer substitutions as in [8, 1]) of some operational semantics for constructive negation recently proposed. First we consider the operational semantics defined in <ref> [5, 22] </ref>.
Reference: [23] <author> T. Sato, and F. Motoyoshi. </author> <title> A Complete Top-down Interpreter for First Order Logic Programs. </title> <booktitle> In Logic Programming, Proc. of the 1991 International Symposium, </booktitle> <pages> pages 35-53, </pages> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: A second group of methods has been proposed to deal also with infinite trees and it can be understood as using the completion of a program instead of the program itself. The basic concept of <ref> [25, 18, 6, 24, 23, 21, 3, 4] </ref> is, roughly speaking, that in a derivation step for :p ( ~ t) the completed definition of the predicate p is used: literal :p ( ~ t) can be replaced by the negated right hand side of the completed definition of the predicate
Reference: [24] <author> P. J. Stuckey. </author> <title> Constructive Negation for Constraint Logic Programming. </title> <booktitle> In Proc. Sixth IEEE Symp. on Logic In Computer Science, </booktitle> <pages> pages 328-339. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: The basic idea which is formalized by SLD-CNF resolution is that, to handle a negative subgoal, one first considers its positive version and then negates all its answers. Answers to negative goals are described by first-order formulas which are interpreted in CET, the equality theory defined by Clark. Stuckey <ref> [24] </ref> pointed out how constraint logic programming provides a much more natural setting for describing constructive negation and described a setting for constructive negation for constraint logic programming over arbitrary structures. <p> There are obvious analogies between P and A P , the non-ground (constrained) version of P defined by Stuckey in <ref> [24] </ref>. The main difference is that instead of deriving information on success and failure we derive information on success and divergent computations. Note that our information is richer than the former. <p> The extension of a partial interpretation to ground constraints and to ground formulas is defined in <ref> [24] </ref>, by the following rules. * Let c be a ground constraint. c is true in F iff T j= c and c is false in F iff T j= :c. * We assume the usual strong three-valued interpretation of the symbols ^; _; :; 8; 9; !, and following Kunen, <p> A second group of methods has been proposed to deal also with infinite trees and it can be understood as using the completion of a program instead of the program itself. The basic concept of <ref> [25, 18, 6, 24, 23, 21, 3, 4] </ref> is, roughly speaking, that in a derivation step for :p ( ~ t) the completed definition of the predicate p is used: literal :p ( ~ t) can be replaced by the negated right hand side of the completed definition of the predicate <p> Another extension of <ref> [6, 24] </ref> is that not only literals can be selected but also some negated formula.
Reference: [25] <author> M. Wallace. </author> <title> Negation by Constraints: a Sound and Efficient Implementation of Negation in Deductive Databases. </title> <booktitle> In Proc. 1987 Symposium on Logic Programming, </booktitle> <address> San Francisco, </address> <pages> pages 253-263, </pages> <month> August </month> <year> 1987. </year>
Reference-contexts: A second group of methods has been proposed to deal also with infinite trees and it can be understood as using the completion of a program instead of the program itself. The basic concept of <ref> [25, 18, 6, 24, 23, 21, 3, 4] </ref> is, roughly speaking, that in a derivation step for :p ( ~ t) the completed definition of the predicate p is used: literal :p ( ~ t) can be replaced by the negated right hand side of the completed definition of the predicate
References-found: 25

