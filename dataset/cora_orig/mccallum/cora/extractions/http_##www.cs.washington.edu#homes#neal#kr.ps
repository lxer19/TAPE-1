URL: http://www.cs.washington.edu/homes/neal/kr.ps
Refering-URL: http://www.cs.washington.edu/homes/neal/pr-pub.html
Root-URL: 
Email: neal@cs.washington.edu, etzioni@cs.washington.edu  
Phone: (206) 616-1849 FAX: (206) 543-2969  
Title: Scaling up goal recognition  
Author: Neal Lesh and Oren Etzioni 
Address: Seattle, WA 98195  
Affiliation: Department of Computer Science and Engineering University of Washington,  
Abstract: Traditionally, plan and goal recognition has investigated examples in which the number of plans and goals is less than one hundred. In this paper, we address three challenges to scaling up goal recognition. First, hand coding the plan library is a tedious if not impractical method of generating massive libraries. Second, previous representations for plan libraries are exponentially large in the number of goal predicates. Third, existing algorithms consider each candidate goal which is prohibitively slow. Our solution to the first problem is to automatically construct plan libraries with biases which are explicit assumptions about the type of plans and goals people have. Our solution to the second problem is to represent the consistent goals with a compact, version space representation. Our solution to the third problem is a goal recognition algorithm that can quickly update this compact representation given an observed action. Experimentally, in both software and kitchen domains, we show our prototype implementation to be fast on libraries containing thousands of goals. Analytically, we identify a class of goals for which our algorithm is logarithmic in the number of goals. 
Abstract-found: 1
Intro-found: 1
Reference: [ Agre and Horswill, 1992 ] <author> P. Agre and I. Horswill. </author> <title> Cultural support for improvisation. </title> <booktitle> In Proc. 10th Nat. Conf. on AI, </booktitle> <pages> pp. 363-368, </pages> <year> 1992. </year>
Reference-contexts: Our formulation and the RIGS algorithm allow for arbitrarily "deep" plans with sub-goals, subgoals of subgoals, and so on. The above example is also small. Section 9 describes experiments on large libraries in the Unix and Toast <ref> [ Agre and Horswill, 1992 ] </ref> domains. We have recently tested BOCE, with similar results, on data gathered under Microsoft Windows 95. 3 Since user help systems are a primary application of keyhole recognition, software systems are an important domain. <p> A 30% savings occurs, for example, if the task-completion agent satisfies the actor's goal after the actor executes 7 actions in a 10 action plan. In our experiments, goal recognition leads to well over 50% work saved. 9.2 Toast Toast <ref> [ Agre and Horswill, 1992 ] </ref> is a simulated agent that performs cooking tasks. Toast accepts goals such as making omelettes, cleaning dirty dishes, or setting the table.
Reference: [ Ardissono and Cohen, 1995 ] <author> L. Ardissono and R. Cohen. </author> <title> On the value of user modeling for improving plan recognition. </title> <booktitle> In Proceedings of the workshop on The Next Generation of Plan Recognition Systems: Challenges for and Insight from Related Areas of AI, </booktitle> <pages> pp. 8-12, </pages> <month> August </month> <year> 1995. </year>
Reference: [ Carberry, 1990 ] <author> S. Carberry. </author> <title> Incorporating default inferences into plan recognition. </title> <booktitle> In Proc. 8th Nat. Conf. on AI, </booktitle> <volume> vol. 1, </volume> <pages> pp. 471-8, </pages> <month> july </month> <year> 1990. </year>
Reference-contexts: research was funded in part by Office of Naval Research grant 92-J-1946, by ARPA / Rome Labs grant F30602-95-1-0024, by a gift from Rockwell International Palo Alto Research, and by National Science Foundation grant IRI-9357772. plans and goals, such as the traffic [ Pynadath and Wellman, 1995 ] and student-scheduling <ref> [ Carberry, 1990 ] </ref> domains. Our objective is to apply goal recognition, a special case of plan recognition, to domains in which there are tens of thousands of possible goals and hundreds of plans per goal.
Reference: [ Etzioni, 1991 ] <author> Oren Etzioni. </author> <title> STATIC: A problem-space compiler for prodigy. </title> <booktitle> In Proc. 9th Nat. Conf. on AI, </booktitle> <pages> pp. 533-540, </pages> <year> 1991. </year>
Reference-contexts: BOCE calls RIGS [ Lesh and Etzioni, 1995 ] , to determine the consistency of individual goals. RIGS represents all consistent plans for each consistent goal using consistency graphs, which are based on plan-operator graphs <ref> [ Etzioni, 1991, Smith and Peot, 1993, Etzioni, 1993 ] </ref> . In the special case mentioned above, BOCE processes observed actions in time that is logarithmic in the number of goals.
Reference: [ Etzioni, 1993 ] <author> Oren Etzioni. </author> <title> Acquiring search-control knowledge via static analysis. </title> <journal> Artificial Intelligence, </journal> <volume> 62(2) </volume> <pages> 255-302, </pages> <year> 1993. </year>
Reference-contexts: BOCE calls RIGS [ Lesh and Etzioni, 1995 ] , to determine the consistency of individual goals. RIGS represents all consistent plans for each consistent goal using consistency graphs, which are based on plan-operator graphs <ref> [ Etzioni, 1991, Smith and Peot, 1993, Etzioni, 1993 ] </ref> . In the special case mentioned above, BOCE processes observed actions in time that is logarithmic in the number of goals.
Reference: [ Fikes and Nilsson, 1971 ] <author> R. Fikes and N. Nilsson. </author> <title> STRIPS: A new approach to the application of theorem proving to problem solving. </title> <journal> Artificial Intelligence, </journal> <volume> 2(3/4), </volume> <year> 1971. </year>
Reference-contexts: Our formulation can accommodate many planning languages (e.g. STRIPS <ref> [ Fikes and Nilsson, 1971 ] </ref> ).
Reference: [ Huber et al., 1994 ] <author> J.M. Huber, H.D. Edmund, </author> <title> and M.P. Wellman. The automated mapping of plans for plan recognition. </title> <booktitle> In Proc. 10th Conf. on Uncertainty in Ar-tifical Intelligence, </booktitle> <pages> pp. 344-51, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: The second issue we address, compact representation, is also particularly desirable for massive libraries because it is not feasible to explicitly store each plan and goal. The library has been stored in a variety of com-pact representations including context-free grammars [ Vilain, 1990 ] , belief networks <ref> [ Huber et al., 1994 ] </ref> , message passing networks [ Lin and Goebel, 1990 ] , and plan-operator graphs [ Lesh and Etzioni, 1995 ] . These representations store plans implicitly but store goals explicitly and contain pairwise links between goals.
Reference: [ Kautz, 1987 ] <author> H. Kautz. </author> <title> A Formal Theory Of Plan Recognition. </title> <type> PhD thesis, </type> <institution> University of Rochester, </institution> <year> 1987. </year>
Reference-contexts: Assumption A4 allows the recognizer to construct PL out of primitives in sets fl and . 4 Automated construction We now discuss the content of the plan library and show how to construct a library with biases. 4.1 Extraneous plans and goals It is often stated (e.g. <ref> [ Kautz, 1987, Weida and Lit-man, 1992 ] </ref> ) that the plan library must contain every plan and goal the actor could have. It might, then, be tempting to include every conceivable plan and goal in the library. <p> Plan hierarchies, meticulously described by <ref> [ Kautz, 1987 ] </ref> , are a widely-used (e.g. [ Ardissono and Cohen, 1995, Lin, 1995, Lin and Goebel, 1990, Vilain, 1990, Wobcke, 1994 ] ) example of a more expressive representation.
Reference: [ Lesh and Etzioni, 1995 ] <author> Neal Lesh and Oren Etzioni. </author> <title> A sound and fast goal recognizer. </title> <booktitle> In Proc. 15th Int. Joint Conf. on AI, </booktitle> <pages> pp. 1704-1710, </pages> <year> 1995. </year>
Reference-contexts: The library has been stored in a variety of com-pact representations including context-free grammars [ Vilain, 1990 ] , belief networks [ Huber et al., 1994 ] , message passing networks [ Lin and Goebel, 1990 ] , and plan-operator graphs <ref> [ Lesh and Etzioni, 1995 ] </ref> . These representations store plans implicitly but store goals explicitly and contain pairwise links between goals. Thus, the size of these representations grows quadrat-ically in the number of candidate goals which in turn grows exponentially in the number of goal predicates. <p> We provide the bias-specific functions the algorithm needs for initializing the boundaries and quickly updating the boundaries given a new observed action. BOCE can infer from the boundaries that some goal is, is part of, or is sufficient for one of the actor's goals. BOCE calls RIGS <ref> [ Lesh and Etzioni, 1995 ] </ref> , to determine the consistency of individual goals. RIGS represents all consistent plans for each consistent goal using consistency graphs, which are based on plan-operator graphs [ Etzioni, 1991, Smith and Peot, 1993, Etzioni, 1993 ] . <p> The directed-weak plan bias is flexible in that it allows 1 The terms in this definition are defined formally in <ref> [ Lesh and Etzioni, 1995 ] </ref> . multiple actions to support the same precondition and allows plans that do not necessarily achieve their goal. Directed-weak plans can contain redundant actions, such as executing a pwd command after a cd command. <p> We use consistency graphs <ref> [ Lesh and Etzioni, 1995 ] </ref> to represent the consistent plans for each goal in S and G. The RIGS algorithm takes a goal set GS, fl, and A, and constructs and manipulates a consistency graph in order to identify which goals in GS are inconsistent with A. <p> One needs to "plug in" the Init, Compare, Consistent, and MinGen functions (see table 1) to instantiate the goal recognizer. These functions depend on the plan and goal bias. The Consistent function for the directed-weak plan bias is described in <ref> [ Lesh and Etzioni, 1995 ] </ref> . In section 6.2, we describe the Init, Compare, and MinGen for two classes of conjunctive search goals. The following is a brief sketch of how the algorithm * BOCE-initialize () 1. Let hS 0 ; G 0 i = Init () 2.
Reference: [ Lin and Goebel, 1990 ] <author> D. Lin and R. Goebel. </author> <title> A message passing algorithm for plan recognition. </title> <booktitle> In Proc. 12th Int. Joint Conf. on AI, </booktitle> <volume> vol. 1, </volume> <pages> pp. 280-5, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: The library has been stored in a variety of com-pact representations including context-free grammars [ Vilain, 1990 ] , belief networks [ Huber et al., 1994 ] , message passing networks <ref> [ Lin and Goebel, 1990 ] </ref> , and plan-operator graphs [ Lesh and Etzioni, 1995 ] . These representations store plans implicitly but store goals explicitly and contain pairwise links between goals. <p> Our third challenge, fast recognition, is important because recognizers must respond quickly to a new observation in order to support real-time interaction with people. [ Vilain, 1990 ] and <ref> [ Lin and Goebel, 1990 ] </ref> imposed restrictions on the plan language to achieve recognition that is linear in the size of an input plan hierarchy H. Since jHj is quadratic in the number of goals, the recognition algorithms are not sufficiently fast for large domains. <p> The complexity of his algorithm is O (jHj 2 jAj 3 ) where jHj is the size, including edges, of the input plan hierarchy and A is the observations. <ref> [ Lin and Goebel, 1990 ] </ref> describe a message-passing scheme with complexity O (jHjjAj 3 ) under Vilain's restrictions. Although the faster of these algorithms is linear in jHj, H contains every candidate goal.
Reference: [ Lin, 1995 ] <author> D. Lin. </author> <title> Program recognition by observation. </title> <booktitle> In Proceedings of the workshop on The Next Generation of Plan Recognition Systems: Challenges for and Insight from Related Areas of AI, </booktitle> <pages> pp. 84-89, </pages> <month> August </month> <year> 1995. </year>
Reference: [ Mitchell, 1982 ] <author> T. Mitchell. </author> <title> Generalization as search. </title> <journal> Artificial Intelligence, </journal> <volume> 18 </volume> <pages> 203-226, </pages> <month> March </month> <year> 1982. </year>
Reference-contexts: We import ideas and techniques from machine learning to meet these three challenges. 2 Overview Our approach to the above challenges follows from the observation that concept learning (e.g. <ref> [ Mitchell, 1982, Shavlik and Dietterich, 1990 ] </ref> ) is structurally similar to plan recognition. Concept learners select a concept that describes, or fits, a large set of data on the basis of seeing a small portion of that data. <p> We can define, for example, a plan library that contains all optimal plans for goals of length two, or one that contains all plans that achieve goals formed by conjunction over the input predicates. Concept learners do not explicitly store each candidate hypothesis. We borrowed the version space representation <ref> [ Mitchell, 1982 ] </ref> of hypothesis spaces from concept learning. We establish a partial-order on goals, using the generality relationship, and store only the boundaries between the consistent and inconsistent regions of the goal space. <p> Then we describe the bias-specific functions that BOCE requires for two classes of conjunctive search goals. Finally, we extend BOCE to handle multiple goals and interleaved plans. 6.1 Boce algorithm The Based-on-Candidate-Elimination (BOCE) goal recognition algorithm, shown in figure 2, closely resem bles the Candidate Elimination algorithm's <ref> [ Mitchell, 1982 ] </ref> update procedure for a positive example. The pseudo code in figure 2 can be viewed as a template for an algorithm. One needs to "plug in" the Init, Compare, Consistent, and MinGen functions (see table 1) to instantiate the goal recognizer.
Reference: [ Pynadath and Wellman, 1995 ] <author> D.V. Pynadath and M.P. Wellman. </author> <title> Accounting for context in plan recognition, with application to traffic monitoring. </title> <booktitle> In Proc. 11th Conf. on Uncertainty in Artifical Intelligence, </booktitle> <pages> pp. 472-81, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: This research was funded in part by Office of Naval Research grant 92-J-1946, by ARPA / Rome Labs grant F30602-95-1-0024, by a gift from Rockwell International Palo Alto Research, and by National Science Foundation grant IRI-9357772. plans and goals, such as the traffic <ref> [ Pynadath and Wellman, 1995 ] </ref> and student-scheduling [ Carberry, 1990 ] domains. Our objective is to apply goal recognition, a special case of plan recognition, to domains in which there are tens of thousands of possible goals and hundreds of plans per goal.
Reference: [ Shavlik and Dietterich, 1990 ] <editor> J. Shavlik and T. Diet-terich, eds. </editor> <booktitle> Readings in Machine Learning. </booktitle> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1990. </year>
Reference-contexts: We import ideas and techniques from machine learning to meet these three challenges. 2 Overview Our approach to the above challenges follows from the observation that concept learning (e.g. <ref> [ Mitchell, 1982, Shavlik and Dietterich, 1990 ] </ref> ) is structurally similar to plan recognition. Concept learners select a concept that describes, or fits, a large set of data on the basis of seeing a small portion of that data.
Reference: [ Smith and Peot, 1993 ] <author> D. Smith and M. Peot. </author> <title> Postponing threats in partial-order planning. </title> <booktitle> In Proc. 11th Nat. Conf. on AI, </booktitle> <pages> pp. 500-506, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: BOCE calls RIGS [ Lesh and Etzioni, 1995 ] , to determine the consistency of individual goals. RIGS represents all consistent plans for each consistent goal using consistency graphs, which are based on plan-operator graphs <ref> [ Etzioni, 1991, Smith and Peot, 1993, Etzioni, 1993 ] </ref> . In the special case mentioned above, BOCE processes observed actions in time that is logarithmic in the number of goals.
Reference: [ van Beek, 1996 ] <author> P. van Beek. </author> <title> An investigation of probabilistic interpretations of heuristics in plan recognition. </title> <booktitle> In Proceedings of the Fifth International Conference on User Modeling, </booktitle> <pages> pp. 113-120, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: Constructing the library, however, is a delicate task. Automating construction requires articulating the principles that govern which plans and goals belong in the plan library. [ Weida and Litman, 1992 ] and <ref> [ van Beek, 1996 ] </ref> , among others, state that the library must be complete, i.e. it must include every plan and goal the actor might execute. We show that the quality of recognition depends on the content of the plan library in another, more subtle way.
Reference: [ Vilain, 1990 ] <author> M. Vilain. </author> <title> Getting serious about parsing plans: a grammatical analysis of plan recognition. </title> <booktitle> In Proc. 8th Nat. Conf. on AI, </booktitle> <pages> pp. 190-197, </pages> <year> 1990. </year>
Reference-contexts: The second issue we address, compact representation, is also particularly desirable for massive libraries because it is not feasible to explicitly store each plan and goal. The library has been stored in a variety of com-pact representations including context-free grammars <ref> [ Vilain, 1990 ] </ref> , belief networks [ Huber et al., 1994 ] , message passing networks [ Lin and Goebel, 1990 ] , and plan-operator graphs [ Lesh and Etzioni, 1995 ] . These representations store plans implicitly but store goals explicitly and contain pairwise links between goals. <p> Thus, the size of these representations grows quadrat-ically in the number of candidate goals which in turn grows exponentially in the number of goal predicates. Our third challenge, fast recognition, is important because recognizers must respond quickly to a new observation in order to support real-time interaction with people. <ref> [ Vilain, 1990 ] </ref> and [ Lin and Goebel, 1990 ] imposed restrictions on the plan language to achieve recognition that is linear in the size of an input plan hierarchy H. <p> In contrast, our approach requires the plan library to contain all and only plans and goals that share an underlying structure, defined by the plan and goal biases. Others before us have traded expressiveness for tractability. <ref> [ Vilain, 1990 ] </ref> converts recognition into context free grammar parsing by requiring plan steps to be totally ordered and not shared or interleaved.
Reference: [ Weida and Litman, 1992 ] <author> R. Weida and D. Litman. </author> <title> Terminological Reasoning with Constraint Networks and an Application to Plan Recognition. </title> <booktitle> In Proc. 3rd Int. Conf. on Principles of Knowledge Representation and Reasoning, </booktitle> <month> October </month> <year> 1992. </year>
Reference-contexts: Constructing the library, however, is a delicate task. Automating construction requires articulating the principles that govern which plans and goals belong in the plan library. <ref> [ Weida and Litman, 1992 ] </ref> and [ van Beek, 1996 ] , among others, state that the library must be complete, i.e. it must include every plan and goal the actor might execute. <p> Formally, g i g j if every action sequence consistent with g i is also consistent with g j . If g i g j and g j 6 g i then g i g j . This closely resembles the definition of generality between plans in <ref> [ Weida and Litman, 1992 ] </ref> . We represent VS (A) with a three-tuple hS; G; Ai, where S is the set of most specific, consistent goals and G is the set of most general, consistent goals. <p> Thus H can contain (2 jj + 2 jflj ) 2 edges, making the above algorithm's worst-case running time O ((2 jj + 2 jflj ) 2 jAj 3 ). <ref> [ Weida and Litman, 1992 ] </ref> automate construction of the plan library to the extent that they automatically compute the generality relationships between plans. They also gain considerable efficiency by maintaining only the boundaries within a space of plans.
Reference: [ Wilensky et al., 1988 ] <author> Robert Wilensky, David Chin, Marc Luria, James Martin, James Mayfield, and Dekai Wu. </author> <title> The Berkeley UNIX Consultant project. </title> <journal> Computational Linguistics, </journal> <volume> 14(4) </volume> <pages> 35-84, </pages> <year> 1988. </year>
Reference-contexts: To allow step sharing and interleaving with the above algorithms, each combination of goals needs to be represented explicitly in H and exploits generality to avoid fully enumeration of the library and to enable partial recognition. RIGS is similar in spirit to the Unix Consultant <ref> [ Wilensky et al., 1988 ] </ref> , which also chains actions together.
Reference: [ Wobcke, 1994 ] <author> W. Wobcke. </author> <title> Plan recognition as belief revision. </title> <booktitle> In Proceedings of the 1994 Second Australian and New Zealand Conference on Intelligent Information Systems, </booktitle> <pages> pp. 382-386. </pages> <publisher> IEEE, </publisher> <year> 1994. </year>
References-found: 20

