URL: ftp://ftp.research.microsoft.com/users/lomet/pub/real-rec.ps
Refering-URL: http://www.research.microsoft.com/users/lomet/pub/default.htm
Root-URL: http://www.research.microsoft.com
Title: Advanced Recovery Techniques in Practice  
Author: David Lomet 
Date: December 5, 1996  
Address: Redmond, WA 98052  
Affiliation: Microsoft Corporation  
Abstract: Over the past 10 years, the way that database systems achieve recovery, both from system crashes and transaction aborts, has undergone a major advance. Prior techniques severely impeded concurrency and resulted in large amounts of data being written to the log. The new techniques now permit early release of locks, hence enhancing concurrency; and logical operations, hence avoiding the need to physically copy data to the log. This technology has found its way into database systems of our current marketplace. In this paper, we briefly sketch the techniques being exploited, which are described fully elsewhere in this book, and illustrate them by describing how they solve the problem of B-tree recovery. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. Bernstein, V. Hadzilacos, and N. Goodman. </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, MA, </address> <year> 1987. </year>
Reference-contexts: We further restrict our attention precisely to the impact of the form of logged operation on the performance characteristics of the recovery system. More complete descriptions of the requirements and organization of recovery systems are found elsewhere in this book, and in <ref> [1, 9, 3] </ref>. Section two explores what has become the standard set of options when choosing logged operations. There are two "extremes", logical recovery and physical recovery. We briefly describe them to give a flavor of why the recovery problem has been difficult. <p> We describe these enhancements in the next two sections. 2 The situation for undo recovery is different, as we shall see. 4 3 Multi-level Undo Recovery 3.1 Multi-level Transactions Concurrency control and recovery theory suggests <ref> [1] </ref> that strict two phase locking is required to serialize and recover transactions.
Reference: [2] <author> J. Gray, P. McJones, M. Blasgen, B. Lindsay, R. Lorie, T. Price, and F. Putzolu. </author> <title> The recovery manager of the System R database manager. </title> <journal> ACM Computing Surveys, </journal> <volume> 13(2) </volume> <pages> 223-242, </pages> <month> June </month> <year> 1981. </year>
Reference-contexts: This can be very difficult and complicated. It is referred to as the action consistency problem [3], and can arise for both redo and undo operations. To solve this problem while providing operations that may touch multiple pages, System R <ref> [2] </ref> periodically installed operation consistent checkpoints. These checkpoints required that execution of the operational system be temporarily suspended so that the results of all operations since the last checkpoint could be atomically installed (via a shadow technique) into the database state. After installation, normal operation was resumed.
Reference: [3] <author> J. Gray and A. Reuter. </author> <title> Transaction Processing: Concepts and Techniques. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1993. </year>
Reference-contexts: We further restrict our attention precisely to the impact of the form of logged operation on the performance characteristics of the recovery system. More complete descriptions of the requirements and organization of recovery systems are found elsewhere in this book, and in <ref> [1, 9, 3] </ref>. Section two explores what has become the standard set of options when choosing logged operations. There are two "extremes", logical recovery and physical recovery. We briefly describe them to give a flavor of why the recovery problem has been difficult. <p> Section two explores what has become the standard set of options when choosing logged operations. There are two "extremes", logical recovery and physical recovery. We briefly describe them to give a flavor of why the recovery problem has been difficult. We then introduce physiological recovery <ref> [3, 9] </ref>, which is a carefully crafted limited form of logical recovery tailored to the block oriented organization of the disk. <p> This can be very difficult and complicated. It is referred to as the action consistency problem <ref> [3] </ref>, and can arise for both redo and undo operations. To solve this problem while providing operations that may touch multiple pages, System R [2] periodically installed operation consistent checkpoints. <p> It is this very large checkpoint cost that has caused logical logging to fall out of favor for redo recovery. 2 2.3 "Physio-logical" Operations The recovery technique that is at the core of recovery in current industrial database systems is what is called in <ref> [3] </ref> physiological logging. The operations are specific to a page, the unit of transfer between cache and disk, but the operations are logical, not physical. That is, the operations represent state transitions, not state values. <p> The operations are specific to a page, the unit of transfer between cache and disk, but the operations are logical, not physical. That is, the operations represent state transitions, not state values. Page-based, state transition operation logging was not described in the research literature until <ref> [9, 3] </ref>, but it had been used in some commercial systems substantially before. Physiological logging, like logical logging, requires that the state needed by an operation be identifiable. This led to the notion of state identifiers called log sequence numbers or LSNs.
Reference: [4] <author> Lehman, P., Yao, </author> <title> S.B., Efficient locking for concurrent operations on B-trees. </title> <journal> ACM Trans. </journal> <note> on Database Systems l6,4 (Dec 1981) 650-670. </note>
Reference-contexts: The bottom up method described in [6] permits this, and with no risk of deadlock. Hence, latches can be used This method exploits a side link a la the B-link tree of <ref> [4] </ref> to restructure the tree without fear of deadlock. The structure modification operations are sometimes called half-splits, and each can be protected with a single latch specific to the splitting node. However, even half splits can have multiple log records per structure modification.
Reference: [5] <author> D. Lomet. MLR: </author> <title> A recovery method for multi-level systems. </title> <booktitle> In Proceedings of the 1992 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 185-194. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1992. </year>
Reference-contexts: We then introduce physiological recovery [3, 9], which is a carefully crafted limited form of logical recovery tailored to the block oriented organization of the disk. Recovery in most industrial database systems is based on physiological recovery. 1 Conditions called "determinable execution" and "operation consistency" were used in <ref> [5] </ref> to characterize the requirements for undo recovery. But these are stronger than necessary. 2 While physiological recovery is an enormous improvement on its predecessors, work continues on further improvements. It is the advancements beyond physiological recovery that are the subject of this paper. <p> It is the advancements beyond physiological recovery that are the subject of this paper. There are two techniques that we describe, one for undo recovery and one for redo. undo: multi-level transactions [11] and their recovery <ref> [12, 5] </ref> make it possible to release locks before the end of transaction while preserving serializable executions. <p> But when the a multi-level subtransaction commits, it drops these low level locks, and passes to its parent only the high level locks necessary to serialize and ensure undo at the higher level of abstraction <ref> [5, 12] </ref> in this volume. This is effective exactly because of the different levels of abstraction. Database systems that do physiological recovery all use a trivial form of multi-level transaction to ensure that only one operation can change a page at a time. <p> Recovery designed to cope with multi-level subtransactions are designed specifically for situations like these. Instead of performing undo recovery from the log tail back in a single sequential pass of the log, multi-level methods <ref> [12, 5] </ref> perform undo recovery level by level, begining at the lowest level of abstraction. In the case of B-trees, this ensures that the B-tree is fully recovered prior to undoing logical record operations that need well-formed paths. The MLR method [5] extends to an arbitrary number of levels. <p> In the case of B-trees, this ensures that the B-tree is fully recovered prior to undoing logical record operations that need well-formed paths. The MLR method <ref> [5] </ref> extends to an arbitrary number of levels. Using MLR, B-tree structure modifications can be incorporated into any scheme involving multiple levels of abstraction, regardless of the number of other levels.
Reference: [6] <author> Lomet, D. and Salzberg, B. </author> <title> Concurrency and Recovery for Index Trees. </title> <booktitle> In Proceedings of the 1992 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 351-360. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1992. </year>
Reference-contexts: This raises the normal lock overhead involved, while providing higher concurrency. And, of course, occasionally, transactions will be aborted to cope with deadlocks. Out-of-Sequence Undo Maximum concurrency permits B-tree structure modifications to occur simultaneously, whether on the same path or not. The bottom up method described in <ref> [6] </ref> permits this, and with no risk of deadlock. Hence, latches can be used This method exploits a side link a la the B-link tree of [4] to restructure the tree without fear of deadlock.
Reference: [7] <author> Lomet, D. and Tuttle, M. </author> <title> Redo Recovery after System Crashes. </title> <booktitle> Proc. Very Large Databases Conf.(Sept. </booktitle> <address> 1995) Zurich, Switzerland 457-468. </address>
Reference-contexts: The minimal acceptable state is that the transaction have no effect. States in which partial executions become durable are not acceptable. 1.2 Why Recovery is Difficult What is needed is for the recovery method to provide is what was called in <ref> [7] </ref> a REDO test, which we now informally extend to undo recovery as well and re-name as an EXECUTE test. The EXECUTE test must satisfy the following conditions 1 : 1. <p> The multi-level recovery is described in section three, where we show how to enhance concurrency for B-tree structure changes. redo: more logical redo permits us to avoid logging state changes when new pages are initialized and substantial data is moved. "Logical" redo in which an operation can span database pages <ref> [7] </ref>, is explained in section four, where we show how it can reduce the data logged during a B-tree split. It is worth emphasizing here (though we do not provide citations) that both the techniques above have appeared in commercial database systems. <p> splitting only occurs once in every 10 or 20 updates, depending on the number of records contained in the B-tree leaf, this amount of logging adds substantially to the cost of using a B-tree as the storage structure for database records. 4 4.2 Multi-Page Half-Split Operations The recovery framework in <ref> [7] </ref> explains how, in general, the nature of log operations imposes requirements on cache management. A multi-page operation requires that the cache manager order flushes of pages to disk. Here we only explain the specific example of a multi-page half-split operation. <p> Any write-read conflicts do not impact recovery as inverting the flush order does not prevent the redo of the earlier operation. Write-write conflicts are technically more difficult to reason away, but can nonetheless be ignored <ref> [7] </ref> for the split operations that we deal with here. A split operation reads the original node O, and writes both O and a new node N . <p> The read-write conflict between the updates for the split operation results in the need to flush N before O is flushed. During undo, the upsplit read-write conflicts result in the need to flush O before 10 N . The framework of <ref> [7] </ref> lead directly to these requirements (with appropriate explanation to deal with the B-tree undo recovery situation. At least one commercial database system logs a half-split as a single operation.
Reference: [8] <author> Lomet, D. and Tuttle, M. </author> <title> A Formal Treatment of Redo Recovery with Pragmatic Implications. </title> <institution> Cambridge Research Lab, </institution> <address> Cambridge, MA. </address>
Reference: [9] <author> Mohan, C., Haderle, D., Lindsay, B., Pirahesh, H., and Schwarz, P. </author> <title> ARIES: A transaction recovery method supporting fine-granularity locking and partial rollbacks using write-ahead logging. </title> <journal> ACM Trans. on Database Systems 17,1 (Mar. </journal> <year> 1992) </year> <month> 94-162. 11 </month>
Reference-contexts: We further restrict our attention precisely to the impact of the form of logged operation on the performance characteristics of the recovery system. More complete descriptions of the requirements and organization of recovery systems are found elsewhere in this book, and in <ref> [1, 9, 3] </ref>. Section two explores what has become the standard set of options when choosing logged operations. There are two "extremes", logical recovery and physical recovery. We briefly describe them to give a flavor of why the recovery problem has been difficult. <p> Section two explores what has become the standard set of options when choosing logged operations. There are two "extremes", logical recovery and physical recovery. We briefly describe them to give a flavor of why the recovery problem has been difficult. We then introduce physiological recovery <ref> [3, 9] </ref>, which is a carefully crafted limited form of logical recovery tailored to the block oriented organization of the disk. <p> The operations are specific to a page, the unit of transfer between cache and disk, but the operations are logical, not physical. That is, the operations represent state transitions, not state values. Page-based, state transition operation logging was not described in the research literature until <ref> [9, 3] </ref>, but it had been used in some commercial systems substantially before. Physiological logging, like logical logging, requires that the state needed by an operation be identifiable. This led to the notion of state identifiers called log sequence numbers or LSNs. <p> There are two outcomes log LSN pLSN: the update is already incorporated into the page; bypass this operation. log LSN &gt; pLSN: the update is not yet in the page; redo the operation and update the page. The current recovery paradigm with physiological logging is to repeat history <ref> [9] </ref> by performing redo first using all logged updates. This brings the system to a state as of the last logged operation. Then one applies undo to roll back uncommitted operations, where the undo can be of the same form as for handling transaction abort during normal operation.
Reference: [10] <author> Mohan, C. and Levine, F. ARIES/IM: </author> <title> An efficient and high concurrency index management method using write-ahead logging. </title> <booktitle> In Proceedings of the 1992 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 371-380. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1992. </year>
Reference-contexts: Industrial database systems use locking for concurrency control. The granularity of the lock and its lock mode conflicts will determine how much concurrency is possible. The basic ARIES/IM <ref> [10] </ref> B-tree method provides a single structure modification lock (SMO), which is locked in exclusive (X) mode when a structure modification is in progress. Only a single modification can be active at a time.
Reference: [11] <author> G. Weikum. </author> <title> A theoretical foundation of multi-level concurrency control. </title> <booktitle> In Proceedings of the 5th Annual ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 31-42, </pages> <month> March </month> <year> 1986. </year>
Reference-contexts: It is the advancements beyond physiological recovery that are the subject of this paper. There are two techniques that we describe, one for undo recovery and one for redo. undo: multi-level transactions <ref> [11] </ref> and their recovery [12, 5] make it possible to release locks before the end of transaction while preserving serializable executions. <p> All of them use some flavor of multi-level transaction <ref> [11] </ref> that permits locks to be released early without compromising either serializability or recovery. A multi-level transaction is another form of subtransaction, more powerful than a nested transaction. Nested transactions can lock objects held by the parent transaction, and return all their locks to their parent when they commit.
Reference: [12] <author> G. Weikum, C. Hasse, P. Broessler, and P. Muth. </author> <title> Multi-level recovery. </title> <booktitle> In Proceedings of the 9th Annual ACM Symposium on Principles of Database Systems, </booktitle> <month> April </month> <year> 1990. </year> <month> 12 </month>
Reference-contexts: It is the advancements beyond physiological recovery that are the subject of this paper. There are two techniques that we describe, one for undo recovery and one for redo. undo: multi-level transactions [11] and their recovery <ref> [12, 5] </ref> make it possible to release locks before the end of transaction while preserving serializable executions. <p> But when the a multi-level subtransaction commits, it drops these low level locks, and passes to its parent only the high level locks necessary to serialize and ensure undo at the higher level of abstraction <ref> [5, 12] </ref> in this volume. This is effective exactly because of the different levels of abstraction. Database systems that do physiological recovery all use a trivial form of multi-level transaction to ensure that only one operation can change a page at a time. <p> Recovery designed to cope with multi-level subtransactions are designed specifically for situations like these. Instead of performing undo recovery from the log tail back in a single sequential pass of the log, multi-level methods <ref> [12, 5] </ref> perform undo recovery level by level, begining at the lowest level of abstraction. In the case of B-trees, this ensures that the B-tree is fully recovered prior to undoing logical record operations that need well-formed paths. The MLR method [5] extends to an arbitrary number of levels.
References-found: 12

