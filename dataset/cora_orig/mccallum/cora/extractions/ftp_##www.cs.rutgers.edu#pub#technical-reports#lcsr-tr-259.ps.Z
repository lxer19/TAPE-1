URL: ftp://www.cs.rutgers.edu/pub/technical-reports/lcsr-tr-259.ps.Z
Refering-URL: http://www.cs.rutgers.edu/pub/technical-reports/
Root-URL: 
Email: email: fxxzhang,ryderg@cs.rutgers.edu, blandi@scr.siemens.com  
Title: Decomposition for Pointer-induced Aliasing Analysis  
Author: Sean Zhang Barbara G. Ryder William Landi 
Address: New Brunswick, NJ 08903  755 College Rd. East Princeton, NJ 08540  
Affiliation: Department of Computer Science Rutgers University  Siemens Corporate Research Inc  
Note: Program  
Abstract: Laboratory of Computer Science Research Technical Report LCSR-TR-259, March 1996 Abstract For compile-time pointer aliasing analysis, a program written in the C language can be considered as a sequence of pointer-related assignments. In this paper, we present a technique that decomposes these assignments into unrelated sets in terms of their effects on pointer-induced aliasing. This decomposition will allow different pointer aliasing analysis methods to be applied to individual sets of assignments so that end users of pointer aliasing information can get the efficiency/precision tradeoff desirable for their applications. We show the feasibility of this approach by using both a flow-sensitive and a flow-insensitive aliasing analysis algorithm on a same program. We use the aliasing solutions of the resulting analysis to resolve locations modified or referenced through names containing pointer dereferences (thru-deref MOD/REF); we empirically show that for a number of programs, the resulting analysis is much faster than the complete flow-sensitive analysis and yields a thru-deref MOD/REF solution of similar precision.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Lars Ole Andersen. </author> <title> Program analysis and specialization for the C programming language. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Copenhagen, </institution> <month> may </month> <year> 1994. </year>
Reference-contexts: The existing analysis algorithms can be classified into flow-sensitive/context-sensitive [5, 6, 7, 8, 9, 10, 11, 12, 16, 30], flow-insensitive/context-insensitive [3, 24, 26, 28], flow-sensitive/context-insensitive [4, 22], and flow-insensitive/context-sensitive <ref> [1] </ref>. They can also be organized into stack-based aliasing analysis [7, 8], heap-based aliasing analysis [4, 6, 9, 10, 11], and both [5, 16, 22, 24, 26, 30]. The work by the research group at McGill University [7, 8, 9, 10] is particularly related to our work.
Reference: [2] <author> J. Banning. </author> <title> An efficient way to find the side effects of procedure calls and the aliases of variables. </title> <booktitle> In Conference Record of the 6th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 29-41, </pages> <month> Jan. </month> <year> 1979. </year>
Reference-contexts: Our program decomposition can identify the sets of statements related to recursive data structures and therefore allow shape analysis techniques [4, 10, 23] to be applied to these statements to extract more precise information. The modification side effect analysis for FORTRAN was given in <ref> [2] </ref>; the analysis for C was first presented in [17, 18]. Empirical results of modifications/references through pointer indirections were also reported in [8]. 8 Conclusion and Future Work We have presented a program decomposition technique for point-induced aliasing analysis, which works for well-typed C programs.
Reference: [3] <author> Michael Burke, Paul Carini, Jong-Deok Choi, and Michael Hind. </author> <title> Flow-insensitive interprocedural alias analysis in the presence of pointers. </title> <booktitle> In Lecture Notes in Computer Science, </booktitle> <volume> number No. 892, </volume> <pages> pages 234-250. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year> <booktitle> Proceedings from the 7th International Workshop on Languages and Compilers for Parallel Computing. </booktitle>
Reference-contexts: In addition, our decomposition enables a sparse program representation for each component and therefore will allow any analysis algorithm to run faster. The existing analysis algorithms can be classified into flow-sensitive/context-sensitive [5, 6, 7, 8, 9, 10, 11, 12, 16, 30], flow-insensitive/context-insensitive <ref> [3, 24, 26, 28] </ref>, flow-sensitive/context-insensitive [4, 22], and flow-insensitive/context-sensitive [1]. They can also be organized into stack-based aliasing analysis [7, 8], heap-based aliasing analysis [4, 6, 9, 10, 11], and both [5, 16, 22, 24, 26, 30].
Reference: [4] <author> David R. Chase, Mark Wegman, and F. Kenneth Zadeck. </author> <title> Analysis of pointers and structures. </title> <booktitle> In Proceedings of SIGPLAN'90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 296-310, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Some of them are more appropriate for aliases involving accesses to heap locations (i.e., heap-based aliases), e.g., <ref> [4, 6, 12] </ref>. Some are more appropriate for aliases involving accesses to stack locations (i.e., stack-based aliases), e.g., [7, 8]. Others handle both in a similar fashion, e.g., [5, 16, 22, 30]. <p> In addition, our decomposition enables a sparse program representation for each component and therefore will allow any analysis algorithm to run faster. The existing analysis algorithms can be classified into flow-sensitive/context-sensitive [5, 6, 7, 8, 9, 10, 11, 12, 16, 30], flow-insensitive/context-insensitive [3, 24, 26, 28], flow-sensitive/context-insensitive <ref> [4, 22] </ref>, and flow-insensitive/context-sensitive [1]. They can also be organized into stack-based aliasing analysis [7, 8], heap-based aliasing analysis [4, 6, 9, 10, 11], and both [5, 16, 22, 24, 26, 30]. <p> The existing analysis algorithms can be classified into flow-sensitive/context-sensitive [5, 6, 7, 8, 9, 10, 11, 12, 16, 30], flow-insensitive/context-insensitive [3, 24, 26, 28], flow-sensitive/context-insensitive [4, 22], and flow-insensitive/context-sensitive [1]. They can also be organized into stack-based aliasing analysis [7, 8], heap-based aliasing analysis <ref> [4, 6, 9, 10, 11] </ref>, and both [5, 16, 22, 24, 26, 30]. The work by the research group at McGill University [7, 8, 9, 10] is particularly related to our work. Their approach is to decouple the stack-based aliasing analysis and heap-based aliasing analysis. <p> The G FA for a program, similar to the graph that may result from the analysis in [24, 26], can be perceived as a storage shape graph <ref> [4] </ref> although it may be quite approximate when there are recursive data structures. Our program decomposition can identify the sets of statements related to recursive data structures and therefore allow shape analysis techniques [4, 10, 23] to be applied to these statements to extract more precise information. <p> Our program decomposition can identify the sets of statements related to recursive data structures and therefore allow shape analysis techniques <ref> [4, 10, 23] </ref> to be applied to these statements to extract more precise information. The modification side effect analysis for FORTRAN was given in [2]; the analysis for C was first presented in [17, 18].
Reference: [5] <author> J. Choi, M. Burke, and P. Carini. </author> <title> Efficient flow-sensitive interprocedural computation of pointer-induced aliases and side effects. </title> <booktitle> In Conference Record of te 20th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 232-245, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Some of them are more appropriate for aliases involving accesses to heap locations (i.e., heap-based aliases), e.g., [4, 6, 12]. Some are more appropriate for aliases involving accesses to stack locations (i.e., stack-based aliases), e.g., [7, 8]. Others handle both in a similar fashion, e.g., <ref> [5, 16, 22, 30] </ref>. It has been proposed in [8] that completely different analysis methods have to be considered for stack-based and heap-based aliases. <p> Any of these algorithms can be employed for individual weakly connected components in our program decomposition. In addition, our decomposition enables a sparse program representation for each component and therefore will allow any analysis algorithm to run faster. The existing analysis algorithms can be classified into flow-sensitive/context-sensitive <ref> [5, 6, 7, 8, 9, 10, 11, 12, 16, 30] </ref>, flow-insensitive/context-insensitive [3, 24, 26, 28], flow-sensitive/context-insensitive [4, 22], and flow-insensitive/context-sensitive [1]. They can also be organized into stack-based aliasing analysis [7, 8], heap-based aliasing analysis [4, 6, 9, 10, 11], and both [5, 16, 22, 24, 26, 30]. <p> They can also be organized into stack-based aliasing analysis [7, 8], heap-based aliasing analysis [4, 6, 9, 10, 11], and both <ref> [5, 16, 22, 24, 26, 30] </ref>. The work by the research group at McGill University [7, 8, 9, 10] is particularly related to our work. Their approach is to decouple the stack-based aliasing analysis and heap-based aliasing analysis.
Reference: [6] <author> Alain Deutsch. </author> <title> Interprocedural may-alias analysis for pointers: Beyond k-limiting. </title> <booktitle> In Proceedings of SIGPLAN'94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 230-241, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Some of them are more appropriate for aliases involving accesses to heap locations (i.e., heap-based aliases), e.g., <ref> [4, 6, 12] </ref>. Some are more appropriate for aliases involving accesses to stack locations (i.e., stack-based aliases), e.g., [7, 8]. Others handle both in a similar fashion, e.g., [5, 16, 22, 30]. <p> Any of these algorithms can be employed for individual weakly connected components in our program decomposition. In addition, our decomposition enables a sparse program representation for each component and therefore will allow any analysis algorithm to run faster. The existing analysis algorithms can be classified into flow-sensitive/context-sensitive <ref> [5, 6, 7, 8, 9, 10, 11, 12, 16, 30] </ref>, flow-insensitive/context-insensitive [3, 24, 26, 28], flow-sensitive/context-insensitive [4, 22], and flow-insensitive/context-sensitive [1]. They can also be organized into stack-based aliasing analysis [7, 8], heap-based aliasing analysis [4, 6, 9, 10, 11], and both [5, 16, 22, 24, 26, 30]. <p> The existing analysis algorithms can be classified into flow-sensitive/context-sensitive [5, 6, 7, 8, 9, 10, 11, 12, 16, 30], flow-insensitive/context-insensitive [3, 24, 26, 28], flow-sensitive/context-insensitive [4, 22], and flow-insensitive/context-sensitive [1]. They can also be organized into stack-based aliasing analysis [7, 8], heap-based aliasing analysis <ref> [4, 6, 9, 10, 11] </ref>, and both [5, 16, 22, 24, 26, 30]. The work by the research group at McGill University [7, 8, 9, 10] is particularly related to our work. Their approach is to decouple the stack-based aliasing analysis and heap-based aliasing analysis.
Reference: [7] <author> Maryam Emami. </author> <title> A practical interprocedural alias analysis for an optimizing/parallelizing c compiler. </title> <type> Master's thesis, </type> <institution> McGill University, Montreal, Canada, </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: Some of them are more appropriate for aliases involving accesses to heap locations (i.e., heap-based aliases), e.g., [4, 6, 12]. Some are more appropriate for aliases involving accesses to stack locations (i.e., stack-based aliases), e.g., <ref> [7, 8] </ref>. Others handle both in a similar fashion, e.g., [5, 16, 22, 30]. It has been proposed in [8] that completely different analysis methods have to be considered for stack-based and heap-based aliases. <p> Any of these algorithms can be employed for individual weakly connected components in our program decomposition. In addition, our decomposition enables a sparse program representation for each component and therefore will allow any analysis algorithm to run faster. The existing analysis algorithms can be classified into flow-sensitive/context-sensitive <ref> [5, 6, 7, 8, 9, 10, 11, 12, 16, 30] </ref>, flow-insensitive/context-insensitive [3, 24, 26, 28], flow-sensitive/context-insensitive [4, 22], and flow-insensitive/context-sensitive [1]. They can also be organized into stack-based aliasing analysis [7, 8], heap-based aliasing analysis [4, 6, 9, 10, 11], and both [5, 16, 22, 24, 26, 30]. <p> The existing analysis algorithms can be classified into flow-sensitive/context-sensitive [5, 6, 7, 8, 9, 10, 11, 12, 16, 30], flow-insensitive/context-insensitive [3, 24, 26, 28], flow-sensitive/context-insensitive [4, 22], and flow-insensitive/context-sensitive [1]. They can also be organized into stack-based aliasing analysis <ref> [7, 8] </ref>, heap-based aliasing analysis [4, 6, 9, 10, 11], and both [5, 16, 22, 24, 26, 30]. The work by the research group at McGill University [7, 8, 9, 10] is particularly related to our work. Their approach is to decouple the stack-based aliasing analysis and heap-based aliasing analysis. <p> They can also be organized into stack-based aliasing analysis [7, 8], heap-based aliasing analysis [4, 6, 9, 10, 11], and both [5, 16, 22, 24, 26, 30]. The work by the research group at McGill University <ref> [7, 8, 9, 10] </ref> is particularly related to our work. Their approach is to decouple the stack-based aliasing analysis and heap-based aliasing analysis. They first perform a stack-base analysis [7, 8], which identifies pointers to the heap, and then they apply a heap-based analysis [9, 10] for these heap-directed pointers. <p> The work by the research group at McGill University [7, 8, 9, 10] is particularly related to our work. Their approach is to decouple the stack-based aliasing analysis and heap-based aliasing analysis. They first perform a stack-base analysis <ref> [7, 8] </ref>, which identifies pointers to the heap, and then they apply a heap-based analysis [9, 10] for these heap-directed pointers. Our approach of 28 program decomposition is more general than their approach of decoupling the two problems.
Reference: [8] <author> Maryam Emami, Rakesh Ghiya, and Laurie Hendren. </author> <title> Context-sensitive interprocedural points-to analysis in the presence of function pointers. </title> <booktitle> In Proceedings of SIGPLAN'94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 242-256, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Some of them are more appropriate for aliases involving accesses to heap locations (i.e., heap-based aliases), e.g., [4, 6, 12]. Some are more appropriate for aliases involving accesses to stack locations (i.e., stack-based aliases), e.g., <ref> [7, 8] </ref>. Others handle both in a similar fashion, e.g., [5, 16, 22, 30]. It has been proposed in [8] that completely different analysis methods have to be considered for stack-based and heap-based aliases. <p> Some are more appropriate for aliases involving accesses to stack locations (i.e., stack-based aliases), e.g., [7, 8]. Others handle both in a similar fashion, e.g., [5, 16, 22, 30]. It has been proposed in <ref> [8] </ref> that completely different analysis methods have to be considered for stack-based and heap-based aliases. However, it is not clear how different approaches can be combined in a reasonable way to solve the problem for programs that may have both kinds of aliases. <p> Any of these algorithms can be employed for individual weakly connected components in our program decomposition. In addition, our decomposition enables a sparse program representation for each component and therefore will allow any analysis algorithm to run faster. The existing analysis algorithms can be classified into flow-sensitive/context-sensitive <ref> [5, 6, 7, 8, 9, 10, 11, 12, 16, 30] </ref>, flow-insensitive/context-insensitive [3, 24, 26, 28], flow-sensitive/context-insensitive [4, 22], and flow-insensitive/context-sensitive [1]. They can also be organized into stack-based aliasing analysis [7, 8], heap-based aliasing analysis [4, 6, 9, 10, 11], and both [5, 16, 22, 24, 26, 30]. <p> The existing analysis algorithms can be classified into flow-sensitive/context-sensitive [5, 6, 7, 8, 9, 10, 11, 12, 16, 30], flow-insensitive/context-insensitive [3, 24, 26, 28], flow-sensitive/context-insensitive [4, 22], and flow-insensitive/context-sensitive [1]. They can also be organized into stack-based aliasing analysis <ref> [7, 8] </ref>, heap-based aliasing analysis [4, 6, 9, 10, 11], and both [5, 16, 22, 24, 26, 30]. The work by the research group at McGill University [7, 8, 9, 10] is particularly related to our work. Their approach is to decouple the stack-based aliasing analysis and heap-based aliasing analysis. <p> They can also be organized into stack-based aliasing analysis [7, 8], heap-based aliasing analysis [4, 6, 9, 10, 11], and both [5, 16, 22, 24, 26, 30]. The work by the research group at McGill University <ref> [7, 8, 9, 10] </ref> is particularly related to our work. Their approach is to decouple the stack-based aliasing analysis and heap-based aliasing analysis. They first perform a stack-base analysis [7, 8], which identifies pointers to the heap, and then they apply a heap-based analysis [9, 10] for these heap-directed pointers. <p> The work by the research group at McGill University [7, 8, 9, 10] is particularly related to our work. Their approach is to decouple the stack-based aliasing analysis and heap-based aliasing analysis. They first perform a stack-base analysis <ref> [7, 8] </ref>, which identifies pointers to the heap, and then they apply a heap-based analysis [9, 10] for these heap-directed pointers. Our approach of 28 program decomposition is more general than their approach of decoupling the two problems. <p> The modification side effect analysis for FORTRAN was given in [2]; the analysis for C was first presented in [17, 18]. Empirical results of modifications/references through pointer indirections were also reported in <ref> [8] </ref>. 8 Conclusion and Future Work We have presented a program decomposition technique for point-induced aliasing analysis, which works for well-typed C programs. We also provide an algorithm that calculate the flow-insensitive aliases based on the decomposition.
Reference: [9] <author> Rakesh Ghiya. </author> <title> Practical techniques for interprocedural heap analysis. </title> <type> Master's thesis, </type> <institution> McGill University, Montreal, Canada, </institution> <month> march </month> <year> 1995. </year>
Reference-contexts: Any of these algorithms can be employed for individual weakly connected components in our program decomposition. In addition, our decomposition enables a sparse program representation for each component and therefore will allow any analysis algorithm to run faster. The existing analysis algorithms can be classified into flow-sensitive/context-sensitive <ref> [5, 6, 7, 8, 9, 10, 11, 12, 16, 30] </ref>, flow-insensitive/context-insensitive [3, 24, 26, 28], flow-sensitive/context-insensitive [4, 22], and flow-insensitive/context-sensitive [1]. They can also be organized into stack-based aliasing analysis [7, 8], heap-based aliasing analysis [4, 6, 9, 10, 11], and both [5, 16, 22, 24, 26, 30]. <p> The existing analysis algorithms can be classified into flow-sensitive/context-sensitive [5, 6, 7, 8, 9, 10, 11, 12, 16, 30], flow-insensitive/context-insensitive [3, 24, 26, 28], flow-sensitive/context-insensitive [4, 22], and flow-insensitive/context-sensitive [1]. They can also be organized into stack-based aliasing analysis [7, 8], heap-based aliasing analysis <ref> [4, 6, 9, 10, 11] </ref>, and both [5, 16, 22, 24, 26, 30]. The work by the research group at McGill University [7, 8, 9, 10] is particularly related to our work. Their approach is to decouple the stack-based aliasing analysis and heap-based aliasing analysis. <p> They can also be organized into stack-based aliasing analysis [7, 8], heap-based aliasing analysis [4, 6, 9, 10, 11], and both [5, 16, 22, 24, 26, 30]. The work by the research group at McGill University <ref> [7, 8, 9, 10] </ref> is particularly related to our work. Their approach is to decouple the stack-based aliasing analysis and heap-based aliasing analysis. They first perform a stack-base analysis [7, 8], which identifies pointers to the heap, and then they apply a heap-based analysis [9, 10] for these heap-directed pointers. <p> Their approach is to decouple the stack-based aliasing analysis and heap-based aliasing analysis. They first perform a stack-base analysis [7, 8], which identifies pointers to the heap, and then they apply a heap-based analysis <ref> [9, 10] </ref> for these heap-directed pointers. Our approach of 28 program decomposition is more general than their approach of decoupling the two problems.
Reference: [10] <author> Rakesh Ghiya. </author> <title> Is it a tree, a dag, or a cyclic graph? a shape analysis for heap-directed pointers in c. </title> <booktitle> In Conference Record of te 23rd ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-15, </pages> <month> Jan. </month> <year> 1996. </year>
Reference-contexts: Any of these algorithms can be employed for individual weakly connected components in our program decomposition. In addition, our decomposition enables a sparse program representation for each component and therefore will allow any analysis algorithm to run faster. The existing analysis algorithms can be classified into flow-sensitive/context-sensitive <ref> [5, 6, 7, 8, 9, 10, 11, 12, 16, 30] </ref>, flow-insensitive/context-insensitive [3, 24, 26, 28], flow-sensitive/context-insensitive [4, 22], and flow-insensitive/context-sensitive [1]. They can also be organized into stack-based aliasing analysis [7, 8], heap-based aliasing analysis [4, 6, 9, 10, 11], and both [5, 16, 22, 24, 26, 30]. <p> The existing analysis algorithms can be classified into flow-sensitive/context-sensitive [5, 6, 7, 8, 9, 10, 11, 12, 16, 30], flow-insensitive/context-insensitive [3, 24, 26, 28], flow-sensitive/context-insensitive [4, 22], and flow-insensitive/context-sensitive [1]. They can also be organized into stack-based aliasing analysis [7, 8], heap-based aliasing analysis <ref> [4, 6, 9, 10, 11] </ref>, and both [5, 16, 22, 24, 26, 30]. The work by the research group at McGill University [7, 8, 9, 10] is particularly related to our work. Their approach is to decouple the stack-based aliasing analysis and heap-based aliasing analysis. <p> They can also be organized into stack-based aliasing analysis [7, 8], heap-based aliasing analysis [4, 6, 9, 10, 11], and both [5, 16, 22, 24, 26, 30]. The work by the research group at McGill University <ref> [7, 8, 9, 10] </ref> is particularly related to our work. Their approach is to decouple the stack-based aliasing analysis and heap-based aliasing analysis. They first perform a stack-base analysis [7, 8], which identifies pointers to the heap, and then they apply a heap-based analysis [9, 10] for these heap-directed pointers. <p> Their approach is to decouple the stack-based aliasing analysis and heap-based aliasing analysis. They first perform a stack-base analysis [7, 8], which identifies pointers to the heap, and then they apply a heap-based analysis <ref> [9, 10] </ref> for these heap-directed pointers. Our approach of 28 program decomposition is more general than their approach of decoupling the two problems. <p> Our program decomposition can identify the sets of statements related to recursive data structures and therefore allow shape analysis techniques <ref> [4, 10, 23] </ref> to be applied to these statements to extract more precise information. The modification side effect analysis for FORTRAN was given in [2]; the analysis for C was first presented in [17, 18].
Reference: [11] <author> Laurie J. Hendren and Alexandru Nicolau. </author> <title> Parallelizing programs with recursive data structures. </title> <booktitle> In International Conference on Parallel Processing, </booktitle> <pages> pages II49-56, </pages> <year> 1989. </year>
Reference-contexts: Any of these algorithms can be employed for individual weakly connected components in our program decomposition. In addition, our decomposition enables a sparse program representation for each component and therefore will allow any analysis algorithm to run faster. The existing analysis algorithms can be classified into flow-sensitive/context-sensitive <ref> [5, 6, 7, 8, 9, 10, 11, 12, 16, 30] </ref>, flow-insensitive/context-insensitive [3, 24, 26, 28], flow-sensitive/context-insensitive [4, 22], and flow-insensitive/context-sensitive [1]. They can also be organized into stack-based aliasing analysis [7, 8], heap-based aliasing analysis [4, 6, 9, 10, 11], and both [5, 16, 22, 24, 26, 30]. <p> The existing analysis algorithms can be classified into flow-sensitive/context-sensitive [5, 6, 7, 8, 9, 10, 11, 12, 16, 30], flow-insensitive/context-insensitive [3, 24, 26, 28], flow-sensitive/context-insensitive [4, 22], and flow-insensitive/context-sensitive [1]. They can also be organized into stack-based aliasing analysis [7, 8], heap-based aliasing analysis <ref> [4, 6, 9, 10, 11] </ref>, and both [5, 16, 22, 24, 26, 30]. The work by the research group at McGill University [7, 8, 9, 10] is particularly related to our work. Their approach is to decouple the stack-based aliasing analysis and heap-based aliasing analysis.
Reference: [12] <author> Laurie J. Hendren and Alexandru Nicolau. </author> <title> Parallelizing programs with recursive data structures. </title> <journal> IEEE Transaction on Parallel and Distributed Systems, </journal> <volume> 1(1) </volume> <pages> 35-47, </pages> <year> 1990. </year> <month> 30 </month>
Reference-contexts: Some of them are more appropriate for aliases involving accesses to heap locations (i.e., heap-based aliases), e.g., <ref> [4, 6, 12] </ref>. Some are more appropriate for aliases involving accesses to stack locations (i.e., stack-based aliases), e.g., [7, 8]. Others handle both in a similar fashion, e.g., [5, 16, 22, 30]. <p> Any of these algorithms can be employed for individual weakly connected components in our program decomposition. In addition, our decomposition enables a sparse program representation for each component and therefore will allow any analysis algorithm to run faster. The existing analysis algorithms can be classified into flow-sensitive/context-sensitive <ref> [5, 6, 7, 8, 9, 10, 11, 12, 16, 30] </ref>, flow-insensitive/context-insensitive [3, 24, 26, 28], flow-sensitive/context-insensitive [4, 22], and flow-insensitive/context-sensitive [1]. They can also be organized into stack-based aliasing analysis [7, 8], heap-based aliasing analysis [4, 6, 9, 10, 11], and both [5, 16, 22, 24, 26, 30].
Reference: [13] <author> Fritz Henglein. </author> <title> Efficient type inference for higher-order binding-time analysis. </title> <booktitle> In Functional Program--ming and Computer Architecture, </booktitle> <pages> pages 448-472, </pages> <year> 1991. </year>
Reference-contexts: A similar result was reported in [21]. The FA relation is similar to the points-to relation [24, 26]. The approach in [24, 26] is based on a non-standard type inference technique and is inspired by the work on using type inference for binding-time analysis <ref> [13] </ref>. The algorithm handles type casting and indirect calls through function pointers, but do not allow structure types as in C. We handle structures and plan to consider function pointers and type casting in the future.
Reference: [14] <author> William Landi. </author> <title> Undecidability of static analysis. </title> <journal> ACM letters on programming languages and systems, </journal> <volume> 1 </volume> <pages> 323-337, </pages> <year> 1992. </year>
Reference-contexts: Theoretical classification of the compile-time pointer aliasing problem in the literature supports the use of different analysis methods. Landi and Ryder [15] first proved that the may aliasing problem is polynomial for single-level pointers and is NP-hard for multiple-level pointers (including recursive data structures). Later Landi <ref> [14] </ref> proved that for finite-level pointer dereferences ( 2), the may aliasing problem is P-space hard and for recursive data structures, where the number of dereferences is not known at compile time, the problem is undecidable. A similar result was reported in [21].
Reference: [15] <author> William Landi and Barbara G. Ryder. </author> <title> Pointer-induced aliasing: a problem classification. </title> <booktitle> In Conference Record of the 18th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 93-103, </pages> <month> Jan. </month> <year> 1991. </year>
Reference-contexts: For instance, if k is 1 for a component, then there are only single-level pointers in the pointer-related assignments affiliated with the component; it is known that the may-aliasing problem for single-level pointers can be solved precisely in polynomial time <ref> [15] </ref>. If k is 1 for a component, then the pointer-related assignments for the component are involved with some recursive data structures. The may-aliasing problem for recursive data structures has been proved to be NP-hard [15]; our experiences with the algorithm by Landi and Ryder [16] have shown that it is <p> known that the may-aliasing problem for single-level pointers can be solved precisely in polynomial time <ref> [15] </ref>. If k is 1 for a component, then the pointer-related assignments for the component are involved with some recursive data structures. The may-aliasing problem for recursive data structures has been proved to be NP-hard [15]; our experiences with the algorithm by Landi and Ryder [16] have shown that it is time-consuming to analyze large programs with recursive data structures. 20 21 left: flow-insensitive center: combined right: flow-sensitive 22 left: flow-insensitive center: combined right: flow-sensitive 23 24 left: flow-insensitive center: combined right: flow-sensitive 25 26 In <p> Second, we do not require these recursive data structures involve only heap-directed pointers; they may involve pointers from or to stack locations. Theoretical classification of the compile-time pointer aliasing problem in the literature supports the use of different analysis methods. Landi and Ryder <ref> [15] </ref> first proved that the may aliasing problem is polynomial for single-level pointers and is NP-hard for multiple-level pointers (including recursive data structures).
Reference: [16] <author> William Landi and Barbara G. Ryder. </author> <title> A safe approximate algorithm for interprocedural pointer aliasing. </title> <booktitle> In Proceedings of 1992 ACM Symposium on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: Some of them are more appropriate for aliases involving accesses to heap locations (i.e., heap-based aliases), e.g., [4, 6, 12]. Some are more appropriate for aliases involving accesses to stack locations (i.e., stack-based aliases), e.g., [7, 8]. Others handle both in a similar fashion, e.g., <ref> [5, 16, 22, 30] </ref>. It has been proposed in [8] that completely different analysis methods have to be considered for stack-based and heap-based aliases. <p> Statements have IDs associated with them, where an ID is in the range of 1..(# of statements). Conditional and goto statements use statement IDs for their destinations. This is a quadruple representation and it can be depicted in a graphical form such as the ICFG <ref> [16] </ref>. 1 In this paper, we will use flow-sensitive and flow-insensitive to mean algorithm-flow-sensitive and algorithm-flow-insensitive [20]. 2 Program ::= (Procedure) + Procedure ::= (Statement) + Statement ::= entry of P (FmlName 1 ,...,FmlName m ) (procedure entry) j exit of P (procedure exit) j call P (ArgName 1 ,...,ArgName m <p> If k is 1 for a component, then the pointer-related assignments for the component are involved with some recursive data structures. The may-aliasing problem for recursive data structures has been proved to be NP-hard [15]; our experiences with the algorithm by Landi and Ryder <ref> [16] </ref> have shown that it is time-consuming to analyze large programs with recursive data structures. 20 21 left: flow-insensitive center: combined right: flow-sensitive 22 left: flow-insensitive center: combined right: flow-sensitive 23 24 left: flow-insensitive center: combined right: flow-sensitive 25 26 In Figure 12, we present the time for calculating the PE <p> This shows that both calculations are efficient and practical. Combined Analysis We have also experimented with application of different pointer aliasing analysis algorithms to independent sets of pointer-related assignments determined by our program decomposition. We used two pointer aliasing analysis algorithms: one is Landi and Ryder's flow-sensitive algorithm <ref> [16] </ref> and another is the calculation of the partial FA relation given in Section 5.2, which gives us safe flow-insensitive aliasing information. The application of pointer aliasing information that we choose, is to resolve the fixed locations modified or referenced through each object name with pointer dereferences (thru-deref MOD/REF problem). <p> Explanation We think the fact that the combined analysis is doing almost as well as the flow-sensitive analysis in terms of the thru-deref MOD/REF solutions, has something to do with our representation of heap locations, the particular problem we are solving (the thru-deref MOD/REF problems) and the flow-sensitive analysis <ref> [16] </ref> we are using. We use one heap name for each call of system-defined memory allocation routines in a program; the flow-sensitive algorithm also use this approach. <p> Any of these algorithms can be employed for individual weakly connected components in our program decomposition. In addition, our decomposition enables a sparse program representation for each component and therefore will allow any analysis algorithm to run faster. The existing analysis algorithms can be classified into flow-sensitive/context-sensitive <ref> [5, 6, 7, 8, 9, 10, 11, 12, 16, 30] </ref>, flow-insensitive/context-insensitive [3, 24, 26, 28], flow-sensitive/context-insensitive [4, 22], and flow-insensitive/context-sensitive [1]. They can also be organized into stack-based aliasing analysis [7, 8], heap-based aliasing analysis [4, 6, 9, 10, 11], and both [5, 16, 22, 24, 26, 30]. <p> They can also be organized into stack-based aliasing analysis [7, 8], heap-based aliasing analysis [4, 6, 9, 10, 11], and both <ref> [5, 16, 22, 24, 26, 30] </ref>. The work by the research group at McGill University [7, 8, 9, 10] is particularly related to our work. Their approach is to decouple the stack-based aliasing analysis and heap-based aliasing analysis.
Reference: [17] <author> William Landi, Barbara G. Ryder, and Sean Zhang. </author> <title> Interprocedural modification side effect analysis with pointer aliasing. </title> <booktitle> In Proceedings of SIGPLAN'93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 56-67, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: The modification side effect analysis for FORTRAN was given in [2]; the analysis for C was first presented in <ref> [17, 18] </ref>. Empirical results of modifications/references through pointer indirections were also reported in [8]. 8 Conclusion and Future Work We have presented a program decomposition technique for point-induced aliasing analysis, which works for well-typed C programs. We also provide an algorithm that calculate the flow-insensitive aliases based on the decomposition.
Reference: [18] <author> William Landi, Barbara G. Ryder, and Sean Zhang. </author> <title> Interprocedural modification side effect analysis with pointer aliasing. </title> <type> Technical Report LCSR-TR-201, </type> <institution> Laboratory for Computer Science Research, Rutgers University, </institution> <month> March </month> <year> 1993. </year>
Reference-contexts: The modification side effect analysis for FORTRAN was given in [2]; the analysis for C was first presented in <ref> [17, 18] </ref>. Empirical results of modifications/references through pointer indirections were also reported in [8]. 8 Conclusion and Future Work We have presented a program decomposition technique for point-induced aliasing analysis, which works for well-typed C programs. We also provide an algorithm that calculate the flow-insensitive aliases based on the decomposition.
Reference: [19] <author> T. J. Marlowe, W. A. Landi, B. G. Ryder, J. D. Choi, M. G. Burke, and P. Carini. </author> <title> Pointer-induced aliasing: a clarification. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 28(9) </volume> <pages> 67-70, </pages> <year> 1993. </year>
Reference: [20] <author> Thomas J. Marlowe, Barbara G. Ryder, and Michael Burke. </author> <title> Defining flow sensitivity for data flow problems. </title> <type> Technical Report Number LCSR-TR-249, </type> <institution> Laboratory for Computer Science Research, Rutgers University, </institution> <month> July </month> <year> 1995. </year>
Reference-contexts: Conditional and goto statements use statement IDs for their destinations. This is a quadruple representation and it can be depicted in a graphical form such as the ICFG [16]. 1 In this paper, we will use flow-sensitive and flow-insensitive to mean algorithm-flow-sensitive and algorithm-flow-insensitive <ref> [20] </ref>. 2 Program ::= (Procedure) + Procedure ::= (Statement) + Statement ::= entry of P (FmlName 1 ,...,FmlName m ) (procedure entry) j exit of P (procedure exit) j call P (ArgName 1 ,...,ArgName m ) (call statement) j return from P (return statement) j PrmName = PrmName 1 Op PrmName
Reference: [21] <author> G. Ramalingam. </author> <title> The undecidability of aliasing. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(5) </volume> <pages> 1467-1471, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: Later Landi [14] proved that for finite-level pointer dereferences ( 2), the may aliasing problem is P-space hard and for recursive data structures, where the number of dereferences is not known at compile time, the problem is undecidable. A similar result was reported in <ref> [21] </ref>. The FA relation is similar to the points-to relation [24, 26]. The approach in [24, 26] is based on a non-standard type inference technique and is inspired by the work on using type inference for binding-time analysis [13].
Reference: [22] <author> Erik Ruf. </author> <title> Context-insensitive alias analysis reconsidered. </title> <booktitle> In Proceedings of SIGPLAN'95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 13-22, </pages> <month> june </month> <year> 1995. </year>
Reference-contexts: Some of them are more appropriate for aliases involving accesses to heap locations (i.e., heap-based aliases), e.g., [4, 6, 12]. Some are more appropriate for aliases involving accesses to stack locations (i.e., stack-based aliases), e.g., [7, 8]. Others handle both in a similar fashion, e.g., <ref> [5, 16, 22, 30] </ref>. It has been proposed in [8] that completely different analysis methods have to be considered for stack-based and heap-based aliases. <p> In addition, our decomposition enables a sparse program representation for each component and therefore will allow any analysis algorithm to run faster. The existing analysis algorithms can be classified into flow-sensitive/context-sensitive [5, 6, 7, 8, 9, 10, 11, 12, 16, 30], flow-insensitive/context-insensitive [3, 24, 26, 28], flow-sensitive/context-insensitive <ref> [4, 22] </ref>, and flow-insensitive/context-sensitive [1]. They can also be organized into stack-based aliasing analysis [7, 8], heap-based aliasing analysis [4, 6, 9, 10, 11], and both [5, 16, 22, 24, 26, 30]. <p> They can also be organized into stack-based aliasing analysis [7, 8], heap-based aliasing analysis [4, 6, 9, 10, 11], and both <ref> [5, 16, 22, 24, 26, 30] </ref>. The work by the research group at McGill University [7, 8, 9, 10] is particularly related to our work. Their approach is to decouple the stack-based aliasing analysis and heap-based aliasing analysis.
Reference: [23] <author> Mooly Sagiv, Thomas Reps, and Reinhard Wilhelm. </author> <title> Solving shape-analysis problems in languages with destructive updating. </title> <booktitle> In Conference Record of te 23rd ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 16-31, </pages> <month> Jan. </month> <year> 1996. </year>
Reference-contexts: Our program decomposition can identify the sets of statements related to recursive data structures and therefore allow shape analysis techniques <ref> [4, 10, 23] </ref> to be applied to these statements to extract more precise information. The modification side effect analysis for FORTRAN was given in [2]; the analysis for C was first presented in [17, 18].
Reference: [24] <author> Bjarne Steensgaard. </author> <title> Points-to analysis in almost linear time. </title> <type> Technical Report MSR-TR-95-08, </type> <institution> Mi-crosoft Research, </institution> <month> March </month> <year> 1995. </year> <note> to appear in POPL'96. </note>
Reference-contexts: In addition, our decomposition enables a sparse program representation for each component and therefore will allow any analysis algorithm to run faster. The existing analysis algorithms can be classified into flow-sensitive/context-sensitive [5, 6, 7, 8, 9, 10, 11, 12, 16, 30], flow-insensitive/context-insensitive <ref> [3, 24, 26, 28] </ref>, flow-sensitive/context-insensitive [4, 22], and flow-insensitive/context-sensitive [1]. They can also be organized into stack-based aliasing analysis [7, 8], heap-based aliasing analysis [4, 6, 9, 10, 11], and both [5, 16, 22, 24, 26, 30]. <p> They can also be organized into stack-based aliasing analysis [7, 8], heap-based aliasing analysis [4, 6, 9, 10, 11], and both <ref> [5, 16, 22, 24, 26, 30] </ref>. The work by the research group at McGill University [7, 8, 9, 10] is particularly related to our work. Their approach is to decouple the stack-based aliasing analysis and heap-based aliasing analysis. <p> A similar result was reported in [21]. The FA relation is similar to the points-to relation <ref> [24, 26] </ref>. The approach in [24, 26] is based on a non-standard type inference technique and is inspired by the work on using type inference for binding-time analysis [13]. The algorithm handles type casting and indirect calls through function pointers, but do not allow structure types as in C. <p> A similar result was reported in [21]. The FA relation is similar to the points-to relation <ref> [24, 26] </ref>. The approach in [24, 26] is based on a non-standard type inference technique and is inspired by the work on using type inference for binding-time analysis [13]. The algorithm handles type casting and indirect calls through function pointers, but do not allow structure types as in C. <p> The idea of program decomposition for pointer aliasing analysis was motivated by their work on constructing call graphs for programs with indirect calls through function pointers. The G FA for a program, similar to the graph that may result from the analysis in <ref> [24, 26] </ref>, can be perceived as a storage shape graph [4] although it may be quite approximate when there are recursive data structures.
Reference: [25] <author> Bjarne Steensgaard. </author> <title> Sparse functional stores for imperative programs. </title> <booktitle> In ACM SIGPLAN Workshop on Intermediate Representation, </booktitle> <pages> pages 62-70, </pages> <month> Jan. </month> <year> 1995. </year>
Reference-contexts: We handle structures and plan to consider function pointers and type casting in the future. The points-to relation calculated by the algorithms is used to fragment stores for the VDG representation <ref> [25, 29] </ref>. The FA relation is also similar to the cheap alias relation in the work done by Altucher and Landi at Siemens Corporate Research. Their approach is to calculate a program-wise alias relation, which is reflexive, symmetrical, transitive and right-regular.
Reference: [26] <author> Bjarne Steensgaard. </author> <title> Points-to analysis in almost linear time. </title> <booktitle> In Conference Record of te 23rd ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 32-41, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: In addition, our decomposition enables a sparse program representation for each component and therefore will allow any analysis algorithm to run faster. The existing analysis algorithms can be classified into flow-sensitive/context-sensitive [5, 6, 7, 8, 9, 10, 11, 12, 16, 30], flow-insensitive/context-insensitive <ref> [3, 24, 26, 28] </ref>, flow-sensitive/context-insensitive [4, 22], and flow-insensitive/context-sensitive [1]. They can also be organized into stack-based aliasing analysis [7, 8], heap-based aliasing analysis [4, 6, 9, 10, 11], and both [5, 16, 22, 24, 26, 30]. <p> They can also be organized into stack-based aliasing analysis [7, 8], heap-based aliasing analysis [4, 6, 9, 10, 11], and both <ref> [5, 16, 22, 24, 26, 30] </ref>. The work by the research group at McGill University [7, 8, 9, 10] is particularly related to our work. Their approach is to decouple the stack-based aliasing analysis and heap-based aliasing analysis. <p> A similar result was reported in [21]. The FA relation is similar to the points-to relation <ref> [24, 26] </ref>. The approach in [24, 26] is based on a non-standard type inference technique and is inspired by the work on using type inference for binding-time analysis [13]. The algorithm handles type casting and indirect calls through function pointers, but do not allow structure types as in C. <p> A similar result was reported in [21]. The FA relation is similar to the points-to relation <ref> [24, 26] </ref>. The approach in [24, 26] is based on a non-standard type inference technique and is inspired by the work on using type inference for binding-time analysis [13]. The algorithm handles type casting and indirect calls through function pointers, but do not allow structure types as in C. <p> The idea of program decomposition for pointer aliasing analysis was motivated by their work on constructing call graphs for programs with indirect calls through function pointers. The G FA for a program, similar to the graph that may result from the analysis in <ref> [24, 26] </ref>, can be perceived as a storage shape graph [4] although it may be quite approximate when there are recursive data structures.
Reference: [27] <author> Robert E. Tarjan. </author> <title> Data Structures and Network Algorithms. </title> <institution> Society for Industrial and Applied Mathematics, </institution> <year> 1983. </year>
Reference-contexts: Therefore there are no more than N 0 calls to MERGE () and the number of calls to FIND () will be O (N 0 ). If we use a fast union/find algorithm such as the one in <ref> [27] </ref>, the cost of all calls to UNION () and FIND () in Phase 2 is O (N 0 fi ff (N 0 ,N 0 )), where ff is the inverse of the Ackermann's function; the cost of calls to MERGE () in Phase 2 is (O (N 0 fi ff
Reference: [28] <author> W. Weihl. </author> <title> Interprocedural data flow analysis in the presence of pointers, procedure variables and label variables. </title> <booktitle> In Conference Record of the 7th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 83-94, </pages> <month> Jan. </month> <year> 1980. </year>
Reference-contexts: In addition, our decomposition enables a sparse program representation for each component and therefore will allow any analysis algorithm to run faster. The existing analysis algorithms can be classified into flow-sensitive/context-sensitive [5, 6, 7, 8, 9, 10, 11, 12, 16, 30], flow-insensitive/context-insensitive <ref> [3, 24, 26, 28] </ref>, flow-sensitive/context-insensitive [4, 22], and flow-insensitive/context-sensitive [1]. They can also be organized into stack-based aliasing analysis [7, 8], heap-based aliasing analysis [4, 6, 9, 10, 11], and both [5, 16, 22, 24, 26, 30].
Reference: [29] <author> Daniel Weise, Roger Crew, Michael Ernst, and Bjarne Steensgaard. </author> <title> Value dependence graphs: Representation without taxation. </title> <booktitle> In Conference Record of te 21st ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 297-310, </pages> <month> January </month> <year> 1994. </year> <month> 31 </month>
Reference-contexts: We handle structures and plan to consider function pointers and type casting in the future. The points-to relation calculated by the algorithms is used to fragment stores for the VDG representation <ref> [25, 29] </ref>. The FA relation is also similar to the cheap alias relation in the work done by Altucher and Landi at Siemens Corporate Research. Their approach is to calculate a program-wise alias relation, which is reflexive, symmetrical, transitive and right-regular.
Reference: [30] <author> Robert Wilson and Monica Lam. </author> <title> Efficient context-sensitive pointer analysis for c programs. </title> <booktitle> In Proceed--ings of SIGPLAN'95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 1-12, </pages> <month> june </month> <year> 1995. </year>
Reference-contexts: Some of them are more appropriate for aliases involving accesses to heap locations (i.e., heap-based aliases), e.g., [4, 6, 12]. Some are more appropriate for aliases involving accesses to stack locations (i.e., stack-based aliases), e.g., [7, 8]. Others handle both in a similar fashion, e.g., <ref> [5, 16, 22, 30] </ref>. It has been proposed in [8] that completely different analysis methods have to be considered for stack-based and heap-based aliases. <p> Any of these algorithms can be employed for individual weakly connected components in our program decomposition. In addition, our decomposition enables a sparse program representation for each component and therefore will allow any analysis algorithm to run faster. The existing analysis algorithms can be classified into flow-sensitive/context-sensitive <ref> [5, 6, 7, 8, 9, 10, 11, 12, 16, 30] </ref>, flow-insensitive/context-insensitive [3, 24, 26, 28], flow-sensitive/context-insensitive [4, 22], and flow-insensitive/context-sensitive [1]. They can also be organized into stack-based aliasing analysis [7, 8], heap-based aliasing analysis [4, 6, 9, 10, 11], and both [5, 16, 22, 24, 26, 30]. <p> They can also be organized into stack-based aliasing analysis [7, 8], heap-based aliasing analysis [4, 6, 9, 10, 11], and both <ref> [5, 16, 22, 24, 26, 30] </ref>. The work by the research group at McGill University [7, 8, 9, 10] is particularly related to our work. Their approach is to decouple the stack-based aliasing analysis and heap-based aliasing analysis.
Reference: [31] <author> Sean Zhang, Barbara G. Ryder, and Willam Landi. </author> <title> Program decomposition for pointer-induced aliasing analysis: Appendices. </title> <type> Technical report, </type> <institution> Laboratory for Computer Science Research, Rutgers University, </institution> <month> April </month> <year> 1996. </year> <note> In preparation. </note>
Reference-contexts: For instance, for the example program in Figure 4, the FA relation can be partitioned into two subrelations. We prove in <ref> [31] </ref> that the FA relation for a program contains the run-time aliases at any program point on an execution path of the program. <p> We call the graph G FA . In Figure 10, we show the G FA for the example program in Figure 4. The next few lemmas show that G FA is the graph we want. We provide their proofs in <ref> [31] </ref>. 17 Lemma 5.1 For any object name o 1 in B, there is a path from a node x in G FA such that the path is annotated with a sequence of accessors A = a 1 a 2 :::a j (j 0) and o 1 = apply fl (o,A), <p> We call the equivalence relation induced by these sets the partial FA relation. 2 The partial FA relation is the projection of the FA relation on the set B 1 . Since the FA relation for a program is a safe estimate of the run-time aliases for the program <ref> [31] </ref>, we can use the partial FA relation as safe alias relation involving only object names in B 1 .
References-found: 31

