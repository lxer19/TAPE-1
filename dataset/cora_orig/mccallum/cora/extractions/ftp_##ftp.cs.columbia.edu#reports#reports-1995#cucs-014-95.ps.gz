URL: ftp://ftp.cs.columbia.edu/reports/reports-1995/cucs-014-95.ps.gz
Refering-URL: http://www.cs.columbia.edu/~library/1995.html
Root-URL: http://www.cs.columbia.edu
Title: A Paradigm for Decentralized Process Modeling and its Realization in the Oz Environment  
Author: Israel Z. Ben-Shaul CUCS-- 
Degree: Submitted in partial fulfillment of the requirements for the degree of Doctor of Philosophy in the Graduate School of Arts and Sciences.  
Date: 1995  
Affiliation: Columbia University  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Robert Allen and David Garlan. </author> <title> Formalizing architectural connections. </title> <booktitle> In 16th International Conference on Software Engineering, </booktitle> <pages> pages 71-80, </pages> <address> Sorrento, Italy, May 1994. </address> <publisher> IEEE Computer Society Press. Panel Introduction. </publisher>
Reference-contexts: Some related work in this direction has already been done in the area of interconnection languages (e.g., Conic [75]), and in the more general emerging field of software architecture [36], where researchers have been looking at formalisms to define the structure of complex (distributed) systems (e.g. <ref> [1] </ref>). 7.2.2 Wide Area Modeling This direction has been addressed in Oz only preliminarily at best (in Section 5.6).
Reference: [2] <author> Robert Balzer. </author> <title> A 15 year perspective on automatic programming. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-11(11):1257-1268, </volume> <month> November </month> <year> 1985. </year>
Reference: [3] <author> Sergio Bandinelli and Alfonso Fuggetta. </author> <title> Computational reflection in software process modeling: the SLANG approach. </title> <booktitle> In 15th International Conference on Software Engineering, </booktitle> <pages> pages 144-154, </pages> <address> Baltimore MD, May 1993. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Requiring an object-based project database does not seem to be a severe restriction, though, as most existing PCEs tend to use object-based databases (Adele-2 [10], Merlin [109], SPADE <ref> [3] </ref>, Arcadia [57], Matisse [35], to name a few). * T | A set of tools being used in the environment. <p> The application of our decentralized model to Petri-net-based PCEs is influenced primarily by SLANG <ref> [3] </ref> and FUNSOFT [39], and their corresponding PMLs SPADE and MELMAC, respectively. Each of these PMLs is based on extended Petri-net formalisms (specifically, SLANG is based on ER nets, and FUNSOFT on predicate/transition nets), but we will stick for the most part with the general Petri-net formalism.
Reference: [4] <author> Sergio Bandinelli, Alfonso Fuggetta, Carlo Ghezzi, and Sandro Grigolli. </author> <title> Process enactment in SLANG. </title> <editor> In J.C. Derniame, editor, </editor> <booktitle> Software Process Technology Second European Workshop, number 635 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Trondheim, Norway, </address> <month> September </month> <year> 1992. </year>
Reference-contexts: This is a multi-process extension of an example which was originally given in <ref> [4] </ref> describing SLANG. In the example, there are two processes, CODE and TEST, used by two separate groups that are responsible for coding and testing the application, respectively.
Reference: [5] <author> Jay Banerjee and Won Kim. </author> <title> Semantics and implementation of schema evolution in object-oriented databases. </title> <booktitle> In ACM SIGMOD Annual Conference on the Management of Data, </booktitle> <pages> pages 311-322, </pages> <address> San Francisco CA, </address> <month> May </month> <year> 1987. </year> <journal> Special issue of SIGMOD Record, </journal> <volume> 16(3), </volume> <month> December </month> <year> 1987. </year>
Reference: [6] <author> Naser S. Barghouti. </author> <title> Concurrency Control in Rule-Based Software Development Environments. </title> <type> PhD thesis, </type> <institution> Columbia University, </institution> <month> February </month> <year> 1992. </year> <month> CUCS-001-92. </month>
Reference-contexts: The transaction support for this model in Marvel is described in <ref> [17, 6, 68] </ref>. Recall that the implementation of this model in Marvel was based on annotations made to predicates of rules. <p> tables; (2) a transaction table that associates lock modes (from the lock table) with operations which are carried out during process execution; and (3) a set of control-rules that tailor the default two phase locking protocol for concurrency control (see [17] for (1) and (2). (3) is due to Barghouti <ref> [6] </ref>). As with rules, an instance of the transaction manager without proper lock and transaction tables is useless, but unlike rules, Oz provides default tables which are suitable in most cases (the control-rule base is entirely optional). <p> An example of the need for the latter case is for supporting advanced concurrency-control mechanisms such as in <ref> [6] </ref>.
Reference: [7] <author> Naser S. Barghouti and Gail E. Kaiser. </author> <title> Concurrency control in advanced database applications. </title> <journal> ACM Computing Surveys, </journal> <volume> 23(3) </volume> <pages> 269-317, </pages> <month> September </month> <year> 1991. </year>
Reference: [8] <author> Naser S. Barghouti and Gail E. Kaiser. </author> <title> Scaling up rule-based development environments. </title> <journal> International Journal on Software Engineering & Knowledge Engineering, </journal> <volume> 2(1) </volume> <pages> 59-78, </pages> <month> March </month> <year> 1992. </year>
Reference: [9] <editor> David R. Barstow, Howard E. Shrobe, and Erik Sandewall (editors). </editor> <title> Interactive Programming Environments. </title> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <year> 1984. </year> <month> 232 </month>
Reference: [10] <author> Noureddine Belkhatir, Jacky Estublier, and Walcelio L. Melo. </author> <title> Adele 2: A support to large software development process. </title> <editor> In Mark Dowson, editor, </editor> <booktitle> 1st International Conference on the Software Process: Manufacturing Complex Systems, </booktitle> <pages> pages 159-170, </pages> <address> Redondo Beach CA, </address> <month> October </month> <year> 1991. </year> <journal> IEEE Computer Society. </journal>
Reference-contexts: Requiring an object-based project database does not seem to be a severe restriction, though, as most existing PCEs tend to use object-based databases (Adele-2 <ref> [10] </ref>, Merlin [109], SPADE [3], Arcadia [57], Matisse [35], to name a few). * T | A set of tools being used in the environment.
Reference: [11] <author> Noureddine Belkhatir, Jacky Estublier, and Walcelio L. Melo. </author> <title> Software process model and work space control in the Adele system. </title> <booktitle> In 2nd International Conference on the Software Process: Continuous Software Process Improvement, </booktitle> <pages> pages 2-11, </pages> <address> Berlin Germany, February 1993. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference: [12] <author> M. Ben-Ari. </author> <title> The Ada Rendezvous, </title> <booktitle> chapter 6, </booktitle> <pages> pages 93-105. </pages> <publisher> Prentice Hall International, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1982. </year>
Reference-contexts: However, Ada (and hence APPL/A) has some built-in constructs for concurrent and distributed programming that might be used to model Summits. In particular, the Ada 84 Rendezvous <ref> [12] </ref> seems suitable at first glance. Figure 3.8 shows a partial implementation of the motivating example using Rendezvous.
Reference: [13] <author> Israel Z. Ben-Shaul. </author> <title> An object management system for multi-user programming environments. </title> <type> Master's thesis, </type> <institution> Columbia University, Department of Computer Science, </institution> <month> April </month> <year> 1991. </year> <month> CUCS-010-91. </month>
Reference-contexts: Thus, it is necessary for the server to keep a context for each chain, and switch among the contexts to service multiple clients concurrently. A mechanism for context-switching among multiple executing clients was part of Marvel (due to the author, see <ref> [13] </ref>) and was upgraded to Oz. Considering the multi-server architecture of Oz, there is an additional problem. <p> do not, Summits should be defined so that the amount of transfer of bulk data (e.g., files) is minimized. * Time shifting (across geographically dispersed teams) should also be considered when modeling processes, particularly regarding process steps 13 The natural extension to a hierarchy of SubEnvs was originally proposed in <ref> [13] </ref>, but is beyond the scope of this thesis. 220 that depend on timing constraints. For example, synchronous multiuser activities should be restricted to times of day when there is overlap in working hours. 4.
Reference: [14] <author> Israel Z. Ben-Shaul, George T. Heineman, Steve S. Popovich, Peter D. Skopp, Andrew Z. Tong, and Giuseppe Valetto. </author> <title> Integrating groupware and process technologies in the Oz environment. In Carlo Ghezzi, editor, </title> <booktitle> 9th International Software Process Workshop, </booktitle> <address> Airlie VA, October 1994. </address> <publisher> IEEE Computer Society Press. In press. </publisher>
Reference-contexts: the process model to improve the hit/miss ratio. 7.2.3 User Modeling, Groupware and Process This topic has been already discussed above, and some preliminary work in this direction has been already done in this thesis (Sections 3.6, 4.5 and 6.2), as well as by other members in our research group <ref> [14, 108, 107] </ref>.
Reference: [15] <author> Israel Z. Ben-Shaul and Gail E. Kaiser. </author> <title> A configuration process for a distributed software development environment. </title> <booktitle> In 2nd International Workshop on Configurable Distributed Systems, </booktitle> <pages> pages 123-134, </pages> <address> Pittsburgh PA, March 1994. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Finally, protection from accident is afforded through the objectbase's normal access control facilities. We now present the actual registration process. A detailed description of the configuration process is also given in <ref> [15] </ref>. 178 5.3.1 Configuration Facilities The registration process presented here is mostly similar to any other Oz (sub)process.
Reference: [16] <author> Israel Z. Ben-Shaul and Gail E. Kaiser. </author> <title> A paradigm for decentralized process modeling and its realization in the oz environment. </title> <booktitle> In 16th International Conference on Software Engineering, </booktitle> <pages> pages 179-188, </pages> <address> Sorrento, Italy, May 1994. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: An alternative approach would have been to execute all related Summit activities consecutively, preceded and proceeded by local operations (This, in fact, was the initial composite-Summit model as presented in <ref> [16] </ref>). That is, when a summit activity completes, the coordinating SubEnv enacts (recursively) any further Summit activities emanating from the previous one, and fan-out begins only when the global execution completes.
Reference: [17] <author> Israel Z. Ben-Shaul, Gail E. Kaiser, and George T. Heineman. </author> <title> An architecture for multi-user software development environments. </title> <journal> Computing Systems, The Journal of the USENIX Association, </journal> <volume> 6(2) </volume> <pages> 65-103, </pages> <month> Spring </month> <year> 1993. </year>
Reference-contexts: The transaction support for this model in Marvel is described in <ref> [17, 6, 68] </ref>. Recall that the implementation of this model in Marvel was based on annotations made to predicates of rules. <p> It is a multi- client-server architecture, whereby each SubEnv follows a standard client-server architecture and is essentially self-sufficient for local work, and multiple SubEnvs are inter-connected through a communication layer that enables process-interoperability, with no shared-memory. As many aspects of the single-server architecture are similar to the Marvel architecture <ref> [17] </ref>, they are therefore not discussed here any further. The internal architecture of Oz is illustrated in figure 5.1. <p> external lock table, containing compatibility matrix, power matrix, and inheritance tables; (2) a transaction table that associates lock modes (from the lock table) with operations which are carried out during process execution; and (3) a set of control-rules that tailor the default two phase locking protocol for concurrency control (see <ref> [17] </ref> for (1) and (2). (3) is due to Barghouti [6]). As with rules, an instance of the transaction manager without proper lock and transaction tables is useless, but unlike rules, Oz provides default tables which are suitable in most cases (the control-rule base is entirely optional). <p> Com-ponentization, among other things, is important to support architectural design autonomy, where SubEnvs can be built with different components (e.g., different OMS, or different transaction management). While preliminary work towards componentization has been done by the author in the Marvel project (see <ref> [17] </ref>), it is in general outside the scope of this thesis, and is addressed in the theses of Popovich [88] and Heineman [46]. 5.1.2 The Oz Client The client consists of four major sub-components: (1) interface to, and information about, rules and built-in commands, (2) objectbase display, (3) activity execution module,
Reference: [18] <author> Philip A. Bernstein. </author> <title> Database system support for software engineering. </title> <booktitle> In 9th International Conference on Software Engineering, </booktitle> <pages> pages 166-178, </pages> <address> Monterey CA, March 1987. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference: [19] <author> Sara A. Bly, Steve R. Harrison, and Susan Irwin. </author> <title> Media spaces: Bringing people together in a video, audio, and computing environment. </title> <journal> Communications of the ACM, </journal> <volume> 36(1) </volume> <pages> 28-47, </pages> <month> January </month> <year> 1993. </year>
Reference: [20] <author> Omran A. Bukhres, Jiansan Chen, Weimin Du, and Ahmed K. Elmagarmid. </author> <title> Interbase: An execution environment for heterogeneous software systems. </title> <journal> Computer, </journal> <volume> 26(8) </volume> <pages> 57-69, </pages> <month> August </month> <year> 1993. </year> <month> 233 </month>
Reference: [21] <author> Stefano Ceri and Giuseppe Pelagatti. </author> <title> Distributed Databases. </title> <publisher> McGraw Hill, </publisher> <year> 1985. </year>
Reference: [22] <author> Noam Chomsky. </author> <title> On certain formal properties of grammars. </title> <journal> Information and Control, </journal> <volume> 2(2), </volume> <year> 1959. </year>
Reference-contexts: At a later point, when both teams are ready for a second test, a second Summit activity is initiated. 3.5.3 Grammar-Based PMLs The grammar hierarchy <ref> [22] </ref> and the corresponding automata provide another powerful formalism for modeling a wide variety of systems, although they may have been less frequently applied to software process modeling than the other paradigms mentioned.
Reference: [23] <author> Donald Cohen. </author> <title> Automatic compilation of logical specifications into efficient programs. </title> <booktitle> In 5th National Conference on Artificial Intelligence, volume Science, </booktitle> <pages> pages 20-25, </pages> <address> Philadelphia, PA, </address> <month> August </month> <year> 1986. </year> <note> AAAI. </note>
Reference-contexts: Forward chaining arises when the action or post-condition of a rule fulfills the pre-conditions of some rules, which are then fired recursively. Rule-based PMLs can be roughly divided into backward-chaining oriented such as Prolog-based Darwin [78], forward-chaining oriented such as AP5 <ref> [23] </ref>, and those that incorporate both, like Merlin [109]. The rule is the natural unit of commonality for import-export, although in practice the import can be carried out on a set of logically related (but nevertheless independent from each other) set of rules.
Reference: [24] <author> Wolfgang Deiters and Volker Gruhn. </author> <title> Managing software processes in the environment MELMAC. </title> <editor> In Richard N. Taylor, editor, </editor> <booktitle> 4th ACM SIGSOFT Symposium on Software Development Environments, </booktitle> <pages> pages 193-205, </pages> <address> Irvine CA, </address> <month> De-cember </month> <year> 1990. </year> <journal> Special issue of Software Engineering Notes, </journal> <volume> 15(6), </volume> <month> December </month> <year> 1990. </year>
Reference: [25] <author> Prasun Dewan and Rajiv Choudhary. </author> <title> A high-level and flexible framework for implementing multiuser user interfaces. </title> <journal> ACM Transactions on Information Systems, </journal> <volume> 10(4) </volume> <pages> 345-380, </pages> <month> October </month> <year> 1992. </year>
Reference: [26] <author> Prasun Dewan and John Riedl. </author> <title> Toward computer-supported concurrent software engineering. </title> <journal> Computer, </journal> <volume> 26(1) </volume> <pages> 17-36, </pages> <month> January </month> <year> 1993. </year>
Reference: [27] <author> Mark Dowson. </author> <title> Istar | an integrated project support environment. </title> <editor> In Peter Henderson, editor, </editor> <booktitle> ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pages 27-33, </pages> <address> Palo Alto, CA, </address> <month> December </month> <year> 1986. </year> <journal> Special issue of SIGPLAN Notices, </journal> <volume> 22(1), </volume> <month> January </month> <year> 1987. </year>
Reference: [28] <author> Anthony Earl. </author> <title> Principles of a reference model for computer aided software engineering environments. </title> <editor> In Fred Long, editor, </editor> <booktitle> Software Engineering Environments International Workshop on Environments, volume 467 of Lecture Notes in Computer Science, </booktitle> <pages> pages 115-129, </pages> <address> Chinon, France, </address> <month> September </month> <year> 1989. </year> <note> Springer-Verlag. </note>
Reference-contexts: repository, and management (including concurrency) * Communication services * Tool integration mechanisms * Task/Process management * User interface * Translators and/or interpreters for the process and data models Hence, with the exception of the last item, these are the same components as in the "toaster" reference model for general SDEs <ref> [28] </ref>. The key difference is that by using the translator and loader, some or all of the above components can be tailored, and are not hard wired into the system.
Reference: [29] <author> R. Ahmed et al. </author> <title> The Pegasus heterogenous multidatabase system. </title> <journal> Computer, </journal> <volume> 24(12) </volume> <pages> 19-27, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: The situation with pre-existing schemas is less satisfactory, however, particularly with respect to strongly typed PMLs. Such PMLs should provide facilities that enable to superimpose new shared sub-schemas on top of the pre-existing ones (perhaps along the lines of what is done in Pegasus <ref> [29] </ref>). Alternatively, PMLs might need to sacrifice some of their typing restrictions, at least for Summit rules, to accommodate heterogeneous schemas. 5. Infrastructure support | The comprehensive infrastructure that was built in Oz to support interconnectivity seems to have addressed the "conflicting" independent operation requirement.
Reference: [30] <author> Simon M. Kaplan et al. </author> <title> Supporting collaborative software developement with conversation builder. </title> <editor> In Herbert Weber, editor, </editor> <booktitle> 5th ACM SIGSOFT Symposium on Software Development Environments, </booktitle> <pages> pages 11-20, </pages> <address> Tyson's Corner VA, </address> <month> De-cember </month> <year> 1992. </year> <journal> Special issue of Software Engineering Notes, </journal> <volume> 17(5), </volume> <month> December </month> <year> 1992. </year>
Reference: [31] <author> Marc I. Kellner et al. </author> <title> Software process modeling example problem. </title> <booktitle> In 1st International Conference on the Software Process: Manufacturing Complex Systems, </booktitle> <pages> pages 176-186, </pages> <address> Redondo Beach CA, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: Since then, the example has evolved several times ( <ref> [45, 31] </ref> and the latest version [83]), adding or revising (sub)scenarios that require more advanced modeling and enactment capabilities, and removing some of the rigidity of earlier versions.
Reference: [32] <author> Christer Fernstrom. </author> <title> PROCESS WEAVER: Adding process support to UNIX. </title> <booktitle> In 2nd International Conference on the Software Process: Continuous Software Process Improvement, </booktitle> <pages> pages 12-26, </pages> <address> Berlin, Germany, February 1993. </address> <publisher> IEEE Computer Society Press. </publisher> <pages> 234 </pages>
Reference: [33] <author> G. Forte and R.J. Norman. </author> <title> A self assessment by the software engineering community. </title> <journal> Communications of the ACM, </journal> <volume> 35(4) </volume> <pages> 29-32, </pages> <month> April </month> <year> 1992. </year>
Reference: [34] <author> Pankaj K. Garg, Peiwei Mi, Thuan Pham, Walt Scacchi, and Gary Thunquest. </author> <title> The SMART approach for software process engineering. </title> <booktitle> In 16th International Conference on Software Engineering, </booktitle> <pages> pages 341-350, </pages> <address> Sorrento, Italy, May 1994. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference: [35] <author> P.K. Garg, T. Pham, B. Beach, A. Deshpande, A. Ishizaki, K. Wentzel, and W. Fong. Matisse: </author> <title> A knowldge-based team programming environment. </title> <journal> International Journal of Software Engineering and Knowledge Engineering, </journal> <volume> 4(1) </volume> <pages> 15-59, </pages> <year> 1994. </year>
Reference-contexts: Requiring an object-based project database does not seem to be a severe restriction, though, as most existing PCEs tend to use object-based databases (Adele-2 [10], Merlin [109], SPADE [3], Arcadia [57], Matisse <ref> [35] </ref>, to name a few). * T | A set of tools being used in the environment.
Reference: [36] <author> David Garlan and Dewayne Perry. </author> <title> Software architecture: Practice, potential, and pitfalls. </title> <booktitle> In 16th International Conference on Software Engineering, </booktitle> <pages> pages 363-364, </pages> <address> Sorrento, Italy, May 1994. </address> <publisher> IEEE Computer Society Press. Panel Introduction. </publisher>
Reference-contexts: Some related work in this direction has already been done in the area of interconnection languages (e.g., Conic [75]), and in the more general emerging field of software architecture <ref> [36] </ref>, where researchers have been looking at formalisms to define the structure of complex (distributed) systems (e.g. [1]). 7.2.2 Wide Area Modeling This direction has been addressed in Oz only preliminarily at best (in Section 5.6).
Reference: [37] <author> Carlo Ghezzi, </author> <title> editor. </title> <booktitle> 9th International Software Process Workshop, </booktitle> <address> Airlie VA, October 1994. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference: [38] <author> Mark A. Gisi and Gail E. Kaiser. </author> <title> Extending a tool integration language. </title> <editor> In Mark Dowson, editor, </editor> <booktitle> 1st International Conference on the Software Process: Manufacturing Complex Systems, </booktitle> <pages> pages 218-227, </pages> <address> Redondo Beach CA, October 1991. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Then, each client invokes the activity in its own address space. However, Oz does not interfere or otherwise support the communication at the tool level, which is considered the responsibility of the (multi-user) tool itself. In order to "tie" the tools to the process (es), the standard tool envelopes <ref> [38] </ref> can be used to bind information from the process to the tools (see for example, the white board envelope in Appendix B.2.5.4), or our new enveloping mechanism for asynchronous tools can be employed.
Reference: [39] <author> Volker Gruhn and Rudiger Jegelka. </author> <title> An evaluation of FUNSOFT nets. </title> <editor> In J.C. Derniame, editor, </editor> <booktitle> Software Process Technology Second European Workshop, number 635 in Lecture Notes in Computer Science, </booktitle> <pages> pages 196-214. </pages> <publisher> Springer-Verlag, </publisher> <address> Trondheim, Norway, </address> <month> September </month> <year> 1992. </year>
Reference-contexts: This is sometimes done through wrappers, or envelopes. 2. Process-step | This level encapsulates an activity with local prerequisites and immediate consequences (if any) of the tool invocation, as imposed by the process. For example, in the FUNSOFT Petri-net based PML <ref> [39] </ref>, a process step corresponds to a transition along with its (optionally) attached predicates; in the Articulator task graphs [77], this level corresponds to a node with its predecessor and successor edges; and in rule-based PMLs, a process step is represented by a rule with pre- and post-conditions. <p> The application of our decentralized model to Petri-net-based PCEs is influenced primarily by SLANG [3] and FUNSOFT <ref> [39] </ref>, and their corresponding PMLs SPADE and MELMAC, respectively. Each of these PMLs is based on extended Petri-net formalisms (specifically, SLANG is based on ER nets, and FUNSOFT on predicate/transition nets), but we will stick for the most part with the general Petri-net formalism.
Reference: [40] <author> Nico Haberman and Dewayne Perry. </author> <title> Ada for Experienced Programmers. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1983. </year>
Reference-contexts: Once again, the productions including a common symbol might be completely different in different local processes, and enacted independently and autonomously. 3.5.4 APPL/A We conclude this section with an attempt to apply the decentralzied model to APPL/A [104]. APPL/A is an imperative PML that extends Ada <ref> [40] </ref> with several constructs that support modeling and execution of processes, such as persistent data types (relations), triggers for reactive control, and predicates for specification of local constraints.
Reference: [41] <author> A.N. Habermann and D. Notkin. </author> <title> Gandalf: Software development environments. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-12(12):1117-1127, </volume> <month> December </month> <year> 1986. </year>
Reference: [42] <author> Dennis Heimbigner. </author> <title> Proscription versus Prescription in process-centered environments. </title> <editor> In Takuya Katayama, editor, </editor> <booktitle> 6th International Software Process Workshop: Support for the Software Process, </booktitle> <pages> pages 99-102, </pages> <address> Hakodate, Japan, October 1990. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: There is a spectrum of approaches to employing grammars in process enactment, analogous to sentence generation at one end (what Heimbigner calls a prescriptive process <ref> [42] </ref>) to sentence recognition (parsing) at the other (proscriptive). The PDL project employed the former for context-free grammars [56], while the implementation of the Activity Structures Language on top of Marvel follows the latter approach [60].
Reference: [43] <author> Dennis Heimbigner. </author> <title> A federated architecture for envrionments: Take II. In Preprints of the Process Sensitive SEE Architectures Workshop, </title> <address> Boulder CO, </address> <month> September </month> <year> 1992. </year> <month> 235 </month>
Reference-contexts: One particularly neglected aspect of modeling is user modeling. This has several implications such as unique identification of users across sites, aliasing of "users" from multiple sites to the same nomadic user, security issues, assignment of roles, end so on. 230 7.2.4 System and Language Heterogeneity To re-quote Heimbigner <ref> [43] </ref>, "environments will move to looser, federated, architectures... address inter-operability between partial-environments of varying degrees of openness". We certainly agree with this assessment. This thesis focused on heterogeneity at the process level, and for the most part assumed a homogeneous underlying framework and modelling language.
Reference: [44] <author> Dennis Heimbigner. </author> <title> The ProcessWall: A process state server approach to process programming. </title> <editor> In Herbert Weber, editor, </editor> <booktitle> 5th ACM SIGSOFT Symposium on Software Development Environments, </booktitle> <pages> pages 159-168, </pages> <address> Tyson's Corner VA, </address> <month> December </month> <year> 1992. </year> <journal> Special issue of Software Engineering Notes, </journal> <volume> 17(5), </volume> <month> December </month> <year> 1992. </year>
Reference: [45] <author> Dennis Heimbigner and Marc Kellner. </author> <title> Software process example for ISPW-7, </title> <month> August </month> <year> 1991. </year>
Reference-contexts: Since then, the example has evolved several times ( <ref> [45, 31] </ref> and the latest version [83]), adding or revising (sub)scenarios that require more advanced modeling and enactment capabilities, and removing some of the rigidity of earlier versions.
Reference: [46] <author> George T. Heineman. </author> <title> A transaction manager component for cooperative transaction models. </title> <editor> In Ann Gawman, W. Morven Gentleman, Evelyn Kidd, Perke Larson, and Jacob Slonim, editors, </editor> <booktitle> 1993 CASCON Conference, </booktitle> <pages> pages 910-918, </pages> <address> Toronto Ontario, Canada, </address> <month> October </month> <year> 1993. </year> <institution> IBM Canada Ltd. Laboratory and National Research Council Canada. </institution>
Reference-contexts: As outlined in Chapter 1, the implementation of this component is in general outside the scope of this thesis and is treated separately by Heineman <ref> [46] </ref>. 5.1.1.3 Data Manager This is the lowermost component in the server, consisting of several sub-components. The main sub-component is the in-memory object manager that provides a uniform object-based access to data from any system component. <p> While preliminary work towards componentization has been done by the author in the Marvel project (see [17]), it is in general outside the scope of this thesis, and is addressed in the theses of Popovich [88] and Heineman <ref> [46] </ref>. 5.1.2 The Oz Client The client consists of four major sub-components: (1) interface to, and information about, rules and built-in commands, (2) objectbase display, (3) activity execution module, and (4) an ad-hoc query interface.
Reference: [47] <author> George T. Heineman. </author> <title> A transaction manager component for cooperative transaction models. </title> <type> Technical Report CUCS-017-93, </type> <institution> Columbia University Department of Computer Science, </institution> <month> July </month> <year> 1993. </year> <type> PhD Thesis Proposal. </type>
Reference-contexts: Binding of user-selected remote objects as parameters for Summit rules coordination rules, see <ref> [47] </ref>. 185 1) while (waiting_for_reply) 2) do 3) if (incoming_message) 4) then 5) if (this is a new service request message) 6) then 7) if (a non-update request) 8) then 9) service_request (incoming_message) 10) else 11) queue_request (incoming_message) 12) end 13) else /* this is the reply */ 14) waiting_for_reply =
Reference: [48] <author> George T. Heineman and Gail E. Kaiser. </author> <title> Incremental process support for code reengineering. </title> <booktitle> In International Conference on Software Maintenance, </booktitle> <pages> pages 282-290, </pages> <address> Victoria BC, Canada, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: Instead, they both have to be performed manually using external scripts. But once defined, Summits are fully operational across physical sites. 15 We are using Marvel 3.1.1 to produce Oz, employing a process based on code re-engineering and compo-nentization (see <ref> [48] </ref>), but plan to start using Oz for its own further development as soon as it is sufficiently robust. 202 The ISPW Example: Validation and Methodology Issues The purpose of this chapter is twofold: (1) To validate the feasibility and effectiveness of the ideas and their implementations as presented in this
Reference: [49] <author> George T. Heineman and Gail E. Kaiser. </author> <title> An architecture for integrating concur-rency control into environment frameworks. </title> <booktitle> In 17th International Conference on Software Engineering, </booktitle> <address> Seattle WA, </address> <month> April </month> <year> 1995. </year> <note> In press. </note>
Reference-contexts: However, the actual implementation of the decentralized transaction manager that supports these semantics is for the most part beyond the scope of this dissertation, and is part of Heineman's dissertation, covered in <ref> [49] </ref>. 3.4 The Motivating Example Revisited Recall the motivating example introduced in Section 1.3 (Figure 1.1). Figure 3.4 illustrates its enactment using the Summit protocol. <p> This section focuses on defining the desired transactional semantics of the Summit model. The general solution of how to build a transaction mechanism that addresses the needs described here is beyond the scope of this thesis and is presented by Heineman in <ref> [49] </ref>. The transactional semantics in Oz are tied to the notion of atomicity vs. automation chaining which were inherited from Marvel and extended in Oz. Thus, we begin with a summary of this model in Marvel, and proceed with the extensions made in Oz. 138 4.4.5.1 Atomicity vs. <p> The execution of a single Summit rule is modeled as a distributed transaction, preserving the atomicity of a rule. This includes support for two-phase commit protocol and distributed abort, and involves interaction between local transaction and lock managers (the details are in <ref> [49] </ref>). The Summit model introduces few new kinds of chains: 1. Automation chain from a Summit rule to a local rule ("local" in this context means non-Summit, it does not mean that it necessarily executes at the coordinating SubEnv). We will refer to this as Summit-to-Local-AUtomation chain (SLAU). 2.
Reference: [50] <author> George T. Heineman, Gail E. Kaiser, Naser S. Barghouti, and Israel Z. Ben-Shaul. </author> <title> Rule chaining in marvel: Dynamic binding of parameters. </title> <journal> IEEE Expert, </journal> <volume> 7(6) </volume> <pages> 26-32, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: This seemingly obscure property of cross-site links stems from the fact that automatic (as opposed to user-invoked) derivation of the parameters of rules during chaining is based on their structural relationships to parameters in previously executed rules (for details of this "inversion" algorithm, see <ref> [50] </ref>). Thus, since cross-site links are the only way to structurally relate the otherwise disjoint objectbases, the lack of such a construct would eliminate the possibility of automatically deriving parameters from remote SubEnvs, unless those SubEnvs have already participated in earlier Summits in the on-going chain. <p> Rule names are obviously not sufficient, since multiple (overloaded) rules with the same name can co-exist even within a single local SubEnv (see <ref> [50] </ref> regarding rule overloading). So, some sort of unique rule id scheme is needed. <p> The reason is somewhat pragmatic, and has to do with the rule-overloading mechanism. Recall that Oz allows multiple rules with the same name to co-exist, and determines which rule to execute based on the types and number of actual parameters supplied by the client <ref> [50] </ref>.
Reference: [51] <author> SynerVision for SoftBench: </author> <title> A Process Engine for Teams, 1992. Marketing literature. </title>
Reference-contexts: Note that this requirement excludes environments with no data modeling support (e.g., Synervision <ref> [51] </ref>). Furthermore, the schema must support the notion of an "object" as explained below.
Reference: [52] <author> Bernhard Holtkamp. </author> <title> Process engine interoperation in PSEEs. In Preprints of the Process Sensitive SEE Architectures Workshop, </title> <address> Boulder CO, </address> <month> September </month> <year> 1992. </year>
Reference: [53] <author> M. Honda. </author> <title> Support for parallel development in the sun network software environment. </title> <booktitle> In 2nd International Workshop on Computer-Aided Software Engineering, </booktitle> <pages> pages 5-5 - 5-7, </pages> <year> 1988. </year>
Reference: [54] <author> Watts Humphrey and Marc I. Kellner. </author> <title> Software process modeling: </title> <booktitle> Principles of entity process models. In 11th International Conference on Software Engineering, </booktitle> <pages> pages 331-342, </pages> <address> Pittsburgh PA, May 1989. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference: [55] <author> Watts S. Humphrey. </author> <title> Managing the Software Process. </title> <publisher> Addison-Wesley, </publisher> <address> Reading MA, </address> <year> 1989. </year> <month> 236 </month>
Reference: [56] <author> Hajimu Iida, Takeshi Ogihara, Katsuro Inoue, and Koji Torii. </author> <title> Generating a menu-oriented navigation system from formal description of software development activity sequence. </title> <editor> In Mark Dowson, editor, </editor> <booktitle> 1st International Conference on the Software Process: Manufacturing Complex Systems, </booktitle> <pages> pages 45-57, </pages> <address> Re-dondo Beach CA, October 1991. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: There is a spectrum of approaches to employing grammars in process enactment, analogous to sentence generation at one end (what Heimbigner calls a prescriptive process [42]) to sentence recognition (parsing) at the other (proscriptive). The PDL project employed the former for context-free grammars <ref> [56] </ref>, while the implementation of the Activity Structures Language on top of Marvel follows the latter approach [60]. One group experimented with both in the context of attribute grammars, for HFSP [61] and ObjectiveAttributeGrammars [96], respectively.
Reference: [57] <author> R. Kadia. </author> <title> Issues encountered in building a flexible software development environment. </title> <editor> In Herbert Weber, editor, </editor> <booktitle> 5th ACM SIGSOFT Symposium on Software Development Environments, </booktitle> <pages> pages 169-180, </pages> <address> Tyson's Corner VA, </address> <month> December </month> <year> 1992. </year> <journal> Special issue of Software Engineering Notes, </journal> <volume> 17(5), </volume> <month> December </month> <year> 1992. </year>
Reference-contexts: Requiring an object-based project database does not seem to be a severe restriction, though, as most existing PCEs tend to use object-based databases (Adele-2 [10], Merlin [109], SPADE [3], Arcadia <ref> [57] </ref>, Matisse [35], to name a few). * T | A set of tools being used in the environment.
Reference: [58] <author> Gail E. Kaiser, Israel Z. Ben-Shaul, George T. Heineman, and Wilfredo Marrero. </author> <title> Process evolution for the marvel environment. </title> <type> Technical Report CUCS-047-92, </type> <institution> Columbia University Department of Computer Science, </institution> <month> April </month> <year> 1993. </year>
Reference: [59] <author> Gail E. Kaiser, Peter H. Feiler, and Steven S. Popovich. </author> <title> Intelligent assistance for software development and maintenance. </title> <journal> IEEE Software, </journal> <volume> 5(3) </volume> <pages> 40-49, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: avoiding the need to perform schema evolution if only rule strategies are modified; and (3) it increases componentization by separating data and process modeling, thereby allowing the potential to use different data definition languages (and different OMSs) with the same rule language, and vice versa. 5 An early Marvel paper <ref> [59] </ref> described a different approach with respect to restrictions and chaining across strategies. 100 Oz provides the following five built-in commands for establishing Treaties: export, import, unexport, unimport, and treaty.
Reference: [60] <author> Gail E. Kaiser, Steven S. Popovich, and Israel Z. Ben-Shaul. </author> <title> A bi-level language for software process modeling. </title> <booktitle> In 15th International Conference on Software Engineering, </booktitle> <pages> pages 132-143, </pages> <address> Baltimore MD, May 1993. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: The task level may be explicitly defined in the PML through a special notation, or may be implicitly defined through the local prerequisites/consequences in the process-step level, or both. For example, the Activity Structures Language <ref> [60] </ref> specifies "local constraints" using rules (the form of process steps), and "global control flow" using constrained expressions (explicit tasks). In a Petri-net PML, the task level typically corresponds to a subnet, if such a construct exists. <p> These families were chosen to cover most of the known PCEs [64]. Each PML style has its own strengths and weaknesses with respect to process modeling, and there is no "perfect" process modeling (some of these differences are overviewed in <ref> [60] </ref>). Further, a particular PML might arbitrarily divert from the properties that identify its family. <p> The PDL project employed the former for context-free grammars [56], while the implementation of the Activity Structures Language on top of Marvel follows the latter approach <ref> [60] </ref>. One group experimented with both in the context of attribute grammars, for HFSP [61] and ObjectiveAttributeGrammars [96], respectively. Considering the grammar-based PMLs, a terminal symbol corresponds to an activity 82 in our context hierarchy, a non-terminal symbol to a task, and a production to a process step.
Reference: [61] <author> Takuya Katayama. </author> <title> A hierarchical and functional software process description and its enaction. </title> <booktitle> In 11th International Conference on Software Engineering, </booktitle> <pages> pages 343-352, </pages> <address> Pittsburgh PA, </address> <month> May </month> <year> 1989. </year> <note> IEEE Computer Science Press. </note>
Reference-contexts: The PDL project employed the former for context-free grammars [56], while the implementation of the Activity Structures Language on top of Marvel follows the latter approach [60]. One group experimented with both in the context of attribute grammars, for HFSP <ref> [61] </ref> and ObjectiveAttributeGrammars [96], respectively. Considering the grammar-based PMLs, a terminal symbol corresponds to an activity 82 in our context hierarchy, a non-terminal symbol to a task, and a production to a process step.
Reference: [62] <author> Takuya Katayama, </author> <title> editor. </title> <booktitle> 6th International Software Process Workshop: Support for the Software Process, </booktitle> <address> Hakodate, Japan, October 1990. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Both objectives are attained by discussing the modeling and enactment of an instantiated Oz environment that supports the so-called ISPW-9 Example 1 . The ISPW example was first introduced at the 6th International Software Process Workshop <ref> [62] </ref> in an attempt to provide a canonical "benchmark" process scenario, and ".. as a common framework for understanding and evaluating various approaches to software process modeling and enactment".
Reference: [63] <author> Rick Kazman, Len Bass, Gregory Abowd, and Mike Webb. SAAM: </author> <title> A method for analyzing the properties of software architectures. </title> <booktitle> In 16th International Conference on Software Engineering, </booktitle> <pages> pages 81-90, </pages> <address> Sorrento, Italy, May 1994. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: The key difference is that by using the translator and loader, some or all of the above components can be tailored, and are not hard wired into the system. Indeed, one of the architectural challenges in building a DEPCE is to preserve the modifiability property, which, as evidenced in <ref> [63] </ref>, is the most important property in determining the quality of the architecture. Based on the above definitions and requirements, a high-level view of an architecture of a single-process PCE with an instantiated environment is depicted in Figure 3.1. <p> As many aspects of the single-server architecture are similar to the Marvel architecture [17], they are therefore not discussed here any further. The internal architecture of Oz is illustrated in figure 5.1. We use the following graphical lexicon, partially adopted from <ref> [63] </ref>: squared boxes with the widest bold lines (e.g., the Server) represent operating-system processes, or independent threads of control; squared boxes with lines with intermediate width (e.g., the Task component) represent top-level computational components which are part of an operating-system process but are relatively independent from other components; squared boxes with
Reference: [64] <author> Marc I. Kellner and H. Dieter Rombach. </author> <title> Session summary: Comparisons of software process descriptions. </title> <editor> In Takuya Katayama, editor, </editor> <booktitle> 6th International Software Process Workshop: Support for the Software Process, </booktitle> <pages> pages 7-18, </pages> <address> Hako-date, Japan, October 1990. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: These families were chosen to cover most of the known PCEs <ref> [64] </ref>. Each PML style has its own strengths and weaknesses with respect to process modeling, and there is no "perfect" process modeling (some of these differences are overviewed in [60]). Further, a particular PML might arbitrarily divert from the properties that identify its family.
Reference: [65] <author> Won Kim, Nat Ballou, Jorge F. Garza, and Darrel Woelk. </author> <title> A distributed object-oriented database system suporting shared and private databases. </title> <journal> ACM Transactions on Information Systems, </journal> <volume> 9(1) </volume> <pages> 31-51, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: This functionality has not been realized in Oz yet, as evidenced by the first two unused fields in the SUB ENV class. 5.2.4.2 Object, Client, and Rule Ids Distributed object naming schemes have been thoroughly investigated in the distributed object-oriented database community (see, for example, Orion-2 <ref> [65] </ref>). This is in general outside the scope of this thesis as a research topic, and we only present here a simple solution. The main goal in the design of the object-id management is to reconcile the conflict between allowing autonomy in id assignment and still providing uniqueness.
Reference: [66] <author> Won Kim and Jungyun Seo. </author> <title> Classifying schematic and data heterogeneity in multidatabase systems. </title> <journal> Computer, </journal> <volume> 24(12) </volume> <pages> 12-18, </pages> <month> December </month> <year> 1991. </year> <month> 237 </month>
Reference-contexts: This approach is the most flexible, and fits well with the overall research requirements, but it is also the hardest to realize. The problems associated with this approach fall in general under the domain of schematic heterogeneity, a topic that is investigated by the heterogeneous database community (e.g., see <ref> [66] </ref>) and is largely beyond the scope of this thesis as a research topic, although a practical solution is given in Section 4.3.3. 3.2.5 Sharing Data Instances Requirement 3 in Section 3.2.1 indicated the need to identify data instances which should be made accessible to Treaty subtasks.
Reference: [67] <author> Balachander Krishnamurthy and Naser S. Barghouti. Provence: </author> <title> A process visualization and enactment environment. </title> <editor> In Ian Sommerville and Manfred Paul, editors, </editor> <booktitle> 4th European Software Engineering Conference, number 717 in Lecture Notes in Computer Science, </booktitle> <pages> pages 451-465. </pages> <publisher> Springer-Verlag, </publisher> <address> Garmisch-Partenkirchen, Germany, </address> <month> September </month> <year> 1993. </year>
Reference: [68] <institution> Programming Systems Laboratory. </institution> <note> Marvel 3.1 Administrator's manual. Technical Report CUCS-009-93, </note> <institution> Columbia University Department of Computer Science, </institution> <month> March </month> <year> 1993. </year>
Reference-contexts: The transaction support for this model in Marvel is described in <ref> [17, 6, 68] </ref>. Recall that the implementation of this model in Marvel was based on annotations made to predicates of rules. <p> This user repository approach is superior in terms of user modeling, and also solves the problem of relying on the operating-system's user-id which might not be unique across domains. In fact, such a user repository has already been used (optionally) for access control purposes <ref> [68] </ref>, but has not been been applied to delegation yet and is a topic for future work (see Section 7.2.3).
Reference: [69] <author> David B. Leblang and Robert P. Chase, Jr. </author> <title> Computer-aided software engineering in a distributed workstation environment. </title> <editor> In Peter Henderson, editor, </editor> <booktitle> ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pages 104-112. </pages> <publisher> ACM Press, </publisher> <month> April </month> <year> 1984. </year> <journal> Special issue of SIGPLAN Notices, </journal> <volume> 19(5), </volume> <month> May </month> <year> 1984. </year>
Reference: [70] <author> Manny Lehman, </author> <title> editor. </title> <booktitle> Software Process Workshop, </booktitle> <address> Egham, Surrey, UK, Febru-ary 1984. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference: [71] <author> Manny M. Lehman. </author> <title> Process models, process programs, </title> <booktitle> programming support. In 9th International Conference on Software Engineering, </booktitle> <pages> pages 14-16, </pages> <address> Mon-terey, CA, </address> <month> March </month> <year> 1987. </year>
Reference: [72] <author> Andrew Lih. </author> <title> Oz firewall support, </title> <month> February </month> <year> 1994. </year> <note> Project-course E6998y. </note>
Reference-contexts: By using the SOCKS library of replacement socket calls, Oz clients and servers can communicate with each other, thereby enabling interoperability through firewalled sites. For more details on the SOCKS integration, see <ref> [72] </ref>. 14 This work was done by Andrew Lih. 201 5.7 Implementation Status As already mentioned in Chapter 4, at the time of this writing, Oz version 1.0 has been completed and is fully operational 15 , with most of the features discussed in this chapter fully implemented.
Reference: [73] <institution> Lion Engineering Enviornment, </institution> <year> 1994. </year> <title> Marketing literature. </title>
Reference: [74] <author> Jeff Magee, Naranker Dulay, and Jeff Kramer. </author> <title> Sturcturing parallel and distributed progrmas. </title> <journal> Software Engineering Journal, </journal> <volume> 8(2) </volume> <pages> 73-82, </pages> <month> March </month> <year> 1993. </year>
Reference-contexts: Process interconnection language, separate from a specific PML | This is analogous to Module Interconnection Languages, in which a separate notation is used to denote how modules are inter-connected. For example, the Darwin <ref> [74] </ref> configuration language, the successor to Conic [75] 4 , enables (operating system) processes to interconnect independently of the specific language in which they are written, by means of typed ports through which data is exchanged between the processes.
Reference: [75] <author> Jeff Magee, Jeff Kramer, and Morris Sloman. </author> <title> Constructing distributed systems in Conic. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 15(6) </volume> <pages> 663-675, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Process interconnection language, separate from a specific PML | This is analogous to Module Interconnection Languages, in which a separate notation is used to denote how modules are inter-connected. For example, the Darwin [74] configuration language, the successor to Conic <ref> [75] </ref> 4 , enables (operating system) processes to interconnect independently of the specific language in which they are written, by means of typed ports through which data is exchanged between the processes. <p> For example, this could be used to model and subsequently support interoperability among autonomous Internet repositories, making them more active and responsive to other objects on the network. Some related work in this direction has already been done in the area of interconnection languages (e.g., Conic <ref> [75] </ref>), and in the more general emerging field of software architecture [36], where researchers have been looking at formalisms to define the structure of complex (distributed) systems (e.g. [1]). 7.2.2 Wide Area Modeling This direction has been addressed in Oz only preliminarily at best (in Section 5.6).
Reference: [76] <author> Peiwei Mi and Walt Scacchi. </author> <title> Modeling articulation work in software engineering processes. </title> <editor> In Mark Dowson, editor, </editor> <booktitle> 1st International Conference on the Software Process: Manufacturing Complex Systems, </booktitle> <pages> pages 188-201, </pages> <address> Redondo Beach CA, October 1991. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference: [77] <author> Peiwei Mi and Walt Scacchi. </author> <title> Process integration in CASE environments. </title> <journal> IEEE Software, </journal> <volume> 9(2) </volume> <pages> 45-53, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: For example, in the FUNSOFT Petri-net based PML [39], a process step corresponds to a transition along with its (optionally) attached predicates; in the Articulator task graphs <ref> [77] </ref>, this level corresponds to a node with its predecessor and successor edges; and in rule-based PMLs, a process step is represented by a rule with pre- and post-conditions. The process-step level may also supply the mechanism to interface among multiple activities in a process. <p> For example, in a Petri-net formalism the transition (along with its input and output places) seems a natural choice, whereas in rule-based PMLs the rule (process step) is likely to be chosen. In PMLs that support task hierarchies and modularization (e.g., Articulator <ref> [77] </ref>), a subtask might be the right choice. It is important to recognize that the activity portion of a decentralized subprocess need not be executable in every participating SubEnv, e.g., since the encapsulated tool may not be physically available everywhere.
Reference: [78] <author> Naftaly H. Minsky and David Rozenshtein. </author> <title> A software development environment for law-governed systems. </title> <editor> In Peter Henderson, editor, </editor> <booktitle> ACM SIG-SOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pages 65-75, </pages> <address> Boston MA, </address> <month> November </month> <year> 1988. </year> <journal> ACM Press. Special issue of SIGPLAN Notices, </journal> <volume> 24(2), </volume> <booktitle> February 1989 and of Software Engineering Notes, </booktitle> <volume> 13(5), </volume> <month> November </month> <year> 1988. </year> <month> 238 </month>
Reference-contexts: Then the firing of the second rule is considered recursively. Forward chaining arises when the action or post-condition of a rule fulfills the pre-conditions of some rules, which are then fired recursively. Rule-based PMLs can be roughly divided into backward-chaining oriented such as Prolog-based Darwin <ref> [78] </ref>, forward-chaining oriented such as AP5 [23], and those that incorporate both, like Merlin [109]. The rule is the natural unit of commonality for import-export, although in practice the import can be carried out on a set of logically related (but nevertheless independent from each other) set of rules.
Reference: [79] <author> J. Eliot B. Moss. </author> <title> Nested Transactions: An Approach to Reliable Distributed Computing. Information Systems. </title> <publisher> The MIT Press, </publisher> <address> Cambridge MA, </address> <year> 1985. </year>
Reference-contexts: One solution to this approach is to follow the nested transaction model <ref> [79] </ref>, and replace the failed local transaction by a sub-transaction that commits (e.g., retrying the local transaction) in order for the Summit transaction to commit. But this approach might hold up the Summit and is complicated to realize.
Reference: [80] <author> John R. Nicol, C. Thomas Wilkes, and Frank A. Manola. </author> <title> Object orientation in heterogeneous distributed computing systems. </title> <journal> Computer, </journal> <volume> 26(6) </volume> <pages> 57-67, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Such machines should be capable of communicating with other heterogeneous machines using underlying standards (e.g., CORBA <ref> [80] </ref>) and service explicit as well as implicit (i.e., not-coded) processes. 231
Reference: [81] <author> Leon Osterweil. </author> <title> Software processes are software too. </title> <booktitle> In 9th International Conference on Software Engineering, </booktitle> <pages> pages 1-13, </pages> <address> Monterey CA, March 1987. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference: [82] <author> James D. Palmer and N. </author> <title> Ann Fields. Computer supported cooperative work. </title> <journal> Computer, </journal> <volume> 27, </volume> <month> May </month> <year> 1994. </year>
Reference: [83] <author> Maria H. Penedo. </author> <title> Life-cycle (sub) process demonstration scenario, March 1994. </title> <booktitle> 9th International Software Process Workshop (ISPW9). </booktitle>
Reference-contexts: Since then, the example has evolved several times ( [45, 31] and the latest version <ref> [83] </ref>), adding or revising (sub)scenarios that require more advanced modeling and enactment capabilities, and removing some of the rigidity of earlier versions. <p> within the community as a valid criteria for evaluating the technologies and their underlying concepts. 1 This Oz environment was actually demonstrated at the 9th ISPW. 203 The remainder of this section is organized as follows: Section 6.1 describes a brief overview of the Scenario (a full description copied from <ref> [83] </ref> is given in Appendix B). Section 6.2 discuses in detail the solution to the Scenario with focus on design issues and rationale, as opposed to actual codification of the process (which is given separately in Appendix B).
Reference: [84] <author> Maria H. Penedo and William Riddle. </author> <title> Process-sensitive SEE architecture (PSEA) workshop summary. </title> <booktitle> In ACM SIGSOFT Software Engineering Notes, </booktitle> <address> Boulder CO, </address> <month> April </month> <year> 1993. </year>
Reference: [85] <editor> Dewayne E. Perry, editor. </editor> <booktitle> 3rd International Conference on the Software Process: Applying Software Process, </booktitle> <address> Reston VA, October 1994. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference: [86] <author> James L. Peterson. </author> <title> Petri Net Theory and The Modeling of Systems. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs NJ, </address> <year> 1981. </year>
Reference-contexts: Since the Oz PML is rule-based, we defer further discussion of rules to Chapter 4. 3.5.2 Petri-Nets The Petri-net <ref> [86] </ref> is a powerful formalism for modeling concurrent systems, and it has been widely applied to software process modeling. The application of our decentralized model to Petri-net-based PCEs is influenced primarily by SLANG [3] and FUNSOFT [39], and their corresponding PMLs SPADE and MELMAC, respectively.
Reference: [87] <author> Burkhard Peuschel and Stefan Wolf. </author> <title> Architectural support for distributed process centered software development environments. </title> <editor> In Wilhelm Schafer, editor, </editor> <booktitle> 8th International Software Process Workshop, </booktitle> <pages> pages 126-128, </pages> <address> Wadern, Ger-many, March 1993. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference: [88] <author> Steven S. Popovich. </author> <title> Rule-based process servers for software development environments. </title> <booktitle> In 1992 Centre for Advanced Studies Conference, </booktitle> <volume> volume I, </volume> <pages> pages 477-497, </pages> <address> Toronto ON, Canada, </address> <month> November </month> <year> 1992. </year> <institution> IBM Canada Ltd. Laboratory. </institution>
Reference-contexts: While preliminary work towards componentization has been done by the author in the Marvel project (see [17]), it is in general outside the scope of this thesis, and is addressed in the theses of Popovich <ref> [88] </ref> and Heineman [46]. 5.1.2 The Oz Client The client consists of four major sub-components: (1) interface to, and information about, rules and built-in commands, (2) objectbase display, (3) activity execution module, and (4) an ad-hoc query interface.
Reference: [89] <institution> CLF Project. CLF Manual. USC Information Sciences Institute, </institution> <month> January </month> <year> 1988. </year>
Reference: [90] <editor> Sudha Ram, editor. </editor> <booktitle> Special Issue on Heterogeneous Distributed Database Systems, volume 24:12 of Computer. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> December </month> <year> 1991. </year>
Reference: [91] <author> Steven P. Reiss. </author> <title> An approach to incremental compilation. </title> <booktitle> In SIGPLAN '84 Symposium on Compiler Construction, </booktitle> <pages> pages 144-156, </pages> <address> Montreal, Canada, </address> <month> June </month> <year> 1984. </year> <journal> Special issue of @i[SIGPLAN Notices], </journal> <volume> 19(6), </volume> <month> June </month> <year> 1984. </year>
Reference: [92] <author> Steven P. Reiss. </author> <title> Connecting tools using message passing in the field environment. </title> <journal> IEEE Software, </journal> <volume> 7(4) </volume> <pages> 57-66, </pages> <month> July </month> <year> 1990. </year> <month> 239 </month>
Reference: [93] <author> Thomas W. Reps and Tim Teitelbaum. </author> <title> The Synthesizer Generator: A System for Constructing Language-Based Editors. Texts and Monographs in Computer Science. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1989. </year>
Reference: [94] <author> M. J. Rochkind. </author> <title> The source code control system. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-1:364-370, </volume> <year> 1975. </year>
Reference-contexts: NY's process backward chains to its local configuration manager, say RCS [106], and issues a check-out rule on the object. At the same time, CT backward chains locally to its private configuration manager, say SCCS <ref> [94] </ref>, and issues its own check-out request. This rule could further have a condition that implies firing other rules recursively, independent of any other site's process knowledge or interest.
Reference: [95] <author> Mahadev Satyanarayanan, James J. Kistler, Puneet Kumar, Maria E. Okasaki, Ellen H. Siegel, and David C. Steere. Coda: </author> <title> A highly available file system for a distributed workstation environment. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 39(4) </volume> <pages> 447-459, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: Cache and replica management as well as pre-fetching methods in distributed systems in general and in distributed database and file systems in particular, is a wide topic on its own and has been widely explored (e.g., Coda <ref> [95] </ref>). However, special characteristics of Oz make it a "special case" worth discussing the solution to the first two problems mentioned above.
Reference: [96] <author> Yoichi Shinoda and Takuya Katayama. </author> <title> Towards formal description and automatic generation of programming environments. </title> <editor> In Fred Long, editor, </editor> <booktitle> Software Engineering Environments International Workshop on Environments, number 467 in Lecture Notes in Computer Science, </booktitle> <pages> pages 261-270. </pages> <publisher> Springer-Verlag, </publisher> <address> Chi-non, France, </address> <month> September </month> <year> 1989. </year>
Reference-contexts: The PDL project employed the former for context-free grammars [56], while the implementation of the Activity Structures Language on top of Marvel follows the latter approach [60]. One group experimented with both in the context of attribute grammars, for HFSP [61] and ObjectiveAttributeGrammars <ref> [96] </ref>, respectively. Considering the grammar-based PMLs, a terminal symbol corresponds to an activity 82 in our context hierarchy, a non-terminal symbol to a task, and a production to a process step.
Reference: [97] <author> Izhar Shy, Richard Taylor, and Leon Osterweil. </author> <title> A metaphor and a conceptual architecture for software development enviornments. </title> <editor> In Fred Long, editor, </editor> <booktitle> Software Engineering Environments International Workshop on Environments, volume 467 of Lecture Notes in Computer Science, </booktitle> <pages> pages 77-97. </pages> <publisher> Springer-Verlag, </publisher> <address> Chinon, France, </address> <month> September </month> <year> 1989. </year>
Reference: [98] <author> Peter D. Skopp. </author> <title> Process centered software development on mobile hosts. </title> <type> Technical Report CUCS-035-93, </type> <institution> Columbia University Department of Computer Science, </institution> <month> October </month> <year> 1993. </year> <type> MS Thesis Proposal. </type>
Reference-contexts: delegation consists of two aspects: (1) modeling the work itself, delegatee (s), tools, and artifacts involved; and (2) supporting the enactment of the 14 A proxy client mechanism in Oz was implemented by Peter Skopp originally to support low-bandwidth clients, but was later generalized for other purposes including delegation; see <ref> [98] </ref> for details. 15 Tong also describes support for hybrid form of process-based delegation, where the delegation is modeled in the process but the delegated work is still entered into an agenda rather than executed immediately by the delegatee. 146 defined delegation. <p> but on average it is about 100 bytes long. 12 An extension of this model that deals with low-bandwidth clients where there is no shared file system with their server (mainly to address remote clients that are connected through a modem to the server) is dealt with separately by Skopp <ref> [98] </ref>. 13 This is largely due to Peter Skopp and Shelley Tselepis 198 maintain information on the transfer. However, information regarding the halted rule is held only by the receiver. <p> For example, by observing the rule network and anticipating a path in a chain of rules, files that are intended to be used in (forward-chained) rules in the near future can be prefetched. Some preliminary work in this area has been done by Skopp, see <ref> [98] </ref>. 199 5.6.1.2 Extensions to Connection Server and Database The basic requirement here is to ensure that all the information which is necessary for connectivity, without exceptions, can be obtained from the connection database or through the Connection Server.
Reference: [99] <author> Peter D. Skopp and Gail E. Kaiser. </author> <title> Disconnected operation in a multi-user software development environment. </title> <editor> In Bharat Bhargava, editor, </editor> <booktitle> IEEE Workshop on Advances in Parallel and Distributed Systems, </booktitle> <pages> pages 146-151, </pages> <address> Princeton NJ, </address> <month> October </month> <year> 1993. </year>
Reference-contexts: That is, a client is assumed to always be connected to its local server. (An extension of this model, in which clients can be disconnected temporarily from their server, is investigated separately by Skopp <ref> [99] </ref>.) In contrast, the two other connections can be regarded as "temporary", since they are 1 There are actually three kinds of clients: XView, Motif, and a command-line client. 158 159 optional, and can be dynamically reconnected and disconnected over the course of a session, without disrupting the local operation of
Reference: [100] <author> Michael H. Sokolsky and Gail E. Kaiser. </author> <title> A framework for immigrating existing software into new software development environments. </title> <journal> Software Engineering Journal, </journal> <volume> 6(6) </volume> <pages> 435-453, </pages> <month> November </month> <year> 1991. </year>
Reference-contexts: test cases were valid, as 8 The author, George Heineman, Peter Skopp and Jack Yang. 9 C/Marvel , a process that supports general purpose code development in the C programming language. 10 A tool that aids in migrating file-system-based environments into Oz is currently under development, based on the Marvelizer <ref> [100] </ref> tool which migrated artifacts from the file system into a Marvel environment. We already employ a separate tool for upgrading Marvel environments into (single-site) Oz environments, and intend to combine both functionalities into the ozify tool. 217 well as the other artifacts that were maintained in the objectbases.
Reference: [101] <author> Ian Sommerville. </author> <title> Software Engineering. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1989. </year>
Reference: [102] <author> Nandit Soparkar, Henry F. Korth, and Abraham Silberschatz. </author> <title> Failure-resilient transaction management in multidatabases. </title> <journal> Computer, </journal> <volume> 24(12) </volume> <pages> 28-36, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: While autonomy concerns should play a role in the design of distributed transaction management supporting our model, it is in general impossible to provide global consistency as well as local autonomy in transaction management (as shown by Korth in <ref> [102] </ref>). The approach to be taken, then, should be directed towards minimizing the global atomicity requirements of Summits.
Reference: [103] <author> Robert E. Strom, David F. Bacon, Arthur P. Goldberg, Andy Lowry, Daniel M. Yellin, and Shaula Alexander Yemini. </author> <title> Hermes A Language for Distributed Computing. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs NJ, </address> <year> 1991. </year>
Reference-contexts: Other distributed programming languages | This community produced numerous languages that support some form of dynamic program configuration among relatively independent (operating system) processes. One representative is Hermes <ref> [103] </ref>, another port-based language in which new ports can be added to an executing (operating system) process and existing port connections can also be changed, by statements executed from within the existing Hermes code.
Reference: [104] <author> Stanley M. Sutton, Jr. APPL/A: </author> <title> A Prototype Language for Software-Process Programming. </title> <type> PhD thesis, </type> <institution> University of Colorado, </institution> <year> 1990. </year> <month> 240 </month>
Reference-contexts: Once again, the productions including a common symbol might be completely different in different local processes, and enacted independently and autonomously. 3.5.4 APPL/A We conclude this section with an attempt to apply the decentralzied model to APPL/A <ref> [104] </ref>. APPL/A is an imperative PML that extends Ada [40] with several constructs that support modeling and execution of processes, such as persistent data types (relations), triggers for reactive control, and predicates for specification of local constraints.
Reference: [105] <author> Carl D. Tait and Dan Duchamp. </author> <title> Detection and exploitation of file working sets. </title> <booktitle> In 11th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 2-9, </pages> <address> Arlington TX, May 1991. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: The key issue is to use the right criteria to determine what files are likely to be needed soon, and prefetch them. For example, one method might be to use history of access patterns (for more work in that area see <ref> [105] </ref>). The interesting aspect from the Oz perspective is that the process model contains semantic knowledge which might help in predicting future references.
Reference: [106] <author> Walter F. Tichy. </author> <title> RCS | a system for version control. </title> <journal> Software | Practice & Experience, </journal> <volume> 15(7) </volume> <pages> 637-654, </pages> <month> July </month> <year> 1985. </year>
Reference-contexts: In our example, suppose that the object xv:c from NY and query:c from CT are not checked-out. NY's process backward chains to its local configuration manager, say RCS <ref> [106] </ref>, and issues a check-out rule on the object. At the same time, CT backward chains locally to its private configuration manager, say SCCS [94], and issues its own check-out request. <p> The tool also incorporates audio for verbal communication during the inspection process, and video stills to identify the participants. 211 sub-system, including sophisticated support for version branching and merging which was built on top of RCS <ref> [106] </ref>; Tools for editing, compiling, building and debugging the code fix, automation support for parts of the process, consistency propagations, and more (see Section B.2.3 for details).
Reference: [107] <author> Andrew Z. Tong, Gail E. Kaiser, and Steven S. Popovich. </author> <title> A flexible rule-chaining engine for process-based software engineering. </title> <booktitle> In 9th Knowledge-Based Software Engineering Conference, </booktitle> <pages> pages 79-88, </pages> <address> Monterey CA, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: This approach is relatively straightforward, and can be realized "outside the process" by built-in commands that allow to transfer tasks across users, provided that there exist a persistent mechanism in which to store these requests (e.g., a user agenda); such approach was taken by Tong et al. in <ref> [107] </ref> 15 , and we do not discuss it here any further. <p> Delegation of whole sub-chains may be particularly attractive for pre- and post- Summits, where whole local chains could be delegated to local users. However, this subject is yet to be explored (for a partial treatment of task delegation see <ref> [107] </ref>); here we focus on the simpler case of activity delegation. <p> the process model to improve the hit/miss ratio. 7.2.3 User Modeling, Groupware and Process This topic has been already discussed above, and some preliminary work in this direction has been already done in this thesis (Sections 3.6, 4.5 and 6.2), as well as by other members in our research group <ref> [14, 108, 107] </ref>.
Reference: [108] <author> Giuseppe Valetto. </author> <title> Expanding the repertoire of process-based tool integration. </title> <type> Master's thesis, </type> <institution> Columbia University, Department of Computer Science, </institution> <month> Decem-ber </month> <year> 1994. </year> <month> CUCS-027-94. </month>
Reference-contexts: The first has to do with integrating groupware technology, mainly integration of synchronous multi-user tools (e.g., multi-user editors) that enable multiple human users, possibly physically dispersed, to collaborate (support for enactment of asynchronous multi-user tools in PCEs has been investigated in <ref> [108] </ref>). While in some aspects the introduction of this technology obviously implies additional architectural support from the PCE (for example, connecting multiple human users from multiple sites to the same conceptual activity), the extension of this aspect to our model seems both natural and simple. <p> For related work on infrastructure support for multi-user asynchronous tools (e.g., "large" tools that are themselves systems, like databases) see <ref> [108] </ref>. 4.5.1 Modeling and Enacting Delegation The need for delegation is clear: since delegation of tasks is commonplace in multi-person organizations, multi-user PCEs should enable users to delegate certain tasks to other users and/or other machines. <p> The various user/machine delegation combinations are summarized in table 4.5.1 (Local vs. Remote is with respect to the Initiating User). We focus in this section on user and full delegation (cases 3 and 4 in the table); machine-only delegation has been explored by Valetto in <ref> [108] </ref>. Delegation can be ad hoc or process-based. Ad hoc delegation assumes that a unit of work has been pre-assigned to a user (or a set of users) and that he can manually assign (parts of) it to other user (s). <p> However, there are several differences regarding the 17 Borrowed from the language extensions which were made in <ref> [108] </ref>. 153 policy of an acceptable binding set. First, the activity must be delegated to a set of at least two users and the initiator may or may not be treated as an implicit participant (regardless of whether he is specified in the binding set). <p> If, however, the support for multi-user tools is modified in Oz and requires to allow multiple decentralized tasks to explicitly update the same objects (for example, along the lines of <ref> [108] </ref>), this constraint might need to be relaxed. Given the above constraint, the implication is that if we could find a way to properly update a ready-to-run task with the relevant update information just before activating it, its view of the cache would still be valid. 2. <p> the process model to improve the hit/miss ratio. 7.2.3 User Modeling, Groupware and Process This topic has been already discussed above, and some preliminary work in this direction has been already done in this thesis (Sections 3.6, 4.5 and 6.2), as well as by other members in our research group <ref> [14, 108, 107] </ref>.
Reference: [109] <author> Wilhelm Schafer, Burkhard Peuschel and Stefan Wolf. </author> <title> A knowledge-based software development environment supporting cooperative work. </title> <journal> International Journal on Software Engineering & Knowledge Engineering, </journal> <volume> 2(1) </volume> <pages> 79-106, </pages> <month> March </month> <year> 1992. </year> <month> 241 </month>
Reference-contexts: Requiring an object-based project database does not seem to be a severe restriction, though, as most existing PCEs tend to use object-based databases (Adele-2 [10], Merlin <ref> [109] </ref>, SPADE [3], Arcadia [57], Matisse [35], to name a few). * T | A set of tools being used in the environment. <p> Forward chaining arises when the action or post-condition of a rule fulfills the pre-conditions of some rules, which are then fired recursively. Rule-based PMLs can be roughly divided into backward-chaining oriented such as Prolog-based Darwin [78], forward-chaining oriented such as AP5 [23], and those that incorporate both, like Merlin <ref> [109] </ref>. The rule is the natural unit of commonality for import-export, although in practice the import can be carried out on a set of logically related (but nevertheless independent from each other) set of rules.
References-found: 109

