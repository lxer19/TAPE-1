URL: http://www.cs.msu.edu/~stire/Papers/ase98.ps
Refering-URL: http://www.cs.msu.edu/~stire/
Root-URL: http://www.cs.msu.edu
Title: Automating UI Generation by Model Composition  
Author: R. E. Kurt Stirewalt Spencer Rugaber 
Address: East Lansing, Michigan 48824 Atlanta, Georgia 30332-0280  
Affiliation: Computer Science and Engineering Dept. College of Computing Michigan State University Georgia Institute of Technology  
Abstract: Copyright 1998 IEEE. Published in the 13th Conference on Automated Software Engineering (ASE'98) October 13-16, 1998 in Honolulu, Hawaii. Personal use of this material is permitted. However, permission to reprint/republish this material for advertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists, or to reuse any copyrighted component of this work in other works, must be obtained from the IEEE. Contact: Hoes Lane/ PO Box 1331/ Piscataway, NJ 08855-1331, USA. Abstract Automated user-interface generation environments have been criticized for their failure to deliver rich and powerful interactive applications [18]. To specify more powerful systems, designers require multiple specialized modeling notations [12, 14]. The model-composition problem is concerned with automatically deriving powerful, correct, and efficient user interfaces from multiple models specified in different notations. Solutions balance the advantages of separating code generation into specialized code generators with deep, model-specific knowledge against the correctness and efficiency obstacles that result from such separation. We present a correct and efficient solution that maximizes the advantage of separation through run-time composition mechanisms. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. D. Abowd. </author> <title> Formal Aspects of Human-Computer Interaction. </title> <type> PhD thesis, </type> <institution> University of Oxford, </institution> <year> 1991. </year>
Reference-contexts: However, to generate code from models, we need a more formal def inition of agents and agent composition. Process algebras, such as LOTOS [4], are formal notations used to describe concurrent, communicating agents. Process algebras are particularly useful for describing user-interface agent composition <ref> [1, 2] </ref>. A process is an entity whose internal structure can only be discovered by observing the actions in which it participates. In this paper, we use the LOTOS [4] notation to specify processes. <p> In our abbreviated LOTOS notation, the conjunction of P 1 and P 2 is written P 1 k P 2 . Alexander uses conjunction to compose separately defined application and presentation agents [2]. Abowd uses agent-based separation to illuminate usability properties of interactive systems <ref> [1] </ref>. Both of these approaches rely on the use of conjunction to compose agents that are defined separately but that influence each other. In fact, conjunction is a general operator for composing partial specifications of a system [19].
Reference: [2] <author> H. Alexander. </author> <title> Structuring dialogues using CSP. </title> <editor> In M. Harrison and H. Thimbleby, editors, </editor> <title> Formal Methods in Human-Computer Interaction. </title> <publisher> Cambridge University Press, </publisher> <year> 1990. </year>
Reference-contexts: However, to generate code from models, we need a more formal def inition of agents and agent composition. Process algebras, such as LOTOS [4], are formal notations used to describe concurrent, communicating agents. Process algebras are particularly useful for describing user-interface agent composition <ref> [1, 2] </ref>. A process is an entity whose internal structure can only be discovered by observing the actions in which it participates. In this paper, we use the LOTOS [4] notation to specify processes. <p> For brevity, however, we use the conjunction operator without naming the event set. In our abbreviated LOTOS notation, the conjunction of P 1 and P 2 is written P 1 k P 2 . Alexander uses conjunction to compose separately defined application and presentation agents <ref> [2] </ref>. Abowd uses agent-based separation to illuminate usability properties of interactive systems [1]. Both of these approaches rely on the use of conjunction to compose agents that are defined separately but that influence each other. In fact, conjunction is a general operator for composing partial specifications of a system [19].
Reference: [3] <author> L. Bass and J. Coutaz. </author> <title> Developing Software for the User Interface. SEI Series in Software Engineering. </title> <publisher> Addison-Wesley, </publisher> <year> 1991. </year>
Reference-contexts: A distinguishing characteristic of MASTERMIND is that the model-specific code generators work independently of one another. Composing the code generated from multiple models is difficult. A model, by design, represents some aspects of a system and is neutral with respect to others <ref> [3] </ref>. Inevitably, however, functionality described in one model overlaps with or is dependent upon functionality described in another.
Reference: [4] <author> T. Bolognesi and E. Brinksma. </author> <title> Introduction to the ISO specification language LOTOS. </title> <journal> Computer Network ISDN Systems, </journal> <volume> 14(1), </volume> <year> 1987. </year>
Reference-contexts: However, to generate code from models, we need a more formal def inition of agents and agent composition. Process algebras, such as LOTOS <ref> [4] </ref>, are formal notations used to describe concurrent, communicating agents. Process algebras are particularly useful for describing user-interface agent composition [1, 2]. A process is an entity whose internal structure can only be discovered by observing the actions in which it participates. In this paper, we use the LOTOS [4] notation <p> LOTOS <ref> [4] </ref>, are formal notations used to describe concurrent, communicating agents. Process algebras are particularly useful for describing user-interface agent composition [1, 2]. A process is an entity whose internal structure can only be discovered by observing the actions in which it participates. In this paper, we use the LOTOS [4] notation to specify processes. LOTOS is a process algebra that uses temporal operators to specify permissible orderings and dependences over actions. A LOTOS process performs actions and interacts with other, concurrently executing, processes. Actions are built up out of atomic units called events.
Reference: [5] <author> T. P. Browne et al. </author> <title> Using declarative descriptions to model user interfaces with MASTERMIND. </title> <editor> In F. Paterno and P. Palanque, editors, </editor> <title> Formal Methods in Human Computer Interaction. </title> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: The model-based approach to interactive system development addresses this deficiency by decomposing UI design into the construction of separate models, each of which is declaratively specified <ref> [5] </ref>. Once specified, automated tools integrate the models and generate an efficient system from them. The model-composition problem is the need to efficiently implement and automatically integrate interactive software from separate declarative models. This paper introduces the model-composition problem and presents a solution. <p> By focusing attention on a single aspect of a user interface, a model can be expressed in a highly-specialized notation. This property makes systems developed using the model-based approach easier to develop and maintain than systems produced using other approaches. The MASTERMIND project <ref> [5, 12] </ref> is concerned with the automatic generation of user interfaces from three kinds of models: Presentation models represent the appearance of user interfaces in terms of their widgets and how the widgets behave; Application models represent which parts (functions and data) of applications are accessible from the user interface; and <p> In MAS TERMIND, the rich expressive power is achieved through special-purpose modeling notations <ref> [12, 5] </ref>. The remainder of this paper addresses the generation of correct implementations with maximal efficiency while preserving the expressive power of MASTERMIND models. 3 Design requirements Recall from Figure 1 that each class of model has a code generator that synthesizes run-time modules for models in that class.
Reference: [6] <author> P. Castells, P. Szekely, and E. Salcher. </author> <title> Declarative models of presentation. </title> <booktitle> In IUI'97: International Conference on Intelligent User Interfaces, </booktitle> <pages> pages 137144, </pages> <year> 1997. </year>
Reference-contexts: One characteristic of model-based approaches is that, by restricting the focus of a model to a single attribute of the system, modeling notations can be specialized and highly declarative. The MASTERMIND Presentation Model <ref> [6] </ref>, for example, combines concepts and terminology from graphic design with mechanisms for composing complex presentations through functional constraints. Dialogue models use state and event constructs to describe the user-computer conversation. <p> This new code generator is incorporating state-space reduction technology and will improve interaction time that, in the prototype, is a function of the depth of a dialogue expression with constant time interaction. We are also working on adapting the presentation model code generator described in <ref> [6] </ref> to work within our infra-structure. 6 Conclusions Generating code for a specialized modeling notation is easy. Integrating code generated from multiple models is difficult. Integration is much more complicated than mere linking of compiled object modules.
Reference: [7] <author> J. Coutaz. </author> <title> PAC, an object-oriented model for dialog design. </title> <booktitle> In Human Computer Interaction - INTERACT'87, </booktitle> <pages> pages 431436, </pages> <year> 1987. </year>
Reference: [8] <author> D. Harel. </author> <title> On visual formalisms. </title> <journal> Communications of the ACM, </journal> <volume> 31(5), </volume> <year> 1988. </year>
Reference-contexts: The MASTERMIND Presentation Model [6], for example, combines concepts and terminology from graphic design with mechanisms for composing complex presentations through functional constraints. Dialogue models use state and event constructs to describe the user-computer conversation. Example notations include StateCharts <ref> [8] </ref> and Petri nets [13], which use a variety of composition mechanisms that include state hierarchy, concurrency, and communication. The MASTERMIND Application Model combines concepts and terminology from object-oriented design techniques [15] with mechanisms for composing complex behavior based on method invocation.
Reference: [9] <author> G. E. Krasner and S. T. Pope. </author> <title> A cookbook for using the model view controller user interface paradigm in smalltalk. </title> <journal> Journal of Object Oriented Programming, </journal> <volume> 1(3), </volume> <year> 1988. </year>
Reference-contexts: These architectures describe interactive systems as collections of independent communicating agents, which are independent computational units with identity and behavior. Two general frameworksthe Model-View-Controller (MVC) <ref> [9] </ref> and the Presentation-Abstraction-Control (PAC) [7]define specific agent roles and provide guidance on how these agents should be connected. The roles prescribed by the PAC framework most closely resemble those of the MASTERMIND models.
Reference: [10] <author> B. A. Myers et al. </author> <title> The Amulet environment: New models for effective user-interface software development. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 23(6), </volume> <year> 1997. </year>
Reference-contexts: Inter-model composition is concerned with managing this latter inter-model behavior. Some behavior is highly model specific and neither influences nor is affected by behavior specified in other models. In the presentation model, for example, objects are implemented using graphical primitives in the Amulet toolkit <ref> [10] </ref>, and attribute relations are implemented as declarative formulas that, at run-time, eagerly propagate attribute changes to dependent attributes. As long as changes in these attributes do not trigger behavior in the dialogue or application models, these aspects can be ignored when considering model composition.
Reference: [11] <author> B. A. Myers and M. B. Rosson. </author> <title> Survey on user interface programming. </title> <booktitle> In SIGCHI'92: Human Factors in Computing Systems, </booktitle> <month> May </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Building user interfaces (UIs) is time consuming and costly. In systems with graphical UIs (GUIs), nearly 50% of source code lines and development time could be attributed to the UI <ref> [11] </ref>. GUIs are usually built from a fixed set of modules composed in regular ways. Hence, GUI construction is a natural target for automation.
Reference: [12] <author> R. Neches et al. </author> <title> Knowledgeable development environments using shared design models. </title> <booktitle> In Intelligent Interfaces Workshop, </booktitle> <pages> pages 6370, </pages> <year> 1993. </year>
Reference-contexts: By focusing attention on a single aspect of a user interface, a model can be expressed in a highly-specialized notation. This property makes systems developed using the model-based approach easier to develop and maintain than systems produced using other approaches. The MASTERMIND project <ref> [5, 12] </ref> is concerned with the automatic generation of user interfaces from three kinds of models: Presentation models represent the appearance of user interfaces in terms of their widgets and how the widgets behave; Application models represent which parts (functions and data) of applications are accessible from the user interface; and <p> In MAS TERMIND, the rich expressive power is achieved through special-purpose modeling notations <ref> [12, 5] </ref>. The remainder of this paper addresses the generation of correct implementations with maximal efficiency while preserving the expressive power of MASTERMIND models. 3 Design requirements Recall from Figure 1 that each class of model has a code generator that synthesizes run-time modules for models in that class.
Reference: [13] <author> P. Palanque, R. Bastide, and V. Senges. </author> <title> Validating interactive system design through the verification of formal task and system models. </title> <booktitle> In Working Conference on Engineering for Human Computer Interaction, </booktitle> <year> 1995. </year>
Reference-contexts: The MASTERMIND Presentation Model [6], for example, combines concepts and terminology from graphic design with mechanisms for composing complex presentations through functional constraints. Dialogue models use state and event constructs to describe the user-computer conversation. Example notations include StateCharts [8] and Petri nets <ref> [13] </ref>, which use a variety of composition mechanisms that include state hierarchy, concurrency, and communication. The MASTERMIND Application Model combines concepts and terminology from object-oriented design techniques [15] with mechanisms for composing complex behavior based on method invocation.
Reference: [14] <author> A. Puerta. </author> <title> The Mecano project: Comprehensive and integrated support for model-based user interface development. </title> <booktitle> In Computer-Aided Design of User Interfaces, </booktitle> <year> 1996. </year>
Reference: [15] <author> J. Rumbaugh et al. </author> <title> Object-Oriented Modeling and Design. </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: Dialogue models use state and event constructs to describe the user-computer conversation. Example notations include StateCharts [8] and Petri nets [13], which use a variety of composition mechanisms that include state hierarchy, concurrency, and communication. The MASTERMIND Application Model combines concepts and terminology from object-oriented design techniques <ref> [15] </ref> with mechanisms for composing complex behavior based on method invocation. These examples illustrate that composition mechanisms in one model may not exist in another model. It is not clear that any of these intra-model mechanisms are sufficient for inter-model composition, the subject of this paper. <p> The design refines the notions of action and synchronization, which form the basis of inter-module communication, into run-time objects that implement these constraints. 4.1 Run-time control One concern in designing a system is the implementation of software control <ref> [15] </ref>. Control can be implemented in many ways. In procedural systems, for example, control is synonymous with location in the code; whereas in concurrent systems, control is distributed and managed by multiple objects concurrently. <p> Action objects are run-time entities that encapsulate the status (enabled or disabled) of observable actions with activation procedures that can be specialized by model-specific code generators to implement desired functionality. Figure 5 shows our design as an OMT <ref> [15] </ref> object model. The class Action in our design is abstract: It declares an operation enable () that must be supplied by a subclass. OMT denotes subclassing by a triangle, one point of which is connected to the superclass, with one or more lines emanating out to its subclasses.
Reference: [16] <author> R. E. K. Stirewalt. </author> <title> Automatic Generation of Interactive Systems from Declarative Models. </title> <type> PhD thesis, </type> <institution> Georgia Institute of Technology, </institution> <year> 1997. </year>
Reference-contexts: Once all of the synchronization requirements have been met, the Event issues the appropriate activate, get, and set operations and then instructs the dialogue module to compute the next state. This process is described in greater detail in <ref> [16] </ref>. 5 Results and status We evaluated our solution to the model-composition problem with respect to power, correctness, and efficiency. Power We were able to express user interfaces in several case studies using our modeling notations. <p> Power We were able to express user interfaces in several case studies using our modeling notations. We tested the quality of user interfaces on two specific examples: the Print/Save widget described in x 3.3 and an airspace and runway executive that supports an air-traffic controller (ATC) <ref> [16] </ref>. The former demonstrates the ability to generate common, highly reusable tasks for standard graphical user interfaces. The latter demonstrates the ability to support a complex task using a direct-manipulation interface. The ATC example testifies to the power of our approach. <p> In such a deployment, these signals would be connected to External actions and would fit into the framework without change. For more details on this case study and the print/save dialogue, see Stirewalt <ref> [16] </ref>. Correctness In addition to being able to generate and manage powerful user interfaces, the composition of our modules is correct. Two aspects of our approach require justification on these grounds. First is the design of run-time action synchronization. This paper addresses the theoretical issues involved here. <p> As we mentioned earlier, the MAS TERMIND Dialogue model notation can be thought of as a syntactic sugaring for a subset of Full LOTOS. We implemented a prototype dialogue model code generator whose correctness was validated in Stirewalt <ref> [16] </ref>. Efficiency We measured efficiency empirically by applying our prototype code generator on the ATC example. We generated dialogue modules and connected these with hand-coded presentation and application modules. On the examples we tried, we observed no time delays between interactions.
Reference: [17] <author> P. Szekely et al. </author> <title> Declarative models for user-interface construction tools: the MASTERMIND approach. </title> <editor> In Bass and Unger, editors, </editor> <title> Engineering for Human-Computer Interaction. </title> <publisher> Chapman & Hall, </publisher> <year> 1996. </year>
Reference-contexts: Model-based UI generation works on the premise that development and support environments may be built around declarative models of a system. Developers using this paradigm build interfaces by specifying models that describe the desired interface, rather than writing a program that exhibits the behavior <ref> [17] </ref>. One characteristic of model-based approaches is that, by restricting the focus of a model to a single attribute of the system, modeling notations can be specialized and highly declarative.
Reference: [18] <author> Pedro Szekely, Ping Luo, and Robert Neches. </author> <title> Beyond interface builders: Model-based interface tools. In Bridges Between Worlds: </title> <booktitle> Human Factors in Computing Systems: </booktitle> <address> INTERCHI'93, </address> <year> 1993. </year>
Reference: [19] <author> P. Zave and M. Jackson. </author> <title> Conjunction as composition. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 2(4):371411, </volume> <year> 1993. </year>
Reference-contexts: Abowd uses agent-based separation to illuminate usability properties of interactive systems [1]. Both of these approaches rely on the use of conjunction to compose agents that are defined separately but that influence each other. In fact, conjunction is a general operator for composing partial specifications of a system <ref> [19] </ref>. The idea is that each partial specification imposes constraints upon variables (or, in the case of agents, events) that are mentioned in other partial specifications. When these specifications are conjoined, the common variables must satisfy each constraint.
References-found: 19

