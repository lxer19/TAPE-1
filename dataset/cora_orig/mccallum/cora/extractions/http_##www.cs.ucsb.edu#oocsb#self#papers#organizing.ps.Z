URL: http://www.cs.ucsb.edu/oocsb/self/papers/organizing.ps.Z
Refering-URL: http://www.cs.ucsb.edu/oocsb/self/papers/organizing-programs.html
Root-URL: http://www.cs.ucsb.edu
Email: (self@self.stanford.edu)  
Title: Organizing Programs Without Classes  
Author: DAVID UNGAR CRAIG CHAMBERS BAY-WEI CHANG URS HLZLE 
Address: 94305  
Affiliation: Computer Systems Laboratory, Stanford University, Stanford, California  
Date: 4, 3, 1991  
Note: To be published in: LISP AND SYMBOLIC COMPUTATION: An International Journal,  1991 Kluwer Academic Publishers Manufactured in The Netherlands  
Abstract: All organizational functions carried out by classes can be accomplished in a simple and natural way by object inheritance in classless languages, with no need for special mechanisms. A single modeldividing types into prototypes and traitssupports sharing of behavior and extending or replacing representations. A natural extension, dynamic object inheritance, can model behavioral modes. Object inheritance can also be used to provide structured name spaces for well-known objects. Classless languages can even express class-based encapsulation. These stylized uses of object inheritance become instantly recognizable idioms, and extend the repertory of organizing principles to cover a wider range of programs. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Bobrow, D. G., DeMichiel, L. G., Gabriel, R. P., Keene, S. E., Kiczales, G., and Moon, D. A. </author> <title> Common Lisp Object System Specification. </title> <journal> Published as SIGPLAN Notices, </journal> <volume> 23, </volume> <month> 9 </month> <year> (1988). </year>
Reference-contexts: Both are natural and structured programming styles fostered by classless languages. Class-based languages typically have a much more difficult time handling cases that differ from strict representation extension. As mentioned above, Trellis/Owl is one notable exception. Languages with powerful metaclass facilities, such as CLOS <ref> [1] </ref>, are able to define metaclasses for subclasses that do not inherit the instance variables of their superclasses, but this solution is much more complex and probably more verbose than the simple solution in classless languages.
Reference: 2. <author> Borning, A. H. </author> <title> Classes Versus Prototypes in Object-Oriented Languages. </title> <booktitle> In Proceedings of the ACM/IEEE Fall Joint Computer Conference (1986) 36-40. </booktitle>
Reference-contexts: 1 Introduction Recently, several researchers have proposed object models based on prototypes and delegation instead of classes and static inheritance <ref> [2, 9, 11, 14, 15, 18] </ref>. These proposals have concentrated on explaining how prototype-based languages allow more exible arrangements of objects.
Reference: 3. <author> Chambers, C., and Ungar, D. </author> <title> Customization: Optimizing Compiler Technology for SELF, a Dynamically-Typed Object-Oriented Programming Language. </title> <booktitle> In Proceedings of the SIGPLAN 89 Conference on Programming Language Design and Implementation. Published as SIGPLAN Notices, </booktitle> <volume> 24, </volume> <month> 7 </month> <year> (1989) </year> <month> 146-160. </month>
Reference-contexts: The ideas presented here are based on the lessons we learned as we found ways to organize code in SELF, a dynamically-typed prototype-based language <ref> [3, 4, 10, 18] </ref>.
Reference: 4. <author> Chambers, C., Ungar, D., and Lee, E. </author> <title> An Efficient Implementation of SELF, a Dynamically-Typed Object-Oriented Language Based on Prototypes. </title> <booktitle> In OOPSLA 89 Conference Proceedings. Published as SIGPLAN Notices, </booktitle> <volume> 24, </volume> <month> 10 </month> <year> (1989) </year> <month> 49-70. </month> <note> Also to be published in Lisp and Symbolic Computation, 4, 3 (1991). </note>
Reference-contexts: The ideas presented here are based on the lessons we learned as we found ways to organize code in SELF, a dynamically-typed prototype-based language <ref> [3, 4, 10, 18] </ref>.
Reference: 5. <author> Chambers, C., Ungar, D., Chang, B., and Hlzle, U. </author> <title> Parents are Shared Parts of Objects: Inheritance and Encapsulation in SELF. </title> <note> To be published in Lisp and Symbolic Computation, 4, 3 (1991). </note>
Reference-contexts: Since classless languages have no explicit classes or types, it would appear that type-based encapsulation would be impossible to support, severely weakening any encapsulation provided by the language. Perhaps surprisingly, SELFs visibility rules do support a form of type-based encapsulation <ref> [5] </ref>.
Reference: 6. <author> Goldberg, A. </author> <title> Smalltalk-80: The Interactive Programming Environment. </title> <address> Ad-dison-Wesley, Reading, MA (1984). </address> <note> 56 UNGAR, CHAMBERS, CHANG, AND HLZLE </note>
Reference-contexts: Many systems provide features to help organize these name spaces into smaller categories of names that break down the name spaces into digestible chunks. For example, the Smalltalk-80 environment <ref> [6] </ref> supports a two-level structure for browsing classes, dividing up classes into class categories. Classless systems using name space objects can be similarly broken down into categories by subdividing name spaces into multiple parents.
Reference: 7. <author> Goldberg, A., and Robson, D. </author> <title> Smalltalk-80: The Language and Its Implementation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA (1983). </address>
Reference-contexts: To initialize a new instances list of vertices, the Polygon class could define a wrapper method named vertices: that just assigned its argument to the vertices instance variable. This wrapper method is required in languages like Smalltalk-80 1 <ref> [7] </ref> that limit access to an objects instance variables to the object itself. In a classless language, the polygon data type is defined similarly. A prototypical polygon object is created as the first instance of the polygon type (see Figure 1b).
Reference: 8. <author> LaLonde, W. R. </author> <title> Designing Families of Data Types Using Exemplars. </title> <journal> In ACM Transactions on Programming Languages and Systems, </journal> <volume> 11, </volume> <month> 2 </month> <year> (1989) </year> <month> 212-248. </month>
Reference-contexts: For example, the collection data type could be refined into an empty collection data type and a non-empty collection data type, using inheritance to relate the three types <ref> [8] </ref>. However, the behavior mode of an instance may change as its state changes: an empty collection becomes non-empty if an element is added to it. This would correspond in a class-based language to changing an objects class dynamically, and in a prototype-based language to changing an objects parent dynamically.
Reference: 9. <author> LaLonde, W. R., Thomas, D. A., and Pugh, J. R. </author> <title> An Exemplar Based Small-talk. </title> <booktitle> In OOPSLA 86 Conference Proceedings. Published as SIGPLAN Notices, </booktitle> <volume> 21, </volume> <month> 11 </month> <year> (1986) </year> <month> 322-330. </month>
Reference-contexts: 1 Introduction Recently, several researchers have proposed object models based on prototypes and delegation instead of classes and static inheritance <ref> [2, 9, 11, 14, 15, 18] </ref>. These proposals have concentrated on explaining how prototype-based languages allow more exible arrangements of objects.
Reference: 10. <author> Lee, E. </author> <title> Object Storage and Inheritance for SELF, a Prototype-Based Object-Oriented Programming Language. </title> <type> Engineers thesis, </type> <institution> Stanford University (1988). </institution>
Reference-contexts: The ideas presented here are based on the lessons we learned as we found ways to organize code in SELF, a dynamically-typed prototype-based language <ref> [3, 4, 10, 18] </ref>.
Reference: 11. <author> Lieberman, H. </author> <title> Using Prototypical Objects to Implement Shared Behavior in Object-Oriented Systems. </title> <booktitle> In OOPSLA 86 Conference Proceedings. Published as SIGPLAN Notices, </booktitle> <volume> 21, </volume> <month> 11 </month> <year> (1986) </year> <month> 214-223. </month>
Reference-contexts: 1 Introduction Recently, several researchers have proposed object models based on prototypes and delegation instead of classes and static inheritance <ref> [2, 9, 11, 14, 15, 18] </ref>. These proposals have concentrated on explaining how prototype-based languages allow more exible arrangements of objects.
Reference: 12. <author> Schaffert, C., Cooper, T., and Wilpolt, C. </author> <title> Trellis Object-Based Environment: Language Reference Manual, </title> <type> Version 1.1. </type> <institution> DEC-TR-372, Digital Equipment Corp., Hudson, </institution> <address> MA (1985). </address>
Reference-contexts: This convenience is afforded by SELFs uniform use of messages to access both state and behavior, and could be adopted by other classless and class-based languages to achieve similar exibility. Trellis/Owl <ref> [12, 13] </ref>, a class-based language, also accesses instance variables using messages and is able to change the representation of a subclass by overriding the instance variables inherited from its superclasses with methods defined in the subclass.
Reference: 13. <author> Schaffert, C., Cooper, T., Bullis, B., Kilian, M., and Wilpolt, C. </author> <title> An Introduction to Trellis/Owl. </title> <booktitle> In OOPSLA 86 Conference Proceedings. Published as SIGPLAN Notices, </booktitle> <volume> 21, </volume> <month> 11 </month> <year> (1986) </year> <month> 9-16. </month>
Reference-contexts: This convenience is afforded by SELFs uniform use of messages to access both state and behavior, and could be adopted by other classless and class-based languages to achieve similar exibility. Trellis/Owl <ref> [12, 13] </ref>, a class-based language, also accesses instance variables using messages and is able to change the representation of a subclass by overriding the instance variables inherited from its superclasses with methods defined in the subclass.
Reference: 14. <author> Stein, L. A. </author> <title> Delegation Is Inheritance. </title> <booktitle> In OOPSLA 87 Conference Proceedings. Published as SIGPLAN Notices, </booktitle> <volume> 22, </volume> <month> 12 </month> <year> (1987) </year> <month> 138-146. </month>
Reference-contexts: 1 Introduction Recently, several researchers have proposed object models based on prototypes and delegation instead of classes and static inheritance <ref> [2, 9, 11, 14, 15, 18] </ref>. These proposals have concentrated on explaining how prototype-based languages allow more exible arrangements of objects.
Reference: 15. <author> Stein, L. A., Lieberman, H., and Ungar, D. </author> <title> A Shared View of Sharing: The Treaty of Orlando. </title> <editor> In Kim, W., and Lochovosky, F., editors, </editor> <title> Object-Oriented Concepts, Applications, and Databases, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA (1988). </address>
Reference-contexts: 1 Introduction Recently, several researchers have proposed object models based on prototypes and delegation instead of classes and static inheritance <ref> [2, 9, 11, 14, 15, 18] </ref>. These proposals have concentrated on explaining how prototype-based languages allow more exible arrangements of objects.
Reference: 16. <author> Stroustrup, B. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA (1986). </address>
Reference-contexts: Different class-based languages that support multiple inheritance answer this difficult question differently; some languages, like C++ <ref> [16, 17] </ref>, provide the programmer the option of doing either, at some cost in extra language complexity. Classless languages dont face this dilemma. Since the prototypical instance of the data type is defined explicitly, the programmer has complete control over each types representation.
Reference: 17. <author> Stroustrup, B. </author> <title> The Evolution of C++: </title> <booktitle> 1985 to 1987. In USENIX C++ Workshop Proceedings (1987) 1-21. </booktitle>
Reference-contexts: Different class-based languages that support multiple inheritance answer this difficult question differently; some languages, like C++ <ref> [16, 17] </ref>, provide the programmer the option of doing either, at some cost in extra language complexity. Classless languages dont face this dilemma. Since the prototypical instance of the data type is defined explicitly, the programmer has complete control over each types representation.
Reference: 18. <author> Ungar, D., and Smith, R. B. </author> <title> SELF: The Power of Simplicity. </title> <booktitle> In OOPSLA 87 Conference Proceedings. Published as SIGPLAN Notices, </booktitle> <volume> 22, </volume> <month> 12 </month> <year> (1987) </year> <month> 227-241. </month> <note> Also to be published in Lisp and Symbolic Computation, 4, 3 (1991). </note>
Reference-contexts: 1 Introduction Recently, several researchers have proposed object models based on prototypes and delegation instead of classes and static inheritance <ref> [2, 9, 11, 14, 15, 18] </ref>. These proposals have concentrated on explaining how prototype-based languages allow more exible arrangements of objects. <p> The ideas presented here are based on the lessons we learned as we found ways to organize code in SELF, a dynamically-typed prototype-based language <ref> [3, 4, 10, 18] </ref>.
References-found: 18

