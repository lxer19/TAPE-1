URL: http://www.cs.wustl.edu/~schmidt/CACM-arch.ps.gz
Refering-URL: http://www.cs.wustl.edu/~nanbor/cgi-bin/ace-cvs.cgi/ACE_wrappers/TAO/docs/configurations.html?r1=1.8&r2=1.9
Root-URL: 
Email: schmidt@cs.wustl.edu  
Title: Evaluating Architectures for Multi-threaded CORBA Object Request Brokers  
Author: Douglas C. Schmidt 
Address: St. Louis, MO 63130, USA  
Affiliation: Department of Computer Science, Washington University  
Abstract: This paper will appear in a Communications of the ACM Special Issue on CORBA edited by Krishnan Seetharaman. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Vinoski, </author> <title> CORBA: Integrating Diverse Applications Within Distributed Heterogeneous Environments, </title> <journal> IEEE Communications Magazine, </journal> <volume> vol. 14, </volume> <month> February </month> <year> 1997. </year>
Reference-contexts: Introduction CORBA Object Request Brokers (ORBs) deliver client requests to servants and return responses to clients <ref> [1] </ref>. To accomplish this, ORBs manage transport connections, perform transport endpoint demultiplexing, and provide the multi-threading architecture used by applications. The architecture used to multi-thread an ORB has a substantial impact on its performance and predictability [2]. <p> This way, clients are not starved by waiting for their requests to be serviced. Likewise, system resources are conserved since creating a new thread is typically much less expensive than creating an entirely new process [3]. Sidebar: Overview of the CORBA ORB Reference Model CORBA Object Request Brokers (ORBs) <ref> [1] </ref> allow clients to invoke operations on distributed objects without concern for: Object location: CORBA objects can be co-located with the client or distributed on a remote server, without affecting their implementation or use.
Reference: [2] <author> D. C. Schmidt, S. Mungee, S. Flores-Gaitan, and A. Gokhale, </author> <title> Alleviating Priority Inversion and Non-determinism in Real-time CORBA ORB Core Architectures, </title> <booktitle> in Proceedings of the Fourth IEEE Real-Time Technology and Applications Symposium, </booktitle> <address> (San Francisco, CA), </address> <publisher> IEEE, </publisher> <month> December </month> <year> 1997. </year>
Reference-contexts: To accomplish this, ORBs manage transport connections, perform transport endpoint demultiplexing, and provide the multi-threading architecture used by applications. The architecture used to multi-thread an ORB has a substantial impact on its performance and predictability <ref> [2] </ref>. A key challenge for ORB developers and application programmers, therefore, is to devise threading architectures that can handle multiple client requests efficiently. Multi-threading allows operations to execute simultaneously without impeding the progress of other operations. Likewise, multi-threading can minimize latency and ensure predictability in real-time systems [2]. <p> performance and predictability <ref> [2] </ref>. A key challenge for ORB developers and application programmers, therefore, is to devise threading architectures that can handle multiple client requests efficiently. Multi-threading allows operations to execute simultaneously without impeding the progress of other operations. Likewise, multi-threading can minimize latency and ensure predictability in real-time systems [2]. This paper describes and evaluates common CORBA multi-threading architectures used by ORB implementations, including CORBAplus, HP ORB Plus, miniCOOL, MT-Orbix, TAO, and VisiBroker. Sidebar: Overview of Multi-threading A thread is a single sequence of execution steps performed in the context of a process [3]. <p> Its primary disadvantage is that it does not support load balancing effectively. Moreover, for clients that make only a single request to each server, thread-per-connection is equivalent to the thread-per-request architecture. VisiBroker from Inprise, the TAO ORB <ref> [2] </ref>, and SunSoft IIOP implement the thread-per-connection architecture. The Thread-per-Servant Architecture The thread-per-servant architecture 2 associates a thread for each servant, e.g., a video-on-demand session, registered in the ORB's Object Adapter. <p> Client requests can be executed concurrently until the number of simultaneous requests exceeds the number of threads in the pool. At this point, additional requests must be queued until a thread becomes available. Thread pool is a common architecture for structuring ORB multi-threading, particularly for real-time ORBs <ref> [2] </ref>. Below, we describe and evaluate several common thread pool architectures. The Worker Thread Pool Architecture As shown in Figure 6, the components in a worker thread pool include an I/O thread, a request queue, and a pool of worker threads. <p> The disadvantage with a threading framework is that its generality can significantly increase locking overhead. For instance, locks must be acquired to insert requests into the queue of the appropriate thread of a thread pool. The overhead from locking can greatly reduce throughput and increase latency <ref> [2] </ref>. The Reactor-per-Thread-Priority Architecture The Reactor-per-thread-priority architecture is based on the Reactor pattern [10], which integrates transport endpoint de-multiplexing and the dispatching of the corresponding event handlers. This threading architecture associates a group of Reactors with a group of threads running at different priorities.
Reference: [3] <author> J. Eykholt, S. Kleiman, S. Barton, R. Faulkner, A. Shivalingiah, M. Smith, D. Stein, J. Voll, M. Weeks, and D. Williams, </author> <title> Beyond Multiprocessing... Multithreading the SunOS Kernel, </title> <booktitle> in Proceedings of the Summer USENIX Conference, </booktitle> <address> (San Antonio, Texas), </address> <month> June </month> <year> 1992. </year>
Reference-contexts: This paper describes and evaluates common CORBA multi-threading architectures used by ORB implementations, including CORBAplus, HP ORB Plus, miniCOOL, MT-Orbix, TAO, and VisiBroker. Sidebar: Overview of Multi-threading A thread is a single sequence of execution steps performed in the context of a process <ref> [3] </ref>. In addition to its own instruction pointer, a thread contains resources like a run-time stack of method activation records, a set of registers, and thread-specific storage. <p> This way, clients are not starved by waiting for their requests to be serviced. Likewise, system resources are conserved since creating a new thread is typically much less expensive than creating an entirely new process <ref> [3] </ref>. Sidebar: Overview of the CORBA ORB Reference Model CORBA Object Request Brokers (ORBs) [1] allow clients to invoke operations on distributed objects without concern for: Object location: CORBA objects can be co-located with the client or distributed on a remote server, without affecting their implementation or use.
Reference: [4] <author> Object Management Group, </author> <title> The Common Object Request Broker: Architecture and Specification, </title> <editor> 2.2 ed., </editor> <month> Feb. </month> <year> 1998. </year>
Reference-contexts: ORB Core: When a client invokes an operation on a servant, the ORB Core is responsible for delivering the request to the servant and returning a response, if any, to the client. For servants executing remotely, a CORBA-compliant <ref> [4] </ref> ORB Core communicates via the Internet Inter-ORB Protocol (IIOP), which is a version of the General Inter-ORB Protocol (GIOP) that runs atop the TCP transport protocol. An ORB Core is typically implemented as a run-time library linked into client and server applications. <p> Likewise, servers need not know if clients use the DII or SII to invoke requests. Object Adapter: An Object Adapter associates a servant with an ORB, demultiplexes incoming requests to the servant, and dispatches the appropriate operation upcall on that servant. Recent CORBA portability enhancements <ref> [4] </ref> define the Portable Object Adapter (POA), which supports multiple nested POAs per ORB. Object Adapters make it possible for an ORB to support various types of servants that possess similar requirements.
Reference: [5] <author> E. Eide, K. Frei, B. Ford, J. Lepreau, and G. Lindstrom, Flick: </author> <title> A Flexible, Optimizing IDL Compiler, </title> <booktitle> in Proceedings of ACM SIGPLAN '97 Conference on Programming Language Design and Implementation (PLDI), </booktitle> <address> (Las Vegas, NV), </address> <publisher> ACM, </publisher> <month> June </month> <year> 1997. </year>
Reference-contexts: In addition to providing language transparency, IDL compilers eliminate common sources of network programming errors and provide opportunities for automated compiler optimizations <ref> [5] </ref>. Dynamic Invocation Interface (DII): The DII allows clients to generate requests at run-time. This flexibility is useful when an application has no compile-time knowledge of the interface it is accessing.
Reference: [6] <author> D. Schmidt and S. Vinoski, </author> <title> Comparing Alternative Programming Techniques for Multi-threaded CORBA Servers: </title> <journal> Thread-per-Request, C++ Report, </journal> <volume> vol. 8, </volume> <month> February </month> <year> 1996. </year>
Reference-contexts: There are a variety of strategies for structuring the multi-threading architecture in an ORB. Below, we describe a number of alternative ORB Core multi-threading architectures, focusing on server-side multi-threading. The Thread-per-Request Architecture The thread-per-request architecture <ref> [6] </ref> handles each request from a client in a separate thread of control. As shown in Figure 3, the components in the thread-per-request architecture include an I/O thread and one or more dynamically spawned threads.
Reference: [7] <author> D. Schmidt and S. Vinoski, </author> <title> Comparing Alternative Programming Techniques for Multi-threaded CORBA Servers: </title> <journal> Thread-per-Object, C++ Report, </journal> <volume> vol. 8, </volume> <month> July </month> <year> 1996. </year>
Reference-contexts: MT-Orbix can be configured to support thread-per-servant. Thread Pool Architectures A thread pool [8] is another variation of the thread-per-request architecture that amortizes thread creation costs by pre-spawning a pool of threads. A thread pool architecture 2 This architecture is also known as thread-per-object <ref> [7] </ref>. 4 is useful for ORBs that want to bound the number of OS re-sources they consume. Client requests can be executed concurrently until the number of simultaneous requests exceeds the number of threads in the pool. At this point, additional requests must be queued until a thread becomes available.
Reference: [8] <author> D. Schmidt and S. Vinoski, </author> <title> Comparing Alternative Programming Techniques for Multi-threaded CORBA Servers: Thread Pool, </title> <journal> C++ Report, </journal> <volume> vol. 8, </volume> <month> April </month> <year> 1996. </year>
Reference-contexts: The primary disadvantage with thread-per-servant is that it does not support load balancing effectively. Therefore, if one servant receives considerably more requests than others it can become a performance bottleneck. MT-Orbix can be configured to support thread-per-servant. Thread Pool Architectures A thread pool <ref> [8] </ref> is another variation of the thread-per-request architecture that amortizes thread creation costs by pre-spawning a pool of threads. A thread pool architecture 2 This architecture is also known as thread-per-object [7]. 4 is useful for ORBs that want to bound the number of OS re-sources they consume.
Reference: [9] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: One way of structuring this framework is shown in Figure 8. This design 5 is based on the MT-Orbix thread filter framework, which is a variant of the Chain of Responsibility pattern <ref> [9] </ref>. In MT-Orbix, an application can install a thread filter at the top of a chain of filters. Filters are application-programmable hooks that can perform a number of tasks. Common tasks include intercepting, modifying, or examining each request sent to and from the ORB.
Reference: [10] <author> D. C. Schmidt, </author> <title> Reactor: An Object Behavioral Pattern for Concurrent Event Demultiplexing and Event Handler Dispatching, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien and D. C. Schmidt, </editor> <booktitle> eds.), </booktitle> <pages> pp. 529545, </pages> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: For instance, locks must be acquired to insert requests into the queue of the appropriate thread of a thread pool. The overhead from locking can greatly reduce throughput and increase latency [2]. The Reactor-per-Thread-Priority Architecture The Reactor-per-thread-priority architecture is based on the Reactor pattern <ref> [10] </ref>, which integrates transport endpoint de-multiplexing and the dispatching of the corresponding event handlers. This threading architecture associates a group of Reactors with a group of threads running at different priorities.
Reference: [11] <author> T. H. Harrison, D. L. Levine, and D. C. Schmidt, </author> <title> The Design and Performance of a Real-time CORBA Event Service, </title> <booktitle> in Proceedings of OOPSLA '97, </booktitle> <address> (Atlanta, GA), </address> <publisher> ACM, </publisher> <month> October </month> <year> 1997. </year>
Reference-contexts: As shown in Figure 9, the components in the Reactor per-thread-priority architecture include multiple pre-allocated Reactors, each of which is associated with its own real-time thread of control for each priority level in the ORB. For instance, avionics mission computing systems <ref> [11] </ref> commonly execute their tasks in fixed priority threads corresponding to the rates, e.g., 20 Hz, 10 Hz, 5 Hz, and 1 Hz, at which operations are called by clients.
Reference: [12] <author> D. C. Schmidt, </author> <title> Acceptor and Connector: Design Patterns for Initializing Communication Services, in Pattern Languages of Program Design (R. </title> <editor> Martin, F. Buschmann, and D. Riehle, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1997. </year>
Reference-contexts: The connection handler reads (2) the request and dispatches (3) it to a servant that executes the upcall at its thread priority. Each Reactor in an ORB server thread is also associated with an Acceptor <ref> [12] </ref>. The Acceptor is a factory that listens on a particular port number for clients to connect to that thread and creates a connection handler to process the GIOP requests. In the example in Figure 9, there is a listener port for each priority level.
Reference: [13] <author> C. Liu and J. Layland, </author> <title> Scheduling Algorithms for Multiprogramming in a Hard-Real-Time Environment, </title> <journal> JACM, </journal> <volume> vol. 20, </volume> <pages> pp. 4661, </pages> <month> January </month> <year> 1973. </year>
Reference-contexts: In addition, this multi-threading architecture supports scheduling and analysis techniques that associate priority with rate, such as Rate Monotonic Scheduling (RMS) and Rate Monotonic Analysis (RMA) <ref> [13, 14] </ref>. The disadvantage with the Reactor-per-thread-priority architecture is that it serializes all client requests for each Reactor within a single thread of control, which can reduce parallelism. To alleviate this problem, a variant of this architecture can associate a pool of threads with each priority level.
Reference: [14] <author> M. H. Klein, T. Ralya, B. Pollak, R. Obenza, and M. G. Harbour, </author> <title> A Practitioner's Handbook for Real-Time Analysis: Guide to Rate Monotonic Analysis for Real-Time Systems. </title> <publisher> Norwell, </publisher> <address> Massachusetts: </address> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year> <month> 7 </month>
Reference-contexts: In addition, this multi-threading architecture supports scheduling and analysis techniques that associate priority with rate, such as Rate Monotonic Scheduling (RMS) and Rate Monotonic Analysis (RMA) <ref> [13, 14] </ref>. The disadvantage with the Reactor-per-thread-priority architecture is that it serializes all client requests for each Reactor within a single thread of control, which can reduce parallelism. To alleviate this problem, a variant of this architecture can associate a pool of threads with each priority level.
References-found: 14

