URL: ftp://ic.eecs.berkeley.edu/pub/Thesis/shiple.ps.Z
Refering-URL: http://www-cad.eecs.berkeley.edu:80/~shiple/
Root-URL: http://www.cs.berkeley.edu
Title: Formal Analysis of Synchronous Circuits  
Author: by Thomas Robert Shiple 
Degree: 1987 A dissertation submitted in partial satisfaction of the requirements for the degree of Doctor of Philosophy in Engineering-Electrical Engineering and Computer Sciences in the GRADUATE DIVISION of the UNIVERSITY of CALIFORNIA at BERKELEY Committee in charge: Professor Alberto Sangiovanni-Vincentelli, Chair Professor Robert Brayton Professor Leo Harrington  
Date: 1996  
Address: 1987  
Affiliation: S.B. (Massachusetts Institute of Technology)  S.M. (Massachusetts Institute of Technology)  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Sharad Malik. </author> <title> Analysis of cyclic combinational circuits. </title> <journal> IEEE Trans. Computer-Aided Design, </journal> <volume> 13(7) </volume> <pages> 950-956, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: Note that an acyclic network is combinationally output-stable regardless of the placement of delays, because the outputs are functionally determined by the inputs. Example 2.21 [Placement of delays] Consider the circuit in Figure 2.19 (Figure 6a from Malik <ref> [1] </ref>). Let N 1 be the network with just one state variable, y 1 . The excitation function for y 1 is S 1 = x + (y 1 y 1 ) = x. <p> Clearly, z is not combinationally output-stable if and only if f is satisfiable. f 2.4.2 Malik's algorithm for deciding combinational output-stability Independently of the work of Brzozowski and Seger, Malik devised a BDD-based algorithm for determining whether or not a network is combinationally output-stable (Malik uses the term "combinational" instead) <ref> [1] </ref>. It turns out that Malik's algorithm is closely related to the test given in statement 3 of Theorem 2.24.
Reference: [2] <author> Leon Stok. </author> <title> False loops through resource sharing. </title> <booktitle> In Proc. Int'l Conf. on Computer-Aided Design, </booktitle> <pages> pages 345-348, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: Circuit classification: These works classify circuits based on their well-behavedness. 4. FSM extraction: These works provide algorithms to extract finite state machines from transistor-level netlists. Their classification of well-behaved circuits is implicit in the result of their algorithms. 2.2.1 Motivation Stok <ref> [2] </ref> explains how false combinational cycles arise naturally when datapath resources (e.g., adders, shifters) are allocated during high-level synthesis.
Reference: [3] <author> Janusz A. Brzozowski and Carl-Johan H. Seger. </author> <title> Asynchronous Circuits. </title> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: In particular, we define three formal classes of well-behaved circuits, that tradeoff time to decide the class, with the permissiveness of the class. The definition of these classes is grounded in the up-bounded inertial delay model, and the GMW analysis of synchronous circuits of Brzozowski and Seger <ref> [3] </ref>. For each class, we prove the complexity of deciding the class, and give an algorithm that provably decides the class exactly. <p> Thus, before any class of well-behaved circuits can be defined, we must state precisely what the underlying delay model is, and what the temporal interaction is between the circuit and its environment. For delays, we use the up-bounded inertial delay model of Brzozowski and Seger <ref> [3] </ref>. For the interaction with the environment, we assume that the circuit is clocked with a sufficient period so that any output that will eventually stabilize has time enough to do so. Also, the environment provides inputs, and samples outputs, at the clock ticks. <p> Nonetheless, we know examples exist (see Figure 2.3) where extra functional units must be added to eliminate the combinational cycles. Given this, our philosophy is to provide rigorous analysis so that circuits with cycles can be handled directly. 2.2.2 Circuit analysis Brzozowski and Seger <ref> [3] </ref> study asynchronous circuits under various delay models. In particular, for the up-bounded inertial delay model, they present two methods to analyze the behavior of a circuit. <p> The notation, definitions, and results introduced in this section are largely those of Brzozowski and Seger <ref> [3] </ref>. 24 2.3.1 Circuits and networks A circuit is an arbitrary interconnection of logic gates and flip-flops. For the time being, we neglect flip-flops; instead, we treat their I/Os as circuit I/Os. <p> as being defined over all input-delay, wire, and gate vertices: V : B jIj fi B jWj+jGj ! B . 25 X 1 y 1 z 2 z 5 z 7 y 4 X 1 x 1 z 3 y 2 z 4 y 3 z 6 z 5 from <ref> [3] </ref>.) * gate vertex y i : Y i : B jWj ! B (maps a wire-vertex state to B ; this is just the Boolean function of the gate corresponding to the gate vertex); * wire vertex z i : Z i : B jIj+jGj ! B (provides the value
Reference: [4] <author> Kavita Ravi and Fabio Somenzi. </author> <title> High-density reachability analysis. </title> <booktitle> In Proc. Int'l Conf. on Computer-Aided Design, </booktitle> <pages> pages 154-158, </pages> <month> November </month> <year> 1995. </year>
Reference-contexts: The closer g is to f , and the smaller the BDD for g, the better is the approximation. This problem was independently formulated by Ravi and Somenzi <ref> [4] </ref>. We develop some theory related to the problem, and present a heuristic solution. Each of the main chapters of this dissertation can be read independently of the others after first reviewing some common terminology in Section 1.1. <p> In a similar manner, bddOverApprox adds minterms to a function by replacing BDD nodes by the constant ONE. Ravi and Somenzi <ref> [4] </ref> independently and concurrently formulated the same BDD approximation problem, although they apply it in a different situation. The main contribution of this work is a BDD-based algorithm to solve the state reachability problem, via a series of under- and over-approximations to the state transition graph. <p> They use the complement of R + as an under-approximation of the unreachable states to perform logic minimization. Ravi and Somenzi <ref> [4] </ref> propose a technique to under-approximate R. Their al 159 gorithm proceeds with the usual symbolic BFS, but when the set of states A to explore becomes too large (in terms of BDD size), they continue the search from only a subset of A. <p> the minimum cost solution is f itself, and when ff = 0, the minimum cost solution is the zero function. 4.5.2 The subsetting problem of Ravi and Somenzi Ravi and Somenzi independently and concurrently formulated a problem, termed the subsetting problem, which is nearly identical to our BDD under-approximation problem <ref> [4] </ref>. They employ subsetting to compute an under-approximation of the set of reachable states of an FSM, as explained in Section 4.3. Here, we explain the subsetting problem, and the heuristics they propose for solving this problem.
Reference: [5] <author> Randal E. Bryant. </author> <title> Graph-based algorithms for Boolean function manipulation. </title> <journal> IEEE Trans. on Computers, </journal> <volume> C-35(8):677-691, </volume> <month> August </month> <year> 1986. </year>
Reference-contexts: A binary decision diagram (BDD) is a data structure used to store and manipulate such functions <ref> [5] </ref>. A BDD is a rooted, directed, acyclic graph. There are two types of vertices. Terminal vertices have no outgoing edges and are labeled by the constants ZERO or ONE. Non-terminal vertices are labeled by a variable x i , and have a lo child and a hi child.
Reference: [6] <author> Olivier Coudert, Christian Berthet, and Jean Christophe Madre. </author> <title> Verification of sequential machines using Boolean functional vectors. </title> <booktitle> In Proceedings of the IFIP International Workshop, Applied Formal Methods for Correct VLSI Design, </booktitle> <month> November </month> <year> 1989. </year>
Reference-contexts: This freedom can be used to find a new function g such that f c g f + c. The operators restrict and constrain can be used for this purpose <ref> [6, 7, 8] </ref>. 10 Chapter 2 Logical Analysis of Combinational Cycles In Synchronous Circuits 2.1 Introduction We analyze the logical behavior of synchronous circuits described at the gate and flip-flop level. A combinational cycle in such a circuit is a structural cycle containing only logic gates. <p> In addition, we can arbitrarily choose the behavior of T i on any state x not in C, since such states are disregarded when the eventual product with C is formed. The operators constrain and restrict implement the simplification of BDDs using don't care sets <ref> [6, 7, 8] </ref>. 157 Cabodi et al. [47] introduce the existsCofactor, which is similar to the constrain operator, but allows existential quantification to distribute over conjunction. <p> The procedure for approximating the true and false edges to F follows analogously. 5 Alternatively, we could define T 0 i = restrict (T i ; fromI), using the restrict operator of <ref> [6] </ref> . Then 9u Q i is no longer exactly E (x; y), but can still be used to form approximations. 188 U 0 G fromI V S fi S edges false 189 4.7 Summary and future work We have presented a technique for deciding state reachability for large FSMs.
Reference: [7] <author> Herve J. Touati, Hamid Savoj, Bill Lin, Robert K. Brayton, and Alberto Sangiovanni-Vincentelli. </author> <title> Implicit state enumeration of finite state machines using BDDs. </title> <booktitle> In Proc. Int'l Conf. on Computer-Aided Design, </booktitle> <pages> pages 130-133, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: This freedom can be used to find a new function g such that f c g f + c. The operators restrict and constrain can be used for this purpose <ref> [6, 7, 8] </ref>. 10 Chapter 2 Logical Analysis of Combinational Cycles In Synchronous Circuits 2.1 Introduction We analyze the logical behavior of synchronous circuits described at the gate and flip-flop level. A combinational cycle in such a circuit is a structural cycle containing only logic gates. <p> Namely, the equation 9x (f (x; y) g (y)) can be rewritten as 9x (f (x; y)) g (y): Several researchers have used this fact to quantify some variables before the entire product is formed, in an attempt to avoid the intermediate blowup in the overall computation <ref> [43, 44, 45, 46, 7] </ref>. Another technique for simplifying image computation is to use certain sets of states as don't cares to simplify the BDDs of the set A of states and the individual transition relations T i . <p> In addition, we can arbitrarily choose the behavior of T i on any state x not in C, since such states are disregarded when the eventual product with C is formed. The operators constrain and restrict implement the simplification of BDDs using don't care sets <ref> [6, 7, 8] </ref>. 157 Cabodi et al. [47] introduce the existsCofactor, which is similar to the constrain operator, but allows existential quantification to distribute over conjunction.
Reference: [8] <author> Thomas R. Shiple, Ramin Hojati, Alberto L. Sangiovanni-Vincentelli, and Robert K. Brayton. </author> <title> Heuristic minimization of BDDs using don't cares. </title> <booktitle> In Proc. 31st Design Automat. Conf., </booktitle> <pages> pages 225-231, </pages> <address> San Diego, CA, </address> <month> June </month> <year> 1994. </year> <month> 198 </month>
Reference-contexts: This freedom can be used to find a new function g such that f c g f + c. The operators restrict and constrain can be used for this purpose <ref> [6, 7, 8] </ref>. 10 Chapter 2 Logical Analysis of Combinational Cycles In Synchronous Circuits 2.1 Introduction We analyze the logical behavior of synchronous circuits described at the gate and flip-flop level. A combinational cycle in such a circuit is a structural cycle containing only logic gates. <p> In addition, we can arbitrarily choose the behavior of T i on any state x not in C, since such states are disregarded when the eventual product with C is formed. The operators constrain and restrict implement the simplification of BDDs using don't care sets <ref> [6, 7, 8] </ref>. 157 Cabodi et al. [47] introduce the existsCofactor, which is similar to the constrain operator, but allows existential quantification to distribute over conjunction.
Reference: [9] <author> Yosinori Watanabe and Robert K. Brayton. </author> <title> The maximum set of permissible behaviors for FSM networks. </title> <booktitle> In Proc. Int'l Conf. on Computer-Aided Design, </booktitle> <pages> pages 316-320, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: Because c and c are mutually exclusive, the cycle is false (i.e., never closed). 4. The composition of Mealy machines. When a single FSM is synthesized within the context of a set of interacting FSMs, the resulting composition may create a combi national cycle <ref> [9] </ref>. 5. The specification of reactive programs in synchronous programming languages. A language like Esterel allows the specification of "zero-delay cycles," and it is the task of the compiler to determine if such cycles are false. In some cases (1 and 2), combinational cycles are created intentionally to hold state.
Reference: [10] <author> Thomas R. Shiple, Vigyan Singhal, Robert K. Brayton, and Alberto L. Sangiovanni-Vincentelli. </author> <title> Analysis of combinational cycles in sequential circuits. </title> <booktitle> In Proc. Int'l Symposium on Circuits and Systems, </booktitle> <pages> pages 592-595, </pages> <booktitle> vol. IV, </booktitle> <month> May </month> <year> 1996. </year>
Reference-contexts: Nonetheless, this cycle is false because the multiplexors m 1 and m 2 are controlled in such a way that the loop is never closed. 1 A summary of the material in Section 2.5 is presented in <ref> [10] </ref>, and the material in Section 2.6 is presented in [11]. 18 b e a g ++ Thus, even though the natural tendency of high-level synthesis tools is to create (false) combinational cycles in order to share resources, Stok notes that such cycles are undesirable because downstream tools (e.g., logic synthesis,
Reference: [11] <author> Thomas R. Shiple, Gerard Berry, and Herve Touati. </author> <title> Constructive analysis of cyclic circuits. </title> <booktitle> In European Design and Test Conference, </booktitle> <pages> pages 328-333, </pages> <month> March </month> <year> 1996. </year>
Reference-contexts: Nonetheless, this cycle is false because the multiplexors m 1 and m 2 are controlled in such a way that the loop is never closed. 1 A summary of the material in Section 2.5 is presented in [10], and the material in Section 2.6 is presented in <ref> [11] </ref>. 18 b e a g ++ Thus, even though the natural tendency of high-level synthesis tools is to create (false) combinational cycles in order to share resources, Stok notes that such cycles are undesirable because downstream tools (e.g., logic synthesis, timing analysis) cannot handle cyclic circuits.
Reference: [12] <author> Jerry R. Burch, David Dill, Elizabeth Wolf, and Giovanni De Micheli. </author> <title> Modeling hierarchical combinational circuits. </title> <booktitle> In Proc. Int'l Conf. on Computer-Aided Design, </booktitle> <pages> pages 612-617, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: This work does not address the classification of circuits according to well-behaved 19 ness. However, it is pivotal to our research because it provides the theoretical foundation upon which we define and analyze well-behaved circuits. Section 2.3 is devoted to reviewing Brzozowski and Seger's work. Burch et al. <ref> [12] </ref> model logic gates by ternary-valued relations, where the third value, ?, represents an oscillating or intermediate voltage. By using ?, oscillating behaviors caused by combinational cycles are preserved when gates are composed (by taking the intersection of their corresponding ternary-valued relations).
Reference: [13] <author> Oded Maler and Amir Pnueli. </author> <title> Timing analysis of asynchronous circuits using timed automata. </title> <editor> In Paolo E. Camurati and Hans Eveking, editors, </editor> <booktitle> Proceedings of the Conference on Correct Hardware Design and Verification Methods, volume 987 of Lecture Notes in Computer Science, </booktitle> <pages> pages 189-205, </pages> <address> Frankfurt/Main, Germany, </address> <month> October </month> <year> 1995. </year> <note> Springer-Verlag. </note>
Reference-contexts: This is in contrast to the use of Boolean relations to model gates, where oscillating behaviors "disappear" when gates are composed. Burch uses the ternary model to solve various substitution and rectification problems for gate-level circuits. However, they do not address the problem of well-behaved circuits. Maler and Pnueli <ref> [13] </ref> provide an elegant method to translate asynchronous circuits, described at the gate-level, into timed automata.
Reference: [14] <author> Sharad Malik. </author> <title> Analysis of cyclic combinational circuits. </title> <booktitle> In Proc. Int'l Conf. on Computer-Aided Design, </booktitle> <pages> pages 618-625, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: However, for the bi-bounded inertial delay model, this complication may be necessary, and hence this approach may be useful. 2.2.3 Circuit classification Malik <ref> [14] </ref> provided the original inspiration for our research. He noted that combinational cycles do arise in practice, but that no method for rigorously analyzing such circuits had ever 20 been proposed.
Reference: [15] <author> Nicholas Halbwachs and Florence Maraninchi. </author> <title> On the symbolic analysis of combinational loops in circuits and synchronous programs. </title> <booktitle> In Euromicro'95, </booktitle> <month> September </month> <year> 1995. </year> <title> Como, </title> <address> Italy. </address>
Reference-contexts: Also, we are able to formally prove that Malik's algorithm does in fact decide this class correctly. With this goal completed, we then extend the spirit of Malik's work to define well-behavedness over sequences of inputs, rather than just over single input vectors. Halbwachs and Maraninchi <ref> [15] </ref> define a class of well-behaved circuits called consistent circuits. Basically, they view a circuit as a system of Boolean equations (one equation for each gate), and consider the solutions of this system.
Reference: [16] <author> Randal E. Bryant. </author> <title> Extraction of gate level models from transistor circuits by four-valued symbolic analysis. </title> <booktitle> In Proc. Int'l Conf. on Computer-Aided Design, </booktitle> <pages> pages 350-353, </pages> <month> November </month> <year> 1991. </year>
Reference-contexts: First, they do not address the underlying delay model. They simply accept as input to their own tools, the output of a circuit extraction tool, like TRANALYZE <ref> [16] </ref> 21 or ANAMOS [17], without formal regard to how the tool does the extraction. Second, they do not formally classify those circuits that can be represented by an FSM (i.e., are well-behaved), and those that cannot.
Reference: [17] <author> Randal E. Bryant. </author> <title> Boolean analysis of MOS circuits. </title> <journal> IEEE Trans. Computer-Aided Design, </journal> <volume> 6(4) </volume> <pages> 634-649, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: First, they do not address the underlying delay model. They simply accept as input to their own tools, the output of a circuit extraction tool, like TRANALYZE [16] 21 or ANAMOS <ref> [17] </ref>, without formal regard to how the tool does the extraction. Second, they do not formally classify those circuits that can be represented by an FSM (i.e., are well-behaved), and those that cannot.
Reference: [18] <author> Kanwar Jit Singh and P. A. Subrahmanyam. </author> <title> Extracting RTL models from transistor netlists. </title> <booktitle> In Proc. Int'l Conf. on Computer-Aided Design, </booktitle> <pages> pages 11-15, </pages> <month> November </month> <year> 1995. </year> <month> 199 </month>
Reference-contexts: Despite this lack of formality, we describe their algorithms, and discuss their results on some specific circuits. Also, these tools have some interesting capabilities that provide directions for extending our own research. Singh and Subrahmanyam <ref> [18] </ref> propose a method to extract FSMs, at the Boolean function level, from transistor netlists. They employ TRANALYZE as a preprocessor, which generates a network of zero-delay logic blocks (defined over the four values 0; 1; X; Z) and unit-delay elements, from a transistor netlist.
Reference: [19] <author> Manish Pandey, Alok Jain, Randal E. Bryant, Derek Beatty, Gary York, and Samir Jain. </author> <title> Extraction of finite state machines from transistor netlists by symbolic simulation. </title> <booktitle> In Proc. Int'l Conf. on Computer Design, </booktitle> <pages> pages 596-601, </pages> <month> October </month> <year> 1995. </year>
Reference-contexts: Thus, different next configurations arising from critical races cannot be modeled. Taken together, these two points demonstrate that this technique is incompatible with an inertial delay model. Pandey et al. <ref> [19] </ref> give a procedure for extracting a cycle-based FSM from a transistor netlist. The first step is to execute TRANALYZE. The second step is to perform symbolic, 3-valued simulation, over one complete clock cycle.
Reference: [20] <author> Timothy Kam and P. A. Subrahmanyam. </author> <title> Comparing layouts with HDL models: A formal verification technique. </title> <journal> IEEE Trans. Computer-Aided Design, </journal> <volume> 14(4) </volume> <pages> 503-509, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: On the other hand, this procedure may be too permissive for the same reason as in Singh's work, because TRANALYZE performs Boolean simplification. Kam and Subrahmanyam <ref> [20] </ref> proposed an algorithm to extract FSMs from transistor netlists. The first step in their algorithm is to invoke ANAMOS, a tool that extracts the ternary valued "excitation function" of each potential storage node in the netlist.
Reference: [21] <author> M. J. C. Gordon. </author> <title> The Denotational Description of Programming Languages. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: The vector of ternary excitation functions is denoted by S. This corresponds to the interpretation of the network in Scott's ordered Boolean domain B ? = f?; 0; 1g, familiar in other communities <ref> [21, 22] </ref>. 2.3.3.2 Algorithm A Ternary simulation is applied to a ternary network N, starting from a binary valued initial state b with the input held constant at the binary value a. As presented by Brzozowski and Seger, it is implemented by applying two algorithms, A and B, in sequence. <p> Algorithm B is computing the greatest fixed point of the excitation functions, over the domain f0; 1; g m . As such, there are other ways of computing this fixed point <ref> [21] </ref>, but we are interested not in the method, but only in the result, which we use to characterize combinationally output-stable networks in Section 2.4.
Reference: [22] <author> G. D. Plotkin. </author> <title> LCF as a programming language. </title> <journal> Theoretical Computer Science, </journal> <volume> 5(3) </volume> <pages> 223-256, </pages> <year> 1977. </year>
Reference-contexts: The vector of ternary excitation functions is denoted by S. This corresponds to the interpretation of the network in Scott's ordered Boolean domain B ? = f?; 0; 1g, familiar in other communities <ref> [21, 22] </ref>. 2.3.3.2 Algorithm A Ternary simulation is applied to a ternary network N, starting from a binary valued initial state b with the input held constant at the binary value a. As presented by Brzozowski and Seger, it is implemented by applying two algorithms, A and B, in sequence.
Reference: [23] <author> Gerard Berry. </author> <title> The constructive semantics of pure Esterel. </title> <note> To Appear, </note> <year> 1996. </year>
Reference-contexts: In fact, Berry gives a linear time algorithm for ternary simulation on concrete inputs <ref> [23] </ref>. Ultimately, we are interested in simulating a network for all inputs, and hence in Section 2.4 we turn to symbolic methods to gain efficiency. The result of Algorithm A is exactly equal to the lub of the reachable states found by GMW analysis starting in the total state ab. <p> Finally, a circuit can be synthesized from this FSM, as shown in Figure 2.8. 2.6 Constructivity In this section we introduce a third notion of well-behavedness, called constructiv-ity. This name, coined by Berry, is derived from the relationship between constructive logic and this notion of well-behavedness <ref> [23] </ref>. We will see that constructivity is strictly more con 80 0011C0000C 0010 0000B 0110 10/0 10/0 10/0 10/0 01/1 00/0 01/1 01/1 10/0 01/1 10/0 01/1 00/0 81 servative than sequential output-stability, but strictly more permissive than combinational output-stability. <p> The constructive mode is natural in this domain because the state vertices represent the automatic variables (which are initialized on each invocation | they do not remember their previous value) and the flip-flops represent static variables (whose assignment should be unique) This application is thoroughly explored in <ref> [23] </ref>, where Berry defines the constructive semantics of pure Esterel. He shows that an Esterel program is constructive (in the sense of these semantics) if and only if the network derived from the program is constructive (in the sense defined here).
Reference: [24] <author> William H. Kautz. </author> <title> The necessity of closed circuit loops in minimal combinational circuits. </title> <journal> IEEE Trans. Comput., </journal> <volume> 19(2) </volume> <pages> 162-164, </pages> <month> February </month> <year> 1970. </year>
Reference-contexts: and hence N 2 is not combinationally output-stable. y 2 y 1 00 11 00 11 R 0 R 1 As a side note, the work of Kautz is often cited as proving the existence of logic functions whose minimal circuit implementation using 2-input NOR gates must have combinational cycles <ref> [24] </ref>. Interestingly, the example circuit he gives actually fails the test for combinational output-stability, under the UIN delay model.
Reference: [25] <author> Fran~cois Bourdoncle. </author> <title> Efficient chaotic iteration strategies with widenings. </title> <booktitle> In Proceedings of the International Conference on Formal Methods in Programming and their Applications, volume 735 of Lecture Notes in Computer Science, </booktitle> <pages> pages 128-141. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: This would require 3 passes to reach convergence. However, if we break the circuit at the output of 2 and use the order 3, 1, 4, 2, we reach convergence in a single pass. 1 4 3 1 1 We apply an evaluation ordering scheme by Bourdoncle <ref> [25] </ref> to heuristically minimize the number of gate evaluations. Bourdoncle's algorithm takes as input a directed graph and produces a weak topological ordering (WTO). A WTO can be thought of as a decomposition of a graph into recursive, strongly connected components (SCCs). Consider the graph in Figure 2.24.
Reference: [26] <author> Adnan Aziz and Robert K. Brayton. </author> <title> Verifying interacting finite state machines. </title> <type> Technical Report UCB/ERL M93/52, </type> <institution> Electronics Research Laboratory, U.C. Berkeley, </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: Theorem 2.44 Deciding if a network is sequentially output-stable is PSPACE-hard. Proof The reduction is from single state reachability <ref> [26] </ref>. Instance: Given an acyclic network N with n inputs, m gates, l flip-flops, an external initial state x 0 2 B l and a state x 00 2 B l . <p> As it turns out, we cannot hope to do better than this in the worst case, because the problem of model checking a system of interacting FSMs is PSPACE-complete <ref> [26] </ref>. Our goal is to develop an algorithm that alleviates the explosion problem by identifying equivalent states in each component machine. <p> In summary, an efficient solution to the state reachability problem would provide 153 efficient solutions to a host of other CAD problems. When an FSM is described as a set of interacting FSMs, the state reachability problem is PSPACE-complete <ref> [26] </ref>. Even so, algorithms based on symbolic breadth-first traversal using BDDs can handle FSMs with several hundred flip-flops.
Reference: [27] <author> Robin Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice Hall, </publisher> <address> New York, </address> <year> 1989. </year>
Reference-contexts: In this subsection, we define the bisimulation relation and give the quotient construction. 64 2.5.4.1 Bisimulation Bisimulation is an equivalence relation on states <ref> [27, p. 88] </ref>. This relation is finer than I/O trace equivalence, but coarser than graph isomorphism. We define bisimulation on finite transition graphs as a least fixed point operation. <p> When the top level is reached and just a single machine remains, the usual CTL model checking algorithm is applied to determine the states that satisfy . Our formula dependent equivalence can be best explained by comparing it to bisimulation ("strong bisimulation" of Milner <ref> [27, p. 88] </ref>). 108 Definition 3.4 Given an FSM M = (S; X ; I ; O; O; T ), the bisimulation equivalence rela tion, denoted by ~, is the coarsest equivalence relation satisfying the following: For all x; y 2 S, x ~ y implies * O (x) = O <p> However, it is not immediately obvious that this definition is sound, i.e., that there exists a unique such relation. This section establishes that the definition is indeed sound. Proving this fact is not straightforward. Our development parallels that of Milner's development <ref> [27] </ref> showing that bisimulation is also "the coarsest equivalence relation" satisfying a certain property. We start by defining a formula-dependent bisimulation (FDB) in Definition 3.16, which looks like E , but provides only a one-way implication.
Reference: [28] <author> R. Paige and R.E. Tarjan. </author> <title> Three partition-refinement algorithms. </title> <journal> SIAM Journal of Computing, </journal> <volume> 16(6) </volume> <pages> 973-989, </pages> <year> 1987. </year>
Reference-contexts: For a network N , the bisimulation relation can be computed in time O (jT N j log jQ N j) | linear in the number of edges and logarithmic in the number of states of the corresponding transition graph | using the Paige-Tarjan algorithm for stable partition refinement <ref> [28] </ref>. Of course, this bound is exponential in the size of N (as would be expected since the problem of testing for sequential output-stability is PSPACE-hard in the size of N ). 2.5.4.2 Quotient Mealy machine Mealy FSMs are defined in Section 1.1.2.
Reference: [29] <author> R. J. van Glabbeek. </author> <title> The linear time branching time spectrum. </title> <editor> In J. C. M. Baeten and J. W. Klop, editors, </editor> <title> CONCUR '90, Theories of Concurrency: Unification and Extension, </title> <booktitle> volume 458 of Lecture Notes in Computer Science, </booktitle> <pages> pages 278-297. </pages> <publisher> Springer-Verlag, </publisher> <month> August </month> <year> 1990. </year> <month> 200 </month>
Reference-contexts: Namely, p ' L q if L (p) = L (q). It is well known <ref> [29] </ref> that 1. for deterministic structures, bisimulation and language equivalence coincide, and 2. for nondeterministic structures, bisimulation refines language equivalence (i.e., p ' B q implies p ' L q, but the converse is not necessarily true).
Reference: [30] <author> Ellen M. Sentovich, Kanwar Jit Singh, Cho Moon, Hamid Savoj, Robert K. Brayton, and Alberto Sangiovanni-Vincentelli. </author> <title> Sequential circuit design using synthesis and optimization. </title> <booktitle> In Proc. Int'l Conf. on Computer Design, </booktitle> <month> October </month> <year> 1992. </year>
Reference-contexts: This can be realized by a circuit where the output is driven by a logical 1. Given a deterministic Mealy FSM M (described for example, by a table of transitions), a synthesis tool (e.g., <ref> [30] </ref>) can be used to produce a multi-level implementation without combinational cycles. The number of flip-flops in this implementation is not correlated with the number in the original circuit (even excepting the fact that the state encoding method, for example, one-hot versus minimal, influences the number of flip-flops).
Reference: [31] <author> Ramin Hojati, Robert K. Brayton, and Robert P. Kurshan. </author> <title> BDD-based debugging of designs using language containment and fair CTL. In Costas Courcoubetis, editor, </title> <booktitle> Proceedings of the Conference on Computer-Aided Verification, volume 697 of Lecture Notes in Computer Science, </booktitle> <pages> pages 41-58. </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1993. </year>
Reference-contexts: We simply work backwards starting from the unstable state to find a sequence of inputs back to an initial state. The process of generating an error trace is the same as that used in formal verification tools <ref> [31] </ref>. 2.6.6 Constructivity in the presence of an environment To test constructivity for a network N with respect to an environment M fi , the reduced transition graph G N must be derived from the product of M fi and G N .
Reference: [32] <author> Vigyan Singhal, Carl Pixley, Adnan Aziz, and Robert K. Brayton. </author> <title> Exploiting power-up delay for sequential optimization. </title> <booktitle> In European Design Automation Conference, </booktitle> <address> Brighton, Great Britain, </address> <month> September </month> <year> 1995. </year>
Reference-contexts: The third direction is to define new classes of output-stable circuits, with different properties. For example, following the spirit of Singhal's work <ref> [32] </ref>, one could ignore unstable behavior for the first k clock cycles, to allow a circuit enough time to be reset.
Reference: [33] <author> Edmund M. Clarke, E. Allen Emerson, and Aravinda Prasad Sistla. </author> <title> Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: A well known verification technique is computation tree logic (CTL) model checking. In this approach, a design is modeled as a finite state machine (FSM), properties are stated using CTL formulas, and a "model checker" is used to prove that the FSM satisfies the given CTL formulas <ref> [33] </ref>. The complexity of model checking a formula is linear in the number of states of the FSM. Oftentimes, large designs are constructed by linking together a set of FSMs. <p> The semantics of CTL is usually defined on finite Kripke structures, which are directed graphs where each node is labeled by a set of atomic propositions <ref> [33] </ref>. To extend these semantics to FSMs, we just ignore the labels on the transitions of the FSMs, and we view the outputs as atomic propositions. Let M = hS; X ; I ; O; O; T i be an FSM.
Reference: [34] <author> Michael C. Browne, Edmund M. Clarke, and Orna Grumberg. </author> <title> Characterizing Kripke structures in temporal logic. </title> <type> Technical Report CS 87-104, </type> <institution> Department of Computer Science, Carnegie Mellon University, </institution> <year> 1987. </year>
Reference-contexts: The symbol T means "true", the union of all input assignments. to simplify the components before taking their product, thus leading to a smaller product machine. It is well known that bisimulation equivalence is the coarsest (or weakest) equivalence that preserves the truth of all CTL formulas <ref> [34] </ref>. However, in general we are interested in model checking a system with respect to just a few formulas, and hence preserving all CTL formulas is stronger than needed.
Reference: [35] <author> Adnan Aziz, Thomas R. Shiple, Vigyan Singhal, and Alberto L. Sangiovanni-Vincentelli. </author> <title> Formula-dependent equivalence for compositional CTL model checking. </title> <editor> In David L. Dill, editor, </editor> <booktitle> Proceedings of the Conference on Computer-Aided Verification, volume 818 of Lecture Notes in Computer Science, </booktitle> <pages> pages 324-337, </pages> <address> Stanford, CA, June 1994. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Dams et al. have also devised an approach using ACTL [39]. Like our method, they compute an equivalence with respect to a single formula. Although they are limited to 1 This chapter is largely taken from <ref> [35] </ref>. 105 formulas of ACTL, it may turn out that coarser equivalences are possible by restricting to a subset of CTL. They do not address how their equivalence can be used in compositional model checking, where a formula may refer to the atomic propositions of several interacting machines.
Reference: [36] <author> A. Bouajjani, J-C. Fernandez, N. Halbwachs, P. Raymond, and C. Ratel. </author> <title> Minimal state graph generation. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 18(3) </volume> <pages> 247-271, </pages> <year> 1992. </year>
Reference-contexts: As mentioned in the introduction, bisimulation preserves the truth of all CTL formulas, and hence can be used to identify equivalent states to derive smaller component machines. This technique has been used by <ref> [36] </ref>. Clarke et al. presented the interface rule, which can be applied when a CTL formula refers to the atomic propositions of just one machine, the "main" machine [37]. In this case, the outputs of the other machines, which cannot be sensed by the main machine, can be "hidden".
Reference: [37] <author> Edmund M. Clarke, David E. Long, and Kenneth L. McMillan. </author> <title> Compositional model checking. </title> <booktitle> In 4th Annual Symposium on Logic in Computer Science, Asilomar, </booktitle> <address> CA, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: This technique has been used by [36]. Clarke et al. presented the interface rule, which can be applied when a CTL formula refers to the atomic propositions of just one machine, the "main" machine <ref> [37] </ref>. In this case, the outputs of the other machines, which cannot be sensed by the main machine, can be "hidden". After hiding such outputs, some states in the other machines may become equivalent, and hence the number of states can be reduced.
Reference: [38] <author> Orna Grumberg and David E. </author> <title> Long. Model checking and modular verification. </title> <editor> In J. C. M. Baeten and J. F. Groote, editors, </editor> <booktitle> CONCUR '91, International Conference 201 on Concurrency Theory, volume 527 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <month> August </month> <year> 1991. </year>
Reference-contexts: In general, any output not referred to by the formula, and not observable by other machines, can be hidden. Grumberg et al. defined a subset of CTL, known as ACTL, which permits only universal path quantification, and not existential path quantification <ref> [38] </ref>. They go on to develop an approach to compositional model checking for ACTL. If an ACTL formula is true of one component in a system, then it is true of the entire system. Thus, in some cases the full product machine can be avoided.
Reference: [39] <author> Dennis Dams, Orna Grumberg, and Rob Gerth. </author> <title> Generation of reduced models for checking fragments of CTL. In Costas Courcoubetis, editor, </title> <booktitle> Proceedings of the Conference on Computer-Aided Verification, volume 697 of Lecture Notes in Computer Science, </booktitle> <pages> pages 479-490. </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1993. </year>
Reference-contexts: If the formula is false, then the product machine must always be formed. An asset of this approach is that it handles fairness constraints on the system. Dams et al. have also devised an approach using ACTL <ref> [39] </ref>. Like our method, they compute an equivalence with respect to a single formula. Although they are limited to 1 This chapter is largely taken from [35]. 105 formulas of ACTL, it may turn out that coarser equivalences are possible by restricting to a subset of CTL.
Reference: [40] <author> Massimiliano Chiodo, Thomas R. Shiple, Alberto L. Sangiovanni-Vincentelli, and Robert K. Brayton. </author> <title> Automatic compositional minimization in CTL model checking. </title> <booktitle> In Proc. Int'l Conf. on Computer-Aided Design, </booktitle> <pages> pages 172-178, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: This is especially true when ascertaining if the environment for a system has been correctly modeled so that it can produce the stimuli of interest. Hence, we are interested in techniques that can handle full CTL. The work of Chiodo et al. <ref> [40] </ref> has similar aims as ours, and the current work can be seen as an outgrowth of that work. Both approaches are exact, fully automatic, and formula dependent. <p> Note that whereas Chiodo et al. <ref> [40] </ref> always recursively decompose a formula into its immediate subformulas, we can decompose a formula into arbitrary subformulas, since our equivalence works on nested formulas.
Reference: [41] <author> E. Allen Emerson. </author> <title> Temporal and modal logic. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <pages> pages 995-1072. </pages> <publisher> Elsevier Science Publishers B.V., </publisher> <year> 1990. </year>
Reference-contexts: Proof The reduction is from CTL satisfiability, which is known to be EXPTIME-complete <ref> [41] </ref>. To check if a formula is satisfiable, compute FAIL for the component M shown in Claim: x 2 FAIL if and only if is not satisfiable.
Reference: [42] <author> Olivier Coudert, Christian Berthet, and Jean Christophe Madre. </author> <title> Verification of synchronous sequential machines based on symbolic execution. </title> <editor> In J. Sifakis, editor, </editor> <booktitle> Proceedings of the Workshop on Automatic Verification Methods for Finite State Systems, volume 407 of Lecture Notes in Computer Science, </booktitle> <pages> pages 365-373. </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1989. </year>
Reference-contexts: Given these bounds, a heuristic like restrict <ref> [42] </ref> is used to find a small BDD between T and T max . Theorem 3.30 of Section 3.6.3.2 shows that any transition relation between T and T max can be used without altering the result returned by the model checker. <p> A breakthrough occurred in 1989 when Coudert, Berthet and Madre proposed using BDDs to perform symbolic breadth-first traversal of state graphs <ref> [42] </ref>. With this approach, the number of states in the graph is no longer the principal limitation (as in depth-first traversal); instead the "complexity" of the Boolean functions defining the underlying circuit govern the efficiency.
Reference: [43] <author> Jerry R. Burch, Edmund M. Clarke, and David E. </author> <title> Long. Representing circuits more efficiently in symbolic model checking. </title> <booktitle> In Proc. 28th Design Automat. Conf., </booktitle> <pages> pages 403-407, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: Namely, the equation 9x (f (x; y) g (y)) can be rewritten as 9x (f (x; y)) g (y): Several researchers have used this fact to quantify some variables before the entire product is formed, in an attempt to avoid the intermediate blowup in the overall computation <ref> [43, 44, 45, 46, 7] </ref>. Another technique for simplifying image computation is to use certain sets of states as don't cares to simplify the BDDs of the set A of states and the individual transition relations T i .
Reference: [44] <author> Daniel Geist and Ilan Beer. </author> <title> Efficient model checking by automated ordering of transition relation partitions. </title> <editor> In David L. Dill, editor, </editor> <booktitle> Proceedings of the Conference on Computer-Aided Verification, volume 818 of Lecture Notes in Computer Science, </booktitle> <pages> pages 299-310, </pages> <address> Stanford, CA, June 1994. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Namely, the equation 9x (f (x; y) g (y)) can be rewritten as 9x (f (x; y)) g (y): Several researchers have used this fact to quantify some variables before the entire product is formed, in an attempt to avoid the intermediate blowup in the overall computation <ref> [43, 44, 45, 46, 7] </ref>. Another technique for simplifying image computation is to use certain sets of states as don't cares to simplify the BDDs of the set A of states and the individual transition relations T i .
Reference: [45] <author> Ramin Hojati, Sriram C. Krishnan, and Robert K. Brayton. </author> <title> Early quantification and partitioned transition relations. </title> <booktitle> In Proc. Int'l Conf. on Computer Design, </booktitle> <month> October </month> <year> 1996. </year>
Reference-contexts: Namely, the equation 9x (f (x; y) g (y)) can be rewritten as 9x (f (x; y)) g (y): Several researchers have used this fact to quantify some variables before the entire product is formed, in an attempt to avoid the intermediate blowup in the overall computation <ref> [43, 44, 45, 46, 7] </ref>. Another technique for simplifying image computation is to use certain sets of states as don't cares to simplify the BDDs of the set A of states and the individual transition relations T i . <p> First, we find a schedule for the conjunctions and quantifications (for example, using the techniques in <ref> [45] </ref>). In general, this may be in the form of a tree. Then we build C j according to this schedule, but we apply bddOverApprox to intermediate results to avoid large BDDs. In particular, there are two types of intermediate computations. 1.
Reference: [46] <author> Rajeev K. Ranjan, Adnan Aziz, Robert K. Brayton, Bernard Plessier, and Carl Pix-ley. </author> <title> Efficient BDD algorithms for FSM synthesis and verification. </title> <booktitle> In International Workshop on Logic Synthesis, </booktitle> <pages> pages 3-27 - 3-34, </pages> <month> May </month> <year> 1995. </year> <month> 202 </month>
Reference-contexts: Namely, the equation 9x (f (x; y) g (y)) can be rewritten as 9x (f (x; y)) g (y): Several researchers have used this fact to quantify some variables before the entire product is formed, in an attempt to avoid the intermediate blowup in the overall computation <ref> [43, 44, 45, 46, 7] </ref>. Another technique for simplifying image computation is to use certain sets of states as don't cares to simplify the BDDs of the set A of states and the individual transition relations T i .
Reference: [47] <author> Gianpiero Cabodi and Paolo E. Camurati. </author> <title> Exploiting cofactoring for efficient FSM symbolic traversal based on the transition relation. </title> <booktitle> In Proc. Int'l Conf. on Computer Design, </booktitle> <pages> pages 299-303, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: The operators constrain and restrict implement the simplification of BDDs using don't care sets [6, 7, 8]. 157 Cabodi et al. <ref> [47] </ref> introduce the existsCofactor, which is similar to the constrain operator, but allows existential quantification to distribute over conjunction.
Reference: [48] <author> Felice Balarin. </author> <title> Iterative Methods for Formal Verification of Digital Systems. </title> <type> PhD thesis, </type> <institution> University of California, Berkeley, </institution> <year> 1994. </year>
Reference-contexts: All three of the techniques discussed in this subsection are orthogonal to our approach, and in fact can be used in combination with our approach 4.3.2 Exact state reachability Balarin introduced an algorithm to test for language emptiness of automata over infinite strings <ref> [48] </ref>. For ease of presentation, we describe his algorithm for the simpler case of automata over finite strings. An automaton over finite strings has a designated set F of accepting, or final, states.
Reference: [49] <author> Gianpiero Cabodi, Paolo E. Camurati, and Stefano Quer. </author> <title> Efficient state space pruning in symbolic backward traversal. </title> <booktitle> In Proc. Int'l Conf. on Computer Design, </booktitle> <pages> pages 230-235, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: However, whereas Balarin analyzes a single path from I to F in V at a given iteration, we analyze all of the paths from I to F to guide the search for a real path in the under-approximation U . 158 The work of Cabodi et al. <ref> [49] </ref> is similar in spirit to ours. They first compute an over-approximation of the states reachable from I, and then use this information to constrain an exact backward search from F .
Reference: [50] <author> Costas Courcoubetis, Moshe Y. Vardi, Pierre Wolper, and M. Yannakakis. </author> <title> Memory-efficient algorithms for the verification of temporal properties. </title> <booktitle> Formal Methods in System Design, </booktitle> 1(2/3):275-288, October 1992. 
Reference-contexts: If I is reached in the backward search from F , the the state reachability problem is answered in the affirmative. The work of Courcoubetis et al. <ref> [50] </ref> addresses the problem of not being able to build the transition relation for an FSM M . Instead of employing BDDs and performing BFS on the state graph, they use DFS, building up the graph one transition at a time. <p> As mentioned previously, this problem of approximating a set using a small BDD is the same problem we have formulated. As such, we could employ the heuristics proposed by Ravi and Somenzi in our work. As mentioned earlier, Courcoubetis et al. <ref> [50] </ref> perform state graph traversal using depth-first traversal, and not using BDDs. To represent the set of states visited thus far in a traversal, they use a data structure whose size is directly proportional to the size of the set of states.
Reference: [51] <author> Hyunwoo Cho, Gary D. Hachtel, Enrico Macii, Bernard Plessier, and Fabio Somenzi. </author> <title> Algorithms for approximate FSM traversal. </title> <booktitle> In Proc. 30th Design Automat. Conf., </booktitle> <pages> pages 25-30, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: In the cases where R + or R cannot be used to answer the state reachability problem, they could be used as a starting point to focus the search for a path from I to F . Cho et al. <ref> [51] </ref> have devised various techniques for over-approximating R. The first step of these techniques is to partition the flip-flops of the FSM to yield a set of k interacting sub-FSMs. This partitioning is done so that flip-flops with strong interaction tend to be placed in the same sub-FSM.
Reference: [52] <author> Patrick C. McGeer, Kenneth L. McMillan, Alexander Saldanha, Alberto L. Sangiovanni-Vincentelli, and Patrick Scaglia. </author> <title> Fast discrete function evaluation using decision diagrams. </title> <booktitle> In Proc. Int'l Conf. on Computer-Aided Design, </booktitle> <pages> pages 402-407, </pages> <month> November </month> <year> 1995. </year>
Reference-contexts: Then we successively apply graph bipartitioning (using, for example, the Fiduccia-Mattheyses algorithm), minimizing the number of u variables cut. 3 This technique has been used by others in a variety of settings, e.g., <ref> [52, 53, 54] </ref>. 185 The size of each partition is limited by a user provided parameter, giving the maximum of the sum of BDD sizes for each partition. 4 4.6.1.3 Building each cluster At this point, we must construct the graph C j (x; y) for each cluster: C j (x;
Reference: [53] <author> Jawahar Jain, Amit Narayan, Claudionor Coelho, Sunil P. Khatri, Alberto L. Sangiovanni-Vincentelli, Robert K. Brayton, and Masahiro Fujita. </author> <title> Combining Top-down and Bottom-up Approaches for ROBDD Construction. </title> <type> Technical Report UCB/ERL M95/30, </type> <institution> Electronics Research Laboratory, U.C. Berkeley, </institution> <month> April </month> <year> 1995. </year>
Reference-contexts: Then we successively apply graph bipartitioning (using, for example, the Fiduccia-Mattheyses algorithm), minimizing the number of u variables cut. 3 This technique has been used by others in a variety of settings, e.g., <ref> [52, 53, 54] </ref>. 185 The size of each partition is limited by a user provided parameter, giving the maximum of the sum of BDD sizes for each partition. 4 4.6.1.3 Building each cluster At this point, we must construct the graph C j (x; y) for each cluster: C j (x;
Reference: [54] <author> Rajeev K. Ranjan. </author> <title> Private communication, </title> <year> 1996. </year>
Reference-contexts: Then we successively apply graph bipartitioning (using, for example, the Fiduccia-Mattheyses algorithm), minimizing the number of u variables cut. 3 This technique has been used by others in a variety of settings, e.g., <ref> [52, 53, 54] </ref>. 185 The size of each partition is limited by a user provided parameter, giving the maximum of the sum of BDD sizes for each partition. 4 4.6.1.3 Building each cluster At this point, we must construct the graph C j (x; y) for each cluster: C j (x;
Reference: [55] <author> Hyunwoo Cho, Gary D. Hachtel, Enrico Macii, Massimo Poncino, and Fabio Somenzi. </author> <title> A structural approach to state space decomposition for approximate reachability analysis. </title> <booktitle> In Proc. Int'l Conf. on Computer Design, </booktitle> <pages> pages 236-239, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: stopping the computation when the limit is exceeded, and restarting it with a lower value of ff (i.e., a worse approximation, but smaller BDD size); or we could just restart the phase of conjuncting clusters with a lower value of ff. 4 The flip-flop partitioning technique of Cho et al. <ref> [55] </ref> could also be applied to the present problem. 186 4.6.2 Initial under-approximation of G The goal of this subroutine is to find a subset U of the edges of G such that U has low cost, as defined in Definition 4.7.
References-found: 55

