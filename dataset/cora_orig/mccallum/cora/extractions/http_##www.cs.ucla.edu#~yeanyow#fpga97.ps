URL: http://www.cs.ucla.edu/~yeanyow/fpga97.ps
Refering-URL: http://www.cs.ucla.edu/~yeanyow/
Root-URL: http://www.cs.ucla.edu
Title: Partially-Dependent Functional Decomposition with Applications in FPGA Synthesis and Mapping  
Author: Jason Cong and Yean-Yow Hwang 
Address: Los Angeles  
Affiliation: Department of Computer Science University of California,  
Abstract: In this paper, we give a necessary and sufficient condition for the existence of partially-dependent functional decomposition and develop new algorithms to compute such decompositions. We apply our method to the synthesis and mapping for Xilinx XC4000 FPGA's which contain non-uniform sizes of LUT's in its architecture. We develop a new mapping algorithm named PDDMAP which uses CLB's to cover nodes on critical paths for depth minimization and uses LUT's to cover non-critical nodes for area minimization. On average, PDDMAP is able to reduce the depth by 13% with only 1% of increase in area comparing to the results by FlowMap followed by a CLB generation procedure match_4k. We also develop a post-mapping procedure named PDDSYN which resynthesizes mapping solutions to reduce the mapping area. On average, PDDSYN is able to improve PDDMAP mapping solutions by 5% in depth and 7% in CLB count, and achieves 8% smaller depth and 11% fewer CLB count comparing to FlowSyn followed by match_4k. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Ashenhurst, R. L., </author> <title> ``The Decomposition of Switching Functions,'' </title> <booktitle> Proc. Int'l Symp. on Theory of Switching Functions, </booktitle> <year> 1959. </year>
Reference-contexts: When t = 1, it is called a simple disjoint decomposition. Functions y 1 (B) to y t (B) are the encoding functions and function g is the base function of the decomposition. The necessary and sufficient conditions for a disjoint decomposition to exist were given by Ashenhurst <ref> [1] </ref>, Curtis [10], and Roth and Karp [17] in different forms. Recently, efficient decomposition algorithms [3, 14, 21] have been developed based on the functional representation of reduced ordered binary decision diagrams (ROBDD) [2]. A comprehensive survey of the results on functional decomposition was given in [7]. <p> The condition for a disjoint decomposition g (Y (B),X -B) of f (X) to exist is given by the following theorem. Theorem 1 <ref> [1, 10] </ref> There exists a decomposition g (Y (B),X -B) of f (X) under the bound set B if and only if | cs B ( f ) | 2 | Y | where | Y | denotes the number of encoding functions in Y (B).
Reference: [2] <author> Bryant, R. E., </author> <title> ``Graph-based Algorithms for Boolean Function Manipulation,'' </title> <journal> IEEE Trans. on Computers, </journal> <volume> Vol. C-35, </volume> <pages> pp. 677-691, </pages> <month> Aug. </month> <year> 1986. </year>
Reference-contexts: The necessary and sufficient conditions for a disjoint decomposition to exist were given by Ashenhurst [1], Curtis [10], and Roth and Karp [17] in different forms. Recently, efficient decomposition algorithms [3, 14, 21] have been developed based on the functional representation of reduced ordered binary decision diagrams (ROBDD) <ref> [2] </ref>. A comprehensive survey of the results on functional decomposition was given in [7]. In general, the encoding functions may depend on all variables in the bound set. A partially-dependent decomposition produces encoding functions which are independent of some variables in the bound set. <p> The cofactor set of f (X) with respect to B, denoted cs B (f ), is the set of all distinct cofactors of f (X) with respect to the variables in B. Clearly | cs B ( f ) | 2 | B | . We use ROBDD <ref> [2] </ref> to represent functions in this paper. For each node u in a ROBDD, let f u denote the function of the ROBDD rooted at u. Figure 1 shows three partial ROBDD's (top 4 levels).
Reference: [3] <author> Chang, S.-C. and M. Marek-Sadowska, </author> <title> ``Technology Mapping via Transformations of Function Graphs,'' </title> <booktitle> Proc. IEEE Int'l Conf. on Computer Design, </booktitle> <pages> pp. 159-162, </pages> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: The necessary and sufficient conditions for a disjoint decomposition to exist were given by Ashenhurst [1], Curtis [10], and Roth and Karp [17] in different forms. Recently, efficient decomposition algorithms <ref> [3, 14, 21] </ref> have been developed based on the functional representation of reduced ordered binary decision diagrams (ROBDD) [2]. A comprehensive survey of the results on functional decomposition was given in [7]. In general, the encoding functions may depend on all variables in the bound set.
Reference: [4] <author> Cong, J. and Y. Ding, </author> <title> ``Beyond the Combinatorial Limit in Depth Minimization for LUT-Based FPGA Designs,'' </title> <booktitle> Proc. IEEE Int'l Conf. on Computer-Aided Design, </booktitle> <pages> pp. 110-114, </pages> <year> 1993. </year>
Reference-contexts: The ROBDD's of functions are computed first, and multiple output functional decomposition and support minimization techniques are applied to produce LUT networks. However, it might be difficult to compute ROBDD's for large circuits. Alternatively, <ref> [19, 4] </ref> integrate synthesis into technology mapping. For example, the FlowSyn algorithm [4] synthesizes subnetworks to obtain depth below the combinatorial limit of technology mapping. Since synthesis is applied locally, this approach can be used for large circuits. <p> The ROBDD's of functions are computed first, and multiple output functional decomposition and support minimization techniques are applied to produce LUT networks. However, it might be difficult to compute ROBDD's for large circuits. Alternatively, [19, 4] integrate synthesis into technology mapping. For example, the FlowSyn algorithm <ref> [4] </ref> synthesizes subnetworks to obtain depth below the combinatorial limit of technology mapping. Since synthesis is applied locally, this approach can be used for large circuits. We propose a new approach named PDDSYN which resynthesizes any mapping solutions for area minimization. <p> The set of benchmarks are first optimized for area and then decomposed into 2-input simple-gate multi-level networks using standard SIS routines. The same set of benchmarks has been widely used in previous mapping experiments. We shall compare our results with those from FlowMap [5], TechMap-D [19], FlowSyn <ref> [4] </ref> and BoolMap-D [16]. In our first experiment, we collect statistics of implementing wide functions in technology mapping using XC4000 CLB's. For every node in MCNC benchmarks, we compute all 6-input and 7-input cuts of the node. <p> The results are in Table 2. Comparing to FlowMap followed by match_4k, PDDMAP is able to decrease CLB depth by 13% with only 1% increase of CLB's. We tested PDDSYN on CLB networks generated by PDDMAP and compared the resynthesized CLB networks with the results by FlowSyn <ref> [4] </ref> followed by match_4k, and also with the LUT mapping results by TechMap-D [19] and BoolMap-D [16]. Because the two sets of data in [19, 16] are from LUT mapping solutions, only their depths are used for direct comparison.
Reference: [5] <author> Cong, J. and Y. Ding, ``FlowMap: </author> <title> An Optimal Technology Mapping Algorithm for Delay Optimization in Lookup-Table Based FPGA Designs,'' </title> <journal> IEEE Trans. on Computer-Aided Design, </journal> <volume> Vol. </volume> <pages> CAD-13(1) pp. 1-12, </pages> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: The height of a cut, denoted height (X v ,X hh v ), is the maximum height of nodes in the cutset. A min-cut of height p in N v can be computed using the max-flow min-cut algorithm <ref> [5] </ref>. A fanout-free cone (FFC) at v, denoted FFC v , is a cone rooted at v such that for every uv FFC v , output (u) FFC v [6]. The MFFC at v, denoted MFFC v , is the FFC at v which contains a maximal number of nodes. <p> But considering the success rate of mapping wide functions to XC4000 CLB and the computing time, we select K = 7 in our implementation. For K = 7, we try to cover networks by CLB's (not only LUT's) directly. In the FlowMap algorithm <ref> [5] </ref> the label of a node v is defined to be the minimum level of v in any LUT mapping solutions. We call it the LUT label of v, lut_label (v ). <p> The set of benchmarks are first optimized for area and then decomposed into 2-input simple-gate multi-level networks using standard SIS routines. The same set of benchmarks has been widely used in previous mapping experiments. We shall compare our results with those from FlowMap <ref> [5] </ref>, TechMap-D [19], FlowSyn [4] and BoolMap-D [16]. In our first experiment, we collect statistics of implementing wide functions in technology mapping using XC4000 CLB's. For every node in MCNC benchmarks, we compute all 6-input and 7-input cuts of the node.
Reference: [6] <author> Cong, J. and Y. Ding, </author> <title> ``On Area/Depth Trade-off in LUT-Based FPGA Technology Mapping,'' </title> <journal> IEEE Trans. on VLSI Systems, </journal> <volume> Vol. 2, </volume> <month> June </month> <year> 1994. </year>
Reference-contexts: A min-cut of height p in N v can be computed using the max-flow min-cut algorithm [5]. A fanout-free cone (FFC) at v, denoted FFC v , is a cone rooted at v such that for every uv FFC v , output (u) FFC v <ref> [6] </ref>. The MFFC at v, denoted MFFC v , is the FFC at v which contains a maximal number of nodes. An important property of MFFC is that two MFFC's are either disjoint or one contains another [6]. <p> v such that for every uv FFC v , output (u) FFC v <ref> [6] </ref>. The MFFC at v, denoted MFFC v , is the FFC at v which contains a maximal number of nodes. An important property of MFFC is that two MFFC's are either disjoint or one contains another [6]. As a result, any network can be uniquely partitioned into a set of MFFC's. 3.1. XC4000 CLB Functional Capability The Xilinx XC4000-families configurable logic block (XC4000 CLB) contains three LUT's F, G and H as shown in Figure 3 [22].
Reference: [7] <author> Cong, J. and Y. Ding, </author> <title> ``Combinational Logic Synthesis for LUT Based Field Programmable Gate Arrays,'' </title> <journal> ACM Trans. on Design Automation of Electronic Systems, </journal> <volume> Vol. 1, 2, </volume> <pages> pp. 145-204, </pages> <year> 1996. </year>
Reference-contexts: Recently, efficient decomposition algorithms [3, 14, 21] have been developed based on the functional representation of reduced ordered binary decision diagrams (ROBDD) [2]. A comprehensive survey of the results on functional decomposition was given in <ref> [7] </ref>. In general, the encoding functions may depend on all variables in the bound set. A partially-dependent decomposition produces encoding functions which are independent of some variables in the bound set.
Reference: [8] <author> Cong, J. and Y.-Y. Hwang, </author> <title> ``A Theory on Partially-Dependent Functional Decomposition with Application in LUT-based FPGA,'' </title> <institution> in UCLA Computer Science Dept. Tech. Report CSD-950050, </institution> <month> (December </month> <year> 1995). </year>
Reference-contexts: Please refer to <ref> [8] </ref> for a detail proof. The methods for computing single and multiple partially-dependent encoding functions are discussed in Section 2.2. We illustrate the theorem by an example. Consider a function f (X) of which the ROBDD is in Figure 1 (a). <p> The proof is omitted and can be found in <ref> [8] </ref>. Note that we do not treat non-disjoint variables as encoding functions in this corallary. Efficient computation for non-disjoint decompositions are introduced in the next section. 2.2. <p> Details can be found in <ref> [8] </ref>. In the application to FPGA synthesis, we usually have | B | = 5. For m 3 our method is quite efficient. When m = 4 and a large number of partitions which satisfy Theorem 2 are detected, we limit m to 3 in our implementation for partially-dependent decomposition. <p> Or, we can modify the algorithm in functions and select a maximum number of mutually assignable encoding functions from the set to construct a decomposition of as many partially-dependent encoding functions as possible. Details can be found in <ref> [8] </ref>. 3. Applications of Partially-Dependent Functional Decomposition Before we describe our applications, we introduce some notations. Given a network N, let N v denote the subnetwork consisting of node v and all the predecessors of v. <p> from PI's Select (X v ,X hh v ) of minimum CLB_count v (X v ,X hh Map X v to a LUT Map every u n (X v ,X hh v ) recursively using LUT's Collapse N to a network of CLB's and LUT's Match LUT's using match_4k in <ref> [8] </ref> Pack matched LUT's into CLB's and return iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii cost v (X v ,X hh v ) is the cost of mapping v using a XC4000 CLB with n (X v ,X hh v ) as inputs.
Reference: [9] <author> Cong, J., J. Peck, and Y. Ding, ``RASP: </author> <title> A General Logic Synthesis System for SRAM-based FPGAs,'' </title> <booktitle> Proc. ACM 4th Int'l Symp. on FPGA, </booktitle> <month> Feb. </month> <year> 1996. </year>
Reference-contexts: The number K can be set to either 4 or 5. If we set K = 4, every two 4-LUT's in the mapping solution can be implemented by the F and G LUT's in a XC4000 CLB, but the H LUT is left unused. Alternatively, the RASP system <ref> [9] </ref> set K = 5 to generate 5-LUT mapping solutions followed by a routine match_4k to decompose each 5-LUT into either (i) a 4-LUT feeding into a 2-LUT (which we call a 4-2 decomposition). or (ii) two 4-LUT's feeding into a 3-LUT (which we call a 4-4-3 decomposition). <p> v (X v ,X v ) belongs to Category I or II 15 clb_label (v) = max_label 16 else 17 clb_label (v) = max_label + 1 18 else if | n (X v ,X hh 19 clb_label (v) = max_label + 1 iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii CLB's using the match_4k procedure developed in <ref> [9] </ref>. The PDDMAP mapping algorithm is outlined in Figure 5. <p> The LUT's with zero fanout will be removed from N in the traverse. 4. Experimental Results We have implemented PDDMAP and PDDSYN in C language and incorporated our implementation into the SIS [20] and the RASP <ref> [9] </ref> FPGA logic synthesis package. We test our algorithms using MCNC combinational benchmarks on a SPARC 5 workstation with 96MB of memory. The set of benchmarks are first optimized for area and then decomposed into 2-input simple-gate multi-level networks using standard SIS routines. <p> Only 6% of encoding functions can be implemented by XC4000 CLB's. We use PDDMAP to generate mapping solutions for MCNC benchmarks. In order to compare our results with previous results, we use a procedure match_4k proposed in the RASP system <ref> [9] </ref> to transform LUT networks into XC4000 CLB networks.
Reference: [10] <author> Curtis, H. A., </author> <title> ``A Generalized Tree Circuit,'' </title> <journal> Journal of the ACM, </journal> <volume> Vol. </volume> <pages> 8(4) pp. 484-496, </pages> <year> 1961. </year>
Reference-contexts: Functions y 1 (B) to y t (B) are the encoding functions and function g is the base function of the decomposition. The necessary and sufficient conditions for a disjoint decomposition to exist were given by Ashenhurst [1], Curtis <ref> [10] </ref>, and Roth and Karp [17] in different forms. Recently, efficient decomposition algorithms [3, 14, 21] have been developed based on the functional representation of reduced ordered binary decision diagrams (ROBDD) [2]. A comprehensive survey of the results on functional decomposition was given in [7]. <p> In Figure 1 (a), f u 0 denotes both f x h h cs B (f ) = - f u 0 , f u 1 , f u 4 -. It is clear that cs B (f ) represents the set of distinct columns in the decomposition chart <ref> [10] </ref> or the set of compatible classes [21]. <p> The condition for a disjoint decomposition g (Y (B),X -B) of f (X) to exist is given by the following theorem. Theorem 1 <ref> [1, 10] </ref> There exists a decomposition g (Y (B),X -B) of f (X) under the bound set B if and only if | cs B ( f ) | 2 | Y | where | Y | denotes the number of encoding functions in Y (B).
Reference: [11] <author> Garey, M. and D. Johnson, </author> <title> Computer and Intractability: A Guide to the Theory of NP-Completeness, </title> <publisher> Freeman, </publisher> <address> San Francisco (1979). </address>
Reference-contexts: 2 do y 1 (b 1 , . . . ,b m ) = 0 return y 1 (z 1 , . . . ,z m ) iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii order to compute a partition in reasonable time, we use a dynamic programming algorithm similar to that for the number partitioning problem <ref> [11] </ref>. Details can be found in [8]. In the application to FPGA synthesis, we usually have | B | = 5. For m 3 our method is quite efficient.
Reference: [12] <author> Huang, J.-D., J.-Y. Jou, and W.-Z. Shen, </author> <title> ``Compatible Class Encoding in Roth-Karp Decomposition for Two-Output LUT Architecture,'' </title> <booktitle> Proc. IEEE Int'l Conf. on Computer-Aided Design, </booktitle> <pages> pp. 359-363, </pages> <month> Nov. </month> <year> 1995. </year>
Reference-contexts: In general, the encoding functions may depend on all variables in the bound set. A partially-dependent decomposition produces encoding functions which are independent of some variables in the bound set. Methods to minimize the support of encoding functions during decomposition were recently proposed in <ref> [12, 15] </ref> and produce good results. However, we observe some limitations. [12] encodes compatible classes carefully to eliminate variables from the bound set. But because it is a strict encoding, [12] does not guarantee to find a partially-dependent decomposition when there is one. <p> A partially-dependent decomposition produces encoding functions which are independent of some variables in the bound set. Methods to minimize the support of encoding functions during decomposition were recently proposed in [12, 15] and produce good results. However, we observe some limitations. <ref> [12] </ref> encodes compatible classes carefully to eliminate variables from the bound set. But because it is a strict encoding, [12] does not guarantee to find a partially-dependent decomposition when there is one. <p> Methods to minimize the support of encoding functions during decomposition were recently proposed in [12, 15] and produce good results. However, we observe some limitations. <ref> [12] </ref> encodes compatible classes carefully to eliminate variables from the bound set. But because it is a strict encoding, [12] does not guarantee to find a partially-dependent decomposition when there is one. The approach in [15] builds ROBDD's to represent implicitly all assignable encoding functions which are independent of one variable. This approach is capable of searching for partially-dependent encoding functions in a large solution space. <p> However, different encoding functions may partition the compatible classes in the same way. It is unnecessary to compute all encoding functions in order to obtain a decomposition. When there are only few compatible classes, this approach could be inefficient. Besides, neither <ref> [12, 15] </ref> provides a necessary and sufficient condition to characterize the existence of a partially-dependent decomposition. In this paper, we shall present a necessary and sufficient condition for testing the existence of a partially-dependent decomposition. Based on this condition, we develop a partition-based method to compute partially-dependent decomposition.
Reference: [13] <author> Lai, Y.-T., K.-R. R. Pan, and M. Pedram, </author> <title> ``FPGA Synthesis using Function Decomposition,'' </title> <booktitle> Proc. Int'l Conf. on Computer Design: VLSI in Computers, </booktitle> <pages> pp. 30-35, </pages> <month> Oct. </month> <year> 1994. </year>
Reference-contexts: Resynthesis of Mapping Solutions Direct synthesis for LUT-based FPGA produces excellent results in both area and depth for MCNC benchmarks <ref> [13, 21, 16] </ref>. The ROBDD's of functions are computed first, and multiple output functional decomposition and support minimization techniques are applied to produce LUT networks. However, it might be difficult to compute ROBDD's for large circuits. Alternatively, [19, 4] integrate synthesis into technology mapping.
Reference: [14] <author> Lai, Y.-T., M. Pedram, and S. Vrudhula, </author> <title> ``BDD Based Decomposition of Logic Functions with Application to FPGA Synthesis,'' </title> <booktitle> Proc. 30th ACM/IEEE Design Automation Conf., </booktitle> <pages> pp. 642-647, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: The necessary and sufficient conditions for a disjoint decomposition to exist were given by Ashenhurst [1], Curtis [10], and Roth and Karp [17] in different forms. Recently, efficient decomposition algorithms <ref> [3, 14, 21] </ref> have been developed based on the functional representation of reduced ordered binary decision diagrams (ROBDD) [2]. A comprehensive survey of the results on functional decomposition was given in [7]. In general, the encoding functions may depend on all variables in the bound set. <p> A special case of the partially-dependent decomposition is the non-disjoint decomposition where B sup (g) . B sup (g) is the set of non-disjoint variables which appear as inputs to both the base function and the encoding functions. <ref> [14] </ref> gave a necessary and sufficient condition for non-disjoint decomposition and an algorithm to compute it. However, the approach does not relate disjoint and non-disjoint decompositions and is not easy to apply.
Reference: [15] <author> Legl, C., B. Wurth, and K. Eckl, </author> <title> ``An Implicit Algorithm for Support Minimization during Functional Decomposition,'' </title> <booktitle> Proc. European Design and Test Conf., </booktitle> <month> March </month> <year> 1996. </year>
Reference-contexts: In general, the encoding functions may depend on all variables in the bound set. A partially-dependent decomposition produces encoding functions which are independent of some variables in the bound set. Methods to minimize the support of encoding functions during decomposition were recently proposed in <ref> [12, 15] </ref> and produce good results. However, we observe some limitations. [12] encodes compatible classes carefully to eliminate variables from the bound set. But because it is a strict encoding, [12] does not guarantee to find a partially-dependent decomposition when there is one. <p> However, we observe some limitations. [12] encodes compatible classes carefully to eliminate variables from the bound set. But because it is a strict encoding, [12] does not guarantee to find a partially-dependent decomposition when there is one. The approach in <ref> [15] </ref> builds ROBDD's to represent implicitly all assignable encoding functions which are independent of one variable. This approach is capable of searching for partially-dependent encoding functions in a large solution space. However, different encoding functions may partition the compatible classes in the same way. <p> However, different encoding functions may partition the compatible classes in the same way. It is unnecessary to compute all encoding functions in order to obtain a decomposition. When there are only few compatible classes, this approach could be inefficient. Besides, neither <ref> [12, 15] </ref> provides a necessary and sufficient condition to characterize the existence of a partially-dependent decomposition. In this paper, we shall present a necessary and sufficient condition for testing the existence of a partially-dependent decomposition. Based on this condition, we develop a partition-based method to compute partially-dependent decomposition. <p> However, the approach does not relate disjoint and non-disjoint decompositions and is not easy to apply. Later, <ref> [15] </ref> pointed out that selecting encoding functions of single variable leads to a non-disjoint decomposition so that non-disjoint decomposition becomes a special case of disjoint decomposition with support minimization. <p> In this case, y 1 (x i ) is a non-disjoint variable. It is interesting to notice that searching for a non-disjoint variable is the simplest case in our approach, while the method in <ref> [15] </ref> is most efficient in computing encoding functions of | B | - 1 variables. In general, the existence of non-disjoint variables (i.e. non-disjoint decomposition) can be tested efficiently in our approach.
Reference: [16] <author> Legl, C., B. Wurth, and K. Eckl, </author> <title> ``A Boolean Approach to Performance-Directed Technology Mapping for LUT-Based FPGA Designs,'' </title> <booktitle> Proc. ACM/IEEE 33rd Design Automation Conf., </booktitle> <pages> pp. 730-733, </pages> <year> 1996. </year>
Reference-contexts: Resynthesis of Mapping Solutions Direct synthesis for LUT-based FPGA produces excellent results in both area and depth for MCNC benchmarks <ref> [13, 21, 16] </ref>. The ROBDD's of functions are computed first, and multiple output functional decomposition and support minimization techniques are applied to produce LUT networks. However, it might be difficult to compute ROBDD's for large circuits. Alternatively, [19, 4] integrate synthesis into technology mapping. <p> The same set of benchmarks has been widely used in previous mapping experiments. We shall compare our results with those from FlowMap [5], TechMap-D [19], FlowSyn [4] and BoolMap-D <ref> [16] </ref>. In our first experiment, we collect statistics of implementing wide functions in technology mapping using XC4000 CLB's. For every node in MCNC benchmarks, we compute all 6-input and 7-input cuts of the node. <p> We tested PDDSYN on CLB networks generated by PDDMAP and compared the resynthesized CLB networks with the results by FlowSyn [4] followed by match_4k, and also with the LUT mapping results by TechMap-D [19] and BoolMap-D <ref> [16] </ref>. Because the two sets of data in [19, 16] are from LUT mapping solutions, only their depths are used for direct comparison. From Table 3 and Table 2, we see PDDSYN is able to improve PDDMAP mapping solutions by 5% in depth and 7% in CLB count. <p> We tested PDDSYN on CLB networks generated by PDDMAP and compared the resynthesized CLB networks with the results by FlowSyn [4] followed by match_4k, and also with the LUT mapping results by TechMap-D [19] and BoolMap-D [16]. Because the two sets of data in <ref> [19, 16] </ref> are from LUT mapping solutions, only their depths are used for direct comparison. From Table 3 and Table 2, we see PDDSYN is able to improve PDDMAP mapping solutions by 5% in depth and 7% in CLB count.
Reference: [17] <author> Roth, J. P. and R. M. Karp, </author> <title> ``Minimization Over Boolean Graphs,'' </title> <journal> IBM Journal of Research and Development, </journal> <pages> pp. 227-238, </pages> <month> April </month> <year> 1962. </year>
Reference-contexts: Functions y 1 (B) to y t (B) are the encoding functions and function g is the base function of the decomposition. The necessary and sufficient conditions for a disjoint decomposition to exist were given by Ashenhurst [1], Curtis [10], and Roth and Karp <ref> [17] </ref> in different forms. Recently, efficient decomposition algorithms [3, 14, 21] have been developed based on the functional representation of reduced ordered binary decision diagrams (ROBDD) [2]. A comprehensive survey of the results on functional decomposition was given in [7].
Reference: [18] <author> Rudell, R., </author> <title> Private Communication 1996. </title>
Reference-contexts: the best cut (X v ,X hh v ) in N v when mapping node v for area minimization in the LUT mapping phase, PDDMAP computes a set C (v) of all 5-feasible cuts for every node v (from PI's to PO's in topological order) based on the suggestion of <ref> [18] </ref>. For a node v, this set C (v) can be computed by merging cuts from all sets C (u i ) where (u i ,v) N and accepting only 5-feasible cuts in the merged set. Although there are O (n 5 ) 5-feasible cuts in the worst case, [18] pointed <p> of <ref> [18] </ref>. For a node v, this set C (v) can be computed by merging cuts from all sets C (u i ) where (u i ,v) N and accepting only 5-feasible cuts in the merged set. Although there are O (n 5 ) 5-feasible cuts in the worst case, [18] pointed out that average number of cuts per node is usually smaller than 100 for a 2-input network.
Reference: [19] <author> Sawkar, P. and D. Thomas, </author> <title> ``Performance Directed Technology Mapping for Look-Up Table Based FPGAs,'' </title> <booktitle> Proc. 30th ACM/IEEE Design Automation Conf., </booktitle> <pages> pp. 208-212, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: The ROBDD's of functions are computed first, and multiple output functional decomposition and support minimization techniques are applied to produce LUT networks. However, it might be difficult to compute ROBDD's for large circuits. Alternatively, <ref> [19, 4] </ref> integrate synthesis into technology mapping. For example, the FlowSyn algorithm [4] synthesizes subnetworks to obtain depth below the combinatorial limit of technology mapping. Since synthesis is applied locally, this approach can be used for large circuits. <p> The set of benchmarks are first optimized for area and then decomposed into 2-input simple-gate multi-level networks using standard SIS routines. The same set of benchmarks has been widely used in previous mapping experiments. We shall compare our results with those from FlowMap [5], TechMap-D <ref> [19] </ref>, FlowSyn [4] and BoolMap-D [16]. In our first experiment, we collect statistics of implementing wide functions in technology mapping using XC4000 CLB's. For every node in MCNC benchmarks, we compute all 6-input and 7-input cuts of the node. <p> We tested PDDSYN on CLB networks generated by PDDMAP and compared the resynthesized CLB networks with the results by FlowSyn [4] followed by match_4k, and also with the LUT mapping results by TechMap-D <ref> [19] </ref> and BoolMap-D [16]. Because the two sets of data in [19, 16] are from LUT mapping solutions, only their depths are used for direct comparison. <p> We tested PDDSYN on CLB networks generated by PDDMAP and compared the resynthesized CLB networks with the results by FlowSyn [4] followed by match_4k, and also with the LUT mapping results by TechMap-D [19] and BoolMap-D [16]. Because the two sets of data in <ref> [19, 16] </ref> are from LUT mapping solutions, only their depths are used for direct comparison. From Table 3 and Table 2, we see PDDSYN is able to improve PDDMAP mapping solutions by 5% in depth and 7% in CLB count.
Reference: [20] <author> Sentovich, E., K. Singh, L. Lavagno, C. Moon, R. Murgai, A. Saldanha, H. Savoj, P. Stephen, R. Brayton, and A. Sangiovanni-Vincentelli, </author> <title> ``SIS: A System for Sequential Circuit Synthesis,'' </title> <note> U.C.Berkeley Technical Report UCB/ERL M92/41, </note> <month> May, </month> <year> 1992. </year>
Reference-contexts: The LUT's with zero fanout will be removed from N in the traverse. 4. Experimental Results We have implemented PDDMAP and PDDSYN in C language and incorporated our implementation into the SIS <ref> [20] </ref> and the RASP [9] FPGA logic synthesis package. We test our algorithms using MCNC combinational benchmarks on a SPARC 5 workstation with 96MB of memory. The set of benchmarks are first optimized for area and then decomposed into 2-input simple-gate multi-level networks using standard SIS routines.
Reference: [21] <author> Wurth, B., K. Eckl, and K. Antreich, </author> <title> ``Functional Multiple-Output Decomposition: Theory and an Implicit Algorithm,'' </title> <booktitle> Proc. ACM/IEEE Design Automation Conf., </booktitle> <pages> pp. </pages> <address> 54--59, </address> <month> Jun. </month> <year> 1995. </year>
Reference-contexts: The necessary and sufficient conditions for a disjoint decomposition to exist were given by Ashenhurst [1], Curtis [10], and Roth and Karp [17] in different forms. Recently, efficient decomposition algorithms <ref> [3, 14, 21] </ref> have been developed based on the functional representation of reduced ordered binary decision diagrams (ROBDD) [2]. A comprehensive survey of the results on functional decomposition was given in [7]. In general, the encoding functions may depend on all variables in the bound set. <p> It is clear that cs B (f ) represents the set of distinct columns in the decomposition chart [10] or the set of compatible classes <ref> [21] </ref>. Let g (Y (B),X -B) represent the function g (y 1 (B), y 2 (B), . . . , y t (B), x b +1 , . . . , x n ) where Y (B) = - y 1 (B), y 2 (B),..., y t (B)-. <p> An encoding function y i (B) is said assignable to another encoding function y j (B) if they together partition cs B (f ) into four subsets such that each subset contains at most 2 | Y | - 2 cofactors <ref> [21] </ref>. After obtaining y 1 by Min_Support_Y1, we can compute a minimal-support encoding functions y 2 assignable to y 1 in a similar way, and repeat the process for remaining encoding functions. <p> Resynthesis of Mapping Solutions Direct synthesis for LUT-based FPGA produces excellent results in both area and depth for MCNC benchmarks <ref> [13, 21, 16] </ref>. The ROBDD's of functions are computed first, and multiple output functional decomposition and support minimization techniques are applied to produce LUT networks. However, it might be difficult to compute ROBDD's for large circuits. Alternatively, [19, 4] integrate synthesis into technology mapping.
Reference: [22] <author> Xilinx, </author> <title> The Programmable Logic Data Book, </title> <address> Xilinx, San Jose, CA (1994). </address>
Reference-contexts: As a result, any network can be uniquely partitioned into a set of MFFC's. 3.1. XC4000 CLB Functional Capability The Xilinx XC4000-families configurable logic block (XC4000 CLB) contains three LUT's F, G and H as shown in Figure 3 <ref> [22] </ref>. Four independent inputs (F1-F4 and G1-G4) are provided for each of two 4-input LUT's F and G. The LUT H has inputs from F, G and a third input from outside the block (H1).
References-found: 22

