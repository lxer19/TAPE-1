URL: http://www.csc.calpoly.edu/~smeldal/DARPA92/DARPA92.ps
Refering-URL: http://www.csc.calpoly.edu/~smeldal/tidbits.html
Root-URL: http://www.csc.calpoly.edu
Title: Subtyping, assignment and cloning in a concurrent object-oriented language  
Author: John C. Mitchell flyz Dinesh Katiyar David C. Luckham Neel Madhav Sigurd Meldal Sriram Sankar 
Abstract: This paper describes subtyping, assignment, equality and cloning in a concurrent object-oriented language called rapide. Based on experiments and language design considerations, we separate the subtype relation from the derivation (or inheritance) hierarchy. This avoids various anomalies and has the added benefit of reducing the syntactic and design complexity of programs that use intricate subtype relationships. A relatively sophisticated algorithm to decide subtyping is also needed for implementation. Objects may contain multiple threads, and different objects with the same type may have different implementations. This makes it difficult to provide a meaningful, predefined form of "copy" assignment or predefined equality tests. Therefore, the primitive form of assignment in rapide is a form of pointer assignment. Special provision is made for user-defined "cloning," so that an object may produce a meaningful copy of itself. Equality may be user-defined for any type, in some cases overriding an "inherited" predefined equality. 
Abstract-found: 1
Intro-found: 1
Reference: [AC91] <author> R.M Amadio and L. Cardelli. </author> <title> Subtyping recursive types. </title> <booktitle> In Proc. ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 104-118, </pages> <year> 1991. </year>
Reference-contexts: For example, the Point interface contains a reference to itself. Subtype checking becomes a bit more involved in such situations, since the recursion may have to be "unfolded" a few times before the check can be performed. Amadio and Cardelli <ref> [AC91] </ref> present an algorithm for subtyping recursive function types, based on a coding of recursive types as infinite trees. We extend the algorithm to handle recursion in interfaces. The algorithm essentially compares types by finger-pointing through the graph representations of the types.
Reference: [BL90] <author> F. </author> <title> Belz and D.C. Luckham. A new approach to prototyping Ada-based hardware/software systems. </title> <booktitle> In Proc. ACM Tri-Ada'90 Conference, </booktitle> <month> December </month> <year> 1990. </year> <note> To appear. </note>
Reference-contexts: This paper describes the relationship between subtyping and inheritance in rapide and aspects of the type/module language that effect the interaction with the other sublanguages. An outline of an early version of rapide (then called Reality) is given in <ref> [BL90] </ref> and a preliminary report on the type and module system appears in [MMM91]. After eighteen months of design work and programming experiments, we believe that the types/module language will remain relatively stable, providing standard structuring primitives.
Reference: [CCH + 89] <author> P. Canning, W. Cook, W. Hill, J. Mitchell, and W. Olthoff. </author> <title> F-bounded quantification for object-oriented programming. </title> <booktitle> In Functional Prog. and Computer Architecture, </booktitle> <pages> pages 273-280, </pages> <year> 1989. </year>
Reference-contexts: The first is that due to subtyping, we do not have to maintain a special category of "equality types." Instead, types with equality are identified as subtypes of the type with equality operation (see, e.g., the example treatment of ordered types in [MMM91] or the examples in <ref> [CCH + 89] </ref>). Second, since operations are constituents of values, there is a natural place for "ad hoc" operations such as equality that have different semantics for different types. <p> Second, since operations are constituents of values, there is a natural place for "ad hoc" operations such as equality that have different semantics for different types. Thus basic features from object-oriented programming, together with bounded polymorphism (see <ref> [CW85, CCH + 89, MMM91] </ref>) allow us to treat an otherwise problematic area relatively simply. 6 User-defined cloning 6.1 Motivation A certain kind of copying seems essential in practice.
Reference: [CM91] <author> L. Cardelli and J.C. Mitchell. </author> <title> Operations on records. </title> <journal> Math. Structures in Computer Science, </journal> <volume> 1(1) </volume> <pages> 3-48, </pages> <year> 1991. </year> <title> Summary in Math. Foundations of Prog. Lang. Semantics, </title> <publisher> Springer LNCS 442, </publisher> <year> 1990, </year> <pages> pp 22-52. </pages>
Reference-contexts: This rule does not consider type and parameterized type constituents for brevity. 3.4 Issues in subtype checking The subtyping algorithm is similar to those in <ref> [CM91, Ghe90] </ref> with the following additional complications: recursive types: Interfaces may be defined recursively. For example, the Point interface contains a reference to itself.
Reference: [Coo89] <author> W.R. Cook. </author> <title> A proposal for making Eiffel type-safe. </title> <booktitle> In European Conf. on Object-Oriented Programming, </booktitle> <pages> pages 57-72, </pages> <year> 1989. </year>
Reference-contexts: The main reason is that complete substitutivity may be at odds with a clean or understandable definition of the subtype relation. An extreme example is Eiffel [Mey92], where contravariance of function arguments is overlooked in some cases (see <ref> [Coo89] </ref>). In rapide, we have made substitutivity a guiding principle, with our separation between subtyping and derivation allowing us to avoid the Eiffel problem. There are, however, some subtleties surrounding modules with type constituents.
Reference: [CW85] <author> L. Cardelli and P. Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <year> 1985. </year>
Reference-contexts: Second, since operations are constituents of values, there is a natural place for "ad hoc" operations such as equality that have different semantics for different types. Thus basic features from object-oriented programming, together with bounded polymorphism (see <ref> [CW85, CCH + 89, MMM91] </ref>) allow us to treat an otherwise problematic area relatively simply. 6 User-defined cloning 6.1 Motivation A certain kind of copying seems essential in practice.
Reference: [GGM91] <author> C.A. Gunter, E. Gunter, </author> <title> and D.B. MacQueen. An abstract interpretation of ML equality kinds. </title> <booktitle> In Int'l Conf. Theor. Aspects of Computer Software, page ??, 1991. </booktitle>
Reference-contexts: These are the predefined types and the predefined type constructors (assuming equality on the argument types), except for function types. In addition, equality is predefined for reference types. This is superficially similar to the treatment of equality in Standard ML <ref> [GGM91] </ref>, except for two important features of rapide.
Reference: [Ghe90] <author> Giorgio Ghelli. </author> <title> Proof Theoretic Studies about a minimal type system integrating inclusion and parametric polymorphism. </title> <type> PhD thesis, </type> <institution> University of Pisa, </institution> <year> 1990. </year>
Reference-contexts: This rule does not consider type and parameterized type constituents for brevity. 3.4 Issues in subtype checking The subtyping algorithm is similar to those in <ref> [CM91, Ghe90] </ref> with the following additional complications: recursive types: Interfaces may be defined recursively. For example, the Point interface contains a reference to itself. <p> However, we disallow the bounding expression to involve any types with bounds. This restriction is placed because the subtyping problem for the general case is undecidable. The undecidability arises in a rather subtle fashion, as is evident from the plausible algorithmic claims of <ref> [Ghe90] </ref>, later shown incorrect by the undecidability result of [Pie92]. While specifying a bound for a type, it is often useful to be able to mention the type itself.
Reference: [GR83] <author> A. Goldberg and D. Robson. </author> <title> Smalltalk-80: The language and its implementation. </title> <publisher> Addison Wesley, </publisher> <year> 1983. </year> <month> 11 </month>
Reference-contexts: Due to space restrictions, we are limited in our ability to provide comparisons with related programming languages. We would expect to provide more comparative information in a conference version of the paper. Our main influences are Smalltalk <ref> [GR83] </ref>, C ++ [Str86], Eiffel [Mey92], Self [US87] and Standard ML [Mil85, Mac85, HMT87]. For the reader familiar with [MMM91], we briefly summarize changes in the language since Fall, 1990.
Reference: [HMT87] <author> R. Harper, R. Milner, and M. Tofte. </author> <title> The semantics of Standard ML. </title> <type> Technical Report ECS--LFCS-87-36, </type> <institution> Lab. for Foundations of Computer Science, University of Edinburgh, </institution> <month> August </month> <year> 1987. </year>
Reference-contexts: Due to space restrictions, we are limited in our ability to provide comparisons with related programming languages. We would expect to provide more comparative information in a conference version of the paper. Our main influences are Smalltalk [GR83], C ++ [Str86], Eiffel [Mey92], Self [US87] and Standard ML <ref> [Mil85, Mac85, HMT87] </ref>. For the reader familiar with [MMM91], we briefly summarize changes in the language since Fall, 1990. The main change is in the definition of subtyping, which is now determined in a way that is unrelated to the inheritance mechanism.
Reference: [LHM + 86] <author> D. C. Luckham, D. P. Helmbold, S. Meldal, D. L. Bryan, and M. A. Haberler. </author> <title> Task sequencing language for specifying distributed ada systems. </title> <booktitle> In Lecture Notes in Computer Science, </booktitle> <volume> Number 275, </volume> <pages> pages 249-305. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <month> May </month> <year> 1986. </year>
Reference-contexts: A second generation implementation of the type/module and executable languages in currently underway. The primary basis for the specification language is Anna, for which a tool suit already exists <ref> [LvHKBO87, LHM + 86] </ref>. Prototyping is the incremental development and analysis of systems. Our primary goals in the development of rapide are to explore prototyping processes and to produce a language and support tools for prototyping.
Reference: [LvHKBO87] <author> David Luckham, Friedrich W. von Henke, Bernd Krieg-Bruckner, and Olaf Owe. </author> <title> Anna A Language for Annotating Ada Programs. </title> <booktitle> In Lecture Notes in Computer Science, Number 260. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <month> July </month> <year> 1987. </year>
Reference-contexts: A second generation implementation of the type/module and executable languages in currently underway. The primary basis for the specification language is Anna, for which a tool suit already exists <ref> [LvHKBO87, LHM + 86] </ref>. Prototyping is the incremental development and analysis of systems. Our primary goals in the development of rapide are to explore prototyping processes and to produce a language and support tools for prototyping.
Reference: [Mac85] <author> D.B. MacQueen. </author> <title> Modules for Standard ML. </title> <journal> Polymorphism, </journal> <volume> 2(2), </volume> <year> 1985. </year> <pages> 35 pages. </pages> <note> An earlier version appeared in Proc. 1984 ACM Symp. on Lisp and Functional Programming. </note>
Reference-contexts: Due to space restrictions, we are limited in our ability to provide comparisons with related programming languages. We would expect to provide more comparative information in a conference version of the paper. Our main influences are Smalltalk [GR83], C ++ [Str86], Eiffel [Mey92], Self [US87] and Standard ML <ref> [Mil85, Mac85, HMT87] </ref>. For the reader familiar with [MMM91], we briefly summarize changes in the language since Fall, 1990. The main change is in the definition of subtyping, which is now determined in a way that is unrelated to the inheritance mechanism.
Reference: [Mey92] <author> B. Meyer. </author> <title> Eiffel: The Language. </title> <publisher> Prentice-Hall, </publisher> <year> 1992. </year>
Reference-contexts: Due to space restrictions, we are limited in our ability to provide comparisons with related programming languages. We would expect to provide more comparative information in a conference version of the paper. Our main influences are Smalltalk [GR83], C ++ [Str86], Eiffel <ref> [Mey92] </ref>, Self [US87] and Standard ML [Mil85, Mac85, HMT87]. For the reader familiar with [MMM91], we briefly summarize changes in the language since Fall, 1990. The main change is in the definition of subtyping, which is now determined in a way that is unrelated to the inheritance mechanism. <p> This is an ideal, and most languages deviate from it in some way. The main reason is that complete substitutivity may be at odds with a clean or understandable definition of the subtype relation. An extreme example is Eiffel <ref> [Mey92] </ref>, where contravariance of function arguments is overlooked in some cases (see [Coo89]). In rapide, we have made substitutivity a guiding principle, with our separation between subtyping and derivation allowing us to avoid the Eiffel problem. There are, however, some subtleties surrounding modules with type constituents. <p> Given a module with mutable state, we need to be able to create (at run-time) another module in a behaviorally equivalent state, but occupying distinct memory locations so that subsequent updates to one module do not effect the other. As in Eiffel <ref> [Mey92] </ref> and Self [US87], we call this form of copying cloning. To give an example where cloning is useful, consider a module generator returning a new module.
Reference: [Mil85] <author> R. Milner. </author> <title> The Standard ML core language. </title> <journal> Polymorphism, </journal> <volume> 2(2), </volume> <year> 1985. </year> <pages> 28 pages. </pages> <note> An earlier version appeared in Proc. 1984 ACM Symp. on Lisp and Functional Programming. </note>
Reference-contexts: Due to space restrictions, we are limited in our ability to provide comparisons with related programming languages. We would expect to provide more comparative information in a conference version of the paper. Our main influences are Smalltalk [GR83], C ++ [Str86], Eiffel [Mey92], Self [US87] and Standard ML <ref> [Mil85, Mac85, HMT87] </ref>. For the reader familiar with [MMM91], we briefly summarize changes in the language since Fall, 1990. The main change is in the definition of subtyping, which is now determined in a way that is unrelated to the inheritance mechanism. <p> We describe rapide assignment in more detail in the rest of this section. A language mechanisms for copying is described in Section 6. 4.2 Reference types In rapide, as in Standard ML <ref> [Mil85] </ref>, assignment is an operation associated with reference types. A consequence is that a variable of type A has a different type from a constant of type A.
Reference: [MMM91] <author> J.C. Mitchell, S. Meldal, and N. Madhav. </author> <title> An extension of Standard ML modules with sub-typing and inheritance. </title> <booktitle> In Proc. 18th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 270-278, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: An outline of an early version of rapide (then called Reality) is given in [BL90] and a preliminary report on the type and module system appears in <ref> [MMM91] </ref>. After eighteen months of design work and programming experiments, we believe that the types/module language will remain relatively stable, providing standard structuring primitives. Within this framework, the specification and executable sublanguages may change freely, as long as certain general criteria for compatibility between the three languages are maintained. <p> We would expect to provide more comparative information in a conference version of the paper. Our main influences are Smalltalk [GR83], C ++ [Str86], Eiffel [Mey92], Self [US87] and Standard ML [Mil85, Mac85, HMT87]. For the reader familiar with <ref> [MMM91] </ref>, we briefly summarize changes in the language since Fall, 1990. The main change is in the definition of subtyping, which is now determined in a way that is unrelated to the inheritance mechanism. <p> In <ref> [MMM91] </ref>, we explained a mechanism based on textual copy of module constituents. We have replaced this with the more common and predictable method of identifying dynamically resolved calls with the special symbol self. <p> The internal interface describes module constituents that are accessible only to other modules of the same type. The primary motivation for the internal interface is to solve a problem associated with binary operations in typed object-oriented languages. This is discussed in some detail in <ref> [MMM91] </ref>. Both external and internal interfaces have a set of constituent declarations, derivation declarations and specifications. A constituent may be type, a parameterized type (type constructor), or a constant of any type (including function or procedure). <p> This is largely parallel to the interface derivation mechanism, except for the issue of dynamic binding. The preliminary description in <ref> [MMM91] </ref> described derivation via syntactic copying and substitution, but the language has since been revised in favor of explicit use of the keyword self to indicate dynamic interpretation of references to module constituents. The decision to separate interfaces from modules is discussed at some length in [MMM91], and also in papers <p> The preliminary description in <ref> [MMM91] </ref> described derivation via syntactic copying and substitution, but the language has since been revised in favor of explicit use of the keyword self to indicate dynamic interpretation of references to module constituents. The decision to separate interfaces from modules is discussed at some length in [MMM91], and also in papers of other authors, such as [Sny86]. Our experience since [MMM91], and communication with our colleagues, continues to support this decision. <p> The decision to separate interfaces from modules is discussed at some length in <ref> [MMM91] </ref>, and also in papers of other authors, such as [Sny86]. Our experience since [MMM91], and communication with our colleagues, continues to support this decision. A particular situation illustrating the advantage of this separation, as opposed to the more common approach of Smalltalk, C ++ and Eiffel, involves library routines and modules. <p> The first is that due to subtyping, we do not have to maintain a special category of "equality types." Instead, types with equality are identified as subtypes of the type with equality operation (see, e.g., the example treatment of ordered types in <ref> [MMM91] </ref> or the examples in [CCH + 89]). Second, since operations are constituents of values, there is a natural place for "ad hoc" operations such as equality that have different semantics for different types. <p> Second, since operations are constituents of values, there is a natural place for "ad hoc" operations such as equality that have different semantics for different types. Thus basic features from object-oriented programming, together with bounded polymorphism (see <ref> [CW85, CCH + 89, MMM91] </ref>) allow us to treat an otherwise problematic area relatively simply. 6 User-defined cloning 6.1 Motivation A certain kind of copying seems essential in practice.
Reference: [Pie92] <author> B. Pierce. </author> <title> Bounded quantification is undecidable. </title> <booktitle> In Proc. 19th ACM Symp. Principles of Programming Languages, </booktitle> <address> page ??, 1992. </address> <note> To appear. Available as Carnegie Mellon Technical Report CMU-CS-91-161. </note>
Reference-contexts: This restriction is placed because the subtyping problem for the general case is undecidable. The undecidability arises in a rather subtle fashion, as is evident from the plausible algorithmic claims of [Ghe90], later shown incorrect by the undecidability result of <ref> [Pie92] </ref>. While specifying a bound for a type, it is often useful to be able to mention the type itself.
Reference: [Sny86] <author> A. Snyder. </author> <title> Encapsulation and inheritance in object-oriented programming languages. </title> <booktitle> In Proc. ACM Symp. on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 38-46, </pages> <month> October </month> <year> 1986. </year>
Reference-contexts: The decision to separate interfaces from modules is discussed at some length in [MMM91], and also in papers of other authors, such as <ref> [Sny86] </ref>. Our experience since [MMM91], and communication with our colleagues, continues to support this decision. A particular situation illustrating the advantage of this separation, as opposed to the more common approach of Smalltalk, C ++ and Eiffel, involves library routines and modules.
Reference: [Str86] <author> B. Stroustrop. </author> <title> The C ++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: Due to space restrictions, we are limited in our ability to provide comparisons with related programming languages. We would expect to provide more comparative information in a conference version of the paper. Our main influences are Smalltalk [GR83], C ++ <ref> [Str86] </ref>, Eiffel [Mey92], Self [US87] and Standard ML [Mil85, Mac85, HMT87]. For the reader familiar with [MMM91], we briefly summarize changes in the language since Fall, 1990. The main change is in the definition of subtyping, which is now determined in a way that is unrelated to the inheritance mechanism.
Reference: [US87] <author> D. Ungar and R.B. Smith. </author> <title> Self: The power of simplicity. </title> <booktitle> In Proc. ACM Symp. on Object-Oriented Programming: Systems, Languages, and Applications, </booktitle> <pages> pages 227-241, </pages> <year> 1987. </year>
Reference-contexts: Due to space restrictions, we are limited in our ability to provide comparisons with related programming languages. We would expect to provide more comparative information in a conference version of the paper. Our main influences are Smalltalk [GR83], C ++ [Str86], Eiffel [Mey92], Self <ref> [US87] </ref> and Standard ML [Mil85, Mac85, HMT87]. For the reader familiar with [MMM91], we briefly summarize changes in the language since Fall, 1990. The main change is in the definition of subtyping, which is now determined in a way that is unrelated to the inheritance mechanism. <p> Given a module with mutable state, we need to be able to create (at run-time) another module in a behaviorally equivalent state, but occupying distinct memory locations so that subsequent updates to one module do not effect the other. As in Eiffel [Mey92] and Self <ref> [US87] </ref>, we call this form of copying cloning. To give an example where cloning is useful, consider a module generator returning a new module. When useful data is passed as a parameter to the module generator, it is common to initialize the state variables to copies of this data.
References-found: 20

