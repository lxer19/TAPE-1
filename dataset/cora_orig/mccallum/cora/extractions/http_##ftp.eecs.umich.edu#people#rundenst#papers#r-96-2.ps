URL: http://ftp.eecs.umich.edu/people/rundenst/papers/r-96-2.ps
Refering-URL: http://ftp.eecs.umich.edu/people/rundenst/papers/
Root-URL: http://www.eecs.umich.edu
Email: e-mail: viviane@eecs.umich.edu, rundenst@eecs.umich.edu  
Title: Consistent View Removal in Transparent Schema Evolution Systems  
Author: Viviane Crestana-Taube and Elke A. Rundensteiner 
Address: 1301 Beal Avenue, Ann Arbor, MI 48109-2122  
Affiliation: Dept. of Elect. Engineering and Computer Science Software Systems Research Laboratory University of Michigan,  
Abstract: We have developed the Transparent Schema Evolution (TSE) system that, simulating schema evolution using object-oriented views, allows for the interoperability of applications with diverse and even changing requirements. TSE relieves users of the risk of making existing application programs obsolete when run against the modified schema, because the old view schema is maintained while a new view schema is generated to capture the changes desired by the user. However, TSE may be generating a large number of schema versions (object-oriented view schemata) over time, resulting in an excessive build-up of classes and underlying object instances some of which may potentially no longer be in use. In this paper, we propose to solve this problem by developing techniques for effective and consistent schema removal. First, we characterize four potential problems of schema consistency that could be caused by removal of a single virtual class; and then outline our solution approach for each of these problems. Second, we demonstrate that view schema removal is sensitive to the order in which individual classes are processed. Our solution to this problem is the development of a dependency graph model for capturing the class relationships, used as a foundation for selecting among removal sequences. Designed to optimize the performance of the TSE system by effective schema version removal, the proposed techniques will enable more effective interoperability among evolving software applications. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Banerjee, W. Kim, H. J. Kim, and H. F. Korth. </author> <title> Semantics and implementation of schema evolution in object-oriented databases. </title> <booktitle> SIGMOD, </booktitle> <pages> pages 311-322, </pages> <year> 1987. </year>
Reference-contexts: In fact, virtual classes in TSE can independently define ad-ditional attributes and methods. In traditional SE systems, the semantics are to propagate all user-initiated changes to the whole schema. For example, a delete-class (C) command causes the deletion of properties from all of C's subclasses, if inherited from C <ref> [13, 1] </ref>. In SVR, we are instead trying to achieve garbage-collection semantics, namely, we must assure that the rest of the schema stays unaffected. <p> Our work is also related to the issue of schema consistency, e.g., Orion <ref> [1] </ref> or O2 [13, 5]. We both must establish what constitutes a consistent schema, and must assure that transformation operations indeed result in a consistent final schema. However, the objectives as well as the strategies of achieving these goals are rather distinct.
Reference: [2] <author> E. Bertino. </author> <title> Integration of heterogeneous data repositories by using object-oriented views. </title> <booktitle> International Workshop on Interoperability in Multidatabase Systems, </booktitle> <pages> pages 22-29, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: In fact, the resulting schema meets all schema invariants. Based on these concepts, we are implementing a Schema Version Removal (SVR) tool for TSE/GemStone [4]. 2 Related Work Several other approaches towards transparent schema evolution using views have been recently presented in the literature <ref> [2, 3] </ref>. <p> Instead, a class will only be deleted when this class is not used in any view schema (i.e., no user has access to this class). Like other view systems <ref> [2] </ref>, MultiView assumes closed view schemas [11]. The closure criterion ensures that all classes that are being used by the type interface of any class in a view schema are also defined within the view.
Reference: [3] <author> Svein Erik Bratsberg. </author> <title> Unified class evolution by object-oriented views. </title> <booktitle> In Proc. 12th Intl. Conf. on the Entity-Relationship Approach, </booktitle> <pages> pages 423-439, </pages> <year> 1992. </year>
Reference-contexts: In fact, the resulting schema meets all schema invariants. Based on these concepts, we are implementing a Schema Version Removal (SVR) tool for TSE/GemStone [4]. 2 Related Work Several other approaches towards transparent schema evolution using views have been recently presented in the literature <ref> [2, 3] </ref>.
Reference: [4] <author> V. Crestana-Taube and E. A. Rundensteiner. </author> <title> Consistent view removal in transparent schema evolution systems. </title> <type> Technical Report in progress, </type> <institution> University of Michigan, </institution> <year> 1996. </year>
Reference-contexts: In fact, the resulting schema meets all schema invariants. Based on these concepts, we are implementing a Schema Version Removal (SVR) tool for TSE/GemStone <ref> [4] </ref>. 2 Related Work Several other approaches towards transparent schema evolution using views have been recently presented in the literature [2, 3]. <p> Since we are adding an IS-A edge from SB to SP and SB was already a subclass (indirectly) of SP, and the original schema was not acyclic, this edge cannot cause a cycle. SI5 and SI6 are not violated because of the way the redefinition is done <ref> [4] </ref>. 5 Techniques for Multiple Class Removal 5.1 Issues of Multiple Class Removal The approach detailed in the previous section is used to determine whether and how an individual class can be deleted from the global schema. <p> A more elaborated cost model would take into consideration not only the number of classes, but their VC-type, the final schema configuration, and usage patterns, since these are factors that influence the performance of retrieval and of update propagation of instances in the database <ref> [4] </ref>. Such more elaborate schemes are beyond the scope of this workshop paper and will be handled in a future report. 6 Conclusions Contributions of this work are three-fold.
Reference: [5] <author> C. Delcourt and R. Zicari. </author> <title> The design of an integrity consistency checker (ICC) for an object oriented database system. </title> <booktitle> In ECOOP, </booktitle> <pages> pages 97-117, </pages> <year> 1991. </year>
Reference-contexts: Our work is also related to the issue of schema consistency, e.g., Orion [1] or O2 <ref> [13, 5] </ref>. We both must establish what constitutes a consistent schema, and must assure that transformation operations indeed result in a consistent final schema. However, the objectives as well as the strategies of achieving these goals are rather distinct. <p> In <ref> [5] </ref> the approach rec-ommended for solving the undefined reference problem (in particular, behavioral consistency) is to build a method-dependency graph that can be constructed by evaluating the code from each method. This is very expensive and may not be a feasible solution in practice.
Reference: [6] <author> H. A. Kuno and E. A. Rundensteiner. </author> <title> The Multi-View OODB view system: Design and implementation. </title> <note> Accepted by Theory and Practice of Object Systems (TAPOS), Special Issue on Subjectivity in Object-Oriented Systems, </note> <year> 1996. </year>
Reference-contexts: 1 Introduction Motivation. The general goal of this work is to develop powerful interoperability-enabling solutions for the integration of software applications <ref> [11, 6, 7] </ref>. These mechanisms must allow applications to evolve and flexibly change their data requirements, while minimizing or even eliminating the impact of such change on other integrated applications. <p> Legend Class Name &lt;Name&gt; is-a relationship property &lt;attr.&gt; Virtual Class Base Class The TSE system is built on top of the Multiview OO view system <ref> [11, 6] </ref>. Each view schema is composed of a set of view classes and relationships among them. Each view class is a proxy object that corresponds to a real class (base or virtual) in the underlying global schema. Multi-view supports a full range of virtual classes. <p> The view system Multiview <ref> [11, 6] </ref> underlying TSE is such that each view class V in a view schema VS corresponds to a class C (either base or virtual) in the global schema GS, with C denoted by GS-class (V). <p> By guaranteeing the two conditions stated above, we can guarantee that the view schemas will be unaffected (for a description of how view schemata are derived from GS see <ref> [11, 6] </ref>). 4.2 Problems of Class Removal When removing a view schema VS, we would like to remove every class from GS that participates in the view VS.
Reference: [7] <author> H. A. Kuno and E. A. Rundensteiner. </author> <title> Using Object-Oriented Principles to Optimize Update Propagation to Materialized Views. </title> <booktitle> To appear in IEEE International Conf on Data Engineering, </booktitle> <year> 1996. </year>
Reference-contexts: 1 Introduction Motivation. The general goal of this work is to develop powerful interoperability-enabling solutions for the integration of software applications <ref> [11, 6, 7] </ref>. These mechanisms must allow applications to evolve and flexibly change their data requirements, while minimizing or even eliminating the impact of such change on other integrated applications. <p> Removing faulty or non-current view schemas will make it easier for the application developer to determine which view schema to run against. Also, performance improvements are likely to occur for the propagation of updates from a base class to its derived classes, given fewer derived, materialized classes <ref> [7] </ref>. Problem Description. Removal of such view schemata even if they are no longer in use could have potential side effects on other view schemata and thus would not be transparent to the users. <p> Multi-view supports a full range of virtual classes. Currently, in Multiview, all virtual classes are defined by a single object algebra operator, such as select, hide, union, etc. [11, 12]. Multiview is the first OO view system to handle incrementally materialized views <ref> [7] </ref> which is of advantage to TSE allowing fast retrieval of all instances, regardless whether the class we are retrieving the instance from is a base or virtual class. Throughout the paper we will be using the example of the university database depicted in Figure 2 (a).
Reference: [8] <editor> Report on the Object-Oriented Database Workshop: </editor> <title> Panel on Schema Evolution and Version Management. </title> <booktitle> In SIGMOD Records, </booktitle> <volume> Vol 18, No.3, </volume> <month> Sep </month> <year> 1989. </year>
Reference-contexts: Note, in particular, that no previous works have addressed the schema removal problem as characterized in this paper. Note that for systems using conventional versioning rather than object-oriented view mechanisms <ref> [8] </ref>, schema removal is likely to be less of an issue. These versioning systems typically create complete copies of class versions without integrating them into one global schema; resulting in a duplication of methods and thus no true interdependencies as in our case.
Reference: [9] <author> Y. G. Ra and E. A. Rundensteiner. </author> <title> A transparent object-oriented schema change approach using view schema evolution. </title> <booktitle> In IEEE International Conf on Data Engineering, </booktitle> <pages> pages 165-172, </pages> <month> March </month> <year> 1995. </year>
Reference-contexts: These mechanisms must allow applications to evolve and flexibly change their data requirements, while minimizing or even eliminating the impact of such change on other integrated applications. In this vein, we are developing a Transparent Schema Evolution system called TSE <ref> [9, 10] </ref>, which simulates schema evolution (SE) using object-oriented views fl This work was supported in part by the NSF RIA grant #IRI-9309076, NSF NYI grant #IRI 94-57609, and the University of Michigan Faculty Award Program. <p> For a more detailed discussion and comparison the reader is referred to papers on the TSE system itself <ref> [9, 10, ?] </ref>. Note, in particular, that no previous works have addressed the schema removal problem as characterized in this paper. Note that for systems using conventional versioning rather than object-oriented view mechanisms [8], schema removal is likely to be less of an issue. <p> This example shows one of the schema change operators that the TSE system supports, namely the delete-attribute operator. For more detailed information and a complete reference on the schema change operators supported by the TSE system refer to <ref> [9, 10] </ref>. <p> First, we provide a characterization of the view removal problem for transparent schema evolution systems which to the best of our knowledge has not previously been studied. Results of this work should improve efficiency of transparent schema evolution systems such as TSE <ref> [9] </ref>, and thus increase their utility as mechanisms for enabling interoperability. Second, we characterize four potential schema consistency problems for single class removal, and present a solution for each of these problems.
Reference: [10] <author> Y. G. Ra and E. A. Rundensteiner. </author> <title> A Transparent Schema Evolution System Based on Object-Oriented View Technology. </title> <journal> Accepted by IEEE Transactions on Knowledge and Data Engineering, </journal> <year> 1996. </year>
Reference-contexts: These mechanisms must allow applications to evolve and flexibly change their data requirements, while minimizing or even eliminating the impact of such change on other integrated applications. In this vein, we are developing a Transparent Schema Evolution system called TSE <ref> [9, 10] </ref>, which simulates schema evolution (SE) using object-oriented views fl This work was supported in part by the NSF RIA grant #IRI-9309076, NSF NYI grant #IRI 94-57609, and the University of Michigan Faculty Award Program. <p> For a more detailed discussion and comparison the reader is referred to papers on the TSE system itself <ref> [9, 10, ?] </ref>. Note, in particular, that no previous works have addressed the schema removal problem as characterized in this paper. Note that for systems using conventional versioning rather than object-oriented view mechanisms [8], schema removal is likely to be less of an issue. <p> in this paper to optimize schema removal, such as establishing an ordering for class removal processing, have not been developed for conventional SE. 3 The TSE System The TSE system combines schema evolution with schema versioning where a schema version is defined to be a dynamic view of the schema <ref> [10] </ref>. stored data STORED DATA User/Application Program1 User/Application Program2 virtual data1 view schema VS1 SCHEMA SPECIFY SCHEMA CHANGE global schema GS stored data MODIFIED STORED DATA EXTENDED SCHEMA User/Application Program1 User/Application Program2 view schema VS2 virtual data2 virtual data1 view schema VS1 remove remove add add SCHEMA CHANGE is REALIZED BY <p> This example shows one of the schema change operators that the TSE system supports, namely the delete-attribute operator. For more detailed information and a complete reference on the schema change operators supported by the TSE system refer to <ref> [9, 10] </ref>.
Reference: [11] <author> E. A. Rundensteiner. </author> <title> MultiView: A methodology for supporting multiple views in object-oriented databases. </title> <booktitle> In 18th VLDB Conf, </booktitle> <pages> pages 187-198, </pages> <year> 1992. </year>
Reference-contexts: 1 Introduction Motivation. The general goal of this work is to develop powerful interoperability-enabling solutions for the integration of software applications <ref> [11, 6, 7] </ref>. These mechanisms must allow applications to evolve and flexibly change their data requirements, while minimizing or even eliminating the impact of such change on other integrated applications. <p> Legend Class Name &lt;Name&gt; is-a relationship property &lt;attr.&gt; Virtual Class Base Class The TSE system is built on top of the Multiview OO view system <ref> [11, 6] </ref>. Each view schema is composed of a set of view classes and relationships among them. Each view class is a proxy object that corresponds to a real class (base or virtual) in the underlying global schema. Multi-view supports a full range of virtual classes. <p> Each view class is a proxy object that corresponds to a real class (base or virtual) in the underlying global schema. Multi-view supports a full range of virtual classes. Currently, in Multiview, all virtual classes are defined by a single object algebra operator, such as select, hide, union, etc. <ref> [11, 12] </ref>. Multiview is the first OO view system to handle incrementally materialized views [7] which is of advantage to TSE allowing fast retrieval of all instances, regardless whether the class we are retrieving the instance from is a base or virtual class. <p> The view system Multiview <ref> [11, 6] </ref> underlying TSE is such that each view class V in a view schema VS corresponds to a class C (either base or virtual) in the global schema GS, with C denoted by GS-class (V). <p> By guaranteeing the two conditions stated above, we can guarantee that the view schemas will be unaffected (for a description of how view schemata are derived from GS see <ref> [11, 6] </ref>). 4.2 Problems of Class Removal When removing a view schema VS, we would like to remove every class from GS that participates in the view VS. <p> When specifying a virtual class by an object algebra operator such as hide, select, union, etc. <ref> [11] </ref>, the type and extent of the derived class may or may not be the same as those of the source class. In order to determine the situations where the delete cannot be performed, we classify our object algebra operators used for view specification as defined below. <p> Instead, a class will only be deleted when this class is not used in any view schema (i.e., no user has access to this class). Like other view systems [2], MultiView assumes closed view schemas <ref> [11] </ref>. The closure criterion ensures that all classes that are being used by the type interface of any class in a view schema are also defined within the view.
Reference: [12] <author> E. A. Rundensteiner. </author> <title> A classification algorithm for supporting object-oriented views. </title> <booktitle> In CIKM, </booktitle> <pages> pages 18-25, </pages> <month> Nov. </month> <year> 1994. </year>
Reference-contexts: The difficulty here is caused by the fact that all view classes (whether base or virtual) from different view schemas are integrated together into a unified global schema <ref> [12] </ref>. This offers advantages, such as that virtual classes in the TSE system participate in the actual inheritance hierarchy and thus behave just like base classes. 1 Gemstone is a trademark of GemStone Systems, Inc. In fact, virtual classes in TSE can independently define ad-ditional attributes and methods. <p> Each view class is a proxy object that corresponds to a real class (base or virtual) in the underlying global schema. Multi-view supports a full range of virtual classes. Currently, in Multiview, all virtual classes are defined by a single object algebra operator, such as select, hide, union, etc. <ref> [11, 12] </ref>. Multiview is the first OO view system to handle incrementally materialized views [7] which is of advantage to TSE allowing fast retrieval of all instances, regardless whether the class we are retrieving the instance from is a base or virtual class. <p> Note that some Intermediate Classes (namely, IC this this example) were created to provide schema consistency (as explained in <ref> [12] </ref>). In this case, suppose we detected that classes Student2 and Student3 are not being used by any view schema and therefore can be removed. As indicated in the figure, removing Student2 by itself causes no problem since TA can be redefined from Student3.
Reference: [13] <author> R. Zicari. </author> <title> A Framework for O 2 Schema Updates. </title> <booktitle> In 7th IEEE International Conf. on Data Engineering, </booktitle> <pages> pages 146-182, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: In fact, virtual classes in TSE can independently define ad-ditional attributes and methods. In traditional SE systems, the semantics are to propagate all user-initiated changes to the whole schema. For example, a delete-class (C) command causes the deletion of properties from all of C's subclasses, if inherited from C <ref> [13, 1] </ref>. In SVR, we are instead trying to achieve garbage-collection semantics, namely, we must assure that the rest of the schema stays unaffected. <p> Our work is also related to the issue of schema consistency, e.g., Orion [1] or O2 <ref> [13, 5] </ref>. We both must establish what constitutes a consistent schema, and must assure that transformation operations indeed result in a consistent final schema. However, the objectives as well as the strategies of achieving these goals are rather distinct.
References-found: 13

