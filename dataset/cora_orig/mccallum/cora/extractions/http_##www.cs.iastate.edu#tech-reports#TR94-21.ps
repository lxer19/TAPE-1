URL: http://www.cs.iastate.edu/tech-reports/TR94-21.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: http://www.cs.iastate.edu
Title: Weak Behavioral Subtyping for Types with Mutable Objects Keywords: object-oriented, behavioral subtype, abstract data type,
Author: Krishna Kishore Dhara and Gary T. Leavens Krishna Kishore Dhara and Gary T. Leavens, 
Address: 226 Atanasoff Hall  Ames, Iowa 50011-1040, USA  
Affiliation: Department of Computer Science  Iowa Sate University  
Note: Submitted for publication. c  1994. Copies may be made for research and scholarly purposes, but not for direct commercial advantage. All rights reserved.  
Date: November 1994  
Pubnum: TR #94-21  
Abstract: 1992 CR Categories: D.3.1 [Programming Languages] Formal Definitions and Theory | Semantics; D.3.3 [Programming Languages] Language Constructs | Abstract data types; F.3.1 [Logics and Meaning of Programs] Specifying and verifying and reasoning about programs | logics of programs; F.3.2 [Logics and Meanings of Programs] Semantics of Programming Languages | algebraic approaches to semantics, denotational sematics. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Pierre America. </author> <title> A behavioural approach to subtyping in object-oriented programming languages. </title> <type> Technical Report 443, </type> <institution> Philips Research Laboratories, Nederlandse Philips Bedrijven B. V., </institution> <month> January </month> <year> 1989. </year> <note> Superseded by a later version in April 1989. </note>
Reference-contexts: We believe that such aliasing restrictions may actually be of some practical benefit, as they allow naive reasoning to be sound. Most other model-theoretic approaches [2], [10] [8] [11] do not deal with mutation and aliasing. In contrast to our approach, America <ref> [1] </ref> and Liskov and Wing [13] [12] give proof-theoretic definitions of behavioral subtyping. We leave for future work a direct comparison between our definition and such proof-theoretic definitions, and formulating the model-theoretic equivalent of Liskov and Wing's definitions.
Reference: [2] <author> Kim B. Bruce and Peter Wegner. </author> <title> An algebraic model of subtype and inheritance. </title> <editor> In Francois Ban~cilhon and Peter Buneman, editors, </editor> <booktitle> Advances in Database Programming Languages, </booktitle> <pages> pages 75-96. </pages> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <month> August </month> <year> 1990. </year>
Reference-contexts: Knowing the conditions on behavioral subtyping is important for guiding the design of ADTs. It is also critical for proving the soundness of logics for OO program verification. Previous work on the model theory of behavioral subtyping has not allowed mutation and aliasing <ref> [2] </ref> [10] [8] [11]. But mutation and aliasing are important in practical OO programming, and many types occurring in practice have objects with mutable (time-varying) state. Although it is possible to imagine an OO language where aliasing is eliminated entirely, existing OO languages do permit aliasing. <p> We have given suitable aliasing restrictions, which disallow direct aliasing between identifiers of different types. We believe that such aliasing restrictions may actually be of some practical benefit, as they allow naive reasoning to be sound. Most other model-theoretic approaches <ref> [2] </ref>, [10] [8] [11] do not deal with mutation and aliasing. In contrast to our approach, America [1] and Liskov and Wing [13] [12] give proof-theoretic definitions of behavioral subtyping.
Reference: [3] <author> Luca Cardelli. </author> <title> Typeful programming. </title> <editor> In E. J. Neuhold and M. Paul, editors, </editor> <booktitle> Formal Description of Programming Concepts, IFIP State-of-the-Art Reports, </booktitle> <pages> pages 431-507. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1991. </year>
Reference-contexts: The subtype relationships between the various collection types in Cook's hierarchy [5] are weak behavioral subtypes in our sense. For immutable tuple types, our definition matches Cardelli's rules <ref> [3] </ref>. Because this definition permits B and A to be different algebras, it works for incomplete specifications: those with observably different models. Such incomplete specifications are important in practice, so that a subtype can be more completely specified than its supertypes.
Reference: [4] <author> Jolly Chen. </author> <title> The Larch/Generic interface language. </title> <type> Technical report, </type> <institution> Massachusetts Institute of Technology, EECS department, </institution> <month> May </month> <year> 1989. </year> <note> The author's Bachelor's thesis. Available from John Guttag at MIT (guttag@lcs.mit.edu). </note>
Reference-contexts: RetAliasRel is a family of partial functions indexed by the natural numbers, such that for each natural number n, RetAliasRel n : OPS n fi TYPES n fi PowerSet (TYPES) n ! PowerSet (TYPES) ? . Our models of abstract types with mutable objects are algebraic [15] <ref> [4] </ref> [7]. Objects are modeled by typed locations containing values, which may in turn contain locations. We define algebras and stores simultaneously, because the operations of an algebra take and return a store [7].
Reference: [5] <author> W. R. Cook. </author> <title> Interfaces and specifications for the Smalltalk-80 collection classes. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 27(10) </volume> <pages> 1-15, </pages> <month> October </month> <year> 1992. </year> <booktitle> OOPSLA '92 Proceedings, Andreas Paepcke (editor). </booktitle>
Reference-contexts: As an example, a completely mutable array is a weak behavioral subtype of partially mutable array, which in turn is a weak behavioral subtype of an immutable array. The subtype relationships between the various collection types in Cook's hierarchy <ref> [5] </ref> are weak behavioral subtypes in our sense. For immutable tuple types, our definition matches Cardelli's rules [3]. Because this definition permits B and A to be different algebras, it works for incomplete specifications: those with observably different models.
Reference: [6] <author> Gary T. Leavens. </author> <title> Modular specification and verification of object-oriented programs. </title> <journal> IEEE Software, </journal> <volume> 8(4) </volume> <pages> 72-80, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: One modular reasoning technique is supertype abstraction, in which one reasons about the effects of method sends using the properties of the static types of the subexpressions [10] <ref> [6] </ref>. The purpose and justification of a definition of behavioral subtyping is that it makes supertype abstraction sound. Our technical approach showing that a definition of behavioral subtyping makes super-type abstraction sound is to capture the conclusions of reasoning via supertype abstraction in a set of expected behaviors.
Reference: [7] <author> Gary T. Leavens and Krishna Kishore Dhara. </author> <title> Blended algebraic and denotational semantics for ADT languages. </title> <type> Technical Report 93-21b, </type> <institution> Department of Computer 12 Science, Iowa State University, Ames, Iowa, </institution> <month> 50011, September </month> <year> 1994. </year> <note> Submitted for publication. Available by anonymous ftp from ftp.cs.iastate.edu, and by e-mail from almanac@cs.iastate.edu. </note>
Reference-contexts: I 2 := E "TD*" is a sequence of zero or more "TD"s (with separators in concrete examples). 3.1 Denotational Semantics The denotational semantics of INST is given in two parts <ref> [7] </ref>: the type and method declarations are compiled into a signature and an algebra over that signature. The semantics of expressions, declarations, and commands are parameterized by an algebra. <p> Nonstandard notations not explained in this paragraph will be explained further below. The type of P is a dependent type. The signature INST and the INST -algebra A INST give the signature and semantics of the visible types (see Figures 4 and 6 in <ref> [7] </ref>). The valuation function for type declaration sequences, T Dfl, adds to the signature and algebra primitive operations for each type declared; these primitive operations are used by the semantics of expressions and commands for creating objects and for accessing their instance variables. <p> RetAliasRel is a family of partial functions indexed by the natural numbers, such that for each natural number n, RetAliasRel n : OPS n fi TYPES n fi PowerSet (TYPES) n ! PowerSet (TYPES) ? . Our models of abstract types with mutable objects are algebraic [15] [4] <ref> [7] </ref>. Objects are modeled by typed locations containing values, which may in turn contain locations. We define algebras and stores simultaneously, because the operations of an algebra take and return a store [7]. <p> Our models of abstract types with mutable objects are algebraic [15] [4] <ref> [7] </ref>. Objects are modeled by typed locations containing values, which may in turn contain locations. We define algebras and stores simultaneously, because the operations of an algebra take and return a store [7].
Reference: [8] <author> Gary T. Leavens and Don Pigozzi. </author> <title> Typed homomorphic relations extended with sub-types. </title> <type> Technical Report 91-14, </type> <institution> Department of Computer Science, Iowa State University, Ames, Iowa, </institution> <month> 50011, June </month> <year> 1991. </year> <booktitle> Appears in the proceedings of Mathematical Foundations of Programming Semantics '91, Springer-Verlag, Lecture Notes in Computer Science, </booktitle> <volume> volume 598, </volume> <pages> pages 144-167, </pages> <year> 1992. </year>
Reference-contexts: Knowing the conditions on behavioral subtyping is important for guiding the design of ADTs. It is also critical for proving the soundness of logics for OO program verification. Previous work on the model theory of behavioral subtyping has not allowed mutation and aliasing [2] [10] <ref> [8] </ref> [11]. But mutation and aliasing are important in practical OO programming, and many types occurring in practice have objects with mutable (time-varying) state. Although it is possible to imagine an OO language where aliasing is eliminated entirely, existing OO languages do permit aliasing. <p> We have given suitable aliasing restrictions, which disallow direct aliasing between identifiers of different types. We believe that such aliasing restrictions may actually be of some practical benefit, as they allow naive reasoning to be sound. Most other model-theoretic approaches [2], [10] <ref> [8] </ref> [11] do not deal with mutation and aliasing. In contrast to our approach, America [1] and Liskov and Wing [13] [12] give proof-theoretic definitions of behavioral subtyping.
Reference: [9] <author> Gary T. Leavens and Don Pigozzi. </author> <title> The behavior-realization adjunction and generalized homomorphic relations. </title> <type> Technical Report 94-18, </type> <institution> Department of Computer Science, Iowa State University, Ames, Iowa, </institution> <month> 50011, September </month> <year> 1994. </year> <note> Submitted for publication. </note>
Reference-contexts: Relating locations along with the store does not account for aliasing between identifiers in the environment. So one must relate whole states. This idea is captured by the definition of simulation relations below. 4.1 Simulation Relations The following formulation of simulation relations uses techniques from <ref> [9] </ref>. Definition 4.1 (simulation relation) Let C and A be -algebras.
Reference: [10] <author> Gary T. Leavens and William E. Weihl. </author> <title> Reasoning about object-oriented programs that use subtypes (extended abstract). </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 25(10) </volume> <pages> 212-223, </pages> <month> October </month> <year> 1990. </year> <booktitle> OOPSLA ECOOP '90 Proceedings, N. Meyrowitz (editor). </booktitle>
Reference-contexts: Knowing the conditions on behavioral subtyping is important for guiding the design of ADTs. It is also critical for proving the soundness of logics for OO program verification. Previous work on the model theory of behavioral subtyping has not allowed mutation and aliasing [2] <ref> [10] </ref> [8] [11]. But mutation and aliasing are important in practical OO programming, and many types occurring in practice have objects with mutable (time-varying) state. Although it is possible to imagine an OO language where aliasing is eliminated entirely, existing OO languages do permit aliasing. <p> One modular reasoning technique is supertype abstraction, in which one reasons about the effects of method sends using the properties of the static types of the subexpressions <ref> [10] </ref> [6]. The purpose and justification of a definition of behavioral subtyping is that it makes supertype abstraction sound. Our technical approach showing that a definition of behavioral subtyping makes super-type abstraction sound is to capture the conclusions of reasoning via supertype abstraction in a set of expected behaviors. <p> We have given suitable aliasing restrictions, which disallow direct aliasing between identifiers of different types. We believe that such aliasing restrictions may actually be of some practical benefit, as they allow naive reasoning to be sound. Most other model-theoretic approaches [2], <ref> [10] </ref> [8] [11] do not deal with mutation and aliasing. In contrast to our approach, America [1] and Liskov and Wing [13] [12] give proof-theoretic definitions of behavioral subtyping.
Reference: [11] <author> Gary T. Leavens and William E. Weihl. </author> <title> Subtyping, modular specification, and modular verification for applicative object-oriented programs. </title> <type> Technical Report 92-28d, </type> <institution> Department of Computer Science, Iowa State University, Ames, Iowa, </institution> <month> 50011, August </month> <year> 1994. </year> <note> Full version of a paper to appear in Acta Informatica. Available by anonymous ftp from ftp.cs.iastate.edu, and by e-mail from almanac@cs.iastate.edu. </note>
Reference-contexts: Knowing the conditions on behavioral subtyping is important for guiding the design of ADTs. It is also critical for proving the soundness of logics for OO program verification. Previous work on the model theory of behavioral subtyping has not allowed mutation and aliasing [2] [10] [8] <ref> [11] </ref>. But mutation and aliasing are important in practical OO programming, and many types occurring in practice have objects with mutable (time-varying) state. Although it is possible to imagine an OO language where aliasing is eliminated entirely, existing OO languages do permit aliasing. <p> We have given suitable aliasing restrictions, which disallow direct aliasing between identifiers of different types. We believe that such aliasing restrictions may actually be of some practical benefit, as they allow naive reasoning to be sound. Most other model-theoretic approaches [2], [10] [8] <ref> [11] </ref> do not deal with mutation and aliasing. In contrast to our approach, America [1] and Liskov and Wing [13] [12] give proof-theoretic definitions of behavioral subtyping.
Reference: [12] <author> Barbara Liskov and Jeannette Wing. </author> <title> A behavioral notion of subtyping. </title> <note> To appear in ACM TOPLAS. Obtained from the authors through the URL http://www.cs.cmu.edu:8001/afs/cs.cmu.edu/user/wing/www/home.html, 1994. </note>
Reference-contexts: But mutation and aliasing are important in practical OO programming, and many types occurring in practice have objects with mutable (time-varying) state. Although it is possible to imagine an OO language where aliasing is eliminated entirely, existing OO languages do permit aliasing. Unlike Liskov and Wing [13] <ref> [12] </ref>, we do not allow arbitrary aliasing, but instead seek a middle ground that permits more useful behavioral subtype relationships. The purpose of our study is ultimately to show how to reason in a modular fashion about OO programs. <p> no surprising behavior is possible when subtyping relationships are required to satisfy the definition. fl This work was supported in part by the National Science Foundation under Grant CCR-9108654. 1 In this paper we define "weak behavioral subtyping." It is a weaker definition than either of Liskov and Wing's definitions <ref> [12] </ref> because it allows types with mutable objects (hereinafter mutable types) to be subtypes of immutable types. We sketch the semantics of a programming language with the necessary aliasing control, and show that weak behavioral subtyping is adequate in the sense described above. <p> Using Liskov and Wing's definitions of behavioral subtype [13] <ref> [12] </ref>, BoolSeq and StoreBool cannot have a common subtype, because BoolSeq objects are immutable (and thus a common subtype would have to violate a history constraint, or would have a mutator corresponding to store that could not be explained). <p> This definition is weaker than Liskov and Wing's definitions [13] <ref> [12] </ref>, because it allows types with immutable objects to have subtypes with mutable objects. This flexibility seems to be important in practice. The price to be paid, however, is that the language must restrict aliasing. We have given suitable aliasing restrictions, which disallow direct aliasing between identifiers of different types. <p> We believe that such aliasing restrictions may actually be of some practical benefit, as they allow naive reasoning to be sound. Most other model-theoretic approaches [2], [10] [8] [11] do not deal with mutation and aliasing. In contrast to our approach, America [1] and Liskov and Wing [13] <ref> [12] </ref> give proof-theoretic definitions of behavioral subtyping. We leave for future work a direct comparison between our definition and such proof-theoretic definitions, and formulating the model-theoretic equivalent of Liskov and Wing's definitions.
Reference: [13] <author> Barbara Liskov and Jeannette M. Wing. </author> <title> Specifications and their use in defining sub-types. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 28(10) </volume> <pages> 16-28, </pages> <month> October </month> <year> 1993. </year> <booktitle> OOPSLA '93 Proceedings, Andreas Paepcke (editor). </booktitle>
Reference-contexts: But mutation and aliasing are important in practical OO programming, and many types occurring in practice have objects with mutable (time-varying) state. Although it is possible to imagine an OO language where aliasing is eliminated entirely, existing OO languages do permit aliasing. Unlike Liskov and Wing <ref> [13] </ref> [12], we do not allow arbitrary aliasing, but instead seek a middle ground that permits more useful behavioral subtype relationships. The purpose of our study is ultimately to show how to reason in a modular fashion about OO programs. <p> Using Liskov and Wing's definitions of behavioral subtype <ref> [13] </ref> [12], BoolSeq and StoreBool cannot have a common subtype, because BoolSeq objects are immutable (and thus a common subtype would have to violate a history constraint, or would have a mutator corresponding to store that could not be explained). <p> This definition is weaker than Liskov and Wing's definitions <ref> [13] </ref> [12], because it allows types with immutable objects to have subtypes with mutable objects. This flexibility seems to be important in practice. The price to be paid, however, is that the language must restrict aliasing. <p> We believe that such aliasing restrictions may actually be of some practical benefit, as they allow naive reasoning to be sound. Most other model-theoretic approaches [2], [10] [8] [11] do not deal with mutation and aliasing. In contrast to our approach, America [1] and Liskov and Wing <ref> [13] </ref> [12] give proof-theoretic definitions of behavioral subtyping. We leave for future work a direct comparison between our definition and such proof-theoretic definitions, and formulating the model-theoretic equivalent of Liskov and Wing's definitions.
Reference: [14] <author> John C. Reynolds. </author> <title> Using category theory to design implicit conversions and generic operators. </title> <editor> In Neil D. Jones, editor, </editor> <booktitle> Semantics-Directed Compiler Generation, Proceedings of a Workshop, Aarhus, Denmark, volume 94 of Lecture Notes in Computer Science, </booktitle> <pages> pages 211-258. </pages> <publisher> Springer-Verlag, </publisher> <month> January </month> <year> 1980. </year>
Reference-contexts: To define observations, we fix a set of the visible (or built-in) types, VIS = fInt; Boolg. The externally visible values of these types are: EXTERNALS Int def and EXTERNALS Bool def = ftrue; falseg. Signatures are roughly as in Reynolds's category sorted algebras <ref> [14] </ref>, with the addition of information about aliasing that is used in our static restrictions on aliasing.
Reference: [15] <author> Jeannette Marie Wing. </author> <title> A two-tiered approach to specifying programs. </title> <type> Technical Report TR-299, </type> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, </institution> <year> 1983. </year>
Reference-contexts: RetAliasRel is a family of partial functions indexed by the natural numbers, such that for each natural number n, RetAliasRel n : OPS n fi TYPES n fi PowerSet (TYPES) n ! PowerSet (TYPES) ? . Our models of abstract types with mutable objects are algebraic <ref> [15] </ref> [4] [7]. Objects are modeled by typed locations containing values, which may in turn contain locations. We define algebras and stores simultaneously, because the operations of an algebra take and return a store [7].
References-found: 15

