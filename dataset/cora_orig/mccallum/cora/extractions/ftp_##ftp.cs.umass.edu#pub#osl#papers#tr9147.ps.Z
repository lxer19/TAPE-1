URL: ftp://ftp.cs.umass.edu/pub/osl/papers/tr9147.ps.Z
Refering-URL: http://spa-www.cs.umass.edu/bibliography.html
Root-URL: 
Title: A Language-Independent Garbage Collector Toolkit  
Author: Richard L. Hudson J. Eliot B. Moss Amer Diwan Christopher F. Weight 
Note: This project is supported by National Science Foundation Grant CCR-8658074, and by Digital Equip ment Corporation,  
Address: Amherst, MA 01003  
Affiliation: Object Oriented Systems Laboratory Department of Computer and Information Science University of Massachusetts, Amherst  GTE Laboratories, and Apple Computer.  
Abstract: COINS Technical Report 91-47 September 1991 Abstract We describe a memory management toolkit for language implementors. It offers efficient and flexible generation scavenging garbage collection. In addition to providing a core of language-independent algorithms and data structures, the toolkit includes auxiliary components that ease implementation of garbage collection for programming languages. We have detailed designs for Smalltalk and Modula-3 and are confident the toolkit can be used with a wide variety of languages. The toolkit approach is itself novel, and our design includes a number of additional innovations in flexibility, efficiency, accuracy, and cooperation between the compiler and the collector. 
Abstract-found: 1
Intro-found: 1
Reference: [Appel et al., 1988] <author> Andrew W. Appel, John R. Ellis, and Kai Li. </author> <title> Realtime concurrent collection on stock multiprocessors. </title> <booktitle> In Proceedings of the ACM SIGPLAN '88 Conference on Programming Language Design and Implementation (Atlanta, </booktitle> <address> Georgia, </address> <month> June </month> <year> 1988), </year> <journal> ACM SIGPLAN Not. </journal> <volume> 23, </volume> <month> 7 (July </month> <year> 1988), </year> <pages> pp. 11-20. </pages>
Reference-contexts: Incrementality may be important in achieving acceptable pause times when scavenging older generations, because they tend to be larger. Various techniques have been introduced recently that use hardware page access interrupts to implement incremental scavenging. One simple technique that borrows ideas from both [Caudill and Wirfs-Brock, 1986] and <ref> [Appel et al., 1988] </ref> can make our garbage collector incremental by limiting the number of blocks processed at a time. To start a scavenge, the roots are enumerated and the FROM space objects to which they refer are copied to TO space.
Reference: [Baker, 1978] <author> H. G. Baker. </author> <title> List processing in real time on a serial computer. </title> <journal> Communications of the ACM 21, </journal> <month> 4 (April </month> <year> 1978), </year> <pages> 280-294. </pages>
Reference-contexts: Wilson, Lam, and Moher [Wilson et al., 1991] has further refined the technique to obtain better clustering and reduce paging. Our algorithm is essentially a multi-generational form of copy collection as described by, e.g., <ref> [Baker, 1978] </ref>, and like that method, can readily be made incremental (see Section 3). 2.3 Large Object Space [Ungar and Jackson, 1988] demonstrated that there are performance advantages to avoiding the copying of large objects. In addition, our fixed size blocks cannot accommodate objects larger than a block.
Reference: [Bartlett, 1988] <author> Joel F. Bartlett. </author> <title> Compacting garbage collection with ambiguous roots. </title> <type> Research Report 88/2, </type> <institution> Western Research Laboratory, Digital Equipment Corporation, </institution> <month> February </month> <year> 1988. </year>
Reference-contexts: White during the presentation of [White, 1980]. 1 persistent objects, for buffer and address space management purposes. 2 Moving or deleting objects requires finding and updating exactly those pointers referring to the moved or deleted objects. Ambiguous roots collectors 3 (e.g., <ref> [Bartlett, 1988] </ref>) treat any root area quantity that appears to be a root pointer as if it actually is a root pointer.
Reference: [Card et al., 1983] <author> Stuart K. Card, Thomas P. Moran, and Allen Newell. </author> <title> The Psychology of Human-Computer Interaction. </title> <publisher> Lawrence Erlbaum Associates, </publisher> <address> Hillsdale, NJ, </address> <year> 1983. </year>
Reference-contexts: Another drawback of these schemes is that if several scans are required in a short period of time, availability can be reduced to unacceptable levels. <ref> [Card et al., 1983] </ref> state that for one event to be perceived as causing another event the pause time between the two events must be less that .05 seconds.
Reference: [Caudill and Wirfs-Brock, 1986] <author> Patrick J. Caudill and Allen Wirfs-Brock. </author> <title> A third generation Smalltalk-80 implementation. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications (Portland, </booktitle> <address> Oregon, </address> <month> September </month> <year> 1986), </year> <journal> ACM SIG-PLAN Not. </journal> <volume> 21, </volume> <month> 11 (November </month> <year> 1986), </year> <pages> pp. 119-130. </pages>
Reference-contexts: Incrementality may be important in achieving acceptable pause times when scavenging older generations, because they tend to be larger. Various techniques have been introduced recently that use hardware page access interrupts to implement incremental scavenging. One simple technique that borrows ideas from both <ref> [Caudill and Wirfs-Brock, 1986] </ref> and [Appel et al., 1988] can make our garbage collector incremental by limiting the number of blocks processed at a time. To start a scavenge, the roots are enumerated and the FROM space objects to which they refer are copied to TO space.
Reference: [Cheney, 1970] <author> C. J. </author> <title> Cheney. A nonrecursive list compacting algorithm. </title> <journal> Communications of the ACM 13, </journal> <month> 11 (November </month> <year> 1970), </year> <pages> 677-678. </pages>
Reference-contexts: In practice, TO space may be spread out across many blocks, and each TO step has its own unprocessed and allocation pointers. 6 Section 4 discusses possible promotion criteria in more detail. 8 The use of two pointers to do the processing was first described by <ref> [Cheney, 1970] </ref>. [Moon, 1984] describes a modification to this algorithm that results in better clustering of objects by interleaving the processing of objects referred to by the root set with processing of the objects they refer to.
Reference: [Fenichel and Yochelson, 1969] <author> Robert R. Fenichel and Jerome C. Yochelson. </author> <title> A LISP garbage-collector for virtual-memory computer systems. </title> <journal> Communications of the ACM 12, </journal> <month> 11 (November </month> <year> 1969), </year> <pages> 611-612. </pages>
Reference-contexts: The new blocks of a generation being scavenged are called TO space and the old blocks are called FROM space <ref> [Fenichel and Yochelson, 1969] </ref> (see Figure 2). Note that either all steps of a generation are scavenged or none are. This is because remembered sets (discussed in detail in Section 2.4.1) track inter-generational pointers, ignoring the finer grained step information.
Reference: [Gabriel, 1985] <author> Richard P. Gabriel. </author> <title> Performance and Evaluation of Lisp Systems. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1985. </year> <month> 21 </month>
Reference-contexts: Together these various optimizations are likely to reduce the store noting overhead of many programs significantly, making remembered sets acceptable for optimized languages. For example, when we recoded DESTRUCT, one of the Gabriel benchmarks <ref> [Gabriel, 1985] </ref>, into Modula-3 and considered the store noting that would result, we found that virtually all the store noting was eliminated because the updates stored values known to be integers. 2.5 Stack Processing Since stacks are a rapidly changing traced area, they are usually searched rather than remembered.
Reference: [Goldberg, 1991] <author> Benjamin Goldberg. </author> <title> Tag-free garbage collection in strongly typed programming languages. </title> <booktitle> In [SIGPLAN, </booktitle> <year> 1991], </year> <pages> pp. 165-176. </pages>
Reference-contexts: Finally, we note that the maps can actually be turned into code fragments that extract the roots. This would give the greatest speed in stack decoding, but might use too much space. <ref> [Goldberg, 1991] </ref> discusses implementation techniques that support compiler generation of stack decoding routines. 10 8 Threads are lightweight processes sharing the same address space; each thread has its own stack. 9 Our collector does not operate concurrently with the application threads. 10 Goldberg claims that his techniques require no tags in
Reference: [Hosking and Moss, 1991] <author> Antony L. Hosking and J. Eliot B. Moss. </author> <title> Compiler support for persistent programming. </title> <type> COINS Technical Report 91-25, </type> <institution> University of Massachusetts, </institution> <address> Amherst, MA 01003, </address> <month> March </month> <year> 1991. </year>
Reference-contexts: We start by describing the memory organization; we then present the algorithms, emphasizing points of flexibility; and we conclude by discussing the location and management of roots. 2 The details fall beyond the scope of this paper; see <ref> [Hosking and Moss, 1991] </ref> for further information. 3 These are also often called conservative collectors, but we find the term ambiguous roots to be more precisely descriptive. 2 2.1 Memory Organization We divide memory into three areas: collected, traced, and untraced.
Reference: [Lieberman and Hewitt, 1983] <author> Henry Lieberman and Carl Hewitt. </author> <title> A real-time garbage collection based on the lifetimes of objects. </title> <journal> Communications of the ACM 26, </journal> <month> 6 (June </month> <year> 1983), </year> <pages> 419-429. </pages>
Reference-contexts: We took high performance to include the following: giving short garbage collection pause times for interactive programs, tolerating a wide range of program allocation behaviors, avoiding run-time tags, interfering minimally with compiler optimizations, and adding little or no normal case code. We chose generation scavenging <ref> [Lieberman and Hewitt, 1983; Ungar, 1984] </ref> as the basis for our collector because it achieves short pause times and low overhead in memory management. In generational systems, objects are created in the new generation.
Reference: [Moon, 1984] <author> David Moon. </author> <title> Garbage collection in a large Lisp system. </title> <booktitle> In Proceedings of the ACM Symposium on Lisp and Functional Programming (Austin, </booktitle> <address> TX, </address> <month> August </month> <year> 1984), </year> <pages> pp. 235-246. </pages>
Reference-contexts: In practice, TO space may be spread out across many blocks, and each TO step has its own unprocessed and allocation pointers. 6 Section 4 discusses possible promotion criteria in more detail. 8 The use of two pointers to do the processing was first described by [Cheney, 1970]. <ref> [Moon, 1984] </ref> describes a modification to this algorithm that results in better clustering of objects by interleaving the processing of objects referred to by the root set with processing of the objects they refer to.
Reference: [Moss and Kohler, 1987] <author> J. Eliot B. Moss and Walter H. Kohler. </author> <title> Concurrency features for the Trellis/Owl language. </title> <booktitle> In Proceedings of the European Conference on Object-Oriented Programming (Paris, </booktitle> <address> France, </address> <month> June </month> <year> 1987), </year> <editor> J. Bezivin, J.-M. Hullot, P. Cointe, and H. Lieberman, Eds., </editor> <volume> vol. </volume> <booktitle> 276 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 171-180. </pages>
Reference-contexts: Synchronize then restarts each thread not already at a consistent stopping point. Each thread will then advance and stop. We use a variety of techniques to avoid or reduce normal case overhead, which we do not detail here (see <ref> [Moss and Kohler, 1987] </ref> for some ideas). The implementor must also supply a Resume routine, which allows the run-time system to resurrect the previous run-time state and resume normal operation. 5.6 Allocation The toolkit supplies routines for allocating objects in collected areas, which encapsulate all the necessary details.
Reference: [Shaw, 1987] <author> Robert A. Shaw. </author> <title> Improving garbage collector performance in virtual memory. </title> <type> Tech. Rep. </type> <institution> CSL-TR-87-323, Stanford University, </institution> <month> March </month> <year> 1987. </year>
Reference-contexts: If any roots are found, they are processed and updated. In any case, the card mark is reset if after scanning the card contains no roots. 7 <ref> [Shaw, 1987] </ref> describes a garbage collection technique that relies on virtual memory page dirty bit information.
Reference: [Shaw, 1988] <author> Robert A. Shaw. </author> <title> Empirical Analysis of a LISP System. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <month> February </month> <year> 1988. </year> <note> Available as Tech. Report CSL-TR-88-351. </note>
Reference-contexts: Step 1 is the youngest step in a generation. Typically, as a generation is scavenged, surviving objects are moved from their current to the next older step, and objects in the oldest step of a generation are promoted into the youngest step in the next generation. <ref> [Shaw, 1988] </ref> describes a similar scheme called a bucket brigade. In our scheme, all the survivors of a step move together. This avoids attaching age information to individual objects. Rather, age is encoded in the step. <p> Second, we can maintain one large remembered set for all generations, or we can maintain one for each generation. One point of variation is what is remembered. Ungar remembers objects, Shaw <ref> [Shaw, 1988] </ref> remembers virtual memory pages, and Sobalvarro [Sobalvarro, 1988] remembers fractions of pages called cards. The information associated with a card can be a single bit for compactness or a byte for speed [Wilson, 1990].
Reference: [SIGPLAN, 1991] <institution> Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design and Implementation (Toronto, </institution> <address> Ontario, Canada, </address> <month> June </month> <year> 1991), </year> <journal> ACM SIGPLAN Not. </journal> <volume> 26, </volume> <month> 6 (June </month> <year> 1991). </year>
Reference: [Sleator and Tarjan, 1985] <author> Daniel Dominic Sleator and Robert Endre Tarjan. </author> <title> Self-adjusting binary search trees. </title> <journal> Journal of the ACM 32, </journal> <month> 3 (July </month> <year> 1985). </year>
Reference-contexts: The algorithm refinements are straightforward so we skip the details. We chose not to compact large object space. Rather, we maintain free list information using splay trees <ref> [Sleator and Tarjan, 1985] </ref>, which offer excellent average and worst case performance for free list maintenance operations. 2.4 Root Set The roots of a generation set G are the pointers from outside G into G.
Reference: [Sobalvarro, 1988] <author> Patrick G. Sobalvarro. </author> <title> A lifetime-based garbage collector for LISP systems on general-purpose computers, 1988. B.S. </title> <type> Thesis, </type> <institution> Dept. of EECS, Massacusetts Institute of Technology, </institution> <address> Cambridge, MA. </address>
Reference-contexts: Second, we can maintain one large remembered set for all generations, or we can maintain one for each generation. One point of variation is what is remembered. Ungar remembers objects, Shaw [Shaw, 1988] remembers virtual memory pages, and Sobalvarro <ref> [Sobalvarro, 1988] </ref> remembers fractions of pages called cards. The information associated with a card can be a single bit for compactness or a byte for speed [Wilson, 1990].
Reference: [Ungar, 1984] <author> David Ungar. </author> <title> Generation scavenging: A non-disruptive high performance storage reclamation algorithm. </title> <booktitle> In Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments (Pittsburgh, </booktitle> <address> Pennsylvania, </address> <month> April </month> <year> 1984), </year> <journal> ACM SIGPLAN Not. </journal> <volume> 19, </volume> <month> 5 (May </month> <year> 1984), </year> <pages> pp. 157-167. </pages>
Reference-contexts: We took high performance to include the following: giving short garbage collection pause times for interactive programs, tolerating a wide range of program allocation behaviors, avoiding run-time tags, interfering minimally with compiler optimizations, and adding little or no normal case code. We chose generation scavenging <ref> [Lieberman and Hewitt, 1983; Ungar, 1984] </ref> as the basis for our collector because it achieves short pause times and low overhead in memory management. In generational systems, objects are created in the new generation. <p> Generation 1 is the youngest, and holds the most recently allocated objects. As objects survive repeated scavenges, they are promoted to ever higher (older) generations. Higher generations are scavenged less frequently, focusing collection activity on young objects, which typically die (become garbage) more rapidly than older objects. Unlike Ungar <ref> [Ungar, 1984; Ungar and Jackson, 1988] </ref>, we allow more than two generations. Figure 2 illustrates a scavenge of the two youngest generations. In addition to supporting multiple generations, we allow the number of generations to increase and decrease dynamically, by inserting or deleting one or more generations. <p> However, searching younger generations to find pointers into a generation being scavenged does almost as much work as scavenging the younger generations. Thus, it makes more sense to scavenge the younger generations, too, as we have been assuming. 2.4.1 Remembered Sets Ungar <ref> [Ungar, 1984; Ungar and Jackson, 1988] </ref> (among others) has shown that pointers from older to younger objects are rare. This suggests that such pointers should be remembered.
Reference: [Ungar and Jackson, 1988] <author> David Ungar and Frank Jackson. </author> <title> Tenuring policies for generation-based storage reclamation. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications (San Diego, </booktitle> <address> California, </address> <month> September </month> <year> 1988), </year> <journal> ACM SIG-PLAN Not. </journal> <volume> 23, </volume> <month> 11 (November </month> <year> 1988), </year> <pages> pp. 1-17. </pages>
Reference-contexts: Generation 1 is the youngest, and holds the most recently allocated objects. As objects survive repeated scavenges, they are promoted to ever higher (older) generations. Higher generations are scavenged less frequently, focusing collection activity on young objects, which typically die (become garbage) more rapidly than older objects. Unlike Ungar <ref> [Ungar, 1984; Ungar and Jackson, 1988] </ref>, we allow more than two generations. Figure 2 illustrates a scavenge of the two youngest generations. In addition to supporting multiple generations, we allow the number of generations to increase and decrease dynamically, by inserting or deleting one or more generations. <p> Our algorithm is essentially a multi-generational form of copy collection as described by, e.g., [Baker, 1978], and like that method, can readily be made incremental (see Section 3). 2.3 Large Object Space <ref> [Ungar and Jackson, 1988] </ref> demonstrated that there are performance advantages to avoiding the copying of large objects. In addition, our fixed size blocks cannot accommodate objects larger than a block. To address these concerns our toolkit provides a separate large object space (LOS) as part of the collected area. <p> However, searching younger generations to find pointers into a generation being scavenged does almost as much work as scavenging the younger generations. Thus, it makes more sense to scavenge the younger generations, too, as we have been assuming. 2.4.1 Remembered Sets Ungar <ref> [Ungar, 1984; Ungar and Jackson, 1988] </ref> (among others) has shown that pointers from older to younger objects are rare. This suggests that such pointers should be remembered. <p> 12 the maximum size of a small object; 13 the minimum size of a large object; 14 where each step moves survivors to; which generations to scavenge at one time; when to scavenge; when to insert or merge generations; when to insert or merge steps; and how many 11 See <ref> [Ungar and Jackson, 1988] </ref> and [Wilson and Moher, 1989] for some interesting discussions and ideas. 12 The block size may not be changed dynamically. 13 This may be smaller than the block size. 14 This may be smaller than the maximum size of small object. 16 blocks are scanned at one
Reference: [White, 1980] <author> Jon L. White. </author> <title> Address/memory management for a gigantic Lisp environment or, GC considered harmful. </title> <booktitle> In Proceedings of the ACM Symposium on Lisp and Functional Programming (Stanford, </booktitle> <address> California, </address> <month> August </month> <year> 1980), </year> <booktitle> ACM, </booktitle> <pages> pp. 119-127. </pages>
Reference-contexts: These techniques are not strictly part of the toolkit, but we explain the necessary compiler enhancements in Section 2.5. To implement persistence effectively, we need to be able to move (or delete) heap copies of 1 This phenomenon was noted by Jon L. White during the presentation of <ref> [White, 1980] </ref>. 1 persistent objects, for buffer and address space management purposes. 2 Moving or deleting objects requires finding and updating exactly those pointers referring to the moved or deleted objects.
Reference: [Wilson, 1990] <author> Paul R. Wilson. </author> <type> Personal communication, </type> <month> October </month> <year> 1990. </year>
Reference-contexts: One point of variation is what is remembered. Ungar remembers objects, Shaw [Shaw, 1988] remembers virtual memory pages, and Sobalvarro [Sobalvarro, 1988] remembers fractions of pages called cards. The information associated with a card can be a single bit for compactness or a byte for speed <ref> [Wilson, 1990] </ref>. Note that page or card marking can be used as a source of candidates for entry into separate remembered sets, or the card table can be the remembered set.
Reference: [Wilson et al., 1991] <author> Paul R. Wilson, Michael S. Lam, and Thomas G. Moher. </author> <title> Effective static-graph reorganization to improve locality in garbage-collected systems. </title> <booktitle> In [SIGPLAN, </booktitle> <year> 1991], </year> <pages> pp. 177-191. </pages>
Reference-contexts: Wilson, Lam, and Moher <ref> [Wilson et al., 1991] </ref> has further refined the technique to obtain better clustering and reduce paging.
Reference: [Wilson and Moher, 1989] <author> Paul R. Wilson and Thomas G. Moher. </author> <title> Design of the Opportunistic Garbage Collector. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications (New Orleans, </booktitle> <address> Louisiana, </address> <month> October </month> <year> 1989), </year> <journal> ACM SIGPLAN Not. </journal> <volume> 24, </volume> <month> 10 (October </month> <year> 1989), </year> <pages> pp. 23-35. </pages>
Reference-contexts: By filtering we mean the determination that a given store operation is, first of all, storing a pointer as opposed to a non-pointer value (pointer filtering), and secondly, if the pointer needs to be remembered (generation filtering). Along with Shaw, Sobalvarro, and Wilson and Moher <ref> [Wilson and Moher, 1989] </ref>, we believe that tight unconditional code at each (pointer) store gives the best performance, and generational filtering should be performed later; Ungar performs all filtering at store time, calling it a store check. <p> a small object; 13 the minimum size of a large object; 14 where each step moves survivors to; which generations to scavenge at one time; when to scavenge; when to insert or merge generations; when to insert or merge steps; and how many 11 See [Ungar and Jackson, 1988] and <ref> [Wilson and Moher, 1989] </ref> for some interesting discussions and ideas. 12 The block size may not be changed dynamically. 13 This may be smaller than the block size. 14 This may be smaller than the maximum size of small object. 16 blocks are scanned at one time.
Reference: [Zorn, 1990] <author> Benjamin Zorn. </author> <title> Comparing mark-and-sweep and stop-and-copy garbage collection. </title> <booktitle> In Proceedings of the ACM Symposium on Lisp and Functional Programming (Nice, </booktitle> <address> France, </address> <month> June </month> <year> 1990), </year> <pages> pp. 87-98. 23 </pages>
Reference-contexts: in fact from any address in the object. 5 The contiguous nursery area also reduces the number of page traps if we use an access protected 3 4 5 allocates only enough blocks to hold the surviving objects; when the scavenge is complete, the original blocks can be reused immediately. <ref> [Zorn, 1990] </ref> claims that since the youngest generation needs to fit in primary memory, the mark-and-sweep algorithm requires less memory because each generation is one-half the size of copying algorithm generations. An important contribution of our scheme is that it immediately reuses freed blocks following a scavenge, as just mentioned. <p> This means the amount of space needed for the youngest generation consists of the area used for allocation plus the number of blocks needed to hold objects surviving a scavenge, as illustrated in Figure 4. Depending on the length between scavenges, <ref> [Zorn, 1990] </ref> claims a survival rate between 3% and 24% of objects allocated since the last scavenge. Therefore, our scheme requires between 52% to 62% of that needed by the traditional stop-and-copy schemes described by Zorn.
References-found: 25

