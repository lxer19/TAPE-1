URL: http://www.cs.pitt.edu/~gupta/research/Comp/lcpc95.ps
Refering-URL: http://www.cs.pitt.edu/~gupta/research/optimization.html
Root-URL: 
Title: Array Data Flow Analysis for Load-Store Optimizations in Superscalar Architectures  
Author: Rastislav Bodk and Rajiv Gupta 
Address: Pittsburgh, Pittsburgh, PA 15260  
Affiliation: Dept. of Computer Science, University of  
Abstract: The performance of scientific programs on superscalar processors can be significantly degraded by memory references that frequently arise due to load and store operations associated with array references. Therefore, register allocation techniques have been developed for allocating registers to array elements whose values are repeatedly referenced over one or more loop iterations. To place load, store, and register-to-register shift operations without introducing fully/partially redundant and dead memory operations, a detailed value flow analysis of array references is required. We present an analysis framework to efficiently solve various data flow problems required by array load-store optimizations. The framework determines the collective behavior of recurrent references spread over multiple loop iterations. We also demonstrate how our algorithms can be adapted for various fine-grain architectures. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> M.E. Benitez and J.W. Davidson, </author> <title> "Code Generation for Streaming: an Access/Execute Mechanism," </title> <booktitle> Proceedings of Arch. Support for Programming Languages and Operating Systems-IV, </booktitle> <pages> pages 132-141, </pages> <year> 1991. </year>
Reference-contexts: In scientific programs, a significant fraction of memory accesses arise from references to array elements. In order to reduce the frequency of these memory references, recent research has also considered the assignment of registers to array elements in inner loops <ref> [1, 3, 4, 10, 11] </ref>. The loop in Fig. 1 (a) contains references that in turn access the same array element over five consecutive loop iterations. The value of an array element flows among the references forming a live range. <p> if (odd (i)) then v use A [i + 3] vii else viii def A [2 fi i] ix endif x def A [i + 4] xi endloop (a) Source loop. 1 load R1, A [4] 2 load R2, A [3] 3 load R3, A [2] 4 load R4, A <ref> [1] </ref> 5 for i in 1 : : : N i 7 use R4 iii 8 if (odd (i)) then iv 9 use R1 v 10 shift R3, R4 11 shift R2, R3 12 def R2 vi 13 store R2, A [i + 3] vi 14 else vii 15 store R1, <p> Placement of register shifts. Array live ranges longer than one iteration are allocated a set of virtual registers which must shift their values once per iteration using register copy operations so that each reference finds its value in the same register during each loop iteration. Existing techniques <ref> [1, 3, 4, 10] </ref> place the shifts at the end of the loop body, as illustrated in Fig. 3 (d). In this example, such a placement requires four copy operations because the iteration boundary crosses the live range four times. <p> The LDS positions are determined in our framework by solving a data flow problem under a numeric chain lattice. The details are beyond the scope of the paper. Streaming in WM <ref> [1] </ref>. The WM architecture provides streaming load/store instructions that enable vector-like access to array elements with a fixed displacement through a FIFO memory queue. <p> As we can see, the length of the stretched loop is typically small. Techniques described in <ref> [1, 3, 10, 11] </ref> do not handle full conditional control flow. The only available method for array PRE is Scalar Replacement of Carr et al. [4]. However, we can obtain a superset of their optimizations.
Reference: 2. <author> R. Bodik and R. Gupta, </author> <title> "Optimal Placement of Load-Store Operations for Array Accesses in Loops," </title> <type> Technical report 95-03, </type> <institution> DCS, Univ. of Pittsburgh, </institution> <year> 1995. </year>
Reference-contexts: iii use A [i] iv if (odd (i)) then v use A [i + 3] vii else viii def A [2 fi i] ix endif x def A [i + 4] xi endloop (a) Source loop. 1 load R1, A [4] 2 load R2, A [3] 3 load R3, A <ref> [2] </ref> 4 load R4, A [1] 5 for i in 1 : : : N i 7 use R4 iii 8 if (odd (i)) then iv 9 use R1 v 10 shift R3, R4 11 shift R2, R3 12 def R2 vi 13 store R2, A [i + 3] vi 14 <p> The bound is low due to typically low values of d max , the length of the longest stretched loop, and d sum , the cumulative length of all stretched loops in the loop, as shown in Sect. 4. The bit-vector implementation and the complexity analysis are elaborated in <ref> [2] </ref>. The framework can also analyze loops with multiple entries and exits.
Reference: 3. <author> D. Callahan, S. Carr, and K. Kennedy, </author> <title> "Improving Register Allocation for Subscripted Variables," </title> <booktitle> Proceedings of the SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <address> White Plains, New York, </address> <pages> pages 53-65, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: In scientific programs, a significant fraction of memory accesses arise from references to array elements. In order to reduce the frequency of these memory references, recent research has also considered the assignment of registers to array elements in inner loops <ref> [1, 3, 4, 10, 11] </ref>. The loop in Fig. 1 (a) contains references that in turn access the same array element over five consecutive loop iterations. The value of an array element flows among the references forming a live range. <p> 1 : : : N iii use A [i] iv if (odd (i)) then v use A [i + 3] vii else viii def A [2 fi i] ix endif x def A [i + 4] xi endloop (a) Source loop. 1 load R1, A [4] 2 load R2, A <ref> [3] </ref> 3 load R3, A [2] 4 load R4, A [1] 5 for i in 1 : : : N i 7 use R4 iii 8 if (odd (i)) then iv 9 use R1 v 10 shift R3, R4 11 shift R2, R3 12 def R2 vi 13 store R2, A <p> Placement of register shifts. Array live ranges longer than one iteration are allocated a set of virtual registers which must shift their values once per iteration using register copy operations so that each reference finds its value in the same register during each loop iteration. Existing techniques <ref> [1, 3, 4, 10] </ref> place the shifts at the end of the loop body, as illustrated in Fig. 3 (d). In this example, such a placement requires four copy operations because the iteration boundary crosses the live range four times. <p> As we can see, the length of the stretched loop is typically small. Techniques described in <ref> [1, 3, 10, 11] </ref> do not handle full conditional control flow. The only available method for array PRE is Scalar Replacement of Carr et al. [4]. However, we can obtain a superset of their optimizations.
Reference: 4. <author> S. Carr and K. Kennedy, </author> <title> "Scalar Replacement in the Presence of Conditional Control Flow," </title> <journal> Software-Practice and Experience, </journal> <volume> Vol. 24, No. 1, </volume> <pages> pages 51-77, </pages> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: In scientific programs, a significant fraction of memory accesses arise from references to array elements. In order to reduce the frequency of these memory references, recent research has also considered the assignment of registers to array elements in inner loops <ref> [1, 3, 4, 10, 11] </ref>. The loop in Fig. 1 (a) contains references that in turn access the same array element over five consecutive loop iterations. The value of an array element flows among the references forming a live range. <p> 1.1 i for i in 1 : : : N iii use A [i] iv if (odd (i)) then v use A [i + 3] vii else viii def A [2 fi i] ix endif x def A [i + 4] xi endloop (a) Source loop. 1 load R1, A <ref> [4] </ref> 2 load R2, A [3] 3 load R3, A [2] 4 load R4, A [1] 5 for i in 1 : : : N i 7 use R4 iii 8 if (odd (i)) then iv 9 use R1 v 10 shift R3, R4 11 shift R2, R3 12 def R2 <p> Placement of register shifts. Array live ranges longer than one iteration are allocated a set of virtual registers which must shift their values once per iteration using register copy operations so that each reference finds its value in the same register during each loop iteration. Existing techniques <ref> [1, 3, 4, 10] </ref> place the shifts at the end of the loop body, as illustrated in Fig. 3 (d). In this example, such a placement requires four copy operations because the iteration boundary crosses the live range four times. <p> Figure 6 illustrates the computation of costs for several cuts of the loop body in Fig. 1 (b). The optimal cut f13; 8g requires two shifts. On the other hand, the approach used by Carr <ref> [4] </ref>, which places the shifts at the end of the loop (i.e, at end), requires four shifts. Prologue and epilogue. <p> To eliminate the register pressure caused by allocating registers to all live ranges, the cost/benefit ratio can be determined for every candidate range, as is done in <ref> [4] </ref>. When only a part of a live range can be allocated registers, the most beneficial segment of the range can be found with a data flow analysis using our framework, as is done for scalars in the load/store range analysis developed by Kolte and Harrold [16]. <p> As we can see, the length of the stretched loop is typically small. Techniques described in [1, 3, 10, 11] do not handle full conditional control flow. The only available method for array PRE is Scalar Replacement of Carr et al. <ref> [4] </ref>. However, we can obtain a superset of their optimizations. For instance, when a congruent definition is killed only outside the stretched loop window, their algorithm considers it to be an unsafe generator for the live range, even though for the register allocation purposes the kill has no effect.
Reference: 5. <author> G.J. Chaitin, </author> <title> "Register Allocation and Spilling via Graph Coloring," </title> <booktitle> Proceedings of the SIGPLAN Symposium on Compiler Construction, SIGPLAN Notices, </booktitle> <volume> vol. 17, no. 6, </volume> <pages> pages 98-105, </pages> <month> June </month> <year> 1982. </year>
Reference-contexts: 1 Introduction The performance of a superscalar processor is adversely affected by frequent references to memory. Therefore, techniques for effective allocation of registers to scalars have received considerable attention <ref> [5] </ref>. In scientific programs, a significant fraction of memory accesses arise from references to array elements. In order to reduce the frequency of these memory references, recent research has also considered the assignment of registers to array elements in inner loops [1, 3, 4, 10, 11].
Reference: 6. <author> T.H. Cormen, C.E. Leiserson, and R.L. Rivest, </author> <title> Introduction to Algorithms, </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: Such set is a generalized dominator [12] of end. The shifts are placed into nodes of set S which minimizes the sum of weighted appearances of its members. The optimal dominator set is identified by means of solving the maximum network flow problem <ref> [6] </ref>. The network flow is defined by setting the flow capacity of every node n to the weighted appearance of the node. <p> In a network with saturated flow, there exists a set of nodes S that cut the loop body such that the maximum flow from start to end is equal to the cumulative flow capacity of the nodes in S <ref> [6] </ref>. Obviously, there is no cut with a lower flow capacity than that of S. Since S collectively dominates end and its cost is the minimum among all cuts, S represents the optimal shift placement. An O (N 3 ) algorithm for the network flow problem exists [6] and, since the <p> nodes in S <ref> [6] </ref>. Obviously, there is no cut with a lower flow capacity than that of S. Since S collectively dominates end and its cost is the minimum among all cuts, S represents the optimal shift placement. An O (N 3 ) algorithm for the network flow problem exists [6] and, since the number of basic blocks in a loop is typically very small, the algorithm is practical for our purposes.
Reference: 7. <author> J.C. Dehnert, P.Y.-T. Hsu, and J.P. Bratt, </author> <title> "Overlapped Loop Support in the Cydra 5," </title> <booktitle> Proceedings of ASPLOS-III, </booktitle> <pages> pages 26-39, </pages> <year> 1989. </year>
Reference-contexts: This can be verified from the positions of the loads by a data flow analysis within our framework. Cyclic Register Files in Cydra 5 <ref> [7] </ref>. The design of Cydra 5 [7] took into consideration array register allocation and provided a cyclic register file in which it is possible to shift the contents of a subset of registers in one cycle. <p> This can be verified from the positions of the loads by a data flow analysis within our framework. Cyclic Register Files in Cydra 5 <ref> [7] </ref>. The design of Cydra 5 [7] took into consideration array register allocation and provided a cyclic register file in which it is possible to shift the contents of a subset of registers in one cycle.
Reference: 8. <author> D.M. Dhamdhere, </author> <title> "Practical Adaptation of the Global Optimization Algorithm of Morel and Renvoise," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Volume 13, No. 2, </volume> <pages> pages 291-294, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: In contrast, load placement which does not consider PRE and PDE of memory references would perform 2 loads and 2 stores. Existing PRE and PDE techniques have primarily focussed on scalars and thus they do not perform optimization of array references over multiple loop iterations <ref> [8, 9, 15, 17] </ref>. 1.3 2 Analyzing Congruent References This section presents the data flow analysis framework. The analysis considers a group of array references that refer to the same array element during the execution of one or more consecutive loop iterations. <p> The algorithms are applied with respect to a given branching structure and code ordering, that is, we do not modify the branching structure or reorder program statements during these algorithms. However, since arbitrary graphs may prevent code placement optimizations, a dummy node is inserted along every critical edge 2 <ref> [8, 15] </ref>. Load Placement. The main objective of this step is to identify points at which the placement of loads does not introduce partial redundancy.
Reference: 9. <author> D.M. Dhamdhere, B.K. Rosen and F.K. Zadeck, </author> <title> "How to Analyze Large Programs Efficiently and informatively," </title> <booktitle> Proc. of the SIGPLAN PLDI, </booktitle> <address> San Francisco, </address> <publisher> Cali-fornia, </publisher> <pages> pages 212-223, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: In contrast, load placement which does not consider PRE and PDE of memory references would perform 2 loads and 2 stores. Existing PRE and PDE techniques have primarily focussed on scalars and thus they do not perform optimization of array references over multiple loop iterations <ref> [8, 9, 15, 17] </ref>. 1.3 2 Analyzing Congruent References This section presents the data flow analysis framework. The analysis considers a group of array references that refer to the same array element during the execution of one or more consecutive loop iterations.
Reference: 10. <author> E. Duesterwald, R. Gupta, </author> <title> and M.L. Soffa, "Register Pipelining: An Integrated Approach to Register Allocation for Scalar and Subscripted Variables," </title> <booktitle> Proc. of International Workshop on Compiler Construction, </booktitle> <publisher> LNCS 641 Springer Verlag, </publisher> <pages> pages 192-206, </pages> <address> Paderborn, Germany, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: In scientific programs, a significant fraction of memory accesses arise from references to array elements. In order to reduce the frequency of these memory references, recent research has also considered the assignment of registers to array elements in inner loops <ref> [1, 3, 4, 10, 11] </ref>. The loop in Fig. 1 (a) contains references that in turn access the same array element over five consecutive loop iterations. The value of an array element flows among the references forming a live range. <p> Placement of register shifts. Array live ranges longer than one iteration are allocated a set of virtual registers which must shift their values once per iteration using register copy operations so that each reference finds its value in the same register during each loop iteration. Existing techniques <ref> [1, 3, 4, 10] </ref> place the shifts at the end of the loop body, as illustrated in Fig. 3 (d). In this example, such a placement requires four copy operations because the iteration boundary crosses the live range four times. <p> As we can see, the length of the stretched loop is typically small. Techniques described in <ref> [1, 3, 10, 11] </ref> do not handle full conditional control flow. The only available method for array PRE is Scalar Replacement of Carr et al. [4]. However, we can obtain a superset of their optimizations.
Reference: 11. <author> E. Duesterwald, R. Gupta, </author> <title> and M.L. Soffa, "A Practical Data Flow Framework for Array Reference Analysis and its Application in Optimizations," </title> <booktitle> Proc. of ACM SIG-PLAN Conference on Programming Language Design and Implementation, </booktitle> <address> pp.68-77, Albuquerque, New Mexico, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: In scientific programs, a significant fraction of memory accesses arise from references to array elements. In order to reduce the frequency of these memory references, recent research has also considered the assignment of registers to array elements in inner loops <ref> [1, 3, 4, 10, 11] </ref>. The loop in Fig. 1 (a) contains references that in turn access the same array element over five consecutive loop iterations. The value of an array element flows among the references forming a live range. <p> Due to these properties, the framework exposes precise collective behavior of the recurrent references to which a register pipeline will be allocated. Our work was inspired by the framework of Duesterwald <ref> [11] </ref> which is based on reference analysis and thus is not capable of determining that two references may in concert generate the same value. To overcome this deficiency, we base our framework on value analysis. <p> The value of k s r can be computed using the simple approach suggested in <ref> [11] </ref>, which is equivalent to computing line intersection. If k s r is 1, then there is no dependence between references r and s. <p> As we can see, the length of the stretched loop is typically small. Techniques described in <ref> [1, 3, 10, 11] </ref> do not handle full conditional control flow. The only available method for array PRE is Scalar Replacement of Carr et al. [4]. However, we can obtain a superset of their optimizations.
Reference: 12. <author> R. Gupta, </author> <title> "Generalized Dominators and Post-Dominators," </title> <booktitle> The Nineteenth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 246-257, </pages> <address> Albuquerque, New Mexico, </address> <month> January </month> <year> 1992. </year>
Reference-contexts: A set of nodes S is a valid candidate for the placement of shifts if exactly one node from S is encountered along any path through the loop body. Such set is a generalized dominator <ref> [12] </ref> of end. The shifts are placed into nodes of set S which minimizes the sum of weighted appearances of its members. The optimal dominator set is identified by means of solving the maximum network flow problem [6].
Reference: 13. <author> L. Hendren, G.R. Gao, E.R. Altman, and C. Mukerji, </author> <title> "A Register Allocation Framework based upon Hierarchical Cyclic Interval Graphs," </title> <booktitle> Intnl. Workshop on 1.16 Compiler Construction, </booktitle> <publisher> LNCS 641 Springer Verlag, </publisher> <pages> pages 176-191, </pages> <address> Germany, </address> <year> 1992. </year>
Reference-contexts: Corresponding to a load, store, and shift placement, the number of virtual registers introduced for a given live range is minimal. Furthermore, the scalar ranges created through the use of virtual registers will be precisely identifi able by a scalar register allocator such as the one presented in <ref> [13] </ref>. <p> For instance, in Fig. 1 (b) lines 16 and 17 use register R2 allocated to the congruent live range. Since the resulting scalar live ranges cross iterations, the allocator developed by Hendren et al. <ref> [13] </ref> is very suitable for subsequent register allocation. To eliminate the register pressure caused by allocating registers to all live ranges, the cost/benefit ratio can be determined for every candidate range, as is done in [4]. <p> Register placement of nested loops is performed in the manner similar to that of <ref> [13] </ref>, starting from the innermost loop and working outward.
Reference: 14. <author> V. Kathail, M. Schlansker, and B. Rau, </author> <title> HPL PlayDoh Architecture Specification: </title> <note> Version 1.0, HPL-93-80, </note> <month> February, </month> <year> 1994. </year>
Reference-contexts: Then, the final solution for node n i is given by IN [n][i] = max (IN 0 [n][i]; IN T [n][i] (T IN [start][i])). This formula is used to modify Steps II and III of Fig. 4 (b). 3.3 Exploiting Fine-Grain Architectures. Data Speculative Load in PlayDoh <ref> [14] </ref>. The algorithm inserts a load after every killing reference that appears in the live range of the congruent value. This load updates the register pipeline in case the killing reference wrote to a memory location that is being stored in a pipeline register. <p> Since upward movement of such a load is not possible, the load latency may complicate scheduling. In this subsection we discuss the utilization of an existing run-time memory disambiguation mechanism <ref> [14] </ref> for eliminating the load latency and propose a modification to the mechanism. 1.13 1 do i = 1, n 2 store R1, A [i] 3 store R2, A [f (i)] 4 load R3, A [i] 5 end do (a) Load after a kill. 1 do i = 1, n 2 <p> Fig. 7. The use of data speculative load. In Fig. 7 (a) the live range of the value A [i] is split by the definition of A [f (i)] and thus a load must be placed at line 4. The PlayDoh architecture <ref> [14] </ref> offers data speculative load (LDS) and load verification (LDV) instructions that can eliminate latency of the load as is shown in Fig. 7 (b).
Reference: 15. <author> J. Knoop, O. Ruthing, and B. Steffen, </author> <title> "Optimal Code Motion: </title> <journal> Theory and Practice," ACM TOPLAS, </journal> <volume> vol. 16, num. 4, </volume> <pages> 1117-1155. </pages>
Reference-contexts: In contrast, load placement which does not consider PRE and PDE of memory references would perform 2 loads and 2 stores. Existing PRE and PDE techniques have primarily focussed on scalars and thus they do not perform optimization of array references over multiple loop iterations <ref> [8, 9, 15, 17] </ref>. 1.3 2 Analyzing Congruent References This section presents the data flow analysis framework. The analysis considers a group of array references that refer to the same array element during the execution of one or more consecutive loop iterations. <p> This form of optimality is a direct consequence of employing a formulation for partial redundancy elimination developed by Knoop et al. <ref> [15] </ref>. 2. The lengths of array live ranges are minimal, that is, the lengths cannot be shortened without introducing additional memory references. 3. <p> The algorithms are applied with respect to a given branching structure and code ordering, that is, we do not modify the branching structure or reorder program statements during these algorithms. However, since arbitrary graphs may prevent code placement optimizations, a dummy node is inserted along every critical edge 2 <ref> [8, 15] </ref>. Load Placement. The main objective of this step is to identify points at which the placement of loads does not introduce partial redundancy. <p> An approach for eliminating partially redundant scalar expressions was developed by 2 A critical edge is an edge leading from a node with more than one successor to a node with more than one predecessor. 1.8 Knoop et al. <ref> [15] </ref>. This approach is adapted for application to loads for array references by utilizing the framework introduced in the preceding section.
Reference: 16. <author> P. Kolte and M.J. Harrold, </author> <title> "Load/Store Range Analysis for Global Register Allocation," </title> <booktitle> Proc. of the SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <address> Albuquerque, New Mexico, </address> <pages> pages 268-277, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: When only a part of a live range can be allocated registers, the most beneficial segment of the range can be found with a data flow analysis using our framework, as is done for scalars in the load/store range analysis developed by Kolte and Harrold <ref> [16] </ref>. Register placement of nested loops is performed in the manner similar to that of [13], starting from the innermost loop and working outward.
Reference: 17. <author> E. Morel and C. </author> <title> Renvoise, "Global Optimization by Suppression of Partial Redundancies," </title> <journal> Communications of the ACM, </journal> <volume> Volume 22, No. 2, </volume> <pages> pages 96-103, </pages> <year> 1979. </year>
Reference-contexts: In contrast, load placement which does not consider PRE and PDE of memory references would perform 2 loads and 2 stores. Existing PRE and PDE techniques have primarily focussed on scalars and thus they do not perform optimization of array references over multiple loop iterations <ref> [8, 9, 15, 17] </ref>. 1.3 2 Analyzing Congruent References This section presents the data flow analysis framework. The analysis considers a group of array references that refer to the same array element during the execution of one or more consecutive loop iterations.
Reference: 18. <author> M. Wolfe and U. Banerjee, </author> <title> "Data Dependence and Its Application to Parallel Processing," </title> <journal> Intl. Journal of Parallel Programming, </journal> <volume> Vol. 16, No. 2, </volume> <month> April </month> <year> 1987. </year> <title> This article was processed using the L a T E X macro package with LLNCS style 1.17 </title>
Reference-contexts: If k s r is 1, then there is no dependence between references r and s. On systems with full dependence analysis, accuracy of a finite k s r is verified by any data dependence test such as the gcd test <ref> [18] </ref>. 1.6 procedure Specialize for every reference r 2 GEN C for every i 2 positions C (r) add r to GEN C for every reference r 2 KILL C for every i 2 positions C (r) add r to KILL C i function positions C (r) if r 2 C
References-found: 18

