URL: ftp://ftp.cs.virginia.edu/pub/techreports/CS-97-26.ps.Z
Refering-URL: ftp://ftp.cs.virginia.edu/pub/techreports/README.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: Email: -nguyen grimshaw-@virgina.edu  
Title: Building robust distributed applications with reflective transformations Building Robust Distributed Applications With Reflective Transformations 1  
Author: Anh Nguyen-Tuong and Andrew S. Grimshaw 
Keyword: worldwide virtual computer, metacomputing, metasystems, fault-tolerance, reflection, reflective transformations  
Address: Charlottesville VA 22903  
Affiliation: Department of Computer Science University of Virginia  
Pubnum: Technical Report CS-97-26  
Abstract: Several projects are currently underway to build the nations next generation computing infrastructure. These projects are sometimes called metasystems projects and seek to provide the illusion of a single, unified, virtual computing environment to end users. We expect metasystems to consist of millions of hosts and billions of objects, and on this scale, resource failures will be the norm and no longer the exception. One of the technical challenges that must be solved before such systems become usable is the widespread adoption of fault-tolerance techniques for both system level services and user applications. As part of the Legion metasystem project, we have developed an architecture for incorporating fault-tolerance techniques into user applications. Our approach is based on reflective dynamic transformation techniques that manipulate the control and data flow characteristics of an application to achieve the desired fault-tolerance policies. In this paper, we present our Reflective Graph & Event model (RGE) computation model and illustrate sample reflective transformations for incorporating exception handling and replication techniques into applications. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. Agha, D. C. Sturman, </author> <title> A Methodology for Adapting Patterns of Faults, Foundations of Dependable Computing: Models and Frameworks for Dependable Systems , Kluwer Academic Publishers, </title> <journal> Vol. </journal> <volume> 1, </volume> <pages> pp. 23-60, </pages> <year> 1994. </year>
Reference-contexts: While others have proposed using reflection as the basis for building robust applications <ref> [1] </ref>[16][39], these works have focussed on specific fault-tolerance techniques such as replication [16] or providing persistence [39]. [1] is a notable exception and its architecture provides support for both exception handling and replication. In this paper, we specify a novel reflective computational model, the Reflective Graph & Event Model (RGE), that differs from previous works in its scope and the information that it reflects to protocol writers. <p> systems <ref> [1] </ref>[16][29][39]. Its use has also been advocated for the next generation of real-time global databases [46]. In [29][39], the Common List Object System (CLOS) [28] is extended to support persistence using reflection. In [16], reflective features of the language open-C++ are used to implement replication techniques for objects. MAUD [1] is a metalevel architecture for building adaptively dependable systems that has been implemented on an actor-based system. While these systems demonstrate the feasibility of using reflection as an enabling technology for structuring robust applications, the question as to what information should be reflected is an open one. <p> In [16], the authors note that using inheritance alone poses problem for integrating replication techniques into user applications as standard objectoriented programming languages do not allow protocol writers to modify the method invocation dispatch mechanism. In <ref> [1] </ref>, the authors observe that traditional metaobject protocols such as the one in [16] do not have explicit representations for the control flow of objects. The RGE model directly addresses both issues. DOME provides a set of predefined classes to support data-parallel computations. <p> Examples of such languages include Ada [14], C++ [51], CLU [30]. While we draw inspiration from these works, we differ from these in that our exception propagation model is not languagespecific. We make a distinction between exception handling (as espoused by a specific programming language) versus exception propagation. In <ref> [1] </ref>, the authors distinguish between two and three-party systems with respect to exception handling. In a two-party system, exception handling routines are defined within the scope of invoking objects (invoker and signaler) whereas in a three-party system, the handler may be independent of the call chain.
Reference: [2] <author> O. Babaoglu et. al., </author> <title> "Paralex: An Environment for Parallel Programming in Distributed Systems", </title> <type> Technical Report UBLCS-92-4, </type> <institution> Laboratory for Computer Science, University of Bologna, </institution> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: MDF is the basis for Mentat [22], a high-performance object-oriented system, as well as its successor, Legion, a worldwide metasystem software project. The functional nature of the data-flow model lends itself well to fault-tolerance techniques <ref> [2] </ref>[26][37]. Other coarse-grained data-flow systems include Paralex [2], CDF [3], HeNCE [6], Code/Rope [12]. Our choice of MDF as a starting point for the RGE model stems from the fact that MDF is a proven model and further, it has a notion of persistent actors actors that maintain state information between method invocations.
Reference: [3] <author> R. F. Babb, </author> <title> Parallel Processing with Large-Grain Data Flow Techniques, </title> <booktitle> IEEE Computer, </booktitle> <pages> pp. 55-61, </pages> <month> July </month> <year> 1984. </year>
Reference-contexts: MDF is the basis for Mentat [22], a high-performance object-oriented system, as well as its successor, Legion, a worldwide metasystem software project. The functional nature of the data-flow model lends itself well to fault-tolerance techniques [2][26][37]. Other coarse-grained data-flow systems include Paralex [2], CDF <ref> [3] </ref>, HeNCE [6], Code/Rope [12]. Our choice of MDF as a starting point for the RGE model stems from the fact that MDF is a proven model and further, it has a notion of persistent actors actors that maintain state information between method invocations.
Reference: [4] <author> T. Becker, </author> <booktitle> Application-Transparent Fault Tolerance in Distributed Systems , Proceedings of the 2 nd International Workshop on Configurable Distributed Systems, </booktitle> <pages> pp. 36-45, </pages> <year> 1994. </year>
Reference-contexts: For example, Fault-Tolerant Mach [44] uses the concept of sentries to intercept calls between the application layer and the Mach system services. In <ref> [4] </ref>, the author proposes a fault-tolerance layer that exports the same interface as the underlying operating system. In [36], the authors exploit the Internet Inter-Orb Protocol Interface (IIOP) to extend CORBA with fault-tolerance based on replication techniques.
Reference: [5] <author> A. Beguelin, et. al., </author> <title> Application Level Fault Tolerance in Heterogenous Networks of Workstations, </title> <note> to appear in a special issue of the Journal of Parallel and Distributed Computing on Workstation Clusters and Network-based Computing, </note> <month> September </month> <year> 1997. </year>
Reference-contexts: Arjuna [49], Avalon/C++ [15], DOME <ref> [5] </ref>, BAST [19] are examples of systems that take this approach. In [16], the authors note that using inheritance alone poses problem for integrating replication techniques into user applications as standard objectoriented programming languages do not allow protocol writers to modify the method invocation dispatch mechanism.
Reference: [6] <author> A. Beguelin et. al., </author> <title> HeNCE: Graphical Development Tools for Network-Based Concurrent Computing, </title> <booktitle> Proceedings SHPCC-92, </booktitle> <pages> pp. 129-36, </pages> <address> Williamsburg, VA, </address> <month> May </month> <year> 1992. </year>
Reference-contexts: MDF is the basis for Mentat [22], a high-performance object-oriented system, as well as its successor, Legion, a worldwide metasystem software project. The functional nature of the data-flow model lends itself well to fault-tolerance techniques [2][26][37]. Other coarse-grained data-flow systems include Paralex [2], CDF [3], HeNCE <ref> [6] </ref>, Code/Rope [12]. Our choice of MDF as a starting point for the RGE model stems from the fact that MDF is a proven model and further, it has a notion of persistent actors actors that maintain state information between method invocations.
Reference: [7] <author> R. Ben-Natan, </author> <title> CORBA: A Guide to the Common Object Request Broker Architecture , McGraw Hill, </title> <year> 1995. </year>
Reference-contexts: The RGE model captures just that information and exports it to protocol writers through first-class program graphs and events. Many distributed systems are already in some degrees reflective. CORBAs Dynamic Invocation Interface <ref> [7] </ref>, Microsofts Distributed Component Object Model (DCOM) [11], Javas Core Reflection API [34] all provide dynamic access to the methods and signatures exported by objects.
Reference: [8] <author> B. Bershad et. al., </author> <title> Extensibility, Safety and Performance in the SPIN Operating System, </title> <booktitle> Proceedings of the 15 th ACM Symposium on Operating System Principles (SOSP-15) , pp. </booktitle> <pages> 267-284, </pages> <address> Copper Mountain, CO, </address> <year> 1995. </year>
Reference-contexts: We focus on reflective transformations that manipulate the control and data-flow of objects and applications to obtain a desired fault-tolerance policy, and hence could easily incorporate group communication primitives as part of our transformations. 2.4 Reflection Reflection has been used successfully in several contexts, including operating systems <ref> [8] </ref>, programming languages [16][28], and in the construction of dependable systems [1][16][29][39]. Its use has also been advocated for the next generation of real-time global databases [46]. In [29][39], the Common List Object System (CLOS) [28] is extended to support persistence using reflection.
Reference: [9] <author> N. T. Bhatti, et. al., Coyote: </author> <title> A System for Constructing Fine-Grain Configurable Communication Services, </title> <institution> Department of Computer Science Technical Report TR 97-12 , University of Arizona, </institution> <month> July </month> <year> 1997. </year>
Reference-contexts: We argue that these models should possess reflective capabilities similar to those found in our RGE model. 2.2 Events The event paradigm is well established and many systems use it as the basis for extensibility, i.e. Coyote <ref> [9] </ref>, the Java Bean Component Model [24], SPIN [40], Legion [53]. While the RGE model does not mandate that objects be implemented using events, a natural implementation of RGE would use a system that is event-driven such as the protocol stack of objects in Legion. <p> Examples of such systems include Amoeba [27], Coyote <ref> [9] </ref>, Delta-4 [41], Isis [10], Horus [43], and Totem [35]. These systems are also known as CATOCS (causally and totally ordered communication systems) and provide varying degrees of ordering properties in the presence of failures.
Reference: [10] <author> K. P. Birman and R. V. Renesse, </author> <title> Reliable Distributed Computing with the Isis Toolkit , IEEE Computer Society Press, </title> <publisher> Los Alamitos, </publisher> <address> California, </address> <year> 1994. </year>
Reference-contexts: Examples of such systems include Amoeba [27], Coyote [9], Delta-4 [41], Isis <ref> [10] </ref>, Horus [43], and Totem [35]. These systems are also known as CATOCS (causally and totally ordered communication systems) and provide varying degrees of ordering properties in the presence of failures.
Reference: [11] <author> N. Brown and C. Kindel, </author> <title> Distributed Component Object Model Protocol DCOM/1.0, http://www.microsoft.com/oledev/olecom/, Internet Draft, </title> <month> May </month> <year> 1996. </year>
Reference-contexts: The RGE model captures just that information and exports it to protocol writers through first-class program graphs and events. Many distributed systems are already in some degrees reflective. CORBAs Dynamic Invocation Interface [7], Microsofts Distributed Component Object Model (DCOM) <ref> [11] </ref>, Javas Core Reflection API [34] all provide dynamic access to the methods and signatures exported by objects.
Reference: [12] <author> J. C. Browne, T. Lee and J. Werth, </author> <title> Experimental Evaluation of a Reusability-Oriented Parallel Programming Environment, </title> <journal> IEEE Transactions on Software Engineering , pp. </journal> <pages> 111-120, </pages> <month> February </month> <year> 1990. </year>
Reference-contexts: MDF is the basis for Mentat [22], a high-performance object-oriented system, as well as its successor, Legion, a worldwide metasystem software project. The functional nature of the data-flow model lends itself well to fault-tolerance techniques [2][26][37]. Other coarse-grained data-flow systems include Paralex [2], CDF [3], HeNCE [6], Code/Rope <ref> [12] </ref>. Our choice of MDF as a starting point for the RGE model stems from the fact that MDF is a proven model and further, it has a notion of persistent actors actors that maintain state information between method invocations.
Reference: [13] <author> D. Cheriton and D. Skeen, </author> <title> Understanding the Limitations of Causally and Totally Ordered Communication, </title> <booktitle> Proceedings of the Thirteenth ACM Symposium on Operating Systems Principles (SOSP-13), </booktitle> <address> New York, </address> <publisher> ACM Press, </publisher> <pages> pp. 44-57, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: These systems are also known as CATOCS (causally and totally ordered communication systems) and provide varying degrees of ordering properties in the presence of failures. This class of systems has been the source of much controversy and has been criticized on the basis of the end-to-end argument <ref> [13] </ref>. The basic argument against CATOCS revolves around the tradeoffs and mismatches between the needs of user applications and the costs of guaranteeing ordering property applications that do not require CATOCS should not have to pay for it.
Reference: [14] <author> Q. Cui and J. Gannon, </author> <booktitle> Data-Oriented Exception Handling in Ada , IEEE Transactions on Software Engineering, </booktitle> <pages> pp. 98-106, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: System builders such as language designers and compiler writers can use the RGE model as their implementation model and then export their own API to end users. 2.7 Exception handling Exception handling in sequential programming languages is a well-understood area [17][20]. Examples of such languages include Ada <ref> [14] </ref>, C++ [51], CLU [30]. While we draw inspiration from these works, we differ from these in that our exception propagation model is not languagespecific. We make a distinction between exception handling (as espoused by a specific programming language) versus exception propagation.
Reference: [15] <author> D. L. Detlefs, M. P. Herlihy and J. M. Wing, </author> <title> Inheritance of Synchronization and Recovery Properties in Avalon/C++, </title> <booktitle> IEEE Computer, </booktitle> <pages> pp. 57-69, </pages> <month> December </month> <year> 1988. </year>
Reference-contexts: Viewed in this manner, the RGE model could be described as the specification of a middleware architecture for building robust applications. 2.6 Fault-tolerance encapsulated in objects An approach to providing fault-tolerance at the user level is to use the objectoriented paradigm to encapsulate fault-tolerance properties. Arjuna [49], Avalon/C++ <ref> [15] </ref>, DOME [5], BAST [19] are examples of systems that take this approach. In [16], the authors note that using inheritance alone poses problem for integrating replication techniques into user applications as standard objectoriented programming languages do not allow protocol writers to modify the method invocation dispatch mechanism.
Reference: [16] <author> J. C. Fabre et. al., </author> <title> Implementing Fault Tolerant Applications using Reflective ObjectOriented Programming, </title> <booktitle> The Twenty-fifth Symposium on Fault-Tolerant Computing (FTCS-25) , pp. </booktitle> <pages> 489-498, </pages> <year> 1995. </year>
Reference-contexts: While others have proposed using reflection as the basis for building robust applications [1]<ref> [16] </ref>[39], these works have focussed on specific fault-tolerance techniques such as replication [16] or providing persistence [39]. [1] is a notable exception and its architecture provides support for both exception handling and replication. <p> in several contexts, including operating systems [8], programming languages <ref> [16] </ref>[28], and in the construction of dependable systems [1][16][29][39]. Its use has also been advocated for the next generation of real-time global databases [46]. In [29][39], the Common List Object System (CLOS) [28] is extended to support persistence using reflection. In [16], reflective features of the language open-C++ are used to implement replication techniques for objects. MAUD [1] is a metalevel architecture for building adaptively dependable systems that has been implemented on an actor-based system. <p> Arjuna [49], Avalon/C++ [15], DOME [5], BAST [19] are examples of systems that take this approach. In <ref> [16] </ref>, the authors note that using inheritance alone poses problem for integrating replication techniques into user applications as standard objectoriented programming languages do not allow protocol writers to modify the method invocation dispatch mechanism. In [1], the authors observe that traditional metaobject protocols such as the one in [16] do not <p> In <ref> [16] </ref>, the authors note that using inheritance alone poses problem for integrating replication techniques into user applications as standard objectoriented programming languages do not allow protocol writers to modify the method invocation dispatch mechanism. In [1], the authors observe that traditional metaobject protocols such as the one in [16] do not have explicit representations for the control flow of objects. The RGE model directly addresses both issues. DOME provides a set of predefined classes to support data-parallel computations.
Reference: [17] <author> F. Christian, </author> <title> Exception Handling and Tolerance of Software Faults , Software Fault Tolerance , M. Lyu Editor, </title> <publisher> Wiley, </publisher> <year> 1995, </year> <pages> pp. 81-107. </pages>
Reference-contexts: In the next section, we illustrate an exception propagation model that fully exploits both aspects of the RGE model. 5 Exception Propagation Model Exceptions have been proposed as a structuring mechanism for building distributed robust applications <ref> [17] </ref> as they provide a mechanism for error detection and recovery. We now present a novel exception propagation model based on the RGE model. We distinguish between exception propagation and exception handling. <p> This style of programming wherein computations are implemented with a series of client/server calls and wherein exceptions are masked in a hierarchical fashion is standard <ref> [17] </ref>. 5.2.1 Selective masking of exceptions In the examples thus far, objects have been interested in all exceptions. This need not be the case. For example, consider the example wherein a client is interested in math exceptions while the server object is interested only in security exceptions.
Reference: [18] <author> I. Foster and C. Kesselman, Globus: </author> <title> A metacomputing infrastructure toolkit, </title> <journal> International Journal of Supercomputing Applications, </journal> <year> 1997. </year> <title> Building robust distributed applications with reflective transformations </title>
Reference-contexts: We conclude and present future works in section 7. 2 Related Work To date no metasystems exist on a large scale except perhaps for the World Wide Web. Several projects are under way to build a metasystem, including Globus <ref> [18] </ref>, Globe [50] and Legion [21]. While all recognize the need for fault-tolerance, specific details are sketchy or nonexistent. The RGE model addresses the issue of incorporating fault-tolerance into applications and suggests a way of structuring robust distributed applications.
Reference: [19] <author> B. Garbinato, P. Felber and R. Guerraoui, </author> <title> Modeling Protocols as Objects for Structuring Reliable Distributed Systems, </title> <booktitle> Proceedings of the Communications Networks and Distributed Systems Modeling and Simulation Conference (CNDS'97), </booktitle> <address> Phoenix, Arizona, </address> <month> January </month> <year> 1997. </year>
Reference-contexts: Arjuna [49], Avalon/C++ [15], DOME [5], BAST <ref> [19] </ref> are examples of systems that take this approach. In [16], the authors note that using inheritance alone poses problem for integrating replication techniques into user applications as standard objectoriented programming languages do not allow protocol writers to modify the method invocation dispatch mechanism.
Reference: [20] <author> J. B. Goodenough, </author> <title> Exception Handling: Issues and a Proposed Notation , Communications of the ACM, </title> <booktitle> 18:12, </booktitle> <pages> pp. 683-696, </pages> <month> December </month> <year> 1975. </year>
Reference: [21] <author> A. S. Grimshaw, </author> <title> The Legion vision of a worldwide virtual computer, </title> <journal> Communications of the ACM , 40:1, </journal> <pages> pp. 39-45, </pages> <month> January </month> <year> 1997. </year>
Reference-contexts: Fault-tolerance protocols are regarded widely as complex and difficult to implement correctly, and when one factors in the complexity of writing distributed or parallel applications (without regards to any fault-tolerance), the magnitude of the problem becomes evident. As part of the Legion metacomputing project <ref> [21] </ref>, we have developed an architecture for incorporating fault-tolerance techniques into user applications. Our approach is based on dynamic transformation techniques that manipulate the control and data flow characteristics of an application to achieve the desired fault-tolerance policies. <p> We conclude and present future works in section 7. 2 Related Work To date no metasystems exist on a large scale except perhaps for the World Wide Web. Several projects are under way to build a metasystem, including Globus [18], Globe [50] and Legion <ref> [21] </ref>. While all recognize the need for fault-tolerance, specific details are sketchy or nonexistent. The RGE model addresses the issue of incorporating fault-tolerance into applications and suggests a way of structuring robust distributed applications. Note that in many instances, system-level services provided by metasystems are themselves applications.
Reference: [22] <author> A. S. Grimshaw, A. Ferrari and E. West, </author> <title> Mentat, Parallel Programming Using C++ , The MIT Press, </title> <address> Cambridge, Massachusetts, </address> <pages> pp. 383-427, </pages> <year> 1996. </year>
Reference-contexts: MDF is the basis for Mentat <ref> [22] </ref>, a high-performance object-oriented system, as well as its successor, Legion, a worldwide metasystem software project. The functional nature of the data-flow model lends itself well to fault-tolerance techniques [2][26][37]. Other coarse-grained data-flow systems include Paralex [2], CDF [3], HeNCE [6], Code/Rope [12].
Reference: [23] <author> A. S. Grimshaw, J. B. Weissman and T. Strayer, </author> <title> Portable RunTime Support for Dynamic Object-Oriented Parallel Processing, </title> <institution> Technical Report CS-93-40 , Department of Computer Science, University of Virginia, </institution> <month> July 14, </month> <year> 1993. </year>
Reference-contexts: Works on graph-based models ( 2.1), event-based models ( 2.2), reflective systems ( 2.4), and, in general, other approaches ( 2.3, 2.5, 2.6, 2.7) to support the construction of robust distributed applications, are all relevant to our own. 2.1 Data-Flow RGE uses the Macro-Data Flow (MDF) model <ref> [23] </ref> as the basis for specifying control-flow and data-dependence information between objects. MDF is the basis for Mentat [22], a high-performance object-oriented system, as well as its successor, Legion, a worldwide metasystem software project. The functional nature of the data-flow model lends itself well to fault-tolerance techniques [2][26][37]. <p> MDF graphs are first-class entities. They may be manipulated and transformed and hence enable the construction of generic graph transformers. We provide a very brief review of MDF and of our extensions. Interested readers may refer to the literature for a thorough description <ref> [23] </ref>. Program graphs model computations in MDF. Graph nodes are called actors and represent method invocations on objects 2 ; arcs denote data-dependencies between actors; and tokens flowing arcs represent data or control information.
Reference: [24] <author> G. </author> <title> Hamilton (editor), JavaBeans, http://splash.javasoft.com/beans/docs/spec.html, Sun Microsystems, </title> <month> July </month> <year> 1997. </year>
Reference-contexts: We argue that these models should possess reflective capabilities similar to those found in our RGE model. 2.2 Events The event paradigm is well established and many systems use it as the basis for extensibility, i.e. Coyote [9], the Java Bean Component Model <ref> [24] </ref>, SPIN [40], Legion [53]. While the RGE model does not mandate that objects be implemented using events, a natural implementation of RGE would use a system that is event-driven such as the protocol stack of objects in Legion. <p> Building robust distributed applications with reflective transformations 4.2 Reflective Events The event paradigm is well-understood and has been applied successfully in such diverse areas as windowing systems [38], extensible kernel systems [40], component based systems <ref> [24] </ref>, and the building of flexible protocol stacks [9][53]. Here, we advocate the use of the event paradigm for building reflective fault-tolerance components for distributed systems.
Reference: [25] <institution> Iona Ltd. And Isis Distributed Systems, Inc., </institution> <note> An Introduction to Orbix+Isis, 1995. Available at info@iona.ie. </note>
Reference-contexts: In [36], the authors exploit the Internet Inter-Orb Protocol Interface (IIOP) to extend CORBA with fault-tolerance based on replication techniques. In [48], the authors specify a replication service for CORBA using a primary/backup scheme. Electra [32][33] Building robust distributed applications with reflective transformations and Orbix+ISIS <ref> [25] </ref> are both CORBA-compliant systems that provide fault-tolerance using groups and group communication primitives (section 2.3). Implicit in all these approaches is the definition of a sufficient set of information that needs to be intercepted, i.e. available, in order to implement a set of fault-tolerance policies.
Reference: [26] <author> R. Jagannathan and E. A. Ashcroft, </author> <title> Fault Tolerance in Parallel Implementations of Functional Languages, </title> <booktitle> The Twenty-first Symposium on Fault-Tolerance Computing (FTCS-21) , pp. </booktitle> <pages> 256-263, </pages> <year> 1991. </year>
Reference: [27] <author> M. F. Kaashoek and A. S. Tanenbaum, </author> <title> Group communication in the Amoeba distributed operating system, </title> <booktitle> Proceedings of the 11 th IEEE International Conference on Distributed Computing Systems , pp. </booktitle> <pages> 222-230, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Furthermore, the RGE model specifies a correspondence between the internal implementation (events) of an object and its external data and control-flow (graphs). 2.3 Group communication Multicast group communication primitives have been proposed as a useful foundation on which to build robust systems. Examples of such systems include Amoeba <ref> [27] </ref>, Coyote [9], Delta-4 [41], Isis [10], Horus [43], and Totem [35]. These systems are also known as CATOCS (causally and totally ordered communication systems) and provide varying degrees of ordering properties in the presence of failures.
Reference: [28] <author> G. Kiczales, J. D. Rivieres and D. G. Bobrow, </author> <title> The Art of the Metaobject Protocol, </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: our transformations. 2.4 Reflection Reflection has been used successfully in several contexts, including operating systems [8], programming languages [16]<ref> [28] </ref>, and in the construction of dependable systems [1][16][29][39]. Its use has also been advocated for the next generation of real-time global databases [46]. In [29][39], the Common List Object System (CLOS) [28] is extended to support persistence using reflection. In [16], reflective features of the language open-C++ are used to implement replication techniques for objects. MAUD [1] is a metalevel architecture for building adaptively dependable systems that has been implemented on an actor-based system.
Reference: [29] <author> A. H. Lee and J. L. </author> <title> Zachary, </title> <journal> Reflections on metaprogramming , IEEE Transactions on Software Engineering, </journal> <volume> vol. 21, </volume> <pages> pp. 883-892, </pages> <month> November </month> <year> 1995. </year>
Reference: [30] <author> B. Liskov and A. Snyder, </author> <title> Exception Handling in CLU, </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pp. 546-558, </pages> <month> November </month> <year> 1979. </year>
Reference-contexts: Examples of such languages include Ada [14], C++ [51], CLU <ref> [30] </ref>. While we draw inspiration from these works, we differ from these in that our exception propagation model is not languagespecific. We make a distinction between exception handling (as espoused by a specific programming language) versus exception propagation.
Reference: [31] <author> P. Maes, </author> <title> Concepts and Experiments in Computational Reflection, </title> <booktitle> Proceedings of the ACM Conference on ObjectOriented Programming Systems, Languages and Applications (OOPSLA) , pp. </booktitle> <pages> 147-55, </pages> <month> October </month> <year> 1987. </year>
Reference: [32] <author> S. Maffeis, </author> <title> Adding Group Communication and Fault Tolerance to CORBA, </title> <booktitle> Proceedings of the 1995 USENIX Conference on ObjectOriented Technologies, </booktitle> <address> Monterey, CA, </address> <month> June </month> <year> 1995. </year>
Reference: [33] <author> S. Maffeis, </author> <title> A Fault-Tolerant CORBA Name Server, </title> <booktitle> Proceedings of the 15th International Symposium on Reliable and Distributed Systems (SRDS-15), </booktitle> <pages> pp. 188-197, </pages> <month> October </month> <year> 1996. </year>
Reference: [34] <author> Sun Microsystems, </author> <title> Reflection, </title> <note> http://www.javasoft.com/products/jdk/1.1/docs/guide/reflection/, 1997. </note>
Reference-contexts: The RGE model captures just that information and exports it to protocol writers through first-class program graphs and events. Many distributed systems are already in some degrees reflective. CORBAs Dynamic Invocation Interface [7], Microsofts Distributed Component Object Model (DCOM) [11], Javas Core Reflection API <ref> [34] </ref> all provide dynamic access to the methods and signatures exported by objects.
Reference: [35] <author> L. E. Moser, et. al., Totem: </author> <title> A Fault-Tolerant Multicast Group Communication System, </title> <journal> Communications of the ACM, </journal> <volume> 39:4, </volume> <pages> pp. 54-63, </pages> <month> April </month> <year> 1996. </year>
Reference-contexts: Examples of such systems include Amoeba [27], Coyote [9], Delta-4 [41], Isis [10], Horus [43], and Totem <ref> [35] </ref>. These systems are also known as CATOCS (causally and totally ordered communication systems) and provide varying degrees of ordering properties in the presence of failures. This class of systems has been the source of much controversy and has been criticized on the basis of the end-to-end argument [13].
Reference: [36] <author> P. Narasimhan, L. E. Moser, P. M. Melliar-Smith, </author> <title> Exploiting the Internet Inter-ORB Protocol Interface to Provide CORBA with Fault Tolerance , Proceedings of the Third USENIX Conference on ObjectOriented Technologies (COOTS), </title> <month> June </month> <year> 1997. </year>
Reference-contexts: For example, Fault-Tolerant Mach [44] uses the concept of sentries to intercept calls between the application layer and the Mach system services. In [4], the author proposes a fault-tolerance layer that exports the same interface as the underlying operating system. In <ref> [36] </ref>, the authors exploit the Internet Inter-Orb Protocol Interface (IIOP) to extend CORBA with fault-tolerance based on replication techniques. In [48], the authors specify a replication service for CORBA using a primary/backup scheme.
Reference: [37] <author> A. Nguyen-Tuong, A. S. Grimshaw, and M. Hyett, </author> <title> Exploiting Data-Flow for Fault-Tolerance in a Wide-Area Parallel System, </title> <booktitle> Proceedings of the 15th International Symposium on Reliable and Distributed Systems (SRDS-15), </booktitle> <pages> pp. 1-11, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: The Voter is then responsible for routing the correct return value to the client. 6.3 Loadsharing & fault-tolerance for stateless servers Stateless servers represent an important class of servers as they lend themselves well to optimized replication techniques for both fault-tolerance and loadsharing <ref> [37] </ref>. Since by definition there is no server state to maintain, method invocations may be routed to any of the replicas without worrying about state consistency. Similarly to the previous policies, the GM transparently intercepts Client requests.
Reference: [38] <author> A. Nye, </author> <title> Xlib Programming Manual for Version 11, </title> <publisher> OReilly & Associates, Inc., Volume 1, </publisher> <year> 1988. </year>
Reference-contexts: In practice the size of the graph that needs to be carried on each invocation is optimized heavily. 4 Pronounced bottom token. Building robust distributed applications with reflective transformations 4.2 Reflective Events The event paradigm is well-understood and has been applied successfully in such diverse areas as windowing systems <ref> [38] </ref>, extensible kernel systems [40], component based systems [24], and the building of flexible protocol stacks [9][53]. Here, we advocate the use of the event paradigm for building reflective fault-tolerance components for distributed systems.
Reference: [39] <author> A. Paepcke, PCLOS: </author> <title> Stress testing CLOS: Experiencing the metaobject protocol, </title> <booktitle> Proceedings of the ACM Conference on ObjectOriented Programming Systems, Languages and Applications (OOPSLA) , 1990. </booktitle>
Reference-contexts: While others have proposed using reflection as the basis for building robust applications [1][16]<ref> [39] </ref>, these works have focussed on specific fault-tolerance techniques such as replication [16] or providing persistence [39]. [1] is a notable exception and its architecture provides support for both exception handling and replication.
Reference: [40] <author> P. Pardyak and B. Bershad, </author> <title> Dynamic Binding for an Extensible System, </title> <booktitle> Proceedings of the Second USENIX Symposium on Operating Systems Design and Implementation (OSDI) , Seattle, WA, </booktitle> <pages> pp. 201 212, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: We argue that these models should possess reflective capabilities similar to those found in our RGE model. 2.2 Events The event paradigm is well established and many systems use it as the basis for extensibility, i.e. Coyote [9], the Java Bean Component Model [24], SPIN <ref> [40] </ref>, Legion [53]. While the RGE model does not mandate that objects be implemented using events, a natural implementation of RGE would use a system that is event-driven such as the protocol stack of objects in Legion. <p> Building robust distributed applications with reflective transformations 4.2 Reflective Events The event paradigm is well-understood and has been applied successfully in such diverse areas as windowing systems [38], extensible kernel systems <ref> [40] </ref>, component based systems [24], and the building of flexible protocol stacks [9][53]. Here, we advocate the use of the event paradigm for building reflective fault-tolerance components for distributed systems.
Reference: [41] <author> D. Powell, ed., Delta-4: </author> <title> A Generic Architecture for Dependable Distributed Computing, </title> <publisher> Springer Verlag, </publisher> <address> Berlin and New York, </address> <year> 1991. </year>
Reference-contexts: Examples of such systems include Amoeba [27], Coyote [9], Delta-4 <ref> [41] </ref>, Isis [10], Horus [43], and Totem [35]. These systems are also known as CATOCS (causally and totally ordered communication systems) and provide varying degrees of ordering properties in the presence of failures.
Reference: [42] <author> D. Powell, </author> <title> Introduction to Special Section on Group Communication, </title> <journal> Communications of the ACM , 39:4, </journal> <pages> pp. 50-53, </pages> <month> April </month> <year> 1996. </year> <title> Building robust distributed applications with reflective transformations </title>
Reference-contexts: For an overview of CATOCS systems, please see <ref> [42] </ref>. Our work with the RGE model is orthogonal to the issue of using group communication primitives.
Reference: [43] <author> R. V. Renesse, K. P. Birman and S. Maffeis, Horus: </author> <title> A Flexible Group Communication System, </title> <journal> Communications of the ACM, </journal> <volume> 39:4, </volume> <pages> pp. 76-83, </pages> <month> April </month> <year> 1996. </year>
Reference-contexts: Examples of such systems include Amoeba [27], Coyote [9], Delta-4 [41], Isis [10], Horus <ref> [43] </ref>, and Totem [35]. These systems are also known as CATOCS (causally and totally ordered communication systems) and provide varying degrees of ordering properties in the presence of failures.
Reference: [44] <author> M. Russinovich, Z. Segall, and D. Siewiorek, </author> <title> Application Transparent Fault Management in Fault Tolerant Mach, </title> <booktitle> Foundations of Dependable Computing: System Implementation, </booktitle> <pages> pp. 215-241. </pages>
Reference-contexts: As the name suggests, middleware solutions sit between the user program and the underlying system. The common trait with middleware solutions is that they intercept the control flow between the application level and the underlying system to implement the desired fault-tolerance guarantees. For example, Fault-Tolerant Mach <ref> [44] </ref> uses the concept of sentries to intercept calls between the application layer and the Mach system services. In [4], the author proposes a fault-tolerance layer that exports the same interface as the underlying operating system.
Reference: [45] <author> F. Schneider, </author> <title> Implementing Fault-Tolerant Services Using the State Machine Approach , ACM Computing Surveys, </title> <month> December, </month> <year> 1990. </year>
Reference-contexts: A reflective system is by nature self-referential: it has a representation of itself that it can observe and manipulate, and its representation is causally connected to its behavior. Structuring applications along reflective guidelines is the key to enabling our transformation techniques. Consider the following representative constructs extracted from replication <ref> [45] </ref> and log-based rollback-recovery techniques: on the receipt of a message, log onto stable storage before sending a message, append a sequence number when receiving a message, inspect sequence number.
Reference: [46] <author> J. A. Stankovic, S. H. Son, J. Liebeherr, BeeHive: </author> <title> Global Multimedia Database Support for Dependable, Real-Time Applications, </title> <institution> Technical Report CS-97-08 , Department of Computer Science, University of Virginia, </institution> <year> 1997. </year>
Reference-contexts: Its use has also been advocated for the next generation of real-time global databases <ref> [46] </ref>. In [29][39], the Common List Object System (CLOS) [28] is extended to support persistence using reflection. In [16], reflective features of the language open-C++ are used to implement replication techniques for objects.
Reference: [47] <author> R. W. </author> <title> Sebesta, </title> <booktitle> "Concepts of Programming Languages", 2nd ed., </booktitle> <publisher> The Benjamin/Cummings Publishing Company, Inc, </publisher> <year> 1993. </year>
Reference-contexts: Common definitions for exception are: errors or unusual conditions that are software-detectable or any unusual event, erroneous or not, that is detectable either by hardware or software, and that may require special processing <ref> [47] </ref>. The word exception has the connotation of a rare event, an assumption that no longer holds true in a wide-area distributed systems 7 .
Reference: [48] <editor> G. Sheu, et. al., </editor> <booktitle> A Fault-Tolerant Object Service on CORBA , Proceedings of the 17 th International Conference on Distributed Computing Systems, </booktitle> <pages> pp. 393-400, </pages> <month> May </month> <year> 1997. </year>
Reference-contexts: In [4], the author proposes a fault-tolerance layer that exports the same interface as the underlying operating system. In [36], the authors exploit the Internet Inter-Orb Protocol Interface (IIOP) to extend CORBA with fault-tolerance based on replication techniques. In <ref> [48] </ref>, the authors specify a replication service for CORBA using a primary/backup scheme. Electra [32][33] Building robust distributed applications with reflective transformations and Orbix+ISIS [25] are both CORBA-compliant systems that provide fault-tolerance using groups and group communication primitives (section 2.3).
Reference: [49] <author> S. K. Shrivastava, G. N. Dixon and G. D. Parrington, </author> <title> An Overview of the Arjuna Distributed Programming System, </title> <journal> IEEE Software, </journal> <pages> pp. 66-73, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Viewed in this manner, the RGE model could be described as the specification of a middleware architecture for building robust applications. 2.6 Fault-tolerance encapsulated in objects An approach to providing fault-tolerance at the user level is to use the objectoriented paradigm to encapsulate fault-tolerance properties. Arjuna <ref> [49] </ref>, Avalon/C++ [15], DOME [5], BAST [19] are examples of systems that take this approach. In [16], the authors note that using inheritance alone poses problem for integrating replication techniques into user applications as standard objectoriented programming languages do not allow protocol writers to modify the method invocation dispatch mechanism.
Reference: [50] <author> M. van Steen, P. Homburg, </author> <title> and A.S. Tanenbaum. "The Architectural Design of Globe: A Wide-Area Distributed System", </title> <type> Technical Report IR-422, </type> <institution> Department of Mathematics and Computer Science, Vrije Universiteit, </institution> <address> Amsterdam, </address> <month> March </month> <year> 1997. </year>
Reference-contexts: We conclude and present future works in section 7. 2 Related Work To date no metasystems exist on a large scale except perhaps for the World Wide Web. Several projects are under way to build a metasystem, including Globus [18], Globe <ref> [50] </ref> and Legion [21]. While all recognize the need for fault-tolerance, specific details are sketchy or nonexistent. The RGE model addresses the issue of incorporating fault-tolerance into applications and suggests a way of structuring robust distributed applications. Note that in many instances, system-level services provided by metasystems are themselves applications.
Reference: [51] <author> B. Stroustrup, </author> <title> The C++ Programming Language, </title> <publisher> Addison-Wesley, </publisher> <address> 2 nd edition, </address> <year> 1991. </year>
Reference-contexts: System builders such as language designers and compiler writers can use the RGE model as their implementation model and then export their own API to end users. 2.7 Exception handling Exception handling in sequential programming languages is a well-understood area [17][20]. Examples of such languages include Ada [14], C++ <ref> [51] </ref>, CLU [30]. While we draw inspiration from these works, we differ from these in that our exception propagation model is not languagespecific. We make a distinction between exception handling (as espoused by a specific programming language) versus exception propagation.
Reference: [52] <author> H. Veen, </author> <title> "Dataflow Machine Architecture," </title> <journal> ACM Computing Surveys , pp. </journal> <volume> 365-396, vol. 18, no. 4, </volume> <month> December, </month> <year> 1986. </year>
Reference-contexts: implicitly contains a set of assumptions regarding possible failure modes. 4 Reflective Graph and Event Model (RGE) As the name indicates, the Reflective Graph and Event Model is composed of two other execution models: (1) a graph-driven execution model, macro-data flow (MDF), which is an extension of the data-flow model <ref> [52] </ref>, and (2), a standard event-driven execution model. MDF specifies the interaction between objects while the event model specifies the internal implementation of objects.
Reference: [53] <author> C. L. Viles et. al. </author> , <title> Enabling Flexibility in the Legion RunTime Library, </title> <booktitle> International Conference on Parallel and Distributed Processing Techniques (PDPTA '97), </booktitle> <address> Las Vegas, NV, </address> <year> 1997. </year>
Reference-contexts: We argue that these models should possess reflective capabilities similar to those found in our RGE model. 2.2 Events The event paradigm is well established and many systems use it as the basis for extensibility, i.e. Coyote [9], the Java Bean Component Model [24], SPIN [40], Legion <ref> [53] </ref>. While the RGE model does not mandate that objects be implemented using events, a natural implementation of RGE would use a system that is event-driven such as the protocol stack of objects in Legion. <p> Reflecting this need for configurability and extensibility, the protocol stack for Legion objects is build by connecting components via the event paradigm. For a more detailed description of the Legion Event Model, see <ref> [53] </ref>. The most striking feature of the Legion Event Model is that only a few events are needed to build the protocol stack. They are: MessageReceive . The object has received a fully formed message, i.e., all packets have been assembled MessageSend .
References-found: 53

