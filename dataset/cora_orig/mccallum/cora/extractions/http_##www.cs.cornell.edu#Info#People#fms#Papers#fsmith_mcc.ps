URL: http://www.cs.cornell.edu/Info/People/fms/Papers/fsmith_mcc.ps
Refering-URL: http://www.cs.cornell.edu/Info/People/fms/fms.html
Root-URL: http://www.cs.cornell.edu
Email: fms@cs.cornell.edu  jgm@cs.cornell.edu  
Title: Comparing Mostly-Copying and Mark-Sweep Conservative Collection  
Author: Frederick Smith Greg Morrisett 
Affiliation: Cornell University  Cornell University  
Abstract: Many high-level language compilers generate C code and then invoke a C compiler for code generation. To date, most of these compilers link the resulting code against a conservative mark-sweep garbage collector in order to reclaim unused memory. We introduce a new collector, MCC, based on an extension of mostly-copying collection. We analyze the various design decisions made in MCC and provide a performance comparison to the most widely used conservative mark-sweep collector (the Boehm-Demers-Weiser collector). Our results show that a good mostly-copying collector can outperform a mature highly-optimized mark-sweep collector when physical memory is large relative to the live data. A surprising result of our analysis is that cache behavior can have a greater impact on overall performance than either collector time or allocation time. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> American National Standards Institute, </institution> <address> 1430 Broad-way, New York, NY 10018, USA. </address> <booktitle> American National Standard Programming Language C, ANSI X3.159-1989, </booktitle> <month> Dec. 14 </month> <year> 1989. </year>
Reference-contexts: 1 Overview For almost any language, there are a handful of compilers that generate C <ref> [1] </ref> as a target language. For instance, Java-to-C compilers include Toba [20], Vortex [11], and Harissa [18]; and ML-to-C compilers include Bigloo [22], SML2C [27], and TIL/C [28] 1 .
Reference: [2] <author> A. W. Appel and D. B. MacQueen. </author> <title> Standard ML of New Jersey. </title> <editor> In M. Wirsing, editor, </editor> <booktitle> Third International Symposium on Programming Language Implementation and Logic Programming, </booktitle> <pages> pages 1-13, </pages> <address> New York, </address> <month> Aug. </month> <year> 1991. </year> <title> Springer-Verlag. </title> <booktitle> Volume 528 of Lecture Notes in Computer Science. </booktitle>
Reference-contexts: To our surprise, we found that in many cases, the client was actually slowed under MCC due to a loss of spatial locality. Contrary to our initial belief, a fast allocation sequence was relatively unimportant for overall performance. The main results of this paper are: 2 Both SML/NJ <ref> [2] </ref> and O'Caml [19], two widely-used ML compilers, use variants of copying collection for at least the most recently allocated data. * A new one-pass mostly-copying collector, MCC, that allows typed and untyped objects to co-exist in the heap and to be collected. <p> The code, except for allocation, collection, and the array size primitive, is the same for both versions. We selected benchmarks that have been used in the literature [17, 26, 24, 23] to compare the performance of TIL and SML/NJ <ref> [2] </ref>. Table 1 gives a brief description of each benchmark 4 . Since most of these ran very quickly, we modified the programs slightly to make them run longer (e.g., by increasing the data set sizes or number of iterations).
Reference: [3] <author> G. Attardi and T. Flagella. </author> <title> A customizable memory management framework. </title> <booktitle> In USENIX Association, editor, Proceedings of the 1994 USENIX C++ Conference: </booktitle> <address> April 11-14, 1994, Cambridge, MA, </address> <pages> pages 123-142, </pages> <address> Berkeley, CA, USA, </address> <month> Apr. </month> <year> 1994. </year> <booktitle> USENIX. </booktitle>
Reference-contexts: One, due to Bartlett, is used in a Scheme-to-C compiler and in its newest variant has migrated to C++ [7]. The other is the Customizable Memory Manager (CMM) which is also a collector for C++ <ref> [3, 4] </ref>. Bartlett's algorithm does two traversals over the live graph. Conceptually, in the first pass the algorithm identifies all quasi-pointers and all objects that cannot be moved. It promotes all pages containing such objects to to-space by linking them into the to-space list. <p> One of the innovations introduced by CMM was the live map a bitmask associated with each page that records the objects that are actually live on that page. Before this development, collectors treated all objects on promoted pages as roots with false retention in excess of 50% <ref> [3] </ref>. This algorithm is proportional to the size of the other heaps, and the live data in the collected heap. Untyped objects exist in a different heap and are collected via some other collection strategy.
Reference: [4] <author> G. Attardi, T. Flagella, and P. Iglio. </author> <title> Performance tuning in a customizable collector. </title> <editor> In H. Baker, editor, </editor> <booktitle> Proceedings of International Workshop on Memory Management, Lecture Notes in Computer Science, </booktitle> <address> Kinross, Scotland, Sept. 1995. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: One, due to Bartlett, is used in a Scheme-to-C compiler and in its newest variant has migrated to C++ [7]. The other is the Customizable Memory Manager (CMM) which is also a collector for C++ <ref> [3, 4] </ref>. Bartlett's algorithm does two traversals over the live graph. Conceptually, in the first pass the algorithm identifies all quasi-pointers and all objects that cannot be moved. It promotes all pages containing such objects to to-space by linking them into the to-space list. <p> Groebner Computes a Groebner basis. Table 1: Brief description of the benchmarks. were incorrectly made (because the object was referenced by a quasi-pointer) during the second pass. CMM is a customizable collector that supports mostly-copying collector. BDW and CMM have been compared in the context of C++ <ref> [4] </ref>. Like Bartlett, CMM implements a two stage mostly-copying algorithm. In the first stage all other heaps are examined for quasi-pointers, or pointers into this heap. All pages containing objects referenced by quasi-pointers are promoted into to-space. The heap being collected does not contain any untyped objects.
Reference: [5] <author> J. F. Bartlett. </author> <title> Compacting garbage collection with ambiguous roots. </title> <type> Technical Report 88/2, </type> <institution> Digital Equipment Corporation Western Research Laboratory, Palo Alto, California, </institution> <month> Feb. </month> <year> 1988. </year>
Reference-contexts: In other respects BDW is similar to a highly tuned, accurate mark-sweep collector: it potentially suffers the same fragmentation problems, and relative to copying collectors, requires more instructions for allocation. An alternative to conservative mark-sweep, first proposed by Bartlett <ref> [5] </ref> and ideally suited to compilers from type safe languages to C, is mostly-copying collection. Mostly-copying collection requires that most objects be typed (annotated to distinguish pointers from other values) in order to be effective. <p> BDW can detect quasi-pointers very effectively. Most failed pointer tests take about 5 instructions, and a successful quasi-pointer detection takes about 30 instructions [16]. The speed of pointer testing makes completely conservative collectors such as BDW practical. 2.2 MCC Mostly-copying collection is an idea originally due to Bartlett <ref> [5] </ref>. As discussed above, a sound collector cannot modify a quasi-pointer and cannot therefore move an object referenced by a quasi-pointer. In fact exactly those objects which are not referenced by quasi-pointers can be copied.
Reference: [6] <author> J. F. Bartlett. </author> <title> Mostly-copying garbage collection picks up generations and C++. </title> <type> Technical report, </type> <institution> DEC WRL, </institution> <month> Oct. </month> <year> 1989. </year>
Reference-contexts: In particular, programs that hide or manufacture pointers are not supported. We call a value that is inferred, but not known, to be a pointer a quasi-pointer (sometimes referred to as an ambiguous pointer <ref> [6] </ref>). Misidentification of values as quasi-pointers artificially increases the size of the live graph, and limits the effectiveness of the collector. Of course correctly distinguishing pointers from other values is not always possible, and for some large, long running programs pointer misidentification may be a significant problem [14].
Reference: [7] <author> J. F. Bartlett. </author> <title> A generational, compacting collector for C++. </title> <editor> In E. Jul and N.-C. Juul, editors, </editor> <booktitle> OOP-SLA/ECOOP '90 Workshop on Garbage Collection in Object-Oriented Systems, </booktitle> <month> Oct. </month> <year> 1990. </year>
Reference-contexts: Readers interested in further details should refer to our technical report [25]. 2.2.3 Related Collectors There are two other mostly-copying collectors that bear a strong resemblance to MCC. One, due to Bartlett, is used in a Scheme-to-C compiler and in its newest variant has migrated to C++ <ref> [7] </ref>. The other is the Customizable Memory Manager (CMM) which is also a collector for C++ [3, 4]. Bartlett's algorithm does two traversals over the live graph. Conceptually, in the first pass the algorithm identifies all quasi-pointers and all objects that cannot be moved.
Reference: [8] <author> H.-J. Boehm. </author> <title> Space-efficient conservative garbage collection. </title> <booktitle> In ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 197-206, </pages> <address> Albuquerque, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: In these situations a variant of copying collection called mostly-copying collection is possible. In the following subsections, we examine the algorithms and implementations of the BDW mark-sweep collector and the MCC mostly-copying collector in greater detail. 2.1 The Boehm-Demers-Weiser Collector BDW <ref> [10, 8] </ref> is a conservative mark-sweep collector available on a wide variety of platforms. It is used by at least 13 language implementations to date and has been under development since 1987 3 .
Reference: [9] <author> H.-J. Boehm and D. R. Chase. </author> <title> A proposal for garbage-collector-safe C compilation. C Language Translation, </title> <year> 1992. </year>
Reference-contexts: However, for most programs it is possible to detect quasi-pointers with great accuracy (usually less than 10% misidentification) and speed (30 instructions) [16]. This is possible because of architectural constraints that force pointers to be multiples of the word-size and to reside in specific address ranges <ref> [10, 9] </ref>. Conservative collectors have traditionally been limited to collection algorithms that do not update values in the client's data. Since quasi-pointers are not known to be pointers, altering a quasi-pointer to point to a new location, as would be necessary in copying collection, could change the client's behavior.
Reference: [10] <author> H.-J. Boehm and M. Weiser. </author> <title> Garbage collection in an uncooperative environment. </title> <journal> Software Practice and Experience, </journal> <volume> 18(9) </volume> <pages> 807-820, </pages> <year> 1988. </year>
Reference-contexts: However, for most programs it is possible to detect quasi-pointers with great accuracy (usually less than 10% misidentification) and speed (30 instructions) [16]. This is possible because of architectural constraints that force pointers to be multiples of the word-size and to reside in specific address ranges <ref> [10, 9] </ref>. Conservative collectors have traditionally been limited to collection algorithms that do not update values in the client's data. Since quasi-pointers are not known to be pointers, altering a quasi-pointer to point to a new location, as would be necessary in copying collection, could change the client's behavior. <p> In these situations a variant of copying collection called mostly-copying collection is possible. In the following subsections, we examine the algorithms and implementations of the BDW mark-sweep collector and the MCC mostly-copying collector in greater detail. 2.1 The Boehm-Demers-Weiser Collector BDW <ref> [10, 8] </ref> is a conservative mark-sweep collector available on a wide variety of platforms. It is used by at least 13 language implementations to date and has been under development since 1987 3 .
Reference: [11] <author> J. Dean, G. DeFouw, D. Grove, V. Livinov, and C. Chambers. </author> <title> Vortex: An optimizing compiler for object-oriented languages. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 31(10) </volume> <pages> 83-100, </pages> <month> Oct. </month> <year> 1996. </year> <title> Discusses performance of Vortex compiler for Cecil, C++, Java, and Modula-3. </title>
Reference-contexts: 1 Overview For almost any language, there are a handful of compilers that generate C [1] as a target language. For instance, Java-to-C compilers include Toba [20], Vortex <ref> [11] </ref>, and Harissa [18]; and ML-to-C compilers include Bigloo [22], SML2C [27], and TIL/C [28] 1 . The developers of these compilers chose C as a target language to leverage the optimizations of existing C compilers and to obtain a relatively portable, easy-to-build back-end.
Reference: [12] <author> A. Diwan, D. Tarditi, and E. Moss. </author> <title> Measuring subsystem performance of programs using copying garbage collection. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-14, </pages> <address> Portland Oregon, </address> <year> 1994. </year>
Reference-contexts: Several studies in the literature have suggested that allocation costs can be significant <ref> [13, 12, 15] </ref>, and are in fact one of the main advantages of copying collection. We were interested in determining whether we could reap these same benefits in a mostly-copying setting. To achieve fast allocation, clients allocate objects contiguously on a single page until the page is full.
Reference: [13] <author> A. Diwan, D. Tarditi, and E. Moss. </author> <title> Memory-system performance of programs with intensive heap allocation. </title> <journal> Transactions on Computer Systems, </journal> <volume> 13(3) </volume> <pages> 244-273, </pages> <month> Aug. </month> <year> 1995. </year>
Reference-contexts: Several studies in the literature have suggested that allocation costs can be significant <ref> [13, 12, 15] </ref>, and are in fact one of the main advantages of copying collection. We were interested in determining whether we could reap these same benefits in a mostly-copying setting. To achieve fast allocation, clients allocate objects contiguously on a single page until the page is full.
Reference: [14] <author> D. Edelson. </author> <title> A mark-and-sweep collector for c++. </title> <booktitle> In Nineteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 51-58, </pages> <address> New Mexico, </address> <month> Jan. </month> <year> 1992. </year>
Reference-contexts: Misidentification of values as quasi-pointers artificially increases the size of the live graph, and limits the effectiveness of the collector. Of course correctly distinguishing pointers from other values is not always possible, and for some large, long running programs pointer misidentification may be a significant problem <ref> [14] </ref>. However, for most programs it is possible to detect quasi-pointers with great accuracy (usually less than 10% misidentification) and speed (30 instructions) [16]. This is possible because of architectural constraints that force pointers to be multiples of the word-size and to reside in specific address ranges [10, 9].
Reference: [15] <author> M. W. Hicks, J. T. Moore, and S. M. Nettles. </author> <title> The measured cost of copying garbage collection mechanisms. </title> <booktitle> In International Conference on Functional Programming, </booktitle> <address> Amsterdam, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: Several studies in the literature have suggested that allocation costs can be significant <ref> [13, 12, 15] </ref>, and are in fact one of the main advantages of copying collection. We were interested in determining whether we could reap these same benefits in a mostly-copying setting. To achieve fast allocation, clients allocate objects contiguously on a single page until the page is full. <p> In addition, MCC implements a slow pointer testing routine which penalizes it further in the presence of a deep stack or many conservative objects relative to BDW. Despite these drawbacks, MCC is comparable if not better than BDW on almost all benchmarks. The study in <ref> [15] </ref> suggests that more sophisticated techniques may yield another 20% improvement in collector times. And, a few modifications to our compiler may further decrease the cost of allocation.
Reference: [16] <author> R. E. Jones. </author> <title> Garbage Collection: Algorithms for Automatic Dynamic Memory Management. </title> <publisher> Wiley, </publisher> <month> July </month> <year> 1996. </year> <title> With a chapter on Distributed Garbage Collection by R. </title> <type> Lins. </type> <note> Reprinted February 1996. </note>
Reference-contexts: This paper requires familiarity with many garbage collection concepts that for the sake of brevity have been omitted. The reader requiring more clarification is referred to Paul Wilson's survey on garbage collection techniques [31] or Richard Jones' text <ref> [16] </ref>. 2 Conservative Collection Conservative garbage collection is the extension of accurate garbage collection to environments where partial or no type information is available. In particular, a conservative collector is not told which values are pointers for some subset of the heap. <p> Of course correctly distinguishing pointers from other values is not always possible, and for some large, long running programs pointer misidentification may be a significant problem [14]. However, for most programs it is possible to detect quasi-pointers with great accuracy (usually less than 10% misidentification) and speed (30 instructions) <ref> [16] </ref>. This is possible because of architectural constraints that force pointers to be multiples of the word-size and to reside in specific address ranges [10, 9]. Conservative collectors have traditionally been limited to collection algorithms that do not update values in the client's data. <p> Only then is a collection invoked to refill the free list. BDW can detect quasi-pointers very effectively. Most failed pointer tests take about 5 instructions, and a successful quasi-pointer detection takes about 30 instructions <ref> [16] </ref>. The speed of pointer testing makes completely conservative collectors such as BDW practical. 2.2 MCC Mostly-copying collection is an idea originally due to Bartlett [5]. As discussed above, a sound collector cannot modify a quasi-pointer and cannot therefore move an object referenced by a quasi-pointer.
Reference: [17] <author> G. Morrisett. </author> <title> Compiling with Types. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> De-cember </month> <year> 1995. </year>
Reference-contexts: We compiled eight small to medium sized benchmarks for ML, using BDW 4.10 and then MCC. The code, except for allocation, collection, and the array size primitive, is the same for both versions. We selected benchmarks that have been used in the literature <ref> [17, 26, 24, 23] </ref> to compare the performance of TIL and SML/NJ [2]. Table 1 gives a brief description of each benchmark 4 .
Reference: [18] <author> G. Muller, B. Moura, F. Bellard, and C. Consel. Harissa: </author> <title> a flexible and efficient java environment mixing bytecode and compiled code. </title> <booktitle> In Usenix Conference on Object-Oriented Technlogies and Systems, </booktitle> <address> Oregon, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: 1 Overview For almost any language, there are a handful of compilers that generate C [1] as a target language. For instance, Java-to-C compilers include Toba [20], Vortex [11], and Harissa <ref> [18] </ref>; and ML-to-C compilers include Bigloo [22], SML2C [27], and TIL/C [28] 1 . The developers of these compilers chose C as a target language to leverage the optimizations of existing C compilers and to obtain a relatively portable, easy-to-build back-end.
Reference: [19] <editor> Objective caml. </editor> <address> http://pauillac.inria.fr/ocaml/. </address>
Reference-contexts: Contrary to our initial belief, a fast allocation sequence was relatively unimportant for overall performance. The main results of this paper are: 2 Both SML/NJ [2] and O'Caml <ref> [19] </ref>, two widely-used ML compilers, use variants of copying collection for at least the most recently allocated data. * A new one-pass mostly-copying collector, MCC, that allows typed and untyped objects to co-exist in the heap and to be collected.
Reference: [20] <author> T. A. Proebsting, G. Townsend, P. Bridges, J. H. Hart-man, T. Newsham, and S. A. Watterson. Toba: </author> <title> Java for applications: A way ahead of time (WAT) compiler. </title> <type> Technical Report TR97-01, </type> <institution> The Department of Computer Science, University of Arizona, </institution> <address> Jan. 8 1997. Wed, 08 Jan 97 00:00:00 GMT. </address>
Reference-contexts: 1 Overview For almost any language, there are a handful of compilers that generate C [1] as a target language. For instance, Java-to-C compilers include Toba <ref> [20] </ref>, Vortex [11], and Harissa [18]; and ML-to-C compilers include Bigloo [22], SML2C [27], and TIL/C [28] 1 . The developers of these compilers chose C as a target language to leverage the optimizations of existing C compilers and to obtain a relatively portable, easy-to-build back-end.
Reference: [21] <author> C. Reade. </author> <title> Elements of Functional Programming. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, </address> <year> 1989. </year>
Reference-contexts: Knuth-Bendix Runs the Knuth-Bendix completion algo rithm on a rewriting system. Lexgen Generates a lexer for ML. Life Runs 10; 000 generations of the Life simula tion <ref> [21] </ref> for a small self-replicating automata. Logic Performs some simple theorem-proving using back-tracking and unification. Mergesort Mergesorts a large list repeatedly. Pia Runs a perspective inversion algorithm to decide the location of an object in a perspective video image [30]. Groebner Computes a Groebner basis.
Reference: [22] <author> M. Serrano and P. Weis. Bigloo: </author> <title> a portable and optimizing compiler for strict functional languages. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> 983 </volume> <pages> 366-81, </pages> <year> 1995. </year>
Reference-contexts: 1 Overview For almost any language, there are a handful of compilers that generate C [1] as a target language. For instance, Java-to-C compilers include Toba [20], Vortex [11], and Harissa [18]; and ML-to-C compilers include Bigloo <ref> [22] </ref>, SML2C [27], and TIL/C [28] 1 . The developers of these compilers chose C as a target language to leverage the optimizations of existing C compilers and to obtain a relatively portable, easy-to-build back-end.
Reference: [23] <author> Z. Shao and A. W. Appel. </author> <title> Space-efficient closure representations. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 150-161, </pages> <address> Orlando, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: We compiled eight small to medium sized benchmarks for ML, using BDW 4.10 and then MCC. The code, except for allocation, collection, and the array size primitive, is the same for both versions. We selected benchmarks that have been used in the literature <ref> [17, 26, 24, 23] </ref> to compare the performance of TIL and SML/NJ [2]. Table 1 gives a brief description of each benchmark 4 .
Reference: [24] <author> Z. Shao and A. W. Appel. </author> <title> A type-based compiler for Standard ML. </title> <booktitle> In ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 116-129, </pages> <address> La Jolla, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: We compiled eight small to medium sized benchmarks for ML, using BDW 4.10 and then MCC. The code, except for allocation, collection, and the array size primitive, is the same for both versions. We selected benchmarks that have been used in the literature <ref> [17, 26, 24, 23] </ref> to compare the performance of TIL and SML/NJ [2]. Table 1 gives a brief description of each benchmark 4 .
Reference: [25] <author> F. Smith and G. Morrisett. </author> <title> Mostly copying collection: A viable alternative to conservative mark-sweep. </title> <type> Technical report, </type> <institution> Cornell, </institution> <year> 1997. </year>
Reference-contexts: After sweeping, promoted pages may have unused space. MCC does not reuse this space in subsequent collections. MCC correctly deals with large objects, alignment restrictions, and pointers from and into the static region. Readers interested in further details should refer to our technical report <ref> [25] </ref>. 2.2.3 Related Collectors There are two other mostly-copying collectors that bear a strong resemblance to MCC. One, due to Bartlett, is used in a Scheme-to-C compiler and in its newest variant has migrated to C++ [7]. <p> The allocation sequence for MCC is seven instructions versus nine instructions for BDW. In addition MCC's allocation sequence requires only a single memory operation as opposed to four for BDW (see <ref> [25] </ref> for details). The advantages of faster allocation were hard to separate from the much larger cache ef fects without doing a cycle-level simulation. * Arrays. Computing the array size is the only code other than allocation that is different for the two collectors.
Reference: [26] <author> D. Tarditi. </author> <title> Design and Implementation of Code Optimizations for a TypeDirected Compiler for Standard ML. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> December </month> <year> 1996. </year>
Reference-contexts: We compiled eight small to medium sized benchmarks for ML, using BDW 4.10 and then MCC. The code, except for allocation, collection, and the array size primitive, is the same for both versions. We selected benchmarks that have been used in the literature <ref> [17, 26, 24, 23] </ref> to compare the performance of TIL and SML/NJ [2]. Table 1 gives a brief description of each benchmark 4 .
Reference: [27] <author> D. Tarditi, A. Acharya, and P. Lee. </author> <title> No assembly required: Compiling standard ML to C. </title> <type> Technical Report CMU-CS-90-187, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> Nov. 90. </month>
Reference-contexts: 1 Overview For almost any language, there are a handful of compilers that generate C [1] as a target language. For instance, Java-to-C compilers include Toba [20], Vortex [11], and Harissa [18]; and ML-to-C compilers include Bigloo [22], SML2C <ref> [27] </ref>, and TIL/C [28] 1 . The developers of these compilers chose C as a target language to leverage the optimizations of existing C compilers and to obtain a relatively portable, easy-to-build back-end. However, Java, ML, and many other languages require garbage collection which C does not directly provide.
Reference: [28] <author> D. Tarditi, G. Morrisett, P. Cheng, C. Stone, R. Harper, and P. Lee. </author> <title> TIL: A type directed optimizing compiler for ML. </title> <booktitle> In Proceedings of the ACM SIGPLAN '96 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 181-192, </pages> <address> Philadelphia, Pennsylvania, </address> <month> 21- May </month> <year> 1996. </year>
Reference-contexts: 1 Overview For almost any language, there are a handful of compilers that generate C [1] as a target language. For instance, Java-to-C compilers include Toba [20], Vortex [11], and Harissa [18]; and ML-to-C compilers include Bigloo [22], SML2C [27], and TIL/C <ref> [28] </ref> 1 . The developers of these compilers chose C as a target language to leverage the optimizations of existing C compilers and to obtain a relatively portable, easy-to-build back-end. However, Java, ML, and many other languages require garbage collection which C does not directly provide. <p> One of the drawbacks of CMM's approach is that it cannot break cycles between heaps. 3 Empirical Results 3.1 Comparison of Overall Costs for ML To compare MCC to BDW, we added a C back end to the TIL compiler <ref> [29, 28] </ref> and targeted it to use both collectors. TIL generates fairly natural C code that uses the C stack and produces natural C constructs such as while loops. We compiled eight small to medium sized benchmarks for ML, using BDW 4.10 and then MCC.
Reference: [29] <author> D. Tarditi, G. Morrisett, P. Cheng, C. Stone, R. Harper, and P. Lee. </author> <title> TIL: A type-directed optimizing compiler for ML. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 31(5) </volume> <pages> 181-192, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: One of the drawbacks of CMM's approach is that it cannot break cycles between heaps. 3 Empirical Results 3.1 Comparison of Overall Costs for ML To compare MCC to BDW, we added a C back end to the TIL compiler <ref> [29, 28] </ref> and targeted it to use both collectors. TIL generates fairly natural C code that uses the C stack and produces natural C constructs such as while loops. We compiled eight small to medium sized benchmarks for ML, using BDW 4.10 and then MCC.
Reference: [30] <author> K. G. Waugh, P. McAndrew, and G. Michaelson. </author> <title> Parallel implementations from function prototypes: a case study. </title> <institution> Technical Report Computer Science 90/4, Heriot-Watt University, Edinburgh, </institution> <month> Aug. </month> <year> 1990. </year>
Reference-contexts: Life Runs 10; 000 generations of the Life simula tion [21] for a small self-replicating automata. Logic Performs some simple theorem-proving using back-tracking and unification. Mergesort Mergesorts a large list repeatedly. Pia Runs a perspective inversion algorithm to decide the location of an object in a perspective video image <ref> [30] </ref>. Groebner Computes a Groebner basis. Table 1: Brief description of the benchmarks. were incorrectly made (because the object was referenced by a quasi-pointer) during the second pass. CMM is a customizable collector that supports mostly-copying collector. BDW and CMM have been compared in the context of C++ [4].

Reference: [32] <author> P. R. Wilson. </author> <title> Garbage collection. </title> <journal> Computing Surveys, </journal> <note> 1995. Expanded version of [31]. Draft available via anonymous internet FTP from cs.utexas.edu as pub/garbage/bigsurv.ps. In revision, to appear. </note>
Reference-contexts: As in a copying collector, most live objects are copied from pages in from-space to pages in to-space. However, live pinned objects cannot be copied. Hence, the page on which they reside is promoted to to-space. The collector maintains both a mark-queue and a Cheney-queue <ref> [32] </ref>. When a pinned object is first encountered, it is placed in the mark-queue, whereas other objects are forwarded and placed in the Cheney-queue. The algorithm begins by scanning the roots and placing the objects they reference in the appropriate queue.
Reference: [33] <author> B. Zorn. </author> <title> The measured cost of conservative garbage collection. </title> <journal> Software Practice and Experience, </journal> <volume> 23 </volume> <pages> 733-756, </pages> <year> 1993. </year>
Reference-contexts: It is used by at least 13 language implementations to date and has been under development since 1987 3 . BDW is easy to use (programs need only redirect malloc and free to the appropriate collector routines) and has performance comparable to explicit memory management for almost all programs <ref> [33] </ref> (for programs with small heaps BDW may require significantly more memory). For better performance, clients may allocate pointer-free (atomic) data through a special allocation routine - GC malloc atomic. Except for quasi-pointer detection, the BDW collection algorithm is a highly-optimized version of mark-sweep.
References-found: 32

