URL: http://www.cs.colorado.edu/~klauser/papers/sigmod96.ps.gz
Refering-URL: http://www.cs.colorado.edu/~klauser/publications.html
Root-URL: http://www.cs.colorado.edu
Email: jcook@cs.colorado.edu  klauser@cs.colorado.edu  alw@cs.colorado.edu  zorn@cs.colorado.edu  
Title: Semi-automatic, Self-adaptive Control of Garbage Collection Rates in Object Databases  
Author: Jonathan E. Cook Artur W. Klauser Alexander L. Wolf Benjamin G. Zorn 
Affiliation: University of Colorado  University of Colorado  University of Colorado  University of Colorado  
Date: June 3-6, 1996  
Note: From the Proceedings of the 1996 ACM SIGMOD Inter. Conf. on Management of Data, Montreal, Canada,  
Abstract: A fundamental problem in automating object database storage reclamation is determining how often to perform garbage collection. We show that the choice of collection rate can have a significant impact on application performance and that the "best" rate depends on the dynamic behavior of the application, tempered by the particular performance goals of the user. We describe two semi-automatic, self-adaptive policies for controlling collection rate that we have developed to address the problem. Using trace-driven simulations, we evaluate the performance of the policies on a test database application that demonstrates two distinct reclustering behaviors. Our results show that the policies are effective at achieving user-specified levels of I/O operations and database garbage percentage. We also investigate the sensitivity of the policies over a range of object connectivities. The evaluation demonstrates that semi-automatic, self-adaptive policies are a practical means for flexibly controlling garbage collection rate. 
Abstract-found: 1
Intro-found: 1
Reference: [AFG95] <author> L. Amsaleg, M. Franklin, and O. Gruber. </author> <title> Efficient incremental garbage collection for client-server object database systems. </title> <booktitle> In Proceedings of the 21st VLDB Conference, </booktitle> <address> Zurich, Switzer-land, </address> <month> September </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Automatic storage reclamation, or garbage collection (GC), is becoming recognized as an important new feature for object database management systems (ODBMSs). A number of recent research papers have considered some of the important aspects of the correctness and performance of ODBMS garbage collection <ref> [AFG95, CWZ94, KLW89, KW93, YNY94] </ref>. A recently proposed standard suggests using garbage collection for at least some of the programmatic interfaces to an ODBMS [Cat93]. Commercial ODBMSs are now providing implementations of garbage collection (e.g., [Cor94]). This work was supported in part by the National Science Foundation under grant IRI-95-21046. <p> Furthermore, our collection rate policies add only little time and space overhead. We also show that our results hold across databases with different object connectivities. While there has been a significant amount of research in object database garbage collection <ref> [AFG95, Bj93, But87, CA86, CWZ94, KLW89, KW93, ML94, Mat85, YNY94] </ref>, none of that previous work has investigated the issue of collection rate. <p> In particular, we make the simplifying assumptions that the entire database is locked while collection is performed, and that logging for recovery is not supported. Clearly, more sophisticated mechanisms must be provided in actual implementations; proposals for such mechanisms are discussed elsewhere <ref> [AFG95, KLW89, KW93, YNY94] </ref>. We evaluate the performance of the policies based on multiple simulation runs that differ only in the initial random number seed. In our results, we present the mean of the values over time. Each simulation run experiences a cold-start of the database.
Reference: [Bj93] <author> Anders Bjornerstedt. </author> <title> Secondary Storage Garbage Collection for Decentralized Object-Based Systems. </title> <type> PhD thesis, </type> <institution> Stockholm University, Dept. of Comp. Sys. Sciences, Royal Inst. of Tech. and Stockholm Univ., Kista, Sweden, </institution> <year> 1993. </year> <note> Also appears as Systems Dev. </note> <institution> and AI Lab. </institution> <note> Report No. 77. </note>
Reference-contexts: Furthermore, our collection rate policies add only little time and space overhead. We also show that our results hold across databases with different object connectivities. While there has been a significant amount of research in object database garbage collection <ref> [AFG95, Bj93, But87, CA86, CWZ94, KLW89, KW93, ML94, Mat85, YNY94] </ref>, none of that previous work has investigated the issue of collection rate.
Reference: [But87] <author> Margaret H. Butler. </author> <title> Storage reclamation in object-oriented database systems. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on the Management of Data, </booktitle> <pages> pages 410-423, </pages> <address> San Francisco, CA, </address> <year> 1987. </year>
Reference-contexts: Furthermore, our collection rate policies add only little time and space overhead. We also show that our results hold across databases with different object connectivities. While there has been a significant amount of research in object database garbage collection <ref> [AFG95, Bj93, But87, CA86, CWZ94, KLW89, KW93, ML94, Mat85, YNY94] </ref>, none of that previous work has investigated the issue of collection rate.
Reference: [CA86] <author> Jack Campin and Malcolm Atkinson. </author> <title> A persistent store garbage collector with statistical facilities. Persistent Programming Reserarch Report 29, </title> <institution> Department of Computing Science, University of Glasgow, </institution> <address> Glasgow, Scotland, </address> <year> 1986. </year>
Reference-contexts: Furthermore, our collection rate policies add only little time and space overhead. We also show that our results hold across databases with different object connectivities. While there has been a significant amount of research in object database garbage collection <ref> [AFG95, Bj93, But87, CA86, CWZ94, KLW89, KW93, ML94, Mat85, YNY94] </ref>, none of that previous work has investigated the issue of collection rate.
Reference: [Cat93] <author> R.G.G. Cattell, </author> <title> editor. The Object Database Standard: ODMG-93. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1993. </year>
Reference-contexts: A number of recent research papers have considered some of the important aspects of the correctness and performance of ODBMS garbage collection [AFG95, CWZ94, KLW89, KW93, YNY94]. A recently proposed standard suggests using garbage collection for at least some of the programmatic interfaces to an ODBMS <ref> [Cat93] </ref>. Commercial ODBMSs are now providing implementations of garbage collection (e.g., [Cor94]). This work was supported in part by the National Science Foundation under grant IRI-95-21046. A. Klauser was supported by a BMfWF/Fulbright Graduate Fellowship.
Reference: [CDN93] <author> Michael J. Carey, David J. DeWitt, and Jef-frey F. Naughton. </author> <title> The OO7 benchmark. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on the Management of Data, </booktitle> <pages> pages 12-21, </pages> <address> Washington, DC, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Figures 1a and 1b show the effect of varying the collection rate on the I/O performance and on the total garbage collected in a test database. Specific details of the test database, an instance of the OO7 benchmark <ref> [CDN93] </ref>, are discussed in Section 3.3. The figures highlight the time/space tradeoff of collection rate policies. <p> We present a performance evaluation of our two 378 new collection rate policies that is based on trace-driven simulations of an application developed by Yong, Naughton, and Yu [YNY94] for the OO7 ODBMS benchmark <ref> [CDN93] </ref>. The application consists of four distinct phases, each exhibiting behavior different from the one that it precedes. Figure 2 illustrates the progression of the phases, which we describe fully in Section 3. <p> Traces of database application events (e.g., object creations, accesses, modifications) are used to drive the simulations; details appear in [CWZ93]. For the work described here, we use traces derived from the OO7 benchmark database <ref> [CDN93] </ref>. Details of the test database are provided in Section 3.3. Because we are concerned with the relative performance of collection rate polices, we assume simple mechanisms for concurrency control and recovery. <p> Preamble lengths range from 10 to 30 collections, depending on the simulation parameters, but usually were closer to 10 than to 30. For the time-varying results shown, preambles are 10 collections. 3.3 Test Database Structure The test database used in our measurements is the OO7 benchmark <ref> [CDN93] </ref>, which was also used by Yong, Naughton, and Yu in their work on garbage collection [YNY94]. Table 1 shows how the characteristics of our Small 0 OO7 database that we measured compares to the Small database used by Yong, Naughton, and Yu, and described in [CDN93]. <p> is the OO7 benchmark <ref> [CDN93] </ref>, which was also used by Yong, Naughton, and Yu in their work on garbage collection [YNY94]. Table 1 shows how the characteristics of our Small 0 OO7 database that we measured compares to the Small database used by Yong, Naughton, and Yu, and described in [CDN93].
Reference: [Che70] <author> C. J. </author> <title> Cheney. A nonrecursive list compacting algorithm. </title> <journal> Comm. of the ACM, </journal> <volume> 13(11) </volume> <pages> 677-678, </pages> <month> November </month> <year> 1970. </year>
Reference-contexts: In contrast, our work is aimed at both quantifying the cost of poor collection rate choices and proposing new policies for effectively controlling the collection rate in object databases. There are a number of similarities between copying garbage collection <ref> [Che70] </ref> and on-line object reclus-tering. In particular, they both have the potential to improve application performance by relocating objects, they both incur additional execution overhead that must be balanced against the performance benefits they provide, and they both must find an appropriate rate at which to operate effectively. <p> The partitioned collection algorithm used in our experiments is described in our previous paper [CWZ94], so we refer the reader to that paper for details. Here we give just a brief review of the important aspects of that algorithm. We use a copying garbage collector <ref> [Che70] </ref> in which objects are relocated as a result of collection. This allows garbage collection to not only reclaim the space occupied by garbage but also to compact the collected partition's live objects for improved reference locality. Copying is done in a breadth-first traversal from the partition's roots.
Reference: [Cor94] <author> Servio Corporation. </author> <title> Announcing GemStone version 4.0. Product literature, </title> <year> 1994. </year>
Reference-contexts: A recently proposed standard suggests using garbage collection for at least some of the programmatic interfaces to an ODBMS [Cat93]. Commercial ODBMSs are now providing implementations of garbage collection (e.g., <ref> [Cor94] </ref>). This work was supported in part by the National Science Foundation under grant IRI-95-21046. A. Klauser was supported by a BMfWF/Fulbright Graduate Fellowship.
Reference: [CWZ93] <author> Jonathan Cook, Alexander Wolf, and Benjamin Zorn. </author> <title> The design of a simulation system for persistent object storage management. </title> <type> Technical Report CU-CS-647-93, </type> <institution> Department of Computer Science, University of Colorado, Boulder, CO, </institution> <month> March </month> <year> 1993. </year>
Reference-contexts: In our experiments, the buffer size was set to 12 8-kilobyte pages. 3.2 Simulation Environment Our simulation system mimics the physical and logical structure of the database implementation being measured. Traces of database application events (e.g., object creations, accesses, modifications) are used to drive the simulations; details appear in <ref> [CWZ93] </ref>. For the work described here, we use traces derived from the OO7 benchmark database [CDN93]. Details of the test database are provided in Section 3.3. Because we are concerned with the relative performance of collection rate polices, we assume simple mechanisms for concurrency control and recovery.
Reference: [CWZ94] <author> Jonathan Cook, Alexander Wolf, and Benjamin Zorn. </author> <title> Partition selection policies in object database garbage collection. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on the Management of Data, </booktitle> <pages> pages 371-382, </pages> <address> Minneapolis, MN, </address> <month> March </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Automatic storage reclamation, or garbage collection (GC), is becoming recognized as an important new feature for object database management systems (ODBMSs). A number of recent research papers have considered some of the important aspects of the correctness and performance of ODBMS garbage collection <ref> [AFG95, CWZ94, KLW89, KW93, YNY94] </ref>. A recently proposed standard suggests using garbage collection for at least some of the programmatic interfaces to an ODBMS [Cat93]. Commercial ODBMSs are now providing implementations of garbage collection (e.g., [Cor94]). This work was supported in part by the National Science Foundation under grant IRI-95-21046. <p> To copy otherwise, to republish, to post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. SIGMOD '96 6/96 Montreal, Canada c fl 1996 ACM 0-89791-794-4/96/0006:: : $3.50 In a previous paper <ref> [CWZ94] </ref> we presented a framework for investigating the issues surrounding partitioned garbage collection of ODBMSs. Partitioned collection is an incremental technique based on manipulating disjoint portions of a database [YNY94] and is akin to generational collection in programming language systems [Wil92]. <p> Furthermore, our collection rate policies add only little time and space overhead. We also show that our results hold across databases with different object connectivities. While there has been a significant amount of research in object database garbage collection <ref> [AFG95, Bj93, But87, CA86, CWZ94, KLW89, KW93, ML94, Mat85, YNY94] </ref>, none of that previous work has investigated the issue of collection rate. <p> The partitioned collection algorithm used in our experiments is described in our previous paper <ref> [CWZ94] </ref>, so we refer the reader to that paper for details. Here we give just a brief review of the important aspects of that algorithm. We use a copying garbage collector [Che70] in which objects are relocated as a result of collection. <p> This behavior results directly from the nature of the heuristic, which assumes that information gained from the collection of the current partition is representative of all the partitions in the database. This assumption fails because the partition selection policy employed (i.e., Updated-Pointer <ref> [CWZ94] </ref>) is effective at finding a partition with more than an average amount of garbage. <p> This accuracy results from its use of fine grain state in the form of the number of pointer overwrites, which has been shown to be highly related to garbage creation <ref> [CWZ94] </ref>. There is also significantly less variation in the garbage estimation of the FGS/HB heuristic because of its use of historical information. heuristic to changes in the history parameter, h, discussed in Section 2.4.
Reference: [GKNV93] <author> E.R. Gansner, E. Koutsofios, S.C. North, and K.-P. Vo. </author> <title> A Technique for Drawing Directed Graphs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 19(3) </volume> <pages> 214-230, </pages> <month> March </month> <year> 1993. </year>
Reference: [KLW89] <author> Elliot Kolodner, Barbara Liskov, and William Weihl. </author> <title> Atomic garbage collection: Managing a stable heap. </title> <booktitle> In Proceedings of the ACM SIG-MOD International Conference on the Management of Data, </booktitle> <pages> pages 15-25, </pages> <address> Portland, OR, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: 1 Introduction Automatic storage reclamation, or garbage collection (GC), is becoming recognized as an important new feature for object database management systems (ODBMSs). A number of recent research papers have considered some of the important aspects of the correctness and performance of ODBMS garbage collection <ref> [AFG95, CWZ94, KLW89, KW93, YNY94] </ref>. A recently proposed standard suggests using garbage collection for at least some of the programmatic interfaces to an ODBMS [Cat93]. Commercial ODBMSs are now providing implementations of garbage collection (e.g., [Cor94]). This work was supported in part by the National Science Foundation under grant IRI-95-21046. <p> Furthermore, our collection rate policies add only little time and space overhead. We also show that our results hold across databases with different object connectivities. While there has been a significant amount of research in object database garbage collection <ref> [AFG95, Bj93, But87, CA86, CWZ94, KLW89, KW93, ML94, Mat85, YNY94] </ref>, none of that previous work has investigated the issue of collection rate. <p> In particular, we make the simplifying assumptions that the entire database is locked while collection is performed, and that logging for recovery is not supported. Clearly, more sophisticated mechanisms must be provided in actual implementations; proposals for such mechanisms are discussed elsewhere <ref> [AFG95, KLW89, KW93, YNY94] </ref>. We evaluate the performance of the policies based on multiple simulation runs that differ only in the initial random number seed. In our results, we present the mean of the values over time. Each simulation run experiences a cold-start of the database.
Reference: [KW93] <author> Elliot Kolodner and William Weihl. </author> <title> Atomic incremental garbage collection and recovery for a large stable heap. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on the Management of Data, </booktitle> <pages> pages 177-186, </pages> <address> Washington, DC, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Automatic storage reclamation, or garbage collection (GC), is becoming recognized as an important new feature for object database management systems (ODBMSs). A number of recent research papers have considered some of the important aspects of the correctness and performance of ODBMS garbage collection <ref> [AFG95, CWZ94, KLW89, KW93, YNY94] </ref>. A recently proposed standard suggests using garbage collection for at least some of the programmatic interfaces to an ODBMS [Cat93]. Commercial ODBMSs are now providing implementations of garbage collection (e.g., [Cor94]). This work was supported in part by the National Science Foundation under grant IRI-95-21046. <p> Furthermore, our collection rate policies add only little time and space overhead. We also show that our results hold across databases with different object connectivities. While there has been a significant amount of research in object database garbage collection <ref> [AFG95, Bj93, But87, CA86, CWZ94, KLW89, KW93, ML94, Mat85, YNY94] </ref>, none of that previous work has investigated the issue of collection rate. <p> In particular, we make the simplifying assumptions that the entire database is locked while collection is performed, and that logging for recovery is not supported. Clearly, more sophisticated mechanisms must be provided in actual implementations; proposals for such mechanisms are discussed elsewhere <ref> [AFG95, KLW89, KW93, YNY94] </ref>. We evaluate the performance of the policies based on multiple simulation runs that differ only in the initial random number seed. In our results, we present the mean of the values over time. Each simulation run experiences a cold-start of the database.
Reference: [Mat85] <author> David C. J. Matthews. </author> <title> Poly manual. </title> <journal> SIGPLAN Notices, </journal> <volume> 20(9), </volume> <month> September </month> <year> 1985. </year>
Reference-contexts: Furthermore, our collection rate policies add only little time and space overhead. We also show that our results hold across databases with different object connectivities. While there has been a significant amount of research in object database garbage collection <ref> [AFG95, Bj93, But87, CA86, CWZ94, KLW89, KW93, ML94, Mat85, YNY94] </ref>, none of that previous work has investigated the issue of collection rate.
Reference: [ML94] <author> Umesh Maheshwari and Barbara Liskov. </author> <title> Fault-tolerant distributed garbage collection in a client-server, object-oriented database. </title> <booktitle> In Proceedings of the Parallel and Distributed Information Systems, </booktitle> <pages> pages 239-248, </pages> <address> Austin, TX, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: Furthermore, our collection rate policies add only little time and space overhead. We also show that our results hold across databases with different object connectivities. While there has been a significant amount of research in object database garbage collection <ref> [AFG95, Bj93, But87, CA86, CWZ94, KLW89, KW93, ML94, Mat85, YNY94] </ref>, none of that previous work has investigated the issue of collection rate.
Reference: [Wil92] <author> Paul R. Wilson. </author> <title> Uniprocessor garbage collection techniques. </title> <booktitle> In Proceedings of the International Workshop on Memory Management, </booktitle> <address> St. Malo, France, </address> <month> September </month> <year> 1992. </year>
Reference-contexts: Partitioned collection is an incremental technique based on manipulating disjoint portions of a database [YNY94] and is akin to generational collection in programming language systems <ref> [Wil92] </ref>. We categorized the issues into a number of policy areas that together contribute to a complete garbage collection algorithm. We described the results of our investigation in one policy area, partition selection, which is the selection of which partition of a database to collect during a given garbage collection.
Reference: [WJMK94] <author> Jr. William J. McIver and Roger King. </author> <title> Self-adaptive, on-line reclustering of complex object data. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on the Management of Data, </booktitle> <pages> pages 407-418, </pages> <address> Minneapolis, MN, </address> <month> March </month> <year> 1994. </year>
Reference-contexts: In recent work, for example, McIver and King <ref> [WJMK94] </ref> investigate the performance of an algorithm in which on-line reclustering is triggered when a measure of reference locality (the "external tension") exceeds a certain threshold and when a cluster analysis determines that reclustering might improve performance.
Reference: [YNY94] <author> Voon-Fee Yong, Jeffrey Naughton, and Jie-Bing Yu. </author> <title> Storage reclamation and reorganization in client-server persistent object stores. </title> <booktitle> In Proc. of the 10th International Conference on Data Engineering, </booktitle> <pages> pages 120-131, </pages> <month> February </month> <year> 1994. </year> <month> 388 </month>
Reference-contexts: 1 Introduction Automatic storage reclamation, or garbage collection (GC), is becoming recognized as an important new feature for object database management systems (ODBMSs). A number of recent research papers have considered some of the important aspects of the correctness and performance of ODBMS garbage collection <ref> [AFG95, CWZ94, KLW89, KW93, YNY94] </ref>. A recently proposed standard suggests using garbage collection for at least some of the programmatic interfaces to an ODBMS [Cat93]. Commercial ODBMSs are now providing implementations of garbage collection (e.g., [Cor94]). This work was supported in part by the National Science Foundation under grant IRI-95-21046. <p> SIGMOD '96 6/96 Montreal, Canada c fl 1996 ACM 0-89791-794-4/96/0006:: : $3.50 In a previous paper [CWZ94] we presented a framework for investigating the issues surrounding partitioned garbage collection of ODBMSs. Partitioned collection is an incremental technique based on manipulating disjoint portions of a database <ref> [YNY94] </ref> and is akin to generational collection in programming language systems [Wil92]. We categorized the issues into a number of policy areas that together contribute to a complete garbage collection algorithm. <p> Although we do not explore this dimension here, our policies can be extended to handle such situations. We present a performance evaluation of our two 378 new collection rate policies that is based on trace-driven simulations of an application developed by Yong, Naughton, and Yu <ref> [YNY94] </ref> for the OO7 ODBMS benchmark [CDN93]. The application consists of four distinct phases, each exhibiting behavior different from the one that it precedes. Figure 2 illustrates the progression of the phases, which we describe fully in Section 3. <p> Furthermore, our collection rate policies add only little time and space overhead. We also show that our results hold across databases with different object connectivities. While there has been a significant amount of research in object database garbage collection <ref> [AFG95, Bj93, But87, CA86, CWZ94, KLW89, KW93, ML94, Mat85, YNY94] </ref>, none of that previous work has investigated the issue of collection rate. <p> For example, Yong, Naughton, and Yu propose a partitioned garbage collection policy, but assume that collection is triggered either when free-space becomes unavailable or after a fixed amount of storage is allocated <ref> [YNY94] </ref>. Their concern in that work is in comparing partitioned garbage collection against other approaches, and they choose a collection rate policy drawn from the realm of programming languages. <p> In particular, we make the simplifying assumptions that the entire database is locked while collection is performed, and that logging for recovery is not supported. Clearly, more sophisticated mechanisms must be provided in actual implementations; proposals for such mechanisms are discussed elsewhere <ref> [AFG95, KLW89, KW93, YNY94] </ref>. We evaluate the performance of the policies based on multiple simulation runs that differ only in the initial random number seed. In our results, we present the mean of the values over time. Each simulation run experiences a cold-start of the database. <p> For the time-varying results shown, preambles are 10 collections. 3.3 Test Database Structure The test database used in our measurements is the OO7 benchmark [CDN93], which was also used by Yong, Naughton, and Yu in their work on garbage collection <ref> [YNY94] </ref>. Table 1 shows how the characteristics of our Small 0 OO7 database that we measured compares to the Small database used by Yong, Naughton, and Yu, and described in [CDN93].
References-found: 18

