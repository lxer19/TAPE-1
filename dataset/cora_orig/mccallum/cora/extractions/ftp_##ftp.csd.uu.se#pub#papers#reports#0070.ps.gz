URL: ftp://ftp.csd.uu.se/pub/papers/reports/0070.ps.gz
Refering-URL: http://www.csd.uu.se/papers/reports.html
Root-URL: 
Title: Reform Compilation for Nonlinear Recursion  
Author: H-akan Millroth 
Address: Box 520, S-751 20 Uppsala, Sweden  
Affiliation: Computing Science Dept., Uppsala University  
Abstract: We present a method for compiling nonlinear recursion in logic programming to parallel iteration (for-loops). The method results in less unification work and fewer procedure calls than implementations of SLD-resolution. The principal restriction is that the recursion depth of the computation must depend only on the size of the input arguments.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Barklund, J. </author> <title> Parallel Unification, </title> <type> Ph.D. Thesis, </type> <institution> Computing Science Dept., Up-psala University, </institution> <year> 1990. </year>
Reference-contexts: Unlike head unification in SLD-resolution, which is split up in many small subunifications, we have one single, large unification problem when invoking the clause. Here we can take advantage of techniques for parallel unification, e.g., the algorithms developed by Barklund <ref> [1] </ref>. Second, in the for-loops comprising the clause body. We can apply loop-parallelization techniques to these loops. In effect, we obtain a form of AND-parallelism that we refer to as recursion parallelism, since it amounts to computing all recursion levels in parallel. <p> The proof of Teorems 4.4-6 below are similar and therefore omitted. Example. If 2 = f: : : ; x 1 = y 2 ; : : :g and l = <ref> [1; 1; 0; 0; 1; 0; 0; 0] </ref> (cf. Fig. 3.1), then: i x i n i x i n 2 y 3 6 x 6 4 x 4 8 x 8 POSR-variables. <p> Example. If 2 = f: : : ; x 1 = T (u 2 ; x 2 ; y 2 ); : : :g and l = <ref> [1; 1; 0; 0; 1; 0; 0; 0] </ref> (cf. Fig. 3.1), then: i x i n i x i n 2 T (u 3 ; x 3 ; y 3 ) 6 x 6 4 x 4 8 x 8 POSRR-variables. <p> Implementation of this operation (and the closely related question of tree representation) is not discussed in this paper. Example (continued). The head of the Sum program is compiled to: (u; x; y; l; r; n) preorder (A1); z <ref> [1] </ref> A2; 5.2. Computation of Reform series The Reform series of some variables are created during head unification. This is the case for POSLL- and POSRR-variables and for NONE-variables occuring as node elements in recursion trees.
Reference: 2. <author> Clark, K.L. </author> <title> Negation as failure, Logic and Data Bases (eds. </title> <editor> H. Gallaire & J. Minker), </editor> <publisher> Plenum Press, </publisher> <year> 1978. </year>
Reference-contexts: denoted by soln (X ), with respect to an equality theory T , is a set of equations on solved form such that T j= X if and only if T j= soln (X ): In this paper we fix T to be the syntactic equality theory given by Clark <ref> [2] </ref>. Let = fx 1 = t 1 ; : : :; x n = t n g be the solution of a set of equations and let w be a term.
Reference: 3. <author> Millroth, H. </author> <title> Reforming Compilation of Logic Programs, </title> <type> Ph.D. Thesis, </type> <institution> Computing Science Dept., Uppsala University, </institution> <year> 1990. </year> <title> (Summary in: </title> <booktitle> Proc. Int. Logic Programming Symp., </booktitle> <address> San Diego, CA., </address> <month> October </month> <year> 1991) </year>
Reference-contexts: 1. Introduction Reform compilation <ref> [3] </ref> is a new compilation method for recursive logic programs which is based on the idea of compiling recursion to parallel iteration (for-loops) [3]. It can be viewed as a method for compiling programs using the Reform inference system [5]. <p> 1. Introduction Reform compilation <ref> [3] </ref> is a new compilation method for recursive logic programs which is based on the idea of compiling recursion to parallel iteration (for-loops) [3]. It can be viewed as a method for compiling programs using the Reform inference system [5]. The main motivation for Reform compilation is increased potential for efficient parallel processing. Let us briefly describe the method for the case of linear recursion. <p> Fortunately, it is possible to precompile into efficient closed-form expressions <ref> [3] </ref>. 1 Throughout the paper we let upper-case greek letters, such as and , denote possibly empty conjunctions of literals. Where can we exploit parallelism in the compiled clause? First, in the head unification.
Reference: 4. <author> Robinson, J.A. </author> <title> A machine-oriented logic based on the resolution principle. </title> <journal> Journal of the ACM 12 (1965), </journal> <pages> 23-41. </pages>
Reference-contexts: The problem of finding a solution of a set of equations ft 1 = t 0 1 ; : : : ; t n = t 0 can be recasted as a unification <ref> [4] </ref> problem: find a most general unifier such that t i t 0 i , where is syntactic equality, for i = 1; : : : ; n. 2.3. <p> If 2 = f: : : ; x 1 = y 2 ; : : :g and r = <ref> [5; 4; 0; 0; 8; 7; 0; 0] </ref> (cf. Fig. 3.1), then: i x i n i x i n 2 y 4 6 y 7 4 x 4 8 x 8 4.4. <p> Example. If 2 = f: : : ; x 1 = T (u 2 ; y 2 ; x 2 ); : : :g and r = <ref> [5; 4; 0; 0; 8; 7; 0; 0] </ref> (cf. Fig. 3.1), then: i x i n i x i n 2 T (u 4 ; y 4 ; x 4 ) 6 T (u 7 ; y 7 ; x 7 ) 4 x 4 8 x 8 5.
Reference: 5. <author> Tarnlund, S. A. Reform, </author> <type> report, </type> <institution> Uppsala University. </institution>
Reference-contexts: 1. Introduction Reform compilation [3] is a new compilation method for recursive logic programs which is based on the idea of compiling recursion to parallel iteration (for-loops) [3]. It can be viewed as a method for compiling programs using the Reform inference system <ref> [5] </ref>. The main motivation for Reform compilation is increased potential for efficient parallel processing. Let us briefly describe the method for the case of linear recursion. <p> The unfolded clause can reduce a goal of "size" n in a single, direct step. This is the idea on which Tarnlund's Reform inference system <ref> [5] </ref> is based. The unfolded clause is called the nth reforment. The program obtained with Reform compilation is a parameterized representation of the nth reforment. <p> The transformed program is: IsoTree (;, ;). IsoTree (T (u, x, y), T (u, x1, y1)) Iso (x1, x2, y1, y2) ^^ ^ IsoTree (x, x2) ^^ ^ IsoTree (y, y2). Iso (x, x, y, y). 3. Nonlinear Reform Tarnlund's Reform inference system <ref> [5] </ref> uses program transformation as a method of computation. The basic idea is to transform (at run-time) recursive programs to an "unfolded" form which can be used to solve a goal in a single, direct step. <p> If 2 = f: : : ; x 1 = y 2 ; : : :g and r = <ref> [5; 4; 0; 0; 8; 7; 0; 0] </ref> (cf. Fig. 3.1), then: i x i n i x i n 2 y 4 6 y 7 4 x 4 8 x 8 4.4. <p> Example. If 2 = f: : : ; x 1 = T (u 2 ; y 2 ; x 2 ); : : :g and r = <ref> [5; 4; 0; 0; 8; 7; 0; 0] </ref> (cf. Fig. 3.1), then: i x i n i x i n 2 T (u 4 ; y 4 ; x 4 ) 6 T (u 7 ; y 7 ; x 7 ) 4 x 4 8 x 8 5.
References-found: 5

