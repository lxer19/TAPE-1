URL: http://hellgate.cs.nyu.edu:8888/~leunga/papers/research/prop.ps
Refering-URL: http://hellgate.cs.nyu.edu:8888/~leunga/prop.html
Root-URL: http://www.cs.nyu.edu
Title: Prop: A C++-based Pattern Matching Language  
Author: Allen Leung 
Keyword: C++ programs. Keywords: pattern matching, object-oriented programming, rewriting, semantic based optimization, compiler generation  
Date: March 6, 1996  
Affiliation: Courant Institute of Mathematical Sciences  
Abstract: In this paper we introduce Prop, a multiparadigm extension of C++ with Standard ML-style algebraic datatypes and pattern matching, tree rewriting, DATALOG-style forward chaining inference, and constraint logical programming. Applications written in Prop can utilize various cooperating formalisms, integrated into the object oriented paradigm of the base language. We use efficient automata-based and semantics based algorithms to generate various pattern matching constructs into efficient and lightweight C++ programs. Interoperability with the base language is achieved transparently since all high level data structures in Prop are mapped into classes. Furthermore, we use conservative garbage collection schemes to minimize interaction with existing code by eliminating the need for manual storage management. Typical Prop program sources are 2-10 times more compact than equivalent programs written in C++. Our benchmarks also show that programs written in Prop's high level formalisms are competitive with native 
Abstract-found: 1
Intro-found: 1
Reference: [AF] <author> Guiseppe Attardi and Tito Flagella. </author> <title> A customisable memory management framework. </title> <type> Technical report, </type> <institution> University of Pisa. </institution> <note> 2 Currently, finalization synchronization must be handled by the object itself. 25 </note>
Reference-contexts: Programs written in Prop can readily utilize existing code and libraries with little change. An optional conservative garbage collector based on <ref> [ED93, AF] </ref> can also be linked into the runtime system for Prop programs that desire automatic memory reclamation. Prop will appeal to two main groups of users. The first are programmers working in C++ but are seeking to incorporate higher level tools without abandoning existing libraries and object oriented frameworks. <p> Garbage collection We use a conservative garbage collector whose framework is based on the work of Customisible Memory Management <ref> [AF] </ref> in the PoSSe algebraic system. This scheme is in turns based on the work on mostly-copying garbage collection by Bartlett [Bar88] in the Scheme to C runtime system. Similar to CMM, garbage collectable objects in Prop are all derived from the base class GCObject.
Reference: [AGT89] <author> Alfred V. Aho, Mahadevan Ganapathi, and Steven W. K. Tjiang. </author> <title> Code generation using tree matching and dynamic programming. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(4) </volume> <pages> 491-516, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: Equational rules can often be used to specify semantics based simplification (e.g. constant folding and simplification based on simple algebraic identities) or transformation (e.g. code selection in a compiler backend <ref> [AGT89] </ref>). Unlike plain pattern matching, however, the structural traversal process in rewriting is implicitly inferred from the type structure of an algebraic datatype, as specified in its definition. Thus when changing the structure of a datatype, unaffected patterns in rewriting rules do not have to be altered.
Reference: [ASU86] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. </author> <booktitle> Compilers: Principles, Techniques and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: Prop is designed as a development language for interpreters, compilers, and language translation and transformation tools <ref> [ASU86, ?] </ref>. It simplifies the construction of these systems by providing high level declarative and rule based formalisms on top of the traditional procedural and object-oriented paradigms of the base language.
Reference: [Bar88] <author> Joel F. Bartlett. </author> <title> Compacting garbage collection with ambiguous roots. </title> <type> Technical Report 88/2, </type> <institution> DEC Western Research Laboratory, Palo Alto, California, </institution> <month> Febrarry </month> <year> 1988. </year>
Reference-contexts: Garbage collection We use a conservative garbage collector whose framework is based on the work of Customisible Memory Management [AF] in the PoSSe algebraic system. This scheme is in turns based on the work on mostly-copying garbage collection by Bartlett <ref> [Bar88] </ref> in the Scheme to C runtime system. Similar to CMM, garbage collectable objects in Prop are all derived from the base class GCObject. <p> By detaching the traversal method from the specific implementation of the garbage collectors, we are able to implement various garbage collection algorithms that can coexist with each other. Two main collection algorithms have been implemented: * A mostly-copying algorithm based on <ref> [Bar88] </ref>. * A non-moving mark-sweep style collector. The copying collector is used as the default in Prop since, unlike C or C++ programs, Prop programs written in an applicative style typically generate more short term objects than an equivalent C or C++ program.
Reference: [Bar89] <author> Joel F. Bartlett. </author> <title> Mostly-copying collection picks up generations and C++. </title> <type> Technical Report TN-12, </type> <institution> DEC Western Research Laboratory, Palo Alto, California, </institution> <month> October </month> <year> 1989. </year>
Reference-contexts: Furthermore, since unused pages are not dirtied they will not need to be swapped out by virtual memory. For extra efficiently, we plan to implement memory mapping/unmapping with mmap/munmap (or their equivalent) for OSes supporting these features. Future optimizations We also plan to implement a generation scheme, such as <ref> [Bar89] </ref>. However, since assignment is a common operation in C++, the cost of implementing a write barrier may become prohibitively high. Furthermore, it is unclear how this can be implemented while maintaining compatibility with existing code.
Reference: [Boe93] <author> Hans-Juergen Boehm. </author> <title> Space efficient conservative garbage collection. </title> <booktitle> ACM SIGPLAN PLDI, </booktitle> <pages> pages 197-206, </pages> <year> 1993. </year>
Reference-contexts: The C++ destructors are called for each collectable object when its storage is reclaimed 2 And finally, * Weak pointers to collectable heaps. Some optimizations We have implemented a few optimizations in the collector. The most important of these is a variant of blacklisting scheme proposed in <ref> [Boe93] </ref> for a mark-sweep style GC: when new memory is allocated, we discard all pages whose addresses may be misidentified as live data in the future. Unlike Boehm's scheme, however, we choose to blacklist an entire page (512 bytes) rather than a single object at a time in our scheme.
Reference: [Cha87] <author> David R. Chase. </author> <title> An imporvement to bottom-up tree pattern matching. </title> <booktitle> Proceedings Fourteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 168-177, </pages> <year> 1987. </year>
Reference-contexts: An algorithm derived from the work on adaptive matching [?] is used in the pattern matching optimizer. Rewriting in Prop is currently performed in a bottom-up manner. Rewriting rules are gathered and compiled into a bottom-up tree automaton using algorithms described in <ref> [Cha87, ?] </ref>. Finally, inference rules are compiled into a table-driven RETE-network. Design principles Although the design and development of Prop have progressed in an ad hoc manner, mostly driven by need, and sometimes by passing interesting, certain design principles have been maintained. <p> Unfortunately, this algorithm is co N P for typed patterns, so instead we use a few heuristics proposed in the paper to select the traversal order. Rewriting in Prop is compiled into bottom-up tree automata [HO82] with an index map compression heuristic <ref> [Cha87] </ref>. Large index maps are also compressed on a secondary level using [?]'s algorithm for trie compression. BURS-like tree automata [?] are generated for tree automata with fixed reduction cost, while tree automata with runtime determined cost functions are compiled into code that performs cost minimization using dynamic programming.
Reference: [ED93] <author> J.R. Ellis and D.L. Detlefs. </author> <title> Safe, efficient garbage collection for C++. </title> <type> Technical Report CSL-93-4, </type> <note> Xerox Parc, </note> <year> 1993. </year>
Reference-contexts: Programs written in Prop can readily utilize existing code and libraries with little change. An optional conservative garbage collector based on <ref> [ED93, AF] </ref> can also be linked into the runtime system for Prop programs that desire automatic memory reclamation. Prop will appeal to two main groups of users. The first are programmers working in C++ but are seeking to incorporate higher level tools without abandoning existing libraries and object oriented frameworks.
Reference: [Ede92] <author> Daniel R. Edelson. </author> <title> Comparing two garbage collectors for C++. </title> <type> Technical Report USCS-CRL-93-20, </type> <institution> University of California at Santa Cruz, </institution> <year> 1992. </year>
Reference-contexts: This object tracing method is generated automatically for each user defined datatype by the datatype compiler. The collectors can discover the current root set by scanning the stack, registers, static data and heap areas. Thus no root registration or inefficient smart pointer schemes <ref> [Ede92] </ref> are necessary: a pointer to a collectable object looks the same as any other pointers and can be placed inside machines registers or otherwise optimized by the compiler in the same manner.
Reference: [GHJV95] <author> Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: Each subclass of GCObject reimplements the virtual function trace (GC *), which is responsible for providing type feedback by traversing the pointers within the object and calling a garbage collector method for each pointer found. Garbage collector objects are implemented as visitors <ref> [GHJV95] </ref>. This object tracing method is generated automatically for each user defined datatype by the datatype compiler. The collectors can discover the current root set by scanning the stack, registers, static data and heap areas.
Reference: [HMM86] <author> Robert Harper, David MacQueen, and Robin Milner. </author> <title> Standard ML. </title> <type> Report ECS-LFCS-86-2, </type> <institution> Laboratory for Foundations of Computer Science, Computer Science Department, Edinburgh University, </institution> <year> 1986. </year>
Reference-contexts: 1 Introduction In this paper we introduce Prop, an extension of C++[Str91, ?] that includes string matching, algebraic datatypes, Standard ML-style pattern matching <ref> [HMM86, RMH90, ?, ?] </ref>, pretty printing, tree rewriting [SPvE93], DATALOG-style inference [?], constraint logic programming [?] and simple persistence as built-in features. Prop is designed as a development language for interpreters, compilers, and language translation and transformation tools [ASU86, ?].
Reference: [HO82] <author> Christoph H. Hoffmann and Michael J. O'Donnell. </author> <title> Pattern matching in trees. </title> <journal> Journal of the ACM, </journal> <volume> 29(1) </volume> <pages> 68-95, </pages> <month> January </month> <year> 1982. </year>
Reference-contexts: Unfortunately, this algorithm is co N P for typed patterns, so instead we use a few heuristics proposed in the paper to select the traversal order. Rewriting in Prop is compiled into bottom-up tree automata <ref> [HO82] </ref> with an index map compression heuristic [Cha87]. Large index maps are also compressed on a secondary level using [?]'s algorithm for trie compression.
Reference: [Les75] <author> M. E. Lesk. LEX: </author> <title> a lexical analyzer generator. </title> <type> Technical Report 39, </type> <institution> AT&T Bell Laboratories, </institution> <address> Murray Hill, N.J., </address> <year> 1975. </year>
Reference-contexts: Algebraic datatypes may specify their pretty printed format in a declarative manner. Lexical analysis The scanner class mechanism in Prop provides functionalities similar to what is offered in modern lexical analyzer generators such as lex <ref> [Les75] </ref>, flex [Pax90], and dlg [PDC91] etc. Instances of scanner classes are simply lexical scanners (with possibly additional encapsulated states) taking input from a I/O stream and generating a stream of lexemes.
Reference: [Pax90] <author> V. Paxson. </author> <title> Using flex | a fast lexical analyzer. </title> <type> Technical report, </type> <institution> The Regents of the University of California, </institution> <month> May </month> <year> 1990. </year>
Reference-contexts: Algebraic datatypes may specify their pretty printed format in a declarative manner. Lexical analysis The scanner class mechanism in Prop provides functionalities similar to what is offered in modern lexical analyzer generators such as lex [Les75], flex <ref> [Pax90] </ref>, and dlg [PDC91] etc. Instances of scanner classes are simply lexical scanners (with possibly additional encapsulated states) taking input from a I/O stream and generating a stream of lexemes.
Reference: [PDC91] <author> T. Parr, H. Dietz, and W. Cohen. </author> <title> PCCTS reference manual. </title> <type> Technical Report TR-EE 90-14, </type> <institution> Puerdue University, West Lafayette, Indiana, </institution> <month> August </month> <year> 1991. </year>
Reference-contexts: Algebraic datatypes may specify their pretty printed format in a declarative manner. Lexical analysis The scanner class mechanism in Prop provides functionalities similar to what is offered in modern lexical analyzer generators such as lex [Les75], flex [Pax90], and dlg <ref> [PDC91] </ref> etc. Instances of scanner classes are simply lexical scanners (with possibly additional encapsulated states) taking input from a I/O stream and generating a stream of lexemes. Unit datatypes (i.e. algebraic datatypes with only non-argument taking variants) can be used to stand for lexemes generated by a lexical scanner. <p> Grammar rules are specified in a BNF-like form similar to that of yacc. Prop currently generates table driven LALR (1) parsers. Shift/reduce conflicts can be resolved using optional operator precedence information, or with optional semantics predicates similar to that in PCCTS <ref> [PDC91] </ref>. Actions may be attached to a grammar, and during parsing, these actions have access to the member data and functions, and inherited and synthesized attributes. <p> Frequently this involves the insertion of non-declarative actions inside the parser or lexer specifications. We borrow a new construct, the semantic predicate, which allows a clean separation of these context sensitive feedback, from the parser generator tool PCCTS <ref> [PDC91] </ref> Aside from terminals, non-terminals and semantic actions, a production can also contain semantic predicates. During parsing, these semantic predicates are evaluated, and productions which contain unsatisfied predicates will be rejected. For example, to deal with the type/variable identifier ambiguity in a language like C, the following productions are needed.
Reference: [RMH90] <author> Mads Tofte Robin Miller and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> The MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction In this paper we introduce Prop, an extension of C++[Str91, ?] that includes string matching, algebraic datatypes, Standard ML-style pattern matching <ref> [HMM86, RMH90, ?, ?] </ref>, pretty printing, tree rewriting [SPvE93], DATALOG-style inference [?], constraint logic programming [?] and simple persistence as built-in features. Prop is designed as a development language for interpreters, compilers, and language translation and transformation tools [ASU86, ?].
Reference: [SPvE93] <author> M. R. Sleep, M. J. Plasmeijer, and M. C. J. D. van Eekelen, </author> <title> editors. Term Graph Rewriting. Theory and Practice. </title> <publisher> John Wiley & Sons, </publisher> <year> 1993. </year>
Reference-contexts: 1 Introduction In this paper we introduce Prop, an extension of C++[Str91, ?] that includes string matching, algebraic datatypes, Standard ML-style pattern matching [HMM86, RMH90, ?, ?], pretty printing, tree rewriting <ref> [SPvE93] </ref>, DATALOG-style inference [?], constraint logic programming [?] and simple persistence as built-in features. Prop is designed as a development language for interpreters, compilers, and language translation and transformation tools [ASU86, ?].
Reference: [Str91] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <note> Second Edition. Addison-Welsey, 1991. 26 </note>
References-found: 18

