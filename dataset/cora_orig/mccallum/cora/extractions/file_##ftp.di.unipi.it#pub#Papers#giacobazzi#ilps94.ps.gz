URL: file://ftp.di.unipi.it/pub/Papers/giacobazzi/ilps94.ps.gz
Refering-URL: http://www.di.unipi.it/di/groups/lp/papers.html
Root-URL: 
Email: E-mail: giaco@lix.polytechnique.fr  
Title: Abductive Analysis of Modular Logic Programs  
Author: Roberto Giacobazzi 
Address: 91128 Palaiseau cedex (France)  
Affiliation: LIX, Laboratoire d'Informatique Ecole Polytechnique  
Abstract: We introduce a practical method for abductive analysis of modular logic programs. This is obtained by reversing the deduction process, which is usually applied in static-dataflow analysis of logic programs. The approach is validated in the framework of abstract interpretation. The abduced information provides an abstract specification for program modules which can be of assistance both in top-down development of programs and in compile-time optimization. To the best of our knowledge this is the first application of abductive reasoning in dataflow analysis of logic programs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. R. Apt. </author> <title> Introduction to Logic Programming. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B: Formal Models and Semantics, </booktitle> <pages> pages 495-574. </pages> <publisher> Elsevier, </publisher> <address> Amsterdam, </address> <year> 1990. </year>
Reference-contexts: Some applications are discussed in Section 5. 2 Preliminaries In the following we assume familiarity with the standard definitions and notation for logic programs <ref> [1] </ref>, constraint logic programs [17, 15] and abstract interpretation [9]. The powerset of a set X is denoted by -(X ). A poset with domain X and partial order v is denoted X v .
Reference: [2] <author> R. Barbuti, R. Giacobazzi, and G. Levi. </author> <title> A General Framework for Semantics-based Bottom-up Abstract Interpretation of Logic Programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 133-181, </pages> <year> 1993. </year>
Reference-contexts: This deductive approach to logic program analysis is usually based on abstract unfolding (i.e. replacement + abstract unification) and is shared by several of the frameworks proposed in the literature (e.g., see <ref> [2, 4, 5, 6, 10, 20] </ref>). In [6] this approach has been applied to modular logic programs providing a compositional analysis in presence of modules. Compositional abstract interpretation is essential for large program development so that altering one module does not require re-analysis of the entire program.
Reference: [3] <author> A. Bossi, M. Gabbrielli, G. Levi, and M. C. Meo. </author> <title> A Compositional Semantics for Logic Programs. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 122(1-2):3-47, </address> <year> 1994. </year>
Reference-contexts: A logic program is viewed as consisting of a set of modules, each module defining a subset of the program's predicates. Analyses are constructed by considering abstract interpretations of the compositional semantics introduced in <ref> [3] </ref>. The abstract meaning of a module corresponds to its analysis and composition of abstract meanings corresponds to composition of analyses. <p> Following Bossi et al. <ref> [3] </ref> we consider sets of clauses modulo the following notion of equivalence between clauses: we say that (h [] b) ~ (h 0 0 [] b 0 ) iff there exists a permutation b 00 of atoms in b 0 such that (h b) 0 (h 0 b 00 ). <p> For simplicity of exposition, we will abuse notation and assume that a clause represents its equivalence class under ~ and write Clause rather than [Clause] ~ . 3 Concrete and abstract semantics In the following, we resume the main results in concrete semantics for composition in <ref> [3] </ref> and compositional analysis in [6]. If P 1 ; : : : ; P n are logic program modules, then P = [ n i=1 P i is a modular logic program. <p> , open (P ) denotes the set of predicates that occur in the body of a clause in P but are not defined in P (we often call them abducible predicates) 1 . 3.1 Concrete semantics for composition The base semantics is the compositional bottom-up semantics of Bossi et al. <ref> [3] </ref>, instantiated to the case of predicate disjoint modules. In [3], an interpretation is any element in Int = -(Clause). Programs and interpretations have then the same structure (i.e., sets of clauses). <p> occur in the body of a clause in P but are not defined in P (we often call them abducible predicates) 1 . 3.1 Concrete semantics for composition The base semantics is the compositional bottom-up semantics of Bossi et al. <ref> [3] </ref>, instantiated to the case of predicate disjoint modules. In [3], an interpretation is any element in Int = -(Clause). Programs and interpretations have then the same structure (i.e., sets of clauses). <p> A bottom-up semantics for open logic programs is defined in <ref> [3] </ref> in terms of "iterated unfolding" | that is, repeatedly unfolding the clauses in a program until further unfolding produces no change. <p> The idea of Bossi et al. <ref> [3] </ref>, is to unfold only those predicates which have a definition, so that the meaning of a program becomes dependent on the meaning of its open predicates. <p> When I consists of unit clauses (facts), the fixpoint operator gives precisely the (non-ground) fixpoint semantics of Falaschi et al. [12]. The following formalizes the notion of compositional semantics based on clause unfolding and provides the basis for the compositional analyses described below. Theorem 3.1 [concrete composition <ref> [3] </ref>] Let P 1 and P 2 be modules.
Reference: [4] <author> M. Bruynooghe. </author> <title> A Practical Framework for the Abstract Interpretation of Logic Programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 10 </volume> <pages> 91-124, </pages> <year> 1991. </year>
Reference-contexts: This deductive approach to logic program analysis is usually based on abstract unfolding (i.e. replacement + abstract unification) and is shared by several of the frameworks proposed in the literature (e.g., see <ref> [2, 4, 5, 6, 10, 20] </ref>). In [6] this approach has been applied to modular logic programs providing a compositional analysis in presence of modules. Compositional abstract interpretation is essential for large program development so that altering one module does not require re-analysis of the entire program.
Reference: [5] <author> M. Codish, D. Dams, and E. Yardeni. </author> <title> Bottom-up Abstract Interpretation of Logic Programs. </title> <journal> Theoretical Computer Science, </journal> <volume> 124(1) </volume> <pages> 93-126, </pages> <year> 1994. </year>
Reference-contexts: This deductive approach to logic program analysis is usually based on abstract unfolding (i.e. replacement + abstract unification) and is shared by several of the frameworks proposed in the literature (e.g., see <ref> [2, 4, 5, 6, 10, 20] </ref>). In [6] this approach has been applied to modular logic programs providing a compositional analysis in presence of modules. Compositional abstract interpretation is essential for large program development so that altering one module does not require re-analysis of the entire program.
Reference: [6] <author> M. Codish, S. K. Debray, and R. Giacobazzi. </author> <title> Compositional Analysis of Modular Logic Programs. </title> <booktitle> In Proc. Twentieth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 451-464. </pages> <publisher> ACM Press, </publisher> <year> 1993. </year>
Reference-contexts: This deductive approach to logic program analysis is usually based on abstract unfolding (i.e. replacement + abstract unification) and is shared by several of the frameworks proposed in the literature (e.g., see <ref> [2, 4, 5, 6, 10, 20] </ref>). In [6] this approach has been applied to modular logic programs providing a compositional analysis in presence of modules. Compositional abstract interpretation is essential for large program development so that altering one module does not require re-analysis of the entire program. <p> This deductive approach to logic program analysis is usually based on abstract unfolding (i.e. replacement + abstract unification) and is shared by several of the frameworks proposed in the literature (e.g., see [2, 4, 5, 6, 10, 20]). In <ref> [6] </ref> this approach has been applied to modular logic programs providing a compositional analysis in presence of modules. Compositional abstract interpretation is essential for large program development so that altering one module does not require re-analysis of the entire program. <p> simplicity of exposition, we will abuse notation and assume that a clause represents its equivalence class under ~ and write Clause rather than [Clause] ~ . 3 Concrete and abstract semantics In the following, we resume the main results in concrete semantics for composition in [3] and compositional analysis in <ref> [6] </ref>. If P 1 ; : : : ; P n are logic program modules, then P = [ n i=1 P i is a modular logic program. Such a program is said to be predicate disjoint if no predicate is defined in more than one module. <p> Such a program is said to be predicate disjoint if no predicate is defined in more than one module. We assume that modular programs are predicate disjoint unless otherwise specified: this assumption, considered also in <ref> [6, 18] </ref>, simplifies the presentation somewhat. <p> Then: F (P 1 [ P 2 ) = F (F (P 1 ) [ F (P 2 )). 3.2 Abstract semantics and deductive analysis The relevance of compositionality in logic program analysis has been firstly addressed in <ref> [6] </ref> by introducing a framework which is based on the compositional semantics F and which formalizes the analysis in terms of the standard theory of abstract interpretation ([9]). We follow [6] by assuming that (Int ; ff; AInt v ; fl) is a Galois insertion 2 and that the abstract semantics <p> )). 3.2 Abstract semantics and deductive analysis The relevance of compositionality in logic program analysis has been firstly addressed in <ref> [6] </ref> by introducing a framework which is based on the compositional semantics F and which formalizes the analysis in terms of the standard theory of abstract interpretation ([9]). We follow [6] by assuming that (Int ; ff; AInt v ; fl) is a Galois insertion 2 and that the abstract semantics F A : AInt ! AInt safely mimics F , i.e., for each I 2 Int: ff (F (I )) v F A (ff (I )). <p> The abstract semantics of a module P is F A (ff (P )). Theorem 3.2 [correctness of compositional analysis <ref> [6] </ref>] Let P 1 , P 2 be modules. Then: ff (F (P 1 [P 2 )) v F A (F A (ff (P 1 ))tF A (ff (P 1 ))). <p> It is a complete lattice AInt v with lub t, ordered by set-inclusion modulo ~ = . ~ = provides also variable hiding and equivalence up to renaming. This construction induces a Galois insertion (Int; ff; AInt; fl) as proved in <ref> [6] </ref>. The abstract unfolding operator unf A : AInt fi AInt ! AInt is defined in [6] as: unf A (P a 2 ) = &gt; &gt; &lt; h 0 [] b 1 :: :: b n fi fi fi fi 1 i=1 &lt;&lt; c P a 0 = ( i <p> This construction induces a Galois insertion (Int; ff; AInt; fl) as proved in <ref> [6] </ref>. The abstract unfolding operator unf A : AInt fi AInt ! AInt is defined in [6] as: unf A (P a 2 ) = &gt; &gt; &lt; h 0 [] b 1 :: :: b n fi fi fi fi 1 i=1 &lt;&lt; c P a 0 = ( i ff A (g i = h i )) &gt; &gt; = Likewise concrete unfolding, unf A <p> As observed in <ref> [6] </ref>, compositional analysis based on unfolding may not terminate even with finite or noetherian abstract domains for substitutions (constraints). This because the fixpoint iteration may introduce clauses with bodies containing an arbitrary number of open atoms. Some solutions to this problem have been proposed in [6, 13]. In [6] an additional <p> As observed in [6], compositional analysis based on unfolding may not terminate even with finite or noetherian abstract domains for substitutions (constraints). This because the fixpoint iteration may introduce clauses with bodies containing an arbitrary number of open atoms. Some solutions to this problem have been proposed in <ref> [6, 13] </ref>. In [6] an additional (and orthogonal) layer of abstraction, the ?-abstraction 4 , is applied to deal with unbounded clause bodies in the abstract semantics. This approach provides finitary descriptions for arbitrary large clauses, but makes the analysis less precise. <p> observed in <ref> [6] </ref>, compositional analysis based on unfolding may not terminate even with finite or noetherian abstract domains for substitutions (constraints). This because the fixpoint iteration may introduce clauses with bodies containing an arbitrary number of open atoms. Some solutions to this problem have been proposed in [6, 13]. In [6] an additional (and orthogonal) layer of abstraction, the ?-abstraction 4 , is applied to deal with unbounded clause bodies in the abstract semantics. This approach provides finitary descriptions for arbitrary large clauses, but makes the analysis less precise. <p> Clause bodies are restricted to contain at most one occurrence of each (open) predicate symbol. In this case, since is finite, the domain of abstract interpretations AInt results a finite-height lattice. The ?-abstracted compositional semantics is denoted F A ? . This semantics is compositional correct (see <ref> [6] </ref>), therefore (by Theorem 4.7) it can be correctly used in abstract abduction. The approach in [13] is oriented to provide a compositional complete abstract semantics. <p> Therefore, any two clauses h [] b and h 0 [] b generated for h b in F A are condensed into (approximated by) a single clause h t A 0 [] b. This restriction reduces the search space for T -stability. Moreover, as proved in <ref> [6] </ref>, ?-abstraction for Dep with condensing is compositional correct. Consider the "naive reverse" routine P rev rev ([],[]). rev ([X|Xs],Zs) :- rev (Xs,Ys), append (Ys,[X],Zs). 4 This technique was originally proposed in [7] as state-approximation for suspension analysis of concurrent logic programs. where the append procedure is open.
Reference: [7] <author> M. Codish, M. Falaschi, and K. Marriott. </author> <title> Suspension Analysis for Concurrent Logic Programs. </title> <editor> In K. Furukawa, editor, </editor> <booktitle> Proc. Eighth Int'l Conf. on Logic Programming, pages 331- 345. </booktitle> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1991. </year>
Reference-contexts: The T -stable semantics, denoted F A T , is proved to be compositional complete in [13, 14]. Example 6 In this example we consider the simpler abstract domain Dep adopted from <ref> [7] </ref>. Elements in Dep are propositional formulae on Var with connectives ^ and $, ordered by implication. It is straightforward to derive Dep by abstract interpretation of Prop. In the following of this example we assume condensing over all solutions i.e., interpretations can only contain single occurrences for any clause. <p> This restriction reduces the search space for T -stability. Moreover, as proved in [6], ?-abstraction for Dep with condensing is compositional correct. Consider the "naive reverse" routine P rev rev ([],[]). rev ([X|Xs],Zs) :- rev (Xs,Ys), append (Ys,[X],Zs). 4 This technique was originally proposed in <ref> [7] </ref> as state-approximation for suspension analysis of concurrent logic programs. where the append procedure is open. A finite compositional abstract se-mantics can be obtained by iterating unfolding until a T -stable sequence is reached.
Reference: [8] <author> A. Cortesi, G. File, and W. Winsborough. </author> <title> Prop revisited: Propositional Formula as Abstract Domain for Groundness Analysis. </title> <booktitle> In Proc. Sixth IEEE Symp. on Logic In Computer Science, </booktitle> <pages> pages 322-327. </pages> <publisher> IEEE Press, </publisher> <year> 1991. </year>
Reference-contexts: We call ground dependency any element in Prop. The corresponding abstract constraint system is (Prop; ^) which is well known to be correct and to form a Galois insertion with the concrete constraint system (C; ^) (e.g., see <ref> [8] </ref>). A safe approximation of F can be obtained by abstracting unfolding. Therefore, abstract semantic objects are descriptions (on A) of clauses. An abstract clause is an object of the form h [] b such that 2 A and h true [] b is normalized.
Reference: [9] <author> P. Cousot and R. Cousot. </author> <title> Systematic Design of Program Analysis Frameworks. </title> <booktitle> In Proc. Sixth ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 269-282. </pages> <publisher> ACM Press, </publisher> <year> 1979. </year>
Reference-contexts: Some applications are discussed in Section 5. 2 Preliminaries In the following we assume familiarity with the standard definitions and notation for logic programs [1], constraint logic programs [17, 15] and abstract interpretation <ref> [9] </ref>. The powerset of a set X is denoted by -(X ). A poset with domain X and partial order v is denoted X v . We write f : A ! B to mean that f is a total function of A into B . <p> with a binary associative and commutative 2 (D; ff; D 0 ; fl) is a Galois connection if D and D 0 v are complete lattices, ff : D ! D 0 and fl : D 0 ! D are monotonic functions such that ffffifl v id and flffiff id <ref> [9] </ref>. <p> It is immediate that: f exists iff f is additive, and f is uniquely determined by f (e.g., see <ref> [9] </ref>). We consider a program property as any element in -(Int).
Reference: [10] <author> S. K. Debray. </author> <title> Efficient Dataflow Analysis of Logic Programs. </title> <journal> Journal of the ACM, </journal> <volume> 39(4) </volume> <pages> 949-984, </pages> <year> 1992. </year>
Reference-contexts: This deductive approach to logic program analysis is usually based on abstract unfolding (i.e. replacement + abstract unification) and is shared by several of the frameworks proposed in the literature (e.g., see <ref> [2, 4, 5, 6, 10, 20] </ref>). In [6] this approach has been applied to modular logic programs providing a compositional analysis in presence of modules. Compositional abstract interpretation is essential for large program development so that altering one module does not require re-analysis of the entire program.
Reference: [11] <author> F. Denis and J.-P. Delahaye. </author> <title> Unfolding, Procedural and Fixpoint Semantics of Logic Programs. </title> <editor> In C. Choffrut and M. Jantzen, editors, </editor> <booktitle> STACS 91, volume 480 of Lecture Notes in Computer Science, </booktitle> <pages> pages 511-522. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1991. </year>
Reference-contexts: &gt; &lt; h 0 [] b 1 :: :: b n fi fi fi fi fi hh i i [] b i i n 0 = ^ ^ ( i ^ fg i = h i g) 9 &gt; &gt; &gt; &gt; ; unf is a binary associative operator (see <ref> [11] </ref>) on Int, which is additive on its first argument and continuous on its second one. A bottom-up semantics for open logic programs is defined in [3] in terms of "iterated unfolding" | that is, repeatedly unfolding the clauses in a program until further unfolding produces no change.
Reference: [12] <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> Declarative Modeling of the Operational Behavior of Logic Languages. </title> <journal> Theoretical Computer Science, </journal> <volume> 69(3) </volume> <pages> 289-318, </pages> <year> 1989. </year>
Reference-contexts: A semantic account of this is provided by showing that abstract abduction corresponds to the abstract weak-op-inverse (see [16]) of the traditional T P -based semantics described in <ref> [12] </ref>. This result further justifies the use of abductive analysis in systematic program development. From the program optimization viewpoint, it is worth noting that the applicability of optimization techniques to a program module may depend on the definition of its open predicates. <p> Moreover, note that if open (P ) = ; then P = ; and T P (I ) = unf (P ; I ). When I consists of unit clauses (facts), the fixpoint operator gives precisely the (non-ground) fixpoint semantics of Falaschi et al. <ref> [12] </ref>. The following formalizes the notion of compositional semantics based on clause unfolding and provides the basis for the compositional analyses described below. Theorem 3.1 [concrete composition [3]] Let P 1 and P 2 be modules.
Reference: [13] <author> M. Gabbrielli, R. Giacobazzi, and D. Montesi. </author> <title> Modular logic programs over finite domains. </title> <editor> In D. Sacca, editor, </editor> <booktitle> Proc. Eight Italian Conference on Logic Programming, </booktitle> <pages> pages 663-678, </pages> <year> 1993. </year> <note> Also Technical Report LIX - Ecole Poly-technique LIX/RR/94/04. </note>
Reference-contexts: As observed in [6], compositional analysis based on unfolding may not terminate even with finite or noetherian abstract domains for substitutions (constraints). This because the fixpoint iteration may introduce clauses with bodies containing an arbitrary number of open atoms. Some solutions to this problem have been proposed in <ref> [6, 13] </ref>. In [6] an additional (and orthogonal) layer of abstraction, the ?-abstraction 4 , is applied to deal with unbounded clause bodies in the abstract semantics. This approach provides finitary descriptions for arbitrary large clauses, but makes the analysis less precise. <p> In this case, since is finite, the domain of abstract interpretations AInt results a finite-height lattice. The ?-abstracted compositional semantics is denoted F A ? . This semantics is compositional correct (see [6]), therefore (by Theorem 4.7) it can be correctly used in abstract abduction. The approach in <ref> [13] </ref> is oriented to provide a compositional complete abstract semantics. This is obtained by taking, as semantics of P , the result of a finite number of iterations of the T A ff (P) operator, without reaching the fixpoint. <p> In this case, any additional unfolding step does not add information with respect to the possible extensions of P . The T -stable semantics, denoted F A T , is proved to be compositional complete in <ref> [13, 14] </ref>. Example 6 In this example we consider the simpler abstract domain Dep adopted from [7]. Elements in Dep are propositional formulae on Var with connectives ^ and $, ordered by implication. It is straightforward to derive Dep by abstract interpretation of Prop.
Reference: [14] <author> R. Giacobazzi. </author> <title> Semantic Aspects of Logic Program Analysis. </title> <type> PhD thesis, </type> <institution> Dipartimento di Informatica, Universita di Pisa, </institution> <year> 1993. </year> <note> TD - 18/93. </note>
Reference-contexts: &gt; &lt; h 0 [] b 1 :: :: b n fi fi fi fi 1 i=1 &lt;&lt; c P a 0 = ( i ff A (g i = h i )) &gt; &gt; = Likewise concrete unfolding, unf A is proved to be associative, additive and continuous (see <ref> [14] </ref>). <p> In this case, any additional unfolding step does not add information with respect to the possible extensions of P . The T -stable semantics, denoted F A T , is proved to be compositional complete in <ref> [13, 14] </ref>. Example 6 In this example we consider the simpler abstract domain Dep adopted from [7]. Elements in Dep are propositional formulae on Var with connectives ^ and $, ordered by implication. It is straightforward to derive Dep by abstract interpretation of Prop.
Reference: [15] <author> R. Giacobazzi, S. K. Debray, and G. Levi. </author> <title> A Generalized Semantics for Constraint Logic Programs. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems 1992, </booktitle> <pages> pages 581-591, </pages> <year> 1992. </year>
Reference-contexts: Some applications are discussed in Section 5. 2 Preliminaries In the following we assume familiarity with the standard definitions and notation for logic programs [1], constraint logic programs <ref> [17, 15] </ref> and abstract interpretation [9]. The powerset of a set X is denoted by -(X ). A poset with domain X and partial order v is denoted X v . <p> Prop provides a concise representation for abstract substitutions which describe ground dependency relations among their arguments. The generalization to Herbrand constraints is straightforward (e.g., see <ref> [15] </ref>). A propositional formula with connectives f$; _; ^g is associated with each constraint.
Reference: [16] <author> C.A.R. Hoare, I.J. Hayes, H. Jifeng, C.C. Morgan, A.W. Roscoe, J.W. Sanders, I.H. Sorensen, J.M. Spivey, and B.A. Sufrin. </author> <title> Laws of programming. </title> <journal> Comm. of the ACM, </journal> <volume> 30(8) </volume> <pages> 672-686, </pages> <year> 1987. </year>
Reference-contexts: Therefore it could be of assistance in the top-down development of a program to meet a specification. Indeed, there is an interesting relation between abduction and specification techniques based on weakest-prespecifications <ref> [16] </ref>. <p> A semantic account of this is provided by showing that abstract abduction corresponds to the abstract weak-op-inverse (see <ref> [16] </ref>) of the traditional T P -based semantics described in [12]. This result further justifies the use of abductive analysis in systematic program development. <p> A formal account of this process can be given in terms of the well known Dijkstra's weakest precondition or weakest prespecification <ref> [16] </ref>. Definition 4.1 [weak-op-inverse] f is a weak-op-inverse of f : D ! D 0 iff (D; f ; D 0 ; f ) is a Galois connection. This terminology has been introduced in [16] to generalize the inverse of sequential command composition ; on specifications. <p> process can be given in terms of the well known Dijkstra's weakest precondition or weakest prespecification <ref> [16] </ref>. Definition 4.1 [weak-op-inverse] f is a weak-op-inverse of f : D ! D 0 iff (D; f ; D 0 ; f ) is a Galois connection. This terminology has been introduced in [16] to generalize the inverse of sequential command composition ; on specifications.
Reference: [17] <author> J. Jaffar and J.-L. Lassez. </author> <title> Constraint Logic Programming. </title> <booktitle> In Proc. Fourteenth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 111-119. </pages> <publisher> ACM Press, </publisher> <year> 1987. </year>
Reference-contexts: Some applications are discussed in Section 5. 2 Preliminaries In the following we assume familiarity with the standard definitions and notation for logic programs [1], constraint logic programs <ref> [17, 15] </ref> and abstract interpretation [9]. The powerset of a set X is denoted by -(X ). A poset with domain X and partial order v is denoted X v . <p> We abuse by denoting (C; ^) the corresponding concrete constraint system. The set of atoms constructed from predicate symbols in and terms from Term is denoted Atom. It is well known that "ordinary" logic programs can be characterized as constraint logic programs on H (see, for example, <ref> [17] </ref>). This simplifies somehow the presentation.
Reference: [18] <author> A.C. Kakas, R.A. Kowalski, and F. Toni. </author> <title> Abductive Logic Programming. </title> <journal> Journal of Logic and Computation, </journal> <volume> 2(6) </volume> <pages> 719-770, </pages> <year> 1993. </year>
Reference-contexts: The process of reversing deduction is logically justified by the abductive reasoning (an excellent survey on the wide literature on abduction is in <ref> [18] </ref>). Abductive reasoning is formulated as follows: "given a set of rules (clauses) P and a conjunction of atoms (an observation or simply a goal) G, find the set of atoms Q (the hypothesis) such that G is a logical consequence of P [ Q" (see [18, 21]). <p> Abductive reasoning is formulated as follows: "given a set of rules (clauses) P and a conjunction of atoms (an observation or simply a goal) G, find the set of atoms Q (the hypothesis) such that G is a logical consequence of P [ Q" (see <ref> [18, 21] </ref>). Atoms in Q are indicated as abducible information. From the abstract interpretation viewpoint, the abductive reasoning can be statically used to derive program properties of modules once the specification of the properties of their composition is given. We call this analysis abductive. <p> Such a program is said to be predicate disjoint if no predicate is defined in more than one module. We assume that modular programs are predicate disjoint unless otherwise specified: this assumption, considered also in <ref> [6, 18] </ref>, simplifies the presentation somewhat. <p> terms of unfolding of clauses unf : Int fi Int ! Int, specifying every possible way to unfold each literal in each clause of P 1 once using clauses in P 2 (see [19]): 1 The predicate disjoint restriction has the advantage that abducible information (for open (P)) is basic <ref> [18] </ref>, i.e., it is not defined in terms of other abducible information. For a set of abducible predicates, we can always transform P (as suggested in [18]) in such a way that it does not have definitions for them: for each abducible predicate p, we can introduce a new predicate ffi <p> once using clauses in P 2 (see [19]): 1 The predicate disjoint restriction has the advantage that abducible information (for open (P)) is basic <ref> [18] </ref>, i.e., it is not defined in terms of other abducible information. For a set of abducible predicates, we can always transform P (as suggested in [18]) in such a way that it does not have definitions for them: for each abducible predicate p, we can introduce a new predicate ffi p and add the clause p (x ) ffi p (x ).
Reference: [19] <author> G. Levi. </author> <title> Models, Unfolding Rules and Fixpoint Semantics. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> <booktitle> Proc. Fifth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 1649-1665. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1988. </year>
Reference-contexts: The concrete semantics is formalized in terms of unfolding of clauses unf : Int fi Int ! Int, specifying every possible way to unfold each literal in each clause of P 1 once using clauses in P 2 (see <ref> [19] </ref>): 1 The predicate disjoint restriction has the advantage that abducible information (for open (P)) is basic [18], i.e., it is not defined in terms of other abducible information. <p> and goal G = [] b, G has a successful derivation in P iff, by extending G to a clause: ans G with a new atom ans such that var (ans) = var ( b), there exists ans 0 [] true 2 unf (fans Gg; F (P )) (e.g., see <ref> [19] </ref>). In this case we say that 0 is the answer constraint. In the following, for any set of variables V we denote ans (V ) a flat and linear atom such that var (ans (V )) = V .
Reference: [20] <author> K. Marriott and H. Stndergaard. </author> <title> Bottom-up Dataflow Analysis of Normal Logic Programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 13(2 </volume> & 3):181-204, 1992. 
Reference-contexts: This deductive approach to logic program analysis is usually based on abstract unfolding (i.e. replacement + abstract unification) and is shared by several of the frameworks proposed in the literature (e.g., see <ref> [2, 4, 5, 6, 10, 20] </ref>). In [6] this approach has been applied to modular logic programs providing a compositional analysis in presence of modules. Compositional abstract interpretation is essential for large program development so that altering one module does not require re-analysis of the entire program.
Reference: [21] <author> D. Poole. </author> <title> A logical framework for default reasoning. </title> <journal> Artificial Intelligence, </journal> <volume> 36 </volume> <pages> 27-47, </pages> <year> 1988. </year>
Reference-contexts: Abductive reasoning is formulated as follows: "given a set of rules (clauses) P and a conjunction of atoms (an observation or simply a goal) G, find the set of atoms Q (the hypothesis) such that G is a logical consequence of P <ref> [ Q" (see [18, 21] </ref>). Atoms in Q are indicated as abducible information. From the abstract interpretation viewpoint, the abductive reasoning can be statically used to derive program properties of modules once the specification of the properties of their composition is given. We call this analysis abductive. <p> Abductive reasoning is formulated as follows: "given a set of rules (clauses) P and a conjunction of atoms (an observation or simply a goal) G, find the set of atoms Q (the hypothesis) such that G is a logical consequence of P [ Q" (see <ref> [18, 21] </ref>). Atoms in Q are indicated as abducible information. From the abstract interpretation viewpoint, the abductive reasoning can be statically used to derive program properties of modules once the specification of the properties of their composition is given. We call this analysis abductive.
References-found: 21

