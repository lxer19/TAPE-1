URL: ftp://ftp.cs.umd.edu/pub/realtime/simulate.ps.gz
Refering-URL: http://www.cs.umd.edu/projects/TimeWare/TimeWare-index-no-abs.html
Root-URL: 
Email: fladan,richg@cs.umd.edu  
Title: Multi-Platform Simulation of Video Playout Performance sembled (combinatorially) using four different CPUs, three types of
Author: Ladan Gharai and Richard Gerber 
Note: This research is supported in part by ONR grant N00014-94-10228, ARL Cooperative Agreement DAAL01-96-2-0002 and NSF Young Investigator Award CCR-9357850.  
Address: College Park, MD 20742  
Affiliation: Institute for Advanced Computer Studies Department of Computer Science University of Maryland  
Abstract: We describe a compositional simulation system, which predicts streamed video performance on multiple platform configurations. System behavior is modeled with a set of key deterministic and stochastic variables, each of which characterizes part of a "virtual system component," e.g., an IO device, a particular CPU, a codec, etc. These variables are profiled in isolation, by inserting lightweight instrumentation code into the main threads and upcalls involved in the playout datapath. Then, a post-processor converts the derived samples into synthesized probability distribution functions, after which the results are stored in the simulator's library. At simulation time, the user selects a set of "virtual components," which are then composed into an "end-user system." The resulting model is used to predict the performance of any video, which usually requires no more than a few seconds. The output is a list of frame-display times, accompanied by statistics on the mean-playout rate, variance, jitter, etc. This scheme lets developers extend the range of their target platforms, by automatically benchmarking new components, storing the results, and then simulating an entirely new set of systems. So, if a developer possesses a large set of pre-profiled components, he or she can quickly estimate a video's performance on a huge spectrum of target platforms without ever having to actually assemble them. In this paper we demonstrate evidence that our method works within a reasonable degree of accuracy, when compared to actual on-line playout. We present results for a generic, streamed Quicktime video system subjected to multiple configurations. These were as 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> David P. Anderson. </author> <title> Metascheduling for Continuous Media. </title> <journal> ACM Transactions on Computer Systems, </journal> <pages> pages 226-252, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: For our purposes, device behavior is sufficiently modeled by rate and latency distributions (as we show in the sequel). We note that our approach to component modeling is echoed in Anderson's treatment of metascheduling <ref> [1] </ref>, where the goal is quite is to provide hard end-to-end guarantees across the entire data-path - CPU, network, file system for continuous media transmission. Jitter management must be addressed in all video playout schemes; when resources are limited, frame-selection policies can greatly quality of playback. <p> We summarize the two methods here: Pure stochastic variable: In this case the time-sample list is sorted as a histogram divided into either 10 3 or 10 4 buckets (depending on the range and variation of the recorded process). Then the histogram is normalized to the interval <ref> [0; 1] </ref>, which yields a (synthesized) discrete probability distribution function (or PDF) f (t) for the variable, where we now assume that a given outcome is made as a simple Bernoulli decision. I.e., f (t) returns the probability of a sample time t being realized during playback on the device. <p> I.e., f (t) returns the probability of a sample time t being realized during playback on the device. Next, f 's cumulative distribution function F (t) is produced, and the output of the entire process is F 1 (u), the CDF's inverse transform, where u is uniformly distributed over <ref> [0; 1] </ref>. The simulator uses this function to generate random response times, in concert with a dedicated random number generator. <p> Finally, at simulation time, we get our IO time variable as follows: T io = L (size) + R 1 (u) where u 2 <ref> [0; 1] </ref> is obtained via a random-number generator, and where the size variable corresponds to a particular IO request. (2) CPU Profiling: The CPU-based playout software itself is modeled by the variables T ply , T pre , T IOc , T iocb , T snd , T sch , T
Reference: [2] <author> Y.N.Patt B.L.Worthington, G.R.Ganger and J.Wilkes. </author> <title> On-line extraction of SCSI disk drive parameters. </title> <booktitle> In ACM Sigmetrics, </booktitle> <year> 1995. </year>
Reference-contexts: We note that other researchers have taken the extreme opposite approach, attempting to capture very fine-grained parameters involved; for example, in [8] and [4] detailed disk scheduling algorithms are presented, with the objective being to increase IO performance in media systems. Closer to our approach is <ref> [2] </ref>, where a SCSI disk is treated as a black box, and its properties are extracted by gauging response-times to certain requests. Our profiling tools take an even coarser approach - they use essentially the same set of random variables for a range IO devices: disks, CDROMs, etc.
Reference: [3] <institution> Apple Computer Corporation. Inside Mach-intosh: </institution> <address> Quicktime. </address> <publisher> Addison Wesley, </publisher> <year> 1994. </year>
Reference-contexts: In this paper we show how these goals can be accomplished. As a proof of concept, we demonstrate our technique using a relatively generic play-out system (with a structure like that shown in Figure 1), which streams video stored in Quicktime-format files. Quicktime <ref> [3] </ref> is a standard file format for consumer Macintosh and PC/Windows systems; it accommodates almost all standard codecs (e.g., In-deo, Cinepak, MPEG), as well as their associated audio samples (encoded or raw).
Reference: [4] <author> D.James Gemmell, Harrick M.Vin, Dilip D.Kandlur, P.Venkat Rangan, and Lawrence A.Rowe. </author> <title> Multimedia Storage Servers: A tutorial. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 40-49, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: This is especially true for the IO device under observation where we use only a single random variable to capture the entire IO dat-apath. We note that other researchers have taken the extreme opposite approach, attempting to capture very fine-grained parameters involved; for example, in [8] and <ref> [4] </ref> detailed disk scheduling algorithms are presented, with the objective being to increase IO performance in media systems. Closer to our approach is [2], where a SCSI disk is treated as a black box, and its properties are extracted by gauging response-times to certain requests.
Reference: [5] <author> Richard Gerber and Ladan Gharai. </author> <title> Experiments with Digital Video Playout. </title> <booktitle> In ACM Sigmetrics, </booktitle> <pages> pages 210-221, </pages> <year> 1996. </year>
Reference: [6] <author> Alan Jones and Andrew Hopper. </author> <title> Handling Audio and Video Streams in a Distributed Environment. </title> <booktitle> In ACM Operating System Review, </booktitle> <year> 1993. </year>
Reference-contexts: Jitter management must be addressed in all video playout schemes; when resources are limited, frame-selection policies can greatly quality of playback. In particular, [10] and <ref> [6] </ref> evaluate the tradeoffs between latency and real-time throughput, where latencies were adjusted based on past frame-queue-size. The objective was to maintain a full display queue, and reduce the the number of gaps during display. Simultaneously, fewer input frames get dropped at the sink point, thereby controlling wasted bandwidth.
Reference: [7] <author> Howard P. Katseff and Bethany S.Robinson. </author> <title> Predictive Prefetch in the Nemesis Multimedia Information Service. </title> <booktitle> In ACM Multimedia Proceedings, </booktitle> <pages> pages 201-209, </pages> <year> 1993. </year>
Reference-contexts: At worst, it arrives too late to be displayed. Our playout system takes this into account, and scales its performance to different platforms/video combinations via predictive prefetch-ing. The strategy is similar to the prefetch algorithm used in Nemesis <ref> [7] </ref>, where the server only sends video and audio frames requested from the client; i.e., the process is receiver controlled, monitored via the display queue and rate. 3 System Overview Our simulation engine was designed to quickly and accurately predict video playback performance on a range specific platform configurations.
Reference: [8] <author> A.L. Narasimha Reddy and James C.Wyllie. </author> <title> IO Issues in a Multimedia System. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 69-74, </pages> <month> March </month> <year> 1994. </year>
Reference-contexts: This is especially true for the IO device under observation where we use only a single random variable to capture the entire IO dat-apath. We note that other researchers have taken the extreme opposite approach, attempting to capture very fine-grained parameters involved; for example, in <ref> [8] </ref> and [4] detailed disk scheduling algorithms are presented, with the objective being to increase IO performance in media systems. Closer to our approach is [2], where a SCSI disk is treated as a black box, and its properties are extracted by gauging response-times to certain requests.
Reference: [9] <author> Ralf Steinmetz. </author> <title> Compression Techniques in Multimedia Systems. </title> <type> Technical Report 43.9307, </type> <institution> IBM European Networking Center, </institution> <address> Vangerowstrabe 18, 69020 Heidelberg, Ger-many, </address> <year> 1993. </year>
Reference-contexts: Keyframes. In temporally-compressed clips, a predictive-prefetch scheme is alway complicated by the existence of keyframes (which are analogous to 6 I-Frames in MPEG <ref> [9] </ref>). For us, this means that when a keyframe is dropped, then the the interpolated sequence following has to be discarded. Thus, while P R (t) is the current predicted rate, the Predict thread cannot simply fetch frames at a constant frequency.
Reference: [10] <author> Donald L. Stone and Kevin Jeffay. </author> <title> An Empirical Study of Delay Jitter Management Policies. </title> <journal> Multimedia Systems, </journal> <volume> 2(6) </volume> <pages> 267-279, </pages> <year> 1995. </year>
Reference-contexts: Jitter management must be addressed in all video playout schemes; when resources are limited, frame-selection policies can greatly quality of playback. In particular, <ref> [10] </ref> and [6] evaluate the tradeoffs between latency and real-time throughput, where latencies were adjusted based on past frame-queue-size. The objective was to maintain a full display queue, and reduce the the number of gaps during display.
References-found: 10

