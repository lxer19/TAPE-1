URL: http://www.cs.nmsu.edu/~epontell/ilps97/4.ps.gz
Refering-URL: http://www.cs.nmsu.edu/lldap/ilps97/programme.html
Root-URL: http://www.cs.nmsu.edu
Email: fhanus,raming@i2.informatik.rwth-aachen.de  
Title: A Concurrent Implementation of Curry in Java  
Author: Michael Hanus Ramin Sadre 
Keyword: Functional logic programming, lazy evaluation, concurrency, implementation  
Address: D-52056 Aachen, Germany  
Affiliation: RWTH Aachen, Informatik II,  
Abstract: Curry is a multi-paradigm declarative language aiming to amalgamate functional, logic, and concurrent programming paradigms. Curry combines in a seamless way features from functional programming and (concurrent) logic programming. Curry's operational semantics is based on the combination of lazy reduction of expressions together with a possibly non-deterministic binding of free variables occurring in expressions. Moreover, (equational) constraints can be executed concurrently which provides for passive constraints and concurrent computation threads that are synchronized on logical variables. This paper sketches a first prototype implementation of Curry in Java. The main emphasis of this implementation is the exploitation of Java threads to implement the concurrent and non-deterministic features of Curry. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Antoy. </author> <title> Definitional trees. </title> <booktitle> In Proc. of the 3rd International Conference on Algebraic and Logic Programming, </booktitle> <pages> pages 143-157. </pages> <publisher> Springer LNCS 632, </publisher> <year> 1992. </year>
Reference-contexts: This reduction may yield a single new expression (deterministic step) or a disjunction of new expressions together with corresponding bindings (non-deterministic step). For inductively sequential programs <ref> [1] </ref> (these are, roughly speaking, function definitions without overlapping left-hand sides), this strategy, called needed narrowing [2], computes the shortest possible successful derivations (if common subterms are shared) and a minimal set of solutions, and it is fully deterministic if free variables do not occur. 5 4 Since the exact evaluation <p> left-hand sides), this strategy, called needed narrowing [2], computes the shortest possible successful derivations (if common subterms are shared) and a minimal set of solutions, and it is fully deterministic if free variables do not occur. 5 4 Since the exact evaluation strategy of Curry is specified using definitional trees <ref> [1, 11] </ref>, Curry also supports more powerful evaluation strategies than current functional languages. 5 These properties also shows some of the advantages of integrating functions into logic programs, since similar properties for purely logic programs are not known.
Reference: [2] <author> S. Antoy, R. Echahed, and M. Hanus. </author> <title> A needed narrowing strategy. </title> <booktitle> In Proc. 21st ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 268-279, </pages> <address> Portland, </address> <year> 1994. </year>
Reference-contexts: This reduction may yield a single new expression (deterministic step) or a disjunction of new expressions together with corresponding bindings (non-deterministic step). For inductively sequential programs [1] (these are, roughly speaking, function definitions without overlapping left-hand sides), this strategy, called needed narrowing <ref> [2] </ref>, computes the shortest possible successful derivations (if common subterms are shared) and a minimal set of solutions, and it is fully deterministic if free variables do not occur. 5 4 Since the exact evaluation strategy of Curry is specified using definitional trees [1, 11], Curry also supports more powerful evaluation
Reference: [3] <author> S. Bonnier and J. Maluszynski. </author> <title> Towards a clean amalgamation of logic programs with external procedures. </title> <booktitle> In Proc. 5th Conference on Logic Programming & 5th Symposium on Logic Programming (Seattle), </booktitle> <pages> pages 311-326. </pages> <publisher> MIT Press, </publisher> <year> 1988. </year>
Reference-contexts: Moreover, the suspension of function calls is also essential to connect external functions in a clean way <ref> [3] </ref>. For instance, the integer numbers can be considered as an infinite set of constants where the addition on integers is conceptually defined by an infinite set of rules: 0+0 = 0 ... ...
Reference: [4] <author> S. Breitinger, R. Loogen, and Y. Ortega-Mallen. </author> <booktitle> Concurrency in functional and logic programming. In Fuji International Workshop on Functional and Logic Programming. </booktitle> <publisher> World Scientific Publ., </publisher> <year> 1995. </year>
Reference-contexts: It is also interesting to note that this model is able to cover recent developments in parallel functional computation models like Eden <ref> [4] </ref> or Goffin [5].
Reference: [5] <author> M.M.T. Chakravarty, Y. Guo, M. Kohler, and H.C.R. </author> <title> Lock. Goffin - higher-order functions meet concurrent constraints. </title> <note> Science of Computer Programming (to appear), </note> <year> 1997. </year>
Reference-contexts: It is also interesting to note that this model is able to cover recent developments in parallel functional computation models like Eden [4] or Goffin <ref> [5] </ref>. <p> Since constraints could be passed as arguments or results of functions (like any other data object or function), it is possible to specify general operators to create flexible communication architectures similarly to Goffin <ref> [5] </ref>. Thus, the same abstraction facilities could be used for sequential as well as concurrent programming.
Reference: [6] <author> B. Demoen and P. Tarau. JProlog. </author> <note> Available at http://www.cs.kuleuven.ac.be/~bmd/PrologInJava/, 1996. </note>
Reference-contexts: Java as an implementation language has|in spite of its efficiency|also other advantages: the ability of the JVM to load classes during run time allows the user to hold only those functions in memory that are actually needed (this feature has also been used by other projects like the Prolog-to-Java-compiler JProlog <ref> [6] </ref>). And last but not least: since the Java-compiler produces bytecode for the JVM, the entire Curry run-time system is portable to other platforms: any computer with an installed JVM (e.g., a WWW-browser) is able to run an application written in Curry without recompilation of the source files.
Reference: [7] <author> E. Giovannetti, G. Levi, C. Moiso, and C. Palamidessi. </author> <title> Kernel LEAF: A logic plus functional language. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 42(2) </volume> <pages> 139-185, </pages> <year> 1991. </year>
Reference-contexts: For instance, if gen is a predicate or constraint which instantiates its argument with potential solutions (i.e., gen is flexible) and test checks whether the argument is a 6 This notion of equality is also known as strict equality <ref> [7, 17] </ref> and is the only reasonable notion of equality in the presence of non-terminating functions. 6 Workshop on Parallelism and Implementation Technology correct solution (i.e., test is rigid), then a constraint like "test (X)^gen (X)" specifies a "test-and-generate" solution where the test is activated as soon as its argument is
Reference: [8] <author> G. Gupta. </author> <title> Multiprocessor Execution of Logic Programs. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1994. </year>
Reference-contexts: Each machine needs a data structure that stores the bindings initiated by the machine (see <ref> [8] </ref> for an overview of different implementation methods). Our current implementation is based on binding arrays: every variable has a unique number that is interpreted as an index in an array of expressions. This array (the binding array) contains the expressions the variables are bound to.
Reference: [9] <author> M. Hanus. </author> <title> The integration of functions into logic programming: From theory to practice. </title> <journal> Journal of Logic Programming, </journal> 19&20:583-628, 1994. Workshop on Parallelism and Implementation Technology <volume> 15 </volume>
Reference-contexts: Moreover, it also amalgamates the most important operational principles developed in the area of integrated functional logic languages: "residuation" and "narrowing" (see <ref> [9] </ref> for a survey on functional logic programming). Curry's operational semantics is based on a single computation model, described in [11], which combines lazy reduction of expressions with a possibly non-deterministic binding of free variables occurring in expressions.
Reference: [10] <author> M. Hanus. </author> <title> Teaching functional and logic programming with a single computation model. </title> <booktitle> In Proc. Ninth International Symposium on Programming Languages, Implementations, Logics, and Programs (PLILP'97), </booktitle> <pages> pages 335-350. </pages> <publisher> Springer LNCS 1292, </publisher> <year> 1997. </year>
Reference-contexts: Actually, Curry has been successfully applied to teach functional and logic programming techniques in a single course without switching between different programming languages <ref> [10] </ref>. In order to provide a portable implementation of Curry, we have developed an interpreter for Curry in Java.
Reference: [11] <author> M. Hanus. </author> <title> A unified computation model for functional and logic programming. </title> <booktitle> In Proc. of the 24th ACM Symposium on Principles of Programming Languages (Paris), </booktitle> <pages> pages 80-93, </pages> <year> 1997. </year>
Reference-contexts: 1 Introduction Curry <ref> [11, 12] </ref> is a multi-paradigm declarative language aiming to integrate functional, logic, and concurrent programming paradigms. <p> Moreover, it also amalgamates the most important operational principles developed in the area of integrated functional logic languages: "residuation" and "narrowing" (see [9] for a survey on functional logic programming). Curry's operational semantics is based on a single computation model, described in <ref> [11] </ref>, which combines lazy reduction of expressions with a possibly non-deterministic binding of free variables occurring in expressions. Thus, purely functional programming, purely logic programming, and concurrent (logic) programming are obtained as particular restrictions of this model. <p> Section 4 discusses some extensions of the basic computation model, and Section 5 contains our conclusions. 2 The Computation Model of Curry This section provides an informal introduction to the computation model of Curry. A formal definition can be found in <ref> [11, 12] </ref>. The basic computational domain of Curry is, similarly to functional or logic languages, a set of data terms constructed from constants and data constructors. <p> left-hand sides), this strategy, called needed narrowing [2], computes the shortest possible successful derivations (if common subterms are shared) and a minimal set of solutions, and it is fully deterministic if free variables do not occur. 5 4 Since the exact evaluation strategy of Curry is specified using definitional trees <ref> [1, 11] </ref>, Curry also supports more powerful evaluation strategies than current functional languages. 5 These properties also shows some of the advantages of integrating functions into logic programs, since similar properties for purely logic programs are not known.
Reference: [12] <author> M. Hanus (ed.). Curry: </author> <title> An integrated functional logic language. </title> <note> Available at http://www-i2.informatik.rwth-aachen.de/~hanus/curry, 1997. </note>
Reference-contexts: 1 Introduction Curry <ref> [11, 12] </ref> is a multi-paradigm declarative language aiming to integrate functional, logic, and concurrent programming paradigms. <p> Section 4 discusses some extensions of the basic computation model, and Section 5 contains our conclusions. 2 The Computation Model of Curry This section provides an informal introduction to the computation model of Curry. A formal definition can be found in <ref> [11, 12] </ref>. The basic computational domain of Curry is, similarly to functional or logic languages, a set of data terms constructed from constants and data constructors.
Reference: [13] <author> J. Hughes. </author> <title> Why functional programming matters. In D.A. </title> <editor> Turner, editor, </editor> <booktitle> Research Topcis in Functional Programming, </booktitle> <pages> pages 17-42. </pages> <publisher> Addison Wesley, </publisher> <year> 1990. </year>
Reference-contexts: Since it is well known that innermost reduction is not normalizing, Curry is based on a lazy (outermost) strategy. This also allows the computation with infinite data structures and provides more modularity by separating control aspects <ref> [13] </ref>. A subtle point in the definition of a lazy evaluation strategy in combination with pattern matching is the selection of the "right" outermost redex. For instance, consider the rules of Example 1 together with the rule f = f. <p> Note that|unlike the backtracking mechanism of Prolog|an infinite computation can not inhibit the output of other solutions, since the OR-parallel computation paths are executed as independent threads. 4 Extensions of the Basic Computation Model Higher-order functions has been shown to be very useful to structure programs and write reusable software <ref> [13] </ref>. Although the computation model described so far includes only first-order functions, higher-order features can be implemented by providing a (first-order) definition of the application function (as shown by Warren [25] for logic programming).
Reference: [14] <author> S. Janson and S. Haridi. </author> <title> Kernal Andorra Prolog and its computation model. </title> <booktitle> In Proc. of the 7th International Conference, </booktitle> <pages> pages 31-46. </pages> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: This leaf can only be reactivated if there is no other active leaf, or if another active leaf has bound the variable. This can avoid unnecessary duplications of active threads and prefers deterministic parts of the computation, similarly to the Andorra computation model <ref> [14] </ref>. If all leafs in a computation structure are suspended but there are several leafs waiting to bind a variable non-deterministically, then only one of them (e.g., the leaf corresponding to the leftmost constraint) is re-activated. A small example helps to see how this works. <p> For example, the evaluation of a goal like "generate (X)^test (X)" does not show any difference|neither in result nor in execution time| to the evaluation of "test (X)^generate (X)". Concerning this, the implementation is comparable with the Andorra model <ref> [14] </ref>. Since the run-time system of our implementation is written in Java, its speed is highly dependent on the efficiency of the JVM. First results of our implementation indicate that our implementation is much slower than highly optimized implementations of Prolog.
Reference: [15] <author> S. Janson and S. Haridi. </author> <title> Programming paradigms of the Andorra Kernel Language. </title> <booktitle> In Proc. 1991 International Logic Programming Symposium, </booktitle> <pages> pages 167-183. </pages> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: The latter case avoids the duplication of processes for don't know non-deterministic computations which is also known as stability from AKL <ref> [15] </ref>. This scheme implements coroutining features of current Prolog systems [18] as well as features of concurrent constraint languages [22]. In the next section, we review the basic computation model of Curry. Its concurrent implementation in Java is described in Section 3. <p> On the other hand, the clear separation between sequential and concurrent computations supports the use of efficient and optimal evaluation strategies for the sequential parts, where similar techniques for the concurrent parts are not available. This is in contrast to other, more fine-grained concurrent computation models like AKL <ref> [15] </ref>, CCP [22], or Oz [23]. 3 Implementation of Curry Programs In this section we sketch a Java-based implementation of an abstract machine for executing Curry programs. We describe the implementation of data terms, defined functions, and the computational model of Curry (variable bindings, non-determinism, concurrency). <p> The two extreme solutions to this problem are the complete copying of the entire computation structure (which corresponds to full OR-parallelism) or to forbid the non-deterministic binding inside concurrent computations. We prefer a middle course and adopt a solution which is also known as stability from AKL <ref> [15] </ref>: * Leafs which want to bind a variable deterministically are allowed to do it immediately. * Non-deterministic binding will cause the leaf to suspend. This leaf can only be reactivated if there is no other active leaf, or if another active leaf has bound the variable.
Reference: [16] <author> R. Loogen, F. Lopez Fraguas, and M. Rodriguez Artalejo. </author> <title> A demand driven computation strategy for lazy narrowing. </title> <booktitle> In Proc. of the 5th International Symposium on Programming Language Implementation and Logic Programming, </booktitle> <pages> pages 184-200. </pages> <publisher> Springer LNCS 714, </publisher> <year> 1993. </year>
Reference-contexts: both sides are undefined (non-terminating), then the equality does not hold. 6 Operationally, an equational constraint e 1 =e 2 is solved by evaluating e 1 and e 2 to unifiable data terms where the lazy evaluation of the expressions is interleaved with the binding of variables to constructor terms <ref> [16] </ref>. Thus, an equational constraint e 1 =e 2 without occurrences of defined functions has the same meaning (unification) as in Prolog. The basic kernel of Curry only provides equations e 1 =e 2 between expressions as constraints.
Reference: [17] <author> J.J. Moreno-Navarro and M. Rodriguez-Artalejo. </author> <title> Logic programming with functions and predicates: The language BABEL. </title> <journal> Journal of Logic Programming, </journal> <volume> 12 </volume> <pages> 191-223, </pages> <year> 1992. </year>
Reference-contexts: For instance, if gen is a predicate or constraint which instantiates its argument with potential solutions (i.e., gen is flexible) and test checks whether the argument is a 6 This notion of equality is also known as strict equality <ref> [7, 17] </ref> and is the only reasonable notion of equality in the presence of non-terminating functions. 6 Workshop on Parallelism and Implementation Technology correct solution (i.e., test is rigid), then a constraint like "test (X)^gen (X)" specifies a "test-and-generate" solution where the test is activated as soon as its argument is <p> Our implementation can be easily extended to conditional rules following the approach taken in Babel <ref> [17] </ref>: consider a conditional rule "l | fcg = r" (the condition c is a constraint) as syntactic sugar for the rule l = (c ) r), where the right-hand side is a guarded expression.
Reference: [18] <author> L. Naish. </author> <title> Negation and Control in Prolog. </title> <publisher> Springer LNCS 238, </publisher> <year> 1987. </year>
Reference-contexts: The latter case avoids the duplication of processes for don't know non-deterministic computations which is also known as stability from AKL [15]. This scheme implements coroutining features of current Prolog systems <ref> [18] </ref> as well as features of concurrent constraint languages [22]. In the next section, we review the basic computation model of Curry. Its concurrent implementation in Java is described in Section 3. <p> In our concurrent implementation, we assign different threads to the evaluation of c 1 and c 2 . These computation threads synchronize on the bindings of common variables. This fairly simple model for concurrent computations is able to cover applications of Prolog systems with coroutining <ref> [18] </ref>. <p> As known from logic programming with coroutining <ref> [18] </ref>, this feature is quite useful to avoid an unrestricted generation of infinite solution sets and also supports a concurrent programming style like in concurrent constraint/logic programming languages. Moreover, the suspension of function calls is also essential to connect external functions in a clean way [3].
Reference: [19] <author> J.F. Nilsson. </author> <title> On the compilation of a domain-based Prolog. </title> <booktitle> In Proc. IFIP'83, </booktitle> <pages> pages 293-298. </pages> <publisher> Elsevier Science Publishers, </publisher> <year> 1983. </year>
Reference-contexts: Thus, standard techniques to translate (sequential) logic programs into procedures of imperative languages (e.g., <ref> [19] </ref>) cannot be applied here. 2 In the following we use a Prolog-like syntax which is slightly different from the actual Curry syntax.
Reference: [20] <author> S.L. Peyton Jones and P. Wadler. </author> <title> Imperative functional programming. </title> <booktitle> In Proc. 20th Symposium on Principles of Programming Languages (POPL'93), </booktitle> <pages> pages 71-84, </pages> <year> 1993. </year>
Reference-contexts: Moreover, due to the use of an integrated functional logic language, one can choose the best of the two worlds in application programs. For instance, input/output (implemented in logic languages by side effects) can be handled with the monadic I/O concept <ref> [20] </ref> in a declarative way. Similarly, many other impure features of Prolog (e.g., arithmetic, cut) can be avoided by the use of functions.
Reference: [21] <author> E. Pontelli and G. Gupta. </author> <title> Implementation mechanisms for dependent and-parallelism. </title> <booktitle> In Proc. of the Fourteenth International Conference on Logic Programming (ICLP'97), </booktitle> <pages> pages 123-137. </pages> <publisher> MIT Press, </publisher> <year> 1997. </year>
Reference-contexts: Backtracking is one possible (but unfair) implementation of disjunctions. However, the concrete evaluation order is not important for the computed results, since Curry has no side effects. Because there is no need to ensure a sequential backtracking semantics as in Prolog (e.g., unlike in the ACE parallel Prolog system <ref> [21] </ref>), we will implement disjunctive computations by independent threads. However, this implementation issue is less important than in Prolog since most parts of larger computations are purely deterministic due to the use of functions in Curry. Functional logic languages are often used to solve equations between expressions containing defined functions.
Reference: [22] <author> V.A. Saraswat. </author> <title> Concurrent Constraint Programming. </title> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: The latter case avoids the duplication of processes for don't know non-deterministic computations which is also known as stability from AKL [15]. This scheme implements coroutining features of current Prolog systems [18] as well as features of concurrent constraint languages <ref> [22] </ref>. In the next section, we review the basic computation model of Curry. Its concurrent implementation in Java is described in Section 3. <p> This is in contrast to other, more fine-grained concurrent computation models like AKL [15], CCP <ref> [22] </ref>, or Oz [23]. 3 Implementation of Curry Programs In this section we sketch a Java-based implementation of an abstract machine for executing Curry programs. We describe the implementation of data terms, defined functions, and the computational model of Curry (variable bindings, non-determinism, concurrency).
Reference: [23] <author> G. Smolka. </author> <title> The Oz programming model. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Computer Science Today: Recent Trends and Developments, </booktitle> <pages> pages 324-343. </pages> <publisher> Springer LNCS 1000, </publisher> <year> 1995. </year>
Reference-contexts: This is in contrast to other, more fine-grained concurrent computation models like AKL [15], CCP [22], or Oz <ref> [23] </ref>. 3 Implementation of Curry Programs In this section we sketch a Java-based implementation of an abstract machine for executing Curry programs. We describe the implementation of data terms, defined functions, and the computational model of Curry (variable bindings, non-determinism, concurrency).
Reference: [24] <author> Sun Microsystems. </author> <title> Java documentation. </title> <note> Available at http://java.sun.com/docs/, 1997. </note>
Reference-contexts: On the other hand, the use of Java provides automatic memory management and support for concurrent programming which largely simplifies the implementation task for Curry. 3.1 Representation of Data Terms and Functions The run-time system of our implementation is completely written in Java <ref> [24] </ref>. This has influenced some implementation choices, in particular, the run-time representation of constructors and functions.
Reference: [25] <author> D.H.D. Warren. </author> <title> Higher-order extensions to Prolog: </title> <booktitle> are they needed? In Machine Intelligence 10, </booktitle> <pages> pages 441-454, </pages> <year> 1982. </year>
Reference-contexts: Although the computation model described so far includes only first-order functions, higher-order features can be implemented by providing a (first-order) definition of the application function (as shown by Warren <ref> [25] </ref> for logic programming). Curry supports the higher-order features of current functional languages (partial function applications, lambda abstractions) by this technique, where the rules for the application function are implicitly defined.
References-found: 25

