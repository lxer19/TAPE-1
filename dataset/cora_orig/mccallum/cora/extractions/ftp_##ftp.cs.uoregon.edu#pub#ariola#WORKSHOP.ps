URL: ftp://ftp.cs.uoregon.edu/pub/ariola/WORKSHOP.ps
Refering-URL: http://www.cs.uoregon.edu/~ariola/publications.html
Root-URL: http://www.cs.uoregon.edu
Title: Compilation of Id  
Author: Zena M. Ariola Arvind 
Date: September 1991  
Affiliation: Aiken Computational Laboratory Harvard University  Laboratory for Computer Science Massachusetts Institute of Technology  
Abstract: In this paper we illustrate, using the Id language, that both the operational semantics of a language and its compilation process can be formalized together. Id is a higher-order non-strict functional language augmented with I-structures and M-structures. The operational semantics of Id is given in terms of a smaller kernel language, called Kid. Kid is also the intermediate form used by the compiler to perform type checking and optimizations. Optimizations are described as extensions of Kid operational semantics. A criteria for correctness of optimizations is presented. P-TAC, a lower-level language, is introduced to capture some efficiency issues related to code generation. The salient features of trans lating Kid into P-TAC are presented.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aho, J. Ullman, and R. Sethi. </author> <booktitle> Compilers: Principles, Techniques, Tools. </booktitle> <address> London, </address> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: These optimizations are often referred to as constant folding and constant propagation <ref> [1] </ref>. Moreover, knowing that the 5 th element of array x is v, the compiler can rewrite the P select (x; i) to v.
Reference: [2] <author> Z. M. Ariola. </author> <title> Orthogonal Graph Rewriting Systems. </title> <type> Technical Report CSG Memo 323, </type> <institution> MIT Laboratory for Computer Science, </institution> <year> 1991. </year>
Reference-contexts: Our let-block semantics precisely defines how arguments are shared; an essential feature for Id extended with I-structures and M-structures. Sharing is expressed by giving a name to each subexpression and by allowing substitution of values and variables only. This idea can be formalized in a Contextual Rewriting Systems (CRS) <ref> [2, 4] </ref> by the following Substitution rules: X = V X = Y where V is either an Integer or a Boolean or an Error. <p> Notationally a context is represented by C <ref> [2] </ref>. C [P store (X; Y; Z)] then represents the program obtained by filling the hole with P store (X; Y; Z). <p> This concept of printable value is related to the notion of instant semantics introduced by Welch [18]. The answer is then defined in terms of the maximum information that can be extracted by reducing that term. Levy [12] and Ariola <ref> [2] </ref> have shown that by picking a suitable definition of print, the domain of answers becomes a term model for the language. Suppose A (M ) denotes the answer associated with M .
Reference: [3] <author> Z. M. Ariola and Arvind. </author> <title> Compilation of Id : a Subset of Id. </title> <type> Technical Report CSG Memo 315, </type> <institution> MIT Laboratory for Computer Science, </institution> <month> November </month> <year> 1990. </year>
Reference-contexts: The Kid to P-TAC translation, which involves choosing representations for data structures and higher-order functions, is discussed in Section 3. The tone of the paper is informal throughout; for a more comprehensive description of the compiler the reader may refer to <ref> [3] </ref>. However, even in [3], M-structures are not discussed. 2 Kid: The Kernel Id language In Kid every expression, except a block, a case or a -expression, is of the form PF n (SE 1 ; ; SE n ) where PF n is the name of a primitive function of <p> The Kid to P-TAC translation, which involves choosing representations for data structures and higher-order functions, is discussed in Section 3. The tone of the paper is informal throughout; for a more comprehensive description of the compiler the reader may refer to <ref> [3] </ref>. However, even in [3], M-structures are not discussed. 2 Kid: The Kernel Id language In Kid every expression, except a block, a case or a -expression, is of the form PF n (SE 1 ; ; SE n ) where PF n is the name of a primitive function of arity n, and SE <p> The set D is initialized with constants that are introduced by the translator. 3.1 Translation from Kid into P-TAC In the following we will only discuss how arrays, lists and functions are repre sented in P-TAC; the interested reader may refer <ref> [3] </ref> for more details. Arrays The representation of Array (l; u) is given in Figure 6.
Reference: [4] <author> Z. M. Ariola and Arvind. </author> <title> A Syntactic Approach to Program Transformations. </title> <booktitle> In Proc. ACM SIGPLAN Symposium on Partial Evaluation and Semantics Based Program Manipulation, </booktitle> <institution> Yale University, </institution> <year> 1991. </year>
Reference-contexts: Our let-block semantics precisely defines how arguments are shared; an essential feature for Id extended with I-structures and M-structures. Sharing is expressed by giving a name to each subexpression and by allowing substitution of values and variables only. This idea can be formalized in a Contextual Rewriting Systems (CRS) <ref> [2, 4] </ref> by the following Substitution rules: X = V X = Y where V is either an Integer or a Boolean or an Error.
Reference: [5] <author> Arvind, R. Nikhil, and K. Pingali. I-Structures: </author> <title> Data Structures for Parallel Computing. </title> <booktitle> In Proceedings of the Workshop on Graph Reduction, </booktitle> <address> Santa Fe, New Mexico, </address> <publisher> Springer-Verlag LNCS 279, </publisher> <pages> pages 336-369, </pages> <month> Septem-ber/October </month> <year> 1987. </year>
Reference-contexts: In this paper we will show certain aspects of the process of compiling Id, an implicit parallel language [13]. Id is a higher-order functional language augmented with I-structures <ref> [5] </ref> and M-structures [7]. I-structures add a flavor of logic variables, while M-structures add side-effects and non-determinism to Id. Id, like most modern functional languages, has a Hindley-Milner type sys 2 tem and non-strict semantics. Id has been in use at MIT as the language for programming dataflow machines.
Reference: [6] <author> L. Augustsson. </author> <title> Compiling Lazy Functional Languages, Part II. </title> <type> PhD thesis, </type> <institution> Chalmers University of Technology, Department of Computer Science, </institution> <year> 1987. </year>
Reference-contexts: The compiler may choose different data structures, such as, parse trees or graphs, for terms in different modules. The idea of viewing intermediate forms as languages is not new in the functional language community <ref> [6, 9, 14] </ref>, but it is still rare in the Fortran community (Pingali's work being a notable exception [15]). In this paper we will show certain aspects of the process of compiling Id, an implicit parallel language [13].
Reference: [7] <author> P. Barth, R. Nikhil, and Arvind. M-structures: </author> <title> Extending a Parallel, Non-strict, Functional Language with state. </title> <booktitle> In Proc. ACM Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> Cam-bridge, </address> <year> 1991. </year> <month> 24 </month>
Reference-contexts: In this paper we will show certain aspects of the process of compiling Id, an implicit parallel language [13]. Id is a higher-order functional language augmented with I-structures [5] and M-structures <ref> [7] </ref>. I-structures add a flavor of logic variables, while M-structures add side-effects and non-determinism to Id. Id, like most modern functional languages, has a Hindley-Milner type sys 2 tem and non-strict semantics. Id has been in use at MIT as the language for programming dataflow machines.
Reference: [8] <author> T. Johnsson. </author> <title> Lambda Lifting: Transforming Programs to Recursive Equa--tions. </title> <booktitle> In Proc. Conf. on Functional Programming Languages and Computer Architecture, </booktitle> <address> Nancy, France, </address> <month> September </month> <year> 1985. </year>
Reference-contexts: Dispatch n;m (i; E 1 ; ; E i ; E n ) ! E i Prior to translating Kid into P-TAC, all nested -expressions are lifted to the top level by a process known as -lifting <ref> [8] </ref>. A Kid program after -lifting only contains closed -expressions.
Reference: [9] <author> T. Johnsson. </author> <title> Compiling Lazy Functional Languages. </title> <type> PhD thesis, </type> <institution> Chalmers University of Technology, Department of Computer Science, </institution> <year> 1987. </year>
Reference-contexts: The compiler may choose different data structures, such as, parse trees or graphs, for terms in different modules. The idea of viewing intermediate forms as languages is not new in the functional language community <ref> [6, 9, 14] </ref>, but it is still rare in the Fortran community (Pingali's work being a notable exception [15]). In this paper we will show certain aspects of the process of compiling Id, an implicit parallel language [13].
Reference: [10] <author> J. Klop. </author> <title> Term Rewriting Systems. Course Notes, Summer course organized by Corrado Boehm, </title> <address> Ustica, Italy, </address> <month> September </month> <year> 1985. </year>
Reference-contexts: Since we have expressed the optimizations as rewrite rules, the problem of termination and the effect of reduction strategies can be stated in terms of strongly normalizing rules and confluence, respectively <ref> [10] </ref>. Most optimization rules are indeed confluent. A few that do destroy confluence do so only in programs with deadlocks. The confluence of optimization rules gives us some flexibility in choosing the order in which rules are to be applied.
Reference: [11] <author> P. Landin. </author> <title> A Correspondence between Algol60 and Church's Lambda notation. </title> <journal> Communications ACM, </journal> <volume> 8, </volume> <year> 1965. </year>
Reference-contexts: 1 Introduction Modern (functional) languages are too complex to be given direct operational semantics. It is usually better to translate the source language into a simpler and smaller kernel language in order to explain its meaning precisely <ref> [11] </ref>. A program is said to be well-formed if it can be translated into the kernel language, 1 and if it satisfies certain other constraints such as type correctness. Operational or dynamic semantics is concerned only with well-formed programs.
Reference: [12] <author> J.-J. Levy. </author> <title> Reductions Correctes et Optimales dans le Lambda-Calcul. </title> <type> Ph.D. thesis, </type> <institution> Universite Paris VII, </institution> <month> October </month> <year> 1978. </year>
Reference-contexts: This concept of printable value is related to the notion of instant semantics introduced by Welch [18]. The answer is then defined in terms of the maximum information that can be extracted by reducing that term. Levy <ref> [12] </ref> and Ariola [2] have shown that by picking a suitable definition of print, the domain of answers becomes a term model for the language. Suppose A (M ) denotes the answer associated with M .
Reference: [13] <author> R. S. Nikhil. </author> <title> Id (Version 90.0) Reference Manual. </title> <type> Technical Report CSG Memo 284-a, </type> <institution> MIT Laboratory for Computer Science, 545 Technology Square, </institution> <address> Cambridge, MA 02139, USA, </address> <month> July </month> <year> 1990. </year>
Reference-contexts: In this paper we will show certain aspects of the process of compiling Id, an implicit parallel language <ref> [13] </ref>. Id is a higher-order functional language augmented with I-structures [5] and M-structures [7]. I-structures add a flavor of logic variables, while M-structures add side-effects and non-determinism to Id. Id, like most modern functional languages, has a Hindley-Milner type sys 2 tem and non-strict semantics.
Reference: [14] <editor> S. L. Peyton Jones. </editor> <booktitle> The implementation of Functional Programming Languages. Prentice-Hall International, </booktitle> <address> Englewood Cliffs, N.J., </address> <year> 1987. </year>
Reference-contexts: The compiler may choose different data structures, such as, parse trees or graphs, for terms in different modules. The idea of viewing intermediate forms as languages is not new in the functional language community <ref> [6, 9, 14] </ref>, but it is still rare in the Fortran community (Pingali's work being a notable exception [15]). In this paper we will show certain aspects of the process of compiling Id, an implicit parallel language [13]. <p> E) j List Case (SE; E; E) j Block j (x 1 ; ; x n ):E Block ::= f [Statement; ] fl In SEg Statement ::= Binding j Command Binding ::= V ariable = E Command ::= P store (SE; SE; SE) Store error j &gt; s functional languages <ref> [14] </ref>, let-blocks play a fundamental role in the operational semantics of Kid. Our let-block semantics precisely defines how arguments are shared; an essential feature for Id extended with I-structures and M-structures. Sharing is expressed by giving a name to each subexpression and by allowing substitution of values and variables only.
Reference: [15] <author> K. Pingali, M. Beck, R. Johnson, M. Moudgill, and P. Stodghill. </author> <title> Dependence Flow Graphs: An Algebraic Approach to Program Dependencies. </title> <booktitle> In Proceedings of the 18th ACM Symposium on Principle of programming Languages, </booktitle> <pages> pages 67-78, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: The idea of viewing intermediate forms as languages is not new in the functional language community [6, 9, 14], but it is still rare in the Fortran community (Pingali's work being a notable exception <ref> [15] </ref>). In this paper we will show certain aspects of the process of compiling Id, an implicit parallel language [13]. Id is a higher-order functional language augmented with I-structures [5] and M-structures [7]. I-structures add a flavor of logic variables, while M-structures add side-effects and non-determinism to Id.
Reference: [16] <author> K. Schauser, D. Culler, and T. von Eicken. </author> <booktitle> Compiler-Controlled Mul-tithreading for Lenient Parallel Languages. In Proc. ACM Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> Cam-bridge, </address> <year> 1991. </year>
Reference-contexts: Id, like most modern functional languages, has a Hindley-Milner type sys 2 tem and non-strict semantics. Id has been in use at MIT as the language for programming dataflow machines. In the last few years interest has grown in compiling Id for workstations and stock parallel machines <ref> [16, 17] </ref>. We have recently started a project to write the Id compiler in Id, which will embody the strategy outlined in this paper. some of the steps in going from Id to Kid, the kernel Id language. The circular arrows in Figure 1 refer to optimizations.
Reference: [17] <author> K. Traub. </author> <title> Compilation as Partitioning: A New Approach to Compiling Non-strict Functional Languages. </title> <booktitle> In Proc. ACM Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> Cambridge, </address> <year> 1991. </year>
Reference-contexts: Id, like most modern functional languages, has a Hindley-Milner type sys 2 tem and non-strict semantics. Id has been in use at MIT as the language for programming dataflow machines. In the last few years interest has grown in compiling Id for workstations and stock parallel machines <ref> [16, 17] </ref>. We have recently started a project to write the Id compiler in Id, which will embody the strategy outlined in this paper. some of the steps in going from Id to Kid, the kernel Id language. The circular arrows in Figure 1 refer to optimizations.
Reference: [18] <author> P. Welch. </author> <title> Continuous Semantics and Inside-out Reductions. In -Calculus and Computer Schience Theory, </title> <booktitle> Italy (Springer-Verlag Lecture Notes in Computer Science 37), </booktitle> <month> March </month> <year> 1975. </year>
Reference-contexts: Only after we reduce +(2,3) to 5, we can say that the printable value of the term is 5. This concept of printable value is related to the notion of instant semantics introduced by Welch <ref> [18] </ref>. The answer is then defined in terms of the maximum information that can be extracted by reducing that term. Levy [12] and Ariola [2] have shown that by picking a suitable definition of print, the domain of answers becomes a term model for the language.
Reference: [19] <author> Proc. </author> <title> ACM SIGPLAN Symposium on Partial Evaluation and Semantics Based Program Manipulation, </title> <institution> Yale University, </institution> <address> New Haven, CN. </address> <month> June </month> <year> 1991. </year> <month> 25 </month>
Reference-contexts: The only optimization rules that can cause non-termination are the partial evaluation and the inline substitution rules. This problem of termination has 13 been studied extensively in the partial evaluation literature which an interested reader may refer <ref> [19] </ref>. The deadcode elimination can be done at any stage but must be done once more in the end to pick up maximum dead code.
References-found: 19

