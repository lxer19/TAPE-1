URL: http://www.cs.umn.edu/Users/dept/users/kumar/mlevel_diffuse_serial.ps
Refering-URL: http://www.cs.umn.edu/Users/dept/users/kumar/
Root-URL: http://www.cs.umn.edu
Email: cs.umn.edu  
Title: Multilevel Diffusion Schemes for Repartitioning of Adaptive Meshes  
Author: Kirk Schloegel, George Karypis, Vipin Kumar kirk, karypis, kumar 
Date: June 19, 1997  
Affiliation: University of Minnesota, Department of Computer Science  
Pubnum: Technical Report: 97-013  
Abstract: For a large class of irregular grid applications, the structure of the mesh changes from one phase of the computation to the next. Eventually, as the graph evolves, the adapted mesh has to be repar-titioned to ensure good load balance. If this new graph is partitioned from scratch, it will lead to an excessive migration of data among processors. In this paper, we present two new schemes for computing repartitionings of adaptively refined meshes. These schemes perform diffusion of vertices in a multilevel framework and minimize vertex movement without significantly compromising the edge-cut. We present heuristics to control the tradeoff between edge-cut and vertex migration costs. We also show that multilevel diffusion produces results with improved edge-cuts over single-level diffusion, is potentially much faster than single-level diffusion in a parallel context, and is better able to make use of heuristics to control the trade-off between edge-cut and vertex migration costs than single-level diffusion. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Biswas and R. C. Strawn. </author> <title> A new procedure for dynamic adaption of three-dimensional unstructured grids. </title> <journal> Applied Numerical Mathematics, </journal> <volume> 13 </volume> <pages> 437-452, </pages> <year> 1994. </year>
Reference-contexts: This problem has been well defined and discussed in previous work [6, 10]. For a large class of irregular grid applications, the computational structure of the problem changes in an incremental fashion from one phase of the computation to another. For example, in adaptive meshes <ref> [1] </ref>, areas of the original graph are selectively coarsened or refined in order to accurately model the dynamic computation. This causes the weights of the vertices and the edges to change.
Reference: [2] <author> J. E. Boillat. </author> <title> Load balancing and poisson equation in a graph. </title> <journal> Concurrency: Practice and Experience, </journal> <volume> 2 </volume> <pages> 289-313, </pages> <year> 1990. </year>
Reference-contexts: Undirected diffusion has the advantage that it is highly distributed in nature. However, balancing occurs without the guidance of a global view of the graph. This can increase the edge-cut, vertex migration costs, and run time of the algorithm. The general context of load balancing has been studied in <ref> [2, 3, 19] </ref>. Directed diffusion is diffusion guided by a global view of the graph. It is accomplished by obtaining a diffusion solution and applying it to the vertices of the imbalanced graph. The diffusion solution, , is a vector with p elements.
Reference: [3] <author> G. Cybenko. </author> <title> Dynamic load balancing for distributed memory multiprocessors. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 7(2) </volume> <pages> 279-301, </pages> <year> 1989. </year>
Reference-contexts: Undirected diffusion has the advantage that it is highly distributed in nature. However, balancing occurs without the guidance of a global view of the graph. This can increase the edge-cut, vertex migration costs, and run time of the algorithm. The general context of load balancing has been studied in <ref> [2, 3, 19] </ref>. Directed diffusion is diffusion guided by a global view of the graph. It is accomplished by obtaining a diffusion solution and applying it to the vertices of the imbalanced graph. The diffusion solution, , is a vector with p elements.
Reference: [4] <author> C. M. Fiduccia and R. M. Mattheyses. </author> <title> A linear time heuristic for improving network partitions. </title> <booktitle> In In Proc. 19th IEEE Design Automation Conference, </booktitle> <pages> pages 175-181, </pages> <year> 1982. </year>
Reference-contexts: Thus, the MeTiS algorithm uses a global view of a graph to quickly find a good initial partition and multilevel views of the graph to further improve this partition. Refinement is done in MeTiS by a method based on the Kernighan-Lin refinement algorithm <ref> [4, 13] </ref>. Vertices are visited randomly.
Reference: [5] <author> Gene H. Golub and Charles Van Loan. </author> <title> Matrix Computations: Second Edition. </title> <publisher> The Johns Hopkins University Press, </publisher> <address> Baltimore, MD, </address> <year> 1989. </year>
Reference-contexts: Furthermore, they showed that when using the parallel conjugate gradient algorithm <ref> [5] </ref> to solve for , the algorithm converges in less than p iterations [8]. Walshaw, Cross, and Everett implemented, JOSTLE, a combined partitioner and directed diffusion repartitioner based on an optimization of the Hu and Blake diffusion solver. The JOSTLE algorithm has two distinct phases.
Reference: [6] <author> Bruce Hendrickson and Robert Leland. </author> <title> A multilevel algorithm for partitioning graphs. </title> <type> Technical Report SAND93-1301, </type> <institution> Sandia National Laboratories, </institution> <year> 1993. </year>
Reference-contexts: Since the weight of any given edge represents the amount of communication required between nodes, minimizing the number of edges cut by the partition tends to minimize the overall amount of communication required by the computation. This problem has been well defined and discussed in previous work <ref> [6, 10] </ref>. For a large class of irregular grid applications, the computational structure of the problem changes in an incremental fashion from one phase of the computation to another.
Reference: [7] <author> G. Horton. </author> <title> A multi-level diffusion method for dynamic load balancing. </title> <journal> Parallel Computing, </journal> <volume> 9 </volume> <pages> 209-218, </pages> <year> 1993. </year>
Reference-contexts: An amount of vertex weight equal to q r needs to be moved from partition q to partition r for every partition r which is adjacent to partition q in order for the graph to balance. A negative value indicates vertex flow in the opposite direction <ref> [7, 8, 17] </ref>. Two methods of computing the diffusion solution involve minimization of the one-norm of the diffusion solution and minimization of its two-norm. One-norm minimization is the minimization of the sum of the elements of the diffusion solution vector.
Reference: [8] <author> Y. F. Hu and R. J. Blake. </author> <title> An optimal dynamic load balancing algorithm. </title> <type> Technical Report DL-P-95-011, </type> <institution> Daresbury Laboratory, Warrington, UK, </institution> <year> 1995. </year>
Reference-contexts: This multilevel diffusion scheme can move large chunks of vertices at coarser levels, and then achieve better load balance at finer levels. In a multilevel context, a global picture of the graph <ref> [8] </ref> can be used to guide graph balancing while utilizing a multilevel view to guide refinement. In this paper, we describe two multilevel diffusion repartitioning algorithms. The first constructs a series of contracted graphs by collapsing pairs of vertices together. <p> Finally, the graph undergoes multilevel refinement in an attempt to clean up the edge-cut disturbed by the balancing phase. The second multilevel diffusion repartitioning algorithm is similar to the first. Here, however, the partition is balanced by means of directed diffusion <ref> [8] </ref>. The graph contraction and multilevel refinement phases are otherwise identical to the first algorithm. We further describe two heuristics which are able to control the tradeoff between edge-cut and vertex migration costs when used in a multilevel context. <p> The concept is for vertices to move from overbalanced partitions to underbalanced partitions and to eventually reach balance, just as in the analogous case, uneven temperatures in a space cause the movement of heat towards equilibrium <ref> [8] </ref>. has a partition weight of 6, while the average partition weight is only 4. Edge-cut for the original graph is 12. In Figure 1 (b), the original partition was thrown out and the graph was then partitioned from scratch. Edge-cut is 12 here. <p> An amount of vertex weight equal to q r needs to be moved from partition q to partition r for every partition r which is adjacent to partition q in order for the graph to balance. A negative value indicates vertex flow in the opposite direction <ref> [7, 8, 17] </ref>. Two methods of computing the diffusion solution involve minimization of the one-norm of the diffusion solution and minimization of its two-norm. One-norm minimization is the minimization of the sum of the elements of the diffusion solution vector. <p> Furthermore, they showed that when using the parallel conjugate gradient algorithm [5] to solve for , the algorithm converges in less than p iterations <ref> [8] </ref>. Walshaw, Cross, and Everett implemented, JOSTLE, a combined partitioner and directed diffusion repartitioner based on an optimization of the Hu and Blake diffusion solver. The JOSTLE algorithm has two distinct phases.
Reference: [9] <author> G. Karypis and V. Kumar. MeTiS: </author> <title> Unstructured graph partitioning and sparse matrix ordering system. </title> <type> Technical report, </type> <institution> Department of Computer Science, University of Minnesota, </institution> <year> 1995. </year> <note> Available on the WWW at URL http://www.cs.umn.edu/~karypis/metis/metis.html. </note>
Reference-contexts: For example, a state-of-the-art multilevel partitioner such as MeTiS <ref> [9] </ref> can provide a fast, scalable and balanced partition with a low edge-cut. However, intuition tells us that since no concern is given for the existing partition, most vertices are not likely to be assigned to their initial partitions with this method. Thus, vertex migration will be unduly high.
Reference: [10] <author> G. Karypis and V. Kumar. </author> <title> Multilevel k-way partitioning scheme for irregular graphs. </title> <type> Technical Report TR 95-064, </type> <institution> Department of Computer Science, University of Minnesota, </institution> <year> 1995. </year> <note> Also available on WWW at URL http://www.cs.umn.edu/~karypis/papers/mlevel kway.ps. </note>
Reference-contexts: Since the weight of any given edge represents the amount of communication required between nodes, minimizing the number of edges cut by the partition tends to minimize the overall amount of communication required by the computation. This problem has been well defined and discussed in previous work <ref> [6, 10] </ref>. For a large class of irregular grid applications, the computational structure of the problem changes in an incremental fashion from one phase of the computation to another. <p> Hence, we first review the k-way multilevel scheme for partitioning. 4.1 A Review of Multilevel Schemes for Graph Partitioning The k-way multilevel graph partitioning algorithm <ref> [10] </ref> implemented in MeTiS 1 has three phases, a coarsening phase, a partitioning phase, and a refinement (or uncoarsening) phase. During the coarsening phase, a sequence of smaller graphs are constructed from an input graph by collapsing vertices together. <p> If so, the vertex is migrated. This process is repeated until it converges <ref> [10] </ref>. We define these two conditions as the vertex migration criteria. 4.2 Multilevel Diffusion Repartitioning Algorithms A multilevel undirected diffusion repartitioning algorithm (MLD) as a modification of the multilevel k-way partitioning algorithm implemented in MeTiS can be derived as follows.
Reference: [11] <author> G. Karypis and V. Kumar. </author> <title> Parallel multilevel k-way partitioning scheme for irregular graphs. </title> <type> Technical Report TR 96-036, </type> <institution> Department of Computer Science, University of Minnesota, </institution> <year> 1996. </year> <note> Also available on WWW at URL http://www.cs.umn.edu/~karypis/papers/mlevel kparallel.ps. A short version appears in Supercomputing 96. </note>
Reference-contexts: Performing the repartitioning on a serial processor can become a very serious bottleneck. If the adapted graph is partitioned from scratch using a state-of-the-art multilevel graph partitioner such as MeTiS <ref> [11] </ref>, then it will reasonably optimize criterion 1 and 2. Since a highly parallel formulation of MeTiS exist [11], criterion 4 can also be met to a large extent. <p> Performing the repartitioning on a serial processor can become a very serious bottleneck. If the adapted graph is partitioned from scratch using a state-of-the-art multilevel graph partitioner such as MeTiS <ref> [11] </ref>, then it will reasonably optimize criterion 1 and 2. Since a highly parallel formulation of MeTiS exist [11], criterion 4 can also be met to a large extent. Partitioning from scratch will, however, result in high vertex migration, as the partitioning does not take the initial location of the vertices into account. <p> Multilevel diffusion can be easily parallelized analogous to multilevel graph partitioning <ref> [11] </ref> and is potentially much faster than single-level diffusion in a parallel context. The organization of this paper is as follows. Section 2 describes the notations and definitions which we use throughout this paper. Section 3 reviews previous related work. Section 4 describes our multilevel diffusion repartitioning algorithms in depth. <p> It also does not include the concepts of vertex weight, size, or of MaxV. Neither is it able to specifically minimize edge-cut, TotalV, or MaxV. 6 4 Multilevel Graph Repartitioning Multilevel graph repartitioning is essentially a modification of the k-way multilevel partitioning algorithm <ref> [11] </ref>. Hence, we first review the k-way multilevel scheme for partitioning. 4.1 A Review of Multilevel Schemes for Graph Partitioning The k-way multilevel graph partitioning algorithm [10] implemented in MeTiS 1 has three phases, a coarsening phase, a partitioning phase, and a refinement (or uncoarsening) phase. <p> Our experiments show that directed diffusion tends to obtain results improved over those obtained by undirected diffusion. The multi-level diffusion scheme and its variants discussed in this paper are at least as easy to parallelize as the multilevel graph partitioner discussed in <ref> [11] </ref>. Recently, scalable parallel formulations of MeTiS's 18 multilevel k-way graph partitioning have been developed [11, 12] that are able to significantly reduce the amount of time required to partition large graphs. The multilevel diffusion algorithms described in this paper can be effectively parallelized using similar techniques. <p> The multi-level diffusion scheme and its variants discussed in this paper are at least as easy to parallelize as the multilevel graph partitioner discussed in [11]. Recently, scalable parallel formulations of MeTiS's 18 multilevel k-way graph partitioning have been developed <ref> [11, 12] </ref> that are able to significantly reduce the amount of time required to partition large graphs. The multilevel diffusion algorithms described in this paper can be effectively parallelized using similar techniques. <p> During the refinement phases groups of vertices are moved among partitions in order to improve the balance as well as reduce the edge-cut. A parallel formulation of this step can select these vertices using either independent sets discussed in <ref> [11] </ref>, or the odd-even scheme discussed in [12]. In either case, the communication overhead of each refinement step is very small as it is proportional to the number of interface vertices of the original partitioning.
Reference: [12] <author> George Karypis and Vipin Kumar. </author> <title> A coarse-grain parallel multilevel k-way partitioning algorithm. </title> <booktitle> In Proceedings of the eighth SIAM conference on Parallel Processing for Scientific Computing, </booktitle> <year> 1997. </year> <month> 19 </month>
Reference-contexts: The multi-level diffusion scheme and its variants discussed in this paper are at least as easy to parallelize as the multilevel graph partitioner discussed in [11]. Recently, scalable parallel formulations of MeTiS's 18 multilevel k-way graph partitioning have been developed <ref> [11, 12] </ref> that are able to significantly reduce the amount of time required to partition large graphs. The multilevel diffusion algorithms described in this paper can be effectively parallelized using similar techniques. <p> During the refinement phases groups of vertices are moved among partitions in order to improve the balance as well as reduce the edge-cut. A parallel formulation of this step can select these vertices using either independent sets discussed in [11], or the odd-even scheme discussed in <ref> [12] </ref>. In either case, the communication overhead of each refinement step is very small as it is proportional to the number of interface vertices of the original partitioning.
Reference: [13] <author> B. W. Kernighan and S. Lin. </author> <title> An efficient heuristic procedure for partitioning graphs. </title> <journal> The Bell System Technical Journal, </journal> <year> 1970. </year>
Reference-contexts: Thus, the MeTiS algorithm uses a global view of a graph to quickly find a good initial partition and multilevel views of the graph to further improve this partition. Refinement is done in MeTiS by a method based on the Kernighan-Lin refinement algorithm <ref> [4, 13] </ref>. Vertices are visited randomly.
Reference: [14] <author> Leonid Oliker and Rupak Biswas. </author> <title> Efficient load balancing and data remapping for adaptive grid calculations. </title> <type> Technical report, </type> <institution> NASA Ames Research Center, Moffett Field, </institution> <address> CA, </address> <year> 1997. </year>
Reference-contexts: Thus, the repartitioner should attempt to balance the graph with respect to vertex weight while minimizing vertex migration with respect to vertex size. Depending on the representation and storage policy of the data, size and weight may not necessarily be equal. One example of such a situation arises in <ref> [14] </ref>. A method of reducing the vertex migration overhead used in [14] is to determine both the coarsening and the refinement of the adaptive mesh prior to repartitioning, but to actually perform only mesh coarsening at this time. This causes the graph to shrink prior to repartitioning. <p> Depending on the representation and storage policy of the data, size and weight may not necessarily be equal. One example of such a situation arises in <ref> [14] </ref>. A method of reducing the vertex migration overhead used in [14] is to determine both the coarsening and the refinement of the adaptive mesh prior to repartitioning, but to actually perform only mesh coarsening at this time. This causes the graph to shrink prior to repartitioning.
Reference: [15] <author> Chao-Wei Ou and Sanjay Ranka. </author> <title> Parallel incremental graph partitioning using linear programming. </title> <type> Technical report, </type> <institution> Syracuse University, Syracuse, </institution> <address> NY, </address> <year> 1992. </year>
Reference-contexts: Such a method can also be potentially faster than partitioning the graph from scratch. Repartitioning schemes that incrementally modify an existing partition have been quite successful on graphs that are small perturbations of the original graphs <ref> [15, 16] </ref>. For these graphs, such a scheme inherits a good (i.e. low edge-cut), but imbalanced starting point in the initial partition. It then attempts to fix the imbalance of this partition while maintaining its good edge-cut. <p> Thus, even if the disturbance to the initial partition is minimized, the final partition will necessarily end up quite a bit removed from it. Hence, the balancing phase of such a method will increase the edge-cut considerably. Local refinement <ref> [15, 16] </ref> can only provide a limited improvement in the edge-cut of the resulting partition. <p> Their results indicate that the repartitioned edge-cut was comparable to the original edge-cut and that the IGP run time was dramatically lower than the run time of the original partition <ref> [15] </ref>. Hu and Blake described a method which computes the diffusion solution while optimally minimizing the two-norm.
Reference: [16] <author> C. Walshaw, M. Cross, and M. G. Everett. </author> <title> Dynamic load-balancing for parallel adaptive unstructured meshes. </title> <booktitle> Parallel Processing for Scientific Computing, </booktitle> <year> 1997. </year>
Reference-contexts: Partitioning from scratch will, however, result in high vertex migration, as the partitioning does not take the initial location of the vertices into account. A partitioning method that incrementally constructs a new partition as simply a modification of the input partition (e.g. by diffusion <ref> [16] </ref>) can potentially move a much smaller number of vertices. Such a method can also be potentially faster than partitioning the graph from scratch. Repartitioning schemes that incrementally modify an existing partition have been quite successful on graphs that are small perturbations of the original graphs [15, 16]. <p> Such a method can also be potentially faster than partitioning the graph from scratch. Repartitioning schemes that incrementally modify an existing partition have been quite successful on graphs that are small perturbations of the original graphs <ref> [15, 16] </ref>. For these graphs, such a scheme inherits a good (i.e. low edge-cut), but imbalanced starting point in the initial partition. It then attempts to fix the imbalance of this partition while maintaining its good edge-cut. <p> Thus, even if the disturbance to the initial partition is minimized, the final partition will necessarily end up quite a bit removed from it. Hence, the balancing phase of such a method will increase the edge-cut considerably. Local refinement <ref> [15, 16] </ref> can only provide a limited improvement in the edge-cut of the resulting partition. <p> Walshaw, Cross, and Everett developed JOSTLE-MD by changing the refinement phase of the original JOSTLE repartitioner to a multilevel refinement phase <ref> [16] </ref>. A summary of their results is included in Section 7.1. Unlike our algorithm, JOSTLE-MD employs a single-level diffusion scheme for balancing and then performs multilevel refinement. It also does not include the concepts of vertex weight, size, or of MaxV. <p> The first set is taken from the DIME software package [18]. The application solves Laplace's equation with Dirichelet boundary conditions on a square, 2-dimensional mesh with a stylized 'S' hole. The problem is solved by Jacobi iteration, refined, and load-balanced <ref> [16] </ref>. The result is a domain with a small degree of change at each successive stage in the mesh adaptation. 16 The second set shows a series of application meshes with a high degree of adaptation at each stage. These graphs are 3-dimensional mesh models of a rotating helicopter blade. <p> Also, the TotalV results are first divided by the total number of vertices in each graph and then averaged together to obtain TotalV%. JOSTLE-D is a single-level diffusion algorithm described in [17]. JOSTLE-MD is a single-level diffusion algorithm with multilevel refinement described in <ref> [16] </ref>. SLDD indicates results obtained from our single-level directed diffusion repartitioning algorithm with cleanness and suppression factors set at zero. MLDD indicates results obtained from the MLDD algorithm. MLDD-CS indicates results obtained from our multilevel directed diffusion repartitioning algorithm with cleanness factor of .0001 and suppression factors of .25. <p> MLDD-CdS indicates results from the MLDD-CS algorithm using a cleanness factor of .0001 and a dynamic suppression factors of 1. MeTiS indicates results from partitioning from scratch with MeTiS. We have taken the results for JOSTLE-D and JOSTLE-MD directly out of <ref> [16] </ref>. Note that although experiments in [16] were also done on the graphs obtained from the DIME software package, the graphs used in our experiments are not identical to those used in [16]. However, we attempted to reconstruct the graphs used in [16]. <p> MLDD-CdS indicates results from the MLDD-CS algorithm using a cleanness factor of .0001 and a dynamic suppression factors of 1. MeTiS indicates results from partitioning from scratch with MeTiS. We have taken the results for JOSTLE-D and JOSTLE-MD directly out of <ref> [16] </ref>. Note that although experiments in [16] were also done on the graphs obtained from the DIME software package, the graphs used in our experiments are not identical to those used in [16]. However, we attempted to reconstruct the graphs used in [16]. Our graphs are very similar in size and nature to those used in [16]. <p> We have taken the results for JOSTLE-D and JOSTLE-MD directly out of <ref> [16] </ref>. Note that although experiments in [16] were also done on the graphs obtained from the DIME software package, the graphs used in our experiments are not identical to those used in [16]. However, we attempted to reconstruct the graphs used in [16]. Our graphs are very similar in size and nature to those used in [16]. We use nine graphs with sizes from 31,624 vertices and 46,986 edges to 281,706 vertices and 421,172 edges, while the graphs in [16] range from 23,787 <p> results for JOSTLE-D and JOSTLE-MD directly out of <ref> [16] </ref>. Note that although experiments in [16] were also done on the graphs obtained from the DIME software package, the graphs used in our experiments are not identical to those used in [16]. However, we attempted to reconstruct the graphs used in [16]. Our graphs are very similar in size and nature to those used in [16]. We use nine graphs with sizes from 31,624 vertices and 46,986 edges to 281,706 vertices and 421,172 edges, while the graphs in [16] range from 23,787 vertices and 35,281 edges to 224,843 vertices and 336,024 edges. <p> <ref> [16] </ref> were also done on the graphs obtained from the DIME software package, the graphs used in our experiments are not identical to those used in [16]. However, we attempted to reconstruct the graphs used in [16]. Our graphs are very similar in size and nature to those used in [16]. We use nine graphs with sizes from 31,624 vertices and 46,986 edges to 281,706 vertices and 421,172 edges, while the graphs in [16] range from 23,787 vertices and 35,281 edges to 224,843 vertices and 336,024 edges. All of the results are obtained using a 64-way partition. <p> those used in <ref> [16] </ref>. However, we attempted to reconstruct the graphs used in [16]. Our graphs are very similar in size and nature to those used in [16]. We use nine graphs with sizes from 31,624 vertices and 46,986 edges to 281,706 vertices and 421,172 edges, while the graphs in [16] range from 23,787 vertices and 35,281 edges to 224,843 vertices and 336,024 edges. All of the results are obtained using a 64-way partition.
Reference: [17] <author> C. Walshaw, M. Cross, and M. G. Everett. </author> <title> Dynamic mesh partitioning: A unified optimisation and load-balancing algorithm. </title> <type> Technical Report 95/IM/06, </type> <institution> Centre for Numerical Modelling and Process Analysis, University of Greenwich, </institution> <address> London, UK, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: An amount of vertex weight equal to q r needs to be moved from partition q to partition r for every partition r which is adjacent to partition q in order for the graph to balance. A negative value indicates vertex flow in the opposite direction <ref> [7, 8, 17] </ref>. Two methods of computing the diffusion solution involve minimization of the one-norm of the diffusion solution and minimization of its two-norm. One-norm minimization is the minimization of the sum of the elements of the diffusion solution vector. <p> The first is a balancing phase in which the diffusion solution guides vertex migration in order to balance the graph. The second is a refinement phase in which a local view of the graph guides vertex migration in order to decrease the edge-cut upset by the balancing phase <ref> [17] </ref>. Walshaw, Cross, and Everett developed JOSTLE-MD by changing the refinement phase of the original JOSTLE repartitioner to a multilevel refinement phase [16]. A summary of their results is included in Section 7.1. Unlike our algorithm, JOSTLE-MD employs a single-level diffusion scheme for balancing and then performs multilevel refinement. <p> Here, the edge-cuts and run times are averaged over the nine experiments. Also, the TotalV results are first divided by the total number of vertices in each graph and then averaged together to obtain TotalV%. JOSTLE-D is a single-level diffusion algorithm described in <ref> [17] </ref>. JOSTLE-MD is a single-level diffusion algorithm with multilevel refinement described in [16]. SLDD indicates results obtained from our single-level directed diffusion repartitioning algorithm with cleanness and suppression factors set at zero. MLDD indicates results obtained from the MLDD algorithm.
Reference: [18] <author> R. D. Williams. Dime: </author> <title> Distributed irregular mesh environment. </title> <type> Technical Report C3P 861, </type> <note> Caltech Concurrent Computation Report, </note> <year> 1990. </year>
Reference-contexts: The next Section shows the results of using MLDD with dynamic suppression on two application domains. 7 Repartioning of Application Graphs We have conducted experiments on repartitioning application graphs from two domains. The first set is taken from the DIME software package <ref> [18] </ref>. The application solves Laplace's equation with Dirichelet boundary conditions on a square, 2-dimensional mesh with a stylized 'S' hole. The problem is solved by Jacobi iteration, refined, and load-balanced [16].
Reference: [19] <author> C. Z. Xu and F. C. M. Lau. </author> <title> The generalized dimension exchange method for load balancing in k-ary ncubes and variants. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 24 </volume> <pages> 72-85, </pages> <year> 1995. </year> <month> 20 </month>
Reference-contexts: Undirected diffusion has the advantage that it is highly distributed in nature. However, balancing occurs without the guidance of a global view of the graph. This can increase the edge-cut, vertex migration costs, and run time of the algorithm. The general context of load balancing has been studied in <ref> [2, 3, 19] </ref>. Directed diffusion is diffusion guided by a global view of the graph. It is accomplished by obtaining a diffusion solution and applying it to the vertices of the imbalanced graph. The diffusion solution, , is a vector with p elements.
References-found: 19

