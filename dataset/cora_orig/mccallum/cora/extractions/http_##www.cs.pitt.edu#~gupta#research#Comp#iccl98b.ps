URL: http://www.cs.pitt.edu/~gupta/research/Comp/iccl98b.ps
Refering-URL: http://www.cs.pitt.edu/~gupta/research/optimization.html
Root-URL: 
Title: Path Profile Guided Partial Redundancy Elimination Using Speculation  
Author: Rajiv Gupta David A. Berson Jesse Z. Fang 
Address: Pittsburgh, PA 15260 Santa Clara, CA 95052  
Affiliation: Dept. of Computer Science Microcomputer Research Lab University of Pittsburgh Intel Corporation  
Abstract: While programs contain a large number of paths, a very small fraction of these paths are typically exercised during program execution. Thus, optimization algorithms should be designed to trade off the performance of less frequently executed paths in favor of more frequently executed paths. However, traditional formulations to code optimizations are incapable of performing such a trade-off. We present a path profile guided partial redundancy elimination algorithm that uses speculation to enable the removal of redundancy along more frequently executed paths at the expense of introducing additional expression evaluations along less frequently executed paths. We describe cost-benefit data flow analysis that uses path profiling information to determine the profitability of using speculation. The cost of enabling speculation of an expression at a conditional is determined by identifying paths along which an additional evaluation of the expression is introduced. The benefit of enabling speculation is determined by identifying paths along which additional redundancy elimination is enabled by speculation. The results of this analysis are incorporated in a speculative expression hoisting framework for partial redundancy elimination. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> T. Ball and J. Larus, </author> <title> "Efficient path profiling," </title> <booktitle> 29th Annual IEEE/ACM International Symposium on Mi-croarchitecture, </booktitle> <address> Paris, France, </address> <year> 1996. </year>
Reference-contexts: Implicit in this formulation is the assumption that all paths through the program are equally important. However, in practice, it has been observed that some paths through a program are more frequently executed than others and many paths are never executed <ref> [1] </ref>. In a study of SPEC95 integer benchmarks that we report in this paper we found that 65% of the functions in these benchmarks contained no more than five paths with non-zero execution frequency.
Reference: [2] <author> R. Bodik and R. Gupta, </author> <title> "Array Data-Flow Analysis for Load-Store Optimizations in Superscalar Architectures," </title> <journal> International Journal of Parallel Programming, </journal> <volume> Vol. 24, No. 6, </volume> <pages> pages 481-512, </pages> <year> 1996. </year>
Reference-contexts: We have also developed analysis techniques in which redundancy and dead code removal decisions are influenced by functional unit resource availabil-ity [9]. Other applications of our approach include strength reduction along certain paths and elimina tion of partially redundant loads and dead stores <ref> [2] </ref>.
Reference: [3] <author> R. Bodik and R. Gupta, </author> <title> "Partial Dead Code Elimination using Slicing Transformations," </title> <booktitle> ACM SIGPLAN Conf. on Prog. Language Design and Implementation, </booktitle> <address> pages 159-170,Las Vegas, Nevada, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: In general restructuring can result in exponential code growth. However, by measuring the cost of enabling the optimization in terms of the code growth, it is possible to limit optimization to the extent possible with limited amount of growth. This approach has already been applied to PRE <ref> [3] </ref>, partial dead code elimination [4] and elimination of partially redundant conditional branches [5]. 6 Concluding Remarks We demonstrated the use of path profile information in combining the use of speculation with the PRE optimization in order to aggressively optimize frequently executed paths through a program.
Reference: [4] <author> R. Bodik, R. Gupta, </author> <title> and M.L. Soffa, "Interprocedu-ral Conditional Branch Elimination," </title> <booktitle> ACM SIGPLAN Conf. on Prog. Language Design and Implementation, </booktitle> <pages> pages 146-158, </pages> <address> Las Vegas, Nevada, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: However, by measuring the cost of enabling the optimization in terms of the code growth, it is possible to limit optimization to the extent possible with limited amount of growth. This approach has already been applied to PRE [3], partial dead code elimination <ref> [4] </ref> and elimination of partially redundant conditional branches [5]. 6 Concluding Remarks We demonstrated the use of path profile information in combining the use of speculation with the PRE optimization in order to aggressively optimize frequently executed paths through a program.
Reference: [5] <author> R. Bodik, R. Gupta and M.L. Soffa, </author> <title> "Complete Removal of Redundant Computations," </title> <booktitle> ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <address> Montreal, Canada, </address> <month> June </month> <year> 1998. </year>
Reference-contexts: This approach has already been applied to PRE [3], partial dead code elimination [4] and elimination of partially redundant conditional branches <ref> [5] </ref>. 6 Concluding Remarks We demonstrated the use of path profile information in combining the use of speculation with the PRE optimization in order to aggressively optimize frequently executed paths through a program.
Reference: [6] <author> F. Chow, S. Chan, R. Kennedy, S-M. Liu, R. Lo, and P. Tu, </author> <title> "A New Algorithm for Partial Redundancy Elimination based upon SSA Form," </title> <booktitle> ACM SIGPLAN Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 273-286, </pages> <address> Las Vegas, Nevada, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: Instead the analysis over the entire program is performed simultaneously with respect to a given expression. The edges that cross loop boundaries are simply ignored during this analysis phase. Our approach performs PRE one expression at a time. As pointed out by Chow et al. <ref> [6] </ref> this approach has many advantages over the traditional approach that considers all expressions simultaneously. It lowers the maximum storage requirement of optimizing all expressions and allows exploitation of nesting relationship in expression trees to speed up the optimization of large expressions.
Reference: [7] <author> J.Z. Fang, </author> <title> "Compiler Algorithms on If-Conversion, Speculative Predicates Assignment and Predicated Code Optimizations," </title> <booktitle> Proc. of the Ninth Workshop on Languages and Compilers for Parallel Computers, </booktitle> <address> San Jose, California, </address> <month> August </month> <year> 1996. </year>
Reference-contexts: S n2SPEC exp (p) COSTPATHS exp (n) FREQ (p 0 ) BENEFIT exp (p) = FREQ (p) also allows the optimizer to focus on more important expressions while ignoring others and provide new opportunities for code reshaping. 3 Speculative Hoisting Framework A number of solutions to PRE have been proposed <ref> [7, 13, 11] </ref>. In this section we present an integration of speculation with the expression hoisting framework proposed by Steffen [13] to perform PRE. The modifications to Steffen's framework that are necessary to incorporate speculation are described in this section. <p> exp (n) EstCost exp (n) = P p2HighP aths CostP aths exp (n)(p) fi F req (p) + Total P p2LowPaths ^n2p Benefit exp (n) EstBenef it exp (n) = P p2HighP aths Benef itP aths exp (n)(p) fi F req (p) 5 Related Work In previous work by Fang <ref> [7] </ref> the use of speculation during partial redundancy elimination was also proposed. However, the algorithms in [7] apply to a single-entry-single-exit acyclic region and no cost-benefit analysis to guide speculation is presented. <p> (p) + Total P p2LowPaths ^n2p Benefit exp (n) EstBenef it exp (n) = P p2HighP aths Benef itP aths exp (n)(p) fi F req (p) 5 Related Work In previous work by Fang <ref> [7] </ref> the use of speculation during partial redundancy elimination was also proposed. However, the algorithms in [7] apply to a single-entry-single-exit acyclic region and no cost-benefit analysis to guide speculation is presented. Independently of our work Horspool and Ho [10] have recently proposed a profile driven PRE algorithm based upon edge profiles.
Reference: [8] <author> R. Gupta, D. Berson, and J.Z. Fang, </author> <title> "Path Profile Guided Partial Dead Code Elimination using Predication," </title> <booktitle> International Conference on Parallel Architectures and Compilation Techniques, </booktitle> <pages> pages 102-115, </pages> <address> San Francisco, Ca, </address> <month> November </month> <year> 1997. </year>
Reference-contexts: In conclusion, the approach we have presented is quite general and can be adapted for application to other optimizations. For example predicated execution can be used to enable code sinking past merge points resulting in the removal of dead code along frequently executed paths <ref> [8] </ref>. We have also developed analysis techniques in which redundancy and dead code removal decisions are influenced by functional unit resource availabil-ity [9]. Other applications of our approach include strength reduction along certain paths and elimina tion of partially redundant loads and dead stores [2].
Reference: [9] <author> R. Gupta, D. Berson, and J.Z. Fang, </author> <title> "Resource-Sensitive Profile-Directed Data Flow Analysis for Code Optimization," </title> <booktitle> The 30th Annual IEEE/ACM International Symposium on Microarchitecture, </booktitle> <pages> pages 558-568, </pages> <address> Research Triangle Park, NC, </address> <month> December </month> <year> 1997. </year>
Reference-contexts: For example predicated execution can be used to enable code sinking past merge points resulting in the removal of dead code along frequently executed paths [8]. We have also developed analysis techniques in which redundancy and dead code removal decisions are influenced by functional unit resource availabil-ity <ref> [9] </ref>. Other applications of our approach include strength reduction along certain paths and elimina tion of partially redundant loads and dead stores [2].
Reference: [10] <author> R.N. Horspool and H.C. Ho, </author> <title> "Partial Redundancy Elimination Driven by a Cost-Benefit Analysis," </title> <booktitle> 8th Israeli Conf. on Computer Systems and Software Engineering, </booktitle> <pages> pages 111-118, </pages> <address> Herzliya, Israel, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: However, the algorithms in [7] apply to a single-entry-single-exit acyclic region and no cost-benefit analysis to guide speculation is presented. Independently of our work Horspool and Ho <ref> [10] </ref> have recently proposed a profile driven PRE algorithm based upon edge profiles. However, our algorithm is superior to theirs because it is more powerful, flexible and efficient.
Reference: [11] <author> J. Knoop, O. Ruthing, and B. Steffen, </author> <title> "Lazy Code Motion," </title> <booktitle> Proc. of Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 224-234, </pages> <year> 1992. </year>
Reference-contexts: S n2SPEC exp (p) COSTPATHS exp (n) FREQ (p 0 ) BENEFIT exp (p) = FREQ (p) also allows the optimizer to focus on more important expressions while ignoring others and provide new opportunities for code reshaping. 3 Speculative Hoisting Framework A number of solutions to PRE have been proposed <ref> [7, 13, 11] </ref>. In this section we present an integration of speculation with the expression hoisting framework proposed by Steffen [13] to perform PRE. The modifications to Steffen's framework that are necessary to incorporate speculation are described in this section. <p> For the example in Figure 5c, according to the above rules speculation at nodes 5, 6 and 10 is enabled. 3.2 Expression Hoisting The original analysis in <ref> [11] </ref> consists of a backward data flow analysis phase followed by a forward data flow analysis phase. Backward data flow is used to identify all down-safe points, that is, points to which expression evaluations can be safely hoisted.
Reference: [12] <author> S.A. Mahlke, et al. </author> <title> "Sentinel Scheduling for VLIW and Superscalar Processors," </title> <booktitle> Proc. of the 5th International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <year> 1992. </year>
Reference-contexts: This is because if this instruction is introduced along a path where it was not executed in the original program, then an exception may be incorrectly reported for an execution that follows that path. However, modern architectures provide solution to this problem <ref> [12] </ref>. Exceptions are suppressed initially if they occur during the execution of a speculated instruction. However, if later execution reaches the point at which the instruction originally resided, the exception is reported. The task of reporting is carried out by special instructions called sentinels [12]. <p> architectures provide solution to this problem <ref> [12] </ref>. Exceptions are suppressed initially if they occur during the execution of a speculated instruction. However, if later execution reaches the point at which the instruction originally resided, the exception is reported. The task of reporting is carried out by special instructions called sentinels [12]. For architectures that do not provide such advanced features, our algorithm should only be applied to non-exception causing instructions. We present a general approach which reduces redundant expression evaluations along more frequently executed paths at the expense of introducing additional expression evaluations along less frequently executed paths.
Reference: [13] <author> B. Steffen, </author> <title> "Data Flow Analysis as Model Checking," </title> <booktitle> Proceedings TACS'91, Sendai, </booktitle> <address> Japan, </address> <publisher> Springer-Verlag, LNCS 526, </publisher> <pages> pages 346-364, </pages> <year> 1991. </year>
Reference-contexts: S n2SPEC exp (p) COSTPATHS exp (n) FREQ (p 0 ) BENEFIT exp (p) = FREQ (p) also allows the optimizer to focus on more important expressions while ignoring others and provide new opportunities for code reshaping. 3 Speculative Hoisting Framework A number of solutions to PRE have been proposed <ref> [7, 13, 11] </ref>. In this section we present an integration of speculation with the expression hoisting framework proposed by Steffen [13] to perform PRE. The modifications to Steffen's framework that are necessary to incorporate speculation are described in this section. <p> In this section we present an integration of speculation with the expression hoisting framework proposed by Steffen <ref> [13] </ref> to perform PRE. The modifications to Steffen's framework that are necessary to incorporate speculation are described in this section.
References-found: 13

