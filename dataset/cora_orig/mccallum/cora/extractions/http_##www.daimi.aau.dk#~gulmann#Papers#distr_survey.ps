URL: http://www.daimi.aau.dk/~gulmann/Papers/distr_survey.ps
Refering-URL: http://www.daimi.aau.dk/~gulmann/papers.html
Root-URL: http://www.daimi.aau.dk
Email: Email: pst@smi.ernet.in  Email: gulmann@brics.dk  
Phone: 2  
Title: Distributed Versions of Linear Time Temporal Logic: A Trace Perspective  
Author: P. S. Thiagarajan ? and Jesper G. Henriksen 
Address: 92 G.N. Chetty Road, T. Nagar, Chennai 600 017, India  Aarhus, Ny Munkegade, 8000 Aarhus C, Denmark  
Affiliation: 1 SPIC Mathematical Institute,  BRICS Department of Computer Science, University of  
Abstract-found: 0
Intro-found: 1
Reference: 1. <author> Alur, R., Peled, D., Penczek, W.: </author> <title> Model checking of causality properties. </title> <booktitle> Proceedings of the 10th Annual IEEE Symposium on Logic in Computer Science, </booktitle> <publisher> IEEE Computer Society Press (1995) 90-100 </publisher>
Reference-contexts: Niebert has considered several -calculus versions of TrPTL [31, 32] and has obtained various decidability results using a variant of asynchronous Buchi automata. The temporal logic of causality (TLC) proposed by Alur, Peled and Penczek is basically a temporal logic over traces <ref> [1] </ref>. The concurrent structures used in [1] as frames for TLC can be easily represented as traces over an appropriately chosen trace alphabet. The interesting feature of TLC is that its branching time modalities are interpreted over causal paths. <p> Niebert has considered several -calculus versions of TrPTL [31, 32] and has obtained various decidability results using a variant of asynchronous Buchi automata. The temporal logic of causality (TLC) proposed by Alur, Peled and Penczek is basically a temporal logic over traces <ref> [1] </ref>. The concurrent structures used in [1] as frames for TLC can be easily represented as traces over an appropriately chosen trace alphabet. The interesting feature of TLC is that its branching time modalities are interpreted over causal paths.
Reference: 2. <institution> Bell Labs Design Automation: </institution> <note> FormalCheck tm . Further information can be obtained at http://www.bell-labs.com/formalcheck/ </note>
Reference: 3. <author> Bracho, F., Droste, M., Kuske, D.: </author> <title> Representation of computations in concurrent automata by dependence orders. </title> <note> Theoretical Computer Science 174(1-2) (1997) 67-96 </note>
Reference: 4. <author> Buchi, J. R.: </author> <title> On a decision method in restricted second order arithmetic. </title> <booktitle> Proceedings of the International Congress on Logic, Methodology and Philosophy of Science, </booktitle> <publisher> Stanford University Press (1960) 1-11 </publisher>
Reference-contexts: Each sentence OE defines an !-language, denoted L OE , where: L OE = foe j oe j= OEg: We say that L ! is MSO ()-definable iff there exists a sentence OE 2 MSO () such that L = L OE . A celebrated result of Buchi <ref> [4] </ref> shows that the class of languages expressible by sentences in MSO () coincides with the class of languages recognized by Buchi automata over . This class is the !-regular languages over .
Reference: 5. <author> Cheng, A.: </author> <title> Petri nets, traces, and local model checking. </title> <booktitle> Proceedings of the 4th International Conference on Algebraic Methodology and Software Technology, Lecture Notes in Computer Science 936, </booktitle> <month> Springer-Verlag </month> <year> (1995) </year> <month> 322-337 </month>
Reference-contexts: At present not much is known about corresponding logics in a branching time setting. Most of the attempts in this direction have lead to logics whose satisfiablity problems are undecidable <ref> [5, 25, 36] </ref>. It is however the case that the model checking problem often remains tractable [5, 36]. <p> At present not much is known about corresponding logics in a branching time setting. Most of the attempts in this direction have lead to logics whose satisfiablity problems are undecidable [5, 25, 36]. It is however the case that the model checking problem often remains tractable <ref> [5, 36] </ref>. We do not know at present whether the properties expressible in such logics have any type of "all-or-none" flavour and if so whether one can develop some reduction techniques for verifying such properties. Some preliminary attempts in this direction have been made in [16, 54].
Reference: 6. <author> Diekert, V.: </author> <title> Combinatorics of traces. </title> <booktitle> Lecture Notes in Computer Science 454, </booktitle> <publisher> Springer-Verlag (1990) </publisher>
Reference-contexts: The equivalence classes generated by I are called (Mazurkiewicz) traces. A set of traces is called a trace language. The theory of traces is well developed and documented|see <ref> [6, 7] </ref> for basic material as well as a substantial number of references to related work. A variety of models of distributed systems naturally have a trace alphabet associated with them [55].
Reference: 7. <editor> Diekert, V., Rozenberg, G. (eds.): </editor> <booktitle> The book of traces. World Scientific (1995) </booktitle>
Reference-contexts: The equivalence classes generated by I are called (Mazurkiewicz) traces. A set of traces is called a trace language. The theory of traces is well developed and documented|see <ref> [6, 7] </ref> for basic material as well as a substantial number of references to related work. A variety of models of distributed systems naturally have a trace alphabet associated with them [55]. <p> FO (; I), the first-order theory of traces, is defined in the obvious way. Clearly it will be strictly weaker than MSO (; I). For more information the reader is referred to <ref> [7] </ref>. Naturally both these theories can be made to handle finite traces as well. Through the rest of this section we fix a distributed alphabet e and let (; I) be the induced trace alphabet.
Reference: 8. <author> Droste, M.: </author> <title> Recognizable languages in concurrency monoids. </title> <note> Theoretical Computer Science 150(1) (1995) 77-109 </note>
Reference: 9. <author> Droste, M., Gastin, P.: </author> <title> Asynchronous cellular automata for pomsets without auto-concurrency. </title> <booktitle> Proceedings of the 7th International Conference on Concurrency Theory, Lecture Notes in Computer Science 1119, </booktitle> <month> Springer-Verlag </month> <year> (1996) </year> <month> 627-638 </month>
Reference: 10. <author> Ebinger, W.: </author> <title> Charakterisierung von sprachklassen unendlicher spuren durch logiken. </title> <type> Dissertation, </type> <institution> Institut fur Informatik, Universitat Stuttgart (1994) </institution>
Reference-contexts: A similar result for infinite traces is not known at present. Unfortunately this logic does not have a matching time complexity in relation to LTL. Recently Walukiewicz has shown that the satisfiability problem for LTrL is non-elementary hard [53]. A related result concerns the logic TLPO formulated by Ebinger <ref> [10] </ref>. This is also a linear time temporal logic interpreted over traces but with full-fledged past-operators. TLPO is claimed to be expressively complete when interpreted over finite traces but nothing is known about the complexity of the satisfiability problem nor about its expressive power in relation to infinite traces.
Reference: 11. <author> Ebinger, W., Muscholl, A.: </author> <title> Logical definability on infinite traces. </title> <note> Theoretical Com--puter Science 154(1) (1996) 67-84 </note>
Reference-contexts: It is known that MSO-definable languages are precisely the regular trace languages; i.e. those recognized by asynchronous automata <ref> [11] </ref>. FO (; I), the first-order theory of traces, is defined in the obvious way. Clearly it will be strictly weaker than MSO (; I). For more information the reader is referred to [7]. Naturally both these theories can be made to handle finite traces as well. <p> It would be nice to have a linear time temporal logic over traces patterned after LTL which has the same expressive power as the first-order theory of traces. The motivation is provided by the next result <ref> [11] </ref>: Proposition 22. Let L ! . Then the following statements are equivalent. 1. L is trace consistent and LTL ()-definable. 2. fstr (oe) j oe 2 Lg is FO (; I)-definable.
Reference: 12. <author> Emerson, A. E.: </author> <title> Temporal and modal logic. In Handbook of Theoretical Computer Science, volume B: Formal Models and Semantics, </title> <publisher> Elsevier Science Publishers (1990) 996-1072 </publisher>
Reference: 13. <author> Fischer, M. J., Ladner, R. E.: </author> <title> Propositional dynamic logic of regular programs. </title> <note> Journal of Computer and System Sciences 18(2) (1979) 194-211 </note>
Reference-contexts: We associate with a formula ff of DLTL () the !-language L ff in the obvious manner. A useful derived operator of DLTL is: hiff By replacing the until-modality of DLTL with the above derived operator we obtain the sublogic DLTL (), which is essentially Propositional Dynamic Logic <ref> [13] </ref> equipped with a linear time semantics. It turns out that DLTL () and DLTL () both have the same expressive power as MSO (). Theorem 21. Let L ! . Then the following statements are equivalent. 1. L is !-regular (i.e. definable in MSO ()). 2.
Reference: 14. <author> Gabbay, A., Pnueli, A., Shelah, S., Stavi, J.: </author> <title> On the temporal analysis of fairness. </title> <booktitle> Proceedings of the 7th Annual Symposium on Principles of Programming Languages, ACM (1980) 163-173 </booktitle>
Reference-contexts: The semantics and notions of first-order definability are carried over in the obvious manner. A fundamental result in the theory of temporal logic is Kamp's Theorem [23] which was later strengthened in <ref> [14] </ref> to establish that LTL () is expressively equivalent to the FO (). The surprise here being that LTL () admits only a bounded number of operators (one unary and one binary as we have formulated it) whereas infinitely many operators of increasing arities can be defined in FO ().
Reference: 15. <author> Gastin, P., Petit, A.: </author> <title> Asynchronous cellular automata for infinite traces. </title> <booktitle> Proceedings of the 19th International Colloquium on Automata, Languages and Programming. Lecture Notes in Computer Science 623, </booktitle> <month> Springer-Verlag </month> <year> (1992) </year> <month> 583-594 </month>
Reference-contexts: It can be viewed as an "implementation" of a trace alphabet. As a result, distributed alphabets play a fundamental role in the automata-theoretic aspects of trace /.-,()*+ /.-,()*+ e 1 ** ** ** @A BC oo ** GF Fig. 1. Example elementary net system languages <ref> [15, 58] </ref>. This will become more clear when the material in Section 6 is encountered. <p> Hence in order to recognize regular trace languages one will have to use strengthened versions of product automata. Such automata called asynchronous automata were formulated by Zielonka for recognizing regular languages of finite traces. These were then generalized for handling infinite traces by Gastin and Petit <ref> [15] </ref>. We will use a combination of these two types of automata for solving the satisfi-ability and model checking problems for the trace-based temporal logic called TrPTL to be considered in the next section. Let e be a distributed alphabet with P as the associated set of agents. <p> Further, one may assume A to be deterministic and one may assume e to be the distributed alphabet induced by the maximal D-cliques of (; I). This result has been generalized to the set of !-regular trace languages by Gastin and Petit <ref> [15] </ref> in terms of asynchronous automata with Buchi acceptance conditions. Since we will treat both finite and infinite traces on an equal footing we will present a class of automata capable of accepting both finite and infinite traces.
Reference: 16. <author> Gerth, R., Kuiper, R., Peled, D., Penczek, W.: </author> <title> A partial-order approach to branching time model checking. </title> <booktitle> Proceedings of the 3rd Israeli Symposium on Theory of Computing and Systems, </booktitle> <publisher> IEEE Computer Society Press (1995) 130-139 </publisher>
Reference-contexts: We do not know at present whether the properties expressible in such logics have any type of "all-or-none" flavour and if so whether one can develop some reduction techniques for verifying such properties. Some preliminary attempts in this direction have been made in <ref> [16, 54] </ref>.
Reference: 17. <author> Godefroid, P.: </author> <title> Partial-order methods for the verification of concurrent systems. </title> <booktitle> Lecture Notes in Computer Science 1032, </booktitle> <publisher> Springer-Verlag (1996) </publisher>
Reference-contexts: The key point is, the finite representation of L 0 can be often substantially smaller than the representation of P r. This is the insight underlying many of the so called partial-order methods deployed in the model checking world <ref> [17, 35, 50] </ref>. As pointed out in the introduction this is also the main motivation for considering the trace-based linear time temporal logics that we will encounter later. We shall conclude this section with some examples. Recall the material on elementary net systems introduced in Section 2.
Reference: 18. <author> Gerth, R., Peled, D., Vardi, M., Wolper, P.: </author> <title> Simple on-the-fly automatic verification of linear time temporal logic. </title> <booktitle> Proceedings of the 15th IFIP WG 6.1 International Workshop on Protocol Specification, Testing, and Verification, </booktitle> <publisher> North-Holland (1995) </publisher>
Reference: 19. <author> Henriksen, J. G., Thiagarajan, P. S.: </author> <title> Dynamic linear time temporal logic. </title> <journal> Journal of Pure and Applied Logic, </journal> <note> Elsevier (to appear) </note>
Reference-contexts: The expressive power of LTL can be extended to obtain the expressive power of MSO while still guaranteeing an exponential time decidable satisfiability problem as demonstrated first in [57]. Here we sketch how the regular programs over can be used to achieve this goal <ref> [19] </ref>. The syntax of regular programs over is given by: Prg () ::= a j 0 + 1 j 0 ; 1 j fl : With each program we associate a set of finite words via the map jj jj : Prg () ! 2 fl .
Reference: 20. <author> Henriksen, J. G., Thiagarajan, P. S.: </author> <title> A product version of dynamic linear time temporal logic. </title> <booktitle> Proceedings of the 8th International Conference on Concurrency Theory, Lecture Notes in Computer Science 1243, </booktitle> <month> Springer-Verlag </month> <year> (1997) </year> <month> 45-58 </month>
Reference-contexts: It is also easy to see that LTL -definable trace languages constitute a strict subclass of regular product trace languages. It has been shown that a product version of DLTL denoted DLTL captures exactly the class of regular product trace languages <ref> [20] </ref>. We also claim that it is an easy exercise to formulate a product version of MSO ( e ) and show that it captures exactly the regular product trace languages.
Reference: 21. <author> Holzmann, G. J.: </author> <title> An overview of the SPIN model checker. In "On-the-fly Model Checking Tutorial", BRICS Autumn School on Verification, Note NS-96-6, </title> <type> BRICS, </type> <institution> Department of Computer Science, University of Aarhus (1996) </institution>
Reference: 22. <author> Huhn, M.: </author> <title> On semantic and logical refinement of actions. </title> <type> Technical Report, </type> <institution> Institut fur Informatik, Universitat Hildesheim, </institution> <address> Germany (1996) </address>
Reference-contexts: If ff 2 con and loc (ff) = fig then O i ff 2 con . (Once again one needs to just demand that ff T floc (a) j a 2 i g.) Connected formulas were first identified by Niebert and used by Huhn <ref> [22] </ref>. They have also been independently identified by Ramanujam [38]. Thanks to the syntactic restrictions imposed on the next state and until formulas, past information is not allowed to creep in. Indeed one can prove the following: Proposition 19. Let ff 2 con .
Reference: 23. <author> Kamp, H. R.: </author> <title> Tense logic and the theory of linear order. </title> <type> Ph.D. thesis, </type> <institution> University of California (1968) </institution>
Reference-contexts: The semantics and notions of first-order definability are carried over in the obvious manner. A fundamental result in the theory of temporal logic is Kamp's Theorem <ref> [23] </ref> which was later strengthened in [14] to establish that LTL () is expressively equivalent to the FO ().
Reference: 24. <author> Katz, S., Peled, D.: </author> <title> Interleaving set temporal logic. </title> <note> Theoretical Computer Science 73(3) (1992) 21-43 </note>
Reference-contexts: Two of the four logics considered by Ramanujam [38] in a closely related setting turn out to be LTL and TrPTL con . We conjecture that the other two logics are also expressible within TrPTL. Katz and Peled introduced the logic ISTL <ref> [24] </ref> whose semantics has a trace-theoretic flavour. In a subsequent paper by Peled and Pnueli [34] on ISTL, the connection to traces was made more directly. Indeed this is one of the first instances of the explicit use of traces in a temporal logical setting that we know of.
Reference: 25. <author> Lodaya, K., Parikh, R., Ramanujam, R., Thiagarajan, P. S.: </author> <title> A logical study of distributed transition systems. </title> <note> Information and Computation 119(1) (1995) 91-118 </note>
Reference-contexts: It is interesting to note that all atomic assertions (that we know of) concerning distributed behaviours are local in nature. Indeed, it is well-known that global atomic propositions will at once lead to an undecidable logic in the current setting <ref> [25, 36] </ref>. Suppose M = (T; fV i g) is a model and c a ! T c 0 with j =2 loc (a). Then M; c j= p (j) iff M; c 0 j= p (j). In this sense the valuation functions are local. <p> At present not much is known about corresponding logics in a branching time setting. Most of the attempts in this direction have lead to logics whose satisfiablity problems are undecidable <ref> [5, 25, 36] </ref>. It is however the case that the model checking problem often remains tractable [5, 36].
Reference: 26. <author> Manna, Z., Pnueli, A.: </author> <title> The temporal logic of reactive and concurrent systems (specification), </title> <publisher> Springer-Verlag (1991) </publisher>
Reference: 27. <author> Mazurkiewicz, A.: </author> <title> Concurrent program schemes and their interpretations. </title> <type> Technical report DAIMI PB-78, </type> <institution> Department of Computer Science, University of Aarhus, </institution> <address> Denmark (1977) </address>
Reference: 28. <author> Meyer, R., Petit, A.: </author> <title> Expressive completeness of LTrL on finite traces: an algebraic proof. </title> <booktitle> Proceedings of the 15th Annual Symposium on Theoretical Aspects of Computer Science 1373, Lecture Notes in Computer Science, </booktitle> <month> Springer-Verlag </month> <year> (1998) </year> <month> 533-543 </month>
Reference-contexts: Thus | except for the addition of the restricted past-operators | LTrL is a generalization of Kamp's Theorem to the much richer setting of traces. Meyer and Petit have shown that the past-operators can be eliminated without loss of expressive power when the logic is interpreted over finite traces <ref> [28] </ref>. A similar result for infinite traces is not known at present. Unfortunately this logic does not have a matching time complexity in relation to LTL. Recently Walukiewicz has shown that the satisfiability problem for LTrL is non-elementary hard [53].
Reference: 29. <author> Mukund, M., Sohoni, M.: </author> <title> Keeping track of the latest gossip in a distributed system. </title> <booktitle> Distributed Computing 10(3) (1997) 117-127 </booktitle>
Reference-contexts: However in the much richer setting of traces it turns out that one must make crucial use of the latest information that the agents have about each other when defining the transitions of A ff 0 . It has been shown by Mukund and Sohoni <ref> [29] </ref> that this information can be kept track of by a deterministic asynchronous automaton whose size depends only on e . (Actually the automaton described in [29] operates over finite traces but it is a trivial task to convert it into an asynchronous automaton having the desired properties). <p> It has been shown by Mukund and Sohoni <ref> [29] </ref> that this information can be kept track of by a deterministic asynchronous automaton whose size depends only on e . (Actually the automaton described in [29] operates over finite traces but it is a trivial task to convert it into an asynchronous automaton having the desired properties). To bring out the relevant properties of this automaton, let T 2 T R ! with T = (E; ; ).
Reference: 30. <author> Mukund, M., Thiagarajan, P. S.: </author> <title> Linear time temporal logics over Mazurkiewicz traces. </title> <booktitle> Proceedings of the 21st International Symposium on Mathematical Foundations of Computer Science, Lecture Notes in Computer Science 1113, </booktitle> <month> Springer-Verlag </month> <year> (1996) </year> <month> 62-92 </month>
Reference: 31. <author> Niebert, P.: </author> <title> A -calculus with local views for systems of sequential agents. </title> <booktitle> Proceedings of the 20th International Symposium on Mathematical Foundations of Computer Science, Lecture Notes in Computer Science 969, </booktitle> <month> Springer-Verlag </month> <year> (1995) </year> <month> 563-573 </month>
Reference-contexts: We feel that local atomic propositions (as used in TrPTL) are crucial for obtaining tractable partial order based temporal logics. Niebert has considered several -calculus versions of TrPTL <ref> [31, 32] </ref> and has obtained various decidability results using a variant of asynchronous Buchi automata. The temporal logic of causality (TLC) proposed by Alur, Peled and Penczek is basically a temporal logic over traces [1].
Reference: 32. <author> Niebert, P.: </author> <title> A temporal logic for the specification and validation of distributed behaviour. </title> <type> Ph.D. thesis, </type> <institution> University of Hildesheim (1997) </institution>
Reference-contexts: We feel that local atomic propositions (as used in TrPTL) are crucial for obtaining tractable partial order based temporal logics. Niebert has considered several -calculus versions of TrPTL <ref> [31, 32] </ref> and has obtained various decidability results using a variant of asynchronous Buchi automata. The temporal logic of causality (TLC) proposed by Alur, Peled and Penczek is basically a temporal logic over traces [1]. <p> At present we do not know much about the relationship between TLC and the logics we have mentioned so far, except that it is strictly weaker than the monadic second-order theory of traces. In an interesting recent development Niebert <ref> [32] </ref> has formulated a fixed point based linear time temporal logic for traces in the setting of distributed alphabets. This logic is denoted as TrPTL. It is equal in expressive power to the monadic second-order theory of traces and it has decision procedure of essentially exponential time complexity.
Reference: 33. <author> Nielsen, M., Plotkin, G., Winskel, G.: </author> <title> Petri nets, event structures and domains, part I. </title> <note> Theoretical Computer Science 13(1) (1981) 85-108 </note>
Reference: 34. <author> Peled, D., Pnueli, A.: </author> <title> Proving partial order properties. </title> <note> Theoretical Computer Science 126(2) (1994) 143-182 </note>
Reference-contexts: We conjecture that the other two logics are also expressible within TrPTL. Katz and Peled introduced the logic ISTL [24] whose semantics has a trace-theoretic flavour. In a subsequent paper by Peled and Pnueli <ref> [34] </ref> on ISTL, the connection to traces was made more directly. Indeed this is one of the first instances of the explicit use of traces in a temporal logical setting that we know of. <p> We have mainly concentrated on the satisfiability and model checking problems as well as expressiveness issues. The problem of axiomatizing these logics seems to be a non-trivial task. Some partial results may be found in [39]. In <ref> [34] </ref> the authors present proof rules for the logic ISTL with a trace semantics together with a relative expressive completeness result. Reisig has also developed a kit of proof rules for a version of UNITY logic [40, 41].
Reference: 35. <author> Peled, D.: </author> <title> Partial order reduction: model checking using representatives. </title> <booktitle> Proceedings of the 21st International Symposium on Mathematical Foundations of Computer Science, Lecture Notes in Computer Science 1113, </booktitle> <month> Springer-Verlag </month> <year> (1996) </year> <month> 93-112 </month>
Reference-contexts: The key point is, the finite representation of L 0 can be often substantially smaller than the representation of P r. This is the insight underlying many of the so called partial-order methods deployed in the model checking world <ref> [17, 35, 50] </ref>. As pointed out in the introduction this is also the main motivation for considering the trace-based linear time temporal logics that we will encounter later. We shall conclude this section with some examples. Recall the material on elementary net systems introduced in Section 2.
Reference: 36. <author> Penczek, W.: </author> <title> Temporal logics for trace systems: on automated verification. </title> <booktitle> International Journal of the Foundations of Computer Science 4(1) (1993) 31-68 </booktitle>
Reference-contexts: It is interesting to note that all atomic assertions (that we know of) concerning distributed behaviours are local in nature. Indeed, it is well-known that global atomic propositions will at once lead to an undecidable logic in the current setting <ref> [25, 36] </ref>. Suppose M = (T; fV i g) is a model and c a ! T c 0 with j =2 loc (a). Then M; c j= p (j) iff M; c 0 j= p (j). In this sense the valuation functions are local. <p> However, it has branching time modalities which permit quantification over the so called observations of a trace. ISTL uses global atomic propositions rather than local atomic propositions. Penczek has also studied a number of temporal logics (including a version of ISTL) with branching time modalities and global atomic propositions <ref> [36] </ref>. His logics are interpreted directly over the space of configurations of a trace resulting in a variety of axiomatizations and undecidability results. We feel that local atomic propositions (as used in TrPTL) are crucial for obtaining tractable partial order based temporal logics. <p> At present not much is known about corresponding logics in a branching time setting. Most of the attempts in this direction have lead to logics whose satisfiablity problems are undecidable <ref> [5, 25, 36] </ref>. It is however the case that the model checking problem often remains tractable [5, 36]. <p> At present not much is known about corresponding logics in a branching time setting. Most of the attempts in this direction have lead to logics whose satisfiablity problems are undecidable [5, 25, 36]. It is however the case that the model checking problem often remains tractable <ref> [5, 36] </ref>. We do not know at present whether the properties expressible in such logics have any type of "all-or-none" flavour and if so whether one can develop some reduction techniques for verifying such properties. Some preliminary attempts in this direction have been made in [16, 54].
Reference: 37. <author> Pnueli, A.: </author> <title> The temporal logic of programs. </title> <booktitle> Proceedings of the 18th Annual Symposium on Foundations of Computer Science, </booktitle> <publisher> IEEE Computer Society Press (1977) 46-57 </publisher>
Reference: 38. <author> Ramanujam, R.: </author> <title> Locally linear time temporal logic. </title> <booktitle> Proceedings of the 11th Annual IEEE Symposium on Logic in Computer Science, </booktitle> <publisher> IEEE Computer Society Press (1996) 118-127 </publisher>
Reference-contexts: They have also been independently identified by Ramanujam <ref> [38] </ref>. Thanks to the syntactic restrictions imposed on the next state and until formulas, past information is not allowed to creep in. Indeed one can prove the following: Proposition 19. Let ff 2 con . Then ff is satisfiable iff ff is root-satisfiable. <p> We shall deal with the relative strengths of these logics in the next section. Two of the four logics considered by Ramanujam <ref> [38] </ref> in a closely related setting turn out to be LTL and TrPTL con . We conjecture that the other two logics are also expressible within TrPTL. Katz and Peled introduced the logic ISTL [24] whose semantics has a trace-theoretic flavour.
Reference: 39. <author> Ramanujam, R.: </author> <title> Rules for trace consistent reasoning. </title> <booktitle> Proceedings of the 3rd Asian Computing Science Conference, Lecture Notes in Computer Science 1345, </booktitle> <month> Springer-Verlag </month> <year> (1997) </year> <month> 57-71 </month>
Reference-contexts: We have mainly concentrated on the satisfiability and model checking problems as well as expressiveness issues. The problem of axiomatizing these logics seems to be a non-trivial task. Some partial results may be found in <ref> [39] </ref>. In [34] the authors present proof rules for the logic ISTL with a trace semantics together with a relative expressive completeness result. Reisig has also developed a kit of proof rules for a version of UNITY logic [40, 41].
Reference: 40. <author> Reisig, W.: </author> <title> Temporal logic and causality in concurrent systems. </title> <booktitle> Proceedings of CONCURRENCY'88, Lecture Notes in Computer Science 335, </booktitle> <month> Springer-Verlag </month> <year> (1988) </year> <month> 121-139 </month>
Reference-contexts: Some partial results may be found in [39]. In [34] the authors present proof rules for the logic ISTL with a trace semantics together with a relative expressive completeness result. Reisig has also developed a kit of proof rules for a version of UNITY logic <ref> [40, 41] </ref>. The models of this logic are the non-sequential processes of a net system and the proof rules are mainly designed to help reason about distributed algorithms modelled using net systems. At present not much is known about corresponding logics in a branching time setting.
Reference: 41. <author> Reisig, W.: </author> <title> Petri net models for distributed algorithms. </title> <booktitle> In Computer Science Today | Recent Trends and Developments, Lecture Notes in Computer Science 1000, </booktitle> <month> Springer-Verlag </month> <year> (1995) </year> <month> 441-454 </month>
Reference-contexts: Some partial results may be found in [39]. In [34] the authors present proof rules for the logic ISTL with a trace semantics together with a relative expressive completeness result. Reisig has also developed a kit of proof rules for a version of UNITY logic <ref> [40, 41] </ref>. The models of this logic are the non-sequential processes of a net system and the proof rules are mainly designed to help reason about distributed algorithms modelled using net systems. At present not much is known about corresponding logics in a branching time setting.
Reference: 42. <author> Sistla, A. P., Clarke, E.: </author> <title> The complexity of propositional linear temporal logics. </title> <note> Journal of the ACM 32(3) (1985) 733-749 </note>
Reference: 43. <author> Stockmeyer, L. J.: </author> <title> The complexity of decision problems in automata theory and logic. </title> <type> Ph.D. thesis, </type> <institution> MIT, </institution> <address> Cambridge, Massachusetts (1974) </address>
Reference-contexts: Secondly, as we saw in Section 2, the satisfiability problem for LTL () can be solved in deterministic exponential time. The satisfiability problem for FO () on the other hand, even when the sentences are interpreted over finite words, is known to be non-elementary hard <ref> [43] </ref>.
Reference: 44. <author> Thiagarajan, P. S.: </author> <title> A trace based extension of linear time temporal logic. </title> <booktitle> Proceedings of the 9th Annual IEEE Symposium on Logic in Computer Science, </booktitle> <publisher> IEEE Computer Society Press (1994) 438-447 </publisher>
Reference-contexts: This is the first such logic patterned after PTL (i.e. LTL) formulated for traces. For a detailed treatment of this logic the reader is referred to <ref> [44, 45] </ref>. As before, it will be notationally convenient to deal with distributed al-phabets in which the names of the processes are positive integers. <p> There is of course a blow-up involved in converting satisfiable formulas to root-satisfiable formulas. If one wants to avoid this blow-up then the decision procedure for checking root-satisfiability can be suitably modified to yield a direct decision procedure for checking satisfiability as done in <ref> [44] </ref>. In any case, it is root satisfiability which is of importance from the standpoint of model checking. Hence here we shall only develop a procedure for deciding if a given formula of TrPTL is root-satisfiable. <p> This construction is an optimized version of the original construction for TrPTL presented in <ref> [44, 45] </ref>. Note that A ff 0 is indeed in standard form. Argu ments similar to those presented in [44, 45] lead to the next set of results. Theorem 18. 1. ff 0 is root-satisfiable iff L T r (A ff 0 ) 6= ;. 2. <p> This construction is an optimized version of the original construction for TrPTL presented in <ref> [44, 45] </ref>. Note that A ff 0 is indeed in standard form. Argu ments similar to those presented in [44, 45] lead to the next set of results. Theorem 18. 1. ff 0 is root-satisfiable iff L T r (A ff 0 ) 6= ;. 2.
Reference: 45. <author> Thiagarajan, P. S.: TrPTL: </author> <title> a trace based extension of linear time temporal logic. </title> <type> Technical report TCS-93-6, </type> <institution> School of Mathematics, SPIC Science Foundation, </institution> <address> Madras (1993) </address>
Reference-contexts: This is the first such logic patterned after PTL (i.e. LTL) formulated for traces. For a detailed treatment of this logic the reader is referred to <ref> [44, 45] </ref>. As before, it will be notationally convenient to deal with distributed al-phabets in which the names of the processes are positive integers. <p> This construction is an optimized version of the original construction for TrPTL presented in <ref> [44, 45] </ref>. Note that A ff 0 is indeed in standard form. Argu ments similar to those presented in [44, 45] lead to the next set of results. Theorem 18. 1. ff 0 is root-satisfiable iff L T r (A ff 0 ) 6= ;. 2. <p> This construction is an optimized version of the original construction for TrPTL presented in <ref> [44, 45] </ref>. Note that A ff 0 is indeed in standard form. Argu ments similar to those presented in [44, 45] lead to the next set of results. Theorem 18. 1. ff 0 is root-satisfiable iff L T r (A ff 0 ) 6= ;. 2.
Reference: 46. <author> Thiagarajan, P. S.: </author> <title> A trace consistent subset of PTL. </title> <booktitle> Proceedings of the 6th International Conference on Concurrency Theory, Lecture Notes in Computer Science 962, </booktitle> <month> Springer-Verlag </month> <year> (1995) </year> <month> 438-452 </month>
Reference: 47. <author> Thiagarajan, P. S.: </author> <title> PTL over product state spaces. </title> <type> Technical report TCS-95-4, </type> <institution> School of Mathematics, SPIC Science Foundation, </institution> <address> Madras (1995) </address>
Reference-contexts: We then formulate in Section 5 the product version of LTL (). We will then use product Buchi automata to solve the satisfiability and model checking problems for the product version of LTL (). The technical details | which we suppress here | can be found in <ref> [47] </ref>. The key notion underlying product behaviours is that of a distributed alphabet. It can be viewed as an "implementation" of a trace alphabet. <p> Once again, we have chosen to avoid dealing with atomic propositions for the sake of convenience. They can be introduced in a local fashion as done in <ref> [47] </ref>. The decidability result to be presented will go through with minor notational overheads. As before, we will often suppress the mention of e . <p> The resulting trace languages will be called product trace languages. As might be expected, the regular product trace languages are the ones obtained from regular product languages via the map str. It is easy to show that not every (regular) trace language is a product trace language <ref> [47] </ref>. It is also easy to see that LTL -definable trace languages constitute a strict subclass of regular product trace languages. It has been shown that a product version of DLTL denoted DLTL captures exactly the class of regular product trace languages [20].
Reference: 48. <author> Thiagarajan, P. S., Walukiewicz, I.: </author> <title> An expressively complete linear time temporal logic for Mazurkiewicz traces. </title> <booktitle> Proceedings of the 12th Annual IEEE Symposium on Logic in Computer Science, </booktitle> <publisher> IEEE Computer Society Press (1997) 183-194 </publisher>
Reference-contexts: Let L ! . Then the following statements are equivalent. 1. L is trace consistent and LTL ()-definable. 2. fstr (oe) j oe 2 Lg is FO (; I)-definable. Egged on by this result, recently a different kind of trace-based linear time temporal logic called LTrL has been proposed <ref> [48] </ref>. This logic works directly with a trace alphabet (i.e. it is not based on agents).
Reference: 49. <author> Thomas, W.: </author> <title> Automata on infinite objects. In Handbook of Theoretical Computer Science, volume B: Formal Models and Semantics, </title> <publisher> Elsevier Science Publishers (1990) 133-191 </publisher>
Reference-contexts: For an excellent survey of regular languages and automata over infinite objects, the reader is referred to <ref> [49] </ref>. It is easy to solve the emptiness problem for Buchi automata; to determine whether or not the language accepted by a Buchi automaton is empty. <p> This can be done in time linear in the size of the automaton where the size of a Buchi automaton is the number of states of the automaton <ref> [49] </ref>. We will now show how one can effectively construct for each ff 2 LTL (), a Buchi automaton B ff such that the language of !-words accepted by B ff is non-empty iff ff is satisfiable. <p> Moreover, the size of B can be assumed to be bounded by 2n 1 n 2 where n 1 is the size of B 1 and n 2 is the size of B 2 <ref> [49] </ref>. Now let P r = (S; !; S in ; V P r ) be a program.
Reference: 50. <author> Valmari, A.: </author> <title> A stubborn attack on state explosion. </title> <booktitle> Formal Methods in Systems Design 1 (1992) 285-313 </booktitle>
Reference-contexts: The key point is, the finite representation of L 0 can be often substantially smaller than the representation of P r. This is the insight underlying many of the so called partial-order methods deployed in the model checking world <ref> [17, 35, 50] </ref>. As pointed out in the introduction this is also the main motivation for considering the trace-based linear time temporal logics that we will encounter later. We shall conclude this section with some examples. Recall the material on elementary net systems introduced in Section 2.
Reference: 51. <author> Vardi, M. Y., Wolper, P.: </author> <title> An automata-theoretic approach to automatic program verification. </title> <booktitle> Proceedings of the 1st Annual IEEE Symposium on Logic in Computer Science, </booktitle> <publisher> IEEE Computer Society Press (1986) 332-345 </publisher>
Reference-contexts: We will now show how one can effectively construct for each ff 2 LTL (), a Buchi automaton B ff such that the language of !-words accepted by B ff is non-empty iff ff is satisfiable. This is an action-based version of the elegant solution presented in <ref> [51] </ref> for LTL. Through the rest of the section we fix a formula ff 0 . To construct B ff 0 we first define the (Fischer-Ladner) closure of ff 0 .
Reference: 52. <author> Vardi, M. Y.: </author> <title> An automata-theoretic approach to linear time temporal logic. In Logics for Concurrency Structure vs. Automata, </title> <booktitle> Lecture Notes in Computer Science 1043, </booktitle> <month> Springer-Verlag </month> <year> (1996) </year> <month> 238-266 </month>
Reference: 53. <author> Walukiewicz, I.: </author> <title> Difficult configurations | on the complexity of LTrL (extended abstract). </title> <booktitle> Proceedings of the 25th International Colloquium on Automata, Languages and Programming. Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag (to appear) </publisher>
Reference-contexts: A similar result for infinite traces is not known at present. Unfortunately this logic does not have a matching time complexity in relation to LTL. Recently Walukiewicz has shown that the satisfiability problem for LTrL is non-elementary hard <ref> [53] </ref>. A related result concerns the logic TLPO formulated by Ebinger [10]. This is also a linear time temporal logic interpreted over traces but with full-fledged past-operators.
Reference: 54. <author> Willems, B., Wolper, P.: </author> <title> Partial-order methods for model checking: from linear time to branching time. </title> <booktitle> Proceedings of the 11th Annual IEEE Symposium on Logic in Computer Science, </booktitle> <publisher> IEEE Computer Society Press (1996) 294-303 </publisher>
Reference-contexts: We do not know at present whether the properties expressible in such logics have any type of "all-or-none" flavour and if so whether one can develop some reduction techniques for verifying such properties. Some preliminary attempts in this direction have been made in <ref> [16, 54] </ref>.
Reference: 55. <author> Winskel, G., Nielsen, M.: </author> <title> Models for concurrency. </title> <booktitle> In Handbook of Logic and the Foundations of Computer Science, </booktitle> <volume> volume 4, </volume> <publisher> Oxford University Press (1995) 1-148 </publisher>
Reference-contexts: A set of traces is called a trace language. The theory of traces is well developed and documented|see [6, 7] for basic material as well as a substantial number of references to related work. A variety of models of distributed systems naturally have a trace alphabet associated with them <ref> [55] </ref>. It also turns out that many interesting properties of distributed systems respect the equivalence relation induced by these trace alphabets. This has important consequences for the practical verification of such properties. The key notion in this context is that of a trace consistent property. <p> We shall not prove these results. The details can be easily obtained using the constructions developed in <ref> [55] </ref> for relating traces and event structures. Henceforth, we will not distinguish between isomorphic elements in T R (; I).
Reference: 56. <author> Wolper, P.: </author> <title> Temporal logic can be more expressive. </title> <booktitle> Proceedings of the 22nd Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <publisher> IEEE Computer Society Press (1981) 340-348 </publisher>
Reference-contexts: than MSO () in the sense that there is a language which is MSO ()-definable but not FO ()- definable. (Indeed this is the sense in which we shall compare the expressive power of various logics in what follows.) For instance, as pointed out by Wolper in a state-based setting <ref> [56] </ref>, the language L fa; bg ! given by "a is executed at every even position" is not definable in this logic. On the other hand, it is easy to come up with a formula of MSO () defining L.
Reference: 57. <author> Wolper, P., Vardi, M. Y., Sistla, A. P.: </author> <title> Reasoning about infinite computation paths. </title> <booktitle> Proceedings of the 24th Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <publisher> IEEE Computer Society Press (1983) 185-194. </publisher>
Reference-contexts: On the other hand, it is easy to come up with a formula of MSO () defining L. The expressive power of LTL can be extended to obtain the expressive power of MSO while still guaranteeing an exponential time decidable satisfiability problem as demonstrated first in <ref> [57] </ref>. Here we sketch how the regular programs over can be used to achieve this goal [19].
Reference: 58. <author> Zielonka, W.: </author> <title> Notes on finite asynchronous automata. </title> <note> R.A.I.R.O. Informatique Theorique et Applications 21 (1987) 99-135 </note>
Reference-contexts: It can be viewed as an "implementation" of a trace alphabet. As a result, distributed alphabets play a fundamental role in the automata-theoretic aspects of trace /.-,()*+ /.-,()*+ e 1 ** ** ** @A BC oo ** GF Fig. 1. Example elementary net system languages <ref> [15, 58] </ref>. This will become more clear when the material in Section 6 is encountered.
References-found: 58

