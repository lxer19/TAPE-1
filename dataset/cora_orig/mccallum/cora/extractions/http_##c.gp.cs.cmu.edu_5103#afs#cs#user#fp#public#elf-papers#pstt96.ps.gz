URL: http://c.gp.cs.cmu.edu:5103/afs/cs/user/fp/public/elf-papers/pstt96.ps.gz
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs/user/fp/public/elf-papers/INDEX.html
Root-URL: http://www.cs.cmu.edu
Email: filianojfpg@cs.cmu.edu  
Title: Linear Higher-Order Pre-Unification (Extended abstract)  
Author: Iliano Cervesato and Frank Pfenning 
Address: Pittsburgh, PA 15213-3891  
Affiliation: Department of Computer Science Carnegie Mellon University  
Abstract: We develop an efficient representation and a pre-unification algorithm in the style of Huet for the This extended abstract has been submitted to the CADE-13 Workshop on Proof Search in Type-Theoretic Languages Brunswick, NJ, July 30th 1996. linear -calculus !ffi&&gt; which includes intuitionistic functions (!), linear functions (ffi), additive pairing (&), and additive unit (&gt;). Potential applications lie in proof search, logic programming, and logical frameworks based on linear type theories. We also show that, surprisingly, a similar pre-unification algorithm does not exist for certain sublanguages.
Abstract-found: 1
Intro-found: 1
Reference: [Cer96] <author> Iliano Cervesato. </author> <title> A Linear Logical Framework. </title> <type> PhD thesis, </type> <institution> Dipartimento di Informatica, Universita di Torino, </institution> <month> February </month> <year> 1996. </year>
Reference-contexts: In particular, the instantiation of logic variables relies on the traditional unification algorithms, in their first- or higher-order variants, depending on the language. More recent proposals, such as the language of the linear logical framework LLF <ref> [Cer96, CP96] </ref> and the system in [IP96], introduce linearity not only at the level of formulas, but also within terms. An implementation of these languages should perform higher-order unification on linear terms in order to instantiate variables. <p> Indeed, the interactions of rules unit and lapp can flatten distinct proofs to the same !ffi&&gt; term. Similarly to ! , !ffi&&gt; enjoys a number of highly desirable properties <ref> [Cer96] </ref>. In particular, since every extension introduces commutative conversions, it is the largest linear -calculus for which strong normalization holds and yields unique normal forms. We write M for the canonical form of the term M , defined as the -expansion of its fi-normal form.
Reference: [CHP96] <author> Iliano Cervesato, Joshua S. Hodas, and Frank Pfenning. </author> <title> Efficient resource management for linear logic proof search. </title> <editor> In R. Dyckhoff, H. Herre, and P. Schroeder-Heister, editors, </editor> <booktitle> Proceedings of the 5th International Workshop on Extensions of Logic Programming, </booktitle> <pages> pages 67-81, </pages> <address> Leipzig, Germany, March 1996. </address> <publisher> Springer-Verlag LNAI 1050. </publisher> <pages> 9 </pages>
Reference-contexts: The only new aspect in the operational semantics of most proposals, such as Lolli [HM94], Lygon [HP94] and Forum [Mil94], concerns the management of linear context formulas <ref> [CHP96] </ref>. In particular, the instantiation of logic variables relies on the traditional unification algorithms, in their first- or higher-order variants, depending on the language. <p> As expected equations among intuitionistic operands are created with an empty linear context (pu iapp). Context splitting in rule pu iapp represents a new form of non-determinism not present in Huet's algorithm. Standard techniques of lazy context management <ref> [CHP96] </ref> can however be used in order to handle it efficiently and deterministically in an actual implementation. A new inherent form of non-determinism arises in the generation of the spine of substitution terms.
Reference: [CP96] <author> Iliano Cervesato and Frank Pfenning. </author> <title> A linear logical framework. </title> <editor> In E. Clarke, editor, </editor> <booktitle> Proceedings of the Eleventh Annual Symposium on Logic in Computer Science, </booktitle> <address> New Brunswick, New Jersey, </address> <month> July </month> <year> 1996. </year> <note> IEEE Computer Society Press. To appear. </note>
Reference-contexts: In particular, the instantiation of logic variables relies on the traditional unification algorithms, in their first- or higher-order variants, depending on the language. More recent proposals, such as the language of the linear logical framework LLF <ref> [Cer96, CP96] </ref> and the system in [IP96], introduce linearity not only at the level of formulas, but also within terms. An implementation of these languages should perform higher-order unification on linear terms in order to instantiate variables. <p> M : A ffi B lapp ; 0 ; 00 ` M ^N : B ilam ; ` x :A: M : A ! B iapp ; ` M N : B from the connectives !, ffi, & and &gt;, which constitutes the propositional core of Lolli [HM94] and LLF <ref> [CP96] </ref>. !ffi&&gt; is also the simply-typed variant of the term language of LLF . Its theoretical relevance derives from the fact that it is the biggest linear -calculus that admits unique long fi-normal forms. Our presentation is organized as follows.
Reference: [Dug93] <author> Dominic Duggan. </author> <title> Unification with extended patterns. </title> <type> Technical Report CS-93-37, </type> <institution> University of Waterloo, Waterloo, </institution> <address> Ontario, Canada, </address> <month> July </month> <year> 1993. </year> <month> Revised March </month> <year> 1994 </year> <month> and September </month> <year> 1994. </year>
Reference-contexts: In particular, !& coincides with the simply-typed -calculus with pairs while !&&gt; corresponds to its extension with a unit type and unit element. Unification in the restricted setting of higher-order patterns has been studied for these two languages in <ref> [Dug93] </ref> and [FL96], respectively. The appropriate restrictions of the rules in Figures 2-3 implement instead a general pre-unification procedure for these calculi. The languages !ffi& and !ffi are particularly interesting since the natural restriction of our pre-unification procedure is unsound for them.
Reference: [FL96] <author> Roland Fettig and Bernd Lochner. </author> <title> Unification of higher-order patterns in a simply typed lambda-calculus with finite products and terminal type. </title> <editor> In H. Ganzinger, editor, </editor> <booktitle> Proceedings of the Seventh International Conference on Rewriting Techniques and Applications, </booktitle> <address> New Brunswick, New Jersey, </address> <month> July </month> <year> 1996. </year> <note> To appear. </note>
Reference-contexts: In particular, !& coincides with the simply-typed -calculus with pairs while !&&gt; corresponds to its extension with a unit type and unit element. Unification in the restricted setting of higher-order patterns has been studied for these two languages in [Dug93] and <ref> [FL96] </ref>, respectively. The appropriate restrictions of the rules in Figures 2-3 implement instead a general pre-unification procedure for these calculi. The languages !ffi& and !ffi are particularly interesting since the natural restriction of our pre-unification procedure is unsound for them.
Reference: [Gir87] <author> Jean-Yves Girard. </author> <title> Linear logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 50 </volume> <pages> 1-102, </pages> <year> 1987. </year>
Reference-contexts: 1 Introduction Linear logic <ref> [Gir87] </ref> refines more traditional logical formalism with direct means of expressing common situations, especially those revolving around a notion of mutable state. Attempts at mechanizing this additional expressive power led to the design of several logic programming languages based on various fragments of linear logic. <p> The pre-unification algorithm is the subject of Section 3. We discuss the unification problem in sublanguages of !ffi&&gt; in Section 4. In order to facilitate our description in the available space, we must assume the reader familiar with traditional higher-order unification [Hue75] and linear logic <ref> [Gir87] </ref>. 2 A Linear Simply-Typed Lambda Calculus This section defines the simply-typed linear -calculus !ffi&&gt; (Subsection 2.1) and presents an equivalent formulation, S !ffi&&gt; (Subsection 2.2), that turns out convenient for describing and implementing unification. 2.1 Basic Formulation The linear simply-typed -calculus !ffi&&gt; extends Church's ! with the three type constructors
Reference: [HM94] <author> Joshua Hodas and Dale Miller. </author> <title> Logic programming in a fragment of intuitionistic linear logic. </title> <journal> Information and Computation, </journal> <volume> 110(2) </volume> <pages> 327-365, </pages> <year> 1994. </year> <booktitle> A preliminary version appeared in the Proceedings of the Sixth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 32-42, </pages> <address> Amsterdam, The Netherlands, </address> <month> July </month> <year> 1991. </year>
Reference-contexts: Attempts at mechanizing this additional expressive power led to the design of several logic programming languages based on various fragments of linear logic. The only new aspect in the operational semantics of most proposals, such as Lolli <ref> [HM94] </ref>, Lygon [HP94] and Forum [Mil94], concerns the management of linear context formulas [CHP96]. In particular, the instantiation of logic variables relies on the traditional unification algorithms, in their first- or higher-order variants, depending on the language. <p> ^ x: A: M : A ffi B lapp ; 0 ; 00 ` M ^N : B ilam ; ` x :A: M : A ! B iapp ; ` M N : B from the connectives !, ffi, & and &gt;, which constitutes the propositional core of Lolli <ref> [HM94] </ref> and LLF [CP96]. !ffi&&gt; is also the simply-typed variant of the term language of LLF . Its theoretical relevance derives from the fact that it is the biggest linear -calculus that admits unique long fi-normal forms. Our presentation is organized as follows. <p> The inference rules for this judgment are displayed in Figure 1. Deleting the terms that appear in them results in the usual rules for the (! ffi&&gt;) fragment of intuitionistic linear logic, ILL !ffi&&gt; <ref> [HM94] </ref>, in a natural deduction style formulation. !ffi&&gt; and ILL !ffi&&gt; are related by a weak form of the Curry-Howard isomorphism. Indeed, the interactions of rules unit and lapp can flatten distinct proofs to the same !ffi&&gt; term.
Reference: [HP94] <author> James Harland and David Pym. </author> <title> A uniform proof-theoretic investigation of linear logic programming. </title> <journal> Journal of Logic and Computation, </journal> <volume> 4(2) </volume> <pages> 175-207, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: Attempts at mechanizing this additional expressive power led to the design of several logic programming languages based on various fragments of linear logic. The only new aspect in the operational semantics of most proposals, such as Lolli [HM94], Lygon <ref> [HP94] </ref> and Forum [Mil94], concerns the management of linear context formulas [CHP96]. In particular, the instantiation of logic variables relies on the traditional unification algorithms, in their first- or higher-order variants, depending on the language.
Reference: [Hue75] <author> Gerard Huet. </author> <title> A unification algorithm for typed -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 27-57, </pages> <year> 1975. </year>
Reference-contexts: Differently from the first-order case, higher-order unification in Church's simply typed -calculus ! is undecidable and does not admit most general unifiers. Nevertheless sound and complete (although possibly non-terminating) procedures have been proposed in order to enumerate solutions. In particular, Huet's pre-unification algorithm <ref> [Hue75] </ref> factorizes unifiers in a non-redundant manner as constraints and has therefore been adopted in the implementation of higher-order logic programming languages [NM88]. Fragments of ! of practical relevance for which unification is decidable and yields most general unifiers have also been discovered. <p> The pre-unification algorithm is the subject of Section 3. We discuss the unification problem in sublanguages of !ffi&&gt; in Section 4. In order to facilitate our description in the available space, we must assume the reader familiar with traditional higher-order unification <ref> [Hue75] </ref> and linear logic [Gir87]. 2 A Linear Simply-Typed Lambda Calculus This section defines the simply-typed linear -calculus !ffi&&gt; (Subsection 2.1) and presents an equivalent formulation, S !ffi&&gt; (Subsection 2.2), that turns out convenient for describing and implementing unification. 2.1 Basic Formulation The linear simply-typed -calculus !ffi&&gt; extends Church's ! with
Reference: [IP96] <author> Samin Ishtiaq and David Pym, </author> <month> May </month> <year> 1996. </year> <type> Personal communications. </type>
Reference-contexts: In particular, the instantiation of logic variables relies on the traditional unification algorithms, in their first- or higher-order variants, depending on the language. More recent proposals, such as the language of the linear logical framework LLF [Cer96, CP96] and the system in <ref> [IP96] </ref>, introduce linearity not only at the level of formulas, but also within terms. An implementation of these languages should perform higher-order unification on linear terms in order to instantiate variables.
Reference: [JP76] <author> D. C. Jensen and T. Pietrzykowski. </author> <title> Mechanizing !-order type theory through unification. </title> <journal> Theoretical Computer Science, </journal> <volume> 3 </volume> <pages> 123-171, </pages> <year> 1976. </year>
Reference-contexts: The achievability of algorithms a la Huet depend crucially on flex-flex equations being always solvable. If this property does not hold, as in some sublanguages of S !ffi&&gt; we will discuss shortly, these equations must be analyzed with techniques similar to <ref> [JP76] </ref> or [Mil89]. The procedure we just described is not guaranteed to terminate for generic equation systems since flex-rigid steps can produce arbitrarily complex new equations.
Reference: [Lev96] <author> Jordi Levy. </author> <title> Linear second-order unification. </title> <editor> In H. Ganzinger, editor, </editor> <booktitle> Proceedings of the Seventh International Conference on Rewriting Techniques and Applications, </booktitle> <address> New Brunswick, New Jersey, </address> <month> July </month> <year> 1996. </year> <note> To appear. </note>
Reference-contexts: An example is Miller's higher-order patterns [Mil89], that has been implemented in the higher-order logic programming language Elf [Pfe91]. Unification in the context of linear -calculi has received limited attention in the literature and, to our knowledge, only a restricted fragment of a multiplicative language has been treated <ref> [Lev96] </ref>. In this extended abstract, we investigate the unification problem in the linear simply-typed -calculus !ffi&&gt; . We give a pre-unification procedure in the style of Huet and discuss the new sources of non-determinism due to linearity. <p> In conclusion, pre-unification procedures in the sense of Huet are not achievable in the calculi with ffi but without &gt;. Finally, a restricted form of unification in the purely linear calculus ffi has been studied in <ref> [Lev96] </ref>.
Reference: [Mil89] <author> Dale Miller. </author> <title> A logic programming language with lambda-abstraction, function variables, and simple unification. </title> <editor> In Peter Schroeder-Heister, editor, </editor> <booktitle> Proceedings of the International Workshop on Extensions of Logic Programming, </booktitle> <pages> pages 253-281, </pages> <address> Tubingen, Germany, 1989. </address> <publisher> Springer-Verlag LNAI 475. </publisher>
Reference-contexts: Fragments of ! of practical relevance for which unification is decidable and yields most general unifiers have also been discovered. An example is Miller's higher-order patterns <ref> [Mil89] </ref>, that has been implemented in the higher-order logic programming language Elf [Pfe91]. Unification in the context of linear -calculi has received limited attention in the literature and, to our knowledge, only a restricted fragment of a multiplicative language has been treated [Lev96]. <p> The achievability of algorithms a la Huet depend crucially on flex-flex equations being always solvable. If this property does not hold, as in some sublanguages of S !ffi&&gt; we will discuss shortly, these equations must be analyzed with techniques similar to [JP76] or <ref> [Mil89] </ref>. The procedure we just described is not guaranteed to terminate for generic equation systems since flex-rigid steps can produce arbitrarily complex new equations.
Reference: [Mil94] <editor> Dale Miller. A multiple-conclusion meta-logic. In S. Abramsky, editor, </editor> <booktitle> Ninth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 272-281, </pages> <address> Paris, France, </address> <month> July </month> <year> 1994. </year>
Reference-contexts: Attempts at mechanizing this additional expressive power led to the design of several logic programming languages based on various fragments of linear logic. The only new aspect in the operational semantics of most proposals, such as Lolli [HM94], Lygon [HP94] and Forum <ref> [Mil94] </ref>, concerns the management of linear context formulas [CHP96]. In particular, the instantiation of logic variables relies on the traditional unification algorithms, in their first- or higher-order variants, depending on the language.
Reference: [NM88] <author> Gopalan Nadathur and Dale Miller. </author> <title> An overview of Prolog. </title> <editor> In Kenneth A. Bowen and Robert A. Kowalski, editors, </editor> <booktitle> Fifth International Logic Programming Conference, </booktitle> <pages> pages 810-827, </pages> <address> Seattle, Washing-ton, August 1988. </address> <publisher> MIT Press. </publisher>
Reference-contexts: Nevertheless sound and complete (although possibly non-terminating) procedures have been proposed in order to enumerate solutions. In particular, Huet's pre-unification algorithm [Hue75] factorizes unifiers in a non-redundant manner as constraints and has therefore been adopted in the implementation of higher-order logic programming languages <ref> [NM88] </ref>. Fragments of ! of practical relevance for which unification is decidable and yields most general unifiers have also been discovered. An example is Miller's higher-order patterns [Mil89], that has been implemented in the higher-order logic programming language Elf [Pfe91].
Reference: [Pfe91] <author> Frank Pfenning. </author> <title> Logic programming in the LF logical framework. </title> <editor> In Gerard Huet and Gordon Plotkin, editors, </editor> <booktitle> Logical Frameworks, </booktitle> <pages> pages 149-181. </pages> <publisher> Cambridge University Press, </publisher> <year> 1991. </year> <month> 10 </month>
Reference-contexts: Fragments of ! of practical relevance for which unification is decidable and yields most general unifiers have also been discovered. An example is Miller's higher-order patterns [Mil89], that has been implemented in the higher-order logic programming language Elf <ref> [Pfe91] </ref>. Unification in the context of linear -calculi has received limited attention in the literature and, to our knowledge, only a restricted fragment of a multiplicative language has been treated [Lev96]. In this extended abstract, we investigate the unification problem in the linear simply-typed -calculus !ffi&&gt; .
References-found: 16

