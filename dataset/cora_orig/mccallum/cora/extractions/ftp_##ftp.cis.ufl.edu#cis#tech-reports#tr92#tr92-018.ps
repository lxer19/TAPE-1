URL: ftp://ftp.cis.ufl.edu/cis/tech-reports/tr92/tr92-018.ps
Refering-URL: http://www.cis.ufl.edu/tech-reports/tech-reports/tr92-abstracts.html
Root-URL: http://www.cis.ufl.edu
Email: hanson@cis.ufl.edu  
Title: The Design and Implementation of the Ariel Active Database Rule System  
Author: Eric N. Hanson 
Date: September 1991  
Address: Gainesville, FL 32611  
Affiliation: Department of Computer and Information Sciences University of Florida  
Pubnum: UF-CIS-018-92  
Abstract: This paper describes the design and implementation of the Ariel DBMS and it's tightly-coupled forward-chaining rule system. The query language of Ariel is a subset of POSTQUEL, extended with a new production-rule sublanguage. Ariel supports traditional relational database query and update operations efficiently, using a System R-like query processing strategy. In addition, the Ariel rule system is tightly coupled with query and update processing. Ariel rules can have conditions based on a mix of patterns, events, and transitions. For testing rule conditions, Ariel makes use of a discrimination network composed of a special data structure for testing single-relation selection conditions efficiently, and a modified version of the TREAT algorithm, called A-TREAT, for testing join conditions. The key modification to TREAT (which could also be used in the Rete algorithm) is the use of virtual ff-memory nodes which save storage since they contain only the predicate associated with the memory node instead of copies of data matching the predicate. The rule-action executor in Ariel binds the data matching a rule's condition to the action of the rule at rule fire time, and executes the rule action using the query processor.
Abstract-found: 1
Intro-found: 1
Reference: [A + 76] <author> M. M. Astrahan et al. </author> <title> System R: Relational approach to database management. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 1(2), </volume> <month> June </month> <year> 1976. </year>
Reference-contexts: These features provide a powerful new capability for a relational database system, giving a foundation on which new active database applications can be built. 3 Architectural Overview The architecture of Ariel, shown in Figure 3, is similar to that of System R <ref> [A + 76] </ref> with additional components attached for rule processing. Similar to System R and other relational database systems, Ariel has a front-end consisting of a lexer, parser, semantic analyzer, and query optimizer.
Reference: [ABC + 83] <author> M. P. Atkinson, P. J. Bailey, K. J. Chisholm, P. W. Cockshott, and R. Morrison. </author> <title> An approach to persistent programming. </title> <journal> The Computer Journal, </journal> <volume> 26(4), </volume> <year> 1983. </year> <note> (reprinted in [ZM90]). </note>
Reference-contexts: One feature of E that caused us a problem is that there is a distinction in E between regular C++ class types and E dbclass types. E thus does not have the property of persistence orthogonality where persistence of an object is strictly independent of its type <ref> [ABC + 83] </ref>. The type of any object that is persistent in E must be declared as a dbclass and all of its sub-objects must also be db-objects.
Reference: [BC79] <author> O. P. Buneman and E. K. Clemons. </author> <title> Efficiently monitoring relational databases. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 4(3) </volume> <pages> 368-382, </pages> <month> September </month> <year> 1979. </year>
Reference-contexts: 1 Introduction Designers of database management systems have long wanted to transform databases from passive repositories for data into active systems that can respond immediately to a change in the state of the data, an event, or a transition between states <ref> [BC79, Esw76] </ref>. However, to create a successful active database system, many problems must be solved, including: y This work was supported in part by the Air Force Office of Scientific Research under grant number AFOSR-89-0286. This paper also appeared as Wright State University report WSU-CS-91-06.
Reference: [BFKM85] <author> L. Brownston, R. Farrell, E. Kant, and N. Martin. </author> <title> Programming Expert Systems in OPS5: an Introduction to Rule-Based Programming. </title> <publisher> Addison Wesley, </publisher> <year> 1985. </year>
Reference-contexts: Finally, the act step executes the statements in the rule action. The cycle repeats until no rules are eligible to run, or the system executes an explicit halt. 2.3.5 Conflict Resolution Phase The conflict resolution rule for Ariel is a variation of the LEX strategy used in OPS5 <ref> [BFKM85] </ref>.
Reference: [BO89] <author> Virginia E. Barker and Dennis E. O'Connor. </author> <title> Expert systems for configuration at Digital: XCON and beyond. </title> <journal> CACM, </journal> <volume> 32(3), </volume> <month> March </month> <year> 1989. </year>
Reference-contexts: We believe that this assumption is reasonable because rules are a form of intentional data (schema) as opposed to extensional data (contents). Moreover, 17 the largest expert system applications built to date have on the order of 10,000 rules <ref> [BO89] </ref>, which is few enough that data structures associated with the rules will fit in a few megabytes of main memory. More typical rule-based system applications have on the order of 50 to 1000 rules.
Reference: [C + 89] <author> S. Chakravarthy et al. HiPAC: </author> <title> A research project in active, time-constained database management, </title> <type> Final Technical Report. Technical Report XAIT-89-02, </type> <institution> Xerox Advanced Information Technology, </institution> <month> August </month> <year> 1989. </year>
Reference-contexts: (RPL [DE88a, DE88b], Starburst rule system [WCL91]), * do not provide a data structure for testing selection conditions, or * provide a data structure for testing selection conditions which cannot efficiently handle conditions placed on an arbitrary attribute (e.g., one without an index) (POSTGRES rule system [SHP88, SHP89, SRH90], HiPAC <ref> [C + 89] </ref>, DIPS [SLR89], Alert [SPAM91]). <p> The HiPAC system has a sophisticated trigger model which allows specification of multiple coupling modes describing the time rule conditions are evaluated and rule actions are run. These include immediate, deferred, and decoupled modes for both conditions and actions <ref> [C + 89] </ref>. In contrast, Ariel executes all rules in the HiPAC mode condition=immediate and action=deferred. The HiPAC design was partially implemented in a main-memory-based prototype. RPL has a rule language based in SQL which is quite similar to the Ariel rule language.
Reference: [CDF + 86] <author> M. Carey, D. DeWitt, D. Frank, G. Graefe, J. Richardson, E. Shekita, and M. Mura-likrishna. </author> <title> The architecture of the EXODUS extensible DBMS. </title> <booktitle> In Procedings of the International Workshop on Object-Oriented Database Systems, </booktitle> <month> September </month> <year> 1986. </year>
Reference-contexts: Similar to System R and other relational database systems, Ariel has a front-end consisting of a lexer, parser, semantic analyzer, and query optimizer. The back end of Ariel consists of a query plan executor, and is built on top of the storage system provided by the EXODUS database toolkit <ref> [CDF + 86, RC87] </ref>. <p> Given that this is a per-tuple CPU cost, the time is substantial, but should not be prohibitive. Of course, these are CPU-only costs, and any increase in CPU speed will cause the predicate testing time to scale down accordingly. 9 Implementation Ariel is implemented using the EXODUS toolkit <ref> [CDF + 86, RC87] </ref> and in particular the E programming language [RCS89], an extension of C++ with persistent objects. The current version of Ariel consists of about 28000 lines of C++/E code.
Reference: [Cha89] <author> Sharma Chakravarthy. </author> <title> Rule management and evaluation: An active DBMS perspective. </title> <booktitle> SIGMOD Record, </booktitle> <volume> 18(3) </volume> <pages> 20-28, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: Some other database rule systems have been developed but have not been implemented in a tightly coupled fashion with the database query processor. These include DIPS [SLR89, RSL89] and RPL [DE88a, DE88b]. Another, HiPAC <ref> [DBB + 88, Cha89, MD89] </ref>, has been implemented, but only as a main-memory prototype. The POSTGRES rule system (PRS) [SHP88, SRH90] and the Starburst rule system (SRS) [WCL91, HCL + 90] have been implemented in a tightly-coupled fashion with their respective database systems.
Reference: [Cha90] <author> Moez Chaabouni. </author> <title> A top-level discrimination network for database rule systems. </title> <type> Master's thesis, </type> <institution> Dept. of Computer Science and Eng., Wright State Univ., </institution> <month> December </month> <year> 1990. </year>
Reference-contexts: Performance results for the join network and rule action planner are not yet available. However, some performance measurements for the top-level discrimination network are presented below (see <ref> [Cha90] </ref> for a more complete performance study of the top-level network). 30 To get empirical figures on the performance of IBS-trees, the algorithm was implemented in C++ on a Sun SPARCstation 1 computer.
Reference: [Col89] <author> Larry Collins. </author> <title> Informal survey of relational database applications at Wright-Patterson AFB. </title> <type> (personal communication), </type> <year> 1989. </year> <month> 37 </month>
Reference-contexts: Typical predicates on these relations (e.g. single-relation selection conditions in WHERE clauses of queries) normally refer to only one or two attributes, and rarely to three or four <ref> [Col89] </ref>.
Reference: [DBB + 88] <author> U. Dayal, B. Blaustein, A. Buchmann, et al. </author> <title> The HiPAC project: Combining active databases and timing constraints. </title> <booktitle> SIGMOD Record, </booktitle> <volume> 17(1) </volume> <pages> 51-70, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: Some other database rule systems have been developed but have not been implemented in a tightly coupled fashion with the database query processor. These include DIPS [SLR89, RSL89] and RPL [DE88a, DE88b]. Another, HiPAC <ref> [DBB + 88, Cha89, MD89] </ref>, has been implemented, but only as a main-memory prototype. The POSTGRES rule system (PRS) [SHP88, SRH90] and the Starburst rule system (SRS) [WCL91, HCL + 90] have been implemented in a tightly-coupled fashion with their respective database systems. <p> index heavily overlapping regions like these predicates poorly, degenerating to what is essentially a sequential search of all predicates in the index. 6.1.2 Practical Considerations for Predicate Indexing in a DBMS Numerous database rule systems have been proposed recently, including Ariel [Han89], RPL [DE88a], the POSTGRES rules system [SHP88], HiPAC <ref> [DBB + 88] </ref>, DIPS [SLR89], and others. We envision that applications built using systems like these will be primarily data management applications, enhanced with rules which will provide improved data integrity, monitoring capability, and some features similar to those found in expert systems.
Reference: [DE88a] <author> Lois M. L. Delcambre and James N. Etheredge. </author> <title> The relational production language: A production language for relational databases. </title> <booktitle> In Proceedings of the Second International Conference on Expert Database Systems, </booktitle> <pages> pages 153-162, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: Some other database rule systems have been developed but have not been implemented in a tightly coupled fashion with the database query processor. These include DIPS [SLR89, RSL89] and RPL <ref> [DE88a, DE88b] </ref>. Another, HiPAC [DBB + 88, Cha89, MD89], has been implemented, but only as a main-memory prototype. The POSTGRES rule system (PRS) [SHP88, SRH90] and the Starburst rule system (SRS) [WCL91, HCL + 90] have been implemented in a tightly-coupled fashion with their respective database systems. <p> Spatial Data structures, particularly R-trees and R+-trees, index heavily overlapping regions like these predicates poorly, degenerating to what is essentially a sequential search of all predicates in the index. 6.1.2 Practical Considerations for Predicate Indexing in a DBMS Numerous database rule systems have been proposed recently, including Ariel [Han89], RPL <ref> [DE88a] </ref>, the POSTGRES rules system [SHP88], HiPAC [DBB + 88], DIPS [SLR89], and others. We envision that applications built using systems like these will be primarily data management applications, enhanced with rules which will provide improved data integrity, monitoring capability, and some features similar to those found in expert systems. <p> Other database rule system projects either: * do not address the need for efficient data structures for finding which rules match a particular tuple (RPL <ref> [DE88a, DE88b] </ref>, Starburst rule system [WCL91]), * do not provide a data structure for testing selection conditions, or * provide a data structure for testing selection conditions which cannot efficiently handle conditions placed on an arbitrary attribute (e.g., one without an index) (POSTGRES rule system [SHP88, SHP89, SRH90], HiPAC [C + <p> RPL has a rule language based in SQL which is quite similar to the Ariel rule language. It provides an interesting model for a production-rule-like trigger language extension for SQL. However, it was implemented on top of another database system without a significant attempt to optimize rule condition testing <ref> [DE88a] </ref>. The work on the Data Intensive Production System (DIPS) describes a strategy for implementation of OPS5 on top of a relational DBMS [SLR89]. DIPS uses mechanisms based on tables of partial matches that test rule conditions differently from traditional Rete and TREAT networks.
Reference: [DE88b] <author> Lois M. L. Delcambre and James N. Etheredge. </author> <title> A self-controlling interpreter for the relational production language. </title> <booktitle> In Proceedings of the 1988 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 396-403, </pages> <address> Chicago IL, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: Some other database rule systems have been developed but have not been implemented in a tightly coupled fashion with the database query processor. These include DIPS [SLR89, RSL89] and RPL <ref> [DE88a, DE88b] </ref>. Another, HiPAC [DBB + 88, Cha89, MD89], has been implemented, but only as a main-memory prototype. The POSTGRES rule system (PRS) [SHP88, SRH90] and the Starburst rule system (SRS) [WCL91, HCL + 90] have been implemented in a tightly-coupled fashion with their respective database systems. <p> Other database rule system projects either: * do not address the need for efficient data structures for finding which rules match a particular tuple (RPL <ref> [DE88a, DE88b] </ref>, Starburst rule system [WCL91]), * do not provide a data structure for testing selection conditions, or * provide a data structure for testing selection conditions which cannot efficiently handle conditions placed on an arbitrary attribute (e.g., one without an index) (POSTGRES rule system [SHP88, SHP89, SRH90], HiPAC [C +
Reference: [Esw76] <author> K. P. Eswaran. </author> <title> Specifications, implementations and interactions of a trigger subsystem in an integrated database system. </title> <type> Technical report, </type> <institution> IBM Research Laboratory, </institution> <address> San Jose, CA, </address> <year> 1976. </year>
Reference-contexts: 1 Introduction Designers of database management systems have long wanted to transform databases from passive repositories for data into active systems that can respond immediately to a change in the state of the data, an event, or a transition between states <ref> [BC79, Esw76] </ref>. However, to create a successful active database system, many problems must be solved, including: y This work was supported in part by the Air Force Office of Scientific Research under grant number AFOSR-89-0286. This paper also appeared as Wright State University report WSU-CS-91-06.
Reference: [For81] <author> Charles L. Forgy. </author> <title> OPS5 user's manual. </title> <type> Technical Report CMU-CS-81-135, </type> <institution> Carnegie-Mellon University, </institution> <address> Pittsburgh, PA 15213, </address> <month> July </month> <year> 1981. </year>
Reference-contexts: The Ariel rule system (ARS) is based on the production system model [For82]. Our approach has been to adopt as much as possible from previous work on main-memory production systems such as OPS5 <ref> [For81] </ref>, but make changes where necessary to improve the functionality and performance of a production system in a database environment. <p> Only rules with priority equal to the maximum of the priorities of all rules on the agenda are eligible to run. 2.3.4 The Rule Execution Cycle Rules in Ariel are processed using a control strategy called the recognize-act cycle, shown in Figure 1, which is commonly used in production systems <ref> [For81] </ref>. The match step finds the set of rules that are eligible to run. The conflict resolution step selects a single rule for execution from the set of eligible rules. Finally, the act step executes the statements in the rule action.
Reference: [For82] <author> C. L. Forgy. </author> <title> Rete: A fast algorithm for the many pattern/many object pattern match problem. </title> <journal> Artificial Intelligence, </journal> <volume> 19 </volume> <pages> 17-37, </pages> <year> 1982. </year>
Reference-contexts: The Ariel system is an implementation of a relational DBMS with a built in rule system which has been designed to address the above issues. The Ariel rule system (ARS) is based on the production system model <ref> [For82] </ref>. Our approach has been to adopt as much as possible from previous work on main-memory production systems such as OPS5 [For81], but make changes where necessary to improve the functionality and performance of a production system in a database environment. <p> Execution of rules is governed by a recognize-act cycle similar to that used in OPS5 <ref> [For82] </ref>. Ariel rules get an opportunity to wake up after every database transition.
Reference: [FW80] <author> J. E. Freund and R. E. Walpole. </author> <title> Mathamatical Statistics. </title> <publisher> Prentice-Hall, </publisher> <year> 1980. </year>
Reference-contexts: If we assume that the default assumption is to replan (this is called the null hypothesis in statistical terminology), then not replanning when it is a good idea is a type I error and replanning when it is a bad idea is a type II error <ref> [FW80] </ref>. The different strategies are discussed here: * Always reoptimize.
Reference: [Gut84] <author> A. Guttman. R-trees: </author> <title> A dynamic index structure for spatial searching. </title> <booktitle> In Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data, </booktitle> <month> June </month> <year> 1984. </year>
Reference-contexts: In addition, the need to set locks on index intervals and on tuples complicates the implementation of storage structures. The final class of selection predicate indexing techniques, called multi-dimensional indexing, utilizes a multi-dimensional data structure for indexing region data such as an R-tree <ref> [Gut84] </ref> or R+-tree [SSH86] to index predicates. The predicates are treated as regions in a k-dimensional space (where k is the number of attributes in the relation on which the predicates are defined), and inserted into the index.
Reference: [Han89] <author> Eric N. Hanson. </author> <title> An initial report on the design of Ariel: a DBMS with an integrated production rule system. </title> <booktitle> SIGMOD Record, </booktitle> <volume> 18(3), </volume> <month> September </month> <year> 1989. </year>
Reference-contexts: Spatial Data structures, particularly R-trees and R+-trees, index heavily overlapping regions like these predicates poorly, degenerating to what is essentially a sequential search of all predicates in the index. 6.1.2 Practical Considerations for Predicate Indexing in a DBMS Numerous database rule systems have been proposed recently, including Ariel <ref> [Han89] </ref>, RPL [DE88a], the POSTGRES rules system [SHP88], HiPAC [DBB + 88], DIPS [SLR89], and others.
Reference: [Han91] <author> Eric N. Hanson. </author> <title> The interval skip list: A data structure for finding all intervals that overlap a point. </title> <booktitle> In Proceedings of the 1991 Workshop on Algorithms and Data Structures. </booktitle> <publisher> Springer Verlag, </publisher> <month> August </month> <year> 1991. </year>
Reference-contexts: An example IBS-tree and IS-list are shown in Figure 5 and Figure 6, respectively. For a complete discussion of the IBS-tree and IS-list, readers are referred to [HC90, HCKW90] and <ref> [Han91] </ref>, respectively. 19 6.2 Saving Storage Using Virtual ff-memories Here we describe a variation of the Rete and TREAT algorithms for minimizing storage use in database rule systems.
Reference: [HC90] <author> Eric N. Hanson and Moez Chaabouni. </author> <title> The IBS tree: A data structure for finding all intervals that overlap a point. </title> <type> Technical Report WSU-CS-90-11, </type> <institution> Wright State University, </institution> <month> April </month> <year> 1990. </year>
Reference-contexts: An example IBS-tree and IS-list are shown in Figure 5 and Figure 6, respectively. For a complete discussion of the IBS-tree and IS-list, readers are referred to <ref> [HC90, HCKW90] </ref> and [Han91], respectively. 19 6.2 Saving Storage Using Virtual ff-memories Here we describe a variation of the Rete and TREAT algorithms for minimizing storage use in database rule systems.
Reference: [HCKW90] <author> Eric N. Hanson, Moez Chaabouni, Chang-ho Kim, and Yu-wang Wang. </author> <title> A predicate matching algorithm for database rule systems. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <month> May </month> <year> 1990. </year>
Reference-contexts: The main performance optimization in A-TREAT is the use of a special top-level discrimination network for testing selection conditions of rules <ref> [HCKW90] </ref>. In addition, we introduce a technique for reducing the amount of state information stored in the network, whereby ff-memory nodes are replaced in some cases by virtual ff-memory nodes which contain only the predicate associated with the node, not the tuples matching the predicate. <p> An example IBS-tree and IS-list are shown in Figure 5 and Figure 6, respectively. For a complete discussion of the IBS-tree and IS-list, readers are referred to <ref> [HC90, HCKW90] </ref> and [Han91], respectively. 19 6.2 Saving Storage Using Virtual ff-memories Here we describe a variation of the Rete and TREAT algorithms for minimizing storage use in database rule systems.
Reference: [HCL + 90] <author> L. Haas, W. Chang, G. M. Lohman, et al. </author> <title> Starburst mid-flight: as the dust clears. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(1), </volume> <month> March </month> <year> 1990. </year>
Reference-contexts: These include DIPS [SLR89, RSL89] and RPL [DE88a, DE88b]. Another, HiPAC [DBB + 88, Cha89, MD89], has been implemented, but only as a main-memory prototype. The POSTGRES rule system (PRS) [SHP88, SRH90] and the Starburst rule system (SRS) <ref> [WCL91, HCL + 90] </ref> have been implemented in a tightly-coupled fashion with their respective database systems. However, neither the PRS, SRS, DIPS, RPL, nor HiPAC have a rule condition testing network comparable to the one in Ariel. <p> 3 transition rule semantics in an efficient, discrimination-network-based rule condition testing system. 2.3.9 External Functions The ability to call external functions from within a DBMS query language is quite useful, and some form of external function interface has been implemented in several systems including ADT-INGRES [Sto86], POSTGRES [SRH90] and STARBURST <ref> [HCL + 90] </ref>. In an active rule system, external functions are even more important than in a traditional database system since they allow vital communication with external processes to be performed automatically in the actions of triggered rules.
Reference: [HHR91] <author> Eric N. Hanson, Tina Harvey, and Mark Roth. </author> <title> Experiences in DBMS implementation using an object-oriented persistent programming language and a database toolkit. </title> <booktitle> In Proceedings of the 1991 ACM Conference on Object-oriented Programming Systems, Languages and Applications, </booktitle> <month> October </month> <year> 1991. </year>
Reference-contexts: However, lack of persistence orthogonality is such a software engineering problem that we feel every effort should be made to develop persistent languages that do have persistence orthogonality <ref> [HHR91] </ref>.
Reference: [ING89] <institution> INGRES Corporation. </institution> <note> INGRES/SQL Reference Manual, </note> <month> November </month> <year> 1989. </year> <note> Version 6.3. 38 </note>
Reference-contexts: Prior to the development of the virtual memory node concept, it was mandatory to materialize the ff-memory nodes, limiting potential optimizations. Some commercial database rule systems already support triggers using a general predicate on a single relation (e.g., the commercial INGRES system <ref> [ING89] </ref>). A selection predicate index like the one for Ariel could be encorporated systems like this to improve performance with low risk.
Reference: [MD89] <author> Dennis R. McCarthy and Umeshwar Dayal. </author> <title> The architecture of an active data base management system. </title> <booktitle> In Proceedings of the 1989 ACM SIGMOD International Conference on Management of Data, </booktitle> <month> June </month> <year> 1989. </year>
Reference-contexts: Some other database rule systems have been developed but have not been implemented in a tightly coupled fashion with the database query processor. These include DIPS [SLR89, RSL89] and RPL [DE88a, DE88b]. Another, HiPAC <ref> [DBB + 88, Cha89, MD89] </ref>, has been implemented, but only as a main-memory prototype. The POSTGRES rule system (PRS) [SHP88, SRH90] and the Starburst rule system (SRS) [WCL91, HCL + 90] have been implemented in a tightly-coupled fashion with their respective database systems.
Reference: [Obj90] <institution> Object Design, Inc. </institution> <note> ObjectStore technical overview, release 1.0, </note> <month> August </month> <year> 1990. </year>
Reference-contexts: However, lack of persistence orthogonality is such a software engineering problem that we feel every effort should be made to develop persistent languages that do have persistence orthogonality [HHR91]. We are encouraged by development of at least one commercial implementation of persistent C++, Object Design's ObjectStore <ref> [Obj90] </ref>, which does have persistence orthogonality, as well as research into persistent virtual-memory in the Cricket project [SZ90] which may simplify implementation of persistent programming languages. 34 10 Review of Related Work There has been a significant amount of research on active databases recently.
Reference: [Pug90] <author> William Pugh. </author> <title> Skip lists: A probabilistic alternative to balanced trees. </title> <journal> Communications of the ACM, </journal> <volume> 33(6), </volume> <month> June </month> <year> 1990. </year>
Reference-contexts: The segment tree does not satisfy the first requirement, and the priority search tree does not satisfy the second requirement. Both the IBS-tree and IS-list satisfy all three. The IBS-tree and the skip-list are based on the binary search tree and the skip-list <ref> [Pug90] </ref>, respectively. They involve transforming the index for point data into an interval index by augmenting the standard data structure with markers to cover each interval.
Reference: [Ras91] <author> Anjali Rastogi. </author> <title> Transition and event condition testing and rule execution in Ariel. </title> <type> Master's thesis, </type> <institution> Dept. of Computer Science and Eng., Wright State Univ., </institution> <month> June </month> <year> 1991. </year>
Reference-contexts: The possible sequences of operations that may occur to a single tuple during a transition are shown below <ref> [Ras91] </ref>: * Case 1: An insertion of a tuple t followed by one or more modifications of t (im fl ). The net effect of this transition is an insertion.
Reference: [RC87] <author> Joel E. Richardson and Michael J. Carey. </author> <title> Programming constructs for database system implementation in EXODUS. </title> <booktitle> In Proceedings of the 1987 ACM SIGMOD International Conference on Management of Data, </booktitle> <month> May </month> <year> 1987. </year>
Reference-contexts: Similar to System R and other relational database systems, Ariel has a front-end consisting of a lexer, parser, semantic analyzer, and query optimizer. The back end of Ariel consists of a query plan executor, and is built on top of the storage system provided by the EXODUS database toolkit <ref> [CDF + 86, RC87] </ref>. <p> join network network selection rule network processor query lexer/parser rule action planner 4 The Rule Catalog The rule catalog is composed of a collection of Rule objects stored as persistent C++ objects (we use the persistence features of the E programming language, a persistent extension of C++ provided with EXODUS <ref> [RC87] </ref>). Each rule object contains the rule name, ruleset name, status of the rule (active or inactive), and persistent syntax tree for the rule. <p> Given that this is a per-tuple CPU cost, the time is substantial, but should not be prohibitive. Of course, these are CPU-only costs, and any increase in CPU speed will cause the predicate testing time to scale down accordingly. 9 Implementation Ariel is implemented using the EXODUS toolkit <ref> [CDF + 86, RC87] </ref> and in particular the E programming language [RCS89], an extension of C++ with persistent objects. The current version of Ariel consists of about 28000 lines of C++/E code.
Reference: [RCS89] <author> Joel E. Richardson, Michael J. Carey, and Daniel T. Schuh. </author> <title> The design of the E programming language. </title> <type> Technical report, </type> <institution> University of Wisconsin, </institution> <year> 1989. </year>
Reference-contexts: Of course, these are CPU-only costs, and any increase in CPU speed will cause the predicate testing time to scale down accordingly. 9 Implementation Ariel is implemented using the EXODUS toolkit [CDF + 86, RC87] and in particular the E programming language <ref> [RCS89] </ref>, an extension of C++ with persistent objects. The current version of Ariel consists of about 28000 lines of C++/E code.
Reference: [RSL89] <author> Louiqa Raschid, Timos Sellis, and Chih-Chen Lin. </author> <title> Exploiting concurrency in a DBMS implementation for production systems. </title> <type> Technical Report UMIACS-TR-89-5, </type> <institution> University of Maryland, </institution> <month> January </month> <year> 1989. </year>
Reference-contexts: Some other database rule systems have been developed but have not been implemented in a tightly coupled fashion with the database query processor. These include DIPS <ref> [SLR89, RSL89] </ref> and RPL [DE88a, DE88b]. Another, HiPAC [DBB + 88, Cha89, MD89], has been implemented, but only as a main-memory prototype.
Reference: [S + 79] <author> P. Selinger et al. </author> <title> Access path selection in a relational database management system. </title> <booktitle> In Proceedings of the 1979 ACM SIGMOD International Conference on Management of Data, </booktitle> <month> June </month> <year> 1979. </year> <note> (reprinted in [Sto88]). </note>
Reference-contexts: This technique is the one normally used in main-memory implementations of production systems. Another predicate indexing method discussed in [SSH86, SHP88], called physical locking, involves treating a predicate clause like a query, and running the standard query optimizer <ref> [S + 79] </ref> to 16 produce an access plan for the query to be indexed. If the resulting access plan requires an index scan, then special persistent markers (locks) are placed on all tuples read during the scan, and all index intervals inspected during the scan.
Reference: [Sam90] <author> Hanan Samet. </author> <title> The Design and Analysis of Spatial Data Structures. </title> <publisher> Addision Wesley, </publisher> <year> 1990. </year>
Reference-contexts: Other interval indexes discussed in the literature, including the segment tree <ref> [Sam90] </ref> and the priority search tree were considered for Ariel, but did not meet the requirements that: 1. the index be efficiently updatable on-line, 2. a relatively straightforward implementation of the index be possible which does not require modification to index different data types, and 3. the index support fast searching
Reference: [SHP88] <author> Michael Stonebraker, Eric Hanson, and Spiros Potamianos. </author> <title> The POSTGRES rule manager. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(7) </volume> <pages> 897-907, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: These include DIPS [SLR89, RSL89] and RPL [DE88a, DE88b]. Another, HiPAC [DBB + 88, Cha89, MD89], has been implemented, but only as a main-memory prototype. The POSTGRES rule system (PRS) <ref> [SHP88, SRH90] </ref> and the Starburst rule system (SRS) [WCL91, HCL + 90] have been implemented in a tightly-coupled fashion with their respective database systems. However, neither the PRS, SRS, DIPS, RPL, nor HiPAC have a rule condition testing network comparable to the one in Ariel. <p> However, in the worst case, where all predicates lie on one relation, match complexity is again O (n). This technique is the one normally used in main-memory implementations of production systems. Another predicate indexing method discussed in <ref> [SSH86, SHP88] </ref>, called physical locking, involves treating a predicate clause like a query, and running the standard query optimizer [S + 79] to 16 produce an access plan for the query to be indexed. <p> and R+-trees, index heavily overlapping regions like these predicates poorly, degenerating to what is essentially a sequential search of all predicates in the index. 6.1.2 Practical Considerations for Predicate Indexing in a DBMS Numerous database rule systems have been proposed recently, including Ariel [Han89], RPL [DE88a], the POSTGRES rules system <ref> [SHP88] </ref>, HiPAC [DBB + 88], DIPS [SLR89], and others. We envision that applications built using systems like these will be primarily data management applications, enhanced with rules which will provide improved data integrity, monitoring capability, and some features similar to those found in expert systems. <p> match a particular tuple (RPL [DE88a, DE88b], Starburst rule system [WCL91]), * do not provide a data structure for testing selection conditions, or * provide a data structure for testing selection conditions which cannot efficiently handle conditions placed on an arbitrary attribute (e.g., one without an index) (POSTGRES rule system <ref> [SHP88, SHP89, SRH90] </ref>, HiPAC [C + 89], DIPS [SLR89], Alert [SPAM91]). <p> The POSTGRES Rule System <ref> [SHP88, SHP89, SRH90] </ref> is a sophisticated tuple-level rule system that allows triggers and integrity constraints to be defined with event and pattern-based conditions on a single tuple. It is a functioning component of the POSTGRES implementation.
Reference: [SHP89] <author> M. Stonebraker, M. Hearst, and S. Potaminos. </author> <title> A commentary on the POSTGRES rules system. </title> <booktitle> SIGMOD Record, </booktitle> <volume> 18(3), </volume> <month> September </month> <year> 1989. </year>
Reference-contexts: match a particular tuple (RPL [DE88a, DE88b], Starburst rule system [WCL91]), * do not provide a data structure for testing selection conditions, or * provide a data structure for testing selection conditions which cannot efficiently handle conditions placed on an arbitrary attribute (e.g., one without an index) (POSTGRES rule system <ref> [SHP88, SHP89, SRH90] </ref>, HiPAC [C + 89], DIPS [SLR89], Alert [SPAM91]). <p> The POSTGRES Rule System <ref> [SHP88, SHP89, SRH90] </ref> is a sophisticated tuple-level rule system that allows triggers and integrity constraints to be defined with event and pattern-based conditions on a single tuple. It is a functioning component of the POSTGRES implementation.
Reference: [SLR89] <author> Timos Sellis, Chih-Chen Lin, and Louiqa Raschid. </author> <title> Data intensive production systems: The DIPS approach. </title> <booktitle> SIGMOD Record, </booktitle> <month> September </month> <year> 1989. </year>
Reference-contexts: Some other database rule systems have been developed but have not been implemented in a tightly coupled fashion with the database query processor. These include DIPS <ref> [SLR89, RSL89] </ref> and RPL [DE88a, DE88b]. Another, HiPAC [DBB + 88, Cha89, MD89], has been implemented, but only as a main-memory prototype. <p> like these predicates poorly, degenerating to what is essentially a sequential search of all predicates in the index. 6.1.2 Practical Considerations for Predicate Indexing in a DBMS Numerous database rule systems have been proposed recently, including Ariel [Han89], RPL [DE88a], the POSTGRES rules system [SHP88], HiPAC [DBB + 88], DIPS <ref> [SLR89] </ref>, and others. We envision that applications built using systems like these will be primarily data management applications, enhanced with rules which will provide improved data integrity, monitoring capability, and some features similar to those found in expert systems. <p> rule system [WCL91]), * do not provide a data structure for testing selection conditions, or * provide a data structure for testing selection conditions which cannot efficiently handle conditions placed on an arbitrary attribute (e.g., one without an index) (POSTGRES rule system [SHP88, SHP89, SRH90], HiPAC [C + 89], DIPS <ref> [SLR89] </ref>, Alert [SPAM91]). <p> However, it was implemented on top of another database system without a significant attempt to optimize rule condition testing [DE88a]. The work on the Data Intensive Production System (DIPS) describes a strategy for implementation of OPS5 on top of a relational DBMS <ref> [SLR89] </ref>. DIPS uses mechanisms based on tables of partial matches that test rule conditions differently from traditional Rete and TREAT networks. However, no clear performance measurements have been done to show which condition testing strategy is superior.
Reference: [SPAM91] <author> Ulf Schreier, Hamid Pirahesh, Rakesh Agrawal, and C. Mohan. Alert: </author> <title> An architecture for transforming a passive DBMS into an active DBMS. </title> <booktitle> In Proc. 17th International Conference on Very Large Data Bases, </booktitle> <address> Barcelona, </address> <month> September </month> <year> 1991. </year>
Reference-contexts: [WCL91]), * do not provide a data structure for testing selection conditions, or * provide a data structure for testing selection conditions which cannot efficiently handle conditions placed on an arbitrary attribute (e.g., one without an index) (POSTGRES rule system [SHP88, SHP89, SRH90], HiPAC [C + 89], DIPS [SLR89], Alert <ref> [SPAM91] </ref>). <p> Alert is another rule system based on top of Starburst which uses an architecture for transforming a passive DBMS into an Active DBMS <ref> [SPAM91] </ref>. Alert provides some interesting mechanisms for defining triggers using queries which return a cursor that can be accessed again to find new matching data even after an end of file (EOF) has been returned.
Reference: [SRH90] <author> Michael Stonebraker, Lawrence Rowe, and Michael Hirohama. </author> <title> The implementation of POSTGRES. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(7) </volume> <pages> 125-142, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: These include DIPS [SLR89, RSL89] and RPL [DE88a, DE88b]. Another, HiPAC [DBB + 88, Cha89, MD89], has been implemented, but only as a main-memory prototype. The POSTGRES rule system (PRS) <ref> [SHP88, SRH90] </ref> and the Starburst rule system (SRS) [WCL91, HCL + 90] have been implemented in a tightly-coupled fashion with their respective database systems. However, neither the PRS, SRS, DIPS, RPL, nor HiPAC have a rule condition testing network comparable to the one in Ariel. <p> We thus decided to use the relational data model and provide a subset of the POSTQUEL query language of POSTGRES 3 for specifying data definition commands, queries and updates <ref> [SRH90] </ref>. POSTQUEL commands retrieve, append, delete, and replace, are supported, along with other commands for creating and destroying relations and indexes, and performing utility functions such as loading relations, gathering statistics on data in relations, and so forth. The syntax of POSTQUEL data manipulation commands is shown below. <p> and dept.name = "Toy" An equivalent command using a tuple variable e to range over the emp relation is: retrieve (e.name, job.title) from e in emp 4 where e.dno = dept.dno and e.jno = job.jno and dept.name = "Toy" For a more detailed description of POSTQUEL, readers are referred to <ref> [SRH90] </ref>. We now turn to a discussion of ARL. 2.2 Rule Language ARL is a production-rule language with enhancements for defining rules with conditions based not only on patterns, but also on events and transitions. The ARL syntax is based on the syntax of the query language. <p> to integrate level 3 transition rule semantics in an efficient, discrimination-network-based rule condition testing system. 2.3.9 External Functions The ability to call external functions from within a DBMS query language is quite useful, and some form of external function interface has been implemented in several systems including ADT-INGRES [Sto86], POSTGRES <ref> [SRH90] </ref> and STARBURST [HCL + 90]. In an active rule system, external functions are even more important than in a traditional database system since they allow vital communication with external processes to be performed automatically in the actions of triggered rules. <p> match a particular tuple (RPL [DE88a, DE88b], Starburst rule system [WCL91]), * do not provide a data structure for testing selection conditions, or * provide a data structure for testing selection conditions which cannot efficiently handle conditions placed on an arbitrary attribute (e.g., one without an index) (POSTGRES rule system <ref> [SHP88, SHP89, SRH90] </ref>, HiPAC [C + 89], DIPS [SLR89], Alert [SPAM91]). <p> The POSTGRES Rule System <ref> [SHP88, SHP89, SRH90] </ref> is a sophisticated tuple-level rule system that allows triggers and integrity constraints to be defined with event and pattern-based conditions on a single tuple. It is a functioning component of the POSTGRES implementation.
Reference: [SSH86] <author> M. Stonebraker, T. Sellis, and E. Hanson. </author> <title> An analysis of rule indexing implementations in data base systems. </title> <booktitle> In Proceedings of the First Annual Conference on Expert Database Systems, </booktitle> <month> April </month> <year> 1986. </year> <month> 39 </month>
Reference-contexts: However, in the worst case, where all predicates lie on one relation, match complexity is again O (n). This technique is the one normally used in main-memory implementations of production systems. Another predicate indexing method discussed in <ref> [SSH86, SHP88] </ref>, called physical locking, involves treating a predicate clause like a query, and running the standard query optimizer [S + 79] to 16 produce an access plan for the query to be indexed. <p> In addition, the need to set locks on index intervals and on tuples complicates the implementation of storage structures. The final class of selection predicate indexing techniques, called multi-dimensional indexing, utilizes a multi-dimensional data structure for indexing region data such as an R-tree [Gut84] or R+-tree <ref> [SSH86] </ref> to index predicates. The predicates are treated as regions in a k-dimensional space (where k is the number of attributes in the relation on which the predicates are defined), and inserted into the index.
Reference: [Sto75] <author> M. Stonebraker. </author> <title> Implementation of integrity constraints and views by query modification. </title> <booktitle> In Proceedings of the 1975 ACM SIGMOD International Conference on Management of Data, </booktitle> <month> June </month> <year> 1975. </year>
Reference-contexts: In the act phase, the statement (s) in the then part of the rule are bound to the P-node for the rule by a 8 process of query modification <ref> [Sto75] </ref>. The modified syntax tree for the command is then passed to the query optimizer which generates an optimal query execution plan. The plan is then interpreted to carry out the command. <p> At the time the rule is activated, the discrimination network for the rule is constructed, and a the binding between the condition and the action of the rule is made explicit through a process of query modification <ref> [Sto75] </ref>, after which the modified definition of the rule is stored in the rule catalog. During query modification, references to tuple variables shared between the rule condition and the rule action are transformed into explicit references to the P-node.
Reference: [Sto86] <author> Michael Stonebraker. </author> <title> Inclusion of new types in relational database systems. </title> <booktitle> In Proceedings of IEEE Data Engineering Conference, </booktitle> <pages> pages 262-269, </pages> <year> 1986. </year> <note> (reprinted in [Sto88]). </note>
Reference-contexts: be how to integrate level 3 transition rule semantics in an efficient, discrimination-network-based rule condition testing system. 2.3.9 External Functions The ability to call external functions from within a DBMS query language is quite useful, and some form of external function interface has been implemented in several systems including ADT-INGRES <ref> [Sto86] </ref>, POSTGRES [SRH90] and STARBURST [HCL + 90]. In an active rule system, external functions are even more important than in a traditional database system since they allow vital communication with external processes to be performed automatically in the actions of triggered rules.
Reference: [Sto88] <author> Michael Stonebraker, </author> <title> editor. </title> <booktitle> Readings in Database Systems. </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1988. </year>
Reference: [SZ90] <author> Eugene Shekita and Michael Zwilling. Cricket: </author> <title> A mapped, persistent object store. </title> <type> Technical report, </type> <institution> University of Wisconsin, </institution> <month> Fall </month> <year> 1990. </year>
Reference-contexts: We are encouraged by development of at least one commercial implementation of persistent C++, Object Design's ObjectStore [Obj90], which does have persistence orthogonality, as well as research into persistent virtual-memory in the Cricket project <ref> [SZ90] </ref> which may simplify implementation of persistent programming languages. 34 10 Review of Related Work There has been a significant amount of research on active databases recently.
Reference: [WCL91] <author> Jennifer Widom, Roberta J. Cochrane, and Bruce G. Lindsay. </author> <title> Implementing set-oriented production rules as an extension to Starburst. </title> <booktitle> In Proceedings of the Seventeenth International Conference on Very Large Data Bases, </booktitle> <year> 1991. </year>
Reference-contexts: These include DIPS [SLR89, RSL89] and RPL [DE88a, DE88b]. Another, HiPAC [DBB + 88, Cha89, MD89], has been implemented, but only as a main-memory prototype. The POSTGRES rule system (PRS) [SHP88, SRH90] and the Starburst rule system (SRS) <ref> [WCL91, HCL + 90] </ref> have been implemented in a tightly-coupled fashion with their respective database systems. However, neither the PRS, SRS, DIPS, RPL, nor HiPAC have a rule condition testing network comparable to the one in Ariel. <p> The designers of the Starburst rule system have implemented a form of level 3 semantics, albeit at substantial implementation complexity and performance overhead <ref> [WF90, WCL91] </ref>. <p> Other database rule system projects either: * do not address the need for efficient data structures for finding which rules match a particular tuple (RPL [DE88a, DE88b], Starburst rule system <ref> [WCL91] </ref>), * do not provide a data structure for testing selection conditions, or * provide a data structure for testing selection conditions which cannot efficiently handle conditions placed on an arbitrary attribute (e.g., one without an index) (POSTGRES rule system [SHP88, SHP89, SRH90], HiPAC [C + 89], DIPS [SLR89], Alert [SPAM91]). <p> DIPS uses mechanisms based on tables of partial matches that test rule conditions differently from traditional Rete and TREAT networks. However, no clear performance measurements have been done to show which condition testing strategy is superior. The Starburst Rule System (SRS) <ref> [WF90, WCL91] </ref> is a set-oriented rule system built on top of the Starburst extended relational DBMS. Starburst, similar to Ariel, allows specification of rules 35 with sophisticated transition conditions. SRS provides an elegant form of level 3 transition rule semantics as described in section 2.3.8.
Reference: [WF90] <author> Jennifer Widom and Sheldon J. Finkelstein. </author> <title> Set-oriented production rules in relational database systems. </title> <booktitle> In Proceedings of the 1990 ACM SIGMOD International Conference on Management of Data, </booktitle> <year> 1990. </year>
Reference-contexts: Ariel treats transitions as a set of logical events (insertions, updates and deletions). These logical events are derived by composing the physical events as they occur. Consider the following sequence of changes to the database, borrowing the notation of <ref> [WF90] </ref>, where S i is a database state, E i is the net effect of a transition T i , T 1 is a user-issued transition, and T i [R j ] is a transition induced by an execution of rule R j : The net effect of the transition from <p> The designers of the Starburst rule system have implemented a form of level 3 semantics, albeit at substantial implementation complexity and performance overhead <ref> [WF90, WCL91] </ref>. <p> DIPS uses mechanisms based on tables of partial matches that test rule conditions differently from traditional Rete and TREAT networks. However, no clear performance measurements have been done to show which condition testing strategy is superior. The Starburst Rule System (SRS) <ref> [WF90, WCL91] </ref> is a set-oriented rule system built on top of the Starburst extended relational DBMS. Starburst, similar to Ariel, allows specification of rules 35 with sophisticated transition conditions. SRS provides an elegant form of level 3 transition rule semantics as described in section 2.3.8.
Reference: [ZM90] <editor> Stanley B. Zdonik and David Maier, editors. </editor> <booktitle> Readings in Object-Oriented Databases. </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1990. </year>
References-found: 47

