URL: http://www.cs.jhu.edu/~cowen/abcp-focs.ps
Refering-URL: http://www.cs.jhu.edu/~cowen/
Root-URL: http://www.cs.jhu.edu
Title: Near-Linear Cost Sequential and Distributed Constructions of Sparse Neighborhood Covers  
Author: Baruch Awerbuch Bonnie Berger Lenore Cowen David Peleg Radcliffe 
Note: 02139. Supported by Air Force Contract AFOSR F49620-92-J-0125, NSF contract 9114440-CCR, DARPA contracts N00014-91-J-1698 and N00014-J-92-1799, and a special grant from IBM.  Supported in part by an NSF Postdoctoral Research Fellowship and an ONR grant provided to the  Supported in part by Air Force Contract OSR-89-02171, Army Contract DAAL-03-86-K-0171 and DARPA Contract N00014-91-J-1698  Supported in part by an Allon Fellowship, a Bantrell Fellowship, a Minerva Fellowship and a Walter and Elise Haas Career Development Award.  
Address: Cambridge, MA  Rehovot 76100, Israel.  
Affiliation: Lab. for Computer Science, MIT,  Dept. of Mathematics and Lab. for Computer Science, MIT.  Bunting Institute. Dept. of Mathematics and Lab. for Computer Science, MIT.  Department of Applied Mathematics and Computer Science, The Weizmann Institute,  
Abstract: This paper introduces the first near-linear (specifically, O(E log n + n log 2 n)) time algorithm for constructing a sparse neighborhood cover in sequential and distributed environments. This automatically implies analogous improvements (from quadratic to near-linear) to all the results in the literature that rely on network decompositions, both in sequential and distributed domains, including adaptive routing schemes with ~ O (1) 1 stretch and memory, small edge cuts in planar graphs, sequential algorithms for dynamic approximate shortest paths with ~ O (E) cost for edge insertion/deletion and ~ O (1) time to answer shortest-path queries, weight and distance-preserving graph spanners with ~ O (E) running time and space, and distributed asynchronous "from-scratch" Breadth-First-Search and network synchronizer constructions with ~ O (1) message and space overhead (down from O(n)). 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Y. Afek and M. Riklin. Sparser: </author> <title> A paradigm for running distributed algorithms. </title> <editor> J. </editor> <booktitle> of Algorithms, </booktitle> <year> 1991. </year> <note> Accepted for publication. </note>
Reference-contexts: Moreover, average degree covers are not sufficient for an efficient solution to the k-pairs shortest paths problem, because the "imbalance" (high and low overlaps) cannot be amortized over many queries. (Unlike the algorithms in this paper, other con structions of average degree covers <ref> [1, 15] </ref> cannot be run for multiple iterations to produce a small maximum degree cover.) However, as Afek et al. [1] and Cohen [15] have pointed out, in the special case of the all - pairs shortest paths application, an average degree cover suffices and leads to a better tradeoff between <p> k-pairs shortest paths problem, because the "imbalance" (high and low overlaps) cannot be amortized over many queries. (Unlike the algorithms in this paper, other con structions of average degree covers [1, 15] cannot be run for multiple iterations to produce a small maximum degree cover.) However, as Afek et al. <ref> [1] </ref> and Cohen [15] have pointed out, in the special case of the all - pairs shortest paths application, an average degree cover suffices and leads to a better tradeoff between running time and approximation; in particular, the constant of approximation can be improved by a constant factor. 1.2 Structure of
Reference: [2] <author> N. Alon, Z. Galil, and O. Margalit. </author> <title> On the ex-ponent of the all-pairs shortest path problem. </title> <booktitle> In Proc. 32nd IEEE Symp. on Foundations of Computer Science, </booktitle> <month> Oct. </month> <year> 1991. </year>
Reference-contexts: implementation [16], in time O (kn log n + kE) with a Fi-bonacci heap implementation [17], or compute all-pairs shortest paths via matrix multiplication in ~ O (M (n)) time, where M (n) is the time for matrix multiplication (currently known to be o (n 2:376 )); for example, see <ref> [2, 24, 3] </ref>. The bottlenecks in the running time of the exact algorithms come either from repeated application of Dijkstra's single source shortest paths algorithm or from matrix multiplication.
Reference: [3] <author> N. Alon, Z. Galil, O. Margalit, and M. Naor. </author> <title> Witnesses for boolean matrix multiplication and for shortest paths. </title> <booktitle> In Proc. 33rd IEEE Symp. on Foundations of Computer Science, </booktitle> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: implementation [16], in time O (kn log n + kE) with a Fi-bonacci heap implementation [17], or compute all-pairs shortest paths via matrix multiplication in ~ O (M (n)) time, where M (n) is the time for matrix multiplication (currently known to be o (n 2:376 )); for example, see <ref> [2, 24, 3] </ref>. The bottlenecks in the running time of the exact algorithms come either from repeated application of Dijkstra's single source shortest paths algorithm or from matrix multiplication.
Reference: [4] <author> B. Awerbuch, A. Bar-Noy, N. Linial, and D. Pe-leg. </author> <title> Compact distributed data structures for adaptive network routing. </title> <booktitle> In Proc. 21st ACM Symp. on Theory of Computing, </booktitle> <pages> pages 230-240, </pages> <month> May </month> <year> 1989. </year>
Reference-contexts: In contrast, our neighborhood cover algorithm finds a solution with small maximum cluster overlap over all nodes. The average degree cover problem is known to be significantly easier <ref> [11, 4] </ref>; in fact, the maximum degree cover algorithm in this paper works through a logarithmic number of it erations, each producing an average degree cover in the "remaining graph". <p> neighborhood cover in time O (E log n + n log n). 6 Example applications 6.1 Routing As a typical example of how to apply the network decomposition data structure in the distributed domain, we focus on a classic network application: online construction of adaptive routing schemes with compact tables <ref> [4, 5, 21] </ref>. Routing schemes have been around since [18, 19], but they have not been efficiently constructible until this paper. Many of the proposed schemes rely on the assumption of the existence of a data structure that can be constructed using small space [4, 22, 13, 8, 11]. <p> Routing schemes have been around since [18, 19], but they have not been efficiently constructible until this paper. Many of the proposed schemes rely on the assumption of the existence of a data structure that can be constructed using small space <ref> [4, 22, 13, 8, 11] </ref>. However, the more efficient schemes of [8, 11] required linear space per node to set up the data structure. <p> The space-efficient construction of sparse covers in this paper provides the missing piece. More specifically, prior to this paper, the best adaptive routing schemes appeared in <ref> [4, 5] </ref>. However, these schemes feature an unfavorable (roughly speaking, exponential) tradeoff between their communication overheads and space requirements; using these schemes one can achieve stretch and memory requirements of around O (n 1 p log n ).
Reference: [5] <author> B. Awerbuch, A. Bar-Noy, N. Linial, and D. Pe-leg. </author> <title> Improved routing strategies with succinct tables. </title> <journal> J. of Algorithms, </journal> <volume> 11 </volume> <pages> 307-341, </pages> <year> 1990. </year>
Reference-contexts: These include adaptive routing schemes with ~ O (1) stretch and memory (down from O (n 1 p log n ) <ref> [5, 12] </ref>); small edge cuts in planar graphs in ~ O (E) running time and space (as a consequence of this paper and the algorithm in [23], down from O (n 2 ) time and space using [11, 23]); sequential algorithms for approximating k-pairs shortest paths (see below and Section 6 <p> neighborhood cover in time O (E log n + n log n). 6 Example applications 6.1 Routing As a typical example of how to apply the network decomposition data structure in the distributed domain, we focus on a classic network application: online construction of adaptive routing schemes with compact tables <ref> [4, 5, 21] </ref>. Routing schemes have been around since [18, 19], but they have not been efficiently constructible until this paper. Many of the proposed schemes rely on the assumption of the existence of a data structure that can be constructed using small space [4, 22, 13, 8, 11]. <p> The space-efficient construction of sparse covers in this paper provides the missing piece. More specifically, prior to this paper, the best adaptive routing schemes appeared in <ref> [4, 5] </ref>. However, these schemes feature an unfavorable (roughly speaking, exponential) tradeoff between their communication overheads and space requirements; using these schemes one can achieve stretch and memory requirements of around O (n 1 p log n ).
Reference: [6] <author> B. Awerbuch, A. Baratz, and D. Peleg. </author> <title> Efficient broadcast and light-weight spanners. </title> <type> Unpublished manuscript, </type> <month> May </month> <year> 1993. </year>
Reference-contexts: a consequence of this paper and the algorithm in [23], down from O (n 2 ) time and space using [11, 23]); sequential algorithms for approximating k-pairs shortest paths (see below and Section 6 for details); weight and distance-preserving graph spanners with ~ O (E) running time and space (see <ref> [6, 15] </ref>, down from O (nE) time using [14] or a combination of [6] and [11]); and a distributed from-scratch network synchronizer construction with ~ O (1) messages and space per edge (down from (n) time and space using [10, 11]). <p> (n 2 ) time and space using [11, 23]); sequential algorithms for approximating k-pairs shortest paths (see below and Section 6 for details); weight and distance-preserving graph spanners with ~ O (E) running time and space (see [6, 15], down from O (nE) time using [14] or a combination of <ref> [6] </ref> and [11]); and a distributed from-scratch network synchronizer construction with ~ O (1) messages and space per edge (down from (n) time and space using [10, 11]).
Reference: [7] <author> B. Awerbuch, B. Patt, D. Peleg, and M. Saks. </author> <title> Adapting to asynchronous dynamic networks with polylogarithmic overhead. </title> <booktitle> In Proc. 24th ACM Symp. on Theory of Computing, </booktitle> <pages> pages 557-570, </pages> <year> 1992. </year>
Reference-contexts: We also comment that the worst case running times of our new algorithms are superior to the expected running times of the best existing randomized algorithms for these tasks, using constructions of <ref> [20, 7] </ref>. We present two example applications in Section 6: online construction of adaptive routing schemes with compact tables, and approximating k-pairs shortest paths.
Reference: [8] <author> B. Awerbuch and D. Peleg. </author> <title> Routing with polynomial communication-space trade-off. </title> <type> Technical Memo TM-411, </type> <institution> MIT, Lab. for Computer Science, </institution> <month> Sept. </month> <year> 1989. </year>
Reference-contexts: Routing schemes have been around since [18, 19], but they have not been efficiently constructible until this paper. Many of the proposed schemes rely on the assumption of the existence of a data structure that can be constructed using small space <ref> [4, 22, 13, 8, 11] </ref>. However, the more efficient schemes of [8, 11] required linear space per node to set up the data structure. <p> Many of the proposed schemes rely on the assumption of the existence of a data structure that can be constructed using small space [4, 22, 13, 8, 11]. However, the more efficient schemes of <ref> [8, 11] </ref> required linear space per node to set up the data structure. This was a serious bottleneck, particularly in the adaptive scenario, since routing tables have to be recomputed every time there is a change in network topology (or traffic conditions). <p> However, these schemes feature an unfavorable (roughly speaking, exponential) tradeoff between their communication overheads and space requirements; using these schemes one can achieve stretch and memory requirements of around O (n 1 p log n ). The more efficient schemes of <ref> [8, 11] </ref> feature a polynomial trade-off, allowing ~ O (1) stretch and run-time memory. However, their preprocessing space requirements were high, namely O (n) per node, and in the adaptive model, this dominates the cost. <p> However, their preprocessing space requirements were high, namely O (n) per node, and in the adaptive model, this dominates the cost. The algorithms presented in this paper enable the best of both worlds, namely, the same trade-off as in <ref> [8, 11] </ref>, with preprocessing requiring the same amount of space as during run-time. 6.2 Approximate shortest paths The k-pairs shortest paths problem is: given an undirected graph with nonnegative edge weights, and k pairs of vertices, find the shortest paths between these pairs of vertices.
Reference: [9] <author> B. Awerbuch and D. Peleg. </author> <title> Efficient distributed construction of sparse covers. </title> <type> Technical Report CS90-17, </type> <institution> Weizmann Institute, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: We present two example applications in Section 6: online construction of adaptive routing schemes with compact tables, and approximating k-pairs shortest paths. Finally, it is worth mentioning that there exists a somewhat weaker notion of neighborhood covers: a small average degree cover <ref> [11, 9] </ref>, where the average cluster overlap over all nodes is small. In contrast, our neighborhood cover algorithm finds a solution with small maximum cluster overlap over all nodes.
Reference: [10] <author> B. Awerbuch and D. Peleg. </author> <title> Network synchronization with polylogarithmic overhead. </title> <booktitle> In Proc. 31st IEEE Symp. on Foundations of Computer Science, </booktitle> <pages> pages 514-522, </pages> <year> 1990. </year>
Reference-contexts: graph spanners with ~ O (E) running time and space (see [6, 15], down from O (nE) time using [14] or a combination of [6] and [11]); and a distributed from-scratch network synchronizer construction with ~ O (1) messages and space per edge (down from (n) time and space using <ref> [10, 11] </ref>). We also comment that the worst case running times of our new algorithms are superior to the expected running times of the best existing randomized algorithms for these tasks, using constructions of [20, 7].
Reference: [11] <author> B. Awerbuch and D. Peleg. </author> <title> Sparse partitions. </title> <booktitle> In Proc. 31st IEEE Symp. on Foundations of Computer Science, </booktitle> <pages> pages 503-513, </pages> <year> 1990. </year>
Reference-contexts: On the other hand, the entire network can be considered one giant cluster, where each node is in just the one cluster, but the diameter of this cluster can be as large as n. Awerbuch and Peleg <ref> [11] </ref> presented a general r-neighborhood cover construction with O (r log n) cluster diameter and O (log n) cluster overlap; it was also shown in [11] how to achieve an essentially optimal trade-off between these parameters. The Awerbuch-Peleg construction, however, takes O (nE) sequential and quadratic distributed time. <p> Awerbuch and Peleg <ref> [11] </ref> presented a general r-neighborhood cover construction with O (r log n) cluster diameter and O (log n) cluster overlap; it was also shown in [11] how to achieve an essentially optimal trade-off between these parameters. The Awerbuch-Peleg construction, however, takes O (nE) sequential and quadratic distributed time. In this paper, we present a new construction that achieves the optimal tradeoff in near-linear time. To achieve this, we abandon the "set coarsening" method of [11], and <p> in <ref> [11] </ref> how to achieve an essentially optimal trade-off between these parameters. The Awerbuch-Peleg construction, however, takes O (nE) sequential and quadratic distributed time. In this paper, we present a new construction that achieves the optimal tradeoff in near-linear time. To achieve this, we abandon the "set coarsening" method of [11], and instead show how to construct the cover only producing BFS trees from carefully selected vertices. The novel aspect of our approach is that the area of the BFS trees is carved out in such a way that one can bound the overlap with other BFS trees. <p> A sequential algorithm with running time and space O (E log n + n log 2 n). (Down from O (nE) time and space in <ref> [11] </ref>.) 2. A distributed asynchronous algorithm with O (log n) messages and space per edge. (Down from O (n) messages and space in [11].) We express all results in this paper in terms of the sequential running time, which is equivalent to the synchronous distributed implementation, where sequential running time becomes <p> A sequential algorithm with running time and space O (E log n + n log 2 n). (Down from O (nE) time and space in <ref> [11] </ref>.) 2. A distributed asynchronous algorithm with O (log n) messages and space per edge. (Down from O (n) messages and space in [11].) We express all results in this paper in terms of the sequential running time, which is equivalent to the synchronous distributed implementation, where sequential running time becomes distributed message complexity. The distributed space requirement will simply be the maximum overlap of the clusters. <p> (1) stretch and memory (down from O (n 1 p log n ) [5, 12]); small edge cuts in planar graphs in ~ O (E) running time and space (as a consequence of this paper and the algorithm in [23], down from O (n 2 ) time and space using <ref> [11, 23] </ref>); sequential algorithms for approximating k-pairs shortest paths (see below and Section 6 for details); weight and distance-preserving graph spanners with ~ O (E) running time and space (see [6, 15], down from O (nE) time using [14] or a combination of [6] and [11]); and a distributed from-scratch network <p> ) time and space using [11, 23]); sequential algorithms for approximating k-pairs shortest paths (see below and Section 6 for details); weight and distance-preserving graph spanners with ~ O (E) running time and space (see [6, 15], down from O (nE) time using [14] or a combination of [6] and <ref> [11] </ref>); and a distributed from-scratch network synchronizer construction with ~ O (1) messages and space per edge (down from (n) time and space using [10, 11]). <p> graph spanners with ~ O (E) running time and space (see [6, 15], down from O (nE) time using [14] or a combination of [6] and [11]); and a distributed from-scratch network synchronizer construction with ~ O (1) messages and space per edge (down from (n) time and space using <ref> [10, 11] </ref>). We also comment that the worst case running times of our new algorithms are superior to the expected running times of the best existing randomized algorithms for these tasks, using constructions of [20, 7]. <p> We present two example applications in Section 6: online construction of adaptive routing schemes with compact tables, and approximating k-pairs shortest paths. Finally, it is worth mentioning that there exists a somewhat weaker notion of neighborhood covers: a small average degree cover <ref> [11, 9] </ref>, where the average cluster overlap over all nodes is small. In contrast, our neighborhood cover algorithm finds a solution with small maximum cluster overlap over all nodes. <p> In contrast, our neighborhood cover algorithm finds a solution with small maximum cluster overlap over all nodes. The average degree cover problem is known to be significantly easier <ref> [11, 4] </ref>; in fact, the maximum degree cover algorithm in this paper works through a logarithmic number of it erations, each producing an average degree cover in the "remaining graph". <p> pairs shortest paths application, an average degree cover suffices and leads to a better tradeoff between running time and approximation; in particular, the constant of approximation can be improved by a constant factor. 1.2 Structure of this extended abstract In Section 2, we provide the graph-theoretic definition of neighborhood covers <ref> [11] </ref>. In Section 3, an overview of the new fast algorithm to construct the sparse neighborhood covers data structure is presented. A formal presentation of the algorithm that constructs the data structure is given in Section 4, and the analysis of the algorithm is in Section 5. <p> Finally, in Section 6 we present two sample applications. 2 Network decompositions: def initions The sparse neighborhood covers data structure was first introduced by <ref> [11] </ref> in the context of distributed computing. This paper achieves the first near-linear time construction of this data structure, thereby making it feasible for sequential computation. <p> Awerbuch and Peleg <ref> [11] </ref> presented the first (sequential) construction for a sparse neighborhood cover. <p> Routing schemes have been around since [18, 19], but they have not been efficiently constructible until this paper. Many of the proposed schemes rely on the assumption of the existence of a data structure that can be constructed using small space <ref> [4, 22, 13, 8, 11] </ref>. However, the more efficient schemes of [8, 11] required linear space per node to set up the data structure. <p> Many of the proposed schemes rely on the assumption of the existence of a data structure that can be constructed using small space [4, 22, 13, 8, 11]. However, the more efficient schemes of <ref> [8, 11] </ref> required linear space per node to set up the data structure. This was a serious bottleneck, particularly in the adaptive scenario, since routing tables have to be recomputed every time there is a change in network topology (or traffic conditions). <p> However, these schemes feature an unfavorable (roughly speaking, exponential) tradeoff between their communication overheads and space requirements; using these schemes one can achieve stretch and memory requirements of around O (n 1 p log n ). The more efficient schemes of <ref> [8, 11] </ref> feature a polynomial trade-off, allowing ~ O (1) stretch and run-time memory. However, their preprocessing space requirements were high, namely O (n) per node, and in the adaptive model, this dominates the cost. <p> However, their preprocessing space requirements were high, namely O (n) per node, and in the adaptive model, this dominates the cost. The algorithms presented in this paper enable the best of both worlds, namely, the same trade-off as in <ref> [8, 11] </ref>, with preprocessing requiring the same amount of space as during run-time. 6.2 Approximate shortest paths The k-pairs shortest paths problem is: given an undirected graph with nonnegative edge weights, and k pairs of vertices, find the shortest paths between these pairs of vertices.
Reference: [12] <author> B. Awerbuch and D. Peleg. </author> <title> Routing with polynomial communication space trade-off. </title> <journal> SIAM J. on Discr. Math., </journal> <note> 1991. To appear. Also in Technical Memo TM-411, </note> <institution> MIT, </institution> <month> Sept. </month> <year> 1989. </year>
Reference-contexts: These include adaptive routing schemes with ~ O (1) stretch and memory (down from O (n 1 p log n ) <ref> [5, 12] </ref>); small edge cuts in planar graphs in ~ O (E) running time and space (as a consequence of this paper and the algorithm in [23], down from O (n 2 ) time and space using [11, 23]); sequential algorithms for approximating k-pairs shortest paths (see below and Section 6
Reference: [13] <author> A. E. Baratz and J. M. Jaffe. </author> <title> Virtual circuits in large computer networks. </title> <booktitle> Computer Networks, </booktitle> <pages> pages 27-37, </pages> <month> Dec. </month> <year> 1986. </year>
Reference-contexts: Routing schemes have been around since [18, 19], but they have not been efficiently constructible until this paper. Many of the proposed schemes rely on the assumption of the existence of a data structure that can be constructed using small space <ref> [4, 22, 13, 8, 11] </ref>. However, the more efficient schemes of [8, 11] required linear space per node to set up the data structure.
Reference: [14] <author> B. Chandra, G. Das, G. Narasimhan, and J. Soares. </author> <title> New sparseness results on graph spanners. </title> <booktitle> In Proc. 8'th ACM Symposium on Computational Geometry, </booktitle> <year> 1993. </year>
Reference-contexts: in [23], down from O (n 2 ) time and space using [11, 23]); sequential algorithms for approximating k-pairs shortest paths (see below and Section 6 for details); weight and distance-preserving graph spanners with ~ O (E) running time and space (see [6, 15], down from O (nE) time using <ref> [14] </ref> or a combination of [6] and [11]); and a distributed from-scratch network synchronizer construction with ~ O (1) messages and space per edge (down from (n) time and space using [10, 11]).
Reference: [15] <author> E. Cohen. </author> <title> Fast algorithms for constructing t-spanners and paths with stretch t. </title> <booktitle> these proceedings, </booktitle> <year> 1993. </year>
Reference-contexts: a consequence of this paper and the algorithm in [23], down from O (n 2 ) time and space using [11, 23]); sequential algorithms for approximating k-pairs shortest paths (see below and Section 6 for details); weight and distance-preserving graph spanners with ~ O (E) running time and space (see <ref> [6, 15] </ref>, down from O (nE) time using [14] or a combination of [6] and [11]); and a distributed from-scratch network synchronizer construction with ~ O (1) messages and space per edge (down from (n) time and space using [10, 11]). <p> Moreover, average degree covers are not sufficient for an efficient solution to the k-pairs shortest paths problem, because the "imbalance" (high and low overlaps) cannot be amortized over many queries. (Unlike the algorithms in this paper, other con structions of average degree covers <ref> [1, 15] </ref> cannot be run for multiple iterations to produce a small maximum degree cover.) However, as Afek et al. [1] and Cohen [15] have pointed out, in the special case of the all - pairs shortest paths application, an average degree cover suffices and leads to a better tradeoff between <p> problem, because the "imbalance" (high and low overlaps) cannot be amortized over many queries. (Unlike the algorithms in this paper, other con structions of average degree covers [1, 15] cannot be run for multiple iterations to produce a small maximum degree cover.) However, as Afek et al. [1] and Cohen <ref> [15] </ref> have pointed out, in the special case of the all - pairs shortest paths application, an average degree cover suffices and leads to a better tradeoff between running time and approximation; in particular, the constant of approximation can be improved by a constant factor. 1.2 Structure of this extended abstract <p> Note that we can achieve a better running time than known exact algorithms even for paths that are only a constant factor times the length of the shortest path. Fur ther work in this direction is reported in <ref> [15] </ref>. Acknowledgments We thank Yehuda Afek, Edith Cohen, Tom Leighton and Moti Ricklin for stimulating discussions.
Reference: [16] <author> T. H. Cormen, C. E. Leiserson, and R. L. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> MIT Press/McGraw-Hill, </publisher> <year> 1990. </year>
Reference-contexts: The best-known bounds for exact k-pairs shortest paths run Dijkstra's algorithm in time O (kE log n) with a binary heap implementation <ref> [16] </ref>, in time O (kn log n + kE) with a Fi-bonacci heap implementation [17], or compute all-pairs shortest paths via matrix multiplication in ~ O (M (n)) time, where M (n) is the time for matrix multiplication (currently known to be o (n 2:376 )); for example, see [2, 24,
Reference: [17] <author> M. Fredman and R. E. Tarjan. </author> <title> Fibonacci heaps and their uses in improved network optimization algorithms. </title> <journal> J. of the ACM, </journal> <pages> pages 596-615, </pages> <year> 1987. </year>
Reference-contexts: The best-known bounds for exact k-pairs shortest paths run Dijkstra's algorithm in time O (kE log n) with a binary heap implementation [16], in time O (kn log n + kE) with a Fi-bonacci heap implementation <ref> [17] </ref>, or compute all-pairs shortest paths via matrix multiplication in ~ O (M (n)) time, where M (n) is the time for matrix multiplication (currently known to be o (n 2:376 )); for example, see [2, 24, 3].
Reference: [18] <author> L. Kleinrock and F. Kamoun. </author> <title> Hierarchical routing for large networks; performance evaluation and optimization. </title> <journal> Computer Networks, </journal> <volume> 1 </volume> <pages> 155-174, </pages> <year> 1977. </year>
Reference-contexts: Routing schemes have been around since <ref> [18, 19] </ref>, but they have not been efficiently constructible until this paper. Many of the proposed schemes rely on the assumption of the existence of a data structure that can be constructed using small space [4, 22, 13, 8, 11].
Reference: [19] <author> L. Kleinrock and F. Kamoun. </author> <title> Optimal clustering structures for hierarchical topological design of large computer networks. </title> <journal> Computer Networks, </journal> <volume> 10 </volume> <pages> 221-248, </pages> <year> 1980. </year>
Reference-contexts: Routing schemes have been around since <ref> [18, 19] </ref>, but they have not been efficiently constructible until this paper. Many of the proposed schemes rely on the assumption of the existence of a data structure that can be constructed using small space [4, 22, 13, 8, 11].
Reference: [20] <author> N. Linial and M. Saks. </author> <title> Decomposing graphs into regions of small diameter. </title> <booktitle> In Proc. 2nd ACM-SIAM Symp. on Discrete Algorithms, </booktitle> <pages> pages 320-330. </pages> <address> ACM/SIAM, </address> <month> Jan. </month> <year> 1991. </year>
Reference-contexts: We also comment that the worst case running times of our new algorithms are superior to the expected running times of the best existing randomized algorithms for these tasks, using constructions of <ref> [20, 7] </ref>. We present two example applications in Section 6: online construction of adaptive routing schemes with compact tables, and approximating k-pairs shortest paths. <p> each vertex is contained in at most c log n sets, where c &gt; 0: We remark that the diameter/sparsity tradeoff in this definition is tight to within a constant factor; there exist graphs for which any (log n; r)-neighborhood cover places some vertex in at least (log n) sets <ref> [20] </ref>. Awerbuch and Peleg [11] presented the first (sequential) construction for a sparse neighborhood cover.
Reference: [21] <author> D. Peleg. </author> <title> Distance-dependent distributed directories. </title> <journal> Info. and Computation, </journal> <note> 1993. Also in Tech. Report CS89-10, </note> <institution> The Weizmann Institute, </institution> <month> May 89. </month>
Reference-contexts: neighborhood cover in time O (E log n + n log n). 6 Example applications 6.1 Routing As a typical example of how to apply the network decomposition data structure in the distributed domain, we focus on a classic network application: online construction of adaptive routing schemes with compact tables <ref> [4, 5, 21] </ref>. Routing schemes have been around since [18, 19], but they have not been efficiently constructible until this paper. Many of the proposed schemes rely on the assumption of the existence of a data structure that can be constructed using small space [4, 22, 13, 8, 11].
Reference: [22] <author> D. Peleg and E. Upfal. </author> <title> A tradeoff between size and efficiency for routing tables. </title> <journal> J. of the ACM, </journal> <volume> 36 </volume> <pages> 510-530, </pages> <year> 1989. </year>
Reference-contexts: Routing schemes have been around since [18, 19], but they have not been efficiently constructible until this paper. Many of the proposed schemes rely on the assumption of the existence of a data structure that can be constructed using small space <ref> [4, 22, 13, 8, 11] </ref>. However, the more efficient schemes of [8, 11] required linear space per node to set up the data structure.
Reference: [23] <author> S. Rao. </author> <title> Finding small edge cuts in planar graphs. </title> <booktitle> In Proc. 24th ACM Symp. on Theory of Computing, </booktitle> <pages> pages 229-240, </pages> <year> 1992. </year>
Reference-contexts: These include adaptive routing schemes with ~ O (1) stretch and memory (down from O (n 1 p log n ) [5, 12]); small edge cuts in planar graphs in ~ O (E) running time and space (as a consequence of this paper and the algorithm in <ref> [23] </ref>, down from O (n 2 ) time and space using [11, 23]); sequential algorithms for approximating k-pairs shortest paths (see below and Section 6 for details); weight and distance-preserving graph spanners with ~ O (E) running time and space (see [6, 15], down from O (nE) time using [14] or <p> (1) stretch and memory (down from O (n 1 p log n ) [5, 12]); small edge cuts in planar graphs in ~ O (E) running time and space (as a consequence of this paper and the algorithm in [23], down from O (n 2 ) time and space using <ref> [11, 23] </ref>); sequential algorithms for approximating k-pairs shortest paths (see below and Section 6 for details); weight and distance-preserving graph spanners with ~ O (E) running time and space (see [6, 15], down from O (nE) time using [14] or a combination of [6] and [11]); and a distributed from-scratch network
Reference: [24] <author> R. Seidel. </author> <title> On the all-pairs-shortest-path problem. </title> <booktitle> In Proc. 24th ACM Symp. on Theory of Computing, </booktitle> <pages> pages 745-749, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: implementation [16], in time O (kn log n + kE) with a Fi-bonacci heap implementation [17], or compute all-pairs shortest paths via matrix multiplication in ~ O (M (n)) time, where M (n) is the time for matrix multiplication (currently known to be o (n 2:376 )); for example, see <ref> [2, 24, 3] </ref>. The bottlenecks in the running time of the exact algorithms come either from repeated application of Dijkstra's single source shortest paths algorithm or from matrix multiplication.
References-found: 24

