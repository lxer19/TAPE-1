URL: http://seclab.cs.ucdavis.edu/~samorodi/papers/USENIX/pldi96-omniware.ps
Refering-URL: http://seclab.cs.ucdavis.edu/~samorodi/papers/USENIX/
Root-URL: http://www.cs.ucdavis.edu
Title: Efficient and Language-Independent Mobile Programs  
Author: Ali-Reza Adl-Tabatabai Geoff Langdale Steven Lucco and Robert Wahbe 
Address: 1563 Solano Ave. MS-350 Pittsburgh, PA 5213 Berkeley, CA 94707  
Affiliation: 1 School of Computer Science 2 Colusa Software Carnegie Mellon University  
Note: To appear in the Proceedings of PLDI'96, ACM SIGPLAN'96 Conf. on Programming Language Design and Implementation, May 1996, Philadelphia, PA  
Abstract: This paper evaluates the design and implementation of Omni-ware: a safe, efficient, and language-independent system for executing mobile program modules. Previous approaches to implementing mobile code rely on either language semantics or abstract machine interpretation to enforce safety. In the former case, the mobile code system sacrifices universality to gain safety by dictating a particular source language or type system. In the latter case, the mobile code system sacrifices performance to gain safety through abstract machine interpretation. Omniware uses software fault isolation, a technology developed to provide safe extension code for databases and operating systems, to achieve a unique combination of language-independence and excellent performance. Software fault isolation uses only the semantics of the underlying processor to determine whether a mobile code module can corrupt its execution environment. This separation of programming language implementation from program module safety enables our mobile code system to use a radically simplified virtual machine as its basis for portability. We measured the performance of Omniware using a suite of four SPEC92 programs on the Pentium, PowerPC, Mips, and Sparc processor architectures. Including the overhead for enforcing safety on all four processors, OmniVM executed the benchmark programs within 21% as fast as the optimized, unsafe code produced by the vendor-supplied compiler. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. Andrews and D. </author> <title> Sand. Migrating a CISC computer family onto RISC via object code translation. </title> <booktitle> In Proceedings of the 5th International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 213-222, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: OmniVM differs from Mahler in the far wider range of architectures it supports, and the requirement for safe execution. Similarly, the Taos operating system [34] defines as its compiler target the Taos Virtual Processor, which, like Mahler, is an attempt to support multi-platform optimization. Binary translation systems <ref> [1] </ref> address the problem of migrating existing native code from one platform to another. A similar approach is the idea of fat binaries, where the compiler generates an object file containing multiple text sections one for each of the target architectures. Neither of these methods address the issue of safety.
Reference: [2] <author> D. Bacon, S. Graham, and O. Sharp. </author> <title> Compiler transformations for high-performance computing. </title> <journal> ACM Comput. Surv., </journal> <volume> 26(4) </volume> <pages> 345-420, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: Hence, a compiler can perform a great deal of machine-independent optimization (such as register allocation, constant folding, constant propagation, and strength reduction <ref> [2] </ref>) prior to module load time. This is important in many mobile code contexts such as Web pages where load time, and hence optimization during loading, must be minimized. Section 4 demonstrates quantitatively that compilers can substantially optimize OmniVM modules prior to load time.
Reference: [3] <author> H. Bal, A. Tanenbaum, and M. Kaashoek. ORCA: </author> <title> a language for distributed programming. </title> <journal> SIGPLAN Notices, </journal> <volume> 25(5) </volume> <pages> 17-24, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: Similarly, distributed object-oriented database systems [4] use method invocation as a basis for data queries. In the absence of mobile code, these systems must manage heterogeneous binaries for each dynamically created data class. Because of these requirements, several languages for programming distributed systems, such as Orca <ref> [3] </ref> and Emerald [36], incorporate mobile code as a fundamental programming construct. The mobile code systems introduced to date have used one of two methods for enforcing safe execution: abstract machine interpretation or language semantics. Abstract machine interpreters [12] trade performance for safety.
Reference: [4] <author> J. Bennerjee, W. Kim, H. Kim, and H. Korth. </author> <title> Semantics and implementation of scheme evolution in object-oriented databases. </title> <booktitle> In Proc. ACM SIGMOD Conference, </booktitle> <pages> pages 311-322, </pages> <month> December </month> <year> 1987. </year>
Reference-contexts: Moreover, multi-platform operating systems, such as Mi-crosoft Windows NT [31], when combined with network file systems, require either cumbersome management of processor-specific binaries or some form of mobile code. Similarly, distributed object-oriented database systems <ref> [4] </ref> use method invocation as a basis for data queries. In the absence of mobile code, these systems must manage heterogeneous binaries for each dynamically created data class.
Reference: [5] <author> T. Berners-Lee, R. Fielding, and H. Nielsen. </author> <note> HTTP/1.0 Internet Draft 04, </note> <month> October </month> <year> 1995. </year> <title> Internet Draft (work in progress). </title>
Reference-contexts: Currently, the most visible computer application requiring mobile code is executable content for electronic documents. While documents containing executable content have been around for at least two decades [46, 13], the combination of electronic documents with widely adopted network protocols <ref> [5] </ref> on the Internet requires mobile executable document content. Because mobile programs are often untrusted, safety is an essential feature of any mobile code system. The system must maintain precise control over a mobile code module's access to the resources of its execution environment.
Reference: [6] <author> D. Bernstein and M. Rodeh. </author> <title> Global instruction scheduling for superscalar machines. </title> <booktitle> In Proceedings of the SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 241-255, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: The PowerPC has a few features that are unusually challenging for code generators, specifically, auto-update addressing modes, branch-and-decrement instructions and multiple condition registers. Effective use of these features can result in substantial speed-ups [22], especially when the compiler performs global instruction scheduling <ref> [6] </ref>. We are currently enhancing our translators with global instruction scheduling and a framework for machine-dependent peephole optimizations. We expect these improvements to bring the performance of translated code on the PowerPC in line with that of the other two RISC processors.
Reference: [7] <author> N. Borenstein. </author> <title> EMail with a mind of its own: The Safe-Tcl language for enabled mail. </title> <booktitle> In IFIP Working Group 6.5 Conference, </booktitle> <month> May </month> <year> 1994. </year>
Reference-contexts: No performance evaluations have been released for Java, so it is difficult to evaluate the performance of the Java compiler or interpreter. Some mobile code systems rely entirely on interpretation of source code at the host. Many scripting languages are in this category, including safe variants of Perl, Tcl <ref> [7] </ref> and Python [41]. These language-specific mobile code systems are useful for certain unstructured tasks such as parsing user input, but they require software distribution in source form and their performance is limited.
Reference: [8] <author> M. Burke and L. Torczon. </author> <title> Interprocedural optimization: eliminating unnecessary recompilation. </title> <journal> ACM Transactions on Programming Languagesand Systems, </journal> <volume> 15(3) </volume> <pages> 367-399, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: Typically, compilers target an entire architecture family, not a particular processor implementation. Several studies suggest that we can significantly improve performance using this information <ref> [27, 44, 8] </ref>. In addition, our results suggest several simple steps towards this goal. First, implementing a global pointer can significantly improve performance. The performance improvement resulting from implementing a global pointer on the Sparc confirms this assertion.
Reference: [9] <author> L. Cardelli, J. Donahue, L. Glassman, M. Jordan, B. Kalsow, and G. Nelson. </author> <title> Modula-3 language definition. </title> <journal> SIGPLAN Notices, </journal> <volume> 27(8), </volume> <month> August </month> <year> 1992. </year>
Reference-contexts: This mechanism is effective and language-independent, but inherently slow. A mobile code system can use language semantics to enforce safety by guaranteeing that a program can't affect resources that it can't name <ref> [38, 9, 40] </ref>. Though rare in current practice, it is possible to achieve good performance using this approach if the compiler intermediate representation retains type information [23, 39]. However, this approach works through restriction.
Reference: [10] <author> B. </author> <title> Case. Intel reveals Pentium implementation details. </title> <type> Microprocessor Report, </type> <pages> pages 9-17, </pages> <month> March </month> <year> 1993. </year>
Reference-contexts: Using a RISC-like virtual machine also yields competitive x86 code. A number of superscalar implementations of the x86 architecture provide a RISC core instruction set. For instance, Intel's Pentium <ref> [10] </ref> and Pentium Pro [20], AMD's K5 [35], and NexGen's Nx686 [21] processors are superscalar implementations of the x86 architecture, that can concurrently dispatch only RISC-like instructions [25].
Reference: [11] <author> F. Chow, S. Correll, M. Himelstein, E. Killian, and L. Weber. </author> <booktitle> How many addressing modes are enough? In Proceedings of the 2nd International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 117-121, </pages> <month> October </month> <year> 1987. </year>
Reference-contexts: On a CISC machine such as the x86, a single instruction will suffice. On a RISC machine, the translator typically generates one additional instruction for address calculation. Section 4 shows the overhead introduced through using large address offsets and how, by using a global pointer <ref> [11] </ref>, we can eliminate the bulk of this overhead. In contrast, if OmniVM were to restrict the size of address offsets, the compiler would generate additional address calculation instructions; further, an optimizing compiler might move these instructions across basic blocks.
Reference: [12] <author> K. Chung and H. Yuen. </author> <title> A tiny Pascal compiler. </title> <journal> Byte, </journal> <volume> 39(9) </volume> <pages> 58-64, </pages> <month> September </month> <year> 1978. </year>
Reference-contexts: The mobile code systems introduced to date have used one of two methods for enforcing safe execution: abstract machine interpretation or language semantics. Abstract machine interpreters <ref> [12] </ref> trade performance for safety. A mobile code system based around an abstract machine consists of a compiler for some number of source languages coupled with an interpreter for the abstract machine. <p> Omniware's overhead of only 10-20% makes it an order of magnitude faster than any other uni-versal mobile code system, because other universal systems must rely on abstract machine interpretation to enforce safety <ref> [12, 32] </ref>. For many applications of mobile code, such as executable content for Internet documents, our current performance is sufficient.
Reference: [13] <institution> Compton's Interactive Encyclopedia, </institution> <year> 1995. </year>
Reference-contexts: Currently, the most visible computer application requiring mobile code is executable content for electronic documents. While documents containing executable content have been around for at least two decades <ref> [46, 13] </ref>, the combination of electronic documents with widely adopted network protocols [5] on the Internet requires mobile executable document content. Because mobile programs are often untrusted, safety is an essential feature of any mobile code system.
Reference: [14] <author> J. Strong et. al. </author> <title> The problem of programming communication with changing machines. </title> <journal> Communications of the ACM, </journal> <volume> 1(8) </volume> <pages> 12-18, </pages> <month> August </month> <year> 1958. </year>
Reference-contexts: Neither of these methods address the issue of safety. The ANDF [29] project is a recent attempt to standardize a universal intermediate language for software distribution <ref> [14] </ref>. ANDF's intermediate representation comprises typed expression trees. This representation is at a higher level than the OmniVM, and more work is required to translate it to native code.
Reference: [15] <author> M. Franz. </author> <title> Code-Generation On-the-Fly: A Key to Portable Software. </title> <type> PhD thesis, </type> <institution> Swiss Federal Institute of Technology Zurich, </institution> <year> 1994. </year> <note> Diss. ETH No. 10497. </note>
Reference-contexts: Thus, this representation is less suitable for applications where speed of translation is important, and will not benefit as much from compiler optimizations as OmniVM does. The OMI project <ref> [15] </ref> uses a similar approach. Telescript [26] and Java [19] are two mobile code systems that achieve portability and safety by compiling to a machine-independent intermediate representation. Telescript enforces safety in its interpreter. Java depends on a type system for mobile code safety.
Reference: [16] <author> C. Fraser and D. Hanson. </author> <title> A retargetable compiler for ANSI C. </title> <journal> SIGPLAN Notices, </journal> <volume> 26(10) </volume> <pages> 29-43, </pages> <month> Oct </month> <year> 1991. </year>
Reference-contexts: This design choice has two advantages. First, it simplifies the implementation of compilers to OmniVM and translators from OmniVM. For example, we retargeted both gcc [17] and lcc <ref> [16] </ref> to OmniVM within two months. Second, the use of simple instructions gives the source language compiler more opportunity for optimization because more aspects (such as data layout) of the final code are defined by the compiler.
Reference: [17] <author> Gcc, </author> <year> 1994. </year> <title> Free Software Foundation. </title>
Reference-contexts: This design choice has two advantages. First, it simplifies the implementation of compilers to OmniVM and translators from OmniVM. For example, we retargeted both gcc <ref> [17] </ref> and lcc [16] to OmniVM within two months. Second, the use of simple instructions gives the source language compiler more opportunity for optimization because more aspects (such as data layout) of the final code are defined by the compiler.
Reference: [18] <author> J. Gosling. </author> <title> Java intermediate bytecodes. </title> <booktitle> In ACM SIGPLAN Workshop on Intermediate Representations (IR '95), </booktitle> <pages> pages 111-118, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: A virtual machine implementing this type system can check whether this promise is kept and reject programs that perform type-violating operations <ref> [18] </ref>. Hence, a mobile code system that uses language semantics to enforce safety sacrifices universality. This has two drawbacks. First, type-based mobile code systems can't implement type-unsafe languages such as C, C++, Pascal, Common Lisp, and Fortran. <p> Telescript enforces safety in its interpreter. Java depends on a type system for mobile code safety. Java's intermediate representation is tailored for fast interpretation by a stack machine <ref> [18] </ref>, and, because it defers decisions such as data layout, requires more work than OmniVM to translate into efficient machine code. No performance evaluations have been released for Java, so it is difficult to evaluate the performance of the Java compiler or interpreter.
Reference: [19] <author> J. Gosling and H. McGilton. </author> <title> The Java language environment: A white paper, 1995. Sun Microsystems, </title> <publisher> Inc. </publisher>
Reference-contexts: Thus, this representation is less suitable for applications where speed of translation is important, and will not benefit as much from compiler optimizations as OmniVM does. The OMI project [15] uses a similar approach. Telescript [26] and Java <ref> [19] </ref> are two mobile code systems that achieve portability and safety by compiling to a machine-independent intermediate representation. Telescript enforces safety in its interpreter. Java depends on a type system for mobile code safety.
Reference: [20] <author> L. Gwennap. </author> <title> Intel's P6 uses decoupled superscalar design. </title> <type> Microprocessor Report, </type> <pages> pages 9-15, </pages> <month> February </month> <year> 1995. </year>
Reference-contexts: Using a RISC-like virtual machine also yields competitive x86 code. A number of superscalar implementations of the x86 architecture provide a RISC core instruction set. For instance, Intel's Pentium [10] and Pentium Pro <ref> [20] </ref>, AMD's K5 [35], and NexGen's Nx686 [21] processors are superscalar implementations of the x86 architecture, that can concurrently dispatch only RISC-like instructions [25].
Reference: [21] <author> L. Gwennap. </author> <title> Nx686 goes toe-to-toe with Pentium Pro. </title> <type> Microprocessor Report, </type> <pages> pages 1-10, </pages> <month> October </month> <year> 1995. </year>
Reference-contexts: Using a RISC-like virtual machine also yields competitive x86 code. A number of superscalar implementations of the x86 architecture provide a RISC core instruction set. For instance, Intel's Pentium [10] and Pentium Pro [20], AMD's K5 [35], and NexGen's Nx686 <ref> [21] </ref> processors are superscalar implementations of the x86 architecture, that can concurrently dispatch only RISC-like instructions [25].
Reference: [22] <author> C. B. Hall and K. O'Brien. </author> <title> Performance characteristics of architectural features of the IBM RISC System/6000. </title> <booktitle> In Proceedings of the 4th International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 303-309, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: The PowerPC has a few features that are unusually challenging for code generators, specifically, auto-update addressing modes, branch-and-decrement instructions and multiple condition registers. Effective use of these features can result in substantial speed-ups <ref> [22] </ref>, especially when the compiler performs global instruction scheduling [6]. We are currently enhancing our translators with global instruction scheduling and a framework for machine-dependent peephole optimizations.
Reference: [23] <author> R. Harper and P. Lee. </author> <title> Advanced languages for systems software: The Fox project in 1994. </title> <type> Technical report, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> January </month> <year> 1994. </year> <note> techreport CMU-CS-FOX-94-01. </note>
Reference-contexts: A mobile code system can use language semantics to enforce safety by guaranteeing that a program can't affect resources that it can't name [38, 9, 40]. Though rare in current practice, it is possible to achieve good performance using this approach if the compiler intermediate representation retains type information <ref> [23, 39] </ref>. However, this approach works through restriction. For example, a strongly-typed intermediate language might promise through the type system that integer arithmetic will not be performed on a particular value, because the value has a pointer type.
Reference: [24] <author> Intel. </author> <title> Optimizations for Intel's 32-Bit Processors. Application Note AP-500, </title> <institution> Intel Corp., </institution> <month> February </month> <year> 1994. </year>
Reference-contexts: An Intel application note describing instruction selection and scheduling for the Pentium processor, advises against selecting complex instructions and suggests using a load/store model of instruction selection <ref> [24] </ref>. 3.2 Register file organization The OmniVM has 16 integer registers and 16 floating-point registers. On the RISC targets, the OmniVM registers are mapped directly onto physical registers, while on the x86, some registers are mapped to memory locations.
Reference: [25] <author> K. Johnson. </author> <title> RISC-like design fares well for x86 CPUs. </title> <type> Microprocessor Report, </type> <pages> pages 26-27, </pages> <month> November </month> <year> 1995. </year>
Reference-contexts: A number of superscalar implementations of the x86 architecture provide a RISC core instruction set. For instance, Intel's Pentium [10] and Pentium Pro [20], AMD's K5 [35], and NexGen's Nx686 [21] processors are superscalar implementations of the x86 architecture, that can concurrently dispatch only RISC-like instructions <ref> [25] </ref>. An Intel application note describing instruction selection and scheduling for the Pentium processor, advises against selecting complex instructions and suggests using a load/store model of instruction selection [24]. 3.2 Register file organization The OmniVM has 16 integer registers and 16 floating-point registers.
Reference: [26] <author> S. Knaster. </author> <title> Magic Cap concepts, </title> <month> May </month> <year> 1995. </year> <title> General Magic, </title> <publisher> Inc. </publisher>
Reference-contexts: Thus, this representation is less suitable for applications where speed of translation is important, and will not benefit as much from compiler optimizations as OmniVM does. The OMI project [15] uses a similar approach. Telescript <ref> [26] </ref> and Java [19] are two mobile code systems that achieve portability and safety by compiling to a machine-independent intermediate representation. Telescript enforces safety in its interpreter. Java depends on a type system for mobile code safety.
Reference: [27] <author> M. Lam, E. Rothberg, and M. Wolf. </author> <title> The cache performance and optimizations of blocked algorithms. </title> <booktitle> In Proceedings of the 4th International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 63-74, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: However, we plan to add the capability for aggressive optimization to our translators, including global optimizations, link-level (interprocedural) optimizations, and chip-specific transformations such as global instruction scheduling, instruction combination and the organization of code and data to fit cache capacity and layout <ref> [27] </ref>. By adding these capabilities, we hope to make the Omniware system suitable for tasks such as general software distribution. <p> Typically, compilers target an entire architecture family, not a particular processor implementation. Several studies suggest that we can significantly improve performance using this information <ref> [27, 44, 8] </ref>. In addition, our results suggest several simple steps towards this goal. First, implementing a global pointer can significantly improve performance. The performance improvement resulting from implementing a global pointer on the Sparc confirms this assertion.
Reference: [28] <author> S. Lucco, O. Sharp, and R. Wahbe. Omniware: </author> <title> A universal substrate for web programming. </title> <booktitle> In Fourth International World Wide Web Conference, </booktitle> <month> December </month> <year> 1995. </year>
Reference-contexts: We call the computer application that loads a mobile code module the host. To achieve safety, it is necessary for the mobile code mechanism to prevent a faulty or malicious module from corrupting host data or calling unauthorized host functions. Our mobile code system, Omniware <ref> [28] </ref>, uses software fault isolation (SFI) to enforce safety [42]. SFI enables mutually distrustful program modules to safely share an address space. Table 1 summarizes the Omniware performance for four SPEC92 programs; Section 4 provides detailed performance results.
Reference: [29] <author> S. Macrakis. </author> <title> From UNCOL to ANDF: Progress in standard intermedia languages, 1993. Open Software Foundation. </title>
Reference-contexts: A similar approach is the idea of fat binaries, where the compiler generates an object file containing multiple text sections one for each of the target architectures. Neither of these methods address the issue of safety. The ANDF <ref> [29] </ref> project is a recent attempt to standardize a universal intermediate language for software distribution [14]. ANDF's intermediate representation comprises typed expression trees. This representation is at a higher level than the OmniVM, and more work is required to translate it to native code.
Reference: [30] <author> B. Noble, M. Price, and M. Satyanarayanan. </author> <title> A programming interface for application-aware adaptation in mobile computing. </title> <booktitle> In Proceedings of the Second USENIX Symposium on Mobile and Location-Independent Computing, </booktitle> <month> April </month> <year> 1995. </year>
Reference-contexts: This document does not provide an express or implied warranty for any Colusa product or license to any Colusa intellectual property. 2 Background In the software industry, the need for mobile code is increasingly widespread. For example, distributed database systems [37] and file systems <ref> [30] </ref> require safe function shipping to achieve scalability. An e-mail client can ship a mail-filtering function to a server to reduce server bandwidth requirements. A file system server can ship a decompression function to a client to offload its processing.
Reference: [31] <institution> Windows NT Workstation 3.51 Product Overview, 1995. Mi-crosoft Corporation. </institution>
Reference-contexts: An e-mail client can ship a mail-filtering function to a server to reduce server bandwidth requirements. A file system server can ship a decompression function to a client to offload its processing. Moreover, multi-platform operating systems, such as Mi-crosoft Windows NT <ref> [31] </ref>, when combined with network file systems, require either cumbersome management of processor-specific binaries or some form of mobile code. Similarly, distributed object-oriented database systems [4] use method invocation as a basis for data queries.
Reference: [32] <author> J. Ousterhout. </author> <title> TCL: An embeddable command language. </title> <booktitle> In Proceedings of the 1990 Usenix Winter Conference, </booktitle> <pages> pages 22-26, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Omniware's overhead of only 10-20% makes it an order of magnitude faster than any other uni-versal mobile code system, because other universal systems must rely on abstract machine interpretation to enforce safety <ref> [12, 32] </ref>. For many applications of mobile code, such as executable content for Internet documents, our current performance is sufficient.
Reference: [33] <author> D. Patterson. </author> <title> Reduced instruction set computers. </title> <journal> Communications of the ACM, </journal> <volume> 28(1) </volume> <pages> 8-21, </pages> <month> January </month> <year> 1985. </year>
Reference-contexts: This separation of programming language implementation from program module safety enables Omniware to use a radically simplified (RISC-like) virtual machine as its basis for portability <ref> [33] </ref>. This design choice has two advantages. First, it simplifies the implementation of compilers to OmniVM and translators from OmniVM. For example, we retargeted both gcc [17] and lcc [16] to OmniVM within two months.
Reference: [34] <author> D. Pountain. </author> <title> Parallel course. </title> <journal> Byte, </journal> <volume> 19(7) </volume> <pages> 53-60, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: Designed for portable optimization rather than mobile code, Mahler [45] defines a virtual machine that abstracts over the details of several different Titan processor implementations. OmniVM differs from Mahler in the far wider range of architectures it supports, and the requirement for safe execution. Similarly, the Taos operating system <ref> [34] </ref> defines as its compiler target the Taos Virtual Processor, which, like Mahler, is an attempt to support multi-platform optimization. Binary translation systems [1] address the problem of migrating existing native code from one platform to another.
Reference: [35] <author> M. Slater. </author> <title> AMD's K5 designed to outrun Pentium. </title> <type> Microprocessor Report, </type> <pages> pages 1-11, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: Using a RISC-like virtual machine also yields competitive x86 code. A number of superscalar implementations of the x86 architecture provide a RISC core instruction set. For instance, Intel's Pentium [10] and Pentium Pro [20], AMD's K5 <ref> [35] </ref>, and NexGen's Nx686 [21] processors are superscalar implementations of the x86 architecture, that can concurrently dispatch only RISC-like instructions [25].
Reference: [36] <author> B. Steensgaard and E. </author> <month> Jul. </month> <title> Object and native code thread mobility among heterogeneous computers. </title> <booktitle> In Proceedings of the 15th ACM Symposium on Operating Systems Principles, </booktitle> <month> December </month> <year> 1995. </year>
Reference-contexts: Similarly, distributed object-oriented database systems [4] use method invocation as a basis for data queries. In the absence of mobile code, these systems must manage heterogeneous binaries for each dynamically created data class. Because of these requirements, several languages for programming distributed systems, such as Orca [3] and Emerald <ref> [36] </ref>, incorporate mobile code as a fundamental programming construct. The mobile code systems introduced to date have used one of two methods for enforcing safe execution: abstract machine interpretation or language semantics. Abstract machine interpreters [12] trade performance for safety.
Reference: [37] <author> M. Stonebraker and G. Kemnitz. </author> <title> The POSTGRES next-generation database management system. </title> <journal> Communications of the ACM, </journal> <volume> 34(10) </volume> <pages> 78-92, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: This document does not provide an express or implied warranty for any Colusa product or license to any Colusa intellectual property. 2 Background In the software industry, the need for mobile code is increasingly widespread. For example, distributed database systems <ref> [37] </ref> and file systems [30] require safe function shipping to achieve scalability. An e-mail client can ship a mail-filtering function to a server to reduce server bandwidth requirements. A file system server can ship a decompression function to a client to offload its processing.
Reference: [38] <author> R. Sweet. </author> <title> The Mesa programming environment. </title> <booktitle> In Proceedings SIGPLAN Symposium on Language Issues in Programming Environments, </booktitle> <pages> pages 216-229, </pages> <month> July </month> <year> 1985. </year>
Reference-contexts: This mechanism is effective and language-independent, but inherently slow. A mobile code system can use language semantics to enforce safety by guaranteeing that a program can't affect resources that it can't name <ref> [38, 9, 40] </ref>. Though rare in current practice, it is possible to achieve good performance using this approach if the compiler intermediate representation retains type information [23, 39]. However, this approach works through restriction.
Reference: [39] <author> D. Tarditi, G. Morrisett, P. Cheng, C. Stone, R. Harper, and P. Lee. </author> <title> TIL: A type-directed optimizing compiler for ML. </title> <booktitle> In Proceedings of the ACM SIGPLAN '96 Conference on Programming Languages Design and Implementation. ACM, </booktitle> <month> May </month> <year> 1996. </year> <note> To appear. </note>
Reference-contexts: A mobile code system can use language semantics to enforce safety by guaranteeing that a program can't affect resources that it can't name [38, 9, 40]. Though rare in current practice, it is possible to achieve good performance using this approach if the compiler intermediate representation retains type information <ref> [23, 39] </ref>. However, this approach works through restriction. For example, a strongly-typed intermediate language might promise through the type system that integer arithmetic will not be performed on a particular value, because the value has a pointer type.
Reference: [40] <author> J. Ullman. </author> <title> Elements of ML programming. </title> <publisher> Prentice Hall, </publisher> <year> 1994. </year>
Reference-contexts: This mechanism is effective and language-independent, but inherently slow. A mobile code system can use language semantics to enforce safety by guaranteeing that a program can't affect resources that it can't name <ref> [38, 9, 40] </ref>. Though rare in current practice, it is possible to achieve good performance using this approach if the compiler intermediate representation retains type information [23, 39]. However, this approach works through restriction.
Reference: [41] <author> G. van Rossum. </author> <title> Python tutorial, </title> <month> October </month> <year> 1995. </year> <note> Online at: http://www.python.org/doc/tut/tut.html. </note>
Reference-contexts: Some mobile code systems rely entirely on interpretation of source code at the host. Many scripting languages are in this category, including safe variants of Perl, Tcl [7] and Python <ref> [41] </ref>. These language-specific mobile code systems are useful for certain unstructured tasks such as parsing user input, but they require software distribution in source form and their performance is limited.
Reference: [42] <author> R. Wahbe, S. Lucco, T. Anderson, and S. Graham. </author> <title> Efficent software-based fault isolation. </title> <booktitle> In Proceedings of the 14th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 203-216, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: To achieve safety, it is necessary for the mobile code mechanism to prevent a faulty or malicious module from corrupting host data or calling unauthorized host functions. Our mobile code system, Omniware [28], uses software fault isolation (SFI) to enforce safety <ref> [42] </ref>. SFI enables mutually distrustful program modules to safely share an address space. Table 1 summarizes the Omniware performance for four SPEC92 programs; Section 4 provides detailed performance results. <p> Section 4 quantifies the overhead of using Om-niVM to enforce write and execute protections on multi-page segments. Software fault isolation can also support efficient read protection and fine-grained access protection <ref> [42, 43] </ref>. Execution time relative to native program Mips Sparc PPC x86 li 1.10 1.05 1.18 1.11 compress 1.04 1.02 1.23 1.02 alvinn 1.20 1.07 1.08 1.25 eqntott 1.20 1.04 1.35 1.06 average 1.14 1.05 1.21 1.11 Table 1: Execution time of translated code with SFI, relative to native code. <p> Table 2 shows that using fewer than 16 registers penalizes performance on the Sparc. On RISC targets, the runtime system reserves some registers to efficiently implement SFI <ref> [42] </ref>, to store environment information, and to preserve compatibility with the native application binary interface. On processors such as the Pow-erPC or Sparc, we could use as many as 23 OmniVM registers. <p> Tables 3 and 4 also show the execution time overhead introduced by SFI. On all platforms, there is a performance penalty of approximately 10%. Other reports have investigated the effect of applying compiler optimizations to software fault isolation <ref> [42] </ref>. Based on these studies, we expect that Omniware's software fault isolation overhead will be cut to approximately 5% through these optimizations. 4.2 Benefits from translator optimizations Table 5 shows that simple local instruction scheduling can substantially improve native code generated by OmniVM translators. <p> Finally, SFI forms the foundation of our approach, but incurs an execution time overhead of approximately 10%. The overhead of SFI optimizations can be reduced using standard compiler techniques such as loop invariant code motion, as described in <ref> [42] </ref>. We have not implemented SFI optimizations and expect optimization will cut this overhead in half. 5 Related projects Several projects have employed virtual machine architectures with low-level instruction sets that resemble the OmniVM instruction set.
Reference: [43] <author> R. Wahbe, S. Lucco, and S. Graham. </author> <title> Practical data break-points: </title> <booktitle> Design and implementation. In Proceedings of the SIGPLAN '93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 1-12, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Section 4 quantifies the overhead of using Om-niVM to enforce write and execute protections on multi-page segments. Software fault isolation can also support efficient read protection and fine-grained access protection <ref> [42, 43] </ref>. Execution time relative to native program Mips Sparc PPC x86 li 1.10 1.05 1.18 1.11 compress 1.04 1.02 1.23 1.02 alvinn 1.20 1.07 1.08 1.25 eqntott 1.20 1.04 1.35 1.06 average 1.14 1.05 1.21 1.11 Table 1: Execution time of translated code with SFI, relative to native code.
Reference: [44] <author> D. Wall. </author> <title> Global register allocation at link time. </title> <booktitle> In Proceedings of the 7th SIGPLAN Symposium on Compiler Construction, </booktitle> <pages> pages 264-275, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: Typically, compilers target an entire architecture family, not a particular processor implementation. Several studies suggest that we can significantly improve performance using this information <ref> [27, 44, 8] </ref>. In addition, our results suggest several simple steps towards this goal. First, implementing a global pointer can significantly improve performance. The performance improvement resulting from implementing a global pointer on the Sparc confirms this assertion.
Reference: [45] <author> D. Wall. </author> <title> Experience with a software-defined machine architecture. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 14(3), </volume> <month> July </month> <year> 1992. </year>
Reference-contexts: Our translators include several optimizations. We have implemented local instruction scheduling in our Mips and PowerPC translators based on the algorithm described in <ref> [45] </ref>. We implement a global pointer in our Sparc translator and fill branch delay slots. On the x86, we perform only floating-point pipeline scheduling and peephole optimization. <p> We have not implemented SFI optimizations and expect optimization will cut this overhead in half. 5 Related projects Several projects have employed virtual machine architectures with low-level instruction sets that resemble the OmniVM instruction set. Designed for portable optimization rather than mobile code, Mahler <ref> [45] </ref> defines a virtual machine that abstracts over the details of several different Titan processor implementations. OmniVM differs from Mahler in the far wider range of architectures it supports, and the requirement for safe execution.
Reference: [46] <author> G. Williams. </author> <title> Hypercard (personal toolkit). </title> <journal> Byte, </journal> <volume> 12(14) </volume> <pages> 109-117, </pages> <month> December </month> <year> 1987. </year>
Reference-contexts: Currently, the most visible computer application requiring mobile code is executable content for electronic documents. While documents containing executable content have been around for at least two decades <ref> [46, 13] </ref>, the combination of electronic documents with widely adopted network protocols [5] on the Internet requires mobile executable document content. Because mobile programs are often untrusted, safety is an essential feature of any mobile code system.
References-found: 46

