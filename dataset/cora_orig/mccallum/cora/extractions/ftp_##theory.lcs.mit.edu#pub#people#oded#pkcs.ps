URL: ftp://theory.lcs.mit.edu/pub/people/oded/pkcs.ps
Refering-URL: http://theory.lcs.mit.edu/~cis/lattice/code/manual.html
Root-URL: 
Email: shaihg@theory.lcs.mit.edu  
Title: Public-Key Cryptosystems from Lattice Reduction Problems  
Author: Oded Goldreich Shafi Goldwasser Shai Halevi foded, shafi, 
Keyword: Public-Key Cryptosystems, Lattice Reduction Problems  
Address: ISRAEL  
Affiliation: Weizmann Institute of Science,  MIT, Laboratory for Computer Science  
Abstract: We present a new proposal for a trapdoor one-way function, from which we derive public-key encryption and digital signatures. The security of the new construction is based on the conjectured computational difficulty of lattice-reduction problems, providing a possible alternative to existing public-key encryption algo rithms and digital signatures such as RSA and DSS.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> M. Ajtai. </author> <title> Generating hard instances of lattice problems. </title> <booktitle> In Proceedings of the 28th Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 99-108, </pages> <year> 1996. </year>
Reference-contexts: Due to lack of space, we do not discuss that construction in this extended abstract. 1.1 Discussion Our work was inspired by a remarkable result of Ajtai <ref> [1] </ref> who introduced a function which is provably a one-way function if approximating the shortest non-zero vector (SVP) in a lattice is hard on the worst case. <p> In our experiments, we went through the basis vectors one at a time, to make sure that we replace them all. The coefficients in the linear combination were chose at random from f1; 0; 1g with a bias towards 0 (specifically, we used Pr <ref> [1] </ref> = Pr [1] = 1=7). This was done so that the size of the numbers in the public basis will not grow too fast. Our experiments indicate that using 2n mixing steps was sufficient to prevent LLL from recovering the original basis. <p> In our experiments, we went through the basis vectors one at a time, to make sure that we replace them all. The coefficients in the linear combination were chose at random from f1; 0; 1g with a bias towards 0 (specifically, we used Pr <ref> [1] </ref> = Pr [1] = 1=7). This was done so that the size of the numbers in the public basis will not grow too fast. Our experiments indicate that using 2n mixing steps was sufficient to prevent LLL from recovering the original basis.
Reference: 2. <author> M. Ajtai and C. Dwork. </author> <title> A Public-Key Cryptosystem with Worst-Case/Average-Case Equivalence, </title> <booktitle> In 29th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 284-293, </pages> <year> 1997. </year>
Reference-contexts: Ajtai's construction, however, does not provide a trapdoor function and thus does not provide a way of doing public-key encryption based on lattice problems. Constructing such a trapdoor function is the novelty and focus of our work. Independently of our work, Ajtai and Dwork <ref> [2] </ref> suggested a public-key encryption scheme whose security is reducible to a variant of SVP. Although exhibiting a trapdoor Boolean predicate (which is sufficient for public-key encryption see [13]), the Ajtai-Dwork construction does not provide a trapdoor function. <p> That is, given the trapdoor information it is possible to decide whether the predicate evaluates to 0 or 1 but not known how to find an inverse. Also, the variant of SVP used in the security proof of <ref> [2] </ref>, called the poly (n)- unique shortest vector problem seems to be considerably easier than the general SVP. Finally, we note that the Ajtai-Dwork construction is less efficient than ours, both in terms of the key-size and in terms of encryption time (O (n 4 ) vs.
Reference: 3. <author> S. Arora, L. Babai, J. Stern, and Z. Sweedyk. </author> <title> The hardness of approximate optimia in lattices, codes, and systems of linear equations. </title> <journal> In Journal of Computer and System Sciences, </journal> <volume> 54(2), </volume> <pages> pages 317-331, </pages> <year> 1997. </year>
Reference-contexts: The CVP was shown by van Emde Boas [6] to be N P-hard for any l p norm. Also, Arora et al. <ref> [3] </ref> proved that approximating the CVP to within any constant factor is also NP-hard. No polynomial-time algorithm is known for approximating the CVP in R n to within a polynomial factor in n.
Reference: 4. <author> L. Babai, </author> <title> On Lovasz lattice reduction and the nearest lattice point problem. </title> <journal> in Combinatorica, </journal> <volume> vol. 6, </volume> <year> 1986, </year> <pages> pp. 1-13. </pages>
Reference-contexts: The value of the function on this input is just the vector sum of the two points. To invert the function, we use a reduced basis R in one of Babai's nearest-vector approximation algorithms <ref> [4] </ref> to find a lattice point which is at most away from the given vector. The cryptanalytic problem underlying our scheme is to approximate the closest vector problem (CVP) in a lattice, given a non-reduced basis for that lattice. <p> No polynomial-time algorithm is known for approximating the CVP in R n to within a polynomial factor in n. The best polynomial time algorithms for approximating CVP are based on the LLL algorithm [17] and its variants. Babai <ref> [4] </ref> proved that the CVP in R n be approximated in polynomial time to within a factor of 2 n=2 . This was later improved by Schnorr [21] to a factor of (1 + ") n for any " &gt; 0. <p> The value n is rather arbitrary, and was only chosen to get integers of about 8 bits for the parameters which we work with. INVERT. Given R and c, we use Babai's Round-off algorithm <ref> [4] </ref> to invert the function. Namely, we represent c as a linear combination on the columns of R and then round the coefficients in this linear combination to the nearest integers to get a lattice point. <p> The Nearest-plane Attack One rather obvious improvement to the Round-off attack from above is to use a better approximation algorithm for the CVP. In particular, instead of using Babai's Round-off algorithm we can use the Nearest-plane algorithm which was also described in <ref> [4] </ref>. On a high-level, the difference between the Round-off and the Nearest-plane algorithms is that in the Nearest-plane, the rounding in the different entries are done adaptively (rather that all at once).
Reference: 5. <author> M. Blum and S. Goldwasser. </author> <title> An Efficient Probabilistic Public-Key Encryption Scheme which Hides All Partial Information. </title> <booktitle> in Proceedings of CRYPTO '84, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1985, </year> <pages> pp. 289-299. </pages>
Reference: 6. <author> P. van Emde Boas, </author> <title> Another N P-complete problem and the complexity of computing short vectors in a lattice. </title> <type> Reprot 81-04, </type> <institution> Mathematische Instituut, University of Amsterdam, </institution> <year> 1981. </year>
Reference-contexts: In this problem we are given a basis B for a lattice in R and another vector v 2 R n , and our task is to find the vector in L (B) which is closest to v (in some norm). The CVP was shown by van Emde Boas <ref> [6] </ref> to be N P-hard for any l p norm. Also, Arora et al. [3] proved that approximating the CVP to within any constant factor is also NP-hard. No polynomial-time algorithm is known for approximating the CVP in R n to within a polynomial factor in n.
Reference: 7. <institution> Digital Signature Standard (DSS). </institution> <note> FIPS PUB 186, </note> <year> 1994. </year>
Reference: 8. <author> W. Diffie and M.E. Hellman. </author> <title> New Directions In Cryptography. </title> <journal> IEEE Transactions on Information Theory, </journal> <volume> Vol IT-22, </volume> <year> 1976, </year> <pages> pp. 644-654. </pages>
Reference: 9. <author> T. El-Gamal. </author> <title> A Public Key Cryptosystem and a Signature Scheme Based on Discrete Logarithms. </title> <journal> IEEE Trans. Information Theory, </journal> <volume> vol. 31, </volume> <year> 1985, </year> <pages> pp. 469-472 </pages>
Reference: 10. <author> O. Goldreich, S. Goldwasser and S. </author> <title> Halevi Collision-Free Hashing from Lattice Problems. Theory of Cryptography Library: </title> <type> Record 96-09. </type> <note> Available from http://theory.lcs.mit.edu/tcryptol/1996/96-09.html </note>
Reference-contexts: n will imply the ability to compute a small basis for the lattice which in turn will enable the attacker to find close vectors in a lattice and break the scheme. (Interestingly, a family of collision-free hash functions can be constructed assuming that Lattice-Reduction is hard on the worst-case, see <ref> [10] </ref>).
Reference: 11. <author> O. Goldreich, S. Goldwasser and S. </author> <title> Halevi Public-Key Cryptosystems from Lattice Reductions Problems. </title> <note> ECCC Report TR96-056. Available from http://www.eccc.uni-trier.de/eccc-local/Lists/TR-1996.html </note>
Reference-contexts: These tests are described in the TR version of this work <ref> [11] </ref>. 5.2 Evaluation of the Round-Off Attack We used the analysis from Subsection 3.4, in conjunction with our tests, to evaluate the performance of the Round-off attack in dimensions 80 through 160 (in increments of 10). We performed the following experiments: 1.
Reference: 12. <author> O. Goldreich and L.A. </author> <title> Levin A Hard-Core Predicate for All One-Way Functions Proceedings of the 21st ACM Symposium on Theory of Computing, </title> <booktitle> 1989, </booktitle> <pages> pp. 25-32 </pages>
Reference-contexts: There are several ways to do that, and we discuss some of them in Section 4. One generic way is to use hard core bits of the trapdoor function to embed the bits of the message (e.g., <ref> [12] </ref>). This approach has the advantage of ensuring that the encryption scheme is as secure as the underlying trapdoor function, but it is inefficient in terms of message expansion. <p> Since we have a candidate for a trapdoor one-way function, we may use hard-core bits of this function as the message bits. In particular, we can use the general construction of Goldreich-Levin, <ref> [12] </ref>) which shows how and where to hide hard core bits in a pre-image of any one-way function. (This construction enables hiding log n bits in one function evaluation.) This approach has the advantage of being able to prove that it is impossible to even distinguish in polynomial time between any
Reference: 13. <author> S. Goldwasser and S. Micali, </author> <title> Probabilistic Encryption. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> Vol. 28, </volume> <year> 1984, </year> <pages> pp. 270-299. </pages>
Reference-contexts: From trapdoor function to encryption scheme. In order to use the above trapdoor function for public-key encryption, we need a way to embed the message in the arguments to this function, in such a way that no partial information about the message is leaked by the ciphertext (cf., <ref> [13] </ref>). There are several ways to do that, and we discuss some of them in Section 4. One generic way is to use hard core bits of the trapdoor function to embed the bits of the message (e.g., [12]). <p> Constructing such a trapdoor function is the novelty and focus of our work. Independently of our work, Ajtai and Dwork [2] suggested a public-key encryption scheme whose security is reducible to a variant of SVP. Although exhibiting a trapdoor Boolean predicate (which is sufficient for public-key encryption see <ref> [13] </ref>), the Ajtai-Dwork construction does not provide a trapdoor function. That is, given the trapdoor information it is possible to decide whether the predicate evaluates to 0 or 1 but not known how to find an inverse. <p> To encrypt arbitrary messages, we must specify an (easily invertible) encoding which maps messages into lattice vectors which are then encrypted as above. Describing such an encoding is the focus of this section. To obtain a semantically secure encryption scheme <ref> [13] </ref>, we need an encoding scheme such that seeing the ciphertext does not help a polynomial time adversary in getting any information about the message. Other parameters which need to be considered (besides security) are the efficiency of encoding and decoding, and the message expansion.
Reference: 14. <author> S. Goldwasser, S. Micali and R.L. Rivest. </author> <title> A Digital Signature Scheme Secure Against Adaptive Chosen Message Attack. </title> <journal> SIAM Journal on Computing, </journal> <volume> Vol. 17, no. 2, </volume> <year> 1988, </year> <pages> pp. 281-308. </pages>
Reference-contexts: When applying the method in a setting where this property is desirable (e.g., signing analog signals which may change a little in time), this feature may be of great benefit. However, to get secure signatures in the sense of <ref> [14] </ref>, this property pause a significant problem. When applying the method to a message space where such property is undesirable, we propose to first hash the message and only then sign it.
Reference: 15. <author> R. Kannan. </author> <title> Algorithmic Geometry of Numbers. </title> <booktitle> in Annual Review of Computer Science, </booktitle> <volume> vol. </volume> <pages> 2, </pages> <address> 1987, </address> <publisher> Annual Reviews Inc. </publisher>
Reference: 16. <author> The LiDIA project software-package and user-manual. </author> <note> Available from http://www.informatik.th-darmstadt.de/TI/LiDIA/ </note>
Reference-contexts: Our numerical estimates for the work-load of the various attacks are based on experiments reported in Section 5. In these experiments we used the implementation of the LLL lattice-reduction algorithm from the LiDIA project <ref> [16] </ref>. The bottom line of our experiments is that all the attacks below become infeasible in dimensions above 150. We do not have data about the performance of these attack using better lattice-reduction algorithms (such as the ones described in [22]. <p> In this section we describe our testing methods and sketch a few of the main results. A full report on these tests will be available in the full version of this paper. For these experiments we used the implementation of the LLL lattice-reduction algorithm from the LiDIA project <ref> [16] </ref>. 5.1 Choosing Parameters for the Key-Generation The tests which we performed to determine the parameters of the key-generation process are omitted from this extended abstract.
Reference: 17. <author> A.K. Lenstra, H.W. Lenstra, L. Lovasz. </author> <title> Factoring polynomials with rational coefficients. </title> <booktitle> Math-ematische Annalen 261, </booktitle> <month> 515-534 </month> <year> (1982). </year>
Reference-contexts: No polynomial-time algorithm is known for approximating the CVP in R n to within a polynomial factor in n. The best polynomial time algorithms for approximating CVP are based on the LLL algorithm <ref> [17] </ref> and its variants. Babai [4] proved that the CVP in R n be approximated in polynomial time to within a factor of 2 n=2 . This was later improved by Schnorr [21] to a factor of (1 + ") n for any " &gt; 0.
Reference: 18. <author> R.J. </author> <title> McEliece, A Public-Key Cryptosystem Based on Algebraic Coding Theory. </title> <type> DSN Progress Report 42-44, </type> <institution> Jet Propulsion Laboratory </institution>
Reference-contexts: By using the private basis, which is a reduced basis, the correct decryption is obtained with high probability. We remark that our encryption algorithm is similar in its algorithmic nature to a scheme based on algebraic coding that was suggested by McEliece's in <ref> [18] </ref>. A signature scheme. It is also possible to construct a signature scheme along similar lines: Regard the message as a n-dimensional vector over the reals. Then, a signature of such vector, is a lattice point which is close to it (where closeness is defined by a published threshold). <p> O (n 2 ) for both measures). Thus, it seems that their current construction is not really practical. In retrospect, our encryption scheme bears much similarity to McEliece's scheme <ref> [18] </ref>. His scheme utilizes a pair of matrices over GF (2), which corresponds to two representations of the same linear code. The encryption method is probabilistic: one multiplies the public matrix by the message vector and adds a random noise vector to the resulting codeword.
Reference: 19. <author> M.O. Rabin, </author> <title> Digital Signatures and Public-Key Functions as Intractable as Factorization. </title> <type> Technical Report MIT/LCS/TR-212, </type> <institution> M.I.T., </institution> <year> 1978. </year>
Reference-contexts: Moreover, the source of security of these proposals almost always relies on the (apparent) computational intractability of problems in finite integer rings, specifically integer factorization (e.g., <ref> [20, 19, etc.] </ref>) and discrete logarithm computations (e.g.,[8, 9, 7, etc]). In this paper we propose a new trapdoor one-way function relying on the computational difficulty of lattice reduction problems, in particular the problem of finding closest vectors in a lattice to a given point (CVP).
Reference: 20. <author> R.L. Rivest, A. Shamir and L. Adleman. </author> <title> A Method for Obtaining Digital Signatures and Public-Key Cryptosystems. </title> <journal> Communications of the ACM, </journal> <volume> Vol. 21, </volume> <year> 1978, </year> <pages> pp. 120-126. </pages>
Reference-contexts: Moreover, the source of security of these proposals almost always relies on the (apparent) computational intractability of problems in finite integer rings, specifically integer factorization (e.g., <ref> [20, 19, etc.] </ref>) and discrete logarithm computations (e.g.,[8, 9, 7, etc]). In this paper we propose a new trapdoor one-way function relying on the computational difficulty of lattice reduction problems, in particular the problem of finding closest vectors in a lattice to a given point (CVP).
Reference: 21. <author> C.P. Schnorr. </author> <title> A hierarchy of polynomial time lattice basis reduction algorithms. </title> <booktitle> in Theoretical Computer Science, </booktitle> <volume> vol. 53, </volume> <year> 1987, </year> <pages> pp. 201-224 </pages>
Reference-contexts: This fact follows since there is an integer matrix T such that BT = C and another integer matrix T 1 such that CT 1 = B. The notion of of the orthogonality defect of a basis, which was introduced by Schnorr in <ref> [21] </ref>, plays a crucial role in the security of our schemes. Definition 2. Let B be a real non-singular n fi n matrix. <p> The best polynomial time algorithms for approximating CVP are based on the LLL algorithm [17] and its variants. Babai [4] proved that the CVP in R n be approximated in polynomial time to within a factor of 2 n=2 . This was later improved by Schnorr <ref> [21] </ref> to a factor of (1 + ") n for any " &gt; 0. We note, however, that these bounds refer to worst-case instances, and these algorithms typically perform much better than the above upper-bounds.
Reference: 22. <author> C.P. Schnorr and H.H. Horner, </author> <title> Attacking the Chor-Rivest Cryptosystem by Improved Lattice Reduction. </title> <booktitle> in Proceedings of EUROCRYPT '95, </booktitle> <editor> Louis C. Guillou and Jean-Jacques Quisquater, editors. </editor> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> volume 921, </volume> <publisher> Springer-Verlag, </publisher> <year> 1995. </year> <title> pp. 1-12 This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: In particular, we found that in dimension 100, the bases we obtained had a high dial-orthogonality-defect. At the present time, the best practical lattice-reduction algorithm which we are aware of is Schnorr's block-reduction scheme (which was used to attack the Chor-Rivest cryptosystem, see <ref> [22] </ref>). We speculate that working in dimensions about 250-300 should be good enough with respect to this algorithm. Distribution of the private bases. We considered two possible distributions for choosing the private basis. <p> The bottom line of our experiments is that all the attacks below become infeasible in dimensions above 150. We do not have data about the performance of these attack using better lattice-reduction algorithms (such as the ones described in <ref> [22] </ref>. We speculate that when using these better algorithms, the attacks will become infeasible in dimensions about 250-300.
References-found: 22

