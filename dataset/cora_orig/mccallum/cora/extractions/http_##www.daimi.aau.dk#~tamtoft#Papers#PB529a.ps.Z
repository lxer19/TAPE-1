URL: http://www.daimi.aau.dk/~tamtoft/Papers/PB529a.ps.Z
Refering-URL: http://www.daimi.aau.dk/~tamtoft/papers.html
Root-URL: http://www.daimi.aau.dk
Email: e-mail: -tamtoft,fn,hrn-@daimi.aau.dk  
Title: Polymorphic Subtyping for Side Eoeects  
Author: Torben Amtoft Flemming Nielson Hanne Riis Nielson 
Date: February 5, 1998  
Address: Denmark  
Affiliation: Computer Science Department, Aarhus University,  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Torben Amtoft and Flemming Nielson and Hanne Riis Nielson: </author> <title> Type and behaviour reconstruction for higher-order concurrent programs. </title> <journal> Journal of Functional Programming, </journal> <volume> 7(3):321347, </volume> <month> May </month> <year> 1997. </year>
Reference-contexts: A more ambitious analysis is the approach of [17] to let annotated type and eoeect systems extract terms of a process algebra from programs with communication; this involves poly-morphism and subeoeecting but (presumably because the inference system is expressed without using constraints) the algorithmic issues are non-trivial [14]; <ref> [1] </ref> presents an algorithm that is sound as well as complete, but which generates constraints that we do not know how to solve in the general case. Finally we should mention [31] where eoeects are incorporated into ML types in order to deal with region inference.
Reference: [2] <author> Torben Amtoft and Flemming Nielson and Hanne Riis Nielson and Jr-gen Ammann: </author> <title> Polymorphic subtypes for eoeect analysis: the dynamic semantics. </title> <booktitle> In Analysis and Veriocation of Multiple-Agent Languages, </booktitle> <pages> pages 172206, </pages> <address> SLNCS 1192, </address> <year> 1997. </year>
Reference-contexts: The type system presented in [19] is a major step towards integrating poly-morphism, subtyping, and eoeects; it generalises the subeoeecting approach of [28] and admits eoeects into the subtyping approaches of [26, 8]. A key insight is that in order to establish semantic soundness (as is formally done in <ref> [2] </ref>) one must be very careful when deciding the set of variables over which to generalise in the inference rule for let: not only should this set be disjoint from the set of variables occurring in the eoeect (as is standard in eoeect systems, e.g. [28]) but it should also be
Reference: [3] <author> Torben Amtoft and Hanne Riis Nielson and Flemming Nielson: </author> <title> Be-haviour analysis for validating communication patterns. </title> <type> Technical Report DAIMI PB-527, </type> <institution> Dept. of Comp. Science, Aarhus University, </institution> <month> September </month> <year> 1997. </year> <title> Invited submission for Springer International Journal on Software Tools for Technology Transfer. </title>
Reference-contexts: The system post-processes the constraints generated by W so as to produce readable output; in Chapter 6 we mention a selection of the techniques used and show that the resulting constraint set is in a certain sense bisimilar to the original constraints. <ref> [3] </ref> contains a description of the system, illustrated by several examples, as well as a brief account of the underlying theory (to be developed in the rest of this document). <p> In this chapter we describe how to transform the constraints, and at the same time simplify b, so as to improve readability. In Sect. 6.1 we shall see how to ond a solution R to the region constraints C r . The user will typically, as illustrated in <ref> [3, 15] </ref>, restrict his attention to a few selected channel labels; with L hid the remaining ihiddenj labels we introduce a special behaviour o which denotes creation of, or communication over, a channel whose label belongs to L hid .
Reference: [4] <author> Luis Damas and Robin Milner: </author> <title> Principal type-schemes for functional programs. </title> <booktitle> In Proc. of POPL '82, </booktitle> <publisher> ACM Press, </publisher> <year> 1982. </year>
Reference-contexts: One of the pioneering papers in the area is [11] that developed the orst polymorphic type inference system, and an algorithm, for the applicative fragment of ML; a shorter presentation for the typed -calculus with let is given in <ref> [4] </ref>. Subtyping. Since then many papers have studied how to integrate sub-typing. A number of early papers did so by mainly focusing on the typed -calculus and only brieAEy dealing with let [12, 6]. Later papers have treated polymorphism in full generality [26, 8].
Reference: [5] <author> You-Chin Fuh and Prateek Mishra: </author> <title> Polymorphic subtype inference: Closing the theory-practice gap. </title> <booktitle> In Proc. TAPSOFT '89, </booktitle> <pages> pages 167 183, </pages> <address> SLNCS 352, </address> <year> 1989. </year>
Reference-contexts: Later papers have treated polymorphism in full generality [26, 8]. A key ingredient in these approaches is the simpliocation of the enormous set of constraints into something manageable <ref> [5, 26] </ref>. Eoeects. Already ML necessitates an incorporation of imperative eoeects due to the presence of ref-types. <p> Still the algorithm will produce a rather unwieldy number of constraints; to reduce this number substantially we may apply an algorithm R (deoned in Sect. 4.4) which adapts the techniques of <ref> [5, 26] </ref>. 1.6 Syntactic Soundness In Sect. 4.5 we shall prove that W is (syntactically) sound, that is if W (A; e) = (S; t; b; C) then C; S A ` e : t & b. <p> The techniques used are basically those of [26] and <ref> [5] </ref>, adapted to our framework. The transformation R may be described as a non-deterministic rewriting process, operating over triples of the form (C; t; b) with C atomic, and with respect to a oxed environment A. <p> that e can be typed in the ML type system. 101 Chapter 5 Completeness of the Inference Algorithm 5.1 Lazy Instance We now begin the preparations for formulating syntactic completeness of algorithm W, as done in Sect. 5.2; to do so we must adapt the notion of lazy instance from <ref> [5] </ref>. <p> Proof See Appendix D. 2 5.2 The Completeness Result The notion of lazy instance <ref> [5] </ref> corresponds to our notion of S-instance and is a key tool in the formulation of syntactic completeness (see Theorem 5.18) which allows a proof by induction: 104 if C fl ; A fl ` at C fl is atomic and A fl C fl S 00 A with A well-formed
Reference: [6] <author> You-Chin Fuh and Prateek Mishra: </author> <title> Type inference with subtypes. </title> <booktitle> Theoretical Computer Science 73, </booktitle> <pages> pages 155175, </pages> <year> 1990. </year>
Reference-contexts: Subtyping. Since then many papers have studied how to integrate sub-typing. A number of early papers did so by mainly focusing on the typed -calculus and only brieAEy dealing with let <ref> [12, 6] </ref>. Later papers have treated polymorphism in full generality [26, 8]. A key ingredient in these approaches is the simpliocation of the enormous set of constraints into something manageable [5, 26]. Eoeects. Already ML necessitates an incorporation of imperative eoeects due to the presence of ref-types. <p> In order to incorporate subtyping we also need to generate type constraints as in <ref> [6, 26] </ref>. The presence of type constraints is a consequence of our overall design: types and behaviours should be inferred simultaneously ifrom scratchj, as is done by the algorithm W presented in Sect. 4.1. <p> The constraints generated by W have to be massaged so as to satisfy certain invariants and for this we devise the algorithm F (Sect. 4.3), inspired by <ref> [6] </ref>. <p> turns out [15] that the system greatly assists in validating a number of safety properties for irealisticj concurrent systems. 1.9 Future Work We have seen that the present development integrates many features from previous approaches in the literature; below we mention some features that are not yet covered: * unlike <ref> [6, 26] </ref> we do not allow inclusion between base types, such as int real; 1 http://www.daimi.aau.dk/flbra8130/TBA/TBA.html. 13 * unlike [7, 31] we do not enable polymorphic recursion in the type an- notations. 14 Chapter 2 The Static Semantics For illustrating our approach we have chosen a variant of Concurrent ML (CML) <p> types to the same location at various stages (although apparently it is always possible to choose the same type and still get subject reduction). 2 77 Chapter 4 The Inference Algorithm In designing an inference algorithm W for the type inference system we are motivated by the overall approach of <ref> [26, 6] </ref>. One ingredient (called W 0 ) of this will be to perform a syntax-directed traversal of the expression in order to determine its type and behaviour; this will involve constructing a constraint set for expressing the required relationship between the type and behaviour and region variables. <p> Recall (Fact 2.11 and Fact 2.13) that these notions are closed under substitution; this will not be the case for the notion of atomicity. Atomicity As in <ref> [12, 6, 26] </ref> we shall want the type constraints to match and shall decompose them into atomic constraints; in our setting these will not contain base types as we have no ordering among those. <p> (t 1 fi t 2 ff) by forcing ff to be replaced by a type expression that imatchesj the opposite side of the constraint, and for disallowing constraints like (t 1 fi t 2 t 0 1 ! fi t 0 2 ); a phenomenon that can be found in <ref> [12, 6, 26] </ref> as well. <p> The algorithm follows the overall approach of [26, 8] except that as in <ref> [6] </ref> there are no explicit uniocation steps; these all take place as part of the F transformation. The main novel ingredient of our approach shows up in the clause for let as we shall explain shortly. <p> This is helpful for reducing the size of constraint sets and type schemes. 2 83 4.3 Algorithm F We are now going to deone the algorithm F which iforces type constraints to matchj by transforming them into atomic constraints; the algorithm closely resembles <ref> [6, procedure MATCH] </ref>. The algorithm may be described as a non-deterministic rewriting process. <p> The type part is isomorphic to the initial constraints, so this process may continue forever: we perform a second match and produce a second substitution R 2 , etc. To detect this situation we follow <ref> [6] </ref> in making use of the equivalence relation and extend it with ff 1 ff 2 after the orst match that produced R 1 ; the intuition is that ff 1 and ff 2 eventually must be bound to types having the same shape. <p> Proof We orst address termination and for this purpose we (much as in <ref> [6] </ref>) deone an ordering on triples (S; C; ) as follows: (S 0 ; C 0 ; 0 ) is less than (S; C; ) if either the number of equivalence classes in FV (C 0 ) wrt. 0 is less than the number of equivalence classes in FV (C) wrt.
Reference: [7] <author> Fritz Henglein and Christian Mossin: </author> <title> Polymorphic binding-time analysis. </title> <booktitle> In Proc. ESOP '94, </booktitle> <pages> pages 287301, </pages> <address> SLNCS 788, </address> <year> 1994. </year>
Reference-contexts: Integration. In the area of static program analysis, annotated type and eoeect systems have been used as the basis for control AEow analysis [29] and binding time analysis <ref> [16, 7] </ref>. These papers typically make use of a polymorphic type system with subtyping and no eoeects, or a non-polymorphic type system with eoeects and subtyping. <p> 1.9 Future Work We have seen that the present development integrates many features from previous approaches in the literature; below we mention some features that are not yet covered: * unlike [6, 26] we do not allow inclusion between base types, such as int real; 1 http://www.daimi.aau.dk/flbra8130/TBA/TBA.html. 13 * unlike <ref> [7, 31] </ref> we do not enable polymorphic recursion in the type an- notations. 14 Chapter 2 The Static Semantics For illustrating our approach we have chosen a variant of Concurrent ML (CML) [22, 20] which includes * identioers x, function abstractions fn x)e and function applications e 1 e 2 (as
Reference: [8] <author> Mark P. Jones: </author> <title> A theory of qualioed types. </title> <booktitle> In Proc. ESOP '92, </booktitle> <pages> pages 287306, </pages> <address> SLNCS 582, </address> <year> 1992. </year> <month> 210 </month>
Reference-contexts: Subtyping. Since then many papers have studied how to integrate sub-typing. A number of early papers did so by mainly focusing on the typed -calculus and only brieAEy dealing with let [12, 6]. Later papers have treated polymorphism in full generality <ref> [26, 8] </ref>. A key ingredient in these approaches is the simpliocation of the enormous set of constraints into something manageable [5, 26]. Eoeects. Already ML necessitates an incorporation of imperative eoeects due to the presence of ref-types. <p> The type system presented in [19] is a major step towards integrating poly-morphism, subtyping, and eoeects; it generalises the subeoeecting approach of [28] and admits eoeects into the subtyping approaches of <ref> [26, 8] </ref>. <p> the behaviour of the spawned pro cess. (As discussed previously one might add wrap to the language: this constant transforms delayed communications of type t event fi into delayed communications of type t 0 event fi 0 .) We will incorporate the eoeects of [28, 17] into the approach of <ref> [26, 8] </ref> by deoning a type inference system with judgements of the form 5 We shall distinguish rather sharply between these two entities, but Observation 2.15 suggests that they may be identioed. 22 c A (c) () unit true; false bool 1; 0; 1; 2 int = int fi int ! <p> The overall structure of the type inference system of Figure 2.5 is very close to those of <ref> [26, 8] </ref> with a few components from [28, 17] thrown in; the novel ideas of our approach only show up as carefully constructed side conditions for some of the rules. <p> The algorithm follows the overall approach of <ref> [26, 8] </ref> except that as in [6] there are no explicit uniocation steps; these all take place as part of the F transformation. The main novel ingredient of our approach shows up in the clause for let as we shall explain shortly. <p> As we shall see below (Lemma 5.13) it is the restriction to atomic constraints C fl that allows algorithm F to manipulate type constraints without losing instances. The decomposition of S 00 into S 0 S is standard and may be found also in <ref> [26, 8] </ref>.
Reference: [9] <author> Pierre Jouvelot and David K. Gioeord: </author> <title> Algebraic reconstruction of types and eoeects. </title> <booktitle> In Proc. POPL'91, </booktitle> <pages> pages 303310. </pages> <publisher> ACM Press, </publisher> <year> 1991. </year>
Reference-contexts: Therefore we shall instead follow <ref> [9] </ref> and generate behaviour constraints: that is, in the process of uniong t 1 ! b t 2 and t 0 1 ! b 0 2 we generate constraints relating b and b 0 .
Reference: [10] <author> Xavier Leroy and Pierre Weis: </author> <title> Polymorphic type inference and assignment. </title> <booktitle> In Proc. POPL '91, </booktitle> <pages> pages 291302. </pages> <publisher> ACM Press, </publisher> <year> 1991. </year>
Reference-contexts: that is the system employs subeoeecting. * [28] can be considered a reonement of [32] in that eoeects also record the region in which a reference cell is created or a read/write operation is performed; this information enables one to imaskj eoeects which have taken place in iinaccessiblej regions. * <ref> [10] </ref> presents a somewhat alternative view: here focus is not on detecting creation of reference cells but rather to detect their use; this means 8 that if an identioer occurs free in a function closure then all variables in its type have to be iexaminedj. <p> premise that the inference system assigns a type t to e but the conclusion depends on the kind of dynamic semantics used: for a denota-tional semantics one may require (as in [11]) that the denotation of e ihas typej t; for a big-step (natural) semantics one may require (as in <ref> [30, 10] </ref>) that if e ! v then v ihas typej t; for a small-step semantics [21] one requires (as in [33]) the following subject reduction property: if e ! e 0 then the inference system also assigns e 0 the type t.
Reference: [11] <author> Robin Milner: </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17:348375, </volume> <year> 1978. </year>
Reference-contexts: This will facilitate modular proofs of correctness while at the same time allowing the inference algorithms to generate syntax-free constraints that can be solved eOEciently. 7 1.2 State of the Art Polymorphism. One of the pioneering papers in the area is <ref> [11] </ref> that developed the orst polymorphic type inference system, and an algorithm, for the applicative fragment of ML; a shorter presentation for the typed -calculus with let is given in [4]. Subtyping. Since then many papers have studied how to integrate sub-typing. <p> Statements of semantic soundness typically contain as premise that the inference system assigns a type t to e but the conclusion depends on the kind of dynamic semantics used: for a denota-tional semantics one may require (as in <ref> [11] </ref>) that the denotation of e ihas typej t; for a big-step (natural) semantics one may require (as in [30, 10]) that if e ! v then v ihas typej t; for a small-step semantics [21] one requires (as in [33]) the following subject reduction property: if e ! e 0 <p> In addition, in order to ensure that iwell-typed programs do not go wrongj <ref> [11] </ref> one must establish that ierror conogurationsj (those which are istuckj) cannot be typed. We shall choose a small-step semantics as we consider this the most appropriate for concurrent languages; the conogurations of the transition system will be process pools P P which map process identioers into expressions. <p> the rule for let in the inference system; the proof of Lemma 3.24 highlights how the judicious choice of generalisation strategy actually allows to extend the environment. 1.5 An Inference Algorithm In Chap. 4 we shall aim at constructing a type reconstruction algorithm in the spirit of Milner's algorithm W <ref> [11] </ref>: given an expression e and an environment A, the recursively deoned function W will produce a substitution S, a type t, and a behaviour b. The deonition in [11] employs uniocation [23]: if e 1 has been given type t 0 ! t 1 and e 2 has been given <p> Inference Algorithm In Chap. 4 we shall aim at constructing a type reconstruction algorithm in the spirit of Milner's algorithm W <ref> [11] </ref>: given an expression e and an environment A, the recursively deoned function W will produce a substitution S, a type t, and a behaviour b. The deonition in [11] employs uniocation [23]: if e 1 has been given type t 0 ! t 1 and e 2 has been given type t 2 then in order to type e 1 e 2 one must unify t 0 and t 2 . <p> Decomposition is valid because types constitute a ifree algebraj: two types are equal if and only if they have the same top-level constructor and also their subcomponents are equal. However, this will not be the case 11 for behaviours, and therefore W of <ref> [11] </ref> cannot immediately be generalised to work on annotated types. <p> type an- notations. 14 Chapter 2 The Static Semantics For illustrating our approach we have chosen a variant of Concurrent ML (CML) [22, 20] which includes * identioers x, function abstractions fn x)e and function applications e 1 e 2 (as in the -calculus); * polymorphic let-expressions (as in ML <ref> [11] </ref>); * recursive functions and conditionals (to facilitate programming); * constructors (for building data structures); * base functions (for inspecting and decomposing data structures).
Reference: [12] <author> John C. Mitchell: </author> <title> Type inference with simple subtypes. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(3):245285, </volume> <year> 1991. </year>
Reference-contexts: Subtyping. Since then many papers have studied how to integrate sub-typing. A number of early papers did so by mainly focusing on the typed -calculus and only brieAEy dealing with let <ref> [12, 6] </ref>. Later papers have treated polymorphism in full generality [26, 8]. A key ingredient in these approaches is the simpliocation of the enormous set of constraints into something manageable [5, 26]. Eoeects. Already ML necessitates an incorporation of imperative eoeects due to the presence of ref-types. <p> Recall (Fact 2.11 and Fact 2.13) that these notions are closed under substitution; this will not be the case for the notion of atomicity. Atomicity As in <ref> [12, 6, 26] </ref> we shall want the type constraints to match and shall decompose them into atomic constraints; in our setting these will not contain base types as we have no ordering among those. <p> (t 1 fi t 2 ff) by forcing ff to be replaced by a type expression that imatchesj the opposite side of the constraint, and for disallowing constraints like (t 1 fi t 2 t 0 1 ! fi t 0 2 ); a phenomenon that can be found in <ref> [12, 6, 26] </ref> as well. <p> Consequently the iextended occur checkj Dom (R 2 ) " FV (ff 2 event fi 2 ) = ; fails. 2 Remark Matching bears certain similarities to uniocation and can actually be deoned in terms of uniocation. In <ref> [12] </ref> matching is performed by orst doing uniocation and then the resulting substitution is transformed such that it imaps into fresh variablesj.
Reference: [13] <author> Flemming Nielson (editor): </author> <title> ML with Concurrency: Design, Analysis, Implementation and Application. </title> <booktitle> Springer Monographs in Computer Science, </booktitle> <year> 1997. </year>
Reference: [14] <author> Flemming Nielson and Hanne Riis Nielson: </author> <title> Constraints for polymorphic behaviours for Concurrent ML. </title> <booktitle> In Proc. </booktitle> <address> CCL'94, SLNCS 845, </address> <year> 1994. </year>
Reference-contexts: A more ambitious analysis is the approach of [17] to let annotated type and eoeect systems extract terms of a process algebra from programs with communication; this involves poly-morphism and subeoeecting but (presumably because the inference system is expressed without using constraints) the algorithmic issues are non-trivial <ref> [14] </ref>; [1] presents an algorithm that is sound as well as complete, but which generates constraints that we do not know how to solve in the general case. Finally we should mention [31] where eoeects are incorporated into ML types in order to deal with region inference. <p> Alternatively one could allow types to contain more complex behaviours, permitting say int ! ae ! int int; the deonition chosen amounts to demanding that types should be (what <ref> [14] </ref> calls) simple.
Reference: [15] <author> Hanne Riis Nielson and Torben Amtoft and Flemming Nielson: </author> <title> Be-haviour analysis and safety conditions: a case study in CML. </title> <type> Technical Report DAIMI PB-528, </type> <institution> Dept. of Comp. Science, Aarhus University, </institution> <note> Oc-tober 1997. Accepted for FASE'98. </note>
Reference-contexts: It turns out <ref> [15] </ref> that the system greatly assists in validating a number of safety properties for irealisticj concurrent systems. 1.9 Future Work We have seen that the present development integrates many features from previous approaches in the literature; below we mention some features that are not yet covered: * unlike [6, 26] we <p> In this chapter we describe how to transform the constraints, and at the same time simplify b, so as to improve readability. In Sect. 6.1 we shall see how to ond a solution R to the region constraints C r . The user will typically, as illustrated in <ref> [3, 15] </ref>, restrict his attention to a few selected channel labels; with L hid the remaining ihiddenj labels we introduce a special behaviour o which denotes creation of, or communication over, a channel whose label belongs to L hid .
Reference: [16] <author> Hanne Riis Nielson and Flemming Nielson: </author> <title> Automatic binding analysis for a typed -calculus. </title> <booktitle> Science of Computer Programming, </booktitle> <address> 10:139176, </address> <year> 1988. </year>
Reference-contexts: Integration. In the area of static program analysis, annotated type and eoeect systems have been used as the basis for control AEow analysis [29] and binding time analysis <ref> [16, 7] </ref>. These papers typically make use of a polymorphic type system with subtyping and no eoeects, or a non-polymorphic type system with eoeects and subtyping.
Reference: [17] <author> Hanne Riis Nielson and Flemming Nielson: </author> <title> Higher-order concurrent programs with onite communication topology. </title> <booktitle> In Proc. POPL'94, </booktitle> <pages> pages 8497. </pages> <publisher> ACM Press, </publisher> <year> 1994. </year> <note> Full version appears as [18]. </note>
Reference-contexts: These papers typically make use of a polymorphic type system with subtyping and no eoeects, or a non-polymorphic type system with eoeects and subtyping. A more ambitious analysis is the approach of <ref> [17] </ref> to let annotated type and eoeect systems extract terms of a process algebra from programs with communication; this involves poly-morphism and subeoeecting but (presumably because the inference system is expressed without using constraints) the algorithmic issues are non-trivial [14]; [1] presents an algorithm that is sound as well as complete, <p> To keep the development in [19] as simple as possible, region information is omitted from the eoeects. 1.3 Ma jor Achievement I: Causality Chapter 2 reintroduces regions and further improves on [19] in that causality is incorporated into the eoeects, thus following <ref> [17] </ref>, and we shall therefore prefer to use the word ibehavioursj rather than ieoeectsj. At the same time we slightly reformulate the notion of upwards closure used in the generalisation rule (cf. the preceding paragraph). <p> The general picture is much as in <ref> [17] </ref> that types are unchanged whereas the behaviours get ismallerj and the environments are iextendedj. Extending the environment is a potential danger to semantic soundness, cf. the considerations in [30, section 5] where it was concluded that store operations in Standard ML are harmless unless they actually expand the store. <p> of the channel l call which created it; accordingly the syntax of regions (r 2 Reg) is given by r::=ae j flg The role of the behaviour variable fi is to express the dynamic eoeect that takes place when the function is applied or the delayed communication syn-chronised; motivated by <ref> [17] </ref> the syntax of behaviours (b 2 Beh) is given by: j SPAWN b j t chan ae j ae ! t j ae ? t that is in addition to behaviour variables we have the empty behaviour " (no ivisiblej actions take place); a sequential composition b 1 ; b <p> So compared with the eoeects in e.g. [28] we have (by means of the ; operator) incorporated causality information; on the other hand we have not allowed to mask out behaviours which operate on iinaccessiblej regions (cf. Chap. 1). In contrast to <ref> [17] </ref> there is no explicit recursion; in Section 2.5 we shall see that constraints may implicitly give rise to irecursivej behaviours. A substitution is a mapping from type variables into types and behaviour variables into behaviour variables and region variables into region variables such that the domain is onite. <p> onally the type of spawn records the behaviour of the spawned pro cess. (As discussed previously one might add wrap to the language: this constant transforms delayed communications of type t event fi into delayed communications of type t 0 event fi 0 .) We will incorporate the eoeects of <ref> [28, 17] </ref> into the approach of [26, 8] by deoning a type inference system with judgements of the form 5 We shall distinguish rather sharply between these two entities, but Observation 2.15 suggests that they may be identioed. 22 c A (c) () unit true; false bool 1; 0; 1; 2 <p> The overall structure of the type inference system of Figure 2.5 is very close to those of [26, 8] with a few components from <ref> [28, 17] </ref> thrown in; the novel ideas of our approach only show up as carefully constructed side conditions for some of the rules.
Reference: [18] <author> Hanne Riis Nielson and Flemming Nielson. </author> <title> Communication analysis for Concurrent ML. </title> <booktitle> In [13]. </booktitle>
Reference-contexts: behaviour inference system backwards, as b 1 ; b 2 b 0 1 ; b 0 2 does not entail b 1 b 0 1 and b 2 b 0 (consider e.g. b 1 = b 0 2 = " and b 0 6 A similar claim is formalised in <ref> [18] </ref> where a syntactically deoned ordering on be-haviours is shown to be a decidable subset of the undecidable simulation ordering, deoned using an operational semantics for behaviours. 7 One might also add the rule C ` (b 1 + b 2 ); b 3 j (b 1 ; b 3 )
Reference: [19] <author> Hanne Riis Nielson and Flemming Nielson and Torben Amtoft: </author> <title> Polymorphic subtypes for eoeect analysis: the static semantics. </title> <booktitle> In Analysis and Veriocation of Multiple-Agent Languages, </booktitle> <pages> pages 141171, </pages> <address> SLNCS 1192, </address> <year> 1997. </year>
Reference-contexts: Finally we should mention [31] where eoeects are incorporated into ML types in order to deal with region inference. The type system presented in <ref> [19] </ref> is a major step towards integrating poly-morphism, subtyping, and eoeects; it generalises the subeoeecting approach of [28] and admits eoeects into the subtyping approaches of [26, 8]. <p> To keep the development in <ref> [19] </ref> as simple as possible, region information is omitted from the eoeects. 1.3 Ma jor Achievement I: Causality Chapter 2 reintroduces regions and further improves on [19] in that causality is incorporated into the eoeects, thus following [17], and we shall therefore prefer to use the word ibehavioursj rather than ieoeectsj. <p> To keep the development in <ref> [19] </ref> as simple as possible, region information is omitted from the eoeects. 1.3 Ma jor Achievement I: Causality Chapter 2 reintroduces regions and further improves on [19] in that causality is incorporated into the eoeects, thus following [17], and we shall therefore prefer to use the word ibehavioursj rather than ieoeectsj. At the same time we slightly reformulate the notion of upwards closure used in the generalisation rule (cf. the preceding paragraph).
Reference: [20] <author> Prakash Panangaden and John H. Reppy: </author> <title> The essence of Concurrent ML. </title> <booktitle> In [13]. </booktitle>
Reference-contexts: 26] we do not allow inclusion between base types, such as int real; 1 http://www.daimi.aau.dk/flbra8130/TBA/TBA.html. 13 * unlike [7, 31] we do not enable polymorphic recursion in the type an- notations. 14 Chapter 2 The Static Semantics For illustrating our approach we have chosen a variant of Concurrent ML (CML) <ref> [22, 20] </ref> which includes * identioers x, function abstractions fn x)e and function applications e 1 e 2 (as in the -calculus); * polymorphic let-expressions (as in ML [11]); * recursive functions and conditionals (to facilitate programming); * constructors (for building data structures); * base functions (for inspecting and decomposing data
Reference: [21] <author> Gordon D. Plotkin: </author> <title> A structural approach to operational semantics. </title> <type> Report DAIMI FN-19, </type> <institution> Aarhus University, Denmark, </institution> <year> 1981. </year>
Reference-contexts: the kind of dynamic semantics used: for a denota-tional semantics one may require (as in [11]) that the denotation of e ihas typej t; for a big-step (natural) semantics one may require (as in [30, 10]) that if e ! v then v ihas typej t; for a small-step semantics <ref> [21] </ref> one requires (as in [33]) the following subject reduction property: if e ! e 0 then the inference system also assigns e 0 the type t.
Reference: [22] <author> John H. Reppy: </author> <title> Concurrent ML: Design, application and semantics. </title> <booktitle> In Proc. Functional Programming, Concurrency, Simulation and Automated Reasoning, </booktitle> <pages> pages 165198, </pages> <address> SLNCS 693, </address> <year> 1993. </year>
Reference-contexts: 26] we do not allow inclusion between base types, such as int real; 1 http://www.daimi.aau.dk/flbra8130/TBA/TBA.html. 13 * unlike [7, 31] we do not enable polymorphic recursion in the type an- notations. 14 Chapter 2 The Static Semantics For illustrating our approach we have chosen a variant of Concurrent ML (CML) <ref> [22, 20] </ref> which includes * identioers x, function abstractions fn x)e and function applications e 1 e 2 (as in the -calculus); * polymorphic let-expressions (as in ML [11]); * recursive functions and conditionals (to facilitate programming); * constructors (for building data structures); * base functions (for inspecting and decomposing data <p> This leads to a very powerful programming discipline, in particular in the presence of choose and wrap 1 , as is discussed in <ref> [22] </ref>. The non-sequential base functions are spawn, sync, channel l and these are explained below. <p> of a fi-component in t 1 ! fi t 2 (omitted in a isilentj function type t 1 ! t 2 ) and t event fi, and the presence of a ae-component in t chan ae, this is much the same type structure that is actually used in Concurrent ML <ref> [22] </ref>.
Reference: [23] <author> J.A. Robinson: </author> <title> A machine-oriented logic based on the resolution principle. </title> <journal> Journal of the ACM, </journal> <volume> 12:2341, </volume> <year> 1965. </year>
Reference-contexts: The deonition in [11] employs uniocation <ref> [23] </ref>: if e 1 has been given type t 0 ! t 1 and e 2 has been given type t 2 then in order to type e 1 e 2 one must unify t 0 and t 2 .
Reference: [24] <author> Jrg H. </author> <title> Siekmann: </title> <journal> Uniocation theory. J. Symbolic Computation, </journal> <volume> 7:207 274, </volume> <year> 1989. </year>
Reference-contexts: We thus have to rethink the uniocation algorithm; and as the behaviours of this paper do not seem to satisfy simple algebraic properties (such as associativity or commutativity) it appears unlikely that we can adapt results from uniocation theory <ref> [24] </ref> (to get a uniocation algorithm producing a set of unioers from which all other unioers can be derived).
Reference: [25] <author> Geooerey S. Smith: </author> <title> Polymorphic type inference for languages with overloading and subtyping. </title> <type> Ph.D thesis from Cornell, </type> <year> 1991. </year>
Reference-contexts: In [12] matching is performed by orst doing uniocation and then the resulting substitution is transformed such that it imaps into fresh variablesj. In <ref> [25, Fig. 3.7] </ref> it is orst checked whether it is possible to unify a certain set of equations, derived from the constraint set; if this is the case then the algorithm behaves similar to the one presented here except that the equivalence relation is no longer needed. 2 To formalise the
Reference: [26] <author> Geooerey S. Smith: </author> <title> Polymorphic type inference with overloading and subtyping. </title> <booktitle> In Proc. TAPSOFT '93, </booktitle> <pages> pages 671685, </pages> <address> SLNCS 668, </address> <year> 1993. </year> <title> Also see: Principal type schemes for functional programs with overloading and subtyping: </title> <booktitle> Science of Computer Programming 23, </booktitle> <pages> pages 197226, </pages> <year> 1994. </year>
Reference-contexts: Subtyping. Since then many papers have studied how to integrate sub-typing. A number of early papers did so by mainly focusing on the typed -calculus and only brieAEy dealing with let [12, 6]. Later papers have treated polymorphism in full generality <ref> [26, 8] </ref>. A key ingredient in these approaches is the simpliocation of the enormous set of constraints into something manageable [5, 26]. Eoeects. Already ML necessitates an incorporation of imperative eoeects due to the presence of ref-types. <p> Later papers have treated polymorphism in full generality [26, 8]. A key ingredient in these approaches is the simpliocation of the enormous set of constraints into something manageable <ref> [5, 26] </ref>. Eoeects. Already ML necessitates an incorporation of imperative eoeects due to the presence of ref-types. <p> The type system presented in [19] is a major step towards integrating poly-morphism, subtyping, and eoeects; it generalises the subeoeecting approach of [28] and admits eoeects into the subtyping approaches of <ref> [26, 8] </ref>. <p> In order to incorporate subtyping we also need to generate type constraints as in <ref> [6, 26] </ref>. The presence of type constraints is a consequence of our overall design: types and behaviours should be inferred simultaneously ifrom scratchj, as is done by the algorithm W presented in Sect. 4.1. <p> Still the algorithm will produce a rather unwieldy number of constraints; to reduce this number substantially we may apply an algorithm R (deoned in Sect. 4.4) which adapts the techniques of <ref> [5, 26] </ref>. 1.6 Syntactic Soundness In Sect. 4.5 we shall prove that W is (syntactically) sound, that is if W (A; e) = (S; t; b; C) then C; S A ` e : t & b. <p> turns out [15] that the system greatly assists in validating a number of safety properties for irealisticj concurrent systems. 1.9 Future Work We have seen that the present development integrates many features from previous approaches in the literature; below we mention some features that are not yet covered: * unlike <ref> [6, 26] </ref> we do not allow inclusion between base types, such as int real; 1 http://www.daimi.aau.dk/flbra8130/TBA/TBA.html. 13 * unlike [7, 31] we do not enable polymorphic recursion in the type an- notations. 14 Chapter 2 The Static Semantics For illustrating our approach we have chosen a variant of Concurrent ML (CML) <p> the behaviour of the spawned pro cess. (As discussed previously one might add wrap to the language: this constant transforms delayed communications of type t event fi into delayed communications of type t 0 event fi 0 .) We will incorporate the eoeects of [28, 17] into the approach of <ref> [26, 8] </ref> by deoning a type inference system with judgements of the form 5 We shall distinguish rather sharply between these two entities, but Observation 2.15 suggests that they may be identioed. 22 c A (c) () unit true; false bool 1; 0; 1; 2 int = int fi int ! <p> The overall structure of the type inference system of Figure 2.5 is very close to those of <ref> [26, 8] </ref> with a few components from [28, 17] thrown in; the novel ideas of our approach only show up as carefully constructed side conditions for some of the rules. <p> We then have separate rules for subtyping, instantiation and generalisation and we shall explain their side conditions in subsequent sections. 2.2 Subtyping Rule (sub) generalises the subeoeecting rule of [28] by incorporating subtyping and extends the subtyping rule of <ref> [26] </ref> to deal with behaviours. <p> The relation C ` t 1 t 2 expresses the usual notion of subtyping: given the assumptions in C, t 1 is a more precise approximation than t 2 . It is induced by the subeoeecting relation so unlike e.g. <ref> [26] </ref> we do not have any ordering on base types, such as int real; in particular it is contravariant in the argument position of a (silent as well as non-silent) function type. <p> (r 1 r 2 ) 2 C (reAE) C ` r r (trans) C ` r 1 r 2 C ` r 2 r 3 (bw) C ` (t chan ae) (t 0 chan ae 0 ) C ` ae ae 0 2.3 Instantiation Rule (ins) is much as in <ref> [26] </ref> and merely says that to take an instance of a type scheme we must ensure that the constraints are satisoed; this is expressed using the notion of solvability: Deonition 2.3 The type scheme 8 (~ff ~ fi~ae : C 0 ): t 0 is solvable from C by the substitution <p> C; A ` e 1 : t 1 & b 1 C; A ` e 2 : t 2 & b 2 2.4 Generalisation Except for the well-formedness requirement (explained later), rule (gen) seems close to the corresponding rule in <ref> [26] </ref>: clearly we cannot generalise over variables free in the global type assumptions or global constraint sets, and as in eoeect systems (e.g. [28]) we cannot generalise over variables visible in the eoeect. Furthermore, as in [26] solvability is imposed to ensure that we do not create type schemes that have <p> the well-formedness requirement (explained later), rule (gen) seems close to the corresponding rule in <ref> [26] </ref>: clearly we cannot generalise over variables free in the global type assumptions or global constraint sets, and as in eoeect systems (e.g. [28]) we cannot generalise over variables visible in the eoeect. Furthermore, as in [26] solvability is imposed to ensure that we do not create type schemes that have no instances; this condition ensures that the expressions let x = e 1 in e 2 and let x = e 1 in (x;e 2 ) are going to be equivalent in the type system. <p> types to the same location at various stages (although apparently it is always possible to choose the same type and still get subject reduction). 2 77 Chapter 4 The Inference Algorithm In designing an inference algorithm W for the type inference system we are motivated by the overall approach of <ref> [26, 6] </ref>. One ingredient (called W 0 ) of this will be to perform a syntax-directed traversal of the expression in order to determine its type and behaviour; this will involve constructing a constraint set for expressing the required relationship between the type and behaviour and region variables. <p> Recall (Fact 2.11 and Fact 2.13) that these notions are closed under substitution; this will not be the case for the notion of atomicity. Atomicity As in <ref> [12, 6, 26] </ref> we shall want the type constraints to match and shall decompose them into atomic constraints; in our setting these will not contain base types as we have no ordering among those. <p> (t 1 fi t 2 ff) by forcing ff to be replaced by a type expression that imatchesj the opposite side of the constraint, and for disallowing constraints like (t 1 fi t 2 t 0 1 ! fi t 0 2 ); a phenomenon that can be found in <ref> [12, 6, 26] </ref> as well. <p> The algorithm follows the overall approach of <ref> [26, 8] </ref> except that as in [6] there are no explicit uniocation steps; these all take place as part of the F transformation. The main novel ingredient of our approach shows up in the clause for let as we shall explain shortly. <p> : fl C fl 0 g with C the least equivalence relation satisfying that if (g 1 g 2 ) 2 C and fl; fl 0 2 FV (g 1 ; g 2 ) then fl C fl 0 ; 2 This is exactly the place where the algorithm of <ref> [26] </ref> makes use of constraint simplio cation in the iclosej function. 82 * C j f~ff ~ fi~aeg = f (g 1 g 2 ) 2 C j FV (g 1 ; g 2 ) " f~ff ~ fi~aeg 6= ;g. <p> The techniques used are basically those of <ref> [26] </ref> and [5], adapted to our framework. The transformation R may be described as a non-deterministic rewriting process, operating over triples of the form (C; t; b) with C atomic, and with respect to a oxed environment A. <p> We now explain the rules: (redund) removes constraints which are redundant due to the ordering being reAEexive and transitive; applying this rule repeatedly is called itransitive reductionj in <ref> [26] </ref> and is essential for a compact representation of the constraints. The remaining rules all replace some variable fl by another variable fl 0 . <p> the requirement concerning ChanVar (t; b; C) is needed for technical reasons but notice that we may expect that all variables in ChanVar (t; b; C) will belong to FV (A 0 ) for some A 0 encountered during the algorithm (inside some channel type t 0 chan ae). (In <ref> [26] </ref> it holds that ; ` t 1 j t 2 implies t 1 = t 2 so if fl and fl 0 belong to the same cycle in C then all substitutions that solve C can be written on the form S 0 [fl 7! fl 0 ], hence cycle <p> Note that unlike the corresponding concept in <ref> [26] </ref> we allow to replace C by any C 0 such that C 0 ` C thus borrowing ideas from Kripke 102 semantics. In our view this is essential for achieving substitution and entail-ment properties throughout and for avoiding the problem identioed in [26] about enlarging the constraint set. 2 We <p> Note that unlike the corresponding concept in <ref> [26] </ref> we allow to replace C by any C 0 such that C 0 ` C thus borrowing ideas from Kripke 102 semantics. In our view this is essential for achieving substitution and entail-ment properties throughout and for avoiding the problem identioed in [26] about enlarging the constraint set. 2 We write oe 1 C oe 2 also in the case where oe 1 or oe 2 are types: here ts C t means ts C 8 (() : ;): t and t C oe means 8 (() : ;): t C oe. <p> As we shall see below (Lemma 5.13) it is the restriction to atomic constraints C fl that allows algorithm F to manipulate type constraints without losing instances. The decomposition of S 00 into S 0 S is standard and may be found also in <ref> [26, 8] </ref>. <p> As we shall see below (Lemma 5.13) it is the restriction to atomic constraints C fl that allows algorithm F to manipulate type constraints without losing instances. The decomposition of S 00 into S 0 S is standard and may be found also in [26, 8]. Just as in <ref> [26] </ref> our hypothesis cannot simply be A fl = S 00 A but has to be A fl C fl S 00 A; this is necessary for the inductive proof due to the fact that the occurrences of rule (gen) in C fl ; A fl ` e : oe fl
Reference: [27] <author> Jean-Pierre Talpin and Pierre Jouvelot: </author> <title> Polymorphic type, region and eoeect inference. </title> <journal> Journal of Functional Programming, </journal> <volume> 2(3):245271, </volume> <year> 1992. </year>
Reference-contexts: When designing a reconstruction algorithm it is apparently a key feature to require all types in question to be simple, as in <ref> [27] </ref> and [32], but in [27] the inference system employs non-simple types and in [32] a idi-rectj as well as an iindirectj inference system (the latter geared towards an algorithm employing constraints) is given. <p> When designing a reconstruction algorithm it is apparently a key feature to require all types in question to be simple, as in <ref> [27] </ref> and [32], but in [27] the inference system employs non-simple types and in [32] a idi-rectj as well as an iindirectj inference system (the latter geared towards an algorithm employing constraints) is given.
Reference: [28] <author> Jean-Pierre Talpin and Pierre Jouvelot: </author> <title> The type and eoeect discipline. </title> <journal> Information and Computation, </journal> <volume> 111, </volume> <year> 1994. </year> <note> (A preliminary version appeared in Proc. LICS '92, pages 162173.) </note>
Reference-contexts: Eoeects may be approximated by larger eoeects, that is the system employs subeoeecting. * <ref> [28] </ref> can be considered a reonement of [32] in that eoeects also record the region in which a reference cell is created or a read/write operation is performed; this information enables one to imaskj eoeects which have taken place in iinaccessiblej regions. * [10] presents a somewhat alternative view: here focus <p> This method is quite powerful but unfortunately it fails to be a conservative extension of ML: some purely applicative programs which are typeable in ML may be untypeable in this system. The surveys in <ref> [28, section 11] </ref> and in [32, section 5] show that many of these (and other) systems are incomparable, in the sense that for any two approaches it will often be the case that there are programs which are accepted by one of them but not by the other, and vice versa. <p> Finally we should mention [31] where eoeects are incorporated into ML types in order to deal with region inference. The type system presented in [19] is a major step towards integrating poly-morphism, subtyping, and eoeects; it generalises the subeoeecting approach of <ref> [28] </ref> and admits eoeects into the subtyping approaches of [26, 8]. <p> (as is formally done in [2]) one must be very careful when deciding the set of variables over which to generalise in the inference rule for let: not only should this set be disjoint from the set of variables occurring in the eoeect (as is standard in eoeect systems, e.g. <ref> [28] </ref>) but it should also be upwards closed with respect to a 9 constraint set. <p> id over a newly created channel. (To be able to execute one would need to spawn a process that could read over the same channel.) This program is of interest because it will be rejected by a system using subeoeecting only, whereas it will be accepted in the systems of <ref> [28] </ref> and [30]. 19 In Sect. 2.5 we shall see that we will be able to type this program in our system as well! 2 2.1 Annotated Types To prepare for the type inference system we must clarify the syntax of types, behaviours, regions, substitutions, type schemes, and constraints. <p> So compared with the eoeects in e.g. <ref> [28] </ref> we have (by means of the ; operator) incorporated causality information; on the other hand we have not allowed to mask out behaviours which operate on iinaccessiblej regions (cf. Chap. 1). <p> onally the type of spawn records the behaviour of the spawned pro cess. (As discussed previously one might add wrap to the language: this constant transforms delayed communications of type t event fi into delayed communications of type t 0 event fi 0 .) We will incorporate the eoeects of <ref> [28, 17] </ref> into the approach of [26, 8] by deoning a type inference system with judgements of the form 5 We shall distinguish rather sharply between these two entities, but Observation 2.15 suggests that they may be identioed. 22 c A (c) () unit true; false bool 1; 0; 1; 2 <p> The overall structure of the type inference system of Figure 2.5 is very close to those of [26, 8] with a few components from <ref> [28, 17] </ref> thrown in; the novel ideas of our approach only show up as carefully constructed side conditions for some of the rules. <p> We then have separate rules for subtyping, instantiation and generalisation and we shall explain their side conditions in subsequent sections. 2.2 Subtyping Rule (sub) generalises the subeoeecting rule of <ref> [28] </ref> by incorporating subtyping and extends the subtyping rule of [26] to deal with behaviours. <p> ` e 2 : t 2 & b 2 2.4 Generalisation Except for the well-formedness requirement (explained later), rule (gen) seems close to the corresponding rule in [26]: clearly we cannot generalise over variables free in the global type assumptions or global constraint sets, and as in eoeect systems (e.g. <ref> [28] </ref>) we cannot generalise over variables visible in the eoeect. <p> be typed. (It is interesting to point out that if one changed the applied occurrence of f in the program to the expression fn z =&gt; f z then subeoeecting would suOEce for generalising over ff y and hence would allow to type the self-application of id.) The system of <ref> [28] </ref> does not have subtyping but nevertheless the application of id to itself is typeable [28, section 11, the case (id4 id4)]. <p> of f in the program to the expression fn z =&gt; f z then subeoeecting would suOEce for generalising over ff y and hence would allow to type the self-application of id.) The system of [28] does not have subtyping but nevertheless the application of id to itself is typeable <ref> [28, section 11, the case (id4 id4)] </ref>.
Reference: [29] <author> Yan-Mei Tang: </author> <title> Control AEow analysis by eoeect systems and abstract interpretation. </title> <type> PhD thesis, </type> <institution> Ecoles des Mines de Paris, </institution> <year> 1994. </year>
Reference-contexts: Integration. In the area of static program analysis, annotated type and eoeect systems have been used as the basis for control AEow analysis <ref> [29] </ref> and binding time analysis [16, 7]. These papers typically make use of a polymorphic type system with subtyping and no eoeects, or a non-polymorphic type system with eoeects and subtyping. <p> The presence of type constraints is a consequence of our overall design: types and behaviours should be inferred simultaneously ifrom scratchj, as is done by the algorithm W presented in Sect. 4.1. This should be compared with the approach in <ref> [29, chapter 5] </ref> where an eoeect system with subtyping but without polymorphism is presented; as the iunderlyingj types are given in advance it is suOEcient to generate behaviour constraints.
Reference: [30] <author> Mads Tofte: </author> <title> Type inference for polymorphic references. Information and Computation, </title> <address> 89:134, </address> <year> 1990. </year>
Reference-contexts: A key ingredient in these approaches is the simpliocation of the enormous set of constraints into something manageable [5, 26]. Eoeects. Already ML necessitates an incorporation of imperative eoeects due to the presence of ref-types. A pioneering paper in the area is <ref> [30] </ref> that develops a distinction between imperative and applicative type variables: for creation of a reference cell we demand that its type contain imperative variables only; and one is not allowed to generalise over imperative variables unless the expression in question is non-expansive (i.e. does not expand the store) which will <p> The problem of typing ML with references (but without subtyping) has lead to a number of attempts to improve upon <ref> [30] </ref>; this includes the following: * [32] is similar in spirit to [30] in that one is not allowed to generalise over a type variable if a reference cell has been created with a type containing this variable; to trace such variables the type system is augmented with eoeects. <p> The problem of typing ML with references (but without subtyping) has lead to a number of attempts to improve upon <ref> [30] </ref>; this includes the following: * [32] is similar in spirit to [30] in that one is not allowed to generalise over a type variable if a reference cell has been created with a type containing this variable; to trace such variables the type system is augmented with eoeects. <p> premise that the inference system assigns a type t to e but the conclusion depends on the kind of dynamic semantics used: for a denota-tional semantics one may require (as in [11]) that the denotation of e ihas typej t; for a big-step (natural) semantics one may require (as in <ref> [30, 10] </ref>) that if e ! v then v ihas typej t; for a small-step semantics [21] one requires (as in [33]) the following subject reduction property: if e ! e 0 then the inference system also assigns e 0 the type t. <p> The general picture is much as in [17] that types are unchanged whereas the behaviours get ismallerj and the environments are iextendedj. Extending the environment is a potential danger to semantic soundness, cf. the considerations in <ref> [30, section 5] </ref> where it was concluded that store operations in Standard ML are harmless unless they actually expand the store. <p> a newly created channel. (To be able to execute one would need to spawn a process that could read over the same channel.) This program is of interest because it will be rejected by a system using subeoeecting only, whereas it will be accepted in the systems of [28] and <ref> [30] </ref>. 19 In Sect. 2.5 we shall see that we will be able to type this program in our system as well! 2 2.1 Annotated Types To prepare for the type inference system we must clarify the syntax of types, behaviours, regions, substitutions, type schemes, and constraints. <p> Thus the two branches of the conditional will match. Also in the approach of <ref> [30] </ref> one can generalise over ff y and hence type the self-application of id. <p> We refer to <ref> [30] </ref> for the details. 2.6 Basic Properties of the Inference System We now list a few basic properties of the inference system that we shall use later. <p> Such an extension is a potential danger to semantic soundness, cf. the considerations in <ref> [30, section 5] </ref> where it was concluded that store operations in Standard ML are harmless unless they actually expand the store; in order to construct an inference tree with the new environment we must demand that the new environment variables are ipresentj in the behaviour. * The inewj expression e n
Reference: [31] <author> Mads Tofte and Lars Birkedal: </author> <title> Region-annotated types and type schemes, </title> <note> 1996. Submitted for publication. </note>
Reference-contexts: Finally we should mention <ref> [31] </ref> where eoeects are incorporated into ML types in order to deal with region inference. The type system presented in [19] is a major step towards integrating poly-morphism, subtyping, and eoeects; it generalises the subeoeecting approach of [28] and admits eoeects into the subtyping approaches of [26, 8]. <p> 1.9 Future Work We have seen that the present development integrates many features from previous approaches in the literature; below we mention some features that are not yet covered: * unlike [6, 26] we do not allow inclusion between base types, such as int real; 1 http://www.daimi.aau.dk/flbra8130/TBA/TBA.html. 13 * unlike <ref> [7, 31] </ref> we do not enable polymorphic recursion in the type an- notations. 14 Chapter 2 The Static Semantics For illustrating our approach we have chosen a variant of Concurrent ML (CML) [22, 20] which includes * identioers x, function abstractions fn x)e and function applications e 1 e 2 (as <p> We have chosen (also to facilitate the correctness proof of the algorithm) a more uniform approach, perhaps similar in spirit to <ref> [31] </ref> where arrows are annotated with pairs of the form *:OE with * an eoeect variable and with OE a set of region or eoeect variables: one can think of this as an arrow annotated with * together with the con 21 straint OE *.
Reference: [32] <author> Andrew K. Wright: </author> <title> Typing references by eoeect inference. </title> <booktitle> In Proc. ESOP '92, </booktitle> <pages> pages 473491, </pages> <address> SLNCS 582, </address> <year> 1992. </year> <month> 212 </month>
Reference-contexts: The problem of typing ML with references (but without subtyping) has lead to a number of attempts to improve upon [30]; this includes the following: * <ref> [32] </ref> is similar in spirit to [30] in that one is not allowed to generalise over a type variable if a reference cell has been created with a type containing this variable; to trace such variables the type system is augmented with eoeects. <p> Eoeects may be approximated by larger eoeects, that is the system employs subeoeecting. * [28] can be considered a reonement of <ref> [32] </ref> in that eoeects also record the region in which a reference cell is created or a read/write operation is performed; this information enables one to imaskj eoeects which have taken place in iinaccessiblej regions. * [10] presents a somewhat alternative view: here focus is not on detecting creation of reference <p> This method is quite powerful but unfortunately it fails to be a conservative extension of ML: some purely applicative programs which are typeable in ML may be untypeable in this system. The surveys in [28, section 11] and in <ref> [32, section 5] </ref> show that many of these (and other) systems are incomparable, in the sense that for any two approaches it will often be the case that there are programs which are accepted by one of them but not by the other, and vice versa. <p> As the main distinguishing feature of our inference system (as mentioned above), essential for semantic soundness, was the choice of generalisation rule; so the distinguishing feature of our algorithm, essential for syntactic soundness (and eventually for syntactic completeness), is the choice of gener-alisation rule. This involves (rather similar to <ref> [32] </ref>) taking downwards closure of a set of variables with respect to a constraint set. 12 1.7 Major Achievement II: Completeness Chapter 5 is devoted to the diOEcult task of proving the completeness of the algorithm presented in Chap. 4. <p> When designing a reconstruction algorithm it is apparently a key feature to require all types in question to be simple, as in [27] and <ref> [32] </ref>, but in [27] the inference system employs non-simple types and in [32] a idi-rectj as well as an iindirectj inference system (the latter geared towards an algorithm employing constraints) is given. <p> When designing a reconstruction algorithm it is apparently a key feature to require all types in question to be simple, as in [27] and <ref> [32] </ref>, but in [27] the inference system employs non-simple types and in [32] a idi-rectj as well as an iindirectj inference system (the latter geared towards an algorithm employing constraints) is given. <p> Other approaches We have demonstrated that the program from Example 2.2 can be typed in our system, where the subtyping rule was used to establish (9); we shall now examine how other type systems behave on this program. First consider a system similar to <ref> [32] </ref> in that (i) it employs subeoeecting only, and (ii) it contains no constraints, so all behaviour information has to be explicitly coded into the types. <p> The exclusion of the set FV (A; b) C# (rather than just FV (A; b)) is necessary in order to ensure f~ff ~ fi~aeg C 0 " = f~ff ~ fi~aeg which is essential for semantic soundness (cf. the discussion in the Introduction); the computation of iIndirect Free Variablesj of <ref> [32] </ref> is very similar to our notion of downwards closure. <p> Finally we have chosen Clos (FV (t); C) as the iuniversej in which to perform the set dioeerence; this universe must be large enough that we may still hope for syntactic completeness and all of FV (t), FV (t) C# (similar to what is in fact taken in <ref> [32] </ref>) and FV (t) C" are apparently too small for this (except for the latter they are not even upwards closed). Fact 4.4 Let oe = GEN (A; b)(C; t). If C is atomic then oe is well-formed.
Reference: [33] <author> Andrew K. Wright and Matthias Felleisen: </author> <title> A syntactic approach to type soundness. </title> <journal> Information and Computation, </journal> <volume> 115, </volume> <pages> pages 3894, </pages> <year> 1994. </year> <month> 213 </month>
Reference-contexts: used: for a denota-tional semantics one may require (as in [11]) that the denotation of e ihas typej t; for a big-step (natural) semantics one may require (as in [30, 10]) that if e ! v then v ihas typej t; for a small-step semantics [21] one requires (as in <ref> [33] </ref>) the following subject reduction property: if e ! e 0 then the inference system also assigns e 0 the type t. In addition, in order to ensure that iwell-typed programs do not go wrongj [11] one must establish that ierror conogurationsj (those which are istuckj) cannot be typed. <p> To this end one usually (cf. the methodical considerations in <ref> [33] </ref>) wants a result that guarantees that ierror conogura-tions are not typeablej; here we presuppose some consistent constraint set C and some standard channel environment A, and assume A is solvable from C so by Lemma 2.24 we need consider only normalised inferences. (The reason for demanding consistency is that otherwise <p> This should be compared with the subject reduction result in <ref> [33, Lemma 5.2] </ref>, the formulation of which allows one the possibility of assigning dioeerent types to the same location at various stages (although apparently it is always possible to choose the same type and still get subject reduction). 2 77 Chapter 4 The Inference Algorithm In designing an inference algorithm W
References-found: 33

