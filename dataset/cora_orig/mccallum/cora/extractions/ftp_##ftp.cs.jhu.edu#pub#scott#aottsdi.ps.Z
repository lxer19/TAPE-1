URL: ftp://ftp.cs.jhu.edu/pub/scott/aottsdi.ps.Z
Refering-URL: http://www.cs.jhu.edu/labs/pll/home.html
Root-URL: http://www.cs.jhu.edu
Email: amyg@cs.jhu.edu  
Title: Application of OOP Type Theory: State, Decidability, Integration  
Author: Jonathan Eifrig Scott Smith Valery Trifonov Amy Zwarico feifrig, scott, trifonov, 
Affiliation: Department of Computer Science, The Johns Hopkins University  
Abstract: Important strides toward developing expressive yet semantically sound type systems for object-oriented programming languages have recently been made by Cook, Bruce, Mitchell, and others. This paper focusses on how the theoretical work using F-bounded quantification may be brought more into the realm of actual language implementations while preserving rigorous soundness properties. We simultaneously address three of the more significant problems: adding a notion of global state, proving type-checking is decidable, and integrating the more widely implemented view that subclasses correspond to subtypes with the F-bounded view. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Amadio and L. Cardelli. </author> <title> Subtyping recursive types. </title> <booktitle> In Conference Record of the Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1991. </year>
Reference-contexts: Examples are rules for distributing quantifiers over type constructors, and the more sophisticated subtyping relation on recursive types of <ref> [1] </ref>. 5 Loop Type Soundness In this section we present the Loop type system, and show how Loop terms and types may be given meaning by translation into Soop, the result being Loop programs experience no "message not understood" errors upon execution. 5.1 The Loop Type System The syntax of Loop <p> On the other hand Loop does not have the subtyping rule for objects types of TOIL (adopted in a restricted form from the system of <ref> [1] </ref>), so there are programs using open-ended "self-type" ty-pable in TOIL but not in Loop; however the TOIL rule disallows negative occurrences of "self-type" in the supertype, which limits its applicability to infrequent cases.
Reference: [2] <author> K. Bruce. </author> <title> Safe type checking in a statically-typed object-oriented programming language. </title> <booktitle> In Conference Record of the Twentieth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 285-298, </pages> <year> 1993. </year>
Reference-contexts: To frame the problem we desire a static type system that preserves all of the classic features of (untyped) class-based OOP, including treatment of two particularly difficult issues: binary methods and object subsumption. Important strides toward solving this problem have recently been made <ref> [8, 5, 2, 15] </ref>. By using F-bounded quantification, these researchers can capture the open-ended nature of class definitions in the presence of inheritance: "self" refers not only to the current class being defined, but also to any future extension of it by subclassing. <p> This principle is currently at the core of most of the commonly used typed object-oriented programming languages, including C++ and Object Pascal. However, problems arise in the presence of methods that take and/or return objects of "self-type," the type of the object containing the method itself <ref> [8, 2] </ref>. There are two common views of how "self" should be treated when typing a class expression. In one view, its type is fixed and thus denotes an object of the current class only. <p> See [8] for more discussion of how the open-ended view of "self" relates to other approaches in the literature. Bruce and van Gent [4] have defined an imperative OOP language, TOIL, which is an imperative extension of TOOPL <ref> [2] </ref> (a decidability proof for type-checking of another variant of TOOPL is presented in [3]). TOIL and Loop are closely related, since both are based on F-bounded quantification; here we outline some differences. We interpret Loop via translation to Soop, while TOIL is given semantics directly.
Reference: [3] <author> K. B. Bruce, J. Crabtree, T. P. Murtagh, R. van Gent, A. Dimock, and R. Muller. </author> <title> Safe and decidable type checking in an object-oriented language. </title> <booktitle> In OOPSLA '93 Conference Proceedings, </booktitle> <year> 1993. </year>
Reference-contexts: Nearly all previous semantic work takes a functional view of objects; however, state is of central importance to OOP and cannot be ignored. Another problem is that an implementable language requires decidable type checking. Some progress has been made in this area for functional OO languages <ref> [3] </ref>, but the problem is difficult and the most general type systems may prove to be undecibible [16]. <p> Bruce and van Gent [4] have defined an imperative OOP language, TOIL, which is an imperative extension of TOOPL [2] (a decidability proof for type-checking of another variant of TOOPL is presented in <ref> [3] </ref>). TOIL and Loop are closely related, since both are based on F-bounded quantification; here we outline some differences. We interpret Loop via translation to Soop, while TOIL is given semantics directly.
Reference: [4] <author> Kim B. Bruce and Robert van Gent. </author> <title> TOIL: A new type-safe object-oriented imperative language. </title> <type> Technical report, </type> <institution> Williams College, </institution> <year> 1993. </year>
Reference-contexts: Several solutions with various limitations have been proposed; the reader is referred to <ref> [12, 4] </ref> and the discussions in [9] for details. Our approach avoids these limitations by defining a fixed point combinator in terms of mutable cells in the spirit of Landin. <p> See [8] for more discussion of how the open-ended view of "self" relates to other approaches in the literature. Bruce and van Gent <ref> [4] </ref> have defined an imperative OOP language, TOIL, which is an imperative extension of TOOPL [2] (a decidability proof for type-checking of another variant of TOOPL is presented in [3]). TOIL and Loop are closely related, since both are based on F-bounded quantification; here we outline some differences.
Reference: [5] <author> P. Canning, W. Cook, W. Hill, J. Mitchell, and W. Olthoff. </author> <title> F-bounded polymorphism for object-oriented programming. </title> <booktitle> In Proceedings of the Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 273-280, </pages> <year> 1989. </year>
Reference-contexts: To frame the problem we desire a static type system that preserves all of the classic features of (untyped) class-based OOP, including treatment of two particularly difficult issues: binary methods and object subsumption. Important strides toward solving this problem have recently been made <ref> [8, 5, 2, 15] </ref>. By using F-bounded quantification, these researchers can capture the open-ended nature of class definitions in the presence of inheritance: "self" refers not only to the current class being defined, but also to any future extension of it by subclassing. <p> The type expression 8 [t i i ]: t binds the type variables t i in each of their upper bounds i as well as in the body t ; this allows a form of F-bounded polymorphism <ref> [5] </ref>. The type variable t is bound in t: t . By convention 8 and have lower precedence than the arrow. We use FTV (t ) to denote the set of free type variables of t . <p> The converse part (correctness of the inferred type) follows trivially. 2 Termination of the algorithm follows similarly by induction on the structure of Loop terms, and by ter mination of the algorithms for subtype checking and computing least upper bounds. 7 Discussion We have shown here how the ideas of <ref> [5] </ref> used to model typed functional OOP can be applied to Loop, a state-based OOP language with decidable type-checking. We also explored the deficiencies that arise from the fact that subtyping is not inheritance, and showed how fixed-self typings may thus sometimes be preferable.
Reference: [6] <author> L. Cardelli. </author> <title> A semantics of multiple inheritance. In Semantics of Data Types, </title> <booktitle> volume 173 of Lecture notes in Computer Science, </booktitle> <pages> pages 51-67. </pages> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: We use FTV (t ) to denote the set of free type variables of t . The Soop types are partially ordered by the subtyp-ing relation , formalized by the system of rules in Figure 3. The subtyping system is an extension of the standard record subtyping <ref> [6] </ref> with recursive and F-bounded polymorphic types. A constraint system C is a finite map in TVar !Typ; in our proof rules for the subtyping relation such functions serve as systems of assumptions about the free type variables, mapping them to their respective upper bounds.
Reference: [7] <author> W. Cook and J. Palsberg. </author> <title> A denotational semantics of inheritance and its correctness. </title> <booktitle> In OOPSLA '89 Proceedings, </booktitle> <pages> pages 433-443, </pages> <year> 1989. </year>
Reference-contexts: When a new object is created, its instance variables are hidden, and the "self-type" t becomes fixed. 5.2 Operational Semantics The semantics of Loop is defined via a translation of Loop terms into Soop terms; this translation is given in Figure 7. In many encodings of object-oriented languages <ref> [7, 13] </ref> an object is defined as a record formed by taking a fixed point of a class function, a function mapping records to records. This results in a recursive record, and the methods of the object|fields of the record|gain access to its "self" by unrolling the fixed point expression.
Reference: [8] <author> William R. Cook, Walter L. Hill, and Peter S. Canning. </author> <title> Inheritance is not subtyping. </title> <booktitle> In Conference Record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages. </booktitle> <publisher> ACM Press, </publisher> <year> 1990. </year>
Reference-contexts: To frame the problem we desire a static type system that preserves all of the classic features of (untyped) class-based OOP, including treatment of two particularly difficult issues: binary methods and object subsumption. Important strides toward solving this problem have recently been made <ref> [8, 5, 2, 15] </ref>. By using F-bounded quantification, these researchers can capture the open-ended nature of class definitions in the presence of inheritance: "self" refers not only to the current class being defined, but also to any future extension of it by subclassing. <p> This principle is currently at the core of most of the commonly used typed object-oriented programming languages, including C++ and Object Pascal. However, problems arise in the presence of methods that take and/or return objects of "self-type," the type of the object containing the method itself <ref> [8, 2] </ref>. There are two common views of how "self" should be treated when typing a class expression. In one view, its type is fixed and thus denotes an object of the current class only. <p> In purely functional languages this encoding produces good results, but the situation changes with the introduction of effects and call-by-value semantics. The associated fixed point combinator is then only well-defined on functionals, but as pointed out for instance in <ref> [8] </ref>, classes do not correspond to functionals. <p> Ghelli presents another solution to the fixed/open "self" problem that always preserves subtyping between subclass and superclass objects, but at the expense of requiring redefinition of a method whenever the type changes, and doing dynamic dispatching based on the type information at run-time [11]. See <ref> [8] </ref> for more discussion of how the open-ended view of "self" relates to other approaches in the literature.
Reference: [9] <author> J. Eifrig, S. Smith, V. Trifonov, and A. Zwarico. </author> <title> An interpretation of typed OOP in a language with state. </title> <booktitle> Lisp and Symbolic Computation, </booktitle> <year> 1995. </year> <note> To appear. </note>
Reference-contexts: Due to space considerations the Soop operational semantics and type soundness proofs cannot be presented in detail here; complete proofs may be found in <ref> [9] </ref>. Here we must settle for a brief outline. We present semantics of Soop in the general framework of [10, 14]. The operational interpreter of the language is specified by binary relations between Soop terms in memory environments, which represent the notion of computation. <p> Several solutions with various limitations have been proposed; the reader is referred to [12, 4] and the discussions in <ref> [9] </ref> for details. Our approach avoids these limitations by defining a fixed point combinator in terms of mutable cells in the spirit of Landin. <p> When t occurs free in M , this will allow the methods to have open-ended notions of "self-type." 5.3 Type Soundness of Loop We now sketch how type soundness may be proven for Loop. Proofs are omitted for lack of space; see <ref> [9] </ref> for complete proofs. The language studied there is an un-typed version of Loop and since the translation ignores explicit type information, proofs are unchanged. The translation of Loop type expressions and judgements into Soop judgements appears in Figure 7.
Reference: [10] <author> M. Felleisen and R. Hieb. </author> <title> The revised report on the syntactic theories of sequential control and state. </title> <journal> Theoretical Computer Science, </journal> <volume> 102 </volume> <pages> 235-271, </pages> <year> 1992. </year>
Reference-contexts: Due to space considerations the Soop operational semantics and type soundness proofs cannot be presented in detail here; complete proofs may be found in [9]. Here we must settle for a brief outline. We present semantics of Soop in the general framework of <ref> [10, 14] </ref>. The operational interpreter of the language is specified by binary relations between Soop terms in memory environments, which represent the notion of computation. A computation state h; ei is a pair of a memory 2 Var ! Val and an expression e.
Reference: [11] <author> Giorgio Ghelli. </author> <title> A static type system for message passing. </title> <booktitle> In Proc. OOPSLA, </booktitle> <pages> pages 129-145, </pages> <year> 1991. </year>
Reference-contexts: To be clear, we do not address delegation-style OOP here [15], nor do we consider having dynamic dispatch based on type information known at run-time <ref> [11] </ref>. 2 The Loop Language We begin our discussion by defining a representative object-oriented programming language, Loop (Little Object-Oriented Programming language). <p> In particular, it is possible to have positive occurrences of SelfType be open-ended and negative occurrences fixed, preserving some open-endedness and at the same time conforming to the subclasses-generate-subtypes principle. The terms covariance and contravariance are sometimes used in the literature when discussing this topic <ref> [11] </ref>. <p> Ghelli presents another solution to the fixed/open "self" problem that always preserves subtyping between subclass and superclass objects, but at the expense of requiring redefinition of a method whenever the type changes, and doing dynamic dispatching based on the type information at run-time <ref> [11] </ref>. See [8] for more discussion of how the open-ended view of "self" relates to other approaches in the literature.
Reference: [12] <author> A. V. Hense. </author> <title> Wrapper semantics of an object-oriented programming language with state. </title> <booktitle> In Proceedings of the International Conference on Theoretical Aspects of Computer Software, volume 526 of Lecture notes in Computer Science, </booktitle> <pages> pages 548-567. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Several solutions with various limitations have been proposed; the reader is referred to <ref> [12, 4] </ref> and the discussions in [9] for details. Our approach avoids these limitations by defining a fixed point combinator in terms of mutable cells in the spirit of Landin.
Reference: [13] <author> Samuel N. Kamin and Uday S. Reddy. </author> <title> Two Semantic Models of Object-Oriented Languages, </title> <booktitle> chapter 13, </booktitle> <pages> pages 464-495. </pages> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: When a new object is created, its instance variables are hidden, and the "self-type" t becomes fixed. 5.2 Operational Semantics The semantics of Loop is defined via a translation of Loop terms into Soop terms; this translation is given in Figure 7. In many encodings of object-oriented languages <ref> [7, 13] </ref> an object is defined as a record formed by taking a fixed point of a class function, a function mapping records to records. This results in a recursive record, and the methods of the object|fields of the record|gain access to its "self" by unrolling the fixed point expression.
Reference: [14] <author> I. A. Mason and C. L. Talcott. </author> <title> Equivalence in functional languages with effects. </title> <journal> Journal of Functional Programming, </journal> <volume> 1 </volume> <pages> 287-327, </pages> <year> 1991. </year>
Reference-contexts: Due to space considerations the Soop operational semantics and type soundness proofs cannot be presented in detail here; complete proofs may be found in [9]. Here we must settle for a brief outline. We present semantics of Soop in the general framework of <ref> [10, 14] </ref>. The operational interpreter of the language is specified by binary relations between Soop terms in memory environments, which represent the notion of computation. A computation state h; ei is a pair of a memory 2 Var ! Val and an expression e.
Reference: [15] <author> J. Mitchell. </author> <title> Towards a typed foundation for method specialization and inheritance. </title> <booktitle> In Conference Record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1990. </year>
Reference-contexts: To frame the problem we desire a static type system that preserves all of the classic features of (untyped) class-based OOP, including treatment of two particularly difficult issues: binary methods and object subsumption. Important strides toward solving this problem have recently been made <ref> [8, 5, 2, 15] </ref>. By using F-bounded quantification, these researchers can capture the open-ended nature of class definitions in the presence of inheritance: "self" refers not only to the current class being defined, but also to any future extension of it by subclassing. <p> We give a collection of type rules for Soop and show the rules sound with respect to an operational semantics: no run-time type errors can occur. To be clear, we do not address delegation-style OOP here <ref> [15] </ref>, nor do we consider having dynamic dispatch based on type information known at run-time [11]. 2 The Loop Language We begin our discussion by defining a representative object-oriented programming language, Loop (Little Object-Oriented Programming language).
Reference: [16] <author> B. Pierce. </author> <title> Bounded quantification is undecidable. </title> <booktitle> In Conference Record of the Nineteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 305-315, </pages> <year> 1992. </year>
Reference-contexts: Another problem is that an implementable language requires decidable type checking. Some progress has been made in this area for functional OO languages [3], but the problem is difficult and the most general type systems may prove to be undecibible <ref> [16] </ref>.
Reference: [17] <author> Didier Remy. </author> <title> Type inference for records in a natural extension of ML. </title> <editor> In Carl A. Gunter and John C. Mitchell, editors, </editor> <title> Theoretical Aspects Of Object-Oriented Programming. Types, Semantics and Language Design. </title> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: Classes are not fully "first-class citizens": we cannot write a function that takes an arbitrary class as argument and returns a class with some methods added. To achieve this, some notion of extensible record would need to be added to Soop <ref> [17] </ref>.
Reference: [18] <author> J.P. Seldin. </author> <title> A sequent calculus for type assignment. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 42 </volume> <pages> 11-28, </pages> <year> 1977. </year>
Reference-contexts: Theorem 4.3 (Soop Type Soundness) If ` h; ei : t , then either h; ei diverges, or h; ei 7! fl h 0 ; vi and 0 ` h 0 ; vi : t for some 0 . In comparison with proofs of subject reduction for the -calculus <ref> [18] </ref> and ML-style polymorphic languages [19], the proof for the Soop type system is complicated by the relatively rich subtyping relation.
Reference: [19] <author> A. Wright and M. Felleisen. </author> <title> A syntactic approach to type soundness. </title> <type> Technical Report TR91-160, </type> <institution> Rice University Department of Computer Science, </institution> <year> 1991. </year> <note> To appear in Information and Computation. </note>
Reference-contexts: Typing of computation states is defined as follows: ` h; ei : t if ;; ` e : t , and ;; ` (x) : t x where (x) = t x Ref, for each x 2 dom (). Following <ref> [19] </ref> we establish soundness of the type system of Soop with respect to the computation relations by proving that a subject reduction property holds for this type system, and that the stuck states cannot be given types. <p> In comparison with proofs of subject reduction for the -calculus [18] and ML-style polymorphic languages <ref> [19] </ref>, the proof for the Soop type system is complicated by the relatively rich subtyping relation.
References-found: 19

