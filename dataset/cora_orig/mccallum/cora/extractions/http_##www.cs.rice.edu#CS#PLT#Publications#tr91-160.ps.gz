URL: http://www.cs.rice.edu/CS/PLT/Publications/tr91-160.ps.gz
Refering-URL: http://www.cs.rice.edu/CS/PLT/Publications/
Root-URL: 
Title: A Syntactic Approach to Type Soundness  
Author: Andrew K. Wright Matthias Felleisen 
Date: June 18, 1992  
Address: Houston, TX 77251-1892  
Affiliation: Department of Computer Science Rice University  
Abstract: Rice Technical Report TR91-160 To appear in: Information and Computation Abstract We present a new approach to proving type soundness for Hindley/Milner-style polymorphic type systems. The keys to our approach are (1) an adaptation of subject reduction theorems from combinatory logic to programming languages, and (2) the use of rewriting techniques for the specification of the language semantics. The approach easily extends from polymorphic functional languages to imperative languages that provide references, exceptions, continuations, and similar features. We illustrate the technique with a type soundness theorem for the core of Standard ML, which includes the first type soundness proof for polymorphic exceptions and continuations.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Abadi, M., Cardelli, L., Pierce, B., and Plotkin, G. </author> <title> Dynamic typing in a statically-typed language. </title> <journal> ACM Transactions on Programming Languages and Systems 13, </journal> <month> 2 (April </month> <year> 1991), </year> <pages> 237-268. </pages> <booktitle> Previously appeared in: Proceedings of the 16th Annual Symposium on Principles of Programming Languages (January 1989), </booktitle> <pages> 213-227. </pages>
Reference-contexts: The complexity of the semantic relation complicates the proof; indeed, Tofte found a mistake in Damas's proof, although the theorem is not thought to be false [37: page 2]. Abadi, Cardelli, Pierce, and Plotkin <ref> [1] </ref>: Abadi et al. demonstrate type soundness for a functional language with a dynamic type and related operations. Their proof with respect to a denotational semantics is similar to Milner's proof, although it is complicated by the presence of dynamic values. <p> This language has explicitly typed declarations; the proof of type preservation is significantly simpler in the presence of such declarations. They do not develop a type soundness theorem. Abadi et al. <ref> [1] </ref> give a proof of soundness for type dynamic with respect to a structural operational semantics, in addition to their denotationally based proof.
Reference: [2] <author> Barendregt, H. P. </author> <title> The Lambda Calculus: Its Syntax and Semantics, revised ed., </title> <booktitle> vol. 103 of Studies in Logic and the Foundations of Mathematics. </booktitle> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1984. </year>
Reference-contexts: The free variables, F V (e), and bound variables of an expression are defined as usual, with and let-expressions binding their variables. The let-expression binds x in e 2 but not e 1 , i.e., let bindings are not recursive. The fixed-point combinator Y provides recursion. Following Barendregt <ref> [2] </ref>, we adopt the convention that bound variables are always distinct from free variables in distinct expressions, and we identify expressions that differ only by a consistent renaming of the bound variables.
Reference: [3] <author> Crank, E., and Felleisen, M. </author> <title> Parameter-passing and the lambda calculus. </title> <booktitle> Proceedings of the 18th Annual Symposium on Principles of Programming Languages (January 1991), </booktitle> <pages> 233-244. </pages>
Reference-contexts: In this section we consider several extensions to Functional ML. The first subsection deals with Reference ML, an extension of Functional ML with references. It uses our previous work on a calculus of state, v -S [12, 14], and in particular its cell-oriented variant <ref> [3] </ref>. The second subsection addresses Exception ML, an extension of Functional ML with exceptions. It uses a modified version of our control calculus, v -C [13, 14], especially its fragment with prompts [9]. <p> The latter approach requires duplicating much of the work of the case for applications. 6 This semantics is due to Crank and Felleisen <ref> [3] </ref>, which was derived from Felleisen and Hieb's work [14]. A similar definition of evaluation for dealing with state using rewriting techniques also appears in the work of Mason and Talcott [19]. <p> reductions and equations with the extension of contexts to: C ::= [] j C e j e C j let x be C in e j let x be e in C j x:C j :C j hx; Ci:e: The calculus satisfies the same basic properties as the v -calculus <ref> [3] </ref>.
Reference: [4] <author> Curry, H. B., and Feys, R. </author> <title> Combinatory Logic, Volume I. </title> <publisher> North-Holland, </publisher> <address> Ams-terdam, </address> <year> 1958. </year>
Reference-contexts: We present a simple approach to the proof of soundness for Hindley/Milner-style polymorphic type systems. Our approach is based on subject reduction, a classical result from combinatory logic <ref> [4] </ref>, and on rewriting as a means to specifying operational semantics [11, 12, 13, 14]. To demonstrate the approach, we develop a proof of soundness for the core 1 of Standard ML, which extends a functional polymorphic language with references and exceptions. <p> However, we believe that this only indicates a problem with their semantic framework. Syntactic Type Soundness 9 if . e 1 : t and e 1 7! e 2 then . e 2 : t . In combinatory logic, this property is known as subject reduction <ref> [4] </ref>. The second observation is that sound type systems do not assign a type to irreducible expressions that are the sources of type errors, such as 1 + true. <p> The structure of the proof always remains the same, whether or not the language includes some combination of references, exceptions, continuations, or other features. 3.1 Related Work Curry and Feys <ref> [4] </ref> introduced the notion of subject reduction for combinatory logic. In the language of combinatory logic, the CL-term e of a deduction concluding . e : t is called the subject, and the type t is called the predicate. <p> However, this is solely a property of the type system, and says nothing about the relation of the type system to the semantics of the language. 4.3 Type Soundness Our proof of type soundness rests upon the notion of subject reduction <ref> [4] </ref>. The subject reduction property states that reductions preserve the type of expressions. Lemma 4.3 below extends subject reduction to Functional ML. Subject reduction by itself is not sufficient for type soundness. In addition, we must prove that programs containing type errors are not typable.
Reference: [5] <author> Damas, L., and Milner, R. </author> <title> Principal type schemes for functional programs. </title> <booktitle> Proceedings of the 9th Annual Symposium on Principles of Programming Languages (January 1982), </booktitle> <pages> 207-212. </pages>
Reference-contexts: Theorem (Strong Soundness) If . e : t then j= E [[e]]; : t . Weak soundness is a consequence of the fact that wrong does not possess any type. Theorem (Weak Soundness) If . e : t then E [[e]]; 6= wrong. Syntactic Type Soundness 5 Damas <ref> [5, 6] </ref>: Damas extended Milner's results to a language with reference cells and destructive assignment. The proof technique is derived from Milner's technique; however, the proof is significantly more complicated. <p> The algorithm is sound [20] with respect to Syntactic Type Soundness 14 the type system, meaning that it infers only valid typings. Theorem (Soundness of W) [Milner] If (S; t ) = W (; e) succeeds then S . e : t . The algorithm is also complete <ref> [5] </ref>, meaning that if an expression has a valid typing, then the algorithm will find a typing. Furthermore, the algorithm always terminates.
Reference: [6] <author> Damas, L. M. M. </author> <title> Type Assignment in Programming Languages. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, </institution> <year> 1985. </year>
Reference-contexts: While it is easy to design a sound type system for an explicitly typed monomorphic language, the formulation of a sound type system for a language based on Hindley/Milner-style polymorphism and type inference is delicate <ref> [6, 8, 15, 17, 20, 37] </ref>. Although the treatment of purely functional languages is relatively well understood in this framework, the incorporation of imperative features such as references and exceptions requires extreme care, and the soundness of such systems is not obvious. <p> Significant effort has been invested in proving type soundness for Hindley/Milner-style type systems, and their practical realization in the programming language Standard ML [22, 23]. Soundness proofs exist for the functional fragment [20, 36], for extensions including references <ref> [6, 17, 35, 37] </ref>, and for a monomorphic language including first-class continuations [8]. However, there are several drawbacks to the existing proofs. <p> The existing techniques are complicated, and the resulting proofs are lengthy and error-prone. For an illustration of the difficulties with such proofs, we refer the reader to Tofte's [37] discussion of Damas's <ref> [6] </ref> faulty proof of a type soundness theorem for a polymorphic language with references. We present a simple approach to the proof of soundness for Hindley/Milner-style polymorphic type systems. <p> We also show soundness for an extension to Standard ML with first-class continuations. In principle, our approach is uniformly applicable to any language; 1 Mitchell and Harper refer to the functional polymorphic sublanguage as the essence of ML [24]. However, the difficulties of typing references and exceptions <ref> [6, 17, 35, 37] </ref> and the fact that they cannot be expressed by facilities of the functional core [10] indicate that they are equally important. Syntactic Type Soundness 3 in practice, the resulting proofs are lengthy but simple, requiring only ordinary inductive techniques. <p> Theorem (Strong Soundness) If . e : t then j= E [[e]]; : t . Weak soundness is a consequence of the fact that wrong does not possess any type. Theorem (Weak Soundness) If . e : t then E [[e]]; 6= wrong. Syntactic Type Soundness 5 Damas <ref> [5, 6] </ref>: Damas extended Milner's results to a language with reference cells and destructive assignment. The proof technique is derived from Milner's technique; however, the proof is significantly more complicated. <p> They describe several approaches to proving type soundness for the languages. One is with 2 This is an over-simplification; the reader interested in the precise definition is referred to Damas's thesis <ref> [6] </ref>. Syntactic Type Soundness 6 respect to a continuation-passing denotational semantics, based on the following domain equations: V = B 0 : : : B n F K K = V ! A where K is the domain of continuations, and A is the domain of answers. <p> or -expressions enclosing values: a ::= v j :v:(answers) Based on these definitions, evaluation may be defined like before: eval vr (e) = a iff e vr !7! a:(eval vr ) 5.1.2 Typing Typing reference cells in the presence of polymorphism is not straightforward, as the obvious solution is unsound <ref> [6, 36, 37] </ref>.
Reference: [7] <author> Donahue, J., and Demers, A. </author> <title> Data types are values. </title> <journal> ACM Transactions on Programming Languages and Systems 7, </journal> <month> 3 (July </month> <year> 1985), </year> <pages> 426-445. </pages>
Reference-contexts: A static type system is sound if well-typed programs cannot cause type errors; a programming language with a sound static type system is strongly typed <ref> [7] </ref>. While it is easy to design a sound type system for an explicitly typed monomorphic language, the formulation of a sound type system for a language based on Hindley/Milner-style polymorphism and type inference is delicate [6, 8, 15, 17, 20, 37].
Reference: [8] <author> Duba, B. F., Harper, R., and MacQueen, D. </author> <title> Typing first-class continuations in ML. </title> <booktitle> Proceedings of the 18th Annual Symposium on Principles of Programming Languages (January 1991), </booktitle> <pages> 163-173. </pages>
Reference-contexts: While it is easy to design a sound type system for an explicitly typed monomorphic language, the formulation of a sound type system for a language based on Hindley/Milner-style polymorphism and type inference is delicate <ref> [6, 8, 15, 17, 20, 37] </ref>. Although the treatment of purely functional languages is relatively well understood in this framework, the incorporation of imperative features such as references and exceptions requires extreme care, and the soundness of such systems is not obvious. <p> Soundness proofs exist for the functional fragment [20, 36], for extensions including references [6, 17, 35, 37], and for a monomorphic language including first-class continuations <ref> [8] </ref>. However, there are several drawbacks to the existing proofs. Proofs of type soundness are sensitive to the precise formulation of the semantics of the language| different techniques are required for denotational versus operational formulations of the semantics, and even for different languages within the same semantic framework. <p> Although the type system Abadi et al. use is not polymorphic, it should be possible to extend the type system and the soundness proof to include polymorphism. Duba, Harper, and MacQueen <ref> [8] </ref>: Duba et al. present several languages extending a monomorphic functional core with first-class continuations in the spirit of Scheme [28]. They describe several approaches to proving type soundness for the languages. <p> Leroy and Weis have successfully applied Tofte's technique to show soundness for a different type system for polymorphic references [17]. Talpin and Jouvelot have also applied the technique to demonstrate soundness for a system that infers types, effects, and regions for references [35]. Duba, Harper, and MacQueen <ref> [8] </ref>: Duba et al. also present a proof of type soundness with respect to a structural operational semantics for a monomorphic language with continuations. <p> The typing of our extension is similar to that described by Duba et al. <ref> [8] </ref>, and implemented in Standard ML of New Jersey [34]. It is a simple matter to merge this extension with Core ML.
Reference: [9] <author> Felleisen, M. </author> <title> The theory and practice of first-class prompts. </title> <booktitle> Proceedings of the 15th Annual Symposium on Principles of Programming Languages (1988), </booktitle> <pages> 180-190. </pages>
Reference-contexts: The second subsection addresses Exception ML, an extension of Functional ML with exceptions. It uses a modified version of our control calculus, v -C [13, 14], especially its fragment with prompts <ref> [9] </ref>. The final subsection presents Core ML, which includes both references and exceptions. 4 Type preservation by itself does not guarantee type soundness. Consider the (trivial) type system where every type is a subtype of every other type. Type preservation holds since every expression can be assigned every type.
Reference: [10] <author> Felleisen, M. </author> <title> On the expressive power of programming languages. </title> <booktitle> Science of Computer Programming 17 (1991), </booktitle> <pages> 35-75. </pages> <note> Preliminary version in: Proceedings of the Eu-ropean Symposium on Programming, LNCS 432 (1990), 134-151. </note>
Reference-contexts: However, the difficulties of typing references and exceptions [6, 17, 35, 37] and the fact that they cannot be expressed by facilities of the functional core <ref> [10] </ref> indicate that they are equally important. Syntactic Type Soundness 3 in practice, the resulting proofs are lengthy but simple, requiring only ordinary inductive techniques. <p> In a presentation of the typing rules for consumption by programmers, the typing rule for -expressions may be deleted. However, unlike -expressions, the abort-expressions of the continuation fragment cannot be considered as abbreviations <ref> [10] </ref>. To obtain a strong soundness theorem, abort-expressions must be considered as belonging only to the evaluation space, and not to the syntax of programs. The exception fragment has no such additional expressions.
Reference: [11] <author> Felleisen, M., and Friedman, D. P. </author> <title> Control operators, the SECD-machine, and the -calculus. In Formal Description of Programming Concepts III, </title> <editor> M. Wirsing, Ed. </editor> <publisher> Elsevier Science Publishers B.V. (North-Holland), </publisher> <address> Amsterdam, </address> <year> 1986, </year> <pages> pp. 193-217. </pages>
Reference-contexts: We present a simple approach to the proof of soundness for Hindley/Milner-style polymorphic type systems. Our approach is based on subject reduction, a classical result from combinatory logic [4], and on rewriting as a means to specifying operational semantics <ref> [11, 12, 13, 14] </ref>. To demonstrate the approach, we develop a proof of soundness for the core 1 of Standard ML, which extends a functional polymorphic language with references and exceptions. We also show soundness for an extension to Standard ML with first-class continuations. <p> By Standardization, we know that an expression reduces to a value precisely if a reduction of leftmost-outermost redexes outside of abstractions leads to a value. Based on this idea, we can use the calculus to define an evaluation function <ref> [11] </ref>. <p> If this abstraction is later applied to a value, control transfers to the captured continuation. 6.1 Semantics While defining calculus reductions for first-class continuations is possible [13, 14], the resulting calculus is inappropriate for our problem. Since we are only interested in evaluation, we take a simpler approach <ref> [11] </ref>.
Reference: [12] <author> Felleisen, M., and Friedman, D. P. </author> <title> A syntactic theory of sequential state. </title> <booktitle> Theoretical Computer Science 69, </booktitle> <month> 3 </month> <year> (1989), </year> <month> 243-287. </month> <title> Preliminary version in: </title> <booktitle> Proceedings of the 14th Annual Symposium on Principles of Programming Languages, </booktitle> <year> 1987, </year> <pages> 314-325. </pages>
Reference-contexts: We present a simple approach to the proof of soundness for Hindley/Milner-style polymorphic type systems. Our approach is based on subject reduction, a classical result from combinatory logic [4], and on rewriting as a means to specifying operational semantics <ref> [11, 12, 13, 14] </ref>. To demonstrate the approach, we develop a proof of soundness for the core 1 of Standard ML, which extends a functional polymorphic language with references and exceptions. We also show soundness for an extension to Standard ML with first-class continuations. <p> Programming language calculi, like the -calculus, are the natural choice to specify the semantics of a language such that each intermediate step of evaluation is a program. Plotkin [26] shows how the semantics of a prototypical functional language relates to the -calculus. The -calculi extensions for state <ref> [12, 14] </ref> extend this strategy to languages with references and similar constructs. Likewise, the control calculi [13, 14] can be adapted to address non-local control facilities such as exceptions and first-class continuations. <p> In this section we consider several extensions to Functional ML. The first subsection deals with Reference ML, an extension of Functional ML with references. It uses our previous work on a calculus of state, v -S <ref> [12, 14] </ref>, and in particular its cell-oriented variant [3]. The second subsection addresses Exception ML, an extension of Functional ML with exceptions. It uses a modified version of our control calculus, v -C [13, 14], especially its fragment with prompts [9].
Reference: [13] <author> Felleisen, M., Friedman, D. P., Kohlbecker, E. E., and Duba, B. </author> <title> A syntactic theory of sequential control. </title> <booktitle> Theoretical Computer Science 52, </booktitle> <month> 3 </month> <year> (1987), </year> <month> 205-237. </month> <title> Preliminary version in: </title> <booktitle> Proceedings of the Symposium on Logic in Computer Science, </booktitle> <year> 1986, </year> <month> 131-141. </month> <title> Syntactic Type Soundness 48 </title>
Reference-contexts: We present a simple approach to the proof of soundness for Hindley/Milner-style polymorphic type systems. Our approach is based on subject reduction, a classical result from combinatory logic [4], and on rewriting as a means to specifying operational semantics <ref> [11, 12, 13, 14] </ref>. To demonstrate the approach, we develop a proof of soundness for the core 1 of Standard ML, which extends a functional polymorphic language with references and exceptions. We also show soundness for an extension to Standard ML with first-class continuations. <p> Plotkin [26] shows how the semantics of a prototypical functional language relates to the -calculus. The -calculi extensions for state [12, 14] extend this strategy to languages with references and similar constructs. Likewise, the control calculi <ref> [13, 14] </ref> can be adapted to address non-local control facilities such as exceptions and first-class continuations. Since the intermediate states of evaluation are programs, we may apply the type system to deduce a type for each state. <p> It uses our previous work on a calculus of state, v -S [12, 14], and in particular its cell-oriented variant [3]. The second subsection addresses Exception ML, an extension of Functional ML with exceptions. It uses a modified version of our control calculus, v -C <ref> [13, 14] </ref>, especially its fragment with prompts [9]. The final subsection presents Core ML, which includes both references and exceptions. 4 Type preservation by itself does not guarantee type soundness. Consider the (trivial) type system where every type is a subtype of every other type. <p> If this abstraction is later applied to a value, control transfers to the captured continuation. 6.1 Semantics While defining calculus reductions for first-class continuations is possible <ref> [13, 14] </ref>, the resulting calculus is inappropriate for our problem. Since we are only interested in evaluation, we take a simpler approach [11].
Reference: [14] <author> Felleisen, M., and Hieb, R. </author> <title> The revised report on the syntactic theories of sequential control and state. </title> <type> Tech. Rep. </type> <institution> TR-100, Rice University, </institution> <month> June </month> <year> 1989. </year> <note> To appear in: Theoretical Computer Science, </note> <year> 1992. </year>
Reference-contexts: We present a simple approach to the proof of soundness for Hindley/Milner-style polymorphic type systems. Our approach is based on subject reduction, a classical result from combinatory logic [4], and on rewriting as a means to specifying operational semantics <ref> [11, 12, 13, 14] </ref>. To demonstrate the approach, we develop a proof of soundness for the core 1 of Standard ML, which extends a functional polymorphic language with references and exceptions. We also show soundness for an extension to Standard ML with first-class continuations. <p> Programming language calculi, like the -calculus, are the natural choice to specify the semantics of a language such that each intermediate step of evaluation is a program. Plotkin [26] shows how the semantics of a prototypical functional language relates to the -calculus. The -calculi extensions for state <ref> [12, 14] </ref> extend this strategy to languages with references and similar constructs. Likewise, the control calculi [13, 14] can be adapted to address non-local control facilities such as exceptions and first-class continuations. <p> Plotkin [26] shows how the semantics of a prototypical functional language relates to the -calculus. The -calculi extensions for state [12, 14] extend this strategy to languages with references and similar constructs. Likewise, the control calculi <ref> [13, 14] </ref> can be adapted to address non-local control facilities such as exceptions and first-class continuations. Since the intermediate states of evaluation are programs, we may apply the type system to deduce a type for each state. <p> In this section we consider several extensions to Functional ML. The first subsection deals with Reference ML, an extension of Functional ML with references. It uses our previous work on a calculus of state, v -S <ref> [12, 14] </ref>, and in particular its cell-oriented variant [3]. The second subsection addresses Exception ML, an extension of Functional ML with exceptions. It uses a modified version of our control calculus, v -C [13, 14], especially its fragment with prompts [9]. <p> It uses our previous work on a calculus of state, v -S [12, 14], and in particular its cell-oriented variant [3]. The second subsection addresses Exception ML, an extension of Functional ML with exceptions. It uses a modified version of our control calculus, v -C <ref> [13, 14] </ref>, especially its fragment with prompts [9]. The final subsection presents Core ML, which includes both references and exceptions. 4 Type preservation by itself does not guarantee type soundness. Consider the (trivial) type system where every type is a subtype of every other type. <p> In order to simplify the semantics, we do not treat it as such <ref> [14] </ref>. Intuitively, a -expression plays the role of a store fragment during the reduction of a program with imperative assignment statements. <p> The latter approach requires duplicating much of the work of the case for applications. 6 This semantics is due to Crank and Felleisen [3], which was derived from Felleisen and Hieb's work <ref> [14] </ref>. A similar definition of evaluation for dealing with state using rewriting techniques also appears in the work of Mason and Talcott [19]. <p> If this abstraction is later applied to a value, control transfers to the captured continuation. 6.1 Semantics While defining calculus reductions for first-class continuations is possible <ref> [13, 14] </ref>, the resulting calculus is inappropriate for our problem. Since we are only interested in evaluation, we take a simpler approach [11].
Reference: [15] <author> Hindley, R. </author> <title> The principal type-scheme of an object in combinatory logic. </title> <journal> Transactions of the American Mathematical Society 146 (December 1969), </journal> <pages> 29-60. </pages>
Reference-contexts: While it is easy to design a sound type system for an explicitly typed monomorphic language, the formulation of a sound type system for a language based on Hindley/Milner-style polymorphism and type inference is delicate <ref> [6, 8, 15, 17, 20, 37] </ref>. Although the treatment of purely functional languages is relatively well understood in this framework, the incorporation of imperative features such as references and exceptions requires extreme care, and the soundness of such systems is not obvious.
Reference: [16] <author> Hindley, R. J., and Seldin, J. P. </author> <title> Introduction to Combinators and -Calculus. </title> <publisher> Cambridge University Press, </publisher> <year> 1986. </year>
Reference: [17] <author> Leroy, X., and Weis, P. </author> <title> Polymorphic type inference and assignment. </title> <booktitle> Proceedings of the 18th Annual Symposium on Principles of Programming Languages (January 1991), </booktitle> <pages> 291-302. </pages>
Reference-contexts: While it is easy to design a sound type system for an explicitly typed monomorphic language, the formulation of a sound type system for a language based on Hindley/Milner-style polymorphism and type inference is delicate <ref> [6, 8, 15, 17, 20, 37] </ref>. Although the treatment of purely functional languages is relatively well understood in this framework, the incorporation of imperative features such as references and exceptions requires extreme care, and the soundness of such systems is not obvious. <p> Significant effort has been invested in proving type soundness for Hindley/Milner-style type systems, and their practical realization in the programming language Standard ML [22, 23]. Soundness proofs exist for the functional fragment [20, 36], for extensions including references <ref> [6, 17, 35, 37] </ref>, and for a monomorphic language including first-class continuations [8]. However, there are several drawbacks to the existing proofs. <p> We also show soundness for an extension to Standard ML with first-class continuations. In principle, our approach is uniformly applicable to any language; 1 Mitchell and Harper refer to the functional polymorphic sublanguage as the essence of ML [24]. However, the difficulties of typing references and exceptions <ref> [6, 17, 35, 37] </ref> and the fact that they cannot be expressed by facilities of the functional core [10] indicate that they are equally important. Syntactic Type Soundness 3 in practice, the resulting proofs are lengthy but simple, requiring only ordinary inductive techniques. <p> Lemmas involving the semantic relation are proved using the technique of co-induction that Milner and Tofte developed for this purpose [21]. Leroy and Weis have successfully applied Tofte's technique to show soundness for a different type system for polymorphic references <ref> [17] </ref>. Talpin and Jouvelot have also applied the technique to demonstrate soundness for a system that infers types, effects, and regions for references [35].
Reference: [18] <author> MacQueen, D. B., Plotkin, G., and Sethi, R. </author> <title> An ideal model for recursive polymorphic types. </title> <booktitle> Proceedings of the 11th Annual Symposium on Principles of Programming Languages (January 1984), </booktitle> <pages> 165-174. </pages>
Reference-contexts: To establish soundness, Milner introduced a semantic relation j=. This relation identifies each type t with an ideal V t of the domain V <ref> [18] </ref>. An ideal is simply a subset of the domain that is closed under certain operations (subset and least upper bounds of finite consistent subsets); each of the basic domains forms an ideal. <p> Types, in turn, denote ideals over V, but due to the unusual element D of the domain equation, establishing that types denote ideals requires extending the ideal model for recursive types <ref> [18] </ref>. The proof that the required fixed points exist in the new model involves a metric space argument, but is a straightforward extension of the original.
Reference: [19] <author> Mason, I., and Talcott, C. </author> <title> Programming, transforming, and proving with function abstractions and memories. </title> <booktitle> In Proceedings of the International Conference on Automata, Languages, and Programming, LNCS 372 (1989), </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 574-588. </pages>
Reference-contexts: A similar definition of evaluation for dealing with state using rewriting techniques also appears in the work of Mason and Talcott <ref> [19] </ref>. Syntactic Type Soundness 22 By the variable conventions, x is not free in v in the ref reduction; the domains of 1 and 2 are disjoint in merge ; and the free variables of R are disjoint from the domain of in lift .
Reference: [20] <author> Milner, R. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences 17 (1978), </journal> <pages> 348-375. </pages>
Reference-contexts: While it is easy to design a sound type system for an explicitly typed monomorphic language, the formulation of a sound type system for a language based on Hindley/Milner-style polymorphism and type inference is delicate <ref> [6, 8, 15, 17, 20, 37] </ref>. Although the treatment of purely functional languages is relatively well understood in this framework, the incorporation of imperative features such as references and exceptions requires extreme care, and the soundness of such systems is not obvious. <p> Let . e : t mean that the type system assigns program e the type t , i.e., e is well-typed. The simplest soundness property states that well-typed programs do not yield wrong <ref> [20] </ref>. Definition (Weak Soundness) If . e : t then eval (e) 6= wrong. <p> Significant effort has been invested in proving type soundness for Hindley/Milner-style type systems, and their practical realization in the programming language Standard ML [22, 23]. Soundness proofs exist for the functional fragment <ref> [20, 36] </ref>, for extensions including references [6, 17, 35, 37], and for a monomorphic language including first-class continuations [8]. However, there are several drawbacks to the existing proofs. <p> Programs are closed expressions. A program e is well-typed if it has a type t in the empty type environment; we then write . e : t . 2.1 Proofs based on Denotational Semantics Milner <ref> [20] </ref>: Milner formulated and proved a type soundness theorem for a functional language like the above based on a denotational semantics for the language of untyped expressions. <p> Section 4 considers a functional language, similar to that considered by Milner <ref> [20] </ref>. Section 5 considers an extension to references, an extension to exceptions, and shows how the results may be merged to consider a language with both. To our knowledge, this is the first proof of soundness for exceptions. <p> This type system has the important property that there is an algorithm W to determine whether an expression has a type <ref> [20] </ref>. Given a type environment and an expression, the algorithm computes a substitution and a type. The algorithm is sound [20] with respect to Syntactic Type Soundness 14 the type system, meaning that it infers only valid typings. <p> This type system has the important property that there is an algorithm W to determine whether an expression has a type <ref> [20] </ref>. Given a type environment and an expression, the algorithm computes a substitution and a type. The algorithm is sound [20] with respect to Syntactic Type Soundness 14 the type system, meaning that it infers only valid typings. Theorem (Soundness of W) [Milner] If (S; t ) = W (; e) succeeds then S . e : t .
Reference: [21] <author> Milner, R., and Tofte, M. </author> <title> Co-induction in relational semantics. </title> <booktitle> Theoretical Computer Science 87 (1991), </booktitle> <pages> 209-220. </pages>
Reference-contexts: The theorem is proved by induction on the depth of the deduction of s; E ` e ) v; s 0 . Lemmas involving the semantic relation are proved using the technique of co-induction that Milner and Tofte developed for this purpose <ref> [21] </ref>. Leroy and Weis have successfully applied Tofte's technique to show soundness for a different type system for polymorphic references [17]. Talpin and Jouvelot have also applied the technique to demonstrate soundness for a system that infers types, effects, and regions for references [35].
Reference: [22] <author> Milner, R., and Tofte, M. </author> <title> Commentary on Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1991. </year>
Reference-contexts: Weak soundness follows from strong soundness since wrong is not a member of V t for any type t . Significant effort has been invested in proving type soundness for Hindley/Milner-style type systems, and their practical realization in the programming language Standard ML <ref> [22, 23] </ref>. Soundness proofs exist for the functional fragment [20, 36], for extensions including references [6, 17, 35, 37], and for a monomorphic language including first-class continuations [8]. However, there are several drawbacks to the existing proofs. <p> Answers for eval vx are: a ::= v j exception in v j exception x in raise x v:(answers) 7 Due to our use of the variable conventions for exn merge , our exceptions are generative as in Standard ML <ref> [22, 23] </ref>. Syntactic Type Soundness 33 Answers of the third form are unhandled exceptions: since handlers are dynamically bound, it is possible for an exception to be raised when no handler for it is installed.
Reference: [23] <author> Milner, R., Tofte, M., and Harper, R. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: Weak soundness follows from strong soundness since wrong is not a member of V t for any type t . Significant effort has been invested in proving type soundness for Hindley/Milner-style type systems, and their practical realization in the programming language Standard ML <ref> [22, 23] </ref>. Soundness proofs exist for the functional fragment [20, 36], for extensions including references [6, 17, 35, 37], and for a monomorphic language including first-class continuations [8]. However, there are several drawbacks to the existing proofs. <p> Answers for eval vx are: a ::= v j exception in v j exception x in raise x v:(answers) 7 Due to our use of the variable conventions for exn merge , our exceptions are generative as in Standard ML <ref> [22, 23] </ref>. Syntactic Type Soundness 33 Answers of the third form are unhandled exceptions: since handlers are dynamically bound, it is possible for an exception to be raised when no handler for it is installed.
Reference: [24] <author> Mitchell, J. C., and Harper, R. </author> <title> The essence of ML. </title> <booktitle> Proceedings of the 15th Annual Symposium on Principles of Programming Languages (January 1988), </booktitle> <pages> 28-46. </pages>
Reference-contexts: We also show soundness for an extension to Standard ML with first-class continuations. In principle, our approach is uniformly applicable to any language; 1 Mitchell and Harper refer to the functional polymorphic sublanguage as the essence of ML <ref> [24] </ref>. However, the difficulties of typing references and exceptions [6, 17, 35, 37] and the fact that they cannot be expressed by facilities of the functional core [10] indicate that they are equally important.
Reference: [25] <author> Mitchell, J. C., and Plotkin, G. D. </author> <title> Abstract types have existential type. </title> <journal> ACM Transactions on Programming Languages and Systems 10, </journal> <month> 3 (July </month> <year> 1988), </year> <month> 470-502. </month> <title> Also appeared in: </title> <booktitle> Proceedings of the 11th Annual Symposium on Principles of Programming Languages, </booktitle> <year> 1984, </year> <pages> 37-51. </pages>
Reference-contexts: Subject reduction states that reduction of the subject of a deduction preserves the predicate. Subject reduction holds for terms in CL and the -calculus [33]. Mitchell and Plotkin <ref> [25] </ref> present a type preservation theorem, i.e., subject reduction, for a variant of the second order polymorphic -calculus. This language has explicitly typed declarations; the proof of type preservation is significantly simpler in the presence of such declarations. They do not develop a type soundness theorem.
Reference: [26] <author> Plotkin, G. D. </author> <title> Call-by-name, call-by-value and the lambda-calculus. </title> <booktitle> Theoretical Computer Science 1 (1975), </booktitle> <pages> 125-159. </pages>
Reference-contexts: Thus, proving type soundness reduces to proving that well-typed programs yield only well-typed answers. Programming language calculi, like the -calculus, are the natural choice to specify the semantics of a language such that each intermediate step of evaluation is a program. Plotkin <ref> [26] </ref> shows how the semantics of a prototypical functional language relates to the -calculus. The -calculi extensions for state [12, 14] extend this strategy to languages with references and similar constructs. <p> A natural basis for a calculus of Functional ML is Plotkin's untyped v -calculus <ref> [26] </ref>. Let Var be a denumerable set of variables and Const be a set of constants. <p> An equational system may be constructed as the congruence closure of v, but plays no role for our work. With an appropriate choice of ffi, the calculus satisfies Church-Rosser and Standardization properties; the proofs are variants of Plotkin's proofs for the v -calculus <ref> [26] </ref>. By Standardization, we know that an expression reduces to a value precisely if a reduction of leftmost-outermost redexes outside of abstractions leads to a value. Based on this idea, we can use the calculus to define an evaluation function [11].
Reference: [27] <author> Plotkin, G. D. </author> <title> A structural approach to operational semantics. </title> <type> Tech. Rep. DAIMI FN-19, </type> <institution> -Arhus University, </institution> <month> September </month> <year> 1981. </year>
Reference-contexts: However, the argument does not extend to higher types. For further details, we refer the reader to their paper [8: page 169]. 2.2 Proofs based on Structural Operational Semantics Tofte [36, 37]: Tofte reformulated Milner's functional language with a structural operational semantics <ref> [27] </ref>. The semantics is specified as a deductive proof system; a conclusion E ` e ) v of a deduction states that expression e evaluates to v in value environment E. A value environment is a finite map from variables to operational values.
Reference: [28] <editor> Rees, J., and Clinger, W. </editor> <title> Revised 3 report on the algorithmic language Scheme. </title> <journal> SIGPLAN Notices 21, </journal> <month> 12 (December </month> <year> 1986), </year> <month> 37-79. </month> <title> Syntactic Type Soundness 49 </title>
Reference-contexts: Duba, Harper, and MacQueen [8]: Duba et al. present several languages extending a monomorphic functional core with first-class continuations in the spirit of Scheme <ref> [28] </ref>. They describe several approaches to proving type soundness for the languages. One is with 2 This is an over-simplification; the reader interested in the precise definition is referred to Damas's thesis [6].
Reference: [29] <author> Reppy, J. H. </author> <title> Higher-order Concurrency. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <year> 1991. </year>
Reference-contexts: This mechanism is indispensable when writing non-trivial ML programs. Subtyping, inheritance, and type inference for records are a strong focus of recent research efforts to explain object-oriented languages, as many popular object-oriented languages have unsound static type systems. Reppy <ref> [29] </ref> has successfully addressed concurrency with our technique; it should also be possible to treat nondeterminism and distributed computing. We have used our technique to prove an alternative type system for references sound [38].
Reference: [30] <author> Reynolds, J. </author> <title> Definitional interpreters for higher order programming languages. </title> <booktitle> ACM Conference Proceedings (1972), </booktitle> <pages> 717-740. </pages>
Reference-contexts: Duba, Harper, and MacQueen [8]: Duba et al. also present a proof of type soundness with respect to a structural operational semantics for a monomorphic language with continuations. The proof is an adaptation of Tofte's technique; however, the semantics is significantly restructured, as the technique of defunctionalization <ref> [30] </ref> is used to represent the flow of control explicitly. The semantics has two judgment forms. The first kind of conclusion, E; K ` e ) v, indicates that expression e evaluates to answer v in environment E and continuation K.
Reference: [31] <author> Reynolds, J. C. </author> <title> On the relation between direct and continuation semantics. </title> <booktitle> Proceedings of the International Conference on Automata, Languages, and Programming (1974), </booktitle> <pages> 141-156. </pages>
Reference-contexts: Since the semantic relation (j=) must involve the types of values in the store, it can no longer be defined by induction on types; its existence must be established by a category theoretical argument that generalizes the technique of inclusive predicates <ref> [31] </ref>. The complexity of the semantic relation complicates the proof; indeed, Tofte found a mistake in Damas's proof, although the theorem is not thought to be false [37: page 2].
Reference: [32] <author> Scott, D. </author> <title> Data types as lattices. </title> <journal> SIAM Journal of Computing 3, </journal> <volume> 5 (1976), </volume> <pages> 522-586. </pages>
Reference-contexts: The semantic domain is the solution of the following reflexive domain equation <ref> [32] </ref>: V = B 0 : : : B n F W B 0 ; : : : ; B n are basic domains (with bottom), such as integers and booleans; F is the function domain; W is a domain consisting of the single element wrong; is the separated sum; and
Reference: [33] <author> Seldin, J. P. </author> <title> A sequent calculus for type assignment. </title> <journal> Journal of Symbolic Logic 42 (1977), </journal> <pages> 11-28. </pages>
Reference-contexts: Subject reduction states that reduction of the subject of a deduction preserves the predicate. Subject reduction holds for terms in CL and the -calculus <ref> [33] </ref>. Mitchell and Plotkin [25] present a type preservation theorem, i.e., subject reduction, for a variant of the second order polymorphic -calculus. This language has explicitly typed declarations; the proof of type preservation is significantly simpler in the presence of such declarations. They do not develop a type soundness theorem.
Reference: [34] <institution> Standard ML of New Jersey release notes (version 0.75). AT&T Bell Laboratories, </institution> <month> November </month> <year> 1991. </year>
Reference-contexts: The typing of our extension is similar to that described by Duba et al. [8], and implemented in Standard ML of New Jersey <ref> [34] </ref>. It is a simple matter to merge this extension with Core ML.
Reference: [35] <author> Talpin, J.-P., and Jouvelot, P. </author> <title> The type and effect discipline. </title> <type> Tech. Rep. </type> <institution> EMP-CRI A/206, Ecole des Mines de Paris, </institution> <month> July </month> <year> 1991. </year>
Reference-contexts: Significant effort has been invested in proving type soundness for Hindley/Milner-style type systems, and their practical realization in the programming language Standard ML [22, 23]. Soundness proofs exist for the functional fragment [20, 36], for extensions including references <ref> [6, 17, 35, 37] </ref>, and for a monomorphic language including first-class continuations [8]. However, there are several drawbacks to the existing proofs. <p> We also show soundness for an extension to Standard ML with first-class continuations. In principle, our approach is uniformly applicable to any language; 1 Mitchell and Harper refer to the functional polymorphic sublanguage as the essence of ML [24]. However, the difficulties of typing references and exceptions <ref> [6, 17, 35, 37] </ref> and the fact that they cannot be expressed by facilities of the functional core [10] indicate that they are equally important. Syntactic Type Soundness 3 in practice, the resulting proofs are lengthy but simple, requiring only ordinary inductive techniques. <p> Leroy and Weis have successfully applied Tofte's technique to show soundness for a different type system for polymorphic references [17]. Talpin and Jouvelot have also applied the technique to demonstrate soundness for a system that infers types, effects, and regions for references <ref> [35] </ref>. Duba, Harper, and MacQueen [8]: Duba et al. also present a proof of type soundness with respect to a structural operational semantics for a monomorphic language with continuations.
Reference: [36] <author> Tofte, M. </author> <title> Operational Semantics and Polymorphic Type Inference. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, </institution> <year> 1987. </year>
Reference-contexts: Significant effort has been invested in proving type soundness for Hindley/Milner-style type systems, and their practical realization in the programming language Standard ML [22, 23]. Soundness proofs exist for the functional fragment <ref> [20, 36] </ref>, for extensions including references [6, 17, 35, 37], and for a monomorphic language including first-class continuations [8]. However, there are several drawbacks to the existing proofs. <p> However, the argument does not extend to higher types. For further details, we refer the reader to their paper [8: page 169]. 2.2 Proofs based on Structural Operational Semantics Tofte <ref> [36, 37] </ref>: Tofte reformulated Milner's functional language with a structural operational semantics [27]. The semantics is specified as a deductive proof system; a conclusion E ` e ) v of a deduction states that expression e evaluates to v in value environment E. <p> or -expressions enclosing values: a ::= v j :v:(answers) Based on these definitions, evaluation may be defined like before: eval vr (e) = a iff e vr !7! a:(eval vr ) 5.1.2 Typing Typing reference cells in the presence of polymorphism is not straightforward, as the obvious solution is unsound <ref> [6, 36, 37] </ref>. <p> (n.+ 1 n)) !! let f be hx; y.yi: x in (z. ! f true) (:= f (n.+ 1 n)) !! hx; y.yi: (z. ! x true) (:= x (n.+ 1 n)) !! hx; n.+ 1 ni: ! x true !! hx; n.+ 1 ni: + 1 true As Tofte <ref> [36, 37] </ref> points out, the problem with the obvious typing is the generalization of type variables that appear free in the type of a value in the store. <p> Like Tofte, we classify only values as non-expansive, but a stronger type system is possible by classifying more expressions as non-expansive <ref> [36, 37] </ref>.
Reference: [37] <author> Tofte, M. </author> <title> Type inference for polymorphic references. </title> <booktitle> Information and Computation 89, </booktitle> <month> 1 (November </month> <year> 1990), </year> <pages> 1-34. </pages>
Reference-contexts: While it is easy to design a sound type system for an explicitly typed monomorphic language, the formulation of a sound type system for a language based on Hindley/Milner-style polymorphism and type inference is delicate <ref> [6, 8, 15, 17, 20, 37] </ref>. Although the treatment of purely functional languages is relatively well understood in this framework, the incorporation of imperative features such as references and exceptions requires extreme care, and the soundness of such systems is not obvious. <p> Significant effort has been invested in proving type soundness for Hindley/Milner-style type systems, and their practical realization in the programming language Standard ML [22, 23]. Soundness proofs exist for the functional fragment [20, 36], for extensions including references <ref> [6, 17, 35, 37] </ref>, and for a monomorphic language including first-class continuations [8]. However, there are several drawbacks to the existing proofs. <p> The proofs for two different languages are difficult to reconcile to prove soundness for a language including features of both. The existing techniques are complicated, and the resulting proofs are lengthy and error-prone. For an illustration of the difficulties with such proofs, we refer the reader to Tofte's <ref> [37] </ref> discussion of Damas's [6] faulty proof of a type soundness theorem for a polymorphic language with references. We present a simple approach to the proof of soundness for Hindley/Milner-style polymorphic type systems. <p> We also show soundness for an extension to Standard ML with first-class continuations. In principle, our approach is uniformly applicable to any language; 1 Mitchell and Harper refer to the functional polymorphic sublanguage as the essence of ML [24]. However, the difficulties of typing references and exceptions <ref> [6, 17, 35, 37] </ref> and the fact that they cannot be expressed by facilities of the functional core [10] indicate that they are equally important. Syntactic Type Soundness 3 in practice, the resulting proofs are lengthy but simple, requiring only ordinary inductive techniques. <p> However, the argument does not extend to higher types. For further details, we refer the reader to their paper [8: page 169]. 2.2 Proofs based on Structural Operational Semantics Tofte <ref> [36, 37] </ref>: Tofte reformulated Milner's functional language with a structural operational semantics [27]. The semantics is specified as a deductive proof system; a conclusion E ` e ) v of a deduction states that expression e evaluates to v in value environment E. <p> or -expressions enclosing values: a ::= v j :v:(answers) Based on these definitions, evaluation may be defined like before: eval vr (e) = a iff e vr !7! a:(eval vr ) 5.1.2 Typing Typing reference cells in the presence of polymorphism is not straightforward, as the obvious solution is unsound <ref> [6, 36, 37] </ref>. <p> (n.+ 1 n)) !! let f be hx; y.yi: x in (z. ! f true) (:= f (n.+ 1 n)) !! hx; y.yi: (z. ! x true) (:= x (n.+ 1 n)) !! hx; n.+ 1 ni: ! x true !! hx; n.+ 1 ni: + 1 true As Tofte <ref> [36, 37] </ref> points out, the problem with the obvious typing is the generalization of type variables that appear free in the type of a value in the store. <p> Like Tofte, we classify only values as non-expansive, but a stronger type system is possible by classifying more expressions as non-expansive <ref> [36, 37] </ref>.
Reference: [38] <author> Wright, A. K. </author> <title> Typing references by effect inference. </title> <booktitle> In Proceedings of the European Symposium on Programming, LNCS 582 (1992), </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 473-491. </pages>
Reference-contexts: Such a semantics for Reference ML is slightly simpler, as the ref, merge , and lift reductions coalesce into one program reduction, but the structure of the proof is essentially the same. Our work on an alternative type system for references uses this approach <ref> [38] </ref>. We chose to use calculi in this paper as the resulting proofs are more regular in structure. In specifying the semantics of references as a calculus, we use an additional expression form, the -expression, that is not present in ML. <p> Reppy [29] has successfully addressed concurrency with our technique; it should also be possible to treat nondeterminism and distributed computing. We have used our technique to prove an alternative type system for references sound <ref> [38] </ref>. Finally, it may be possible to adapt our technique to demonstrate the consistency of module systems like that of Standard ML.
References-found: 38

