URL: ftp://mancos.cs.utah.edu/papers/presint3.ps.Z
Refering-URL: ftp://mancos.cs.utah.edu/papers/presint3.html
Root-URL: 
Email: fbaford,mike,lepreaug@cs.utah.edu  
Title: Using Annotated Interface Definitions to Optimize RPC  
Author: Bryan Ford Mike Hibler Jay Lepreau 
Address: Utah  
Affiliation: Department of Computer Science, University of  
Abstract: Technical Report UUCS-95-014 March, 1995 Abstract In RPC-based communication, it is useful to distinguish the RPC interface, which is the network contract between the client and the server, from the presentation, which is the programmer's contract between the RPC stubs and the code that calls or is called by them. Presentation is usually a fixed function of the RPC interface, but some RPC systems, such as DCE and Concert, support the notion of a flexible presentation or endpoint modifier, allowing controlled modification of the behavior of the stubs on each side without affecting the contract between the client and the server. Up until now, the primary motivation for flexible presentation has been for programmer convenience and improved interoperability. However, we have found flexible presentation also to be useful for optimization of RPC, and in many cases necessary to achieving maximal performance without throwing out the RPC system and resorting to hand-coded stubs. In this paper we provide examples demonstrating this point for a number of different operating systems and IPC transport mechanisms, with RPC performance improvements ranging from 5% to an order of magnitude. In general, we observe that the more efficient the underlying IPC transport mechanism is, the more important it is for the RPC system to support flexible presentation, in order to avoid unnecessary user-space overhead. 1 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. S. Auerbach et al. Concert/C: </author> <title> A language for distributed programming. </title> <booktitle> In Proc. of the Winter 1994 USENIX Conference, </booktitle> <pages> pages 79-96, </pages> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: Also, the ACF's primary purpose is for programmer convenience, not optimization. The Concert/C distributed programming system <ref> [2, 1] </ref> much more fully develops the concept of flexible presentation. In their system, as in ours, presentation includes storage allocation attributes, such as which entity (application, stub, transport) is responsible for the allocation and deallocation of storage for each parameter.
Reference: [2] <author> J. S. Auerbach and J. R. Russell. </author> <title> The Concert signature representation: IDL as an intermediate language. </title> <booktitle> In Proc. of the Workshop on Interface Definition Languages, </booktitle> <pages> pages 1-12, </pages> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: Also, the ACF's primary purpose is for programmer convenience, not optimization. The Concert/C distributed programming system <ref> [2, 1] </ref> much more fully develops the concept of flexible presentation. In their system, as in ours, presentation includes storage allocation attributes, such as which entity (application, stub, transport) is responsible for the allocation and deallocation of storage for each parameter.
Reference: [3] <author> B. N. Bershad, T. E. Anderson, E. D. Lazowska, and H. M. Levy. </author> <title> Lightweight remote procedure call. </title> <journal> ACM Trans. Comput. Syst., </journal> <volume> 8(1) </volume> <pages> 37-55, </pages> <month> Feb. </month> <year> 1990. </year>
Reference-contexts: Only pairwise shared memory channels are taken advantage of, and the resulting system has the same basic performance characteristics as LRPC <ref> [3] </ref>.
Reference: [4] <author> A. D. Birrell and B. J. Nelson. </author> <title> Implementing remote procedure calls. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(1), </volume> <month> Feb. </month> <year> 1984. </year>
Reference-contexts: 1 Introduction In a typical remote procedure call (RPC) system, interfaces between clients and servers are defined explicitly in an interface definition language (IDL), and the IDL file is processed by a stub generator to produce client and server stubs <ref> [4] </ref>. The primary purpose of the IDL file is to define the network contract between the client and the server: what operations can be invoked and what information must be passed across the network on an invocation.
Reference: [5] <author> D. D. Clark and D. L. Tennenhouse. </author> <title> Architectural considerations for a new generation of protocols. </title> <booktitle> In Proceedings of the SIGCOMM '90 Symposium, </booktitle> <pages> pages 200-208, </pages> <year> 1990. </year>
Reference-contexts: It is aimed at optimizing the generation of generally fixed-format stubs which marshal network protocol headers, efficiently performing byte swapping, alignment mapping, etc. USC is designed to be used by a higher level stub generator. In the traditional networking domain, Clark and Tennenhouse <ref> [5] </ref> emphasize the importance of optimizing the presentation layer, showing that it often dominates processing time. They also emphasize that for performance reasons, the necessity of non-contiguous data location in the recipient is a critical architectural constraint. <p> Their emphasis is on the latter, ours the former, but similar issues and performance effects obtain. We bring to RPC the focus on presentation optimization that has been elucidated in the traditional networking arena <ref> [5, 20] </ref>.
Reference: [6] <author> P. Druschel and L. L. Peterson. Fbufs: </author> <title> A high-bandwidth cross-domain transfer facility. </title> <booktitle> In Proc. of the 14th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 189-202, </pages> <year> 1993. </year> <month> 15 </month>
Reference-contexts: Flexible presentation support provides a principled way to specify these constraints. For example, if data sent in an RPC is uninterpreted by the server (e.g., I/O buffers), the client can be allowed to retain access to the data while the server processes it, saving overhead, as in volatile fbufs <ref> [6] </ref>. <p> In this section we examine the fbufs data transfer mechanism <ref> [6] </ref>, a shared memory-based protocol that allows large amounts of data to be passed through many protection domains along semi-fixed data paths without incurring any expensive copying or virtual memory remapping operations along the way.
Reference: [7] <author> P. Druschel, L. L. Peterson, and N. C. Hutchinson. </author> <title> Beyond micro-kernel design: Decoupling modu-larity and protection in Lipto. </title> <booktitle> In Proc. of the 12th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 512-520, </pages> <address> Yokohama, Japan, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: In that implementation pipe buffers are always 4K in size. 4.4 Same-Domain Communication One well-known way to reduce the overall performance overhead in decomposed systems is to decouple modularity from protection <ref> [7] </ref>: make all inter-module communication go through well-defined RPC-like interfaces that can cross process and machine boundaries, but allow the resulting system to be configured so that several modules share the same protection domain and RPC between them is optimized to simple procedure calls.
Reference: [8] <author> B. Ford and J. Lepreau. </author> <title> Evolving Mach 3.0 to a migrating thread model. </title> <booktitle> In Proc. of the Winter 1994 USENIX Conference, </booktitle> <pages> pages 97-114, </pages> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: Processes that have open file handles to a particular pipe communicate directly with the pipe server to read and write data. Communication with the pipe server is done using a new, streamlined low-level Mach IPC mechanism similar to those implemented in other recent microkernels <ref> [10, 17, 8] </ref>. The new IPC path allows messages to be transferred through processor registers and/or a simple message buffer copied by the kernel directly from the source address space to the target address space.
Reference: [9] <author> D. Golub, R. Dean, A. Forin, and R. Rashid. </author> <title> Unix as an application program. </title> <booktitle> In Proc. of the Summer 1990 USENIX Conference, </booktitle> <pages> pages 87-96, </pages> <address> Anaheim, CA, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: Our implementation runs on the Mach microkernel, in a Lites [12] environment (a Unix server based on BSD 4.4 Lite). The standard Lites server is mostly monolithic in nature, with the same overall design as the original CMU UX single server <ref> [9] </ref>. However, in our version of Lites we have implemented the pipe server as a separate Mach task outside of the main Unix server. Processes that have open file handles to a particular pipe communicate directly with the pipe server to read and write data.
Reference: [10] <author> G. Hamilton and P. Kougiouris. </author> <title> The Spring nucleus: a microkernel for objects. </title> <booktitle> In Proc. of the Summer 1993 USENIX Conference, </booktitle> <pages> pages 147-159, </pages> <address> Cincinnati, OH, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Processes that have open file handles to a particular pipe communicate directly with the pipe server to read and write data. Communication with the pipe server is done using a new, streamlined low-level Mach IPC mechanism similar to those implemented in other recent microkernels <ref> [10, 17, 8] </ref>. The new IPC path allows messages to be transferred through processor registers and/or a simple message buffer copied by the kernel directly from the source address space to the target address space.
Reference: [11] <author> G. Hamilton, M. L. Powell, and J. J. Mitchell. Subcontract: </author> <title> A flexible base for distributed programming. </title> <booktitle> In Proc. of the 14th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 69-79, </pages> <year> 1993. </year>
Reference-contexts: In Concert, the primary purpose of this separation is to handle the vagaries of RPC mapping to different languages; for example, whether a returned value maps to an out parameter or to a function return value. Subcontract <ref> [11] </ref>, a general method for extending and specializing object communication mechanisms and semantics 3 , is largely complementary to our work, addressing a level higher than the stub level.
Reference: [12] <author> J. Helander. </author> <title> Unix under Mach: The Lites server. </title> <type> Master's thesis, </type> <institution> Helsinki University of Technology, </institution> <year> 1994. </year> <pages> 64 pp. </pages> <note> Also http://www.cs.hut.fi/jvh/lites.MASTERS.ps. </note>
Reference-contexts: Section 4.5 demonstrates the second point, that presentation attributes can be leveraged by specializable transport mechanisms, to further optimize RPC. Except for the Linux example, all tests were performed on an HP730 (66 MHz PARISC architecture) running Mach 3.0 and the Lites <ref> [12] </ref> Unix single server. <p> This server is representative of a common model of communication: an intermediate entity that performs a data transformation between two parties. Thus, the results presented here should generalize to other components in a decomposed system. Our implementation runs on the Mach microkernel, in a Lites <ref> [12] </ref> environment (a Unix server based on BSD 4.4 Lite). The standard Lites server is mostly monolithic in nature, with the same overall design as the original CMU UX single server [9].
Reference: [13] <author> ISO. </author> <title> Information Procesing Systems Open Systems Interconnetion Basic Reference Model. </title> <journal> ISO-7498, </journal> <volume> 194. </volume>
Reference-contexts: In our terminology (adopted from the OSI networking model <ref> [13] </ref>), these function prototypes represent alternate presentations of the same interface. <p> paper we describe related work (Section 2), briefly describe the design of our IDL compiler (Section 3), present specific examples in which flexible presentation enhances RPC performance and quantify the improvements (Section 4), propose future work, and conclude. 2 Related Work The term presentation comes from the OSI networking model <ref> [13] </ref> which defines a presentation layer responsible for providing applications with data in the locally-preferred representation. The primary presentation emphasis in the OSI model is on data representation at the format level (e.g., ASCII or EBCDIC, big- or little-endian).
Reference: [14] <author> M. K. Johnson. </author> <title> LINUX Kernel Hackers' Guide. </title> <address> ftp://tsx-11.mit.edu:/pub/linux/docs/linux-doc/- project/khg-0.6.ps.gz, </address> <year> 1993. </year> <pages> 119 pp. </pages>
Reference-contexts: The times presented below include all RPC costs, including both user-level stub code and kernel processing. 4.1 Linux NFS Client In several traditional Unix-compatible monolithic operating systems, such as 4.3/4.4BSD [16] and Linux <ref> [14] </ref> 4 , the NFS file system support built into the kernel uses manually-written Sun RPC stubs, even though an automatic stub generator (rpcgen) is available.
Reference: [15] <author> P. Klint. </author> <title> Interpretation techniques. </title> <journal> Software Practice and Experience, </journal> <volume> 11(9) </volume> <pages> 963-973, </pages> <month> Sept. </month> <year> 1981. </year>
Reference-contexts: It then builds a combination signature based on both input signatures. The combination signature includes a block which threads <ref> [15] </ref> together small blocks of code which perform key parts of the RPC, such as register saving and restoring. The binding time work needn't be done by the kernel; a privileged user process could equally 13 well do it.
Reference: [16] <author> S. J. Leffler, M. K. McKusick, M. J. Karels, and J. S. Quarterman. </author> <title> The Design and Implementation of the 4.3BSD Unix Operating System. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1989. </year>
Reference-contexts: The times presented below include all RPC costs, including both user-level stub code and kernel processing. 4.1 Linux NFS Client In several traditional Unix-compatible monolithic operating systems, such as 4.3/4.4BSD <ref> [16] </ref> and Linux [14] 4 , the NFS file system support built into the kernel uses manually-written Sun RPC stubs, even though an automatic stub generator (rpcgen) is available.
Reference: [17] <author> J. Liedtke. </author> <title> Improving IPC by kernel design. </title> <booktitle> In Proc. of the 14th ACM Symposium on Operating Systems Principles, </booktitle> <address> Asheville, NC, </address> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: Processes that have open file handles to a particular pipe communicate directly with the pipe server to read and write data. Communication with the pipe server is done using a new, streamlined low-level Mach IPC mechanism similar to those implemented in other recent microkernels <ref> [10, 17, 8] </ref>. The new IPC path allows messages to be transferred through processor registers and/or a simple message buffer copied by the kernel directly from the source address space to the target address space.
Reference: [18] <author> Microsoft Corporation and Digital Equipment Corporation. </author> <title> Common Object Model Specification, </title> <month> July </month> <year> 1994. </year> <pages> 62 pp. </pages>
Reference-contexts: The rightmost bar in each group is for flexible presentation, which copies only when necessary, and never requires the programmer to make a copy manually. 4.4.2 Example: allocation/deallocation of out parameters Many systems, including COM <ref> [18] </ref> and CORBA, specify move semantics for out parameters, meaning the server allocates storage for the parameter and donates that storage to the client upon returning; the client must then free the buffer later.
Reference: [19] <author> Object Management Group. </author> <title> The Common Object Request Broker: Architecture and specification. </title> <note> Draft 10 Rev 1.1 Doc # 91.12.1, OMG, </note> <month> Dec. </month> <year> 1991. </year>
Reference-contexts: However, in most RPC systems, the IDL file also indirectly defines the programmer's contract between the stubs and the programmer: how parameters are passed to the stub, who allocates storage for the parameters, etc. For example, consider the following CORBA <ref> [19] </ref> IDL fragment: interface SysLog - void write_msg (in string msg); -; Given this interface definition, a CORBA-compliant stub compiler for C will always produce a stub with the following C function prototype, with the msg parameter assumed to be null-terminated: void SysLog write msg (SysLog object, CORBA Exception *ex, char
Reference: [20] <author> S. O'Malley, T. Proebsting, and A. B. Montz. </author> <title> USC: A universal stub compiler. </title> <booktitle> In Proc. of the SIG-COMM '94 Symposium, </booktitle> <month> Aug. </month> <year> 1994. </year>
Reference-contexts: Their emphasis is on the latter, ours the former, but similar issues and performance effects obtain. We bring to RPC the focus on presentation optimization that has been elucidated in the traditional networking arena <ref> [5, 20] </ref>.
Reference: [21] <author> Open Software Foundation. </author> <title> OSF DCE Application Development Guide. </title> <publisher> Prentice Hall, </publisher> <year> 1993. </year> <month> 16 </month>
Reference-contexts: However, a few allow the presentation to be varied independently for a given client or server. In DCE <ref> [21] </ref>, a few presentation attributes can be specified explicitly, separately from the IDL file defining the interface, in a supplemental file known as an application control file (ACF). <p> The primary presentation emphasis in the OSI model is on data representation at the format level (e.g., ASCII or EBCDIC, big- or little-endian). We know of two IDLs for RPC in which the notion of separate presentation exists to some degree. DCE <ref> [21] </ref>, with its Application Configuration File (ACF), was, to our knowledge, the first RPC system to support separately specified presentation.
References-found: 21

