URL: http://www.cs.rice.edu/CS/PLT/Publications/tacs94-cf.ps.gz
Refering-URL: http://www.cs.rice.edu/CS/PLT/Publications/
Root-URL: 
Title: Extensible Denotational Language Specifications  
Author: Robert Cartwright, Matthias Felleisen 
Date: April 18-21, 1994  
Note: To appear in: Symposium on Theoretical Aspects  
Address: Houston, TX 77251-1892  Sendai,  
Affiliation: Department of Computer Science Rice University  of Computer Software  
Abstract-found: 0
Intro-found: 0
Reference: 1. <author> Allison, L. </author> <title> A Practical Introduction to Denotational Semantics. </title> <booktitle> Cam-bridge Computer Science Texts 23. </booktitle> <publisher> Cambridge University Press, </publisher> <address> Cambridge, England. </address> <year> 1986. </year>
Reference-contexts: Traditional denotational language specifications <ref> [1, 15, 27, 35] </ref> cope with these constructs by interpreting program phrases as functions that map environments fi stores fi continuations to values fi stores. Programmers, however, rely on simpler semantic descriptions when they reason about program phrases. <p> In a functional language of Pure Scheme, the evaluation context of a redex plays no role until the redex is reduced to a value. For example, the expression E [(( x:(add1 (if x 0 1))) true)] reduces to E <ref> [1] </ref>, no matter what E is. More generally, all (closed) expressions in a mathematical language (with recursion) either produce a value, signal an error, or diverge. Consequently, a denotational semantics can map an expression in such a language to numbers, boolean values, functions, errors, or bottom. <p> employs the syntax (catch x e) for catching the continuation and binding it to x and the syntax (throw x e) for throwing the value of e to the continuation bound to x [37]. 7 Modeling first-class continuation objects according to the traditional method requires the use of a continuation-semantics <ref> [36, 1, 15, 27, 35] </ref>. A continuation semantics parameterizes the denotation of every phrase type over a continuation, which is a function that maps intermediate results to final answers. In the framework of extended direct semantics the output of the final answer is under the control of the central administrator.
Reference: 2. <author> Allison, L. </author> <title> Direct semantics and exceptions define jumps and coroutines. </title> <journal> Information Processing Letters 31, </journal> <year> 1989, </year> <pages> 327-330. </pages>
Reference-contexts: Extensible Denotational Language Specifications 21 Vienna School of Denotational Semantics. The extended direct semantics for Control Scheme is related to the approach of the Vienna School of Denotational Semantics [3, 4, 15:52-55] to modeling jumps and labels, a method that was partially rediscovered by Allison <ref> [2] </ref>. Indeed, the treatment of labels and gotos in block-structured languages according to this school of thought can be seen as an instance of our technique. In their framework, a statement denotes a state transformer that either returns a new state or a syntactic label (combined with a state).
Reference: 3. <author> Bjtrner, D. and C. Jones. </author> <title> Formal Specification and Software Development. </title> <publisher> Prentice Hall International, </publisher> <year> 1982. </year>
Reference-contexts: At this point it is not clear what the trade-offs between the monad approach and our approach are. Extensible Denotational Language Specifications 21 Vienna School of Denotational Semantics. The extended direct semantics for Control Scheme is related to the approach of the Vienna School of Denotational Semantics <ref> [3, 4, 15:52-55] </ref> to modeling jumps and labels, a method that was partially rediscovered by Allison [2]. Indeed, the treatment of labels and gotos in block-structured languages according to this school of thought can be seen as an instance of our technique.
Reference: 4. <author> Blikle, A. and A. Tarlecki. </author> <title> Naive denotational semantics. </title> <booktitle> In Proc. IFIP 9th World Computer Congress: Information Processing 83, </booktitle> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1983, </year> <pages> 345-355. </pages>
Reference-contexts: At this point it is not clear what the trade-offs between the monad approach and our approach are. Extensible Denotational Language Specifications 21 Vienna School of Denotational Semantics. The extended direct semantics for Control Scheme is related to the approach of the Vienna School of Denotational Semantics <ref> [3, 4, 15:52-55] </ref> to modeling jumps and labels, a method that was partially rediscovered by Allison [2]. Indeed, the treatment of labels and gotos in block-structured languages according to this school of thought can be seen as an instance of our technique. <p> The responsibility of propagating effects rests with the composition function for statements and other "glue" functions. When a label reaches the top-level, an exception handler that corresponds to our administrator effects the appropriate jump. Blikle and Tarleki <ref> [4] </ref> showed that by using the VDM technique, denotational specifications can use sets instead of domains and partial functions, instead of continuous ones. The Vienna School has not applied this technique to the specification of other imperative language constructs [D.
Reference: 5. <author> Crank, E. and M. Felleisen. </author> <title> Parameter-passing and the lambda-calculus. </title> <booktitle> In Proc. 18th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1991, </year> <pages> 233-245. </pages>
Reference-contexts: The last subsection shows that the denotation of a phrase is stable with respect to all possible extensions. 4 It is also possible to design an operational semantics that deals with such resources on a more local level <ref> [5, 11, 40] </ref>. 5 The language is universal relative to the chosen universal domain.
Reference: 6. <author> Demichiel, L.G. </author> <title> Overview: The Common Lisp Object System. </title> <booktitle> Lisp and Symbolic Computation 1(3/4), </booktitle> <year> 1988, </year> <pages> 227-244. </pages>
Reference-contexts: This method yields monolithic interpreters defined from independent pieces, but the method for gluing them together is based on program text and is thus beyond the scope of most programming languages. One alternative is to use an object-oriented programming language in the spirit of CLOS <ref> [6] </ref>. Each language fragment would extend the list of resources, and the interpreter and administrator methods of an existing language. In addition a language fragment would also introduce new local data constructors.
Reference: 7. <author> Dybvig, R. K. </author> <title> The Scheme Programming Language, </title> <publisher> Prentice-Hall, </publisher> <address> Engle-wood Cliffs, New Jersey, </address> <year> 1987. </year>
Reference-contexts: Once the resulting language module is fed into the language transformer for the control language, this will 8 Rice Scheme is an extension of Chez Scheme <ref> [7] </ref> that includes modules and data constructor definitions for immutable structures. It also comes with a soft type system [41] that infers types and eliminates type checks where possible.
Reference: 8. <author> Dybvig, R. K. and R. Hieb. </author> <title> Engines from continuations. </title> <note> Journal of Computer Languages (Pergamon Press) 14(2), </note> <year> 1989, </year> <pages> 109-124. </pages>
Reference-contexts: The resulting meaning function and the 7 With first-class continuations objects it is easy to simulate many other control constructs and patterns, e.g., loop exits, blind and non-blind backtracking [14], corou tines [16], light-weight threads [39], and time-preempted computations <ref> [8] </ref>. 14 Robert Cartwright, Matthias Felleisen administrator would be identical to the ones we just described. In general, the addition of new orthogonal linguistic constructs is as straightforward as the extension of Pure Scheme to Control Scheme or of State Scheme to Core Scheme.
Reference: 9. <author> Felleisen, M. and D.P. Friedman. </author> <title> A reduction semantics for imperative higher-order languages. </title> <booktitle> In Proc. Conference on Parallel Architectures and Languages Europe, Volume II: Parallel Languages. Lecture Notes in Computer Science 259. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Heidelberg, </address> <year> 1987, </year> <pages> 206-223. </pages>
Reference-contexts: B contains the pieces of the implementation that are not explained in Section 4. 2 Extensible Operational Semantics The intuition underlying our framework of extensible semantic specifications is derived from a generalization of the operational semantics of the -calculus to full-fledged Scheme-style programming languages with exceptions, first-class continuations, and assignments <ref> [9, 10, 11, 12] </ref>. The extensions of these semantics are conservative in the sense that the reduction relation for the extended language is a superset of the original reduction relation.
Reference: 10. <author> Felleisen, M. and D.P. Friedman. </author> <title> A syntactic theory of sequential state. </title> <journal> Theor. Comput. Sci. </journal> <volume> 69(3), </volume> <year> 1989, </year> <month> 243-287. </month> <title> Preliminary version in: </title> <booktitle> Proc. 14th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1987, </year> <pages> 314-325. </pages>
Reference-contexts: B contains the pieces of the implementation that are not explained in Section 4. 2 Extensible Operational Semantics The intuition underlying our framework of extensible semantic specifications is derived from a generalization of the operational semantics of the -calculus to full-fledged Scheme-style programming languages with exceptions, first-class continuations, and assignments <ref> [9, 10, 11, 12] </ref>. The extensions of these semantics are conservative in the sense that the reduction relation for the extended language is a superset of the original reduction relation.
Reference: 11. <author> Felleisen, M. and R. Hieb. </author> <title> The revised report on the syntactic theories of sequential control and state. </title> <type> Technical Report 100, </type> <institution> Rice University, </institution> <month> June </month> <year> 1989. </year> <institution> Theor. Comput. Sci. </institution> <month> 102, </month> <year> 1992, </year> <pages> 235-271. </pages>
Reference-contexts: B contains the pieces of the implementation that are not explained in Section 4. 2 Extensible Operational Semantics The intuition underlying our framework of extensible semantic specifications is derived from a generalization of the operational semantics of the -calculus to full-fledged Scheme-style programming languages with exceptions, first-class continuations, and assignments <ref> [9, 10, 11, 12] </ref>. The extensions of these semantics are conservative in the sense that the reduction relation for the extended language is a superset of the original reduction relation. <p> The last subsection shows that the denotation of a phrase is stable with respect to all possible extensions. 4 It is also possible to design an operational semantics that deals with such resources on a more local level <ref> [5, 11, 40] </ref>. 5 The language is universal relative to the chosen universal domain.
Reference: 12. <author> Felleisen, M., D.P. Friedman, E. Kohlbecker, and B. Duba. </author> <title> A syntactic theory of sequential control. </title> <journal> Theor. Comput. Sci. </journal> <volume> 52(3), </volume> <year> 1987, </year> <pages> 205-237. </pages> <note> Preliminary version in: Proc. Symposium on Logic in Computer Science, </note> <year> 1986, </year> <pages> 131-141. </pages>
Reference-contexts: B contains the pieces of the implementation that are not explained in Section 4. 2 Extensible Operational Semantics The intuition underlying our framework of extensible semantic specifications is derived from a generalization of the operational semantics of the -calculus to full-fledged Scheme-style programming languages with exceptions, first-class continuations, and assignments <ref> [9, 10, 11, 12] </ref>. The extensions of these semantics are conservative in the sense that the reduction relation for the extended language is a superset of the original reduction relation.
Reference: 13. <author> Filinski, A. </author> <title> Representing monads. </title> <booktitle> In Proc. 21st ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1994, </year> <title> to appear. Extensible Denotational Language Specifications 23 </title>
Reference-contexts: M [[e]] = C 0 !C (M 0 [[e]]( V!V 0 ffi )) C!C 0 (M [[e]]( V 0 !V ffi 0 )) v M 0 [[e]] 0 ; The reader may want to contrast this general statement with the numerous papers on the relationship between direct and continuation semantics <ref> [13, 18, 26, 30, 34] </ref>. 4 Composing Interpreters Given an extended direct semantics of Core Scheme, we should be able to implement an interpreter for Core Scheme in a modular fashion.
Reference: 14. <author> Friedman, D.P., C.T. Haynes, and E. Kohlbecker. </author> <title> Programming with continuations. In Program Transformations and Programming Environments, edited by P. Pepper. </title> <publisher> Springer-Verlag, </publisher> <address> Heidelberg, </address> <year> 1985, </year> <pages> 263-274. </pages>
Reference-contexts: Merging the reference domains into the domains of Control Scheme yields domains that are isomorphic to those of Core Scheme. The resulting meaning function and the 7 With first-class continuations objects it is easy to simulate many other control constructs and patterns, e.g., loop exits, blind and non-blind backtracking <ref> [14] </ref>, corou tines [16], light-weight threads [39], and time-preempted computations [8]. 14 Robert Cartwright, Matthias Felleisen administrator would be identical to the ones we just described.
Reference: 15. <author> Gordon, M.J. </author> <title> The Denotational Description of Programming Languages, </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: Traditional denotational language specifications <ref> [1, 15, 27, 35] </ref> cope with these constructs by interpreting program phrases as functions that map environments fi stores fi continuations to values fi stores. Programmers, however, rely on simpler semantic descriptions when they reason about program phrases. <p> employs the syntax (catch x e) for catching the continuation and binding it to x and the syntax (throw x e) for throwing the value of e to the continuation bound to x [37]. 7 Modeling first-class continuation objects according to the traditional method requires the use of a continuation-semantics <ref> [36, 1, 15, 27, 35] </ref>. A continuation semantics parameterizes the denotation of every phrase type over a continuation, which is a function that maps intermediate results to final answers. In the framework of extended direct semantics the output of the final answer is under the control of the central administrator.
Reference: 16. <author> Haynes, C.T., D.P. Friedman, and M. Wand. </author> <title> Obtaining coroutines from continuations. </title> <note> Journal of Computer Languages (Pergamon Press) 11, </note> <year> 1986, </year> <month> 143-153. </month> <title> Preliminary Version in Lisp and Functional Programming, </title> <booktitle> 1984, </booktitle> <address> Austin, TX. </address>
Reference-contexts: The resulting meaning function and the 7 With first-class continuations objects it is easy to simulate many other control constructs and patterns, e.g., loop exits, blind and non-blind backtracking [14], corou tines <ref> [16] </ref>, light-weight threads [39], and time-preempted computations [8]. 14 Robert Cartwright, Matthias Felleisen administrator would be identical to the ones we just described.
Reference: 17. <author> Kanneganti, R., and R. Cartwright. </author> <title> What is a universal higher-order programming language? In Proc. </title> <booktitle> International Conference on Automata, Languages, and Programming. Lecture Notes in Computer Science 700. </booktitle> <publisher> Springer Verlag, </publisher> <address> Berlin, </address> <year> 1993, </year> <pages> 682-695. </pages>
Reference-contexts: The first part defines the syntactic and semantic domains of the language. The domains are sub-domains of some universal domain, e.g., P! [29], T ! [24], U [28], or T <ref> [17] </ref>. The syntactic domains specify the phrases of the language; the semantic domains contain denotations for the various kinds of syntactic phrases. The second part is a functional interpreter that maps elements of the syntactic domains to elements in semantic domains. <p> The second part is a functional interpreter that maps elements of the syntactic domains to elements in semantic domains. It is defined in a universal 5 programming language like Lambda [29] or KL <ref> [17] </ref> and satisfies the law of composition-ality, i.e., the interpretation of a phrase is a function of the interpretations of its sub-phrases. To keep track of the denotations of free variables, interpreters are also parameterized over an environment argument.
Reference: 18. <author> Meyer, A.R. and M. Wand. </author> <title> Continuation semantics in typed lambda-calculi. </title> <booktitle> Proc. Workshop Logics of Programs, Lecture Notes in Computer Science 193, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Heidelberg, </address> <year> 1985, </year> <pages> 219-224. </pages>
Reference-contexts: M [[e]] = C 0 !C (M 0 [[e]]( V!V 0 ffi )) C!C 0 (M [[e]]( V 0 !V ffi 0 )) v M 0 [[e]] 0 ; The reader may want to contrast this general statement with the numerous papers on the relationship between direct and continuation semantics <ref> [13, 18, 26, 30, 34] </ref>. 4 Composing Interpreters Given an extended direct semantics of Core Scheme, we should be able to implement an interpreter for Core Scheme in a modular fashion.
Reference: 19. <author> Milner, R., M. Tofte, and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts and London, England, </address> <year> 1990. </year>
Reference-contexts: Based on extended direct semantics, it is also possible to construct interpreters for complete languages by composing interpreters for language fragments. 1 The Denotational Specifications of Complex Languages A programming language like Scheme [25], Common LISP [32], or ML <ref> [19] </ref> consists of a rich functional core, augmented by destructive operations on data objects, control constructs, and possibly other imperative operators. Traditional denotational language specifications [1, 15, 27, 35] cope with these constructs by interpreting program phrases as functions that map environments fi stores fi continuations to values fi stores.
Reference: 20. <author> Moggi, E. </author> <title> An abstract view of programming languages. </title> <type> LFCS Report ECS-LFCS-90-113, </type> <institution> University of Edinburgh, </institution> <year> 1990. </year>
Reference-contexts: Moggi's <ref> [21, 22, 20] </ref> recent work on formulating notions of computations as monads, popularized by Wadler [38], is partly motivated by the lack of modularity in denotational specifications and a resulting lack of understanding of 20 Robert Cartwright, Matthias Felleisen the logical relationships between computations.
Reference: 21. <author> Moggi, E. </author> <title> Notions of computations and monads. </title> <journal> Inf. and Comp. </journal> <volume> 93, </volume> <year> 1991, </year> <pages> 55-92. </pages>
Reference-contexts: Moggi's <ref> [21, 22, 20] </ref> recent work on formulating notions of computations as monads, popularized by Wadler [38], is partly motivated by the lack of modularity in denotational specifications and a resulting lack of understanding of 20 Robert Cartwright, Matthias Felleisen the logical relationships between computations.
Reference: 22. <author> Moggi, E. </author> <title> Computational lambda-calculus and monads. </title> <booktitle> In Proc. Fourth Symposium on Logic in Computer Science, </booktitle> <year> 1989, </year> <pages> 14-23. </pages>
Reference-contexts: Moggi's <ref> [21, 22, 20] </ref> recent work on formulating notions of computations as monads, popularized by Wadler [38], is partly motivated by the lack of modularity in denotational specifications and a resulting lack of understanding of 20 Robert Cartwright, Matthias Felleisen the logical relationships between computations.
Reference: 23. <author> Mosses, P. </author> <title> Denotational Semantics. </title> <booktitle> In Handbook of Theoretical Computer Science, </booktitle> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1991, </year> <pages> 575-631. </pages>
Reference-contexts: Moreover, if we add control operators (such as goto or callcc), the meaning of 5 becomes a constant function from environments fi stores fi continuations to values fi stores. This annoying property of denota-tional semantics is well-known among language researchers. Indeed, in a recent survey paper, Peter Mosses <ref> [23] </ref> has argued that this phenomenon has been a major impediment to the acceptance of denotational semantics as a practical vehicle for defining programming languages.
Reference: 24. <author> Plotkin, G. </author> <title> T ! as a Universal Domain. </title> <journal> J. Comput. Syst. Sci. </journal> <volume> 17, </volume> <year> 1978, </year> <pages> 209-236. </pages>
Reference-contexts: The first part defines the syntactic and semantic domains of the language. The domains are sub-domains of some universal domain, e.g., P! [29], T ! <ref> [24] </ref>, U [28], or T [17]. The syntactic domains specify the phrases of the language; the semantic domains contain denotations for the various kinds of syntactic phrases. The second part is a functional interpreter that maps elements of the syntactic domains to elements in semantic domains.
Reference: 25. <editor> Rees, J. and W. Clinger (Eds.). </editor> <title> The revised 3 report on the algorithmic language Scheme. </title> <journal> SIGPLAN Notices 21(12), </journal> <year> 1986, </year> <pages> 37-79. </pages>
Reference-contexts: Based on extended direct semantics, it is also possible to construct interpreters for complete languages by composing interpreters for language fragments. 1 The Denotational Specifications of Complex Languages A programming language like Scheme <ref> [25] </ref>, Common LISP [32], or ML [19] consists of a rich functional core, augmented by destructive operations on data objects, control constructs, and possibly other imperative operators.
Reference: 26. <author> Reynolds, </author> <title> J.C. On the relation between direct and continuation semantics. </title> <booktitle> In Proc. International Conference on Automata, Languages and Programming, </booktitle> <year> 1974, </year> <pages> 141-156. </pages>
Reference-contexts: M [[e]] = C 0 !C (M 0 [[e]]( V!V 0 ffi )) C!C 0 (M [[e]]( V 0 !V ffi 0 )) v M 0 [[e]] 0 ; The reader may want to contrast this general statement with the numerous papers on the relationship between direct and continuation semantics <ref> [13, 18, 26, 30, 34] </ref>. 4 Composing Interpreters Given an extended direct semantics of Core Scheme, we should be able to implement an interpreter for Core Scheme in a modular fashion.
Reference: 27. <author> Schmidt, D.A. </author> <title> Denotational Semantics: A Methodology for Language Development. </title> <publisher> Allyn and Bacon, </publisher> <address> Newton, Mass., </address> <year> 1986. </year>
Reference-contexts: Traditional denotational language specifications <ref> [1, 15, 27, 35] </ref> cope with these constructs by interpreting program phrases as functions that map environments fi stores fi continuations to values fi stores. Programmers, however, rely on simpler semantic descriptions when they reason about program phrases. <p> employs the syntax (catch x e) for catching the continuation and binding it to x and the syntax (throw x e) for throwing the value of e to the continuation bound to x [37]. 7 Modeling first-class continuation objects according to the traditional method requires the use of a continuation-semantics <ref> [36, 1, 15, 27, 35] </ref>. A continuation semantics parameterizes the denotation of every phrase type over a continuation, which is a function that maps intermediate results to final answers. In the framework of extended direct semantics the output of the final answer is under the control of the central administrator.
Reference: 28. <author> Scott, D. S. </author> <title> Domains for denotational semantics. </title> <booktitle> In Proc. International Conference on Automata, Languages, and Programming, Lecture Notes in Mathematics 140, </booktitle> <publisher> Springer Verlag, </publisher> <address> Berlin, </address> <year> 1982, </year> <pages> 577-613. </pages>
Reference-contexts: The first part defines the syntactic and semantic domains of the language. The domains are sub-domains of some universal domain, e.g., P! [29], T ! [24], U <ref> [28] </ref>, or T [17]. The syntactic domains specify the phrases of the language; the semantic domains contain denotations for the various kinds of syntactic phrases. The second part is a functional interpreter that maps elements of the syntactic domains to elements in semantic domains.
Reference: 29. <author> Scott, </author> <title> D.S. Data types as lattices. </title> <journal> SIAM J. Comput. </journal> <volume> 5(3), </volume> <year> 1976, </year> <pages> 522-587. </pages>
Reference-contexts: The first part defines the syntactic and semantic domains of the language. The domains are sub-domains of some universal domain, e.g., P! <ref> [29] </ref>, T ! [24], U [28], or T [17]. The syntactic domains specify the phrases of the language; the semantic domains contain denotations for the various kinds of syntactic phrases. The second part is a functional interpreter that maps elements of the syntactic domains to elements in semantic domains. <p> The second part is a functional interpreter that maps elements of the syntactic domains to elements in semantic domains. It is defined in a universal 5 programming language like Lambda <ref> [29] </ref> or KL [17] and satisfies the law of composition-ality, i.e., the interpretation of a phrase is a function of the interpretations of its sub-phrases. To keep track of the denotations of free variables, interpreters are also parameterized over an environment argument.
Reference: 30. <author> Sethi R. and A. Tang. </author> <title> Constructing call-by-value continuation semantics. </title> <journal> J. ACM 27(3), </journal> <year> 1980, </year> <pages> 580-597. </pages> <note> 24 Robert Cartwright, Matthias Felleisen </note>
Reference-contexts: M [[e]] = C 0 !C (M 0 [[e]]( V!V 0 ffi )) C!C 0 (M [[e]]( V 0 !V ffi 0 )) v M 0 [[e]] 0 ; The reader may want to contrast this general statement with the numerous papers on the relationship between direct and continuation semantics <ref> [13, 18, 26, 30, 34] </ref>. 4 Composing Interpreters Given an extended direct semantics of Core Scheme, we should be able to implement an interpreter for Core Scheme in a modular fashion.
Reference: 31. <author> Sitaram, D. and M. Felleisen. </author> <title> Modeling continuations without continuations. </title> <booktitle> In Proc. 18th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1991, </year> <pages> 185-196. </pages>
Reference-contexts: We are also grateful to Dan Friedman, Brian 10 Since we wrote the original report on extended direct semantics, Dorai Sitaram and the second author have explored this question for one special case (continuations) and have published a report on the results <ref> [31] </ref>. 22 Robert Cartwright, Matthias Felleisen Milnes, Amr Sabry, and Steve Weeks for comments on an early draft of the paper. The Scheme code was type-set with Dorai Sitaram's SL a T E X.
Reference: 32. <author> Steele, G.L., Jr. </author> <title> Common Lisp|The Language. </title> <publisher> Digital Press, </publisher> <year> 1984. </year>
Reference-contexts: Based on extended direct semantics, it is also possible to construct interpreters for complete languages by composing interpreters for language fragments. 1 The Denotational Specifications of Complex Languages A programming language like Scheme [25], Common LISP <ref> [32] </ref>, or ML [19] consists of a rich functional core, augmented by destructive operations on data objects, control constructs, and possibly other imperative operators.
Reference: 33. <author> Steele, G.L., Jr. </author> <title> Building interpreters by composing monads. </title> <booktitle> In Proc. 21st ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1994, </year> <note> to appear. </note>
Reference-contexts: In addition a language fragment would also introduce new local data constructors. Here we present another alternative based on the module system of Rice Extensible Denotational Language Specifications 17 Scheme. 8 It is inspired by Steele's upcoming paper on composing monads <ref> [33] </ref>. 9 Fig. 7 through Fig. 14 in this section and Section B contain the complete code. A language is implemented as a module that exports three bindings: 1. an interpreter function; 2. an administrator function; and 3. a list of resources. <p> A typical example is the combination of an exception monad with a store monad. One combination undoes side-effects in the process of raising an exception, the other one does not. To overcome the problems associated with combining monads, Steele <ref> [33] </ref> introduces the idea of a pseudo-monad , a relaxation of Moggi's notion. Based on the functional composition of pseudo-monads, Steele shows how to build interpreters for languages from interpreters for language fragments. Section 4 was inspired by his approach.
Reference: 34. <author> Stoy, J. </author> <title> The congruence of two programming language definitions. </title> <journal> Theor. Comput. Sci. </journal> <volume> 13, </volume> <year> 1981, </year> <pages> 151-174. </pages>
Reference-contexts: M [[e]] = C 0 !C (M 0 [[e]]( V!V 0 ffi )) C!C 0 (M [[e]]( V 0 !V ffi 0 )) v M 0 [[e]] 0 ; The reader may want to contrast this general statement with the numerous papers on the relationship between direct and continuation semantics <ref> [13, 18, 26, 30, 34] </ref>. 4 Composing Interpreters Given an extended direct semantics of Core Scheme, we should be able to implement an interpreter for Core Scheme in a modular fashion.
Reference: 35. <author> Stoy, </author> <title> J.E. Denotational Semantics: The Scott-Strachey Approach to Programming Languages. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass. </address> <year> 1981. </year>
Reference-contexts: Traditional denotational language specifications <ref> [1, 15, 27, 35] </ref> cope with these constructs by interpreting program phrases as functions that map environments fi stores fi continuations to values fi stores. Programmers, however, rely on simpler semantic descriptions when they reason about program phrases. <p> employs the syntax (catch x e) for catching the continuation and binding it to x and the syntax (throw x e) for throwing the value of e to the continuation bound to x [37]. 7 Modeling first-class continuation objects according to the traditional method requires the use of a continuation-semantics <ref> [36, 1, 15, 27, 35] </ref>. A continuation semantics parameterizes the denotation of every phrase type over a continuation, which is a function that maps intermediate results to final answers. In the framework of extended direct semantics the output of the final answer is under the control of the central administrator.
Reference: 36. <author> Strachey, C. </author> <title> and C.P. Wadsworth. Continuations: A mathematical semantics for handling full jumps. </title> <type> Technical Monograph PRG-11, </type> <institution> Oxford University Computing Laboratory, Programming Research Group, </institution> <year> 1974. </year>
Reference-contexts: employs the syntax (catch x e) for catching the continuation and binding it to x and the syntax (throw x e) for throwing the value of e to the continuation bound to x [37]. 7 Modeling first-class continuation objects according to the traditional method requires the use of a continuation-semantics <ref> [36, 1, 15, 27, 35] </ref>. A continuation semantics parameterizes the denotation of every phrase type over a continuation, which is a function that maps intermediate results to final answers. In the framework of extended direct semantics the output of the final answer is under the control of the central administrator.
Reference: 37. <author> Sussman, G.J. and G.L. Steele Jr. </author> <title> Scheme: An interpreter for extended lambda calculus. </title> <type> Memo 349, </type> <institution> MIT AI Lab, </institution> <year> 1975. </year>
Reference-contexts: Control Scheme employs the syntax (catch x e) for catching the continuation and binding it to x and the syntax (throw x e) for throwing the value of e to the continuation bound to x <ref> [37] </ref>. 7 Modeling first-class continuation objects according to the traditional method requires the use of a continuation-semantics [36, 1, 15, 27, 35]. A continuation semantics parameterizes the denotation of every phrase type over a continuation, which is a function that maps intermediate results to final answers.
Reference: 38. <author> Wadler, P. </author> <title> The essence of functional programming. </title> <booktitle> In Proc. 19th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1992, </year> <pages> 1-14. </pages>
Reference-contexts: Moggi's [21, 22, 20] recent work on formulating notions of computations as monads, popularized by Wadler <ref> [38] </ref>, is partly motivated by the lack of modularity in denotational specifications and a resulting lack of understanding of 20 Robert Cartwright, Matthias Felleisen the logical relationships between computations.
Reference: 39. <author> Wand, M. </author> <title> Continuation-based multiprocessing. </title> <booktitle> In Proc. 1980 ACM Conference on Lisp and Functional Programming, </booktitle> <year> 1980, </year> <pages> 19-28. </pages>
Reference-contexts: The resulting meaning function and the 7 With first-class continuations objects it is easy to simulate many other control constructs and patterns, e.g., loop exits, blind and non-blind backtracking [14], corou tines [16], light-weight threads <ref> [39] </ref>, and time-preempted computations [8]. 14 Robert Cartwright, Matthias Felleisen administrator would be identical to the ones we just described. In general, the addition of new orthogonal linguistic constructs is as straightforward as the extension of Pure Scheme to Control Scheme or of State Scheme to Core Scheme.
Reference: 40. <author> Wright, A. and M. Felleisen. </author> <title> A syntactic approach to type soundness. </title> <type> Technical Report 160. </type> <institution> Rice University, </institution> <year> 1991. </year> <note> Information and Computation, 1993, to appear. </note>
Reference-contexts: The last subsection shows that the denotation of a phrase is stable with respect to all possible extensions. 4 It is also possible to design an operational semantics that deals with such resources on a more local level <ref> [5, 11, 40] </ref>. 5 The language is universal relative to the chosen universal domain.
Reference: 41. <author> Wright, A.K. and R. Cartwright. </author> <title> A practical soft type system for Scheme. </title> <type> Technical Report Rice CS 93-218. </type> <institution> Rice University, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: Once the resulting language module is fed into the language transformer for the control language, this will 8 Rice Scheme is an extension of Chez Scheme [7] that includes modules and data constructor definitions for immutable structures. It also comes with a soft type system <ref> [41] </ref> that infers types and eliminates type checks where possible.
References-found: 41

