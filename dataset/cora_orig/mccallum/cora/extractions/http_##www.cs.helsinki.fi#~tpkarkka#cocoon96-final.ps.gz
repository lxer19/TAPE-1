URL: http://www.cs.helsinki.fi/~tpkarkka/cocoon96-final.ps.gz
Refering-URL: http://www.cs.helsinki.fi/research/pmdm/publications/
Root-URL: 
Email: Email: fJuha.Karkkainen,Esko.Ukkoneng@cs.Helsinki.FI  
Title: Sparse Suffix Trees  
Author: Juha Karkkainen and Esko Ukkonen 
Address: P.O. Box 26 (Teollisuuskatu 23) FIN-00014 University of Helsinki, Finland.  
Affiliation: Department of Computer Science,  
Abstract: A sparse suffix tree is a suffix tree that represents only a subset of the suffixes of the text. This is in contrast to the standard suffix tree that represents all suffixes. By selecting a small enough subset, a sparse suffix tree can be made to fit the available storage, unfortunately at the cost of increased search times. The idea of sparse suffix trees goes back to PATRICIA tries. Evenly spaced sparse suffix trees represent every kth suffix of the text. In the paper, we give general construction and search algorithms for evenly spaced sparse suffix trees, and present their run time analysis, both in the worst and in the average case. The algorithms are further improved by using so-called dual suffix trees.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A. Andersson, N. J. Larsson, and K. Swansson, </author> <title> Suffix trees on words, </title> <booktitle> in Proc. 7th Symposium on Combinatorial Pattern Matching (CPM), </booktitle> <year> 1996. </year> <note> To appear. </note>
Reference-contexts: The idea already appears in [14]. Such an unevenly spaced SST can be constructed either through the full suffix tree, at the cost of extra space, or by brute force construction, at the cost of extra time. Recently, Andersson et. al <ref> [1] </ref> have presented fast construction algorithms working in small space. Another natural variation is to represent every kth suffix for some fixed k. Such an evenly spaced SST can be constructed directly, in linear time, using a modified version of the classical suffix tree construction algorithm. <p> By the results of Apostolico and Szpankowski [5], the expected construction time for random text and randomly selected suffixes is O (n+N log N ). Recently, Andersson et. al <ref> [1] </ref> have described a more complicated O (n) time and O (N ) space construction algorithm. 4 Evenly Spaced Sparse Suffix Trees An evenly spaced sparse suffix tree contains every kth suffix of the text for some positive integer k. We will also use the term k-spaced suffix tree.
Reference: 2. <author> A. Andersson and S. Nilsson, </author> <title> Improved behaviour of tries by adaptive branching, </title> <journal> Inf. Process. Lett., </journal> <volume> 46 (1993), </volume> <pages> pp. 295-300. </pages> <month> 3. </month> , <title> Efficient implementation of suffix trees, </title> <journal> Software|Practice and Experience, </journal> <volume> 25 (1995), </volume> <pages> pp. 129-141. </pages>
Reference-contexts: The size depends on implementation details and the structure of the text, but will never be as low as 10n bytes, where n is the size of the text. Suffix arrays [11, 6] (size 5n bytes), level-compressed tries <ref> [2, 3] </ref> (size about 11n bytes), suffix cactuses [8] (size 9n bytes), and suffix binary search trees [7] (size about 10n bytes) are alternative smaller data structures with almost the same properties as the suffix tree. Their space requirement is still high for large texts.
Reference: 4. <author> A. Apostolico, </author> <title> The myriad virtues of subword trees, in Combinatorial Algorithms on Words, </title> <editor> A. Apostolico and Z. Galil, eds., </editor> <publisher> Springer-Verlag, </publisher> <year> 1985, </year> <pages> pp. 85-95. </pages>
Reference-contexts: Because of such strong properties, suffix trees are used as essential building blocks in several string matching algorithms <ref> [4] </ref>. Although linear in size, a suffix tree can be too large to be really attractive in practical applications. The size depends on implementation details and the structure of the text, but will never be as low as 10n bytes, where n is the size of the text.
Reference: 5. <author> A. Apostolico and W. Szpankowski, </author> <title> Self-alignments in words and their applications, </title> <journal> Journal of Algorithms, </journal> <volume> 13 (1992), </volume> <pages> pp. 446-467. </pages>
Reference-contexts: The construction works in just O (N ) space for a sparse suffix tree of N suffixes. The construction time is, in the worst case, linear in the total length of the suffixes, which is O (N n). By the results of Apostolico and Szpankowski <ref> [5] </ref>, the expected construction time for random text and randomly selected suffixes is O (n+N log N ).
Reference: 6. <author> G. H. Gonnet, R. A. Baeza-Yates, and T. Snider, </author> <title> Lexicographical indices for text: Inverted files vs. pat trees, </title> <type> Technical Report OED-91-01, </type> <institution> Centre for the New OED, University of Waterloo, </institution> <year> 1991. </year>
Reference-contexts: Although linear in size, a suffix tree can be too large to be really attractive in practical applications. The size depends on implementation details and the structure of the text, but will never be as low as 10n bytes, where n is the size of the text. Suffix arrays <ref> [11, 6] </ref> (size 5n bytes), level-compressed tries [2, 3] (size about 11n bytes), suffix cactuses [8] (size 9n bytes), and suffix binary search trees [7] (size about 10n bytes) are alternative smaller data structures with almost the same properties as the suffix tree. <p> For example, if the text is natural language, one could want to represent only the suffixes that start from the beginning of each word (instead of each character) <ref> [6] </ref>. The idea already appears in [14]. Such an unevenly spaced SST can be constructed either through the full suffix tree, at the cost of extra space, or by brute force construction, at the cost of extra time.
Reference: 7. <author> R. W. Irving, </author> <title> Suffix binary search trees, </title> <type> Technical report TR-1995-7, </type> <institution> Computing Science Department, University of Glasgow, </institution> <month> Apr. </month> <year> 1995. </year>
Reference-contexts: Suffix arrays [11, 6] (size 5n bytes), level-compressed tries [2, 3] (size about 11n bytes), suffix cactuses [8] (size 9n bytes), and suffix binary search trees <ref> [7] </ref> (size about 10n bytes) are alternative smaller data structures with almost the same properties as the suffix tree. Their space requirement is still high for large texts.
Reference: 8. <author> J. K arkk ainen, </author> <title> Suffix cactus: A cross between suffix tree and suffix array, </title> <booktitle> in Proc. 6th Symposium on Combinatorial Pattern Matching, </booktitle> <volume> CPM 95, </volume> <year> 1995, </year> <pages> pp. 191-204. </pages>
Reference-contexts: The size depends on implementation details and the structure of the text, but will never be as low as 10n bytes, where n is the size of the text. Suffix arrays [11, 6] (size 5n bytes), level-compressed tries [2, 3] (size about 11n bytes), suffix cactuses <ref> [8] </ref> (size 9n bytes), and suffix binary search trees [7] (size about 10n bytes) are alternative smaller data structures with almost the same properties as the suffix tree. Their space requirement is still high for large texts.
Reference: 9. <author> D. E. Knuth, J. H. Morris, and V. R. Pratt, </author> <title> Fast pattern matching in strings, </title> <journal> SIAM J. Comput., </journal> <volume> 6 (1977), </volume> <pages> pp. 323-350. </pages>
Reference-contexts: The problem of string matching is to find the occurrences of string P as a substring of T . It can be solved in linear time by scanning text T using, e.g., the Knuth-Morris-Pratt algorithm <ref> [9] </ref>. For a large static text, a faster solution can be achieved by preprocessing the text. A suffix tree of text T is a compacted trie for the suffixes of T . Fig. 1 shows an example of a suffix tree.
Reference: 10. <author> S. R. Kosaraju and A. L. Delcher, </author> <title> Large-scale assembly of DNA strings and space-efficient construction of suffix trees, </title> <booktitle> in Proc. 27th Annual ACM Symposium on Theory of Computing (STOC), </booktitle> <year> 1995, </year> <pages> pp. 169-177. </pages>
Reference-contexts: In this section we will show how to modify the linear time construction algorithm for full suffix trees to work for evenly spaced suffix trees. Essentially the same algorithm was presented in different context in <ref> [10] </ref>. For the construction algorithm we need suffix links. Definition 1. In a k-spaced suffix tree, there is a suffix link from an internal node S to root, if jSj k, and to another internal node S k otherwise.
Reference: 11. <author> U. Manber and G. Myers, </author> <title> Suffix arrays: A new method for on-line string searches, </title> <journal> SIAM J. Comput., </journal> <volume> 22 (1993), </volume> <pages> pp. 935-948. </pages>
Reference-contexts: Although linear in size, a suffix tree can be too large to be really attractive in practical applications. The size depends on implementation details and the structure of the text, but will never be as low as 10n bytes, where n is the size of the text. Suffix arrays <ref> [11, 6] </ref> (size 5n bytes), level-compressed tries [2, 3] (size about 11n bytes), suffix cactuses [8] (size 9n bytes), and suffix binary search trees [7] (size about 10n bytes) are alternative smaller data structures with almost the same properties as the suffix tree.
Reference: 12. <author> U. Manber and S. Wu, </author> <title> A two-level approach to information retrieval, </title> <type> Technical Report TR 93-06, </type> <institution> University of Arizona, </institution> <year> 1993. </year>
Reference-contexts: A totally different, word-oriented approach to the indexing problem is described in <ref> [12] </ref>.
Reference: 13. <author> E. M. McCreight, </author> <title> A space-economical suffix tree construction algorithm, </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 23 (1976), </volume> <pages> pp. 262-272. </pages>
Reference-contexts: Suffix trees offer a theoretically time-optimal solution. A suffix tree is a trie-like data structure that represents all suffixes of a text. It can be constructed in time linear in the length of the text <ref> [16, 13, 15] </ref>. With the help of the suffix tree it is possible to find all occurrences of a given string (`keyword') in the text in time that is linear in the length of the string and in the number of the occurrences. <p> Suffix trees can be constructed in linear time <ref> [16, 13, 15] </ref>. The construction algorithms utilize extra pointers, called the suffix links, between the nodes. <p> We will omit here the details of this quite complicated algorithm and refer to <ref> [13, 15] </ref>. The resulting algorithm constructs a k-spaced SST in O (n) time and O (n=k) space. 5 String Matching Efficient string matching in full suffix trees utilizes the fact that every substring of the text is a prefix of some suffix.
Reference: 14. <author> D. R. Morrison, </author> <title> PATRICIA|Practical Algorithm To Retrieve Information Coded in Alphanumeric, </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 15 (1968), </volume> <pages> pp. 514-534. </pages>
Reference-contexts: For example, if the text is natural language, one could want to represent only the suffixes that start from the beginning of each word (instead of each character) [6]. The idea already appears in <ref> [14] </ref>. Such an unevenly spaced SST can be constructed either through the full suffix tree, at the cost of extra space, or by brute force construction, at the cost of extra time. Recently, Andersson et. al [1] have presented fast construction algorithms working in small space.
Reference: 15. <author> E. Ukkonen, </author> <title> On-line construction of suffix-trees, </title> <journal> Algorithmica, </journal> <volume> 14 (1995), </volume> <pages> pp. 249-260. </pages>
Reference-contexts: Suffix trees offer a theoretically time-optimal solution. A suffix tree is a trie-like data structure that represents all suffixes of a text. It can be constructed in time linear in the length of the text <ref> [16, 13, 15] </ref>. With the help of the suffix tree it is possible to find all occurrences of a given string (`keyword') in the text in time that is linear in the length of the string and in the number of the occurrences. <p> Suffix trees can be constructed in linear time <ref> [16, 13, 15] </ref>. The construction algorithms utilize extra pointers, called the suffix links, between the nodes. <p> We will omit here the details of this quite complicated algorithm and refer to <ref> [13, 15] </ref>. The resulting algorithm constructs a k-spaced SST in O (n) time and O (n=k) space. 5 String Matching Efficient string matching in full suffix trees utilizes the fact that every substring of the text is a prefix of some suffix.
Reference: 16. <author> P. Weiner, </author> <title> Linear pattern matching algorithms, </title> <booktitle> in Proc. IEEE 14th Annual Symposium on Switching and Automata Theory, </booktitle> <year> 1973, </year> <pages> pp. </pages> <month> 1-11. </month> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: Suffix trees offer a theoretically time-optimal solution. A suffix tree is a trie-like data structure that represents all suffixes of a text. It can be constructed in time linear in the length of the text <ref> [16, 13, 15] </ref>. With the help of the suffix tree it is possible to find all occurrences of a given string (`keyword') in the text in time that is linear in the length of the string and in the number of the occurrences. <p> Suffix trees can be constructed in linear time <ref> [16, 13, 15] </ref>. The construction algorithms utilize extra pointers, called the suffix links, between the nodes.
References-found: 15

