URL: ftp://ftp.cs.brown.edu/pub/techreports/95/cs95-12.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-95-12.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> C. Braem, B. Le Charlier, S. Modart, and P. Van Hentenryck. </author> <title> Cardinality Analysis of Prolog. </title> <booktitle> In Proceedings of the International Symposium on Logic Programming (ILPS-94), </booktitle> <pages> pages 457-471, </pages> <address> Ithaca, NY, </address> <month> November </month> <year> 1994. </year>
Reference-contexts: A typical CLP (&lt; lin ) program is the factorial program 1 This was motivated by our previous work on sequences <ref> [12, 1] </ref> which separates properties of the elements of the sequences from properties of the sequence. 2 Note that Marriott and Stuckey use an abstraction function for constraints and an approximation relation for the remaining semantic objects. 2 fact (x 1 ,x 2 ) :- x 1 = 0, x 2
Reference: [2] <author> M. Bruynooghe. </author> <title> A Practical Framework for the Abstract Interpretation of Logic Programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 10(2) </volume> <pages> 91-124, </pages> <month> February </month> <year> 1991. </year>
Reference-contexts: Overview of the Framework Our abstract interpretation is a natural extension to CLP of our logic programming framework [14]. It is thus close to the work of Marriott and Stndergaard [15, 16], Winsborough [23]. Also related are the frameworks of Bruynooghe <ref> [2] </ref> and Hermenegildo [19, 9]. Our framework follows the traditional approach to abstract interpretation [5]. As is traditional in abstract interpretation, the starting point of the analysis is a collecting semantics for the programming language. <p> The algorithm uses memoization, a dependency graph to avoid redundant computation, the abstract operations of the abstract semantics, and the ordering relation on the abstract domain. It has many similarities with PLAI [19] and can be seen either as an implementation of Bruynooghe's framework <ref> [2] </ref> or as an instance of a general fixpoint algorithm [13]. Concrete Objects The concrete objects manipulated by our concrete semantics are linear constraints and multisets of linear constraints. Consider a set of variables D = fx 1 ; : : : ; x n g.
Reference: [3] <author> W. Buttner and H. Simonis. </author> <title> Embedding Boolean Expressions into Logic Programming. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 4 </volume> <pages> 191-205, </pages> <month> October </month> <year> 1987. </year>
Reference-contexts: Many CLP languages have been defined in the last decade on computation domains such linear real constraints (e.g., [11, 22, 4]), integers (e.g., [21]), Booleans (e.g., <ref> [3, 4] </ref>), and nonlinear real constraints (e.g., [20]) to name a few. Recently, more and more attention has been devoted to abstract interpretation of constraint logic programming (e.g., [16, 9]) and of CLP (&lt; lin ), an instance of CLP over linear real constraints, in particular (e.g., [17, 18, 7]).
Reference: [4] <author> A. Colmerauer. </author> <title> An Introduction to Prolog III. </title> <journal> CACM, </journal> <volume> 28(4) </volume> <pages> 412-418, </pages> <year> 1990. </year>
Reference-contexts: 1 Introduction Constraint logic programming (CLP) <ref> [10, 4] </ref> is a generalization of logic programming where unification is replaced by constraint solving over some computation domain. <p> 1 Introduction Constraint logic programming (CLP) [10, 4] is a generalization of logic programming where unification is replaced by constraint solving over some computation domain. Many CLP languages have been defined in the last decade on computation domains such linear real constraints (e.g., <ref> [11, 22, 4] </ref>), integers (e.g., [21]), Booleans (e.g., [3, 4]), and nonlinear real constraints (e.g., [20]) to name a few. <p> Many CLP languages have been defined in the last decade on computation domains such linear real constraints (e.g., [11, 22, 4]), integers (e.g., [21]), Booleans (e.g., <ref> [3, 4] </ref>), and nonlinear real constraints (e.g., [20]) to name a few. Recently, more and more attention has been devoted to abstract interpretation of constraint logic programming (e.g., [16, 9]) and of CLP (&lt; lin ), an instance of CLP over linear real constraints, in particular (e.g., [17, 18, 7]).
Reference: [5] <author> P. Cousot and R. Cousot. </author> <title> Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints. </title> <publisher> In New York ACM Press, </publisher> <editor> editor, </editor> <booktitle> Conf. Record of Fourth ACM Symposium on Programming Languages (POPL'77), </booktitle> <pages> pages 238-252, </pages> <address> Los Angeles, CA, </address> <month> January </month> <year> 1977. </year>
Reference-contexts: It is thus close to the work of Marriott and Stndergaard [15, 16], Winsborough [23]. Also related are the frameworks of Bruynooghe [2] and Hermenegildo [19, 9]. Our framework follows the traditional approach to abstract interpretation <ref> [5] </ref>. As is traditional in abstract interpretation, the starting point of the analysis is a collecting semantics for the programming language. Our concrete semantics is a collecting fixpoint semantics which captures the top-down execution of constraint logic programs using a left-to-right computation rule and which ignores the clause selection rule.
Reference: [6] <author> P. Cousot and N. Halbwachs. </author> <title> Automatic Discovery of Linear Restraints Among Variables of a Program. </title> <booktitle> In Conf. Record of Fifth ACM Symposium on Principles of Programming Languages (POPL'78), </booktitle> <year> 1978. </year>
Reference-contexts: Marriott and Stuckey [17] have shown that determining when reordering can be performed reduces to checking if a constraint store is always satisfiable. A variety of abstract domains can be used for this task, including the abstract domain of Cousot and Halbwachs <ref> [6] </ref> and the LSign domain of Marriott and Stuckey [18]. LSign is a new and elegant domain whose key conceptual ideas are the abstraction of linear constraints by replacing coefficients by their signs and the use of annotations for preserving multiplicity information on the constraints.
Reference: [7] <author> V. Dumortier and G. Janssens. </author> <title> Towards a Practical Full Mode Inference System for CLP(H,N). </title> <booktitle> In Eleventh International Conference on Logic Programming (ICLP-94), </booktitle> <address> Santa Marguerita Ligure, Italy, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: Recently, more and more attention has been devoted to abstract interpretation of constraint logic programming (e.g., [16, 9]) and of CLP (&lt; lin ), an instance of CLP over linear real constraints, in particular (e.g., <ref> [17, 18, 7] </ref>). This interest is motivated by the large potential for optimization in CLP (&lt; lin ) programs using techniques such as refinements, reordering, and removal of constraints [17]. Reordering constraints is a particularly interesting avenue since it enables other optimizations to be applied more effectively.
Reference: [8] <author> M.L. Fredman and R.E. Tarjan. </author> <title> Fibonacci Heaps and Their Uses in Improved Network Optimization Algorithms. </title> <journal> JACM, </journal> <volume> 34 </volume> <pages> 596-615, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: Theorem 28 Let fi 1 and fi 2 be two abstract stores. The complexity of checking if fi 1 v fi 2 is not more than O (jfi 1 j 2 2 log jfi 1 jjfi 2 j). Proof This follows from <ref> [8] </ref> which proved that the weighted bipartite matching problem can be solved in time O (jV j 2 log jV j+jV jjEj) i.e O (jfi 1 j 2 jfi 2 j 2 log jfi 1 jjfi 2 j) and the definition of the matching graph. 2 9 4.2 Addition We now
Reference: [9] <author> M. Garcia de la Banda and M. Hermenegildo. </author> <title> A Practical Approach to the Global Analysis of CLP Programs. </title> <booktitle> In Proc. of the International Symposium on Logic Programming (ILPS'93), </booktitle> <address> Vancouver, Canada, </address> <month> November </month> <year> 1993. </year>
Reference-contexts: Recently, more and more attention has been devoted to abstract interpretation of constraint logic programming (e.g., <ref> [16, 9] </ref>) and of CLP (&lt; lin ), an instance of CLP over linear real constraints, in particular (e.g., [17, 18, 7]). This interest is motivated by the large potential for optimization in CLP (&lt; lin ) programs using techniques such as refinements, reordering, and removal of constraints [17]. <p> Overview of the Framework Our abstract interpretation is a natural extension to CLP of our logic programming framework [14]. It is thus close to the work of Marriott and Stndergaard [15, 16], Winsborough [23]. Also related are the frameworks of Bruynooghe [2] and Hermenegildo <ref> [19, 9] </ref>. Our framework follows the traditional approach to abstract interpretation [5]. As is traditional in abstract interpretation, the starting point of the analysis is a collecting semantics for the programming language.
Reference: [10] <author> J. Jaffar and J-L. Lassez. </author> <title> Constraint Logic Programming. </title> <booktitle> In POPL-87, </booktitle> <address> Munich, FRG, </address> <month> January </month> <year> 1987. </year>
Reference-contexts: 1 Introduction Constraint logic programming (CLP) <ref> [10, 4] </ref> is a generalization of logic programming where unification is replaced by constraint solving over some computation domain.
Reference: [11] <author> J. Jaffar, S. Michaylov, P.J. Stuckey, and R. Yap. </author> <title> The CLP(&lt;) Language and System. </title> <journal> ACM Transactions on Programming Languages, </journal> <volume> 14(3) </volume> <pages> 339-395, </pages> <year> 1992. </year>
Reference-contexts: 1 Introduction Constraint logic programming (CLP) [10, 4] is a generalization of logic programming where unification is replaced by constraint solving over some computation domain. Many CLP languages have been defined in the last decade on computation domains such linear real constraints (e.g., <ref> [11, 22, 4] </ref>), integers (e.g., [21]), Booleans (e.g., [3, 4]), and nonlinear real constraints (e.g., [20]) to name a few.
Reference: [12] <author> B. Le Charlier, S. Rossi, and P. Van Hentenryck. </author> <title> An Abstract Interpretation Framework Which Accurately Handles Prolog Search Rule and the Cut. </title> <booktitle> In Proceedings of the International Symposium on Logic Programming (ILPS-94), </booktitle> <pages> pages 157-171, </pages> <address> Ithaca, NY, </address> <month> November </month> <year> 1994. </year>
Reference-contexts: A typical CLP (&lt; lin ) program is the factorial program 1 This was motivated by our previous work on sequences <ref> [12, 1] </ref> which separates properties of the elements of the sequences from properties of the sequence. 2 Note that Marriott and Stuckey use an abstraction function for constraints and an approximation relation for the remaining semantic objects. 2 fact (x 1 ,x 2 ) :- x 1 = 0, x 2
Reference: [13] <author> B. Le Charlier and P. Van Hentenryck. </author> <title> A Universal Top-Down Fixpoint Algorithm. </title> <type> Technical Report CS-92-25, </type> <institution> CS Department, Brown University, </institution> <year> 1992. </year>
Reference-contexts: It has many similarities with PLAI [19] and can be seen either as an implementation of Bruynooghe's framework [2] or as an instance of a general fixpoint algorithm <ref> [13] </ref>. Concrete Objects The concrete objects manipulated by our concrete semantics are linear constraints and multisets of linear constraints. Consider a set of variables D = fx 1 ; : : : ; x n g.
Reference: [14] <author> B. Le Charlier and P. Van Hentenryck. </author> <title> Experimental Evaluation of a Generic Abstract Interpretation Algorithm for Prolog. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(1) </volume> <pages> 35-101, </pages> <month> January 94. 16 </month>
Reference-contexts: Overview of the Framework Our abstract interpretation is a natural extension to CLP of our logic programming framework <ref> [14] </ref>. It is thus close to the work of Marriott and Stndergaard [15, 16], Winsborough [23]. Also related are the frameworks of Bruynooghe [2] and Hermenegildo [19, 9]. Our framework follows the traditional approach to abstract interpretation [5]. <p> The upper bound operation is a consistent abstraction of union of sets of constraint stores. The monotonicity of the concretization function and the consistency of the abstract operations guarantee that any post-fixpoint of the abstract transformation is an approximation of the least fixpoint of the concrete transformation (see <ref> [14] </ref> for the details). The last step of the methodology consists in computing the least fixpoint or a postfixpoint of the abstract semantics. GAIA [14] is a top-down algorithm computing a small, but sufficient, subset of least fixpoint (or of a postfixpoint) necessary to answer a user query. <p> the consistency of the abstract operations guarantee that any post-fixpoint of the abstract transformation is an approximation of the least fixpoint of the concrete transformation (see <ref> [14] </ref> for the details). The last step of the methodology consists in computing the least fixpoint or a postfixpoint of the abstract semantics. GAIA [14] is a top-down algorithm computing a small, but sufficient, subset of least fixpoint (or of a postfixpoint) necessary to answer a user query. The algorithm uses memoization, a dependency graph to avoid redundant computation, the abstract operations of the abstract semantics, and the ordering relation on the abstract domain.
Reference: [15] <author> K. Marriott and H. Sondergaard. </author> <title> Notes for a Tutorial on Abstract Interpretation of Logic Programs. </title> <booktitle> North American Conference on Logic Programming, </booktitle> <address> Cleveland, Ohio, </address> <month> October </month> <year> 1989. </year>
Reference-contexts: Overview of the Framework Our abstract interpretation is a natural extension to CLP of our logic programming framework [14]. It is thus close to the work of Marriott and Stndergaard <ref> [15, 16] </ref>, Winsborough [23]. Also related are the frameworks of Bruynooghe [2] and Hermenegildo [19, 9]. Our framework follows the traditional approach to abstract interpretation [5]. As is traditional in abstract interpretation, the starting point of the analysis is a collecting semantics for the programming language.
Reference: [16] <author> K. Marriott and H. Sondergaard. </author> <title> Analysis of Constraint Logic Programs. </title> <booktitle> In Proceedings of the North American Conference on Logic Programming (NACLP-90), </booktitle> <address> Austin, TX, </address> <month> October </month> <year> 1990. </year>
Reference-contexts: Recently, more and more attention has been devoted to abstract interpretation of constraint logic programming (e.g., <ref> [16, 9] </ref>) and of CLP (&lt; lin ), an instance of CLP over linear real constraints, in particular (e.g., [17, 18, 7]). This interest is motivated by the large potential for optimization in CLP (&lt; lin ) programs using techniques such as refinements, reordering, and removal of constraints [17]. <p> Overview of the Framework Our abstract interpretation is a natural extension to CLP of our logic programming framework [14]. It is thus close to the work of Marriott and Stndergaard <ref> [15, 16] </ref>, Winsborough [23]. Also related are the frameworks of Bruynooghe [2] and Hermenegildo [19, 9]. Our framework follows the traditional approach to abstract interpretation [5]. As is traditional in abstract interpretation, the starting point of the analysis is a collecting semantics for the programming language.
Reference: [17] <author> K. Marriott and P. Stuckey. </author> <title> The 3 R's of optimizing Constraint Logic Programs: Refinement, Removal, and Reordering. </title> <booktitle> In Proc. of the 20th ACM Symposium on Principles of Programming Languages (POPL'93), </booktitle> <address> Charleston, South Carolina, </address> <month> January </month> <year> 1993. </year>
Reference-contexts: Recently, more and more attention has been devoted to abstract interpretation of constraint logic programming (e.g., [16, 9]) and of CLP (&lt; lin ), an instance of CLP over linear real constraints, in particular (e.g., <ref> [17, 18, 7] </ref>). This interest is motivated by the large potential for optimization in CLP (&lt; lin ) programs using techniques such as refinements, reordering, and removal of constraints [17]. Reordering constraints is a particularly interesting avenue since it enables other optimizations to be applied more effectively. <p> This interest is motivated by the large potential for optimization in CLP (&lt; lin ) programs using techniques such as refinements, reordering, and removal of constraints <ref> [17] </ref>. Reordering constraints is a particularly interesting avenue since it enables other optimizations to be applied more effectively. Marriott and Stuckey [17] have shown that determining when reordering can be performed reduces to checking if a constraint store is always satisfiable. <p> This interest is motivated by the large potential for optimization in CLP (&lt; lin ) programs using techniques such as refinements, reordering, and removal of constraints <ref> [17] </ref>. Reordering constraints is a particularly interesting avenue since it enables other optimizations to be applied more effectively. Marriott and Stuckey [17] have shown that determining when reordering can be performed reduces to checking if a constraint store is always satisfiable. A variety of abstract domains can be used for this task, including the abstract domain of Cousot and Halbwachs [6] and the LSign domain of Marriott and Stuckey [18].
Reference: [18] <author> K. Marriott and P. Stuckey. </author> <title> Approximating Interaction Between Linear Arithmetic Constraints. </title> <booktitle> In Proc. of the International Symposium on Logic Programming (ILPS'94), </booktitle> <address> Ithaca, NY, </address> <month> November </month> <year> 1994. </year>
Reference-contexts: Recently, more and more attention has been devoted to abstract interpretation of constraint logic programming (e.g., [16, 9]) and of CLP (&lt; lin ), an instance of CLP over linear real constraints, in particular (e.g., <ref> [17, 18, 7] </ref>). This interest is motivated by the large potential for optimization in CLP (&lt; lin ) programs using techniques such as refinements, reordering, and removal of constraints [17]. Reordering constraints is a particularly interesting avenue since it enables other optimizations to be applied more effectively. <p> A variety of abstract domains can be used for this task, including the abstract domain of Cousot and Halbwachs [6] and the LSign domain of Marriott and Stuckey <ref> [18] </ref>. LSign is a new and elegant domain whose key conceptual ideas are the abstraction of linear constraints by replacing coefficients by their signs and the use of annotations for preserving multiplicity information on the constraints. <p> This allows the projection operation to be approximated by abstract versions of Fourier and Gauss elimination. Unfortunately, the ordering given in <ref> [18] </ref>, i.e., fi 1 v fi 2 , 8fl 1 2 fi 1 9fl 2 2 fi 2 fl 1 v fl 2 does not capture the intended meaning, since it would conclude that the set fi 1 = f = x 1 + x 2 ; = x 1 + <p> The intended meaning of <ref> [18] </ref> is that fi 1 represents exactly two constraints while fi 2 represents exactly one constraint. Hence fi 2 is always satisfiable, while fi 1 may not be. We observed this problem when trying to define an upper bound operation for LSign which was not given in [18]. <p> intended meaning of <ref> [18] </ref> is that fi 1 represents exactly two constraints while fi 2 represents exactly one constraint. Hence fi 2 is always satisfiable, while fi 1 may not be. We observed this problem when trying to define an upper bound operation for LSign which was not given in [18]. <p> It is important to stress that our goal in this paper is not to improve the LSign domain but rather to show how the results of <ref> [18] </ref> can be corrected and completed, since they seem to be particularly appropriate for optimizing compilers of CLP (&lt; lin ). The rest of this paper is organized in the following way. Section 2 gives the background for this paper. <p> Section 4 contains the implementation of the abstract operations (i.e., ordering, addition of a constraint, upper bound, projection) and their consistency proofs. Section 5 contains the conclusion of the paper. 2 Preliminaries CLP (&lt; lin ) Programs As in <ref> [18] </ref>, we consider the analysis of CLP programs containing only constraints in &lt; lin (i.e. no functor symbol). <p> Although the presentation differs considerably from <ref> [18] </ref>, the domain is in fact a slight generalization of the original domain. The new presentation is motivated by the fact that it makes it easy to define the concretization function compositionally by identifying the semantic objects clearly. In contrast, [18] uses an approach based on an abstraction function and approximation <p> Although the presentation differs considerably from <ref> [18] </ref>, the domain is in fact a slight generalization of the original domain. The new presentation is motivated by the fact that it makes it easy to define the concretization function compositionally by identifying the semantic objects clearly. In contrast, [18] uses an approach based on an abstraction function and approximation relations. The first key idea is the notion of an abstract constraint which abstracts a concrete constraint by replacing each coefficient by its sign. Our definitions assume D = fx 1 ; : : : ; x n g. <p> concretization function Cc : AS D ! CS D is defined as Cc (;) = f;g Cc (fflg [ fi) = f 1 [ 2 j 1 2 Cc (fl) ^ 2 2 Cc (fi) g fl 62 fi: Abstract stores are denoted by the letter fi, possibly subscripted. 3 <ref> [18] </ref> contains one other multiplicity OneOrMore which is obtained easily in our domain by including one constraint with multiplicity One and one constraint with multiplicity Any. Note also that all inequalities are defined with a multiplicity Any in [18]. 5 The additional condition in the above definition is a simple subsumption <p> fi: Abstract stores are denoted by the letter fi, possibly subscripted. 3 <ref> [18] </ref> contains one other multiplicity OneOrMore which is obtained easily in our domain by including one constraint with multiplicity One and one constraint with multiplicity Any. Note also that all inequalities are defined with a multiplicity Any in [18]. 5 The additional condition in the above definition is a simple subsumption condition stating that a constraint with multiplicity ZeroOrOne is not subsumed by a constraint with multiplicity Any and that a constraint with multiplicity Any is not subsumed by another constraint with multiplicity Any. <p> Figure 1 describes a simple projection algorithm based on the traditional Gaussian and Fourier eliminations which are standard in this area. Figure 2 presents the abstract algorithm. The algorithms are close to those in <ref> [18] </ref> but they are simplified thanks to the introduction of operations Csplit and Asplit which avoids much of the tedious case analysis. Fourier elimination is also more precise. The intuition behind the concrete version is as follows. Cproject nondeterministically chooses a constraint in the store. <p> The main difference comes from the fact that we avoid combining a constraint with multiplicity One or ZeroOrOne with itself, contrary to the algorithm in <ref> [18] </ref>. This is achieved by testing the multiplicity of the constraint. Lemma 42 [Fourier] Let v 2 N , be a store, and fi be an abstract store. <p> [Project] Let v 2 N , be a store and fi be an abstract store. 2 Cc (fi) ) there exists 0 such that 0 $ Cproject (; v) ^ 0 2 Cc (Aproject (fi; v)): Proof See Appendix A. 2 5 Conclusion This paper reconsidered the LSign domain of <ref> [18] </ref> and was motivated by the fact that the ordering relation given in [18] does not capture the intended meaning. <p> abstract store. 2 Cc (fi) ) there exists 0 such that 0 $ Cproject (; v) ^ 0 2 Cc (Aproject (fi; v)): Proof See Appendix A. 2 5 Conclusion This paper reconsidered the LSign domain of <ref> [18] </ref> and was motivated by the fact that the ordering relation given in [18] does not capture the intended meaning. Our first contribution was to define a new ordering on LSign, whose meaning is now defined by a monotone concretization function from abstract constraint stores to sets of constraint stores (which are multisets of constraints). <p> Our first contribution was to define a new ordering on LSign, whose meaning is now defined by a monotone concretization function from abstract constraint stores to sets of constraint stores (which are multisets of constraints). The ordering and the concretization function capture the intended meaning of <ref> [18] </ref>. Our second contribution is to show that ordering in LSign reduces to a polynomial matching problem. Our third contribution is to define implementations of the abstract operations, i.e. abstract addition of a constraint, abstract projection and a schema to generate upper bound operations, and to prove their consistency.
Reference: [19] <author> K. Muthukumar and M. Hermenegildo. </author> <title> Compile-Time Derivation of Variable Dependency Using Abstract Interpretation. </title> <journal> Journal of Logic Programming, </journal> <volume> 13(2-3):315-347, </volume> <month> August </month> <year> 1992. </year>
Reference-contexts: Overview of the Framework Our abstract interpretation is a natural extension to CLP of our logic programming framework [14]. It is thus close to the work of Marriott and Stndergaard [15, 16], Winsborough [23]. Also related are the frameworks of Bruynooghe [2] and Hermenegildo <ref> [19, 9] </ref>. Our framework follows the traditional approach to abstract interpretation [5]. As is traditional in abstract interpretation, the starting point of the analysis is a collecting semantics for the programming language. <p> The algorithm uses memoization, a dependency graph to avoid redundant computation, the abstract operations of the abstract semantics, and the ordering relation on the abstract domain. It has many similarities with PLAI <ref> [19] </ref> and can be seen either as an implementation of Bruynooghe's framework [2] or as an instance of a general fixpoint algorithm [13]. Concrete Objects The concrete objects manipulated by our concrete semantics are linear constraints and multisets of linear constraints.
Reference: [20] <author> W. Older and A. Vellino. </author> <title> Extending Prolog with Constraint Arithmetics on Real Intervals. </title> <booktitle> In Canadian Conference on Computer & Electrical Engineering, </booktitle> <address> Ottawa, </address> <year> 1990. </year>
Reference-contexts: Many CLP languages have been defined in the last decade on computation domains such linear real constraints (e.g., [11, 22, 4]), integers (e.g., [21]), Booleans (e.g., [3, 4]), and nonlinear real constraints (e.g., <ref> [20] </ref>) to name a few. Recently, more and more attention has been devoted to abstract interpretation of constraint logic programming (e.g., [16, 9]) and of CLP (&lt; lin ), an instance of CLP over linear real constraints, in particular (e.g., [17, 18, 7]).
Reference: [21] <author> P. Van Hentenryck. </author> <title> Constraint Satisfaction in Logic Programming. Logic Programming Series, </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1989. </year>
Reference-contexts: 1 Introduction Constraint logic programming (CLP) [10, 4] is a generalization of logic programming where unification is replaced by constraint solving over some computation domain. Many CLP languages have been defined in the last decade on computation domains such linear real constraints (e.g., [11, 22, 4]), integers (e.g., <ref> [21] </ref>), Booleans (e.g., [3, 4]), and nonlinear real constraints (e.g., [20]) to name a few.
Reference: [22] <author> P. Van Hentenryck and T. Graf. </author> <title> Standard Forms for Rational Linear Arithmetics in Constraint Logic Programming. </title> <journal> Annals of Mathematics and Artificial Intelligence, </journal> <volume> 5(2-4):303-320, </volume> <year> 1992. </year>
Reference-contexts: 1 Introduction Constraint logic programming (CLP) [10, 4] is a generalization of logic programming where unification is replaced by constraint solving over some computation domain. Many CLP languages have been defined in the last decade on computation domains such linear real constraints (e.g., <ref> [11, 22, 4] </ref>), integers (e.g., [21]), Booleans (e.g., [3, 4]), and nonlinear real constraints (e.g., [20]) to name a few.
Reference: [23] <author> W. Winsborough. </author> <title> Multiple Specialization using Minimal-Function Graph Semantics. </title> <journal> Journal of Logic Programming, </journal> <volume> 13(4), </volume> <month> July </month> <year> 1992. </year> <month> 17 </month>
Reference-contexts: Overview of the Framework Our abstract interpretation is a natural extension to CLP of our logic programming framework [14]. It is thus close to the work of Marriott and Stndergaard [15, 16], Winsborough <ref> [23] </ref>. Also related are the frameworks of Bruynooghe [2] and Hermenegildo [19, 9]. Our framework follows the traditional approach to abstract interpretation [5]. As is traditional in abstract interpretation, the starting point of the analysis is a collecting semantics for the programming language.
References-found: 23

