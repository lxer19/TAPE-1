URL: http://www.uni-paderborn.de/fachbereich/AG/agmadh/Scripts/GENERAL/dyn-survey.ps.gz
Refering-URL: http://www.uni-paderborn.de/fachbereich/AG/agmadh/WWW/english/scripts.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Dynamic Graph Algorithms  
Author: David Eppstein Zvi Galil Giuseppe F. Italiano 
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> D. Alberts, G. Cattaneo, and G. F. </author> <title> Italiano. An empirical study of dynamic graph algorithms. </title> <booktitle> In Proc. 7th ACM-SIAM Symp. Discrete Algorithms, </booktitle> <pages> pages 192-201, </pages> <year> 1996. </year>
Reference-contexts: We refer the interested reader to [27] for the details. 6 Research Issues and Summary In this chapter we have described the most efficient known algorithms for maintaining dynamic graphs. Experimental comparison of some of the dynamic connectivity algorithms has recently been performed by Alberts et al. <ref> [1] </ref>, who showed that in the average case for sufficiently random inputs, a simple sparsification tree based on edge subdivision performs as well as the vertex subdivision method we described in Theorem 6.
Reference: [2] <author> G. Ausiello, G. F. Italiano, A. Marchetti Spaccamela, and U. Nanni. </author> <title> Incremental algorithms for minimal length paths. </title> <journal> J. Algorithms, </journal> <volume> 12 </volume> <pages> 615-638, </pages> <year> 1991. </year> <month> 35 </month>
Reference-contexts: Supported in part by the ESPRIT LTR Project no. 20244 (ALCOM-IT) and by a Research Grant from University of Venice "Ca' Foscari". 1 Most of the efficient data structures available for directed graphs are partially dynamic <ref> [2, 13, 29, 30, 31, 37, 39, 43, 53] </ref>, and only preliminary results are available for fully dynamic problems [25]. For this reason, an alternative viewpoint that has been proposed is to measure the complexity of a dynamic algorithm as a function of the output change [17, 40].
Reference: [3] <author> J. Cheriyan, M. Y. Kao, and R. Thurimella. </author> <title> Scan-first search and sparse certificates|an improved parallel algorithm for k-vertex connectivity. </title> <journal> SIAM J. Comput., </journal> <volume> 22 </volume> <pages> 157-174, </pages> <year> 1993. </year>
Reference-contexts: The technique is based on the concept of a certificate: Definition 1 For any graph property P, and graph G, a certificate for G is a graph G 0 such that G has property P if and only if G 0 has the property. Cheriyan et al. <ref> [3] </ref> use a similar concept, however they require G 0 to be a subgraph of G. We do not need this restriction. However, this allows trivial certificates: G 0 could be chosen from two graphs of constant complexity, one with property P and one without it.
Reference: [4] <author> F. Chin and D. Houk. </author> <title> Algorithms for updating minimum spanning trees. </title> <journal> J. Comp. Syst. Sci., </journal> <volume> 16 </volume> <pages> 333-344, </pages> <year> 1978. </year>
Reference-contexts: These edges are moved to level (i + 1) and the same procedure is applied recursively on level (i + 1). One particular dynamic graph problem that has been thoroughly investigated is the maintenance of a minimum spanning forest <ref> [4, 10, 14, 45] </ref>. This is an important problem on its own, but it has also impact on other problems as well.
Reference: [5] <author> R. F. Cohen and R. Tamassia. </author> <title> Dynamic expression trees and their applications. </title> <booktitle> In Proc. 2nd ACM-SIAM Symp. Discrete Algorithms, </booktitle> <pages> pages 52-61, </pages> <year> 1991. </year>
Reference-contexts: We only mention that some extensions of the dynamic trees of Sleator and Tarjan are the edge-ordered dynamic trees [12], designed to handle compressions and expansions of edges efficiently, and the dynamic expression trees <ref> [5] </ref>. Rather than the dynamic trees of Sleator and Tarjan, we describe in more detail the topology trees of Frederickson.
Reference: [6] <author> G. Di Battista and R. Tamassia. </author> <title> Incremental planarity testing. </title> <booktitle> In Proc. 30th IEEE Symp. Foundations of Computer Science, </booktitle> <pages> pages 436-441, </pages> <year> 1989. </year>
Reference: [7] <author> G. Di Battista and R. Tamassia. </author> <title> On-line graph algorithms with SPQR-trees. </title> <booktitle> In Proc. 17th Int. Colloquium on Automata, Languages and Programming, </booktitle> <pages> pages 598-611. </pages> <booktitle> Lecture Notes in Computer Science 443, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1990. </year>
Reference-contexts: total number of parent and union steps is O (n), giving a total of O (q) finds and O (n) unions in the set union data structure. 2 To complete this section, we mention that all the incremental algorithms proposed in the literature for edge and vertex connectivity (see e.g. <ref> [7, 8, 20, 33, 35, 36, 38, 52] </ref>) follow the approach outlined here for 2-edge connectivity. Namely, connectivity queries are answered by maintaining a tree that reflects the structure of the connectivity cuts of the graph.
Reference: [8] <author> E. A. Dinitz. </author> <title> Maintaining the 4-edge-connected components of a graph on-line. </title> <booktitle> In Proc. 2nd Israel Symp. Theory of Computing and Systems, </booktitle> <pages> pages 88-99, </pages> <year> 1993. </year>
Reference-contexts: total number of parent and union steps is O (n), giving a total of O (q) finds and O (n) unions in the set union data structure. 2 To complete this section, we mention that all the incremental algorithms proposed in the literature for edge and vertex connectivity (see e.g. <ref> [7, 8, 20, 33, 35, 36, 38, 52] </ref>) follow the approach outlined here for 2-edge connectivity. Namely, connectivity queries are answered by maintaining a tree that reflects the structure of the connectivity cuts of the graph.
Reference: [9] <author> D. Eppstein. </author> <title> Clustering for faster network simplex pivots. </title> <booktitle> In Proc. 5th ACM-SIAM Symp. Discrete Algorithms, </booktitle> <pages> pages 160-166, </pages> <year> 1994. </year>
Reference-contexts: Along with their applications to dynamic graph algorithms, topology trees can be used in situations in which a dynamic tree is part of a static graph; for instance, topology trees can be used to speed up the execution of pivots in the network simplex algorithm for minimum cost circulations <ref> [9] </ref>. Before defining clustering and topology trees, we describe a standard graph transformation that we use throughout.
Reference: [10] <author> D. Eppstein, Z. Galil, G. F. Italiano, and A. Nissenzweig. </author> <title> Sparsification A technique for speeding up dynamic graph algorithms. Revised manuscript, </title> <booktitle> 1996. See also Proc. 33rd IEEE Symp. Foundations of Computer Science, </booktitle> <pages> pages 60-69, </pages> <year> 1992. </year>
Reference-contexts: A refinement of the clustering technique appears in the idea of ambivalent data structures [15], in which edges can belong to multiple groups, only one of which is actually selected depending on the topology of the given spanning tree. Another technique we describe is sparsification by Eppstein et al. <ref> [10] </ref>. This is a divide-and-conquer technique that can be used to reduce the dependence on the number of edges in a graph, so that the time bounds for maintaining some property of the graph match the times for computing in sparse graphs. Roughly speaking, sparsification works as follows. <p> These edges are moved to level (i + 1) and the same procedure is applied recursively on level (i + 1). One particular dynamic graph problem that has been thoroughly investigated is the maintenance of a minimum spanning forest <ref> [4, 10, 14, 45] </ref>. This is an important problem on its own, but it has also impact on other problems as well. <p> This is an important problem on its own, but it has also impact on other problems as well. Indeed the data structures and techniques developed for dynamic minimum spanning forests have found applications also in other areas, such as dynamic edge and vertex connectivity <ref> [10, 15, 19, 26, 41, 42] </ref>. Thus, we will focus our attention to the fully dynamic maintenance of minimum spanning trees. 5.1 Clustering and Topology Trees Let G = (V; E) be a graph, with a designated spanning tree S. <p> In this section we describe a general technique for designing dynamic graph algorithms, due to Eppstein et al. <ref> [10] </ref>, which is called sparsification. This technique can be used to speed up many fully dynamic graph algorithms. <p> All polynomials are well-behaved. Polylogarithms and other slowly growing functions are not well behaved, but since sparsification typically causes little improvement for such functions we will in general assume all time bounds to be well behaved. Theorem 6 (Eppstein et al. <ref> [10] </ref>) Let P be a property for which we can find sparse certificates in time f (n; m) for some well-behaved f , and such that we can construct a data structure for testing property P in time g (n; m) which can answer queries in time q (n; m). <p> Informally, we refer to a certificate as stable if it is the certificate produced by a stable mapping. The certificate consisting of the whole graph is stable, but not sparse. Theorem 7 (Eppstein et al. <ref> [10] </ref>) Let P be a property for which stable sparse certificates can be maintained in time f (n; m) per update, where f is well behaved, and for which there is a data structure for property P with update time g (n; m) and query time q (n; m). <p> We next describe the O (n 1=2 ) algorithm for the fully dynamic maintenance of a minimum spanning forest given by Eppstein et al. <ref> [10] </ref> based on sparsification. A minimum spanning forest is not a graph property, since it is a subgraph rather than a Boolean function. However sparsification still applies to this problem. Alternately, sparsification maintains any property defined on the minimum spanning trees of graphs. <p> We improve this bound by combining Frederickson's algorithm with sparsification: we apply the stable sparsification technique of Theorem 7, with f (n; m) = g (n; m) = O (m 1=2 ) by Theorem 5. Theorem 8 (Eppstein et al. <ref> [10] </ref>) The minimum spanning forest of an undirected graph can be maintained in time O (n 1=2 ) per update. The dynamic spanning tree algorithms described so far produce fully dynamic connectivity algorithms with the same time bounds. <p> forest algorithm, and provides efficient algorithms: 2-edge connectivity can be solved in O (n 1=2 ) time per update, 3-edge connectivity can be solved in O (n 2=3 ) time per update, and for any higher k, k-edge connectivity can be solved in O (n log n) time per update <ref> [10] </ref>. <p> Vertex connectivity is not so easy: for 2 k 4, there are algorithms with times ranging from O (n 1=2 log 2 n) to O (nff (n)) per update <ref> [10, 26, 42] </ref>. 5.3 Randomized Algorithms All the previous techniques yield efficient deterministic algorithms, whose best running times are O (n 1=2 ). Recently, Henzinger and King [24] proposed a new approach that, exploiting the power of randomization, is able to achieve faster update times for some problems.
Reference: [11] <author> D. Eppstein, Z. Galil, G. F. Italiano, and T. H. Spencer. </author> <title> Separator based sparsification for dynamic planar graph algorithms. </title> <booktitle> In Proc. 25th ACM Symp. Theory of Computing, </booktitle> <pages> pages 208-217, </pages> <year> 1993. </year>
Reference: [12] <author> D. Eppstein, G. F. Italiano, R. Tamassia, R. E. Tarjan, J. Westbrook, and M. Yung. </author> <title> Maintenance of a minimum spanning forest in a dynamic plane graph. </title> <journal> J. Algorithms, </journal> <volume> 13 </volume> <pages> 33-54, </pages> <year> 1992. </year>
Reference-contexts: We do not give the details of the method here, and refer the interested reader to reference [44]. We only mention that some extensions of the dynamic trees of Sleator and Tarjan are the edge-ordered dynamic trees <ref> [12] </ref>, designed to handle compressions and expansions of edges efficiently, and the dynamic expression trees [5]. Rather than the dynamic trees of Sleator and Tarjan, we describe in more detail the topology trees of Frederickson.
Reference: [13] <author> S. Even and H. Gazit. </author> <title> Updating distances in dynamic graphs. </title> <journal> Methods of Operations Research, </journal> <volume> 49 </volume> <pages> 371-387, </pages> <year> 1985. </year>
Reference-contexts: Supported in part by the ESPRIT LTR Project no. 20244 (ALCOM-IT) and by a Research Grant from University of Venice "Ca' Foscari". 1 Most of the efficient data structures available for directed graphs are partially dynamic <ref> [2, 13, 29, 30, 31, 37, 39, 43, 53] </ref>, and only preliminary results are available for fully dynamic problems [25]. For this reason, an alternative viewpoint that has been proposed is to measure the complexity of a dynamic algorithm as a function of the output change [17, 40].
Reference: [14] <author> G. N. Frederickson. </author> <title> Data structures for on-line updating of minimum spanning trees. </title> <journal> SIAM J. Comput., </journal> <volume> 14 </volume> <pages> 781-798, </pages> <year> 1985. </year>
Reference-contexts: There are two fully dynamic data structures for this problem: the dynamic trees of Sleator and Tarjan [44], and the topology trees of Frederickson <ref> [14] </ref>. Both data structures follow the common idea of partitioning a tree into a set of vertex-disjoint paths. However, they are very different in how this partition is chosen, and in the data structures they use to represent the paths inside the partition. <p> Indeed, Sleator and Tarjan [44] use a simple partition of the trees based upon a careful choice of sophisticated data structures to represent paths. On the contrary, Frederickson <ref> [14] </ref> uses a more sophisticated partition that is based upon the topology of the tree; this implies more complicated algorithms but simpler data structures for representing paths. <p> This is handled by rebuilding portions of the topology tree in a bottom-up fashion, and involves a constant amount of work to be done on at most O (log n) topology tree nodes. Lemma 2 (Frederickson <ref> [14] </ref>) The update of a topology tree because of an edge insertion or deletion can be supported in time O (log n). 7 4 Partially Dynamic Problems on Undirected Graphs For undirected graphs, most of the partially dynamic problems considered are incremental, namely they support edge insertions only. <p> All of these techniques use some form of graph decomposition, and partition either the vertices or the edges of the graph to be maintained. The first technique we present is the clustering technique of Frederickson <ref> [14] </ref>, which is based upon partitioning the graph into a suitable collection of connected subgraphs called clusters, such that each update involves only a small number of such clusters. <p> These edges are moved to level (i + 1) and the same procedure is applied recursively on level (i + 1). One particular dynamic graph problem that has been thoroughly investigated is the maintenance of a minimum spanning forest <ref> [4, 10, 14, 45] </ref>. This is an important problem on its own, but it has also impact on other problems as well. <p> When the partition can be applied recursively, better O (m 1=2 ) time bounds can be achieved with the help of topology trees (see for instance <ref> [14, 15] </ref>). <p> Finally, the restricted multi-level partition has the nice property of having only logarithmic depth. Indeed Frederickson [15] shows that each level of the topology tree has a number of nodes which is a constant fraction of the previous level, from which the following lemma follows. Lemma 5 (Frederickson <ref> [14, 15] </ref>) The number of levels in a restricted multi-level partition is fi (log n). The topology tree is a hierarchical representation of G based on T . Each level of the topology tree partitions the vertices of G into connected subsets called clusters. <p> This is handled by rebuilding portions of the topology tree in a bottom-up fashion, and involves a constant amount of work to be done on at most O (log n) topology tree nodes. This yields the following lemma. Lemma 6 (Frederickson <ref> [14, 15] </ref>) The update of a topology tree because of an edge swap can be supported in time O (z + log n). A 2-dimensional topology tree for a topology tree is defined as follows. <p> The crucial point of this analysis is that only O (m=z) nodes in the 2-dimensional topology tree need to be looked at and eventually updated during a swap, and this can be done in constant time per node. Lemma 7 (Frederickson <ref> [14, 15] </ref>) The update of a 2-dimensional topology tree because of an edge swap in the corresponding topology tree can be supported in time O (m=z). <p> Typical algorithms will balance this bound by choosing z = fi (m 1=2 ) to get an O (m 1=2 ) total time bound, as shown in the following theorem. Theorem 5 (Frederickson <ref> [14] </ref>) The minimum spanning forest of an undirected graph can be maintained in time O (m 1=2 ) per update, where m is the current number of edges in the graph. <p> need to be adjusted, we can adjust a constant number of clusters during each update. 2 18 5.2 Sparsification The techniques described in Section 5.1 allow us to obtain an O (m 1=2 ) time bound for the fully dynamic maintenance of a minimum spanning forest, connectivity and 2-edge connectivity <ref> [14, 15] </ref>. The type of clustering used is very problem-dependent, however, and makes these techniques unsuitable to be used as a black box. Namely, whenever we want to apply such techniques to solve a certain problem, we must devise a proper partition of the graph into clusters.
Reference: [15] <author> G. N. Frederickson. </author> <title> Ambivalent data structures for dynamic 2-edge-connectivity and k smallest spanning trees. </title> <booktitle> In Proc. 32nd Symp. Foundations of Computer Science, </booktitle> <pages> pages 632-641, </pages> <year> 1991. </year>
Reference-contexts: This implies that at any level a cluster of tree degree 3 consists always of a single vertex. Once again, several multi-level partitions are possible. But each restricted multi-level partition has the nice property of having only logarithmic depth, as implied by the following lemma of Frederickson <ref> [15] </ref>. Lemma 1 (Frederickson [15]) For any ` 0, the number of clusters at level ` + 1 is at most 5=6 times the number of clusters at level `. The topology tree is a hierarchical representation of T . <p> Once again, several multi-level partitions are possible. But each restricted multi-level partition has the nice property of having only logarithmic depth, as implied by the following lemma of Frederickson <ref> [15] </ref>. Lemma 1 (Frederickson [15]) For any ` 0, the number of clusters at level ` + 1 is at most 5=6 times the number of clusters at level `. The topology tree is a hierarchical representation of T . <p> The changes in the topology tree are caused by the changes in the restricted multi-level partition it represents: at each level of the topology tree, we apply few locally greedy adjustments similar to the ones described before for one-level restricted partitions. As shown in <ref> [15] </ref>, the topology tree update actually consists of two subtasks. First, a constant number of basic clusters (corresponding to leaves in the topology tree) have to be examined and possibly updated. <p> Typically, this decomposition is applied recursively and the information about the subgraphs is combined with the topology trees described in Section 3.1. A refinement of the clustering technique appears in the idea of ambivalent data structures <ref> [15] </ref>, in which edges can belong to multiple groups, only one of which is actually selected depending on the topology of the given spanning tree. Another technique we describe is sparsification by Eppstein et al. [10]. <p> This is an important problem on its own, but it has also impact on other problems as well. Indeed the data structures and techniques developed for dynamic minimum spanning forests have found applications also in other areas, such as dynamic edge and vertex connectivity <ref> [10, 15, 19, 26, 41, 42] </ref>. Thus, we will focus our attention to the fully dynamic maintenance of minimum spanning trees. 5.1 Clustering and Topology Trees Let G = (V; E) be a graph, with a designated spanning tree S. <p> When the partition can be applied recursively, better O (m 1=2 ) time bounds can be achieved with the help of topology trees (see for instance <ref> [14, 15] </ref>). <p> Note that since any cluster has maximum external degree 3, it can have at most three boundary vertices. A restricted partition of order z can be found in linear time as shown in <ref> [15] </ref>. We now discuss how to update the clusters of a restricted partition of order z when the underlying graph is subject to updates. <p> Furthermore, there are no non-tree edges having an endpoint in a cluster of tree degree 3. Finally, the restricted multi-level partition has the nice property of having only logarithmic depth. Indeed Frederickson <ref> [15] </ref> shows that each level of the topology tree has a number of nodes which is a constant fraction of the previous level, from which the following lemma follows. Lemma 5 (Frederickson [14, 15]) The number of levels in a restricted multi-level partition is fi (log n). <p> Finally, the restricted multi-level partition has the nice property of having only logarithmic depth. Indeed Frederickson [15] shows that each level of the topology tree has a number of nodes which is a constant fraction of the previous level, from which the following lemma follows. Lemma 5 (Frederickson <ref> [14, 15] </ref>) The number of levels in a restricted multi-level partition is fi (log n). The topology tree is a hierarchical representation of G based on T . Each level of the topology tree partitions the vertices of G into connected subsets called clusters. <p> tree node at level ` represents a vertex cluster at level ` in the restricted multi-level partition. (2) A node at level ` 1 has at most two children, representing the vertex clusters at level ` 1 whose union gives the vertex cluster the node represents. 16 As shown in <ref> [15] </ref>, the update of a topology tree because of an edge swap in T consists of two subtasks. First, a constant number of basic clusters (corresponding to leaves in the topology tree) have to be examined and possibly updated. <p> This is handled by rebuilding portions of the topology tree in a bottom-up fashion, and involves a constant amount of work to be done on at most O (log n) topology tree nodes. This yields the following lemma. Lemma 6 (Frederickson <ref> [14, 15] </ref>) The update of a topology tree because of an edge swap can be supported in time O (z + log n). A 2-dimensional topology tree for a topology tree is defined as follows. <p> This yields a total of O (z + (m=z) log n) time. The computational saving of a 2-dimensional topology tree is that it can be updated during a swap in its corresponding topology tree in O (m=z) time only <ref> [15] </ref>. The crucial point of this analysis is that only O (m=z) nodes in the 2-dimensional topology tree need to be looked at and eventually updated during a swap, and this can be done in constant time per node. <p> The crucial point of this analysis is that only O (m=z) nodes in the 2-dimensional topology tree need to be looked at and eventually updated during a swap, and this can be done in constant time per node. Lemma 7 (Frederickson <ref> [14, 15] </ref>) The update of a 2-dimensional topology tree because of an edge swap in the corresponding topology tree can be supported in time O (m=z). <p> need to be adjusted, we can adjust a constant number of clusters during each update. 2 18 5.2 Sparsification The techniques described in Section 5.1 allow us to obtain an O (m 1=2 ) time bound for the fully dynamic maintenance of a minimum spanning forest, connectivity and 2-edge connectivity <ref> [14, 15] </ref>. The type of clustering used is very problem-dependent, however, and makes these techniques unsuitable to be used as a black box. Namely, whenever we want to apply such techniques to solve a certain problem, we must devise a proper partition of the graph into clusters.
Reference: [16] <author> M. L. Fredman and M. R. Henzinger. </author> <title> Lower bounds for fully dynamic connectivity problems in graphs. </title> <journal> Algorithmica. </journal> <note> To appear. </note>
Reference-contexts: Is there any faster randomized algorithm for this? Very little is known about lower bounds for fully dynamic graph problems. The only nontrivial lower bounds known are the (log n= log log n) lower bounds of Fredman and Henzinger <ref> [16] </ref> for the 34 cell-probe model of computation. While the randomized algorithms described in this chapter are close to these lower bounds, there is still a big gap for the deterministic algorithms.
Reference: [17] <author> D. Frigioni, A. Marchetti-Spaccamela, and U. Nanni. </author> <title> Fully dynamic output bounded single source shortest path problems. </title> <booktitle> In Proc. 7th ACM-SIAM Symp. Discrete Algorithms, </booktitle> <pages> pages 212-221, </pages> <year> 1996. </year>
Reference-contexts: For this reason, an alternative viewpoint that has been proposed is to measure the complexity of a dynamic algorithm as a function of the output change <ref> [17, 40] </ref>. The main dynamic problems considered on directed graphs include shortest paths and transitive closure.
Reference: [18] <author> H. N. Gabow and M. Stallman. </author> <title> Efficient algorithms for graphic matroid intersection and parity. </title> <booktitle> In Proc. 12th Int. Coll. Automata, Languages, and Programming, </booktitle> <pages> pages 210-220. </pages> <booktitle> Lecture Notes in Computer Science 194, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1985. </year>
Reference: [19] <author> Z. Galil and G. F. </author> <title> Italiano. Fully dynamic algorithms for 2-edge-connectivity. </title> <journal> SIAM J. Comput., </journal> <volume> 21 </volume> <pages> 1047-1069, </pages> <year> 1992. </year>
Reference-contexts: This is an important problem on its own, but it has also impact on other problems as well. Indeed the data structures and techniques developed for dynamic minimum spanning forests have found applications also in other areas, such as dynamic edge and vertex connectivity <ref> [10, 15, 19, 26, 41, 42] </ref>. Thus, we will focus our attention to the fully dynamic maintenance of minimum spanning trees. 5.1 Clustering and Topology Trees Let G = (V; E) be a graph, with a designated spanning tree S. <p> Fully dynamic algorithms based only on a single level of clustering obtain typically time bounds of O (m 2=3 ) (see for instance <ref> [19, 41] </ref>). When the partition can be applied recursively, better O (m 1=2 ) time bounds can be achieved with the help of topology trees (see for instance [14, 15]).
Reference: [20] <author> Z. Galil and G. F. </author> <title> Italiano. Maintaining the 3-edge-connected components of a graph on-line. </title> <journal> SIAM J. Comput., </journal> <volume> 22 </volume> <pages> 11-28, </pages> <year> 1993. </year>
Reference-contexts: total number of parent and union steps is O (n), giving a total of O (q) finds and O (n) unions in the set union data structure. 2 To complete this section, we mention that all the incremental algorithms proposed in the literature for edge and vertex connectivity (see e.g. <ref> [7, 8, 20, 33, 35, 36, 38, 52] </ref>) follow the approach outlined here for 2-edge connectivity. Namely, connectivity queries are answered by maintaining a tree that reflects the structure of the connectivity cuts of the graph.
Reference: [21] <author> Z. Galil, G. F. Italiano, and N. Sarnak. </author> <title> Fully dynamic planarity testing. </title> <booktitle> In Proc. 24th ACM Symp. Theory of Computing, </booktitle> <pages> pages 495-506, </pages> <year> 1992. </year>
Reference: [22] <author> D. Giammarresi and G. F. </author> <title> Italiano. Decremental 2- and 3-connectivity on planar graphs. Algorithmica. To appear. </title> <booktitle> See also Proc. 3rd Scandinavian Workshop on Algorithm Theory, </booktitle> <pages> pages 221-232. </pages> <booktitle> Lecture Notes in Computer Science 621, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference: [23] <author> F. Harary. </author> <title> Graph Theory. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1969. </year>
Reference-contexts: This is without loss of generality, as we can convert any tree T to a tree T 0 with maximum vertex degree 3 by means of a standard transformation <ref> [23] </ref>, which will be defined in a more general sense for graphs in Section 5.1. Let T be a tree of maximum degree 3 to be maintained dynamically. Before definining formally a topology tree, we need a little terminology. <p> Before defining clustering and topology trees, we describe a standard graph transformation that we use throughout. We convert the graph G into a graph with maximum vertex degree 3 <ref> [23] </ref>: Suppose v 2 V has degree d (v) &gt; 3, and is adjacent to vertices u 1 ; u 2 ; : : : ; u d .
Reference: [24] <author> M. R. Henzinger and V. King. </author> <title> Randomized dynamic graph algorithms with polylogarithmic time per operation. </title> <booktitle> In Proc. 27th Symp. on Theory of Computing, </booktitle> <pages> pages 519-527, </pages> <year> 1995. </year>
Reference-contexts: The previous two techniques allows one to design efficient deterministic algorithms. The last technique we present in this section is due to Henzinger and King <ref> [24] </ref>, and it is a combination of a suitable graph decomposition and randomization. We now sketch how this decomposition is defined. Let G be a graph whose spanning forest has to be maintained dynamically. <p> Recently, Henzinger and King <ref> [24] </ref> proposed a new approach that, exploiting the power of randomization, is able to achieve faster update times for some problems. <p> If e is a tree edge, let i be the level where e first appears. We do a delete tree (e) at level j, for j i, and then call replace (u; v; i). This yields the following bounds. Theorem 9 (Henzinger and King <ref> [24] </ref>) Let G be a graph with m 0 edges and n vertices subject to edge deletions only. A spanning forest of G can be maintained in O (log 3 n) expected amortized time per deletion, if there are at least (m 0 ) deletions. <p> Corollary 2 All edges of G are contained in some level E i , i d2 log ne. We are now ready to analyze the running time of the entire algorithm. Theorem 10 (Henzinger and King <ref> [24] </ref>) Let G be a graph with m 0 edges and n vertices subject to edge insertions and deletions. A spanning forest of G can be maintained in O (log 3 n) expected amortized time per update, if there are at least (m 0 ) updates.
Reference: [25] <author> M. R. Henzinger and V. King. </author> <title> Fully dynamic biconnectivity and transitive closure. operation. </title> <booktitle> In Proc. Proc. 36th IEEE Symp. Foundations of Computer Science, </booktitle> <pages> pages 664-672, </pages> <year> 1995. </year> <month> 37 </month>
Reference-contexts: ESPRIT LTR Project no. 20244 (ALCOM-IT) and by a Research Grant from University of Venice "Ca' Foscari". 1 Most of the efficient data structures available for directed graphs are partially dynamic [2, 13, 29, 30, 31, 37, 39, 43, 53], and only preliminary results are available for fully dynamic problems <ref> [25] </ref>. For this reason, an alternative viewpoint that has been proposed is to measure the complexity of a dynamic algorithm as a function of the output change [17, 40]. The main dynamic problems considered on directed graphs include shortest paths and transitive closure.
Reference: [26] <author> M. R. Henzinger and J. A. La Poutre. </author> <title> Certificates and fast algorithms for biconnectivity in fully dynamic graphs. </title> <booktitle> In Proc. 3rd European Symp. on Algorithms, </booktitle> <pages> pages 171-184. </pages> <booktitle> Lecture Notes in Computer Science 979, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1995. </year>
Reference-contexts: This is an important problem on its own, but it has also impact on other problems as well. Indeed the data structures and techniques developed for dynamic minimum spanning forests have found applications also in other areas, such as dynamic edge and vertex connectivity <ref> [10, 15, 19, 26, 41, 42] </ref>. Thus, we will focus our attention to the fully dynamic maintenance of minimum spanning trees. 5.1 Clustering and Topology Trees Let G = (V; E) be a graph, with a designated spanning tree S. <p> Vertex connectivity is not so easy: for 2 k 4, there are algorithms with times ranging from O (n 1=2 log 2 n) to O (nff (n)) per update <ref> [10, 26, 42] </ref>. 5.3 Randomized Algorithms All the previous techniques yield efficient deterministic algorithms, whose best running times are O (n 1=2 ). Recently, Henzinger and King [24] proposed a new approach that, exploiting the power of randomization, is able to achieve faster update times for some problems.
Reference: [27] <author> M. R. Henzinger and M. </author> <title> Thorup. Improved sampling with applications to dynamic graph algorithms. </title> <booktitle> In Proc. 23rd Int. Colloquium on Automata, Languages and Programming, </booktitle> <year> 1996. </year>
Reference-contexts: We refer the interested reader to <ref> [27] </ref> for the details. 6 Research Issues and Summary In this chapter we have described the most efficient known algorithms for maintaining dynamic graphs.
Reference: [28] <author> J. Hershberger, M. Rauch, and S. Suri. </author> <title> Data structures for two-edge connectivity in planar graphs. </title> <journal> Theor. Comp. Sci., </journal> <volume> 130 </volume> <pages> 139-161, </pages> <year> 1994. </year>
Reference: [29] <author> T. Ibaraki and N. Katoh. </author> <title> On-line computation of transitive closure for graphs. </title> <journal> Inform. Proc. Lett., </journal> <volume> 16 </volume> <pages> 95-97, </pages> <year> 1983. </year>
Reference-contexts: Supported in part by the ESPRIT LTR Project no. 20244 (ALCOM-IT) and by a Research Grant from University of Venice "Ca' Foscari". 1 Most of the efficient data structures available for directed graphs are partially dynamic <ref> [2, 13, 29, 30, 31, 37, 39, 43, 53] </ref>, and only preliminary results are available for fully dynamic problems [25]. For this reason, an alternative viewpoint that has been proposed is to measure the complexity of a dynamic algorithm as a function of the output change [17, 40].
Reference: [30] <author> G. F. </author> <title> Italiano. Amortized efficiency of a path retrieval data structure. </title> <journal> Theor. Comput. Sci., </journal> <volume> 48 </volume> <pages> 273-281, </pages> <year> 1986. </year>
Reference-contexts: Supported in part by the ESPRIT LTR Project no. 20244 (ALCOM-IT) and by a Research Grant from University of Venice "Ca' Foscari". 1 Most of the efficient data structures available for directed graphs are partially dynamic <ref> [2, 13, 29, 30, 31, 37, 39, 43, 53] </ref>, and only preliminary results are available for fully dynamic problems [25]. For this reason, an alternative viewpoint that has been proposed is to measure the complexity of a dynamic algorithm as a function of the output change [17, 40].
Reference: [31] <author> G. F. </author> <title> Italiano. Finding paths and deleting edges in directed acyclic graphs. </title> <journal> Inform. Proc. Lett., </journal> <volume> 28 </volume> <pages> 5-11, </pages> <year> 1988. </year>
Reference-contexts: Supported in part by the ESPRIT LTR Project no. 20244 (ALCOM-IT) and by a Research Grant from University of Venice "Ca' Foscari". 1 Most of the efficient data structures available for directed graphs are partially dynamic <ref> [2, 13, 29, 30, 31, 37, 39, 43, 53] </ref>, and only preliminary results are available for fully dynamic problems [25]. For this reason, an alternative viewpoint that has been proposed is to measure the complexity of a dynamic algorithm as a function of the output change [17, 40].
Reference: [32] <author> G. F. Italiano, J. A. La Poutre, and M. Rauch. </author> <title> Fully dynamic planarity testing in planar embedded graphs. </title> <booktitle> In Proc. 1st European Symp. Algorithms, </booktitle> <pages> pages 212-223. </pages> <booktitle> Lecture Notes in Computer Science 726, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1993. </year>
Reference: [33] <author> A. Kanevsky, R. Tamassia, G. Di Battista, and J. Chen. </author> <title> On-line maintenance of the four-connected components of a graph. </title> <booktitle> In Proc. 32nd IEEE Symp. Foundations of Computer Science, </booktitle> <pages> pages 793-801, </pages> <year> 1991. </year>
Reference-contexts: total number of parent and union steps is O (n), giving a total of O (q) finds and O (n) unions in the set union data structure. 2 To complete this section, we mention that all the incremental algorithms proposed in the literature for edge and vertex connectivity (see e.g. <ref> [7, 8, 20, 33, 35, 36, 38, 52] </ref>) follow the approach outlined here for 2-edge connectivity. Namely, connectivity queries are answered by maintaining a tree that reflects the structure of the connectivity cuts of the graph.
Reference: [34] <author> P. N. Klein and S. Sairam. </author> <title> Fully dynamic approximation schemes for shortest path problems in planar graphs. </title> <booktitle> In Proc. 3rd Worksh. Algorithms and Data Structures, </booktitle> <pages> pages 442-451. </pages> <booktitle> Lecture Notes in Computer Science 709, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1993. </year>
Reference: [35] <author> J. A. La Poutre. </author> <title> Maintenance of 2- and 3-connected components of graphs, part II: 2- and 3-edge-connected components and 2-vertex-connected components. </title> <type> Technical Report ALCOM-91-145, </type> <institution> Department of Computer Science, Utrecht University, </institution> <year> 1991. </year> <month> 38 </month>
Reference-contexts: total number of parent and union steps is O (n), giving a total of O (q) finds and O (n) unions in the set union data structure. 2 To complete this section, we mention that all the incremental algorithms proposed in the literature for edge and vertex connectivity (see e.g. <ref> [7, 8, 20, 33, 35, 36, 38, 52] </ref>) follow the approach outlined here for 2-edge connectivity. Namely, connectivity queries are answered by maintaining a tree that reflects the structure of the connectivity cuts of the graph.
Reference: [36] <author> J. A. La Poutre. </author> <title> Maintenance of triconnected components of graphs. </title> <booktitle> In Proc. 19th Int. Collo--quium on Automata, Languages and Programming, </booktitle> <pages> pages 354-365. </pages> <booktitle> Lecture Notes in Computer Science 623, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: total number of parent and union steps is O (n), giving a total of O (q) finds and O (n) unions in the set union data structure. 2 To complete this section, we mention that all the incremental algorithms proposed in the literature for edge and vertex connectivity (see e.g. <ref> [7, 8, 20, 33, 35, 36, 38, 52] </ref>) follow the approach outlined here for 2-edge connectivity. Namely, connectivity queries are answered by maintaining a tree that reflects the structure of the connectivity cuts of the graph.
Reference: [37] <author> J. A. La Poutre and J. van Leeuwen. </author> <title> Maintenance of transitive closure and transitive reduction of graphs. </title> <booktitle> In Proc. Workshop on Graph-Theoretic Concepts in Computer Science, </booktitle> <pages> pages 106-120. </pages> <booktitle> Lecture Notes in Computer Science 314, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1988. </year>
Reference-contexts: Supported in part by the ESPRIT LTR Project no. 20244 (ALCOM-IT) and by a Research Grant from University of Venice "Ca' Foscari". 1 Most of the efficient data structures available for directed graphs are partially dynamic <ref> [2, 13, 29, 30, 31, 37, 39, 43, 53] </ref>, and only preliminary results are available for fully dynamic problems [25]. For this reason, an alternative viewpoint that has been proposed is to measure the complexity of a dynamic algorithm as a function of the output change [17, 40].
Reference: [38] <author> J. A. La Poutre, J. van Leeuwen, and M. H. Overmars. </author> <title> Maintenance of 2- and 3-connected components of graphs, part I: 2- and 3-edge-connected components. </title> <journal> Discrete Mathematics, </journal> <volume> 114 </volume> <pages> 329-359, </pages> <year> 1993. </year>
Reference-contexts: total number of parent and union steps is O (n), giving a total of O (q) finds and O (n) unions in the set union data structure. 2 To complete this section, we mention that all the incremental algorithms proposed in the literature for edge and vertex connectivity (see e.g. <ref> [7, 8, 20, 33, 35, 36, 38, 52] </ref>) follow the approach outlined here for 2-edge connectivity. Namely, connectivity queries are answered by maintaining a tree that reflects the structure of the connectivity cuts of the graph.
Reference: [39] <author> C. C. Lin and R. C. Chang. </author> <title> On the dynamic shortest path problem. </title> <journal> J. Information Processing, </journal> <volume> 13 </volume> <pages> 470-476, </pages> <year> 1990. </year> <note> See also Int. </note> <editor> Worksh. </editor> <booktitle> Discrete Algorithms and Complexity, </booktitle> <pages> pages 203-212, </pages> <year> 1989. </year>
Reference-contexts: Supported in part by the ESPRIT LTR Project no. 20244 (ALCOM-IT) and by a Research Grant from University of Venice "Ca' Foscari". 1 Most of the efficient data structures available for directed graphs are partially dynamic <ref> [2, 13, 29, 30, 31, 37, 39, 43, 53] </ref>, and only preliminary results are available for fully dynamic problems [25]. For this reason, an alternative viewpoint that has been proposed is to measure the complexity of a dynamic algorithm as a function of the output change [17, 40].
Reference: [40] <author> G. Ramalingam. </author> <title> Bounded incremental compilation. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Wisconsin at Madison, </institution> <month> August </month> <year> 1993. </year>
Reference-contexts: For this reason, an alternative viewpoint that has been proposed is to measure the complexity of a dynamic algorithm as a function of the output change <ref> [17, 40] </ref>. The main dynamic problems considered on directed graphs include shortest paths and transitive closure.
Reference: [41] <author> M. Rauch. </author> <title> Fully dynamic biconnectivity in graphs. </title> <booktitle> In Proc. 33rd IEEE Symp. Foundations of Computer Science, </booktitle> <pages> pages 50-59, </pages> <year> 1992. </year>
Reference-contexts: This is an important problem on its own, but it has also impact on other problems as well. Indeed the data structures and techniques developed for dynamic minimum spanning forests have found applications also in other areas, such as dynamic edge and vertex connectivity <ref> [10, 15, 19, 26, 41, 42] </ref>. Thus, we will focus our attention to the fully dynamic maintenance of minimum spanning trees. 5.1 Clustering and Topology Trees Let G = (V; E) be a graph, with a designated spanning tree S. <p> Fully dynamic algorithms based only on a single level of clustering obtain typically time bounds of O (m 2=3 ) (see for instance <ref> [19, 41] </ref>). When the partition can be applied recursively, better O (m 1=2 ) time bounds can be achieved with the help of topology trees (see for instance [14, 15]).
Reference: [42] <author> M. Rauch. </author> <title> Improved data structures for fully dynamic biconnectivity. </title> <booktitle> In Proc. 26th Symp. Theory of Computing, </booktitle> <year> 1994. </year>
Reference-contexts: This is an important problem on its own, but it has also impact on other problems as well. Indeed the data structures and techniques developed for dynamic minimum spanning forests have found applications also in other areas, such as dynamic edge and vertex connectivity <ref> [10, 15, 19, 26, 41, 42] </ref>. Thus, we will focus our attention to the fully dynamic maintenance of minimum spanning trees. 5.1 Clustering and Topology Trees Let G = (V; E) be a graph, with a designated spanning tree S. <p> Vertex connectivity is not so easy: for 2 k 4, there are algorithms with times ranging from O (n 1=2 log 2 n) to O (nff (n)) per update <ref> [10, 26, 42] </ref>. 5.3 Randomized Algorithms All the previous techniques yield efficient deterministic algorithms, whose best running times are O (n 1=2 ). Recently, Henzinger and King [24] proposed a new approach that, exploiting the power of randomization, is able to achieve faster update times for some problems.
Reference: [43] <author> H. Rohnert. </author> <title> A dynamization of the all pairs least cost path problem. </title> <booktitle> In Proc. 2nd Symp. Theoretical Aspects of Computer Science, </booktitle> <pages> pages 279-286. </pages> <booktitle> Lecture Notes in Computer Science 182, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1985. </year>
Reference-contexts: Supported in part by the ESPRIT LTR Project no. 20244 (ALCOM-IT) and by a Research Grant from University of Venice "Ca' Foscari". 1 Most of the efficient data structures available for directed graphs are partially dynamic <ref> [2, 13, 29, 30, 31, 37, 39, 43, 53] </ref>, and only preliminary results are available for fully dynamic problems [25]. For this reason, an alternative viewpoint that has been proposed is to measure the complexity of a dynamic algorithm as a function of the output change [17, 40].
Reference: [44] <author> D. D. Sleator and R. E. Tarjan. </author> <title> A data structure for dynamic trees. </title> <journal> J. Comp. Syst. Sci., </journal> <volume> 24 </volume> <pages> 362-381, </pages> <year> 1983. </year>
Reference-contexts: We will thus focus on the fully dynamic tree membership problem. Other properties that have been considered are finding the parent of a vertex, or finding the least common ancestor of two vertices <ref> [44] </ref>. <p> There are two fully dynamic data structures for this problem: the dynamic trees of Sleator and Tarjan <ref> [44] </ref>, and the topology trees of Frederickson [14]. Both data structures follow the common idea of partitioning a tree into a set of vertex-disjoint paths. However, they are very different in how this partition is chosen, and in the data structures they use to represent the paths inside the partition. <p> Both data structures follow the common idea of partitioning a tree into a set of vertex-disjoint paths. However, they are very different in how this partition is chosen, and in the data structures they use to represent the paths inside the partition. Indeed, Sleator and Tarjan <ref> [44] </ref> use a simple partition of the trees based upon a careful choice of sophisticated data structures to represent paths. <p> On the contrary, Frederickson [14] uses a more sophisticated partition that is based upon the topology of the tree; this implies more complicated algorithms but simpler data structures for representing paths. The dynamic trees of Sleator and Tarjan <ref> [44] </ref> are able to maintain maintain a collection of rooted trees, each of whose vertices has a real-valued cost, under an arbitrary sequence of the following operations: maketree (v): initialize a new tree consisting of single vertex v with cost zero. findroot (v): return the root of the tree containing vertex <p> This operation assumes that v is not a tree root. evert (v): Make v the root of its tree. 4 Theorem 1 (Sleator and Tarjan <ref> [44] </ref>) Each of the above operations can be supported in O (log n) worst-case time. We do not give the details of the method here, and refer the interested reader to reference [44]. <p> a tree root. evert (v): Make v the root of its tree. 4 Theorem 1 (Sleator and Tarjan <ref> [44] </ref>) Each of the above operations can be supported in O (log n) worst-case time. We do not give the details of the method here, and refer the interested reader to reference [44]. We only mention that some extensions of the dynamic trees of Sleator and Tarjan are the edge-ordered dynamic trees [12], designed to handle compressions and expansions of edges efficiently, and the dynamic expression trees [5]. <p> The first technique we present is the clustering technique of Frederickson [14], which is based upon partitioning the graph into a suitable collection of connected subgraphs called clusters, such that each update involves only a small number of such clusters. The dynamic trees of Sleator and Tarjan <ref> [44] </ref> can be used to maintain information about the edges of a tree; clusters dually keep track of the edges that are not part of some given spanning tree, by grouping them according to which clusters they connect.
Reference: [45] <author> P. M. Spira and A. Pan. </author> <title> On finding and updating spanning trees and shortest paths. </title> <journal> SIAM J. Comput., </journal> <volume> 4 </volume> <pages> 375-380, </pages> <year> 1975. </year> <month> 39 </month>
Reference-contexts: These edges are moved to level (i + 1) and the same procedure is applied recursively on level (i + 1). One particular dynamic graph problem that has been thoroughly investigated is the maintenance of a minimum spanning forest <ref> [4, 10, 14, 45] </ref>. This is an important problem on its own, but it has also impact on other problems as well.
Reference: [46] <author> R. Tamassia. </author> <title> A dynamic data structure for planar graph embedding. </title> <booktitle> In Proc. 15th Int. Collo--quium on Automata, Languages and Programming, </booktitle> <pages> pages 576-590. </pages> <booktitle> Lecture Notes in Computer Science 317, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1988. </year>
Reference: [47] <author> R. Tamassia and F. P. Preparata. </author> <title> Dynamic maintenance of planar digraphs, with applications. </title> <journal> Algorithmica, </journal> <volume> 5 </volume> <pages> 509-527, </pages> <year> 1990. </year>
Reference: [48] <author> R. Tamassia and I. G. Tollis. </author> <title> Dynamic reachability in planar digraphs with one source and one sink. </title> <journal> Theor. Comput. Sci., </journal> <volume> 119 </volume> <pages> 331-344, </pages> <year> 1993. </year>
Reference: [49] <author> R. E. Tarjan. </author> <title> Depth-first search and linear graph algorithms. </title> <journal> SIAM J. Comput., </journal> <volume> 1 </volume> <pages> 146-160, </pages> <year> 1972. </year>
Reference-contexts: Proof: The 2-edge-connected components and the bridge-block tree of G 0 can be found in O (jE 0 j) using the algorithm of Tarjan <ref> [49] </ref>.
Reference: [50] <author> R. E. Tarjan and J. van Leeuwen. </author> <title> Worst-case analysis of set union algorithms. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 31 </volume> <pages> 245-281, </pages> <year> 1984. </year>
Reference-contexts: The partially dynamic tree membership problem by means of the well known set union data structures <ref> [50] </ref> described in Chapter 8. We will thus focus on the fully dynamic tree membership problem. Other properties that have been considered are finding the parent of a vertex, or finding the least common ancestor of two vertices [44].
Reference: [51] <author> J. Westbrook. </author> <title> Fast incremental planarity testing. </title> <booktitle> In Proc. 19th Int. Colloquium on Automata, Languages and Programming, </booktitle> <pages> pages 342-353. </pages> <booktitle> Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag 623, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference: [52] <author> J. Westbrook and R. E. Tarjan. </author> <title> Maintaining bridge-connected and biconnected components on-line. </title> <journal> Algorithmica, </journal> <volume> 7 </volume> <pages> 433-464, </pages> <year> 1992. </year>
Reference-contexts: Same2EdgeBlock (u; v): Return true if vertices u and v are in the same 2-edge-connected com ponent. Return false otherwise. InsertEdge (x; y): Insert a new edge between the two vertices x and y. Westbrook and Tarjan <ref> [52] </ref> presented one algorithm that runs in a total of O (qff (q; n)) time, where q is the total number of Same2EdgeBlock and InsertEdge operations, and n is the number of vertices. <p> For sake of simplicity, we describe in details only the algorithm that operates on connected graphs, and refer the interested reader to <ref> [52] </ref> for the full details of the method on general unconnected graphs. For any vertex x in G denote by C 2E (x) the 2-edge-connected component of G containing x. The main data structure maintained by the algorithm is the bridge-block tree of G, which is defined as follows. <p> can be at most O (n) parent steps and (n 1) union steps. 2 With the help of these primitives, we support an InsertEdge (u; v) as follows: InsertEdge (u; v) begin return CondenseP ath (F indP ath (f ind (u); f ind (v))); end Theorem 4 (Westbrook and Tarjan <ref> [52] </ref>) Given an initially connected graph G 0 = (V 0 ; E 0 ) and O (jE 0 j) preprocessing time, a sequence of q InsertEdge and Same2EdgeBlock operations can be processed in O (qff (q; n)) time. <p> total number of parent and union steps is O (n), giving a total of O (q) finds and O (n) unions in the set union data structure. 2 To complete this section, we mention that all the incremental algorithms proposed in the literature for edge and vertex connectivity (see e.g. <ref> [7, 8, 20, 33, 35, 36, 38, 52] </ref>) follow the approach outlined here for 2-edge connectivity. Namely, connectivity queries are answered by maintaining a tree that reflects the structure of the connectivity cuts of the graph.

References-found: 52

