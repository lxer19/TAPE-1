URL: ftp://ftp.eecs.umich.edu/groups/Ealgebras/leanEA.ps
Refering-URL: http://www.eecs.umich.edu/gasm/new1995.html
Root-URL: http://www.cs.umich.edu
Email: beckert@ira.uka.de  posegga@fz.telekom.de  
Phone: 2  
Title: leanE A A Lean Evolving Algebra Compiler rearrange(F:=G, ([G]=&gt;*[E],F=..[C|D],D=&gt;*B,A=..[C|B]), asserta(A=&gt;E)). [G|H]=&gt;*[E|F] []=&gt;*[]. implements an efficient
Author: Bernhard Beckert and Joachim Posegga ifications. 
Note: rearrange(E,C,B), rearrange(F,D,A).  
Address: 76128 Karlsruhe, Germany;  64276 Darmstadt, Germany;  
Affiliation: 1 University of Karlsruhe, Institute for Logic, Complexity and Deduction Systems,  Deutsche Telekom AG, Research Centre,  
Abstract: The Prolog program "term_expansion((define C as A with B), (C=&gt;A:-B,!)). term_expansion((transition E if C then D), ((transition E):-C,!,B,A,(transition _))) :- rearrange(D,B,A). rearrange((E,F),(C,D),(A,B)) :- 
Abstract-found: 1
Intro-found: 1
Reference: <author> B orger, Egon, & Rosenzweig, Dean. </author> <year> 1994. </year> <title> A Mathematical Definition of Full Prolog. </title> <booktitle> Science of Computer Programming. </booktitle>
Reference-contexts: The number of specifications using EAs is rapidly growing; examples are specifications of the languages ANSI C (Gurevich & Hug-gins, 1993) and ISO Prolog <ref> (Borger & Rosenzweig, 1994) </ref>, and of the virtual architecture APE (Borger et al., 1994b). EA specifications have also been used to validate language implementations (e.g., Occam (Borger et al., 1994a)) and distributed protocols (Gurevich & Mani, 1995).
Reference: <author> B orger, Egon, Durdanovic, Igor, & Rosenzweig, Dean. </author> <year> 1994a. </year> <title> Occam: Specification and Compiler Correctness. Pages 489-508 of: </title> <editor> Montanari, U., & Olderog, E.-R. (eds), </editor> <booktitle> Proceedings, IFIP Working Conference on Programming Concepts, Methods and Calculi (PROCOMET 94). </booktitle> <publisher> North-Holland. </publisher>
Reference-contexts: EA specifications have also been used to validate language implementations (e.g., Occam <ref> (Borger et al., 1994a) </ref>) and distributed protocols (Gurevich & Mani, 1995). When working with EAs, it is very handy to have a simulator at hand for running the specified algebras.
Reference: <author> B orger, Egon, Del Castillo, Giuseppe, Glavan, P., & Rosenzweig, Dean. </author> <year> 1994b. </year> <title> Towards a Mathematical Specification of the APE100 Architecture: The APESE Model. Pages 396-401 of: </title> <editor> Pehrson, B., & Simon, I. (eds), </editor> <booktitle> Proceedings, IFIP 13th World Computer Congress, </booktitle> <volume> vol. 1. </volume> <publisher> Amster-dam: Elsevier. </publisher>
Reference-contexts: The number of specifications using EAs is rapidly growing; examples are specifications of the languages ANSI C (Gurevich & Hug-gins, 1993) and ISO Prolog (Borger & Rosenzweig, 1994), and of the virtual architecture APE <ref> (Borger et al., 1994b) </ref>. EA specifications have also been used to validate language implementations (e.g., Occam (Borger et al., 1994a)) and distributed protocols (Gurevich & Mani, 1995). When working with EAs, it is very handy to have a simulator at hand for running the specified algebras.
Reference: <author> Gurevich, Yuri. </author> <year> 1991. </year> <title> Evolving Algebras. A Tutorial Introduction. </title> <journal> Bulletin of the EATCS, </journal> <volume> 43, </volume> <pages> 264-284. </pages>
Reference: <author> Gurevich, Yuri. </author> <year> 1995. </year> <title> Evolving Algebras 1993: Lipari Guide. </title> <editor> In: B orger, E. (ed), </editor> <title> Specification and Validation Methods. </title> <publisher> Oxford University Press. </publisher>
Reference-contexts: EA specifications have also been used to validate language implementations (e.g., Occam (Borger et al., 1994a)) and distributed protocols <ref> (Gurevich & Mani, 1995) </ref>. When working with EAs, it is very handy to have a simulator at hand for running the specified algebras. <p> The implementation of the basic version of leanE A is explained in parallel. This basic version is characterized mathematically in Section 4 by giving the semantics of leanE A programs; Subsection 4.6 summarizes the differences to the standard semantics of EAs, as defined in the Lipari Guide <ref> (Gurevich, 1995) </ref>. In Section 5, a number of purely syntactical extensions are added for the sake of programming convenience, and more semantical extensions like including typed algebras, or implementing non-deterministic evolving algebras are discussed. <p> goal "[t] =&gt;* [X]" succeeds and binds the Prolog variable X to u iff [[t]] fl 2. the execution of P terminates in a state S iff S is a final state; 3. the predicate =? implements the equality relation. 4.6 Peculiarities of leanE A 's Semantics The Lipari Guide <ref> (Gurevich, 1995) </ref> defines what is usually understood as the standard semantics of EAs. Although leanE A is oriented at this semantics, there are a couple of details where leanE A 's semantics differ. <p> The reason for the differences is not that the standard semantics could not be implemented, but that we decided to compromise for the sake of elegance and clearness of our program. leanE A complies with the semantics given in <ref> (Gurevich, 1995) </ref> with the following exceptions: Relations There are no special pre-defined elements denoting true and false in the universe. The value of the relation =? (and similar pre-defined relations, see Section 5.2) is represented by succeeding (resp. failing) of the corresponding predicate. <p> If no default value is defined for a certain function, it is classically internal. If the default value of a location is changed, this is what is called an external location in <ref> (Gurevich, 1995) </ref>. The relation =? (and similar predicates) are static. Since there is no real distinction, it is possible to mix internal and external functions in function calls. External functions are reiterated (i.e., evaluated multiply in one state) if they occur multiply in a term being evaluated. <p> import", where import is defined by the function definition define import as X with gensym (f,X). 13 Local Non-determinism If the updates of a firing transition are inconsistent, i.e., several updates define a new value for the same location, the first value is chosen (this is called local non-determinism in <ref> (Gurevich, 1995) </ref>). 5 Extensions 5.1 The let Instruction It is often useful to use local abbreviations in a transition.
Reference: <author> Gurevich, Yuri, & Huggins, Jim. </author> <year> 1993. </year> <title> The Semantics of the C Programming Language. </title> <booktitle> Pages 273-309 of: Proceedings, Computer Science Logic (CSL). </booktitle> <publisher> LNCS 702. Springer. </publisher>
Reference-contexts: The number of specifications using EAs is rapidly growing; examples are specifications of the languages ANSI C <ref> (Gurevich & Hug-gins, 1993) </ref> and ISO Prolog (Borger & Rosenzweig, 1994), and of the virtual architecture APE (Borger et al., 1994b). EA specifications have also been used to validate language implementations (e.g., Occam (Borger et al., 1994a)) and distributed protocols (Gurevich & Mani, 1995).
Reference: <author> Gurevich, Yuri, & Mani, Raghu. </author> <year> 1995. </year> <title> Group Membership Protocol: Speci--fication and Verification. </title> <editor> In: B orger, E. (ed), </editor> <title> Specification and Validation Methods. </title> <publisher> Oxford University Press. </publisher>
Reference-contexts: EA specifications have also been used to validate language implementations (e.g., Occam (Borger et al., 1994a)) and distributed protocols <ref> (Gurevich & Mani, 1995) </ref>. When working with EAs, it is very handy to have a simulator at hand for running the specified algebras. <p> The implementation of the basic version of leanE A is explained in parallel. This basic version is characterized mathematically in Section 4 by giving the semantics of leanE A programs; Subsection 4.6 summarizes the differences to the standard semantics of EAs, as defined in the Lipari Guide <ref> (Gurevich, 1995) </ref>. In Section 5, a number of purely syntactical extensions are added for the sake of programming convenience, and more semantical extensions like including typed algebras, or implementing non-deterministic evolving algebras are discussed. <p> goal "[t] =&gt;* [X]" succeeds and binds the Prolog variable X to u iff [[t]] fl 2. the execution of P terminates in a state S iff S is a final state; 3. the predicate =? implements the equality relation. 4.6 Peculiarities of leanE A 's Semantics The Lipari Guide <ref> (Gurevich, 1995) </ref> defines what is usually understood as the standard semantics of EAs. Although leanE A is oriented at this semantics, there are a couple of details where leanE A 's semantics differ. <p> The reason for the differences is not that the standard semantics could not be implemented, but that we decided to compromise for the sake of elegance and clearness of our program. leanE A complies with the semantics given in <ref> (Gurevich, 1995) </ref> with the following exceptions: Relations There are no special pre-defined elements denoting true and false in the universe. The value of the relation =? (and similar pre-defined relations, see Section 5.2) is represented by succeeding (resp. failing) of the corresponding predicate. <p> If no default value is defined for a certain function, it is classically internal. If the default value of a location is changed, this is what is called an external location in <ref> (Gurevich, 1995) </ref>. The relation =? (and similar predicates) are static. Since there is no real distinction, it is possible to mix internal and external functions in function calls. External functions are reiterated (i.e., evaluated multiply in one state) if they occur multiply in a term being evaluated. <p> import", where import is defined by the function definition define import as X with gensym (f,X). 13 Local Non-determinism If the updates of a firing transition are inconsistent, i.e., several updates define a new value for the same location, the first value is chosen (this is called local non-determinism in <ref> (Gurevich, 1995) </ref>). 5 Extensions 5.1 The let Instruction It is often useful to use local abbreviations in a transition.
Reference: <author> Kappel, Angelica M. </author> <year> 1993. </year> <title> Executable Specifications based on Dynamic Algebras. </title> <booktitle> Pages 229-240 of: Proceedings, 4th International Conference on Logic Programming and Automated Reasoning (LPAR), </booktitle> <address> St. Petersburg, Russia. </address> <publisher> LNCS 698. Springer. </publisher>
Reference-contexts: When working with EAs, it is very handy to have a simulator at hand for running the specified algebras. This observation is of course not new and implementations of abstract machines for EAs already exist: Angelica Kappel describes a Prolog-based implementation in <ref> (Kappel, 1993) </ref>, and Jim Huggins reports an implementation written in C. Both implementations are quite sophisticated and offer a convenient language for specifying EAs. In this paper, we describe a new approach to implementing a simulator for evolving algebras; we focus on deterministic, sequential EAs.
Reference: <author> O'Keefe, Richard A. </author> <year> 1990. </year> <title> The Craft of Prolog. </title> <publisher> MIT Press. </publisher>
References-found: 9

