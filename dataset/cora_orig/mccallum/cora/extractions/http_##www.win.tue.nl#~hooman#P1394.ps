URL: http://www.win.tue.nl/~hooman/P1394.ps
Refering-URL: http://www.win.tue.nl/~hooman/P1394.html
Root-URL: http://www.win.tue.nl
Title: Towards Mechanical Verification of Parts of the IEEE P1394 Serial Bus  
Author: Lars Kuhne Jozef Hooman Willem-Paul de Roever 
Abstract: The IEEE P1394 Serial Bus standard provides high performance connections for data transfer between hardware components and is especially well suited for connecting multimedia devices. To achieve its mechanical verification, a high level specification is developed for the asynchronous part of the P1394 Link layer, using the verification tool PVS. We derive a formal framework which closely resembles the state machine approach used in the standard document. In this framework, a new parallel combina-tor characterizes synchronous message passing between transitions for which a set of messages is exchanged atomically. The combinator is mechanically checked for being commutative and associative. As expected, unclarities, ambiguities and unforseen properties need to be resolved in the specification of the Link layer. To date, important Link Layer properties have been handproved using linear time temporal logic; the next aim of the authors is the mechanization of these proofs in PVS. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. D. Brookes, C. A. R. Hoare, and A. W. Roscoe. </author> <title> A theory of communicating sequential processes. </title> <journal> Journal of the ACM, </journal> <volume> 31(3) </volume> <pages> 560-599, </pages> <month> July </month> <year> 1984. </year>
Reference-contexts: Messages have a direction, there can only be one sending and only one receiving process for each message (point to point communication). Parallel processes communicating by means of synchronous message passing are well understood <ref> [6, 1, 2] </ref>. The distinguishing feature of our framework is that processes must synchronize on a set of messages in a single step instead of only a single message.
Reference: [2] <author> R. DeNicola and M. Hennessy. </author> <title> Testing equivalences for processes. </title> <journal> Theoretical Computer Science, </journal> <volume> 34 </volume> <pages> 83-133, </pages> <year> 1984. </year>
Reference-contexts: Messages have a direction, there can only be one sending and only one receiving process for each message (point to point communication). Parallel processes communicating by means of synchronous message passing are well understood <ref> [6, 1, 2] </ref>. The distinguishing feature of our framework is that processes must synchronize on a set of messages in a single step instead of only a single message. <p> Our ready sets extend the idea of ready sets in [6] to capture synchronization on sets of messages, each element of a ready set represents a choice of the environment. Note that acceptance sets in <ref> [2] </ref>, like our ready sets, are sets of sets of messages but their meaning is different each member of an acceptance set represents an internal choice of the system.
Reference: [3] <author> IEEE. </author> <title> P1394 Standard for a High Performance Serial Bus, </title> <type> Draft 8.0v2. </type> <institution> The Institute of Electrical and Electronic Engeneers, </institution> <month> July </month> <year> 1995. </year>
Reference-contexts: 1 Introduction The IEEE P1394 Serial Bus <ref> [3] </ref>, also known as "Firewire", is a standard for high performance connections between (computer) components. The P1394 protocol is organized in three layers, the Transaction layer, the Link layer and the Physical layer. It supports two basic data transfer services: asynchronous data transfer and isochronous data transfer. <p> The interactive theorem prover contains powerful commands ("strategies" in PVS terminology) for, e.g., inductive reasoning, automatic rewriting and the use of decision procedures for propositional and arithmetical reasoning. In section 2 we briefly summarize the protocol architecture and the interface of the Link layer. In <ref> [3] </ref> the Link layer operation is specified in a non-standard and informal state machine approach. We point out the general problems that arise when trying to use these state machines as a basis for formal verification. <p> We point out the general problems that arise when trying to use these state machines as a basis for formal verification. These problems are solved in section 3 by providing a framework for Communicating Transition Systems which formalizes the state machine notation in <ref> [3] </ref>. In this framework a new parallel combinator is derived such that that parallel processes are able to atomically synchronize on a set of messages instead of a single one. To increase confidence in the definition it is mechanically checked that the parallel combi-nator is commutative and associative. <p> For the case of three nodes this is illustrated in figure 1. 2.2 Link Layer Interface The Link layer provides an acknowledged data-gram service (a one way data transfer with confirmation of request) to the Transaction layer <ref> [3, p. 22] </ref>. <p> The Link layer operation is specified in the state machine depicted in <ref> [3, Figure 6.19] </ref>. For the reader's convenience, the part relevant for this work is reproduced in figure 2. <p> Thus, parallel execution of state machines must be considered. But in <ref> [3] </ref> the semantics of parallel execution of state machines is not described. In particular the underlying communication mechanism is neither mentioned nor explained. For formal verification it is necessary to translate the original state machine into a formal framework where these points are clarified. <p> For formal verification it is necessary to translate the original state machine into a formal framework where these points are clarified. To keep the probability of translation errors small, it is desirable to use a framework which closely resembles the state machines of <ref> [3] </ref>. 3 Formal Framework The development of the formal framework for the specification of the Link layer has been led by the following design goals: * A Link layer formalization close to the original description should be possible. * The framework should be similar to other well known formalisms. * The <p> This is very useful for an implementation of the Firewire protocol and explains why in industry <ref> [3] </ref> is considered a well written document. At the same time a very detailed description aggravates any correctness argument since the wealth of information hides why the protocol basically works. We therefore abstract from the specification in [3] in the following ways, resulting in the description given in figure 4: * <p> useful for an implementation of the Firewire protocol and explains why in industry <ref> [3] </ref> is considered a well written document. At the same time a very detailed description aggravates any correctness argument since the wealth of information hides why the protocol basically works. We therefore abstract from the specification in [3] in the following ways, resulting in the description given in figure 4: * We do not use a quantitative notion of time (i.e. only the order of events is considered, not the distance in time between events). <p> In the original specification, transmission of a packet is often done in a state (e.g. in states L2, L4 or L6). In our formalism actions can only take place during execution of transitions. Transforming the state machine in <ref> [3, Figure 6.19] </ref> into our formalism makes the state L6 superfluous. Furthermore it is necessary to introduce a new location L2' from which the transmission of a data packet (originally inside L2) can be performed. <p> To model these possible behaviors, we introduce two functions ASSEMBLE ACK 1 and ASSEMBLE ACK 2 which construct an acknowledge packet from an acknowledgment code with and without a DATA END delimiter respectively. It is not clear from <ref> [3, Figure 6.19] </ref> how it is ensured that a Link layer does not miss incoming data packets while arbitrating in L1. <p> It is not clear from [3, Figure 6.19] how it is ensured that a Link layer does not miss incoming data packets while arbitrating in L1. To solve this problem, here an incoming data packet is identified with a LOST arbitration, as indicated in <ref> [3, p. 175] </ref>. 4.2 Problems with the Formalization In addition to the more general problems mentioned in section 2.3, the original specification in [3] is imprecise at many points in the description of the operation of the Link layer. <p> To solve this problem, here an incoming data packet is identified with a LOST arbitration, as indicated in [3, p. 175]. 4.2 Problems with the Formalization In addition to the more general problems mentioned in section 2.3, the original specification in <ref> [3] </ref> is imprecise at many points in the description of the operation of the Link layer. <p> For example the explaining text for state L4, where an asynchronous packet is received, includes <ref> [3, p. 176] </ref>: The link layer should communicate the PHY arbitration request (with an arbitration class of IMMEDIATE) as soon as possible after it verifies that the destination ID in the packet header addresses this node [. . . ], in anticipation of sending an acknowledge packet [. . . ]. <p> Their graphical representations are given in figures 5 and 6 below. 5 Conclusion and Future Work As a first step towards the mechanical verification of the asynchronous part of the Link layer of the IEEE P1394 serial bus, we have formalized the specification given in <ref> [3] </ref>, using the specification language of PVS. To keep the probability of introducing modeling errors small, we have not tried to model the protocol in an existing state machine framework, but instead tried to give a formal model close to the original description.
Reference: [4] <author> L. Kuhne. </author> <type> Master's thesis, </type> <institution> Christian-Albrechts Universitat Kiel, </institution> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: This is especially problematic since the Transaction layer is not informed of LOST Physical Arbitration confirmations, so it does not have the chance to repeat the LK DATA.req. The hand proofs of all mentioned properties will be published in <ref> [4] </ref>. Currently we are working on the integration of linear time temporal logic into PVS. With this at hand, we plan to use PVS to check the proofs of the protocol properties mechanically.
Reference: [5] <author> Z. Manna and A. Pnueli. </author> <title> The temporal logic of reactive systems. </title> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: They have been used to give a manual proof, using linear time temporal logic <ref> [5] </ref>, of some important properties of the protocol. In the proof the CTS's from figures 5 and 6 are not used directly but only serve to show that the assumptions about the environment have a model.
Reference: [6] <author> E. R. Olderog and C. A. R. Hoare. </author> <title> Specification-oriented semantics for communicating processes. </title> <journal> Acta Informatica, </journal> <volume> 23 </volume> <pages> 9-66, </pages> <year> 1986. </year>
Reference-contexts: Messages have a direction, there can only be one sending and only one receiving process for each message (point to point communication). Parallel processes communicating by means of synchronous message passing are well understood <ref> [6, 1, 2] </ref>. The distinguishing feature of our framework is that processes must synchronize on a set of messages in a single step instead of only a single message. <p> An empty R set means that the environment has no chance to trigger additional transitions by offering more com-munication partners. Our ready sets extend the idea of ready sets in <ref> [6] </ref> to capture synchronization on sets of messages, each element of a ready set represents a choice of the environment.
Reference: [7] <author> S. Owre, N. Shankar, and J. M. Rushby. </author> <title> The PVS Specification Language. </title> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> February </month> <year> 1993. </year>
Reference-contexts: This paper describes the first step in this direction, namely the formalization of the Link layer protocol. To achieve mechanical support, the formalization is given in the specification language of the Prototype Verification System (PVS) <ref> [7, 8] </ref>. PVS 1 is a specification language integrated with support tools and a theorem prover. The specification language of PVS is a higher-order typed logic with many predefined types, including booleans, integers, sets, sequences, etc.
Reference: [8] <author> N. Shankar, S. Owre, and J. M. Rushby. </author> <title> PVS Tutorial. </title> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> February </month> <year> 1993. </year> <title> Also appears in Tutorial Notes, Formal Methods Eu-rope '93: </title> <booktitle> Industrial-Strength Formal Methods, </booktitle> <pages> pages 357-406, </pages> <address> Odense, Denmark, </address> <month> April </month> <year> 1993. </year>
Reference-contexts: This paper describes the first step in this direction, namely the formalization of the Link layer protocol. To achieve mechanical support, the formalization is given in the specification language of the Prototype Verification System (PVS) <ref> [7, 8] </ref>. PVS 1 is a specification language integrated with support tools and a theorem prover. The specification language of PVS is a higher-order typed logic with many predefined types, including booleans, integers, sets, sequences, etc.
References-found: 8

