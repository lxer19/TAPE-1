URL: ftp://ftp.di.unipi.it/pub/Papers/comini/DecDiagRev/DecDiagRev95.ps.gz
Refering-URL: http://www.di.unipi.it/di/groups/lp/papers.html
Root-URL: 
Email: fcomini,levig@di.unipi.it  giuvit@udsab.dia.unisa.it  
Title: Declarative diagnosis revisited  
Author: Marco Comini, Giorgio Levi Giuliana Vitiello 
Keyword: Declarative diagnosis, Verification, Semantics, Debugging  
Address: Corso Italia 40, 56125 Pisa, Italy  Baronissi (Salerno), Italy  
Affiliation: Dipartimento di Informatica, Universita di Pisa,  Dipartimento di Informatica ed Applicazioni, Universita di Salerno,  
Abstract: We extend the declarative diagnosis methods to the diagnosis w.r.t. computed answers. We show that absence of uncovered atoms implies completeness for a large class of programs. We then define a top-down diagnoser, which uses one oracle only, does not require to determine in advance the symptoms and is driven by a (finite) set of goals. Finally we tackle the problem of effectivity, by introducing (finite) partial specifications. We obtain an effective diagnosis method, which is weaker than the general one in the case of correctness, yet can efficiently be implemented in both a top-down and in a bottom-up style. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. R. Apt and D. Pedreschi. </author> <title> Reasoning about termination of pure PROLOG programs. </title> <journal> Information and Computation, </journal> <volume> 106(1) </volume> <pages> 109-157, </pages> <year> 1993. </year>
Reference-contexts: Then P is totally correct w.r.t. I, if and only if there are no incorrect clauses and uncovered atoms. The requirement on T P seems to be very strong. However, this property holds for a large class of programs, i.e., for acceptable programs as defined in <ref> [1] </ref>. Acceptable programs are the left-terminating programs, i.e., those programs for which the SLD -derivations of ground goals (via the leftmost selection rule) are finite. Most interesting programs are acceptable (all the pure PROLOG programs in [14] are reported in [1] to be acceptable). <p> class of programs, i.e., for acceptable programs as defined in <ref> [1] </ref>. Acceptable programs are the left-terminating programs, i.e., those programs for which the SLD -derivations of ground goals (via the leftmost selection rule) are finite. Most interesting programs are acceptable (all the pure PROLOG programs in [14] are reported in [1] to be acceptable). The same property holds for most of the wrong versions of acceptable programs, since most "natural" errors do not affect the left-termination property. One relevant technical property of acceptable programs is that the ground immediate consequences operator has a unique fixpoint [1]. <p> in [14] are reported in <ref> [1] </ref> to be acceptable). The same property holds for most of the wrong versions of acceptable programs, since most "natural" errors do not affect the left-termination property. One relevant technical property of acceptable programs is that the ground immediate consequences operator has a unique fixpoint [1]. The same property holds for the s-semantics operator T P . Theorem 3.9 (fixpoint uniqueness) Let P be an acceptable program. Then T P "! is the unique fixpoint of T P . The theorem is proved in [4] for all the "immediate consequences" operators corresponding to s-observables.
Reference: [2] <author> A. Bossi, M. Gabbrielli, G. Levi, and M. Martelli. </author> <title> The s-semantics approach: </title> <journal> Theory and applications. Journal of Logic Programming, </journal> <volume> 19-20:149-197, </volume> <year> 1994. </year>
Reference-contexts: The semantics involved in the diagnosis w.r.t. computed answers is the s-semantics <ref> [6, 7, 2] </ref>, which models exactly the process of computing answers. In this paper we first extend to computed answers the declarative diagnosis methods based on the detection of incorrect clauses and uncovered atoms (Section 3). <p> We obtain an effective diagnosis method, which is weaker than the general one in the case of correctness, yet can efficiently be implemented in both a top-down and in a bottom-up style. 2 The semantics modeling computed answers The s-semantics <ref> [6, 7, 2] </ref> is defined on interpretations consisting of sets of possibly non-ground atoms.
Reference: [3] <author> M. Comini and G. Levi. </author> <title> An algebraic theory of observables. </title> <editor> In M. Bruynooghe, editor, </editor> <booktitle> Proceedings of the 1994 Int'l Symposium on Logic Programming, </booktitle> <pages> pages 172-186. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1994. </year>
Reference-contexts: The following theorems are instances of the corresponding theorems proved in [5] for abstract diagnosis, where they are given for a class of properties called s-observables (computed answers is an s-observable <ref> [3] </ref>). The first theorem shows the relation between partial correctness (Definition 3.1) and absence of incorrect clauses (Definition 3.3). Theorem 3.5 If there are no incorrect clauses in P , then P is partially correct (hence there are no incorrectness symptoms). The converse does not hold.
Reference: [4] <author> M. Comini, G. Levi, and G. Vitiello. </author> <title> Abstract debugging of logic programs. </title> <editor> In L. Fri-bourg and F. Turini, editors, </editor> <booktitle> Proc. Logic Program Synthesis and Transformation and Metaprogramming in Logic 1994, volume 883 of Lecture Notes in Computer Science, </booktitle> <pages> pages 440-450. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1994. </year>
Reference-contexts: Declarative diagnosis [13, 12, 10, 8] is concerned with model-theoretic properties. The specification is the intended declarative semantics (the least Herbrand model in [13] and the set of atomic logical consequences in [8]). Abstract diagnosis <ref> [4, 5] </ref> is a generalization of declarative diagnosis, where we consider operational properties, i.e., observables (an observable is any property which can be extracted from a goal computation, i.e., observables are abstractions of SLD-trees). An example of a useful observable is computed answers. <p> The same property holds for the s-semantics operator T P . Theorem 3.9 (fixpoint uniqueness) Let P be an acceptable program. Then T P "! is the unique fixpoint of T P . The theorem is proved in <ref> [4] </ref> for all the "immediate consequences" operators corresponding to s-observables. Note that the same result applies to declarative diagnosis as well. The overall diagnosis method for acceptable programs is then given by the following corollary. Corollary 3.10 Assume P is an acceptable program. Then P is totally correct w.r.t. <p> The problem can only be solved if we have the ability to handle finite approximations of the intended semantics. One solution can be found within the abstract diagnosis framework in <ref> [4, 5] </ref>, where we are able to cope with abstractions of the observables (according to abstract interpretation theory). Here we propose a different solution, where we approximate the intended behavior by a (finite) partial specification.
Reference: [5] <author> M. Comini, G. Levi, and G. Vitiello. </author> <title> Efficent detection of incompleteness errors in the abstract debugging of logic programs. </title> <booktitle> In Proc. 2nd International Workshop on Automated and Algoritmic Debugging, </booktitle> <year> 1995. </year>
Reference-contexts: Declarative diagnosis [13, 12, 10, 8] is concerned with model-theoretic properties. The specification is the intended declarative semantics (the least Herbrand model in [13] and the set of atomic logical consequences in [8]). Abstract diagnosis <ref> [4, 5] </ref> is a generalization of declarative diagnosis, where we consider operational properties, i.e., observables (an observable is any property which can be extracted from a goal computation, i.e., observables are abstractions of SLD-trees). An example of a useful observable is computed answers. <p> An example of a useful observable is computed answers. The diagnosis w.r.t. computed answers is expected to be more precise than the declarative diagnoses in [13] and [8], which can be reconstructed in terms of the observables ground instances of computed answers and correct answers respectively <ref> [5] </ref>. The semantics involved in the diagnosis w.r.t. computed answers is the s-semantics [6, 7, 2], which models exactly the process of computing answers. In this paper we first extend to computed answers the declarative diagnosis methods based on the detection of incorrect clauses and uncovered atoms (Section 3). <p> As we will show in the following, the detection of bugs can be based on Definitions 3.3 and 3.4, while this is not the case for Definition 3.2. The following theorems are instances of the corresponding theorems proved in <ref> [5] </ref> for abstract diagnosis, where they are given for a class of properties called s-observables (computed answers is an s-observable [3]). The first theorem shows the relation between partial correctness (Definition 3.1) and absence of incorrect clauses (Definition 3.3). <p> The problem can only be solved if we have the ability to handle finite approximations of the intended semantics. One solution can be found within the abstract diagnosis framework in <ref> [4, 5] </ref>, where we are able to cope with abstractions of the observables (according to abstract interpretation theory). Here we propose a different solution, where we approximate the intended behavior by a (finite) partial specification.
Reference: [6] <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> Declarative Modeling of the Operational Behavior of Logic Languages. </title> <journal> Theoretical Computer Science, </journal> <volume> 69(3) </volume> <pages> 289-318, </pages> <year> 1989. </year>
Reference-contexts: The semantics involved in the diagnosis w.r.t. computed answers is the s-semantics <ref> [6, 7, 2] </ref>, which models exactly the process of computing answers. In this paper we first extend to computed answers the declarative diagnosis methods based on the detection of incorrect clauses and uncovered atoms (Section 3). <p> We obtain an effective diagnosis method, which is weaker than the general one in the case of correctness, yet can efficiently be implemented in both a top-down and in a bottom-up style. 2 The semantics modeling computed answers The s-semantics <ref> [6, 7, 2] </ref> is defined on interpretations consisting of sets of possibly non-ground atoms.
Reference: [7] <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> A Model-Theoretic Reconstruction of the Operational Semantics of Logic Programs. </title> <journal> Information and Computation, </journal> <volume> 102(1) </volume> <pages> 86-113, </pages> <year> 1993. </year>
Reference-contexts: The semantics involved in the diagnosis w.r.t. computed answers is the s-semantics <ref> [6, 7, 2] </ref>, which models exactly the process of computing answers. In this paper we first extend to computed answers the declarative diagnosis methods based on the detection of incorrect clauses and uncovered atoms (Section 3). <p> We obtain an effective diagnosis method, which is weaker than the general one in the case of correctness, yet can efficiently be implemented in both a top-down and in a bottom-up style. 2 The semantics modeling computed answers The s-semantics <ref> [6, 7, 2] </ref> is defined on interpretations consisting of sets of possibly non-ground atoms.
Reference: [8] <author> G. Ferrand. </author> <title> Error Diagnosis in Logic Programming, an Adaptation of E. Y. Shapiro's Method. </title> <journal> Journal of Logic Programming, </journal> <volume> 4 </volume> <pages> 177-198, </pages> <year> 1987. </year>
Reference-contexts: The diagnosis consists of comparing [[P ]] and I and determining the "errors" and the program components which are sources of errors, when [[P ]] 6= I. The formulation is parametric w.r.t. the property considered in the specification I and in the actual behavior [[P ]]. Declarative diagnosis <ref> [13, 12, 10, 8] </ref> is concerned with model-theoretic properties. The specification is the intended declarative semantics (the least Herbrand model in [13] and the set of atomic logical consequences in [8]). <p> Declarative diagnosis [13, 12, 10, 8] is concerned with model-theoretic properties. The specification is the intended declarative semantics (the least Herbrand model in [13] and the set of atomic logical consequences in <ref> [8] </ref>). Abstract diagnosis [4, 5] is a generalization of declarative diagnosis, where we consider operational properties, i.e., observables (an observable is any property which can be extracted from a goal computation, i.e., observables are abstractions of SLD-trees). An example of a useful observable is computed answers. <p> An example of a useful observable is computed answers. The diagnosis w.r.t. computed answers is expected to be more precise than the declarative diagnoses in [13] and <ref> [8] </ref>, which can be reconstructed in terms of the observables ground instances of computed answers and correct answers respectively [5]. The semantics involved in the diagnosis w.r.t. computed answers is the s-semantics [6, 7, 2], which models exactly the process of computing answers. <p> ; : : : ; X n are distinct variables; ? p (X 1 ; : : : ; X n ) ! 2g: 3 Diagnosis w.r.t. computed answers: basic defi- nitions and results The following Definitions 3.1 and 3.2 extend to diagnosis w.r.t. computed answers the definitions given in <ref> [13, 8, 10] </ref> for declarative diagnosis. In the following I is the specification of the intended s-semantics of P . Definition 3.1 i. P is partially correct w.r.t. I, if O (P ) I. ii. P is complete w.r.t. I, if I O (P ). iii. <p> An incompleteness symptom is an atom A such that A 2 I and A 62 O (P ). Note that a totally correct program has no incorrectness and no incompleteness symptoms. Our incompleteness symptoms are related to the insufficiency symptoms in <ref> [8] </ref>, which are defined by taking gfp (T P ) instead of O (P ) = lfp (T P ) as program semantics. The two definitions, even if different, turn out to be the same for the class of programs we are interested in (see Section 3). <p> I (there are no incompleteness symptoms). The converse does not hold. Note that, if T P has a unique fixpoint, lfp (T P ) = gfp (T P ). Hence our incompleteness symptoms are exactly the insufficiency symptoms in <ref> [8] </ref>. The following corollary is a justification of the overall diagnosis method. Corollary 3.8 Assume T P has a unique fixpoint. Then P is totally correct w.r.t. I, if and only if there are no incorrect clauses and uncovered atoms. The requirement on T P seems to be very strong. <p> Most of the techniques presented in [11] are applicable. However, performance issues are outside the scope of this paper. Let us finally note that our formalization of diagnosis based on the s-semantics is not subject to the theoretical limitations proved by Ferrand <ref> [8] </ref> for his construction based on the atomic logical consequences semantics. The problem is the following. An incorrect clause instance A : B may have an instance (A : B) which is not incorrect. <p> This should be reflected by the fact that incorrect (A : B) is in the denotation of the diagnoser, while incorrect ((A : B)) is not. This is not possible if the denotation is the non-ground semantics in <ref> [8] </ref>, since it is closed under instantiation. On the contrary, if we choose the s-semantics the problem does not arise. 5 Diagnosis with partial specifications The diagnosis cannot effectively be based on the conditions given above, unless the intended s-semantics is finite.
Reference: [9] <author> G. Ferrand. </author> <title> The notions of symptom and error in declarative diagnosis of logic programs. </title> <editor> In P. A. Fritzson, editor, </editor> <booktitle> Automated and Algorithmic Debugging, Proc. AADEBUG '93, volume 749 of Lecture Notes in Computer Science, </booktitle> <pages> pages 40-57. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1993. </year>
Reference-contexts: Ferrand's choice is motivated by the fact that gfp (T P ) is related to finite failures. The approach of using two different semantics for reasoning about incorrectness and incompleteness has been pursued in <ref> [9] </ref>, leading to an elegant uniform (yet non-effective) characterization of correctness and completeness. It is straightforward to realize that an atom may sometimes be an (incorrectness or incompleteness) symptom, just because of another symptom. <p> Note also that definition 5.1 is derived from Definition 3.1 by taking I and I + as specifications to be used for correctness and completeness respectively. Positive and negative specifications have been used in <ref> [9] </ref> with the aim of separately modeling the behavior w.r.t. incorrectness and incompleteness. I + and I are not partial specifications, rather they are specifications of the (complete) intended lfp (T P ) and of the (complete) intended gfp (T P ).
Reference: [10] <author> J. W. Lloyd. </author> <title> Declarative error diagnosis. </title> <journal> New Generation Computing, </journal> <volume> 5(2) </volume> <pages> 133-154, </pages> <year> 1987. </year>
Reference-contexts: The diagnosis consists of comparing [[P ]] and I and determining the "errors" and the program components which are sources of errors, when [[P ]] 6= I. The formulation is parametric w.r.t. the property considered in the specification I and in the actual behavior [[P ]]. Declarative diagnosis <ref> [13, 12, 10, 8] </ref> is concerned with model-theoretic properties. The specification is the intended declarative semantics (the least Herbrand model in [13] and the set of atomic logical consequences in [8]). <p> ; : : : ; X n are distinct variables; ? p (X 1 ; : : : ; X n ) ! 2g: 3 Diagnosis w.r.t. computed answers: basic defi- nitions and results The following Definitions 3.1 and 3.2 extend to diagnosis w.r.t. computed answers the definitions given in <ref> [13, 8, 10] </ref> for declarative diagnosis. In the following I is the specification of the intended s-semantics of P . Definition 3.1 i. P is partially correct w.r.t. I, if O (P ) I. ii. P is complete w.r.t. I, if I O (P ). iii.
Reference: [11] <author> L. Naish. </author> <title> Declarative diagnosis of missing answers. </title> <journal> New Generation Computing, </journal> <volume> 10 </volume> <pages> 255-285, </pages> <year> 1991. </year>
Reference-contexts: Rather we are concerned with the problem of specifying I by means of an oracle, as first suggested in [13]. The oracle is usually implemented by querying the user. Several oracles have been used in declarative debugging (see the discussion in <ref> [11] </ref>). We will use one oracle only, directly related to the property we are concerned with, namely computed answers. Definition 4.1 (oracle) Let G be a goal. A (G) = fG j G computes according to the intended s-semanticsg. <p> The same properties allow us to define systematic diagnosis algorithms which do not need symptoms as inputs. The PROLOG meta-program in Figure 2 is an adaptation of the simplest possible declarative debugger in <ref> [11] </ref>. The oracle answer nondeterministically instantiates its argument. The search for incorrect clause instances and uncovered atoms is driven by the most general atomic goals, represented by unit clauses of the form userdefined (p (X1; :::; Xn)):, for any predicate p occurring in the program P . <p> The diagnosis meta-program can be extended to achieve a better performance and to improve the calls to the oracle. Most of the techniques presented in <ref> [11] </ref> are applicable. However, performance issues are outside the scope of this paper. Let us finally note that our formalization of diagnosis based on the s-semantics is not subject to the theoretical limitations proved by Ferrand [8] for his construction based on the atomic logical consequences semantics.
Reference: [12] <author> L. M. Pereira. </author> <title> Rational debugging in logic programming. </title> <editor> In E. Y. Shapiro, editor, </editor> <booktitle> Proceedings of the 3rd International Conference on Logic Programming, volume 225 of Lecture Notes in Computer Science, </booktitle> <pages> pages 203-210. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1986. </year>
Reference-contexts: The diagnosis consists of comparing [[P ]] and I and determining the "errors" and the program components which are sources of errors, when [[P ]] 6= I. The formulation is parametric w.r.t. the property considered in the specification I and in the actual behavior [[P ]]. Declarative diagnosis <ref> [13, 12, 10, 8] </ref> is concerned with model-theoretic properties. The specification is the intended declarative semantics (the least Herbrand model in [13] and the set of atomic logical consequences in [8]).
Reference: [13] <author> E. Y. Shapiro. </author> <title> Algorithmic program debugging. </title> <booktitle> In Proc. Ninth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 412-531. </pages> <publisher> ACM Press, </publisher> <year> 1982. </year>
Reference-contexts: The diagnosis consists of comparing [[P ]] and I and determining the "errors" and the program components which are sources of errors, when [[P ]] 6= I. The formulation is parametric w.r.t. the property considered in the specification I and in the actual behavior [[P ]]. Declarative diagnosis <ref> [13, 12, 10, 8] </ref> is concerned with model-theoretic properties. The specification is the intended declarative semantics (the least Herbrand model in [13] and the set of atomic logical consequences in [8]). <p> The formulation is parametric w.r.t. the property considered in the specification I and in the actual behavior [[P ]]. Declarative diagnosis [13, 12, 10, 8] is concerned with model-theoretic properties. The specification is the intended declarative semantics (the least Herbrand model in <ref> [13] </ref> and the set of atomic logical consequences in [8]). Abstract diagnosis [4, 5] is a generalization of declarative diagnosis, where we consider operational properties, i.e., observables (an observable is any property which can be extracted from a goal computation, i.e., observables are abstractions of SLD-trees). <p> An example of a useful observable is computed answers. The diagnosis w.r.t. computed answers is expected to be more precise than the declarative diagnoses in <ref> [13] </ref> and [8], which can be reconstructed in terms of the observables ground instances of computed answers and correct answers respectively [5]. The semantics involved in the diagnosis w.r.t. computed answers is the s-semantics [6, 7, 2], which models exactly the process of computing answers. <p> ; : : : ; X n are distinct variables; ? p (X 1 ; : : : ; X n ) ! 2g: 3 Diagnosis w.r.t. computed answers: basic defi- nitions and results The following Definitions 3.1 and 3.2 extend to diagnosis w.r.t. computed answers the definitions given in <ref> [13, 8, 10] </ref> for declarative diagnosis. In the following I is the specification of the intended s-semantics of P . Definition 3.1 i. P is partially correct w.r.t. I, if O (P ) I. ii. P is complete w.r.t. I, if I O (P ). iii. <p> Hence I has to be specified in an extensional way. We are not concerned, for the time being, with the problem of effectivity (i.e., finiteness of I). Rather we are concerned with the problem of specifying I by means of an oracle, as first suggested in <ref> [13] </ref>. The oracle is usually implemented by querying the user. Several oracles have been used in declarative debugging (see the discussion in [11]). We will use one oracle only, directly related to the property we are concerned with, namely computed answers. Definition 4.1 (oracle) Let G be a goal. <p> Definition 4.1 (oracle) Let G be a goal. A (G) = fG j G computes according to the intended s-semanticsg. Once we have the oracle, we can define the oracle simulation, again following <ref> [13] </ref>. The oracle simulation allows us to express in a compact way new top-down diagnosis conditions. The oracle simulation performs one step of goal rewriting by using the program clauses and then gets the answers for the resulting goal from the oracle. <p> This is true also for those diagnosis algorithms which are based on a ground semantics or are driven by the symptoms. As a matter of fact, the assumption in <ref> [13] </ref> on the oracle returning a finite number of answers is too strong. The problem can only be solved if we have the ability to handle finite approximations of the intended semantics.
Reference: [14] <author> L. Sterling and E. Y. Shapiro. </author> <title> The Art of Prolog. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1986. </year>
Reference-contexts: Acceptable programs are the left-terminating programs, i.e., those programs for which the SLD -derivations of ground goals (via the leftmost selection rule) are finite. Most interesting programs are acceptable (all the pure PROLOG programs in <ref> [14] </ref> are reported in [1] to be acceptable). The same property holds for most of the wrong versions of acceptable programs, since most "natural" errors do not affect the left-termination property. One relevant technical property of acceptable programs is that the ground immediate consequences operator has a unique fixpoint [1].
References-found: 14

