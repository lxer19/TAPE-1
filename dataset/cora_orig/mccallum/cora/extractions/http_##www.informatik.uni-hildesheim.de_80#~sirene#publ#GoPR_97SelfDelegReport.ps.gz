URL: http://www.informatik.uni-hildesheim.de:80/~sirene/publ/GoPR_97SelfDelegReport.ps.gz
Refering-URL: http://www.informatik.uni-hildesheim.de:80/~sirene/lit/sirene.lit.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: E-mail: oded@wisdom.weizmann.ac.il.  Email: pfitzmann@cs.uni-sb.de.  Email: rivest@theory.lcs.mit.edu. Sup  
Title: Self-Delegation with Controlled Propagation or- What If You Lose Your Laptop  
Author: Oded Goldreich Birgit Pfitzmann Ronald L. Rivest 
Keyword: Delegation, subkeys, key hierarchy, Zero-Knowledge Proofs, Knowledge Complexity, Threshold Schemes, gradual release of secrets, Signature Schemes, Non-Interactive Zero-Knowledge, Commitment Schemes.  
Note: Currently visiting LCS, MIT. Partially supported by DARPA grant DABT63-96-C-0018.  Work partially done while visiting MIT and partially at the University of Hildesheim. Supported by DFG (German Research Foundation).  ported by DARPA grant DABT63-96-C-0018.  
Address: Rehovot, Israel.  D-66123 Saarbrucken, Germany.  Cambridge, Mass., USA.  
Affiliation: Department of Computer Science and Applied Mathematics, Weizmann Institute of Science,  Universitat des Saarlandes, Fachbereich Informatik,  Laboratory for Computer Science, MIT,  
Date: September 1997  
Abstract: We introduce delegation schemes wherein a user may delegate rights to himself, i.e., to other public keys he owns, but may not safely delegate those rights to others, i.e., to their public keys. In our motivating application, a user has a primary (long-term) key that receives rights, such as access privileges, that may not be delegated to others, yet the user may reasonably wish to delegate these rights to new secondary (short-term) keys he creates to use on his laptop when traveling, to avoid having to store his primary secret key on the vulnerable laptop. We propose several cryptographic schemes, both generic and practical, that allow such self-delegation while providing strong motivation for the user not to delegate rights that he only obtained for personal use to other parties. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Bellare and O. Goldreich: </author> <title> On Defining Proofs of Knowledge; in Crypto '92, </title> <journal> Springer-Verlag, </journal> <volume> LNCS Vol. 740, </volume> <pages> pp. 390-420, </pages> <year> 1992. </year>
Reference-contexts: 2 of sk and r l ; Recall that the authorization of the secondary key by the user himself, e.g., by signing (l; pk l ) using sk, is done outside this core part of our scheme. * Verification: The user gives the verifier an (interactive) zero-knowledge proof of knowledge <ref> [15, 1] </ref> that he knows ( l ; l ) such that l is a valid non-interactive zero-knowledge proof with respect to Ref and pk (which the verifier also knows) and the secret l . 7 An issue left open is how the r l 's become available when the set
Reference: [2] <author> M. Bellare and P. Rogaway: </author> <title> Random oracles are practical: a paradigm for designing efficient protocols; in Proceedings of 1st Annual Conference on Computer and Communications Security, </title> <booktitle> ACM, </booktitle> <pages> pp. 62-73, </pages> <year> 1993. </year>
Reference-contexts: If we only consider polynomial-time adversaries, the server can use a pseudo-random function [12] instead of choosing and storing real random values. In practice, one may use a concrete publicly available function, typically a hash function, which is believed to "behave randomly" (cf. <ref> [10, 2] </ref>). Actually, we merely need a specific "random behaviour" as postulated in Assumption 1 below. To quantify what is leaked by a single secondary key triple, we refer to the formalism of knowledge complexity [15, 14].
Reference: [3] <author> M. Blum: </author> <title> How to Exchange (Secret) Keys; ACM Transactions on Computer Systems, </title> <journal> Vol. </journal> <volume> 1, No. 2, </volume> <pages> pp. 175-193, </pages> <year> 1983. </year>
Reference-contexts: to whom the user gives, in violation of the controlled propagation requirement, many secondary secret keys should be able to find the user's primary secret key.) Thus, what the user has to put into l is related to the gradual release of a secret, as introduced for secret exchange in <ref> [3] </ref>, with the difference that in our case the people who get the pieces of information and those who verify their correctness are different and do not trust each other.
Reference: [4] <author> M. Blum, P. Feldman, and S. Micali: </author> <booktitle> Non-Interactive Zero-Knowledge and its Applications; in 20th STOC, </booktitle> <pages> pp. 103-112, </pages> <year> 1988. </year>
Reference-contexts: We present several constructions achieving such a balance. They are categorized by the following parameters: * Generic vs. specific: In Section 3, we present generic schemes which apply to any primary and secondary keys. These scheme rely on non-interactive zero-knowledge proofs <ref> [4] </ref> and thus on the existence of trapdoor one-way permutations [7, 16]. <p> Hence this part of the proof will be precomputed in the secondary key validation protocol. We use a non-interactive zero-knowledge proof system <ref> [4] </ref> for this.
Reference: [5] <author> D. Chaum, J.-H. Evertse, and J. van de Graaf: </author> <title> An improved protocol for demonstrating possession of discrete logarithms and some generalizations; in Eurocrypt '87, </title> <journal> Springer-Verlag, </journal> <volume> LNCS Vol. 304, </volume> <pages> pp. 127-141, </pages> <year> 1988. </year>
Reference-contexts: Now the user has to give a proof of knowledge of sk fl l , i.e., of the discrete logarithm of pk fl l . The proof better be in zero-knowledge. The system from <ref> [5] </ref> is quite efficient, but it needs t rounds of communication (each with one exponentiation on both sides) for a security level of 2 t . Actually, some of these can be executed in parallel with the usual trade-off between amount of parallelism and tightness of the security, cf. [10].
Reference: [6] <editor> The Digital Signature Standard Proposed by NIST; Communications of the ACM, </editor> <volume> Vol. 35, No. 7, </volume> <pages> pp. 36-40, </pages> <year> 1992. </year>
Reference-contexts: These scheme rely on non-interactive zero-knowledge proofs [4] and thus on the existence of trapdoor one-way permutations [7, 16]. In Section 4, we present more specific and efficient constructions where the primary secret key pair must belong to a discrete-logarithm based cryptographic scheme like Schnorr or DSS signatures <ref> [19, 6] </ref>. * Gradual vs. threshold: In Constructions 1 and 2, the security of the primary secret key degrades gradually with the number of secondary secret keys available to an adversary until the primary secret key is totally revealed. <p> Important examples are Schnorr and DSS signatures <ref> [19, 6] </ref>. The advantage over the schemes in the previous section is that no general zero-knowledge proof techniques are needed, and the resulting self-delegation schemes are not much less efficient than the underlying schemes.
Reference: [7] <author> U. Feige, D. Lapidot, and A. Shamir: </author> <title> Multiple non-interactive zero knowledge proofs based on a single random string; in 31st FOCS, </title> <journal> pp. </journal> <pages> 308-317, </pages> <year> 1990. </year>
Reference-contexts: They are categorized by the following parameters: * Generic vs. specific: In Section 3, we present generic schemes which apply to any primary and secondary keys. These scheme rely on non-interactive zero-knowledge proofs [4] and thus on the existence of trapdoor one-way permutations <ref> [7, 16] </ref>. <p> We use a non-interactive zero-knowledge proof system [4] for this. In the following, we assume that we are given such a proof system where one common random string Ref can be used for an arbitrary number of proofs <ref> [7] </ref>. (This result also applies to the more efficient basic construction in [16].) In schemes with a small bounded set of limitations indices, we could improve efficiency by using a non-interactive zero-knowledge system without this property, i.e., capable of only proving one assertion, and providing enough reference strings in advance.
Reference: [8] <author> P. Feldman: </author> <title> A practical scheme for non-interactive verifiable secret sharing; in 20th FOCS, </title> <journal> pp. </journal> <pages> 427-437, </pages> <year> 1987. </year>
Reference-contexts: The basic idea in the following schemes is somewhat similar to the Verifiable Secret Sharing scheme based on discrete logarithms <ref> [8, 18] </ref>. Each valid secondary key triple will give one linear combination of the shares, such that enough secondary keys will yield an equation system that can be uniquely solved for the shares and thus for the primary secret key.
Reference: [9] <author> U. Feige and A. Shamir: </author> <booktitle> Witness Indistinguishability and Witness Hiding Protocols; inn 22nd STOC, </booktitle> <pages> pp. 416-426, </pages> <year> 1990. </year>
Reference-contexts: However, t need not be very large, because we do not try to exclude every single case of propagation anyway. An alternative is Schnorr identification [19], which needs only one exponentiation on each side, but is only known to be witness-hiding <ref> [9] </ref>. As stated above, a way of using this core scheme is to use the values sk fl l directly as the secondary secret keys. This improves efficiency in case we can omit the proof of knowledge (as the subsequent usage of sk fl l establishes knowledge of it).
Reference: [10] <author> A. Fiat and A. Shamir: </author> <title> How to Prove Yourself: Practical Solutions to Identification and Signature Problems; in Crypto '86, </title> <journal> Springer-Verlag, </journal> <volume> LNCS Vol. 263, </volume> <pages> pp. 186-194, </pages> <year> 1987. </year>
Reference-contexts: If we only consider polynomial-time adversaries, the server can use a pseudo-random function [12] instead of choosing and storing real random values. In practice, one may use a concrete publicly available function, typically a hash function, which is believed to "behave randomly" (cf. <ref> [10, 2] </ref>). Actually, we merely need a specific "random behaviour" as postulated in Assumption 1 below. To quantify what is leaked by a single secondary key triple, we refer to the formalism of knowledge complexity [15, 14]. <p> Actually, some of these can be executed in parallel with the usual trade-off between amount of parallelism and tightness of the security, cf. <ref> [10] </ref>. However, t need not be very large, because we do not try to exclude every single case of propagation anyway. An alternative is Schnorr identification [19], which needs only one exponentiation on each side, but is only known to be witness-hiding [9].
Reference: [11] <author> M. Gasser, A. Goldstein, Ch. Kaufman, and B. Lampson: </author> <booktitle> The Digital Distributed System Security Architecture; in Proceedings of 12th National Computer Security Conference, </booktitle> <pages> pp. 305-319, </pages> <year> 1989. </year>
Reference-contexts: Certain extensions come easily to mind, e.g., the delegation certificate may limit the delegated authority to certain applications or to transactions of restricted value. Related schemes are well-known in the literature, e.g., <ref> [11] </ref> where primary keys are held on smartcards and authority is temporarily delegated to secondary keys on work stations. Such use of delegation certificates, however, is in conflict with the interests of service providers to prevent the propagation of certain rights and benefits.
Reference: [12] <author> O. Goldreich, S. Goldwasser, S. Micali: </author> <title> How to Construct Random Functions; Journal of the ACM, </title> <journal> Vol. </journal> <volume> 33, No. 4, </volume> <pages> pp. 792-807, </pages> <year> 1986. </year> <note> Extended abstract in 25th FOCS, </note> <year> 1984. </year>
Reference-contexts: In this case, we need a random function mapping limitations indices to n-bit strings. One possibility is to have the server maintain a "trusted beacon" which implements such a function. If we only consider polynomial-time adversaries, the server can use a pseudo-random function <ref> [12] </ref> instead of choosing and storing real random values. In practice, one may use a concrete publicly available function, typically a hash function, which is believed to "behave randomly" (cf. [10, 2]). Actually, we merely need a specific "random behaviour" as postulated in Assumption 1 below.
Reference: [13] <author> O. Goldreich, S. Micali, and A. Wigderson: </author> <title> Proofs that Yield Nothing but their Validity or All Languages in NP Have Zero-Knowledge Proof Systems; Journal of the ACM, </title> <journal> Vol. </journal> <volume> 38, No. 1, </volume> <pages> pp. 691-729, </pages> <year> 1991. </year> <note> Extended abstract in 27th FOCS, </note> <year> 1986. </year>
Reference: [14] <author> O. Goldreich and E. </author> <title> Petrank: </title> <booktitle> Quantifying Knowledge Complexity; in 32nd FOCS, </booktitle> <pages> pp. 59-68, </pages> <year> 1991. </year> <note> To appear in Computational Complexity. </note>
Reference-contexts: Actually, we merely need a specific "random behaviour" as postulated in Assumption 1 below. To quantify what is leaked by a single secondary key triple, we refer to the formalism of knowledge complexity <ref> [15, 14] </ref>. <p> The claim holds since l is merely a bit and l is merely a zero-knowledge proof referring to l and the primary public key pk. (Recall that knowledge complexity is always bounded by the actual length of objects and that it is at most additive <ref> [14] </ref>.) Note that the user need not trust the server except with the random selection of Ref : What we showed so far does not rely on the randomness of the r l 's.
Reference: [15] <author> S. Goldwasser, S. Micali, and C. </author> <title> Rackoff: </title> <journal> The Knowledge Complexity of Interactive Proof Systems; SIAM Journal on Computing, </journal> <volume> Vol. 18, No. 1, </volume> <pages> pp. 186-208, </pages> <year> 1989. </year> <note> Extended abstract in 17th STOC, </note> <year> 1985. </year>
Reference-contexts: 2 of sk and r l ; Recall that the authorization of the secondary key by the user himself, e.g., by signing (l; pk l ) using sk, is done outside this core part of our scheme. * Verification: The user gives the verifier an (interactive) zero-knowledge proof of knowledge <ref> [15, 1] </ref> that he knows ( l ; l ) such that l is a valid non-interactive zero-knowledge proof with respect to Ref and pk (which the verifier also knows) and the secret l . 7 An issue left open is how the r l 's become available when the set <p> Actually, we merely need a specific "random behaviour" as postulated in Assumption 1 below. To quantify what is leaked by a single secondary key triple, we refer to the formalism of knowledge complexity <ref> [15, 14] </ref>.
Reference: [16] <author> J. Kilian and E. Petrank: </author> <title> An Efficient Non-Interactive Zero-Knowledge Proof System for NP with General Assumptions; to appear in Journal of Cryptography. </title> <note> Available as TR95-038 of ECCC (Electronic Colloquium on Computational Complexity), http://www.eccc.uni-trier.de/eccc/, 1995. </note>
Reference-contexts: They are categorized by the following parameters: * Generic vs. specific: In Section 3, we present generic schemes which apply to any primary and secondary keys. These scheme rely on non-interactive zero-knowledge proofs [4] and thus on the existence of trapdoor one-way permutations <ref> [7, 16] </ref>. <p> In the following, we assume that we are given such a proof system where one common random string Ref can be used for an arbitrary number of proofs [7]. (This result also applies to the more efficient basic construction in <ref> [16] </ref>.) In schemes with a small bounded set of limitations indices, we could improve efficiency by using a non-interactive zero-knowledge system without this property, i.e., capable of only proving one assertion, and providing enough reference strings in advance.
Reference: [17] <author> M. </author> <title> Naor: </title> <journal> Bit Commitment Using Pseudorandomness; Journal of Cryptology, </journal> <volume> Vol. 4, No. 2, </volume> <pages> pp. 151-158, </pages> <year> 1991. </year>
Reference-contexts: The following lemma shows that the requirement of unique secret keys is no serious restriction. Lemma 1 Any cryptographic scheme where only computational secrecy of sk is required can be transformed into one with unique secret keys. Proof sketch: We use the commitment scheme from <ref> [17] </ref>. It is unconditionally binding, has a non-interactive opening stage, and can be based on any one-way function. In the commit stage, a random number is needed which may be chosen by a trusted server once and for all (see Section 5 in [17]). <p> sketch: We use the commitment scheme from <ref> [17] </ref>. It is unconditionally binding, has a non-interactive opening stage, and can be based on any one-way function. In the commit stage, a random number is needed which may be chosen by a trusted server once and for all (see Section 5 in [17]). We modify the given cryptographic scheme by adding a commitment C on sk to the original public key pk and adding to aux the string open needed to open the commitment. The other algorithms of the scheme are not changed.
Reference: [18] <author> T. P. Pedersen: </author> <title> Non-Interactive and Information-Theoretic Secure Verifiable Secret Sharing; in Crypto '91, </title> <journal> Springer-Verlag, </journal> <volume> LNCS Vol. 576, </volume> <pages> pp. 129-140, </pages> <year> 1992. </year>
Reference-contexts: The basic idea in the following schemes is somewhat similar to the Verifiable Secret Sharing scheme based on discrete logarithms <ref> [8, 18] </ref>. Each valid secondary key triple will give one linear combination of the shares, such that enough secondary keys will yield an equation system that can be uniquely solved for the shares and thus for the primary secret key.
Reference: [19] <author> C. P. Schnorr: </author> <title> Efficient Signature Generation by Smart Cards; Journal of Cryptology, </title> <journal> Vol. </journal> <volume> 4, No. 3, </volume> <pages> pp. 161-174, </pages> <year> 1991. </year>
Reference-contexts: These scheme rely on non-interactive zero-knowledge proofs [4] and thus on the existence of trapdoor one-way permutations [7, 16]. In Section 4, we present more specific and efficient constructions where the primary secret key pair must belong to a discrete-logarithm based cryptographic scheme like Schnorr or DSS signatures <ref> [19, 6] </ref>. * Gradual vs. threshold: In Constructions 1 and 2, the security of the primary secret key degrades gradually with the number of secondary secret keys available to an adversary until the primary secret key is totally revealed. <p> Important examples are Schnorr and DSS signatures <ref> [19, 6] </ref>. The advantage over the schemes in the previous section is that no general zero-knowledge proof techniques are needed, and the resulting self-delegation schemes are not much less efficient than the underlying schemes. <p> Actually, some of these can be executed in parallel with the usual trade-off between amount of parallelism and tightness of the security, cf. [10]. However, t need not be very large, because we do not try to exclude every single case of propagation anyway. An alternative is Schnorr identification <ref> [19] </ref>, which needs only one exponentiation on each side, but is only known to be witness-hiding [9]. As stated above, a way of using this core scheme is to use the values sk fl l directly as the secondary secret keys.
Reference: [20] <author> A. Shamir: </author> <title> How to Share a Secret; Communications of the ACM, </title> <journal> Vol. </journal> <volume> 22, No. 11, </volume> <pages> pp. 612-613, </pages> <year> 1979. </year>
Reference-contexts: This corresponds to setting up a secret sharing scheme as in <ref> [20] </ref>. He makes a commitment C to all the non-constant coefficients using the given commitment scheme. Typically, the length of the commitment automatically shows that the content is a polynomial of degree k 1, otherwise this must be shown in zero-knowledge. <p> For Part 1, the security of the commitment scheme and the zero-knowledge proofs implies that the only non-negligible source of knowledge is in the values i . These are k 1 shares of a secret sharing scheme with threshold k and therefore give no information about the secret pk <ref> [20] </ref>. 2 4 Discrete-Logarithm Schemes We now present two versions of a practical self-delegation scheme for cryptographic schemes based on discrete logarithms in groups of prime order. Important examples are Schnorr and DSS signatures [19, 6].
References-found: 20

