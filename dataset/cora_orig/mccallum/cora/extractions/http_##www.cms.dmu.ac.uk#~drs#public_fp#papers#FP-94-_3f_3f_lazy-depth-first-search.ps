URL: http://www.cms.dmu.ac.uk/~drs/public_fp/papers/FP-94-%3f%3f_lazy-depth-first-search.ps
Refering-URL: http://www.cms.dmu.ac.uk/~drs/public_fp/papers/
Root-URL: 
Email: -gnik, jl-@dcs.glasgow.ac.uk  
Title: Lazy Depth-First Search and Linear Graph Algorithms in Haskell  
Author: David J. King John Launchbury 
Address: Glasgow  
Affiliation: Department of Computing Science University of  
Abstract: Depth-first search is the key to a wide variety of graph algorithms. In this paper we explore the implementation of depth first search in a lazy functional language. For the first time in such languages we obtain a linear-time implementation. But we go further. Unlike traditional imperative presentations, algorithms are constructed from individual components, which may be reused to create new algorithms. Furthermore, the style of program is quite amenable to formal proof, which we exemplify through a calculational-style proof of a strongly-connected components algorithm.
Abstract-found: 1
Intro-found: 1
Reference: <author> Barth, P. S., Nikhil, R. S. and Arvind (1991), M-structures: </author> <title> Extending a parallel, non-strict, functional language with state, </title> <editor> in J. Hughes, ed., </editor> <booktitle> `Conference on Functional Programming Languages and Computer Architecture', </booktitle> <publisher> LNCS 523, Springer-Verlag, </publisher> <address> Cambridge, Massachusetts, </address> <pages> pp. 538-568. </pages>
Reference: <author> Burton, F. W. and Yang, H.-K. </author> <year> (1990), </year> <title> `Manipulating multilinked data structures in a pure functional language', </title> <journal> Software|Practice and Experience 20, </journal> <pages> 1167-1185. </pages>
Reference: <author> Corman, T. H., Leiserson, C. E. and Rivest, R. L. </author> <year> (1990), </year> <title> Introduction to Algorithms, </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts. </address>
Reference: <author> Erwig, M. </author> <year> (1992), </year> <title> Graph algorithms = iteration + data structures? The structure of graph algorithms and a style of programming, </title> <editor> in E. Mayr, ed., </editor> <booktitle> `Graph-Theoretic Concepts in Computer Science', </booktitle> <publisher> LNCS 657, Springer-Verlag, </publisher> <pages> pp. 277-292. </pages>
Reference: <author> Harrison, R. </author> <year> (1993), </year> <title> Abstract data types in Standard ML, </title> <publisher> John Wiley and Sons. </publisher>
Reference: <author> Holyer, I. </author> <year> (1991), </year> <title> Functional programming with Miranda, </title> <publisher> Pitman, London. </publisher>
Reference: <author> Hopcroft, J. E. and Tarjan, R. E. </author> <year> (1973), </year> <title> `Algorithm 447: Efficient algorithms for graph manipulation', </title> <journal> Communications of the ACM 16(6), </journal> <pages> 372-378. </pages>
Reference: <author> Hudak, P., Peyton Jones, S. L., Wadler, P., Arvind, Boutel, B., Fairbairn, J., Fasel, J., Guzman, M. M., Hammond, K., Hughes, J., Johnsson, T., Kieburtz, R., Nikhil, R. S., Partain, W. and Peterson, J. </author> <year> (1992), </year> <title> `Report on the functional programming language Haskell, Version 1.2', </title> <journal> ACM SIGPLAN Notices 27(5). </journal>
Reference-contexts: We make use of recent advances in lazy functional languages which provide updatable state, as implemented within the Glasgow Haskell compiler. The compiler provides extensions to language Haskell <ref> (Hudak et al. 1992) </ref> providing updatable arrays, and allows these state-based actions to be encapsulated so that their external behaviour is purely functional. Consequently we obtain linear algorithms and yet retain the ability to perform purely functional reasoning on all but one reusable component.
Reference: <author> Kashiwagi, Y. and Wise, D. S. </author> <year> (1991), </year> <title> Graph algorithms in a lazy functional programming language, </title> <booktitle> in `Proceedings of the 4'th International Symposium on Lucid and Intensional Programming', </booktitle> <pages> pp. 35-46. </pages> <note> Also available as Technical Report Number 330, </note> <institution> Computer Science Department, Indiana University. </institution>
Reference: <author> Launchbury, J. </author> <year> (1993), </year> <title> Lazy imperative programming, </title> <booktitle> in `Workshop on State in Programming Languages', ACM SIGPLAN, Copenhagen, Denmark, </booktitle> <pages> pp. 46-56. </pages>
Reference: <author> Launchbury, J. and Peyton Jones, S. L. </author> <year> (1994), </year> <title> Lazy functional state threads, </title> <booktitle> in `Conference on Programming Language Design and Implementation', ACM SIGPLAN, </booktitle> <address> Orlando, Florida. </address>
Reference: <author> Manber, U. </author> <year> (1989), </year> <title> Introduction to Algorithms|A Creative Approach, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts. </address>
Reference: <author> Moggi, E. </author> <year> (1989), </year> <title> Computational lambda-calculus and monads, </title> <booktitle> in `Symposium on Logic in Computer Science', IEEE, Asilomar, </booktitle> <address> California. </address> <note> 23 Paulson, </note> <author> L. C. </author> <year> (1991), </year> <title> ML for the working programmer, </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge. </address>
Reference-contexts: This is what we do. We provide an explanation of state-transformers in the Appendix, but as they have already been described in a number of papers <ref> (Moggi 1989, Wadler 1990, Peyton Jones and Wadler 1993, Launchbury 1993) </ref>, and already been implemented in more than one Haskell variant, we avoid cluttering the main text.
Reference: <author> Peyton Jones, S. L. and Wadler, P. </author> <year> (1993), </year> <title> Imperative functional programming, </title> <booktitle> in `20'th Symposium on Principles of Programming Languages', ACM, </booktitle> <address> Charleston, </address> <publisher> North Carolina. </publisher>
Reference: <author> Reif, J. H. </author> <year> (1985), </year> <title> `Depth-first search is inherently sequential', </title> <journal> Information Processing Letters 20, </journal> <pages> 229-234. </pages>
Reference: <author> Sands, D. </author> <year> (1993), </year> <title> A nave time analysis and its theory of cost equivalence, </title> <type> TOPPS report D-173, </type> <institution> DIKU, University of Copenhagen, Denmark. </institution>
Reference: <author> Sharir, M. </author> <year> (1981), </year> <title> `A strong-connectivity algorithm and its applications in data flow analysis', </title> <booktitle> Computers and mathematics with applications 7(1), </booktitle> <pages> 67-72. </pages>
Reference: <author> Tarjan, R. E. </author> <year> (1972), </year> <title> `Depth-first search and linear graph algorithms', </title> <journal> SIAM Journal of Computing 1(2), </journal> <pages> 146-160. </pages>
Reference: <author> Wadler, P. </author> <year> (1990), </year> <title> Comprehending monads, </title> <booktitle> in `Conference on Lisp and Functional Programming', ACM, Nice, France, </booktitle> <pages> pp. 61-78. 24 </pages>
References-found: 19

