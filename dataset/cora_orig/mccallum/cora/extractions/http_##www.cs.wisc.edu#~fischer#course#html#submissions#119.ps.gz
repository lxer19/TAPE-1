URL: http://www.cs.wisc.edu/~fischer/course/html/submissions/119.ps.gz
Refering-URL: http://www.cs.wisc.edu/~fischer/course/html/submissions/
Root-URL: http://www.cs.wisc.edu
Email: evs@larch.lcs.mit.edu  
Title: Static Detection of Dynamic Memory Errors  
Author: David Evans 
Date: October 20, 1995  
Address: 545 Technology Square, Cambridge, MA 02139 (617) 253-3517  
Affiliation: MIT Laboratory for Computer Science  
Abstract: Many important classes of bugs cannot be detected efficiently at compile-time, since they are the result of external constraints not apparent without complex global analyses. In this work, we introduce annotations to make certain constraints explicit at interface points. An efficient static checking tool that exploits these annotations can detect a broad class of errors including dereferencing null pointers, using dead storage, memory leaks and unexpected aliasing. This technique has been used successfully to fix memory management problems in a large program.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Hans-J. Boehm and Mark Weiser. </author> <title> Garbage collection in an uncooperative environment. </title> <journal> Software Practice and Experience, </journal> <month> September </month> <year> 1988. </year>
Reference-contexts: Some of these errors (failure to deallocate memory and using deallocated storage) are relevant only when memory is explicitly deallocated by the programmer, and could therefore be avoided by using a garbage collector <ref> [1] </ref>. If LCLint is used to check programs designed for use with a garbage collector, flags can be used to adjust checking so only those errors relevant in a garbage-collected environment are reported.
Reference: [2] <author> David Evans. </author> <title> Using Specifications to Check Source Code, </title> <institution> MIT/LCS/TR-628, MIT Laboratory for Computer Science, </institution> <month> June </month> <year> 1994. </year>
Reference-contexts: 1 Introduction The LCLint checking tool <ref> [4, 2] </ref> has been used effectively in both industry and academia to detect errors in programs, facilitate enhancements to legacy code, and support a programming methodology based on abstract types and explicit interfaces in C. <p> For this example, we use the employee database program (1000 lines of source code) described in [5]. In <ref> [2] </ref>, LCLint without dynamic memory checking was used on the original database program.
Reference: [3] <author> David Evans. </author> <note> LCLint User's Guide, Version 2.0. </note> <month> (forthcoming) November </month> <year> 1995. </year> <month> (ftp://larch.lcs.mit.edu/pub/Larch/lclint/lclint2.0.userguide.ps.Z) </month>
Reference-contexts: It is up to the programmer to ensure that the lifetime of a dependent reference is contained within the lifetime of the corresponding owned reference. Additional annotations provided for handling reference counted storage, unfreeable shared storage, and exposure for internal references are described in <ref> [3] </ref>. 4.4 Aliasing Program errors often result when there is unexpected aliasing between parameters, return values and global variables. Since aliasing problems sometimes lead to deallocation errors, the annotations provided for detecting deallocation problems also detect many of the common aliasing errors.
Reference: [4] <author> David Evans, John Guttag, Jim Horning and Yang Meng Tan. LCLint: </author> <title> A tool for using specifications to check code. </title> <booktitle> SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <month> December </month> <year> 1994. </year>
Reference-contexts: 1 Introduction The LCLint checking tool <ref> [4, 2] </ref> has been used effectively in both industry and academia to detect errors in programs, facilitate enhancements to legacy code, and support a programming methodology based on abstract types and explicit interfaces in C.
Reference: [5] <author> J.V. Guttag and J.J. Horning with S.J. Garland, K.D. Jones, A. Modet, and J.M. Wing. </author> <title> Larch: Languages and Tools for Formal Specification, </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: This analysis would be infeasible for all but the most trivial programs. To enable local reasoning, we need more information about the code. We allow this by extending the LCL interface specification language <ref> [5, 9] </ref> to provide ways of expressing constraints on memory allocation, initialization and sharing, and by introducing annotations to make it convenient to express these constraints as qualifiers on declarations. LCLint detects places where code is inconsistent with these annotations. <p> For this example, we use the employee database program (1000 lines of source code) described in <ref> [5] </ref>. In [2], LCLint without dynamic memory checking was used on the original database program.
Reference: [6] <author> Laurie Hendren and Joseph Hummel. </author> <title> Abstractions for Recursive Pointer Data Structures: Improving the Analysis and Transformation of Imperative Programs. </title> <booktitle> SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <year> 1992. </year>
Reference-contexts: The NIL compiler detects execution sequences that violate typestate constraints at compile time. Some of the memory annotations used by LCLint could be emulated using typestates. Annotations used by LCLint are simple since our main focus is detecting errors at interface points. ADDS <ref> [6] </ref> presents an approach for dealing with recursive data structures by constraining possible aliasing relationships within datatypes. Better checking of internal aliasing would improve LCLint checking, but since our focus here is on detecting errors at interface boundaries, simple annotations are sufficient to detect a wide range of errors.
Reference: [7] <editor> Posting in comp.os.linux, </editor> <month> August </month> <year> 1994. </year>
Reference: [8] <author> Robert Strom and Nagui Halim. </author> <title> A new programming methodology for long-lived software systems. </title> <type> IBM-RC 9979, </type> <institution> IBM T. J. Watson Research Center, </institution> <month> March </month> <year> 1983. </year>
Reference-contexts: The idea of keeping additional state information on variables is similar to that used by the NIL compiler. The NIL compiler <ref> [8] </ref> extends type checking to also check typestates. Each type has a set of typestates defined by the programming language that can be determined by the compiler at any point in the code.
Reference: [9] <author> Yang Meng Tan. </author> <title> Formal Specification Techniques for Promoting Software Modularity, Enhancing Software Documentation, and Testing Specifications, </title> <institution> MIT/LCS/TR-619, MIT Laboratory for Computer Science, </institution> <month> June </month> <year> 1994. </year>
Reference-contexts: This analysis would be infeasible for all but the most trivial programs. To enable local reasoning, we need more information about the code. We allow this by extending the LCL interface specification language <ref> [5, 9] </ref> to provide ways of expressing constraints on memory allocation, initialization and sharing, and by introducing annotations to make it convenient to express these constraints as qualifiers on declarations. LCLint detects places where code is inconsistent with these annotations.
Reference: [10] <editor> Gray Watson. </editor> <address> Debug Malloc Library, </address> <month> November </month> <year> 1994. </year> <month> (ftp://ftp.letters.com/src/dmalloc/docs/dmalloc.ps) </month>
Reference-contexts: Since these errors typically involve non-local constraints, they cannot be detected efficiently at compile-time by traditional methods. There have been many academic and commercial projects aimed at producing tools that detect these kinds of errors at run-time (dmalloc <ref> [10] </ref>, mprof [11], and Purify [Pure, Inc.]). These tools can be effective in localizing the symptom of a bug where a null pointer is dereferenced or where leaking memory is being allocated. In some cases, this is enough to discover the actual bug in the code. <p> There were a few errors involving incorrectly freeing storage resulting from pointer arithmetic, two errors resulting from freeing static storage 4 , two errors resulting from missing annotations in the standard library specification, and one error involving a complex dependency on a global variable. The dmalloc <ref> [10] </ref> library was then used to detect remaining memory leaks. Several were detected, relating to storage reachable from global and static variables that was not deallocated.
Reference: [11] <author> Benjamin Zorn and Paul Hilfinger. </author> <title> A memory allocation profiler for C and Lisp programs. </title> <publisher> (ftp://gatekeeper.dec.com:/pbu/misc/mprof-3.0.tar.Z) </publisher>
Reference-contexts: Since these errors typically involve non-local constraints, they cannot be detected efficiently at compile-time by traditional methods. There have been many academic and commercial projects aimed at producing tools that detect these kinds of errors at run-time (dmalloc [10], mprof <ref> [11] </ref>, and Purify [Pure, Inc.]). These tools can be effective in localizing the symptom of a bug where a null pointer is dereferenced or where leaking memory is being allocated. In some cases, this is enough to discover the actual bug in the code.
References-found: 11

