URL: http://choices.cs.uiuc.edu/singhai/Papers/icnp94.ps
Refering-URL: http://choices.cs.uiuc.edu/singhai/home.html
Root-URL: http://www.cs.uiuc.edu
Title: Fault-Tolerant Reconfiguration of Trees and Rings in Distributed Systems  
Author: Anish Arora Ashish Singhai 
Keyword: Categories and Subject Descriptors C.2.4 [Computer Communication Systems] Distributed Systems D.1.3 [Programming Techniques] Concurrent Programming D.2.4 [Program Verification] Reliability D.2.10 [Program Design] Methodologies D.4.5 [Operating Systems] Fault-tolerance G.2.2 [Discrete Mathematics] Graph Algorithms  
Note: 0 Supported in part by NSF grant CCR-9308640 and OSU Grant 221506  
Address: Columbus, OH 43210 Urbana-Champaign, IL 61801  
Affiliation: Computer Science Computer Science The Ohio State University University of Illinois  
Abstract: We design two programs that maintain the nodes of any distributed system in a rooted spanning tree and in a unidirectional ring, respectively, in the presence of any finite number of fail-stop failures and repairs of system nodes and communication channels. Our programs are fully distributed, have optimal time and space complexity, and illustrate two different methods for the design of nonmasking fault-tolerant programs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Arora and M. G. Gouda, </author> <title> "Closure and convergence: A foundation of fault-tolerant computing", </title> <journal> IEEE Transactions on Software Engineering 19(11) (1993), </journal> <pages> pp. 1015-1027. </pages>
Reference: [2] <author> A. Arora, </author> <title> "A foundation of fault-tolerant computing", </title> <type> Ph.D. Dissertation, </type> <institution> The University of Texas at Austin (1992). </institution>
Reference-contexts: Such a state predicate identifies the "fault-span" of p. Note that the fault-span includes the fault-free states of the program. (Hence S ) T .) Examples showing how to design fault-span predicates appear in <ref> [2] </ref>. These examples take the view that all classes of faults can be represented as actions that change the program state. <p> Gallagher et al [6] have presented an elegant solution but their solution is fault-intolerant, i.e., their solution does not solve the spanning tree reconfiguration problem. More recently, stabilizing algorithms for spanning tree reconfiguration have been presented <ref> [2, 5, 7] </ref> that tolerate failures as well as repairs of both nodes and edges, but these programs are significantly more complex than RST, since they allow for the formation of transient cycles in the graph of the parent variables.
Reference: [3] <author> A. Arora, M. G. Gouda, and G. Varghese, </author> <title> "Constraint satisfaction as a basis for designing nonmasking fault-tolerance", Journal of High Speed Networks, </title> <booktitle> (1994 to appear); Proceedings of the 14th International Conference on Distributed Computer Systems (1994), </booktitle> <pages> pp. 424-431. </pages>
Reference: [4] <author> A. Arora and A. Singhai, </author> <title> "Optimal, nonmasking fault-tolerant reconfiguration of trees and rings", </title> <note> OSU Technical Report CISRC-TR09-1994; a preliminary version appears in Proceedings of International Conference on Network Protocols 1994. </note>
Reference-contexts: Stage 1 requires at most N rounds; stage 2 requires at most N rounds; and stage 3 requires at most 2N 3 rounds, where N is the number of up nodes. It follows that the time complexity of RST is O (N ) rounds. We refer the reader to <ref> [4] </ref> for formal proofs of all lemmas and theorems in this paper. 4 Maintaining A Unidirectional Ring In this section, we employ the second of the two design approaches discussed in Section 1 to derive a nonmasking fault-tolerant program for maintaining a unidirectional ring.
Reference: [5] <author> A. Arora and M. G. Gouda, </author> <title> "Distributed reset", </title> <journal> IEEE Transactions on Computers 43(9) (1994). </journal>
Reference-contexts: Finally, we show that starting from any state where V holds, every computation of RST reaches a state where S holds. 2 We measure the time complexity of convergence to S in terms of rounds <ref> [5] </ref>. A round is a minimal, nonempty sequence of program steps wherein for each node there exists a step where the node either executes an action or has no actions enabled before or after the step. <p> Gallagher et al [6] have presented an elegant solution but their solution is fault-intolerant, i.e., their solution does not solve the spanning tree reconfiguration problem. More recently, stabilizing algorithms for spanning tree reconfiguration have been presented <ref> [2, 5, 7] </ref> that tolerate failures as well as repairs of both nodes and edges, but these programs are significantly more complex than RST, since they allow for the formation of transient cycles in the graph of the parent variables.
Reference: [6] <author> R. G. Gallagher, P. A. Humblet, and P. M. Spira, </author> <title> "A distributed algorithm for minimum-weight spanning trees", </title> <journal> ACM Transactions on Programming Lang. and Sys. </journal> <volume> 5(1) (1983), </volume> <pages> pp. 66-77. </pages>
Reference-contexts: Gallagher et al <ref> [6] </ref> have presented an elegant solution but their solution is fault-intolerant, i.e., their solution does not solve the spanning tree reconfiguration problem.
Reference: [7] <author> G. Varghese, </author> <title> "Self-stabilization by local checking and correction", </title> <type> Ph.D. Dissertation, </type> <institution> Massachusetts Institute of Technology (1992). </institution>
Reference-contexts: Gallagher et al [6] have presented an elegant solution but their solution is fault-intolerant, i.e., their solution does not solve the spanning tree reconfiguration problem. More recently, stabilizing algorithms for spanning tree reconfiguration have been presented <ref> [2, 5, 7] </ref> that tolerate failures as well as repairs of both nodes and edges, but these programs are significantly more complex than RST, since they allow for the formation of transient cycles in the graph of the parent variables.
Reference: [8] <author> R. Perlman, </author> <title> "An algorithm for distributed computation of a spanning tree in an extended LAN", </title> <booktitle> Ninth ACM Data Communications Symposium, </booktitle> <volume> Vol. 20, No. 7 (1985), </volume> <pages> pp. 44-52. </pages>
Reference: [9] <author> J.-M. Helary and M. Raynal, </author> <title> "Virtual ring construction in parallel distributed systems", </title> <editor> M. Cosnard (ed.), </editor> <booktitle> Parallel Processing, </booktitle> <publisher> Elsevier Science, </publisher> <year> 1988, </year> <pages> pp. 333-345. </pages>
Reference-contexts: Moreover, in the average case, these programs converge much slower than RST. Other programs we are aware of are at best tolerant only to the failures of edges or only the failures and repairs of nodes. Distributed algorithms for ring embeddings have been presented previously <ref> [9, 10] </ref>, but unlike our algorithm, they do not tolerate fail-stop failures or repairs. Helary and Raynal [9] present an algorithm that enumerates ring nodes, one at a time, in the order of a depth first traversal of a tree. <p> Distributed algorithms for ring embeddings have been presented previously [9, 10], but unlike our algorithm, they do not tolerate fail-stop failures or repairs. Helary and Raynal <ref> [9] </ref> present an algorithm that enumerates ring nodes, one at a time, in the order of a depth first traversal of a tree. While this limits the length of the embedded ring to 2 (N 1), it allows to dilation to be linear in N .
Reference: [10] <author> P. Rosenstiehl, J. R. Fiksel, and A. Holliger, </author> <title> "Intelligent graphs: networks of finite automata capable of solving graph problems", </title> <editor> R. C. Read (ed.), </editor> <title> Graph Theory and Computing, </title> <publisher> Academic Press, </publisher> <year> 1972, </year> <pages> pp. 219-265. </pages>
Reference-contexts: Moreover, in the average case, these programs converge much slower than RST. Other programs we are aware of are at best tolerant only to the failures of edges or only the failures and repairs of nodes. Distributed algorithms for ring embeddings have been presented previously <ref> [9, 10] </ref>, but unlike our algorithm, they do not tolerate fail-stop failures or repairs. Helary and Raynal [9] present an algorithm that enumerates ring nodes, one at a time, in the order of a depth first traversal of a tree. <p> The message complexity of their algorithm is O (N ), as messages contain a list of nodes already traversed. By way of contrast, a message passing version of RST will use messages of only O (log M ) size. Rosenstiehl et al <ref> [10] </ref> have presented a self-synchronizing network of finite state automata that execute in unison from a given initial state to embed a ring of dilation at most three in a tree.
Reference: [11] <author> F. B. Bastani, I.-L. Yen, and I.-R. Chen, </author> <title> "A class of inherently fault-tolerant distributed programs", </title> <journal> IEEE Transactions on Software Engg. </journal> <volume> 14(10) (1988), </volume> <pages> pp. 1431-1442. </pages>
References-found: 11

