URL: ftp://ftp.cs.utexas.edu/pub/predator/tosem-92.ps
Refering-URL: http://www.cs.utexas.edu/users/schwartz/pub.htm
Root-URL: 
Title: The Design and Implementation of Hierarchical Software Systems With Reusable Components  
Author: Don Batory and Sean O'Malley 
Keyword: software building-blocks, domain modeling, open system architec tures, reuse, software design.  
Address: Austin, Texas 78712  
Affiliation: Department of Computer Sciences The University of Texas  
Date: October 1992.  
Note: To Appear, ACM Transactions on Software Engr. and Methodology,  This research was supported in part by a grant from Texas Instruments.  
Abstract: We present a domain-independent model of hierarchical software system design and construction that is based on interchangeable software components and large-scale reuse. The model unifies the conceptualizations of two independent projects, Genesis and Avoca, that are successful examples of software component/building-block technologies and domain modeling. Building-block technologies exploit large-scale reuse, rely on open architecture software, and elevate the granularity of programming to the subsystem level. Domain modeling formalizes the similarities and differences among systems of a domain. We believe our model is a blue-print for achieving software component technologies in many domains. 
Abstract-found: 1
Intro-found: 1
Reference: [Bac86] <author> M.J. Bach, </author> <title> The Design of the Unix Operating System, </title> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference: [Bat85] <author> D.S. Batory, </author> <title> `Modeling the Storage Architectures of Commercial Database Systems', </title> <journal> ACM TODS, </journal> <month> 10 #4 (December </month> <year> 1985). </year>
Reference-contexts: Long records are first indexed before being run-length compressed and then fragmented: ss2 = index [ rl_encode [ frag [ internal [ uf ] ] ], internal [ isf ] ] With symmetric FMAP components, a very large family of storage systems can be defined <ref> [Bat85] </ref>. 2.2.3 Relational Database Systems Realms. A database is a collection of interconnected conceptual relations. A link is an interconnection between the records of two different relations. (Normally, interconnections are specified by join predicates relating records of one relation to zero or more records of another.
Reference: [Bat87] <author> D.S. Batory, </author> <title> 'Extensible Cost Models and Query Optimization in GENESIS', </title> <booktitle> in IEEE Database Engineering, </booktitle> <year> 1987. </year>
Reference: [Bat88a] <author> D.S. Batory, </author> <title> `Concepts for a Database System Compiler', </title> <booktitle> ACM PODS 1988. </booktitle>
Reference: [Bat88b] <author> D.S. Batory, J.R. Barnett, J.F. Garza, K.P. Smith, K. Tsukuda, B.C. Twichell, T.E. Wise, </author> <title> 'GENESIS: An Extensible Database Management System', </title> <journal> IEEE Trans. Software Engr., </journal> <pages> 1711-1730. </pages>
Reference-contexts: Recognizing that nonkeyed and single-keyed structures are degenerate cases of multikeyed structures, it follows that a general-purpose interface for multikeyed structures works for single-keyed and nonkeyed structures as well. See <ref> [Bat88b, Bat89a, Roy91, Bat91c] </ref> for further details on the implementation of Genesis. - 10 - components. A node can optionally maintain records in key order, optionally share overflow blocks with other nodes, and optionally have primary blocks and/or overflow blocks. <p> It is common for DBMSs to offer alternative file and/or link implementations without exposing their difference at the DBMS interface. By giving appropriate database schema directives, specific file and link implementations can be declared <ref> [Bat88b] </ref>. Genesis provides alternative implementations via multiplexing component called a software bus. (Software busses can be thought of as the software-lego counterpart to discriminate records). As an example, ss_bus [ s:-FMAP- ] is a symmetric member of the FMAP realm.
Reference: [Bat89a] <author> D.S. Batory, J.R. Barnett, J. Roy, B.C. Twichell, and J. Garza, </author> <title> `Construction of File Management Systems from Software Components', </title> <booktitle> COMPSAC, </booktitle> <year> 1989. </year>
Reference-contexts: Recognizing that nonkeyed and single-keyed structures are degenerate cases of multikeyed structures, it follows that a general-purpose interface for multikeyed structures works for single-keyed and nonkeyed structures as well. See <ref> [Bat88b, Bat89a, Roy91, Bat91c] </ref> for further details on the implementation of Genesis. - 10 - components. A node can optionally maintain records in key order, optionally share overflow blocks with other nodes, and optionally have primary blocks and/or overflow blocks. <p> See <ref> [Bat89a, Roy91] </ref> for further details. 2.2.2 Storage Systems Realms. Storage systems map conceptual relations to internal relations. They are type expressions of symmetric components from the realm FMAP.
Reference: [Bat89b] <author> D.S. Batory, </author> <title> 'On the Reusability of Query Optimization Algorithms', </title> <booktitle> Information Systems, </booktitle> <year> 1989. </year>
Reference-contexts: With the exception of the RSTREAM realm, all realms that we have considered so far have components that are statically composed at design time. That RSTREAM components are composed dynamically at run time appears to be an unusual feature of DBMSs. See <ref> [Bat89b] </ref> for details on the reuse aspects of query 2.2 The DLANG interface is character input and output. quel [ ] and sql [ ] differ in the strings of characters that they recognize, even though their procedural interfaces are indistinguishable. - 13 - optimization algorithms. 2.2.4 Other Topics Software Busses. <p> suboperations: Q_opt ( R ) =&gt; Joining_phase ( Reducing_phase ( Q_graph ( R ) ) ) (*) Q_graph:RfiG maps a relational query R to a query graph G [Ber81a], Reducing_phase:GfiG maps a query graph without semijoin operations to one that does (which is the classical means of optimizing distributed queries <ref> [Bat89b, Jar84] </ref>), and Joining_phase ( ):GfiE maps query graphs to executable expressions. In the following paragraphs, we catalog algorithms for each of these suboperations.
Reference: [Bat90] <author> D.S. Batory, </author> <title> `The Genesis Database System Compiler: User Manual', </title> <type> U. </type> <institution> of Texas Tech. </institution> <type> Rep. </type> <institution> TR-90-27, </institution> <year> 1990. </year>
Reference: [Bat91a] <author> D.S. Batory and J.R. Barnett, `DaTE: </author> <title> The Genesis DBMS Software Layout Editor', in Conceptual Modelling, Databases, and CASE, </title> <editor> R. Zicari, ed., </editor> <publisher> McGraw-Hill, </publisher> <year> 1991. </year>
Reference-contexts: DaTE guarantees that design rules are not violated, which amounts to avoiding illegal compositions of components. Design rule checking is briefly considered in Section 5 and in detail in <ref> [Bat91a] </ref>. Using DaTE, a specification of a university-quality relational DBMS takes less than a half-hour. The software that is generated is untuned because tuning constants that are part of every component are assigned default values. <p> Design rules express these constraints and confirm common intuition: as one composes components, constraints on legal instantiations are `inherited' in a top-down manner, thus further restricting the set of components that can be used at any given position in a system. We explain in <ref> [Bat91a] </ref> how design rules are defined and enforced in the Genesis component layout editor (DaTE). DaTE presents a graphical interface by which system designs can compose components quickly, while ensuring that incorrect compositions are impossible to specify.
Reference: [Bat91b] <author> D.S. Batory, </author> <title> `A Domain Modeling Methodology', </title> <note> in preparation. </note>
Reference-contexts: We do not present a methodology for modeling a domain in terms of the meta-model; that is far beyond the scope of this paper and is the subject of ongoing work <ref> [Bat91b] </ref>. Our work affirms and extends basic insights of many pioneers in software engineering: the software families and abstract interface concepts of Parnas [Par79], parameterized types - 3 - of Goguen [Gog84], hierarchical system designs of Habermann [Hab76], object-orientation of Goldberg [Gol84], and the frameworks concept of Deutsch [Deu89].
Reference: [Bat91c] <author> D.S. Batory, et al., </author> <title> `The Implementation of Genesis', </title> <note> in preparation. </note>
Reference-contexts: Recognizing that nonkeyed and single-keyed structures are degenerate cases of multikeyed structures, it follows that a general-purpose interface for multikeyed structures works for single-keyed and nonkeyed structures as well. See <ref> [Bat88b, Bat89a, Roy91, Bat91c] </ref> for further details on the implementation of Genesis. - 10 - components. A node can optionally maintain records in key order, optionally share overflow blocks with other nodes, and optionally have primary blocks and/or overflow blocks. <p> We chose not to include them just to keep the model overview simple. Further details on these topics are given in <ref> [Bat91c] </ref>. Layout Editors and Tuning. Because type expressions quickly become difficult to read, Genesis has a layout editor, called DaTE, which enables components of different realms to be composed graphically. DaTE guarantees that design rules are not violated, which amounts to avoiding illegal compositions of components. <p> A similar - 22 - BLOCK BLOCK NODE NODE AMETHOD AMETHOD FMAP FMAP (b) cursor (a) Component Component Component Component Component Component Component block cursor node cursor file cursor Component file cursor node cursor block cursor optimization is used for components that are symmetric <ref> [Bat91c] </ref>. - 23 - 3.1.2 An Example from Avoca Avoca components communicate through control blocks called session objects. Components are called protocol objects.
Reference: [Bax91] <author> I. Baxter, </author> <type> personal communication. </type>
Reference-contexts: It may be the case that a control block corresponds to the state variables of a `local process' that exists only within a single component <ref> [Bax91] </ref>. How processes generally fit into our model is a problem that we are now investigating. - 21 - 3.1.1 An Example from Genesis Genesis components communicate through control blocks called cursors. Let F be a FMAP component and C be a file (FMAP) cursor.
Reference: [Ber81a] <author> P.A. Bernstein and D.M. Chiu, </author> <title> `Using Semi-Joins to Solve Relational Queries', </title> - <journal> 45 - Journal of the ACM, </journal> <month> 28 #1 (January </month> <year> 1981). </year>
Reference-contexts: Different relational DBMSs realize Q_opt ( ) in different ways. Q_opt ( ) can be decomposed into a composition of three suboperations: Q_opt ( R ) =&gt; Joining_phase ( Reducing_phase ( Q_graph ( R ) ) ) (*) Q_graph:RfiG maps a relational query R to a query graph G <ref> [Ber81a] </ref>, Reducing_phase:GfiG maps a query graph without semijoin operations to one that does (which is the classical means of optimizing distributed queries [Bat89b, Jar84]), and Joining_phase ( ):GfiE maps query graphs to executable expressions. In the following paragraphs, we catalog algorithms for each of these suboperations. <p> Reducing_phase and Joining_phase algorithms are data language independent. A partial catalog of algorithms for each operation is shown below: 3.5 Reducing_phase ( G ) =&gt; G ; identity no optimization Sdd1 ( G ) ; SDD1 algorithm [Ber81b] Bc ( G ) ; Bernstein & Chiu algorithm <ref> [Ber81a] </ref> Yol ( G ) ; Yu et al. algorithm [Yu84] ...
Reference: [Ber81b] <author> P.A. Bernstein, et al., </author> <title> `Query Processing in a System for Distributed Databases (SDD-1)', </title> <journal> ACM Transactions on Database Systems, </journal> <month> 6 #4 (December </month> <year> 1981). </year>
Reference-contexts: Reducing_phase and Joining_phase algorithms are data language independent. A partial catalog of algorithms for each operation is shown below: 3.5 Reducing_phase ( G ) =&gt; G ; identity no optimization Sdd1 ( G ) ; SDD1 algorithm <ref> [Ber81b] </ref> Bc ( G ) ; Bernstein & Chiu algorithm [Ber81a] Yol ( G ) ; Yu et al. algorithm [Yu84] ...
Reference: [Ber89] <author> B. Bershad, T. Anderson, E. Lazowska, and H. Levy, </author> <title> `Lightweight Remote Procedure Call', </title> <booktitle> ACM Symposium on Operating Systems Principles, </booktitle> <year> 1989. </year>
Reference-contexts: It has been experimentally determined that most `remote' procedure calls are in fact calls to different address spaces on the same machine <ref> [Ber89] </ref>. local_rpc is an efficient protocol that relies on the local operating system to process remote procedure calls. sun_rpc is the xkernel implementation of Sun RPC and is fully compatible with existing implementations. sprite_rpc is the xkernel implementation of Sprite RPC and is again compatible with the original version.
Reference: [Big89a] <author> T.J. Biggerstaff and A.J. Perlis, </author> <title> Software Reusability I: Concepts and Models, </title> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference: [Big89b] <author> T.J. Biggerstaff and A.J. Perlis, </author> <title> Software Reusability II: Applications and Experience, </title> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference: [Boo87] <author> G. Booch, </author> <title> Software Components with Ada, </title> <publisher> Benjamin Cummings, </publisher> <year> 1987. </year>
Reference: [Boo91] <author> G. Booch, </author> <title> Object-Oriented Design With Applications, </title> <publisher> Benjamin Cummings, </publisher> <year> 1991. </year>
Reference-contexts: We reinforce our discussions with specific examples taken from the Genesis and Avoca prototypes. 4.1 Layered Software Designs and Transformations Object-Oriented Designs. A primary result of an object-oriented design is an object model or schema that defines the classes of objects of an application and their interrelationships <ref> [Boo91, Rum91, Teo90] </ref>. Associated with each class is the set of operations that can be performed on its objects, plus the set of object attributes. Object models are depicted by class diagrams, where classes are nodes and edges are relationships.
Reference: [Bri81] <author> K.H. Britton, R.A. Parker, and D.L. Parnas, </author> <title> `A Procedure for Designing Abstract Interfaces for Device Interface Modules`, </title> <booktitle> International Conference on Software Engineering, </booktitle> <year> 1981. </year>
Reference-contexts: Note that meta-types, type classes, theories, and realms are themselves types. Our model deals with components and realms. Components. The fundamental unit of large scale software construction is the component. Every component has an interface and an implementation. Following the lead of Parnas <ref> [Par79, Bri81] </ref>, the interface of a component is anything that is visible externally to the component. Everything else belongs to its implementation. Every component is a member of a realm T, where all members of T realize exactly the same interface but in different ways.
Reference: [Car85] <author> L. Cardelli and P. Wegner, </author> <title> `On Understanding Types, Data Abstraction, and Polymorphism', </title> <journal> ACM Computing Surveys, </journal> <month> 17 #4 (December </month> <year> 1985). </year>
Reference-contexts: A type is a set of values. An abstract data type (ADT) is a type plus operations on the values of the type. A class is an ADT that belongs to an inheritance lattice <ref> [Car85] </ref>. A component is a closely-knit cluster of classes that act as a unit [Teo86]. Normally, the values of a type are simple (e.g., numbers, strings, etc). When values become complex entities, different names (other than `type') are generally used. For example, a set of types is called a meta-type.
Reference: [Cha76] <editor> D.D. Chamberlin, et al., </editor> <title> `SEQUEL 2: A Unified Approach to Data Definition, Manipulation, </title> <journal> and Control', IBM Journal of Research and Development, </journal> <month> 20 #6 (November </month> <year> 1976). </year>
Reference-contexts: In the following paragraphs, we catalog algorithms for each of these suboperations. Q_graph has many implementations, one for every data language: Q_graph ( R ) =&gt; Sql_graph ( R ) ; SQL language <ref> [Cha76] </ref> Quel_graph ( R ) ; QUEL language [Sto76] Gem_graph ( R ) ; GEM language [Zan83] ...
Reference: [Che87] <author> D. R. Cheriton, `VMTP: </author> <title> A transport protocol for the next generation of communications systems', </title> <booktitle> ACM SIGCOM '86 Symposium, </booktitle> <month> (August </month> <year> 1987). </year>
Reference-contexts: Inside the networking community, the ISO model is the root cause of the rejection of layering as an efficient way of implementing network software by a variety of network architectures (VMPT <ref> [Che87] </ref>, Sprite [Ous88]). ISO architecture sacrificed efficiency for modularity at a time when the introduction of high speed networks required an increase in efficiency. While the networking continued to use layered models to describe network software, layered implementations were actually considered harmful [Ten89].
Reference: [Cla85] <author> D.D. Clark, </author> <title> `The Structuring of Systems Using Upcalls', </title> <booktitle> ACM Symposium on Operating Systems Principles, </booktitle> <year> 1985. </year>
Reference-contexts: Avoca presently has three realms: ASYNC, SYNC, and STREAM. Each is discussed in turn. 2.3.1 Asynchronous Protocols Realm. Protocols that send and receive messages asynchronously are members of the ASYNC realm. Senders send messages without waiting for a reply and all messages are delivered to their destinations using upcalls <ref> [Cla85] </ref>. If a destination replies to a message, the sender is responsible for matching requests and replies using local state or message header information. ASYNC protocols are generally the lowest level protocols supported in any network software system. <p> C itself may call external operations d i and u i . The d i are down calls requesting services from lower-level components and the u i are upcalls, requests for services from higher-level components <ref> [Cla85] </ref>. Upcalls arise in systems that receive asynchronous inputs through lower level components and that usher the processing of these inputs up through the system.
Reference: [Deu89] <author> P.L. Deutsch, </author> <title> `Design Reuse and Frameworks in the Smalltalk-80 Programming System' in [Big89a]. </title>
Reference-contexts: Our work affirms and extends basic insights of many pioneers in software engineering: the software families and abstract interface concepts of Parnas [Par79], parameterized types - 3 - of Goguen [Gog84], hierarchical system designs of Habermann [Hab76], object-orientation of Goldberg [Gol84], and the frameworks concept of Deutsch <ref> [Deu89] </ref>. We begin by explaining the superstructure of large scale systems and its relationship to the design of open-architecture software. - 4 - 2. <p> A set of abstract classes with their concrete classes defines a framework, which is an important organizational concept in the design of families of software systems <ref> [Deu89, Joh88] </ref>. Object models that define realm interfaces are implemented by frameworks. In the most general case, every class of an object model is an abstract class. Each component is implemented by a special concrete class for each abstract class in the model.
Reference: [Dij68] <author> E.W. Dijkstra, </author> <title> `The Structure of THE Multiprogramming System', </title> <journal> Communications of the ACM, </journal> <month> 11 #5 (May </month> <year> 1968). </year>
Reference-contexts: GF lower levels higher levels transformation TAB TA C TB E 4.0 It is worth noting that the ideas of hierarchical/layered system design were well-understood over two decades ago <ref> [Dij68, Par72, Hab76] </ref>. Astonishingly, the idea of stratified designs and layered systems is virtually absent in contemporary object-oriented literature. 4.1 A primary contribution of object-orientation to the design of hierarchical systems is that an object model precisely defines both the operations and objects of a level (virtual machine). <p> Contemporary object-oriented design techniques are basically two-dimensional; they concentrate on developing a single object model which can be drawn on a flat (two-dimensional) surface that explains an application. Our work recognizes and extends concepts of early software engineering pioneers <ref> [Dij68, Par72, Hab76] </ref> that software design techniques must be extended by another dimension in order to account for layering in hierarchical systems. Where our work departs from known results are the concepts of realms, type-expressions, and the role of interface standardization. - 37 - 5.
Reference: [Gog84] <author> J. Goguen, </author> <title> `Parameterized Programming', </title> <journal> IEEE Trans. Software Engr., </journal> <month> SE-10,5 (September </month> <year> 1984). </year>
Reference-contexts: Our work affirms and extends basic insights of many pioneers in software engineering: the software families and abstract interface concepts of Parnas [Par79], parameterized types - 3 - of Goguen <ref> [Gog84] </ref>, hierarchical system designs of Habermann [Hab76], object-orientation of Goldberg [Gol84], and the frameworks concept of Deutsch [Deu89]. We begin by explaining the superstructure of large scale systems and its relationship to the design of open-architecture software. - 4 - 2. <p> When values become complex entities, different names (other than `type') are generally used. For example, a set of types is called a meta-type. A set of ADTs is called a type class [Wad89] and a set of classes is a theory <ref> [Gog84, Gra91] </ref>. We will call a set of components a realm. Note that meta-types, type classes, theories, and realms are themselves types. Our model deals with components and realms. Components. The fundamental unit of large scale software construction is the component. Every component has an interface and an implementation. <p> When components are composed, operation calls are replaced with their algorithms in the obvious way <ref> [Gog84] </ref>. 3.3-4 Rewrite rules can be adorned with additional information. Preconditions are an example. Algorithms without preconditions are robust, as they will always work no matter what their input might be. However, robust algorithms tend to be inefficient. Faster algorithms often exist, but work only for restricted inputs.
Reference: [Gol84] <author> A. Goldberg, </author> <title> Smalltalk-80: The Interactive Programming Environment, </title> <publisher> Addison-Wesley, </publisher> <year> 1984. </year>
Reference-contexts: Our work affirms and extends basic insights of many pioneers in software engineering: the software families and abstract interface concepts of Parnas [Par79], parameterized types - 3 - of Goguen [Gog84], hierarchical system designs of Habermann [Hab76], object-orientation of Goldberg <ref> [Gol84] </ref>, and the frameworks concept of Deutsch [Deu89]. We begin by explaining the superstructure of large scale systems and its relationship to the design of open-architecture software. - 4 - 2.
Reference: [Gra87] <author> G. Graefe and D.J. DeWitt, </author> <title> `The EXODUS Optimizer Generator', </title> <booktitle> ACM SIG-MOD, </booktitle> <year> 1987. </year>
Reference-contexts: Joining_phase ( G ) =&gt; Sys_R ( G ) ; System R algorithm [Sel79] U_ingres ( G ) ; University Ingres algorithm [Won76] Exodus ( G, RS ) ; Exodus rule optimizer <ref> [Gra87] </ref> - RS is the rule set ... From the above catalogs, it is easy to see how different implementations of components can arise.
Reference: [Gra91] <author> H. Graves and W. Polak, </author> <title> `Common Intermediate Design Language Overview', </title> <institution> Lockheed Palo Alto Research Laboratory, </institution> <month> Spring </month> <year> 1991. </year>
Reference-contexts: When values become complex entities, different names (other than `type') are generally used. For example, a set of types is called a meta-type. A set of ADTs is called a type class [Wad89] and a set of classes is a theory <ref> [Gog84, Gra91] </ref>. We will call a set of components a realm. Note that meta-types, type classes, theories, and realms are themselves types. Our model deals with components and realms. Components. The fundamental unit of large scale software construction is the component. Every component has an interface and an implementation.
Reference: [Gut77] <author> J. Guttag, </author> <title> `Abstract Data Types and the Development of Data Structures', </title> <journal> Comm. ACM, </journal> <month> 20 #6 (June </month> <year> 1977). </year>
Reference-contexts: Thus, design encapsulation cannot always be realized solely by ADT encapsulation. We believe that Parnas was the first to recognize the concept of design encapsulation [Par72], and Guttag was among the first to recognize the concept of ADT encapsulation <ref> [Gut77] </ref>. However, the distinction between design and ADT encapsulation was not evident to us before we began the Genesis and Avoca projects. Domain Modeling. Creating a domain model is definitely not an ad hoc process.
Reference: [Gut78] <author> J. Guttag, E. Horowitz, and D.R. Musser, </author> <title> `Abstract Data Types and Software - 46 - Validation', </title> <journal> Communications of the ACM, </journal> <month> 21 #12 (December </month> <year> 1978). </year>
Reference: [Hab76] <author> A.N. Habermann, L. Flon, and L. Cooprider, </author> <title> `Modularization and Hierarchy in a Family of Operating Systems', </title> <journal> Communications of the ACM, </journal> <month> 19 #5 (May </month> <year> 1976). </year>
Reference-contexts: Our work affirms and extends basic insights of many pioneers in software engineering: the software families and abstract interface concepts of Parnas [Par79], parameterized types - 3 - of Goguen [Gog84], hierarchical system designs of Habermann <ref> [Hab76] </ref>, object-orientation of Goldberg [Gol84], and the frameworks concept of Deutsch [Deu89]. We begin by explaining the superstructure of large scale systems and its relationship to the design of open-architecture software. - 4 - 2. <p> The actual implementation of the components, although important, is a lower-level detail. It is worth noting that over fifteen years ago Haberman observed that software system designs are hierarchical, but system implementations need not be <ref> [Hab76] </ref>. Our notation and metamodel extends this insight by making the conceptual layering that exists in systems explicit. Although explicit component boundaries are maintained in Genesis- and Avoca-produced systems, this is not mandatory (e.g., components could be macro-expanded together). <p> To illustrate the issues of multiple selections, query optimization in databases involves the evaluation of alternative algorithms for processing a retrieval operation. The algorithm 3.3 The elimination of explicit layering via inline expansion, which replaces an operation with its algorithmic body, was proposed in <ref> [Hab76, Bat88] </ref>. Inline expansion is possible in systems that have no bottom operations, because unbounded recursion may arise (e.g., a bottom call B calls a top call T, which in turn may call B again). <p> GF lower levels higher levels transformation TAB TA C TB E 4.0 It is worth noting that the ideas of hierarchical/layered system design were well-understood over two decades ago <ref> [Dij68, Par72, Hab76] </ref>. Astonishingly, the idea of stratified designs and layered systems is virtually absent in contemporary object-oriented literature. 4.1 A primary contribution of object-orientation to the design of hierarchical systems is that an object model precisely defines both the operations and objects of a level (virtual machine). <p> As noted in <ref> [Hab76] </ref>, defining transmit calls as macros and expanding inline through a sequence of layers could possibly result in a single instruction. It is the system design that is hierarchical, not its implementation. <p> Contemporary object-oriented design techniques are basically two-dimensional; they concentrate on developing a single object model which can be drawn on a flat (two-dimensional) surface that explains an application. Our work recognizes and extends concepts of early software engineering pioneers <ref> [Dij68, Par72, Hab76] </ref> that software design techniques must be extended by another dimension in order to account for layering in hierarchical systems. Where our work departs from known results are the concepts of realms, type-expressions, and the role of interface standardization. - 37 - 5. <p> Then certainly, a component of R1 could be used where ever a component of R0 is used. Such an addition, we believe, would allow us to express the class of hierarchical systems described by Habermann, Flon, and Cooprider <ref> [Hab76] </ref>. Multiple Standards. Consensus is needed for interface standards. As both of our projects relied on a small group of designers, consensus wasn't difficult. In general, however, we would expect independent design teams would arrive at different "standards". Consensus and component interoperability would then become problematic.
Reference: [Hab76] <author> A.N. Habermann, L. Flon, and L. Cooprider, </author> <title> `Modularization and Hierarchy in a Family of Operating Systems', </title> <journal> Communications of the ACM, </journal> <month> 19 #5 (May </month> <year> 1976). </year>
Reference-contexts: Our work affirms and extends basic insights of many pioneers in software engineering: the software families and abstract interface concepts of Parnas [Par79], parameterized types - 3 - of Goguen [Gog84], hierarchical system designs of Habermann <ref> [Hab76] </ref>, object-orientation of Goldberg [Gol84], and the frameworks concept of Deutsch [Deu89]. We begin by explaining the superstructure of large scale systems and its relationship to the design of open-architecture software. - 4 - 2. <p> The actual implementation of the components, although important, is a lower-level detail. It is worth noting that over fifteen years ago Haberman observed that software system designs are hierarchical, but system implementations need not be <ref> [Hab76] </ref>. Our notation and metamodel extends this insight by making the conceptual layering that exists in systems explicit. Although explicit component boundaries are maintained in Genesis- and Avoca-produced systems, this is not mandatory (e.g., components could be macro-expanded together). <p> To illustrate the issues of multiple selections, query optimization in databases involves the evaluation of alternative algorithms for processing a retrieval operation. The algorithm 3.3 The elimination of explicit layering via inline expansion, which replaces an operation with its algorithmic body, was proposed in <ref> [Hab76, Bat88] </ref>. Inline expansion is possible in systems that have no bottom operations, because unbounded recursion may arise (e.g., a bottom call B calls a top call T, which in turn may call B again). <p> GF lower levels higher levels transformation TAB TA C TB E 4.0 It is worth noting that the ideas of hierarchical/layered system design were well-understood over two decades ago <ref> [Dij68, Par72, Hab76] </ref>. Astonishingly, the idea of stratified designs and layered systems is virtually absent in contemporary object-oriented literature. 4.1 A primary contribution of object-orientation to the design of hierarchical systems is that an object model precisely defines both the operations and objects of a level (virtual machine). <p> As noted in <ref> [Hab76] </ref>, defining transmit calls as macros and expanding inline through a sequence of layers could possibly result in a single instruction. It is the system design that is hierarchical, not its implementation. <p> Contemporary object-oriented design techniques are basically two-dimensional; they concentrate on developing a single object model which can be drawn on a flat (two-dimensional) surface that explains an application. Our work recognizes and extends concepts of early software engineering pioneers <ref> [Dij68, Par72, Hab76] </ref> that software design techniques must be extended by another dimension in order to account for layering in hierarchical systems. Where our work departs from known results are the concepts of realms, type-expressions, and the role of interface standardization. - 37 - 5. <p> Then certainly, a component of R1 could be used where ever a component of R0 is used. Such an addition, we believe, would allow us to express the class of hierarchical systems described by Habermann, Flon, and Cooprider <ref> [Hab76] </ref>. Multiple Standards. Consensus is needed for interface standards. As both of our projects relied on a small group of designers, consensus wasn't difficult. In general, however, we would expect independent design teams would arrive at different "standards". Consensus and component interoperability would then become problematic.
Reference: [Hay88] <author> R. Hayes, S. Manweiler, and R. Schlichting, </author> <title> A simple system for constructing distributed, mixed language programs, </title> <journal> Software---Practice and Experience, </journal> <month> July </month> <year> 1988. </year>
Reference-contexts: Avoca is most closely related to the MIL IDL [Sno89] and the multi-language programming environments MLP <ref> [Hay88] </ref> and Polylith [Pur85]. (In fact, Polylith notation was used initially for Avoca). However the critical feature of Avoca is the methodology used to design composable protocols [OMa90b]. The notation used to describe such protocols is not nearly as important as properties such as symmetric components.
Reference: [Hut91] <author> N.C. Hutchinson and L.L. Peterson, </author> <title> `The x-Kernel: An Architecture for Implementing Network Protocols', </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> 17 #1 (January </month> <year> 1991). </year>
Reference-contexts: Avoca is a system for constructing efficient and modular network software suites using a combination of pre-existing and newly created communication protocols [OMa89-90c]. Protocol suites are expressed as a graph of prefabricated protocol components. The graph is loaded into a communications kernel (the xkernel <ref> [Hut91] </ref>) and executed. Genesis and Avoca are successful examples of both software component technologies and domain modeling. When we compared Genesis and Avoca, we were amazed at the similarities in their conceptual design, organization, and implementation. We concluded that the similarities were not accidental, but were intrinsic to building-block technologies. <p> Protocol suite specifications are manually written as, unlike Genesis, Avoca does not have a component layout editor. The runtime environment for Avoca is provided by the xkernel: an operating system kernel designed to run network protocols <ref> [OMa89-90b, Hut91] </ref>. One of the goals of the xker-nel was to support encapsulated protocols efficiently. As it turned out, most existing protocols are so unencapsulated in design and implementation, that they could not take advantage of many of the xkernel's features.
Reference: [Jar84] <author> M. Jarke and J. Koch, </author> <title> `Query Optimization in Database Systems', </title> <journal> ACM Computing Surveys, </journal> <month> 16 #2 (June </month> <year> 1984). </year>
Reference-contexts: These statements are translated into optimized expressions, called access plans, that are compositions of retrieval and join operations over base relations. In this section, we catalog implementations of DLANG retrieval statements. Expanded discussions on this subject are given in [Bat87-89b], and a tutorial on query optimization is presented in <ref> [Jar84] </ref>. Let R be a relational query. (As readers will soon see, the particular language used to express R doesn't matter). <p> suboperations: Q_opt ( R ) =&gt; Joining_phase ( Reducing_phase ( Q_graph ( R ) ) ) (*) Q_graph:RfiG maps a relational query R to a query graph G [Ber81a], Reducing_phase:GfiG maps a query graph without semijoin operations to one that does (which is the classical means of optimizing distributed queries <ref> [Bat89b, Jar84] </ref>), and Joining_phase ( ):GfiE maps query graphs to executable expressions. In the following paragraphs, we catalog algorithms for each of these suboperations. <p> The above three Q_opt examples show the reuse of the Sql_graph algorithm. Second, it is worth noting that almost all reducing phase algorithms are nonrobust; typically reducing phase algorithms can only process tree graphs <ref> [Jar84] </ref>. As mentioned earlier, nonrobust algorithms can be paired with robust algorithms to form new robust algorithms.
Reference: [Joh88] <author> R.E. Johnson and B. Foote, </author> <title> `Designing Reusable Classes', </title> <journal> Journal of Object-Oriented Programming, </journal> <month> June/July </month> <year> 1988. </year>
Reference-contexts: A set of abstract classes with their concrete classes defines a framework, which is an important organizational concept in the design of families of software systems <ref> [Deu89, Joh88] </ref>. Object models that define realm interfaces are implemented by frameworks. In the most general case, every class of an object model is an abstract class. Each component is implemented by a special concrete class for each abstract class in the model.
Reference: [Kor91] <author> H.F. Korth and A. Silberschatz, </author> <title> Database System Concepts, </title> <publisher> McGraw-Hill, </publisher> <year> 1991. </year>
Reference-contexts: However, relationships can be defined by manually `connecting' one record with another. In CODASYL terminology, a link is called a set <ref> [Kor91] </ref>). A relational system maps a database with a nonprocedural data language interface to a set of conceptual relations (with no links) whose interface is procedural. Relational systems - 12 - are compositions of components from the realms DLANG, LINK, and RSTREAM, with references to storage systems. <p> Specific instances of (*) correspond to query processing algorithms of commercial DBMSs. The data model/data language component of DB2 <ref> [Sel79, Kor91] </ref> uses the following implementation of Q_opt ( ): Q_opt (R) =&gt; Sys_r ( Sql_graph ( R ) ) That is, DB2 uses 1) Sql_graph to map SELECT-FROM-WHERE queries to query graphs, 2) the identity function G for its reducing phase algorithm, and 3) the Sys_r algorithm to map query <p> Consider the following examples. Two commonly identified ADTs (modules) in a DBMS are the storage system (which stores and retrieves tuples of relations) and the query optimizer (which identifies the fastest search strategy to be used by the storage system in processing a query) <ref> [Kor91] </ref>. Both the storage system and query optimizer can be implemented by distinct ADTs, where each - 41 - other's local variables and local functions are hidden from view. Although ADT encapsulation is preserved, design encapsulation is not.
Reference: [Lin89] <author> B. Lindsay, </author> <title> private communication, </title> <year> 1989. </year>
Reference-contexts: However, there is no notion of components, layers, or classes in the model itself. How algorithms are defined, how they are related (if at all) to components, is unclear. Starburst supports `attachments' that are similar to, but less powerful than Genesis components <ref> [Lin89] </ref>. Attachments are not part of the optimizer model. Modular Network Software. Outside of the networking community, the ISO 7 layer model [Zim80] is often cited as an example of the application of modular design to production systems.
Reference: [Lis77] <author> B. Liskov, A. Snyder, R. Atkinson, and C. Schaffert, </author> <title> `Abstraction Mechanisms in CLU', </title> <journal> Communications of the ACM, </journal> <month> 20 #8 (August </month> <year> 1977).` </year>
Reference-contexts: Our work distinguishes two types of encapsulation: ADT and design. We are all familiar with ADT encapsulation; programming languages (ADA, C++) enforce ADT encapsulation through the hiding of local variables and local functions <ref> [Lis77] </ref>. The idea is to permit changes to an ADT's implementation without triggering changes to other ADTs. Design encapsulation, on the other hand, is the form of encapsulation that is required for software component technologies.
Reference: [Loh88] <author> G. Lohman, </author> <title> `Grammar-like Functional Rules for Representing Query Optimization Alternatives', </title> <booktitle> Proc. ACM SIGMOD 1988. </booktitle>
Reference-contexts: Furthermore, ANSI/SPARC layers were effectively monolithic, leaving little opportunity for exploring and achieving component reuse. More recently, research on extensible database systems has lead to more modular DBMS architectures. However, only Genesis and Starburst <ref> [Loh88] </ref> were based on formal models of DBMS software. The Starburst model deals with rule-based query optimization, which essentially is a model of what we have called algorithm reuse. The optimizer "glues" algorithms together to form access plans.
Reference: [Mas90] <author> T. Mason and D. Brown, </author> <title> Unix Programming Tools: Lex & Yacc, </title> <publisher> O'Reilly & Associates, </publisher> <year> 1990. </year>
Reference-contexts: If the indexing component is absent, the indexing statement is not present in the DDL. A standard way to implement DDLs is via Lex and Yacc <ref> [Mas90] </ref>. An individual DDL statement is represented by one or more Lex tokens and one or more Yacc rules. The presence or absence of a component will trigger the inclusion or exclusion of tokens and rules.
Reference: [Mog91] <author> J.C. Mogul and A. Borg, </author> <title> `The Effect of Context Switches on Cache Performance', </title> <booktitle> Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <month> April </month> <year> 1991. </year>
Reference-contexts: When organized in this fashion, traversing each additional layer costs at least one context switch. Context switches even for `lightweight' processes are enormously expensive when one considers the effect on a memory cache <ref> [Mog91] </ref>. Most interprocess communication primitives have additional built-in overheads that only make matters worse. The xkernel uses a process-per-message as it enters the kernel. This process shepherds the message through a graph of protocol objects until it leaves the kernel.
Reference: [OMa89] <author> S.W. O'Malley, </author> <type> Ph.D. Dissertation, </type> <institution> University of Arizona, </institution> <year> 1990. </year>
Reference-contexts: To be a reliable, a request reply protocol must deliver only one message to the destination for each request. sync_select [ ] is the synchronous version of async_select [ ], and is used to address remote procedures <ref> [OMa89] </ref>. sun_select [ ] is the sun demultiplexing protocol that takes three 32-bit addresses as its input, and as we'll see later, can be defined in terms of sync_select [ ]. Other SYNC_AVOCA protocols were created to perform the other functions normally bundled into RPC protocols. <p> The approach to developing Avoca was to produce the fastest possible protocol suites, and against all preconceived notions (including the designers), the decomposed version of Sprite RPC turned out to be faster than the original and monolithic version in both latency and bandwidth (see <ref> [OMa89, OMa90a] </ref> for actual performance figures). This is not to say that protocol encapsulation improves performance in most cases, but that the per-protocol overhead was low enough that it did not dominate the performance outcome.
Reference: [OMa90a] <author> S. O'Malley, </author> <title> 'Avoca : An Environment For Programming With Protocols', </title> <type> Ph.D. Dissertation, </type> <institution> University of Arizona TR90-31 (Aug. </institution> <year> 1990). </year>
Reference-contexts: ISO architecture sacrificed efficiency for modularity at a time when the introduction of high speed networks required an increase in efficiency. While the networking continued to use layered models to describe network software, layered implementations were actually considered harmful [Ten89]. In <ref> [OMa90a] </ref>, it was shown that it is possible to increase performance without sacrificing modularity. Some of the methods used by Avoca to organize heavily layered protocol suites were also used in the higher layers of the ISO architecture. <p> The approach to developing Avoca was to produce the fastest possible protocol suites, and against all preconceived notions (including the designers), the decomposed version of Sprite RPC turned out to be faster than the original and monolithic version in both latency and bandwidth (see <ref> [OMa89, OMa90a] </ref> for actual performance figures). This is not to say that protocol encapsulation improves performance in most cases, but that the per-protocol overhead was low enough that it did not dominate the performance outcome.
Reference: [OMa90b] <author> S.W. O'Malley and L.L. Peterson, </author> <title> `A New Methodology for Designing Network Software', </title> <note> submitted for publication. </note>
Reference-contexts: Avoca is most closely related to the MIL IDL [Sno89] and the multi-language programming environments MLP [Hay88] and Polylith [Pur85]. (In fact, Polylith notation was used initially for Avoca). However the critical feature of Avoca is the methodology used to design composable protocols <ref> [OMa90b] </ref>. The notation used to describe such protocols is not nearly as important as properties such as symmetric components. Second, by making it simple to define arbitrarily complex interfaces, the probability of any module being composable is reduced.
Reference: [OMa90c] <author> S.W. O'Malley, M.B. Abbott, N.C. Hutchinson, and L.L. Peterson, </author> <title> `A Transparent Blast Facility', </title> <journal> Journal of Internetworking, </journal> <month> 1 #2 (December </month> <year> 1990). </year>
Reference-contexts: The ASYNC_AVOCA subrealm contains symmetric Avoca protocols that are not virtual. blast [ ] breaks a large message into 16 fragments, sends the fragments, and reassembles the original message once all fragments have arrived <ref> [OMa90c] </ref>. async_select [ ] is a simple demultiplexing protocol that is essentially a symmetric version of udp [ ]. 2.3 Virtual asynchronous protocols are found in the VIRTUAL_ASYNC subrealm. vaddr [ ] directs incoming packets to the first of its two ASYNC arguments and determines if the destination address can be
Reference: [Ous88] <author> J.K. Ousterhout, A.R. Cherenson, F. Douglis, M.N. Nelson and B.B. Welch, </author> <title> 'The Sprite Network Operating System', </title> <booktitle> IEEE Computer, </booktitle> <month> (February </month> <year> 1988). </year>
Reference-contexts: Inside the networking community, the ISO model is the root cause of the rejection of layering as an efficient way of implementing network software by a variety of network architectures (VMPT [Che87], Sprite <ref> [Ous88] </ref>). ISO architecture sacrificed efficiency for modularity at a time when the introduction of high speed networks required an increase in efficiency. While the networking continued to use layered models to describe network software, layered implementations were actually considered harmful [Ten89].
Reference: [Par72] <author> D.L. Parnas, </author> <title> `On the Criteria to be used in Decomposing Systems into Modules', </title> <journal> Communications of the ACM, </journal> <volume> 15 #12, </volume> <year> 1972. </year>
Reference-contexts: GF lower levels higher levels transformation TAB TA C TB E 4.0 It is worth noting that the ideas of hierarchical/layered system design were well-understood over two decades ago <ref> [Dij68, Par72, Hab76] </ref>. Astonishingly, the idea of stratified designs and layered systems is virtually absent in contemporary object-oriented literature. 4.1 A primary contribution of object-orientation to the design of hierarchical systems is that an object model precisely defines both the operations and objects of a level (virtual machine). <p> Contemporary object-oriented design techniques are basically two-dimensional; they concentrate on developing a single object model which can be drawn on a flat (two-dimensional) surface that explains an application. Our work recognizes and extends concepts of early software engineering pioneers <ref> [Dij68, Par72, Hab76] </ref> that software design techniques must be extended by another dimension in order to account for layering in hierarchical systems. Where our work departs from known results are the concepts of realms, type-expressions, and the role of interface standardization. - 37 - 5. <p> The inclusion/exclusion process must be done at precompile time, a task that has nothing to do with to ADT encapsulation. Thus, design encapsulation cannot always be realized solely by ADT encapsulation. We believe that Parnas was the first to recognize the concept of design encapsulation <ref> [Par72] </ref>, and Guttag was among the first to recognize the concept of ADT encapsulation [Gut77]. However, the distinction between design and ADT encapsulation was not evident to us before we began the Genesis and Avoca projects. Domain Modeling. Creating a domain model is definitely not an ad hoc process.
Reference: [Par79] <author> D.L. Parnas, </author> <title> `Designing Software for Ease of Extension and Contraction', </title> <journal> IEEE TOSE, </journal> <month> March </month> <year> 1979. </year> <month> - 47 </month> - 
Reference-contexts: Our work affirms and extends basic insights of many pioneers in software engineering: the software families and abstract interface concepts of Parnas <ref> [Par79] </ref>, parameterized types - 3 - of Goguen [Gog84], hierarchical system designs of Habermann [Hab76], object-orientation of Goldberg [Gol84], and the frameworks concept of Deutsch [Deu89]. We begin by explaining the superstructure of large scale systems and its relationship to the design of open-architecture software. - 4 - 2. <p> Note that meta-types, type classes, theories, and realms are themselves types. Our model deals with components and realms. Components. The fundamental unit of large scale software construction is the component. Every component has an interface and an implementation. Following the lead of Parnas <ref> [Par79, Bri81] </ref>, the interface of a component is anything that is visible externally to the component. Everything else belongs to its implementation. Every component is a member of a realm T, where all members of T realize exactly the same interface but in different ways.
Reference: [Pri91] <author> R. Prieto-Diaz and G. Arango, ed., </author> <title> Domain Analysis and Software Systems Modeling, </title> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: It is believed that software component technologies can be achieved through domain analysis, an effort to formalize the similarities and differences among systems of a mature and well-understood domain <ref> [Pri91] </ref>. Our interest in component technologies and domain analysis has arisen from our involvement in two independent projects: Genesis and Avoca. Genesis is the first building-blocks technology for database management systems [Bat85-91a]. Using a graphical layout editor, a customized DBMS can be specified by composing prefabricated software components.
Reference: [Pur85] <author> J. Purtilo, </author> <title> Polylith: An environment to support management of tool interfaces, </title> <booktitle> In Proceedings of the ACM SIGPLAN Symposium on Language Issues in Programming Environments, </booktitle> <month> July </month> <year> 1985. </year>
Reference-contexts: Avoca is most closely related to the MIL IDL [Sno89] and the multi-language programming environments MLP [Hay88] and Polylith <ref> [Pur85] </ref>. (In fact, Polylith notation was used initially for Avoca). However the critical feature of Avoca is the methodology used to design composable protocols [OMa90b]. The notation used to describe such protocols is not nearly as important as properties such as symmetric components.
Reference: [Roy91] <author> J. Roy, </author> <title> `Design and Use of the Jupiter File Management System', M.Sc. </title> <type> Thesis, </type> <institution> Dept. of Computer Science, University of Texas, </institution> <year> 1991. </year>
Reference-contexts: Recognizing that nonkeyed and single-keyed structures are degenerate cases of multikeyed structures, it follows that a general-purpose interface for multikeyed structures works for single-keyed and nonkeyed structures as well. See <ref> [Bat88b, Bat89a, Roy91, Bat91c] </ref> for further details on the implementation of Genesis. - 10 - components. A node can optionally maintain records in key order, optionally share overflow blocks with other nodes, and optionally have primary blocks and/or overflow blocks. <p> See <ref> [Bat89a, Roy91] </ref> for further details. 2.2.2 Storage Systems Realms. Storage systems map conceptual relations to internal relations. They are type expressions of symmetric components from the realm FMAP.
Reference: [Rum91] <author> J. Rumbaugh, M. Blaha, W. Premerlani, F. Eddy, and W. Lorensen, </author> <title> Object-Oriented Modeling and Design, </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: We reinforce our discussions with specific examples taken from the Genesis and Avoca prototypes. 4.1 Layered Software Designs and Transformations Object-Oriented Designs. A primary result of an object-oriented design is an object model or schema that defines the classes of objects of an application and their interrelationships <ref> [Boo91, Rum91, Teo90] </ref>. Associated with each class is the set of operations that can be performed on its objects, plus the set of object attributes. Object models are depicted by class diagrams, where classes are nodes and edges are relationships.
Reference: [SEI90] <author> Software Engineering Institute, </author> <booktitle> Proceedings of the Workshop on Domain-Specific Software Architectures, </booktitle> <month> July 9-12, </month> <year> 1990. </year>
Reference-contexts: A classical, but largely unrealized, goal of software engineering is software component (building-block) technologies. Such technologies are envisioned to exploit large-scale reuse, leverage off of open-architecture designs, and elevate the granularity of programming to the sub-system level <ref> [SEI90] </ref>. It is believed that software component technologies can be achieved through domain analysis, an effort to formalize the similarities and differences among systems of a mature and well-understood domain [Pri91].
Reference: [Sel79] <author> P.G. Selinger, et al., </author> <title> `Access Path Selection in a Relational Database Management System', </title> <booktitle> ACM SIGMOD, </booktitle> <year> 1979. </year>
Reference-contexts: Joining_phase ( G ) =&gt; Sys_R ( G ) ; System R algorithm <ref> [Sel79] </ref> U_ingres ( G ) ; University Ingres algorithm [Won76] Exodus ( G, RS ) ; Exodus rule optimizer [Gra87] - RS is the rule set ... From the above catalogs, it is easy to see how different implementations of components can arise. <p> Specific instances of (*) correspond to query processing algorithms of commercial DBMSs. The data model/data language component of DB2 <ref> [Sel79, Kor91] </ref> uses the following implementation of Q_opt ( ): Q_opt (R) =&gt; Sys_r ( Sql_graph ( R ) ) That is, DB2 uses 1) Sql_graph to map SELECT-FROM-WHERE queries to query graphs, 2) the identity function G for its reducing phase algorithm, and 3) the Sys_r algorithm to map query
Reference: [Sno89] <author> R. Snodgrass, </author> <title> The Interface Description Language: Definition and Use, </title> <publisher> Computer Science Press, </publisher> <address> Rockville, MD., </address> <year> 1989. </year>
Reference-contexts: However, there are three important differences. - 39 - First, a problem with existing MIL's is that they are not sufficient to guarantee module composability, and in some cases don't even seem to encourage the creation of composable modules. Avoca is most closely related to the MIL IDL <ref> [Sno89] </ref> and the multi-language programming environments MLP [Hay88] and Polylith [Pur85]. (In fact, Polylith notation was used initially for Avoca). However the critical feature of Avoca is the methodology used to design composable protocols [OMa90b].
Reference: [Sto76] <author> M. Stonebraker, E. Wong, P. Kreps, and G. </author> <title> Held, `The Design and Implementation of INGRES', </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 1 #3 (Sept. </volume> <year> 1976). </year>
Reference-contexts: In the following paragraphs, we catalog algorithms for each of these suboperations. Q_graph has many implementations, one for every data language: Q_graph ( R ) =&gt; Sql_graph ( R ) ; SQL language [Cha76] Quel_graph ( R ) ; QUEL language <ref> [Sto76] </ref> Gem_graph ( R ) ; GEM language [Zan83] ... The actual choice of Q_graph algorithm is component-specific (e.g., Sql_graph (R) is used for components that present an SQL interface, Quel_graph (R) is used for components that - 27 - present a QUEL interface, and so on).
Reference: [Tan88] <author> A. S. Tanenbaum, </author> <title> Computer Networks, </title> <publisher> Prentice-Hall, </publisher> <year> 1988. </year>
Reference-contexts: and Intel ethernet chips. - 15 - Another subrealm of ASYNC, called EXISTING, contains commonly used protocols such as ip [ ] and udp [ ]. ip [ ] is the Internet Protocol and is responsible for routing packets over the Internet and fragmenting large messages in to smaller ones <ref> [Tan88] </ref>. udp [ ] is a simple demultiplexing protocol which delivers messages to the correct UDP port (a 16 bit integer address). <p> In particular, the Internet community is faced with the task of modifying the internals of TCP because the 16 bit port number they use for addresses is insufficient for many modern applications <ref> [Tan88] </ref>. In Avoca this would be a 30 minute modification. 2.3.3 Network File Systems Realm. The STREAM protocol realm presents a Unix file interface, which offers file read and write operations. STREAM components offer different implementations of network file systems. <p> Sometimes algorithms are rarely published for security or proprietary reasons. Such is the case for command-and-control systems. Other times, algorithms within components are so intertwined that researchers and practitioners make no attempt to separate them. Such is the case with network protocols <ref> [Tan88] </ref>. The database domain is replete with realms in which algorithm cataloging, retrieval algorithms in particular, is possible. In this section, we explain algorithm catalogs and algorithm reuse, and later illustrate their utility in the database domain. - 25 - Algorithm Catalogs.
Reference: [Ten89] <author> D. L. Tennenhouse, </author> <title> `Layered Multiplexing Considered Harmful', </title> <booktitle> 1st International Workshop on High-Speed Networks, </booktitle> <month> (November </month> <year> 1989). </year>
Reference-contexts: ISO architecture sacrificed efficiency for modularity at a time when the introduction of high speed networks required an increase in efficiency. While the networking continued to use layered models to describe network software, layered implementations were actually considered harmful <ref> [Ten89] </ref>. In [OMa90a], it was shown that it is possible to increase performance without sacrificing modularity. Some of the methods used by Avoca to organize heavily layered protocol suites were also used in the higher layers of the ISO architecture. <p> The design of Avoca reflects this fact. Avoca, far from being a top down exercise in software design, is the side-effect of a performance experiment. It was a widely-held belief in the network community that encapsulated and layered protocol design inflicts a prohibitive performance penalty <ref> [Ten89] </ref>. The Avoca domain model was a side effect of an experiment designed to show that this belief was untrue or overstated. It involved the decomposition of the monolithic Sprite RPC protocol into thirty or so micro-protocols; a model was required simply to manage the large number of protocols.
Reference: [Teo86] <author> T.J. Teorey, D. Yang, and J.P. Fry, </author> <title> `A Logical Design Methodology for Relational Databases Using the Extended Entity-Relationship Model', </title> <journal> Computing Surveys, </journal> <month> 18 #2 (June </month> <year> 1986). </year>
Reference-contexts: A type is a set of values. An abstract data type (ADT) is a type plus operations on the values of the type. A class is an ADT that belongs to an inheritance lattice [Car85]. A component is a closely-knit cluster of classes that act as a unit <ref> [Teo86] </ref>. Normally, the values of a type are simple (e.g., numbers, strings, etc). When values become complex entities, different names (other than `type') are generally used. For example, a set of types is called a meta-type.
Reference: [Teo90] <author> T.J. Teorey, </author> <title> Database Modeling and Design: The Entity-Relationship Approach, </title> <publisher> Morgan-Kaufmann, </publisher> <year> 1990. </year>
Reference-contexts: We reinforce our discussions with specific examples taken from the Genesis and Avoca prototypes. 4.1 Layered Software Designs and Transformations Object-Oriented Designs. A primary result of an object-oriented design is an object model or schema that defines the classes of objects of an application and their interrelationships <ref> [Boo91, Rum91, Teo90] </ref>. Associated with each class is the set of operations that can be performed on its objects, plus the set of object attributes. Object models are depicted by class diagrams, where classes are nodes and edges are relationships.
Reference: [Tsi78] <editor> D. Tsichritzis and A. Klug (editors), </editor> <title> The ANSI/X3/SPARC DBMS Framework, </title> <publisher> AFIPS Press, </publisher> <year> 1978. </year>
Reference-contexts: Thus, the distinction we have made between realms and their libraries may have limited applicability. All of these topics are subject for further research. 5.2 Related Research Modular DBMS Software. The first layered architecture to gain popularity in databases was the three-level ANSI/SPARC model <ref> [Tsi78] </ref>. Mappings between levels (the external, conceptual, and internal) were layers, whose implementation it was claimed could be altered independently. To our knowledge, no DBMS ever implemented the ANSI/SPARC architecture; it was a paper design that gave few clues about how to build actual database systems.
Reference: [Wad89] <author> P. Wadler and S. Blott, </author> <title> `How to make ad-hoc polymorphism less ad hoc`, </title> <booktitle> ACM POPL, </booktitle> <year> 1989. </year>
Reference-contexts: Normally, the values of a type are simple (e.g., numbers, strings, etc). When values become complex entities, different names (other than `type') are generally used. For example, a set of types is called a meta-type. A set of ADTs is called a type class <ref> [Wad89] </ref> and a set of classes is a theory [Gog84, Gra91]. We will call a set of components a realm. Note that meta-types, type classes, theories, and realms are themselves types. Our model deals with components and realms. Components. The fundamental unit of large scale software construction is the component.
Reference: [Won76] <author> E. Wong and K. Youseffi, </author> <title> `Decomposition A Strategy for Query Processing', </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 1 #3 (Sept. </volume> <year> 1976). </year>
Reference-contexts: Joining_phase ( G ) =&gt; Sys_R ( G ) ; System R algorithm [Sel79] U_ingres ( G ) ; University Ingres algorithm <ref> [Won76] </ref> Exodus ( G, RS ) ; Exodus rule optimizer [Gra87] - RS is the rule set ... From the above catalogs, it is easy to see how different implementations of components can arise.
Reference: [Yu84] <author> C.T. Yu, Z.M. Ozsoyoglu, and K. Lam, </author> <title> `Optimization of Tree Queries', </title> <journal> Journal of Computer and System Science, </journal> <month> 29 #3 (December </month> <year> 1984). </year>
Reference-contexts: A partial catalog of algorithms for each operation is shown below: 3.5 Reducing_phase ( G ) =&gt; G ; identity no optimization Sdd1 ( G ) ; SDD1 algorithm [Ber81b] Bc ( G ) ; Bernstein & Chiu algorithm [Ber81a] Yol ( G ) ; Yu et al. algorithm <ref> [Yu84] </ref> ... Joining_phase ( G ) =&gt; Sys_R ( G ) ; System R algorithm [Sel79] U_ingres ( G ) ; University Ingres algorithm [Won76] Exodus ( G, RS ) ; Exodus rule optimizer [Gra87] - RS is the rule set ...
Reference: [Zan83] <author> C. Zaniolo, </author> <title> `The Database Language GEM', </title> <booktitle> ACM SIGMOD, </booktitle> <year> 1983. </year>
Reference-contexts: From our experience, selecting few (perhaps two or three) algorithms per operation is sufficient. 3.2.1 An Example From Genesis Recall that DLANG is the realm of nonprocedural data languages. Every DLANG component offers a nonprocedural retrieval statement. (For example, SQL uses the SELECT-FROM-WHERE statement; QUEL and GEM <ref> [Zan83] </ref> use RETRIEVE-WHERE). These statements are translated into optimized expressions, called access plans, that are compositions of retrieval and join operations over base relations. In this section, we catalog implementations of DLANG retrieval statements. <p> In the following paragraphs, we catalog algorithms for each of these suboperations. Q_graph has many implementations, one for every data language: Q_graph ( R ) =&gt; Sql_graph ( R ) ; SQL language [Cha76] Quel_graph ( R ) ; QUEL language [Sto76] Gem_graph ( R ) ; GEM language <ref> [Zan83] </ref> ... The actual choice of Q_graph algorithm is component-specific (e.g., Sql_graph (R) is used for components that present an SQL interface, Quel_graph (R) is used for components that - 27 - present a QUEL interface, and so on). Reducing_phase and Joining_phase algorithms are data language independent.
Reference: [Zim80] <author> H. Zimmermann, </author> <title> `OSI Reference Model---The ISO Model of Architecture for Open Systems Interconnection', </title> <journal> IEEE Transactions on Communications, </journal> <month> 28 #4 (April </month> <year> 1980). </year>
Reference-contexts: Starburst supports `attachments' that are similar to, but less powerful than Genesis components [Lin89]. Attachments are not part of the optimizer model. Modular Network Software. Outside of the networking community, the ISO 7 layer model <ref> [Zim80] </ref> is often cited as an example of the application of modular design to production systems. Inside the networking community, the ISO model is the root cause of the rejection of layering as an efficient way of implementing network software by a variety of network architectures (VMPT [Che87], Sprite [Ous88]).
References-found: 69

