URL: http://www.cs.pitt.edu/~gupta/research/Dist/rtoss94.ps
Refering-URL: http://www.cs.pitt.edu/~gupta/research/dist.html
Root-URL: 
Title: Correlation Analysis Techniques for Refining Execution Time Estimates of Real-Time Applications  
Author: Rajiv Gupta Prabha Gopinath 
Address: Pittsburgh Pittsburgh, PA 15260  MN65-2300 3660 Technology Drive Minneapolis, MN 55418  
Affiliation: Dept. of Computer Science University of  SSDC Honeywell Inc.  
Abstract: Scheduling techniques based upon worst case execution times, as are commonly used in real-time applications, often result in severe underutilization of the processor resources since most tasks finish in much less time than their anticipated worst-case execution times. In this paper we describe techniques for identifying correlation among the executions of various statements within a program. We demonstrate how this information can be used to refine the estimate of remaining worst case execution time of a real-time task as the execution of the task progresses. Refined estimates can be used at run-time to achieve better utilization of the system and early failure detection and recovery. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A.V. Aho, R. Sethi, and J.D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: By combining the ideas of symbolic evaluation, multiple assignments and direct/indirect influences we develop a general algorithm for identifying correlations. The main steps of the algorithm are as follows: 1. A control flow graph (CFG) representation of the program is constructed <ref> [1] </ref>. 2. The program is converted to static single assignment (SSA) form [2]. The conversion of a program into this form guarantees that each variable is reachable from a single definition of that variable, that is, the definition-use relationships in the program are explicit in the program.
Reference: [2] <author> R. Cytron, J. Ferrante, B.K. Rosen, M.N. Wegman, and F.K. Zadeck. </author> <title> Efficiently Computing Static Single Assignment Form and Control Dependence Graph. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 13, No. 4, </volume> <pages> pages 451-490, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: The main steps of the algorithm are as follows: 1. A control flow graph (CFG) representation of the program is constructed [1]. 2. The program is converted to static single assignment (SSA) form <ref> [2] </ref>. The conversion of a program into this form guarantees that each variable is reachable from a single definition of that variable, that is, the definition-use relationships in the program are explicit in the program. This representation simplifies the algorithms used in future steps.
Reference: [3] <author> E. Duesterwald, R. Gupta and M.L. Soffa. </author> <title> Distributed Slicing and Partial Re-execution for Distributed Programs. </title> <booktitle> Proc. Fifth Workshop on Languages and Compilers for Parallel Computing, </booktitle> <publisher> LNCS 757 Springer Ver-lag, </publisher> <pages> pages 497-511, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: We did not consider parallel programs in this paper. However, methods for statically analyzing distributed programs including slicing algorithms also exist <ref> [3] </ref>. Thus we believe that with further research our approach can be extended to handle distributed programs.
Reference: [4] <author> P. Gopinath and R. Gupta. </author> <title> Applying Compiler Techniques to Scheduling in Real time Systems. </title> <booktitle> Proc. 11th Real-Time Systems Symposium, </booktitle> <pages> pages 247-256, </pages> <address> Or-lando, Florida, </address> <month> December </month> <year> 1990. </year>
Reference-contexts: One common solution to this is to add a safety margin by increasing the WET of a task by some arbitrary percentage. This approach further exacerbates the underutilization problem. In order to address the above problems researchers have proposed run-time refinement of execution time estimates based upon monitoring information <ref> [4] </ref> [5] [7]. We had introduced a technique called Compiler Assisted Adaptive Scheduling (CAADS) [4] using which execution times of the various parts of the program are determined at run-time. If time savings are observed at run-time, they can be used to accommodate newly arriving tasks. <p> This approach further exacerbates the underutilization problem. In order to address the above problems researchers have proposed run-time refinement of execution time estimates based upon monitoring information <ref> [4] </ref> [5] [7]. We had introduced a technique called Compiler Assisted Adaptive Scheduling (CAADS) [4] using which execution times of the various parts of the program are determined at run-time. If time savings are observed at run-time, they can be used to accommodate newly arriving tasks.
Reference: [5] <author> D. Haban and K.G. Shin. </author> <title> Application of Real-Time Monitoring to Scheduling Tasks with Random Execution Times. </title> <booktitle> Proc. 10th Real-Time Systems Symposium, </booktitle> <year> 1989. </year>
Reference-contexts: It also often results in severe under-utilization of the system since tasks typically complete in much less time (sometimes orders of magnitude less) than their WETs would indicate <ref> [5] </ref>. Another problem with the above approach to scheduling based on worst-case execution times arises when a task for some reason, perhaps owing to resource sharing delays, exceeds its WET. This results in deadline failure, but such a failure is noticed very late in the task's lifetime. <p> This approach further exacerbates the underutilization problem. In order to address the above problems researchers have proposed run-time refinement of execution time estimates based upon monitoring information [4] <ref> [5] </ref> [7]. We had introduced a technique called Compiler Assisted Adaptive Scheduling (CAADS) [4] using which execution times of the various parts of the program are determined at run-time. If time savings are observed at run-time, they can be used to accommodate newly arriving tasks.
Reference: [6] <author> S-T. Pan, K. So and J.T. Rahmeh. </author> <title> Improving the Accuracy of Dynamic Branch Prediction Using Branch Correlation. </title> <booktitle> Proc. Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 76-84, </pages> <year> 1992. </year>
Reference-contexts: Evidence that a significant degree of correlation exists in programs has been recently provided by Pan et al <ref> [6] </ref>. They found that correlation information significantly improved the accuracy of branch prediction. Their results show that as compared to 2-bit counter-based prediction scheme, the correlation-based branch prediction achieved 11% additional accuracy. In this paper we propose to utilize correlation information for improving RWET estimates. <p> In order to do so we must identify correlation present in a program. Correlation can be detected at compile-time through static analysis techniques and at run-time using profiling techniques. Surprisingly, many of the opportunities for correlation identified by Pan et al <ref> [6] </ref> using run-time history can also be identified through compile-time analysis of a program. However, Pan et al [6] did not develop any techniques for identifying correlation through program analysis. In this paper we develop such techniques. <p> Correlation can be detected at compile-time through static analysis techniques and at run-time using profiling techniques. Surprisingly, many of the opportunities for correlation identified by Pan et al <ref> [6] </ref> using run-time history can also be identified through compile-time analysis of a program. However, Pan et al [6] did not develop any techniques for identifying correlation through program analysis. In this paper we develop such techniques. In section 2 we identify the type of correlation information that is useful for refining RWETs and we briefly illustrate how correlation information is used to carry out the refinement. <p> S0 (1): if (..) f S1 (1): a = 0 g S3 (1): ... S4 (1): ... g The above example illustrates a common situation that Pan et al <ref> [6] </ref> observed in many SPEC integer benchmark programs such as the gnu C-compiler, eqntott, li etc. Very often there are statements that assign constant values to variables that are typically flags.
Reference: [7] <author> C. Park and A. Shaw. </author> <title> Experiments with a Program Timing Tool Based on Source-Level Timing Schema. </title> <booktitle> Proc. 11th Real-Time Systems Symposium, </booktitle> <pages> pages 72-81, </pages> <year> 1990. </year>
Reference-contexts: This approach further exacerbates the underutilization problem. In order to address the above problems researchers have proposed run-time refinement of execution time estimates based upon monitoring information [4] [5] <ref> [7] </ref>. We had introduced a technique called Compiler Assisted Adaptive Scheduling (CAADS) [4] using which execution times of the various parts of the program are determined at run-time. If time savings are observed at run-time, they can be used to accommodate newly arriving tasks.
Reference: [8] <author> L. Sha and J. Goodenough. </author> <title> Real Time Scheduling Theory and ADA. </title> <booktitle> Computer, </booktitle> <pages> pages 53-62, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: It does not scale con fl Partially supported by National Science Foundation Presidential Young Investigator Award CCR-9157371 to the University of Pittsburgh. veniently as the system gets larger <ref> [8] </ref>. It also often results in severe under-utilization of the system since tasks typically complete in much less time (sometimes orders of magnitude less) than their WETs would indicate [5].
Reference: [9] <author> M. Weiser. </author> <title> Program Slicing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. SE-10, No. 4, </volume> <pages> pages 352-357, </pages> <month> July </month> <year> 1984. </year>
Reference-contexts: S0: if (aa==2) f S1: aa = 0 g B0: if (aa!=bb) f S5: .... g Assignment Statements. 3. Indirectly Affecting Assignments: In some situations in order to identify correlations we need to compute a program data slice <ref> [9] </ref> which identifies all those statements that directly or indirectly influence the values of variables used in a branch condition. Consider the example shown in Figure 4. The program slice for the value of y in S5 is includes statements S1, S2 and S4. <p> The data slice contains all statements that directly or indirectly lead to the computation of the value of v used in the branch condition. Thus, the data slice is computed by taking a closure of data de pendences for the variable <ref> [9] </ref>. * Corresponding to each variable v, using the data slice DS (v) and forward substituting expressions, we generate a set of symbolic expressions, SE (v), that represent the value of variable v at B under various program executions.
References-found: 9

