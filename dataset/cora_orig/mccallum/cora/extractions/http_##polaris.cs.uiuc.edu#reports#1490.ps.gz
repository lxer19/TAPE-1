URL: http://polaris.cs.uiuc.edu/reports/1490.ps.gz
Refering-URL: http://polaris.cs.uiuc.edu/polaris/rep2.html
Root-URL: http://www.cs.uiuc.edu
Email: bblume@hpclopt.cup.hp.com eigenman@ecn.purdue.edu  
Title: Non-Linear and Symbolic Data Dependence Testing  
Author: William Blume Rudolf Eigenmann 
Date: April 19, 1996  
Affiliation: Hewlett-Packard, California Purdue University, Indiana  
Abstract: One of the most crucial qualities of an optimizing compiler is its ability to detect when different data references access the same storage location. Such references are said to be data-dependent and they impose constraints on the amount of program modifications the compiler can apply for improving the program's performance. For parallelizing compilers the most important program constructs to investigate are loops and the array references they contain. In previous work we have found a serious limitation of current data dependence tests to be that they cannot handle loop bounds or array subscripts that are symbolic, nonlinear expressions. In this paper, we describe a dependence test, called the Range Test, that can handle such expressions. Briefly, the Range Test proves independence by determining whether certain symbolic inequalities hold for a permutation of the loop nest. Powerful symbolic analyses and constraint propagation techniques were developed to prove such inequalities. The Range Test has been implemented in Polaris, a parallelizing compiler developed at the University of Illinois we will present measurements of the Range Test's performance and compare it with state-of-the-art tests.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Utpal Banerjee. </author> <title> Dependence Analysis for Supercomputing. </title> <publisher> Kluwer. </publisher> <address> Boston, MA, </address> <year> 1988. </year>
Reference-contexts: Powerful dependence tests are needed to effectively exploit the inherent parallelism in these sequential programs. There has been much research in the area of data dependence analysis <ref> [1, 19, 26, 28, 31] </ref>. Modern day data dependence tests have become very accurate and efficient. However, most of these tests require the loop bounds and array subscripts to be represented as a linear (affine) function of loop index variables. <p> Section 8 presents our conclusions and plans for future work. 2 Data dependence In this section we will give a brief definition of data dependences. For a more thorough description of data dependence and dependence analysis, see Banerjee et al <ref> [3, 1, 31] </ref>. To ease the presentation of the Range Test, we will assume that we have a perfectly nested FORTRAN-77 loop nest as shown in Figure 2. We will also assume that the tested array A has only one dimension. <p> The following discussion compares our test to one of the most effective state-of-the-art tests and points out related ideas of other projects. Mathematically, the Range Test can be thought of as an extension of a symbolic version of the Triangular Banerjee's Inequalities test with dependence direction vectors <ref> [1, 30] </ref>, which is one of the most effective state-of-the-art tests. (However, our approach and implementation are substantially different.) The only drawback of our test, compared to the Triangular Banerjee's test with directions, is that it cannot test arbitrary direction vectors, particularly those containing more than one `&lt;' or `&gt;' (e.g.,
Reference: [2] <author> Utpal Banerjee. </author> <title> A Theory of Loop Permutations. </title> <editor> In A. Nicolau D. Gelernter and D. Padua, editors, </editor> <booktitle> Languages and Compilers for Parallel Processing, </booktitle> <pages> pages 54-74. </pages> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: We will show that this heuristic generates a legal permutation using Lemma 1, for whose proof we refer to Banerjee's <ref> [2] </ref>. Lemma 1 A loop that does not carry a dependence can be legally moved deeper into the loop nest and all loops that didn't carry a dependence beforehand would still not do so.
Reference: [3] <author> Utpal Banerjee, Rudolf Eigenmann, Alexandru Nicolau, and David Padua. </author> <title> Automatic Program Parallelization. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 81(2) </volume> <pages> 211-243, </pages> <month> February </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Parallelizing compilers are necessary to allow programs written in standard sequential languages to run efficiently on parallel machines. In order to achieve good performance, these compilers must be able to identify the important loops whose iterations can be run concurrently, and transform these loops into parallel ones <ref> [3] </ref>. Powerful dependence tests are needed to effectively exploit the inherent parallelism in these sequential programs. There has been much research in the area of data dependence analysis [1, 19, 26, 28, 31]. Modern day data dependence tests have become very accurate and efficient. <p> Section 8 presents our conclusions and plans for future work. 2 Data dependence In this section we will give a brief definition of data dependences. For a more thorough description of data dependence and dependence analysis, see Banerjee et al <ref> [3, 1, 31] </ref>. To ease the presentation of the Range Test, we will assume that we have a perfectly nested FORTRAN-77 loop nest as shown in Figure 2. We will also assume that the tested array A has only one dimension.
Reference: [4] <author> M. Berry, D. Chen, P. Koss, D. Kuck, L. Pointer, S. Lo, Y. Pang, R. Roloff, A. Sameh, E. Clementi, S. Chin, D. Schneider, G. Fox, P. Messina, D. Walker, C. Hsiung, J. Schwarzmeier, K. Lue, S. Orszag, F. Seidl, O. Johnson, G. Swanson, R. Goodrum, and J. Martin. </author> <title> The Perfect Club Benchmarks: Effective Performance Evaluation of Supercomputers. </title> <journal> Int'l. Journal of Supercomputer Applications, </journal> <volume> 3(3) </volume> <pages> 5-40, </pages> <month> Fall </month> <year> 1989. </year>
Reference-contexts: After simplification, this becomes [1 : 1]. From this range, we can now see that x fl y + 1 &gt; y. 5 Examples In this section, we will provide examples of important loop nests, taken from the Perfect Benchmarks <ref> [4] </ref>, that the Range Test can determine to be parallel but which conventional data dependence tests cannot. One example is a loop nest taken from subroutine FTRVMT from the code OCEAN. This loop nest accounts for 44% of the code's sequential execution time on an Alliant FX/80.
Reference: [5] <author> Bill Blume and Rudolf Eigenmann. </author> <title> Demand-driven, Symbolic Range Propagation. </title> <booktitle> Proceedings of the Eighth Workshop on Languages and Compilers for Parallel Computing, </booktitle> <month> August </month> <year> 1995. </year>
Reference-contexts: The range propagation algorithm can be somewhat costly, although not prohibitively so. Because of this, we have developed several techniques to improve its efficiency, such as using Static 20 Single Assignment form [14], propagating ranges derived only from control flow, or propagating ranges only on demand <ref> [5] </ref>.
Reference: [6] <author> Bill Blume, Rudolf Eigenmann, Keith Faigin, John Grout, Jay Hoeflinger, David Padua, Paul Petersen, Bill Pottenger, Lawrence Rauchwerger, Peng Tu, and Stephen Weatherford. </author> <title> Polaris: The Next Generation in Parallelizing Compilers. </title> <booktitle> Proceedings of the Workshop on Languages and Compilers for Parallel Computing, </booktitle> <address> Ithaca, New York, pages 10.1 - 10.18, </address> <month> August </month> <year> 1994. </year>
Reference-contexts: Because of this, dependence arcs from reductions, induction variables, and private arrays and scalars have already been eliminated when the Range and Omege Tests were executed. Details of these advanced techniques can be found in <ref> [10, 6] </ref>. From Table 2, we can see that there are cases where the Range Test does better, and cases where the Omega Test does better. This should not be surprising, because the Omega Test has difficulties with non-affine expressions while the Range Test was designed to handle such cases. <p> We have implemented the Range Test together with a symbolic range propagation algorithm in Polaris, a parallelizing compiler being developed at the University of Illinois <ref> [18, 6] </ref>. Currently, the Range Test is the only data dependence test implemented in Polaris. <p> However, with the Range Test, along with other advanced techniques mentioned in <ref> [6] </ref>, we are able to optimize the codes close to the hand parallelized versions, which reached a speedup of 43 for TRFD and 16 for OCEAN.
Reference: [7] <author> William Blume and Rudolf Eigenmann. </author> <title> The Range Test: A Dependence Test for Symbolic, Nonlinear Expressions. </title> <booktitle> Proceedings of Supercomputing '94, </booktitle> <address> Washington D.C., </address> <pages> pages 528-537, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: Powerful variable constraint propagation and symbolic simplification techniques were developed to determine such inequality relationships. To maximize the number of loops found parallel using the Range Test, we examine the loops in the loop nest in a permuted order. The Range Test has been introduced in <ref> [7] </ref>. Since then, we have evaluated the test extensively and compared it with other data dependence tests. Section 2 briefly defines data dependences and direction vectors. Section 3 then describes the Range Test. Section 4 gives an overview of the range propagation algorithm, which allows us to compare symbolic expressions.
Reference: [8] <author> William Blume and Rudolf Eigenmann. </author> <title> Symbolic Range Propagation. </title> <booktitle> Proceedings of the 9th International Parallel Processing Symposium, </booktitle> <pages> pages 357-363, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: We will only give a brief sketch of this technique and refer to interested reader to <ref> [8] </ref>. Range propagation consists of two parts: the range propagation algorithm and an expression comparison facility. The range propagation algorithm collects and propagates variable constraints through a program. The expression comparison facility uses these variable constraints to determine arithmetic relationships between two symbolic expressions.
Reference: [9] <author> William Blume and Rudolf Eigenmann. </author> <title> An Overview of Symbolic Analysis Techniques Needed for the Effective Parallelization of the Perfect Benchmarks. </title> <booktitle> Proceedings of the 1994 International Conference on Parallel Processing, </booktitle> <address> pages II233 II238, </address> <month> August, </month> <year> 1994. </year>
Reference-contexts: For example, a parallelizing compiler could achieve a speedup of at most two for the codes OCEAN and TRFD from the Perfect Benchmarks if it could not parallelize loops with nonlinear array subscripts <ref> [9] </ref>. For some of these loops, nonlinear expressions occurred in the original program text. For other loops, nonlinear expressions were introduced by the compiler. Two common compiler passes can introduce nonlinearities into array subscript expressions: induction variable substitution and array linearization. <p> Early ideas of such a test were described in <ref> [17, 23, 9] </ref>. The most distinguished feature of the test may be the fact that it is now available in an actual compiler, which has proven to parallelize important programs to an unprecedented degree.
Reference: [10] <author> William Blume, Rudolf Eigenmann, Jay Hoeflinger, David Padua, Paul Petersen, Lawrence Rauch-werger, and Peng Tu. </author> <title> Automatic Detection of Parallelism: A Grand Challenge for High-Performance Computing. </title> <journal> IEEE Parallel and Distributed Technology, </journal> <volume> 2(3) </volume> <pages> 37-47, </pages> <month> Fall </month> <year> 1994. </year>
Reference-contexts: Because of this, dependence arcs from reductions, induction variables, and private arrays and scalars have already been eliminated when the Range and Omege Tests were executed. Details of these advanced techniques can be found in <ref> [10, 6] </ref>. From Table 2, we can see that there are cases where the Range Test does better, and cases where the Omega Test does better. This should not be surprising, because the Omega Test has difficulties with non-affine expressions while the Range Test was designed to handle such cases.
Reference: [11] <author> Franc~ois Bourdoncle. </author> <title> Abstract Debugging of Higher-Order Imperative Languages. </title> <booktitle> Proceedings of the ACM SIGPLAN '93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 46-55, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: There has been some work in the determination of variable constraints. Much work has been done in determining the possible range, or interval, of values that variables can take, for the purpose of array bounds checking or program verification <ref> [22, 11] </ref>. These algorithms, however, only propagate integer ranges.
Reference: [12] <author> Partrick Cousot and Radhia Cousot. </author> <title> Abstract Interpretation: A unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints. </title> <booktitle> Proceedings of the 4th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 238-252, </pages> <month> January </month> <year> 1977. </year>
Reference-contexts: The expression comparison facility uses these variable constraints to determine arithmetic relationships between two symbolic expressions. The range propagation algorithm centers on the collection and propagation of symbolic lower and upper bounds on variables, called ranges, through a program unit. Abstract interpretation <ref> [12] </ref> is used to compute the ranges for variables at each point of a program unit. <p> These merged ranges are computed by taking the largest upper bound and smallest lower bound from the merging control flow paths. To guarantee that the algorithm eventually reaches a fixed point and halts, a widening operator <ref> [12] </ref> is also applied to merge points that are loop headers. This widening operator sets a range to a conservative value if the range has changed too often during the course of computation.
Reference: [13] <author> Patrick Cousot and Nicolas Halbwachs. </author> <title> Automatic Discovery of Linear Restraints Among Variables of a Program. </title> <booktitle> In Proceedings of the 5th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 84-97, </pages> <year> 1978. </year>
Reference-contexts: Much work has been done in determining the possible range, or interval, of values that variables can take, for the purpose of array bounds checking or program verification [22, 11]. These algorithms, however, only propagate integer ranges. Cousot and Halbwachs <ref> [13] </ref> offer a powerful algorithm for determining symbolic linear constraints between variables. (Their algorithm is used by Haghighat's symbolic dependence test to determine variable constraints.) Their algorithm is based upon the calculation, intersection, and merging of convex polyhedrons in the n-space of variable values.
Reference: [14] <author> Ron Cytron, Jeanne Ferrante, Barry K. Rosen, Mark N. Wegman, and F. Kenneth Zadeck. </author> <title> Efficiently Computing Static Single Assignment Form and the Control Dependence Graph. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(4) </volume> <pages> 451-490, </pages> <month> October </month> <year> 1991. </year> <month> 21 </month>
Reference-contexts: In these versions, the Range Test should not significantly increase the compiler's execution time. The range propagation algorithm can be somewhat costly, although not prohibitively so. Because of this, we have developed several techniques to improve its efficiency, such as using Static 20 Single Assignment form <ref> [14] </ref>, propagating ranges derived only from control flow, or propagating ranges only on demand [5].
Reference: [15] <author> R. J. Duffin. </author> <title> On Fourier's Analysis of Linear Inequality Systems. </title> <booktitle> Mathematical Programming Study 1, </booktitle> <pages> pages 71-95, </pages> <year> 1974. </year>
Reference-contexts: Nevertheless, the Omega test serves as an interesting reference point. Roughly, the Omega Test is a variant of integer Fourier-Motzkin analysis <ref> [15, 29] </ref> with optimizations to make the common cases fast. For affine array subscripts and loop bounds, the Omega Test is an exact data dependence test. The Omega Test handles non-affine expressions using uninterpreted function symbols.
Reference: [16] <author> Rudolf Eigenmann, Jay Hoeflinger, G. Jaxon, and David Padua. </author> <title> The Cedar Fortran Project. </title> <type> Technical Report 1262, </type> <institution> Univ. of Illinois at Urbana-Champaign, Cntr. for Supercomputing Res, & Dev., </institution> <month> April </month> <year> 1992. </year>
Reference-contexts: Unfortunately, not all nonlinear expressions can be removed. It was believed that this would not be a problem for dependence testing real programs since nonlinear expressions would be rare. However, our manual parallelization effort of the Perfect Benchmarks have shown us that this is not the case <ref> [17, 16] </ref>. For example, a parallelizing compiler could achieve a speedup of at most two for the codes OCEAN and TRFD from the Perfect Benchmarks if it could not parallelize loops with nonlinear array subscripts [9]. For some of these loops, nonlinear expressions occurred in the original program text.
Reference: [17] <author> Rudolf Eigenmann, Jay Hoeflinger, Zhiyuan Li, and David Padua. </author> <title> Experience in the Automatic Parallelization of Four Perfect-Benchmark Programs. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> 589, </volume> <pages> pages 65-83, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: Unfortunately, not all nonlinear expressions can be removed. It was believed that this would not be a problem for dependence testing real programs since nonlinear expressions would be rare. However, our manual parallelization effort of the Perfect Benchmarks have shown us that this is not the case <ref> [17, 16] </ref>. For example, a parallelizing compiler could achieve a speedup of at most two for the codes OCEAN and TRFD from the Perfect Benchmarks if it could not parallelize loops with nonlinear array subscripts [9]. For some of these loops, nonlinear expressions occurred in the original program text. <p> Early ideas of such a test were described in <ref> [17, 23, 9] </ref>. The most distinguished feature of the test may be the fact that it is now available in an actual compiler, which has proven to parallelize important programs to an unprecedented degree.
Reference: [18] <author> Keith A. Faigin, Jay P. Hoeflinger, David A. Padua, Paul M. Petersen, and Stephen A. Weatherford. </author> <title> The Polaris Internal Representation. </title> <journal> International Journal of Parallel Programming, </journal> <volume> 22(5) </volume> <pages> 553-586, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: We have implemented the Range Test together with a symbolic range propagation algorithm in Polaris, a parallelizing compiler being developed at the University of Illinois <ref> [18, 6] </ref>. Currently, the Range Test is the only data dependence test implemented in Polaris.
Reference: [19] <author> Gina Goff, Ken Kennedy, and Chau-Wen Tseng. </author> <title> Practical Dependence Testing. </title> <booktitle> In Proceedings of the ACM SIGPLAN 91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 15-29, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: Powerful dependence tests are needed to effectively exploit the inherent parallelism in these sequential programs. There has been much research in the area of data dependence analysis <ref> [1, 19, 26, 28, 31] </ref>. Modern day data dependence tests have become very accurate and efficient. However, most of these tests require the loop bounds and array subscripts to be represented as a linear (affine) function of loop index variables. <p> Induction variable substitution replaces loop-variant (i.e., non-constant) expressions by terms that are closer to the affine forms understood by the dependence tests. Other techniques have also been developed to handle additive, loop-invariant, symbolic terms or to eliminate unwanted operations such as divisions <ref> [19, 26, 28] </ref>. Unfortunately, not all nonlinear expressions can be removed. It was believed that this would not be a problem for dependence testing real programs since nonlinear expressions would be rare.
Reference: [20] <author> Mohammad Haghighat and Constantine Polychronopoulos. </author> <title> Symbolic Dependence Analysis for High-Performance Parallelizing Compilers. </title> <booktitle> Parallel and Distributed Computing: Advances in Languages and Compilers for Parallel Processing, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <pages> pages 310-330, </pages> <year> 1991. </year>
Reference-contexts: Haghighat and Polychronopoulos, presented a dependence test to handle nonlinear, symbolic expressions <ref> [20] </ref>. Their algorithm is essentially a symbolic version of Banerjee's Inequalities test.
Reference: [21] <author> Mohammad Haghighat and Constantine Polychronopoulos. </author> <title> Symbolic Analysis: A Basis for Paral-leliziation, Optimization, and Scheduling of Programs. </title> <booktitle> Proceedings of the Sixth Annual Languages and Compilers for Parallelism Workshop, </booktitle> <address> Portland, Oregon, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: We also determine variable constraints and perform symbolic inequality tests, although we use different techniques. We will compare these two methods later in this section. In a separate paper, Haghighat and Polychronopoulos <ref> [21] </ref> describe a technique to prove that a symbolic expression is strictly increasing or decreasing. By using this technique, self-dependences for an array reference can be eliminated. Their example can prove that all the loops in Figure 8, after induction variable substitution, are parallel.
Reference: [22] <author> William H. Harrison. </author> <title> Compiler Analysis of the Value Ranges for Variables. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-3(3):243-250, </volume> <month> May </month> <year> 1977. </year>
Reference-contexts: There has been some work in the determination of variable constraints. Much work has been done in determining the possible range, or interval, of values that variables can take, for the purpose of array bounds checking or program verification <ref> [22, 11] </ref>. These algorithms, however, only propagate integer ranges.
Reference: [23] <author> Jay Hoeflinger. </author> <title> Run-Time Dependence Testing by Integer Sequence Analysis. </title> <type> Technical Report 1194, </type> <institution> Univ. of Illinois at Urbana-Champaign, Center for Supercomputing Res. & Dev., </institution> <month> January </month> <year> 1992. </year>
Reference-contexts: Early ideas of such a test were described in <ref> [17, 23, 9] </ref>. The most distinguished feature of the test may be the fact that it is now available in an actual compiler, which has proven to parallelize important programs to an unprecedented degree.
Reference: [24] <author> Wayne Kelly, Vadim Maslov, William Pugh, Evan Rosser, Tatiana Shpeisman, and David Wonna-cott. </author> <title> The Omega Library (version 0.91) Interface Guide. </title> <type> Technical report, </type> <institution> University of Maryland, </institution> <month> February </month> <year> 1995. </year>
Reference-contexts: For affine array subscripts and loop bounds, the Omega Test is an exact data dependence test. The Omega Test handles non-affine expressions using uninterpreted function symbols. Our implementation of the Omega Test uses the Omega Library version 0.91 <ref> [24] </ref>. 14 Since uninterpreted function symbols are the Omega Test's solution to non-affine expressions, the functionality of uninterpreted function symbols needs some further explanation. An uninterpreted function symbol is simply a variable with one or more arguments, (e.g., f (i; j)), representing a side-effect-free function.
Reference: [25] <author> Vadim Maslov. Delinearization: </author> <title> An Efficient Way to Break Multiloop Dependence Equations. </title> <booktitle> Proceedings of the SIGPLAN `92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 152-161, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: However, as described, the test only handles self-dependences. The subroutine OLDA in TRFD has other important loop nests that has multiple array accesses with nonlinear subscript expressions similar to the subscripts from Figure 8. 19 Maslov <ref> [25] </ref> presents an alternate way to handle symbolic, non-linear expressions. Instead of testing these expressions directly, his algorithm partitions the expression into several independent subexpres-sions, then tests these partitions using conventional data dependence tests. Essentially, it delinearizes array references.
Reference: [26] <author> D. Maydan, J. Hennessy, and M. Lam. </author> <title> Efficient and exact data dependence analysis. </title> <booktitle> In SIGPLAN NOTICES: Proceedings of the ACM SIGPLAN 91 Conference on Programming Language Design and Implementation, </booktitle> <address> Toronto, Ontario, Canada, </address> <month> June 26-28, </month> <pages> pages 1-14. </pages> <publisher> ACM Press, </publisher> <year> 1991. </year>
Reference-contexts: Powerful dependence tests are needed to effectively exploit the inherent parallelism in these sequential programs. There has been much research in the area of data dependence analysis <ref> [1, 19, 26, 28, 31] </ref>. Modern day data dependence tests have become very accurate and efficient. However, most of these tests require the loop bounds and array subscripts to be represented as a linear (affine) function of loop index variables. <p> Induction variable substitution replaces loop-variant (i.e., non-constant) expressions by terms that are closer to the affine forms understood by the dependence tests. Other techniques have also been developed to handle additive, loop-invariant, symbolic terms or to eliminate unwanted operations such as divisions <ref> [19, 26, 28] </ref>. Unfortunately, not all nonlinear expressions can be removed. It was believed that this would not be a problem for dependence testing real programs since nonlinear expressions would be rare. <p> However, with the Range Test, along with other advanced techniques mentioned in [6], we are able to optimize the codes close to the hand parallelized versions, which reached a speedup of 43 for TRFD and 16 for OCEAN. With the aid of memoization <ref> [26] </ref>, or the caching of already tested array subscript pairs, we have found the execution time of the Range Test to be acceptable, even when applied as the only test. In future versions of Polaris, we will only invoke this test when other dependence tests fail due to nonlinear expressions.
Reference: [27] <author> Paul M. Petersen and David A. Padua. </author> <title> Static and Dynamic Evaluation of Data Dependence Analysis. </title> <booktitle> Presented at ICS'93, </booktitle> <address> Tokyo, Japan, </address> <pages> pages 107-116, </pages> <month> July 19-23, </month> <year> 1993. </year>
Reference-contexts: We chose this comparison because the Omega test is among the most accurate data-dependence tests available. In terms of efficiency, the Omaga test may not be the ideal comparison because, as others have pointed out, simpler and faster tests are equally powerful in practice <ref> [27] </ref>. Nevertheless, the Omega test serves as an interesting reference point. Roughly, the Omega Test is a variant of integer Fourier-Motzkin analysis [15, 29] with optimizations to make the common cases fast. For affine array subscripts and loop bounds, the Omega Test is an exact data dependence test.
Reference: [28] <author> William Pugh. </author> <title> A Practical Algorithm for Exact Array Dependence Analysis. </title> <journal> Communications of the ACM, </journal> <volume> 35(8) </volume> <pages> 102-114, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: Powerful dependence tests are needed to effectively exploit the inherent parallelism in these sequential programs. There has been much research in the area of data dependence analysis <ref> [1, 19, 26, 28, 31] </ref>. Modern day data dependence tests have become very accurate and efficient. However, most of these tests require the loop bounds and array subscripts to be represented as a linear (affine) function of loop index variables. <p> Induction variable substitution replaces loop-variant (i.e., non-constant) expressions by terms that are closer to the affine forms understood by the dependence tests. Other techniques have also been developed to handle additive, loop-invariant, symbolic terms or to eliminate unwanted operations such as divisions <ref> [19, 26, 28] </ref>. Unfortunately, not all nonlinear expressions can be removed. It was believed that this would not be a problem for dependence testing real programs since nonlinear expressions would be rare. <p> The Range Test, on the other hand, would have no difficulties in proving that this array has no self-dependences. 6 Measurements To measure the effectiveness and speed of the Range Test, we compared its results with the Omega Test <ref> [28] </ref>. We chose this comparison because the Omega test is among the most accurate data-dependence tests available. In terms of efficiency, the Omaga test may not be the ideal comparison because, as others have pointed out, simpler and faster tests are equally powerful in practice [27]. <p> For example, it converts an array reference A (n fl i + j), where 1 j n, into a two-dimensional array A (j; i). The greatest strength of this technique is that it can convert non-linear expressions into linear ones, allowing exact data tests like the Omega Test <ref> [28] </ref> to be applied. Because of this, there are situations where Maslov's algorithm succeeds whereas the Range Test does not, such as the array references A (n fl i + j) and A (i + n fl j), where 1 i j n.
Reference: [29] <author> H. P. Williams. </author> <title> Fourier's method of Linear Programming and its Dual. </title> <journal> The American Mathematical Monthly, </journal> <volume> 93(9) </volume> <pages> 681-695, </pages> <month> November </month> <year> 1986. </year>
Reference-contexts: Nevertheless, the Omega test serves as an interesting reference point. Roughly, the Omega Test is a variant of integer Fourier-Motzkin analysis <ref> [15, 29] </ref> with optimizations to make the common cases fast. For affine array subscripts and loop bounds, the Omega Test is an exact data dependence test. The Omega Test handles non-affine expressions using uninterpreted function symbols.
Reference: [30] <author> Michael Wolfe. </author> <title> Triangular Banerjee's Inequalities with Directions. </title> <type> Technical report, </type> <institution> Oregon Graduate Institute of Science and Technology, </institution> <month> June </month> <year> 1992. </year> <pages> CS/E 92-013. </pages>
Reference-contexts: The following discussion compares our test to one of the most effective state-of-the-art tests and points out related ideas of other projects. Mathematically, the Range Test can be thought of as an extension of a symbolic version of the Triangular Banerjee's Inequalities test with dependence direction vectors <ref> [1, 30] </ref>, which is one of the most effective state-of-the-art tests. (However, our approach and implementation are substantially different.) The only drawback of our test, compared to the Triangular Banerjee's test with directions, is that it cannot test arbitrary direction vectors, particularly those containing more than one `&lt;' or `&gt;' (e.g.,
Reference: [31] <author> Michael Wolfe and Utpal Banerjee. </author> <title> Data Dependence and its Application to Parallel Processing. </title> <journal> International Journal of Parallel Programming, </journal> <volume> 16(2) </volume> <pages> 137-178, </pages> <year> 1987. </year> <month> 22 </month>
Reference-contexts: Powerful dependence tests are needed to effectively exploit the inherent parallelism in these sequential programs. There has been much research in the area of data dependence analysis <ref> [1, 19, 26, 28, 31] </ref>. Modern day data dependence tests have become very accurate and efficient. However, most of these tests require the loop bounds and array subscripts to be represented as a linear (affine) function of loop index variables. <p> Section 8 presents our conclusions and plans for future work. 2 Data dependence In this section we will give a brief definition of data dependences. For a more thorough description of data dependence and dependence analysis, see Banerjee et al <ref> [3, 1, 31] </ref>. To ease the presentation of the Range Test, we will assume that we have a perfectly nested FORTRAN-77 loop nest as shown in Figure 2. We will also assume that the tested array A has only one dimension.
References-found: 31

