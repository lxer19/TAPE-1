URL: file://ftp.di.unipi.it/pub/Papers/meo/ResSem94tr.ps.gz
Refering-URL: http://www.di.unipi.it/di/groups/lp/papers.html
Root-URL: 
Email: gabbri@cwi.nl  fgabbri,levi,meog@di.unipi.it  
Phone: 2  
Author: Gabbrielli ; Giorgio Levi Maria Chiara Meo 
Affiliation: Dipartimento di Informatica, Universita di Pisa,  
Address: Kruislaan 413, 1098 SJ Amsterdam, The Netherlands  Corso Italia 40, 56125 Pisa, Italy,  
Note: Maurizio  
Abstract: Resultants Semantics for Prolog Abstract In this paper we study some first order formulas, called resultants, which can be used to describe in a concise way most of the relevant information associated to SLD-derivations. We first extend to resultants some classical results of logic programming theory. Then we define a fixpoint semantics for Prolog computed resultants, i.e. those formulas which are obtained by considering the leftmost selection rule. Suitable abstractions of such a semantics are then used to model call patterns and partial answers. Finally we show how these results can be generalized to a larger class of selection rules.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. R. Apt. </author> <title> Introduction to Logic Programming. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B: Formal Models and Semantics, </booktitle> <pages> pages 495-574. </pages> <publisher> Elsevier, Amsterdam and The MIT Press, </publisher> <address> Cambridge, </address> <year> 1990. </year>
Reference-contexts: In this subsection we introduce some notations we will use in the following and, for the reader's convenience, we recall some basic notions. We refer to <ref> [20, 1] </ref> for further details on the logic programming theory. <p> An SLD-refutation of P [ G is a finite SLD-derivation of P [ G which has the empty clause 2 as the last query in the derivation. A selection rule R is usually (see <ref> [1] </ref>) defined as a function which when applied to a "history" containing the goal, all the clauses and the mgu's used in the derivation G 0 ; G 1 ; : : :G i , returns an atom in G i . <p> An SLD-derivation is fair if 1 The mgu's used in SLD-derivation are not always assumed to be idempotent. Note that, since idempotent mgu's are also relevant, the previous "static" definition of renaming apart of clauses is sufficient (see <ref> [1] </ref>). Such a static renaming would not be correct when non relevant mgu's are used. <p> Moreover, since f ~ Bg is a set of (ground) atoms, from the switching lemma <ref> [1] </ref> we can derive that there exists also a refutation G 0 ; P;R ~ D 1 ; f ~ Bg;R 2; (1) where, since G 0 is ground, # jV ar (G 0 ) is clearly the empty substitution ". <p> Lemma 2.6 (And-compositionality of derivations) Let P be a program and G : A 1 ; : : :; A n be a query. (i) If there exists an LD-derivation G # ; P;L ~ B then there exists i 2 <ref> [1; n] </ref>; such that * for any j 2 [1; i 1] 4 , there exists an LD-refutation A j # j ; P;L 2 and there exists an LD-derivation A i # i * there exists 2 mgu ((A 1 ; : : : ; A i ); (A 1 <p> Lemma 2.6 (And-compositionality of derivations) Let P be a program and G : A 1 ; : : :; A n be a query. (i) If there exists an LD-derivation G # ; P;L ~ B then there exists i 2 [1; n]; such that * for any j 2 <ref> [1; i 1] </ref> 4 , there exists an LD-refutation A j # j ; P;L 2 and there exists an LD-derivation A i # i * there exists 2 mgu ((A 1 ; : : : ; A i ); (A 1 # 1 ; : : : ; A i <p> : : : ; A i ); (A 1 # 1 ; : : : ; A i # i )) such that G# = G and ~ B = ( ~ D; A i+1 ; : : :; A n ) . (ii) Conversely, if there exists i 2 <ref> [1; n] </ref>; such that * for any j 2 [1; i 1]; there exists an LD-refutation A j # j ; P;L 2 and there exists a LD-derivation A i # i ; P ~ D, * (A 1 ; : : : ; A i ) and (A 1 # <p> # 1 ; : : : ; A i # i )) such that G# = G and ~ B = ( ~ D; A i+1 ; : : :; A n ) . (ii) Conversely, if there exists i 2 [1; n]; such that * for any j 2 <ref> [1; i 1] </ref>; there exists an LD-refutation A j # j ; P;L 2 and there exists a LD-derivation A i # i ; P ~ D, * (A 1 ; : : : ; A i ) and (A 1 # 1 1 ; : : : ; A i <p> ~ D, * (A 1 ; : : : ; A i ) and (A 1 # 1 1 ; : : : ; A i # i i ) are unifiable, where the j 's are renamings such that A j # j j , for any j 2 <ref> [1; i 1] </ref>, (A i # i i ; ~ D i ) and G are pairwise variable disjoint, then there exists an LD-derivation G # ; P;L ~ B and there exists 2 mgu ((A 1 ; : : : ; A i ); (A 1 # 1 1 ; <p> Moreover, in both (i) and (ii), the length of the derivation for G is equal to the sum of the lengths of the derivations for the A h 's, with h 2 <ref> [1; i] </ref>. <p> the previous lemma we can easily derive the following Lemma 2.7 (And-compositionality of resultants) Let P be a program and G : A 1 ; : : : ; A n be a query. (i) If there exists an L-computed resultant for G in P then there exists i 2 <ref> [1; n] </ref>; such that * for any j 2 [1; i 1], there exists an L-computed resultant A 0 j for A j in P and there exists an L-computed resultant A 0 i ~ D for A i in P , 4 Here and in the following, given i 2 <p> Lemma 2.7 (And-compositionality of resultants) Let P be a program and G : A 1 ; : : : ; A n be a query. (i) If there exists an L-computed resultant for G in P then there exists i 2 [1; n]; such that * for any j 2 <ref> [1; i 1] </ref>, there exists an L-computed resultant A 0 j for A j in P and there exists an L-computed resultant A 0 i ~ D for A i in P , 4 Here and in the following, given i 2 [1; n], we use j 2 [1; i 1] <p> n]; such that * for any j 2 [1; i 1], there exists an L-computed resultant A 0 j for A j in P and there exists an L-computed resultant A 0 i ~ D for A i in P , 4 Here and in the following, given i 2 <ref> [1; n] </ref>, we use j 2 [1; i 1] as a shorthand for j 2 [1; n] and j &lt; i. 8 * there exists 2 mgu ((A 1 ; : : :; A i ); (A 0 1 ; : : : ; A 0 i )) such that = <p> j 2 <ref> [1; i 1] </ref>, there exists an L-computed resultant A 0 j for A j in P and there exists an L-computed resultant A 0 i ~ D for A i in P , 4 Here and in the following, given i 2 [1; n], we use j 2 [1; i 1] as a shorthand for j 2 [1; n] and j &lt; i. 8 * there exists 2 mgu ((A 1 ; : : :; A i ); (A 0 1 ; : : : ; A 0 i )) such that = (G ~ D; A i+1 ; <p> resultant A 0 j for A j in P and there exists an L-computed resultant A 0 i ~ D for A i in P , 4 Here and in the following, given i 2 <ref> [1; n] </ref>, we use j 2 [1; i 1] as a shorthand for j 2 [1; n] and j &lt; i. 8 * there exists 2 mgu ((A 1 ; : : :; A i ); (A 0 1 ; : : : ; A 0 i )) such that = (G ~ D; A i+1 ; : : : ; A n ) : (ii) <p> * there exists 2 mgu ((A 1 ; : : :; A i ); (A 0 1 ; : : : ; A 0 i )) such that = (G ~ D; A i+1 ; : : : ; A n ) : (ii) Conversely, if there exists i 2 <ref> [1; n] </ref>; such that * for any j 2 [1; i 1], there exists a renamed version A 0 j of an L-computed resultant for A j in P and there exists a renamed version A 0 i ~ D of an L-computed resultant for A i in P , * <p> : :; A i ); (A 0 1 ; : : : ; A 0 i )) such that = (G ~ D; A i+1 ; : : : ; A n ) : (ii) Conversely, if there exists i 2 [1; n]; such that * for any j 2 <ref> [1; i 1] </ref>, there exists a renamed version A 0 j of an L-computed resultant for A j in P and there exists a renamed version A 0 i ~ D of an L-computed resultant for A i in P , * the renamed versions of resultants do not share variables <p> Theorem 3.3 (Correctness) Let P be a program and G : A 1 ; : : : ; A n be a query. is an L-computed resultant for G in P iff there exists i 2 <ref> [1; n] </ref>; such that * for any j 2 [1; i 1] there exist A 0 j in O L (P ) and A 0 i ~ L in O L (P ), which do not share variables with each other and with G, * there exists ff 2 mgu ((A <p> Theorem 3.3 (Correctness) Let P be a program and G : A 1 ; : : : ; A n be a query. is an L-computed resultant for G in P iff there exists i 2 [1; n]; such that * for any j 2 <ref> [1; i 1] </ref> there exist A 0 j in O L (P ) and A 0 i ~ L in O L (P ), which do not share variables with each other and with G, * there exists ff 2 mgu ((A 1 ; : : :; A i ); (A <p> Moreover, as previously noted, O L (P ) is closed under renaming. Therefore, by Lemma 2.7, is an L-computed resultant for ~ G in P iff there exists i 2 <ref> [1; n] </ref> such that 1. for any j 2 [1; i 1], there exists A 0 j 2 O L (P ) and there exists A 0 i ~ L 2 O L (P ) which do not share variables with each other and with ~ G, 2. there exists 2 <p> Moreover, as previously noted, O L (P ) is closed under renaming. Therefore, by Lemma 2.7, is an L-computed resultant for ~ G in P iff there exists i 2 [1; n] such that 1. for any j 2 <ref> [1; i 1] </ref>, there exists A 0 j 2 O L (P ) and there exists A 0 i ~ L 2 O L (P ) which do not share variables with each other and with ~ G, 2. there exists 2 mgu ( ~ G 1;i ; ~ A 0 <p> Then we define T P;L (X) = Id [ f (A ~ L i ; B i+1 ; : : :; B n )# 2 C j there exists A B 1 ; : : : ; B n 2 P and i 2 <ref> [1; n] </ref>; for any j 2 [1; i 1] there exists H j 2 X and there exists H i ~ L i 2 X; all renamed renamed apart, such that # 2 mgu ((B 1 ; : : : ; B i ); (H 1 ; : : :; H <p> Then we define T P;L (X) = Id [ f (A ~ L i ; B i+1 ; : : :; B n )# 2 C j there exists A B 1 ; : : : ; B n 2 P and i 2 [1; n]; for any j 2 <ref> [1; i 1] </ref> there exists H j 2 X and there exists H i ~ L i 2 X; all renamed renamed apart, such that # 2 mgu ((B 1 ; : : : ; B i ); (H 1 ; : : :; H i )) g Lemma 3.5 T <p> program and G : A 1 ; : : : ; A n be a query. 14 (i) Let F pa;L (P ) = C (P ) ] A (P ) as defined in Definition 4.3. # is an L-partial answer for G in P iff there exists i 2 <ref> [1; n] </ref> such that * there exists a sequence H 1 ; : : : ; H i1 of atoms in A (P ), there exists H i 2 F pa;L (P ), all renamed apart, * there exists fl 2 mgu ((A 1 ; : : : ; A i <p> apart, * there exists fl 2 mgu ((A 1 ; : : : ; A i ); (H 1 ; : : :; H i )) and # = fl jV ar (G) . (ii) # is a correct L-partial answer for G in P iff there exists i 2 <ref> [1; n] </ref> such that * there exists a sequence H 1 ; : : : ; H i1 of atoms in F cpa;L (P ), there exists H i ~ B 2 F cpa;L (P ), all renamed apart, * there exists fl 2 mgu ((A 1 ; : : : <p> Let us denote ~ B; A i+1 ; : : : ; A n by G 0 . By Theorems 3.3 and 3.7, there exists an L-computed resultant Gfi ~ B 0 for G in P iff there exists i 2 <ref> [1; n] </ref>, there exists a sequence ~ H of atoms H 1 ; : : : ; H i1 in F L (P ) and there exists a clause H i ~ B 2 F L (P ), all renamed apart, such that there exists fl 2 mgu ((A 1 ; <p> Lemma 4.8 Let P be a program and G : A 1 ; : : : ; A n be a query. (i) A is an L-call pattern for G in P iff there exists i 2 <ref> [1; n] </ref> such that * there exists a sequence H 1 ; : : : ; H i1 of atoms in F pt;L (P ), there exists a clause H i ~ B 2 F pt;L (P ), all renamed apart, * there exists fl 2 mgu ((A 1 ; : <p> : ; H i )) and A = B 0 fl, where B 0 is the first atom in the query ~ B; A i+1 ; : : : ; A n . 16 (ii) A is a correct L-call pattern for G in P iff there exists i 2 <ref> [1; n] </ref> such that * there exists a sequence H 1 ; : : : ; H i1 of atoms in F cpt;L (P ), there exists a clause H i ~ B 2 F cpt;L (P ), all renamed apart, * there exists fl 2 mgu ((A 1 ; : <p> rule R is local, if it satisfies the following conditions: 1. if G : A 1 ; : : : ; A n is the initial goal, then the atom selected by R in G is the atom A s , such that (s) &lt; (i) for any i 2 <ref> [1; n] </ref>, i 6= s; 2. if G is a generic resolvent, assume that A 1 ; : : : ; A n is the sequence of atoms in G introduced by the last derivation step. <p> Then, as before, the atom selected is the atom A s , such that (s) &lt; (i) for any i 2 <ref> [1; n] </ref>, i 6= s. Rules which select one of the most recently introduced atoms were called local in [25] and were studied since they produce SLD-trees with a simple structure, suitable for efficient searching techniques. Clearly the rules that we consider are also local in the sense of [25].
Reference: [2] <author> R.N. Bol, K.R. Apt, and J.W. Klop. </author> <title> An analysis of loop checking mechanisms for logic programs. </title> <journal> Theoretical Computer Science, </journal> <volume> 86 </volume> <pages> 35-79, </pages> <year> 1991. </year>
Reference-contexts: For example, in addition to the above mentioned use of resultants to formalize partial evaluation theory [21], resultants have been used in <ref> [2] </ref> to study loop checking mechanisms and in [12] to prove the correctness of a modular Unfold/Fold transformation system. From resultants we can also extract the information needed to characterize non-standard properties of SLD-computations, such as partial computed answers and call patterns.
Reference: [3] <author> R. Barbuti, M. Codish, R. Giacobazzi, and M. Maher. </author> <title> Oracle Semantics for PROLOG. </title> <editor> In H. Kirchner and G. Levi, editors, </editor> <booktitle> Algebraic and Logic Programming, Proceedings of the Third International Conference, volume 632 of Lecture Notes in Computer Science, </booktitle> <pages> pages 100-114. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: These observables were considered also in [15] without taking into account the selection rule. Also related are the works <ref> [3, 4] </ref> which, using a more complex semantic domain, aim at a semantics modeling the Prolog deep-first search strategy.
Reference: [4] <author> A. Bossi, M. Bugliesi, and M. Fabris. </author> <title> Fixpoint semantics for PROLOG. </title> <editor> In D. S. Warren, editor, </editor> <booktitle> Proc. Tenth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 374-389. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1993. </year>
Reference-contexts: These observables were considered also in [15] without taking into account the selection rule. Also related are the works <ref> [3, 4] </ref> which, using a more complex semantic domain, aim at a semantics modeling the Prolog deep-first search strategy.
Reference: [5] <author> Michel Bergere, Gerard Ferrand and Jean-Hugues Rety. </author> <title> Independence of the Computation Rule for SLD-Resolution with Delay. </title> <type> Technical Report INRIA RR-LIFO-93-9, </type> <year> 1993. </year>
Reference-contexts: Since dynamic rules allow the call to run more efficiently, most of modern Prolog style languages provide such a flexible scheduling. It is worth noting that, as shown in <ref> [5] </ref>, when considering SLD-derivation with delay R-computed resultants whose bodies contain only delayed atoms are independent from the selection rule R.
Reference: [6] <author> A. Bossi, M. Gabbrielli, G. Levi, and M. Martelli. </author> <title> The s-semantics approach: Theory and applications. </title> <type> Technical Report TR 9/93, </type> <institution> Dipartimento di Informatica, Universita di Pisa, </institution> <year> 1993. </year> <note> To appear in the Journal of Logic Programming. </note>
Reference-contexts: In the following we give the (operational and fixpoint) definition of a semantics which models L-computed resultants, and we prove its correctness. Two abstractions of this semantics are considered in section 4. Other semantics, such as the least Herbrand model, the c-semantics [8] and the s-semantics <ref> [13, 6] </ref> could easily be obtained as well by using very simple abstraction operators. Abstract semantics arising in the context of abstract interpretation could be obtained as well. We consider here the case of the leftmost selection rule only in order to keep the presentation simple.
Reference: [7] <author> A. Bossi, M. Gabbrielli, G. Levi, and M. </author> <title> C Meo. A Compositional Semantics for Logic Programs. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 122(1-2):3-47, </address> <year> 1994. </year>
Reference-contexts: Section 5 contains a discussion on such an extension. In order to describe resultants we use a semantic domain based on clauses. A similar semantic domain was first introduced in [17] and then further studied in <ref> [7] </ref> to obtain a semantics compositional wrt the union of programs. Since we are taking into account the selection rule, the ordering of atoms in the body of a clause is relevant. <p> Related work include the papers [13] which defined a semantics based on unit clauses, [17] which first introduced the idea of using (generic) clauses as semantic objects, and more notably <ref> [7] </ref> which defined a fixpoint semantic based on a T P like operator acting on sets of clauses. Our collecting semantics for Prolog indeed is essentially such a fixpoint semantics extended in order to take into account the selection rule (which was not considered in the mentioned papers). <p> Our collecting semantics for Prolog indeed is essentially such a fixpoint semantics extended in order to take into account the selection rule (which was not considered in the mentioned papers). Moreover, it is worth noting that while clauses were used in <ref> [7] </ref> to obtain a semantics compositional wrt the union of programs, here our aim was to model resultants and other observables such as call patterns and partial answers. These observables were considered also in [15] without taking into account the selection rule.
Reference: [8] <author> K. L. Clark. </author> <title> Predicate logic as a computational formalism. Res. </title> <type> Report DOC 79/59, </type> <institution> Imperial College, Dept. of Computing, </institution> <address> London, </address> <year> 1979. </year>
Reference-contexts: In the following we give the (operational and fixpoint) definition of a semantics which models L-computed resultants, and we prove its correctness. Two abstractions of this semantics are considered in section 4. Other semantics, such as the least Herbrand model, the c-semantics <ref> [8] </ref> and the s-semantics [13, 6] could easily be obtained as well by using very simple abstraction operators. Abstract semantics arising in the context of abstract interpretation could be obtained as well. We consider here the case of the leftmost selection rule only in order to keep the presentation simple.
Reference: [9] <author> M. Comini and G. Levi. </author> <title> An Algebraic theory of observables. </title> <editor> In M. Bruynooghe, editor, </editor> <booktitle> Proc. Int'l Symposium on Logic Programming. </booktitle> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1994. </year> <note> To appear. </note>
Reference-contexts: Indeed, suitable abstractions of this semantics allow us to characterize observables useful for specific applications. We have considered the case of partial answers and call patterns, proving a full abstraction result. Semantics for abstract observables (like those arising in program analysis) could be obtained as well (see <ref> [9] </ref>). Therefore, the collecting semantics can be seen as a reference semantics for Prolog transformation and analysis systems. As discussed in the previous section, all the results given for the leftmost selection rule can easily be extended to the class of local rules. <p> These observables were considered also in [15] without taking into account the selection rule. Also related are the works [3, 4] which, using a more complex semantic domain, aim at a semantics modeling the Prolog deep-first search strategy. More recently, the paper <ref> [9] </ref> constructs an algebraic framework which, starting from a semantics similar to our resultants semantics, allows to derive several different semantics (including abstract ones) by using Galois connections. Some preliminary results contained in this paper appeared in our previous works [14, 16].
Reference: [10] <author> S. K. Debray. </author> <title> Formal bases for dataflow analysis of logic programs. </title> <editor> In G. Levi, editor, </editor> <booktitle> Advances in logic programming theory. </booktitle> <publisher> Oxford University Press, </publisher> <year> 1994. </year> <note> To appear. </note>
Reference-contexts: From resultants we can also extract the information needed to characterize non-standard properties of SLD-computations, such as partial computed answers and call patterns. These properties are useful for program analysis and program optimization <ref> [10] </ref>. The call patterns, for instance, are the atoms which are selected during the SLD-derivation. <p> The knowledge about partial answers and call patterns makes it possible to derive properties of procedure calls, which are clearly relevant to program optimization and play an important role in most program analysis frameworks based on abstract interpretation (see <ref> [10] </ref> for a recent broad overview). For example, if we know that an atom in the body of a clause is always ground when selected in an SLD-derivation, then we can simplify the program code associated to the clause. Computed answers are independent from the selection rule.
Reference: [11] <author> E. Eder. </author> <title> Properties of substitutions and unifications. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 1 </volume> <pages> 31-46, </pages> <year> 1985. </year>
Reference-contexts: A substitution # is a unifier of terms t and t 0 if t# t 0 #. It is well known that the mgu of two terms is unique up to renaming (see for example <ref> [11] </ref>). Moreover, if two terms are unifiable, then there exists an idempotent mgu for them. We will denote by mgu (t 1 ; t 2 ) the set of idempotent most general unifier of t 1 and t 2 .
Reference: [12] <author> S. Etalle and M. Gabbrielli. </author> <title> Modular Transformations of CLP Programs. </title> <editor> In Maria Alpuente, editor, </editor> <booktitle> Proc. of the Joint conference on declarative programming GULP-PRODE, </booktitle> <year> 1994. </year>
Reference-contexts: For example, in addition to the above mentioned use of resultants to formalize partial evaluation theory [21], resultants have been used in [2] to study loop checking mechanisms and in <ref> [12] </ref> to prove the correctness of a modular Unfold/Fold transformation system. From resultants we can also extract the information needed to characterize non-standard properties of SLD-computations, such as partial computed answers and call patterns. These properties are useful for program analysis and program optimization [10].
Reference: [13] <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> Declarative Modeling of the Operational Behavior of Logic Languages. </title> <journal> Theoretical Computer Science, </journal> <volume> 69(3) </volume> <pages> 289-318, </pages> <year> 1989. </year>
Reference-contexts: In the following we give the (operational and fixpoint) definition of a semantics which models L-computed resultants, and we prove its correctness. Two abstractions of this semantics are considered in section 4. Other semantics, such as the least Herbrand model, the c-semantics [8] and the s-semantics <ref> [13, 6] </ref> could easily be obtained as well by using very simple abstraction operators. Abstract semantics arising in the context of abstract interpretation could be obtained as well. We consider here the case of the leftmost selection rule only in order to keep the presentation simple. <p> Therefore, the collecting semantics can be seen as a reference semantics for Prolog transformation and analysis systems. As discussed in the previous section, all the results given for the leftmost selection rule can easily be extended to the class of local rules. Related work include the papers <ref> [13] </ref> which defined a semantics based on unit clauses, [17] which first introduced the idea of using (generic) clauses as semantic objects, and more notably [7] which defined a fixpoint semantic based on a T P like operator acting on sets of clauses.
Reference: [14] <author> M. Gabbrielli, G. Levi, and M. C. Meo. </author> <title> Observational Equivalences for Logic Programs. </title> <editor> In K. Apt, editor, </editor> <booktitle> Proc. Joint Int'l Conf. and Symposium on Logic Programming, </booktitle> <pages> pages 131-145. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1992. </year>
Reference-contexts: More recently, the paper [9] constructs an algebraic framework which, starting from a semantics similar to our resultants semantics, allows to derive several different semantics (including abstract ones) by using Galois connections. Some preliminary results contained in this paper appeared in our previous works <ref> [14, 16] </ref>. Acknowledgments We thank Krzysztof Apt for his suggestions which helped us to clarify some tricky properties of resultants. 20
Reference: [15] <author> M. Gabbrielli, G. Levi, and M. C. Meo. </author> <title> Observable Behaviours and Equivalences of Logic Programs. </title> <note> Submitted for publication. 21 </note>
Reference-contexts: These semantics extend those in <ref> [15] </ref> to consider also the selection rule. Informally, a partial answer for a query G in the program P is the substitution (restricted to the variables in G) computed by any finite, possibly non terminated, SLD-derivation. A call pattern instead is any selected atom in an SLD-derivation. <p> Moreover, it is worth noting that while clauses were used in [7] to obtain a semantics compositional wrt the union of programs, here our aim was to model resultants and other observables such as call patterns and partial answers. These observables were considered also in <ref> [15] </ref> without taking into account the selection rule. Also related are the works [3, 4] which, using a more complex semantic domain, aim at a semantics modeling the Prolog deep-first search strategy.
Reference: [16] <author> M. Gabbrielli and M. C. Meo. </author> <title> Fixpoint Semantics for Partial Computed Answer Substitu--tions and Call Patterns. </title> <editor> In H. Kirchner and G. Levi, editors, </editor> <booktitle> Algebraic and Logic Programming, Proc. of the Third Int'l Conf., volume 632 of LNCS, </booktitle> <pages> pages 84-99. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: More recently, the paper [9] constructs an algebraic framework which, starting from a semantics similar to our resultants semantics, allows to derive several different semantics (including abstract ones) by using Galois connections. Some preliminary results contained in this paper appeared in our previous works <ref> [14, 16] </ref>. Acknowledgments We thank Krzysztof Apt for his suggestions which helped us to clarify some tricky properties of resultants. 20
Reference: [17] <author> H. Gaifman and E. Shapiro. </author> <title> Fully abstract compositional semantics for logic programs. </title> <booktitle> In Proc. Sixteenth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 134-142. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: However, all the following results can be generalized to a suitable class of selection rules. Section 5 contains a discussion on such an extension. In order to describe resultants we use a semantic domain based on clauses. A similar semantic domain was first introduced in <ref> [17] </ref> and then further studied in [7] to obtain a semantics compositional wrt the union of programs. Since we are taking into account the selection rule, the ordering of atoms in the body of a clause is relevant. <p> As discussed in the previous section, all the results given for the leftmost selection rule can easily be extended to the class of local rules. Related work include the papers [13] which defined a semantics based on unit clauses, <ref> [17] </ref> which first introduced the idea of using (generic) clauses as semantic objects, and more notably [7] which defined a fixpoint semantic based on a T P like operator acting on sets of clauses.
Reference: [18] <author> H.J. Komorowski. </author> <title> A Specification of an Abstract Prolog Machine and Its Application to Partial Evaluation. </title> <type> PhD thesis, </type> <institution> Linkoping University, Sweden, 1981. Linkoping Studies in Science and Technology Dissertations 69. </institution>
Reference-contexts: 1 Introduction Resultants have been introduced in [21] to study the partial evaluation of logic programs <ref> [18] </ref>. Briefly, a resultant is a first order formula of the form Q 1 Q 2 , where the Q i 's are conjunctions of atomic formulas or, for short, queries.
Reference: [19] <author> J.-L. Lassez, M. J. Maher, and K. Marriott. </author> <title> Unification Revisited. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 587-625. </pages> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, Ca., </address> <year> 1988. </year>
Reference: [20] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1987. </year> <note> Second edition. </note>
Reference-contexts: In this subsection we introduce some notations we will use in the following and, for the reader's convenience, we recall some basic notions. We refer to <ref> [20, 1] </ref> for further details on the logic programming theory. <p> This establishes a soundness property for computed resultants. In order to state the completeness, we first need a stronger version of the lifting-lemma <ref> [20] </ref> which can be described as follows. An SLD-derivation of a query Gfl can be lifted to an SLD-derivation of G in a strong sense which relate the mgu's and the resolvents.
Reference: [21] <author> J. W. Lloyd and J. C. Shepherdson. </author> <title> Partial Evaluation in Logic Programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 11 </volume> <pages> 217-242, </pages> <year> 1991. </year>
Reference-contexts: 1 Introduction Resultants have been introduced in <ref> [21] </ref> to study the partial evaluation of logic programs [18]. Briefly, a resultant is a first order formula of the form Q 1 Q 2 , where the Q i 's are conjunctions of atomic formulas or, for short, queries. <p> For example, in addition to the above mentioned use of resultants to formalize partial evaluation theory <ref> [21] </ref>, resultants have been used in [2] to study loop checking mechanisms and in [12] to prove the correctness of a modular Unfold/Fold transformation system. From resultants we can also extract the information needed to characterize non-standard properties of SLD-computations, such as partial computed answers and call patterns. <p> As previously sketched, a resultant <ref> [21] </ref> is a first order formula of the form G 1 G 2 where G i is a possibly empty conjunction of atoms and all the variables are assumed to be universally quantified in front of the formula 2 . <p> However, it can be useful to show some properties for generic resultants, since these properties generalize familiar results concerning refutations and computed answers. Let us start with a result from <ref> [21] </ref>. Namely, computed resultants are also correct resultants. In fact, from the soundness theorem of SLD-resolution, if is a computed resultant for the 2 Note that a resultant is not a clause. 4 query G in the program P then P j= . <p> In fact, differently from the general case, the resultants of an atomic query p ( ~ t) in a program P are clauses. These clauses are called a "partial evaluation" of p ( ~ t) in P <ref> [21] </ref>, and they can be substituted for the original ones defining p in the program P , in order to improve the performance in the evaluation of queries which are instances of p ( ~ t).
Reference: [22] <author> C. Palamidessi. </author> <title> Algebraic properties of idempotent substitutions. </title> <editor> In M. S. Paterson, editor, </editor> <booktitle> Proc. of the 17th International Colloquium on Automata, Languages and Programming, volume 443 of Lecture Notes in Computer Science, </booktitle> <pages> pages 386-399. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1990. </year>
Reference: [23] <author> J. Shoenfield. </author> <title> Mathematical Logic. </title> <publisher> Addison-Wesley, </publisher> <year> 1967. </year>
Reference-contexts: P j= is then a shorthand for P j= . Since is a correct resultant for G in P , by definition P j= and therefore, by using the Theorem on Constants <ref> [23] </ref>, P j= 0 holds. Since ~ B is ground by definition of , we can apply the Deduction Theorem [23] to show that P [ f ~ Bg j= 0 G 0 holds (where f ~ Bg denotes the set of atoms in the conjunction ~ B). 3 If is <p> Since is a correct resultant for G in P , by definition P j= and therefore, by using the Theorem on Constants <ref> [23] </ref>, P j= 0 holds. Since ~ B is ground by definition of , we can apply the Deduction Theorem [23] to show that P [ f ~ Bg j= 0 G 0 holds (where f ~ Bg denotes the set of atoms in the conjunction ~ B). 3 If is infinite, since programs and formulas are finite, clearly we can take = 0 . 6 The completeness of SLD-resolution implies <p> Finally, the initial assumption on the the new constants and the fact that is a computed resultant imply that the c i 's do not appear in . By recalling the initial definition = G 0 ~ B from (6) and the Theorem on Constants <ref> [23] </ref>, we have then j= which completes the proof. As a specific case of previous result, we have the following. Corollary 2.5 Let P be a program, G be a query and G ~ B be a correct resultant for G in P .
Reference: [24] <author> H. Tamaki and T. Sato. </author> <title> Unfold/Fold Transformations of Logic Programs. </title> <editor> In Sten -Ake Tarnlund, editor, </editor> <booktitle> Proc. Second Int'l Conf. on Logic Programming, </booktitle> <pages> pages 127-139, </pages> <year> 1984. </year>
Reference-contexts: This logical representation is quite convenient to study transformation techniques of logic programs such as partial evaluation and Fold/Unfold <ref> [24] </ref>. In fact, since these transformations are based on unfolding, i.e. on the application of some SLD-derivation steps to the program clauses, their intermediate and final results and also their basic properties can be naturally expressed in terms of resultants.
Reference: [25] <author> L. Vieille. </author> <title> Recursive query processing: the power of logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 69 </volume> <pages> 1-53, </pages> <year> 1989. </year>
Reference-contexts: Then, as before, the atom selected is the atom A s , such that (s) &lt; (i) for any i 2 [1; n], i 6= s. Rules which select one of the most recently introduced atoms were called local in <ref> [25] </ref> and were studied since they produce SLD-trees with a simple structure, suitable for efficient searching techniques. Clearly the rules that we consider are also local in the sense of [25]. Moreover, a local rule according to Definition 5.2 is also a skeleton rule as defined in the preliminaries. <p> Rules which select one of the most recently introduced atoms were called local in <ref> [25] </ref> and were studied since they produce SLD-trees with a simple structure, suitable for efficient searching techniques. Clearly the rules that we consider are also local in the sense of [25]. Moreover, a local rule according to Definition 5.2 is also a skeleton rule as defined in the preliminaries. Note also that the PROLOG leftmost rule is local by defining as follows: (i) = i.
Reference: [26] <author> D. A. Wolfram, M.J. Maher, , and J-L. Lassez. </author> <title> A Unified Treatment of Resolution Strategies for Logic Programs. </title> <editor> In Sten -Ake Tarnlund, editor, </editor> <booktitle> Proc. Second Int'l Conf. on Logic Programming, </booktitle> <pages> pages 263-276, </pages> <year> 1984. </year> <month> 22 </month>
References-found: 26

