URL: http://www.csc.ncsu.edu/faculty/riely/papers/94concur.ps.gz
Refering-URL: http://www.csc.ncsu.edu/faculty/riely/papers.html
Root-URL: http://www.csc.ncsu.edu
Email: email: rance@csc.ncsu.edu, riely@cs.unc.edu  
Phone: 2  
Title: Testing-Based Abstractions for Value-Passing Systems  
Author: Rance Cleaveland and James Riely 
Address: Raleigh, NC 27695-8206, USA  N.C., Chapel Hill, NC 27599-3175, USA  
Affiliation: 1 Dept. of Computer Science, N.C. State University,  Dept. of Computer Science, University of  
Abstract: This paper presents a framework for the abstract interpretation of processes that pass values. We define a process description language that is parameterized with respect to the set of values that processes may exchange and show that an abstraction over values induces an abstract semantics for processes. Our main results state that if the abstract value interpretation safely/optimally approximates the ground interpretation, then the resulting abstracted processes safely/optimally approximate those derived from the ground semantics (in a precisely defined sense). As the processes derived from an abstract semantics in general have far fewer states than those derived from a concrete semantics, our technique enables the automatic analysis of systems that lie beyond the scope of existing techniques. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> S. Bensalem, A. Bouajjani, C. Loiseaux, and J. Sifakis. </author> <title> Property-preserving simulations. </title> <booktitle> In Proceedings of the Workshop on Computer-Aided Verification, volume 663 of LNCS, </booktitle> <pages> pages 260|273. </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1992. </year>
Reference-contexts: Finally, we intend to further explore the connections between our approach and effect systems. Related Work. Existing work on abstractions of concurrent systems has focused on the development of abstraction techniques that preserve certain classes of formulas in various temporal logics <ref> [1, 3, 10] </ref>. The frameworks of these papers differ in details, but each considers how to generate, from an abstraction on values, abstractions on Kripke structures that preserve various fragments of the temporal logic CT L fl .
Reference: 2. <author> B. Bloom and R. Paige. </author> <title> Computing ready simulations efficiently. </title> <booktitle> In Proceedings of the North American Process Algebra Workshop, Workshops in Computing, </booktitle> <pages> pages 119-134, </pages> <address> Stony Brook, New York, </address> <month> August </month> <year> 1992. </year> <note> Springer-Verlag. </note>
Reference-contexts: Algorithms have been proposed for determining whether such systems enjoy properties specified by formulas in various temporal logics [4, 5, 8, 25, 27, 28] and for computing whether or not two systems exhibit the same (or related) observable behavior <ref> [2, 6, 18, 21] </ref>. Tools built around implementations of these algorithms have been applied to the analysis of a variety of different kinds of systems [7, 11, 12, 22, 23, 24].
Reference: 3. <author> Edmund M. Clarke, Orna Grumberg, and David E. </author> <title> Long. Model checking and abstraction. </title> <booktitle> In Proceedings ACM POPL, </booktitle> <pages> pages 343-354, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: Finally, we intend to further explore the connections between our approach and effect systems. Related Work. Existing work on abstractions of concurrent systems has focused on the development of abstraction techniques that preserve certain classes of formulas in various temporal logics <ref> [1, 3, 10] </ref>. The frameworks of these papers differ in details, but each considers how to generate, from an abstraction on values, abstractions on Kripke structures that preserve various fragments of the temporal logic CT L fl .
Reference: 4. <author> E.M. Clarke, </author> <title> E.A. Emerson, and A.P. Sistla. Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM TOPLAS, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: 1 Introduction Research over the past decade points to the practical viability of automatically verifying concurrent finite-state systems. Algorithms have been proposed for determining whether such systems enjoy properties specified by formulas in various temporal logics <ref> [4, 5, 8, 25, 27, 28] </ref> and for computing whether or not two systems exhibit the same (or related) observable behavior [2, 6, 18, 21].
Reference: 5. <author> R. Cleaveland. </author> <title> Tableau-based model checking in the propositional mu-calculus. </title> <journal> Acta Infor-matica, </journal> <volume> 27(8) </volume> <pages> 725-747, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Research over the past decade points to the practical viability of automatically verifying concurrent finite-state systems. Algorithms have been proposed for determining whether such systems enjoy properties specified by formulas in various temporal logics <ref> [4, 5, 8, 25, 27, 28] </ref> and for computing whether or not two systems exhibit the same (or related) observable behavior [2, 6, 18, 21].
Reference: 6. <author> R. Cleaveland and M.C.B. Hennessy. </author> <title> Testing equivalence as a bisimulation equivalence. </title> <journal> Formal Aspects of Computing, </journal> <volume> 5 </volume> <pages> 1-20, </pages> <year> 1993. </year>
Reference-contexts: Algorithms have been proposed for determining whether such systems enjoy properties specified by formulas in various temporal logics [4, 5, 8, 25, 27, 28] and for computing whether or not two systems exhibit the same (or related) observable behavior <ref> [2, 6, 18, 21] </ref>. Tools built around implementations of these algorithms have been applied to the analysis of a variety of different kinds of systems [7, 11, 12, 22, 23, 24]. <p> In addition to having a pleasing operational justification based on process testing, this preorder may be seen to relate processes on the basis of the safety and liveness properties that they enjoy. In order to define this relation, we first introduce the following definitions, which borrow heavily from <ref> [6, 13] </ref>. 7 Definition 9.
Reference: 7. <author> R. Cleaveland, J. Parrow, and B. Steffen. </author> <title> The Concurrency Workbench: A semantics-based tool for the verification of finite-state systems. </title> <journal> ACM TOPLAS, </journal> <volume> 15(1) </volume> <pages> 36-72, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Tools built around implementations of these algorithms have been applied to the analysis of a variety of different kinds of systems <ref> [7, 11, 12, 22, 23, 24] </ref>. When communicating processes are capable of exchanging values taken from an infinite set, however, the resulting system is usually not finite-state, and the automatic analysis routines mentioned above, which rely to some extent on an enumeration of system states, are not directly applicable.
Reference: 8. <author> R. Cleaveland and B. Steffen. </author> <title> A linear-time model-checking algorithm for the alternation-free modal mu-calculus. </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> 2 </volume> <pages> 121-147, </pages> <year> 1993. </year>
Reference-contexts: 1 Introduction Research over the past decade points to the practical viability of automatically verifying concurrent finite-state systems. Algorithms have been proposed for determining whether such systems enjoy properties specified by formulas in various temporal logics <ref> [4, 5, 8, 25, 27, 28] </ref> and for computing whether or not two systems exhibit the same (or related) observable behavior [2, 6, 18, 21].
Reference: 9. <author> P. Cousot and R. Cousot. </author> <title> Comparing the Galois connection and widening/narrowing approaches to abstract interpretation. </title> <booktitle> In PLILP '92, volume 631 of LNCS, </booktitle> <pages> pages 269-295. </pages> <publisher> Springer-Verlag, </publisher> <month> August </month> <year> 1992. </year>
Reference-contexts: Springer Verlag. Some typographical errors in the original have been corrected. one, with results obtained from the former also guaranteed to be applicable to the latter. Our work is inspired by that done in the abstract interpretation of sequential programming languages <ref> [9] </ref>, which has led to the development of techniques that permit certain properties of sequential programs to be deduced automatically at compile-time. In particular, our approach is similar to work on factored semantics described in [17], although our setting is operational rather than denotational.
Reference: 10. <author> D. Dams, O. Grumberg, and R. Gerth. </author> <title> Abstract interpretation of reactive systems: Abstractions preserving 8CTL fl , 9CTL fl and CTL fl . In PROCOMET '94, </title> <journal> IFIP Transactions. </journal> <volume> North-Holland/Elsevier, </volume> <month> June </month> <year> 1994. </year> <note> Full version available from Eindhoven University of Technology. </note>
Reference-contexts: Finally, we intend to further explore the connections between our approach and effect systems. Related Work. Existing work on abstractions of concurrent systems has focused on the development of abstraction techniques that preserve certain classes of formulas in various temporal logics <ref> [1, 3, 10] </ref>. The frameworks of these papers differ in details, but each considers how to generate, from an abstraction on values, abstractions on Kripke structures that preserve various fragments of the temporal logic CT L fl .
Reference: 11. <author> J. Goyer. </author> <title> Communications protocols for the B-HIVE multicomputer. </title> <type> Master's thesis, </type> <institution> North Carolina State University, </institution> <year> 1991. </year>
Reference-contexts: Tools built around implementations of these algorithms have been applied to the analysis of a variety of different kinds of systems <ref> [7, 11, 12, 22, 23, 24] </ref>. When communicating processes are capable of exchanging values taken from an infinite set, however, the resulting system is usually not finite-state, and the automatic analysis routines mentioned above, which rely to some extent on an enumeration of system states, are not directly applicable.
Reference: 12. <author> E. Harcourt, J. Mauney, and T. Cook. </author> <title> Specification of instruction-level parallelism. </title> <booktitle> In Proceedings of the North American Process Algebra Workshop, </booktitle> <month> August </month> <year> 1993. </year> <type> Technical Report TR93-1369, </type> <institution> Cornell University. </institution> <month> 15 </month>
Reference-contexts: Tools built around implementations of these algorithms have been applied to the analysis of a variety of different kinds of systems <ref> [7, 11, 12, 22, 23, 24] </ref>. When communicating processes are capable of exchanging values taken from an infinite set, however, the resulting system is usually not finite-state, and the automatic analysis routines mentioned above, which rely to some extent on an enumeration of system states, are not directly applicable.
Reference: 13. <author> M.C.B. Hennessy. </author> <title> Algebraic Theory of Processes. </title> <publisher> MIT Press, </publisher> <address> Boston, </address> <year> 1988. </year>
Reference-contexts: The remainder of the paper is organized as follows. The next section formally introduces value interpretations. Section 3 then gives the syntax and semantics of processes and defines a preorder on processes, indicating when one process approximates another. The semantic relation is a variant of the testing/failures preorders <ref> [13] </ref>, which we also argue preserves both liveness and safety properties of processes. In Section 4 we extend the abstraction functions defined in Section 2 to process terms (syntax) and labeled transition systems (semantics) so that the main results may be formally stated. <p> In addition to having a pleasing operational justification based on process testing, this preorder may be seen to relate processes on the basis of the safety and liveness properties that they enjoy. In order to define this relation, we first introduce the following definitions, which borrow heavily from <ref> [6, 13] </ref>. 7 Definition 9.
Reference: 14. <author> M.C.B. Hennessy and A. Ingolfsdottir. </author> <title> A theory of communicating processes with value-passing. </title> <journal> Information and Computation, </journal> <volume> 107 </volume> <pages> 202-236, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: Section 7 contains our conclusions and directions for future work. 2 Values and value abstractions In the next section we give the syntax and semantics of VPL I |Value-Passing Language with value interpretation I. VPL I is a simple variant of the language defined by Hennessy and Ingolfsdottir in <ref> [14] </ref>; the difference lies in the fact that V P L I is explicitly parameterized with respect to an interpretation I of values. <p> For this purpose we use a variant of the must preorder of <ref> [14] </ref>. In addition to having a pleasing operational justification based on process testing, this preorder may be seen to relate processes on the basis of the safety and liveness properties that they enjoy. <p> I N and N &lt; It is traditional to abbreviate IP I [[p]] &lt; I IP I [[q]], as p &lt; We now compare our semantics with the one given in <ref> [14] </ref>. There, value interpretations are assumed to be deterministic. Table 2 gives their formulation of the semantics. <p> The basis case (s = *) requires a further induction on the length of the longest initial o -sequence of p. That there can be no infinite o sequence is established by the premise and the fact that the model of a process is image finite (see <ref> [14] </ref>). 5.2 Optimality In order to prove optimality, we must first lift IP I [[]] to sets of process terms. To this end we introduce the following operator on transition systems. Definition 24. <p> A solution here, however, would open up the possibility of treating higher-order value passing languages. To this end it would be useful to cast our results in terms of acceptance trees <ref> [14] </ref>; this rephrasing should not present difficulties. Finally, we intend to further explore the connections between our approach and effect systems. Related Work.
Reference: 15. <author> M.C.B. Hennessy and H. Lin. </author> <title> Symbolic bisimulations. </title> <type> Technical Report 1/92, </type> <institution> Sussex University, </institution> <year> 1992. </year>
Reference-contexts: Consequently, the "properties" that are preserved would in general be different. Characterizing these differences precisely remains a topic that needs to be addressed. The goals of our work are also similar to those of Hennessy and Lin in their work on symbolic bisimulations <ref> [15] </ref>. Central to their work is the notion of a symbolic transition system, which is a transition system with sets of free variables as states and guarded expressions as edges.
Reference: 16. <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice-Hall, </publisher> <address> London, </address> <year> 1985. </year>
Reference-contexts: In particular, our approach is similar to work on factored semantics described in [17], although our setting is operational rather than denotational. More specifically, we give a semantics for a language similar to CSP <ref> [16] </ref> in which the core semantics is explicitly parameterized with respect to a value interpretation that defines the meaning of data. We also define the conditions under which an abstract value interpretation is safe relative to the original interpretation and under which a safe abstraction is said to be optimal.
Reference: 17. <author> N.D. Jones and F. Nielson. </author> <title> Abstract Interpretation: A Semantics-Based Tool for Program Analysis. </title> <booktitle> Handbook of Logic in Computer Science. </booktitle> <address> Oxford, </address> <note> To appear. </note>
Reference-contexts: In particular, our approach is similar to work on factored semantics described in <ref> [17] </ref>, although our setting is operational rather than denotational. More specifically, we give a semantics for a language similar to CSP [16] in which the core semantics is explicitly parameterized with respect to a value interpretation that defines the meaning of data. <p> At the opposite extreme from the trivial semantics is the optimal (or induced) semantics. In the traditional setting, f A is said to be optimal for f C if f A is the most precise safe approximation of f C . Formally <ref> [17] </ref>, we may say that f A is optimal if f A (a) = A ffffif C ffifl (a), where = A is the equivalence induced by v A .
Reference: 18. <author> P. Kanellakis and S.A. Smolka. </author> <title> CCS expressions, finite state processes, and three problems of equivalence. </title> <journal> Information and Computation, </journal> <volume> 86(1) </volume> <pages> 43-68, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: Algorithms have been proposed for determining whether such systems enjoy properties specified by formulas in various temporal logics [4, 5, 8, 25, 27, 28] and for computing whether or not two systems exhibit the same (or related) observable behavior <ref> [2, 6, 18, 21] </ref>. Tools built around implementations of these algorithms have been applied to the analysis of a variety of different kinds of systems [7, 11, 12, 22, 23, 24].
Reference: 19. <author> F. Nielson and H. Nielson. </author> <title> From CML to process algebras. </title> <editor> In E. Best, editor, </editor> <booktitle> Proceedings of CONCUR '93, volume 715 of LNCS, </booktitle> <pages> pages 493-508, </pages> <address> Hildesheim, Germany, </address> <month> August </month> <year> 1993. </year> <note> Springer-Verlag. </note>
Reference-contexts: For example (rec P (x):c!x:P (x + 1)) (0) has an infinite symbolic transition system; our method will produce a finite transition system for this process, given a finite abstract value set. Our work is also related to that done by Nielson and Nielson on effect systems for CML <ref> [19] </ref>. An effect system is an extension of a conventional type system that describes the side-effects (in our case, events) that a program may have.
Reference: 20. <author> E.-R. </author> <title> Olderog and C.A.R. Hoare. Specification-oriented semantics for communicating processes. </title> <journal> Acta Informatica, </journal> <volume> 23 </volume> <pages> 9-66, </pages> <year> 1986. </year>
Reference-contexts: Then p &lt; I q iff p &lt;&lt; I q We close this section by remarking on connections between &lt; I and safety and liveness properties. Olderog and Hoare <ref> [20] </ref> present a framework for the consideration of safety and liveness in the context of labeled transition systems; they define a preorder that is similar to the specification preorder and show that if one transition system is less than another, then the higher one enjoys all the safety and liveness properties
Reference: 21. <author> R. Paige and R.E. Tarjan. </author> <title> Three partition refinement algorithms. </title> <journal> SIAM Journal of Computing, </journal> <volume> 16(6) </volume> <pages> 973-989, </pages> <month> December </month> <year> 1987. </year>
Reference-contexts: Algorithms have been proposed for determining whether such systems enjoy properties specified by formulas in various temporal logics [4, 5, 8, 25, 27, 28] and for computing whether or not two systems exhibit the same (or related) observable behavior <ref> [2, 6, 18, 21] </ref>. Tools built around implementations of these algorithms have been applied to the analysis of a variety of different kinds of systems [7, 11, 12, 22, 23, 24].
Reference: 22. <author> J. Parrow. </author> <title> Verifying a CSMA/CD-protocol with CCS. </title> <booktitle> In Proceedings of the IFIP Symposium on Protocol Specification, Testing and Verification, </booktitle> <pages> pages 373-387, </pages> <address> Atlantic City, New Jersey, June 1988. </address> <publisher> North-Holland. </publisher>
Reference-contexts: Tools built around implementations of these algorithms have been applied to the analysis of a variety of different kinds of systems <ref> [7, 11, 12, 22, 23, 24] </ref>. When communicating processes are capable of exchanging values taken from an infinite set, however, the resulting system is usually not finite-state, and the automatic analysis routines mentioned above, which rely to some extent on an enumeration of system states, are not directly applicable.
Reference: 23. <author> J. Richier, C. Rodgriguez, J. Sifakis, and J. Voiron. </author> <title> Verification in XESAR of the sliding window protocol. </title> <booktitle> In Proceedings of the IFIP Symposium on Protocol Specification, Testing and Verification, </booktitle> <pages> pages 235-250, </pages> <address> Zurich, May 1987. </address> <publisher> North-Holland. </publisher>
Reference-contexts: Tools built around implementations of these algorithms have been applied to the analysis of a variety of different kinds of systems <ref> [7, 11, 12, 22, 23, 24] </ref>. When communicating processes are capable of exchanging values taken from an infinite set, however, the resulting system is usually not finite-state, and the automatic analysis routines mentioned above, which rely to some extent on an enumeration of system states, are not directly applicable.
Reference: 24. <author> V. Roy and R. de Simone. Auto/Autograph. </author> <booktitle> In Computer-Aided Verification '90, </booktitle> <pages> pages 235-250, </pages> <address> Piscataway, New Jersey, </address> <month> July </month> <year> 1990. </year> <journal> American Mathematical Society. </journal>
Reference-contexts: Tools built around implementations of these algorithms have been applied to the analysis of a variety of different kinds of systems <ref> [7, 11, 12, 22, 23, 24] </ref>. When communicating processes are capable of exchanging values taken from an infinite set, however, the resulting system is usually not finite-state, and the automatic analysis routines mentioned above, which rely to some extent on an enumeration of system states, are not directly applicable.
Reference: 25. <author> C. Stirling and D. Walker. </author> <title> Local model checking in the modal mu-calculus. </title> <booktitle> In TAPSOFT '89, volume 352 of LNCS, </booktitle> <pages> pages 369-383, </pages> <address> Barcelona, March 1989. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: 1 Introduction Research over the past decade points to the practical viability of automatically verifying concurrent finite-state systems. Algorithms have been proposed for determining whether such systems enjoy properties specified by formulas in various temporal logics <ref> [4, 5, 8, 25, 27, 28] </ref> and for computing whether or not two systems exhibit the same (or related) observable behavior [2, 6, 18, 21].
Reference: 26. <author> R. van Glabbeek. </author> <title> The linear time-branching time spectrum. </title> <booktitle> In Proceedings of CONCUR '90, volume 458 of LNCS, </booktitle> <pages> pages 278-297. </pages> <publisher> Springer-Verlag, </publisher> <month> August </month> <year> 1990. </year>
Reference-contexts: Their programming models have focused on shared memory, whereas ours considers value-passing; in addition, their semantics are based on the simulation preorder, which is incomparable to the preorder used 14 here <ref> [26] </ref>. Consequently, the "properties" that are preserved would in general be different. Characterizing these differences precisely remains a topic that needs to be addressed. The goals of our work are also similar to those of Hennessy and Lin in their work on symbolic bisimulations [15].
Reference: 27. <author> M. Vardi and P. Wolper. </author> <title> An automata-theoretic approach to automatic program verification. </title> <booktitle> In Proceedings of the Symposium on Logic in Computer Science, </booktitle> <pages> pages 332-344, </pages> <address> Cambridge, Massachusetts, June 1986. </address> <publisher> Computer Society Press. </publisher>
Reference-contexts: 1 Introduction Research over the past decade points to the practical viability of automatically verifying concurrent finite-state systems. Algorithms have been proposed for determining whether such systems enjoy properties specified by formulas in various temporal logics <ref> [4, 5, 8, 25, 27, 28] </ref> and for computing whether or not two systems exhibit the same (or related) observable behavior [2, 6, 18, 21].
Reference: 28. <author> G. Winskel. </author> <title> A note on model checking the modal -calculus. </title> <booktitle> In Proceedings ICALP, volume 372 of LNCS, </booktitle> <pages> pages 761-772, </pages> <address> Stresa, Italy, July 1989. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: 1 Introduction Research over the past decade points to the practical viability of automatically verifying concurrent finite-state systems. Algorithms have been proposed for determining whether such systems enjoy properties specified by formulas in various temporal logics <ref> [4, 5, 8, 25, 27, 28] </ref> and for computing whether or not two systems exhibit the same (or related) observable behavior [2, 6, 18, 21].
Reference: 29. <author> P. Wolper. </author> <title> Expressing interesting properties of programs in propositional temporal logic. </title> <booktitle> In Proceedings ACM POPL, </booktitle> <pages> pages 184-193, </pages> <month> January </month> <year> 1986. </year>
Reference-contexts: To end the section, we give a sufficient condition for establishing that this is the case. The condition is a natural generalization of data-independence as studied by Wolper <ref> [29] </ref>. We need the following definitions. Definition 26. Let ff : C 7! A and f : Val C 7! Val C .
Reference: 30. <author> W.J. Yeh and M. Young. </author> <title> Compositional reachability analysis using process algebra. </title> <booktitle> In TAV '91, </booktitle> <pages> pages 49-59. </pages> <publisher> ACM SIGSOFT, ACM Press, </publisher> <month> October </month> <year> 1991. </year> <month> 16 </month>
Reference-contexts: Their language is much more complex, supporting higher-order and structured values. However, our abstractions preserve more of the behavior of the original process than do theirs; for example, their abstractions reduce external to internal non-determinism. As for more applied work, Yeh and Young <ref> [30] </ref> have used an approach that can be seen as an instance of ours for verifying properties of Ada programs. Their success points to the practical importance of our technique.
References-found: 30

