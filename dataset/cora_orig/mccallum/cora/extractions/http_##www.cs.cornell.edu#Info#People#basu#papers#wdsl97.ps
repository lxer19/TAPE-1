URL: http://www.cs.cornell.edu/Info/People/basu/papers/wdsl97.ps
Refering-URL: http://www.cs.cornell.edu/Info/People/basu/papers.html
Root-URL: http://www.cs.brown.edu/
Title: A Language-Based Approach to Protocol Construction  
Author: Anindya Basu Mark Hayden Greg Morrisett Thorsten von Eicken 
Address: Ithaca, NY 14853-7501  
Affiliation: Department of Computer Science, Cornell University,  
Abstract: User-level network architectures that provide applications with direct access to network hardware have become popular with the emergence of high-speed networking technologies such as ATM and Fast Ethernet. However, experience with user-level network architectures such as U-Net [vEBBV95] has shown that building correct and efficient protocols on such architectures is a challenge. To address this problem, Promela++, an extension of the Promela protocol validation language has been developed. Promela++ allows automatic verification of protocol correctness against programmer specified safety requirements. Furthermore, Promela++ can be compiled to efficient C code. Thus far, the results are encouraging: the C code produced by the Promela++ compiler shows performance comparable to hand-coded versions of a relatively simple protocol.
Abstract-found: 1
Intro-found: 1
Reference: [BDF + 95] <author> M. A. Blumrich, C. Dubnicki, E. W. Felten, K. Li, and M. R. Mesarina. </author> <title> Virtual Memory Mapped Network Interfaces. </title> <journal> IEEE Micro, </journal> <volume> 15(1) </volume> <pages> 21-28, </pages> <month> February </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Recent research in high-speed network interfaces has focused on removing the operating system from the critical path of communication. An effective solution is to provide user-level messaging <ref> [vEBBV95, MC95, BDF + 95, PLC95, BJM + 96] </ref>, a technique that enables applications to send and receive messages without kernel intervention. The use of user-level networking architectures has pushed in-kernel protocol stacks into user space.
Reference: [BG92] <author> G. Berry and G. Gonthier. </author> <title> The ESTEREL Synchronous Programming Language: Design, Semantics, </title> <booktitle> Implementation. Science of Computer Programming, </booktitle> <volume> 19(2) </volume> <pages> 87-152, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: In practice, this is often a complex task and does not allow for code reuse in most cases. The protocol correctness issue has been addressed by multiple high-level validation languages such as Esterel <ref> [BG92] </ref> and Promela [Hol91]. However, though such languages allow for validation, the set of language abstractions provided by these systems is often very restricted, and support for access to low-level system resources is poor. As a result, specifying efficient protocols using these languages is quite difficult. <p> The following paragraphs discuss the shortcomings of existing languages with respect to these three requirements. Formal protocol validation languages such as Promela [Hol91] and Esterel <ref> [BG92] </ref> are well-suited for verifying protocol correctness. However, with the exception of Esterel, there does not appear to be any compiler that generates sufficiently high-performance code for any of these languages. In the case of Esterel, the HIPPCO [CDO96] optimizing compiler generates efficient code from a high-level specification.
Reference: [BJM + 96] <author> G. Buzzard, D. Jacobson, M. Mackey, S. Marovich, and J. Wilkes. </author> <title> An Implementation of the Hamlyn Sender-Managed Interface Architecture. </title> <booktitle> In Proceedings of the 2nd Symposium on Operating Systems Design and Implementation, </booktitle> <address> Seattle, Washington, </address> <year> 1996. </year>
Reference-contexts: 1 Introduction Recent research in high-speed network interfaces has focused on removing the operating system from the critical path of communication. An effective solution is to provide user-level messaging <ref> [vEBBV95, MC95, BDF + 95, PLC95, BJM + 96] </ref>, a technique that enables applications to send and receive messages without kernel intervention. The use of user-level networking architectures has pushed in-kernel protocol stacks into user space.
Reference: [CCHvE96] <author> C. C. Chang, G. Czajkowski, C. Hawblitzel, and T. von Eicken. </author> <title> Low-latency Communication on the IBM RISC System/6000 SP. </title> <booktitle> In Proceedings of Supercomputing '96, </booktitle> <year> 1996. </year>
Reference-contexts: On message receipt, the handler extracts the message from the network and incorporates it into the ongoing computation. The Active Messages library supports transmission of small messages as well as bulk transfer of data and has been implemented on MPPs (e.g., CM-5 [vECGS92], SP-2 <ref> [CCHvE96] </ref>, Meiko CS-2 [SS95]) and workstation clusters [vEBBV95]. The Active Messages implementation in Promela++ consists of two layers a flow-control layer that implements a window-based go-back-N retransmission scheme and a network layer that communicates directly with the physical network.
Reference: [CDO96] <author> C. Casteluccia, W. Dabbous, and S. O'Malley. </author> <title> Generating Efficient Protocol Code from an Abstract Specification. </title> <booktitle> In Proceedings of SIGCOMM '96, </booktitle> <institution> Stanford University, California, </institution> <year> 1996. </year>
Reference-contexts: However, though such languages allow for validation, the set of language abstractions provided by these systems is often very restricted, and support for access to low-level system resources is poor. As a result, specifying efficient protocols using these languages is quite difficult. Moreover, with the exception of HIPPCO <ref> [CDO96] </ref> (discussed later), compilers that generate efficient code for such languages do not exist. Thus, even if a correct protocol has been developed using these verification tools, the entire protocol must be re-implemented in a different language such as C which may (and often does) introduce errors in the implementation. <p> The optimizations used by the compiler ensure that the correctness properties are not violated during the Promela++ to C conversion. Compilation of a high-level protocol specification language has been described before <ref> [CDO96] </ref>, but Promela++ appears to be the only language that combines the advantages of protocol validation and optimized code generation from a modular specification. The rest of the paper is organized as follows. The motivation and a brief description of the language are given in Sections 2 and 3. <p> Formal protocol validation languages such as Promela [Hol91] and Esterel [BG92] are well-suited for verifying protocol correctness. However, with the exception of Esterel, there does not appear to be any compiler that generates sufficiently high-performance code for any of these languages. In the case of Esterel, the HIPPCO <ref> [CDO96] </ref> optimizing compiler generates efficient code from a high-level specification. However, Esterel, like most other protocol specification languages, suffers from a lack of sufficiently expressive language constructs which complicates the programmer's task significantly. For example, Esterel does not support arrays or user-defined types.
Reference: [CT90] <author> D. D. Clark and D. L. Tennenhouse. </author> <title> Architectural Considerations for a New Generation of Protocols. </title> <booktitle> In Proceedings of SIGCOMM '90, </booktitle> <pages> pages 200-208, </pages> <address> Philadelphia, Pennsylvania, </address> <year> 1990. </year>
Reference-contexts: In contrast, it is often difficult to tailor a monolithic stack to specific application requirements without rewriting large portions and introducing errors. Previous work has demonstrated that layering often adds considerable overheads to protocol processing <ref> [CT90] </ref>. Thus, the challenge is to combine the modularity and verifiability of layered protocol stacks with the good performance of monolithic (non-layered) protocol stacks. Various partial solutions have been proposed to this problem. Integrated Layer Processing [CT90] advocates the rewriting of existing protocol stacks such that the processing done by the <p> Previous work has demonstrated that layering often adds considerable overheads to protocol processing <ref> [CT90] </ref>. Thus, the challenge is to combine the modularity and verifiability of layered protocol stacks with the good performance of monolithic (non-layered) protocol stacks. Various partial solutions have been proposed to this problem. Integrated Layer Processing [CT90] advocates the rewriting of existing protocol stacks such that the processing done by the different layers is pipelined, avoiding message copies everytime a layer boundary is crossed. In practice, this is often a complex task and does not allow for code reuse in most cases.
Reference: [HL94] <author> R. Harper and P. Lee. </author> <title> Advanced Languages for Systems Software: the Fox Project in 1994. </title> <type> Technical Report CMU-CS-FOX-94-01, </type> <institution> Carnegie Mellon University, </institution> <year> 1994. </year>
Reference-contexts: Finally, no current protocol specification language provides any explicit abstractions for layered protocol stack construction. The Fox project <ref> [HL94] </ref> has attempted to address this issue using functors and signatures in ML but does not handle protocol verification.
Reference: [Hol91] <author> G. J. Holzmann. </author> <title> Design and Validation of Computer Protocols. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: In practice, this is often a complex task and does not allow for code reuse in most cases. The protocol correctness issue has been addressed by multiple high-level validation languages such as Esterel [BG92] and Promela <ref> [Hol91] </ref>. However, though such languages allow for validation, the set of language abstractions provided by these systems is often very restricted, and support for access to low-level system resources is poor. As a result, specifying efficient protocols using these languages is quite difficult. <p> This paper presents an overview of the design and initial implementation of Promela++, an extension of the Promela <ref> [Hol91] </ref> protocol validation language. Promela++ combines the advantages of a protocol validation language with various mechanisms that support efficient code generation from a layered specification. In particular, Promela++ allows the protocol developer to specify the control flow of a protocol layer in a C-like language. <p> The following paragraphs discuss the shortcomings of existing languages with respect to these three requirements. Formal protocol validation languages such as Promela <ref> [Hol91] </ref> and Esterel [BG92] are well-suited for verifying protocol correctness. However, with the exception of Esterel, there does not appear to be any compiler that generates sufficiently high-performance code for any of these languages. <p> Moreover, the ML programming model is very different from that of C/C++ and is quite unfamiliar to most protocol developers. 3 3 Design of Promela++ Promela++ is an extension of the Promela <ref> [Hol91] </ref> protocol validation language. The Promela protocol validation language was chosen as a starting point because of its closeness to C and the fact that it was specifically designed for protocol specification and validation. <p> The design goals for Promela++ were the following: * In order to support automatic verification of correctness requirements, there should be a straightforward translation from Promela++ to Promela. This will allow the use of existing tools, such as the SPIN validator <ref> [Hol91] </ref>, on Promela++ specifications. * In order to support domain-specific optimizations, Promela++ should have a minimal number of domain-specific language constructs based on a clearly defined execution model. * The syntax of Promela++ and its expressive power should be as close to C as possible, without compromising the first two goals. <p> In Figure 2, the portion of the code enclosed between `Cf' and `gC' in lines 41-46 (where the message is sent out using the send system call) is treated as opaque C code and passed on to the C compiler without processing. 3.3 Verification The standard Promela distribution <ref> [Hol91] </ref> includes a verifier called SPIN that does a depth first search of the protocol state space to check for violations of programmer specified safety properties. To use this verifier, the programmer writes a protocol specification in Promela++ along with the safety properties that need to be checked. <p> The Active Messages implementation was also validated against certain simple assertions. The Promela++ to Promela compiler generates about 800 lines of Promela code. The verification was done using the SPIN validator <ref> [Hol91] </ref> that did a controlled depth-first search of the state space upto a depth of 200,000 nodes and checked about 2 million states for errors.
Reference: [HvRB96] <author> M. Hayden, R. van Renesse, and K. Birman. </author> <title> Optimizing Layered Communication Protocols. </title> <type> Technical report, </type> <institution> Cornell University, </institution> <year> 1996. </year> <month> 14 </month>
Reference-contexts: Thus, inlining along fast paths and outlining of UNLIKELY code fragments results in more efficient placement of code in memory and lower overheads along the fast paths. Delayed state updates <ref> [HvRB96] </ref> improve communication latency by delaying state updates until after the control has been passed to the next protocol layer on the fast path. This results in better overlap of communication with computation and reduces end-to-end message latency.
Reference: [MC95] <author> A. M. Mainwaring and D. E. Culler. </author> <title> Active Messages: Organization and Applications Programming Interface. </title> <note> http://now.CS.Berkeley.EDU/Papers/am-spec.ps, 1995. </note>
Reference-contexts: 1 Introduction Recent research in high-speed network interfaces has focused on removing the operating system from the critical path of communication. An effective solution is to provide user-level messaging <ref> [vEBBV95, MC95, BDF + 95, PLC95, BJM + 96] </ref>, a technique that enables applications to send and receive messages without kernel intervention. The use of user-level networking architectures has pushed in-kernel protocol stacks into user space.
Reference: [MPBO96] <author> D. Mosberger, L. L. Peterson, P. G. Bridges, and S. O'Malley. </author> <title> Analysis of Techniques to Improve Protocol Latency. </title> <booktitle> In Proceedings of SIGCOMM '96, </booktitle> <institution> Stanford University, California, </institution> <year> 1996. </year>
Reference-contexts: Second, since C is a general purpose language, it is difficult for a C compiler to make optimizations that are specific to the domain of protocol compilation. There is an ongoing effort to use C with a special compiler that performs certain non-standard optimizations <ref> [MPBO96] </ref> for the purpose of protocol construction, but this approach does not address the protocol correctness and verification issue. Finally, no current protocol specification language provides any explicit abstractions for layered protocol stack construction. <p> management routines are implemented as a protocol-independent runtime library. 4.1 Optimizations The current version of the Promela++ compiler implements two simple optimizations first, it converts the event emissions necessary for inter-layer communication into procedure calls wherever possible and second, it inlines procedure calls along the programmer-annotated fast paths (as in <ref> [MPBO96] </ref>). Converting event emissions to simple procedure calls of the appropriate event handler reduces the layering overheads significantly: the costs of allocating, enqueueing and dequeueing events as well as running the scheduler are now replaced by the cost of a procedure call. <p> The compiler simply creates a new block for the procedure body that contains all the local declarations. Some more aggressive optimizations that include outlining and delayed state updates look promising but have not yet been implemented. Outlining <ref> [MPBO96] </ref> is a technique that improves instruction 11 Optimization None -O fcall -O inline Hand-coded Latency (in sec) 176:2 78:8 78:2 77:9 Instruction count (recv) 242 117 112 100 Table 1: Performance of Active Messages cache performance by compacting the fast path code in one contiguous memory region and moving the
Reference: [PLC95] <author> S. Pakin, M. Lauria, and A. Chien. </author> <title> High Performance Messaging on Workstations: Illinois Fast Messages (FM) for Myrinet. </title> <booktitle> In Proceedings of Supercomputing '95, </booktitle> <address> San Diego, California, </address> <year> 1995. </year>
Reference-contexts: 1 Introduction Recent research in high-speed network interfaces has focused on removing the operating system from the critical path of communication. An effective solution is to provide user-level messaging <ref> [vEBBV95, MC95, BDF + 95, PLC95, BJM + 96] </ref>, a technique that enables applications to send and receive messages without kernel intervention. The use of user-level networking architectures has pushed in-kernel protocol stacks into user space.
Reference: [SS95] <author> K. E. Schauser and C. J. Scheiman. </author> <title> Experience with Active Messages on the Meiko CS-2. </title> <booktitle> In Proceedings of the 9th International Parallel Processing Symposium, </booktitle> <address> Santa Barbara, California, </address> <month> April </month> <year> 1995. </year>
Reference-contexts: On message receipt, the handler extracts the message from the network and incorporates it into the ongoing computation. The Active Messages library supports transmission of small messages as well as bulk transfer of data and has been implemented on MPPs (e.g., CM-5 [vECGS92], SP-2 [CCHvE96], Meiko CS-2 <ref> [SS95] </ref>) and workstation clusters [vEBBV95]. The Active Messages implementation in Promela++ consists of two layers a flow-control layer that implements a window-based go-back-N retransmission scheme and a network layer that communicates directly with the physical network.
Reference: [vEBBV95] <author> T. von Eicken, A. Basu, V. Buch, and W. Vogels. U-Net: </author> <title> A User-level Network Interface for Parallel and Distributed Computing. </title> <booktitle> In Proceedings of the 15th ACM Symposium on Operating System Principles, </booktitle> <pages> pages 40-53, </pages> <address> Copper Mountain Resort, Colorado, </address> <year> 1995. </year>
Reference-contexts: 1 Introduction Recent research in high-speed network interfaces has focused on removing the operating system from the critical path of communication. An effective solution is to provide user-level messaging <ref> [vEBBV95, MC95, BDF + 95, PLC95, BJM + 96] </ref>, a technique that enables applications to send and receive messages without kernel intervention. The use of user-level networking architectures has pushed in-kernel protocol stacks into user space. <p> The Active Messages library supports transmission of small messages as well as bulk transfer of data and has been implemented on MPPs (e.g., CM-5 [vECGS92], SP-2 [CCHvE96], Meiko CS-2 [SS95]) and workstation clusters <ref> [vEBBV95] </ref>. The Active Messages implementation in Promela++ consists of two layers a flow-control layer that implements a window-based go-back-N retransmission scheme and a network layer that communicates directly with the physical network.
Reference: [vECGS92] <author> T. von Eicken, D. E. Culler, S. C. Goldstein, and K. E. Schauser. </author> <title> Active Messages: A Mechanism for Integrated Communication and Computation. </title> <booktitle> In Proceedings of the 19th Annual Symposium on Computer Architecture, </booktitle> <pages> pages 256-266, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: The rest of the paper is organized as follows. The motivation and a brief description of the language are given in Sections 2 and 3. Section 4 describes the current compiler and a set of compiler optimizations based on the Promela++ language abstractions. An implementation of Active Messages <ref> [vECGS92] </ref> in Promela++ is described in Section 5 and its performance is 2 evaluated. <p> On message receipt, the handler extracts the message from the network and incorporates it into the ongoing computation. The Active Messages library supports transmission of small messages as well as bulk transfer of data and has been implemented on MPPs (e.g., CM-5 <ref> [vECGS92] </ref>, SP-2 [CCHvE96], Meiko CS-2 [SS95]) and workstation clusters [vEBBV95]. The Active Messages implementation in Promela++ consists of two layers a flow-control layer that implements a window-based go-back-N retransmission scheme and a network layer that communicates directly with the physical network.
Reference: [vRBG + 95] <author> R. van Renesse, K. P. Birman, B. B. Glade, K. Guo, M. Hayden, T. Hickey, D. Malki, A. Vaysburd, and W. Vogels. Horus: </author> <title> A Flexible Group Communications System. </title> <type> Technical Report TR95-1500, </type> <institution> Cornell University, Computer Science Department, </institution> <month> March </month> <year> 1995. </year> <month> 15 </month>
Reference-contexts: The Promela++ design is based on an execution model that is very similar to the execution model of the Horus system <ref> [vRBG + 95] </ref>. The following subsections first define the Promela++ execution model and then describe how Promela++ directly implements the execution model. 3.1 Execution Model Conceptually, each protocol layer is represented by a co-routine that communicates with adjacent layers via pairs of asynchronous send and receive channels. <p> Ideally, only the code in the LIKELY branches of the called procedures should be inlined. Further compiler analysis is required to make this possible. More complex protocols such as the Horus communication system <ref> [vRBG + 95] </ref> are being written, verified and evaluated using Promela++. Finally, profiling information instead of programmer annotations should be used to identify LIKELY paths. Acknowledgments We are grateful to the anonymous referees for their comments which helped us in improving the presentation significantly.
References-found: 16

