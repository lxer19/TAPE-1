URL: http://www.pdos.lcs.mit.edu/~hbriceno/thesis.ps
Refering-URL: http://www.pdos.lcs.mit.edu/~hbriceno/
Root-URL: 
Title: Decentralizing UNIX Abstractions in the Exokernel Architecture  
Author: by H ector Manuel Brice no Pulido M. Frans Kaashoek Gregory R. Ganger Dawson R. Engler Arthur C. Smith 
Degree: Submitted to the Department of Electrical Engineering and Computer Science in partial fulfillment of the requirements for the degrees of Bachelor of Science and Master of Engineering in Computer Science and Engineering at the  All rights reserved. Author  Certified by  Associate Professor Thesis Supervisor Certified by  Postdoctoral Associate Thesis Supervisor Certified by  Ph.D. Candidate Thesis Supervisor Accepted by  Chairman, Departmental Committee on Graduate Students  
Date: February 1997  February 7, 1997  
Affiliation: MASSACHUSETTS INSTITUTE OF TECHNOLOGY  c Massachusetts Institute of Technology 1997.  Department of Electrical Engineering and Computer Science  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> M. Accetta, R. Baron, W. Bolosky, D. Golub, R. Rashid, A. Tevanian, and M. Young. </author> <title> Mach: a new kernel foundation for UNIX development. </title> <booktitle> In Proceedings of the Summer 1986 USENIX Conference, </booktitle> <pages> pages 93112, </pages> <month> July </month> <year> 1986. </year>
Reference-contexts: Although the paper presents the ideas, it does not present any platform or mechanisms to carry them about. Microkernels like Mach <ref> [1] </ref>, Chorus [15], and QNX [8] move many of the structures of traditional kernels into user-level servers. In contrast to the user-level servers discussed throughout this thesis, their user-level servers are privileged, and therefore hard to replace and processes are forced to use them.
Reference: [2] <author> T.E. Anderson. </author> <title> The case for application-specific operating systems. </title> <booktitle> In Third Workshop on Workstation Operating Systems, </booktitle> <pages> pages 9294, </pages> <year> 1992. </year>
Reference-contexts: Introduction It has been widely recognized that traditional operating systems (OSs) should provide much more flexibility and performance to applications <ref> [2, 3, 4, 14] </ref>. The exokernel architecture is intended to solve the performance and flexibility problems associated with traditional OSs by giving applications protected and efficient control of hardware and software resources. Exokernels simply protect resources, allowing applications to manage them. <p> The related work can be divided into two areas: The idea of library operating systems, which is the context of this thesis, and mechanisms for decentralizing shared protected state. Library operating systems were first proposed by Anderson <ref> [2] </ref> in a two-page position paper. In that paper, Anderson proposes an application-specific structure where as much of the operating system as possible should be pushed into runtime library routines linked in with each application.
Reference: [3] <author> B. N. Bershad, S. Savage, P. Pardyak, E. G. Sirer, M. Fiuczynski, D. Becker, S. Eggers, and C. Chambers. </author> <title> Extensibility, safety and performance in the SPIN operating system. </title> <booktitle> In Proceedings of the Fifteenth ACM Symposium on Operating Systems Principles, </booktitle> <month> December </month> <year> 1995. </year>
Reference-contexts: Introduction It has been widely recognized that traditional operating systems (OSs) should provide much more flexibility and performance to applications <ref> [2, 3, 4, 14] </ref>. The exokernel architecture is intended to solve the performance and flexibility problems associated with traditional OSs by giving applications protected and efficient control of hardware and software resources. Exokernels simply protect resources, allowing applications to manage them. <p> This paper did not describe how this approach could be used for other operating system abstractions and missed an opportunity to handle more cases directly by the process. Finally, the SPIN operating system <ref> [3] </ref> also addresses the problem of protected sharing. SPIN exploits type-safe languages and protected environments to guarantee that state is only modified by specific code. 37 38 Chapter 6 Conclusion Empirically centralized resource management can significantly hurt application performance and flexibility [3, 4]. <p> Finally, the SPIN operating system [3] also addresses the problem of protected sharing. SPIN exploits type-safe languages and protected environments to guarantee that state is only modified by specific code. 37 38 Chapter 6 Conclusion Empirically centralized resource management can significantly hurt application performance and flexibility <ref> [3, 4] </ref>. To solve these problems, this thesis shows how to decentralize resource management using unprivileged library operating systems. Unfortunately, while decentralization is has many advantages, it is can be difficult to implement well. To aid implementors, this thesis has made three main contributions: 1.
Reference: [4] <author> D. R. Engler, M. F. Kaashoek, and J. O'Toole Jr. Exokernel: </author> <title> an operating system architecture for application-specific resource management. </title> <booktitle> In Proceedings of the Fifteenth ACM Symposium on Operating Systems Principles, </booktitle> <month> December </month> <year> 1995. </year>
Reference-contexts: Introduction It has been widely recognized that traditional operating systems (OSs) should provide much more flexibility and performance to applications <ref> [2, 3, 4, 14] </ref>. The exokernel architecture is intended to solve the performance and flexibility problems associated with traditional OSs by giving applications protected and efficient control of hardware and software resources. Exokernels simply protect resources, allowing applications to manage them. <p> Finally, the SPIN operating system [3] also addresses the problem of protected sharing. SPIN exploits type-safe languages and protected environments to guarantee that state is only modified by specific code. 37 38 Chapter 6 Conclusion Empirically centralized resource management can significantly hurt application performance and flexibility <ref> [3, 4] </ref>. To solve these problems, this thesis shows how to decentralize resource management using unprivileged library operating systems. Unfortunately, while decentralization is has many advantages, it is can be difficult to implement well. To aid implementors, this thesis has made three main contributions: 1.
Reference: [5] <author> D.R. Engler and M.F. Kaashoek. DPF: </author> <title> fast, flexible message demultiplexing using dynamic code generation. </title> <booktitle> In ACM Communication Architectures, Protocols, and Applications (SIG-COMM) 1996, </booktitle> <pages> pages 5359, </pages> <address> Stanford, CA, USA, </address> <month> August </month> <year> 1996. </year>
Reference-contexts: Whenever a process wants access to a resource, it presents a capability. If that capability dominates any of the capabilities associated with the resource, the process is granted access. The networking device is protected by a packet filter engine [13]. The XOK implementation of the packet filter engine, DPF <ref> [5] </ref>, uses dynamic code generation to obtain high performance. 3.3 Implementation of Major Abstractions and Mechanisms 3.3.1 Bootstrapping, Fork and Exec A recurring problem with any OS implementation is bootstrapping: how to initialize and setup the system when it starts.
Reference: [6] <author> Gregory R. Ganger and M. Frans Kaashoek. </author> <title> Embedded inodes and explicit grouping: Exploiting disk bandwidth for small files. </title> <booktitle> Proceedings of the Winter 1997 USENIX Conference, </booktitle> <pages> pages 117, </pages> <month> January </month> <year> 1997. </year>
Reference-contexts: Therefore, when a process inherits a file descriptor, it will know what kind of file descriptor and which functions to use to manipulate it. 3.3.5 Files ExOS 1.0 supports both a local and a remote file system. The local file system is based on the Co-locating FFS (C-FFS) <ref> [6] </ref>. The remote file system is based on Sun's Network File System (NFS) [16]. The NFS implementation is simple.
Reference: [7] <author> Michael Greenwald and David Cheriton. </author> <title> The synergy between non-blocking synchronization and operating system structure. </title> <booktitle> In Proceedings of the Second Symposium on Operating Systems Design and Implementation, </booktitle> <month> October </month> <year> 1996. </year>
Reference-contexts: in a centralized system, because the effect of a bug is restricted to the authority of the associated abstraction [11]. * Concurrency Control: Concurrency control can be achieved either using standard distributed algorithms or duplicating the single-point serialization of centralized OSs via mechanisms such as critical regions and non-blocking synchronization <ref> [7] </ref>.
Reference: [8] <author> D. Hildebrand. </author> <title> An architectural overview of QNX. </title> <booktitle> In Proceedings of the Usenix Workshop on Micro-kernels and Other Kernel Architectures, </booktitle> <month> April </month> <year> 1992. </year>
Reference-contexts: Although the paper presents the ideas, it does not present any platform or mechanisms to carry them about. Microkernels like Mach [1], Chorus [15], and QNX <ref> [8] </ref> move many of the structures of traditional kernels into user-level servers. In contrast to the user-level servers discussed throughout this thesis, their user-level servers are privileged, and therefore hard to replace and processes are forced to use them.
Reference: [9] <author> Howard, J.H. Kazar, M.L. Menees, S.G. Nichols, D.A. Satyanarayanan M. Sidebotham R.N., West, and M.J. </author> <title> Scale and performance in a distributed file system. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1):5181, </volume> <month> February </month> <year> 1988. </year>
Reference-contexts: It is an implementation that gives enough functionality to run a wide variety of applications, like vi, gcc, make, and common benchmarks such as Andrew <ref> [9] </ref> and Lmbench [12]. Although it was not a design goal, ExOS 1.0 has also supported the implementation of an emulator that can run some statically-linked OpenBSD binaries unchanged. ExOS 1.0 is implemented as a user-level untrusted library that is linked with each application. <p> The results show that ExOS 1.0 I/O performance is comparable to that of OpenBSD . There are still some deficiencies with process creation time demonstrated by the results of the second benchmark. ExOS 1.0 can also successfully execute the Andrew Benchmark <ref> [9] </ref> and most of the Lmbench benchmarks [12] (except those using mmap and RPC which are not currently supported).
Reference: [10] <author> C. Maeda and B. N. Bershad. </author> <title> Protocol service decomposition for high-performance networking. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 244255, </pages> <year> 1993. </year> <month> 41 </month>
Reference-contexts: In contrast to the user-level servers discussed throughout this thesis, their user-level servers are privileged, and therefore hard to replace and processes are forced to use them. A closer approximation of the mechanisms described in this thesis was proposed by Maeda <ref> [10] </ref>. In this paper, system calls like recvfrom and sendto were handled directly by the process itself and only in exceptional cases, like when sockets are being shared, would they be handled by a server.
Reference: [11] <author> David Mazi eres and Frans Kaashoek. </author> <title> Secure applications need flexible operating systems. </title> <note> submitted, </note> <month> February </month> <year> 1997. </year>
Reference-contexts: This approach would provide even better security than is provided in a centralized system, because the effect of a bug is restricted to the authority of the associated abstraction <ref> [11] </ref>. * Concurrency Control: Concurrency control can be achieved either using standard distributed algorithms or duplicating the single-point serialization of centralized OSs via mechanisms such as critical regions and non-blocking synchronization [7].
Reference: [12] <author> Larry McVoy and Carl Staelin. lmbench: </author> <title> Portable tools for performance analysis. </title> <booktitle> Proceedings of the San Diego USENIX Conference, </booktitle> <pages> pages 279294, </pages> <year> 1996. </year>
Reference-contexts: It is an implementation that gives enough functionality to run a wide variety of applications, like vi, gcc, make, and common benchmarks such as Andrew [9] and Lmbench <ref> [12] </ref>. Although it was not a design goal, ExOS 1.0 has also supported the implementation of an emulator that can run some statically-linked OpenBSD binaries unchanged. ExOS 1.0 is implemented as a user-level untrusted library that is linked with each application. <p> The results show that ExOS 1.0 I/O performance is comparable to that of OpenBSD . There are still some deficiencies with process creation time demonstrated by the results of the second benchmark. ExOS 1.0 can also successfully execute the Andrew Benchmark [9] and most of the Lmbench benchmarks <ref> [12] </ref> (except those using mmap and RPC which are not currently supported). Again, the benchmark results are not great: ExOS 1.0 has not been optimized at all simplicity was one of the main design goals. 3.5 Discussion At this point we are satisfied with the functionality of ExOS 1.0 .
Reference: [13] <author> J.C. Mogul, R.F. Rashid, and M.J. Accetta. </author> <title> The packet filter: An efficient mechanism for user-level network code. </title> <booktitle> In Proceedings of the Eleventh ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 3951, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: Whenever a process wants access to a resource, it presents a capability. If that capability dominates any of the capabilities associated with the resource, the process is granted access. The networking device is protected by a packet filter engine <ref> [13] </ref>. The XOK implementation of the packet filter engine, DPF [5], uses dynamic code generation to obtain high performance. 3.3 Implementation of Major Abstractions and Mechanisms 3.3.1 Bootstrapping, Fork and Exec A recurring problem with any OS implementation is bootstrapping: how to initialize and setup the system when it starts.
Reference: [14] <author> J. K. Ousterhout. </author> <booktitle> Why aren't operating systems getting faster as fast as hardware? In Proceedings of the Summer 1990 USENIX Conference, </booktitle> <pages> pages 247256, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Introduction It has been widely recognized that traditional operating systems (OSs) should provide much more flexibility and performance to applications <ref> [2, 3, 4, 14] </ref>. The exokernel architecture is intended to solve the performance and flexibility problems associated with traditional OSs by giving applications protected and efficient control of hardware and software resources. Exokernels simply protect resources, allowing applications to manage them.
Reference: [15] <author> M. Rozier, V. Abrossimov, F. Armand, I. Boule, M. Gien, M. Guillemont, F. Herrmann, C. Kaiser, S. Langlois, P. Leonard, and W. Neuhauser. </author> <title> Chorus distributed operating system. </title> <booktitle> Computing Systems, </booktitle> <address> 1(4):305370, </address> <year> 1988. </year>
Reference-contexts: Although the paper presents the ideas, it does not present any platform or mechanisms to carry them about. Microkernels like Mach [1], Chorus <ref> [15] </ref>, and QNX [8] move many of the structures of traditional kernels into user-level servers. In contrast to the user-level servers discussed throughout this thesis, their user-level servers are privileged, and therefore hard to replace and processes are forced to use them.
Reference: [16] <author> Inc. Sun Microsystems. NFS: </author> <title> Network file system protocol specification. </title> <journal> RFC: </journal> <volume> 1094, </volume> <month> March </month> <year> 1989. </year>
Reference-contexts: The local file system is based on the Co-locating FFS (C-FFS) [6]. The remote file system is based on Sun's Network File System (NFS) <ref> [16] </ref>. The NFS implementation is simple. The first process mounts the root file system from a statically-determined server and places in shared memory a socket handler (see 3.3.6) to be used for all communication with the NFS server. Processes map each remote file operation to NFS requests.
Reference: [17] <author> Andrew S. Tanenbaum. </author> <title> Modern Operating Systems. </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year> <month> 42 </month>
Reference-contexts: It consists of the executable program's data and stack, its program counter, stack pointer, and other registers, and all other information needed to run the program <ref> [17] </ref>. Processes can be suspended and resumed to allow multiple processes to timeshare a machine. There are usually a set of credentials associated with each process that define the resources it is allowed to access.
References-found: 17

