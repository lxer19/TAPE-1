URL: http://www.cs.arizona.edu/scout/Papers/joust.ps
Refering-URL: http://www.cs.arizona.edu/scout/publications.html
Root-URL: http://www.cs.arizona.edu
Title: Joust: A Platform for Liquid Software  
Author: John H. Hartman, Larry L. Peterson, Andy Bavier, Peter A. Bigot, Patrick Bridges Brady Montz, Rob Piltz, Todd A Proebsting, and Oliver Spatscheck 
Affiliation: Department of Computer Science University of Arizona  
Abstract: Mobile code makes it easier to maintain, debug, update, and customize a system. Active networks are one of the most interesting applications of mobile code: code is injected into the nodes of a network to customize the network's functionality, such as routing, and to add new features, such as special-purpose congestion control and filtering algorithms. The challenge is to develop a communication-oriented platform for such systems. We refer to mobile code targeted at low-level, communication-oriented systems like active networks as liquid software, the key distinction being that liquid software is focused on the efficient transfer of data, not high-performance computation. To this end, we have designed and implemented Joust, which consists of a complete re-implementation of the Java virtual machine (including both the runtime system and a just-in-time compiler), running on the Scout operating system (a configurable, communication-oriented OS). The result is a configurable, high-performance platform for running liquid software. We present the results of implementing two different applications of liquid software on Joust, including a prototype architecture for active networks.
Abstract-found: 1
Intro-found: 1
Reference: [BW88] <author> H. Boehm and M. Weiser. </author> <title> Garbage collection in an uncooperative environment. </title> <journal> Software Practice & Experience, </journal> <pages> pages 807820, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: This limited form of roll-forward prevents the system from deadlocking if the catching thread is inside a critical section when an exception is thrown. Finally, JVM provides garbage-collection facilities. The Joust garbage collector is adapted from the Boehm-Demers-Weiser (BDW) conservative garbage collector <ref> [BW88] </ref>. This collector considers every register and every word of allocated memory a potential pointer, and considers all memory reachable from these pointers to be in-use.
Reference: [Cor97a] <institution> Microsoft Corporation. Microsoft security management architecture white paper. </institution> <note> URL: http://www.microsoft.com/security/ie4security.htm, 1997. </note>
Reference-contexts: The more difficult question is how to enforce a security policy for multiple, mutually untrusted Java applications that interact with each other within JVM. This is the subject of current research, as summarized by Wallach et al. [WBDF97]. Netscape [Cor97b] and Microsoft <ref> [Cor97a] </ref> use object signing to identify the principal responsible for the program, and extended stack introspection to determine the rights of a current thread. These models can easily be used, not only to reveal the rights a current thread possesses, but also to determine the principal that requested those rights.
Reference: [Cor97b] <author> Netscape Communications Corporation. </author> <title> Netscape developer online documentation. </title> <note> URL: http://developer.netscape.com/library/documentation/, 1997. </note>
Reference-contexts: The more difficult question is how to enforce a security policy for multiple, mutually untrusted Java applications that interact with each other within JVM. This is the subject of current research, as summarized by Wallach et al. [WBDF97]. Netscape <ref> [Cor97b] </ref> and Microsoft [Cor97a] use object signing to identify the principal responsible for the program, and extended stack introspection to determine the rights of a current thread.
Reference: [GP96] <author> William G. Griswold and Paul S. Phillips. </author> <title> Microbenchmarks for Java. </title> <note> URL: http://www-cse.uscd.edu/wgg/JavaProf/javaprof.html, 1996. </note>
Reference-contexts: Table 1 shows the performance of several Java implementations on a set of microbenchmarks adapted from the UCSD Java Microbench-marks <ref> [GP96] </ref>. The times are in microseconds, obtained by measuring a given number of repetitions and averaging. All tests were performed on a 200MHz Pentium Pro system; the Unix tests used Linux 2.0.31. We tested two versions of Sun's Java Developer's Kit.
Reference: [HKM + ] <author> Michael Hicks, Pankaj Kakkar, Jonathan T. Moore, Carl A. Gunter, and Scott Nettles. </author> <title> PLAN: A programming language for active networks. </title> <address> URL: http://www.cis.upenn.edu/switchware/papers/plan.ps. </address>
Reference-contexts: Active networking is just one example of a class of systems that exploit liquid softwarelow-level, communication-oriented code that easily flows from machine to machine [HMPP96]. Several active network prototypes exist, including ANTS [WGT98] and PLAN <ref> [HKM + ] </ref>. These prototypes differ in their details, but they all define an active network execution environment that runs at user-level on general-purpose operating systems. General-purpose operating systems are typically designed for computation, not communication, and therefore provide neither the performance nor the services required by active networks.
Reference: [HMPP96] <author> John H. Hartman, Udi Manber, Larry L. Peterson, and Todd A. Proebsting. </author> <title> Liquid software: A new paradigm for networked systems. </title> <type> Technical Report 9611, </type> <institution> Department of Computer Science, The University of Arizona, </institution> <month> June </month> <year> 1996. </year>
Reference-contexts: A network that exploits mobile code in this way is called an active network because the network's packet delivery service is programmable, rather than fixed. Active networking is just one example of a class of systems that exploit liquid softwarelow-level, communication-oriented code that easily flows from machine to machine <ref> [HMPP96] </ref>. Several active network prototypes exist, including ANTS [WGT98] and PLAN [HKM + ]. These prototypes differ in their details, but they all define an active network execution environment that runs at user-level on general-purpose operating systems.
Reference: [LY97] <author> Tim Lindholm and Frank Yellin. </author> <title> The Java Virtual Machine Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1997. </year>
Reference-contexts: UNIX, for example, encapsulates computation within the process abstraction, and gives processes very little control over CPU scheduling. Language runtime systems, such as the Java virtual machine <ref> [LY97] </ref>, make the problem worse by providing high-level abstractions through which applications access system resources. Indeed, Java applications are unable to control memory allocation, and are forced to rely on the JVM garbage collector's policies.
Reference: [MP96] <author> David Mosberger and Larry Peterson. </author> <title> Making paths explicit in the Scout operating system. </title> <booktitle> In Proceedings of the Second Symposium on Operating Systems Design and Implementation, </booktitle> <pages> pages 153168, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: The three major components of Joust are then described in the subsequent three sections: Section 3 gives an overview of Scout <ref> [MP96] </ref>, the underlying OS upon which Joust is built; Section 4 describes the Java runtime system; and Section 5 describes the JIT compiler.
Reference: [Pag97] <institution> BISS GmbH Home Page. Biss GmbH. </institution> <note> URL: http://www.biss-net.com/, 1997. </note>
Reference-contexts: Unfortunately, WIMP is not a GUI toolkit; it is simply a window manager. It draws geometric shapes, but does not implement widgets, such as buttons. Instead of writing an entire GUI toolkit ourselves, we use the BISS GmbH <ref> [Pag97] </ref> implementation of the AWT. BISS AWT can be used as a substitute for Java's AWT, or as the toolkit underneath it. Joust uses it as a toolkit so that applications require no modification; they use the standard Sun AWT classes.
Reference: [PTB + 97] <author> Todd A. Proebsting, Gregg Townsend, Patrick Bridges, John H. Hartman, Tim Newsham, and Scott A. Watterson. Toba: </author> <title> Java for applicationsa way ahead of time (WAT) compiler. </title> <type> Technical Report 9701, </type> <institution> Department of Computer Science, The University of Arizona, </institution> <year> 1997. </year>
Reference-contexts: This involves exposing the path and message abstraction to the application, so that it can use them effectively. Together, these optimizations result in a high-performance JVM that is specialized for use in a communication-oriented system. 4.1 General Optimizations Joust's JVM was originally developed for the Toba system <ref> [PTB + 97] </ref>. There are several platform-independent issues in the implementation of JVM, primarily related to differences between JVM's functionality and that commonly provided by operating systems. First, JVM implements pre-emptive threads that use monitors and condition variables to synchronize. Java monitors are relatively unique in that they are recursive. <p> Section 7 describes a similar extension that is used to control how a Scout path is scheduled. Appears in IEEE Networks, July 1998. 11 5 Bytecode Compiler The Joust execution framework is based on the Toba translation system <ref> [PTB + 97] </ref>. Toba originally supported a way-ahead-of-time (WAT) Java translator, and ran on various Unix systems. We have since ported it to Scout and added a just-in-time (JIT) compiler.
Reference: [SP97] <author> O. Spatscheck and L. Peterson. Escort: </author> <title> Scout security architecture. </title> <type> Technical Report TR97-17, </type> <institution> Department of Computer Science, The University of Arizona, Tucson, Arizona, </institution> <month> December </month> <year> 1997. </year>
Reference-contexts: We are currently extending Scout to support multiple, mutually untrusted Java applications <ref> [SP97] </ref>. When these applications are independenti.e., they do not interact within the scope of JVMsecurity can be enforced by multiply instantiating the JVM module. The more difficult question is how to enforce a security policy for multiple, mutually untrusted Java applications that interact with each other within JVM.
Reference: [WA97] <author> T.J. Wilkinson and Associates. KAFFE: </author> <title> A free virtual machine to run Java code. </title> <note> URL: http://www.kaffe.org, 1997. Appears in IEEE Networks, </note> <month> July </month> <year> 1998. </year> <month> 19 </month>
Reference-contexts: We tested two versions of Sun's Java Developer's Kit. Version 1.0.2 is the one with which Toba (and Joust) is compatible, but significant performance improvements in later JDK releases make it appropriate to base our comparisons on JDK 1.1.3. We also compare with the Kaffe system <ref> [WA97] </ref>, another system which implements just-in-time compilation of Java bytecode. The final three columns compare the Toba/Linux JIT, the Toba/Linux WAT, and Joust. The microbenchmark names are for the most part descriptive.
Reference: [WBDF97] <author> Dan Wallach, Dirk Balfanz, Drew Dean, and Edward Felten. </author> <title> Extensible security architecture for Java. </title> <booktitle> In Proceedings of the Sixteenth ACM Symposium on Operating System Principles, </booktitle> <pages> pages 116128, </pages> <address> Saint Malo, France, </address> <month> October </month> <year> 1997. </year>
Reference-contexts: The more difficult question is how to enforce a security policy for multiple, mutually untrusted Java applications that interact with each other within JVM. This is the subject of current research, as summarized by Wallach et al. <ref> [WBDF97] </ref>. Netscape [Cor97b] and Microsoft [Cor97a] use object signing to identify the principal responsible for the program, and extended stack introspection to determine the rights of a current thread.
Reference: [WGT98] <author> David Wetherall, John Guttag, and David Tennenhouse. </author> <title> ANTS: A toolkit for building and dynamically deploying network protocols. </title> <booktitle> In IEEE OPENARCH 98, </booktitle> <address> San Francisco, CA, </address> <month> April </month> <year> 1998. </year>
Reference-contexts: Active networking is just one example of a class of systems that exploit liquid softwarelow-level, communication-oriented code that easily flows from machine to machine [HMPP96]. Several active network prototypes exist, including ANTS <ref> [WGT98] </ref> and PLAN [HKM + ]. These prototypes differ in their details, but they all define an active network execution environment that runs at user-level on general-purpose operating systems. <p> AWT and advanced data structures, an even greater speedup is to be expected because that code is WAT'ed by Toba and linked into the Joust kernel where it may called by any JIT'ed method. 6 Active Networks on Joust ANTS is an experimental active network architecture written in Java 1.0.2 <ref> [WGT98] </ref>. All ANTS packets, called capsules, carry or refer to executable code. This code is installed in ANTS routers in the network as they are traversed by capsules.
References-found: 14

