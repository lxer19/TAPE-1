URL: ftp://ftp.cs.huji.ac.il/users/transis/thesis/ohad-msc.ps.gz
Refering-URL: http://www.cs.huji.ac.il/labs/transis/thesis.html
Root-URL: http://www.cs.huji.ac.il
Title: The Design and Implementation of  
Author: Lansis/E Prof. Danny Dolev 
Degree: A thesis submitted in partial fulfillment of the requirements for the degree of Master of Science by Ohad Rodeh supervised by  
Date: May 25, 1997  
Address: Jerusalem, Israel  
Affiliation: Institute of Computer Science The Hebrew University of Jerusalem  
Abstract-found: 0
Intro-found: 1
Reference: [ADKM92] <author> Y. Amir, D. Dolev, S. Kramer, and D. Malki. Transis: </author> <title> A Communication Sub-System for High Availability. </title> <booktitle> In 22nd FTCS conference, </booktitle> <pages> pages 76-84, </pages> <month> July </month> <year> 1992. </year>
Reference: [ADMSM94] <author> Y. Amir, D. Dolev, P. M. Melliar-Smith, and L. E. Moser. </author> <title> Robust and Efficient Replication using Group Communication. </title> <type> Technical Report CS94-20, </type> <institution> Institute of Computer Science, The Hebrew University of Jerusalem, Jerusalem, Israel, </institution> <year> 1994. </year>
Reference-contexts: Two papers have been published describing how database replication can be efficiently accomplished using a replication layer over Lansis. One of these works <ref> [ADMSM94] </ref> benefits from the implementation of safe ordering at the Lansis level. The other [Kei94] does not require this. 9.2 Future Work We intend to pursue the unification of Transis and Ensemble in this framework.
Reference: [AMMS + 95] <author> Y. Amir, L. E. Moser, P. M. Melliar-Smith, D. A. Agarwal, and P. Ciarfella. </author> <title> The Totem Single-Ring Ordering and Membership Protocol. </title> <booktitle> In 13th ACM Transactions On Computer Systems, </booktitle> <volume> 4, </volume> <pages> pages 311-342, </pages> <month> November </month> <year> 1995. </year>
Reference-contexts: Today there are quite a few full scale applications written over the Isis commercial GCS [BJ87]. This includes air traffic control, process management, network simulation, file management, replicated databases, and more. In the Totem system <ref> [AMMS + 95] </ref> a token is passed through the members of a process group. Only the token holder may broadcast messages; other members are restricted to receiving messages and must buffer outgoing messages until they receive the token. <p> If no process fails then this layer is non-blocking. Thus, any message received by the Agree layer is eventually delivered. 4.6 The Membership Algorithm Many membership algorithms are known. In Lansis a symmetric algorithm is used. In Ensemble an asymmetric (leader-based) algorithm is used. In Totem <ref> [AMMS + 95] </ref> a token based algorithm is used. Any membership algorithm must provide view and failure notifications to the system. In Lansis/E 21 cm s;2 causally following cm r;1 . <p> All members proceed to deliver to the upper layer all messages in the buffer according to the leader's instructions. In addition to the Sequencer layer, Ensemble provides two alternative layers called Totem and Total. As their names imply they implement the total ordering algorithms of the Totem <ref> [AMMS + 95] </ref> and Total [AMMSA93] token-ring systems. The layers do not implement the membership and mes 46 sage reliability mechanisms of the systems. The Sequencer, Total, and Totem layers totally order all messages. They do not allow different types of messages (Causal, Safe, Agree) as in Lansis.
Reference: [AMMSA93] <author> Y. Amir, L. E. Moser, P. M. Melliar-Smith, and V. Agrawala. </author> <title> Fast Message Ordering and Membership Using a Logical Token-Passine Ring. </title> <booktitle> In 13th International Conrerence on Distributed Computing Systems, </booktitle> <pages> pages 551-560, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: In addition to the Sequencer layer, Ensemble provides two alternative layers called Totem and Total. As their names imply they implement the total ordering algorithms of the Totem [AMMS + 95] and Total <ref> [AMMSA93] </ref> token-ring systems. The layers do not implement the membership and mes 46 sage reliability mechanisms of the systems. The Sequencer, Total, and Totem layers totally order all messages. They do not allow different types of messages (Causal, Safe, Agree) as in Lansis.
Reference: [BDGB94] <author> O. Babaoglu, R. Davoli, L.A. Giachini, and M. Baker. Relacs: </author> <title> A Communication Infrastructure for Constructing Reliable Applications in Large-Scale Distributed Systems. </title> <type> TR UBLC-94-15, </type> <institution> University of Bologna, </institution> <month> Jan </month> <year> 1994. </year> <note> homepage: www.cs.unibo.it/projects/relacs.html. </note>
Reference-contexts: This mechanism coupled with the reachability relation forms the basis of the Phoenix membership and group services. Newtop [MES] developed at the University of Newcastle supports inter-group semantics and causal/total ordering via an extension of Lamport's time stamping technique [Lam78]. The Relacs system <ref> [BDGB94] </ref> also supports the process group abstraction, though at the semantic level virtual synchrony [BJ87] is compromised in order to facilitate group communication over large scale systems. Amoeba [KTHB89] supports the process group abstraction at the operating system level.
Reference: [BFH97] <author> K. Birman, R. Friedman, and M. Hayden. </author> <title> The Maestro Group Manager: A Structuring Tool For Applications with Multiple Quality of Service Requirements. </title> <type> Technical Report TR97-1619, </type> <institution> Cornell University, </institution> <year> 1997. </year> <note> homepage: www.cs.cornell.edu/- Info/Projects/Ensemble/Maestro/Maestro.html. </note>
Reference-contexts: However, layering also introduces the event protocol which complicates the system through the addition of intra-stack communication. Ensemble, unlike Lansis, uses the message passing paradigm for inter layer communication. This allows layers to be physically separated, i.e., they may reside on different machines. The Maestro system <ref> [BFH97] </ref> exploits this to separate the membership layers from the rest of stack. In order to avoid unnecessary coping of message content when crossing a layer boundary, when layers are situated on the same machine, content is stored in a shared buffer. <p> The new Sync performs synchronization via the following protocol: 1. Catch the DnBlockReq message. 2. Block the view. 3. When the UpStable events show StabVct = NumCast, UpSd (UpBlockOk). These modification were later embedded in the current version of Ensemble due to other research efforts <ref> [BFH97] </ref>. 60 8 Interoperability of Lansis/E and Ensemble Embedding Lansis in Ensemble we intended to achieve interoperability between Lansis protocols and Ensemble protocols. Thus, the user could intermix Lansis/E and Ensemble layers to achieve the protocol combinations most suitable to its application. <p> Since the membership layers are used only rarely and contain many of the complicated protocols, we can significantly reduce the code size of a regular stack without compromising performance. This was later implemented and enhanced as part of the Maestro <ref> [BFH97] </ref> system, built around Ensemble, providing a high level interface to the application. 64 9 Conclusions We rewrote Lansis code in the form of a set of Ensemble protocols, creating a new system named Lansis/E.
Reference: [BJ87] <author> K. Birman and T. Joseph. </author> <title> Exploiting Virtual Synchrony in Distributed Systems. </title> <booktitle> In 11th ACM Symp. Operating Systems Principles, </booktitle> <pages> pages 123-138, </pages> <note> Nov 87. homepage: www.isis.com. </note>
Reference-contexts: Ongoing work is conducted on the scalability issues. As networks grow support is needed for geographically disperse process groups. Support is also needed for large process groups comprised of more than two dozen processes. Today there are quite a few full scale applications written over the Isis commercial GCS <ref> [BJ87] </ref>. This includes air traffic control, process management, network simulation, file management, replicated databases, and more. In the Totem system [AMMS + 95] a token is passed through the members of a process group. <p> Newtop [MES] developed at the University of Newcastle supports inter-group semantics and causal/total ordering via an extension of Lamport's time stamping technique [Lam78]. The Relacs system [BDGB94] also supports the process group abstraction, though at the semantic level virtual synchrony <ref> [BJ87] </ref> is compromised in order to facilitate group communication over large scale systems. Amoeba [KTHB89] supports the process group abstraction at the operating system level. This provides better performance for applications that make heavy use of group communication.
Reference: [BSS91] <author> K. Birman, A. Schiper, and P. Stephenson. </author> <title> Lightweight Causal and Atomic Group Multicast. </title> <journal> ACM Trans. Comp. Syst., </journal> <volume> 9(3) </volume> <pages> 272-314, </pages> <year> 1991. </year> <institution> TR 91-1192 of dept. comp. sci., Cornell Uni. </institution> <month> 73 </month>
Reference-contexts: This section also describes the basic concepts of group communication, message ordering and virtual synchrony which we use throughout this work. 4.1 Lansis The Lansis package contains the core algorithms and functionality of Tran-sis in a LAN setting. The Transis session service, supporting lightweight groups <ref> [BSS91] </ref>, is built on top of Lansis. Above the Transis session service higher level services and applications are constructed. Lansis is a multicast communication layer implemented as a library connected through a socket (or a memory buffer) interface to the user application.
Reference: [BVR94] <author> K. Birman and R. Van Renesse. </author> <title> Reliable Distributed Com--puting with the Isis Toolkit. </title> <publisher> IEEE Computer Society Press, </publisher> <year> 1994. </year>
Reference-contexts: Ensemble is written in OCAML [Ler97] | a modern version of ML [MTH90]. This makes a semiautomatic proof of the system closer to reality. The design methodology behind Ensemble draws from experience gained through many years of coding realistic GCS's (Isis <ref> [BVR94] </ref>, Horus [VRCGS92]) stressing modularity and flexibility. Thus, Ensemble is divided into many layers each implementing a simple protocol; where layers communicate by message passing. By stacking together these layers, much like one uses lego blocks, the user may customize the system to suit his needs. <p> For example, in m 1 m 2 but process s receives m 2 and then m 1 . We view the causal order as a natural extension of the fifo order to the case where more than two parties communicate (for an extensive discussion see <ref> [BVR94] </ref>). Thus, our GCS supports it. 8 3.3 Membership Following the Relacs and Phoenix projects we define reachability between processes. We say that process q is reachable from process p if and only if p's messages eventually reach q (we denote this by p ;q). <p> Guaranteeing applications that failures are perceived "atomically" could simplify application writing considerably. This is the rational behind the virtual synchrony model. The virtual synchrony model has many variants. Here we reference three specifications of increasing strength | Virtual Synchrony (VS) <ref> [BVR94] </ref>, 27 Extended Virtual Synchrony (EVS) [MAMSA94], and Strong Virtual Syn--chrony (SVS) [FVR95]. The algorithms implementing these specifications are executed only in the event of a view change. The stronger the specification, the stronger the guarantees made to the application.
Reference: [CHTCB96] <author> T.D. Chandra, V. Hadzilacos, S. Toueg, and B. Charron-Bost. </author> <title> On the Impossibility of Group Membership. </title> <booktitle> In 10th ACM Symp. on Prin. of Database Systems (PODS), </booktitle> <pages> pages 322-330, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: FD p cannot tell if q has crashed, is slow, or cannot be reached because of a routing or link failure. Furthermore, the impossibility of creating a perfect failure detector has been shown <ref> [CHTCB96] </ref>. If FD p receives ImAlive messages from process q, previously determined to be unreachable, then q is determined to be reachable again. Since different processes use different timeouts and since network conditions change over time, reachability may be hard to compute and even harder to agree upon.
Reference: [CM84] <author> J. Chang and N.F. Maxemchuk. </author> <title> Reliable Broadcast Protocols. </title> <journal> ACM Transactions on Computer systems, </journal> <volume> 2(3) </volume> <pages> 251-273, </pages> <month> August </month> <year> 1984. </year> <note> homepage: www.atlantis.ivv.nasa.gov/- projects/RMP/RMP.html. </note>
Reference-contexts: This scheme facilitates efficient usage of the Ethernet broadcast media while preventing collisions. Furthermore, allowing only a single member to broadcast at each time instance makes it easy to support total order efficiently, to detect stability, and to prevent fragmentation. The RMP <ref> [CM84] </ref> system uses a closely related idea. It uses a postorder-ing token ring. Processes may broadcast at any time. Received messages are buffered until the leader's ordering message is received.
Reference: [CT91] <author> T. D. Chandra and S. Toueg. </author> <title> Unreliable Failure Detectors for Asynchronous Systems. </title> <booktitle> In 10th ACM Symp. on Prin. of Database Systems (PODS), </booktitle> <pages> pages 325-340, </pages> <year> 1991. </year>
Reference-contexts: We say that process q is reachable from process p if and only if p's messages eventually reach q (we denote this by p ;q). Reachability changes with time and network conditions. Typically, a failure detector <ref> [CT91] </ref> is used by each process to decide which processes are reachable at a given time instance. A failure detector usually works via timeouts and "I'm alive" messages. Denote the failure detector at process p by FD p . FD p broadcasts each timeout an "ImAlive" message.
Reference: [DMS94] <author> D. Dolev, D. Malki, and H. R. </author> <title> Strong. An Asynchronous Membership Protocol that Tolerates Partitions. </title> <type> Technical Report TR94-6, </type> <institution> Institute of Computer Science, The Hebrew University of Jerusalem, </institution> <year> 1994. </year>
Reference-contexts: It is waiting for message cm v;1 in order to complete an A-cut. we chose to use the Ensemble algorithm. For the sake of completeness we decided to include here a description of Lansis' original algorithm. This section provides an overview of the membership algorithm used in Lansis <ref> [DMS94] </ref> as well as a general discussion of membership algorithm semantics and interface. The Lansis algorithm is symmetric, that is, all processes play an equivalent role in it. As described in the system model (see Section 3), the membership algorithm has to compute the E-reachability relation and its equivalence classes.
Reference: [FVR95] <author> R. Friedman and R. Van Renesse. </author> <title> Strong and Weak Virtual Synchrony in Horus. </title> <type> Technical Report TR95-1537, </type> <institution> Cornell University, </institution> <year> 1995. </year>
Reference-contexts: This means that it separates the application from the network through a software module (see by N send/N deliver) capabilities while providing the application with an interface of strong semantics. The new interface follows the Strong Virtual Synchrony model <ref> [FVR95] </ref> and is denoted by SVS send/SVS deliver. This separation allows the GCS to buffer messages, delay their delivery until correct ordering is achieved, retransmit messages lost by the network, and more. <p> This included restructuring Lansis into layers, distribution of shared data structures, and translation of symmetric algorithms to asymmetric algorithms. We also enhanced the virtual synchrony specification supported by Lan-sis from extended virtual synchrony [MAMSA94] (EVS) to strong virtual synchrony <ref> [FVR95] </ref> (SVS). This provides the application with a stronger programming model. In this section we describe the restructuring of Lansis into the five Lan-sis/E layers. Each layer performs a distinct algorithm and provides a specific interface with guaranteed semantics (such as fifo order, causal order, etc.). <p> This is the rational behind the virtual synchrony model. The virtual synchrony model has many variants. Here we reference three specifications of increasing strength | Virtual Synchrony (VS) [BVR94], 27 Extended Virtual Synchrony (EVS) [MAMSA94], and Strong Virtual Syn--chrony (SVS) <ref> [FVR95] </ref>. The algorithms implementing these specifications are executed only in the event of a view change. The stronger the specification, the stronger the guarantees made to the application. Stronger guarantees come at the expense of a longer delay at view changes. Among the alternative virtual synchrony specifications Lansis supports EVS.
Reference: [Gra78] <editor> J.N. Gray. </editor> <booktitle> Notes on Database Operating Systems. In Operating Systems: An Advanced Course, Lecture Notes in Computer Science, </booktitle> <volume> volume 60, </volume> <pages> pages 393-481. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1978. </year>
Reference-contexts: In order to increase database availability it can be replicated onto multiple servers. Since databases are constantly updated and queried 65 consistency must be kept between replicas. In order to keep all the copies consistent two phase [Ske82] or three phase <ref> [Gra78] </ref> commit protocols are commonly used. Typically in such systems a server proposes an update, the other servers store the update in a stable storage (disk), verify that the update is consistent with their local state, and acknowledge.
Reference: [Hay96] <author> M. Hayden. </author> <title> The Ensemble Group Communication System, </title> <note> 1996. homepage: www.cs.cornell.edu/Info/Projects/- Ensemble/index.html. </note>
Reference-contexts: 1 Introduction This work presents the unification of two group communication systems: Lansis ([ADKM92], [MADK94]), developed at the Hebrew university, and Ensemble <ref> [Hay96] </ref>, developed at Cornell university. A Group Communication system (GCS) introduces the process group abstraction. A process group coherently binds together many processes into one entity. Within the context of a group a process may reliably broadcast messages using known paradigms such as fifo, causal, or total (atomic). <p> Furthermore, since the environment is lossy and asynchronous it is not always possible to ensure message safety, uniform total ordering, and reliability. 38 5 Ensemble This section describes the Ensemble system <ref> [Hay96] </ref>. The system is written in OCAML [Ler97], a novel dialect of ML, developed at the French institute for computer science research at INRIA. OCAML is a high level functional language that is machine independent. <p> The user can choose reliable/fifo-ordered/totally-ordered communication, using ATM/UDP/Deering UDP, employing the membership service, etc.. The regular stack, which will be discussed further below, supports virtual synchrony and reliable fifo. The following subsection is based on the Ensemble manual <ref> [Hay96] </ref> and is given here for the sake of completeness. 5.1 Infrastructure 5.1.1 Event Protocol: Intra-Stack Communication Ensemble embodies two forms of communication. The first is communication between protocol stacks in a process group using messages sent via some communication transport (UDP, ATM, etc.).
Reference: [HR] <author> M. Hayden and O. Rodeh. </author> <title> Security Architecture for Group Communication. </title> <booktitle> In preperation. </booktitle>
Reference-contexts: The other [Kei94] does not require this. 9.2 Future Work We intend to pursue the unification of Transis and Ensemble in this framework. We have gone ahead with this and implemented our security architecture for GCSs <ref> [HR] </ref> in Ensemble. Lansis/E groups can now be secured from outside tampering via authenticating all group communication using a security layer. We believe that Lansis/E should implement only total, causal and fifo ordering. The simplest, strongest, and most intuitive ordering guarantee is total order.
Reference: [HVR96] <author> M. Hayden and R. Van Renesse. </author> <title> Optimizing Layered Communication Protocols. </title> <type> Technical Report TR96-1613, </type> <institution> Cornell University, </institution> <year> 1996. </year> <month> 74 </month>
Reference-contexts: View changes are implemented in a clever way. When a process p passes from view V 1 to V 2 a new stack is initialized for V 2 This facilitates using different protocols in V 2 and helps in optimization <ref> [HVR96] </ref>. Since the network is asynchronous, the old stack is kept alive until all processes have passed from V 1 to V 2 . It is subsequentally garbage collected. We say that a process installs a new view when it performs the above. <p> The Gmp and Sync layers, which are active (almost) only when view changes occur, are stashed there (see Table 1). The most active layers, the Mnak and Stable, are placed closest to the network. New ways of optimizing stack have been suggested ([VR96], <ref> [HVR96] </ref>) and are being explored. 51 6 Lansis/E | Implementation in Ensemble 6.1 Overview In order to implement Lansis/E in the Ensemble framework four major changes had to be made: * Linearization: The interfaces between Lansis/E algorithms (recall Fig ure 5) are not linear, they had to be put into a
Reference: [Kei94] <author> I. Keidar. </author> <title> A Highly Available Paradigm for Consistent Object Replication. </title> <type> Master's thesis, </type> <institution> Institute of Computer Science, The Hebrew University of Jerusalem, Jerusalem, Israel, </institution> <year> 1994. </year> <note> Also available as Technical Report CS95-5. </note>
Reference-contexts: Two papers have been published describing how database replication can be efficiently accomplished using a replication layer over Lansis. One of these works [ADMSM94] benefits from the implementation of safe ordering at the Lansis level. The other <ref> [Kei94] </ref> does not require this. 9.2 Future Work We intend to pursue the unification of Transis and Ensemble in this framework. We have gone ahead with this and implemented our security architecture for GCSs [HR] in Ensemble.
Reference: [KTHB89] <author> M. F. Kaashoek, A. S. Tanenbaum, S. F. Hummel, and E. H. Bal. </author> <title> An Efficient Reliable Broadcast Protocol. </title> <journal> Operating Systems Review, </journal> <volume> 23(4) </volume> <pages> 5-19, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: The Relacs system [BDGB94] also supports the process group abstraction, though at the semantic level virtual synchrony [BJ87] is compromised in order to facilitate group communication over large scale systems. Amoeba <ref> [KTHB89] </ref> supports the process group abstraction at the operating system level. This provides better performance for applications that make heavy use of group communication. Most applications do not rely on low level reliable communication or group abstractions.
Reference: [Lam78] <author> L. Lamport. </author> <title> Time, Clocks, and the Ordering of Events in a Distributed System. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July 78. </month>
Reference-contexts: This mechanism coupled with the reachability relation forms the basis of the Phoenix membership and group services. Newtop [MES] developed at the University of Newcastle supports inter-group semantics and causal/total ordering via an extension of Lamport's time stamping technique <ref> [Lam78] </ref>. The Relacs system [BDGB94] also supports the process group abstraction, though at the semantic level virtual synchrony [BJ87] is compromised in order to facilitate group communication over large scale systems. Amoeba [KTHB89] supports the process group abstraction at the operating system level. <p> In order to guard against such scenarios we define the notion of causal order (denoted by ) among messages such that if m 2 is the response to message m 1 then m 1 m 2 . More generally, we wish to capture the happened-before relation defined by Lamport <ref> [Lam78] </ref>, and have m 1 m 2 if m 1 causes m 2 . To this end we first define: m 2 follows m 1 def 7 m 2 . Process s receives m 2 then m 1 .
Reference: [Ler97] <author> Xavier Leroy. </author> <title> The Objective Caml system release 1.05, 1997. homepage: </title> <publisher> pauillac.inria.fr/ocaml. </publisher>
Reference-contexts: The Horus [VRCGS92] system is a GCS developed in Cornell. Similar to Transis it is written in C. Its core functionality has been reimple-mented in the Ensemble system. Ensemble, as Lansis, implements the basic membership and message reliability algorithms. Ensemble is written in OCAML <ref> [Ler97] </ref> | a modern version of ML [MTH90]. This makes a semiautomatic proof of the system closer to reality. The design methodology behind Ensemble draws from experience gained through many years of coding realistic GCS's (Isis [BVR94], Horus [VRCGS92]) stressing modularity and flexibility. <p> Furthermore, since the environment is lossy and asynchronous it is not always possible to ensure message safety, uniform total ordering, and reliability. 38 5 Ensemble This section describes the Ensemble system [Hay96]. The system is written in OCAML <ref> [Ler97] </ref>, a novel dialect of ML, developed at the French institute for computer science research at INRIA. OCAML is a high level functional language that is machine independent.
Reference: [MADK94] <author> D. Malki, Y. Amir, D. Dolev, and S. Kramer. </author> <title> The Transis Approach to High Availability Cluster Communication. </title> <type> TR CS94-14, </type> <institution> Institute of Computer Science, The Hebrew University of Jerusalem, </institution> <month> June </month> <year> 1994. </year>
Reference-contexts: 1 Introduction This work presents the unification of two group communication systems: Lansis ([ADKM92], <ref> [MADK94] </ref>), developed at the Hebrew university, and Ensemble [Hay96], developed at Cornell university. A Group Communication system (GCS) introduces the process group abstraction. A process group coherently binds together many processes into one entity. <p> Processes may dynamically join and leave a group. Groups may dynamically partition into many components due to network failures/partitions. The GCS is responsible for hiding these "inconveniences" from the programmer, overcoming the asynchronous nature of the network and keeping the group abstraction consistent. The Transis ([ADKM92], <ref> [MADK94] </ref>) system is a GCS developed in the Hebrew university. It is written in the C programming language and consists of several disjoint modules. Transis' core functions are encapsulated in the Lansis subsystem which is responsible for basic membership and message reliability services.
Reference: [MAMSA94] <author> L. E. Moser, Y. Amir, P. M. Melliar-Smith, and D. A. Agar-wal. </author> <title> Extended Virtual Synchrony. </title> <booktitle> In 14th IEEE International Conference on Distributed Computing Systems (ICDCS), </booktitle> <pages> pages 56-65, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: This included restructuring Lansis into layers, distribution of shared data structures, and translation of symmetric algorithms to asymmetric algorithms. We also enhanced the virtual synchrony specification supported by Lan-sis from extended virtual synchrony <ref> [MAMSA94] </ref> (EVS) to strong virtual synchrony [FVR95] (SVS). This provides the application with a stronger programming model. In this section we describe the restructuring of Lansis into the five Lan-sis/E layers. <p> Three message ordering paradigms are supported: causal, agreed, and safe order. The current view of the processes is maintained and view changes are delivered in a consistent manner with application messages. In this Lansis follows the extended virtual synchrony <ref> [MAMSA94] </ref> model (EVS). Lansis interacts with the network through an N send/N deliver interface providing the client with an EVS send/EVS deliver interface. In order to save copy operations all messages are kept in a global buffer to which Lansis modules refer through pointers. <p> Guaranteeing applications that failures are perceived "atomically" could simplify application writing considerably. This is the rational behind the virtual synchrony model. The virtual synchrony model has many variants. Here we reference three specifications of increasing strength | Virtual Synchrony (VS) [BVR94], 27 Extended Virtual Synchrony (EVS) <ref> [MAMSA94] </ref>, and Strong Virtual Syn--chrony (SVS) [FVR95]. The algorithms implementing these specifications are executed only in the event of a view change. The stronger the specification, the stronger the guarantees made to the application. Stronger guarantees come at the expense of a longer delay at view changes.
Reference: [MES] <author> R.A. Macedo, P.D. Ezhilchelvan, and S.K. Shrivastava. New-top: </author> <title> A total order multicast protocol using causal blocks. </title> <institution> TR NE1 7RU UL, Department of Computing Science, University of Newcastle. </institution>
Reference-contexts: By making reachability a transitive relation the network can be cleanly split into disjoint components within which all sites can communicate. This mechanism coupled with the reachability relation forms the basis of the Phoenix membership and group services. Newtop <ref> [MES] </ref> developed at the University of Newcastle supports inter-group semantics and causal/total ordering via an extension of Lamport's time stamping technique [Lam78].
Reference: [MFSW95] <author> C. Malloth, P. Felber, A. Schiper, and U. Wilhelm. Pheonix: </author> <title> A toolkit for building fault-tolerant, distributed applications in large scale. </title> <type> TR CH-1015, </type> <institution> Ecole Polytechnic Federale de Lausanne, </institution> <month> July </month> <year> 1995. </year> <note> homepage: lsewww.epfl.ch/projets/- phoenix/index.html. </note>
Reference-contexts: The current holder of the token (the leader) broadcasts an ordering message every time interval, specifying the order in which buffered messages are to be delivered to the application. All members order messages according to the leader's instructions. The Phoenix project <ref> [MFSW95] </ref> is geared towards large scale systems. Phoenix identifies the basic predicate between sites to be reachability. Site 3 A can reach Site B if and only if B receives A's messages.
Reference: [MTH90] <author> R. Milner, M. Tofte, and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Similar to Transis it is written in C. Its core functionality has been reimple-mented in the Ensemble system. Ensemble, as Lansis, implements the basic membership and message reliability algorithms. Ensemble is written in OCAML [Ler97] | a modern version of ML <ref> [MTH90] </ref>. This makes a semiautomatic proof of the system closer to reality. The design methodology behind Ensemble draws from experience gained through many years of coding realistic GCS's (Isis [BVR94], Horus [VRCGS92]) stressing modularity and flexibility.
Reference: [Ske82] <author> D. Skeen. </author> <title> A Quorum-Based Commit Protocol. </title> <booktitle> In 6th Berke-ley Workshop on Distributed Data Management and Computer Networks, </booktitle> <pages> pages 69-80, </pages> <month> Feb. </month> <year> 1982. </year> <month> 75 </month>
Reference-contexts: In order to increase database availability it can be replicated onto multiple servers. Since databases are constantly updated and queried 65 consistency must be kept between replicas. In order to keep all the copies consistent two phase <ref> [Ske82] </ref> or three phase [Gra78] commit protocols are commonly used. Typically in such systems a server proposes an update, the other servers store the update in a stable storage (disk), verify that the update is consistent with their local state, and acknowledge.
Reference: [VR96] <author> R. Van Renesse. </author> <title> Masking the Overhead of Protocol Layering. </title> <booktitle> In 9th ACM SIGCOMM, </booktitle> <month> September </month> <year> 1996. </year>
Reference: [VRCGS92] <author> R. Van Renesse, R. Cooper, B. Glade, and P. Stephenson. </author> <title> A RISC Approach to Process Groups. </title> <booktitle> In Proceedings of the 5th ACM SIGOPS Workshop, </booktitle> <pages> pages 21-23, </pages> <month> September </month> <year> 1992. </year> <month> 76 </month>
Reference-contexts: Lansis assumes the existence of one group whose members all reside on the same LAN. Transis contains mechanisms which extend Lansis to efficiently handle multiple groups whose members are not in the same LAN. The Horus <ref> [VRCGS92] </ref> system is a GCS developed in Cornell. Similar to Transis it is written in C. Its core functionality has been reimple-mented in the Ensemble system. Ensemble, as Lansis, implements the basic membership and message reliability algorithms. Ensemble is written in OCAML [Ler97] | a modern version of ML [MTH90]. <p> Ensemble is written in OCAML [Ler97] | a modern version of ML [MTH90]. This makes a semiautomatic proof of the system closer to reality. The design methodology behind Ensemble draws from experience gained through many years of coding realistic GCS's (Isis [BVR94], Horus <ref> [VRCGS92] </ref>) stressing modularity and flexibility. Thus, Ensemble is divided into many layers each implementing a simple protocol; where layers communicate by message passing. By stacking together these layers, much like one uses lego blocks, the user may customize the system to suit his needs.
References-found: 30

