URL: http://www.cs.wvu.edu/~atkinson/pubs/confirmation-report.ps.gz
Refering-URL: http://www.cs.wvu.edu/~atkinson/publications.html
Root-URL: http://www.cs.wvu.edu
Email: E-mail: atkis@cs.uq.edu.au  
Phone: Phone: +61 7 3365 1003 Fax: +61 7 3365 1533  
Title: Engineering Software Library Systems Confirmation Report  
Author: Steven Atkinson 
Degree: Supervisor: Dr. R.W.  
Address: AUSTRALIA  
Affiliation: Duke Software Verification Research Centre Department of Computer Science The University of Queensland QLD 4072  
Abstract: The reuse of complete software developments and the processes used to create them has the potential to significantly ease the process of software engineering, by providing a source of verified software artifacts. It is suggested that reuse of software artifacts can be achieved through the utilization of software libraries. However, software library systems are not yet common or mature phenomena, and as such are themselves candidates for the application of requirements analysis, formal specification, design and other software engineering activities. A more formal approach to the analysis of software library requirements and their specification will provide a basis for the development of useful software libraries. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi. </author> <title> Baby modula-3 and a theory of objects. </title> <type> Technical Report 95, </type> <institution> Digital Systems Research Center, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: The abstract data types came to be regarded as object definitions, and Modula-3 incorporated the notion of object components <ref> [1] </ref>.
Reference: [2] <author> M. Abadi and L. Lamport. </author> <title> Composing specifications. </title> <type> Technical Report 66, </type> <institution> Digital Systems Research Center, </institution> <month> October </month> <year> 1990. </year> <month> 15 </month>
Reference-contexts: In effect, composition of components can be regarded as composition of their specifications. A number of attempts to formalise the composition operators of specifications have been made. Abadi and Lamport <ref> [2] </ref> develop results for language-independent specification composition. Butler and Duke [11] and Griffiths [28] provide semantics for the operation composition operators of the formal specification language Object-Z [18, 19].
Reference: [3] <author> S. Atkinson. </author> <title> A Unifying Model for Retrieval from Reusable Software Libraries. </title> <type> Technical Report 95-41 (pending), </type> <institution> Software Verification Research Centre, Dept. of Computer Science , Univ. of Queensland, Australia, </institution> <month> September </month> <year> 1995. </year>
Reference-contexts: A formal model of the retrieval operation, based upon existing approaches in the literature has been developed in <ref> [3] </ref>. A proposal for using the dynamic behaviour of classes in an object oriented library [5] has been made.
Reference: [4] <author> S. Atkinson. </author> <title> Formalizing the Eiffel Library Standard. </title> <type> Technical Report 95-35, </type> <institution> Software Verification Research Centre, Dept. of Computer Science , Univ. of Queensland, Australia, </institution> <month> September </month> <year> 1995. </year> <booktitle> To appear in Proc. Technology of Object-Oriented Languages and Systems: TOOLS 18, </booktitle> <publisher> Prentice Hall 1995. </publisher>
Reference-contexts: However, such a standard for object oriented libraries must determine how substitutability of classes (i.e. components) is defined. The Eiffel Library Standard [48] defines rules which determine when a library is substitutable for another. These rules were formalized <ref> [4] </ref> in the Object-Z specification language. 3.2 Research Plan The goal of the thesis is to provide a reasoned formal specification of reusable software library systems. The methodology being used is to analyze data and process requirements of library systems.
Reference: [5] <author> S. Atkinson and R. Duke. </author> <title> Behavioural retrieval from class libraries. </title> <journal> Australian Computer Science Communications, </journal> <volume> 17(1) </volume> <pages> 13-20, </pages> <month> January </month> <year> 1995. </year> <note> An extended version appears as Software Verification Research Centre Technical Report 94-28, </note> <year> 1994. </year>
Reference-contexts: A external-static hybrid approach has been proposed in [21]. Dynamic Indices: Behavioural techniques seek to take advantage of the distinguishing property of software | executability. Behaviour-based techniques <ref> [5, 53, 29, 49] </ref> seek to find relevant components by comparing input and output spaces of components. 2.3.2 Insertion There is not much literature directly discussing procedures for insertion into software libraries. Weide and Hollingsworth [67] argue that insertion of a component should ensure its local certifiability. <p> A formal model of the retrieval operation, based upon existing approaches in the literature has been developed in [3]. A proposal for using the dynamic behaviour of classes in an object oriented library <ref> [5] </ref> has been made. This retrieval methodology extended previous work [49, 53], by incorporating in the class model the notion that a class may fail to respond to a 14 message, and by using a lattice-inducing partial order over class behaviours to de-termine a notion of approximate component matching. <p> Hence, a formal specification of an object-oriented software library is the goal. The plan is to proceed to investigate: * relating the behavioral model of classes developed in <ref> [5] </ref> to state-based speci fications in Object-Z; * discovering methods of matching large systems, rather than individual com ponents; * defining a clear and formal design rationale for the construction of object oriented libraries.
Reference: [6] <author> M. J. Bates. </author> <title> Where should the person stop and the information search interface start? Information Processing and Management, </title> <booktitle> 26(5) </booktitle> <pages> 575-591, </pages> <year> 1990. </year>
Reference-contexts: This is done in order to take advantage of the work investigating the well-known problem of document retrieval. Bates <ref> [6] </ref> argues that the objective of retrieval systems should not be to strive for near-automation of the search process but rather to allow humans access to some of the hitherto internal strategic search processes used during retrieval.
Reference: [7] <author> N.J. Belkin and W. B. Croft. </author> <title> Information filtering and retrieval: Two sides of the same coin? Commun. </title> <journal> ACM, </journal> <volume> 35(12) </volume> <pages> 29-38, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: In the context of software libraries, this becomes especially relevant because the artifacts retrieved are potentially complex interacting software systems, the construction/discovery of which demands some measure of library user control. Belkin and Croft <ref> [7] </ref> present process models for information retrieval and filtering, concluding that at an abstract level, filtering and retrieval are identifiable tasks. Filtering software components from software libraries using metrics has already been treated as a viable method for retrieval from software libraries [52].
Reference: [8] <author> T.J. Biggerstaff and A.J. Perlis. </author> <title> Software Reusability: Concepts and Models, vol I. Frontier Series. </title> <publisher> ACM (Addison Wesley), </publisher> <address> New York, </address> <year> 1989. </year>
Reference-contexts: Regular attempts to summarize the status of software reuse research have been made. These summaries and some important issues raised in each are mentioned below: * Biggerstaff and Perlis <ref> [8] </ref> collected assorted articles from the literature, and partitioned reuse approaches into two sub-fields: 3 - Composition-based systems: reuse is enabled via composition of software components.
Reference: [9] <author> G. Booch. </author> <title> Software Components with Ada Structures. Tools, and Subsystems, </title> <year> 1987. </year>
Reference-contexts: Lins [37] defines a Modula-2 component library based upon data abstraction and notions of software components developed by Booch <ref> [9] </ref>. Uhl and Schmid [62] define a general catalogue of reusable abstract data types (focussing on container classes) using Ada as the component definition language.
Reference: [10] <author> J. Borstler. </author> <title> Feature-Oriented Classification for Software Reuse. </title> <booktitle> In Proc. Seventh International Conference of Software Engineering and Knowledge Engineering (SEKE'95), </booktitle> <year> 1995. </year>
Reference-contexts: These retrieval methods can be placed into a spectrum, based upon the nature of the indices used as representations of (i.e. surrogates for) components: External Indices: Keyword, facet [56], frame [15], descriptor [46], lexical affinity [41] and feature-based <ref> [10] </ref> techniques all seek to find relevant components based upon controlled vocabularies, properties and ontologies external to the com ponent; 12 Static Indices: Type signature [69] and specification matching [32, 57, 22, 70] tech-niques seek to find relevant components based upon elements of the structure of software components.
Reference: [11] <author> S. Butler and R. Duke. </author> <title> Defining Composition Operators for Object-Oriented Systems. </title> <note> Submitted to Formal Methods Europe (FME '96)., </note> <month> September </month> <year> 1995. </year>
Reference-contexts: In effect, composition of components can be regarded as composition of their specifications. A number of attempts to formalise the composition operators of specifications have been made. Abadi and Lamport [2] develop results for language-independent specification composition. Butler and Duke <ref> [11] </ref> and Griffiths [28] provide semantics for the operation composition operators of the formal specification language Object-Z [18, 19].
Reference: [12] <author> E. Casais. </author> <title> Managing class evolution in object-oriented systems. Object management, </title> <institution> Centre Universitaire d'Informatique, University of Geneva, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: These interface issues are important to ensure cooperation of components when adapted from a proposed library solution. Additionally the library itself will need to evolve over time, and do so in a way which minimally affects client code. Casais <ref> [12] </ref> discusses in detail and provides algorithms for small and large scale object-oriented library evolution.
Reference: [13] <author> P. Coad. </author> <title> Object-oriented patterns. </title> <journal> Commun. ACM, </journal> <volume> 35(9) </volume> <pages> 152-159, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: This implies that ideas from all stages of development comprise knowledge that is reusable. In particular, the reuse of common patterns which appear during software design <ref> [13, 24] </ref> has been an area of intensive research. Design patterns capture architectural and environmental constraints on participating components and connections between the components. Such patterns can be used to replay software developments using a catalogue of standard patterns [34].
Reference: [14] <author> M. Sitaraman (coordinator). </author> <title> Special feature: Component-based software using RESOLVE. </title> <journal> Software Engineering Notes, </journal> <volume> 19(4) </volume> <pages> 21-67, </pages> <month> October </month> <year> 1994. </year> <month> 16 </month>
Reference-contexts: It is claimed that no language paradigm enforces this notion. It is also claimed that the principles of information hiding and encapsulation need re-investigation to allow open implementations [35]. The reusable software group at Ohio State University have developed a reuse-oriented language called RESOLVE <ref> [14] </ref> which has attempted to solve the technical issues of component reuse using a swapping (rather than copying) notion of assignment [66], a two-tiered notion of component specification [58] and a concept module construct replacing the object oriented class construct.
Reference: [15] <author> M. del Rosario Girardi and B. Ibrahim. </author> <title> A similarity measure for retrieving soft-ware artifacts. </title> <booktitle> In Proceedings of the Sixth International Conference on Software Engineering and Knowledge Engineering (SEKE'94), </booktitle> <pages> pages 478-485. </pages> <address> Jurmala, Latvia, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: These retrieval methods can be placed into a spectrum, based upon the nature of the indices used as representations of (i.e. surrogates for) components: External Indices: Keyword, facet [56], frame <ref> [15] </ref>, descriptor [46], lexical affinity [41] and feature-based [10] techniques all seek to find relevant components based upon controlled vocabularies, properties and ontologies external to the com ponent; 12 Static Indices: Type signature [69] and specification matching [32, 57, 22, 70] tech-niques seek to find relevant components based upon elements of
Reference: [16] <author> R. Duke. </author> <title> Do Formal Object-Oriented Methods have a Future? . In Technology of Object-Oriented Languages and Systems: </title> <booktitle> TOOLS 15, </booktitle> <pages> pages 273-280. </pages> <publisher> Prentice-Hall, </publisher> <year> 1994. </year>
Reference-contexts: The problem exists where a number of separate libraries which each contain similar software artifacts are organized using different abstractions. This problem was subsequently highlighted by Duke <ref> [16] </ref> where it is argued that such differences make libraries difficult to use, by imposing a burden of understanding upon the library user. There it is claimed that the use of a library should be governed by formal rules to expose and maintain an underlying design rationale.
Reference: [17] <author> R. Duke, C. Bailes, and G. Smith. </author> <title> Modelling reactive objects. </title> <type> Technical Report 93-1, </type> <institution> Software Verification Research Centre, Dept. of Computer Science , Univ. of Queensland, Australia, </institution> <month> January </month> <year> 1993. </year>
Reference-contexts: In general, there may be many relationships between two software components, any of which may be used as the basis for retrieval from a software library. One component may be a subtype [38] of another, be behaviorally compatible [59] with another, or be substitutable <ref> [17] </ref> with another. It is important to consider all such relationships, because the organization of a software library can benefit from and may reflect the knowledge embodied in many component relationships. 2.2.3 Component Composition Software library components will depend upon each other and cooperate together to form systems.
Reference: [18] <author> R. Duke, P. King, G. Rose, and G. Smith. </author> <title> The Object-Z specification language. </title> <editor> In T. Korson, V. Vaishnavi, and B. Meyer, editors, </editor> <booktitle> Technology of Object-Oriented Languages and Systems: TOOLS 5, </booktitle> <pages> pages 465-483. </pages> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: A number of attempts to formalise the composition operators of specifications have been made. Abadi and Lamport [2] develop results for language-independent specification composition. Butler and Duke [11] and Griffiths [28] provide semantics for the operation composition operators of the formal specification language Object-Z <ref> [18, 19] </ref>.
Reference: [19] <author> R. Duke, G. Rose, and G. Smith. Object-Z: </author> <title> a Specification Language Advocated for the Description of Standards. </title> <type> Technical Report 94-45, </type> <institution> Software Verification Research Centre, Dept. of Computer Science , Univ. of Queensland, Australia, </institution> <year> 1994. </year> <note> To appear in a special issue of Computer Standards and Interfaces on Formal Methods and Standards, </note> <month> September </month> <year> 1995. </year>
Reference-contexts: A number of attempts to formalise the composition operators of specifications have been made. Abadi and Lamport [2] develop results for language-independent specification composition. Butler and Duke [11] and Griffiths [28] provide semantics for the operation composition operators of the formal specification language Object-Z <ref> [18, 19] </ref>.
Reference: [20] <author> S.H. Edwards. </author> <title> Inheritance: One mechanism, many conflicting uses. </title> <booktitle> In Proc. of the Sixth Annual Workshop on Software Reuse, </booktitle> <year> 1993. </year>
Reference-contexts: Wegner [64, 65] examines inheritance, defining inheritance of one component by another to effectivly be a mechanism for resource sharing (delegation). Edwards <ref> [20] </ref> discusses the problems inheritance causes when defining reusable components. The relevance of the use of inheritance to software libraries is important since it is a commonly used relationship between components.
Reference: [21] <author> D.A. Eichmann. </author> <title> A Hybrid Approach to Software Repository Retrieval: Blending Faceted Classification and Type Signatures. </title> <booktitle> In Proc. International Conference on Software Engineering and Knowledge Engineering (SEKE'91), </booktitle> <pages> pages 236-240, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: A external-static hybrid approach has been proposed in <ref> [21] </ref>. Dynamic Indices: Behavioural techniques seek to take advantage of the distinguishing property of software | executability.
Reference: [22] <author> B. Fischer, M. Kievernagel, and W. Struckmann. VCR: </author> <title> A VDM-based software component retrieval tool. </title> <type> Technical Report 94-08, </type> <institution> Institut fur Program-miersprachen und Informationssysteme, Technische Universitat Braunschweig, </institution> <address> Gaustasse 17, D-38092 Braunschweig, Germany, </address> <month> November </month> <year> 1994. </year>
Reference-contexts: as representations of (i.e. surrogates for) components: External Indices: Keyword, facet [56], frame [15], descriptor [46], lexical affinity [41] and feature-based [10] techniques all seek to find relevant components based upon controlled vocabularies, properties and ontologies external to the com ponent; 12 Static Indices: Type signature [69] and specification matching <ref> [32, 57, 22, 70] </ref> tech-niques seek to find relevant components based upon elements of the structure of software components. A external-static hybrid approach has been proposed in [21]. Dynamic Indices: Behavioural techniques seek to take advantage of the distinguishing property of software | executability.
Reference: [23] <author> G. Fischer, S. Henninger, and D. Redmiles. </author> <title> Intertwining Query Construction and Relevance Evaluation. </title> <booktitle> In Proc. CHI '91: Human Factors in Computing Systems, </booktitle> <pages> pages 55-61, </pages> <address> New York, 1991. </address> <publisher> ACM Press. </publisher> <pages> 17 </pages>
Reference: [24] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides. </author> <title> Design patterns: Ab--straction and reuse of object-oriented design. </title> <editor> In Oscar Nierstrasz, editor, </editor> <booktitle> Eu-ropean Conference on Object-Oriented Programming, </booktitle> <pages> pages 406-431, </pages> <address> Kaiser-lauten, Germany, July 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: This implies that ideas from all stages of development comprise knowledge that is reusable. In particular, the reuse of common patterns which appear during software design <ref> [13, 24] </ref> has been an area of intensive research. Design patterns capture architectural and environmental constraints on participating components and connections between the components. Such patterns can be used to replay software developments using a catalogue of standard patterns [34].
Reference: [25] <author> Simon Gibbs. </author> <title> Querying large class collections. Object management, </title> <institution> Centre Universitaire d'Informatique, University of Geneva, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: This section provides a short overview of the software library retrieval problem and the main approaches taken in the literature so far. Gibbs <ref> [25] </ref> discussed the problem of querying and retrieving from large collections of components.
Reference: [26] <author> Simon Gibbs, Dennis Tsichritzis, Eduardo Casais, Oscar Nierstrasz, and Xavier Pintado. </author> <title> Class management for software communities. </title> <journal> Communications of the ACM, </journal> <volume> 33(9) </volume> <pages> 90-103, </pages> <month> September </month> <year> 1990. </year>
Reference: [27] <author> T. Grechenig and S. Bi*. </author> <title> Introducing a software reuse culture in practice. </title> <booktitle> In SEI SE Education "Conference", </booktitle> <month> January </month> <year> 1994. </year>
Reference-contexts: The following dichotomies are identified: white vs. black box reuse, planned vs. ad-hoc reuse, vertical vs. horizontal reuse and compositional vs. generative reuse. The conclusion is that the current trends towards domain analysis [55], development of reuse process models to integrate reuse into standard lifecycles <ref> [27] </ref> may help solve the reuse problem. * Mili et. al.[50] provides a discussion on issues and research directions which touches upon costing and measuring reuse, reuse-oriented software engineering process models, developing reusable assets, and developing with reusable assets (dealing with retrieval, composition, and adaptation of components).
Reference: [28] <author> A. Griffiths. </author> <title> An Extended Semantic Foundation for Object-Z. </title> <type> Technical Report 95-39, </type> <institution> Software Verification Research Centre, Dept. of Computer Science , Univ. of Queensland, </institution> <year> 1995. </year>
Reference-contexts: In effect, composition of components can be regarded as composition of their specifications. A number of attempts to formalise the composition operators of specifications have been made. Abadi and Lamport [2] develop results for language-independent specification composition. Butler and Duke [11] and Griffiths <ref> [28] </ref> provide semantics for the operation composition operators of the formal specification language Object-Z [18, 19].
Reference: [29] <author> R. J. Hall. </author> <title> Generalized behavior-based retrieval. </title> <booktitle> In Proceedings of the 15th International Conference on Software Engineering, </booktitle> <pages> pages 371-380, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: The fundamental difficulty when considering this problem is how to decompose the requirements in such a way as to yield known component specifications. It is not 10 always the case that such a decomposition is possible. Hall <ref> [29] </ref> reverses the problem by attempting to search the space of all possible component compositions until one satisfying the requirements is found. <p> A external-static hybrid approach has been proposed in [21]. Dynamic Indices: Behavioural techniques seek to take advantage of the distinguishing property of software | executability. Behaviour-based techniques <ref> [5, 53, 29, 49] </ref> seek to find relevant components by comparing input and output spaces of components. 2.3.2 Insertion There is not much literature directly discussing procedures for insertion into software libraries. Weide and Hollingsworth [67] argue that insertion of a component should ensure its local certifiability.
Reference: [30] <author> R. Helm and Y.S. Maarek. </author> <title> Integrating information retrieval and domain specific approaches for browsing and retrieval in object-oriented class libraries. </title> <booktitle> In Proc. 7th ACM Conf. on Object-Oriented Programming: Systems, Languages and Applications (OOPSLA'91), </booktitle> <pages> pages 47-61, </pages> <year> 1991. </year>
Reference-contexts: Contributors in the field of software retrieval who have utilized some aspects of information retrieval theory are Helm and Maarek <ref> [30] </ref> who attempt to integrate semantically poor and rich retrieval methods, and Maarek et. al.[41] where document indexing techniques from information retrieval were used to organize software components into related clusters. 2.2 Data Requirements Software engineers will be aiming to retrieve from the object-oriented software library a system of cooperating components
Reference: [31] <author> Richard Helm, Ian M. Holland, and Dipayan Gangopadhyay. </author> <title> Contracts: Specifying behavioural compositions in object-oriented systems. </title> <booktitle> In Proceedings OOP-SLA/ECOOP '90, </booktitle> <pages> pages 169-180, </pages> <month> October </month> <year> 1990. </year> <journal> Published as ACM SIGPLAN Notices, </journal> <volume> volume 25, number 10. </volume>
Reference: [32] <author> J. Jeng and B. H. C. Cheng. </author> <title> Using analogy to determine program modifications based on specification changes. </title> <booktitle> In Proc. of IEEE 5th Int'l Conf. on Tools with Artificial Intelligence, </booktitle> <pages> pages 113-116, </pages> <address> Boston, MA, </address> <month> November </month> <year> 1993. </year>
Reference-contexts: as representations of (i.e. surrogates for) components: External Indices: Keyword, facet [56], frame [15], descriptor [46], lexical affinity [41] and feature-based [10] techniques all seek to find relevant components based upon controlled vocabularies, properties and ontologies external to the com ponent; 12 Static Indices: Type signature [69] and specification matching <ref> [32, 57, 22, 70] </ref> tech-niques seek to find relevant components based upon elements of the structure of software components. A external-static hybrid approach has been proposed in [21]. Dynamic Indices: Behavioural techniques seek to take advantage of the distinguishing property of software | executability.
Reference: [33] <author> R. E. Johnson. </author> <title> Documenting frameworks using patterns. </title> <booktitle> In Object-Oriented Programming Systems, Languages, and Applications Conference Proceedings, </booktitle> <pages> pages 63-76, </pages> <address> Vancouver, BC, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: Design patterns capture architectural and environmental constraints on participating components and connections between the components. Such patterns can be used to replay software developments using a catalogue of standard patterns [34]. Additionally, an application domain can be abstracted into a collection of patterns called a framework <ref> [33] </ref>. London and Milstead [39] present component specifications of two SmallTalk components (realistic sets and dictionaries) in the Z specification language [60] in order to evaluate some of the problems with using formal specification languages to specify components.
Reference: [34] <author> R.E. Johnson and V.F. Russo. </author> <title> Reusing object-oriented designs. </title> <type> Technical Report UIUCDCS 91-1696, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: Design patterns capture architectural and environmental constraints on participating components and connections between the components. Such patterns can be used to replay software developments using a catalogue of standard patterns <ref> [34] </ref>. Additionally, an application domain can be abstracted into a collection of patterns called a framework [33].
Reference: [35] <author> G. Kiczales. </author> <title> Towards a New Model of Abstraction in Software Engineering. </title> <booktitle> In Proceedings of the IMSA'92 Workshop on Reflection and Meta-level Architectures, </booktitle> <year> 1992. </year>
Reference-contexts: Weide and Hollingsworth [67] argue that properties of components should be locally certifiable to allow their reuse in larger systems. It is claimed that no language paradigm enforces this notion. It is also claimed that the principles of information hiding and encapsulation need re-investigation to allow open implementations <ref> [35] </ref>.
Reference: [36] <author> T. Korson and J.D. McGregor. </author> <title> Technical criteria for the specification and evaluation of object-oriented libraries. </title> <journal> Software Engineering Journal, </journal> <pages> pages 85-94, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: Such criteria are useful for comparison of libraries, and are also useful as a guide to the development of library requirements. Korson and McGregor <ref> [36] </ref> discuss the evaluation of object-oriented class libraries.
Reference: [37] <author> C. Lins. </author> <title> The Modula-2 Software Component Library. The Modula-2 Software Component Library Series, Vol. I. </title> <publisher> Springer-Verlag, </publisher> <address> New York, Berlin, Heidel-berg, </address> <year> 1988. </year>
Reference-contexts: Lins <ref> [37] </ref> defines a Modula-2 component library based upon data abstraction and notions of software components developed by Booch [9]. Uhl and Schmid [62] define a general catalogue of reusable abstract data types (focussing on container classes) using Ada as the component definition language.
Reference: [38] <author> B. Liskov and J.M. Wing. </author> <title> A new definition of the subtype relation. </title> <booktitle> In ECOOP '93, </booktitle> <pages> pages 118-141. </pages> <publisher> Springer Verlag, </publisher> <month> July </month> <year> 1993. </year>
Reference-contexts: In general, there may be many relationships between two software components, any of which may be used as the basis for retrieval from a software library. One component may be a subtype <ref> [38] </ref> of another, be behaviorally compatible [59] with another, or be substitutable [17] with another.
Reference: [39] <author> R. L. London and K. R. Milsted. </author> <title> Specifying reusable components using z: Realistic sets and dictionaries. </title> <journal> ACM SIGSOFT Software Eng. Notes, </journal> <volume> 14(3) </volume> <pages> 120-127, </pages> <month> May </month> <year> 1989. </year>
Reference-contexts: Such patterns can be used to replay software developments using a catalogue of standard patterns [34]. Additionally, an application domain can be abstracted into a collection of patterns called a framework [33]. London and Milstead <ref> [39] </ref> present component specifications of two SmallTalk components (realistic sets and dictionaries) in the Z specification language [60] in order to evaluate some of the problems with using formal specification languages to specify components.
Reference: [40] <author> V. B. Lortz and K. G. Shin. </author> <title> Combining contracts and exemplar-based programming for class hiding and construction. </title> <booktitle> Proc. 9th ACM Conf. on Object-Oriented Programming: Systems, Languages and Applications (OOPSLA'94), </booktitle> <pages> pages 453-467, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: Clearly delineating the level of abstraction of a specification is important for determining its use in a library. 11 Lortz and Shin <ref> [40] </ref> introduce an implementation of a dynamic object requestor using contracts. As part of their presentation they describe a process of using abstract metaclasses in a library with implementation variants as subclasses.
Reference: [41] <author> Y.S. Maarek, D.M. Berry, and G.E. Kaiser. </author> <title> An information retrieval approach for automatically constructing software libraries. </title> <journal> IEEE Trans. Software Eng., </journal> <volume> 17(8) </volume> <pages> 800-813, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: These retrieval methods can be placed into a spectrum, based upon the nature of the indices used as representations of (i.e. surrogates for) components: External Indices: Keyword, facet [56], frame [15], descriptor [46], lexical affinity <ref> [41] </ref> and feature-based [10] techniques all seek to find relevant components based upon controlled vocabularies, properties and ontologies external to the com ponent; 12 Static Indices: Type signature [69] and specification matching [32, 57, 22, 70] tech-niques seek to find relevant components based upon elements of the structure of software components.
Reference: [42] <author> J. McGregor and D. Sykes. </author> <title> Object Oriented Software Development: Engineering Software for Reuse. </title> <publisher> Van Nostrund Reinhold, </publisher> <year> 1992. </year>
Reference-contexts: The idea is that software development is abstracted into a set of parameterized rules; when the actual parameters are input, a generated system is output. * McGregor and Sykes <ref> [42] </ref> attempts to collect all the literature related to reuse from the late eighties. The later chapters emphasise the use of class libraries as a major step towards solving the problems of reuse. * Prieto-Diaz [54] provides a list of different aspects of software reuse. <p> In this section, requirements and principles for development of software libraries are outlined, drawing on software engineering literature and results from the field of information retrieval. 2.1.1 Library Abstractions McGregor and Sykes <ref> [42] </ref> discuss the problem of library abstraction mismatches. The problem exists where a number of separate libraries which each contain similar software artifacts are organized using different abstractions.
Reference: [43] <author> M. D. McIlroy. </author> <title> Mass produced software components. </title> <booktitle> Proceedings of the 1969 NATO Conference on Software Engineeering, </booktitle> <year> 1969. </year>
Reference-contexts: 1 Introduction The reuse of complete software developments and the processes used to create them has the potential to significantly ease the process of software engineering, by providing a source of verified software artifacts <ref> [43, 63] </ref>. Software libraries are collections of code fragments, operations, modules, systems, architectures, designs and specifications which have been aggregated to form a resource-rich environment, from which library users can reuse the efforts of others during subsequent software development. <p> As a research field, software reuse has been steadily growing since the mid-eighties. Wegner [63] repeated and extended the idea of the manufacture of software components expressed by McIlroy <ref> [43] </ref>. If software was to be treated as a capital investment, then techniques were required to ensure its quality and reusability, thus ensuring that the initial development cost was amortized over the many uses of the software. Regular attempts to summarize the status of software reuse research have been made.
Reference: [44] <author> B. Meyer. </author> <title> Reusability: The case for object-oriented design. </title> <journal> IEEE Software, </journal> <volume> 4(2) </volume> <pages> 50-64, </pages> <month> March </month> <year> 1987. </year>
Reference-contexts: However, progress towards an industrial-strength reuse methodology has been hindered by organizational and technical issues. It is suggested that solutions to the technical problems of software reuse are of greater concern than the managerial and organizational issues <ref> [44] </ref>. As a research field, software reuse has been steadily growing since the mid-eighties. Wegner [63] repeated and extended the idea of the manufacture of software components expressed by McIlroy [43]. <p> The abstract data types came to be regarded as object definitions, and Modula-3 incorporated the notion of object components [1]. Meyer <ref> [44, 45] </ref> argues the case for object-oriented software components by pointing out that taking a bottom-up compositional view of software construction, working with structured collections of abstract data types, and having language constructs such as multiple inheritance and deferred features all contribute to seamless development of reusable software systems.
Reference: [45] <author> B. Meyer. </author> <title> Object-Oriented Software Construction. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: The abstract data types came to be regarded as object definitions, and Modula-3 incorporated the notion of object components [1]. Meyer <ref> [44, 45] </ref> argues the case for object-oriented software components by pointing out that taking a bottom-up compositional view of software construction, working with structured collections of abstract data types, and having language constructs such as multiple inheritance and deferred features all contribute to seamless development of reusable software systems.
Reference: [46] <author> B. Meyer. </author> <title> Eiffel: The Language. </title> <publisher> Prentice Hall Object-Oriented Series. Prentice Hall (UK) Ltd, </publisher> <address> 66 Wood Lane End, Hertforshire HP24RG, </address> <year> 1992. </year> <month> 19 </month>
Reference-contexts: Lins [37] defines a Modula-2 component library based upon data abstraction and notions of software components developed by Booch [9]. Uhl and Schmid [62] define a general catalogue of reusable abstract data types (focussing on container classes) using Ada as the component definition language. Meyer developed the Eiffel language <ref> [46] </ref> and the Eiffel base libraries [47], attempting to form a natural taxonomy analogous to the classification of the animal kingdom. <p> The Eiffel programming language developed by Meyer <ref> [46] </ref> was designed to demonstrate and utilize the advantages that object-oriented software construction offered. The argument was that reuse can only truly be achieved with a solid technical emphasis on component description languages. <p> These retrieval methods can be placed into a spectrum, based upon the nature of the indices used as representations of (i.e. surrogates for) components: External Indices: Keyword, facet [56], frame [15], descriptor <ref> [46] </ref>, lexical affinity [41] and feature-based [10] techniques all seek to find relevant components based upon controlled vocabularies, properties and ontologies external to the com ponent; 12 Static Indices: Type signature [69] and specification matching [32, 57, 22, 70] tech-niques seek to find relevant components based upon elements of the structure
Reference: [47] <author> B. Meyer. </author> <title> Reusable Software The Base object-oriented component libraries. </title> <publisher> Prentice Hall, </publisher> <address> ISE, </address> <institution> Santa Barbara and SOL, Paris, </institution> <year> 1994. </year>
Reference-contexts: Uhl and Schmid [62] define a general catalogue of reusable abstract data types (focussing on container classes) using Ada as the component definition language. Meyer developed the Eiffel language [46] and the Eiffel base libraries <ref> [47] </ref>, attempting to form a natural taxonomy analogous to the classification of the animal kingdom. <p> Operations with similar be-haviours and effects are named similarly. Each of the libraries above make some attempt to have uniform interfaces; in particular the Eiffel libraries <ref> [47] </ref> have undergone extensive renamings with this goal in mind. * Functional completeness: a component is said to be functionally complete if all operations that could be useful for a user of a component are available in that component. <p> necessary operations; the Ada component library of [62] attempts to provide as many sensible operations as possible; the policy in the Eiffel libraries is to only include an extra operation in a component if certain criteria (e.g. non-duplication of existing functionality) are satisfied. 6 Of the libraries mentioned above, Meyer <ref> [47] </ref> provides the most complete attempt at rationalizing the design of software component libraries. <p> The work on principles of library design outlined in Section 2.1.3 may also serve as certification checks when insertion takes place. In particular, Meyer's library design principles <ref> [47] </ref> have all been applied as certification checks in the Eiffel Base libraries. 2.3.3 Adaptation and Evolution The adaptation operation modifies a component in order to either allow it to successfully cooperate with other components or to change its internal behaviour. Opdyke [51] introduces the concept of refactoring object-oriented systems.
Reference: [48] <author> B. Meyer. </author> <title> The Eiffel Library Standard (Vintage 95). </title> <type> Technical Report TR-EI-48/KL, </type> <institution> Interactive Software Engineering, Inc., </institution> <address> 225 Storke Rd, Suite 7, Goleta, CA 93117 USA, </address> <month> June </month> <year> 1995. </year> <note> Version 8. Available from ftp://ftp.eiffel.com/pub/nice/library. </note>
Reference-contexts: The standardization of facilities which libraries confer on application programs is used to allow application programs to be developed for multiple paltforms. However, such a standard for object oriented libraries must determine how substitutability of classes (i.e. components) is defined. The Eiffel Library Standard <ref> [48] </ref> defines rules which determine when a library is substitutable for another. These rules were formalized [4] in the Object-Z specification language. 3.2 Research Plan The goal of the thesis is to provide a reasoned formal specification of reusable software library systems.
Reference: [49] <author> A. Mili, R. Mili, and R. Mittermeir. </author> <title> Storing and retrieving software components: A refinement based system. </title> <booktitle> In Proceedings of the 16th International Conference on Software Engineering, </booktitle> <pages> pages 91-100. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> May </month> <year> 1994. </year>
Reference-contexts: A external-static hybrid approach has been proposed in [21]. Dynamic Indices: Behavioural techniques seek to take advantage of the distinguishing property of software | executability. Behaviour-based techniques <ref> [5, 53, 29, 49] </ref> seek to find relevant components by comparing input and output spaces of components. 2.3.2 Insertion There is not much literature directly discussing procedures for insertion into software libraries. Weide and Hollingsworth [67] argue that insertion of a component should ensure its local certifiability. <p> A formal model of the retrieval operation, based upon existing approaches in the literature has been developed in [3]. A proposal for using the dynamic behaviour of classes in an object oriented library [5] has been made. This retrieval methodology extended previous work <ref> [49, 53] </ref>, by incorporating in the class model the notion that a class may fail to respond to a 14 message, and by using a lattice-inducing partial order over class behaviours to de-termine a notion of approximate component matching. The methodology is formally presented using the Z specification language.
Reference: [50] <author> H. Mili, F. Mili, and A. Mili. </author> <title> Reusing Software: Issues and Research Directions. </title> <journal> IEEE Trans. Software Eng., </journal> <volume> 21(6) </volume> <pages> 528-561, </pages> <month> June </month> <year> 1995. </year>
Reference: [51] <author> W.F. Opdyke. </author> <title> Refactoring Object-Oriented Frameworks. </title> <type> PhD thesis, </type> <institution> Univerity of Illinois at Urbana-Champaign, Department of Computer Science, </institution> <year> 1992. </year>
Reference-contexts: In particular, Meyer's library design principles [47] have all been applied as certification checks in the Eiffel Base libraries. 2.3.3 Adaptation and Evolution The adaptation operation modifies a component in order to either allow it to successfully cooperate with other components or to change its internal behaviour. Opdyke <ref> [51] </ref> introduces the concept of refactoring object-oriented systems. To refac-tor a system means to change its internal structure without changing its externally visible behaviour. A simple refactoring is to move an object attribute from a subclass to a superclass.
Reference: [52] <author> Xavier Pintado. </author> <title> Selection and exploration in an object-oriented environment: The affinity browser. Object management, </title> <institution> Centre Universitaire d'Informatique, University of Geneva, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: Belkin and Croft [7] present process models for information retrieval and filtering, concluding that at an abstract level, filtering and retrieval are identifiable tasks. Filtering software components from software libraries using metrics has already been treated as a viable method for retrieval from software libraries <ref> [52] </ref>. Fischer et. al.[23] developed prototype tools called CodeFinder and Explainer. Using these tools they examined the requirements of software object libraries using information retrieval analysis techniques.
Reference: [53] <author> A. Podgurski and L. Pierce. </author> <title> Behaviour sampling: A technique for automated retrieval of reusable components. </title> <booktitle> In Proceedings of the 14th International Conference on Software Engineering, </booktitle> <pages> pages 349-360, </pages> <year> 1992. </year>
Reference-contexts: A external-static hybrid approach has been proposed in [21]. Dynamic Indices: Behavioural techniques seek to take advantage of the distinguishing property of software | executability. Behaviour-based techniques <ref> [5, 53, 29, 49] </ref> seek to find relevant components by comparing input and output spaces of components. 2.3.2 Insertion There is not much literature directly discussing procedures for insertion into software libraries. Weide and Hollingsworth [67] argue that insertion of a component should ensure its local certifiability. <p> A formal model of the retrieval operation, based upon existing approaches in the literature has been developed in [3]. A proposal for using the dynamic behaviour of classes in an object oriented library [5] has been made. This retrieval methodology extended previous work <ref> [49, 53] </ref>, by incorporating in the class model the notion that a class may fail to respond to a 14 message, and by using a lattice-inducing partial order over class behaviours to de-termine a notion of approximate component matching. The methodology is formally presented using the Z specification language.
Reference: [54] <author> R. Prieto-Diaz. </author> <title> Status report software reusability. </title> <journal> IEEE Software, </journal> <volume> 10(3) </volume> <pages> 61-66, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: The later chapters emphasise the use of class libraries as a major step towards solving the problems of reuse. * Prieto-Diaz <ref> [54] </ref> provides a list of different aspects of software reuse. The following dichotomies are identified: white vs. black box reuse, planned vs. ad-hoc reuse, vertical vs. horizontal reuse and compositional vs. generative reuse.
Reference: [55] <author> R. Prieto-Diaz and G. Arango, </author> <title> editors. Domain Analysis and Software Systems Modeling, </title> <publisher> Los Alamitos, </publisher> <address> CA, 1991. </address> <publisher> IEEE Computer Society. </publisher>
Reference-contexts: The following dichotomies are identified: white vs. black box reuse, planned vs. ad-hoc reuse, vertical vs. horizontal reuse and compositional vs. generative reuse. The conclusion is that the current trends towards domain analysis <ref> [55] </ref>, development of reuse process models to integrate reuse into standard lifecycles [27] may help solve the reuse problem. * Mili et. al.[50] provides a discussion on issues and research directions which touches upon costing and measuring reuse, reuse-oriented software engineering process models, developing reusable assets, and developing with reusable assets
Reference: [56] <author> R. Prieto-Diaz and P. Freeman. </author> <title> Classifying Software for Reusability. </title> <journal> IEEE Software, </journal> <volume> 4(1) </volume> <pages> 6-16, </pages> <year> 1987. </year>
Reference-contexts: These retrieval methods can be placed into a spectrum, based upon the nature of the indices used as representations of (i.e. surrogates for) components: External Indices: Keyword, facet <ref> [56] </ref>, frame [15], descriptor [46], lexical affinity [41] and feature-based [10] techniques all seek to find relevant components based upon controlled vocabularies, properties and ontologies external to the com ponent; 12 Static Indices: Type signature [69] and specification matching [32, 57, 22, 70] tech-niques seek to find relevant components based upon
Reference: [57] <author> E. J. Rollins and J. M. Wing. </author> <title> Specifications as search keys for software libraries: A case study using lambda prolog. </title> <type> Technical Report CMU-CS-90-159, </type> <institution> Carnegie Mellon University, School of Computer Science Carnegie Mellon University Pittsburgh, </institution> <address> PA 15213-3890, </address> <month> September </month> <year> 1990. </year> <month> 20 </month>
Reference-contexts: as representations of (i.e. surrogates for) components: External Indices: Keyword, facet [56], frame [15], descriptor [46], lexical affinity [41] and feature-based [10] techniques all seek to find relevant components based upon controlled vocabularies, properties and ontologies external to the com ponent; 12 Static Indices: Type signature [69] and specification matching <ref> [32, 57, 22, 70] </ref> tech-niques seek to find relevant components based upon elements of the structure of software components. A external-static hybrid approach has been proposed in [21]. Dynamic Indices: Behavioural techniques seek to take advantage of the distinguishing property of software | executability.
Reference: [58] <author> M. Sitaraman, L.R. Welch, and D.E. Harms. </author> <title> On Specification of Reusable Soft--ware Components. </title> <journal> Intl. J. of Software Engineering and Knowledge Engineering, </journal> <volume> 2(3) </volume> <pages> 207-209, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: The reusable software group at Ohio State University have developed a reuse-oriented language called RESOLVE [14] which has attempted to solve the technical issues of component reuse using a swapping (rather than copying) notion of assignment [66], a two-tiered notion of component specification <ref> [58] </ref> and a concept module construct replacing the object oriented class construct. Further investigation of the current evolution of component description languages is necessary for development of reusable software library components. 2.2.2 Component Relationships There exist two major relationships between components in a software library.
Reference: [59] <author> G. Smith. </author> <title> Formal Definitions of Behavioural Compatibility for Active and Passive Objects. </title> <booktitle> In Proc. 1st Asia-Pacific Software Engineering Conference (APSEC '94), </booktitle> <pages> pages 336-344, </pages> <address> Los Alamitos, CA, December 1994. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: In general, there may be many relationships between two software components, any of which may be used as the basis for retrieval from a software library. One component may be a subtype [38] of another, be behaviorally compatible <ref> [59] </ref> with another, or be substitutable [17] with another.
Reference: [60] <author> J.M. Spivey. </author> <title> The Z Notation: A Reference Manual. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, </publisher> <year> 1989. </year>
Reference-contexts: Additionally, an application domain can be abstracted into a collection of patterns called a framework [33]. London and Milstead [39] present component specifications of two SmallTalk components (realistic sets and dictionaries) in the Z specification language <ref> [60] </ref> in order to evaluate some of the problems with using formal specification languages to specify components. A problem they identified was that it was not clear whether one should specify in a library the abstract properties of the components or to specify their implementations.
Reference: [61] <author> S.R. Thatte. </author> <title> Synthesizing interface stubs for reusable classes. </title> <booktitle> In Proc. of the Sixth Annual Workshop on Software Reuse (WISR 6), </booktitle> <year> 1993. </year>
Reference-contexts: To refac-tor a system means to change its internal structure without changing its externally visible behaviour. A simple refactoring is to move an object attribute from a subclass to a superclass. Retrieved systems may have to be refactored to ensure efficiency or readability. Thatte <ref> [61] </ref> discusses the synthesis of interface stubs given two components with differing interfaces. Yellin and Strom [68] attach protocol specifications to the interface 13 of each object and use these protocols as the basis for software adaptors which bridge the differences between component interfaces.
Reference: [62] <author> J. Uhl and H.A. Schmid. </author> <title> A Systematic Catalogue of Reusable Abstract Data Types. </title> <journal> Lect. Notes in Comput. Sci., </journal> <volume> 460, </volume> <year> 1990. </year>
Reference-contexts: Lins [37] defines a Modula-2 component library based upon data abstraction and notions of software components developed by Booch [9]. Uhl and Schmid <ref> [62] </ref> define a general catalogue of reusable abstract data types (focussing on container classes) using Ada as the component definition language. Meyer developed the Eiffel language [46] and the Eiffel base libraries [47], attempting to form a natural taxonomy analogous to the classification of the animal kingdom. <p> The libraries above each take a different stance on this issue: the Modula-2 components are minimally populated with only the most necessary operations; the Ada component library of <ref> [62] </ref> attempts to provide as many sensible operations as possible; the policy in the Eiffel libraries is to only include an extra operation in a component if certain criteria (e.g. non-duplication of existing functionality) are satisfied. 6 Of the libraries mentioned above, Meyer [47] provides the most complete attempt at rationalizing
Reference: [63] <author> P. </author> <title> Wegner. </title> <journal> Capital-intensive software technology. IEEE Software, </journal> <volume> 1(3), </volume> <month> July </month> <year> 1984. </year>
Reference-contexts: 1 Introduction The reuse of complete software developments and the processes used to create them has the potential to significantly ease the process of software engineering, by providing a source of verified software artifacts <ref> [43, 63] </ref>. Software libraries are collections of code fragments, operations, modules, systems, architectures, designs and specifications which have been aggregated to form a resource-rich environment, from which library users can reuse the efforts of others during subsequent software development. <p> It is suggested that solutions to the technical problems of software reuse are of greater concern than the managerial and organizational issues [44]. As a research field, software reuse has been steadily growing since the mid-eighties. Wegner <ref> [63] </ref> repeated and extended the idea of the manufacture of software components expressed by McIlroy [43].
Reference: [64] <author> P. Wegner. </author> <title> Dimensions of object-based language design. </title> <booktitle> In Proc. 2nd ACM Conf. on Object-Oriented Programming: Systems, Languages and Applications (OOPSLA'87), </booktitle> <pages> pages 168-182, </pages> <year> 1987. </year>
Reference-contexts: The inheritance relationship has been the subject of much debate in the literature; the main issue is how inheritance should and should not be used to develop software of quality. Wegner <ref> [64, 65] </ref> examines inheritance, defining inheritance of one component by another to effectivly be a mechanism for resource sharing (delegation). Edwards [20] discusses the problems inheritance causes when defining reusable components.
Reference: [65] <author> P. Wegner and S. Zdonik. </author> <title> Inheritance as an incremental modification mechanism or what like is and isn't like. </title> <editor> In S. Gjessing and K. Nygaard, editors, </editor> <booktitle> Proc. European Conf. on Object-Oriented Programming (ECOOP'88), </booktitle> <pages> pages 55-77. </pages> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: The inheritance relationship has been the subject of much debate in the literature; the main issue is how inheritance should and should not be used to develop software of quality. Wegner <ref> [64, 65] </ref> examines inheritance, defining inheritance of one component by another to effectivly be a mechanism for resource sharing (delegation). Edwards [20] discusses the problems inheritance causes when defining reusable components.
Reference: [66] <author> B. W. Weide, S.H. Edwards, D. E. Harms, and D.A. Lamb. </author> <title> Design and specification of iterators using the swapping paradigm. </title> <journal> IEEE Trans. Software Eng., </journal> <volume> 20(8) </volume> <pages> 631-643, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: The reusable software group at Ohio State University have developed a reuse-oriented language called RESOLVE [14] which has attempted to solve the technical issues of component reuse using a swapping (rather than copying) notion of assignment <ref> [66] </ref>, a two-tiered notion of component specification [58] and a concept module construct replacing the object oriented class construct.
Reference: [67] <author> B.W. Weide and J.E. Hollingsworth. </author> <title> Scalability of reuse technology to large systems requires local certifiability. </title> <booktitle> In Proc. of the Fifth Annual Workshop on Software Reuse (WISR 5), </booktitle> <year> 1992. </year>
Reference-contexts: The argument was that reuse can only truly be achieved with a solid technical emphasis on component description languages. Other researchers have recognized that there are a number of difficulties with the object paradigm that need to be addressed. Weide and Hollingsworth <ref> [67] </ref> argue that properties of components should be locally certifiable to allow their reuse in larger systems. It is claimed that no language paradigm enforces this notion. It is also claimed that the principles of information hiding and encapsulation need re-investigation to allow open implementations [35]. <p> Behaviour-based techniques [5, 53, 29, 49] seek to find relevant components by comparing input and output spaces of components. 2.3.2 Insertion There is not much literature directly discussing procedures for insertion into software libraries. Weide and Hollingsworth <ref> [67] </ref> argue that insertion of a component should ensure its local certifiability.
Reference: [68] <author> D.M. Yellin and R.E. Strom. </author> <title> Interfaces, protocols, amd the semi-automatic construction of software adaptors. </title> <booktitle> In Proc. 9th ACM Conf. on Object-Oriented Programming: Systems, Languages and Applications (OOPSLA'94), </booktitle> <month> October </month> <year> 1994. </year>
Reference-contexts: A simple refactoring is to move an object attribute from a subclass to a superclass. Retrieved systems may have to be refactored to ensure efficiency or readability. Thatte [61] discusses the synthesis of interface stubs given two components with differing interfaces. Yellin and Strom <ref> [68] </ref> attach protocol specifications to the interface 13 of each object and use these protocols as the basis for software adaptors which bridge the differences between component interfaces. These interface issues are important to ensure cooperation of components when adapted from a proposed library solution.
Reference: [69] <author> A. M. Zaremski and J. M. Wing. </author> <title> Signature matching: A key to reuse. </title> <type> Techni--cal Report CMU-CS-93-151, </type> <institution> Carnegie Mellon University, School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh , PA 15213, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: of the indices used as representations of (i.e. surrogates for) components: External Indices: Keyword, facet [56], frame [15], descriptor [46], lexical affinity [41] and feature-based [10] techniques all seek to find relevant components based upon controlled vocabularies, properties and ontologies external to the com ponent; 12 Static Indices: Type signature <ref> [69] </ref> and specification matching [32, 57, 22, 70] tech-niques seek to find relevant components based upon elements of the structure of software components. A external-static hybrid approach has been proposed in [21]. Dynamic Indices: Behavioural techniques seek to take advantage of the distinguishing property of software | executability.
Reference: [70] <author> A. M. Zaremski and J. M. Wing. </author> <title> Specification Matching of Software Components. </title> <booktitle> In Proc. Third Symposium on the Foundations of Software Engineering (FSE3), </booktitle> <pages> pages 6-17. </pages> <booktitle> ACM SIGSOFT, </booktitle> <month> October </month> <year> 1995. </year> <month> 22 </month>
Reference-contexts: as representations of (i.e. surrogates for) components: External Indices: Keyword, facet [56], frame [15], descriptor [46], lexical affinity [41] and feature-based [10] techniques all seek to find relevant components based upon controlled vocabularies, properties and ontologies external to the com ponent; 12 Static Indices: Type signature [69] and specification matching <ref> [32, 57, 22, 70] </ref> tech-niques seek to find relevant components based upon elements of the structure of software components. A external-static hybrid approach has been proposed in [21]. Dynamic Indices: Behavioural techniques seek to take advantage of the distinguishing property of software | executability.
References-found: 70

