URL: http://www.cs.rice.edu/~willy/papers/ieeep97a.ps.gz
Refering-URL: http://www.cs.rice.edu/~willy/TreadMarks/papers.html
Root-URL: 
Title: Adaptive Protocols for Software Distributed Shared Memory  
Author: Cristiana Amza Alan L. Cox Sandhya Dwarkadas Li-Jie Jin Karthick Rajamani and Willy Zwaenepoel 
Affiliation: Department of Computer Science, Rice University Department of Computer Science, University of Rochester Department of Electrical and Computer Engineering, Rice University  
Abstract: We demonstrate the benefits of software shared memory protocols that adapt at run-time to the memory access patterns observed in the applications. This adaptation is automatic | no user annotations are required | and does not rely on compiler support or special hardware. We investigate adaptation between single- and multiple-writer protocols, dynamic aggregation of pages into a larger transfer unit, and adaptation between invalidate and update. Our results indicate that adaptation between single- and multiple-writer and dynamic page aggregation are clearly beneficial. The results for the adaptation between invalidate and update are less compelling, showing at best gains similar to the dynamic aggregation adaptation and at worst serious performance deterioration. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> C. Amza, A.L. Cox, S. Dwarkadas, P. Keleher, H. Lu, R. Raja-mony, W. Yu, and W. Zwaenepoel. TreadMarks: </author> <title> Shared memory computing on networks of workstations. </title> <journal> IEEE Computer, </journal> <volume> 29(2) </volume> <pages> 18-28, </pages> <month> February </month> <year> 1996. </year>
Reference-contexts: The multiple-writer protocol described in this paper is the one in use with the current version of Tread-Marks <ref> [1] </ref>. The single-writer protocol is a variation of the one presented by Keleher [14]. The adaptive single-writer/multiple-writer protocol extends our earlier work [2] on this topic.
Reference: [2] <author> C. Amza, A.L. Cox, S. Dwarkadas, and W. Zwaenepoel. </author> <title> Software DSM protocols that adapt between single writer and multiple writer. </title> <booktitle> In Proceedings of the Third International Symposium on High-Performance Computer Architecture, </booktitle> <pages> pages 261-271, </pages> <month> February </month> <year> 1997. </year>
Reference-contexts: It is therefore more efficient to put the page in single-writer mode. A page may switch back to multiple-writer mode at the onset of write-write false sharing, which is detected by the ownership refusal protocol, a modification to the single-writer protocol for locating and transferring ownership <ref> [2] </ref>. On a release (an unlock or a barrier arrival), a processor communicates both its owner write notices and its multiple-writer write notices. <p> In either case, p's ownership request is refused, and the page is put in multiple-writer mode. For a more detailed description and a correctness argument, we refer the reader to Amza et al. <ref> [2] </ref>. A.3 Adapting to Migratory Access Adaptation to migratory access only makes sense in the context of an adaptive protocol operating in single-writer mode (or a single-writer protocol) where its purpose is to eliminate the need for explicit ownership messages. <p> the following anecdote: for a larger 3D-FFT data set (256 fi 128 fi 128), the single-writer and adaptive protocols performed well, running completely in main memory, while the multiple-writer protocol paged because of the twins and diffs it stored, causing a 15-fold increase in execution time. (See Amza et al. <ref> [2] </ref> for a detailed account.) B. Dynamic Aggregation of Pages page aggregation, in addition to adapting between single-and multiple-writer and adapting to migratory access. As a baseline for comparison, we reiterate in Figure 2 the speedups from Figure 1 for the adaptive single-writer/multiple-writer protocol. <p> The multiple-writer protocol described in this paper is the one in use with the current version of Tread-Marks [1]. The single-writer protocol is a variation of the one presented by Keleher [14]. The adaptive single-writer/multiple-writer protocol extends our earlier work <ref> [2] </ref> on this topic. In this earlier work, we chose a protocol that started out in single-writer mode, because of its reduced memory use (no twins are ever made for pages that remain in single-writer mode).
Reference: [3] <author> C. Amza, A.L. Cox, K. Rajamani, and W. Zwaenepoel. </author> <title> Tradeoffs between false sharing and aggregation in software distributed shared memory. </title> <booktitle> In Proceedings of the 6th Symposium on the Principles and Practice of Parallel Programming, </booktitle> <pages> pages 90-99, </pages> <month> June </month> <year> 1997. </year>
Reference-contexts: We have demonstrated that communication aggregation is the key to improving performance in both invalidate and update protocols. Adding dynamic aggregation to the invalidate protocol provides the same benefits as using an update protocol, without the risk of sending extra messages. Amza et al. <ref> [3] </ref> investigated the benefits of dynamic page aggregation. They did not, however, combine aggregation with other forms of adaptation. Lu et al. [18] found that aggregation is the main reason that message-passing programs outperform (software) shared-memory programs.
Reference: [4] <author> D. Bailey, J. Barton, T. Lasinski, and H. Simon. </author> <title> The NAS parallel benchmarks. </title> <type> Technical Report TR RNR-91-002, </type> <institution> NASA Ames, </institution> <month> August </month> <year> 1991. </year>
Reference-contexts: The time to obtain a diff varies from 387 to 1,225 microseconds. V. Applications We use eight applications in this study. Water and Barnes-Hut come from the SPLASH benchmark suite [22]. Integer Sort (IS), 3D-FFT, Multigrid (MG) and Conjugate Gradient (CG) come from the NAS benchmark suite <ref> [4] </ref>. Gauss is a Gaussian elimination kernel distributed with TreadMarks. ILINK is part of the FASTLINK package [21] of genetic linkage analysis programs. Table I summarizes the relevant characteristics of the applications.
Reference: [5] <author> H.E. Bal, M.F. Kaashoek, </author> <title> and A.S. Tanenbaum. Orca: A language for parallel programming of distributed systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pages 190-205, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Adaptation between invalidate and update is, however, attractive in some cases if the invalidate mode of the base protocol does not support aggregation. VII. Related Work A large number of software shared memory systems have been built (e.g. <ref> [5] </ref>, [8], [14], [20], [25], [27]). Although the work described here is done in the context of a specific system, TreadMarks, many of the ideas are applicable to other 7 systems as well. First, the adaptation between single- and multiple-writer protocols carries over to all page-based systems. <p> Finally, the tradeoff between update and invalidate also applies to these other systems, although the nature of the tradeoff may change substantially if compiler support is used to determine the choice between update and invalidate <ref> [5] </ref>, [11]. The multiple-writer protocol described in this paper is the one in use with the current version of Tread-Marks [1]. The single-writer protocol is a variation of the one presented by Keleher [14]. The adaptive single-writer/multiple-writer protocol extends our earlier work [2] on this topic.
Reference: [6] <author> R.D. Blumofe and P.A. Lisiecki. </author> <title> Adaptive and reliable parallel computing on network of workstations. </title> <booktitle> In Proceedings of the USENIX 1997 Annual Technical Symposium, </booktitle> <month> January </month> <year> 1997. </year>
Reference-contexts: The adaptation to migratory behavior was first suggested by Cox and Fowler [9] and Stenstrom et al. [24] in the context of hardware shared memory machines. Another form of adaptivity that is important in networks of workstations is adapting to environmental characteristics such as processor and network load <ref> [6] </ref>, [7]. This form of adaptivity is orthogonal to the one discussed in this paper. VIII. Conclusions We have described software DSM protocols that automatically adapt, on a per-page basis, to the access patterns in the application. The protocols dynamically choose between single- and multiple-writer protocols.
Reference: [7] <author> N. Carriero, E. Freeman, D. Gelernter, and D. Kaminsky. </author> <title> Adaptive parallelism and piranha. </title> <journal> IEEE Computer, </journal> <volume> 28(1), </volume> <month> January </month> <year> 1995. </year>
Reference-contexts: The adaptation to migratory behavior was first suggested by Cox and Fowler [9] and Stenstrom et al. [24] in the context of hardware shared memory machines. Another form of adaptivity that is important in networks of workstations is adapting to environmental characteristics such as processor and network load [6], <ref> [7] </ref>. This form of adaptivity is orthogonal to the one discussed in this paper. VIII. Conclusions We have described software DSM protocols that automatically adapt, on a per-page basis, to the access patterns in the application. The protocols dynamically choose between single- and multiple-writer protocols.
Reference: [8] <author> J.B. Carter, J.K. Bennett, and W. Zwaenepoel. </author> <title> Techniques for reducing consistency-related information in distributed shared memory systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 13(3) </volume> <pages> 205-243, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: Performance, however, can be much improved by the use of RC or LRC, especially for software implementations of shared memory, because the messages propagating the shared memory modifications can be delayed and coalesced with the synchronization messages, leading to a substantial reduction in communication <ref> [8] </ref>, [16]. In addition to being data-race-free, all synchronization in the program must be done through the primitives supplied by the run-time system, so that it can take the required consistency actions at synchronization points. <p> Once ownership is obtained, the page's version number is incremented by one. In contrast, in a multiple-writer protocol, there may be several writable copies of a page on different processors <ref> [8] </ref>. Each processor with a writable copy records its own modifications to the page by a technique called twinning and diffing. Pages are initially write-protected so that the first write access to a page causes a protection violation. <p> Adaptation between invalidate and update is, however, attractive in some cases if the invalidate mode of the base protocol does not support aggregation. VII. Related Work A large number of software shared memory systems have been built (e.g. [5], <ref> [8] </ref>, [14], [20], [25], [27]). Although the work described here is done in the context of a specific system, TreadMarks, many of the ideas are applicable to other 7 systems as well. First, the adaptation between single- and multiple-writer protocols carries over to all page-based systems. <p> Our adaptive protocol automatically achieves a similar improvement. Several other systems both hardware and software have investigated configurability or adaptivity as a means of improving performance. Shasta [20] features configurable consistency units to address the requirements of applications with fine-grain sharing at the expense of higher memory overheads. Munin <ref> [8] </ref> uses multiple protocols to handle data with different access characteristics. The novelty in our work is that it chooses automatically between different protocols. In Munin, the choice of protocol was based on somewhat burdensome user annotations.
Reference: [9] <author> A. L. Cox and R.J. Fowler. </author> <title> Adaptive cache coherency for detecting migratory shared data. </title> <booktitle> In Proceedings of the 20th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 98-108, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: The scenario described is that of a migratory access pattern: a sequence of reads followed by a sequence of writes by one processor with no intervening accesses by other processors [26]. Detecting migratory access and eliminating the explicit ownership message is straightforward <ref> [9] </ref>, [24]. If a page is migratory, when a processor performs its first read from the page, it will fault because the page is invalid. Its request for the page will go to the processor that still owns the page. <p> They found that the adjustable cache-block-size implementation did better than the best fixed-size implementations for most of the programs in their suite. The adaptation to migratory behavior was first suggested by Cox and Fowler <ref> [9] </ref> and Stenstrom et al. [24] in the context of hardware shared memory machines. Another form of adaptivity that is important in networks of workstations is adapting to environmental characteristics such as processor and network load [6], [7].
Reference: [10] <author> C. Dubnicki and T. LeBlanc. </author> <title> Adjustable block size coherent caches. </title> <booktitle> In Proceedings of the 19th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 170-180, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: The home-based protocol allows a single-writer optimization that avoids diffing overhead when the home node is the only writer for the page. The downside is that whole pages are fetched on faults, even if the amount of data modified is small. Dubnicki and LeBlanc <ref> [10] </ref> proposed a scheme to reduce the impact on performance due to a mismatch between the cache block size and the sharing patterns exhibited by a given application. They adjusted the amount of data stored in a cache block according to recent reference patterns.
Reference: [11] <author> S. Dwarkadas, A.L. Cox, and W. Zwaenepoel. </author> <title> An integrated compile-time/run-time software distributed shared memory system. </title> <booktitle> In Proceedings of the 7th Symposium on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 186-197, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: Finally, the tradeoff between update and invalidate also applies to these other systems, although the nature of the tradeoff may change substantially if compiler support is used to determine the choice between update and invalidate [5], <ref> [11] </ref>. The multiple-writer protocol described in this paper is the one in use with the current version of Tread-Marks [1]. The single-writer protocol is a variation of the one presented by Keleher [14]. The adaptive single-writer/multiple-writer protocol extends our earlier work [2] on this topic.
Reference: [12] <author> S.J. Eggers and R.H. Katz. </author> <title> A characterization of sharing in parallel programs and its application to coherency protocol evaluation. </title> <booktitle> In Proceedings of the 15th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 373-383, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: In an update protocol, instead, the modifications to the page are sent with the synchronization message. Pages are never invalidated. The tradeoffs between invalidate and update protocols are well known <ref> [12] </ref>. Update protocols send substantially more data, including data that the processor may never access or that may be overwritten by newer data before the processor accesses the data originally sent.
Reference: [13] <author> K. Gharachorloo, D. Lenoski, J. Laudon, P. Gibbons, A. Gupta, and J. Hennessy. </author> <title> Memory consistency and event ordering in scalable shared-memory multiprocessors. </title> <booktitle> In Proceedings of the 17th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 15-26, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: Synchronization primitives include mutual exclusion locks and barriers. Shared memory is accessed through load and store instructions. The memory consistency model presented to the user is release consistency (RC), a relaxed memory model <ref> [13] </ref>. In RC, ordinary shared memory accesses are distinguished from synchronization accesses, with the latter category subdivided into acquire and release accesses. Lock synchronization maps onto acquires and releases in the obvious way: a lock operation corresponds to an acquire, and an unlock corresponds to a release.
Reference: [14] <author> P. Keleher. </author> <title> The relative importance of concurrent writers and weak consistency models. </title> <booktitle> In Proceedings of the 16th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 91-98, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: III. Protocols A. Single- vs. Multiple-Writer Protocols A.1 The Basic Protocols and Their Tradeoffs In a single-writer protocol, there is a single writable copy of a page at any given time <ref> [14] </ref>. The processor currently holding the writable copy of a page is called the owner of that page. Several read-only copies of the page may coexist with the writable owner copy. <p> Adaptation between invalidate and update is, however, attractive in some cases if the invalidate mode of the base protocol does not support aggregation. VII. Related Work A large number of software shared memory systems have been built (e.g. [5], [8], <ref> [14] </ref>, [20], [25], [27]). Although the work described here is done in the context of a specific system, TreadMarks, many of the ideas are applicable to other 7 systems as well. First, the adaptation between single- and multiple-writer protocols carries over to all page-based systems. <p> The multiple-writer protocol described in this paper is the one in use with the current version of Tread-Marks [1]. The single-writer protocol is a variation of the one presented by Keleher <ref> [14] </ref>. The adaptive single-writer/multiple-writer protocol extends our earlier work [2] on this topic. In this earlier work, we chose a protocol that started out in single-writer mode, because of its reduced memory use (no twins are ever made for pages that remain in single-writer mode).
Reference: [15] <author> P. Keleher, A. L. Cox, S. Dwarkadas, and W. Zwaenepoel. </author> <title> An evaluation of software-based release consistent protocols. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 29 </volume> <pages> 126-141, </pages> <month> October </month> <year> 1995. </year>
Reference-contexts: When p arrives at the next barrier, if it has modified a particular page, it sends updates for that page to the processors in the set it has computed during the interval before the barrier <ref> [15] </ref>. These processors return negative acknowledgements to these updates, if they receive a second update for a page and have not accessed the page since the first update. <p> In their system, pages are classified as migratory, producer/consumer or falsely shared. Single-writer mode is used for migratory and producer/consumer pages, while the falsely shared pages are maintained in multiple-writer mode. Updates are used only for migratory and producer/consumer pages. Keleher et al. <ref> [15] </ref> and Espeight et al. [23] have also investigated the benefits of allowing a software shared memory system the choice between invalidate and update.
Reference: [16] <author> P. Keleher, A. L. Cox, and W. Zwaenepoel. </author> <title> Lazy release consistency for software distributed shared memory. </title> <booktitle> In Proceedings of the 19th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 13-21, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: Roughly speaking, RC requires that, before a release by a processor p becomes visible to another processor q, all ordinary shared memory modifications by processor p become visible to processor q. The Lazy Release Consistency (LRC) algorithm <ref> [16] </ref>, one of the possible RC implementations, delays the propagation of shared memory modifications by processor p to processor q until q executes an acquire corresponding to a release by p. <p> Performance, however, can be much improved by the use of RC or LRC, especially for software implementations of shared memory, because the messages propagating the shared memory modifications can be delayed and coalesced with the synchronization messages, leading to a substantial reduction in communication [8], <ref> [16] </ref>. In addition to being data-race-free, all synchronization in the program must be done through the primitives supplied by the run-time system, so that it can take the required consistency actions at synchronization points.
Reference: [17] <author> L. Lamport. </author> <title> How to make a multiprocessor computer that correctly executes multiprocess programs. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-28(9):690-691, </volume> <month> September </month> <year> 1979. </year>
Reference-contexts: Programs without data races, i.e., programs with sufficient synchronization such that any pair of conflicting memory accesses is separated by a release-acquire pair, produce the same results on an RC or an LRC memory system as on a conventional sequentially-consistent memory system <ref> [17] </ref>. Performance, however, can be much improved by the use of RC or LRC, especially for software implementations of shared memory, because the messages propagating the shared memory modifications can be delayed and coalesced with the synchronization messages, leading to a substantial reduction in communication [8], [16].
Reference: [18] <author> H. Lu, S. Dwarkadas, A. L. Cox, and W. Zwaenepoel. </author> <title> Quantifying the performance differences between PVM and TreadMarks. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 43(2) </volume> <pages> 56-78, </pages> <month> June </month> <year> 1997. </year>
Reference-contexts: More importantly, it avoids a pitfall of the multiple-writer protocol, called diff accumulation <ref> [18] </ref>, a scenario in which a number of partially or completely overlapping diffs are transmitted, significantly increasing the amount of communication. <p> Adding dynamic aggregation to the invalidate protocol provides the same benefits as using an update protocol, without the risk of sending extra messages. Amza et al. [3] investigated the benefits of dynamic page aggregation. They did not, however, combine aggregation with other forms of adaptation. Lu et al. <ref> [18] </ref> found that aggregation is the main reason that message-passing programs outperform (software) shared-memory programs. Overall, they found that for six out of their eight applications the speedup on TreadMarks was within 85% of that achieved by PVM. <p> Our adaptive single-writer/multiple-writer protocol addresses the most extreme cases of a less common problem, diff accumulation, found by Lu et al. <ref> [18] </ref>. Diff accumulation in IS contributed to the worst performance with respect to PVM. TreadMarks' speedup was only 42% of PVM's. With diff accumulation manually removed, the speedup improved to within 71% of the speedup on PVM. Our adaptive protocol automatically achieves a similar improvement.
Reference: [19] <author> L.R. Monnerat and R. Bianchini. </author> <title> Efficiently adapting to sharing patterns in software DSMs. </title> <booktitle> In Proceedings of the Fourth International Symposium on High-Performance Computer Architecture, </booktitle> <month> February </month> <year> 1998. </year>
Reference-contexts: These processors return negative acknowledgements to these updates, if they receive a second update for a page and have not accessed the page since the first update. For data protected by a lock, we use the method proposed by, among others, Mon-nerat and Bianchini <ref> [19] </ref>, and Speight and Bennett [23]. We 5 Application Data size Sync. <p> Starting in multiple-writer mode allows for a straightforward adaptation according to the size of the diffs. The adaptive DSM system described by Monnerat and Bianchini <ref> [19] </ref> is most closely related to our work. They also investigate the adaptation between single- and multiple-writer protocols, and adaptation between invalidate and update. In their system, pages are classified as migratory, producer/consumer or falsely shared.
Reference: [20] <author> D.J. Scales, K. Gharachorloo, and C.A. Thekkath. </author> <title> Shasta: A low overhead software-only approach for supporting fine-grain shared memory. </title> <booktitle> In Proceedings of the 7th Symposium on Architectural Support for Programming Languages and Operating Systems, </booktitle> <month> October </month> <year> 1996. </year>
Reference-contexts: Adaptation between invalidate and update is, however, attractive in some cases if the invalidate mode of the base protocol does not support aggregation. VII. Related Work A large number of software shared memory systems have been built (e.g. [5], [8], [14], <ref> [20] </ref>, [25], [27]). Although the work described here is done in the context of a specific system, TreadMarks, many of the ideas are applicable to other 7 systems as well. First, the adaptation between single- and multiple-writer protocols carries over to all page-based systems. <p> With diff accumulation manually removed, the speedup improved to within 71% of the speedup on PVM. Our adaptive protocol automatically achieves a similar improvement. Several other systems both hardware and software have investigated configurability or adaptivity as a means of improving performance. Shasta <ref> [20] </ref> features configurable consistency units to address the requirements of applications with fine-grain sharing at the expense of higher memory overheads. Munin [8] uses multiple protocols to handle data with different access characteristics. The novelty in our work is that it chooses automatically between different protocols.
Reference: [21] <author> A.A. Schaffer. </author> <title> Faster linkage analysis computations for pedigrees with loops or unused alleles. </title> <booktitle> Human Heredity, </booktitle> <volume> 46(4) </volume> <pages> 226-235, </pages> <month> jul </month> <year> 1996. </year>
Reference-contexts: Water and Barnes-Hut come from the SPLASH benchmark suite [22]. Integer Sort (IS), 3D-FFT, Multigrid (MG) and Conjugate Gradient (CG) come from the NAS benchmark suite [4]. Gauss is a Gaussian elimination kernel distributed with TreadMarks. ILINK is part of the FASTLINK package <ref> [21] </ref> of genetic linkage analysis programs. Table I summarizes the relevant characteristics of the applications. It includes for each application, the data set size used, the method of synchronization (locks, barriers, or both), and the sequential running times.
Reference: [22] <author> J.P. Singh, W.-D. Weber, and A. Gupta. </author> <title> SPLASH: Stanford parallel applications for shared-memory. </title> <type> Technical Report CSL-TR-91-469, </type> <institution> Stanford University, </institution> <month> April </month> <year> 1991. </year>
Reference-contexts: The time for an eight processor barrier is 481 microseconds. The time to obtain a diff varies from 387 to 1,225 microseconds. V. Applications We use eight applications in this study. Water and Barnes-Hut come from the SPLASH benchmark suite <ref> [22] </ref>. Integer Sort (IS), 3D-FFT, Multigrid (MG) and Conjugate Gradient (CG) come from the NAS benchmark suite [4]. Gauss is a Gaussian elimination kernel distributed with TreadMarks. ILINK is part of the FASTLINK package [21] of genetic linkage analysis programs. Table I summarizes the relevant characteristics of the applications.
Reference: [23] <author> W.E. Speight and J.K. Bennett. </author> <title> Using multicast and multi-threading to reduce communication in software DSM systems. </title> <booktitle> In Proceedings of the Fourth International Symposium on High-Performance Computer Architecture, </booktitle> <month> February </month> <year> 1998. </year>
Reference-contexts: These processors return negative acknowledgements to these updates, if they receive a second update for a page and have not accessed the page since the first update. For data protected by a lock, we use the method proposed by, among others, Mon-nerat and Bianchini [19], and Speight and Bennett <ref> [23] </ref>. We 5 Application Data size Sync. <p> In their system, pages are classified as migratory, producer/consumer or falsely shared. Single-writer mode is used for migratory and producer/consumer pages, while the falsely shared pages are maintained in multiple-writer mode. Updates are used only for migratory and producer/consumer pages. Keleher et al. [15] and Espeight et al. <ref> [23] </ref> have also investigated the benefits of allowing a software shared memory system the choice between invalidate and update. However, to the best of our knowledge, all of these studies were conducted in the absence of aggregation for the invalidate protocol, inflating the perceived benefits of update.
Reference: [24] <author> P. Stenstrom, M. Brorsson, and L. Sandberg. </author> <title> An adaptive cache coherence protocol optimized for migratory sharing. </title> <booktitle> In Proceedings of the 20th Annual International Symposium on Computer Architecture, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: The scenario described is that of a migratory access pattern: a sequence of reads followed by a sequence of writes by one processor with no intervening accesses by other processors [26]. Detecting migratory access and eliminating the explicit ownership message is straightforward [9], <ref> [24] </ref>. If a page is migratory, when a processor performs its first read from the page, it will fault because the page is invalid. Its request for the page will go to the processor that still owns the page. <p> They found that the adjustable cache-block-size implementation did better than the best fixed-size implementations for most of the programs in their suite. The adaptation to migratory behavior was first suggested by Cox and Fowler [9] and Stenstrom et al. <ref> [24] </ref> in the context of hardware shared memory machines. Another form of adaptivity that is important in networks of workstations is adapting to environmental characteristics such as processor and network load [6], [7]. This form of adaptivity is orthogonal to the one discussed in this paper. VIII.
Reference: [25] <author> R. Stets, S. Dwarkadas, N. Hardavellas, G. Hunt, L. Kon-tothanassis, S. Parthasarathy, and M. Scott. Cashmere-2L: </author> <title> Software coherent shared memory on a clustered remote write network. </title> <booktitle> In Proceedings of the 16th ACM Symposium on Operating Systems Principles, </booktitle> <month> October </month> <year> 1997. </year>
Reference-contexts: Adaptation between invalidate and update is, however, attractive in some cases if the invalidate mode of the base protocol does not support aggregation. VII. Related Work A large number of software shared memory systems have been built (e.g. [5], [8], [14], [20], <ref> [25] </ref>, [27]). Although the work described here is done in the context of a specific system, TreadMarks, many of the ideas are applicable to other 7 systems as well. First, the adaptation between single- and multiple-writer protocols carries over to all page-based systems. <p> Munin [8] uses multiple protocols to handle data with different access characteristics. The novelty in our work is that it chooses automatically between different protocols. In Munin, the choice of protocol was based on somewhat burdensome user annotations. Cashmere <ref> [25] </ref> improves on the home-based protocol introduced by Zhou et al. [27], allowing dynamic migration of the home node. The home-based protocol allows a single-writer optimization that avoids diffing overhead when the home node is the only writer for the page.
Reference: [26] <author> W.-D. Weber and A. Gupta. </author> <title> Analysis of cache invalidation patterns in multiprocessors. </title> <booktitle> In Proceedings of the 3rd Symposium on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 243-256, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: With the adaptive protocol, an ownership request is sent. The scenario described is that of a migratory access pattern: a sequence of reads followed by a sequence of writes by one processor with no intervening accesses by other processors <ref> [26] </ref>. Detecting migratory access and eliminating the explicit ownership message is straightforward [9], [24]. If a page is migratory, when a processor performs its first read from the page, it will fault because the page is invalid.
Reference: [27] <author> Y. Zhou, L. Iftode, and K. Li. </author> <title> Performance evaluation of two home-based lazy release consistency protocols for shared virtual memory systems. </title> <booktitle> In Proceedings of the Second USENIX Symposium on Operating System Design and Implementation, </booktitle> <pages> pages 75-88, </pages> <month> nov </month> <year> 1996. </year>
Reference-contexts: Adaptation between invalidate and update is, however, attractive in some cases if the invalidate mode of the base protocol does not support aggregation. VII. Related Work A large number of software shared memory systems have been built (e.g. [5], [8], [14], [20], [25], <ref> [27] </ref>). Although the work described here is done in the context of a specific system, TreadMarks, many of the ideas are applicable to other 7 systems as well. First, the adaptation between single- and multiple-writer protocols carries over to all page-based systems. <p> The novelty in our work is that it chooses automatically between different protocols. In Munin, the choice of protocol was based on somewhat burdensome user annotations. Cashmere [25] improves on the home-based protocol introduced by Zhou et al. <ref> [27] </ref>, allowing dynamic migration of the home node. The home-based protocol allows a single-writer optimization that avoids diffing overhead when the home node is the only writer for the page. The downside is that whole pages are fetched on faults, even if the amount of data modified is small.
References-found: 27

