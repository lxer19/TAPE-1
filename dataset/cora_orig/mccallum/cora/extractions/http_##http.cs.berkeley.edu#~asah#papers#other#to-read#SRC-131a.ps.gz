URL: http://http.cs.berkeley.edu/~asah/papers/other/to-read/SRC-131a.ps.gz
Refering-URL: http://http.cs.berkeley.edu/~asah/papers/other/to-read/
Root-URL: http://www.cs.berkeley.edu
Title: The Juno-2 Constraint-Based Drawing Editor  
Author: Allan Heydon and Greg Nelson 
Address: 130 Lytton Avenue Palo Alto, California 94301  
Affiliation: Systems Research Center  
Date: December, 1994  
Pubnum: SRC Research Report 131a  
Abstract-found: 0
Intro-found: 1
Reference: [1] <institution> Adobe Systems Inc. </institution> <note> PostScript Language Reference Manual. Addi-son-Wesley, </note> <year> 1985. </year>
Reference-contexts: The Juno-2 programming language is a full-fledged imperative programming language with conditionals, loops, assignments, global variables, local variables, procedures, and closures. For example, Figure 10 was produced with a recursive procedure. The drawing operations are those is an example of a figure drawn by a recursive procedure. of PostScript <ref> [1] </ref>, and the control structures are those of guarded commands [5, 15]. Larger Juno-2 programs are organized into modules, which are collections of definitions. The language is dynamically typed.
Reference: [2] <author> Alan Borning. </author> <title> The programming language aspects of ThingLab, a constraint-oriented simulation laboratory. </title> <journal> ACM Transactions on Programming Languages and Systems v. </journal> <volume> 3, no. 4, </volume> <pages> pp. 353-387, </pages> <year> 1981. </year>
Reference-contexts: We hope Juno-2's programmability will help with this problem, by allowing a collection of useful constraints and drawing operations to be defined once by an experienced Juno-2 user and then used many times by novices. Many other systems have similar goals. ThingLab <ref> [2] </ref> and Garnet [12] provide extensible constraint solvers. In these systems, users define constraints imperatively by providing functions to solve individual constraints, and the solver attempts to invoke them in an order that solves them all.
Reference: [3] <author> Gideon Avrahami, Kenneth P. Brooks, and Marc H. Brown. </author> <title> A two-view approach to constructing user interfaces. </title> <booktitle> ACM SIGGRAPH '89 Conference Proceedings, </booktitle> <pages> pp. 137-146, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: The results in this section describe Juno-2 running on a DEC 3000/600 Alpha workstation equipped with a 175 megahertz DECchip 21064 processor running OSF/1. The entire system is written in Modula-3 [16]. Juno-2's user interface is based on the FormsVBT <ref> [3] </ref> and Trestle [11] object-oriented user interface toolkits, which use the X window system [17] for doing graphics. A standard Trestle module provides software double-buffering. Trestle reduces curved paths to polygonal paths; X strokes and fills the polygonal paths. The reported times include Modula-3 runtime checks and garbage collection.
Reference: [4] <author> S. D. Conte and Carl de Boor. </author> <title> Elementary Numerical Analysis. </title> <publisher> McGraw-Hill, </publisher> <year> 1972. </year>
Reference-contexts: This method consists simply in repeating the following step: replace the constraints by the linear constraints that approximate them around the current point, then solve the linear constraints by Gaussian elimination to produce the next point. For an accessible description, see Conte and de Boor's text <ref> [4] </ref>. It was not obvious at the start of the project whether Newton's method would do the trick. Our first version of the solver failed so often that it was unwise to demonstrate it, much less use it.
Reference: [5] <author> Edsger W. Dijkstra. </author> <title> A Discipline of Programming. </title> <publisher> Prentice-Hall, </publisher> <year> 1976. </year>
Reference-contexts: For example, Figure 10 was produced with a recursive procedure. The drawing operations are those is an example of a figure drawn by a recursive procedure. of PostScript [1], and the control structures are those of guarded commands <ref> [5, 15] </ref>. Larger Juno-2 programs are organized into modules, which are collections of definitions. The language is dynamically typed. Its value space is the smallest set that (1) contains the real numbers, text strings, and the special value NIL, and (2) is closed under the formation of ordered pairs.
Reference: [6] <author> Gerald Farin. </author> <title> Curves and Surfaces for Computer Aided Geometric Design: A Practical Guide, second edition. </title> <publisher> Academic Press, </publisher> <year> 1990. </year>
Reference-contexts: Adjusting to taste pro duced the smooth version on the right. END It is well known that for t = 1=2, p is the midpoint of the B ezier cubic. More generally, p varies over the whole curve as t varies over the real line. Farin's text <ref> [6] </ref> describes B ezier curves and other models for curves and surfaces. Juno-2's constraint solver is powerful enough to use this definition effectively, and it is one of Juno-2's predefined predicates (as are Hor and Sqrt).
Reference: [7] <author> Michael Gleicher and Andrew Witkin. </author> <title> Drawing with constraints. </title> <booktitle> The Visual Computer, to appear v. </booktitle> <volume> 11, no. 1, </volume> <year> 1994. </year>
Reference-contexts: Unfortunately, this precludes important geometric predicates like parallelism and congruence. Chris Van Wyk's IDEAL [20] solves a larger class of constraints, but not general non-linear constraints. These systems are programmable, but not WYSIWYG (what you see is what you get). Constraint-based drawing programs like Michael Gleicher's Briar <ref> [7] </ref>, Steve Sistare's Converge [18], and Aldus's commercial program Intel-liDraw provide numerical non-linear constraint solving, but only over a fixed set of constraints. These systems are WYSIWYG, but provide no programming view. the basic step of the cha-cha. The figure was drawn by overlaying several frames of the animation.
Reference: [8] <author> John D. Hobby. </author> <note> A User's manual for MetaPost. Available via anonymous FTP as the file 162.ps.Z from netlib.att.com in the directory netlib/research/cstr. 18 </note>
Reference-contexts: However, many useful constraint systems contain cycles and therefore cannot be solved by this method. In contrast, Juno-2 allows the user to define constraints declaratively. This can (and usually does) produce cyclic constraint systems; Juno-2 solves them with numerical methods. Donald Knuth's METAFONT [9] and John Hobby's MetaPost <ref> [8] </ref> also provide numerical solvers, but these systems are limited to constraints that are algebraically linear. Unfortunately, this precludes important geometric predicates like parallelism and congruence. Chris Van Wyk's IDEAL [20] solves a larger class of constraints, but not general non-linear constraints.
Reference: [9] <author> Donald E. Knuth. </author> <title> TeX and METAFONT, New Directions in Typeset--ting. </title> <publisher> Digital Press and the American Mathematical Society, </publisher> <address> Bedford, Massachusetts, </address> <year> 1979. </year>
Reference-contexts: However, many useful constraint systems contain cycles and therefore cannot be solved by this method. In contrast, Juno-2 allows the user to define constraints declaratively. This can (and usually does) produce cyclic constraint systems; Juno-2 solves them with numerical methods. Donald Knuth's METAFONT <ref> [9] </ref> and John Hobby's MetaPost [8] also provide numerical solvers, but these systems are limited to constraints that are algebraically linear. Unfortunately, this precludes important geometric predicates like parallelism and congruence. Chris Van Wyk's IDEAL [20] solves a larger class of constraints, but not general non-linear constraints.
Reference: [10] <author> John McCarthy. </author> <title> Recursive functions of symbolic expressions and their computation by machine. </title> <journal> Communications of the ACM, v. </journal> <volume> 3, no. 4, </volume> <pages> pp. 184-95, </pages> <year> 1960. </year>
Reference-contexts: The language is dynamically typed. Its value space is the smallest set that (1) contains the real numbers, text strings, and the special value NIL, and (2) is closed under the formation of ordered pairs. The inclusion of 7 ordered pairs is significant. As in pure Lisp <ref> [10] </ref>, they have the virtue of providing structure to the value space sufficient to construct a variety of data structures, including two and three dimensional points, lists, records, and trees.
Reference: [11] <author> Mark S. Manasse and Greg Nelson. </author> <title> Trestle Reference Manual. </title> <type> Research Report 68, </type> <institution> Digital Systems Reserach Center, </institution> <year> 1991. </year>
Reference-contexts: The results in this section describe Juno-2 running on a DEC 3000/600 Alpha workstation equipped with a 175 megahertz DECchip 21064 processor running OSF/1. The entire system is written in Modula-3 [16]. Juno-2's user interface is based on the FormsVBT [3] and Trestle <ref> [11] </ref> object-oriented user interface toolkits, which use the X window system [17] for doing graphics. A standard Trestle module provides software double-buffering. Trestle reduces curved paths to polygonal paths; X strokes and fills the polygonal paths. The reported times include Modula-3 runtime checks and garbage collection.
Reference: [12] <author> Brad A. Myers, Dario Giuse, Roger B. Dannenberg, Brad Vander Zanden, David Kosbie, Philippe Marchal, Ed Pervin, Andrew Mick-ish, and John A. Kolojejchick. </author> <title> The Garnet toolkit reference manuals: support for highly-interactive, graphical user interfaces in Lisp. </title> <type> Technical Report CMU-CS-90-117, </type> <institution> Carnegie Mellon University, </institution> <month> March, </month> <year> 1990. </year>
Reference-contexts: We hope Juno-2's programmability will help with this problem, by allowing a collection of useful constraints and drawing operations to be defined once by an experienced Juno-2 user and then used many times by novices. Many other systems have similar goals. ThingLab [2] and Garnet <ref> [12] </ref> provide extensible constraint solvers. In these systems, users define constraints imperatively by providing functions to solve individual constraints, and the solver attempts to invoke them in an order that solves them all. However, many useful constraint systems contain cycles and therefore cannot be solved by this method.
Reference: [13] <author> Greg Nelson. </author> <title> Techniques for program verification. </title> <institution> Research report CSL-81-10, Computer Science Laboratory, </institution> <note> Xerox Parc, 1981. Section 5. </note>
Reference-contexts: Our technique for separating out the pair constraints is based on a technique used in mechanical theorem proving <ref> [13] </ref>. Unification closure. We use unification closure to solve the pair constraints. Computing the unification closure is a basic step in resolution theorem-proving and in the type-inference algorithm used by the programming language ML. The input constraint is first converted into a representation called an equivalence graph, or E-graph.
Reference: [14] <author> Greg Nelson. Juno, </author> <title> a constraint-based graphics system. </title> <booktitle> ACM SIG-GRAPH 85 Conference Proceedings. </booktitle> <month> July, </month> <year> 1985. </year>
Reference-contexts: These systems are WYSIWYG, but provide no programming view. the basic step of the cha-cha. The figure was drawn by overlaying several frames of the animation. At each weight change, the count is displayed on the weighted foot. Juno-1 <ref> [14] </ref>, the predecessor of Juno-2, uses double-view editing to combine the WYSIWYG and programming paradigms. Juno-1 also provides numerical non-linear constraint solving, but again for a fixed set of constraints. Although you can define new procedures with Juno-1, you cannot define new constraints.
Reference: [15] <author> Greg Nelson. </author> <title> A generalization of Dijkstra's calculus. </title> <journal> ACM TOPLAS v. </journal> <volume> 11, </volume> <pages> pp. 517-61, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: For example, Figure 10 was produced with a recursive procedure. The drawing operations are those is an example of a figure drawn by a recursive procedure. of PostScript [1], and the control structures are those of guarded commands <ref> [5, 15] </ref>. Larger Juno-2 programs are organized into modules, which are collections of definitions. The language is dynamically typed. Its value space is the smallest set that (1) contains the real numbers, text strings, and the special value NIL, and (2) is closed under the formation of ordered pairs.
Reference: [16] <author> Greg Nelson, </author> <title> editor. Systems programming with Modula-3. </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: The results in this section describe Juno-2 running on a DEC 3000/600 Alpha workstation equipped with a 175 megahertz DECchip 21064 processor running OSF/1. The entire system is written in Modula-3 <ref> [16] </ref>. Juno-2's user interface is based on the FormsVBT [3] and Trestle [11] object-oriented user interface toolkits, which use the X window system [17] for doing graphics. A standard Trestle module provides software double-buffering. Trestle reduces curved paths to polygonal paths; X strokes and fills the polygonal paths.
Reference: [17] <author> Robert W. Scheifler, James Gettys, and Ron Newman. </author> <title> X Window System 2nd ed. </title> <publisher> Digital Press, </publisher> <year> 1990. </year>
Reference-contexts: The entire system is written in Modula-3 [16]. Juno-2's user interface is based on the FormsVBT [3] and Trestle [11] object-oriented user interface toolkits, which use the X window system <ref> [17] </ref> for doing graphics. A standard Trestle module provides software double-buffering. Trestle reduces curved paths to polygonal paths; X strokes and fills the polygonal paths. The reported times include Modula-3 runtime checks and garbage collection.
Reference: [18] <author> Steve Sistare, </author> <title> Graphical interaction techniques in constraint-based geometric modeling, </title> <booktitle> Graphics Interface '91. </booktitle> <year> 1991. </year>
Reference-contexts: Chris Van Wyk's IDEAL [20] solves a larger class of constraints, but not general non-linear constraints. These systems are programmable, but not WYSIWYG (what you see is what you get). Constraint-based drawing programs like Michael Gleicher's Briar [7], Steve Sistare's Converge <ref> [18] </ref>, and Aldus's commercial program Intel-liDraw provide numerical non-linear constraint solving, but only over a fixed set of constraints. These systems are WYSIWYG, but provide no programming view. the basic step of the cha-cha. The figure was drawn by overlaying several frames of the animation.
Reference: [19] <author> Ivan Sutherland. </author> <title> Sketchpad, a man-machine graphical communication system. </title> <booktitle> Proceedings of the Spring Joint Computer Conference, </booktitle> <pages> pp. 507-524, </pages> <address> Detroit, MI, </address> <month> May 21-23, </month> <year> 1963. </year>
Reference-contexts: This figure uses the module to show the table of contents of this report. Interactive constraint-based graphics goes back to Ivan Sutherland's pioneering program Sketchpad <ref> [19] </ref>. But there are many difficulties with constraints, and thirty years after Sketchpad, the sad fact is that constraints have so far been more promising than useful.
Reference: [20] <author> Christopher J. Van Wyk. </author> <title> A high-level language for specifying pictures. </title> <journal> ACM Transactions on Graphics, v. </journal> <volume> 1, no. 2, </volume> <month> April </month> <year> 1982. </year> <pages> Pages 163-182. </pages>
Reference-contexts: Donald Knuth's METAFONT [9] and John Hobby's MetaPost [8] also provide numerical solvers, but these systems are limited to constraints that are algebraically linear. Unfortunately, this precludes important geometric predicates like parallelism and congruence. Chris Van Wyk's IDEAL <ref> [20] </ref> solves a larger class of constraints, but not general non-linear constraints. These systems are programmable, but not WYSIWYG (what you see is what you get).
References-found: 20

