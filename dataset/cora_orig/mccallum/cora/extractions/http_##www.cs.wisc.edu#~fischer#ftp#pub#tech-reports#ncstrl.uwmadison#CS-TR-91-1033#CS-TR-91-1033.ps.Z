URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-91-1033/CS-TR-91-1033.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-91-1033/
Root-URL: http://www.cs.wisc.edu
Email: E-mail: -ramali, reps-@cs.wisc.edu  
Title: On the Computational Complexity of Incremental Algorithms  
Author: G. RAMALINGAM and THOMAS REPS G. Ramalingam and Thomas W. Reps. 
Keyword: General Terms: Algorithms, Theory Additional Key Words and Phrases: all-pairs shortest-path problem, circuit-value problem, closed-semiring path problems, incremental algorithm, locally persistent algorithm, meet-semilattice data-flow analysis problems, reachability problem, single-sink shortest-path problem  
Address: 1210 W. Dayton St., Madison, WI 53706.  
Note: This work was supported in part by an IBM Graduate Fellowship, by a David and Lucile Packard Fellowship for Science and Engineering, by the National Science Foundation under grants DCR-8552602 and CCR-9100424, by the Defense Advanced Research Projects Agency, monitored by the Office of Naval Research under contract N00014-88-K-0590, as well as by a grant from the Digital Equipment Corporation. Authors' address:  Copyright 1991 by  All rights reserved.  
Affiliation: University of Wisconsin-Madison  Computer Sciences Department, University of Wisconsin-Madison,  
Abstract: A common way to evaluate the time complexity of an algorithm is to use asymptotic worst-case analysis and to express the cost of the computation as a function of the size of the input. However, for an incremental algorithm this kind of analysis is often not very informative. (By an incremental algorithm, we mean an algorithm that makes use of the solution to one problem instance to find the solution to a nearby problem instance.) When the cost of the computation is expressed as a function of the size of the (current) input, many incremental algorithms that have been proposed run in time asymptotically no better, in the worst-case, than the time required to perform the computation from scratch. Unfortunately, this kind of information is not very helpful if one wishes to compare different incremental algorithms for a given problem. This paper explores a different way to analyze incremental algorithms. Rather than express the cost of an incremental computation as a function of the size of the current input, we measure the cost in terms of the sum of the sizes of the changes in the input and the output. This change in approach allows us to develop a more informative theory of computational complexity for incremental problems. The paper presents new upper-bound results as well as new lower-bound results. First, three problemsthe single-sink shortest-path problem with positive edge weights, the all-pairs shortest-path problem with positive edge weights, and the circuit-value problemare shown to have bounded incremental complexity (i.e., incremental complexity bounded by a function of the sum of the sizes of the changes in the input and the output). The single-sink shortest-path problem with positive edge weights and the all-pairs shortest-path problem with positive edge weights are shown to be P-time incremental; the circuit-value problem is shown to be Exp-time incremental. We then turn to lower-bounds and establish a number of lower bounds with respect to a class of algorithms called the locally persistent algorithms. We first demonstrate the existence of a non-incremental problem (i.e., a problem for which no bounded locally persistent incremental algorithm exists). We then demonstrate that a number of other problems, including the closed-semiring path problems in directed graphs and the meet-semilattice data-flow analysis problems, are non-incremental with respect to the class of locally persistent algorithms. Our results, together with some previously known ones, shed light on the organization of the complexity hierarchy that exists when incremental-computation problems are classified according to their incremental complexity with respect to locally persistent algorithms. In particular, these results separate the classes of P-time incremental problems, inherently Exp-time incremental problems, and non-incremental problems. Categories and Subject Descriptors: E.1 [Data Structures] -- graphs; F.1.3 [Computation by Abstract Devices]: Complexity Classes -- complexity hierarchies, relations among complexity classes; F.2.2 [Analysis of Algorithms and Problem Complexity]: Nonnumerical Algorithms and Problems -- computations on discrete structures; G.2.1 [Discrete Mathematics]: Combinatorics -- combinatorial algorithms; G.2.2 [Discrete Mathematics]: Graph Theory -- graph algorithms 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Alpern, B., Hoover, R., Rosen, B.K., Sweeney, P.F., and Zadeck, F.K., </author> <title> Incremental evaluation of computational circuits, pp. </title> <booktitle> 32-42 in Proceedings of the First Annual ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <address> (San Francisco, CA, </address> <month> Jan. </month> <pages> 22-24, </pages> <year> 1990), </year> <institution> Society for Industrial and Applied Mathematics, </institution> <address> Philadelphia, PA (1990). </address>
Reference-contexts: Examples of bounded incremental algorithms that have been presented in previous work include (1) Reps's algorithm for updating the attributes of an attributed tree after an editing modification [30, 31], and (2) the algorithm of Alpern et al. for maintaining a priority ordering in a DAG <ref> [1] </ref>. What is new in this paper is that we systematically classify a wide range of problems according to their degree of boundedness. <p> SSSP&gt;0 and APSP&gt;0 are shown to be P-time incremental; the circuit-value problem is shown to be Exp-time incremental. (2) We establish several new lower-bound results, where the lower bounds are established with respect to the class of locally persistent algorithms, which was originally defined by Alpern et al. in <ref> [1] </ref>. Whereas Alpern et al. show the existence of a problem that has an exponential lower bound in || d || , we are able to demonstrate that more difficult problems exist (from the standpoint of incremental computation). <p> Note that it is not necessary to update any distances at all unless two conditions hold: (1) Edge v fi w is a member of SP (G). (2) Edge v fi w is the only member of SP (G) whose source is v. (See lines <ref> [1] </ref> and [3] of Figure 1.) Because the SP edges form a DAG, it is possible to identify the vertices of AFFECTED (i.e., the set of vertices whose shortest distance to sink (G) has increased) through a procedure very much like topological sorting: starting from vertex v, a traversal backwards along <p> v, w, x, y: vertices PriorityQueue: a priority queue of vertices preconditions v fi w E (G) SP (G) consists of all edges in E (G) on shortest paths to sink (G) " v V (G), dist (v) is length of the shortest path from v to sink (G) begin <ref> [1] </ref> if v fi w SP (G) then [2] Remove edge v fi w from SP (G) and from E (G) [3] if there does not exist a vertex x such that v fi x SP (G) then [4] /* Phase 1: Identify vertices in AFFECTED (the set of vertices whose <p> fi w PriorityQueue: a priority queue of vertices u, x: vertices preconditions v fi w E (G) SP (G) consists of all edges in E (G) on shortest paths to sink (G) " v V (G), dist (v) is length of the shortest path from v to sink (G) begin <ref> [1] </ref> Insert edge v fi w into E (G) [2] length (v fi w) := c [3] PriorityQueue := [4] if length (v fi w) + dist (w) &lt; dist (v) then [5] dist (v) := length (v fi w) + dist (w) [6] Insert v into PriorityQueue with priority 0 <p> Procedure DeleteUpdate is presented in Figure 3. DeleteUpdate is very similar to DeleteEdge SSSP &gt;0 , but eliminates the two problems discussed above. DeleteUpdate does not delete any edges; the deletion of edge v fi w is performed in DeleteEdge APSP &gt;0 itself (see line <ref> [1] </ref> of Figure 4). <p> the sink vertex of G WorkSet, AffectedVertices: sets of vertices a, b, c, u, v, w, x, y: vertices PriorityQueue: a priority queue of vertices SP (a, b, c) (dist G (a, c) = length G (a fi b) + dist G (b, c)) (dist G (a, c) ) begin <ref> [1] </ref> AffectedVertices := [2] if there does not exist any vertex x succ G (v) such that SP (v, x, z) then [3] /* Phase 1: Identify vertices in AFFECTED (the set of vertices whose shortest distance to z has increased). */ [4] /* Set AffectedVertices equal to AFFECTED. */ [5] <p> run in time that depends on a lower-order extended size of CHANGED. - 18 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh procedure DeleteEdge APSP&gt;0 (G, v fi w) declare G: a directed graph v fi w: an edge to be deleted from G AffectedSinks, AffectedSources: sets of vertices v, w, x: vertices of G begin <ref> [1] </ref> Remove edge v fi w from E (G) [2] Remove edge w fi v from E (G hh [3] AffectedSinks := the set AffectedVertices from Phase 1 of DeleteUpdate (G hh [4] AffectedSources := the set AffectedVertices from Phase 1 of DeleteUpdate (G, v fi w, w) [5] for each <p> has been inserted in G z: the sink vertex of G WorkSet: a set of edges VisitedVertices: a set of vertices u, x, y: vertices SP (a, b, c) (dist G (a, c) = length G (a fi b) + dist G (b, c)) (dist G (a, c) ) begin <ref> [1] </ref> WorkSet := - v fi w - [2] VisitedVertices := - v - [3] AffectedVertices := [4] while WorkSet do [5] Select and remove an edge x fi y from WorkSet [6] if length G (x fi y) + dist G (y,z) &lt; dist G (x,z) then [7] Insert x <p> ). hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh procedure InsertEdge APSP&gt;0 (G, v fi w, c) declare G: a directed graph v fi w: an edge to be inserted in G c: a positive real number indicating the length of edge v fi w AffectedSinks, AffectedSources: sets of vertices v, w, x: vertices of G begin <ref> [1] </ref> Insert edge v fi w into E (G) [2] Insert edge w fi v into E (G hhhh ) [3] length G (v fi w) := c [4] length G hh [5] AffectedSinks := the set AffectedVertices from InsertUpdate (G hh [6] AffectedSources := the set AffectedVertices from InsertUpdate (G, <p> Alpern et al. show that the incremental circuit-value problem has a lower bound of W (2 || d | | ) under a certain model of incremental computation <ref> [1] </ref>. In this section we develop an algorithm for the incremental circuit-value problem that runs in time O (2 2 | | d || ). Previous to our work, no bounded algorithm for the incremental circuit-value problem was known. Consider a circuit whose vertices are annotated with (output) values. <p> fringe vertex is the same as the original value of the vertex. hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh procedure UpdateSchema (G, u) declare G : an annotated circuit u : a vertex in G WorkSet, InnerFringe, ToBeExpanded : sets of vertices v, w: vertices preconditions Every vertex in G except possibly u is consistent begin <ref> [1] </ref> WorkSet := - u - [2] InnerFringe := - u - [3] u.originalValue := u.value [4] loop [5] for every vertex v WorkSet in relative topological-sort order do recompute v.value od [6] if for all v InnerFringe, v.value = v.originalValue then exit loop fi [7] Choose some non-empty subset ToBeExpanded <p> (P)+v h .outdegree || AFFECTED || || d || . - 25 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh procedure Update (G, u) declare G : an annotated circuit u : a vertex in G WorkSet, InnerFringe : sets of vertices v, w: vertices preconditions Every vertex in G except possibly u is consistent begin <ref> [1] </ref> WorkSet := - u - [2] InnerFringe := - u - [3] u.originalValue := u.value [4] u.cost := 0 [5] loop [6] for every vertex v WorkSet in relative topological-sort order do recompute v.value od [7] if for all v InnerFringe, v.value = v.originalValue then exit loop fi [8] Select <p> The algorithm can also be generalized to handle non-unit changes (i.e., input changes that modify multiple vertices and edges). End Aside. 4. LOWER-BOUND RESULTS: PROBLEMS THAT ARE NON-INCREMENTAL FOR LOCALLY PERSISTENT ALGORITHMS The class of locally persistent algorithms was introduced by Alpern et al. in <ref> [1] </ref>. What follows is their description of this class of algorithms, paraphrased to be applicable to general graph problems. <p> In the remainder of this section we describe the results from other papers that have a bearing on this way of classifying incremental problems; some additional discussion of these problems can be found in Section 6. hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh UNBOUNDED EXPONENTIAL POLYNOMIAL CIRCUIT-VALUE PROBLEM <ref> [1] </ref>, [Section 3.3] ATTRIBUTE UPDATING [31] PRIORITY ORDERING [1] ALL-PAIRS SHORTEST PATH (&gt; 0) [Section 3.2] SINGLE-SOURCE/SINK SHORTEST PATH (&gt; 0) [Section 3.1] MEET-SEMILATTICE DATA-FLOW ANALYSIS PROBLEMS [Section 4.3] SINGLE-SOURCE/SINK CLOSED-SEMIRING PATH PROBLEMS [Section 4.2] SINGLE-SOURCE/SINK SHORTEST PATH (&gt;= 0) [Section 4.2] SINGLE-SOURCE/SINK REACHABILITY [Section 4.1] d |||| d |||| d <p> In the remainder of this section we describe the results from other papers that have a bearing on this way of classifying incremental problems; some additional discussion of these problems can be found in Section 6. hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh UNBOUNDED EXPONENTIAL POLYNOMIAL CIRCUIT-VALUE PROBLEM <ref> [1] </ref>, [Section 3.3] ATTRIBUTE UPDATING [31] PRIORITY ORDERING [1] ALL-PAIRS SHORTEST PATH (&gt; 0) [Section 3.2] SINGLE-SOURCE/SINK SHORTEST PATH (&gt; 0) [Section 3.1] MEET-SEMILATTICE DATA-FLOW ANALYSIS PROBLEMS [Section 4.3] SINGLE-SOURCE/SINK CLOSED-SEMIRING PATH PROBLEMS [Section 4.2] SINGLE-SOURCE/SINK SHORTEST PATH (&gt;= 0) [Section 4.2] SINGLE-SOURCE/SINK REACHABILITY [Section 4.1] d |||| d |||| d |||| log hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh are classified according to their <p> the algorithm he gave for the problem is asymptotically optimal. ([30] is also the first paper that we are aware of in which an incremental algorithm is analyzed in terms of the parameter || d || .) The concept of a locally persistent algorithm is due to Alpern et al. <ref> [1] </ref>. Alpern et al. also established two results concerning the performance of incremental algorithms in terms of the parameter || d || . Their results concerned two problems: the incremental circuit-value problem and the problem of maintaining a priority ordering in a DAG. <p> Priority Ordering and the Circuit-Value Problem A paper by Alpern et al. <ref> [1] </ref> concerning the incremental circuit-value problem and the problem of maintaining a priority ordering in a DAG presents results on the incremental complexity of both problems in terms of the parameter || d || . <p> In this paper all lower-bound results apply to the locally persistent algorithms, a model of incremental computation that was defined by Alpern et al. <ref> [1] </ref>.
Reference: 2. <editor> Ausiello, G., Italiano, G.F., Spaccamela, A.M., and Nanni, U., </editor> <title> Incremental algorithms for minimal length paths, pp. </title> <booktitle> 12-21 in Proceedings of the First Annual ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <address> (San Francisco, CA, </address> <month> Jan. </month> <pages> 22-24, </pages> <year> 1990), </year> <institution> Society - 40 - for Industrial and Applied Mathematics, </institution> <address> Philadelphia, PA (1990). </address>
Reference-contexts: There are incremental problems for which the benefits mentioned above are realized. Examples include the results of Even and Shiloach [13], Reif [29] and Ausiello et al. <ref> [2] </ref>. However, the question of amortized-cost analysis versus worst-case analysis is really orthogonal to the question studied in this paper. <p> queue of vertices preconditions v fi w E (G) SP (G) consists of all edges in E (G) on shortest paths to sink (G) " v V (G), dist (v) is length of the shortest path from v to sink (G) begin [1] if v fi w SP (G) then <ref> [2] </ref> Remove edge v fi w from SP (G) and from E (G) [3] if there does not exist a vertex x such that v fi x SP (G) then [4] /* Phase 1: Identify vertices in AFFECTED (the set of vertices whose shortest distance to sink (G) has increased). */ <p> x: vertices preconditions v fi w E (G) SP (G) consists of all edges in E (G) on shortest paths to sink (G) " v V (G), dist (v) is length of the shortest path from v to sink (G) begin [1] Insert edge v fi w into E (G) <ref> [2] </ref> length (v fi w) := c [3] PriorityQueue := [4] if length (v fi w) + dist (w) &lt; dist (v) then [5] dist (v) := length (v fi w) + dist (w) [6] Insert v into PriorityQueue with priority 0 [7] else if length (v fi w) + dist <p> In the previous two paragraphs, we have been speaking very roughly. In particular, because DeleteEdge SSSP &gt;0 as stated in Figure 1 actually performs the deletion of edge v fi w from graph G (see lines <ref> [2] </ref> and [35]), a few changes in DeleteEdge SSSP &gt;0 are necessary for it to be called multiple times in the manner suggested above. There is also a more serious problem with using procedure DeleteEdge SSSP &gt;0 from Figure 1 in conjunction with the ideas outlined above. <p> of G WorkSet, AffectedVertices: sets of vertices a, b, c, u, v, w, x, y: vertices PriorityQueue: a priority queue of vertices SP (a, b, c) (dist G (a, c) = length G (a fi b) + dist G (b, c)) (dist G (a, c) ) begin [1] AffectedVertices := <ref> [2] </ref> if there does not exist any vertex x succ G (v) such that SP (v, x, z) then [3] /* Phase 1: Identify vertices in AFFECTED (the set of vertices whose shortest distance to z has increased). */ [4] /* Set AffectedVertices equal to AFFECTED. */ [5] WorkSet := - <p> size of CHANGED. - 18 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh procedure DeleteEdge APSP&gt;0 (G, v fi w) declare G: a directed graph v fi w: an edge to be deleted from G AffectedSinks, AffectedSources: sets of vertices v, w, x: vertices of G begin [1] Remove edge v fi w from E (G) <ref> [2] </ref> Remove edge w fi v from E (G hh [3] AffectedSinks := the set AffectedVertices from Phase 1 of DeleteUpdate (G hh [4] AffectedSources := the set AffectedVertices from Phase 1 of DeleteUpdate (G, v fi w, w) [5] for each vertex x AffectedSinks do DeleteUpdate (G, v fi w, <p> vertex of G WorkSet: a set of edges VisitedVertices: a set of vertices u, x, y: vertices SP (a, b, c) (dist G (a, c) = length G (a fi b) + dist G (b, c)) (dist G (a, c) ) begin [1] WorkSet := - v fi w - <ref> [2] </ref> VisitedVertices := - v - [3] AffectedVertices := [4] while WorkSet do [5] Select and remove an edge x fi y from WorkSet [6] if length G (x fi y) + dist G (y,z) &lt; dist G (x,z) then [7] Insert x into AffectedVertices [8] dist G (x,z) := length <p> c) declare G: a directed graph v fi w: an edge to be inserted in G c: a positive real number indicating the length of edge v fi w AffectedSinks, AffectedSources: sets of vertices v, w, x: vertices of G begin [1] Insert edge v fi w into E (G) <ref> [2] </ref> Insert edge w fi v into E (G hhhh ) [3] length G (v fi w) := c [4] length G hh [5] AffectedSinks := the set AffectedVertices from InsertUpdate (G hh [6] AffectedSources := the set AffectedVertices from InsertUpdate (G, v fi w, w) [7] for each vertex x <p> the original value of the vertex. hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh procedure UpdateSchema (G, u) declare G : an annotated circuit u : a vertex in G WorkSet, InnerFringe, ToBeExpanded : sets of vertices v, w: vertices preconditions Every vertex in G except possibly u is consistent begin [1] WorkSet := - u - <ref> [2] </ref> InnerFringe := - u - [3] u.originalValue := u.value [4] loop [5] for every vertex v WorkSet in relative topological-sort order do recompute v.value od [6] if for all v InnerFringe, v.value = v.originalValue then exit loop fi [7] Choose some non-empty subset ToBeExpanded of InnerFringe [8] for every vertex <p> || d || . - 25 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh procedure Update (G, u) declare G : an annotated circuit u : a vertex in G WorkSet, InnerFringe : sets of vertices v, w: vertices preconditions Every vertex in G except possibly u is consistent begin [1] WorkSet := - u - <ref> [2] </ref> InnerFringe := - u - [3] u.originalValue := u.value [4] u.cost := 0 [5] loop [6] for every vertex v WorkSet in relative topological-sort order do recompute v.value od [7] if for all v InnerFringe, v.value = v.originalValue then exit loop fi [8] Select and remove a vertex v from <p> Other previous work on how to maintain shortest paths in graphs incrementally includes papers by Halder [17], Pape [26], Spira and Pan [43], Cheston [8], Cheston and Corneil [9], and Ausiello et al. <ref> [2] </ref>; however, none of the papers in this group analyze either the single-source or the all-pairs problem in terms of the parameter || d || , and furthermore, none of the algorithms presented in these papers is bounded.
Reference: 3. <author> Berman, A.M., Paull, M.C., and Ryder, B.G., </author> <title> Proving relative lower bounds for incremental algorithms, </title> <note> Acta Informatica 27 pp. </note> <month> 665-683 </month> <year> (1990). </year>
Reference-contexts: even been possible to show a lower-bound result for an incremental-computation problem (as opposed to an analysis of a particular incremental algorithm for a problem), demonstrating that in the worst-case no incremental algorithm for the problem can perform asymptotically better than the time required to perform the computation from scratch <ref> [3, 14, 43] </ref>. For these reasons, worst-case analysis (with costs expressed as a function of the size of the input) has not been of much help for making comparisons between different incremental algorithms. <p> The problem of classifying incremental problems has also been addressed by Reif [29] and Berman, Paull, and Ryder <ref> [3] </ref>. In both cases, an important aspect that sets our work apart from theirs is that we analyze incremental complexity in terms of the adaptive parameter || d || , rather than in terms of the size hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 3 A circuit is a DAG with values computed at each vertex. <p> Note that it is not necessary to update any distances at all unless two conditions hold: (1) Edge v fi w is a member of SP (G). (2) Edge v fi w is the only member of SP (G) whose source is v. (See lines [1] and <ref> [3] </ref> of Figure 1.) Because the SP edges form a DAG, it is possible to identify the vertices of AFFECTED (i.e., the set of vertices whose shortest distance to sink (G) has increased) through a procedure very much like topological sorting: starting from vertex v, a traversal backwards along SP edges <p> all edges in E (G) on shortest paths to sink (G) " v V (G), dist (v) is length of the shortest path from v to sink (G) begin [1] if v fi w SP (G) then [2] Remove edge v fi w from SP (G) and from E (G) <ref> [3] </ref> if there does not exist a vertex x such that v fi x SP (G) then [4] /* Phase 1: Identify vertices in AFFECTED (the set of vertices whose shortest distance to sink (G) has increased). */ [5] /* Set AffectedVertices equal to AFFECTED. */ [6] WorkSet := - v <p> a count of the number of SP edges that emanate from x (i.e., | - x fi y | x fi y SP (G) - | ), it is possible to perform the test on line [13] in unit time. (Similarly, it is possible to perform the test on line <ref> [3] </ref> in unit time.) These counts must be adjusted whenever DeleteEdge SSSP &gt;0 or InsertEdge SSSP &gt;0 deletes an edge from SP (G) or inserts an edge into SP (G). <p> (G) SP (G) consists of all edges in E (G) on shortest paths to sink (G) " v V (G), dist (v) is length of the shortest path from v to sink (G) begin [1] Insert edge v fi w into E (G) [2] length (v fi w) := c <ref> [3] </ref> PriorityQueue := [4] if length (v fi w) + dist (w) &lt; dist (v) then [5] dist (v) := length (v fi w) + dist (w) [6] Insert v into PriorityQueue with priority 0 [7] else if length (v fi w) + dist (w) = dist (v) then [8] Insert <p> queue of vertices SP (a, b, c) (dist G (a, c) = length G (a fi b) + dist G (b, c)) (dist G (a, c) ) begin [1] AffectedVertices := [2] if there does not exist any vertex x succ G (v) such that SP (v, x, z) then <ref> [3] </ref> /* Phase 1: Identify vertices in AFFECTED (the set of vertices whose shortest distance to z has increased). */ [4] /* Set AffectedVertices equal to AFFECTED. */ [5] WorkSet := - v - [6] while WorkSet do [7] Select and remove a vertex u from WorkSet [8] Insert vertex u <p> (G, v fi w) declare G: a directed graph v fi w: an edge to be deleted from G AffectedSinks, AffectedSources: sets of vertices v, w, x: vertices of G begin [1] Remove edge v fi w from E (G) [2] Remove edge w fi v from E (G hh <ref> [3] </ref> AffectedSinks := the set AffectedVertices from Phase 1 of DeleteUpdate (G hh [4] AffectedSources := the set AffectedVertices from Phase 1 of DeleteUpdate (G, v fi w, w) [5] for each vertex x AffectedSinks do DeleteUpdate (G, v fi w, x) od [6] for each vertex x AffectedSources do DeleteUpdate <p> of edges VisitedVertices: a set of vertices u, x, y: vertices SP (a, b, c) (dist G (a, c) = length G (a fi b) + dist G (b, c)) (dist G (a, c) ) begin [1] WorkSet := - v fi w - [2] VisitedVertices := - v - <ref> [3] </ref> AffectedVertices := [4] while WorkSet do [5] Select and remove an edge x fi y from WorkSet [6] if length G (x fi y) + dist G (y,z) &lt; dist G (x,z) then [7] Insert x into AffectedVertices [8] dist G (x,z) := length G (x fi y) + dist <p> to be inserted in G c: a positive real number indicating the length of edge v fi w AffectedSinks, AffectedSources: sets of vertices v, w, x: vertices of G begin [1] Insert edge v fi w into E (G) [2] Insert edge w fi v into E (G hhhh ) <ref> [3] </ref> length G (v fi w) := c [4] length G hh [5] AffectedSinks := the set AffectedVertices from InsertUpdate (G hh [6] AffectedSources := the set AffectedVertices from InsertUpdate (G, v fi w, w) [7] for each vertex x AffectedSinks do InsertUpdate (G, v fi w, x) od [8] for <p> hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh procedure UpdateSchema (G, u) declare G : an annotated circuit u : a vertex in G WorkSet, InnerFringe, ToBeExpanded : sets of vertices v, w: vertices preconditions Every vertex in G except possibly u is consistent begin [1] WorkSet := - u - [2] InnerFringe := - u - <ref> [3] </ref> u.originalValue := u.value [4] loop [5] for every vertex v WorkSet in relative topological-sort order do recompute v.value od [6] if for all v InnerFringe, v.value = v.originalValue then exit loop fi [7] Choose some non-empty subset ToBeExpanded of InnerFringe [8] for every vertex v ToBeExpanded do [9] Remove v <p> - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh procedure Update (G, u) declare G : an annotated circuit u : a vertex in G WorkSet, InnerFringe : sets of vertices v, w: vertices preconditions Every vertex in G except possibly u is consistent begin [1] WorkSet := - u - [2] InnerFringe := - u - <ref> [3] </ref> u.originalValue := u.value [4] u.cost := 0 [5] loop [6] for every vertex v WorkSet in relative topological-sort order do recompute v.value od [7] if for all v InnerFringe, v.value = v.originalValue then exit loop fi [8] Select and remove a vertex v from InnerFringe for which v.cost+v.outdegree is minimum <p> Previous Work on Classifying Incremental Problems The problem of classifying incremental problems has been addressed in two previous papers, one by Reif [29] and one by Berman, Paull, and Ryder <ref> [3] </ref>. One aspect of our work that sets it apart from both of these papers is that we analyze incremental complexity in terms of the adaptive parameter || d || , rather than in terms of the size of the current input. <p> On the other hand, it is not clear that it would make sense to measure the complexity of incremental decision problems in terms of || d || . A different approach to the problem of classifying incremental problems was proposed in a paper by Berman, Paull, and Ryder <ref> [3] </ref>. Berman, Paull, and Ryder classify incremental problems through the notion of an incremental relative lower bound (IRLB). <p> problem: Berman, Paull, and Ryder show that hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 13 Recall that with our algorithms, edge-length reductions can be handled by generalizing InsertEdge APSP&gt;0 slightly, while edge-length increases can be handled by generalizing DeleteEdge APSP &gt;0 slightly. - 39 - a number of incremental data-flow analysis problems have O (1) IRLB's <ref> [3] </ref>, which puts them in the class of problems with the poorest incremental behavior (in the sense of Berman, Paull, and Ryder). <p> What is unsatisfactory about these models of incremental computation is that, at best, only very limited use of auxiliary storage is permitted. Berman, Paull, and Ryder do discuss a model of incremental computation that has somewhat fewer restrictions on the use of auxiliary storage <ref> [3] </ref>; however, in their model the cost of initializing any auxiliary storage used must be less than the cost of running the optimal-time batch algorithm for the problem. <p> There are certainly reasonable incremental algorithms that, because of the amount of auxiliary information that the algorithms store and maintain, lie outside the class of algorithms covered by Berman, Paull, and Ryder's model. (For instance, see Section 3.3 of <ref> [3] </ref>.) Thus, a desirable goal for future research is to develop a better model of incremental computation that better addresses the issue of the use and maintenance of auxiliary storage by incremental algorithms.
Reference: 4. <author> Boyce, D.E., Farhi, A., and Weischedel, R., </author> <title> Optimal network problem: a branch-and-bound algorithm, Environment and Planning, </title> <note> (5) pp. 519-533 (1973). As cited in reference [11]. </note>
Reference-contexts: is length of the shortest path from v to sink (G) begin [1] if v fi w SP (G) then [2] Remove edge v fi w from SP (G) and from E (G) [3] if there does not exist a vertex x such that v fi x SP (G) then <ref> [4] </ref> /* Phase 1: Identify vertices in AFFECTED (the set of vertices whose shortest distance to sink (G) has increased). */ [5] /* Set AffectedVertices equal to AFFECTED. */ [6] WorkSet := - v - [7] AffectedVertices := [8] while WorkSet do [9] Select and remove a vertex u from WorkSet <p> consists of all edges in E (G) on shortest paths to sink (G) " v V (G), dist (v) is length of the shortest path from v to sink (G) begin [1] Insert edge v fi w into E (G) [2] length (v fi w) := c [3] PriorityQueue := <ref> [4] </ref> if length (v fi w) + dist (w) &lt; dist (v) then [5] dist (v) := length (v fi w) + dist (w) [6] Insert v into PriorityQueue with priority 0 [7] else if length (v fi w) + dist (w) = dist (v) then [8] Insert v fi w <p> (b, c)) (dist G (a, c) ) begin [1] AffectedVertices := [2] if there does not exist any vertex x succ G (v) such that SP (v, x, z) then [3] /* Phase 1: Identify vertices in AFFECTED (the set of vertices whose shortest distance to z has increased). */ <ref> [4] </ref> /* Set AffectedVertices equal to AFFECTED. */ [5] WorkSet := - v - [6] while WorkSet do [7] Select and remove a vertex u from WorkSet [8] Insert vertex u into AffectedVertices [9] for each vertex x pred G (u) such that SP (x, u, z) do [10] if for <p> edge to be deleted from G AffectedSinks, AffectedSources: sets of vertices v, w, x: vertices of G begin [1] Remove edge v fi w from E (G) [2] Remove edge w fi v from E (G hh [3] AffectedSinks := the set AffectedVertices from Phase 1 of DeleteUpdate (G hh <ref> [4] </ref> AffectedSources := the set AffectedVertices from Phase 1 of DeleteUpdate (G, v fi w, w) [5] for each vertex x AffectedSinks do DeleteUpdate (G, v fi w, x) od [6] for each vertex x AffectedSources do DeleteUpdate (G hh end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh stored at vertex u of graph G is the <p> a set of vertices u, x, y: vertices SP (a, b, c) (dist G (a, c) = length G (a fi b) + dist G (b, c)) (dist G (a, c) ) begin [1] WorkSet := - v fi w - [2] VisitedVertices := - v - [3] AffectedVertices := <ref> [4] </ref> while WorkSet do [5] Select and remove an edge x fi y from WorkSet [6] if length G (x fi y) + dist G (y,z) &lt; dist G (x,z) then [7] Insert x into AffectedVertices [8] dist G (x,z) := length G (x fi y) + dist G (y,z) [9] <p> real number indicating the length of edge v fi w AffectedSinks, AffectedSources: sets of vertices v, w, x: vertices of G begin [1] Insert edge v fi w into E (G) [2] Insert edge w fi v into E (G hhhh ) [3] length G (v fi w) := c <ref> [4] </ref> length G hh [5] AffectedSinks := the set AffectedVertices from InsertUpdate (G hh [6] AffectedSources := the set AffectedVertices from InsertUpdate (G, v fi w, w) [7] for each vertex x AffectedSinks do InsertUpdate (G, v fi w, x) od [8] for each vertex x AffectedSources do InsertUpdate (G hh <p> u) declare G : an annotated circuit u : a vertex in G WorkSet, InnerFringe, ToBeExpanded : sets of vertices v, w: vertices preconditions Every vertex in G except possibly u is consistent begin [1] WorkSet := - u - [2] InnerFringe := - u - [3] u.originalValue := u.value <ref> [4] </ref> loop [5] for every vertex v WorkSet in relative topological-sort order do recompute v.value od [6] if for all v InnerFringe, v.value = v.originalValue then exit loop fi [7] Choose some non-empty subset ToBeExpanded of InnerFringe [8] for every vertex v ToBeExpanded do [9] Remove v from InnerFringe [10] for <p> (G, u) declare G : an annotated circuit u : a vertex in G WorkSet, InnerFringe : sets of vertices v, w: vertices preconditions Every vertex in G except possibly u is consistent begin [1] WorkSet := - u - [2] InnerFringe := - u - [3] u.originalValue := u.value <ref> [4] </ref> u.cost := 0 [5] loop [6] for every vertex v WorkSet in relative topological-sort order do recompute v.value od [7] if for all v InnerFringe, v.value = v.originalValue then exit loop fi [8] Select and remove a vertex v from InnerFringe for which v.cost+v.outdegree is minimum [9] for every vertex <p> (In the symmetric case, length (i, j) = length (j, i) for all vertices i and j.) Dionne cites Murchland as the source of the algorithm he studies for the asymmetric case [25] and Boyce, Farhi, and Weischedel as originators of a similar algorithm to his for the symmetric case <ref> [4] </ref>.
Reference: 5. <author> Cai, J. and Paige, R., </author> <title> Binding performance at language design time, pp. </title> <booktitle> 85-97 in Conference Record of the Fourteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Munich, </address> <publisher> W. </publisher> <address> Germany, </address> <month> January </month> <year> 1987), </year> <booktitle> ACM, </booktitle> <address> New York, NY (1987). </address>
Reference-contexts: Remove edge v fi w from SP (G) and from E (G) [3] if there does not exist a vertex x such that v fi x SP (G) then [4] /* Phase 1: Identify vertices in AFFECTED (the set of vertices whose shortest distance to sink (G) has increased). */ <ref> [5] </ref> /* Set AffectedVertices equal to AFFECTED. */ [6] WorkSet := - v - [7] AffectedVertices := [8] while WorkSet do [9] Select and remove a vertex u from WorkSet [10] Insert vertex u into AffectedVertices [11] for each vertex x such that x fi u SP (G) do [12] Remove <p> " v V (G), dist (v) is length of the shortest path from v to sink (G) begin [1] Insert edge v fi w into E (G) [2] length (v fi w) := c [3] PriorityQueue := [4] if length (v fi w) + dist (w) &lt; dist (v) then <ref> [5] </ref> dist (v) := length (v fi w) + dist (w) [6] Insert v into PriorityQueue with priority 0 [7] else if length (v fi w) + dist (w) = dist (v) then [8] Insert v fi w into SP (G) [9] fi [10] while PriorityQueue do [11] Select and remove <p> [1] AffectedVertices := [2] if there does not exist any vertex x succ G (v) such that SP (v, x, z) then [3] /* Phase 1: Identify vertices in AFFECTED (the set of vertices whose shortest distance to z has increased). */ [4] /* Set AffectedVertices equal to AFFECTED. */ <ref> [5] </ref> WorkSet := - v - [6] while WorkSet do [7] Select and remove a vertex u from WorkSet [8] Insert vertex u into AffectedVertices [9] for each vertex x pred G (u) such that SP (x, u, z) do [10] if for all vertices y succ G (x) such that <p> G begin [1] Remove edge v fi w from E (G) [2] Remove edge w fi v from E (G hh [3] AffectedSinks := the set AffectedVertices from Phase 1 of DeleteUpdate (G hh [4] AffectedSources := the set AffectedVertices from Phase 1 of DeleteUpdate (G, v fi w, w) <ref> [5] </ref> for each vertex x AffectedSinks do DeleteUpdate (G, v fi w, x) od [6] for each vertex x AffectedSources do DeleteUpdate (G hh end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh stored at vertex u of graph G is the length of the shortest path from u to v in G, the value dist G hh <p> u, x, y: vertices SP (a, b, c) (dist G (a, c) = length G (a fi b) + dist G (b, c)) (dist G (a, c) ) begin [1] WorkSet := - v fi w - [2] VisitedVertices := - v - [3] AffectedVertices := [4] while WorkSet do <ref> [5] </ref> Select and remove an edge x fi y from WorkSet [6] if length G (x fi y) + dist G (y,z) &lt; dist G (x,z) then [7] Insert x into AffectedVertices [8] dist G (x,z) := length G (x fi y) + dist G (y,z) [9] for every vertex u <p> For instance, consider the edge x fi y selected in line <ref> [5] </ref> of Figure 5. Vertex x is the vertex to be visited next during the traversal described above. <p> This set is precisely the set of all affected vertices for the single-source shortest-path problem with v as the source, i.e. the set AffectedVer-tices computed by the call InsertUpdate (G hh ,w fi v,v). This is how InsertEdge APSP &gt;0 determines the set AffectedSinks (see line <ref> [5] </ref> of Figure 6); InsertUpdate is then invoked repeatedly, once for each member of AffectedSinks. The update to graph G hh is performed in an analogous fashion. We now consider the time complexity of InsertEdge APSP &gt;0 . <p> Thus, the total running time of line [7] in procedure InsertEdge APSP &gt;0 is O ( || d || 1 ). Similarly, line [8] takes time O ( || d || 1 ). Line <ref> [5] </ref> takes time O ( || AFFECTED v || 1,G hh ); line [6] takes time O ( || AFFECTED w || 1,G ). <p> length of edge v fi w AffectedSinks, AffectedSources: sets of vertices v, w, x: vertices of G begin [1] Insert edge v fi w into E (G) [2] Insert edge w fi v into E (G hhhh ) [3] length G (v fi w) := c [4] length G hh <ref> [5] </ref> AffectedSinks := the set AffectedVertices from InsertUpdate (G hh [6] AffectedSources := the set AffectedVertices from InsertUpdate (G, v fi w, w) [7] for each vertex x AffectedSinks do InsertUpdate (G, v fi w, x) od [8] for each vertex x AffectedSources do InsertUpdate (G hh end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh - 21 <p> G : an annotated circuit u : a vertex in G WorkSet, InnerFringe, ToBeExpanded : sets of vertices v, w: vertices preconditions Every vertex in G except possibly u is consistent begin [1] WorkSet := - u - [2] InnerFringe := - u - [3] u.originalValue := u.value [4] loop <ref> [5] </ref> for every vertex v WorkSet in relative topological-sort order do recompute v.value od [6] if for all v InnerFringe, v.value = v.originalValue then exit loop fi [7] Choose some non-empty subset ToBeExpanded of InnerFringe [8] for every vertex v ToBeExpanded do [9] Remove v from InnerFringe [10] for every vertex <p> : an annotated circuit u : a vertex in G WorkSet, InnerFringe : sets of vertices v, w: vertices preconditions Every vertex in G except possibly u is consistent begin [1] WorkSet := - u - [2] InnerFringe := - u - [3] u.originalValue := u.value [4] u.cost := 0 <ref> [5] </ref> loop [6] for every vertex v WorkSet in relative topological-sort order do recompute v.value od [7] if for all v InnerFringe, v.value = v.originalValue then exit loop fi [8] Select and remove a vertex v from InnerFringe for which v.cost+v.outdegree is minimum [9] for every vertex w (succ (v) - <p> Other Related Work For batch algorithms, the concept of measuring the complexity of an algorithm in terms of the sum of the sizes of the input and the output has been explored by Cai and Paige <ref> [5, 6] </ref> and by Gurevitch and Shelah [16]. In this paper, we measure the complexity of an incremental algorithm in terms of the sum of the sizes of the changes in the input and the output.
Reference: 6. <author> Cai, J. and Paige, R., </author> <title> Languages polynomial in the input plus output, </title> <booktitle> in Proceedings of the Second International Conference on Algebraic Methodology and Software Technology (AMAST), </booktitle> <address> (Iowa City, Iowa, </address> <month> May 22-25, </month> <year> 1991), (1991). </year>
Reference-contexts: and from E (G) [3] if there does not exist a vertex x such that v fi x SP (G) then [4] /* Phase 1: Identify vertices in AFFECTED (the set of vertices whose shortest distance to sink (G) has increased). */ [5] /* Set AffectedVertices equal to AFFECTED. */ <ref> [6] </ref> WorkSet := - v - [7] AffectedVertices := [8] while WorkSet do [9] Select and remove a vertex u from WorkSet [10] Insert vertex u into AffectedVertices [11] for each vertex x such that x fi u SP (G) do [12] Remove edge x fi u from SP (G) [13] <p> path from v to sink (G) begin [1] Insert edge v fi w into E (G) [2] length (v fi w) := c [3] PriorityQueue := [4] if length (v fi w) + dist (w) &lt; dist (v) then [5] dist (v) := length (v fi w) + dist (w) <ref> [6] </ref> Insert v into PriorityQueue with priority 0 [7] else if length (v fi w) + dist (w) = dist (v) then [8] Insert v fi w into SP (G) [9] fi [10] while PriorityQueue do [11] Select and remove a vertex u in PriorityQueue with minimum priority [12] Remove all <p> does not exist any vertex x succ G (v) such that SP (v, x, z) then [3] /* Phase 1: Identify vertices in AFFECTED (the set of vertices whose shortest distance to z has increased). */ [4] /* Set AffectedVertices equal to AFFECTED. */ [5] WorkSet := - v - <ref> [6] </ref> while WorkSet do [7] Select and remove a vertex u from WorkSet [8] Insert vertex u into AffectedVertices [9] for each vertex x pred G (u) such that SP (x, u, z) do [10] if for all vertices y succ G (x) such that SP (x, y, z), y AffectedVertices <p> w fi v from E (G hh [3] AffectedSinks := the set AffectedVertices from Phase 1 of DeleteUpdate (G hh [4] AffectedSources := the set AffectedVertices from Phase 1 of DeleteUpdate (G, v fi w, w) [5] for each vertex x AffectedSinks do DeleteUpdate (G, v fi w, x) od <ref> [6] </ref> for each vertex x AffectedSources do DeleteUpdate (G hh end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh stored at vertex u of graph G is the length of the shortest path from u to v in G, the value dist G hh length of the shortest path from v to u in G. <p> c) = length G (a fi b) + dist G (b, c)) (dist G (a, c) ) begin [1] WorkSet := - v fi w - [2] VisitedVertices := - v - [3] AffectedVertices := [4] while WorkSet do [5] Select and remove an edge x fi y from WorkSet <ref> [6] </ref> if length G (x fi y) + dist G (y,z) &lt; dist G (x,z) then [7] Insert x into AffectedVertices [8] dist G (x,z) := length G (x fi y) + dist G (y,z) [9] for every vertex u such that u fi x E (G) do [10] if SP <p> Except in the case when edge x fi y is v fi w, vertex y is an affected vertex and is the successor of x in a shortest path from x to v. The test in line <ref> [6] </ref> determines if x itself is an affected vertex. If it is, its distance information is updated, and its predecessors in the shortest-path DAG to sink v are added to the workset for subsequent processing, unless they have already been visited. <p> Thus, the total running time of line [7] in procedure InsertEdge APSP &gt;0 is O ( || d || 1 ). Similarly, line [8] takes time O ( || d || 1 ). Line [5] takes time O ( || AFFECTED v || 1,G hh ); line <ref> [6] </ref> takes time O ( || AFFECTED w || 1,G ). <p> vertices v, w, x: vertices of G begin [1] Insert edge v fi w into E (G) [2] Insert edge w fi v into E (G hhhh ) [3] length G (v fi w) := c [4] length G hh [5] AffectedSinks := the set AffectedVertices from InsertUpdate (G hh <ref> [6] </ref> AffectedSources := the set AffectedVertices from InsertUpdate (G, v fi w, w) [7] for each vertex x AffectedSinks do InsertUpdate (G, v fi w, x) od [8] for each vertex x AffectedSources do InsertUpdate (G hh end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh - 21 - 3.3. <p> : sets of vertices v, w: vertices preconditions Every vertex in G except possibly u is consistent begin [1] WorkSet := - u - [2] InnerFringe := - u - [3] u.originalValue := u.value [4] loop [5] for every vertex v WorkSet in relative topological-sort order do recompute v.value od <ref> [6] </ref> if for all v InnerFringe, v.value = v.originalValue then exit loop fi [7] Choose some non-empty subset ToBeExpanded of InnerFringe [8] for every vertex v ToBeExpanded do [9] Remove v from InnerFringe [10] for every vertex w (succ (v) - WorkSet) do [11] Insert w into both WorkSet and InnerFringe <p> annotated circuit u : a vertex in G WorkSet, InnerFringe : sets of vertices v, w: vertices preconditions Every vertex in G except possibly u is consistent begin [1] WorkSet := - u - [2] InnerFringe := - u - [3] u.originalValue := u.value [4] u.cost := 0 [5] loop <ref> [6] </ref> for every vertex v WorkSet in relative topological-sort order do recompute v.value od [7] if for all v InnerFringe, v.value = v.originalValue then exit loop fi [8] Select and remove a vertex v from InnerFringe for which v.cost+v.outdegree is minimum [9] for every vertex w (succ (v) - WorkSet) do <p> Other Related Work For batch algorithms, the concept of measuring the complexity of an algorithm in terms of the sum of the sizes of the input and the output has been explored by Cai and Paige <ref> [5, 6] </ref> and by Gurevitch and Shelah [16]. In this paper, we measure the complexity of an incremental algorithm in terms of the sum of the sizes of the changes in the input and the output.
Reference: 7. <author> Carroll, M. and Ryder, B., </author> <title> Incremental data flow update via attribute and dominator updates, pp. </title> <booktitle> 274-284 in Conference Record of the Fifteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (San Diego, CA, </address> <month> January 13-15, </month> <year> 1988), </year> <booktitle> ACM, </booktitle> <address> New York, NY (1988). </address>
Reference-contexts: informative; when the cost of the computation is expressed as a function of the size of the (current) input (i.e., | x | ), many incremental algorithms that have been proposed run in time asymptotically no better, in the worst-case, than the time required to perform the computation from scratch <ref> [7, 8, 19, 24, 48] </ref>. <p> there does not exist a vertex x such that v fi x SP (G) then [4] /* Phase 1: Identify vertices in AFFECTED (the set of vertices whose shortest distance to sink (G) has increased). */ [5] /* Set AffectedVertices equal to AFFECTED. */ [6] WorkSet := - v - <ref> [7] </ref> AffectedVertices := [8] while WorkSet do [9] Select and remove a vertex u from WorkSet [10] Insert vertex u into AffectedVertices [11] for each vertex x such that x fi u SP (G) do [12] Remove edge x fi u from SP (G) [13] if there does not exist a <p> Insert edge v fi w into E (G) [2] length (v fi w) := c [3] PriorityQueue := [4] if length (v fi w) + dist (w) &lt; dist (v) then [5] dist (v) := length (v fi w) + dist (w) [6] Insert v into PriorityQueue with priority 0 <ref> [7] </ref> else if length (v fi w) + dist (w) = dist (v) then [8] Insert v fi w into SP (G) [9] fi [10] while PriorityQueue do [11] Select and remove a vertex u in PriorityQueue with minimum priority [12] Remove all edges of SP (G) directed away from u <p> vertex x succ G (v) such that SP (v, x, z) then [3] /* Phase 1: Identify vertices in AFFECTED (the set of vertices whose shortest distance to z has increased). */ [4] /* Set AffectedVertices equal to AFFECTED. */ [5] WorkSet := - v - [6] while WorkSet do <ref> [7] </ref> Select and remove a vertex u from WorkSet [8] Insert vertex u into AffectedVertices [9] for each vertex x pred G (u) such that SP (x, u, z) do [10] if for all vertices y succ G (x) such that SP (x, y, z), y AffectedVertices then Insert vertex x <p> ) begin [1] WorkSet := - v fi w - [2] VisitedVertices := - v - [3] AffectedVertices := [4] while WorkSet do [5] Select and remove an edge x fi y from WorkSet [6] if length G (x fi y) + dist G (y,z) &lt; dist G (x,z) then <ref> [7] </ref> Insert x into AffectedVertices [8] dist G (x,z) := length G (x fi y) + dist G (y,z) [9] for every vertex u such that u fi x E (G) do [10] if SP (u,x,v) and u VisitedVertices then [11] Insert u fi x into WorkSet [12] Insert u into <p> InsertUp-date does essentially a simple traversal of the graph &lt;N (AFFECTED x )&gt;, in time O ( || AFFECTED x || ). Thus, the total running time of line <ref> [7] </ref> in procedure InsertEdge APSP &gt;0 is O ( || d || 1 ). Similarly, line [8] takes time O ( || d || 1 ). <p> w into E (G) [2] Insert edge w fi v into E (G hhhh ) [3] length G (v fi w) := c [4] length G hh [5] AffectedSinks := the set AffectedVertices from InsertUpdate (G hh [6] AffectedSources := the set AffectedVertices from InsertUpdate (G, v fi w, w) <ref> [7] </ref> for each vertex x AffectedSinks do InsertUpdate (G, v fi w, x) od [8] for each vertex x AffectedSources do InsertUpdate (G hh end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh - 21 - 3.3. <p> The WorkSet initially consists of only the modified vertex u, and is iteratively expanded by choosing a set of vertices ToBeExpanded (see line <ref> [7] </ref>) and adding all the successors of vertices in ToBeExpanded to WorkSet (lines [8]-[14]). Vertices in ToBeExpanded are said to have been expanded at this stage. After each such expansion, values of vertices in WorkSet are recomputed in a relative topological-sort order. <p> possibly u is consistent begin [1] WorkSet := - u - [2] InnerFringe := - u - [3] u.originalValue := u.value [4] loop [5] for every vertex v WorkSet in relative topological-sort order do recompute v.value od [6] if for all v InnerFringe, v.value = v.originalValue then exit loop fi <ref> [7] </ref> Choose some non-empty subset ToBeExpanded of InnerFringe [8] for every vertex v ToBeExpanded do [9] Remove v from InnerFringe [10] for every vertex w (succ (v) - WorkSet) do [11] Insert w into both WorkSet and InnerFringe [12] w.originalValue := w.value [13] od [15] end loop postconditions Every vertex in <p> It follows that UpdateSchema computes a correct annotation of the circuit. ` The set of vertices to be expanded are chosen (nondeterministically) at line <ref> [7] </ref> of UpdateSchema. If these vertices are chosen arbitrarily, the resulting algorithm will be an unbounded one. The problem is that an unbounded amount of propagation of spurious changes is possible. <p> A simple scheme that keeps the algorithm bounded in the case of DAGs of bounded outdegree is to propagate changes in a breadth-first order. We achieve this by expanding all inner fringe vertices during each iteration. Let SimpleUpdate be the procedure obtained from UpdateSchema by refining line <ref> [7] </ref> to ToBeExpanded := InnerFringe . Proposition 3.2. Procedure SimpleUpdate computes the correct annotation of circuit G in time O (k | AFFECTED | ), where each vertex in G has outdegree k. Proof. The proof that the computed annotation is correct follows from Proposition 3.1. <p> v, w: vertices preconditions Every vertex in G except possibly u is consistent begin [1] WorkSet := - u - [2] InnerFringe := - u - [3] u.originalValue := u.value [4] u.cost := 0 [5] loop [6] for every vertex v WorkSet in relative topological-sort order do recompute v.value od <ref> [7] </ref> if for all v InnerFringe, v.value = v.originalValue then exit loop fi [8] Select and remove a vertex v from InnerFringe for which v.cost+v.outdegree is minimum [9] for every vertex w (succ (v) - WorkSet) do [10] Insert w into both WorkSet and InnerFringe [11] w.originalValue := w.value [12] w.cost <p> A number of papers in the literature on incremental algorithms concern incremental data-flow analysis <ref> [7, 23, 24, 38, 39, 48] </ref>. <p> For instance, Hoover presents evidence that his unbounded algorithm for the circuit-value problem performs well in practice [19]; Ryder, Landi, and Pande present evidence that the unbounded incremental data-flow analysis algorithm of Carroll and Ryder <ref> [7] </ref> performs well in practice [40]; as discussed earlier, Dionne reports excellent performance for some unbounded algorithms for APSP&gt;0 [11]. ACKNOWLEDGEMENTS We are grateful for the comments and helpful suggestions of Susan Horwitz, Alan Demers, and Tim Teitel-baum.
Reference: 8. <author> Cheston, </author> <title> G.A., Incremental algorithms in graph theory, </title> <type> Ph.D. dissertation and Tech. Rep. 91, </type> <institution> Dept. of Computer Science, University of Toronto, Toronto, </institution> <address> Canada (March 1976). </address>
Reference-contexts: informative; when the cost of the computation is expressed as a function of the size of the (current) input (i.e., | x | ), many incremental algorithms that have been proposed run in time asymptotically no better, in the worst-case, than the time required to perform the computation from scratch <ref> [7, 8, 19, 24, 48] </ref>. <p> exist a vertex x such that v fi x SP (G) then [4] /* Phase 1: Identify vertices in AFFECTED (the set of vertices whose shortest distance to sink (G) has increased). */ [5] /* Set AffectedVertices equal to AFFECTED. */ [6] WorkSet := - v - [7] AffectedVertices := <ref> [8] </ref> while WorkSet do [9] Select and remove a vertex u from WorkSet [10] Insert vertex u into AffectedVertices [11] for each vertex x such that x fi u SP (G) do [12] Remove edge x fi u from SP (G) [13] if there does not exist a vertex y such <p> c [3] PriorityQueue := [4] if length (v fi w) + dist (w) &lt; dist (v) then [5] dist (v) := length (v fi w) + dist (w) [6] Insert v into PriorityQueue with priority 0 [7] else if length (v fi w) + dist (w) = dist (v) then <ref> [8] </ref> Insert v fi w into SP (G) [9] fi [10] while PriorityQueue do [11] Select and remove a vertex u in PriorityQueue with minimum priority [12] Remove all edges of SP (G) directed away from u [13] for every vertex x such that u fi x E (G) do [14] <p> x, z) then [3] /* Phase 1: Identify vertices in AFFECTED (the set of vertices whose shortest distance to z has increased). */ [4] /* Set AffectedVertices equal to AFFECTED. */ [5] WorkSet := - v - [6] while WorkSet do [7] Select and remove a vertex u from WorkSet <ref> [8] </ref> Insert vertex u into AffectedVertices [9] for each vertex x pred G (u) such that SP (x, u, z) do [10] if for all vertices y succ G (x) such that SP (x, y, z), y AffectedVertices then Insert vertex x into WorkSet fi [11] od [13] /* Phase 2: <p> - v fi w - [2] VisitedVertices := - v - [3] AffectedVertices := [4] while WorkSet do [5] Select and remove an edge x fi y from WorkSet [6] if length G (x fi y) + dist G (y,z) &lt; dist G (x,z) then [7] Insert x into AffectedVertices <ref> [8] </ref> dist G (x,z) := length G (x fi y) + dist G (y,z) [9] for every vertex u such that u fi x E (G) do [10] if SP (u,x,v) and u VisitedVertices then [11] Insert u fi x into WorkSet [12] Insert u into VisitedVertices [13] fi [15] fi <p> InsertUp-date does essentially a simple traversal of the graph &lt;N (AFFECTED x )&gt;, in time O ( || AFFECTED x || ). Thus, the total running time of line [7] in procedure InsertEdge APSP &gt;0 is O ( || d || 1 ). Similarly, line <ref> [8] </ref> takes time O ( || d || 1 ). Line [5] takes time O ( || AFFECTED v || 1,G hh ); line [6] takes time O ( || AFFECTED w || 1,G ). <p> ) [3] length G (v fi w) := c [4] length G hh [5] AffectedSinks := the set AffectedVertices from InsertUpdate (G hh [6] AffectedSources := the set AffectedVertices from InsertUpdate (G, v fi w, w) [7] for each vertex x AffectedSinks do InsertUpdate (G, v fi w, x) od <ref> [8] </ref> for each vertex x AffectedSources do InsertUpdate (G hh end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh - 21 - 3.3. The Incremental Circuit-Value Problem A circuit is a DAG where every vertex u is associated with a function F u . <p> - u - [2] InnerFringe := - u - [3] u.originalValue := u.value [4] loop [5] for every vertex v WorkSet in relative topological-sort order do recompute v.value od [6] if for all v InnerFringe, v.value = v.originalValue then exit loop fi [7] Choose some non-empty subset ToBeExpanded of InnerFringe <ref> [8] </ref> for every vertex v ToBeExpanded do [9] Remove v from InnerFringe [10] for every vertex w (succ (v) - WorkSet) do [11] Insert w into both WorkSet and InnerFringe [12] w.originalValue := w.value [13] od [15] end loop postconditions Every vertex in G is consistent end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh - 23 - <p> begin [1] WorkSet := - u - [2] InnerFringe := - u - [3] u.originalValue := u.value [4] u.cost := 0 [5] loop [6] for every vertex v WorkSet in relative topological-sort order do recompute v.value od [7] if for all v InnerFringe, v.value = v.originalValue then exit loop fi <ref> [8] </ref> Select and remove a vertex v from InnerFringe for which v.cost+v.outdegree is minimum [9] for every vertex w (succ (v) - WorkSet) do [10] Insert w into both WorkSet and InnerFringe [11] w.originalValue := w.value [12] w.cost := v.cost + v.outdegree [13] od [14] end loop postconditions Every vertex in <p> Other previous work on how to maintain shortest paths in graphs incrementally includes papers by Halder [17], Pape [26], Spira and Pan [43], Cheston <ref> [8] </ref>, Cheston and Corneil [9], and Ausiello et al. [2]; however, none of the papers in this group analyze either the single-source or the all-pairs problem in terms of the parameter || d || , and furthermore, none of the algorithms presented in these papers is bounded.
Reference: 9. <author> Cheston, G.A. and Corneil, D.G., </author> <title> Graph property update algorithms and their application to distance matrices, </title> <note> INFOR 20(3) pp. </note> <month> 178-201 (August </month> <year> 1982). </year>
Reference-contexts: such that v fi x SP (G) then [4] /* Phase 1: Identify vertices in AFFECTED (the set of vertices whose shortest distance to sink (G) has increased). */ [5] /* Set AffectedVertices equal to AFFECTED. */ [6] WorkSet := - v - [7] AffectedVertices := [8] while WorkSet do <ref> [9] </ref> Select and remove a vertex u from WorkSet [10] Insert vertex u into AffectedVertices [11] for each vertex x such that x fi u SP (G) do [12] Remove edge x fi u from SP (G) [13] if there does not exist a vertex y such that x fi y <p> fi w) + dist (w) &lt; dist (v) then [5] dist (v) := length (v fi w) + dist (w) [6] Insert v into PriorityQueue with priority 0 [7] else if length (v fi w) + dist (w) = dist (v) then [8] Insert v fi w into SP (G) <ref> [9] </ref> fi [10] while PriorityQueue do [11] Select and remove a vertex u in PriorityQueue with minimum priority [12] Remove all edges of SP (G) directed away from u [13] for every vertex x such that u fi x E (G) do [14] if length (u fi x) + dist (x) <p> 1: Identify vertices in AFFECTED (the set of vertices whose shortest distance to z has increased). */ [4] /* Set AffectedVertices equal to AFFECTED. */ [5] WorkSet := - v - [6] while WorkSet do [7] Select and remove a vertex u from WorkSet [8] Insert vertex u into AffectedVertices <ref> [9] </ref> for each vertex x pred G (u) such that SP (x, u, z) do [10] if for all vertices y succ G (x) such that SP (x, y, z), y AffectedVertices then Insert vertex x into WorkSet fi [11] od [13] /* Phase 2: Determine new distances to z for <p> [4] while WorkSet do [5] Select and remove an edge x fi y from WorkSet [6] if length G (x fi y) + dist G (y,z) &lt; dist G (x,z) then [7] Insert x into AffectedVertices [8] dist G (x,z) := length G (x fi y) + dist G (y,z) <ref> [9] </ref> for every vertex u such that u fi x E (G) do [10] if SP (u,x,v) and u VisitedVertices then [11] Insert u fi x into WorkSet [12] Insert u into VisitedVertices [13] fi [15] fi end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh - 20 - traversal of this DAG, visiting only affected vertices or <p> u - [3] u.originalValue := u.value [4] loop [5] for every vertex v WorkSet in relative topological-sort order do recompute v.value od [6] if for all v InnerFringe, v.value = v.originalValue then exit loop fi [7] Choose some non-empty subset ToBeExpanded of InnerFringe [8] for every vertex v ToBeExpanded do <ref> [9] </ref> Remove v from InnerFringe [10] for every vertex w (succ (v) - WorkSet) do [11] Insert w into both WorkSet and InnerFringe [12] w.originalValue := w.value [13] od [15] end loop postconditions Every vertex in G is consistent end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh - 23 - Proposition 3.1. <p> u.originalValue := u.value [4] u.cost := 0 [5] loop [6] for every vertex v WorkSet in relative topological-sort order do recompute v.value od [7] if for all v InnerFringe, v.value = v.originalValue then exit loop fi [8] Select and remove a vertex v from InnerFringe for which v.cost+v.outdegree is minimum <ref> [9] </ref> for every vertex w (succ (v) - WorkSet) do [10] Insert w into both WorkSet and InnerFringe [11] w.originalValue := w.value [12] w.cost := v.cost + v.outdegree [13] od [14] end loop postconditions Every vertex in G is consistent end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh Every vertex y in WorkSet hhhhhhh except u was <p> Other previous work on how to maintain shortest paths in graphs incrementally includes papers by Halder [17], Pape [26], Spira and Pan [43], Cheston [8], Cheston and Corneil <ref> [9] </ref>, and Ausiello et al. [2]; however, none of the papers in this group analyze either the single-source or the all-pairs problem in terms of the parameter || d || , and furthermore, none of the algorithms presented in these papers is bounded.
Reference: 10. <author> Dijkstra, </author> <title> E.W., A note on two problems in connexion with graphs, </title> <journal> Numerische Mathematik 1 pp. </journal> <month> 269-271 </month> <year> (1959). </year>
Reference-contexts: There are two phases involved in updating G (and SP (G)) after an edge is deleted. Phase 1 (lines [4]-[15]) carries out the traversal described above and sets the variable AffectedVertices equal to AFFECTED. Phase 2 (lines [16]-[33]) is an adaptation of Dijkstra's (batch) shortest-path algorithm (see reference <ref> [10] </ref>) that is able to pick up the process of assigning dist values in the middle by initializing a priority queue appropriately (lines [17]-[21]). <p> /* Phase 1: Identify vertices in AFFECTED (the set of vertices whose shortest distance to sink (G) has increased). */ [5] /* Set AffectedVertices equal to AFFECTED. */ [6] WorkSet := - v - [7] AffectedVertices := [8] while WorkSet do [9] Select and remove a vertex u from WorkSet <ref> [10] </ref> Insert vertex u into AffectedVertices [11] for each vertex x such that x fi u SP (G) do [12] Remove edge x fi u from SP (G) [13] if there does not exist a vertex y such that x fi y SP (G) then Insert vertex x into WorkSet fi <p> + dist (w) &lt; dist (v) then [5] dist (v) := length (v fi w) + dist (w) [6] Insert v into PriorityQueue with priority 0 [7] else if length (v fi w) + dist (w) = dist (v) then [8] Insert v fi w into SP (G) [9] fi <ref> [10] </ref> while PriorityQueue do [11] Select and remove a vertex u in PriorityQueue with minimum priority [12] Remove all edges of SP (G) directed away from u [13] for every vertex x such that u fi x E (G) do [14] if length (u fi x) + dist (x) = dist <p> In particular, compare the test on line <ref> [10] </ref> of Figure 3 with the one on line [13] of Figure 1. <p> In contrast, the test on line <ref> [10] </ref> of Figure 3 must be performed by explicitly testing at least some of the successors of x to see whether the conditions SP (x, y, z) and y AffectedVertices hold. <p> increased). */ [4] /* Set AffectedVertices equal to AFFECTED. */ [5] WorkSet := - v - [6] while WorkSet do [7] Select and remove a vertex u from WorkSet [8] Insert vertex u into AffectedVertices [9] for each vertex x pred G (u) such that SP (x, u, z) do <ref> [10] </ref> if for all vertices y succ G (x) such that SP (x, y, z), y AffectedVertices then Insert vertex x into WorkSet fi [11] od [13] /* Phase 2: Determine new distances to z for all vertices in AffectedVertices. */ [14] PriorityQueue := [15] for each vertex a AffectedVertices do <p> from WorkSet [6] if length G (x fi y) + dist G (y,z) &lt; dist G (x,z) then [7] Insert x into AffectedVertices [8] dist G (x,z) := length G (x fi y) + dist G (y,z) [9] for every vertex u such that u fi x E (G) do <ref> [10] </ref> if SP (u,x,v) and u VisitedVertices then [11] Insert u fi x into WorkSet [12] Insert u into VisitedVertices [13] fi [15] fi end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh - 20 - traversal of this DAG, visiting only affected vertices or their predecessors. <p> u.value [4] loop [5] for every vertex v WorkSet in relative topological-sort order do recompute v.value od [6] if for all v InnerFringe, v.value = v.originalValue then exit loop fi [7] Choose some non-empty subset ToBeExpanded of InnerFringe [8] for every vertex v ToBeExpanded do [9] Remove v from InnerFringe <ref> [10] </ref> for every vertex w (succ (v) - WorkSet) do [11] Insert w into both WorkSet and InnerFringe [12] w.originalValue := w.value [13] od [15] end loop postconditions Every vertex in G is consistent end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh - 23 - Proposition 3.1. Procedure UpdateSchema computes a correct annotation of G. Proof. <p> for every vertex v WorkSet in relative topological-sort order do recompute v.value od [7] if for all v InnerFringe, v.value = v.originalValue then exit loop fi [8] Select and remove a vertex v from InnerFringe for which v.cost+v.outdegree is minimum [9] for every vertex w (succ (v) - WorkSet) do <ref> [10] </ref> Insert w into both WorkSet and InnerFringe [11] w.originalValue := w.value [12] w.cost := v.cost + v.outdegree [13] od [14] end loop postconditions Every vertex in G is consistent end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh Every vertex y in WorkSet hhhhhhh except u was added to WorkSet during the expansion of some vertex x.
Reference: 11. <author> Dionne, R., </author> <title> Etude et extension d'un algorithme de Murchland, </title> <note> INFOR 16(2) pp. </note> <month> 132-146 (June </month> <year> 1978). </year>
Reference-contexts: AFFECTED (the set of vertices whose shortest distance to sink (G) has increased). */ [5] /* Set AffectedVertices equal to AFFECTED. */ [6] WorkSet := - v - [7] AffectedVertices := [8] while WorkSet do [9] Select and remove a vertex u from WorkSet [10] Insert vertex u into AffectedVertices <ref> [11] </ref> for each vertex x such that x fi u SP (G) do [12] Remove edge x fi u from SP (G) [13] if there does not exist a vertex y such that x fi y SP (G) then Insert vertex x into WorkSet fi [14] od [16] /* Phase 2: <p> dist (v) then [5] dist (v) := length (v fi w) + dist (w) [6] Insert v into PriorityQueue with priority 0 [7] else if length (v fi w) + dist (w) = dist (v) then [8] Insert v fi w into SP (G) [9] fi [10] while PriorityQueue do <ref> [11] </ref> Select and remove a vertex u in PriorityQueue with minimum priority [12] Remove all edges of SP (G) directed away from u [13] for every vertex x such that u fi x E (G) do [14] if length (u fi x) + dist (x) = dist (u) then Insert u <p> a vertex u from WorkSet [8] Insert vertex u into AffectedVertices [9] for each vertex x pred G (u) such that SP (x, u, z) do [10] if for all vertices y succ G (x) such that SP (x, y, z), y AffectedVertices then Insert vertex x into WorkSet fi <ref> [11] </ref> od [13] /* Phase 2: Determine new distances to z for all vertices in AffectedVertices. */ [14] PriorityQueue := [15] for each vertex a AffectedVertices do [16] dist G (a, z) := min (- length G (a fi b) + dist G (b, z) | a fi b E (G) <p> y) + dist G (y,z) &lt; dist G (x,z) then [7] Insert x into AffectedVertices [8] dist G (x,z) := length G (x fi y) + dist G (y,z) [9] for every vertex u such that u fi x E (G) do [10] if SP (u,x,v) and u VisitedVertices then <ref> [11] </ref> Insert u fi x into WorkSet [12] Insert u into VisitedVertices [13] fi [15] fi end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh - 20 - traversal of this DAG, visiting only affected vertices or their predecessors. For instance, consider the edge x fi y selected in line [5] of Figure 5. <p> relative topological-sort order do recompute v.value od [6] if for all v InnerFringe, v.value = v.originalValue then exit loop fi [7] Choose some non-empty subset ToBeExpanded of InnerFringe [8] for every vertex v ToBeExpanded do [9] Remove v from InnerFringe [10] for every vertex w (succ (v) - WorkSet) do <ref> [11] </ref> Insert w into both WorkSet and InnerFringe [12] w.originalValue := w.value [13] od [15] end loop postconditions Every vertex in G is consistent end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh - 23 - Proposition 3.1. Procedure UpdateSchema computes a correct annotation of G. Proof. Consider the circuit as annotated when the procedure terminates. <p> order do recompute v.value od [7] if for all v InnerFringe, v.value = v.originalValue then exit loop fi [8] Select and remove a vertex v from InnerFringe for which v.cost+v.outdegree is minimum [9] for every vertex w (succ (v) - WorkSet) do [10] Insert w into both WorkSet and InnerFringe <ref> [11] </ref> w.originalValue := w.value [12] w.cost := v.cost + v.outdegree [13] od [14] end loop postconditions Every vertex in G is consistent end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh Every vertex y in WorkSet hhhhhhh except u was added to WorkSet during the expansion of some vertex x. <p> Previous Work on Incremental Shortest-Path Algorithms Section 3.2 of this paper presents a bounded incremental algorithm for the all-pairs shortest-path problem with positive edge weights (APSP&gt;0) (assuming the collection of vertices is fixed in advance). There have been three previous papers on APSP&gt;0by Dionne <ref> [11] </ref>, Rohnert [37], and Even and Gazit [14]in which the analysis might be misinterpreted, on first reading, as demonstrating that the algorithms are bounded. In fact, the algorithms given in all three papers have unbounded incremental complexity in general. <p> By contrast, in our algorithm for APSP&gt;0 all costs are bounded by || d || , including all costs for updating the data structures used by the algorithm. An updating method that is similar in spirit to our APSP&gt;0 algorithm from Section 3.2 was proposed by Dionne in 1978 <ref> [11] </ref>. <p> to update distances after the insertion or deletion of edge v fi w, it is useful to compute two sets N 1 and N 2 such that N 1 N 2 includes all ordered pairs (a, b) such that the length of the shortest path from a to b changes <ref> [11] </ref>. These sets are akin to the sets referred to as AffectedSources and AffectedSinks, respectively, in Figures 4 and 6. <p> case of edge insertion, although Dionne's method is able to identify the sets AffectedSources and AffectedSinks, the algorithm he gives to actually find these sets uses loops of the form: for each vertex k of the graph's vertex set do . . . od (see pages 136 and 143 of <ref> [11] </ref>), and hence his algorithm has complexity W ( | V (G) | ). Consequently, the algorithm's complexity is not bounded by any function of || d || i for any fixed value of i. In the case of edge deletion, Dionne's method overestimates AffectedSources and AffectedSinks. <p> In the case of edge deletion, Dionne's method overestimates AffectedSources and AffectedSinks. Furthermore, the algorithm he gives to find these sets again uses loops of the form: for each vertex k of the graph's vertex set do . . . od (see pages 139 and 145 of <ref> [11] </ref>), and hence his edge-deletion method also has complexity W ( | V (G) | ). In contrast, the procedures DeleteEdge APSP &gt;0 and InsertEdge APSP &gt;0 that we give in Section 3.2 can determine AffectedSources and AffectedSinks exactly. <p> Although the algorithms Dionne studies are unbounded, he reports that they have excellent performance. His experiments indicate speedups of between 40 and 250 for an edge-length reduction and between 7 and - 38 - 20 for an edge-length increase <ref> [11] </ref>. 13 In all cases, the speedup reported is with respect to the time required to recompute all distances from scratch using Floyd's shortest-path algorithm [15]. Lin and Chang have given a bounded incremental algorithm for APSP&gt;0 when the problem is restricted to the case of edge insertions only [22]. <p> evidence that his unbounded algorithm for the circuit-value problem performs well in practice [19]; Ryder, Landi, and Pande present evidence that the unbounded incremental data-flow analysis algorithm of Carroll and Ryder [7] performs well in practice [40]; as discussed earlier, Dionne reports excellent performance for some unbounded algorithms for APSP&gt;0 <ref> [11] </ref>. ACKNOWLEDGEMENTS We are grateful for the comments and helpful suggestions of Susan Horwitz, Alan Demers, and Tim Teitel-baum.
Reference: 12. <author> Edmonds, J. and Karp, </author> <title> R.M., Theoretical improvements in algorithmic efficiency for network flow problems, </title> <journal> J. </journal> <note> ACM 19 pp. 248-264 (1972). As cited in reference [45]. </note>
Reference-contexts: */ [5] /* Set AffectedVertices equal to AFFECTED. */ [6] WorkSet := - v - [7] AffectedVertices := [8] while WorkSet do [9] Select and remove a vertex u from WorkSet [10] Insert vertex u into AffectedVertices [11] for each vertex x such that x fi u SP (G) do <ref> [12] </ref> Remove edge x fi u from SP (G) [13] if there does not exist a vertex y such that x fi y SP (G) then Insert vertex x into WorkSet fi [14] od [16] /* Phase 2: Determine new distances to sink (G) for all vertices in AffectedVertices and update <p> Initially AffectedVertices is empty, and each iteration of the loop on lines [8]-[15] places an additional vertex with this property in AffectedVertices. After edge x fi u is removed from SP (G) on line <ref> [12] </ref>, the number of SP (G) edges out of x is then tested (see line [13]). If the number of such edges is zero then all shortest paths starting from x in the original graph immediately lead to vertices in AffectedVertices, and hence to edge v fi w. <p> If any such edge s fi t was formerly part of a shortest path from s to sink (G), s fi t is removed from SP (G) during Phase 1 of DeleteEdge SSSP &gt;0 (see line <ref> [12] </ref>). <p> dist (w) [6] Insert v into PriorityQueue with priority 0 [7] else if length (v fi w) + dist (w) = dist (v) then [8] Insert v fi w into SP (G) [9] fi [10] while PriorityQueue do [11] Select and remove a vertex u in PriorityQueue with minimum priority <ref> [12] </ref> Remove all edges of SP (G) directed away from u [13] for every vertex x such that u fi x E (G) do [14] if length (u fi x) + dist (x) = dist (u) then Insert u fi x into SP (G) fi [15] od [16] for every vertex <p> We can generalize DeleteEdge SSSP &gt;0 and InsertEdge SSSP &gt;0 to handle negative-length edges (as long as all cycles have net positive weight) by adapting the technique of Edmonds and Karp for transforming the length of every edge to a non-negative real without changing the graph's shortest paths <ref> [12, 45] </ref>. <p> G (x,z) then [7] Insert x into AffectedVertices [8] dist G (x,z) := length G (x fi y) + dist G (y,z) [9] for every vertex u such that u fi x E (G) do [10] if SP (u,x,v) and u VisitedVertices then [11] Insert u fi x into WorkSet <ref> [12] </ref> Insert u into VisitedVertices [13] fi [15] fi end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh - 20 - traversal of this DAG, visiting only affected vertices or their predecessors. For instance, consider the edge x fi y selected in line [5] of Figure 5. <p> if for all v InnerFringe, v.value = v.originalValue then exit loop fi [7] Choose some non-empty subset ToBeExpanded of InnerFringe [8] for every vertex v ToBeExpanded do [9] Remove v from InnerFringe [10] for every vertex w (succ (v) - WorkSet) do [11] Insert w into both WorkSet and InnerFringe <ref> [12] </ref> w.originalValue := w.value [13] od [15] end loop postconditions Every vertex in G is consistent end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh - 23 - Proposition 3.1. Procedure UpdateSchema computes a correct annotation of G. Proof. Consider the circuit as annotated when the procedure terminates. <p> od [7] if for all v InnerFringe, v.value = v.originalValue then exit loop fi [8] Select and remove a vertex v from InnerFringe for which v.cost+v.outdegree is minimum [9] for every vertex w (succ (v) - WorkSet) do [10] Insert w into both WorkSet and InnerFringe [11] w.originalValue := w.value <ref> [12] </ref> w.cost := v.cost + v.outdegree [13] od [14] end loop postconditions Every vertex in G is consistent end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh Every vertex y in WorkSet hhhhhhh except u was added to WorkSet during the expansion of some vertex x. Call x the parent of y, denoted by parent (y).
Reference: 13. <author> Even, S. and Shiloach, Y., </author> <title> An on-line edge-deletion problem, </title> <journal> J. ACM 28(1) pp. </journal> <month> 1-4 (January </month> <year> 1981). </year>
Reference-contexts: There are incremental problems for which the benefits mentioned above are realized. Examples include the results of Even and Shiloach <ref> [13] </ref>, Reif [29] and Ausiello et al. [2]. However, the question of amortized-cost analysis versus worst-case analysis is really orthogonal to the question studied in this paper. <p> [6] WorkSet := - v - [7] AffectedVertices := [8] while WorkSet do [9] Select and remove a vertex u from WorkSet [10] Insert vertex u into AffectedVertices [11] for each vertex x such that x fi u SP (G) do [12] Remove edge x fi u from SP (G) <ref> [13] </ref> if there does not exist a vertex y such that x fi y SP (G) then Insert vertex x into WorkSet fi [14] od [16] /* Phase 2: Determine new distances to sink (G) for all vertices in AffectedVertices and update SP (G). */ [17] PriorityQueue := [18] for each <p> Initially AffectedVertices is empty, and each iteration of the loop on lines [8]-[15] places an additional vertex with this property in AffectedVertices. After edge x fi u is removed from SP (G) on line [12], the number of SP (G) edges out of x is then tested (see line <ref> [13] </ref>). If the number of such edges is zero then all shortest paths starting from x in the original graph immediately lead to vertices in AffectedVertices, and hence to edge v fi w. <p> Because each vertex x that is a predecessor of u via an SP edge is not necessarily a member of AFFECTED, care must be taken with the implementation of the conditional statement on line <ref> [13] </ref>: if there does not exist a vertex y such that x fi y SP (G) then . . . fi Although vertex x is guaranteed to be a predecessor of a member of AFFECTED (and hence at most one step away from AFFECTED), all that can be said about vertex <p> However, by maintaining at each vertex x a count of the number of SP edges that emanate from x (i.e., | - x fi y | x fi y SP (G) - | ), it is possible to perform the test on line <ref> [13] </ref> in unit time. (Similarly, it is possible to perform the test on line [3] in unit time.) These counts must be adjusted whenever DeleteEdge SSSP &gt;0 or InsertEdge SSSP &gt;0 deletes an edge from SP (G) or inserts an edge into SP (G). <p> else if length (v fi w) + dist (w) = dist (v) then [8] Insert v fi w into SP (G) [9] fi [10] while PriorityQueue do [11] Select and remove a vertex u in PriorityQueue with minimum priority [12] Remove all edges of SP (G) directed away from u <ref> [13] </ref> for every vertex x such that u fi x E (G) do [14] if length (u fi x) + dist (x) = dist (u) then Insert u fi x into SP (G) fi [15] od [16] for every vertex x such that x fi u E (G) do [17] if <p> In particular, compare the test on line [10] of Figure 3 with the one on line <ref> [13] </ref> of Figure 1. <p> u from WorkSet [8] Insert vertex u into AffectedVertices [9] for each vertex x pred G (u) such that SP (x, u, z) do [10] if for all vertices y succ G (x) such that SP (x, y, z), y AffectedVertices then Insert vertex x into WorkSet fi [11] od <ref> [13] </ref> /* Phase 2: Determine new distances to z for all vertices in AffectedVertices. */ [14] PriorityQueue := [15] for each vertex a AffectedVertices do [16] dist G (a, z) := min (- length G (a fi b) + dist G (b, z) | a fi b E (G) and b <p> x into AffectedVertices [8] dist G (x,z) := length G (x fi y) + dist G (y,z) [9] for every vertex u such that u fi x E (G) do [10] if SP (u,x,v) and u VisitedVertices then [11] Insert u fi x into WorkSet [12] Insert u into VisitedVertices <ref> [13] </ref> fi [15] fi end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh - 20 - traversal of this DAG, visiting only affected vertices or their predecessors. For instance, consider the edge x fi y selected in line [5] of Figure 5. Vertex x is the vertex to be visited next during the traversal described above. <p> InnerFringe, v.value = v.originalValue then exit loop fi [7] Choose some non-empty subset ToBeExpanded of InnerFringe [8] for every vertex v ToBeExpanded do [9] Remove v from InnerFringe [10] for every vertex w (succ (v) - WorkSet) do [11] Insert w into both WorkSet and InnerFringe [12] w.originalValue := w.value <ref> [13] </ref> od [15] end loop postconditions Every vertex in G is consistent end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh - 23 - Proposition 3.1. Procedure UpdateSchema computes a correct annotation of G. Proof. Consider the circuit as annotated when the procedure terminates. <p> InnerFringe, v.value = v.originalValue then exit loop fi [8] Select and remove a vertex v from InnerFringe for which v.cost+v.outdegree is minimum [9] for every vertex w (succ (v) - WorkSet) do [10] Insert w into both WorkSet and InnerFringe [11] w.originalValue := w.value [12] w.cost := v.cost + v.outdegree <ref> [13] </ref> od [14] end loop postconditions Every vertex in G is consistent end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh Every vertex y in WorkSet hhhhhhh except u was added to WorkSet during the expansion of some vertex x. Call x the parent of y, denoted by parent (y).
Reference: 14. <author> Even, S. and Gazit, H., </author> <title> Updating distances in dynamic graphs, </title> <note> Methods of Operations Research 49 pp. </note> <month> 371-387 </month> <year> (1985). </year>
Reference-contexts: even been possible to show a lower-bound result for an incremental-computation problem (as opposed to an analysis of a particular incremental algorithm for a problem), demonstrating that in the worst-case no incremental algorithm for the problem can perform asymptotically better than the time required to perform the computation from scratch <ref> [3, 14, 43] </ref>. For these reasons, worst-case analysis (with costs expressed as a function of the size of the input) has not been of much help for making comparisons between different incremental algorithms. <p> Insert vertex u into AffectedVertices [11] for each vertex x such that x fi u SP (G) do [12] Remove edge x fi u from SP (G) [13] if there does not exist a vertex y such that x fi y SP (G) then Insert vertex x into WorkSet fi <ref> [14] </ref> od [16] /* Phase 2: Determine new distances to sink (G) for all vertices in AffectedVertices and update SP (G). */ [17] PriorityQueue := [18] for each vertex a AffectedVertices do [19] dist (a) := min (- length (a fi b) + dist (b) | a fi b E (G) <p> [8] Insert v fi w into SP (G) [9] fi [10] while PriorityQueue do [11] Select and remove a vertex u in PriorityQueue with minimum priority [12] Remove all edges of SP (G) directed away from u [13] for every vertex x such that u fi x E (G) do <ref> [14] </ref> if length (u fi x) + dist (x) = dist (u) then Insert u fi x into SP (G) fi [15] od [16] for every vertex x such that x fi u E (G) do [17] if length (x fi u) + dist (u) &lt; dist (x) then [18] dist <p> G (u) such that SP (x, u, z) do [10] if for all vertices y succ G (x) such that SP (x, y, z), y AffectedVertices then Insert vertex x into WorkSet fi [11] od [13] /* Phase 2: Determine new distances to z for all vertices in AffectedVertices. */ <ref> [14] </ref> PriorityQueue := [15] for each vertex a AffectedVertices do [16] dist G (a, z) := min (- length G (a fi b) + dist G (b, z) | a fi b E (G) and b (V (G) - AffectedVertices) - - -) [17] if dist G (a, z) then Insert <p> = v.originalValue then exit loop fi [8] Select and remove a vertex v from InnerFringe for which v.cost+v.outdegree is minimum [9] for every vertex w (succ (v) - WorkSet) do [10] Insert w into both WorkSet and InnerFringe [11] w.originalValue := w.value [12] w.cost := v.cost + v.outdegree [13] od <ref> [14] </ref> end loop postconditions Every vertex in G is consistent end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh Every vertex y in WorkSet hhhhhhh except u was added to WorkSet during the expansion of some vertex x. Call x the parent of y, denoted by parent (y). <p> the modified graph is immediate: dist (sink (G)) = 0, dist (v ) = k/3, and for hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 10 The arguments that Berman, Paull, and Ryder use to establish relative lower bounds for various problems are similar to the ones used by Spira and Pan [43] and Even and Gazit <ref> [14] </ref> to establish that no incremental algorithm for the all-pairs single-source shortest-path problem can do better in the worst case than the best batch algorithm for the problem. - 35 - each vertex w V - v, sink (G) -, dist (w) = 2k /3 (since the shortest path from each
Reference: 15. <author> Floyd, R.W., </author> <title> Algorithm 97: shortest path, </title> <journal> Commun. </journal> <note> of the ACM 5 p. 345 (1962). </note>
Reference-contexts: in PriorityQueue with minimum priority [12] Remove all edges of SP (G) directed away from u [13] for every vertex x such that u fi x E (G) do [14] if length (u fi x) + dist (x) = dist (u) then Insert u fi x into SP (G) fi <ref> [15] </ref> od [16] for every vertex x such that x fi u E (G) do [17] if length (x fi u) + dist (u) &lt; dist (x) then [18] dist (x) := length (x fi u) + dist (u) [19] if x PriorityQueue then [20] Decrease the priority of x in <p> that SP (x, u, z) do [10] if for all vertices y succ G (x) such that SP (x, y, z), y AffectedVertices then Insert vertex x into WorkSet fi [11] od [13] /* Phase 2: Determine new distances to z for all vertices in AffectedVertices. */ [14] PriorityQueue := <ref> [15] </ref> for each vertex a AffectedVertices do [16] dist G (a, z) := min (- length G (a fi b) + dist G (b, z) | a fi b E (G) and b (V (G) - AffectedVertices) - - -) [17] if dist G (a, z) then Insert a into PriorityQueue <p> AffectedVertices [8] dist G (x,z) := length G (x fi y) + dist G (y,z) [9] for every vertex u such that u fi x E (G) do [10] if SP (u,x,v) and u VisitedVertices then [11] Insert u fi x into WorkSet [12] Insert u into VisitedVertices [13] fi <ref> [15] </ref> fi end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh - 20 - traversal of this DAG, visiting only affected vertices or their predecessors. For instance, consider the edge x fi y selected in line [5] of Figure 5. Vertex x is the vertex to be visited next during the traversal described above. <p> = v.originalValue then exit loop fi [7] Choose some non-empty subset ToBeExpanded of InnerFringe [8] for every vertex v ToBeExpanded do [9] Remove v from InnerFringe [10] for every vertex w (succ (v) - WorkSet) do [11] Insert w into both WorkSet and InnerFringe [12] w.originalValue := w.value [13] od <ref> [15] </ref> end loop postconditions Every vertex in G is consistent end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh - 23 - Proposition 3.1. Procedure UpdateSchema computes a correct annotation of G. Proof. Consider the circuit as annotated when the procedure terminates. <p> His experiments indicate speedups of between 40 and 250 for an edge-length reduction and between 7 and - 38 - 20 for an edge-length increase [11]. 13 In all cases, the speedup reported is with respect to the time required to recompute all distances from scratch using Floyd's shortest-path algorithm <ref> [15] </ref>. Lin and Chang have given a bounded incremental algorithm for APSP&gt;0 when the problem is restricted to the case of edge insertions only [22].
Reference: 16. <author> Gurevich, Y. and Shelah, S., </author> <title> Time polynomial in input or output, </title> <journal> J. Symbolic Logic 54(3) pp. </journal> <month> 1083-1088 (September </month> <year> 1989). </year>
Reference-contexts: u into AffectedVertices [11] for each vertex x such that x fi u SP (G) do [12] Remove edge x fi u from SP (G) [13] if there does not exist a vertex y such that x fi y SP (G) then Insert vertex x into WorkSet fi [14] od <ref> [16] </ref> /* Phase 2: Determine new distances to sink (G) for all vertices in AffectedVertices and update SP (G). */ [17] PriorityQueue := [18] for each vertex a AffectedVertices do [19] dist (a) := min (- length (a fi b) + dist (b) | a fi b E (G) and b <p> with minimum priority [12] Remove all edges of SP (G) directed away from u [13] for every vertex x such that u fi x E (G) do [14] if length (u fi x) + dist (x) = dist (u) then Insert u fi x into SP (G) fi [15] od <ref> [16] </ref> for every vertex x such that x fi u E (G) do [17] if length (x fi u) + dist (u) &lt; dist (x) then [18] dist (x) := length (x fi u) + dist (u) [19] if x PriorityQueue then [20] Decrease the priority of x in PriorityQueue to <p> if for all vertices y succ G (x) such that SP (x, y, z), y AffectedVertices then Insert vertex x into WorkSet fi [11] od [13] /* Phase 2: Determine new distances to z for all vertices in AffectedVertices. */ [14] PriorityQueue := [15] for each vertex a AffectedVertices do <ref> [16] </ref> dist G (a, z) := min (- length G (a fi b) + dist G (b, z) | a fi b E (G) and b (V (G) - AffectedVertices) - - -) [17] if dist G (a, z) then Insert a into PriorityQueue with priority dist G (a, z) fi <p> Other Related Work For batch algorithms, the concept of measuring the complexity of an algorithm in terms of the sum of the sizes of the input and the output has been explored by Cai and Paige [5, 6] and by Gurevitch and Shelah <ref> [16] </ref>. In this paper, we measure the complexity of an incremental algorithm in terms of the sum of the sizes of the changes in the input and the output.
Reference: 17. <author> Halder, </author> <title> A.K., The method of competing links, </title> <note> Transportation Science 4 pp. </note> <month> 36-51 </month> <year> (1970). </year>
Reference-contexts: fi u from SP (G) [13] if there does not exist a vertex y such that x fi y SP (G) then Insert vertex x into WorkSet fi [14] od [16] /* Phase 2: Determine new distances to sink (G) for all vertices in AffectedVertices and update SP (G). */ <ref> [17] </ref> PriorityQueue := [18] for each vertex a AffectedVertices do [19] dist (a) := min (- length (a fi b) + dist (b) | a fi b E (G) and b (V (G) - AffectedVertices) - - -) [20] if dist (a) then Insert a into PriorityQueue with priority dist (a) <p> u [13] for every vertex x such that u fi x E (G) do [14] if length (u fi x) + dist (x) = dist (u) then Insert u fi x into SP (G) fi [15] od [16] for every vertex x such that x fi u E (G) do <ref> [17] </ref> if length (x fi u) + dist (u) &lt; dist (x) then [18] dist (x) := length (x fi u) + dist (u) [19] if x PriorityQueue then [20] Decrease the priority of x in PriorityQueue to dist (x) - dist (v) [21] else [22] Insert x into PriorityQueue with <p> z for all vertices in AffectedVertices. */ [14] PriorityQueue := [15] for each vertex a AffectedVertices do [16] dist G (a, z) := min (- length G (a fi b) + dist G (b, z) | a fi b E (G) and b (V (G) - AffectedVertices) - - -) <ref> [17] </ref> if dist G (a, z) then Insert a into PriorityQueue with priority dist G (a, z) fi [18] od [19] while PriorityQueue do [20] Select and remove from PriorityQueue a vertex a with minimum priority value [21] for every vertex c such that c fi a E (G) and length <p> Our procedures DeleteEdge APSP &gt;0 and InsertEdge APSP &gt;0 can be generalized to maintain one shortest path between any pair of vertices without increasing their asymptotic time complexity. Other previous work on how to maintain shortest paths in graphs incrementally includes papers by Halder <ref> [17] </ref>, Pape [26], Spira and Pan [43], Cheston [8], Cheston and Corneil [9], and Ausiello et al. [2]; however, none of the papers in this group analyze either the single-source or the all-pairs problem in terms of the parameter || d || , and furthermore, none of the algorithms presented in
Reference: 18. <author> Henderson, P. and Weiser, M., </author> <title> Continuous execution: The Visiprog environment, </title> <booktitle> in Proceedings of the Eighth International Conference on Software Engineering, </booktitle> <year> (1985). </year>
Reference-contexts: 1. INTRODUCTION Many kinds of interactive systems developed in the last fifteen years, such as word processors, electronic spreadsheets, language-based program editors, and systems for computer-aided design, are examples of what has been called the continuous-execution <ref> [18] </ref> or immediate-computation [34] paradigm. In a system that follows the immediate-computation paradigm, the application program and the editing function are closely coupled. Each modification to a datum is processed by the application and has essentially instantaneous effect. <p> SP (G) [13] if there does not exist a vertex y such that x fi y SP (G) then Insert vertex x into WorkSet fi [14] od [16] /* Phase 2: Determine new distances to sink (G) for all vertices in AffectedVertices and update SP (G). */ [17] PriorityQueue := <ref> [18] </ref> for each vertex a AffectedVertices do [19] dist (a) := min (- length (a fi b) + dist (b) | a fi b E (G) and b (V (G) - AffectedVertices) - - -) [20] if dist (a) then Insert a into PriorityQueue with priority dist (a) fi [21] od <p> do [14] if length (u fi x) + dist (x) = dist (u) then Insert u fi x into SP (G) fi [15] od [16] for every vertex x such that x fi u E (G) do [17] if length (x fi u) + dist (u) &lt; dist (x) then <ref> [18] </ref> dist (x) := length (x fi u) + dist (u) [19] if x PriorityQueue then [20] Decrease the priority of x in PriorityQueue to dist (x) - dist (v) [21] else [22] Insert x into PriorityQueue with priority dist (x) - dist (v) [23] fi [24] else if length (x <p> dist G (a, z) := min (- length G (a fi b) + dist G (b, z) | a fi b E (G) and b (V (G) - AffectedVertices) - - -) [17] if dist G (a, z) then Insert a into PriorityQueue with priority dist G (a, z) fi <ref> [18] </ref> od [19] while PriorityQueue do [20] Select and remove from PriorityQueue a vertex a with minimum priority value [21] for every vertex c such that c fi a E (G) and length G (c fi a) + dist G (a, z) &lt; dist G (c, z) do [22] dist G
Reference: 19. <author> Hoover, R., </author> <title> Incremental graph evaluation, </title> <type> Ph.D. dissertation and Tech. Rep. 87-836, </type> <institution> Dept. of Computer Science, Cornell University, </institution> <address> Ithaca, NY (May 1987). </address>
Reference-contexts: informative; when the cost of the computation is expressed as a function of the size of the (current) input (i.e., | x | ), many incremental algorithms that have been proposed run in time asymptotically no better, in the worst-case, than the time required to perform the computation from scratch <ref> [7, 8, 19, 24, 48] </ref>. <p> exist a vertex y such that x fi y SP (G) then Insert vertex x into WorkSet fi [14] od [16] /* Phase 2: Determine new distances to sink (G) for all vertices in AffectedVertices and update SP (G). */ [17] PriorityQueue := [18] for each vertex a AffectedVertices do <ref> [19] </ref> dist (a) := min (- length (a fi b) + dist (b) | a fi b E (G) and b (V (G) - AffectedVertices) - - -) [20] if dist (a) then Insert a into PriorityQueue with priority dist (a) fi [21] od [22] while PriorityQueue do [23] Select and <p> dist (u) then Insert u fi x into SP (G) fi [15] od [16] for every vertex x such that x fi u E (G) do [17] if length (x fi u) + dist (u) &lt; dist (x) then [18] dist (x) := length (x fi u) + dist (u) <ref> [19] </ref> if x PriorityQueue then [20] Decrease the priority of x in PriorityQueue to dist (x) - dist (v) [21] else [22] Insert x into PriorityQueue with priority dist (x) - dist (v) [23] fi [24] else if length (x fi u) + dist (u) = dist (x) then [25] Insert <p> (a, z) := min (- length G (a fi b) + dist G (b, z) | a fi b E (G) and b (V (G) - AffectedVertices) - - -) [17] if dist G (a, z) then Insert a into PriorityQueue with priority dist G (a, z) fi [18] od <ref> [19] </ref> while PriorityQueue do [20] Select and remove from PriorityQueue a vertex a with minimum priority value [21] for every vertex c such that c fi a E (G) and length G (c fi a) + dist G (a, z) &lt; dist G (c, z) do [22] dist G (c, z) <p> For instance, Hoover presents evidence that his unbounded algorithm for the circuit-value problem performs well in practice <ref> [19] </ref>; Ryder, Landi, and Pande present evidence that the unbounded incremental data-flow analysis algorithm of Carroll and Ryder [7] performs well in practice [40]; as discussed earlier, Dionne reports excellent performance for some unbounded algorithms for APSP&gt;0 [11].
Reference: 20. <author> Horwitz, S. and Teitelbaum, T., </author> <title> Generating editing environments based on relations and attributes, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 8(4) pp. </pages> <month> 577-608 (October </month> <year> 1986). </year>
Reference-contexts: sink (G) for all vertices in AffectedVertices and update SP (G). */ [17] PriorityQueue := [18] for each vertex a AffectedVertices do [19] dist (a) := min (- length (a fi b) + dist (b) | a fi b E (G) and b (V (G) - AffectedVertices) - - -) <ref> [20] </ref> if dist (a) then Insert a into PriorityQueue with priority dist (a) fi [21] od [22] while PriorityQueue do [23] Select and remove from PriorityQueue a vertex a with minimum priority value [24] for every vertex b such that a fi b E (G) and length (a fi b) + <p> fi x into SP (G) fi [15] od [16] for every vertex x such that x fi u E (G) do [17] if length (x fi u) + dist (u) &lt; dist (x) then [18] dist (x) := length (x fi u) + dist (u) [19] if x PriorityQueue then <ref> [20] </ref> Decrease the priority of x in PriorityQueue to dist (x) - dist (v) [21] else [22] Insert x into PriorityQueue with priority dist (x) - dist (v) [23] fi [24] else if length (x fi u) + dist (u) = dist (x) then [25] Insert x fi u into SP <p> (- length G (a fi b) + dist G (b, z) | a fi b E (G) and b (V (G) - AffectedVertices) - - -) [17] if dist G (a, z) then Insert a into PriorityQueue with priority dist G (a, z) fi [18] od [19] while PriorityQueue do <ref> [20] </ref> Select and remove from PriorityQueue a vertex a with minimum priority value [21] for every vertex c such that c fi a E (G) and length G (c fi a) + dist G (a, z) &lt; dist G (c, z) do [22] dist G (c, z) := length G (c <p> There has been a variety of work carried out on the problem of taking a high-level specification of a computation to be performed and creating an incremental evaluator that maintains the result value of the computation as inputs to the computation are varied <ref> [20, 21, 27, 42, 44, 47] </ref>. From the standpoint of computational complexity, the most interesting result from this group of papers is the technique that Pugh developed for supporting incremental computation using function caching [28] (see also [27]).
Reference: 21. <author> Koenig, S. and Paige, R., </author> <title> A transformational framework for the automatic control of derived data, pp. </title> <booktitle> 306-318 in Proceedings of the Seventh International Conference on Very Large Data Bases, </booktitle> <address> (Cannes, France, </address> <month> September </month> <year> 1981), (1981). </year>
Reference-contexts: := [18] for each vertex a AffectedVertices do [19] dist (a) := min (- length (a fi b) + dist (b) | a fi b E (G) and b (V (G) - AffectedVertices) - - -) [20] if dist (a) then Insert a into PriorityQueue with priority dist (a) fi <ref> [21] </ref> od [22] while PriorityQueue do [23] Select and remove from PriorityQueue a vertex a with minimum priority value [24] for every vertex b such that a fi b E (G) and length (a fi b) + dist (b) = dist (a) do [25] Insert edge a fi b into SP <p> that x fi u E (G) do [17] if length (x fi u) + dist (u) &lt; dist (x) then [18] dist (x) := length (x fi u) + dist (u) [19] if x PriorityQueue then [20] Decrease the priority of x in PriorityQueue to dist (x) - dist (v) <ref> [21] </ref> else [22] Insert x into PriorityQueue with priority dist (x) - dist (v) [23] fi [24] else if length (x fi u) + dist (u) = dist (x) then [25] Insert x fi u into SP (G) [26] fi [28] od postconditions v fi w E (G) length (v fi <p> fi b E (G) and b (V (G) - AffectedVertices) - - -) [17] if dist G (a, z) then Insert a into PriorityQueue with priority dist G (a, z) fi [18] od [19] while PriorityQueue do [20] Select and remove from PriorityQueue a vertex a with minimum priority value <ref> [21] </ref> for every vertex c such that c fi a E (G) and length G (c fi a) + dist G (a, z) &lt; dist G (c, z) do [22] dist G (c, z) := length G (c fi a) + dist G (a, z) [23] if c PriorityQueue then Decrease <p> There has been a variety of work carried out on the problem of taking a high-level specification of a computation to be performed and creating an incremental evaluator that maintains the result value of the computation as inputs to the computation are varied <ref> [20, 21, 27, 42, 44, 47] </ref>. From the standpoint of computational complexity, the most interesting result from this group of papers is the technique that Pugh developed for supporting incremental computation using function caching [28] (see also [27]).
Reference: 22. <author> Lin, C.-C. and Chang, R.-C., </author> <title> On the dynamic shortest path problem, </title> <journal> Journal of Information Processing 13(4)(1990). </journal>
Reference-contexts: for each vertex a AffectedVertices do [19] dist (a) := min (- length (a fi b) + dist (b) | a fi b E (G) and b (V (G) - AffectedVertices) - - -) [20] if dist (a) then Insert a into PriorityQueue with priority dist (a) fi [21] od <ref> [22] </ref> while PriorityQueue do [23] Select and remove from PriorityQueue a vertex a with minimum priority value [24] for every vertex b such that a fi b E (G) and length (a fi b) + dist (b) = dist (a) do [25] Insert edge a fi b into SP (G) [26] <p> fi u E (G) do [17] if length (x fi u) + dist (u) &lt; dist (x) then [18] dist (x) := length (x fi u) + dist (u) [19] if x PriorityQueue then [20] Decrease the priority of x in PriorityQueue to dist (x) - dist (v) [21] else <ref> [22] </ref> Insert x into PriorityQueue with priority dist (x) - dist (v) [23] fi [24] else if length (x fi u) + dist (u) = dist (x) then [25] Insert x fi u into SP (G) [26] fi [28] od postconditions v fi w E (G) length (v fi w) = <p> z) fi [18] od [19] while PriorityQueue do [20] Select and remove from PriorityQueue a vertex a with minimum priority value [21] for every vertex c such that c fi a E (G) and length G (c fi a) + dist G (a, z) &lt; dist G (c, z) do <ref> [22] </ref> dist G (c, z) := length G (c fi a) + dist G (a, z) [23] if c PriorityQueue then Decrease the priority of c in PriorityQueue to dist G (c, z) [24] else Insert c into PriorityQueue with priority dist G (c, z) [25] fi [27] od end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh <p> Lin and Chang have given a bounded incremental algorithm for APSP&gt;0 when the problem is restricted to the case of edge insertions only <ref> [22] </ref>. The algorithm they give uses an auxiliary procedure that is very similar to InsertUpdate; they employ a different method for determining the sinks for which calls must be made on InsertUpdate. The total cost of their edge-insertion procedure is linear in || d || 1 . <p> The only bounded incremental algorithm that has been given previously is the algorithm of Lin and Chang for the special case of APSP&gt;0 restricted to edge insertions only <ref> [22] </ref>. 6.4. Other Related Work For batch algorithms, the concept of measuring the complexity of an algorithm in terms of the sum of the sizes of the input and the output has been explored by Cai and Paige [5, 6] and by Gurevitch and Shelah [16].
Reference: 23. <author> Marlowe, T.J., </author> <title> Data flow analysis and incremental iteration, </title> <type> Ph.D. dissertation and Tech. Rep. </type> <institution> DCS-TR-255, Rutgers University, </institution> <address> New Brunswick, NJ (October 1989). </address>
Reference-contexts: AffectedVertices do [19] dist (a) := min (- length (a fi b) + dist (b) | a fi b E (G) and b (V (G) - AffectedVertices) - - -) [20] if dist (a) then Insert a into PriorityQueue with priority dist (a) fi [21] od [22] while PriorityQueue do <ref> [23] </ref> Select and remove from PriorityQueue a vertex a with minimum priority value [24] for every vertex b such that a fi b E (G) and length (a fi b) + dist (b) = dist (a) do [25] Insert edge a fi b into SP (G) [26] od [27] for every <p> dist (u) &lt; dist (x) then [18] dist (x) := length (x fi u) + dist (u) [19] if x PriorityQueue then [20] Decrease the priority of x in PriorityQueue to dist (x) - dist (v) [21] else [22] Insert x into PriorityQueue with priority dist (x) - dist (v) <ref> [23] </ref> fi [24] else if length (x fi u) + dist (u) = dist (x) then [25] Insert x fi u into SP (G) [26] fi [28] od postconditions v fi w E (G) length (v fi w) = c SP (G) consists of all edges in E (G) on shortest <p> a with minimum priority value [21] for every vertex c such that c fi a E (G) and length G (c fi a) + dist G (a, z) &lt; dist G (c, z) do [22] dist G (c, z) := length G (c fi a) + dist G (a, z) <ref> [23] </ref> if c PriorityQueue then Decrease the priority of c in PriorityQueue to dist G (c, z) [24] else Insert c into PriorityQueue with priority dist G (c, z) [25] fi [27] od end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh function of || d || 1 , unlike the cost of procedure DeleteEdge SSSP &gt;0 from <p> Some data-flow analysis algorithms also assume that the data-flow graph is a reducible one. With either of these restrictions on input instances, the above reduction of SS-REACHABILITY to problem P is no longer valid. However, we follow Marlowe <ref> [23] </ref>, who argued that these assumptions should be dropped for studies of incremental data-flow analysis (see Section 3.3.1 of [23]). The second possible restriction on input instances relates to the mapping M. <p> With either of these restrictions on input instances, the above reduction of SS-REACHABILITY to problem P is no longer valid. However, we follow Marlowe <ref> [23] </ref>, who argued that these assumptions should be dropped for studies of incremental data-flow analysis (see Section 3.3.1 of [23]). The second possible restriction on input instances relates to the mapping M. Is it possible that realistic flow-graphs will never have a labeling corresponding to the difficult input instances shown to exist above? We argue below that this is not so. <p> A number of papers in the literature on incremental algorithms concern incremental data-flow analysis <ref> [7, 23, 24, 38, 39, 48] </ref>.
Reference: 24. <author> Marlowe, T.J. and Ryder, B.G., </author> <title> An efficient hybrid algorithm for incremental data flow analysis, pp. </title> <booktitle> 184-196 in Conference Record of the Seventeenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (San Francisco, CA, </address> <month> Jan. </month> <pages> 17-19, </pages> <address> 1990), </address> <publisher> ACM, </publisher> <address> New York, NY (1990). </address>
Reference-contexts: informative; when the cost of the computation is expressed as a function of the size of the (current) input (i.e., | x | ), many incremental algorithms that have been proposed run in time asymptotically no better, in the worst-case, than the time required to perform the computation from scratch <ref> [7, 8, 19, 24, 48] </ref>. <p> dist (b) | a fi b E (G) and b (V (G) - AffectedVertices) - - -) [20] if dist (a) then Insert a into PriorityQueue with priority dist (a) fi [21] od [22] while PriorityQueue do [23] Select and remove from PriorityQueue a vertex a with minimum priority value <ref> [24] </ref> for every vertex b such that a fi b E (G) and length (a fi b) + dist (b) = dist (a) do [25] Insert edge a fi b into SP (G) [26] od [27] for every vertex c such that c fi a E (G) and length (c fi <p> &lt; dist (x) then [18] dist (x) := length (x fi u) + dist (u) [19] if x PriorityQueue then [20] Decrease the priority of x in PriorityQueue to dist (x) - dist (v) [21] else [22] Insert x into PriorityQueue with priority dist (x) - dist (v) [23] fi <ref> [24] </ref> else if length (x fi u) + dist (u) = dist (x) then [25] Insert x fi u into SP (G) [26] fi [28] od postconditions v fi w E (G) length (v fi w) = c SP (G) consists of all edges in E (G) on shortest paths to <p> and length G (c fi a) + dist G (a, z) &lt; dist G (c, z) do [22] dist G (c, z) := length G (c fi a) + dist G (a, z) [23] if c PriorityQueue then Decrease the priority of c in PriorityQueue to dist G (c, z) <ref> [24] </ref> else Insert c into PriorityQueue with priority dist G (c, z) [25] fi [27] od end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh function of || d || 1 , unlike the cost of procedure DeleteEdge SSSP &gt;0 from Figure 1 7 ). <p> A number of papers in the literature on incremental algorithms concern incremental data-flow analysis <ref> [7, 23, 24, 38, 39, 48] </ref>.
Reference: 25. <author> Murchland, J.D., </author> <title> A fixed matrix method for all shortest distances in a directed graph and for the inverse problem, </title> <type> Doctoral dissertation, </type> <institution> Universita .. t Karlsruhe, Karlsruhe, </institution> <note> Germany (). As cited in reference [11]. </note>
Reference-contexts: into PriorityQueue with priority dist (a) fi [21] od [22] while PriorityQueue do [23] Select and remove from PriorityQueue a vertex a with minimum priority value [24] for every vertex b such that a fi b E (G) and length (a fi b) + dist (b) = dist (a) do <ref> [25] </ref> Insert edge a fi b into SP (G) [26] od [27] for every vertex c such that c fi a E (G) and length (c fi a) + dist (a) &lt; dist (c) do [28] dist (c) := length (c fi a) + dist (a) [29] if c PriorityQueue then <p> (u) [19] if x PriorityQueue then [20] Decrease the priority of x in PriorityQueue to dist (x) - dist (v) [21] else [22] Insert x into PriorityQueue with priority dist (x) - dist (v) [23] fi [24] else if length (x fi u) + dist (u) = dist (x) then <ref> [25] </ref> Insert x fi u into SP (G) [26] fi [28] od postconditions v fi w E (G) length (v fi w) = c SP (G) consists of all edges in E (G) on shortest paths to sink (G) " v V (G), dist (v) is length of the shortest path <p> dist G (c, z) do [22] dist G (c, z) := length G (c fi a) + dist G (a, z) [23] if c PriorityQueue then Decrease the priority of c in PriorityQueue to dist G (c, z) [24] else Insert c into PriorityQueue with priority dist G (c, z) <ref> [25] </ref> fi [27] od end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh function of || d || 1 , unlike the cost of procedure DeleteEdge SSSP &gt;0 from Figure 1 7 ). <p> Dionne studies both the symmetric and asymmetric cases of the all-pairs problem. (In the symmetric case, length (i, j) = length (j, i) for all vertices i and j.) Dionne cites Murchland as the source of the algorithm he studies for the asymmetric case <ref> [25] </ref> and Boyce, Farhi, and Weischedel as originators of a similar algorithm to his for the symmetric case [4].
Reference: 26. <editor> Pape, U., Netzwerk-veraenderungen und korrektur kuerzester weglaengen von einer wurzelmenge zu allen anderen knoten, </editor> <booktitle> Computing 12 pp. </booktitle> <month> 357-362 </month> <year> (1974). </year>
Reference-contexts: [22] while PriorityQueue do [23] Select and remove from PriorityQueue a vertex a with minimum priority value [24] for every vertex b such that a fi b E (G) and length (a fi b) + dist (b) = dist (a) do [25] Insert edge a fi b into SP (G) <ref> [26] </ref> od [27] for every vertex c such that c fi a E (G) and length (c fi a) + dist (a) &lt; dist (c) do [28] dist (c) := length (c fi a) + dist (a) [29] if c PriorityQueue then Decrease the priority of c in PriorityQueue to dist <p> the priority of x in PriorityQueue to dist (x) - dist (v) [21] else [22] Insert x into PriorityQueue with priority dist (x) - dist (v) [23] fi [24] else if length (x fi u) + dist (u) = dist (x) then [25] Insert x fi u into SP (G) <ref> [26] </ref> fi [28] od postconditions v fi w E (G) length (v fi w) = c SP (G) consists of all edges in E (G) on shortest paths to sink (G) " v V (G), dist (v) is length of the shortest path from v to sink (G) end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh length <p> Our procedures DeleteEdge APSP &gt;0 and InsertEdge APSP &gt;0 can be generalized to maintain one shortest path between any pair of vertices without increasing their asymptotic time complexity. Other previous work on how to maintain shortest paths in graphs incrementally includes papers by Halder [17], Pape <ref> [26] </ref>, Spira and Pan [43], Cheston [8], Cheston and Corneil [9], and Ausiello et al. [2]; however, none of the papers in this group analyze either the single-source or the all-pairs problem in terms of the parameter || d || , and furthermore, none of the algorithms presented in these papers
Reference: 27. <author> Pugh, W. and Teitelbaum, T., </author> <title> Incremental computation via function caching, pp. </title> <booktitle> 315-328 in Conference Record of the Sixteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Austin, TX, </address> <month> Jan. </month> <pages> 11-13, </pages> <address> 1989), </address> <publisher> ACM, </publisher> <address> New York, NY (1989). </address>
Reference-contexts: PriorityQueue do [23] Select and remove from PriorityQueue a vertex a with minimum priority value [24] for every vertex b such that a fi b E (G) and length (a fi b) + dist (b) = dist (a) do [25] Insert edge a fi b into SP (G) [26] od <ref> [27] </ref> for every vertex c such that c fi a E (G) and length (c fi a) + dist (a) &lt; dist (c) do [28] dist (c) := length (c fi a) + dist (a) [29] if c PriorityQueue then Decrease the priority of c in PriorityQueue to dist (c) [30] <p> (c, z) do [22] dist G (c, z) := length G (c fi a) + dist G (a, z) [23] if c PriorityQueue then Decrease the priority of c in PriorityQueue to dist G (c, z) [24] else Insert c into PriorityQueue with priority dist G (c, z) [25] fi <ref> [27] </ref> od end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh function of || d || 1 , unlike the cost of procedure DeleteEdge SSSP &gt;0 from Figure 1 7 ). <p> There has been a variety of work carried out on the problem of taking a high-level specification of a computation to be performed and creating an incremental evaluator that maintains the result value of the computation as inputs to the computation are varied <ref> [20, 21, 27, 42, 44, 47] </ref>. From the standpoint of computational complexity, the most interesting result from this group of papers is the technique that Pugh developed for supporting incremental computation using function caching [28] (see also [27]). <p> From the standpoint of computational complexity, the most interesting result from this group of papers is the technique that Pugh developed for supporting incremental computation using function caching [28] (see also <ref> [27] </ref>). Pugh's work is based on the notion of a stable decomposition of a data structure; for example, he developed a clever representation of sets in which each set iswith high probabilityrepresented by a balanced tree.
Reference: 28. <author> Pugh, </author> <title> W.W., Incremental computation and the incremental evaluation of functional programs, </title> <type> Ph.D. dissertation and Tech. Rep. 88-936, </type> <institution> Dept. of Computer Science, Cornell University, </institution> <address> Ithaca, NY (August 1988). </address>
Reference-contexts: b E (G) and length (a fi b) + dist (b) = dist (a) do [25] Insert edge a fi b into SP (G) [26] od [27] for every vertex c such that c fi a E (G) and length (c fi a) + dist (a) &lt; dist (c) do <ref> [28] </ref> dist (c) := length (c fi a) + dist (a) [29] if c PriorityQueue then Decrease the priority of c in PriorityQueue to dist (c) [30] else Insert c into PriorityQueue with priority dist (c) [31] fi [33] od [35] else Remove edge v fi w from E (G) [36] <p> of x in PriorityQueue to dist (x) - dist (v) [21] else [22] Insert x into PriorityQueue with priority dist (x) - dist (v) [23] fi [24] else if length (x fi u) + dist (u) = dist (x) then [25] Insert x fi u into SP (G) [26] fi <ref> [28] </ref> od postconditions v fi w E (G) length (v fi w) = c SP (G) consists of all edges in E (G) on shortest paths to sink (G) " v V (G), dist (v) is length of the shortest path from v to sink (G) end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh length (v fi <p> From the standpoint of computational complexity, the most interesting result from this group of papers is the technique that Pugh developed for supporting incremental computation using function caching <ref> [28] </ref> (see also [27]). Pugh's work is based on the notion of a stable decomposition of a data structure; for example, he developed a clever representation of sets in which each set iswith high probabilityrepresented by a balanced tree.
Reference: 29. <author> Reif, J.H., </author> <title> A topological approach to dynamic graph connectivity, </title> <note> Information Processing Letters 25(1) pp. </note> <month> 65-70 </month> <year> (1987). </year>
Reference-contexts: There are incremental problems for which the benefits mentioned above are realized. Examples include the results of Even and Shiloach [13], Reif <ref> [29] </ref> and Ausiello et al. [2]. However, the question of amortized-cost analysis versus worst-case analysis is really orthogonal to the question studied in this paper. <p> The problem of classifying incremental problems has also been addressed by Reif <ref> [29] </ref> and Berman, Paull, and Ryder [3]. <p> = dist (a) do [25] Insert edge a fi b into SP (G) [26] od [27] for every vertex c such that c fi a E (G) and length (c fi a) + dist (a) &lt; dist (c) do [28] dist (c) := length (c fi a) + dist (a) <ref> [29] </ref> if c PriorityQueue then Decrease the priority of c in PriorityQueue to dist (c) [30] else Insert c into PriorityQueue with priority dist (c) [31] fi [33] od [35] else Remove edge v fi w from E (G) [36] fi postconditions v fi w E (G) SP (G) consists of <p> Previous Work on Classifying Incremental Problems The problem of classifying incremental problems has been addressed in two previous papers, one by Reif <ref> [29] </ref> and one by Berman, Paull, and Ryder [3]. One aspect of our work that sets it apart from both of these papers is that we analyze incremental complexity in terms of the adaptive parameter || d || , rather than in terms of the size of the current input. <p> The paper by Reif primarily concerns an algorithm for the connectivity problem in undirected graphs when edge deletions but not edge insertions are permitted <ref> [29] </ref>. 9 At the end of the paper, Reif lists a number of incremental problems . . . with linear time sequential RAM algorithms on a single input instance, but which seem to require a complete recomputation in the worst case if a single symbol of the input is modified.
Reference: 30. <author> Reps, T., </author> <title> Optimal-time incremental semantic analysis for syntax-directed editors, pp. </title> <booktitle> 169-176 in Conference Record of the Ninth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Albuquerque, NM, </address> <month> January 25-27, </month> <year> 1982), </year> <booktitle> ACM, </booktitle> <address> New York, NY (1982). </address>
Reference-contexts: For example, an incremental algorithm that is linear in || d || can be said to be optimal <ref> [30, 31] </ref>: the cost | D input | can be charged to the user's action that modifies the input from x to x; the cost of updating the solution from f (x) to f (x) can be no less than | D output | . <p> The notion of a bounded incremental algorithm is not new to this paper. Examples of bounded incremental algorithms that have been presented in previous work include (1) Reps's algorithm for updating the attributes of an attributed tree after an editing modification <ref> [30, 31] </ref>, and (2) the algorithm of Alpern et al. for maintaining a priority ordering in a DAG [1]. What is new in this paper is that we systematically classify a wide range of problems according to their degree of boundedness. <p> [27] for every vertex c such that c fi a E (G) and length (c fi a) + dist (a) &lt; dist (c) do [28] dist (c) := length (c fi a) + dist (a) [29] if c PriorityQueue then Decrease the priority of c in PriorityQueue to dist (c) <ref> [30] </ref> else Insert c into PriorityQueue with priority dist (c) [31] fi [33] od [35] else Remove edge v fi w from E (G) [36] fi postconditions v fi w E (G) SP (G) consists of all edges in E (G) on shortest paths to sink (G) " v V (G), <p> Because vertices whose dist value equals are not queued in PriorityQueue, when dist (c ) has been reduced from to some finite value it is necessary to insert c into PriorityQueue (see line <ref> [30] </ref>). In addition to the various adjustments of dist values that are performed, the basic processing step also performs a loop over a's successors (see lines [24]-[26]). <p> 1 in all cases except for APSP&gt;0.) - 32 - The problem of incremental attribute evaluation for noncircular attribute grammarshow to reevaluate the attributes of an attributed derivation trees after a restructuring operation has been applied to the tree was shown by Reps to be linear in || d || <ref> [30] </ref> (see also [31] and [32]). Thus, the algorithm he gave for the problem is asymptotically optimal. ([30] is also the first paper that we are aware of in which an incremental algorithm is analyzed in terms of the parameter || d || .) The concept of a locally persistent algorithm <p> Attribute Updating The first paper that we are aware of in which an incremental algorithm is analyzed in terms of || d || is a paper by Reps <ref> [30] </ref> (see also [31] and [32]). 11 The problem discussed in that paper is incremental attribute evaluation for noncircular attribute grammarshow to reevaluate the attributes of an attributed derivation tree after a restructuring operation (such as the replacement of a subtree) has been applied to the tree.
Reference: 31. <author> Reps, T., Teitelbaum, T., and Demers, A., </author> <title> Incremental context-dependent analysis for language-based editors, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 5(3) pp. </pages> <month> 449-477 (July </month> <year> 1983). </year>
Reference-contexts: For example, an incremental algorithm that is linear in || d || can be said to be optimal <ref> [30, 31] </ref>: the cost | D input | can be charged to the user's action that modifies the input from x to x; the cost of updating the solution from f (x) to f (x) can be no less than | D output | . <p> The notion of a bounded incremental algorithm is not new to this paper. Examples of bounded incremental algorithms that have been presented in previous work include (1) Reps's algorithm for updating the attributes of an attributed tree after an editing modification <ref> [30, 31] </ref>, and (2) the algorithm of Alpern et al. for maintaining a priority ordering in a DAG [1]. What is new in this paper is that we systematically classify a wide range of problems according to their degree of boundedness. <p> E (G) and length (c fi a) + dist (a) &lt; dist (c) do [28] dist (c) := length (c fi a) + dist (a) [29] if c PriorityQueue then Decrease the priority of c in PriorityQueue to dist (c) [30] else Insert c into PriorityQueue with priority dist (c) <ref> [31] </ref> fi [33] od [35] else Remove edge v fi w from E (G) [36] fi postconditions v fi w E (G) SP (G) consists of all edges in E (G) on shortest paths to sink (G) " v V (G), dist (v) is length of the shortest path from v <p> In the remainder of this section we describe the results from other papers that have a bearing on this way of classifying incremental problems; some additional discussion of these problems can be found in Section 6. hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh UNBOUNDED EXPONENTIAL POLYNOMIAL CIRCUIT-VALUE PROBLEM [1], [Section 3.3] ATTRIBUTE UPDATING <ref> [31] </ref> PRIORITY ORDERING [1] ALL-PAIRS SHORTEST PATH (&gt; 0) [Section 3.2] SINGLE-SOURCE/SINK SHORTEST PATH (&gt; 0) [Section 3.1] MEET-SEMILATTICE DATA-FLOW ANALYSIS PROBLEMS [Section 4.3] SINGLE-SOURCE/SINK CLOSED-SEMIRING PATH PROBLEMS [Section 4.2] SINGLE-SOURCE/SINK SHORTEST PATH (&gt;= 0) [Section 4.2] SINGLE-SOURCE/SINK REACHABILITY [Section 4.1] d |||| d |||| d |||| log hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh are classified <p> cases except for APSP&gt;0.) - 32 - The problem of incremental attribute evaluation for noncircular attribute grammarshow to reevaluate the attributes of an attributed derivation trees after a restructuring operation has been applied to the tree was shown by Reps to be linear in || d || [30] (see also <ref> [31] </ref> and [32]). <p> Attribute Updating The first paper that we are aware of in which an incremental algorithm is analyzed in terms of || d || is a paper by Reps [30] (see also <ref> [31] </ref> and [32]). 11 The problem discussed in that paper is incremental attribute evaluation for noncircular attribute grammarshow to reevaluate the attributes of an attributed derivation tree after a restructuring operation (such as the replacement of a subtree) has been applied to the tree.
Reference: 32. <author> Reps, T., </author> <title> Generating Language-Based Environments, </title> <publisher> The M.I.T. Press, </publisher> <address> Cambridge, MA (1984). </address>
Reference-contexts: for APSP&gt;0.) - 32 - The problem of incremental attribute evaluation for noncircular attribute grammarshow to reevaluate the attributes of an attributed derivation trees after a restructuring operation has been applied to the tree was shown by Reps to be linear in || d || [30] (see also [31] and <ref> [32] </ref>). <p> Attribute Updating The first paper that we are aware of in which an incremental algorithm is analyzed in terms of || d || is a paper by Reps [30] (see also [31] and <ref> [32] </ref>). 11 The problem discussed in that paper is incremental attribute evaluation for noncircular attribute grammarshow to reevaluate the attributes of an attributed derivation tree after a restructuring operation (such as the replacement of a subtree) has been applied to the tree. <p> The algorithm given is linear in || d || and hence asymptotically optimal. Subsequently, other optimal algorithms were given for a variety of attribute-grammar subclasses, e.g., absolutely noncircular grammars <ref> [32] </ref> and ordered attribute grammars [36, 46]. All of the algorithms cited above are locally persistent.
Reference: 33. <author> Reps, T., Marceau, C., and Teitelbaum, T., </author> <title> Remote attribute updating for language-based editors, pp. </title> <booktitle> 1-13 in Conference Record of the Thirteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (St. Petersburg, FL, </address> <month> Jan. </month> <pages> 13-15, </pages> <address> 1986), </address> <publisher> ACM, </publisher> <address> New York, NY (1986). </address> - <month> 41 </month> - 
Reference-contexts: and length (c fi a) + dist (a) &lt; dist (c) do [28] dist (c) := length (c fi a) + dist (a) [29] if c PriorityQueue then Decrease the priority of c in PriorityQueue to dist (c) [30] else Insert c into PriorityQueue with priority dist (c) [31] fi <ref> [33] </ref> od [35] else Remove edge v fi w from E (G) [36] fi postconditions v fi w E (G) SP (G) consists of all edges in E (G) on shortest paths to sink (G) " v V (G), dist (v) is length of the shortest path from v to sink <p> to as | AFFECTED | . - 36 - There are also a variety of other attribute-updating algorithms described in the literature, including one that handles k simultaneous subtree replacements in an n-node tree and runs in amortized time O (( || d || + k ) . log n) <ref> [33] </ref>, and another that permits unit-cost, random-access cursor motion for noncircular attribute grammars and runs in amortized time O ( || d || . dd n ) [35].
Reference: 34. <author> Reps, T. and Teitelbaum, T., </author> <title> Language processing in program editors, </title> <note> Computer 20(11) pp. </note> <month> 29-40 (November </month> <year> 1987). </year>
Reference-contexts: 1. INTRODUCTION Many kinds of interactive systems developed in the last fifteen years, such as word processors, electronic spreadsheets, language-based program editors, and systems for computer-aided design, are examples of what has been called the continuous-execution [18] or immediate-computation <ref> [34] </ref> paradigm. In a system that follows the immediate-computation paradigm, the application program and the editing function are closely coupled. Each modification to a datum is processed by the application and has essentially instantaneous effect.
Reference: 35. <author> Reps, T., </author> <title> Incremental evaluation for attribute grammars with unrestricted movement between tree modifications, </title> <journal> Acta Informa-tica, </journal> <pages> pp. </pages> <month> 155-178 </month> <year> (1988). </year>
Reference-contexts: (c fi a) + dist (a) &lt; dist (c) do [28] dist (c) := length (c fi a) + dist (a) [29] if c PriorityQueue then Decrease the priority of c in PriorityQueue to dist (c) [30] else Insert c into PriorityQueue with priority dist (c) [31] fi [33] od <ref> [35] </ref> else Remove edge v fi w from E (G) [36] fi postconditions v fi w E (G) SP (G) consists of all edges in E (G) on shortest paths to sink (G) " v V (G), dist (v) is length of the shortest path from v to sink (G) end <p> In the previous two paragraphs, we have been speaking very roughly. In particular, because DeleteEdge SSSP &gt;0 as stated in Figure 1 actually performs the deletion of edge v fi w from graph G (see lines [2] and <ref> [35] </ref>), a few changes in DeleteEdge SSSP &gt;0 are necessary for it to be called multiple times in the manner suggested above. There is also a more serious problem with using procedure DeleteEdge SSSP &gt;0 from Figure 1 in conjunction with the ideas outlined above. <p> simultaneous subtree replacements in an n-node tree and runs in amortized time O (( || d || + k ) . log n) [33], and another that permits unit-cost, random-access cursor motion for noncircular attribute grammars and runs in amortized time O ( || d || . dd n ) <ref> [35] </ref>. These algorithms have hybrid complexity measures, in the sense that the running time is a function of the size of the current input as well as || d || (i.e., the running time is of the form O (f ( | input | , || d || )).
Reference: 36. <author> Reps, T. and Teitelbaum, T., </author> <title> The Synthesizer Generator: A System for Constructing Language-Based Editors, </title> <publisher> Springer-Verlag, </publisher> <address> New York, NY (1988). </address>
Reference-contexts: [28] dist (c) := length (c fi a) + dist (a) [29] if c PriorityQueue then Decrease the priority of c in PriorityQueue to dist (c) [30] else Insert c into PriorityQueue with priority dist (c) [31] fi [33] od [35] else Remove edge v fi w from E (G) <ref> [36] </ref> fi postconditions v fi w E (G) SP (G) consists of all edges in E (G) on shortest paths to sink (G) " v V (G), dist (v) is length of the shortest path from v to sink (G) end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh Dijkstra's batch algorithm to AFFECTED and its neighboring edges <p> The algorithm given is linear in || d || and hence asymptotically optimal. Subsequently, other optimal algorithms were given for a variety of attribute-grammar subclasses, e.g., absolutely noncircular grammars [32] and ordered attribute grammars <ref> [36, 46] </ref>. All of the algorithms cited above are locally persistent.
Reference: 37. <author> Rohnert, H., </author> <title> A dynamization of the all pairs least cost path problem, pp. </title> <booktitle> 279-286 in Proceedings of STACS 85: Second Annual Symposium on Theoretical Aspects of Computer Science, </booktitle> <editor> (Saarbruecken, W. Ger., </editor> <month> Jan. </month> <pages> 3-5, </pages> <year> 1985), </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 182, </volume> <editor> ed. K. Melhorn,Springer-Verlag, </editor> <address> New York, NY (1985). </address>
Reference-contexts: Previous Work on Incremental Shortest-Path Algorithms Section 3.2 of this paper presents a bounded incremental algorithm for the all-pairs shortest-path problem with positive edge weights (APSP&gt;0) (assuming the collection of vertices is fixed in advance). There have been three previous papers on APSP&gt;0by Dionne [11], Rohnert <ref> [37] </ref>, and Even and Gazit [14]in which the analysis might be misinterpreted, on first reading, as demonstrating that the algorithms are bounded. In fact, the algorithms given in all three papers have unbounded incremental complexity in general.
Reference: 38. <author> Rosen, B.K., </author> <title> Linear cost is sometimes quadratic, pp. </title> <booktitle> 117-124 in Conference Record of the Eighth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Williamsburg, VA, </address> <month> January 26-28, </month> <year> 1981), </year> <booktitle> ACM, </booktitle> <address> New York, NY (1981). </address>
Reference-contexts: A number of papers in the literature on incremental algorithms concern incremental data-flow analysis <ref> [7, 23, 24, 38, 39, 48] </ref>.
Reference: 39. <author> Ryder, B.G. and Paull, </author> <title> M.C., Incremental data flow analysis algorithms, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 10(1) pp. </pages> <month> 1-50 (January </month> <year> 1988). </year>
Reference-contexts: Together with some previously known results, our results help one to understand the complexity hierarchy that exists when incremental-computation problems are classified according to their incremental complexity with respect to locally persistent algorithms. Ryder and Paull have remarked about the inappropriateness of worst-case analysis for incremental update algorithms <ref> [39] </ref>; similar remarks have appeared in several other papers. However, our work shows that for some incremental-computation problems it is not that worst-case analysis is inappropriate, but rather that an analysis carried out in terms of the parameter | input | is inappropriate. <p> A number of papers in the literature on incremental algorithms concern incremental data-flow analysis <ref> [7, 23, 24, 38, 39, 48] </ref>.
Reference: 40. <author> Ryder, B.G., Landi, W., and Pande, H.D., </author> <title> Profiling an incremental data flow analysis algorithm, </title> <journal> IEEE Transactions on Software Engineering SE-16(2)(February 1990). </journal>
Reference-contexts: For instance, Hoover presents evidence that his unbounded algorithm for the circuit-value problem performs well in practice [19]; Ryder, Landi, and Pande present evidence that the unbounded incremental data-flow analysis algorithm of Carroll and Ryder [7] performs well in practice <ref> [40] </ref>; as discussed earlier, Dionne reports excellent performance for some unbounded algorithms for APSP&gt;0 [11]. ACKNOWLEDGEMENTS We are grateful for the comments and helpful suggestions of Susan Horwitz, Alan Demers, and Tim Teitel-baum.
Reference: 41. <author> Sedgewick, R., </author> <title> Algorithms, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA (1983). </address>
Reference-contexts: all edges in E (G) on shortest paths to sink (G) " v V (G), dist (v) is length of the shortest path from v to sink (G) end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh Dijkstra's batch algorithm to AFFECTED and its neighboring edges (cf., the descriptions of Dijkstra's algorithm given in references [45] and <ref> [41] </ref>). - 10 - Phase 1: Identifying vertices in AFFECTED As we now argue, the value of variable AffectedVertices at the end of Phase 1 of procedure DeleteEdge SSSP &gt;0 equals AFFECTED, the set of vertices of G whose shortest distance to sink (G) has increased. <p> Phase 2: Determining new distances for vertices in AFFECTED and updating SP (G) As stated earlier, Phase 2 of DeleteEdge SSSP &gt;0 is an adaptation of Dijkstra's batch shortest-path algorithm that uses priority-first search <ref> [41] </ref>. <p> This loop is performed because the goal of DeleteEdge SSSP &gt;0 is to update SP (G)the edges of the DAG of shortest paths to sink (G)rather than just building a shortest-path tree (cf., the descriptions of Dijkstra's algorithm given in references [45] and <ref> [41] </ref>).
Reference: 42. <author> Shmueli, O. and Itai, A., </author> <title> Maintenance of views, pp. </title> <booktitle> 240-255 in Proceedings of ACM SIGMOD 84, </booktitle> <address> (Boston, MA, </address> <year> 1984), (1984). </year>
Reference-contexts: There has been a variety of work carried out on the problem of taking a high-level specification of a computation to be performed and creating an incremental evaluator that maintains the result value of the computation as inputs to the computation are varied <ref> [20, 21, 27, 42, 44, 47] </ref>. From the standpoint of computational complexity, the most interesting result from this group of papers is the technique that Pugh developed for supporting incremental computation using function caching [28] (see also [27]).
Reference: 43. <author> Spira, P.M. and Pan, A., </author> <title> On finding and updating spanning trees and shortest paths, </title> <note> SIAM J. Computing 4(3) pp. 375-362 (Sep-tember 1975). </note>
Reference-contexts: even been possible to show a lower-bound result for an incremental-computation problem (as opposed to an analysis of a particular incremental algorithm for a problem), demonstrating that in the worst-case no incremental algorithm for the problem can perform asymptotically better than the time required to perform the computation from scratch <ref> [3, 14, 43] </ref>. For these reasons, worst-case analysis (with costs expressed as a function of the size of the input) has not been of much help for making comparisons between different incremental algorithms. <p> To appreciate the advantages of analyzing incremental algorithms in terms of the parameter || d || rather than in terms of the size of the current input, it is instructive to compare our results with those of Spira and Pan <ref> [43] </ref> concerning the problem SSSP&gt;0. <p> locally persistent algorithms, Spira and Pan obtained a lower-bound: they showed that, in the worst-case, no incremental algorithm of a certain class can perform better asymptotically than the time required to perform the computation from scratch (where costs are expressed as a function of the size of the current input) <ref> [43] </ref>. By contrast, we give an algorithm that, in the worst case, is polynomial in || d || (as opposed to the size of the current input). <p> The solution of SSSP&gt;0 for the modified graph is immediate: dist (sink (G)) = 0, dist (v ) = k/3, and for hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 10 The arguments that Berman, Paull, and Ryder use to establish relative lower bounds for various problems are similar to the ones used by Spira and Pan <ref> [43] </ref> and Even and Gazit [14] to establish that no incremental algorithm for the all-pairs single-source shortest-path problem can do better in the worst case than the best batch algorithm for the problem. - 35 - each vertex w V - v, sink (G) -, dist (w) = 2k /3 (since <p> Other previous work on how to maintain shortest paths in graphs incrementally includes papers by Halder [17], Pape [26], Spira and Pan <ref> [43] </ref>, Cheston [8], Cheston and Corneil [9], and Ausiello et al. [2]; however, none of the papers in this group analyze either the single-source or the all-pairs problem in terms of the parameter || d || , and furthermore, none of the algorithms presented in these papers is bounded.
Reference: 44. <author> Sundaresh, R.S. and Hudak, P., </author> <title> Incremental computation via partial evaluation, </title> <booktitle> in Conference Record of the Eighteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Orlando, FL, </address> <month> January </month> <year> 1991), </year> <booktitle> ACM, </booktitle> <address> New York, NY (1991). </address>
Reference-contexts: There has been a variety of work carried out on the problem of taking a high-level specification of a computation to be performed and creating an incremental evaluator that maintains the result value of the computation as inputs to the computation are varied <ref> [20, 21, 27, 42, 44, 47] </ref>. From the standpoint of computational complexity, the most interesting result from this group of papers is the technique that Pugh developed for supporting incremental computation using function caching [28] (see also [27]).
Reference: 45. <author> Tarjan, R.E., </author> <title> Data Structures and Network Algorithms, </title> <institution> Society for Industrial and Applied Mathematics, </institution> <address> Philadelphia, PA (1983). </address>
Reference-contexts: Here is Tar jan on the subject of amortization <ref> [45] </ref>: Amortization is appropriate in situations where particular algorithms are repeatedly applied, as occurs with operations on data structures. <p> By averaging the time per operation over a worst-case sequence of operations, we sometimes can obtain an overall time bound much smaller than the worst-case time per operation multiplied by the number of operations <ref> [45] </ref>. There are incremental problems for which the benefits mentioned above are realized. Examples include the results of Even and Shiloach [13], Reif [29] and Ausiello et al. [2]. However, the question of amortized-cost analysis versus worst-case analysis is really orthogonal to the question studied in this paper. <p> consists of all edges in E (G) on shortest paths to sink (G) " v V (G), dist (v) is length of the shortest path from v to sink (G) end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh Dijkstra's batch algorithm to AFFECTED and its neighboring edges (cf., the descriptions of Dijkstra's algorithm given in references <ref> [45] </ref> and [41]). - 10 - Phase 1: Identifying vertices in AFFECTED As we now argue, the value of variable AffectedVertices at the end of Phase 1 of procedure DeleteEdge SSSP &gt;0 equals AFFECTED, the set of vertices of G whose shortest distance to sink (G) has increased. <p> This loop is performed because the goal of DeleteEdge SSSP &gt;0 is to update SP (G)the edges of the DAG of shortest paths to sink (G)rather than just building a shortest-path tree (cf., the descriptions of Dijkstra's algorithm given in references <ref> [45] </ref> and [41]). <p> We can generalize DeleteEdge SSSP &gt;0 and InsertEdge SSSP &gt;0 to handle negative-length edges (as long as all cycles have net positive weight) by adapting the technique of Edmonds and Karp for transforming the length of every edge to a non-negative real without changing the graph's shortest paths <ref> [12, 45] </ref>.
Reference: 46. <author> Yeh, D., </author> <title> On incremental evaluation of ordered attributed grammars, </title> <note> BIT 23 pp. </note> <month> 308-320 </month> <year> (1983). </year>
Reference-contexts: The algorithm given is linear in || d || and hence asymptotically optimal. Subsequently, other optimal algorithms were given for a variety of attribute-grammar subclasses, e.g., absolutely noncircular grammars [32] and ordered attribute grammars <ref> [36, 46] </ref>. All of the algorithms cited above are locally persistent.
Reference: 47. <author> Yellin, D. and Strom, R., INC: </author> <title> A language for incremental computations, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 13(2) pp. </pages> <month> 211-236 (April </month> <year> 1991). </year>
Reference-contexts: There has been a variety of work carried out on the problem of taking a high-level specification of a computation to be performed and creating an incremental evaluator that maintains the result value of the computation as inputs to the computation are varied <ref> [20, 21, 27, 42, 44, 47] </ref>. From the standpoint of computational complexity, the most interesting result from this group of papers is the technique that Pugh developed for supporting incremental computation using function caching [28] (see also [27]).
Reference: 48. <author> Zadeck, F.K., </author> <title> Incremental data flow analysis in a structured program editor, </title> <booktitle> Proceedings of the SIGPLAN 84 Symposium on Compiler Construction, </booktitle> <address> (Montreal, Can., </address> <month> June 20-22, </month> <year> 1984), </year> <journal> ACM SIGPLAN Notices 19(6) pp. </journal> <month> 132-143 (June </month> <year> 1984). </year>
Reference-contexts: informative; when the cost of the computation is expressed as a function of the size of the (current) input (i.e., | x | ), many incremental algorithms that have been proposed run in time asymptotically no better, in the worst-case, than the time required to perform the computation from scratch <ref> [7, 8, 19, 24, 48] </ref>. <p> A number of papers in the literature on incremental algorithms concern incremental data-flow analysis <ref> [7, 23, 24, 38, 39, 48] </ref>.
References-found: 48

