URL: http://www.cs.toronto.edu/~paige/Writing/higraphs.ps.gz
Refering-URL: http://www.cs.toronto.edu/~paige/use.html
Root-URL: 
Email: paige@cs.utoronto.ca,  
Title: Higraph-based Predicate and Heterogeneous Specification  
Author: Richard F. Paige 
Date: May 30, 1995  
Web: http://www.cs.utoronto.ca/~paige  
Address: Toronto  
Affiliation: Department of Computer Science, University of  
Abstract: We describe a higraph-based notation for visualizing and writing predicate specifications, and for depicting formal derivations of programs from specifications. We show how to present various system views using the notation, and consider how to deal with abstraction, which is vital in coping with large specifications. We then describe how the notation can be extended to heterogeneous specifications [Paig95].
Abstract-found: 1
Intro-found: 1
Reference: [AsCe93] <author> E. Astesiano and M. Cerioli. </author> <title> Multiparadigm Specification Languages: a first attempt at foundations. </title> <booktitle> In Proc. Semantics of Specification Languages, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: We feel that by using heterogeneous specifications, this restrictability consideration can be obtained. This term arises with [Paig95], although it clearly has roots with the specifications of Zave and Jackson [ZaJa93] and multiparadigm languages <ref> [AsCe93] </ref>. The main difference between heterogeneous specifications and the compositional specifications of [ZaJa93] is that the former allows compositions of specifications with different degrees of (explicit) formality and abstraction, while the latter considers only formal notations at essentially a concrete level of abstraction.
Reference: [Back91] <author> R.J.R. </author> <title> Back. Refinement diagrams. </title> <booktitle> In Proc. Fourth Refinement Workshop, Workshops in Computing, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: If they are able to do this, it allows them to keep track of the development of programs from specifications. Morgan [Morg93] has suggested that formal developments are as important, if not more important, than the end product. Back <ref> [Back91] </ref> has described a visual notation for representing formal developments in the refinement calculus (although his notation is limited to depiction of refinement and only a few specification combinators). We choose to visualize refinement hierarchically, using the blob nesting capability. <p> This is the flow diagram 9 leveling concept as it applies to higraphs. The semantics of a blob containing only a name is provided by the continued refinement and development given elsewhere. An example of this is depicted in Figure 17. We use an unadorned line (as used in <ref> [Back91] </ref> to denote refinement) to indicate the continuation.
Reference: [Booc94] <author> G. Booch. </author> <title> Object-oriented Analysis and Design with Applications, Second Edition, </title> <address> Benjamin-Cummings, </address> <year> 1994. </year>
Reference-contexts: The way we are thinking of accomplishing such use is through heterogeneous specifications, in the following sense: there have been many object-oriented notations discussed in the literature; see, for 23 example [PCW90], or <ref> [Booc94] </ref>. All of these approaches offer very similar facilities and notations for describing encapsulation, modularity, inheritance, and message passing. Typically, the approaches provide diagram notations for specifying design details; for example, structure charts are used for this purpose in the notation of [PCW90].
Reference: [HaLa88] <author> D. Harel, H. Lachover, A. Naamad, A. Pneuli, M. Politi, R. Sherman, and A. Shtul-Trauring. </author> <title> STATEMENT: A working environment for the development of complex reactive systems. </title> <booktitle> In Proc. Tenth IEEE International Conference on Software Engineering, </booktitle> <publisher> IEEE Press, </publisher> <year> 1988. </year>
Reference-contexts: This is the perspective offered 10 by data flow diagrams in, for example, the structured approaches to development. Higraph-based data flow diagrams were presented in <ref> [HaLa88] </ref>; these are called activity charts, and they generalize the standard data flow diagram notation by allowing hierarchy and nesting, along with the usual conventions. It is possible to extend our higraph-based specification notation to allow the description of a data flow view.
Reference: [Hare88] <author> D. Harel. </author> <title> On Visual Formalisms, </title> <journal> Comm. ACM, </journal> <volume> 31(5), </volume> <month> May </month> <year> 1988. </year> <month> 25 </month>
Reference-contexts: Higraphs are a notation that need not suffer from this complaint; while they are visual, they can also be formal. Higraphs are generalized from two well-known topovisual formalisms: Venn diagrams, and hypergraphs. As such, they offer facilities usually attributed to one or the other notation. As presented in Harel <ref> [Hare88] </ref>, various higraph-based notations have been used for describing different views of programs and specifications. For example, Harel presents activity charts, part of the STATEMATE system, which can be used to provide a data flow view of a system. <p> In order to make things more concrete, we concentrate our presentation on one particular formal notation, that of Hehner [Hehn93]. We begin with a brief overview of the general higraph notation, as presented in <ref> [Hare88] </ref>, and a summary of Hehner's formalism. 2.1 Higraphs Higraphs are a topovisual formalism constructed from Venn diagrams and hypergraphs 2 . <p> Thus, higraphs provide both capabilities, which are really needed in coping with numerous computer-related applications. 1 Meaning that the notation is used only when necessary or desirable. 2 Graphs in which the relation being specified need not be binary. 2 In the higraphs of <ref> [Hare88] </ref>, rounded rectangles ("blobs") denote sets; every set of interest is represented by its own unique blob. A higraph is obtained from a collection of potentially nested, overlapping, and partitioned blobs by attaching hyperedges to the boundary of any blob. <p> A higraph is obtained from a collection of potentially nested, overlapping, and partitioned blobs by attaching hyperedges to the boundary of any blob. An example is shown in Figure 1 (with only binary edges). See <ref> [Hare88] </ref> for the basic notations and conventions regarding labeling and orthogonal partitioning (denoted by dashed lines). By default, the relationships (denoted by arrows) are between the sets that are connected, although we are free to attach whatever meaning to the arrows that we choose. <p> By default, the relationships (denoted by arrows) are between the sets that are connected, although we are free to attach whatever meaning to the arrows that we choose. Since higraphs are a visual formalism, they have a precisely-defined syntax and semantics. The formal definition given in <ref> [Hare88] </ref>, based on sets and relations, is very general-in fact, it is too general for our purposes. <p> The annotations can be omitted if they are not needed. Also, notice that we have not given the annotation S ^ T to the enclosing blob; it is perfectly acceptable to give such a label to the orthogonal partitioning (using any of the labeling conventions of <ref> [Hare88] </ref>) if it will prove useful in carrying out later developments 5 . <p> In essence, our higraph-based specifications allow us to generalize the notion of heterogeneality that appears in [Paig95] 4.3 A Brief Aside on Object-Orientation We have shown how higraphs-based specifications can convey flow-related information. Of course, the notation is not limited to such views; for example, <ref> [Hare88] </ref> discusses higraph-based versions of entity-relationship models, finite state machines, etcetera. The problems with all of these notations is their lack of a straightforward way to map abstract concepts into their implementations in terms of procedures and data.
Reference: [Hehn93] <author> E.C.R. Hehner. </author> <title> A Practical Theory of Programming, </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: The formal specifications we will be describing can be from any notation based on set theory or first-order predicate calculus. In order to make things more concrete, we concentrate our presentation on one particular formal notation, that of Hehner <ref> [Hehn93] </ref>. We begin with a brief overview of the general higraph notation, as presented in [Hare88], and a summary of Hehner's formalism. 2.1 Higraphs Higraphs are a topovisual formalism constructed from Venn diagrams and hypergraphs 2 . <p> Since we have more information regarding the interpretation we wish to place on blobs (and, in certain situations, connections between blobs), we will use this information to construct our own formal semantics. 2.2 Predicative programming In the predicative methodology, due to Hehner <ref> [Hehn93] </ref>, specifications and programs are predicates. The notion of specification refinement is boolean implication. The theory applies to both sequential and concurrent programming. It includes ways for explicitly describing resource consumption. Finally, specifications can be combined using the familiar operators of boolean theory. <p> We refer to the components of the state by names, or state variables. Specifications can be written in any well-understood notation; the notations presented in <ref> [Hehn93] </ref> include basic data structures, functions, bunches, sets, and predicates. Programs (in a small language which includes loops, assignments, selection, and sequencing) are given a predicate semantics. The notion of specification refinement, as we've already mentioned, is boolean implication, giving us the following definition. <p> The notion of specification refinement, as we've already mentioned, is boolean implication, giving us the following definition. Definition 1 Specification P is refined by specification S if and only if P is satisfied whenever S is satisfied, i.e., 8; 0 * P ( S. See <ref> [Hehn93] </ref> for more details on the predicative methodology. 3 2.3 Visual specifications As we mentioned earlier, our goal is to use a higraph-based notation to depict specifications 3 . <p> As well, our descriptions of quantification and functions given earlier in this section are special kinds of textual short forms, where the splitting is on a *. 3.2 Concurrent Composition We now have all the tools we need to talk about concurrent (independent) composition. Hehner <ref> [Hehn93] </ref> defines the concurrent composition of two specifications as follows: P k Q = 9 p ; q * P 0 q ^ ( p = ) 0 = q ) ^ ( q = ) 0 = p ) It is easy to depict this with our higraphs.
Reference: [HNP95] <author> E.C.R. Hehner, </author> <title> T.S. Norvell, and R.F. Paige. High-level Circuit Design, </title> <note> submitted for publication. </note>
Reference: [Morg93] <author> C.C. Morgan. </author> <title> The Refinement Calculus, and Literate Development. In Formal Program Development, IFIP TC2/WG2.1 State-of-the-art report, </title> <publisher> LNCS 755, Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: It may be very important for designers to be able to depict specification refinement in their diagrams. If they are able to do this, it allows them to keep track of the development of programs from specifications. Morgan <ref> [Morg93] </ref> has suggested that formal developments are as important, if not more important, than the end product. Back [Back91] has described a visual notation for representing formal developments in the refinement calculus (although his notation is limited to depiction of refinement and only a few specification combinators).
Reference: [Morg94] <author> C.C. Morgan. </author> <title> Programming from Specifications, Second Edition, </title> <publisher> Prentice-Hall, </publisher> <year> 1994. </year>
Reference-contexts: This example is borrowed from <ref> [Morg94] </ref>. We first present the (formal) textual refinement, and then show how to describe it visually. Note that this is a control flow diagram (although it can be easily transformed into other depictions), and that we use a "zoom out" to keep the diagram reasonably clean.
Reference: [PCW90] <author> M. Page-Jones, L. Constantine, and S. Weiss. </author> <title> Modeling Object-Oriented Systems: The Uniform Object Notation, </title> <booktitle> Computer Language, </booktitle> <month> October </month> <year> 1990. </year>
Reference-contexts: The way we are thinking of accomplishing such use is through heterogeneous specifications, in the following sense: there have been many object-oriented notations discussed in the literature; see, for 23 example <ref> [PCW90] </ref>, or [Booc94]. All of these approaches offer very similar facilities and notations for describing encapsulation, modularity, inheritance, and message passing. Typically, the approaches provide diagram notations for specifying design details; for example, structure charts are used for this purpose in the notation of [PCW90]. <p> the literature; see, for 23 example <ref> [PCW90] </ref>, or [Booc94]. All of these approaches offer very similar facilities and notations for describing encapsulation, modularity, inheritance, and message passing. Typically, the approaches provide diagram notations for specifying design details; for example, structure charts are used for this purpose in the notation of [PCW90]. Our approach to integrating higraph-based specifications into an existing object-oriented development framework is very simple: * express the object-oriented notation (or a useful subset thereof ) in some formalism. * replace the design notation (e.g., structure charts) with our higraph-based specifications.
Reference: [Paig95] <author> R.F. Paige. </author> <title> Heterogeneous specifications and their application to software development. Research Proposal, </title> <institution> Department of Computer Science, University of Toronto, </institution> <month> August </month> <year> 1995. </year>
Reference-contexts: Existing in-tegrations often do not provide this property, thus limiting the potential adoption of the formal notation in large-scale development situations. We feel that by using heterogeneous specifications, this restrictability consideration can be obtained. This term arises with <ref> [Paig95] </ref>, although it clearly has roots with the specifications of Zave and Jackson [ZaJa93] and multiparadigm languages [AsCe93]. <p> Heterogeneality: viz., the ability to write specifications as compositions of partial specifications in different notations. We use a formal notation only when necessary or useful. 2. Visual formalism. 1. gives us our desired restrictability; it also has other useful effects (see <ref> [Paig95] </ref> for more details). 2. may serve to make the formal notations more acceptable to the average designer, and will allow us to compose formal specifications with other semiformal (or formal) graphical notations. This might assist in simplifying and smoothing the integration process. <p> We omit all such labels in this paper simply to avoid cluttering the diagrams (although they are used in <ref> [Paig95] </ref>). 5 And, to remain consistent with existing notations, we really should supply such annotations. 6 Intuitively, this description of specification conjunction makes sense in terms of the usual higraph interpretation 6 : being in the blob for S ^ T is tantamount to being in both the blob labeled S <p> Blobs which 15 depict a particular predicate specification will have this specification added to the invariant of the representative Z schema (see <ref> [Paig95] </ref> for ideas on how to cope with heterogeneality in this case). Finally, if it is possible, we represent the hierarchical information present in the diagram. This might be denoted by a refinement relation (with parts left informal). <p> We reiterate that if the data flow higraph bubbles represent predicates, then we include these predicates in our formalization (in the invariant of schemas). This inclusion produces heterogeneous specifications; <ref> [Paig95] </ref> discusses how to cope with these. Another approach to formalizing the higraphs would be to use Harel's semantics, leaving the interpretation of nesting and blob-meaning as in our formalization 7 . Since Harel's semantics is relational, it can be expressed in Z, and therefore use of the translations in [Paig95] <p> <ref> [Paig95] </ref> discusses how to cope with these. Another approach to formalizing the higraphs would be to use Harel's semantics, leaving the interpretation of nesting and blob-meaning as in our formalization 7 . Since Harel's semantics is relational, it can be expressed in Z, and therefore use of the translations in [Paig95] can be combined with the predicate blob definitions to construct heterogeneous specifications. 3.3.2 Control Flow Our diagrams also allow generalizations of a control flow model, where the passing of control can occur through structures that are more abstract or definitional than pure sequencing. Figure 27 shows an example. <p> Other algebraic laws have their own equivalents in our visual notation; we leave their depictions for another time. 20 4 Heterogeneous specifications In <ref> [Paig95] </ref> we discussed the notion of heterogeneous specifications specifications which are written in a number of different notations. Heterogeneous specifications may be textual (for example, a composition of predicates and specification statements), visual (for example, a composition of data flow diagrams and structure charts), or may combine paradigms. <p> They also may lead to solutions to a number of significant problems regarding formal specifications, namely: * How can we integrate formal specifications into development cycles? * How can we obtain restrictability when applying formal notations? It is not our intention to go into any details regarding heterogeneous specifications here; <ref> [Paig95] </ref> contains many of the initial ideas regarding this concept. Instead, we examine some of the ways that higraph-based specifications can be used in a heterogeneous environment. Indeed, this is one of the main reasons we considered higraph-based specifications in the first place. <p> This is easiest to do using the Z notation for the data flow diagrams; it may also be used for formalizing the higraphs. See <ref> [Paig95] </ref> for a description of how to compose Z and predicate specifications. Then, the relationship between the higraph and data flow diagram parts is specified. In doing so, we (intuitively speaking) treat the higraph part as a data flow bubble. <p> In each case, the compositions can be justified by providing a formal semantics for the (visual) partial specifications in each notation, and then using the formal composition rules and translations given in <ref> [Paig95] </ref>. 22 4.2 Textual heterogeneality We've considered heterogeneality at the level of diagrams, through compositions of higraphs with data flow diagrams, control flow diagrams, structure charts, etcetera. The second way that hetero-geneality can be obtained by using our higraph specifications is at the textual level. <p> The annotations in the conjuncts of this diagram have been, up until now, assumed to be predicates. But there is no reason to keep this restriction when we know how to use text-based notations in composition (as is described in <ref> [Paig95] </ref>). For example, the operand P in the composition might be a predicate. <p> We give a semantics to these kinds of heterogeneous specifications exactly as we did in the textual case in <ref> [Paig95] </ref>: we perform translations into a single notation. Of course, the restrictions on formal notation translation mentioned in [Paig95] still apply in the visual case. <p> We give a semantics to these kinds of heterogeneous specifications exactly as we did in the textual case in <ref> [Paig95] </ref>: we perform translations into a single notation. Of course, the restrictions on formal notation translation mentioned in [Paig95] still apply in the visual case. The fact that we have described how to write predicate specifications visually allows us more flexibility and more freedom in how we can write heterogeneous specifications, and how we can apply them to the construction of programs. <p> In essence, our higraph-based specifications allow us to generalize the notion of heterogeneality that appears in <ref> [Paig95] </ref> 4.3 A Brief Aside on Object-Orientation We have shown how higraphs-based specifications can convey flow-related information. Of course, the notation is not limited to such views; for example, [Hare88] discusses higraph-based versions of entity-relationship models, finite state machines, etcetera. <p> There might be particular simplifications or formulations that we can obtain for each notation; for example, we might be able to obtain a nice higraph-based denotation of a Z schema. Of course, we can already obtain representations by using heterogeneous specifications and the translations described in <ref> [Paig95] </ref>, but direct visualizations may prove to be simpler, or more pleasing. 3. Extensions for other diagram paradigms: We should investigate combining the higraph-based specifications with other graphical notations, like Jackson diagrams, statecharts, object oriented diagramming notations, real-time visual notations, etcetera. 4.
Reference: [Rand91] <author> G. Randell. </author> <title> Data flow diagrams and Z. In Z Users Meeting '90, </title> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: The one we choose is that the diagrams depict operations changing a state). Randell <ref> [Rand91] </ref> presents a possible formalization of data flow diagrams in Z. The most significant new problem that we have to deal with here is that our diagrams include nesting. <p> The most significant new problem that we have to deal with here is that our diagrams include nesting. To cope with this, we formalize from the top down: each level in the hierarchy of nesting is formalized separately (as in, say, <ref> [Rand91] </ref>), resulting in a collection of Z schemas. Blobs which 15 depict a particular predicate specification will have this specification added to the invariant of the representative Z schema (see [Paig95] for ideas on how to cope with heterogeneality in this case).
Reference: [SFD92] <author> L.T. Semmens, R.B. France, and T.W. Docker. </author> <title> Integrated Structured Analysis and Formal Specification Techniques, </title> <journal> The Computer Journal 35(6), </journal> <month> June </month> <year> 1992. </year>
Reference: [ZaJa93] <author> P. Zave and M. Jackson. </author> <title> Conjunction as Composition, </title> <journal> ACM Trans. on Software Engineering and Methodology, </journal> <volume> 2(4), </volume> <month> October </month> <year> 1993. </year> <month> 26 </month>
Reference-contexts: We feel that by using heterogeneous specifications, this restrictability consideration can be obtained. This term arises with [Paig95], although it clearly has roots with the specifications of Zave and Jackson <ref> [ZaJa93] </ref> and multiparadigm languages [AsCe93]. The main difference between heterogeneous specifications and the compositional specifications of [ZaJa93] is that the former allows compositions of specifications with different degrees of (explicit) formality and abstraction, while the latter considers only formal notations at essentially a concrete level of abstraction. <p> We feel that by using heterogeneous specifications, this restrictability consideration can be obtained. This term arises with [Paig95], although it clearly has roots with the specifications of Zave and Jackson <ref> [ZaJa93] </ref> and multiparadigm languages [AsCe93]. The main difference between heterogeneous specifications and the compositional specifications of [ZaJa93] is that the former allows compositions of specifications with different degrees of (explicit) formality and abstraction, while the latter considers only formal notations at essentially a concrete level of abstraction.
References-found: 14

