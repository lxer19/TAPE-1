URL: ftp://flint.cs.yale.edu/pub/flint/publications/tcc-tr.ps.gz
Refering-URL: http://daffy.cs.yale.edu/users/shao-zhong/papers.html
Root-URL: http://www.cs.yale.edu
Title: Typed Cross-Module Compilation  
Author: Zhong Shao 
Date: June 27, 1998  
Address: YALEU/DCS/TR-1126  
Affiliation: Yale University Department of Computer Science  Yale University  
Abstract: This research was sponsored in part by the Defense Advanced Research Projects Agency ITO under the title "Software Evolution using HOT Language Technology," DARPA Order No. D888, issued under Contract No. F30602-96-2-0232, and in part by an NSF CAREER Award CCR-9501624, and NSF Grant CCR-9633390. The views and conclusions contained in this document are those of the authors and should not be interpreted as representing the official policies, either expressed or implied, of the Defense Advanced Research Projects Agency or the U.S. Government. 
Abstract-found: 1
Intro-found: 1
Reference: [AH95] <author> Alex Aiken and Nevin Heintze. </author> <title> Constraint-based program analysis. </title> <booktitle> POPL'95 Tutorial, </booktitle> <month> January </month> <year> 1995. </year>
Reference-contexts: Higher-order modules also make it very difficult to carry out static program analysis across the module boundaries. Because the module signature does not propagate any static information other than types, many existing techniques, such as constant propagation, function inlining [App92], partial evaluation [Jon91], 2 and constraint-based analysis <ref> [AH95] </ref>, lose all their information at the functor-application boundaries.
Reference: [App92] <author> Andrew W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: Higher-order modules also make it very difficult to carry out static program analysis across the module boundaries. Because the module signature does not propagate any static information other than types, many existing techniques, such as constant propagation, function inlining <ref> [App92] </ref>, partial evaluation [Jon91], 2 and constraint-based analysis [AH95], lose all their information at the functor-application boundaries.
Reference: [BA97] <author> Matthias Blume and Andrew W. Appel. Lambda-splitting: </author> <title> A higher-order approach to cross-module optimizations. </title> <booktitle> In Proc. 1997 ACM SIGPLAN International Conference on Functional Programming (ICFP'97), </booktitle> <pages> pages 112-124. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1997. </year>
Reference-contexts: However, none of the existing type-theoretic approaches have been able to model the full-transparency property in the MacQueen-Tofte system. Both Lillibridge [Lil97] and Leroy [Ler96a] discussed how to add value identities to their module interfaces though neither of them gave any actual algorithm. Blume and Appel <ref> [BA97] </ref> proposed a cross-module inlining algorithm that supports inlining of functions with free variables. Their algorithm is carried in an untyped setting, so type specialization is not directly supported; neither does their algorithm guarantee the fully transparent propagation of the inlining information.
Reference: [BHLM94] <author> Edoardo Biagioni, Robert Harper, Peter Lee, and Brian Milnes. </author> <title> Signatures for a network protocol stack: A systems application of Standard ML. </title> <booktitle> In 1994 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 55-64, </pages> <address> New York, June 1994. </address> <publisher> ACM Press. </publisher>
Reference-contexts: 1 Introduction Modular programming has proven to be extremely valuable in the development and maintenance of large software systems <ref> [BHLM94, Nel91, Geo97] </ref>. Many modern programming languages such as Modula-3 [Nel91] and Standard ML [MTH90, MTHM97] provide support for both core-level and module-level programming. The core language, in general, deals with the detailed implementation of algorithms in terms of data structures and control constructs.
Reference: [Bis95] <author> Sandip K. Biswas. </author> <title> Higher-order functors with transparent signatures. </title> <booktitle> In Twenty-second Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 154-163, </pages> <address> New York, Jan 1995. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Several recent papers <ref> [HMM90, Bis95, Ler95] </ref> have attacked similar problems but with completely different motivations; they also impose severe restrictions to their module languages (e.g., no type abbreviation or sharing inside signatures [HMM90], no parameterized types [Bis95], and limited forms of functor arguments [Ler95]). * Our compilation algorithm can handle the entire SML'97 language <p> Several recent papers [HMM90, Bis95, Ler95] have attacked similar problems but with completely different motivations; they also impose severe restrictions to their module languages (e.g., no type abbreviation or sharing inside signatures [HMM90], no parameterized types <ref> [Bis95] </ref>, and limited forms of functor arguments [Ler95]). * Our compilation algorithm can handle the entire SML'97 language [MTHM97] including both transparent and opaque signature matching. In fact, the algorithm has been implemented and released with the SML/NJ compiler since version 109.24 (January 9, 1997). <p> This paper shows that at least from the implementation point of view, full transparency is important in providing optimal support to efficient cross-module compilation. The question of whether higher-order modules can be compiled into simple F ! -like calculus has been open for a while. Several recent papers <ref> [HMM90, Bis95, Ler95] </ref> have attacked variants of this problem with different motivations; however, they all impose severe restrictions to their module languages. <p> Harper and Stone [HS97] give a new type-theoretical semantics for the entire SML'97, however, their internal language, IL, contains a separate module calculus that uses translucent signatures. Biswas <ref> [Bis95] </ref> gives a semantics for the MacQueen-Tofte modules based on simple polymorphic types; however, his algorithm does not support parameterized type constructors.
Reference: [Car97] <author> Luca Cardelli. </author> <title> Program fragments, linking, and modularization. </title> <booktitle> In Proc. 24th Annual ACM SIGPLAN-SIGACT Symp. on Principles of Programming Languages, </booktitle> <pages> pages 266-277. </pages> <publisher> ACM Press, </publisher> <year> 1997. </year>
Reference-contexts: use a more sophisticated signature instantiation algorithm to calculate the set of flexible type components in a signature. 5.7 Relationship to separate compilation Several recent papers [Ler94, HL94] argued that the SML'90 module language [MTH90] provides poor support to Modula-2-like true separate compilation, especially under those scenarios described by Cardelli <ref> [Car97] </ref>. The new SML'97 module language fixed some of these problems by supporting opaque signature matching and type 22 abbreviations in signatures. Still, an SML'97 program fragment cannot be closed over all of its free functor variables since modules in SML'97 does not allow parameterization over other functors.
Reference: [Cha92] <author> Craig Chambers. </author> <title> The Design and Implementation of the SELF Compiler, an Optimizing Compiler for Object-Oriented Programming Languages. </title> <type> PhD thesis, </type> <institution> Stanford University, Stanford, California, </institution> <month> March </month> <year> 1992. </year>
Reference-contexts: SA = struct type s = int val f = 3 structure SB = struct functor F (X : ASIG) = struct type s = X.s -&gt; X.s fun f (x : X.s) = X.f end functor APP (B : BSIG) = B.F (SA) structure SC = APP (SB) specialization <ref> [Cha92] </ref>, intensional type analysis [HM95], typed closure conversion [MMH96], tagless garbage collection [Tol94], to name just a few. All of these are performed on the variants of core ML [DM82] or the polymorphic -calculus F ! [Gir72, Rey74].
Reference: [Cou97] <author> Judicael Courant. </author> <title> An applicative module calculus. </title> <editor> In Michel Bidoit and Max Dauchet, editors, TAP-SOFT'97: </editor> <booktitle> Theory and Practice of Software Development: </booktitle> <volume> LNCS Vol 1214, </volume> <pages> pages 622-636, </pages> <address> New York, 1997. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: These problems were heavily researched [HL94, Ler94, Ler95, Lil97, Tof92, MT94, Jon96] and mostly resolved in SML'97 [MTHM97]. The main remaining issue is with the design of higher-order modules, with proposals ranging from fully transparent ones [MT94], to applicative functors <ref> [Ler95, Cou97] </ref>, or abstract functors [HL94, Ler94, Lil97]. Fully transparent modules are most expressive, but it is not clear whether they are absolutely necessary; they also interact poorly with true separate compilation [Ler94].
Reference: [DM82] <author> Luis Damas and Robin Milner. </author> <title> Principal type-schemes for functional programs. </title> <booktitle> In Ninth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 207-212, </pages> <address> New York, Jan 1982. </address> <publisher> ACM Press. </publisher>
Reference-contexts: It is fair to say that the type systems for higher-order modules is much more elaborate than (or at least very different from) those for the core-ML-like languages <ref> [DM82] </ref>. This semantic difference between the core and module languages poses great challenges to compiler writers. Although the module code itself seldom needs to be compiled efficiently, optimizations used for the core language must be compatible with the module constructs in order to have a coherent compiler. <p> All of these are performed on the variants of core ML <ref> [DM82] </ref> or the polymorphic -calculus F ! [Gir72, Rey74]. While they have all demonstrated that types can be used to make programs run faster and consume less space, it is not obvious how any of these would work in the presence of higher-order modules (which make use of dependent types).
Reference: [FSDF93] <author> Cormac Flanagan, Amr Sabry, Bruce F. Duba, and Matthias Felleisen. </author> <title> The essence of compiling with continuations. </title> <booktitle> In Proc. ACM SIGPLAN '93 Conf. on Prog. Lang. Design and Implementation, </booktitle> <pages> pages 237-247, </pages> <address> New York, June 1993. </address> <publisher> ACM Press. </publisher>
Reference: [Geo97] <author> Lal George. MLRISC: </author> <title> Customizable and reusable code generators. </title> <type> Technical memorandum, </type> <institution> AT&T Bell Laboratories, </institution> <address> Murray Hill, NJ, </address> <year> 1997. </year>
Reference-contexts: 1 Introduction Modular programming has proven to be extremely valuable in the development and maintenance of large software systems <ref> [BHLM94, Nel91, Geo97] </ref>. Many modern programming languages such as Modula-3 [Nel91] and Standard ML [MTH90, MTHM97] provide support for both core-level and module-level programming. The core language, in general, deals with the detailed implementation of algorithms in terms of data structures and control constructs.
Reference: [Gir72] <author> J. Y. Girard. </author> <title> Interpretation Fonctionnelle et Elimination des Coupures dans l'Arithmetique d'Ordre Su-perieur. </title> <type> PhD thesis, </type> <institution> University of Paris VII, </institution> <year> 1972. </year>
Reference-contexts: All of these are performed on the variants of core ML [DM82] or the polymorphic -calculus F ! <ref> [Gir72, Rey74] </ref>. While they have all demonstrated that types can be used to make programs run faster and consume less space, it is not obvious how any of these would work in the presence of higher-order modules (which make use of dependent types).
Reference: [HL94] <author> Robert Harper and Mark Lillibridge. </author> <title> A type-theoretic approach to higher-order modules with sharing. </title> <booktitle> In Twenty-first Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 123-137, </pages> <address> New York, Jan 1994. </address> <publisher> ACM Press. </publisher>
Reference-contexts: The module language, on the other hand, provides glue to organize large programs and to build generic and reusable components. A mature and scalable compiler must support both styles of programming well, generating decent code even for heavily modularized programs. ML-style higher-order modules <ref> [MT94, HL94, Ler95] </ref> are widely recognized as one of the most powerful module constructs in existence today. Recent work on the type-theoretic foundations of ML modules [HL94, Ler94, MTHM97] has cleaned up many rough spots in the original design [MTH90]. <p> A mature and scalable compiler must support both styles of programming well, generating decent code even for heavily modularized programs. ML-style higher-order modules [MT94, HL94, Ler95] are widely recognized as one of the most powerful module constructs in existence today. Recent work on the type-theoretic foundations of ML modules <ref> [HL94, Ler94, MTHM97] </ref> has cleaned up many rough spots in the original design [MTH90]. Still, the semantics for higher-order modules involves the use of dependent types [Mac86, HM93] or translucent signatures [HL94, Ler94]. <p> Recent work on the type-theoretic foundations of ML modules [HL94, Ler94, MTHM97] has cleaned up many rough spots in the original design [MTH90]. Still, the semantics for higher-order modules involves the use of dependent types [Mac86, HM93] or translucent signatures <ref> [HL94, Ler94] </ref>. MacQueen and Tofte [MT94] have shown that even a small restriction on signature matching [Ler94, HL94] can significantly compromise the overall expressiveness (i.e., full transparency) of the underlying module language. <p> Still, the semantics for higher-order modules involves the use of dependent types [Mac86, HM93] or translucent signatures [HL94, Ler94]. MacQueen and Tofte [MT94] have shown that even a small restriction on signature matching <ref> [Ler94, HL94] </ref> can significantly compromise the overall expressiveness (i.e., full transparency) of the underlying module language. It is fair to say that the type systems for higher-order modules is much more elaborate than (or at least very different from) those for the core-ML-like languages [DM82]. <p> Our implementation does not eliminate such type sharing, instead, we use a more sophisticated signature instantiation algorithm to calculate the set of flexible type components in a signature. 5.7 Relationship to separate compilation Several recent papers <ref> [Ler94, HL94] </ref> argued that the SML'90 module language [MTH90] provides poor support to Modula-2-like true separate compilation, especially under those scenarios described by Cardelli [Car97]. The new SML'97 module language fixed some of these problems by supporting opaque signature matching and type 22 abbreviations in signatures. <p> The SML'90 module language, however, contains several major problems; for example, type abbreviations are not allowed in signatures, opaque signature matching is not supported, and modules are first-order only. These problems were heavily researched <ref> [HL94, Ler94, Ler95, Lil97, Tof92, MT94, Jon96] </ref> and mostly resolved in SML'97 [MTHM97]. The main remaining issue is with the design of higher-order modules, with proposals ranging from fully transparent ones [MT94], to applicative functors [Ler95, Cou97], or abstract functors [HL94, Ler94, Lil97]. <p> These problems were heavily researched [HL94, Ler94, Ler95, Lil97, Tof92, MT94, Jon96] and mostly resolved in SML'97 [MTHM97]. The main remaining issue is with the design of higher-order modules, with proposals ranging from fully transparent ones [MT94], to applicative functors [Ler95, Cou97], or abstract functors <ref> [HL94, Ler94, Lil97] </ref>. Fully transparent modules are most expressive, but it is not clear whether they are absolutely necessary; they also interact poorly with true separate compilation [Ler94]. <p> The operational nature of this approach makes it good for efficient implementations but harder for formal reasonings. A more type-theoretic approach is to use existential types or manifest types to module type abstraction <ref> [Ler94, HL94] </ref>. However, none of the existing type-theoretic approaches have been able to model the full-transparency property in the MacQueen-Tofte system. Both Lillibridge [Lil97] and Leroy [Ler96a] discussed how to add value identities to their module interfaces though neither of them gave any actual algorithm.
Reference: [HM93] <author> Robert Harper and John C. Mitchell. </author> <title> On the type structure of Standard ML. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 15(2) </volume> <pages> 211-252, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: Recent work on the type-theoretic foundations of ML modules [HL94, Ler94, MTHM97] has cleaned up many rough spots in the original design [MTH90]. Still, the semantics for higher-order modules involves the use of dependent types <ref> [Mac86, HM93] </ref> or translucent signatures [HL94, Ler94]. MacQueen and Tofte [MT94] have shown that even a small restriction on signature matching [Ler94, HL94] can significantly compromise the overall expressiveness (i.e., full transparency) of the underlying module language. <p> The ML module system was first proposed by MacQueen [Mac86] and later incorporated into Standard ML [MTH90]. Harper and Mitchell <ref> [HM93] </ref> show that the SML'90 module language can be translated into a typed lambda calculus (XML) with dependent types. Together with Moggi, they later show that even in the presence of dependent types, type-checking of XML is still decidable [HMM90], thanks to the phase-distinction property of ML-style modules.
Reference: [HM95] <author> Robert Harper and Greg Morrisett. </author> <title> Compiling polymorphism using intensional type analysis. </title> <booktitle> In Twenty-second Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 130-141, </pages> <address> New York, Jan 1995. </address> <publisher> ACM Press. </publisher>
Reference-contexts: s = int val f = 3 structure SB = struct functor F (X : ASIG) = struct type s = X.s -&gt; X.s fun f (x : X.s) = X.f end functor APP (B : BSIG) = B.F (SA) structure SC = APP (SB) specialization [Cha92], intensional type analysis <ref> [HM95] </ref>, typed closure conversion [MMH96], tagless garbage collection [Tol94], to name just a few. All of these are performed on the variants of core ML [DM82] or the polymorphic -calculus F ! [Gir72, Rey74]. <p> Therefore, polymorphic functions in F ! or core ML can be specialized to particular type arguments at compile time. Furthermore, both representation analysis [Ler92, Sha97a] and intensional type analysis <ref> [HM95] </ref> can be performed, inserting coercions or runtime type parameters at every type-application site. Higher-order modules, on the other hand, express both the type and value abstractions through a single construct (i.e., functor). <p> The main contributions of this paper are: * As far as we know, our work is the first comprehensive and formal study on how to apply type-based compilation techniques <ref> [Ler92, Tol94, HM95, MMH96, Sha97a] </ref> to programs using ML-style modules. <p> The product and selection constructors correspond to the product kind fl :: t ; :::; l 0 :: 0 t g. Types in TGC include the monotypes, and are closed under products, function spaces, and polymorphic quantification. Following Harper and Morrisett <ref> [HM95] </ref>, we use T () to denote the corresponding monotype of the constructor . The terms are an explicitly typed -calculus with explicit constructor abstraction (fl) and application forms. <p> Figure 4 gives the typing rules for the product-related constructors and terms. The rest of the rules are all standard, as shown in Appendix A. It is well known that type-checking for the TGC-like calculus is decidable, and furthermore, its typing rules are consistent with properly defined operational semantics <ref> [Mor95, HM95] </ref>. 3 Module semantics and translation To show how we translate the ML-style modules into the TGC calculus, we choose a surface language (SFC) that is similar to the SML'97 module language [MTHM97] extended with the MacQueen-Tofte higher-order modules [MT94]. <p> Shao and Appel [SA95] extended Leroy's representation analysis [Ler92] to work for the SML'90 modules; their algorithm works only for the pure-coercion-based representation analysis [Ler92]. The algorithm in this paper translates the module language into the F ! calculus, so type-based optimizations <ref> [Ler92, Sha97a, HM95, MMH96, Tol94] </ref> that work for F ! immediately work for higher-order modules as well. 7 Conclusions We have presented a series of techniques for compiling across higher-order modules. These techniques have been implemented and released with the SML/NJ compiler since version 109.24 (January 9, 1997). <p> The main contribution of our work is the translation algorithm from ML-style modules (SML'97 extended with MacQueen-Tofte higher-order modules) to the F ! calculus. Without such translation, none of those important type-based optimizations <ref> [HM95, Sha97a, Sha97b] </ref> would apply to the full SML language. We have also presented ways to extend various program analyses to work across higher-order modules; in fact, we show that for fully transparent modules, static information can always be optimally propagated across the module boundaries.
Reference: [HMM90] <author> Robert Harper, John C. Mitchell, and Eugenio Moggi. </author> <title> Higher-order modules and the phase distinction. </title> <booktitle> In Seventeenth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 341-344, </pages> <address> New York, Jan 1990. </address> <publisher> ACM Press. </publisher> <pages> 26 </pages>
Reference-contexts: The challenge then is to deduce these properties statically while still supporting separate compilation. This paper exploits the semantic property <ref> [HMM90] </ref> of ML-style modules to support efficient cross-module compilation. More specifically, we present a type-directed translation of the MacQueen-Tofte higher-order modules [MT94] into a predicative variant of the F ! calculus. <p> Because modules can be compiled in the same way as ordinary polymorphic functions, all the type-based optimizations mentioned above immediately carry over to the module languages. The basic idea of our algorithm is similar to phase-splitting <ref> [HMM90] </ref>: we notice that every ML module can be split into a type part and a value part; the type (value) part of a structure includes all of its type (value) components plus the type (value) parts of its structure and functor components; the type part of a functor is a <p> Several recent papers <ref> [HMM90, Bis95, Ler95] </ref> have attacked similar problems but with completely different motivations; they also impose severe restrictions to their module languages (e.g., no type abbreviation or sharing inside signatures [HMM90], no parameterized types [Bis95], and limited forms of functor arguments [Ler95]). * Our compilation algorithm can handle the entire SML'97 language <p> Several recent papers [HMM90, Bis95, Ler95] have attacked similar problems but with completely different motivations; they also impose severe restrictions to their module languages (e.g., no type abbreviation or sharing inside signatures <ref> [HMM90] </ref>, no parameterized types [Bis95], and limited forms of functor arguments [Ler95]). * Our compilation algorithm can handle the entire SML'97 language [MTHM97] including both transparent and opaque signature matching. In fact, the algorithm has been implemented and released with the SML/NJ compiler since version 109.24 (January 9, 1997). <p> We show how to exploit the full-transparency property to support cross-module program analysis. Finally, we discuss implementation details, related work, and then conclude. 2 An F ! -based target calculus Our target calculus TGC is a predicative variant <ref> [HMM90] </ref> of the polymorphic -calculus F ! . The syntax of TGC is given in Figure 2. Here, kinds classify type constructors (tycon); types classify terms. Declarations (dec) and the term let d t in e t are syntactic sugar introduced to simplify the presentation of our translation algorithm. <p> Harper and Mitchell [HM93] show that the SML'90 module language can be translated into a typed lambda calculus (XML) with dependent types. Together with Moggi, they later show that even in the presence of dependent types, type-checking of XML is still decidable <ref> [HMM90] </ref>, thanks to the phase-distinction property of ML-style modules. The SML'90 module language, however, contains several major problems; for example, type abbreviations are not allowed in signatures, opaque signature matching is not supported, and modules are first-order only. <p> This paper shows that at least from the implementation point of view, full transparency is important in providing optimal support to efficient cross-module compilation. The question of whether higher-order modules can be compiled into simple F ! -like calculus has been open for a while. Several recent papers <ref> [HMM90, Bis95, Ler95] </ref> have attacked variants of this problem with different motivations; however, they all impose severe restrictions to their module languages. <p> Several recent papers [HMM90, Bis95, Ler95] have attacked variants of this problem with different motivations; however, they all impose severe restrictions to their module languages. The algorithm hidden inside Harper, Mitchell, and Moggi's phase-distinction paper <ref> [HMM90] </ref> is most related, however, it does not support type abbreviation and sharing in signatures. 2 Supporting type abbreviation is non-trivial, as discovered by Morrisett [Mor97] and also demonstrated in this paper. <p> Finally, Leroy [Ler95] uses applicative functors to achieve full transparency, but his approach handles limited 2 Although the paper by Harper et al <ref> [HMM90] </ref> was published in 1990, the importance of its phase-splitting algorithm was not recognized until very recently. In fact, we reinvented the same algorithm while working on the type-directed compilation of ML-style modules during 1996. <p> The first version of our algorithm was presented at the IFIP WG2.8 meeting in September 1996. It was at that meeting when Bob Harper pointed us to the phase-distinction paper. In January 1997, Greg Morrisett [Mor97] told us that he had problems adapting the original phase-splitting algorithm <ref> [HMM90] </ref> to SML [MTHM97] since it does not support type abbreviations in signatures.
Reference: [HS97] <author> Robert Harper and Chris Stone. </author> <title> An interpretation of Standard ML in type theory. </title> <type> Technical Report CMU-CS-97-147, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: The algorithm hidden inside Harper, Mitchell, and Moggi's phase-distinction paper [HMM90] is most related, however, it does not support type abbreviation and sharing in signatures. 2 Supporting type abbreviation is non-trivial, as discovered by Morrisett [Mor97] and also demonstrated in this paper. Harper and Stone <ref> [HS97] </ref> give a new type-theoretical semantics for the entire SML'97, however, their internal language, IL, contains a separate module calculus that uses translucent signatures. Biswas [Bis95] gives a semantics for the MacQueen-Tofte modules based on simple polymorphic types; however, his algorithm does not support parameterized type constructors.
Reference: [Jon91] <author> Neil D. Jones. </author> <title> Partial evaluation. </title> <booktitle> POPL'91, tutorial handout, </booktitle> <month> January </month> <year> 1991. </year>
Reference-contexts: Higher-order modules also make it very difficult to carry out static program analysis across the module boundaries. Because the module signature does not propagate any static information other than types, many existing techniques, such as constant propagation, function inlining [App92], partial evaluation <ref> [Jon91] </ref>, 2 and constraint-based analysis [AH95], lose all their information at the functor-application boundaries.
Reference: [Jon96] <author> Mark P. Jones. </author> <title> Using parameterized signatures to express modular structure. </title> <booktitle> In Twenty-third Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 68-78, </pages> <address> New York, Jan 1996. </address> <publisher> ACM Press. </publisher>
Reference-contexts: The SML'90 module language, however, contains several major problems; for example, type abbreviations are not allowed in signatures, opaque signature matching is not supported, and modules are first-order only. These problems were heavily researched <ref> [HL94, Ler94, Ler95, Lil97, Tof92, MT94, Jon96] </ref> and mostly resolved in SML'97 [MTHM97]. The main remaining issue is with the design of higher-order modules, with proposals ranging from fully transparent ones [MT94], to applicative functors [Ler95, Cou97], or abstract functors [HL94, Ler94, Lil97].
Reference: [Ler92] <author> Xavier Leroy. </author> <title> Unboxed objects and polymorphic typing. </title> <booktitle> In Nineteenth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 177-188, </pages> <address> New York, </address> <month> Jan </month> <year> 1992. </year> <note> ACM Press. Longer version available as INRIA Tech Report. </note>
Reference-contexts: Unfortunately, many compilation techniques do not work on programs that use higher-order modules. In fact, most recent work on compiling functional languages have ignored issues on the necessary module support. Take the area of type-directed compilation as an example: recent work includes representation analysis <ref> [Ler92, Sha97a] </ref>, type This research was sponsored in part by the Defense Advanced Research Projects Agency ITO under the title "Software Evolution using HOT Language Technology," DARPA Order No. D888, issued under Contract No. F30602-96-2-0232, and in part by an NSF CAREER Award CCR-9501624, and NSF Grant CCR-9633390. <p> Therefore, polymorphic functions in F ! or core ML can be specialized to particular type arguments at compile time. Furthermore, both representation analysis <ref> [Ler92, Sha97a] </ref> and intensional type analysis [HM95] can be performed, inserting coercions or runtime type parameters at every type-application site. Higher-order modules, on the other hand, express both the type and value abstractions through a single construct (i.e., functor). <p> The main contributions of this paper are: * As far as we know, our work is the first comprehensive and formal study on how to apply type-based compilation techniques <ref> [Ler92, Tol94, HM95, MMH96, Sha97a] </ref> to programs using ML-style modules. <p> We are currently working together on an inlining algorithm that combines the best of both schemes. Type-directed compilation has received much attention lately, but little has been done to extend it to work across higher-order modules. Shao and Appel [SA95] extended Leroy's representation analysis <ref> [Ler92] </ref> to work for the SML'90 modules; their algorithm works only for the pure-coercion-based representation analysis [Ler92]. <p> Type-directed compilation has received much attention lately, but little has been done to extend it to work across higher-order modules. Shao and Appel [SA95] extended Leroy's representation analysis <ref> [Ler92] </ref> to work for the SML'90 modules; their algorithm works only for the pure-coercion-based representation analysis [Ler92]. The algorithm in this paper translates the module language into the F ! calculus, so type-based optimizations [Ler92, Sha97a, HM95, MMH96, Tol94] that work for F ! immediately work for higher-order modules as well. 7 Conclusions We have presented a series of techniques for compiling across higher-order modules. <p> Shao and Appel [SA95] extended Leroy's representation analysis [Ler92] to work for the SML'90 modules; their algorithm works only for the pure-coercion-based representation analysis [Ler92]. The algorithm in this paper translates the module language into the F ! calculus, so type-based optimizations <ref> [Ler92, Sha97a, HM95, MMH96, Tol94] </ref> that work for F ! immediately work for higher-order modules as well. 7 Conclusions We have presented a series of techniques for compiling across higher-order modules. These techniques have been implemented and released with the SML/NJ compiler since version 109.24 (January 9, 1997).
Reference: [Ler94] <author> Xavier Leroy. </author> <title> Manifest types, modules, and separate compilation. </title> <booktitle> In Twenty-first Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 109-122, </pages> <address> New York, Jan 1994. </address> <publisher> ACM Press. </publisher>
Reference-contexts: A mature and scalable compiler must support both styles of programming well, generating decent code even for heavily modularized programs. ML-style higher-order modules [MT94, HL94, Ler95] are widely recognized as one of the most powerful module constructs in existence today. Recent work on the type-theoretic foundations of ML modules <ref> [HL94, Ler94, MTHM97] </ref> has cleaned up many rough spots in the original design [MTH90]. Still, the semantics for higher-order modules involves the use of dependent types [Mac86, HM93] or translucent signatures [HL94, Ler94]. <p> Recent work on the type-theoretic foundations of ML modules [HL94, Ler94, MTHM97] has cleaned up many rough spots in the original design [MTH90]. Still, the semantics for higher-order modules involves the use of dependent types [Mac86, HM93] or translucent signatures <ref> [HL94, Ler94] </ref>. MacQueen and Tofte [MT94] have shown that even a small restriction on signature matching [Ler94, HL94] can significantly compromise the overall expressiveness (i.e., full transparency) of the underlying module language. <p> Still, the semantics for higher-order modules involves the use of dependent types [Mac86, HM93] or translucent signatures [HL94, Ler94]. MacQueen and Tofte [MT94] have shown that even a small restriction on signature matching <ref> [Ler94, HL94] </ref> can significantly compromise the overall expressiveness (i.e., full transparency) of the underlying module language. It is fair to say that the type systems for higher-order modules is much more elaborate than (or at least very different from) those for the core-ML-like languages [DM82]. <p> Our implementation does not eliminate such type sharing, instead, we use a more sophisticated signature instantiation algorithm to calculate the set of flexible type components in a signature. 5.7 Relationship to separate compilation Several recent papers <ref> [Ler94, HL94] </ref> argued that the SML'90 module language [MTH90] provides poor support to Modula-2-like true separate compilation, especially under those scenarios described by Cardelli [Car97]. The new SML'97 module language fixed some of these problems by supporting opaque signature matching and type 22 abbreviations in signatures. <p> The SML'90 module language, however, contains several major problems; for example, type abbreviations are not allowed in signatures, opaque signature matching is not supported, and modules are first-order only. These problems were heavily researched <ref> [HL94, Ler94, Ler95, Lil97, Tof92, MT94, Jon96] </ref> and mostly resolved in SML'97 [MTHM97]. The main remaining issue is with the design of higher-order modules, with proposals ranging from fully transparent ones [MT94], to applicative functors [Ler95, Cou97], or abstract functors [HL94, Ler94, Lil97]. <p> These problems were heavily researched [HL94, Ler94, Ler95, Lil97, Tof92, MT94, Jon96] and mostly resolved in SML'97 [MTHM97]. The main remaining issue is with the design of higher-order modules, with proposals ranging from fully transparent ones [MT94], to applicative functors [Ler95, Cou97], or abstract functors <ref> [HL94, Ler94, Lil97] </ref>. Fully transparent modules are most expressive, but it is not clear whether they are absolutely necessary; they also interact poorly with true separate compilation [Ler94]. <p> Fully transparent modules are most expressive, but it is not clear whether they are absolutely necessary; they also interact poorly with true separate compilation <ref> [Ler94] </ref>. This paper shows that at least from the implementation point of view, full transparency is important in providing optimal support to efficient cross-module compilation. The question of whether higher-order modules can be compiled into simple F ! -like calculus has been open for a while. <p> The operational nature of this approach makes it good for efficient implementations but harder for formal reasonings. A more type-theoretic approach is to use existential types or manifest types to module type abstraction <ref> [Ler94, HL94] </ref>. However, none of the existing type-theoretic approaches have been able to model the full-transparency property in the MacQueen-Tofte system. Both Lillibridge [Lil97] and Leroy [Ler96a] discussed how to add value identities to their module interfaces though neither of them gave any actual algorithm.
Reference: [Ler95] <author> Xavier Leroy. </author> <title> Applicative functors and fully transparent higher-order modules. </title> <booktitle> In Twenty-second Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 142-153, </pages> <address> New York, Jan 1995. </address> <publisher> ACM Press. </publisher>
Reference-contexts: The module language, on the other hand, provides glue to organize large programs and to build generic and reusable components. A mature and scalable compiler must support both styles of programming well, generating decent code even for heavily modularized programs. ML-style higher-order modules <ref> [MT94, HL94, Ler95] </ref> are widely recognized as one of the most powerful module constructs in existence today. Recent work on the type-theoretic foundations of ML modules [HL94, Ler94, MTHM97] has cleaned up many rough spots in the original design [MTH90]. <p> Several recent papers <ref> [HMM90, Bis95, Ler95] </ref> have attacked similar problems but with completely different motivations; they also impose severe restrictions to their module languages (e.g., no type abbreviation or sharing inside signatures [HMM90], no parameterized types [Bis95], and limited forms of functor arguments [Ler95]). * Our compilation algorithm can handle the entire SML'97 language <p> Several recent papers [HMM90, Bis95, Ler95] have attacked similar problems but with completely different motivations; they also impose severe restrictions to their module languages (e.g., no type abbreviation or sharing inside signatures [HMM90], no parameterized types [Bis95], and limited forms of functor arguments <ref> [Ler95] </ref>). * Our compilation algorithm can handle the entire SML'97 language [MTHM97] including both transparent and opaque signature matching. In fact, the algorithm has been implemented and released with the SML/NJ compiler since version 109.24 (January 9, 1997). <p> The SML'90 module language, however, contains several major problems; for example, type abbreviations are not allowed in signatures, opaque signature matching is not supported, and modules are first-order only. These problems were heavily researched <ref> [HL94, Ler94, Ler95, Lil97, Tof92, MT94, Jon96] </ref> and mostly resolved in SML'97 [MTHM97]. The main remaining issue is with the design of higher-order modules, with proposals ranging from fully transparent ones [MT94], to applicative functors [Ler95, Cou97], or abstract functors [HL94, Ler94, Lil97]. <p> These problems were heavily researched [HL94, Ler94, Ler95, Lil97, Tof92, MT94, Jon96] and mostly resolved in SML'97 [MTHM97]. The main remaining issue is with the design of higher-order modules, with proposals ranging from fully transparent ones [MT94], to applicative functors <ref> [Ler95, Cou97] </ref>, or abstract functors [HL94, Ler94, Lil97]. Fully transparent modules are most expressive, but it is not clear whether they are absolutely necessary; they also interact poorly with true separate compilation [Ler94]. <p> This paper shows that at least from the implementation point of view, full transparency is important in providing optimal support to efficient cross-module compilation. The question of whether higher-order modules can be compiled into simple F ! -like calculus has been open for a while. Several recent papers <ref> [HMM90, Bis95, Ler95] </ref> have attacked variants of this problem with different motivations; however, they all impose severe restrictions to their module languages. <p> Another difference is that in his scheme, functors are not considered as higher-order type constructors, instead, he has to encode certain type constructors of kind using higher-order types; this significantly complicates his semantics. Finally, Leroy <ref> [Ler95] </ref> uses applicative functors to achieve full transparency, but his approach handles limited 2 Although the paper by Harper et al [HMM90] was published in 1990, the importance of its phase-splitting algorithm was not recognized until very recently.
Reference: [Ler96a] <author> Xavier Leroy. </author> <title> A modular module system. </title> <type> Technical report 2866, </type> <institution> INRIA, </institution> <month> April </month> <year> 1996. </year>
Reference-contexts: A more type-theoretic approach is to use existential types or manifest types to module type abstraction [Ler94, HL94]. However, none of the existing type-theoretic approaches have been able to model the full-transparency property in the MacQueen-Tofte system. Both Lillibridge [Lil97] and Leroy <ref> [Ler96a] </ref> discussed how to add value identities to their module interfaces though neither of them gave any actual algorithm. Blume and Appel [BA97] proposed a cross-module inlining algorithm that supports inlining of functions with free variables.
Reference: [Ler96b] <author> Xavier Leroy. </author> <title> A syntactic theory of type generativity and sharing. </title> <journal> Journal of Functional Programming, </journal> <volume> 6(5) </volume> <pages> 1-32, </pages> <month> September </month> <year> 1996. </year>
Reference-contexts: A type specification can either be a flexible one|specifying only the arity of the underlying type constructor; or it can be a type abbreviation. Type-sharing specifications in SFC are converted into type abbreviations <ref> [Ler96b] </ref>. A structure expression can be a structure path (p s ), a functor application (f i (s i )), a structure matched by a signature (s i : M s ), or a definitional structure (m b ).
Reference: [Lil97] <author> Mark Lillibridge. </author> <title> Translucent Sums: A Foundation for Higher-Order Module Systems. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> May </month> <year> 1997. </year> <note> Tech Report CMU-CS-97-122. </note>
Reference-contexts: The SML'90 module language, however, contains several major problems; for example, type abbreviations are not allowed in signatures, opaque signature matching is not supported, and modules are first-order only. These problems were heavily researched <ref> [HL94, Ler94, Ler95, Lil97, Tof92, MT94, Jon96] </ref> and mostly resolved in SML'97 [MTHM97]. The main remaining issue is with the design of higher-order modules, with proposals ranging from fully transparent ones [MT94], to applicative functors [Ler95, Cou97], or abstract functors [HL94, Ler94, Lil97]. <p> These problems were heavily researched [HL94, Ler94, Ler95, Lil97, Tof92, MT94, Jon96] and mostly resolved in SML'97 [MTHM97]. The main remaining issue is with the design of higher-order modules, with proposals ranging from fully transparent ones [MT94], to applicative functors [Ler95, Cou97], or abstract functors <ref> [HL94, Ler94, Lil97] </ref>. Fully transparent modules are most expressive, but it is not clear whether they are absolutely necessary; they also interact poorly with true separate compilation [Ler94]. <p> A more type-theoretic approach is to use existential types or manifest types to module type abstraction [Ler94, HL94]. However, none of the existing type-theoretic approaches have been able to model the full-transparency property in the MacQueen-Tofte system. Both Lillibridge <ref> [Lil97] </ref> and Leroy [Ler96a] discussed how to add value identities to their module interfaces though neither of them gave any actual algorithm. Blume and Appel [BA97] proposed a cross-module inlining algorithm that supports inlining of functions with free variables.
Reference: [Mac86] <author> David MacQueen. </author> <title> Using dependent types to express modular structure. </title> <booktitle> In Proc. 13th Annual ACM SIGPLAN-SIGACT Symp. on Principles of Programming Languages, </booktitle> <pages> pages 277-286. </pages> <publisher> ACM Press, </publisher> <year> 1986. </year>
Reference-contexts: Recent work on the type-theoretic foundations of ML modules [HL94, Ler94, MTHM97] has cleaned up many rough spots in the original design [MTH90]. Still, the semantics for higher-order modules involves the use of dependent types <ref> [Mac86, HM93] </ref> or translucent signatures [HL94, Ler94]. MacQueen and Tofte [MT94] have shown that even a small restriction on signature matching [Ler94, HL94] can significantly compromise the overall expressiveness (i.e., full transparency) of the underlying module language. <p> The ML module system was first proposed by MacQueen <ref> [Mac86] </ref> and later incorporated into Standard ML [MTH90]. Harper and Mitchell [HM93] show that the SML'90 module language can be translated into a typed lambda calculus (XML) with dependent types.
Reference: [MMH96] <author> Yasuhiko Minamide, Greg Morrisett, and Robert Harper. </author> <title> Typed closure conversion. </title> <booktitle> In Proc. 23rd Annual ACM SIGPLAN-SIGACT Symp. on Principles of Programming Languages, </booktitle> <pages> pages 271-283. </pages> <publisher> ACM Press, </publisher> <year> 1996. </year>
Reference-contexts: f = 3 structure SB = struct functor F (X : ASIG) = struct type s = X.s -&gt; X.s fun f (x : X.s) = X.f end functor APP (B : BSIG) = B.F (SA) structure SC = APP (SB) specialization [Cha92], intensional type analysis [HM95], typed closure conversion <ref> [MMH96] </ref>, tagless garbage collection [Tol94], to name just a few. All of these are performed on the variants of core ML [DM82] or the polymorphic -calculus F ! [Gir72, Rey74]. <p> The main contributions of this paper are: * As far as we know, our work is the first comprehensive and formal study on how to apply type-based compilation techniques <ref> [Ler92, Tol94, HM95, MMH96, Sha97a] </ref> to programs using ML-style modules. <p> Shao and Appel [SA95] extended Leroy's representation analysis [Ler92] to work for the SML'90 modules; their algorithm works only for the pure-coercion-based representation analysis [Ler92]. The algorithm in this paper translates the module language into the F ! calculus, so type-based optimizations <ref> [Ler92, Sha97a, HM95, MMH96, Tol94] </ref> that work for F ! immediately work for higher-order modules as well. 7 Conclusions We have presented a series of techniques for compiling across higher-order modules. These techniques have been implemented and released with the SML/NJ compiler since version 109.24 (January 9, 1997).
Reference: [Mor95] <author> Greg Morrisett. </author> <title> Compiling with Types. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> December </month> <year> 1995. </year> <note> Tech Report CMU-CS-95-226. </note>
Reference-contexts: Figure 4 gives the typing rules for the product-related constructors and terms. The rest of the rules are all standard, as shown in Appendix A. It is well known that type-checking for the TGC-like calculus is decidable, and furthermore, its typing rules are consistent with properly defined operational semantics <ref> [Mor95, HM95] </ref>. 3 Module semantics and translation To show how we translate the ML-style modules into the TGC calculus, we choose a surface language (SFC) that is similar to the SML'97 module language [MTHM97] extended with the MacQueen-Tofte higher-order modules [MT94].
Reference: [Mor97] <author> Greg Morrisett. </author> <type> Personal Communication, </type> <institution> Cornell University, </institution> <month> January </month> <year> 1997. </year>
Reference-contexts: The algorithm hidden inside Harper, Mitchell, and Moggi's phase-distinction paper [HMM90] is most related, however, it does not support type abbreviation and sharing in signatures. 2 Supporting type abbreviation is non-trivial, as discovered by Morrisett <ref> [Mor97] </ref> and also demonstrated in this paper. Harper and Stone [HS97] give a new type-theoretical semantics for the entire SML'97, however, their internal language, IL, contains a separate module calculus that uses translucent signatures. <p> The first version of our algorithm was presented at the IFIP WG2.8 meeting in September 1996. It was at that meeting when Bob Harper pointed us to the phase-distinction paper. In January 1997, Greg Morrisett <ref> [Mor97] </ref> told us that he had problems adapting the original phase-splitting algorithm [HMM90] to SML [MTHM97] since it does not support type abbreviations in signatures.
Reference: [MT91] <author> Robin Milner and Mads Tofte. </author> <title> Commentary on Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1991. </year>
Reference-contexts: Our static semantics for higher-order modules is based on the the same stamp-based approach used in the official definitions for SML'90 <ref> [MTH90, MT91] </ref> and SML'97 [MTHM97]. The stamp-based semantics uses a global name set to model type generativity and type abstraction: a new type is represented as a fresh stamp not used in the current name set.
Reference: [MT94] <author> David MacQueen and Mads Tofte. </author> <title> A semantics for higher order functors. </title> <booktitle> In The 5th European Symposium on Programming, </booktitle> <pages> pages 409-423, </pages> <address> Berlin, </address> <month> April </month> <year> 1994. </year> <pages> Spinger-Verlag. </pages>
Reference-contexts: The module language, on the other hand, provides glue to organize large programs and to build generic and reusable components. A mature and scalable compiler must support both styles of programming well, generating decent code even for heavily modularized programs. ML-style higher-order modules <ref> [MT94, HL94, Ler95] </ref> are widely recognized as one of the most powerful module constructs in existence today. Recent work on the type-theoretic foundations of ML modules [HL94, Ler94, MTHM97] has cleaned up many rough spots in the original design [MTH90]. <p> Recent work on the type-theoretic foundations of ML modules [HL94, Ler94, MTHM97] has cleaned up many rough spots in the original design [MTH90]. Still, the semantics for higher-order modules involves the use of dependent types [Mac86, HM93] or translucent signatures [HL94, Ler94]. MacQueen and Tofte <ref> [MT94] </ref> have shown that even a small restriction on signature matching [Ler94, HL94] can significantly compromise the overall expressiveness (i.e., full transparency) of the underlying module language. <p> The challenge then is to deduce these properties statically while still supporting separate compilation. This paper exploits the semantic property [HMM90] of ML-style modules to support efficient cross-module compilation. More specifically, we present a type-directed translation of the MacQueen-Tofte higher-order modules <ref> [MT94] </ref> into a predicative variant of the F ! calculus. Because modules can be compiled in the same way as ordinary polymorphic functions, all the type-based optimizations mentioned above immediately carry over to the module languages. <p> MacQueen and Tofte's original semantics <ref> [MT94] </ref> does not address many important features such as type specifications, type declarations, and hidden module components. Our new semantics covers a much richer language and solves the remaining technical problems. <p> its typing rules are consistent with properly defined operational semantics [Mor95, HM95]. 3 Module semantics and translation To show how we translate the ML-style modules into the TGC calculus, we choose a surface language (SFC) that is similar to the SML'97 module language [MTHM97] extended with the MacQueen-Tofte higher-order modules <ref> [MT94] </ref>. We divide the translation from SFC to TGC into two steps: * First, we perform a series of syntactic transformations and normalizations, and then translate the SFC program into a normalized module calculus (NRC); * Second, we translate the NRC program into the TGC calculus. <p> inside the let expressions in SFC are pushed upwards and then turned into the NRC local declarations (see Appendix B for details). 3.2 Static semantics for NRC Before presenting the translation from NRC to TGC, we first give a new and more complete formal semantics for the MacQueen-Tofte higher-order modules <ref> [MT94] </ref> in the context of NRC. Under our stamp-based approach, the "type" of a module|also called the modtype in this paper|is expressed as a pair of a signature and a realization. <p> The most unusual aspect of our semantics is the rules for signature subsumption (see Rules 1-8 in Figure 8): they are much more restrictive than those used by MacQueen and Tofte <ref> [MT94] </ref>. To have one signature subsume another, both must contain the same number of components, following the same order (Rules 2 and 3); furthermore, the respective functor components must have syntactically equivalent signature (Rule 4). <p> The SML'90 module language, however, contains several major problems; for example, type abbreviations are not allowed in signatures, opaque signature matching is not supported, and modules are first-order only. These problems were heavily researched <ref> [HL94, Ler94, Ler95, Lil97, Tof92, MT94, Jon96] </ref> and mostly resolved in SML'97 [MTHM97]. The main remaining issue is with the design of higher-order modules, with proposals ranging from fully transparent ones [MT94], to applicative functors [Ler95, Cou97], or abstract functors [HL94, Ler94, Lil97]. <p> These problems were heavily researched [HL94, Ler94, Ler95, Lil97, Tof92, MT94, Jon96] and mostly resolved in SML'97 [MTHM97]. The main remaining issue is with the design of higher-order modules, with proposals ranging from fully transparent ones <ref> [MT94] </ref>, to applicative functors [Ler95, Cou97], or abstract functors [HL94, Ler94, Lil97]. Fully transparent modules are most expressive, but it is not clear whether they are absolutely necessary; they also interact poorly with true separate compilation [Ler94]. <p> Finally, we have presented a new and more complete formal definition for the MacQueen-Tofte higher-order modules; our new semantics covers a much richer language and solves all the remaining technical problems in MacQueen and Tofte's original proposal <ref> [MT94] </ref>. Availability The implementation discussed in this paper is now released with the Standard ML of New Jersey (SML/NJ) compiler and the FLINT/ML compiler [Sha97b]. SML/NJ is a joint work by Lucent, Princeton, Yale and AT&T. FLINT is a modern compiler infrastructure developed at Yale University.
Reference: [MTH90] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: 1 Introduction Modular programming has proven to be extremely valuable in the development and maintenance of large software systems [BHLM94, Nel91, Geo97]. Many modern programming languages such as Modula-3 [Nel91] and Standard ML <ref> [MTH90, MTHM97] </ref> provide support for both core-level and module-level programming. The core language, in general, deals with the detailed implementation of algorithms in terms of data structures and control constructs. The module language, on the other hand, provides glue to organize large programs and to build generic and reusable components. <p> ML-style higher-order modules [MT94, HL94, Ler95] are widely recognized as one of the most powerful module constructs in existence today. Recent work on the type-theoretic foundations of ML modules [HL94, Ler94, MTHM97] has cleaned up many rough spots in the original design <ref> [MTH90] </ref>. Still, the semantics for higher-order modules involves the use of dependent types [Mac86, HM93] or translucent signatures [HL94, Ler94]. MacQueen and Tofte [MT94] have shown that even a small restriction on signature matching [Ler94, HL94] can significantly compromise the overall expressiveness (i.e., full transparency) of the underlying module language. <p> Our implementation does not eliminate such type sharing, instead, we use a more sophisticated signature instantiation algorithm to calculate the set of flexible type components in a signature. 5.7 Relationship to separate compilation Several recent papers [Ler94, HL94] argued that the SML'90 module language <ref> [MTH90] </ref> provides poor support to Modula-2-like true separate compilation, especially under those scenarios described by Cardelli [Car97]. The new SML'97 module language fixed some of these problems by supporting opaque signature matching and type 22 abbreviations in signatures. <p> The ML module system was first proposed by MacQueen [Mac86] and later incorporated into Standard ML <ref> [MTH90] </ref>. Harper and Mitchell [HM93] show that the SML'90 module language can be translated into a typed lambda calculus (XML) with dependent types. <p> Our static semantics for higher-order modules is based on the the same stamp-based approach used in the official definitions for SML'90 <ref> [MTH90, MT91] </ref> and SML'97 [MTHM97]. The stamp-based semantics uses a global name set to model type generativity and type abstraction: a new type is represented as a fresh stamp not used in the current name set.
Reference: [MTHM97] <author> Robin Milner, Mads Tofte, Robert Harper, and David MacQueen. </author> <title> The Definition of Standard ML (Revised). </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1997. </year>
Reference-contexts: 1 Introduction Modular programming has proven to be extremely valuable in the development and maintenance of large software systems [BHLM94, Nel91, Geo97]. Many modern programming languages such as Modula-3 [Nel91] and Standard ML <ref> [MTH90, MTHM97] </ref> provide support for both core-level and module-level programming. The core language, in general, deals with the detailed implementation of algorithms in terms of data structures and control constructs. The module language, on the other hand, provides glue to organize large programs and to build generic and reusable components. <p> A mature and scalable compiler must support both styles of programming well, generating decent code even for heavily modularized programs. ML-style higher-order modules [MT94, HL94, Ler95] are widely recognized as one of the most powerful module constructs in existence today. Recent work on the type-theoretic foundations of ML modules <ref> [HL94, Ler94, MTHM97] </ref> has cleaned up many rough spots in the original design [MTH90]. Still, the semantics for higher-order modules involves the use of dependent types [Mac86, HM93] or translucent signatures [HL94, Ler94]. <p> Bis95, Ler95] have attacked similar problems but with completely different motivations; they also impose severe restrictions to their module languages (e.g., no type abbreviation or sharing inside signatures [HMM90], no parameterized types [Bis95], and limited forms of functor arguments [Ler95]). * Our compilation algorithm can handle the entire SML'97 language <ref> [MTHM97] </ref> including both transparent and opaque signature matching. In fact, the algorithm has been implemented and released with the SML/NJ compiler since version 109.24 (January 9, 1997). <p> the TGC-like calculus is decidable, and furthermore, its typing rules are consistent with properly defined operational semantics [Mor95, HM95]. 3 Module semantics and translation To show how we translate the ML-style modules into the TGC calculus, we choose a surface language (SFC) that is similar to the SML'97 module language <ref> [MTHM97] </ref> extended with the MacQueen-Tofte higher-order modules [MT94]. <p> The implementation in SML/NJ has been released and in production use since version 109.24 (January 9, 1997). In our implementation, we extended the NRC-to-TGC translation to handle other features in SML'97 <ref> [MTHM97] </ref> such as value components, opaque signature 20 matching, polymorphic types, and recursive datatypes. The translation makes it possible to support type--based optimizations even in the presence of higher-order modules. <p> Functor application under our semantics involves re-elaborating the type-related components only. 5.3 Opaque signature matching The translation algorithm presented in Section 3.3 assumes that signature matching is done transparently. However, opaque signature matching <ref> [MTHM97] </ref> can be supported quite easily as well by using the same signature-instantiation algorithm presented in Figure 10. All flexible type components are turned into "abstract" types, represented as fresh stamps annotated with its representation type (e.g., n (; )). <p> The SML'90 module language, however, contains several major problems; for example, type abbreviations are not allowed in signatures, opaque signature matching is not supported, and modules are first-order only. These problems were heavily researched [HL94, Ler94, Ler95, Lil97, Tof92, MT94, Jon96] and mostly resolved in SML'97 <ref> [MTHM97] </ref>. The main remaining issue is with the design of higher-order modules, with proposals ranging from fully transparent ones [MT94], to applicative functors [Ler95, Cou97], or abstract functors [HL94, Ler94, Lil97]. <p> It was at that meeting when Bob Harper pointed us to the phase-distinction paper. In January 1997, Greg Morrisett [Mor97] told us that he had problems adapting the original phase-splitting algorithm [HMM90] to SML <ref> [MTHM97] </ref> since it does not support type abbreviations in signatures. <p> Our static semantics for higher-order modules is based on the the same stamp-based approach used in the official definitions for SML'90 [MTH90, MT91] and SML'97 <ref> [MTHM97] </ref>. The stamp-based semantics uses a global name set to model type generativity and type abstraction: a new type is represented as a fresh stamp not used in the current name set. The operational nature of this approach makes it good for efficient implementations but harder for formal reasonings.
Reference: [Nel91] <author> Greg Nelson, </author> <title> editor. Systems programming with Modula-3. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: 1 Introduction Modular programming has proven to be extremely valuable in the development and maintenance of large software systems <ref> [BHLM94, Nel91, Geo97] </ref>. Many modern programming languages such as Modula-3 [Nel91] and Standard ML [MTH90, MTHM97] provide support for both core-level and module-level programming. The core language, in general, deals with the detailed implementation of algorithms in terms of data structures and control constructs. <p> 1 Introduction Modular programming has proven to be extremely valuable in the development and maintenance of large software systems [BHLM94, Nel91, Geo97]. Many modern programming languages such as Modula-3 <ref> [Nel91] </ref> and Standard ML [MTH90, MTHM97] provide support for both core-level and module-level programming. The core language, in general, deals with the detailed implementation of algorithms in terms of data structures and control constructs.
Reference: [Rey74] <author> John C. Reynolds. </author> <title> Towards a theory of type structure. </title> <booktitle> In Proceedings, Colloque sur la Programmation, Lecture Notes in Computer Science, </booktitle> <volume> volume 19, </volume> <pages> pages 408-425. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1974. </year>
Reference-contexts: All of these are performed on the variants of core ML [DM82] or the polymorphic -calculus F ! <ref> [Gir72, Rey74] </ref>. While they have all demonstrated that types can be used to make programs run faster and consume less space, it is not obvious how any of these would work in the presence of higher-order modules (which make use of dependent types).
Reference: [SA95] <author> Zhong Shao and Andrew W. Appel. </author> <title> A type-based compiler for Standard ML. </title> <booktitle> In Proc. ACM SIGPLAN '95 Conf. on Prog. Lang. Design and Implementation, </booktitle> <pages> pages 116-129. </pages> <publisher> ACM Press, </publisher> <year> 1995. </year>
Reference-contexts: The elaboration is simple and very efficient because the module-level code is always small and non-recursive. 5 Implementation We have implemented both the translation algorithm and the cross-module inlining algorithm in the SML/NJ compiler <ref> [SA95] </ref> and the FLINT/ML compiler [Sha97b]. The implementation in SML/NJ has been released and in production use since version 109.24 (January 9, 1997). <p> We are currently working together on an inlining algorithm that combines the best of both schemes. Type-directed compilation has received much attention lately, but little has been done to extend it to work across higher-order modules. Shao and Appel <ref> [SA95] </ref> extended Leroy's representation analysis [Ler92] to work for the SML'90 modules; their algorithm works only for the pure-coercion-based representation analysis [Ler92].
Reference: [Sha97a] <author> Zhong Shao. </author> <title> Flexible representation analysis. </title> <booktitle> In Proc. 1997 ACM SIGPLAN International Conference on Functional Programming (ICFP'97), </booktitle> <pages> pages 85-98. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1997. </year>
Reference-contexts: Unfortunately, many compilation techniques do not work on programs that use higher-order modules. In fact, most recent work on compiling functional languages have ignored issues on the necessary module support. Take the area of type-directed compilation as an example: recent work includes representation analysis <ref> [Ler92, Sha97a] </ref>, type This research was sponsored in part by the Defense Advanced Research Projects Agency ITO under the title "Software Evolution using HOT Language Technology," DARPA Order No. D888, issued under Contract No. F30602-96-2-0232, and in part by an NSF CAREER Award CCR-9501624, and NSF Grant CCR-9633390. <p> Therefore, polymorphic functions in F ! or core ML can be specialized to particular type arguments at compile time. Furthermore, both representation analysis <ref> [Ler92, Sha97a] </ref> and intensional type analysis [HM95] can be performed, inserting coercions or runtime type parameters at every type-application site. Higher-order modules, on the other hand, express both the type and value abstractions through a single construct (i.e., functor). <p> The main contributions of this paper are: * As far as we know, our work is the first comprehensive and formal study on how to apply type-based compilation techniques <ref> [Ler92, Tol94, HM95, MMH96, Sha97a] </ref> to programs using ML-style modules. <p> Recent work <ref> [Sha97a] </ref> shows that type-based optimizations can dramatically improve the performance of heavily modularized ML programs. Another issue is on how to make the implementation of our translation algorithm efficient and scalable. <p> Shao and Appel [SA95] extended Leroy's representation analysis [Ler92] to work for the SML'90 modules; their algorithm works only for the pure-coercion-based representation analysis [Ler92]. The algorithm in this paper translates the module language into the F ! calculus, so type-based optimizations <ref> [Ler92, Sha97a, HM95, MMH96, Tol94] </ref> that work for F ! immediately work for higher-order modules as well. 7 Conclusions We have presented a series of techniques for compiling across higher-order modules. These techniques have been implemented and released with the SML/NJ compiler since version 109.24 (January 9, 1997). <p> The main contribution of our work is the translation algorithm from ML-style modules (SML'97 extended with MacQueen-Tofte higher-order modules) to the F ! calculus. Without such translation, none of those important type-based optimizations <ref> [HM95, Sha97a, Sha97b] </ref> would apply to the full SML language. We have also presented ways to extend various program analyses to work across higher-order modules; in fact, we show that for fully transparent modules, static information can always be optimally propagated across the module boundaries.
Reference: [Sha97b] <author> Zhong Shao. </author> <title> An overview of the FLINT/ML compiler. </title> <booktitle> In Proc. 1997 ACM SIGPLAN Workshop on Types in Compilation, </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: The elaboration is simple and very efficient because the module-level code is always small and non-recursive. 5 Implementation We have implemented both the translation algorithm and the cross-module inlining algorithm in the SML/NJ compiler [SA95] and the FLINT/ML compiler <ref> [Sha97b] </ref>. The implementation in SML/NJ has been released and in production use since version 109.24 (January 9, 1997). In our implementation, we extended the NRC-to-TGC translation to handle other features in SML'97 [MTHM97] such as value components, opaque signature 20 matching, polymorphic types, and recursive datatypes. <p> The main contribution of our work is the translation algorithm from ML-style modules (SML'97 extended with MacQueen-Tofte higher-order modules) to the F ! calculus. Without such translation, none of those important type-based optimizations <ref> [HM95, Sha97a, Sha97b] </ref> would apply to the full SML language. We have also presented ways to extend various program analyses to work across higher-order modules; in fact, we show that for fully transparent modules, static information can always be optimally propagated across the module boundaries. <p> Availability The implementation discussed in this paper is now released with the Standard ML of New Jersey (SML/NJ) compiler and the FLINT/ML compiler <ref> [Sha97b] </ref>. SML/NJ is a joint work by Lucent, Princeton, Yale and AT&T. FLINT is a modern compiler infrastructure developed at Yale University.
Reference: [Shi91] <author> Olin Shivers. </author> <title> Control-Flow Analysis of Higher-Order Languages. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon Univ., Pittsburgh, Pennsylvania, </institution> <month> May </month> <year> 1991. </year> <month> CMU-CS-91-145. </month>
Reference-contexts: Under this algorithm, the binding information of each value component is always propagated optimally even across higher-order modules. A more traditional approach would compile the higher-order modules into the usual higher-order functions in the core language, and then perform the heavy-weight control flow analysis <ref> [Shi91] </ref> on them. Our module elaboration algorithm is somewhat similar to the abstract execution, but it separates the module-level declarations from the the core-language expressions within.
Reference: [SLM98] <author> Zhong Shao, Christopher League, and Stefan Monnier. </author> <title> Implementing typed intermediate languages. </title> <booktitle> In Proc. 1998 ACM SIGPLAN International Conference on Functional Programming (ICFP'98), page (to appear). </booktitle> <publisher> ACM Press, </publisher> <month> September </month> <year> 1998. </year> <month> 27 </month>
Reference-contexts: Another issue is on how to make the implementation of our translation algorithm efficient and scalable. Because the translation makes heavy use of large modtype information, a naive implementation can easily add exponential overhead to the compilation and execution of a program. In a companion paper <ref> [SLM98] </ref>, we present a series of techniques on how to optimize the time and space costs of representing and manipulating large types; we show that our translation algorithm can be implemented with minimum overhead. 6 Related work Module systems have been an active research area in the past decade.
Reference: [Tof92] <author> Mads Tofte. </author> <title> Principal signatures for high-order ML functors. </title> <booktitle> In Nineteenth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 189-199, </pages> <address> New York, Jan 1992. </address> <publisher> ACM Press. </publisher>
Reference-contexts: The SML'90 module language, however, contains several major problems; for example, type abbreviations are not allowed in signatures, opaque signature matching is not supported, and modules are first-order only. These problems were heavily researched <ref> [HL94, Ler94, Ler95, Lil97, Tof92, MT94, Jon96] </ref> and mostly resolved in SML'97 [MTHM97]. The main remaining issue is with the design of higher-order modules, with proposals ranging from fully transparent ones [MT94], to applicative functors [Ler95, Cou97], or abstract functors [HL94, Ler94, Lil97].
Reference: [Tol94] <author> Andrew Tolmach. </author> <title> Tag-free garbage collection using explicit type parameters. </title> <booktitle> In Proc. 1994 ACM Conf. on Lisp and Functional Programming, </booktitle> <pages> pages 1-11, </pages> <address> New York, June 1994. </address> <publisher> ACM Press. </publisher>
Reference-contexts: SB = struct functor F (X : ASIG) = struct type s = X.s -&gt; X.s fun f (x : X.s) = X.f end functor APP (B : BSIG) = B.F (SA) structure SC = APP (SB) specialization [Cha92], intensional type analysis [HM95], typed closure conversion [MMH96], tagless garbage collection <ref> [Tol94] </ref>, to name just a few. All of these are performed on the variants of core ML [DM82] or the polymorphic -calculus F ! [Gir72, Rey74]. <p> The main contributions of this paper are: * As far as we know, our work is the first comprehensive and formal study on how to apply type-based compilation techniques <ref> [Ler92, Tol94, HM95, MMH96, Sha97a] </ref> to programs using ML-style modules. <p> Shao and Appel [SA95] extended Leroy's representation analysis [Ler92] to work for the SML'90 modules; their algorithm works only for the pure-coercion-based representation analysis [Ler92]. The algorithm in this paper translates the module language into the F ! calculus, so type-based optimizations <ref> [Ler92, Sha97a, HM95, MMH96, Tol94] </ref> that work for F ! immediately work for higher-order modules as well. 7 Conclusions We have presented a series of techniques for compiling across higher-order modules. These techniques have been implemented and released with the SML/NJ compiler since version 109.24 (January 9, 1997).
Reference: [Win93] <author> Glynn Winskel. </author> <title> The Formal Semantics of Programming Languages. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1993. </year>
Reference-contexts: Proof: Using Lemma 3.3 and by induction on derivation trees <ref> [Win93, Chapter 3] </ref>. 2 The first property we can show is that our static semantics always produce typings that are unique up to the ff-renaming of type stamps.
References-found: 43

