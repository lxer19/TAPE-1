URL: http://www.csl.sri.com/reports/postscript/iccd95.ps.gz
Refering-URL: http://www.csl.sri.com/reports/postscript/
Root-URL: 
Title: Theorem Proving: Not an Esoteric Diversion, but the Unifying Framework for Industrial Verification  
Author: D. A. Cyrluk M. K. Srivas 
Address: Stanford, CA 94305 Menlo Park, CA 94025  
Affiliation: SRI International and Computer Science Department Computer Science Laboratory Stanford University SRI International  
Date: October 1995  
Note: To appear in proceedings of IEEE International Conference on Computer Design (ICCD) '95 Austin, Texas  
Abstract: The effectiveness of hardware verification techniques has increased markedly in the past decade. As hardware verification techniques become increasingly powerful the idea of transitioning verification technology to industry can be taken seriously. Nevertheless, powerful decision procedures that can completely automate the verification of certain types of hardware, whether they are BDD based model-checkers [10] or automatic microprocessor verification tools [4], cannot be adequate on their own for industrial hardware verification. However, a high-level, general-purpose theorem prover with specific capabilities can provide an overall framework in which these tools can be embedded and in which they can then be effectively used for industrial hardware verification. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Mark Aargard and Miriam Leeser. </author> <title> Reasoning about pipelines with structural hazards. </title> <booktitle> In Kumar and Kropf [13], </booktitle> <pages> pages 15-34. </pages>
Reference-contexts: In a higher order prover an appropriate framework can be specified for any given task. In this section we describe one approach for specifying the high level correctness of synchronous sequential circuits such as microprocessors. Other frameworks are discussed in <ref> [1, 8, 20] </ref>. E EE E Abs REG next macro state 2 3 Commuting Property Formal microprocessor verification involves specifying the processor as a machine that interprets the instructions in the instruction set at two levels|macro and micro. <p> Again this could be done very straightforwardly in a theorem prover even without changing the overall framework. However adjustments to the general framework might be needed for super scalar processors <ref> [1] </ref>. Automated tools have been built and used for simple pipelined processors [2, 4], and they can deal with many of the above issues.
Reference: [2] <author> Derek L. Beatty and Randal E. Bryant. </author> <title> Formally verifying a microprocessor using a simulation methodology. </title> <booktitle> In Proceedings of the 31st Design Automation Conference, </booktitle> <pages> pages 596-602. </pages> <institution> Association for Computing Machinery, </institution> <month> June </month> <year> 1994. </year>
Reference-contexts: These techniques span a spectrum from automatic techniques to interactive theorem proving techniques. At one end of the spectrum automatic methods such as model-checking have improved considerably: model-checkers have been able to verify circuits with 10 20 states [3] and have verified the correctness of a PDP-11 sized processor <ref> [2] </ref>, special purpose tools have been able to automate the verification of complete benchmark microprocessors [4, 6, 7], language containment methods [10] have also been effectively applied to significant examples. <p> Again this could be done very straightforwardly in a theorem prover even without changing the overall framework. However adjustments to the general framework might be needed for super scalar processors [1]. Automated tools have been built and used for simple pipelined processors <ref> [2, 4] </ref>, and they can deal with many of the above issues.
Reference: [3] <author> J. R. Burch, E. M. Clarke, K. L. McMillan, D. L. Dill, and L. J. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <journal> Information and Computation, </journal> <volume> 98(2) </volume> <pages> 142-170, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: These techniques span a spectrum from automatic techniques to interactive theorem proving techniques. At one end of the spectrum automatic methods such as model-checking have improved considerably: model-checkers have been able to verify circuits with 10 20 states <ref> [3] </ref> and have verified the correctness of a PDP-11 sized processor [2], special purpose tools have been able to automate the verification of complete benchmark microprocessors [4, 6, 7], language containment methods [10] have also been effectively applied to significant examples. <p> We argue in this paper, that the dual is equally important: that powerful decision procedures that can completely automate the verification of certain types of hardware such as a BDD based model checker <ref> [3] </ref> or automatic microprocessor verification tool [4] cannot be adequate on their own for industrial hardware verification. Consider the following typical verification cycle employed by users of a model-checker or similar automatic tool.
Reference: [4] <author> J. R. Burch and D. L. Dill. </author> <title> Automatic verification of pipelined microprocessor control. </title> <editor> In David Dill, editor, </editor> <booktitle> Computer-Aided Verification, CAV '94, volume 818 of Lecture Notes in Computer Science, </booktitle> <pages> pages 68-80, </pages> <address> Stanford, CA, June 1994. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: one end of the spectrum automatic methods such as model-checking have improved considerably: model-checkers have been able to verify circuits with 10 20 states [3] and have verified the correctness of a PDP-11 sized processor [2], special purpose tools have been able to automate the verification of complete benchmark microprocessors <ref> [4, 6, 7] </ref>, language containment methods [10] have also been effectively applied to significant examples. At the other end of the spectrum, the Boyer-Moore theorem prover and the HOL theorem prover have been successfully used to verify simple microprocessor [11, 12]. <p> We argue in this paper, that the dual is equally important: that powerful decision procedures that can completely automate the verification of certain types of hardware such as a BDD based model checker [3] or automatic microprocessor verification tool <ref> [4] </ref> cannot be adequate on their own for industrial hardware verification. Consider the following typical verification cycle employed by users of a model-checker or similar automatic tool. <p> Again this could be done very straightforwardly in a theorem prover even without changing the overall framework. However adjustments to the general framework might be needed for super scalar processors [1]. Automated tools have been built and used for simple pipelined processors <ref> [2, 4] </ref>, and they can deal with many of the above issues. <p> The theorem prover does the induction and uses abstraction to reduce the inductive step to the two process case which the model-checker can quickly decide. 7.2 Other Decidable Theories Other aspects of hardware verification are amenable to different automated tools. All of <ref> [4, 6, 7] </ref> describe decidable theories or strategies that effectively deal with verification of the data flow through a pipelined microprocessor. The essence of these methods is to use rewriting to generate large IF-THEN-ELSE expressions that then have to be compared for equality. <p> This comparison is done by performing a combinations of case analysis with decision procedures for ground equality and other decidable theories. An overall correctness criteria is built into the tool described in <ref> [4] </ref>. As argued above a better approach would be to separate the correctness criteria and decision procedure. The correctness criteria may not remain universally useful. The decision procedure part which decides the equality of large IF-THEN-ELSE expression will be useful in a wide variety of situations.
Reference: [5] <author> Edmund M. Clarke, Orna Grumberg, and David E. </author> <title> Long. Model checking and abstraction. </title> <booktitle> In 19th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 343-354, </pages> <address> Albuquerque, NM, </address> <month> January </month> <year> 1992. </year> <institution> Association for Computing Machinery. </institution>
Reference-contexts: The user can now take several different paths. He can simplify the circuit by abstracting part of it away. He can reduce the state space by reducing the width of the data-paths. He can use abstraction techniques <ref> [5] </ref> to generate a smaller, but logically equivalent state 1 space. He can break up the problem into smaller sub--problems, each of which he would attack separately. He might want to apply different tools to the different subproblems.
Reference: [6] <author> D. Cyrluk and P. Narendran. </author> <title> Ground temporal logic| a logic for hardware verification. </title> <editor> In David Dill, editor, </editor> <booktitle> Computer-Aided Verification, CAV '94, volume 818 of Lecture Notes in Computer Science, </booktitle> <pages> pages 247-259, </pages> <address> Stanford, CA, June 1994. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: one end of the spectrum automatic methods such as model-checking have improved considerably: model-checkers have been able to verify circuits with 10 20 states [3] and have verified the correctness of a PDP-11 sized processor [2], special purpose tools have been able to automate the verification of complete benchmark microprocessors <ref> [4, 6, 7] </ref>, language containment methods [10] have also been effectively applied to significant examples. At the other end of the spectrum, the Boyer-Moore theorem prover and the HOL theorem prover have been successfully used to verify simple microprocessor [11, 12]. <p> The theorem prover does the induction and uses abstraction to reduce the inductive step to the two process case which the model-checker can quickly decide. 7.2 Other Decidable Theories Other aspects of hardware verification are amenable to different automated tools. All of <ref> [4, 6, 7] </ref> describe decidable theories or strategies that effectively deal with verification of the data flow through a pipelined microprocessor. The essence of these methods is to use rewriting to generate large IF-THEN-ELSE expressions that then have to be compared for equality.
Reference: [7] <author> D. Cyrluk, S. Rajan, N. Shankar, and M. K. Srivas. </author> <title> Effective theorem proving for hardware verification. </title> <booktitle> In Kumar and Kropf [13], </booktitle> <pages> pages 203-222. </pages>
Reference-contexts: one end of the spectrum automatic methods such as model-checking have improved considerably: model-checkers have been able to verify circuits with 10 20 states [3] and have verified the correctness of a PDP-11 sized processor [2], special purpose tools have been able to automate the verification of complete benchmark microprocessors <ref> [4, 6, 7] </ref>, language containment methods [10] have also been effectively applied to significant examples. At the other end of the spectrum, the Boyer-Moore theorem prover and the HOL theorem prover have been successfully used to verify simple microprocessor [11, 12]. <p> We have argued <ref> [7] </ref> that to be effective at hardware verification theorem provers must provide powerful and efficient primitive inference procedures that can be combined by means of user-defined general-purpose, high-level proof strategies. Our discussion [7] focused on the importance of powerful and efficient primitive inference procedures as these are generally lacking in many <p> We have argued <ref> [7] </ref> that to be effective at hardware verification theorem provers must provide powerful and efficient primitive inference procedures that can be combined by means of user-defined general-purpose, high-level proof strategies. Our discussion [7] focused on the importance of powerful and efficient primitive inference procedures as these are generally lacking in many general-purpose interactive verification systems. <p> This concern is addressed by incorporating efficient special purpose verification tools into the theorem prover. These tools along with powerful low-level inference steps and an extensible strategy language can relieve the hardware engineer from the overly mundane and overly demanding tasks required in many theorem provers <ref> [7, 16] </ref>. Again, the AAMP5 and its sequel the AAMP-FV verification [14] efforts bears this out. The initial proofs of several instructions were performed at SRI to develop the proof infrastructure needed to automate the process. <p> Inorder to be useful for practical verification these proof strategies must be as efficient as possible <ref> [7] </ref>. PVS already incorporates many different decision procedures. These include a BDD based propositional simplifier, combined ground decision procedures for equality, arithmetic and reading and writing memory, a conditional rewriter which effectively uses the combined ground decision procedures, and a propositional temporal logic model-checker. <p> The theorem prover does the induction and uses abstraction to reduce the inductive step to the two process case which the model-checker can quickly decide. 7.2 Other Decidable Theories Other aspects of hardware verification are amenable to different automated tools. All of <ref> [4, 6, 7] </ref> describe decidable theories or strategies that effectively deal with verification of the data flow through a pipelined microprocessor. The essence of these methods is to use rewriting to generate large IF-THEN-ELSE expressions that then have to be compared for equality.
Reference: [8] <author> David Cyrluk. </author> <title> Microprocessor verification in PVS: A methodology and simple example. </title> <type> Technical Report SRI-CSL-93-12, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: Theorem provers are well suited for thee types of activities. Finally, just as Hoare-triples or Floyd-inductive assertions provide a general framework for program verification, the verification of hardware can often be stated in a larger more general framework that can act as a guide for the larger verification effort <ref> [8] </ref>. 4 Industrial Verification Hardware verification in industry has several characteristics and needs that distinguish it from the type of verification done by researchers. In this section we enumerate these criteria and show how an interactive theorem prover can meet those needs. 1. <p> In a higher order prover an appropriate framework can be specified for any given task. In this section we describe one approach for specifying the high level correctness of synchronous sequential circuits such as microprocessors. Other frameworks are discussed in <ref> [1, 8, 20] </ref>. E EE E Abs REG next macro state 2 3 Commuting Property Formal microprocessor verification involves specifying the processor as a machine that interprets the instructions in the instruction set at two levels|macro and micro.
Reference: [9] <author> Mike Gordon. </author> <title> Proving a computer correct. </title> <type> Technical Report TR 42, </type> <institution> University of Cambridge, Computer Laboratory, </institution> <year> 1983. </year>
Reference-contexts: Of course there will remain proofs that are going to be difficult for non-experts to do, but we believe that for most hardware proofs stylized approaches can be developed that hardware engineers will be able to follow. 3 Hardware Verification In the 1980s Gordon <ref> [9] </ref> started the field of hardware verification. While not yet achieved, we believe that the practical industrial use of hardware verification is only a matter of time. We hold this belief in spite of the past failure of software verification to transition from research to industry.
Reference: [10] <author> Aarti Gupta. </author> <title> Formal hardware verification methods: A survey. </title> <booktitle> Formal Methods in Systems Design, </booktitle> 1(2/3):151-238, October 1992. 
Reference-contexts: methods such as model-checking have improved considerably: model-checkers have been able to verify circuits with 10 20 states [3] and have verified the correctness of a PDP-11 sized processor [2], special purpose tools have been able to automate the verification of complete benchmark microprocessors [4, 6, 7], language containment methods <ref> [10] </ref> have also been effectively applied to significant examples. At the other end of the spectrum, the Boyer-Moore theorem prover and the HOL theorem prover have been successfully used to verify simple microprocessor [11, 12].
Reference: [11] <author> W.A. Hunt. </author> <title> The mechanical verification of a microprocessor design. </title> <booktitle> In Proc. of IFIP Working Conference on From H.D.L Descriptions to Guaranteed Correct Circuit Designs, </booktitle> <year> 1986. </year>
Reference-contexts: At the other end of the spectrum, the Boyer-Moore theorem prover and the HOL theorem prover have been successfully used to verify simple microprocessor <ref> [11, 12] </ref>. Most recently, PVS [16], a higher-order, general-purpose theorem prover being developed at SRI, has verified a large part of the AAMP5|a half million transistor, commercial pipelined microcoded microprocessor developed at Rockwell-Collins [14].
Reference: [12] <author> J. Joyce, G. Birtwistle, and M. Gordon. </author> <title> Proving a computer correct in higher order logic. </title> <type> Technical Report 100, </type> <institution> Computer Laboratory, University of Cambridge, </institution> <year> 1986. </year>
Reference-contexts: At the other end of the spectrum, the Boyer-Moore theorem prover and the HOL theorem prover have been successfully used to verify simple microprocessor <ref> [11, 12] </ref>. Most recently, PVS [16], a higher-order, general-purpose theorem prover being developed at SRI, has verified a large part of the AAMP5|a half million transistor, commercial pipelined microcoded microprocessor developed at Rockwell-Collins [14].
Reference: [13] <editor> Ramayya Kumar and Thomas Kropf, editors. </editor> <booktitle> Theorem Provers in Circuit Design (TPCD '94), volume 910 of Lecture Notes in Computer Science, </booktitle> <address> Bad Herrenalb, Germany, </address> <month> September </month> <year> 1994. </year> <note> Springer-Verlag. </note>
Reference: [14] <author> Steven P. Miller and Mandayam Srivas. </author> <title> Formal verification of the AAMP5 microprocessor: A case study in the industrial use of formal methods. </title> <booktitle> In WIFT '95: Workshop on Industrial-Strength Formal Specification Techniques, </booktitle> <pages> pages 2-16, </pages> <address> Boca Raton, FL, 1995. </address> <publisher> IEEE Computer Society. </publisher>
Reference-contexts: Most recently, PVS [16], a higher-order, general-purpose theorem prover being developed at SRI, has verified a large part of the AAMP5|a half million transistor, commercial pipelined microcoded microprocessor developed at Rockwell-Collins <ref> [14] </ref>. As hardware verification techniques become increasingly powerful we are approaching a point where fl This work was supported by NASA Langley Research Center under contract NAS1-20334 and NAS1-19704. the idea of transitioning the technology to industry can be taken seriously. <p> The AAMP5 verification effort provides evidence for this view. In the AAMP5 effort the PVS specifications were subject to formal inspections. The hardware engineers found the specifications understandable. Additionally, the rigor of the specifications helped the engineers discover bugs in the AAMP5 design <ref> [14] </ref>. Eventually the hardware engineers were able to use the PVS specification language on their own. Additionally, some of the more esoteric features of the specification language were effectively used. <p> These tools along with powerful low-level inference steps and an extensible strategy language can relieve the hardware engineer from the overly mundane and overly demanding tasks required in many theorem provers [7, 16]. Again, the AAMP5 and its sequel the AAMP-FV verification <ref> [14] </ref> efforts bears this out. The initial proofs of several instructions were performed at SRI to develop the proof infrastructure needed to automate the process. <p> These conclusions are not just based on argument, but have also been born out by an actual industrial verification effort involving the AAMP5 processor <ref> [14] </ref>. This additionally provides a model for future research. Research in increasing the capabilities of automated tools and interactive theorem provers is important, as is research aimed at enhancing their integration. But, perhaps equally important is research that actually applies this combination to actual industrial examples.
Reference: [15] <author> Paul S. Miner. </author> <title> Defining the ieee-854 floating-point standard in pvs. </title> <type> NASA Technical Memorandum 110167, </type> <institution> NASA Langley Research Center, </institution> <month> June </month> <year> 1995. </year>
Reference-contexts: Other examples of specification reuse is the n-bit word library that is part of the AAMP5 specification and the IEEE floating point specification done in PVS <ref> [15] </ref>. The very expressive high-level type system and specification language typical of interactive theorem provers make this type of reuse possible. Specification reuse is by no means unique to theorem provers. Code reuse is also obtained with many object-oriented languages and might very well be part of more automated tools.
Reference: [16] <author> Sam Owre, John Rushby, Natarajan Shankar, and Friedrich von Henke. </author> <title> Formal verification for fault-tolerant architectures: Prolegomena to the design of PVS. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(2) </volume> <pages> 107-125, </pages> <month> February </month> <year> 1995. </year>
Reference-contexts: At the other end of the spectrum, the Boyer-Moore theorem prover and the HOL theorem prover have been successfully used to verify simple microprocessor [11, 12]. Most recently, PVS <ref> [16] </ref>, a higher-order, general-purpose theorem prover being developed at SRI, has verified a large part of the AAMP5|a half million transistor, commercial pipelined microcoded microprocessor developed at Rockwell-Collins [14]. <p> This concern is addressed by incorporating efficient special purpose verification tools into the theorem prover. These tools along with powerful low-level inference steps and an extensible strategy language can relieve the hardware engineer from the overly mundane and overly demanding tasks required in many theorem provers <ref> [7, 16] </ref>. Again, the AAMP5 and its sequel the AAMP-FV verification [14] efforts bears this out. The initial proofs of several instructions were performed at SRI to develop the proof infrastructure needed to automate the process.
Reference: [17] <author> S. Rajan, N. Shankar, </author> <title> and M.K. Srivas. An integration of model-checking with automated proof checking. </title> <editor> In Pierre Wolper, editor, </editor> <booktitle> Computer-Aided Verification, CAV '95, Lecture Notes in Computer Science, Liege, </booktitle> <address> Belgium, </address> <month> June </month> <year> 1995. </year> <note> Springer-Verlag. To appear. </note>
Reference-contexts: We have implemented such an integration between a model-checker and PVS and tested it to verify <ref> [17] </ref> a simplified version of the LFU/BIU model encountered in the AAMP5 design. We plan to extend it to verify the LFU/BIU parts of the AAMP5. Another example of the use of a model-checker in a theorem prover is in the verification of Peterson's n-process mutual exclusion protocol [18].
Reference: [18] <author> N. Shankar. </author> <booktitle> Computer-aided computing. In Proceedings of the 3rd International Conference on the Mathematics of Program Construction, </booktitle> <year> 1995. </year> <note> (To appear). </note>
Reference-contexts: We plan to extend it to verify the LFU/BIU parts of the AAMP5. Another example of the use of a model-checker in a theorem prover is in the verification of Peterson's n-process mutual exclusion protocol <ref> [18] </ref>. The verification is by induction on the number of processes. The model-checker is able to automatically verify the correctness of the base case (one process instance) and the two process instance of the protocol.
Reference: [19] <author> Mandayam Srivas and Mark Bickford. </author> <title> Formal verification of a pipelined microprocessor. </title> <journal> IEEE Software, </journal> <volume> 7(5) </volume> <pages> 52-64, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: For example, they allow instructions following a conditional branch to execute assuming the branch would not be taken leaving the burden of generating correct code to the compilers. One way to handle this is (as shown in <ref> [19] </ref>) either to restrict the set of programs for which the two machines are related or expose some of the effects of pipelining in the macro-machine. Again this could be done very straightforwardly in a theorem prover even without changing the overall framework.
Reference: [20] <author> Phillip J. Windley and Michael L. </author> <title> Coe. A correctness model for pipelined microprocessors. </title> <booktitle> In Kumar and Kropf [13], </booktitle> <pages> pages 33-51. 7 </pages>
Reference-contexts: In a higher order prover an appropriate framework can be specified for any given task. In this section we describe one approach for specifying the high level correctness of synchronous sequential circuits such as microprocessors. Other frameworks are discussed in <ref> [1, 8, 20] </ref>. E EE E Abs REG next macro state 2 3 Commuting Property Formal microprocessor verification involves specifying the processor as a machine that interprets the instructions in the instruction set at two levels|macro and micro.
References-found: 20

