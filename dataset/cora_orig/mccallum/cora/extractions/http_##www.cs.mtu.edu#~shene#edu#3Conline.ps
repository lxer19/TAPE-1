URL: http://www.cs.mtu.edu/~shene/edu/3Conline.ps
Refering-URL: http://www.cs.mtu.edu/~shene/edu/education.html
Root-URL: http://www.cs.mtu.edu
Email: shene@mtu.edu  
Title: A COMPARATIVE STUDY OF LINKED LIST SORTING ALGORITHMS  
Author: by Ching-Kuang Shene 
Address: Houghton, MI 49931-1295  
Affiliation: Michigan Technological University Department of Computer Science  
Abstract-found: 0
Intro-found: 1
Reference: 1. <author> Jon Bentley, </author> <title> Programming Pearls, </title> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: For quick sort, Hoare's original algorithm [3] cannot be used since this algorithm burns a candle from both ends. Nico Lomuto's algorithm as described in Bentley <ref> [1] </ref> could be a better candidate for our study since it keeps two forward scanning pointers. However, since quick sort is not stable (Sedgewick [6]), it is not included.
Reference: 2. <author> Jim Carraway, </author> <title> Doubly-Linked Opportunities, </title> <journal> ACM 3C ONLINE, </journal> <volume> Vol. 3 (1996), No. </volume> <month> 1 (January), </month> <pages> pp. 9-12. </pages>
Reference-contexts: 1 Introduction Carraway recently published an article <ref> [2] </ref> describing a sorting algorithm (the sediment sort) for doubly linked lists. He claimed that the sediment sort is one of the fastest and most efficient sorts for linked list, and planned to determine its complexity. <p> There is no need to repeat the sediment sort here and the interested reader should refer to <ref> [2] </ref> for the details. Since a node in a doubly linked list has two fields, prev and next , pointing to the previous node and the next node, it is good enough for representing a binary tree.
Reference: 3. <author> R. Hoare, </author> <title> Quicksort, </title> <journal> The Computer Journal, </journal> <volume> Vol. 5 (1962), </volume> <pages> pp. 10-15. </pages>
Reference-contexts: Although it could be done with other heap data structures (see, for example, Weiss [8]), the material might be inappropriate for a CS2 type course. For quick sort, Hoare's original algorithm <ref> [3] </ref> cannot be used since this algorithm burns a candle from both ends. Nico Lomuto's algorithm as described in Bentley [1] could be a better candidate for our study since it keeps two forward scanning pointers. However, since quick sort is not stable (Sedgewick [6]), it is not included.
Reference: 4. <author> Donald E. Knuth, </author> <title> The Art of Computer Programming. Volume 3: Sorting and Searching, second printing, </title> <publisher> Addison-Wesley, </publisher> <year> 1975. </year>
Reference-contexts: This algorithm was known to the computer community much earlier and was discussed in Knuth's monumental work (Knuth <ref> [4] </ref>). Figure 1 is a direct translation from Knuth's description, where SWAP () is a macro that swaps two integers a [i] and a [i+1]. <p> There are other interesting algorithms that are worth to be mentioned. For example, the shaker sort is an extension to the bubble sort in which two bounds are used to limit the range for next scan (Knuth <ref> [4] </ref> and Wirth [9]). Since the shaker sort scans the list in both directions, it would be very interesting to know the contribution of using two bounds rather than one in the bubble sort and the sediment sort. Two factors are not addressed in this article. <p> Please note that performing these comparison tests is not new and has been carried out many times based on different criteria by many researchers ever since people knew sorting is an important and useful technique (see Knuth <ref> [4] </ref> for historical notes). However, as an educator, I believe that making these theoretical results down to the earth and accessible for students would be an important job.
Reference: 5. <author> Dalia Motzkin, </author> <title> A Stable Quicksort, </title> <journal> Software-Practice and Experience, </journal> <volume> Vol. 11 (1981), No. 6, </volume> <pages> pp. 607-611. </pages>
Reference-contexts: However, since quick sort is not stable (Sedgewick [6]), it is not included. Instead, an algorithm which was originally designed to make quick sort stable and to handle equal keys is selected for this study. This algorithm was first proposed by Motzkin <ref> [5] </ref> and then analyzed by Wegner [7]. In fact, Wegner showed that on average this algorithm is of order O ((m+n)log (n/m)), where n is the number of keys in an input linked list in which each key occurs m times. The idea of Wegner's algorithm is simple.
Reference: 6. <author> Robert Sedgewick, </author> <title> Algorithms in C++, </title> <publisher> Addison-Wesley, </publisher> <year> 1992. </year>
Reference-contexts: Nico Lomuto's algorithm as described in Bentley [1] could be a better candidate for our study since it keeps two forward scanning pointers. However, since quick sort is not stable (Sedgewick <ref> [6] </ref>), it is not included. Instead, an algorithm which was originally designed to make quick sort stable and to handle equal keys is selected for this study. This algorithm was first proposed by Motzkin [5] and then analyzed by Wegner [7]. <p> Fortunately, moving the nodes alternatively to two lists would also solve this problem (Sedgewick <ref> [6] </ref>). Then, sorting these two lists recursively and merging the results into a single list will sort the given one. Figure 4 depicts the basic idea of this merge sort.
Reference: 7. <author> Lutz M. Wegner, </author> <title> Sorting a Linked List with Equal Keys, </title> <journal> Information Processing Letters, </journal> <volume> Vol. 15 (1982), No. 5 (December), </volume> <pages> pp. 205-208. </pages>
Reference-contexts: However, since quick sort is not stable (Sedgewick [6]), it is not included. Instead, an algorithm which was originally designed to make quick sort stable and to handle equal keys is selected for this study. This algorithm was first proposed by Motzkin [5] and then analyzed by Wegner <ref> [7] </ref>. In fact, Wegner showed that on average this algorithm is of order O ((m+n)log (n/m)), where n is the number of keys in an input linked list in which each key occurs m times. The idea of Wegner's algorithm is simple.
Reference: 8. <author> Mark Allen Weiss, </author> <title> Data Structures and Algorithm Analysis in C++, </title> <address> Benjamin/Cummings, </address> <year> 1994. </year>
Reference-contexts: An efficient implementation of heap sort requires an array that is accessed almost randomly (i.e., accessing the index sequence i, i/2, i/2 2 , and so on). Although it could be done with other heap data structures (see, for example, Weiss <ref> [8] </ref>), the material might be inappropriate for a CS2 type course. For quick sort, Hoare's original algorithm [3] cannot be used since this algorithm burns a candle from both ends.
Reference: 9. <author> Niklaus Wirth, </author> <title> Algorithms & Data Structures, </title> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference-contexts: There are other interesting algorithms that are worth to be mentioned. For example, the shaker sort is an extension to the bubble sort in which two bounds are used to limit the range for next scan (Knuth [4] and Wirth <ref> [9] </ref>). Since the shaker sort scans the list in both directions, it would be very interesting to know the contribution of using two bounds rather than one in the bubble sort and the sediment sort. Two factors are not addressed in this article.
References-found: 9

