URL: ftp://ftp.icsi.berkeley.edu/pub/techreports/1993/tr-93-045.ps.gz
Refering-URL: http://www.icsi.berkeley.edu/techreports/1993.html
Root-URL: http://www.icsi.berkeley.edu
Email: Email: fmurer, om, szyperskig@icsi.berkeley.edu  
Title: Sather Iters: Object-Oriented Iteration Abstraction  
Author: Stephan Murer, Stephen Omohundro, and Clemens Szyperski 
Date: August 1993  
Address: 1947 Center St, Suite 600 Berkeley, CA 94704  
Affiliation: The International Computer Science Institute  
Pubnum: TR-93-045  
Abstract: Sather iters are a powerful new way to encapsulate iteration. We argue that such iteration abstractions belong in a class' interface on an equal footing with its routines. Sather iters were derived from CLU iterators but are much more flexible and better suited for object-oriented programming. We motivate and describe the construct along with several simple examples. We compare it with iteration based on CLU iterators, cursors, riders, streams, series, generators, coroutines, blocks, closures, and lambda expressions. Finally, we describe how to implement them in terms of coroutines and then show how to transform this implementation into efficient code. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Harold Abelson, Gerald Jay Sussman, and Julie Sussman. </author> <title> Structure and Interpretation of Computer Programs. </title> <publisher> MIT Press, </publisher> <year> 1985. </year>
Reference-contexts: Iters maybe arbitrarily nested and support recursion just like routines. Finally, even though the Sather language doesn't have explicit pointers, the array iters compile into efficient code based on pointer arithmetic. 3.3 Streams, Series, and Generators Iters also share many characteristics with streams <ref> [1] </ref>. One natural class of iters are those of the form "it!:T" which have a return value but no arguments and yield a potentially infinite stream of values. <p> The way in which iters suspend and transfer control when yielding corresponds well to the lazy evaluation semantics of streams. The Sieve of Eratosthenes for generating successive prime numbers has been used to show the power of the stream concept <ref> [1, pages 267-269] </ref>. While it is a conceptually simple algorithm, the control flow is rather complex. The stream solution is based 6 on a stream which takes a stream argument and filters out later elements which are divisible by the first element. This solution may be implemented using bound iters. <p> While a suspending coroutine may transfer control to any other waiting coroutine, the flow of control is structured by the "loop"-statement in the case of iters. 7 3.5 Blocks, Closures, and Lambda Expressions Traditionally, iteration abstraction is supported in object-oriented languages by providing anonymous blocks [4], lambda expressions <ref> [1] </ref>, or closures [13]. The container classes provide methods to apply a block to all or part of their elements. The execution of such block-based iterations is controlled by the container class. With iters, the control is shared by the iter and the calling loop.
Reference: [2] <author> Craig Chambers. </author> <title> Object-oriented Multi-Methods in Cecil. </title> <booktitle> In Proceedings of the Sixth European Conference on Object-Oriented Programming (ECOOP'92), </booktitle> <address> Utrecht, </address> <year> 1992. </year>
Reference-contexts: Other--wise, each loop iteration could dispatch to a different iter implementation, effectively destroying our iter semantics. Note that while the Sather language uses single dispatch methods only, the iter mechanism would readily fit into other languages based on multiple dispatch (sometimes called multi-methods <ref> [2] </ref>). Dispatched iters are implemented by relying on the special semantics of constant parameters. When first evaluating the dispatching arguments, the corresponding iter implementation is located, and the coroutine created. Subsequent transfers always refer to the same iter implementation, hence making the dynamic dispatch for these superfluous.
Reference: [3] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: The attributes of the cursor object maintain the current state of the iteration. This may be as simple as a single index into arrays, or as complex as a traversal stack and "seen-node" hash table for traversing trees or graphs. Note that Ellis and Stroustrup <ref> [3] </ref> call the use of cursor objects in C++ "iterators". We found that while cursors work quite well in certain circumstances, they can also become quite cumbersome. They require maintaining a parallel cursor object hierarchy alongside each container class hierarchy.
Reference: [4] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80, The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1985. </year>
Reference-contexts: While a suspending coroutine may transfer control to any other waiting coroutine, the flow of control is structured by the "loop"-statement in the case of iters. 7 3.5 Blocks, Closures, and Lambda Expressions Traditionally, iteration abstraction is supported in object-oriented languages by providing anonymous blocks <ref> [4] </ref>, lambda expressions [1], or closures [13]. The container classes provide methods to apply a block to all or part of their elements. The execution of such block-based iterations is controlled by the container class. With iters, the control is shared by the iter and the calling loop.
Reference: [5] <author> Carl Hewitt. </author> <title> Viewing control structures as patterns of passing messages. </title> <journal> Artificial Intelligence, </journal> <volume> 8 </volume> <pages> 323-364, </pages> <year> 1977. </year>
Reference-contexts: We agree with Hewitt who has found, "that we can do without the paraphernalia of `hairy control structures' (such as possibility lists, non-local gotos, and assignments of values to the internal variables of other procedures in Conniver" <ref> [5, page 341] </ref>. As an alternative, Hewitt proposes lazy evaluation (using an explicit delay pseudo-function). While lazy evaluation allows the efficient handling of multiple recursive data structures, it also poses a particularly difficult problem for efficient implementations. The Common Lisp loop macro [12] is a generalized iteration control structure. <p> This difference in control becomes apparent when trying to iterate synchronously through multiple data structures. Consider the task of comparing the elements of two trees according to a pre-order traversal. This is the classical "same fringe problem" as defined by Hewitt <ref> [5, page 344-347] </ref>.
Reference: [6] <author> C. A. R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice Hall, </publisher> <year> 1985. </year>
Reference-contexts: They include a large number of built-in operations. These operations may each be implemented with iters and encapsulated in classes. 3.4 Coroutines A different approach is to view all the iters and the body of a loop as communicating sequential processes <ref> [6] </ref> tightly coupled by communication through the arguments and results of the iters. Since there is neither preemption nor true parallel execution among iters, we may model iters and the loop body as coroutines [15] (section 4).
Reference: [7] <author> Barbara Liskov and John Guttag. </author> <title> Abstraction and Specification in Program Development. </title> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: Beyond its application in Sather, the iter-based loop construct fits well into other block-structured programming languages. Its encapsulation of iter states decouples separate iteration processes and allows the nesting thereof. The name "iter" (short for "iterator") and the initial design were derived from a construct in the CLU language <ref> [7] </ref>. A CLU iter is like a routine except that it may "yield" in addition to returning. They may only be called in the head of a special "for" loop construct. The loop is executed once each time the iter yields a value. When the iter returns, the loop exits.
Reference: [8] <author> Christopher D. Marlin. </author> <title> Coroutines: A Programming Methodology, a Language Design, and an Implementation. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1980. </year>
Reference-contexts: This approach allows us to semi-formally define the operational semantics of iters in terms of the well-understood coroutine semantics <ref> [8] </ref>.
Reference: [9] <author> Drew V. McDermott and Gerald Jay Sussman. </author> <note> The Conniver reference manual. Technical Report Artificial Intelligence Memo 259a, </note> <institution> MIT, </institution> <month> May </month> <year> 1974. </year>
Reference-contexts: In this section we compare Sather iters with cursors, riders, streams, series, generators, coroutines, closures, and blocks. 3.1 Generalized Control Structures The idea of generalizing iteration control structures goes back to early work such as the generators and "possibility lists" of Conniver <ref> [9] </ref>. Conniver includes activation records (called "frames") as first-class objects. It has a notion of pattern- or generator-defined possibility lists, where "TRY_NEXT is used to get the next value from such a list. Special tokens in possibility lists cause an associated generator to be invoked. <p> Finally, the use of first-class frames allows generators to have side-effects in their caller environment. This can be used to simulate variable arguments and stream-consuming iters. However, experience with the "hairy control structures" of Conniver <ref> [9] </ref> has been found to lead to unintelligible programs. We agree with Hewitt who has found, "that we can do without the paraphernalia of `hairy control structures' (such as possibility lists, non-local gotos, and assignments of values to the internal variables of other procedures in Conniver" [5, page 341].
Reference: [10] <author> Stephen Omohundro. </author> <title> Sather provides nonproprietary access to object-oriented programming. </title> <journal> Computers in Physics, </journal> <volume> 6(5) </volume> <pages> 444-449, </pages> <year> 1992. </year>
Reference-contexts: 1 Introduction and Motivation Sather is an object-oriented language developed at the International Computer Science Institute <ref> [10] </ref>. It has clean and simple syntax, parameterized classes, object-oriented dispatch, multiple inheritance, strong typing, and garbage collection. It was originally derived from Eiffel but aims to achieve the performance of C or C++ without sacrificing elegance or safety.
Reference: [11] <author> Stephen Omohundro and Chu-Cheow Lim. </author> <title> The Sather language and libraries. </title> <type> Technical Report TR-92-017, </type> <institution> International Computer Science Institute, </institution> <month> March </month> <year> 1992. </year>
Reference-contexts: Sather 0.2 had a fairly conventional until ... loop ... end statement. While this suffices for the most basic iterative situations, we felt the need for a more general construct. The Sather 0.2 libraries made heavy use of cursor objects to iterate through the contents of container objects <ref> [11] </ref>. While these work quite well in certain circumstances, they have a number of problems which are described in section 3. That section also describes approaches based on riders, closures, streams, series, generators, coroutines and blocks.
Reference: [12] <author> Guy L. Steele Jr. </author> <title> Common LISP, The Language. </title> <publisher> Digital Press, </publisher> <address> 2 edition, </address> <year> 1990. </year>
Reference-contexts: As an alternative, Hewitt proposes lazy evaluation (using an explicit delay pseudo-function). While lazy evaluation allows the efficient handling of multiple recursive data structures, it also poses a particularly difficult problem for efficient implementations. The Common Lisp loop macro <ref> [12] </ref> is a generalized iteration control structure. While it contains about every iteration primitive that the authors could imagine (somewhat following the PL/1 tradition), all of these are built-in features ("loop 5 clauses") of the "Loop Facility". <p> It is not possible to suspend iteration in one loop and to resume it with the same internal state in another loop. Common Lisp <ref> [12] </ref> is considering the incorporation of series or generators as two proposals for defining iterative constructs. These constructs appear to require special compilation and have a rather complex semantics. They include a large number of built-in operations.
Reference: [13] <author> Gerald J. Sussman and Guy L. Steele Jr. </author> <title> Scheme: An interpreter for Extended Lambda Calculus. </title> <note> Technical Report Artificial Intelligence Memo 349, </note> <institution> MIT, </institution> <month> De-cember </month> <year> 1975. </year>
Reference-contexts: a suspending coroutine may transfer control to any other waiting coroutine, the flow of control is structured by the "loop"-statement in the case of iters. 7 3.5 Blocks, Closures, and Lambda Expressions Traditionally, iteration abstraction is supported in object-oriented languages by providing anonymous blocks [4], lambda expressions [1], or closures <ref> [13] </ref>. The container classes provide methods to apply a block to all or part of their elements. The execution of such block-based iterations is controlled by the container class. With iters, the control is shared by the iter and the calling loop.
Reference: [14] <author> Clemens A. Szypersky. </author> <title> Insight Ethos: </title> <booktitle> On Object-Orientation in Operating Systems, volume 40 of Informatik-Dissertationen ETH Zurich. </booktitle> <publisher> Verlag der Fachvere-ine, </publisher> <address> Zurich, </address> <year> 1992. </year>
Reference-contexts: Riders are a similar idea introduced in Oberon [16] and generalized in Ethos <ref> [14] </ref>. The idea is to define objects that point into a container class and may be used to retrieve successive elements. Their interfaces include routines to create, initialize, increment, and test for completion. The attributes of the cursor object maintain the current state of the iteration.
Reference: [15] <author> Niklaus Wirth. </author> <title> Programming in Modula-2. </title> <publisher> Springer, </publisher> <year> 1983. </year> <month> 17 </month>
Reference-contexts: Since there is neither preemption nor true parallel execution among iters, we may model iters and the loop body as coroutines <ref> [15] </ref> (section 4). Iters are more structured than coroutines with respect to the freedom in passing control.
Reference: [16] <author> Niklaus Wirth and Jurg Gutknecht. </author> <title> Project Oberon The Design of an Operating System and Compiler. </title> <publisher> Addison-Wesley, </publisher> <year> 1992. </year> <month> 18 </month>
Reference-contexts: This prevents the use of the loop macro to support encapsulation of data structure specific iteration procedures. 3.2 Cursors, Riders, and C++ Iterators As mentioned above, cursor objects are a way of encapsulating iteration without additional language constructs. Riders are a similar idea introduced in Oberon <ref> [16] </ref> and generalized in Ethos [14]. The idea is to define objects that point into a container class and may be used to retrieve successive elements. Their interfaces include routines to create, initialize, increment, and test for completion.
References-found: 16

