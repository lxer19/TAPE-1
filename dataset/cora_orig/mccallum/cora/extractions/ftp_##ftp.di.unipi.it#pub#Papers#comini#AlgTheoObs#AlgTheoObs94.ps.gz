URL: ftp://ftp.di.unipi.it/pub/Papers/comini/AlgTheoObs/AlgTheoObs94.ps.gz
Refering-URL: http://www.di.unipi.it/di/groups/lp/papers.html
Root-URL: 
Title: n  
Author: T g n T n g 
Note: Abstract  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> K. R. Apt. </author> <title> Introduction to Logic Programming. </title> <editor> In J. van Leeuwen, editor, </editor> , <booktitle> volume B: Formal Models and Semantics, </booktitle> <pages> pages 495-574. </pages> <publisher> Elsevier, Amsterdam and The MIT Press, </publisher> <address> Cambridge, </address> <year> 1990. </year>
Reference-contexts: Finally section 4 considers the -observables, where the results are weaker yet meaningful from the abstract interpretation theory viewpoint. All the proofs can be found in [6]. For a comprehensive description of the semantics of (positive) logic programs see <ref> [21, 1] </ref>. , and denote a set of function symbols, a set of predicate symbols and a denumerable set of variables respectively. Tuples of variables and terms are sometimes denoted by ~ ~ and ~ ~ . <p> An observable is any property which can be extracted from a goal computation, i.e. . We assume the reader to be familiar with the notions of -resolution and -tree (see <ref> [21, 1] </ref>). We represent here, for notational convenience, -trees as sets of nodes.
Reference: [2] <author> A. Bossi, M. Gabbrielli, G. Levi, and M. Martelli. </author> <title> The s-semantics approach: </title> <journal> Theory and applications. </journal> , <note> 1994. to appear. </note>
Reference-contexts: The behavior of a program (via selection rule ) with respect to a given observable can be understood by observing the corresponding properties for all possible goals. We know from recent results on the semantics <ref> [11, 15, 2] </ref> that we can characterize this behavior just by observing the property for some specific atomic goals, namely the "most general" atomic goals. <p> Then if and only if , , s.t. and . grams. Then The goal we want to achieve is to develop a denotation modeling -trees. We follow the approach in <ref> [14, 2] </ref>, by first defining a "syntactic" semantic domain ( -interpretation). Our modeling of -trees is essentially the basic denotation defined in terms of clauses in [11, 15], extended to handle constraint systems in the style of [17, 19, 20]. <p> We consider two classes of observables, namely -observables and -ob-servables. The -observables ( emantic observables) are observables for which we can define a , which generalizes the properties of the -semantics <ref> [2] </ref>. This denotation provides a correct and complete characterization of the (abstract) program behavior.
Reference: [3] <author> A. Bossi, M. Gabbrielli, G. Levi, and M. C. Meo. </author> <title> A Compositional Semantics for Logic Programs. </title> , <address> 122(1-2):3-47, </address> <year> 1994. </year>
Reference-contexts: We have not considered yet two issues that could be discussed within the framework. The first one is related to <ref> [3] </ref>, which is a relevant property if we want to be able to reason about programs in a modular way. -trees are indeed -compositional. However, the abstraction process can destroy this property. For example, two of the abstractions that we have considered, namely computed answer constraints and call patterns, prop
Reference: [4] <author> M. Codish and B. Demoen. </author> <title> Analysing Logic Programs using " "-ositional Logic Programs and a Magic Wand. </title> <editor> In D. Miller, </editor> <booktitle> editor, </booktitle> , <pages> pages 114-129. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1993. </year>
Reference-contexts: The semantics obtained in [12] and, through a magic set like transformation, in <ref> [4] </ref> is ( ( )). It is a goal independent denotation computable either top-down or bottom-up. We have defined an algebraic framework which allows us to prove several properties of concrete and abstract -trees.
Reference: [5] <author> P. Codognet and G. </author> <title> File. Computations, Abstractions and Constraints. </title> <publisher> In . IEEE Press, </publisher> <year> 1992. </year>
Reference-contexts: Then One more motivation for our algebraic construction can be found in abstract interpretation. The essence of abstract interpretation is to give a non-standard interpretation to the language. In the case, as shown in <ref> [5, 17] </ref>, we only need to give a non-standard interpretation to constraints. In general a constraint system is an interpretation (in a semi-closed semir-ing) for constraint formulas. According to the approach of [19, 17, 20] constraint systems are related by means of constraint system semi-morphisms.
Reference: [6] <author> M. Comini and G. Levi. </author> <title> An algebraic theory of observables. </title> <type> Technical report, </type> <institution> Dipartimento di Informatica, Universita di Pisa, </institution> <year> 1994. </year>
Reference-contexts: Section 3 formalizes the main class of ob-servables, i.e. the -observables for which all the general results are valid. Finally section 4 considers the -observables, where the results are weaker yet meaningful from the abstract interpretation theory viewpoint. All the proofs can be found in <ref> [6] </ref>. For a comprehensive description of the semantics of (positive) logic programs see [21, 1]. , and denote a set of function symbols, a set of predicate symbols and a denumerable set of variables respectively. Tuples of variables and terms are sometimes denoted by ~ ~ and ~ ~ .
Reference: [7] <author> A. Cortesi, G. File, and W. Winsborough. </author> <title> revisited: Propositional Formula as Abstract Domain for Groundness Analysis. In , pages 322-327. </title> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: We show how to reconstruct the ground dependency analysis for call patterns described in [12]. The abstract domain of computation is <ref> [7] </ref>, consisting of propositional formulas which provide a concise representation of abstract substitutions which describe ground dependency relations among arguments of a procedure call. is the algebra of possibly existentially quantified disjunctions of formulas fl ( ) fl ( ) , where each belongs to (for some ) and fl (
Reference: [8] <author> P. Cousot and R. Cousot. </author> <title> Systematic Design of Program Analysis Frameworks. </title> <booktitle> In , pages 269-282, </booktitle> <year> 1979. </year>
Reference-contexts: We approach here the same problem with a different emphasis and a different technical tool. Our main objective is in fact the formalization of the observable, while our abstractions will be based on abstract interpretation techniques <ref> [8] </ref>. This will allow us to model, within the same framework, the approximation which is involved in the abstractions used for program analysis. A similar approach can be found in [18]. <p> We denote by ~ both the tuple and the set of corresponding syntactic objects. ~ denotes ~ ~ . ~ denotes a (possibly empty) conjunction of atoms and ~ ~ denotes the conjunction . For a comprehensive description of abstract interpretation see <ref> [8] </ref>. For a comprehensive description of term systems, closed semirings and constraints systems see [17]. In this paper we consider Constraint Logic Programs over a generic constraint system ( ( )). <p> This in turn means that there exists a Galois connection between the domains of the observables. Hence an observable : : if there exists a co-insertion : s.t. = Let ( ) be the set of observables ordered by approximation. It follows from <ref> [8] </ref> that ( ) is a complete lattice.
Reference: [9] <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> A new Declarative Semantics for Logic Languages. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> , <address> pages 993-1005. </address> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1988. </year>
Reference-contexts: We know from recent results on the semantics [11, 15, 2] that we can characterize this behavior just by observing the property for some specific atomic goals, namely the "most general" atomic goals. This result was first obtained for computed answers in the -semantics framework <ref> [9, 10] </ref> and then proved for other less abstract observables, such as resultants, call patterns and partial answers in [11, 15]. The behaviors for most general atomic goals can then be considered a program denotation. <p> The top-down construction, on the contrary, is always forced to build complete -trees which have later to be abstracted to get the observation. We show now how to reconstruct the version of the - semantics <ref> [9, 10] </ref>. We have already shown in example 3.4 that is an - observable.

Reference: [11] <author> M. </author> <title> Gabbrielli. </title> . <type> PhD thesis, </type> <institution> Dipartimento di Informatica, Universita di Pisa, </institution> <year> 1992. </year>
Reference-contexts: The behavior of a program (via selection rule ) with respect to a given observable can be understood by observing the corresponding properties for all possible goals. We know from recent results on the semantics <ref> [11, 15, 2] </ref> that we can characterize this behavior just by observing the property for some specific atomic goals, namely the "most general" atomic goals. <p> This result was first obtained for computed answers in the -semantics framework [9, 10] and then proved for other less abstract observables, such as resultants, call patterns and partial answers in <ref> [11, 15] </ref>. The behaviors for most general atomic goals can then be considered a program denotation. <p> Then The goal we want to achieve is to develop a denotation modeling -trees. We follow the approach in [14, 2], by first defining a "syntactic" semantic domain ( -interpretation). Our modeling of -trees is essentially the basic denotation defined in terms of clauses in <ref> [11, 15] </ref>, extended to handle constraint systems in the style of [17, 19, 20]. In the following for the sake of simplicity we consider the PROLOG leftmost selection rule (denoted by ). All our results can be generalized to local selection rules [23]. <p> We obtained the call pattern semantics defined in <ref> [16, 11, 15] </ref>. For a generic observable : , the previous theorems state that if is not an -observable then we cannot have a correct and fully abstract denotation which is -compositional. Instead we can have a correct -compositional denotation which is minimal w.r.t. the content of information.
Reference: [12] <author> M. Gabbrielli and R. Giacobazzi. </author> <title> Goal independency and call patterns in the analysis of logic programs. </title> <booktitle> In , 1994. </booktitle>
Reference-contexts: Theorems valid for -observables are therefore weaker and denotations provide characterizations of semantic properties which are correct in the sense of abstract interpretation theory. We show how we can reconstruct the abstract semantics defined in <ref> [12] </ref>, which allows us to derive groundness relations among the arguments of procedure calls. Given an observable we want to be able to observe computations of conjunctive goals from the single conjuncts computations. <p> We show how to reconstruct the ground dependency analysis for call patterns described in <ref> [12] </ref>. <p> The semantics obtained in <ref> [12] </ref> and, through a magic set like transformation, in [4] is ( ( )). It is a goal independent denotation computable either top-down or bottom-up. We have defined an algebraic framework which allows us to prove several properties of concrete and abstract -trees.
Reference: [13] <author> M. Gabbrielli and G. Levi. </author> <title> Modeling Answer Constraints in Constraint Logic Programs. </title> <editor> In K. Furukawa, editor, </editor> , <address> pages 238- 252. </address> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1991. </year>
Reference-contexts: CLP defined by collecting the behaviors for , i.e. goals consisting of the application of a predicate symbol to a tuple of distinct variables. We show how we can reconstruct within the framework some existing semantics, such as the answer constraint semantics <ref> [13] </ref> and the call patterns semantics [15, 16], thus obtaining all the relevant theorems simply by specializing the theorems which are valid in the framework. The -observables (abstract nterpretation observables) are meant to capture the abstractions involved in abstract interpretation, where approximation is the rule of the game. <p> apply theorem 3.5 and the definition of node, to obtain the following denotations: ( ) = ( ; ) ( ) = ( (~; ) (~) Note that ( ) contains all the answer constraints of , while ( ) is the version of the top-down definition of the -semantics <ref> [13] </ref>. Corollary 3.6 tells us that is correct and fully abstract w.r.t. answer constraints. Moreover theorem 3.5 tells us that answer constraints for any goal can be derived from the answer constraints of the most general atomic goals. <p> This result shows the power of our theory. In fact the proof of the same result, using classical methods <ref> [13] </ref>, needs much more effort. The call patterns of a program for a goal and a selection rule are the atoms selected in any -derivation of in via . We define the -domain made of objects of the form ( ), where is a goal and is an atom.
Reference: [14] <author> M. Gabbrielli and G. Levi. </author> <title> On the Semantics of Logic Programs. </title> <editor> In J. Leach Albert, B. Monien, and M. Rodriguez-Artalejo, editors, </editor> , <booktitle> volume 510 of , pages 1-19. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1991. </year>
Reference-contexts: Then if and only if , , s.t. and . grams. Then The goal we want to achieve is to develop a denotation modeling -trees. We follow the approach in <ref> [14, 2] </ref>, by first defining a "syntactic" semantic domain ( -interpretation). Our modeling of -trees is essentially the basic denotation defined in terms of clauses in [11, 15], extended to handle constraint systems in the style of [17, 19, 20].
Reference: [15] <author> M. Gabbrielli, G. Levi, and M. C. Meo. </author> <title> Observational Equivalences for Logic Programs. </title> <editor> In K. Apt, </editor> <booktitle> editor, </booktitle> , <pages> pages 131-145. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1992. </year>
Reference-contexts: The behavior of a program (via selection rule ) with respect to a given observable can be understood by observing the corresponding properties for all possible goals. We know from recent results on the semantics <ref> [11, 15, 2] </ref> that we can characterize this behavior just by observing the property for some specific atomic goals, namely the "most general" atomic goals. <p> This result was first obtained for computed answers in the -semantics framework [9, 10] and then proved for other less abstract observables, such as resultants, call patterns and partial answers in <ref> [11, 15] </ref>. The behaviors for most general atomic goals can then be considered a program denotation. <p> This result was first obtained for computed answers in the -semantics framework [9, 10] and then proved for other less abstract observables, such as resultants, call patterns and partial answers in [11, 15]. The behaviors for most general atomic goals can then be considered a program denotation. In <ref> [15] </ref> this approach is used to define a semantic framework, where one can define i S A A 1 1 i in 2 The basic framework V t x : : : ; b b; b b ; : : : ; b ; b ; : : : ; b <p> Then The goal we want to achieve is to develop a denotation modeling -trees. We follow the approach in [14, 2], by first defining a "syntactic" semantic domain ( -interpretation). Our modeling of -trees is essentially the basic denotation defined in terms of clauses in <ref> [11, 15] </ref>, extended to handle constraint systems in the style of [17, 19, 20]. In the following for the sake of simplicity we consider the PROLOG leftmost selection rule (denoted by ). All our results can be generalized to local selection rules [23]. <p> CLP defined by collecting the behaviors for , i.e. goals consisting of the application of a predicate symbol to a tuple of distinct variables. We show how we can reconstruct within the framework some existing semantics, such as the answer constraint semantics [13] and the call patterns semantics <ref> [15, 16] </ref>, thus obtaining all the relevant theorems simply by specializing the theorems which are valid in the framework. The -observables (abstract nterpretation observables) are meant to capture the abstractions involved in abstract interpretation, where approximation is the rule of the game. <p> We obtained the call pattern semantics defined in <ref> [16, 11, 15] </ref>. For a generic observable : , the previous theorems state that if is not an -observable then we cannot have a correct and fully abstract denotation which is -compositional. Instead we can have a correct -compositional denotation which is minimal w.r.t. the content of information.
Reference: [16] <author> M. Gabbrielli and M. C. Meo. </author> <title> Fixpoint Semantics for Partial Computed Answer Substitutions and Call Patterns. </title> <editor> In H. Kirchner and G. Levi, editors, </editor> , <booktitle> volume 632 of , pages 84-99. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: CLP defined by collecting the behaviors for , i.e. goals consisting of the application of a predicate symbol to a tuple of distinct variables. We show how we can reconstruct within the framework some existing semantics, such as the answer constraint semantics [13] and the call patterns semantics <ref> [15, 16] </ref>, thus obtaining all the relevant theorems simply by specializing the theorems which are valid in the framework. The -observables (abstract nterpretation observables) are meant to capture the abstractions involved in abstract interpretation, where approximation is the rule of the game. <p> We obtained the call pattern semantics defined in <ref> [16, 11, 15] </ref>. For a generic observable : , the previous theorems state that if is not an -observable then we cannot have a correct and fully abstract denotation which is -compositional. Instead we can have a correct -compositional denotation which is minimal w.r.t. the content of information.
Reference: [17] <author> R. Giacobazzi. </author> . <type> PhD thesis, </type> <institution> Dipartimento di Informatica, Universita di Pisa, </institution> <year> 1992. </year>
Reference-contexts: For a comprehensive description of abstract interpretation see [8]. For a comprehensive description of term systems, closed semirings and constraints systems see <ref> [17] </ref>. In this paper we consider Constraint Logic Programs over a generic constraint system ( ( )). When we want to formalize program execution we must take into account, in addition to the inference rules which specify how derivations are made, the properties we observe in a computation ( ). <p> We follow the approach in [14, 2], by first defining a "syntactic" semantic domain ( -interpretation). Our modeling of -trees is essentially the basic denotation defined in terms of clauses in [11, 15], extended to handle constraint systems in the style of <ref> [17, 19, 20] </ref>. In the following for the sake of simplicity we consider the PROLOG leftmost selection rule (denoted by ). All our results can be generalized to local selection rules [23]. <p> However, if the observable is compatible with , the two constructions are equivalent. It is worth noting that most reasonable observables are indeed compatible with (see the examples below). A similar relation between the top-down and bottom-up constructions was already noted for abstractions of the answer constraint in <ref> [17, 19, 20] </ref>. In that framework the equivalence was guaranteed in the case of distributive constraint systems. In such a case, our compatibility condition is always satisfied. <p> Then One more motivation for our algebraic construction can be found in abstract interpretation. The essence of abstract interpretation is to give a non-standard interpretation to the language. In the case, as shown in <ref> [5, 17] </ref>, we only need to give a non-standard interpretation to constraints. In general a constraint system is an interpretation (in a semi-closed semir-ing) for constraint formulas. According to the approach of [19, 17, 20] constraint systems are related by means of constraint system semi-morphisms. <p> In the case, as shown in [5, 17], we only need to give a non-standard interpretation to constraints. In general a constraint system is an interpretation (in a semi-closed semir-ing) for constraint formulas. According to the approach of <ref> [19, 17, 20] </ref> constraint systems are related by means of constraint system semi-morphisms. The program interpretation process is expressed in terms of a set of algebraic operators which model how data objects are collected during the computation. <p> The abstract denotation of is simply the denotation ( ( )) of the abstract program ( ). When clear from the context we denote by . The following theorem generalizes a result in <ref> [17] </ref> and states that the semantics of the "abstract program" is a safe approximation of the abstraction of the semantics of the program. : Since an -observable on the constraint system is obtained by an - observable on the constraint system we expect the semantics construction 0 0 Prop Prop &gt;
Reference: [18] <author> R. Giacobazzi. </author> <title> On the Collecting Semantics of Logic Programs. </title> <editor> In F. S. de Boer and M. Gabbrielli, </editor> <booktitle> editors, </booktitle> , <pages> pages 159-174, </pages> <year> 1994. </year>
Reference-contexts: This will allow us to model, within the same framework, the approximation which is involved in the abstractions used for program analysis. A similar approach can be found in <ref> [18] </ref>. Our main results are the definition of an algebraic framework for reasoning about -trees and their abstractions (observables) in the case of Constraint Logic Programs.
Reference: [19] <author> R. Giacobazzi, S. K. Debray, and G. Levi. </author> <title> A Generalized Semantics for Constraint Logic Programs. </title> <booktitle> In , pages 581-591, </booktitle> <year> 1992. </year>
Reference-contexts: We follow the approach in [14, 2], by first defining a "syntactic" semantic domain ( -interpretation). Our modeling of -trees is essentially the basic denotation defined in terms of clauses in [11, 15], extended to handle constraint systems in the style of <ref> [17, 19, 20] </ref>. In the following for the sake of simplicity we consider the PROLOG leftmost selection rule (denoted by ). All our results can be generalized to local selection rules [23]. <p> However, if the observable is compatible with , the two constructions are equivalent. It is worth noting that most reasonable observables are indeed compatible with (see the examples below). A similar relation between the top-down and bottom-up constructions was already noted for abstractions of the answer constraint in <ref> [17, 19, 20] </ref>. In that framework the equivalence was guaranteed in the case of distributive constraint systems. In such a case, our compatibility condition is always satisfied. <p> In the case, as shown in [5, 17], we only need to give a non-standard interpretation to constraints. In general a constraint system is an interpretation (in a semi-closed semir-ing) for constraint formulas. According to the approach of <ref> [19, 17, 20] </ref> constraint systems are related by means of constraint system semi-morphisms. The program interpretation process is expressed in terms of a set of algebraic operators which model how data objects are collected during the computation.
Reference: [20] <author> R. Giacobazzi, G. Levi, and S. K. Debray. </author> <title> Joining Abstract and Concrete Computations in Constraint Logic Programming. </title> <editor> In M. Nivat, C. Rattray, T. Rus, and G. Scollo, editors, </editor> , <booktitle> Workshops in Computing, </booktitle> <pages> pages 111-127. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1993. </year>
Reference-contexts: We follow the approach in [14, 2], by first defining a "syntactic" semantic domain ( -interpretation). Our modeling of -trees is essentially the basic denotation defined in terms of clauses in [11, 15], extended to handle constraint systems in the style of <ref> [17, 19, 20] </ref>. In the following for the sake of simplicity we consider the PROLOG leftmost selection rule (denoted by ). All our results can be generalized to local selection rules [23]. <p> However, if the observable is compatible with , the two constructions are equivalent. It is worth noting that most reasonable observables are indeed compatible with (see the examples below). A similar relation between the top-down and bottom-up constructions was already noted for abstractions of the answer constraint in <ref> [17, 19, 20] </ref>. In that framework the equivalence was guaranteed in the case of distributive constraint systems. In such a case, our compatibility condition is always satisfied. <p> In the case, as shown in [5, 17], we only need to give a non-standard interpretation to constraints. In general a constraint system is an interpretation (in a semi-closed semir-ing) for constraint formulas. According to the approach of <ref> [19, 17, 20] </ref> constraint systems are related by means of constraint system semi-morphisms. The program interpretation process is expressed in terms of a set of algebraic operators which model how data objects are collected during the computation.
Reference: [21] <editor> J. W. Lloyd. </editor> . <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1987. </year> <note> Second edition. </note>
Reference-contexts: Finally section 4 considers the -observables, where the results are weaker yet meaningful from the abstract interpretation theory viewpoint. All the proofs can be found in [6]. For a comprehensive description of the semantics of (positive) logic programs see <ref> [21, 1] </ref>. , and denote a set of function symbols, a set of predicate symbols and a denumerable set of variables respectively. Tuples of variables and terms are sometimes denoted by ~ ~ and ~ ~ . <p> An observable is any property which can be extracted from a goal computation, i.e. . We assume the reader to be familiar with the notions of -resolution and -tree (see <ref> [21, 1] </ref>). We represent here, for notational convenience, -trees as sets of nodes.
Reference: [22] <author> J. W. Lloyd and J. C. Shepherdson. </author> <title> Partial Evaluation in Logic Programming. </title> , <booktitle> 11 </booktitle> <pages> 217-242, </pages> <year> 1991. </year>
Reference: [23] <author> L. Vieille. </author> <title> Recursive query processing: </title> <journal> the power of logic. </journal> , <volume> 69 </volume> <pages> 1-53, </pages> <year> 1989. </year>
Reference-contexts: In the following for the sake of simplicity we consider the PROLOG leftmost selection rule (denoted by ). All our results can be generalized to local selection rules <ref> [23] </ref>. Let us consider the equivalence relation of variance extended to nodes . ( ) A denotation of the program characterizing its -trees computed by using the rule might be the set of the -trees for all the possible goals modulo variance, i.e. ( ) .
References-found: 22

