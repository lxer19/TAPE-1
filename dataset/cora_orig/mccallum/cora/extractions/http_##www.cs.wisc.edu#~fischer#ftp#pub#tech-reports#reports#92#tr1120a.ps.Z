URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/reports/92/tr1120a.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/reports/92/
Root-URL: http://www.cs.wisc.edu
Abstract-found: 0
Intro-found: 1
Reference: 1. <author> Agarwal, A., Simoni, R., Horowitz, M., and Hennessy, J., </author> <title> An evaluation of directory schemes for cache coherence, </title> <booktitle> in Proceedings of the Fifteenth Annual International Symposium on Computer Architecture, </booktitle> <address> (Honolulu, Hawaii, </address> <month> June </month> <year> 1988), </year> <month> (June </month> <year> 1988). </year>
Reference-contexts: For example, with the declaration numeral: Numeral (bits); a numeral node has two such conceptual leaves, denoted by numeral [0] for the one on the left and numeral <ref> [1] </ref> for the one on the right. <p> access a symbol-table entry with only a few accesses to shared memory. hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 5 There are many approaches that have been used to provide shared memory on multiprocessors, either in software (e.g., shared virtual memory on loosely coupled multiprocessors [21]) or in hardware (via snooping caches [3] or directory protocols <ref> [1] </ref>).
Reference: 2. <author> Aho, A.V., Sethi, R., and Ullman, J.D., </author> <booktitle> Compilers: Principles, Techniques, and Tools, </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA (1986). </address>
Reference-contexts: Thus, our results contribute to the development of parallelized implementations of tools in all of these domains. The particular question addressed is how to exploit parallelism during the evaluation of the attributes of a derivation tree of a (non-circular) attribute grammar [18] (see also [27] or <ref> [2] </ref>). Although this problem has been addressed by others [6, 13, 17, 19, 28], what distinguishes the ideas presented in this paper from earlier work on parallel attribute evaluation is the use of data-parallelism.
Reference: 3. <author> Archibald, J. and Baer, J.-L., </author> <title> Cache coherence protocols: Evaluation using a multiprocessor simulation model, </title> <journal> ACM Trans. on Computer Systems 4(4) pp. </journal> <month> 273-298 (November </month> <year> 1986). </year>
Reference-contexts: must be possible to access a symbol-table entry with only a few accesses to shared memory. hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 5 There are many approaches that have been used to provide shared memory on multiprocessors, either in software (e.g., shared virtual memory on loosely coupled multiprocessors [21]) or in hardware (via snooping caches <ref> [3] </ref> or directory protocols [1]).
Reference: 4. <author> Babich, W.A. and Jazayeri, M., </author> <title> The method of attributes for data flow analysis: Part I. Exhaustive analysis, </title> <note> Acta Informa-tica 10(3) pp. </note> <month> 245-264 (October </month> <year> 1978). </year>
Reference-contexts: Other examples of evaluation algorithms in which the final value of an attribute is accumulated from previous values are the various algorithms proposed for evaluating circular attribute grammars <ref> [4, 9, 11, 12, 26] </ref>.
Reference: 5. <author> Blelloch, G.E., </author> <title> Vector Models for Data-Parallel Computing, </title> <publisher> The M.I.T. Press, </publisher> <address> Cambridge, MA (1990). </address>
Reference-contexts: Authors' address: Computer Sciences Department, Univ. of Wisconsin, 1210 W. Dayton St., Madison, WI 53706. Email: reps@cs.wisc.edu. data-parallel model is a scan over a sequence with respect to an associative operator <ref> [5] </ref>. (The scan operation is sometimes called parallel-prefix or parallel-suffix.) A scan computes a new sequence whose elements are the partial sums of the original sequence. In general, we are given a sequence x 1 , . . . , x n and an associative binary operator . <p> Instead of a simple left-to-right flow of information, the parallel-evaluation strategy uses a different pattern of information flow, which is based on the one employed in the algorithms for carry-lookahead addition [23] and the efficient parallel evaluation of scan operations <ref> [5, 20] </ref> (see Section 3.2). Given one processor per production instance in the derivation tree, a scan-attribution can be evaluated in parallel in 2D + 1 steps, where D is the depth of the derivation tree. <p> Parallel implementation of scan-attribution Because scan-attributions are defined in terms of associative operators, they can be evaluated efficiently in parallel. The pattern of information flow in the parallel evaluation algorithm is based on that employed in the algorithm for the efficient parallel evaluation of scan operations <ref> [5, 20] </ref> (of which carry-lookahead addition is one example [23]). <p> After the down sweep, the values at the leaves are the results of a scan <ref> [5] </ref>. 4 . It is actually not necessary that the problem-decomposition tree be balanced, nor is it necessary that it be a binary tree.
Reference: 6. <author> Boehm, H.-J. and Zwaenepoel, W., </author> <title> Parallel attribute grammar evaluation, pp. </title> <booktitle> 347-354 in Proceedings of the Seventh International Conference on Distributed Computing Systems, </booktitle> <address> (Berlin, </address> <publisher> W. Germany), </publisher> <editor> ed. R. Popescu-Zeletin, G. LeLann, and K.H. </editor> <publisher> Kim,IEEE Computer Society, </publisher> <address> Washington, DC (September 1987). </address>
Reference-contexts: The particular question addressed is how to exploit parallelism during the evaluation of the attributes of a derivation tree of a (non-circular) attribute grammar [18] (see also [27] or [2]). Although this problem has been addressed by others <ref> [6, 13, 17, 19, 28] </ref>, what distinguishes the ideas presented in this paper from earlier work on parallel attribute evaluation is the use of data-parallelism. <p> Attribution rules are defined with respect to a set of grammar rules. Here we define the abstract syntax of binary numerals by giving a collection of operator/operand declarations: 2 hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 1 Some of the speedup figures were established by measuring an implemented system <ref> [6] </ref>; others come from simulations [19, 28]. 2 This notation is a variant of context-free grammars in which the operator names (Numeral, Pair, Bit, Zero, and One) serve to identify the productions uniquely. For example, the declaration numeral: Numeral (bits); is the analogue of the production numeral fi bits. <p> However, from a pragmatic standpoint this may not be necessary. My conjecture is that for almost all problems that arise in practice scan-attributions plus the above three patterns suffice.) 7. Relation to previous work Other work on parallel attribute evaluation includes <ref> [6, 13, 17, 19, 28] </ref>. Kaplan and Kaiser present a distributed evaluator for the problem of incremental attribute updating in language-sensitive editors [13]. Boehm and Zwaenepoel describe an implemented parallel attribute-grammar evaluator that runs on a network multiprocessor of six SUN-2 workstations connected by an Ethernet network [6]. <p> Kaplan and Kaiser present a distributed evaluator for the problem of incremental attribute updating in language-sensitive editors [13]. Boehm and Zwaenepoel describe an implemented parallel attribute-grammar evaluator that runs on a network multiprocessor of six SUN-2 workstations connected by an Ethernet network <ref> [6] </ref>. In [28], Zaring presents parallel algorithms for ordered attribute grammars [14]; Zaring gives algorithms for both tightly coupled and loosely coupled multiprocessor architectures.
Reference: 7. <author> Brent, </author> <title> R.P., The parallel evaluation of general arithmetic expressions, </title> <journal> J. ACM 21(2) pp. </journal> <month> 201-206 </month> <year> (1974). </year>
Reference-contexts: With fewer processors than one per production instance, substantial speedups can still be obtained by having each actual processor simulate the actions that need to be carried out at some number of production instances. In particular, by a theorem of Brent <ref> [7, 8] </ref>, a scan-attribution can be evaluated in at most 2N /P + (2D + 1) steps, where N is the number of production instances in the derivation tree and P &lt; N is the number of processors. <p> The scheduling technique used in the simulation theorem of Brent can be used <ref> [7, 8] </ref> and consequently a scan-attribution can be evaluated in at most 2N /P + (2D + 1) steps.
Reference: 8. <author> Cormen, T.H., Leiserson, C.E., and Rivest, </author> <title> R.L., Introduction to Algorithms, </title> <publisher> The M.I.T. Press, </publisher> <address> Cambridge, MA (1990). </address>
Reference-contexts: With fewer processors than one per production instance, substantial speedups can still be obtained by having each actual processor simulate the actions that need to be carried out at some number of production instances. In particular, by a theorem of Brent <ref> [7, 8] </ref>, a scan-attribution can be evaluated in at most 2N /P + (2D + 1) steps, where N is the number of production instances in the derivation tree and P &lt; N is the number of processors. <p> The scheduling technique used in the simulation theorem of Brent can be used <ref> [7, 8] </ref> and consequently a scan-attribution can be evaluated in at most 2N /P + (2D + 1) steps.
Reference: 9. <author> Farrow, R., </author> <title> Automatic generation of fixed-point-finding evaluators for circular, but well-defined, attribute grammars, </title> <booktitle> Proceedings of the SIGPLAN 86 Symposium on Compiler Construction, </booktitle> <address> (Palo Alto, CA, </address> <month> June 25-27, </month> <year> 1986), </year> <journal> ACM SIG-PLAN Notices 21(7) pp. </journal> <month> 85-98 (July </month> <year> 1986). </year>
Reference-contexts: Other examples of evaluation algorithms in which the final value of an attribute is accumulated from previous values are the various algorithms proposed for evaluating circular attribute grammars <ref> [4, 9, 11, 12, 26] </ref>.
Reference: 10. <author> Hoover, R. and Teitelbaum, T., </author> <title> Efficient incremental evaluation of aggregate values in attribute grammars, </title> <booktitle> Proceedings of the SIGPLAN 86 Symposium on Compiler Construction, </booktitle> <address> (Palo Alto, CA, </address> <month> June 25-27, </month> <year> 1986), </year> <journal> ACM SIGPLAN Notices 21(7) pp. </journal> <month> 39-50 (July </month> <year> 1986). </year>
Reference-contexts: One example of previous work in which the final value of an attribute accumulates from previous values is the differential algorithm of Hoover and Teitelbaum for incremental updating of aggregate-valued attributes in language-sensitive editors <ref> [10] </ref>, which may consider an attribute several times during updating. This is done to compensate for the evaluator's use of imprecise information about the ordering of dependences between attributes.
Reference: 11. <author> Jones, L. and Simon, J., </author> <title> Hierarchical VLSI design systems based on attribute grammars, pp. </title> <booktitle> 58-69 in Conference Record of the Thirteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (St. Petersburg, FL, </address> <month> Jan. </month> <pages> 13-15, </pages> <address> 1986), </address> <publisher> ACM, </publisher> <address> New York, NY (1986). </address>
Reference-contexts: Other examples of evaluation algorithms in which the final value of an attribute is accumulated from previous values are the various algorithms proposed for evaluating circular attribute grammars <ref> [4, 9, 11, 12, 26] </ref>.
Reference: 12. <author> Jones, L.G., </author> <title> Efficient evaluation of circular attribute grammars, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 12(3) pp. </pages> <month> 429-462 (July </month> <year> 1989). </year>
Reference-contexts: Other examples of evaluation algorithms in which the final value of an attribute is accumulated from previous values are the various algorithms proposed for evaluating circular attribute grammars <ref> [4, 9, 11, 12, 26] </ref>.
Reference: 13. <author> Kaplan, S. and Kaiser, G., </author> <title> Incremental attribute evaluation in distributed language-based editors, pp. </title> <booktitle> 121-130 in Proceedings of the Fifth ACM Symposium on Principles of Distributed Computing, </booktitle> <year> (1986). </year>
Reference-contexts: The particular question addressed is how to exploit parallelism during the evaluation of the attributes of a derivation tree of a (non-circular) attribute grammar [18] (see also [27] or [2]). Although this problem has been addressed by others <ref> [6, 13, 17, 19, 28] </ref>, what distinguishes the ideas presented in this paper from earlier work on parallel attribute evaluation is the use of data-parallelism. <p> However, from a pragmatic standpoint this may not be necessary. My conjecture is that for almost all problems that arise in practice scan-attributions plus the above three patterns suffice.) 7. Relation to previous work Other work on parallel attribute evaluation includes <ref> [6, 13, 17, 19, 28] </ref>. Kaplan and Kaiser present a distributed evaluator for the problem of incremental attribute updating in language-sensitive editors [13]. Boehm and Zwaenepoel describe an implemented parallel attribute-grammar evaluator that runs on a network multiprocessor of six SUN-2 workstations connected by an Ethernet network [6]. <p> Relation to previous work Other work on parallel attribute evaluation includes [6, 13, 17, 19, 28]. Kaplan and Kaiser present a distributed evaluator for the problem of incremental attribute updating in language-sensitive editors <ref> [13] </ref>. Boehm and Zwaenepoel describe an implemented parallel attribute-grammar evaluator that runs on a network multiprocessor of six SUN-2 workstations connected by an Ethernet network [6]. In [28], Zaring presents parallel algorithms for ordered attribute grammars [14]; Zaring gives algorithms for both tightly coupled and loosely coupled multiprocessor architectures.
Reference: 14. <author> Kastens, U., </author> <title> Ordered attribute grammars, </title> <note> Acta Informatica 13(3) pp. </note> <month> 229-256 </month> <year> (1980). </year>
Reference-contexts: Boehm and Zwaenepoel describe an implemented parallel attribute-grammar evaluator that runs on a network multiprocessor of six SUN-2 workstations connected by an Ethernet network [6]. In [28], Zaring presents parallel algorithms for ordered attribute grammars <ref> [14] </ref>; Zaring gives algorithms for both tightly coupled and loosely coupled multiprocessor architectures.
Reference: 15. <author> Katayama, T., </author> <title> Translation of attribute grammars into procedures, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 6(3) pp. </pages> <month> 345-369 (July </month> <year> 1984). </year>
Reference-contexts: However, their work is more in the spirit of Zaring's work, which deals with the parallel evaluation of plans for Kastens's class of ordered attribute grammars. Klaiber and Gokhale's work has similar goals, but is couched in terms of Katayama's translation of attribute grammars to mututally recursive procedures <ref> [15] </ref>. Klaiber and Gokhale address the problem of determining which calls to evaluation procedures can be scheduled in parallel. The list-flattening transformation is a normalization step that can uncover additional parallelization opportunities for their scheduling algorithm. Acknowledgements Susan Horwitz provided many comments and helpful suggestions as this paper was being prepared.
Reference: 16. <author> Kernighan, B. and Plauger, P., </author> <title> Software Tools in Pascal, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA (1981). </address>
Reference-contexts: To get a feel for what this means for abstract syntax trees of actual programs, we measured two (uncontrived) Pascal programs: format.p, a simple text-formatting program taken from Kernighan and Plauger's book <ref> [16] </ref>, and gradestats.p, a grading program obtained from a colleague. Figure 1 presents figures on steps, speedup, and efficiency as a function of number of processors for the two programs.
Reference: 17. <author> Klaiber, A. and Gokhale, M., </author> <title> Parallel evaluation of attribute grammars, </title> <journal> IEEE Transactions on Parallel and Distributed Systems 3(2) pp. </journal> <month> 206-220 (March </month> <year> 1992). </year>
Reference-contexts: The particular question addressed is how to exploit parallelism during the evaluation of the attributes of a derivation tree of a (non-circular) attribute grammar [18] (see also [27] or [2]). Although this problem has been addressed by others <ref> [6, 13, 17, 19, 28] </ref>, what distinguishes the ideas presented in this paper from earlier work on parallel attribute evaluation is the use of data-parallelism. <p> However, from a pragmatic standpoint this may not be necessary. My conjecture is that for almost all problems that arise in practice scan-attributions plus the above three patterns suffice.) 7. Relation to previous work Other work on parallel attribute evaluation includes <ref> [6, 13, 17, 19, 28] </ref>. Kaplan and Kaiser present a distributed evaluator for the problem of incremental attribute updating in language-sensitive editors [13]. Boehm and Zwaenepoel describe an implemented parallel attribute-grammar evaluator that runs on a network multiprocessor of six SUN-2 workstations connected by an Ethernet network [6]. <p> Klaiber and Gokhale also make use of an attribute-grammar transformation to restructure computations, in their case a list-flattening transformation <ref> [17] </ref>. However, their work is more in the spirit of Zaring's work, which deals with the parallel evaluation of plans for Kastens's class of ordered attribute grammars. Klaiber and Gokhale's work has similar goals, but is couched in terms of Katayama's translation of attribute grammars to mututally recursive procedures [15].
Reference: 18. <author> Knuth, D.E., </author> <title> Semantics of context-free languages, </title> <journal> Math. Syst. </journal> <note> Theory 2(2) pp. </note> <month> 127-145 (June </month> <year> 1968). </year>
Reference-contexts: Thus, our results contribute to the development of parallelized implementations of tools in all of these domains. The particular question addressed is how to exploit parallelism during the evaluation of the attributes of a derivation tree of a (non-circular) attribute grammar <ref> [18] </ref> (see also [27] or [2]). Although this problem has been addressed by others [6, 13, 17, 19, 28], what distinguishes the ideas presented in this paper from earlier work on parallel attribute evaluation is the use of data-parallelism.
Reference: 19. <author> Kuiper, M.F., </author> <title> Parallel attribute evaluation, </title> <type> Ph.D. dissertation, </type> <institution> Dept. of Computer Science, Utrecht University, </institution> <address> Utrecht, The Netherlands (1989). </address>
Reference-contexts: The particular question addressed is how to exploit parallelism during the evaluation of the attributes of a derivation tree of a (non-circular) attribute grammar [18] (see also [27] or [2]). Although this problem has been addressed by others <ref> [6, 13, 17, 19, 28] </ref>, what distinguishes the ideas presented in this paper from earlier work on parallel attribute evaluation is the use of data-parallelism. <p> Attribution rules are defined with respect to a set of grammar rules. Here we define the abstract syntax of binary numerals by giving a collection of operator/operand declarations: 2 hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 1 Some of the speedup figures were established by measuring an implemented system [6]; others come from simulations <ref> [19, 28] </ref>. 2 This notation is a variant of context-free grammars in which the operator names (Numeral, Pair, Bit, Zero, and One) serve to identify the productions uniquely. For example, the declaration numeral: Numeral (bits); is the analogue of the production numeral fi bits. <p> However, from a pragmatic standpoint this may not be necessary. My conjecture is that for almost all problems that arise in practice scan-attributions plus the above three patterns suffice.) 7. Relation to previous work Other work on parallel attribute evaluation includes <ref> [6, 13, 17, 19, 28] </ref>. Kaplan and Kaiser present a distributed evaluator for the problem of incremental attribute updating in language-sensitive editors [13]. Boehm and Zwaenepoel describe an implemented parallel attribute-grammar evaluator that runs on a network multiprocessor of six SUN-2 workstations connected by an Ethernet network [6]. <p> Kuiper's work is somewhat closer to ours in spirit in that he makes use of an attribute-grammar transformation to restructure computations <ref> [19] </ref>. When his transformation is applicable, the attribute equations of the transformed attribute grammar specify a computation equivalent to the original attribute equations, but the derivation tree's dependence chains are shorter, which increases the amount of potential parallelism.
Reference: 20. <author> Leighton, </author> <title> F.T., Introduction to Parallel Algorithms and Architectures: Arrays, Trees, Hypercubes, </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> San Mateo, CA (1992). </address>
Reference-contexts: Instead of a simple left-to-right flow of information, the parallel-evaluation strategy uses a different pattern of information flow, which is based on the one employed in the algorithms for carry-lookahead addition [23] and the efficient parallel evaluation of scan operations <ref> [5, 20] </ref> (see Section 3.2). Given one processor per production instance in the derivation tree, a scan-attribution can be evaluated in parallel in 2D + 1 steps, where D is the depth of the derivation tree. <p> Parallel implementation of scan-attribution Because scan-attributions are defined in terms of associative operators, they can be evaluated efficiently in parallel. The pattern of information flow in the parallel evaluation algorithm is based on that employed in the algorithm for the efficient parallel evaluation of scan operations <ref> [5, 20] </ref> (of which carry-lookahead addition is one example [23]).
Reference: 21. <author> Li, K. and Hudak, P., </author> <title> Memory coherence in shared virtual memory systems, </title> <journal> ACM Transactions on Computer Systems 7(4) pp. </journal> <month> 321-359 (November </month> <year> 1989). </year>
Reference-contexts: a location in shared memory). (3) It must be possible to access a symbol-table entry with only a few accesses to shared memory. hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 5 There are many approaches that have been used to provide shared memory on multiprocessors, either in software (e.g., shared virtual memory on loosely coupled multiprocessors <ref> [21] </ref>) or in hardware (via snooping caches [3] or directory protocols [1]).
Reference: 22. <author> Myers, </author> <title> E.W., Efficient applicative data types, pp. </title> <booktitle> 66-75 in Conference Record of the Eleventh ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Salt Lake City, UT, </address> <month> Jan. </month> <pages> 15-18, </pages> <address> 1984), </address> <publisher> ACM, </publisher> <address> New York, NY (1984). </address>
Reference-contexts: For the case of a single global scope, one way to imple-ment a symbol table that satisfies these conditions is to use a balanced tree (such as a 2-3 tree, B-tree, or AVL tree) that is updated applicatively (i.e., the spine of the tree is copied on each insertion) <ref> [22, 24] </ref>. With such structures, the only information that needs to be passed explicitly from processor to processor during a symbol-table construction scan is a pointer to the root of the tree.
Reference: 23. <author> Ofman, Y., </author> <title> On the algorithmic complexity of discrete functions, </title> <journal> Soviet Physics Doklady 7(7) pp. </journal> <note> 589-591 (1963). English translation. </note>
Reference-contexts: Instead of a simple left-to-right flow of information, the parallel-evaluation strategy uses a different pattern of information flow, which is based on the one employed in the algorithms for carry-lookahead addition <ref> [23] </ref> and the efficient parallel evaluation of scan operations [5, 20] (see Section 3.2). Given one processor per production instance in the derivation tree, a scan-attribution can be evaluated in parallel in 2D + 1 steps, where D is the depth of the derivation tree. <p> The pattern of information flow in the parallel evaluation algorithm is based on that employed in the algorithm for the efficient parallel evaluation of scan operations [5, 20] (of which carry-lookahead addition is one example <ref> [23] </ref>). A scan operation with respect to an associative operator can be performed on a sequence of length k in 2Rlog kH + 1 steps by decomposing the problem into subprob-lems and arranging the subproblems in a balanced binary tree of depth Rlog k H.
Reference: 24. <author> Reps, T., Teitelbaum, T., and Demers, A., </author> <title> Incremental context-dependent analysis for language-based editors, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 5(3) pp. </pages> <month> 449-477 (July </month> <year> 1983). </year>
Reference-contexts: For the case of a single global scope, one way to imple-ment a symbol table that satisfies these conditions is to use a balanced tree (such as a 2-3 tree, B-tree, or AVL tree) that is updated applicatively (i.e., the spine of the tree is copied on each insertion) <ref> [22, 24] </ref>. With such structures, the only information that needs to be passed explicitly from processor to processor during a symbol-table construction scan is a pointer to the root of the tree.
Reference: 25. <author> Reps, T. and Teitelbaum, T., </author> <title> The Synthesizer Generator: A System for Constructing Language-Based Editors, </title> <publisher> Springer-Verlag, </publisher> <address> New York, NY (1988). </address>
Reference-contexts: For example, the declaration numeral: Numeral (bits); is the analogue of the production numeral fi bits. In general, the notation used in this paper's examples is adapted from the notation used in the Synthesizer Generator <ref> [25] </ref>, a widely distributed system based on attribute grammars. numeral: Numeral (bits); bits: Pair (bits bits) | Bit (bit) bit: Zero () | One () Aside. Before giving the scan grammar's attribution rules for the binary-numeral problem, we first give rules for a conventional attribute grammar that solves the problem. <p> The measurements reported in Figure 1 were taken on trees defined by the Pascal attribute grammar that is distributed with the Synthesizer Generator system for generating language-sensitive editors <ref> [25] </ref>.
Reference: 26. <author> Skedzeleski, </author> <title> S.K., Definition and use of attribute reevaluation in attributed grammars, </title> <type> Ph.D. dissertation and Tech. Rep. </type> <institution> TR-340, Computer Sciences Department, University of Wisconsin, Madison, </institution> <note> WI (October 1978). </note>
Reference-contexts: Other examples of evaluation algorithms in which the final value of an attribute is accumulated from previous values are the various algorithms proposed for evaluating circular attribute grammars <ref> [4, 9, 11, 12, 26] </ref>.
Reference: 27. <author> Waite, W.M. and Goos, G., </author> <title> Compiler Construction, </title> <publisher> Springer-Verlag, </publisher> <address> New York, NY (1983). </address>
Reference-contexts: Thus, our results contribute to the development of parallelized implementations of tools in all of these domains. The particular question addressed is how to exploit parallelism during the evaluation of the attributes of a derivation tree of a (non-circular) attribute grammar [18] (see also <ref> [27] </ref> or [2]). Although this problem has been addressed by others [6, 13, 17, 19, 28], what distinguishes the ideas presented in this paper from earlier work on parallel attribute evaluation is the use of data-parallelism.
Reference: 28. <author> Zaring, A., </author> <title> Parallel evaluation in attribute grammar based systems, </title> <type> Ph.D. dissertation and Tech. Rep. 90-1149, </type> <institution> Dept. of Computer Science, Cornell University, </institution> <address> Ithaca, NY (August 1990). </address>
Reference-contexts: The particular question addressed is how to exploit parallelism during the evaluation of the attributes of a derivation tree of a (non-circular) attribute grammar [18] (see also [27] or [2]). Although this problem has been addressed by others <ref> [6, 13, 17, 19, 28] </ref>, what distinguishes the ideas presented in this paper from earlier work on parallel attribute evaluation is the use of data-parallelism. <p> Attribution rules are defined with respect to a set of grammar rules. Here we define the abstract syntax of binary numerals by giving a collection of operator/operand declarations: 2 hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 1 Some of the speedup figures were established by measuring an implemented system [6]; others come from simulations <ref> [19, 28] </ref>. 2 This notation is a variant of context-free grammars in which the operator names (Numeral, Pair, Bit, Zero, and One) serve to identify the productions uniquely. For example, the declaration numeral: Numeral (bits); is the analogue of the production numeral fi bits. <p> However, from a pragmatic standpoint this may not be necessary. My conjecture is that for almost all problems that arise in practice scan-attributions plus the above three patterns suffice.) 7. Relation to previous work Other work on parallel attribute evaluation includes <ref> [6, 13, 17, 19, 28] </ref>. Kaplan and Kaiser present a distributed evaluator for the problem of incremental attribute updating in language-sensitive editors [13]. Boehm and Zwaenepoel describe an implemented parallel attribute-grammar evaluator that runs on a network multiprocessor of six SUN-2 workstations connected by an Ethernet network [6]. <p> Kaplan and Kaiser present a distributed evaluator for the problem of incremental attribute updating in language-sensitive editors [13]. Boehm and Zwaenepoel describe an implemented parallel attribute-grammar evaluator that runs on a network multiprocessor of six SUN-2 workstations connected by an Ethernet network [6]. In <ref> [28] </ref>, Zaring presents parallel algorithms for ordered attribute grammars [14]; Zaring gives algorithms for both tightly coupled and loosely coupled multiprocessor architectures.
References-found: 28

