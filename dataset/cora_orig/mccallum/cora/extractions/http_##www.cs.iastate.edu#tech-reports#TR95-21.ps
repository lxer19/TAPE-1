URL: http://www.cs.iastate.edu/tech-reports/TR95-21.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: 
Title: Polymorphic Type-Checking in Scheme  
Author: Steven L. Jenkins 
Keyword: abstract data type, type inference, supertype abstraction. 1992 CR Categories: D.3.3 [Programming Languages] Language Constructs Abstract data types.  
Address: 226 Atanasoff Hall  Ames, Iowa 50011-1040, USA  
Affiliation: Department of Computer Science  Iowa State University  
Note: 1995  
Date: August  
Pubnum: TR#95-21  
Abstract: Submitted for publication. Copyright Steven Jenkins and Gary Leavens 1995. Copies may be made for research and scholarly purposes, but not for direct commercial advantage. All rights reserved. Some funding for the project was provided by NSF grant CCR 9593168. 
Abstract-found: 1
Intro-found: 1
Reference: [AbS85] <author> Harold Abelson, Gerald Sussman and Julie Sussman, </author> <title> Structure and Interpretation of Computer Programs, 13th edition, </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts. </address>
Reference-contexts: The code from the first ten chapters of [SpF89] have been checked, as well as sample student code from exercises. Code from other sources was also examined. In particular, code from the first chapter of <ref> [AbS85] </ref> was examined. Since SICP uses nested define s, the report generated in the table was used setting the variable *allow-nested-defines* to #t , which then allowed the programs using nested define s to be desugared into programs using letrec . <p> The problems here, as mentioned above, were primarily with vector-generator and procedures that take a variable number of arguments. The code from the first chapter of <ref> [AbS85] </ref> was the most successfully typed code set. Essentially no errors were produced after some simple transformations were done; i.e., 20 renaming several versions of the same procedure, and adding definitions for some system--specific procedures (e.g., 1+ and 1-). <p> in [Lin93], which does not provide the source for member? ; it is assumed that the implementation is something resembling: (define member? (lambda (item ls) (cond ((null? ls) #f) ((equal? item (car ls)) #t) (else (member? item (cdr ls)))))) In his paper, Lindig provides some results from type-checking code from <ref> [AbS85] </ref>, and from that, we see that his system appears quite practical. However, since we have been unable to obtain a copy, we cannot make any accurate comparisons of our two systems at this time. The last system examined is Wright's and Cartwright's Soft Scheme [WrC93].
Reference: [Car87] <author> Luca Cardelli, </author> <title> Basic Polymorphic Typechecking, </title> <booktitle> Science of Computer Programming, </booktitle> <month> 8,2 (April </month> <year> 1987). </year>
Reference-contexts: These types can be considered as container types, like container classes in an objectoriented paradigm. The list of the type inference rules used is given below. Most of the notation follows Cardelli's presentation of type rules for his subset of ML <ref> [Car87] </ref>. For type environments, the expression x: t is the binding of variable x to type t . If G is a type environment, then G .x: t is the same as G except x has type t . <p> Milner, of course, provides the basic type-checking algorithm, as well as the underlying notions of type-checking polymorphic functions. Milner's work is built upon the framework of Hindley [Hin69]. The paper by Cardelli <ref> [Car87] </ref> presents the basis for polymorphic type-checking, as well as provides some basic type-expressions and type-inference rules. The goal for the system implemented here is to have the same functionality as the system described in [Car87], as well as provide for ADTs and some exception-handling. <p> Milner's work is built upon the framework of Hindley [Hin69]. The paper by Cardelli <ref> [Car87] </ref> presents the basis for polymorphic type-checking, as well as provides some basic type-expressions and type-inference rules. The goal for the system implemented here is to have the same functionality as the system described in [Car87], as well as provide for ADTs and some exception-handling. However, unions of types have been simplified as noted in the section on datum.
Reference: [CR91] <editor> William Clinger and Jonathan Rees (eds.), </editor> <title> Revised 4 Report on the Algorithmic Language Scheme, </title> <year> 1991. </year>
Reference-contexts: Other concepts covered in later chapters of [SpF89] have received only sporadic coverage. For example, call-cc is included in the type system, yet withinput-from-file is not. Completing the coverage of [SpF89] and, eventually, all of Scheme, as defined in <ref> [CR91] </ref> would make this work more widely useful. These restrictions are made, both to simplify the type-checker, as well as to help simplify students' code. While these restrictions are not part of the Scheme language itself, we believe that students produce better code when obeying these restrictions. 2.2.
Reference: [CD80] <author> Mario Coppo, M. Dezani-Ciancaglini, and B. Venneri, </author> <title> Principal type schemes and lambda calculus semantics, in To H. </title> <editor> B. Currry: </editor> <booktitle> Essays on Combinatory Logic, Lambda Calculus, and Formalism, </booktitle> <pages> pp. 535-560, </pages> <address> New York, </address> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference-contexts: Procedures which have more than one type will be referred to as and-types within the rest of the paper. These are a form of intersection types as presented by <ref> [CD80] </ref>. To allow much of the power of Scheme without showing students very complex, if accurate, types, subtyping is used in a very restricted way. Two new types have been introduced: the type poof, and the type datum. <p> As noted in the previous section, however, his type system is too complicated for our needs. The work by Pierce [Pie91], Reynolds [Rey88], and Coppo, Dezani-Ciancaglini, and Venneri <ref> [CD80] </ref>, provide additional insight into and-types, even though they are only handled in a primitive fashion in this work. 5. FUTURE DIRECTIONS All of the syntactic features used to create the system are covered in the introductory programming course, except for a few functions on file handling.
Reference: [Cur90] <author> Pavel Curtis, </author> <title> Constrained Quantification in Polymorphic Type Analysis, </title> <note> Xerox PARC Technical Report CSL-90-1, </note> <month> February </month> <year> 1990. </year>
Reference-contexts: The major limitation is in the use of recursive types. 4.3. Related works In this section we attempt to place out type inference sytem in context with other type systems for Scheme, as well as other functional languages. We will take a brief look at PLEAT <ref> [Cur90] </ref>, STYLE [Lin93], Soft-Scheme [WrC93], and SPS [Wan89], with the emphasis in the section being on STYLE and Soft-Scheme. We will look at three main areas: domain of the type systems, representation of types, and complexity of code. The work of Curtis [Cur90] provides an example of a typesystem for a <p> We will take a brief look at PLEAT <ref> [Cur90] </ref>, STYLE [Lin93], Soft-Scheme [WrC93], and SPS [Wan89], with the emphasis in the section being on STYLE and Soft-Scheme. We will look at three main areas: domain of the type systems, representation of types, and complexity of code. The work of Curtis [Cur90] provides an example of a typesystem for a small, functional language, PLEAT, much in the style of Scheme. However, the types produced by the system are far too complex for beginning students to handle. <p> However, unions of types have been simplified as noted in the section on datum. Thus we have implemented Cardelli's ideas for polymorphic type inference in Scheme, and provided a simple, controlled use of subtyping, along with some facilities for creating and using higher-order types. Curtis <ref> [Cur90] </ref> introduces the use of quantified variables, and presents his version of a type-inference system for a language similar to Scheme called PLEAT. As noted in the previous section, however, his type system is too complicated for our needs.
Reference: [DH94] <author> Hsianlin Dzeng and Christopher T. Haynes, </author> <title> Type Reconstruction for Variable-Arity Procedures, </title> <note> 1994, to be published. </note>
Reference-contexts: However, students can use procedures that have variable arity as long as the procedures and their types are known to the type-inference program. Inferring types for procedures with variable arity could be handled as described in <ref> [DH94] </ref>. This restriction also implies that students cannot define procedures with rest parameters. Functions that are used for their side-effects must have return types of void; for example, the procedure foreach requires that its first argument be a procedure that returns void. <p> One direction this research should take in the future is the addition of a type-inferencing system for these procedures. The work of Dzeng and Haynes looks particularly interesting for this <ref> [DH94] </ref>. 3.4.5. ADTs A major innovation of this project is producing a type-checker that will handle ADTs. Such a type-checker should allow the creation of new types, and be able to type-check the new types, their creators, selectors and mutators, as well as any procedures built using these types. <p> These include the aforementioned procedures of variable arity, as well as define s using rest parameters. Even though these additions will be more complex than simply entering types in a type table, they do not seem to be unrealistic. Dzeng and Haynes <ref> [DH94] </ref> have described a system that will solve the first problem. It only remains to be seen how difficult implementing their ideas into our framework will be. Also, implementing rest parameters should not be difficult once the framework for handling procedures of variable arity is in place.
Reference: [Fa90] <author> M. Fagan, </author> <title> Soft Typing: An Approach to Type Checking for Dynamically Typed Languages, </title> <type> PhD thesis, </type> <institution> Rice University, </institution> <year> 1992. </year>
Reference-contexts: It does, however, have facilities for defining and using structures. These, however, are more suited for more advanced programmers, not students learning about ADTs. Its handling of recursive types and intersection types is based on the work of Fagan <ref> [Fa90] </ref> and is richer, yet more complicated, than ours. The implementation of Soft Scheme is available via ftp from the Scheme repository (ftp.cs.indiana.edu in pub/scheme-repository/imp).
Reference: [Hin69] <author> R. Hindley, </author> <title> The principal type scheme of an object in combinatory logic, </title> <journal> Transactions of the American Mathematical Society, </journal> <volume> Volume 146, </volume> <month> December </month> <year> 1969, </year> <pages> pp. 29-60. </pages>
Reference-contexts: Milner, of course, provides the basic type-checking algorithm, as well as the underlying notions of type-checking polymorphic functions. Milner's work is built upon the framework of Hindley <ref> [Hin69] </ref>. The paper by Cardelli [Car87] presents the basis for polymorphic type-checking, as well as provides some basic type-expressions and type-inference rules. The goal for the system implemented here is to have the same functionality as the system described in [Car87], as well as provide for ADTs and some exception-handling.
Reference: [Lin93] <author> Christian Lindig, </author> <title> STYLE: A Practical Type Checker for Scheme, </title> <publisher> Technische Universitt Braunschweig, Informatik-Bericht Nr. </publisher> <pages> 93-10, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: This aids students in understanding their own programs, as well as in understanding types. Other type-inference systems have been developed for Scheme; for example, STYLE <ref> [Lin93] </ref> and Soft Scheme [WrC93]. However, the complexity of the types output by these systems is often daunting for beginners. The facilities for building and using ADTs with these systems is also different from the approach used in the text used in CS227, Scheme and the Art of Programming [SpF89]. <p> The major limitation is in the use of recursive types. 4.3. Related works In this section we attempt to place out type inference sytem in context with other type systems for Scheme, as well as other functional languages. We will take a brief look at PLEAT [Cur90], STYLE <ref> [Lin93] </ref>, Soft-Scheme [WrC93], and SPS [Wan89], with the emphasis in the section being on STYLE and Soft-Scheme. We will look at three main areas: domain of the type systems, representation of types, and complexity of code. <p> Thus, while SPS does meet some of our goals, it is not a proper fit for our course. A type system that is very close to ours is Christian Lindig's STYLE <ref> [Lin93] </ref>. It offers a type system that operates over the entire specification of Scheme, as well as provides a solid type system. <p> For example, a version of member? , has type (A_nv (B_nv . C_nv) =&gt; bool) in Lindig's system, while it has type (-&gt; (T (list T)) boolean) in ours. Note that the comparison is made on the basis of the type given in <ref> [Lin93] </ref>, which does not provide the source for member? ; it is assumed that the implementation is something resembling: (define member? (lambda (item ls) (cond ((null? ls) #f) ((equal? item (car ls)) #t) (else (member? item (cdr ls)))))) In his paper, Lindig provides some results from type-checking code from [AbS85], and
Reference: [Mil78] <author> Robin Milner, </author> <title> A Theory of Type Polymorphism in Programming, </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 (1978), </volume> <pages> 348-375. </pages>
Reference-contexts: This permits the handler for begin in the type inference algorithm to check for each intermediate expression returning a void type. 3.2. Type-Inference As stated earlier, the algorithm used here is essentially the j algorithm from Milner's original paper on type inference <ref> [Mil78] </ref>. Given an expression, f, and an initially empty environment, p, type variables are instantiated for procedures and variables of unknown types. Then, once all variables are instantiated, unification is used to propogate constraints. If no solution to the set of constraints can be found, an error is signalled. <p> For example, + is given the type ( D (number number number) number) when it is called as in (+ 3 4 5) . Once this has all been done, the bindings created by unification as in <ref> [Mil78] </ref> are all applied and, if no set of possible bindings exists, an error message is returned. If a possible set of bindings exists, then it is applied and the type is returned. 3.3. Re-sugaring Once the type has been found, it is displayed (not returned) to the user.
Reference: [Pie91] <author> Benjamin C. Pierce, </author> <title> Programming With Intersection Types, Union Types, and Polymorphism, </title> <type> CMU-CS-91-106, </type> <year> 1991. </year>
Reference-contexts: Curtis [Cur90] introduces the use of quantified variables, and presents his version of a type-inference system for a language similar to Scheme called PLEAT. As noted in the previous section, however, his type system is too complicated for our needs. The work by Pierce <ref> [Pie91] </ref>, Reynolds [Rey88], and Coppo, Dezani-Ciancaglini, and Venneri [CD80], provide additional insight into and-types, even though they are only handled in a primitive fashion in this work. 5.
Reference: [Rey88] <author> John Reynolds, </author> <title> Preliminary design of the programming language Forsythe, </title> <type> Technical Report CMU-CS-88-159, </type> <institution> Carnegie Mellon University, </institution> <month> June </month> <year> 1988. </year>
Reference-contexts: Curtis [Cur90] introduces the use of quantified variables, and presents his version of a type-inference system for a language similar to Scheme called PLEAT. As noted in the previous section, however, his type system is too complicated for our needs. The work by Pierce [Pie91], Reynolds <ref> [Rey88] </ref>, and Coppo, Dezani-Ciancaglini, and Venneri [CD80], provide additional insight into and-types, even though they are only handled in a primitive fashion in this work. 5.
Reference: [SpF89] <author> George Springer and Daniel P. Friedman, </author> <title> Scheme and the Art of Programming, </title> <publisher> MIT Press and McGraw-Hill, </publisher> <year> 1989. </year>
Reference-contexts: However, the complexity of the types output by these systems is often daunting for beginners. The facilities for building and using ADTs with these systems is also different from the approach used in the text used in CS227, Scheme and the Art of Programming <ref> [SpF89] </ref>. Thus, another goal is to aid students in understanding and using Abstract Data Types (ADTs). By using the type-checker, they can see if their code makes proper use of an ADT's selectors, constructors, and mutators. This is perhaps the most important use of the type-checker. 1.2. <p> The motivation for this is that the text for the class, Scheme and the Art of Programming <ref> [SpF89] </ref> does not use nested define s in the first thirteen chapters, which is the portion of the text normally covered in CS227. In general, the syntax accepted by the type-checker is the subset of Scheme covered in the first thirteen chapters of [SpF89]; however, some extensions have been made to <p> class, Scheme and the Art of Programming <ref> [SpF89] </ref> does not use nested define s in the first thirteen chapters, which is the portion of the text normally covered in CS227. In general, the syntax accepted by the type-checker is the subset of Scheme covered in the first thirteen chapters of [SpF89]; however, some extensions have been made to increase the usefulness of the program. For example, define declarations can be of the form (define name (lambda (arg1 ...) body)) , and of the form (define (name arg1 ...) body) . <p> This is not a great restriction to students as file I/O is beyond the scope of the introductory course, and in the first release of the code, types will be provided in the system. Other concepts covered in later chapters of <ref> [SpF89] </ref> have received only sporadic coverage. For example, call-cc is included in the type system, yet withinput-from-file is not. Completing the coverage of [SpF89] and, eventually, all of Scheme, as defined in [CR91] would make this work more widely useful. <p> Other concepts covered in later chapters of <ref> [SpF89] </ref> have received only sporadic coverage. For example, call-cc is included in the type system, yet withinput-from-file is not. Completing the coverage of [SpF89] and, eventually, all of Scheme, as defined in [CR91] would make this work more widely useful. These restrictions are made, both to simplify the type-checker, as well as to help simplify students' code. <p> To see how these goals have been achieved, we will look at the ADT ratl, i.e., rationals. This is the first ADT students in the CS227 encounter in Scheme and the Art of Programming <ref> [SpF89] </ref>. The implementation for the constructors and selectors are shown below. <p> The results shown below were generated by running type-check-file over each of the files, with the three modifications mentioned: renaming of procedures, removal of procedures with variable arity, and inclusion of helping procedures. The code from the first ten chapters of <ref> [SpF89] </ref> have been checked, as well as sample student code from exercises. Code from other sources was also examined. In particular, code from the first chapter of [AbS85] was examined. <p> Most problems occurred with recursive types, such as trees, or with make-vector , which will be discussed in detail later. Chapter 2 of <ref> [SpF89] </ref> produced 4 errors: three of these were problems with procedures taking advantage of Scheme's using any non#f value to mean true. The only other problem was with a procedure that performed ad hoc polymorphism, and, thus, is beyond the scope of our system. <p> (lambda (gen-proc) (lambda (size) (let ((vec (make-vector size))) (letrec ((loop (lambda (i) (if (&lt; i size) (begin (vector-set! vec i (gen-proc i)) (loop (add1 i)))))) (loop 0)) vec)))) The student's code consisted of 16 procedures (all correct Scheme code) that were solutions to exercises from the first ten chapters of <ref> [SpF89] </ref>. The problems here, as mentioned above, were primarily with vector-generator and procedures that take a variable number of arguments. The code from the first chapter of [AbS85] was the most successfully typed code set. <p> This system is very poweful, and has been shown to perform very well. For our purposes, there are only two problems with the system: it is too complex for students to comprehend the implementation, and it doesn't handle ADTs in the same manner that <ref> [SpF89] </ref> does. It does, however, have facilities for defining and using structures. These, however, are more suited for more advanced programmers, not students learning about ADTs. Its handling of recursive types and intersection types is based on the work of Fagan [Fa90] and is richer, yet more complicated, than ours.
Reference: [Wa89] <author> Mitchell Wand, </author> <title> Semantic Prototyping System (SPS) Reference Manual, Version 1.4 (Chez Scheme), </title> <institution> Northeastern University, </institution> <year> 1989. </year>
Reference: [WrC93] <author> Andrew K. Wright and Robert Cartwright, </author> <title> A Practical Soft Type System for Scheme, </title> <institution> Rice University Technical Report, TR93-218, </institution> <month> December 6, </month> <year> 1993. </year> <month> 25 </month>
Reference-contexts: This aids students in understanding their own programs, as well as in understanding types. Other type-inference systems have been developed for Scheme; for example, STYLE [Lin93] and Soft Scheme <ref> [WrC93] </ref>. However, the complexity of the types output by these systems is often daunting for beginners. The facilities for building and using ADTs with these systems is also different from the approach used in the text used in CS227, Scheme and the Art of Programming [SpF89]. <p> Related works In this section we attempt to place out type inference sytem in context with other type systems for Scheme, as well as other functional languages. We will take a brief look at PLEAT [Cur90], STYLE [Lin93], Soft-Scheme <ref> [WrC93] </ref>, and SPS [Wan89], with the emphasis in the section being on STYLE and Soft-Scheme. We will look at three main areas: domain of the type systems, representation of types, and complexity of code. <p> However, since we have been unable to obtain a copy, we cannot make any accurate comparisons of our two systems at this time. The last system examined is Wright's and Cartwright's Soft Scheme <ref> [WrC93] </ref>. Soft Scheme infers types, and, instead of producing error messages on untypable expressions, inserts runtime checks. The system covers all of R4RS Scheme and produces readable, usable types. This system is very poweful, and has been shown to perform very well.
References-found: 15

