URL: ftp://ftp.cs.man.ac.uk/pub/TR/UMCS-89-12-1.ps.Z
Refering-URL: http://www.cs.man.ac.uk/cstechrep/Abstracts/UMCS-89-12-1.html
Root-URL: http://www.cs.man.ac.uk
Title: KEY CENTRE FOR SOFTWARE TECHNOLOGY  Specifications are not (necessarily) executable  
Author: I. J. Hayes and C. B. Jones 
Date: 148  January, 1990  
Address: Australia 4072  
Affiliation: DEPARTMENT OF COMPUTER SCIENCE UNIVERSITY OF QUEENSLAND St. Lucia Queensland  
Pubnum: TECHNICAL REPORT No.  
Abstract-found: 0
Intro-found: 1
Reference: [BJ82] <author> D. Bjorner and C. B. Jones. </author> <title> Formal Specification and Software Development. </title> <publisher> Prentice Hall International, </publisher> <year> 1982. </year>
Reference-contexts: A subtle example of the use of non-determinism occurs in giving the semantics of programming languages. The goal is to leave the implementor free to allocate storage addresses to variables. Thus, a language description should not dictate a particular stack implementation for Pascal. In, for example, <ref> [BJ82] </ref> the choice of locations (Loc) is under-determined for precisely this reason. This example manifests the problem of something being essentially non-deterministic at the level of abstraction of the specification in spite of its being deterministic in terms of the representation chosen for an implementation.
Reference: [C + 86] <author> R. L. Constable et al. </author> <title> Implementing Mathematics with the NuPRL Proof Development System. </title> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference-contexts: There are three more-or-less distinct ways in which software design can be based on a formal specification: the "transformational" approach (e.g., [CIP85, CIP87]), the "constructive mathematics" approach (e.g., <ref> [C + 86] </ref>), and those methods where designs are posited and then justified at each development step. The arguments presented in this paper apply to all of these approaches, however, this presentation focuses on the third posit and prove approach.
Reference: [CIP85] <author> CIP Language Group. </author> <title> The Munich Project CIP|Volume I: The Wide Spectrum Language CIP-L, </title> <booktitle> volume 183 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: There are three more-or-less distinct ways in which software design can be based on a formal specification: the "transformational" approach (e.g., <ref> [CIP85, CIP87] </ref>), the "constructive mathematics" approach (e.g., [C + 86]), and those methods where designs are posited and then justified at each development step. The arguments presented in this paper apply to all of these approaches, however, this presentation focuses on the third posit and prove approach. <p> The resulting destruction of the clarity of the "specification" would lose what the current authors believe is the principal benefit of the construction of a formal specification: its ability to make the essential concepts of the specified system clear. A wide-spectrum language <ref> [CIP85, CIP87] </ref> is one which includes facilities for specification as well as an executable subset. This approach has advantages for program refinement as a single notation can be used throughout the development process.
Reference: [CIP87] <author> CIP System Group. </author> <title> The Munich Project CIP|Volume II: The Program Transformation System CIP-S, </title> <booktitle> volume 292 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: There are three more-or-less distinct ways in which software design can be based on a formal specification: the "transformational" approach (e.g., <ref> [CIP85, CIP87] </ref>), the "constructive mathematics" approach (e.g., [C + 86]), and those methods where designs are posited and then justified at each development step. The arguments presented in this paper apply to all of these approaches, however, this presentation focuses on the third posit and prove approach. <p> The resulting destruction of the clarity of the "specification" would lose what the current authors believe is the principal benefit of the construction of a formal specification: its ability to make the essential concepts of the specified system clear. A wide-spectrum language <ref> [CIP85, CIP87] </ref> is one which includes facilities for specification as well as an executable subset. This approach has advantages for program refinement as a single notation can be used throughout the development process.
Reference: [Dij75] <author> E. W. Dijkstra. </author> <title> Guarded commands, nondeterminacy and formal derivation of programs. </title> <journal> Communications of ACM, </journal> <volume> 18(8) </volume> <pages> 453-457, </pages> <month> August </month> <year> 1975. </year>
Reference-contexts: If the programming language is deterministic then any implementation should return the same result. If the language is not deterministic for example, Dijkstra's guarded command language <ref> [Dij76, Dij75] </ref> or languages with concurrency constructs 20 then that output may be one of a number of possible outputs for that input, but it is not necessarily the output that will be produced by another implementation or even a second run on the same implementation.
Reference: [Dij76] <author> E. W. Dijkstra. </author> <title> A Discipline of Programming. </title> <publisher> Prentice-Hall, </publisher> <year> 1976. </year>
Reference-contexts: as simple as above; and one is required to reason about the problem (preferably in the mathematical system associated with the application area) in order to determine such properties before one can attempt execution. 2.6 Non-Computable Clauses in Specifications The problem of calculating the so-called Hamming numbers is found in <ref> [Dij76] </ref>. The Hamming numbers are those whose only prime factors are 2, 3, and 5. The problem is to generate the sequence of Hamming numbers in increasing order. <p> If the programming language is deterministic then any implementation should return the same result. If the language is not deterministic for example, Dijkstra's guarded command language <ref> [Dij76, Dij75] </ref> or languages with concurrency constructs 20 then that output may be one of a number of possible outputs for that input, but it is not necessarily the output that will be produced by another implementation or even a second run on the same implementation.
Reference: [FSS83] <author> S.M. Freudenberger, J.T. Schwartz, and M. Sharir. </author> <title> Experience with the SETL optimizer. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(1) </volume> <pages> 26-45, </pages> <month> January </month> <year> 1983. </year>
Reference-contexts: swap two values may be specified thus: i ; j : = j ; i : (This also has the virtue that it solves the so-called frame problem by making it clear that no variables other than i and j are to be changed.) A very high-level language (e.g., SETL <ref> [FSS83] </ref>) expands the range of problems that can be succinctly specified by providing a richer set of available functions that can be used. A powerful technique is the use of functions that are available for objects which are more abstract than those of the final implementation language.
Reference: [Hay87] <author> I. J. Hayes, </author> <title> editor. Specification Case Studies. </title> <booktitle> Prentice-Hall International, </booktitle> <year> 1987. </year>
Reference-contexts: Another point about is-permutation is the way it is made concise by shifting between data types (here, sequences to sets). This technique can be useful in a range of specifications. Even where a specification does not explicitly use a conjunction, the technique may be used implicitly. In both Z <ref> [Hay87, Spi89] </ref> and VDM [Jon86], data type invariants are considered to be conjoined to other properties over types using them.
Reference: [Hen82] <author> P. Henderson. </author> <title> Purely functional operating systems. </title> <editor> In J. Darlington, P. Henderson, and D. A. Turner, editors, </editor> <booktitle> Functional Programming and its Applications, </booktitle> <pages> pages 177-192. </pages> <publisher> Cambridge University Press, </publisher> <year> 1982. </year>
Reference-contexts: An implementation can be considered deterministically at the level where we know about the time at which the commands arrive from the terminals, but at the abstract level (where we hide information about arrival times) non-deterministic behaviour is apparent. See <ref> [Hen82, especially page 190] </ref> for a discussion of this with respect to purely functional operating systems. A subtle example of the use of non-determinism occurs in giving the semantics of programming languages. The goal is to leave the implementor free to allocate storage addresses to variables.
Reference: [Hen86] <author> P. Henderson. </author> <title> Functional programming, formal specification, and rapid prototyping. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-12(2):241-250, </volume> <month> February </month> <year> 1986. </year>
Reference-contexts: Both functional and logic-programming have been suggested as possible bases for executable specifications <ref> [Hen86, Kow85] </ref>.
Reference: [Jon80] <author> C. B. Jones. </author> <title> Software Development: A Rigorous Approach. </title> <publisher> Prentice Hall International, </publisher> <year> 1980. </year> <month> 23 </month>
Reference-contexts: It is, for example, convenient (see <ref> [Jon80] </ref>) to express the task of constructing a parse tree by stating inter alia that collecting the terminal strings from the wanted tree should yield the string given as input. There is, in general, no way of executing such an inverse specification.
Reference: [Jon86] <author> C. B. Jones. </author> <title> Systematic Software Development Using VDM. </title> <publisher> Pren--tice Hall International, </publisher> <year> 1986. </year>
Reference-contexts: This technique can be useful in a range of specifications. Even where a specification does not explicitly use a conjunction, the technique may be used implicitly. In both Z [Hay87, Spi89] and VDM <ref> [Jon86] </ref>, data type invariants are considered to be conjoined to other properties over types using them.
Reference: [Jon87] <author> C. B. Jones. </author> <title> Program specification and verification in VDM. </title> <editor> In M. Broy, editor, </editor> <booktitle> Logic of Programming and Calculi of Discrete Design | NATO ASI Series F: Computer and Systems Sciences, </booktitle> <volume> Vol. 36, </volume> <pages> pages 149-184. </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: This raises the question of the semantics which can be used, for example, to verify proof rules in the presence of "true non-determinacy". This subject is pursued in <ref> [Jon87] </ref> and [Nip86]. 4 Other Issues 4.1 Specification Variables In the specifications that we have given up to this point the specification variables have stood for the values of program variables (or abstractions thereof).
Reference: [JS90] <editor> C. B. Jones and R. C. F. Shaw, editors. </editor> <title> Case Studies in Systematic Software Development. </title> <publisher> Prentice Hall International, </publisher> <year> 1990. </year>
Reference-contexts: In both Z [Hay87, Spi89] and VDM [Jon86], data type invariants are considered to be conjoined to other properties over types using them. An example of the use of conjunction in a non-trivial specification appears in work on unification: see chapters by Fitzgerald and Vadera in <ref> [JS90] </ref>. 7 2.4 Negation in Specifications Specifications can be built up using any expressions of predicate calculus. But, just as conjunction provides a particularly powerful extension to notions of executable languages, negation is also worthy of special mention.
Reference: [Kne89] <author> R. Kneuper. </author> <title> Symbolic Execution as a Tool for Validation of Specifications. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Manchester, </institution> <year> 1989. </year>
Reference-contexts: One approach that has been advocated is to use an executable specification and perform the validation by a series of tests on the specification. (A full discussion of notions of executability and specification can be found in <ref> [Kne89] </ref> which studies the use of symbolic execution for validating specifications.) Although considering individual test cases is useful, it is not as powerful as proving general properties about a specification. Requiring a specification notation to be directly executable restricts the forms of specification that can be used.
Reference: [Kow85] <author> R. Kowalski. </author> <title> The relation between logic programming and logic specification. </title> <editor> In C. A. R. Hoare and J. C. Shepherdson, editors, </editor> <booktitle> Mathematical Logic and Programming Languages, </booktitle> <pages> pages 11-27. </pages> <publisher> Prentice Hall, </publisher> <year> 1985. </year>
Reference-contexts: Both functional and logic-programming have been suggested as possible bases for executable specifications <ref> [Hen86, Kow85] </ref>.
Reference: [Mar85] <author> L. S. Marshall. </author> <title> A formal specification of straight lines on graphics devices. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> 186 </volume> <pages> 129-147, </pages> <month> March </month> <year> 1985. </year>
Reference-contexts: Any description of diff that can be executed will contain considerably more detail about how to go about computing the differences. A particularly interesting specification which embodies such external non-determinism is given in <ref> [Mar85] </ref>. One of the tasks considered is the constraints which must be put on the representation of lines on a raster display.
Reference: [Nip86] <author> T. Nipkow. </author> <title> Non-deterministic data types: Models and implementations. </title> <journal> Acta Informatica, </journal> <volume> 22 </volume> <pages> 629-661, </pages> <year> 1986. </year>
Reference-contexts: This raises the question of the semantics which can be used, for example, to verify proof rules in the presence of "true non-determinacy". This subject is pursued in [Jon87] and <ref> [Nip86] </ref>. 4 Other Issues 4.1 Specification Variables In the specifications that we have given up to this point the specification variables have stood for the values of program variables (or abstractions thereof). However, it is useful to use specification variables that one would never think of implementing as program variables.
Reference: [Spi89] <author> J. M. Spivey. </author> <title> The Z Notation: A Reference Manual. </title> <publisher> Prentice Hall International, </publisher> <year> 1989. </year>
Reference-contexts: Another point about is-permutation is the way it is made concise by shifting between data types (here, sequences to sets). This technique can be useful in a range of specifications. Even where a specification does not explicitly use a conjunction, the technique may be used implicitly. In both Z <ref> [Hay87, Spi89] </ref> and VDM [Jon86], data type invariants are considered to be conjoined to other properties over types using them.
Reference: [Tur85] <author> D. A. Turner. </author> <title> Functional programs as executable specifications. </title> <editor> In C. A. R. Hoare and J. C. Shepherdson, editors, </editor> <booktitle> Mathematical Logic and Programming Languages, </booktitle> <pages> pages 29-54. </pages> <publisher> Prentice-Hall, </publisher> <year> 1985. </year> <month> 24 </month>
Reference-contexts: However, by adding the condition that only the first 100 items are required, an implementation of the whole specification becomes possible. In the paper entitled "Functional programs as executable specifications", Turner <ref> [Tur85, pages 43-44] </ref> makes use of the following non-executable specification for the problem of computing the Hamming numbers (given in Turner's notation): ham = SORT f2 a fi 3 b fi 5 c j a; b; c [0::]g 10 where the notation in braces generates a sequence with no duplicates contain-ing <p> The above argues that considering a specification as determining a set of possible (deterministic) functions is too restrictive. An approach that avoids this restriction while still using functions is to use a function that returns a set of possible results (see, for example <ref> [Tur85, page 31] </ref>). In fact, for our purposes this is theoretically equivalent to using a relational approach; however, a function returning a set is more complicated to deal with in practice.
References-found: 20

