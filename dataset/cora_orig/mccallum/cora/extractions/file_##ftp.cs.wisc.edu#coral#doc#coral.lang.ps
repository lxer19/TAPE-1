URL: file://ftp.cs.wisc.edu/coral/doc/coral.lang.ps
Refering-URL: http://www.cs.wisc.edu/coral/coral.papers.html
Root-URL: 
Title: CORAL|Control, Relations and Logic  
Author: Raghu Ramakrishnan Divesh Srivastava S. Sudarshan 
Date: 1992  
Note: Proceedings of the 18th VLDB Conference  
Address: WI 53706, U.S.A.  Canada  
Affiliation: Computer Sciences Department, University of Wisconsin-Madison,  Vancouver, British Columbia,  
Abstract: CORAL is a modular declarative query language/programming language that supports general Horn clauses with complex terms, set-grouping, aggregation, negation, and relations with tuples that contain (universally quantified) variables. Support for persistent relations is provided by using the EXODUS storage manager. A unique feature of CORAL is that it provides a wide range of evaluation strategies and allows users to | optionally | tailor execution of a program through high-level annotations. A CORAL program is organized as a collection of modules, and this structure is used as the basis for expressing control choices. CORAL has an interface to C++, and uses the class structure of C++ to provide extensibility. Finally, CORAL supports a command sublanguage, in which statements are evaluated in a user-specified order. The statements can be queries, updates, production-system style rules, or any command that can be typed in at the CORAL system prompt. fl This work was supported by a David and Lucile Packard Foundation Fellowship in Science and Engineering, a Presidential Young Investigator Award, with matching grants from Digital Equipment Corporation, Tandem and Xerox, and NSF grant IRI-9011563. An earlier version of this paper appeared at the NACLP '90 Workshop on Deductive Databases. The authors' e-mail addresses are fraghu,divesh,sudarshang@cs.wisc.edu. Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct commercial advantage, the VLDB copyright notice and the title of the publication and its date appear, and notice is given that copying is by permission of the Very Large Data Base Endowment. To copy otherwise, or to republish, requires a fee and/or special permission from the Endowment. 
Abstract-found: 1
Intro-found: 1
Reference: [BNST91] <author> Catriel Beeri, Shamim Naqvi, Oded Shmueli, and Shalom Tsur. </author> <title> Set constructors in a logic database language. </title> <journal> The Journal of Logic Programming, </journal> <pages> pages 181-232, </pages> <year> 1991. </year>
Reference-contexts: In this we follow LDL, whose treatment of the universe is an extension of the Herbrand universe that is used as a standard in logic programming. The extended Herbrand universe is described in <ref> [BNST91] </ref>. There are two ways in which sets and multisets can be created using rules, namely, set-enumeration (f g) and set-grouping (&lt;&gt;) as in LDL. However, the operations CORAL permits on sets are different from those supported by LDL, and we discuss the differences later.
Reference: [CDRS86] <author> Michael Carey, David DeWitt, Joel Richardson, and Eugene Shekita. </author> <title> Object and file management in the EXODUS extensible database system. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <month> August </month> <year> 1986. </year>
Reference-contexts: The current prototype of CORAL is optimized primarily for main-memory execution, but is interfaced with the EXODUS storage manager <ref> [CDRS86] </ref> to provide transparent (and quite efficient) access to data that is stored on disk. The CORAL system is in the public domain, and a copy of the software can be obtained by contacting the authors. The rest of this paper is organized as follows.
Reference: [CGK + 90] <author> D. Chimenti, R. Gamboa, R. Krishna--murthy, S. Naqvi, S. Tsur, and C. Zaniolo. </author> <title> The LDL system prototype. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(1) </volume> <pages> 76-90, </pages> <year> 1990. </year>
Reference: [GPSZ91] <author> Fosca Giannotti, Dino Pedreschi, Domenico Sacca, and Carlo Zaniolo. </author> <title> Non-determinism in deductive databases. </title> <editor> In C. Delobel, M. Kifer, and Y. Masunaga, editors, </editor> <booktitle> Proceedings of the Second International Conference on Deductive and Object-Oriented Databases DOOD'91, </booktitle> <address> Mu-nich, Germany, 1991. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: We believe this semantics can be implemented more efficiently in a bottom-up evaluation than the LDL semantics. Giannotti et al. <ref> [GPSZ91] </ref> have investigated the connections between this "local" version of choice and stable models, and Greco et al. [GZG92] have shown that it is useful in a variety of "greedy" algorithms. Aggregate Selections: Consider the shortest path program from Figure 2.
Reference: [GZG92] <author> Sergio Greco, Carlo Zaniolo, and Sumit Gan-guly. </author> <title> Greedy by choice. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <year> 1992. </year>
Reference-contexts: We believe this semantics can be implemented more efficiently in a bottom-up evaluation than the LDL semantics. Giannotti et al. [GPSZ91] have investigated the connections between this "local" version of choice and stable models, and Greco et al. <ref> [GZG92] </ref> have shown that it is useful in a variety of "greedy" algorithms. Aggregate Selections: Consider the shortest path program from Figure 2.
Reference: [JMSY90] <author> J. Jaffar, S. Michaylov, P. Stuckey, and R. Yap. </author> <title> The CLP(R) language and system. </title> <type> Technical report, </type> <institution> IBM, T. J. Watson Research Center, </institution> <year> 1990. </year>
Reference-contexts: This facility is useful in itself (for example, it allows the use of non-ground data structures like difference-lists and the use of variables to denote some incomplete information), and is essential for future extensions of the system to deal with "constraint facts," in a manner similar to CLP (R) <ref> [JMSY90] </ref>. The language used for imperative modules is currently C++ extended with several new types and constructs. Predicates defined in other modules can be queried from the imperative module; conversely, predicates defined in the imperative module can be used in other modules.
Reference: [KdMS90] <author> G. Kiernan, C. de Maindreville, and E. Si-mon. </author> <title> Making deductive database a practical technology: a step forward. </title> <booktitle> In Proceedings of the ACM SIGMOD Conf. on Management of Data, </booktitle> <year> 1990. </year>
Reference-contexts: Modules with run-time semantics are also available in several production rule systems (for example, RDL1 <ref> [KdMS90] </ref>). 9 Future Directions A number of issues require further work.
Reference: [MPR90] <author> Inderpal S. Mumick, Hamid Pirahesh, and Raghu Ramakrishnan. </author> <title> Duplicates and aggregates in deductive databases. </title> <booktitle> In Proceedings of the Sixteenth International Conference on Very Large Databases, </booktitle> <month> August </month> <year> 1990. </year>
Reference: [MUVG86] <author> Katherine Morris, Jeffrey D. Ullman, and Allen Van Gelder. </author> <title> Design overview of the NAIL! system. </title> <booktitle> In Proceedings of the Third International Conference on Logic Programming, </booktitle> <year> 1986. </year>
Reference: [NT89] <author> Shamim Naqvi and Shalom Tsur. </author> <title> A Logical Language for Data and Knowledge Bases. </title> <booktitle> Principles of Computer Science. </booktitle> <publisher> Computer Science Press, </publisher> <address> New York, </address> <year> 1989. </year>
Reference: [PDR91] <author> Geoffrey Phipps, Marcia A. Derr, and Ken-neth A. Ross. </author> <title> Glue-NAIL!: A deductive database system. </title> <booktitle> In Proceedings of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 308-317, </pages> <year> 1991. </year>
Reference: [RBSS90] <author> Raghu Ramakrishnan, Per Bothner, Di-vesh Srivastava, and S. Sudarshan. </author> <title> CORAL: A database programming language. </title> <editor> In Jan Chomicki, editor, </editor> <booktitle> Proceedings of the NACLP `90 Workshop on Deductive Databases, </booktitle> <month> Octo-ber </month> <year> 1990. </year> <note> Available as Report TR-CS-90-14, </note> <institution> Department of Computing and Information Sciences, Kansas State University. </institution>
Reference-contexts: Modules can be compiled separately. The declarative features of CORAL, which define the sublanguage permitted in declarative modules, 1 The CORAL project was initiated in 88-89 | under the name Conlog | and an initial overview was presented in <ref> [RBSS90] </ref>. 1 provide a powerful language that can be used to write complex view definitions or as a general purpose DBPL. CORAL supports tuples with variables (non-ground terms). While Prolog systems and some production rule systems support non-ground terms, none of the deductive database systems do so. <p> The user is allowed to specify additional indices, which is particularly useful if the Magic Templates rewriting stage is bypassed. The Choice Operator: CORAL provides a version of the choice operator of LDL, but with altogether different semantics <ref> [RBSS90] </ref>. The following example illustrates the use of choice in CORAL.
Reference: [Ros90] <author> Kenneth Ross. </author> <title> Modular Stratification and Magic Sets for DATALOG programs with negation. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 161-171, </pages> <year> 1990. </year>
Reference-contexts: Intuitively, a modularly stratified program is such that in the answers and subgoals generated for the program, there should be no cycles through negation. The following example from <ref> [Ros90] </ref> illustrates the use of modularly stratified negation in a program. Suppose we have a complex mechanism constructed out of a number of components that may themselves be constructed from smaller components. Let the component-of relationship be expressed in the relation part.
Reference: [RSS92a] <author> Raghu Ramakrishnan, Divesh Srivastava, and S. Sudarshan. </author> <title> Controlling the search in bottom-up evaluation. </title> <type> Manuscript, </type> <note> submitted for publication, </note> <year> 1992. </year>
Reference-contexts: However, the part relation is acyclic, and hence the working status of a component is defined negatively in terms of subcomponents, but not negatively in terms of itself. CORAL provides an evaluation mechanism called Ordered Search <ref> [RSS92a] </ref> that evaluates programs with left-to-right modularly stratified negation efficiently. 2.3 Creating Sets and Multisets Sets and multisets are allowed as values in CORAL; f1; 2; 3; f (a; b); ag is an example of a set, f1; f (a); f (a)g is an example of a multiset.
Reference: [RSS92b] <author> Raghu Ramakrishnan, Divesh Srivastava, and S. Sudarshan. </author> <title> Efficient bottom-up evaluation of logic programs. </title> <editor> In J. Vandewalle, editor, </editor> <booktitle> The State of the Art in Computer Systems and Software Engineering. </booktitle> <publisher> Kluwer Academic Publishers, </publisher> <year> 1992. </year>
Reference-contexts: This orthogonality permits the free mixing of different evaluation techniques in different modules in CORAL and is central to how different executions in different modules are combined cleanly. CORAL provides several rewriting transformations such as Magic Templates, Supplementary Magic Templates, Context Factoring, Existential Query Rewriting, etc. (see, e.g., <ref> [RSS92b] </ref>). By default, CORAL chooses a combination of rewriting transformations. However, other combinations might work better for some queries, and the expert user can choose an appropriate combination using annotations.
Reference: [SR91] <author> S. Sudarshan and Raghu Ramakrishnan. </author> <title> Aggregation and relevance in deductive databases. </title> <booktitle> In Proceedings of the Seventeenth International Conference on Very Large Databases, </booktitle> <month> Septem-ber </month> <year> 1991. </year>
Reference-contexts: (described in Section 3.1) reduces the cost of evaluation of a single source shortest path problem from a worst case of O (E V ) to O (E log (V )) 5 (<ref> [SR91] </ref>). This illustrates the importance of aggregate selections and prioritizing the use of facts in a bottom-up evaluation. [SR91] describes a technique to generate such aggregate selections automatically, but aggregate selections could also be specified by the user. 3.3 Rule Level Control Join Orders: CORAL uses a default left to right join order in the absence of information about relation sizes, except that for semi-naive rewritten rules the "delta"
Reference: [STZ92] <author> Oded Shmueli, Shalom Tsur, and Carlo Zan-iolo. </author> <title> Compilation of set terms in the logic data language (LDL). </title> <journal> Journal of Logic Programming, </journal> 12(1&2):89-120, 1992. 
Reference-contexts: An ok team tuple additionally must contain an engineer, a pilot and a doctor. Note that a team containing a single member who is an engineer, a pilot and a doctor would qualify as an ok team. This program is a translation into CORAL of an LDL program from <ref> [STZ92] </ref>; the semantics of the original LDL program required that a team contain at most three members.
Reference: [VBKL90] <author> L. Vieille, P. Bayer, V. Kuchenhoff, and A. Lefebvre. EKS-V1, </author> <title> a short overview. </title> <booktitle> In AAAI-90 Workshop on Knowledge Base Management Systems, </booktitle> <year> 1990. </year>
Reference: [VRK + 90] <author> Jayen Vaghani, Kotagiri Ramamohanarao, David Kemp, Zoltan Somogyi, and Peter Stuckey. </author> <title> The Aditi deductive database system. </title> <booktitle> In Proceedings of the NACLP'90 Workshop on Deductive Database Systems, </booktitle> <year> 1990. </year>
References-found: 19

