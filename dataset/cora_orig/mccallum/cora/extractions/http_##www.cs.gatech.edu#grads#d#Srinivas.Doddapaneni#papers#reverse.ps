URL: http://www.cs.gatech.edu/grads/d/Srinivas.Doddapaneni/papers/reverse.ps
Refering-URL: http://www.cs.gatech.edu/grads/d/Srinivas.Doddapaneni/pubs.html
Root-URL: 
Title: The Transition of Application Programs From COBOL to a Fourth Generation Language  
Author: Spencer Rugaber Srinivas Doddapaneni 
Address: Atlanta, GA 30332  
Affiliation: College of Computing Georgia Institute of Technology  
Abstract: It is becoming increasingly desirable to move older application programs from their traditional mainframe execution environments to networked workstations. These management information systems are most often written in COBOL and store their data in files. A networked environment enables the use of a relational database management system and its fourth generation access language, SQL. A conceptual framework is described that comprises a variety of strategies for making such a transition. Decision criteria for selecting among them are then presented. Finally, a variety of experiments intended to explore the strategies are recounted. The experiments include efforts to automate parts of the process. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Automated Data Systems Manual, </author> <title> Installation Materiel Condition Status Reporting System (IMCSRS), Functional User's Manual, </title> <address> Commander FORSCOM, AFLG-RO, Ft. McPherson, Georgia, </address> <month> April 1, </month> <year> 1984. </year>
Reference: [2] <author> Carlo Batini, Stefano Ceri, and Shamkant B. Na-vathe, </author> <title> Conceptual Database Design | An Entity-Relationship Approach, </title> <publisher> Benjamin Cummings, </publisher> <year> 1992. </year>
Reference-contexts: In particular, an explicit reverse engineering step is required in which a representation of the program's data processing requirements is constructed. Such a procedure targeted specifically at information systems is described in Batini's book <ref> [2] </ref>. Another approach, aimed somewhat more at the functional requirements than at data modeling is described in [13]. The converted program is responsible for generating a report on equipment availability. <p> The program visualization provided by this approach is limited in several ways. First, STP provides no mechanism for refining an ER diagram into lower level diagrams. This is not a fundamental limitation. The Batini book <ref> [2] </ref>, for example, describes several ways in which complex diagrams can be abstracted. The second limitation has to do with relationships. An ER diagram consists of entities and relationships. In our case, the entities correspond to files, and they can be automatically extracted using the procedure described above.
Reference: [3] <author> Barry W. Boehm, </author> <title> Software Engineering Economics, </title> <publisher> Prentice Hall, </publisher> <year> 1981. </year>
Reference-contexts: The largest cost factor in software development is maintaining existing programs after they are delivered. Up to 75% of life cycle cost may be expended on such maintenance. Moreover, maintenance costs are directly related to the amount of code being maintained <ref> [3] </ref>. In section 3.4 we show that a 4GL program can be significantly smaller than the corresponding COBOL program. Hence, it should be much less expensive to maintain. * Simplified use.
Reference: [4] <author> P. P. Chen, </author> <title> "The Entity-Relationship Model-Toward a Unified View of Data," </title> <journal> ACM Transactions on Database Systems, </journal> <pages> pp 9-36, </pages> <month> March </month> <year> 1976. </year>
Reference-contexts: In particular, we used a grammar-based, program analysis tool to extract FD statements from the COBOL source. The statements were then transformed into an Entity Relationship (ER) diagram <ref> [4] </ref> for the Software Through Pictures (STP) CASE tool. Then the STP schema generation feature was used to generate SQL create commands to define tables for holding the data. A COBOL program is a highly structured description of computations and data.
Reference: [5] <author> Kathi Hogshead Davis and Adarsh K. Arora, </author> <title> "A Methodology for Translating a Conventional File System into an Entity-Relationship Model," </title> <booktitle> Proceedings 4th International Conference on the Entity-Relationship Approach, IEEE, </booktitle> <year> 1985. </year>
Reference-contexts: Our investigations of the automatic construction of ER diagrams proved successful at describing those entities that correspond to program files. More difficult is the question of detecting relationships in programs. Some work in this direction is described in <ref> [5, 14] </ref>. We would like to use techniques from compiler data flow analysis to pursue this goal. * Other types of applications. The experiment described in section 3.4 was limited to a program solely concerned with writing a report.
Reference: [6] <author> Melody Eidbo and et al., </author> <title> "ISA-97 Compliant Architecture Testbed (ICAT) Project Final Report," </title> <publisher> ASQB-GC-92-006, AIRMICS. </publisher>
Reference-contexts: In general, an experienced COBOL programmer, using a screen editor that supports global search and replace operations, can make the transition in a straightforward way. A description of the complete set of transformations is available as an appendix to <ref> [6] </ref>. After the code was converted, it successfully compiled using the workstation compiler. In order to test the integrity of the conversion, we ran several of the programs and successfully obtained reports. There are several factors related to the conversion of system data that our experiment did not consider. <p> Therefore, an automated tool will need to analyze the PROCEDURE DIVISION as well as the FILE SECTION. The experiment was successful in the sense that an SQL report was generated from an RDBMS. Full details of this experiment are given in <ref> [6] </ref>. <p> In a sense, maintenance has been moved from a code editing activity to a conceptual alteration expressed graphically. A more detailed description of the experiment is provided in <ref> [6] </ref>. 3.4 Replacement of COBOL by a Report Writer Our most recent experiment involved reengi-neering a report generation application, which was originally written in COBOL, using Oracle's SQL*ReportWriter. The program we chose was the same one used in the previous experiment.
Reference: [7] <author> Ian J. Hayes, </author> <title> "Applying Formal Specification to Software Development in Industry," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. SE-11, no. 2, </volume> <pages> pp 169-178, </pages> <month> February </month> <year> 1985. </year>
Reference-contexts: Maintenance activities that require modification of existing code (versus simply adding new modules) can also help justify the expense of reverse engineering. Reverse engineering does not have to be applied to an entire system <ref> [7] </ref>. Even if only a part of a system is being reverse engineered, there is still a need for the program maintainer to understand the context of the component relative to the entire system.
Reference: [8] <author> Reginald L. Hobbs, John R. Mitchell, Glenn E. Racine, and Richard Wassmath, </author> <title> "Re-engineering Old Production Systems: A Case Study of Systems Redevelopment and Evaluation of Success," Emerging Information Technologies for Competitive Advantage and Economic Development: </title> <booktitle> Proceedings of the 1992 Information Resources Management Association International Conference, </booktitle> <pages> pp 29-37, </pages> <address> Harrisburg, Penn-sylvania, </address> <month> May </month> <year> 1992. </year>
Reference-contexts: This STAMIS consists of approximately 10,000 lines of COBOL code, broken into 15 programs. We had become familiar with this system during an earlier project [18] that ultimately lead to the replacement of IMCSRS by a version written in Ada <ref> [8, 16] </ref>. IMCSRS is smaller than a typical STAMIS, but it performs typical functions. It is responsible for using input transactions to update a master file and then producing a variety of reports describing the status of Army materiel. <p> Results were so positive that the Ada version has replaced the COBOL version as part of regular procedures at the site of the trial. As other sites learned of the improved performance, they requested and obtained the personal computer version <ref> [8, 16] </ref>. Subsequently, an economic analysis was performed to predict the saving that would result for using the Ada version over a ten year period [19]. The predicted results for this system alone were for a $3,000,000 saving.
Reference: [9] <author> Reginald L. Hobbs, Joseph J. Nealon, and Richard Wassmath, </author> <title> "Ada Transition Research Project (Phase I) Final Report," </title> <journal> ASQB-GI-91-005, AIRMICS, </journal> <volume> De-cember 10, </volume> <year> 1990. </year>
Reference-contexts: We believe the resulting implementation is also easy to modify and maintain. 3.5 Economic Justification One related "experiment" should be reported on. Our original examination of IMCSRS was part of an exercise to determine the issues involved in translating a COBOL program to Ada <ref> [9] </ref>. The project involved reverse engineering IMCSRS and then constructing two designs, one using functional decomposition and one using object-oriented design. The designs were compared and the object-oriented design selected for implementation. An Ada implementation was then built and analyzed.
Reference: [10] <author> Ivar Jacobson, Magnus Christerson, Patrik Jonsson, and Gunnar Overgaard, </author> <title> Object-Oriented Software Engineering A Use Case Approach, </title> <publisher> Addison-Wesley, </publisher> <year> 1992. </year>
Reference-contexts: A scenario is a hypothetical narrative describing a potential transition effort. It can be used to explore difficulties in applying the criteria. Scenarios have been effectively used to solicit system requirements during the early stages of software development <ref> [10] </ref>, and their use here has a similar purpose, to unearth unanticipated costs and benefits. The second suggestion involves the use of case studies of previous transition efforts.
Reference: [11] <author> Bret Johnson, </author> <title> "Reverse Engineering with a CASE Tool," </title> <institution> SRC-TR-91-07, Software Research Center, College of Computing, Georgia Institute of Technology, </institution> <month> December </month> <year> 1991. </year>
Reference-contexts: Normally, an STP user manually selects icons and places them in a diagram on the screen. Using the published file format, however, we were able to automatically construct diagrams based on the information extracted by NewYacc <ref> [11, 12] </ref>. The program visualization provided by this approach is limited in several ways. First, STP provides no mechanism for refining an ER diagram into lower level diagrams. This is not a fundamental limitation. The Batini book [2], for example, describes several ways in which complex diagrams can be abstracted.
Reference: [12] <author> Bret Johnson, Steve Ornburn, and Spencer Rugaber, </author> <title> "A Quick Tools Strategy for Program Analysis and Software Maintenance," </title> <booktitle> Proceedings of the Conference on Software Maintenance, </booktitle> <pages> pp 206-213, </pages> <address> Orlando, Florida, </address> <month> November </month> <year> 1992. </year>
Reference-contexts: Normally, an STP user manually selects icons and places them in a diagram on the screen. Using the published file format, however, we were able to automatically construct diagrams based on the information extracted by NewYacc <ref> [11, 12] </ref>. The program visualization provided by this approach is limited in several ways. First, STP provides no mechanism for refining an ER diagram into lower level diagrams. This is not a fundamental limitation. The Batini book [2], for example, describes several ways in which complex diagrams can be abstracted.
Reference: [13] <author> Kit Kamper and Spencer Rugaber, </author> <title> "Reverse Engineering Methodology for Data Processing Applications," </title> <institution> GIT-SERC-90/02, Software Engineering Research Center, Georgia Institute of Technology, </institution> <month> March </month> <year> 1990. </year>
Reference-contexts: Such a procedure targeted specifically at information systems is described in Batini's book [2]. Another approach, aimed somewhat more at the functional requirements than at data modeling is described in <ref> [13] </ref>. The converted program is responsible for generating a report on equipment availability. <p> This can be accomplished by a systematic analysis of the program text, simultaneously constructing a description of the application domain and procedures that the program models. A description of this process is given in <ref> [13] </ref>. Because of the structured nature of programming languages, any analysis must be based on a grammatical description of that language, i. e., a COBOL grammar. We used a grammar-based tool, called NewYacc [15], to annotate the grammar with rules.
Reference: [14] <author> Erik G. Nilsson, </author> <title> "The Translation of a Cobol Data Structure to an Entity-Relationship Type Conceptual Schema," </title> <booktitle> Proceedings 4th International Conference on the Entity-Relationship Approach, IEEE, </booktitle> <year> 1985. </year>
Reference-contexts: Our investigations of the automatic construction of ER diagrams proved successful at describing those entities that correspond to program files. More difficult is the question of detecting relationships in programs. Some work in this direction is described in <ref> [5, 14] </ref>. We would like to use techniques from compiler data flow analysis to pursue this goal. * Other types of applications. The experiment described in section 3.4 was limited to a program solely concerned with writing a report.
Reference: [15] <author> James J. Purtilo and John R. Callahan, </author> <title> "Parse Tree Annotations," </title> <journal> Communications of the ACM, </journal> <volume> vol. 32, no. 12, </volume> <pages> pp 1467-1477, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: A description of this process is given in [13]. Because of the structured nature of programming languages, any analysis must be based on a grammatical description of that language, i. e., a COBOL grammar. We used a grammar-based tool, called NewYacc <ref> [15] </ref>, to annotate the grammar with rules. The rules were applied during traversals of the program parse tree in order to extract constructs from the program. The rules indicate which program features to extract. In the case of IMCSRS, FD statements were extracted.
Reference: [16] <author> Glenn E. Racine, Reginald L. Hobbs, and Richard Wassmath, </author> <title> "Ada Transition Research Project (A Software Modernization Effort)," </title> <booktitle> Proceedings of the 10th Annual National Conference on Ada Technology, </booktitle> <pages> pp 192-201, </pages> <month> February </month> <year> 1992. </year>
Reference-contexts: This STAMIS consists of approximately 10,000 lines of COBOL code, broken into 15 programs. We had become familiar with this system during an earlier project [18] that ultimately lead to the replacement of IMCSRS by a version written in Ada <ref> [8, 16] </ref>. IMCSRS is smaller than a typical STAMIS, but it performs typical functions. It is responsible for using input transactions to update a master file and then producing a variety of reports describing the status of Army materiel. <p> Results were so positive that the Ada version has replaced the COBOL version as part of regular procedures at the site of the trial. As other sites learned of the improved performance, they requested and obtained the personal computer version <ref> [8, 16] </ref>. Subsequently, an economic analysis was performed to predict the saving that would result for using the Ada version over a ten year period [19]. The predicted results for this system alone were for a $3,000,000 saving.
Reference: [17] <author> Spencer Rugaber and Richard Clayton, </author> <title> "The Representation Problem in Reverse Engineering," </title> <booktitle> Proceedings of the First Working Conference on Reverse Engineering, </booktitle> <address> Baltimore, Maryland, </address> <month> May 21-23, </month> <year> 1993. </year>
Reference-contexts: From these efforts, we can learn the ways in which domain models can best support reverse engineering activities. * Knowledge representation. Domain models must be explicitly represented. One approach to this is to use an existing knowledge representation language. Other approaches are described in <ref> [17] </ref>. We would like to explore how well such languages are capable of supporting reverse engineering efforts such as those described here. Acknowledgements The authors gratefully acknowledge the support of the Army Research Laboratory through contract DAKF 11-91-D-0004 and the participation of Richard Clayton, Bret Johnson, and Gary Pardun.
Reference: [18] <author> A Spencer Rugaber and Kit Kamper, </author> <title> "Design Decision Analysis Research Project," </title> <institution> GIT-SERC-90/01, Software Engineering Research Center, Georgia Institute of Technology, </institution> <month> January 28, </month> <year> 1990. </year>
Reference-contexts: To do this, we used the Installation Materiel Condition Status Reporting System (IMCSRS)[1]. This STAMIS consists of approximately 10,000 lines of COBOL code, broken into 15 programs. We had become familiar with this system during an earlier project <ref> [18] </ref> that ultimately lead to the replacement of IMCSRS by a version written in Ada [8, 16]. IMCSRS is smaller than a typical STAMIS, but it performs typical functions.
Reference: [19] <author> Peter G. Sassone, </author> <title> "Economic Justification," </title> <address> ASQB-GM-92-008, AIRMICS, </address> <month> December </month> <year> 1991. </year>
Reference-contexts: As other sites learned of the improved performance, they requested and obtained the personal computer version [8, 16]. Subsequently, an economic analysis was performed to predict the saving that would result for using the Ada version over a ten year period <ref> [19] </ref>. The predicted results for this system alone were for a $3,000,000 saving. And this does not include any savings in maintenance cost due to the increased encapsulation provided by the object-oriented design. The payback period for the re-engineering effort was projected to be less than six months.
Reference: [20] <author> Edward Yourdon, </author> <title> Structured Walkthroughs, </title> <publisher> Yourdon Press, </publisher> <year> 1989. </year>
Reference-contexts: Likewise, a report generator can replace code that explicitly formats output reports, and query operations can replace complex procedural code. * Improved maintainability. Estimates indicate that several hundred billion lines of source code exist in the world and that seventy percent of it is written in COBOL <ref> [20] </ref>. The largest cost factor in software development is maintaining existing programs after they are delivered. Up to 75% of life cycle cost may be expended on such maintenance. Moreover, maintenance costs are directly related to the amount of code being maintained [3].
References-found: 20

