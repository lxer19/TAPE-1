URL: http://www.cs.ucsb.edu/~ambuj/compose.ps
Refering-URL: http://www.cs.ucsb.edu/~ambuj/research.html
Root-URL: http://www.cs.ucsb.edu
Title: Compositional Proofs for Concurrent Objects  
Author: Jerry James Ambuj Singh 
Date: July 19, 1997  
Abstract: We consider the language, programming, and proof-theoretic issues in the design of open systems built from concurrent objects. Our model supports constructs for communication and synchronization, and mechanisms for dierent kinds of method invocations. For full generality, it also supports an unbounded number of objects and threads of control. We express object properties using TLA, and use the rely-guarantee mechanism for specifying the interaction of an object with its environment. Our proof methodology supports proof reuse in subclasses. It also supports compositional reasoning techniques, so that properties of a system can be deduced from the properties of its component objects. We remark on the inheritance anomaly and issues that arise from the unboundedness of the system.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Martn Abadi and Leslie Lamport. </author> <title> The existence of retnement mappings. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 82(2):25384, </address> <month> May </month> <year> 1991. </year> <month> 15 </month>
Reference-contexts: Then, to be acyclic, P = P 1 jjP 2 must entail G 1 or G 2 . However, in the absence of R, neither implication holds. Note that R can be substituted for RG in the lefthand column without changing the necessity of placing G1 in <ref> [1; 2] </ref> and G2 in [2; 1]. 6 Conclusion We have considered the construction of concurrent open systems, and considered some fundamental problems that must be overcome for such an endeavor to be successful. <p> However, in the absence of R, neither implication holds. Note that R can be substituted for RG in the lefthand column without changing the necessity of placing G1 in [1; 2] and G2 in <ref> [2; 1] </ref>. 6 Conclusion We have considered the construction of concurrent open systems, and considered some fundamental problems that must be overcome for such an endeavor to be successful.
Reference: [2] <author> Martn Abadi and Leslie Lamport. </author> <title> An old-fashioned recipe for real time. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(5):154371, </volume> <month> September </month> <year> 1994. </year>
Reference-contexts: The precise logic is relatively unimportant, as long as it is powerful enough to express the concepts of interest. Our model is based on the Temporal Logic of Actions (TLA [3]). It has been shown elsewhere <ref> [2] </ref> that TLA can be adapted for proofs of real time programs. <p> Then, to be acyclic, P = P 1 jjP 2 must entail G 1 or G 2 . However, in the absence of R, neither implication holds. Note that R can be substituted for RG in the lefthand column without changing the necessity of placing G1 in <ref> [1; 2] </ref> and G2 in [2; 1]. 6 Conclusion We have considered the construction of concurrent open systems, and considered some fundamental problems that must be overcome for such an endeavor to be successful. <p> However, in the absence of R, neither implication holds. Note that R can be substituted for RG in the lefthand column without changing the necessity of placing G1 in [1; 2] and G2 in <ref> [2; 1] </ref>. 6 Conclusion We have considered the construction of concurrent open systems, and considered some fundamental problems that must be overcome for such an endeavor to be successful.
Reference: [3] <author> Martn Abadi and Leslie Lamport. </author> <title> Conjoining specitcations. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(3):50734, </volume> <month> May </month> <year> 1995. </year> <note> Also SRC Research Report 118. </note>
Reference-contexts: We give a brief background on TLA, and discuss its use in expressing object properties in Section 3. Our proof methodology is founded on the internal/external property dichotomy, and TLA's Composition Theorem <ref> [3] </ref>. We use this theorem to prove an object's external properties from its internal properties, to prove properties of systems of objects, and to prove properties of a subclass while reusing proofs from the parent class as much as possible. <p> To that end, we need a formal concurrent logic system in which to write object properties. The precise logic is relatively unimportant, as long as it is powerful enough to express the concepts of interest. Our model is based on the Temporal Logic of Actions (TLA <ref> [3] </ref>). It has been shown elsewhere [2] that TLA can be adapted for proofs of real time programs. <p> The TLA Composition Theorem provides a complete composition rule. This is one reason why we chose TLA as our underlying formalism. The completeness of this theorem was remarked upon by Abadi and Lamport <ref> [3] </ref>, but no proof was given. However, the proof is relatively straightforward. <p> The totals can be used in guards to provide a history-based synchronization scheme. Our experience shows that this approach is eective, and may be needed for even simple objects with simple alterations in a subclass. 11 5 Related Work Abadi and Lamport <ref> [3] </ref> develop rules for proving composition in the context of the TLA logic. They use rely-guarantee properties, with no restrictions on the modules to be composed. Such properties are stated with the + . operator, which is equivalent to Misra's co operator, and Manohar and Sivilotti's next operator.
Reference: [4] <author> Henri E. Bal. </author> <title> Programming Distributed Systems. </title> <publisher> Prentice-Hall, </publisher> <address> New York, </address> <year> 1991. </year>
Reference-contexts: paper, we show how to use compositional techniques to prove the correctness of the algorithm. 2 Object Model The concepts introduced in this section are illustrated with the gossip example in Appendix B. 2.1 Basic Concepts Our object model bears many similarities to other distributed object models, such as Orca <ref> [4] </ref>, and the Java object model [10]. An object is an encapsulated state container. The state cannot be accessed directly; the only external access is through method calls, or operations.
Reference: [5] <author> Howard Barringer, Ruurd Kuiper, and Amir Pnueli. </author> <title> Now you may compose temporal logic specitcations. </title> <booktitle> In STOC '84, </booktitle> <pages> pages 5163, </pages> <address> Washington, D.C., USA, 30 April2 May 1984. </address> <publisher> ACM SIGACT, ACM Press. </publisher>
Reference-contexts: It does not deal with a dynamic set of processes, nor does inheritance play a role. The rule appears to be better suited for automated, rather than human, use. Barringer, Kuiper, and Pnueli <ref> [5] </ref> develop a composition rule for temporal logic. They do not use rely-guarantee properties, and there are no restrictions on the modules to be composed. Both safety and progress properties are handled by the rule. However, the rule handles only two processes and cannot deal with inheritance.
Reference: [6] <author> K. Mani Chandy and Jayadev Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, USA, </address> <year> 1988. </year> <note> Reprinted with corrections, </note> <month> May </month> <year> 1989. </year>
Reference: [7] <author> Frank S. de Boer. </author> <title> A proof system for the parallel object-oriented language POOL. </title> <editor> In M. S. Paterson, editor, </editor> <booktitle> ICALP '90, volume 443 of Lecture Notes in Computer Science, </booktitle> <pages> pages 57285, </pages> <institution> Warwick University, </institution> <address> England, 1620 July 1990. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: However, no tools are provided for showing this implication. Other works have attempted to provide such tools. The POOL language is given a proof system by de Boer <ref> [7] </ref> using rely-guarantee properties. The strength of this system is that it handles a dynamic set of processes. However, the composition rule can only prove pure safety properties; there is no composition rule for progress properties. Furthermore, there is no mechanism for dealing with inheritance.
Reference: [8] <author> Leslie Lamport. </author> <title> What good is temporal logic? In R. </title> <editor> E. A. Mason, editor, </editor> <booktitle> Information Processing '83, volume 9 of IFIP Congress Series, </booktitle> <pages> pages 65768, </pages> <address> Paris, France, 1923 September 1983. </address> <publisher> Elsevier Science Pub. Co. </publisher>
Reference: [9] <author> Leslie Lamport. </author> <title> The temporal logic of actions. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(3):872923, </volume> <month> May </month> <year> 1994. </year>
Reference-contexts: This leads us to distinguish between external (abstract) and internal (concrete) propreties of an object. We have chosen to express object properties in TLA <ref> [9] </ref> (Temporal Logic of Actions), a logic that supports the needs listed above. We give a brief background on TLA, and discuss its use in expressing object properties in Section 3. Our proof methodology is founded on the internal/external property dichotomy, and TLA's Composition Theorem [3].
Reference: [10] <author> Tim Lindholm and Frank Yellin. </author> <title> The Java Virtual Machine Specitcation. The Java Series. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, USA, </address> <year> 1997. </year>
Reference-contexts: compositional techniques to prove the correctness of the algorithm. 2 Object Model The concepts introduced in this section are illustrated with the gossip example in Appendix B. 2.1 Basic Concepts Our object model bears many similarities to other distributed object models, such as Orca [4], and the Java object model <ref> [10] </ref>. An object is an encapsulated state container. The state cannot be accessed directly; the only external access is through method calls, or operations.
Reference: [11] <author> Nancy A. Lynch and Mark Tuttle. </author> <title> Hierarchical correctness proofs for distributed algorithms. </title> <booktitle> In PODC '87, </booktitle> <pages> pages 13751, </pages> <address> Vancouver, British Columbia, Canada, </address> <month> 1012 August </month> <year> 1987. </year> <booktitle> ACM SIGACT, ACM SIGOPS, </booktitle> <publisher> ACM Press. </publisher>
Reference: [12] <author> Rajit Manohar and Paolo A. G. Sivilotti. </author> <title> Composing processes using modited rely-guarantee specitcations. </title> <type> Technical Report CS-TR9622, </type> <institution> California Institute of Technology, Pasadena, </institution> <address> CA 91125, </address> <month> 12 June </month> <year> 1996. </year>
Reference-contexts: We discuss these proof methodology issues in Section 4. In concurrent object models, code reuse is achieved through local reasoning and composition, but global reasoning is often dicult to avoid. An example of this problem is given in <ref> [12] </ref>. The example, that of a synchronization algorithm using gossip, is used by us throughout this paper to illustrate our ideas. The gossip algorithm depends on a number of cooperating processes. <p> The basic idea is to show that each method preserves the environment assumptions of the other methods. The proofs are in Appendix C. We avoid the global reasoning techniques needed for weaker composition rules (see <ref> [12] </ref>), applying compositional techniques instead. This is one of the benetts of our approach; low-level (i.e., internal) properties can be constructed with purely local reasoning. In the absence of private methods and nested objects, the external properties of individual objects can be constructed with local reasoning and composition. <p> If all classes pass the cooperation test with respect to some invariant I , then the composition of all the rely properties guarantees I and the composition of all guarantee properties. Manohar and Sivilotti <ref> [12] </ref> provide a composition rule based on modited rely-guarantee properties. These are rely-guarantee properties which can only refer to local variables (i.e., variables local to the process to which the property refers).
Reference: [13] <author> Satoshi Matsuoka and Akinori Yonezawa. </author> <title> Analysis of inheritance anomaly in object-oriented concurrent programming languages. </title> <editor> In Gul Agha, Peter Wegner, and Akinori Yonezawa, editors, </editor> <booktitle> Research Directions in Concurrent Object-Oriented Programming, </booktitle> <pages> pages 10750. </pages> <publisher> MIT Press, </publisher> <address> Cambridge, MA, USA, </address> <year> 1993. </year>
Reference-contexts: We show that fairness can be achieved in this setting, given only the reasonable assumption that the number of threads is always tnite. The inheritance anomaly arises when the need for synchronization clashes with inheritance mechanisms. Matsuoka and Yonezawa <ref> [13] </ref> list three kinds of such situations. First, some synchronization schemes use acceptance sets to state the methods that are currently accepting calls. This approach is problematic when a subclass adds methods, as methods must be added to the acceptance sets of the parent class.
Reference: [14] <author> Jayadev Misra. </author> <title> New UNITY. </title> <note> Unpublished book. </note>
Reference-contexts: This gives an equivalent formulation in which modited rely-guarantee properties can be used. Since R does not imply either R 1 or R 2 , the proof rule above cannot be used. Misra <ref> [14] </ref> starts with mixed properties, then introduces rely-guarantee (conditional) properties. His composition rule is complete, and there are only minimal restrictions on modules. Both safety and progress properties can be deduced using the composition rule.
Reference: [15] <author> Stuart E. Mitchell and Andrew J. Wellings. </author> <title> Synchronisation, concurrent object-oriented programming and the inheritance anomaly. </title> <booktitle> Computer Languages, </booktitle> <address> 22(1):1526, </address> <month> April </month> <year> 1996. </year>
Reference-contexts: Synchronization constraints in the parent class have to be changed to take the new states into account. Various solutions have been proposed. We employ a method similar to that of Mitchell and Wellings <ref> [15] </ref>. We make the set of 2 calls to each method (pending, active, and completed) available to the object. By referencing these sets in guards, the inheritance anomaly can largely be avoided. We discuss these proof methodology issues in Section 4. <p> With the auxiliary variables to help us, we can show that each round corresponds to one use of the parent system. We can then provide a straightforward proof of the properties of the subclass. This approach is similar in spirit to that explored in <ref> [15] </ref>. The authors of that paper show that a simple count of the number of requests for various operations, the number of activations of methods, and the number of completions of methods can provide sucient information to avoid the inheritance anomaly in many cases. <p> The implication is that such auxiliary variables should always be detned in classes, even when they are not immediately needed, if the method of <ref> [15] </ref> is to be used. While this approach does oer some hope of avoiding the inheritance anomaly, it places a burden on the object designer, and oers no hope for existing classes.
Reference: [16] <author> Susan Owicki and David Gries. </author> <title> An axiomatic proof technique for parallel programs I. </title> <journal> Acta Informatica, </journal> <volume> 6(4):319340, </volume> <year> 1976. </year> <month> 16 </month>
Reference-contexts: Since we can express arbitrary units of atomicity, arbitrarily complex actions can take place in a single atomic step. As we will see momentarily, these atomic fragments are, with two exceptions, equivalent to the await B then S construction of Owicki and Gries <ref> [16] </ref>. An object method consists of a set of code fragments with some control structure imposed on it. The control structure can use any of the usual constructs; e.g., sequencing and iteration. Care must be taken when a control structure spans several fragments. <p> The guard may reference only the internal state of the associated object and the local variables of the executing thread 1 . A trivial guard is true in all states. The guard plays much the same role as in Owicki and Gries' system <ref> [16] </ref>, ensuring that the local state meets some criterion before the following atomic step takes place. However, our construction diers from theirs in two signitcant ways: we allow method calls inside an atomic fragment, and we do not assume that a fragment's execution will terminate.
Reference: [17] <author> Amir Pnueli. </author> <title> In transition from global to modular temporal reasoning about programs. </title> <editor> In Krzysztof R. Apt, editor, </editor> <booktitle> Logics and Models of Concurrent Systems, volume 13 of NATO ASI Series F, </booktitle> <pages> pages 12344. </pages> <publisher> Springer-Verlag, </publisher> <address> Heidelberg, </address> <year> 1985. </year>
Reference-contexts: These must be recomputed from the lower-level properties after the composition is performed. Since there is no separate rule for conditional (rely-guarantee) properties, but only a methodology for using them in the main composition rule, it follows that the composition rule for conditional properties is also complete. Pnueli <ref> [17] </ref> goes in the opposite direction, trst using rely-guarantee properties, then going to mixed properties. His rule assumes that every variable is modited by at most one process, leading to some simplitcation of the composition rules.
Reference: [18] <author> Eugene W. Stark. </author> <title> A proof technique for rely/guarantee properties. </title> <editor> In S. N. Maheshwari, editor, </editor> <booktitle> FST&TCS '85, volume 206 of Lecture Notes in Computer Science, </booktitle> <pages> pages 36991, </pages> <address> New Delhi, India, </address> <month> 1618 December </month> <year> 1985. </year> <note> Springer-Verlag. </note>
Reference-contexts: The rule is modited to use induction on a well-founded domain. Then a very simple rule is presented for united (mixed) specitcations, consisting of mere conjunction. Since composition is conjunction by detnition, the latter rule is necessarily complete; however, it may not be helpful. Stark <ref> [18] </ref> provides a composition rule for rely-guarantee properties. It handles progress properties as well as safety properties. However, it cannot handle a dynamic set of processes, nor can 13 it deal with inheritance. It is also incomplete.
Reference: [19] <author> Guy L. Steele, Jr. </author> <title> Common Lisp: The Language. </title> <publisher> Digital Press, </publisher> <address> Bedford, MA, USA, 2nd edition, </address> <year> 1990. </year>
Reference-contexts: Thus, proofs constructed for one member of a class apply to all instances of that class. For the moment, we assume that class implementations are txed in advance, so that we may reason from the program text. This assumption does not hold for all languages. For example, Common Lisp <ref> [19] </ref> has a Meta-Object Protocol (MOP) which allows the user to construct and alter classes at runtime. Such systems introduce complexities that we do not address in this paper. 2.2 Method Calls We now consider the semantics of a method call inside an atomic fragment.
References-found: 19

