URL: file://ftp.cis.ohio-state.edu/pub/tech-report/1996/TR17.ps.gz
Refering-URL: ftp://ftp.cis.ohio-state.edu/pub/tech-report/TRList.html
Root-URL: 
Title: Stepwise Design of Tolerances in Barrier Computations  
Author: Sandeep S. Kulkarni Anish Arora 
Keyword: multitolerance; masking, nonmasking, and stabilizing tolerance; detectable and undetectable faults; stepwise design; distributed systems.  
Address: Columbus, Ohio 43210 USA  
Affiliation: Department of Computer and Information Science 1 The Ohio State University  
Abstract: We design a multitolerant program for synchronizing the phases of processes in a distributed system. The tolerances of our program enable the system processes to: (i) compute all phases correctly in the presence of faults that corrupt variables in a detectable manner, and (ii) compute at most a bounded number of phases incorrectly in the presence of faults that corrupt variables in an undetectable manner. Our design proceeds in a stepwise fashion: In each step, the states of the program are augmented |by adding new variables| and the actions of the program are transformed |by restricting old actions and adding new actions. We show that the program resulting from each step not only provides added functionality but also provides added (i) masking tolerance to the detectable corruptions of the newly added variables, and (ii) time-optimal nonmasking tolerance to undetectable corruptions of the newly added variables. Since the program thus tolerates the corruptions of all of its variables, it thus automatically possesses stabilizing tolerance. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Couverur, N. Francez, and M. Gouda. </author> <title> Asynchronous unison. </title> <booktitle> 12th International Conference on Distributed Computing Systems, </booktitle> <year> 1992. </year>
Reference-contexts: Finally, we make concluding remarks in Section 7. 3 2 Related Work The barrier synchronization problem generalizes a variety of other synchronization problems, including asynchronous clock unison <ref> [1] </ref>, phase synchronization [2], and atomic commitment [3]. A substantial amount of work has already been done on each of these problems. To the best of our knowledge, however, the existence and systematic design of multitolerant solutions for these problems has not received much attention.
Reference: [2] <author> J. Misra. </author> <title> Phase synchronization. </title> <journal> Information Processing Letters, </journal> <volume> 38 </volume> <pages> 101-105, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: Finally, we make concluding remarks in Section 7. 3 2 Related Work The barrier synchronization problem generalizes a variety of other synchronization problems, including asynchronous clock unison [1], phase synchronization <ref> [2] </ref>, and atomic commitment [3]. A substantial amount of work has already been done on each of these problems. To the best of our knowledge, however, the existence and systematic design of multitolerant solutions for these problems has not received much attention.
Reference: [3] <author> P. A. Bernstein, V. Hadzilacos, and N. Goodman. </author> <title> Concurrency Control and Recovery in Database Systems, chapter 7. </title> <publisher> Addison Wesley, </publisher> <year> 1987. </year>
Reference-contexts: Finally, we make concluding remarks in Section 7. 3 2 Related Work The barrier synchronization problem generalizes a variety of other synchronization problems, including asynchronous clock unison [1], phase synchronization [2], and atomic commitment <ref> [3] </ref>. A substantial amount of work has already been done on each of these problems. To the best of our knowledge, however, the existence and systematic design of multitolerant solutions for these problems has not received much attention. In this section, we briefly recall these problems for the reader's convenience.
Reference: [4] <author> A. Arora and M. G. Gouda. </author> <title> Closure and convergence: A foundation of fault-tolerant computing. </title> <journal> IEEE Transactions on Software Engineering, </journal> 19(11) 1015-1027, 1993. 
Reference-contexts: For example, the fail-stop of a process may be considered as a fault that disables all actions of that process. And, the Byzantine behavior of a process may be considered as a fault that adds new nondeterministic actions to that process. In joint work <ref> [4] </ref> with Mohamed Gouda, the second author has observed that by introducing auxiliary variables it is possible to represent the corruption of actions by faults that corrupt the auxiliary variables.
Reference: [5] <author> S. S. Kulkarni and A. Arora. </author> <title> Multitolerance in distributed reset. </title> <type> Technical Report OSU-CISRC 02/96-TR13, </type> <institution> Ohio State University, </institution> <year> 1996. </year> <note> Submitted to Chicago Journal of Theoretical Computer Science, Special Issue on Self-Stabilization. </note>
Reference-contexts: For reasons of space, we have omitted this discussion. (The interested reader 19 is referred to <ref> [5, 6] </ref> for the method to reconstruct the tree and to ensure that the root process completes a diffusing computation, only after all processes participated in that diffusing computation.) Also, using the approach of Schlichting and Schneider [7, 8], to implement processors that, with high probability, behave like fail-stop processors, our
Reference: [6] <author> A. Arora and M. G. Gouda. </author> <title> Distributed reset. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 43(9) </volume> <pages> 1026-1038, </pages> <year> 1994. </year> <booktitle> Extended abstract in Proceedings of the Tenth Conference on Foundations of Software Technology and Theoretical Computer Science, </booktitle> <publisher> LNCS, Springer-Verlag, </publisher> <year> 1990, </year> <pages> 316-331. </pages>
Reference-contexts: For reasons of space, we have omitted this discussion. (The interested reader 19 is referred to <ref> [5, 6] </ref> for the method to reconstruct the tree and to ensure that the root process completes a diffusing computation, only after all processes participated in that diffusing computation.) Also, using the approach of Schlichting and Schneider [7, 8], to implement processors that, with high probability, behave like fail-stop processors, our
Reference: [7] <author> R. D. Schlichting and F. B. Schneider. </author> <title> Fail-stop processors: An approach to designing fault-tolerant computing systems. </title> <journal> ACM Transactions on Computers, </journal> <pages> pages 222-238, </pages> <year> 1983. </year>
Reference-contexts: space, we have omitted this discussion. (The interested reader 19 is referred to [5, 6] for the method to reconstruct the tree and to ensure that the root process completes a diffusing computation, only after all processes participated in that diffusing computation.) Also, using the approach of Schlichting and Schneider <ref> [7, 8] </ref>, to implement processors that, with high probability, behave like fail-stop processors, our program can be extended to tolerate Byzantine faults.
Reference: [8] <author> F. B. Schneider. </author> <title> Byzantine generals in action: Implementing fail-stop processors. </title> <journal> ACM Transactions on Computer Systems,, </journal> <volume> 2(2) </volume> <pages> 145-154, </pages> <year> 1984. </year> <month> 20 </month>
Reference-contexts: space, we have omitted this discussion. (The interested reader 19 is referred to [5, 6] for the method to reconstruct the tree and to ensure that the root process completes a diffusing computation, only after all processes participated in that diffusing computation.) Also, using the approach of Schlichting and Schneider <ref> [7, 8] </ref>, to implement processors that, with high probability, behave like fail-stop processors, our program can be extended to tolerate Byzantine faults.
References-found: 8

