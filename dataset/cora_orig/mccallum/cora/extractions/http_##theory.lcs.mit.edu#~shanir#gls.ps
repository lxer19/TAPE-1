URL: http://theory.lcs.mit.edu/~shanir/gls.ps
Refering-URL: http://theory.lcs.mit.edu/~shanir/
Root-URL: 
Email: E-mail: shanir@theory.lcs.mit.edu  
Title: Concurrent Timestamping Made Simple  
Author: Rainer Gawlick Nancy Lynch Nir Shavit yz 
Address: Tel-Aviv 69978, Israel.  
Note: This work was supported in part by the Office of Naval Research under Contract N00014-91-J-1046, by the Defense Advanced Research Projects Agency under Contract N00014-89-J-1988, and by the National Science Foundation under Contract 89152206-CCR. Contact Author:  
Affiliation: Laboratory for Computer Science, MIT.  MIT and Department of Computer Science, Tel-Aviv University,  
Date: March 3, 1995  
Abstract: Concurrent Time-stamp Systems (ctss) allow processes to temporally order concurrent events in an asynchronous shared memory system, a powerful tool for concurrency control, serving as the basis for solutions to coordination problems such as mutual exclusion, `-exclusion, randomized consensus, and multi-writer multi-reader atomic registers. Solutions to these problems all use an "unbounded number" based concurrent time-stamp system (uctss), a construction which is as simple to use as it is to understand. A bounded "black-box" replacement of uctss would imply equally simple bounded solutions to most of these extensively researched problems. Unfortunately, while all know applications use uctss, all existing solution algorithms are only proven to implement the Dolev-Shavit ctss axioms, which have been widely criticized as "hard-to-use." While it is easy to show that a uctss implements the ctss axioms, there is no proof that a system meeting the ctss axioms implements uctss. Thus, the problem of constructing a bounded black-box replacement for uctss remains open. This paper presents the first such bounded black-box replacement of uctss. The key to the solution is a simplified variant of the Dolev-Shavit ctss algorithm based on the atomic snapshot object proposed by Afek et. al. and Anderson, in a way that limits the number of interleavings that can occur, and whose behaviours can be readily mapped to those of uctss. Using the forward simulation techniques of the I/O Automata model, we are then able show that our bounded algorithm behaves like uctss. The forward simulation allows us to present, what would otherwise be a complicated proof, as an extensive, yet at each step simple case analysis. In fact, we believe that large parts of the forward simulation proof can be checked using an automatic proof checker such as Larch. For read/write memory, our easy to use bounded uctss is only a logaritmic factor from the most efficient known bounded ctss constructions. Moreover, unlike these efficient algorithms, our modular use of an atomic snapshot object implies that our constructions are not limited to read/write memory, and can be applied in any computation model whose basic operations suffice to provide a wait-free snapshot implementation. The complexity of our bounded uctss will be the same as the complexity of the underlaying snapshot implementation used. fl A preliminary version of this work appeared in the Proceedings of the Annual Israel Symposium on Theory and Practice of Computing, Haifa, May 1992, and as Technical Report MIT/LCS/TR-556. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. Abrahamson. </author> <title> On achieving consensus using a shared memory. </title> <booktitle> In Proceedings of 7th ACM Symposium on the Principles of Distributed Computing, </booktitle> <address> Toronto, Ontario, Canada, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: The paradigm of concurrent timestamping is at the heart of solutions to some of the most fundamental problems in multiprocessor concurrency control. Examples of such algorithms include Lamport's first come first served mutual exclusion [17], Vitanyi and Awerbuch's construction of a multi-reader multi-writer atomic register [25], Abrahamson's randomized consensus <ref> [1] </ref>, and Afek, Dolev, Gafni, Merritt, and Shavit's first come first enabled `-exclusion [3]. Solutions to these problems all use an "unbounded number" based concurrent timestamp system (uctss), a construction which is as simple to use as it is to understand. <p> They model their bounded construction after a new type of unbounded ctss construction, where processes choose from "local pools" of label values instead of the simple "global pool" based uctss <ref> [1, 3, 17, 25] </ref>. In order to bound the number of possible label values in the local pool of the bounded implementation, they introduce a form of amortized garbage collection. They then prove that the linear time bounded implementation meets the ctss axioms of [9].
Reference: [2] <author> Y. Afek, H. Attiya, D. Dolev, E. Gafni, M. Merritt, and N. Shavit. </author> <title> Atomic snapshots of shared memory. </title> <booktitle> In Proc. 9th ACM Symp. on Principles of Distributed Computing, </booktitle> <year> 1990, </year> <pages> pp. 1-14. </pages>
Reference-contexts: Our solution consists of the following steps. * Our algorithm is a variation on the Dolev-Shavit algorithm [9] based on the use of the atomic snapshot primitive introduced by Afek et. al <ref> [2] </ref> and Anderson [6]. A snapshot primitive allows a process P i to update the ith memory location, or snap the memory, that is, collect an "instantaneous" view of all n shared memory locations. <p> In fact, we believe that large parts of the forward simulation proof can be checked using an automatic proof checker such as Larch [27, 12]. As mentioned, our algorithm provides a wait-free solution in whatever computation model the atomic snapshot object <ref> [2] </ref> is implemented, be it single-writer multi-reader registers [4], multi-reader multi-writer registers [14], consensus objects [7], or memory with hardware supported compare-and-swap and fetch-and-add primitives. The time complexity of our uctss construction is simply the complexity of the underlying atomic snapshot implementation. <p> The snap i operation, defined by Afek et al. <ref> [2] </ref> and Anderson [6], atomically reads an array of single writer multireader locations. Here we use it to atomically read the current labels for the newlabel i function. To write the new label determined by the newlabel i function we use the update i operation. <p> Here we use it to atomically read the current labels for the newlabel i function. To write the new label determined by the newlabel i function we use the update i operation. A update i operation, also defined by <ref> [2] </ref>, writes a value to a single location in the array of single writer multireader location read by snap i . snap i and update i are waitfree, therefore their use does not compromise the waitfree properties of our timestamp algorithm.
Reference: [3] <author> Y. Afek, D. Dolev, E. Gafni, M. Merritt and N. Shavit. </author> <title> A Bounded first-in, first-enabled solution to the `-exclusion problem. </title> <journal> ACM TOPLAS, </journal> <volume> (16)3, </volume> <pages> pages 939-953, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: Examples of such algorithms include Lamport's first come first served mutual exclusion [17], Vitanyi and Awerbuch's construction of a multi-reader multi-writer atomic register [25], Abrahamson's randomized consensus [1], and Afek, Dolev, Gafni, Merritt, and Shavit's first come first enabled `-exclusion <ref> [3] </ref>. Solutions to these problems all use an "unbounded number" based concurrent timestamp system (uctss), a construction which is as simple to use as it is to understand. <p> They model their bounded construction after a new type of unbounded ctss construction, where processes choose from "local pools" of label values instead of the simple "global pool" based uctss <ref> [1, 3, 17, 25] </ref>. In order to bound the number of possible label values in the local pool of the bounded implementation, they introduce a form of amortized garbage collection. They then prove that the linear time bounded implementation meets the ctss axioms of [9].
Reference: [4] <author> Attiya, H., and Rachman, O. </author> <title> Atomic snapshots in O(nlogn) operations. </title> <booktitle> Proceedings of the 12th ACM Symposium on Principles of Distributed Computing, </booktitle> <month> (Aug. </month> <year> 1993) </year> <month> 29-40. </month>
Reference-contexts: In fact, we believe that large parts of the forward simulation proof can be checked using an automatic proof checker such as Larch [27, 12]. As mentioned, our algorithm provides a wait-free solution in whatever computation model the atomic snapshot object [2] is implemented, be it single-writer multi-reader registers <ref> [4] </ref>, multi-reader multi-writer registers [14], consensus objects [7], or memory with hardware supported compare-and-swap and fetch-and-add primitives. The time complexity of our uctss construction is simply the complexity of the underlying atomic snapshot implementation. For single-writer multi-reader memory, this is the intricate Attiya and Rachman algorithm [4], which takes O (n <p> it single-writer multi-reader registers <ref> [4] </ref>, multi-reader multi-writer registers [14], consensus objects [7], or memory with hardware supported compare-and-swap and fetch-and-add primitives. The time complexity of our uctss construction is simply the complexity of the underlying atomic snapshot implementation. For single-writer multi-reader memory, this is the intricate Attiya and Rachman algorithm [4], which takes O (n log n) operations for either a scan or an update of memory. 2 Hence the complexity of our algorithm is O (n log n) for each operation, a logarithmic factor away from the best know constructions [10, 11, 16].
Reference: [5] <author> H. Attiya, D. Dolev, and N. Shavit. </author> <title> Bounded polynomial randomized consensus. </title> <booktitle> In Proceedings of the 8 th Annual ACM Symposium on Principles of Distributed Computing, pages, ACM SIGACT and SIGOPS, ACM, </booktitle> <year> 1989. </year>
Reference: [6] <author> J. H. Anderson. </author> <title> Multiple-writer composite registers. </title> <journal> Distributed Computing, </journal> <volume> Vol. 7, No. 4, </volume> <pages> pages 175-, </pages> <year> 1994. </year>
Reference-contexts: Our solution consists of the following steps. * Our algorithm is a variation on the Dolev-Shavit algorithm [9] based on the use of the atomic snapshot primitive introduced by Afek et. al [2] and Anderson <ref> [6] </ref>. A snapshot primitive allows a process P i to update the ith memory location, or snap the memory, that is, collect an "instantaneous" view of all n shared memory locations. <p> The snap i operation, defined by Afek et al. [2] and Anderson <ref> [6] </ref>, atomically reads an array of single writer multireader locations. Here we use it to atomically read the current labels for the newlabel i function. To write the new label determined by the newlabel i function we use the update i operation.
Reference: [7] <author> Chandra T. D. and Dwork, C. </author> <title> Using Consensus to solve Atomic Snapshots. </title> <type> Manuscript, </type> <year> 1993. </year>
Reference-contexts: As mentioned, our algorithm provides a wait-free solution in whatever computation model the atomic snapshot object [2] is implemented, be it single-writer multi-reader registers [4], multi-reader multi-writer registers [14], consensus objects <ref> [7] </ref>, or memory with hardware supported compare-and-swap and fetch-and-add primitives. The time complexity of our uctss construction is simply the complexity of the underlying atomic snapshot implementation. <p> One can also use snapshot implementations in other computation models: the snapshot algorithm of Inoue, Chen, Masuzawa and Tokura [14] to get an O (n) per operation bounded uctss using multi-reader multi-writer registers, the Chandra and Dwork <ref> [7] </ref> algorithm to get O (1) label and O (n) scan operations using consensus or randomized consensus objects, or the Riany, Shavit and Touitou [24] algorithm to get O (1) label and O (n) scan operations using memory with hardware supported compare-and-swap and fetch-and-add primitives.
Reference: [8] <author> R. Cori and E. Sopena. </author> <title> Some combinatorial aspects of timestamp systems. </title> <type> Unpublished Manuscript, </type> <year> 1991. </year>
Reference-contexts: Sequential timestamp systems prohibit concurrent operations. This work was continued in several interesting papers on sequential systems with weaker ordering requirements by Li and Vitanyi [21], Cori and Sopena <ref> [8] </ref> and Saks and Zaharoglou [26]. Dolev and Shavit [9] were the first to provide an axiomatic definition and a construction of a bounded concurrent timestamp system using read/write registers.
Reference: [9] <author> D. Dolev and N. Shavit. </author> <title> Bounded concurrent time-stamps are constructible. </title> <journal> SIAM Journal on Computing, </journal> <volume> to appear. </volume> <booktitle> Also in Proceedings of the 21 st Annual ACM Symposium on Theory of Computing, </booktitle> <address> Seattle, Washington, </address> <pages> pages 454-465, </pages> <year> 1989. </year>
Reference-contexts: Sequential timestamp systems prohibit concurrent operations. This work was continued in several interesting papers on sequential systems with weaker ordering requirements by Li and Vitanyi [21], Cori and Sopena [8] and Saks and Zaharoglou [26]. Dolev and Shavit <ref> [9] </ref> were the first to provide an axiomatic definition and a construction of a bounded concurrent timestamp system using read/write registers. <p> Because of the importance of the bounded concurrent timestamping problem, the original solution by Dolev and Shavit has been followed by a series of papers directed at providing more efficient and simple to understand bounded ctss algorithms. Israeli and Pinchasov [16] have simplified the <ref> [9] </ref> algorithm by modifying the labeling scheme of [9], introducing a new label scanning method, and replacing the ordering-of-events based formal proof [18] of the ctss axioms. <p> Israeli and Pinchasov [16] have simplified the <ref> [9] </ref> algorithm by modifying the labeling scheme of [9], introducing a new label scanning method, and replacing the ordering-of-events based formal proof [18] of the ctss axioms. Concurrent with our work, Dwork and Waarts [10] presented the most efficient read/write register based ctss construction to date, taking only O (n) time for either a scan or update. <p> In order to bound the number of possible label values in the local pool of the bounded implementation, they introduce a form of amortized garbage collection. They then prove that the linear time bounded implementation meets the ctss axioms of <ref> [9] </ref>. In [11], Dwork, Herlihy, Plotkin, and Waarts introduce an alternative linear complexity bounded ctss construction that combines a time-lapse snapshot with the bounded ctss algorithm of [9]. The proof of their algorithm leverages the axiomatic proof in [9] by arguing that the executions of 1 their algorithm are a subset <p> They then prove that the linear time bounded implementation meets the ctss axioms of <ref> [9] </ref>. In [11], Dwork, Herlihy, Plotkin, and Waarts introduce an alternative linear complexity bounded ctss construction that combines a time-lapse snapshot with the bounded ctss algorithm of [9]. The proof of their algorithm leverages the axiomatic proof in [9] by arguing that the executions of 1 their algorithm are a subset of the executions of the algorithm in [11]. <p> prove that the linear time bounded implementation meets the ctss axioms of <ref> [9] </ref>. In [11], Dwork, Herlihy, Plotkin, and Waarts introduce an alternative linear complexity bounded ctss construction that combines a time-lapse snapshot with the bounded ctss algorithm of [9]. The proof of their algorithm leverages the axiomatic proof in [9] by arguing that the executions of 1 their algorithm are a subset of the executions of the algorithm in [11]. <p> The key to the solution is an algorithm whose behaviours can be readily mapped to those of uctss, and the use of a forward simulation proof technique. Our solution consists of the following steps. * Our algorithm is a variation on the Dolev-Shavit algorithm <ref> [9] </ref> based on the use of the atomic snapshot primitive introduced by Afek et. al [2] and Anderson [6]. A snapshot primitive allows a process P i to update the ith memory location, or snap the memory, that is, collect an "instantaneous" view of all n shared memory locations. <p> By using a snapshot primitive, we limit the number of interleavings that can occur, and are able to introduce a much simplified version of the labeling algorithm of <ref> [9] </ref> that is tailored so as to allow a forward simulation proof [22].
Reference: [10] <author> C. Dwork and O. Waarts. </author> <title> Simple and efficient bounded concurrent timestamping or bounded concurrent timestamp systems are comprehensible!, </title> <booktitle> ACM Symposium on Theory of Computing, </booktitle> <year> 1992. </year>
Reference-contexts: Israeli and Pinchasov [16] have simplified the [9] algorithm by modifying the labeling scheme of [9], introducing a new label scanning method, and replacing the ordering-of-events based formal proof [18] of the ctss axioms. Concurrent with our work, Dwork and Waarts <ref> [10] </ref> presented the most efficient read/write register based ctss construction to date, taking only O (n) time for either a scan or update. <p> memory, this is the intricate Attiya and Rachman algorithm [4], which takes O (n log n) operations for either a scan or an update of memory. 2 Hence the complexity of our algorithm is O (n log n) for each operation, a logarithmic factor away from the best know constructions <ref> [10, 11, 16] </ref>. <p> Note that the most efficient known shared-memory ctss algorithms <ref> [10, 11, 16] </ref> do not readily imply efficient algorithms in other computation models. Moreover, stronger computational models do not seem to immediately imply significant simplifications of bounded ctss algorithms. The paper is organized as follows. Section 2 presents the I/O Automaton model.
Reference: [11] <author> C. Dwork, M. Herlihy, S. Plotkin, and O. Waarts. </author> <title> Time lapse snapshots. </title> <booktitle> Proceedings of the Israel Symposium on the Theory of Computing and Systems. </booktitle> <address> Haifa, Israel, May 1992(Dolev D., </address> <note> Galil Z., </note> <editor> and Rodeh M. eds.) </editor> <month> 154-170. </month>
Reference-contexts: In order to bound the number of possible label values in the local pool of the bounded implementation, they introduce a form of amortized garbage collection. They then prove that the linear time bounded implementation meets the ctss axioms of [9]. In <ref> [11] </ref>, Dwork, Herlihy, Plotkin, and Waarts introduce an alternative linear complexity bounded ctss construction that combines a time-lapse snapshot with the bounded ctss algorithm of [9]. <p> The proof of their algorithm leverages the axiomatic proof in [9] by arguing that the executions of 1 their algorithm are a subset of the executions of the algorithm in <ref> [11] </ref>. <p> memory, this is the intricate Attiya and Rachman algorithm [4], which takes O (n log n) operations for either a scan or an update of memory. 2 Hence the complexity of our algorithm is O (n log n) for each operation, a logarithmic factor away from the best know constructions <ref> [10, 11, 16] </ref>. <p> Note that the most efficient known shared-memory ctss algorithms <ref> [10, 11, 16] </ref> do not readily imply efficient algorithms in other computation models. Moreover, stronger computational models do not seem to immediately imply significant simplifications of bounded ctss algorithms. The paper is organized as follows. Section 2 presents the I/O Automaton model.
Reference: [12] <author> J. Guttag and J. Horning. </author> <title> Larch: Languages and tools for formal specification. </title> <publisher> Springer Verlag, </publisher> <year> 1993. </year>
Reference-contexts: In fact, we believe that large parts of the forward simulation proof can be checked using an automatic proof checker such as Larch <ref> [27, 12] </ref>. As mentioned, our algorithm provides a wait-free solution in whatever computation model the atomic snapshot object [2] is implemented, be it single-writer multi-reader registers [4], multi-reader multi-writer registers [14], consensus objects [7], or memory with hardware supported compare-and-swap and fetch-and-add primitives.
Reference: [13] <author> M. P. Herlihy. </author> <title> Wait-free synchronization. </title> <journal> In ACM TOPLAS, </journal> <volume> 13(1), </volume> <pages> pages 124-149, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Waitfree algorithms are highly suited for fault tolerant and realtime applications (Herlihy, see <ref> [13] </ref>). The paradigm of concurrent timestamping is at the heart of solutions to some of the most fundamental problems in multiprocessor concurrency control.
Reference: [14] <author> M. Inoue, W. Chen, T. Masuzawa and N. Tokura. </author> <title> Linear-time Snapshot using Multi-writer Multi-reader registers. </title> <booktitle> Workshop on Distributed Algorithms, </booktitle> <pages> pages 130-140, </pages> <publisher> Sp-inger Verlag, </publisher> <year> 1994. </year>
Reference-contexts: As mentioned, our algorithm provides a wait-free solution in whatever computation model the atomic snapshot object [2] is implemented, be it single-writer multi-reader registers [4], multi-reader multi-writer registers <ref> [14] </ref>, consensus objects [7], or memory with hardware supported compare-and-swap and fetch-and-add primitives. The time complexity of our uctss construction is simply the complexity of the underlying atomic snapshot implementation. <p> One can also use snapshot implementations in other computation models: the snapshot algorithm of Inoue, Chen, Masuzawa and Tokura <ref> [14] </ref> to get an O (n) per operation bounded uctss using multi-reader multi-writer registers, the Chandra and Dwork [7] algorithm to get O (1) label and O (n) scan operations using consensus or randomized consensus objects, or the Riany, Shavit and Touitou [24] algorithm to get O (1) label and O
Reference: [15] <author> A. Israeli and M. Li. </author> <title> Bounded time stamps. </title> <booktitle> In 28 th Annual Symposium on Foundations of Computer Science, </booktitle> <address> White Plains, New York, </address> <pages> pages 371-382, </pages> <year> 1987. </year>
Reference-contexts: A bounded "black-box" replacement of uctss would imply equally simple bounded solutions to these extensively researched problems. 1.1 Related Research Israeli and Li, in <ref> [15] </ref>, were the first to isolate the notion of bounded timestamping (timestamping using bounded size memory) as an independent concept, developing an elegant theory of bounded sequential timestamp systems. Sequential timestamp systems prohibit concurrent operations. <p> Such a set of labels can accommodate n h processes in any sequential execution. The cycle system construction is due to Israeli and Li <ref> [15] </ref>. 8 This discussion has not identified a need for the numbers 1 and 2 in the set A. These numbers are the key to making A n1 work in concurrent executions.
Reference: [16] <author> A. Israeli and M. Pinchasov. </author> <title> A linear time bounded concurrent timestamp scheme. </title> <type> Technical Report, </type> <institution> Technion, Haifa, Israel, </institution> <month> March </month> <year> 1991. </year>
Reference-contexts: Because of the importance of the bounded concurrent timestamping problem, the original solution by Dolev and Shavit has been followed by a series of papers directed at providing more efficient and simple to understand bounded ctss algorithms. Israeli and Pinchasov <ref> [16] </ref> have simplified the [9] algorithm by modifying the labeling scheme of [9], introducing a new label scanning method, and replacing the ordering-of-events based formal proof [18] of the ctss axioms. <p> memory, this is the intricate Attiya and Rachman algorithm [4], which takes O (n log n) operations for either a scan or an update of memory. 2 Hence the complexity of our algorithm is O (n log n) for each operation, a logarithmic factor away from the best know constructions <ref> [10, 11, 16] </ref>. <p> Note that the most efficient known shared-memory ctss algorithms <ref> [10, 11, 16] </ref> do not readily imply efficient algorithms in other computation models. Moreover, stronger computational models do not seem to immediately imply significant simplifications of bounded ctss algorithms. The paper is organized as follows. Section 2 presents the I/O Automaton model.
Reference: [17] <author> L. </author> <title> Lamport A new solution of Dijkstra's concurrent programming problem. </title> <journal> Communications of the ACM, </journal> <volume> 78(8) </volume> <pages> 453-455, </pages> <year> 1974. </year>
Reference-contexts: Waitfree algorithms are highly suited for fault tolerant and realtime applications (Herlihy, see [13]). The paradigm of concurrent timestamping is at the heart of solutions to some of the most fundamental problems in multiprocessor concurrency control. Examples of such algorithms include Lamport's first come first served mutual exclusion <ref> [17] </ref>, Vitanyi and Awerbuch's construction of a multi-reader multi-writer atomic register [25], Abrahamson's randomized consensus [1], and Afek, Dolev, Gafni, Merritt, and Shavit's first come first enabled `-exclusion [3]. <p> They model their bounded construction after a new type of unbounded ctss construction, where processes choose from "local pools" of label values instead of the simple "global pool" based uctss <ref> [1, 3, 17, 25] </ref>. In order to bound the number of possible label values in the local pool of the bounded implementation, they introduce a form of amortized garbage collection. They then prove that the linear time bounded implementation meets the ctss axioms of [9].
Reference: [18] <author> L. </author> <title> Lamport On interprocess communication. parts I and II. </title> <journal> Distributed Computing, </journal> <volume> 1, </volume> <month> 1 </month> <year> (1986) </year> <month> 77-101. </month>
Reference-contexts: Israeli and Pinchasov [16] have simplified the [9] algorithm by modifying the labeling scheme of [9], introducing a new label scanning method, and replacing the ordering-of-events based formal proof <ref> [18] </ref> of the ctss axioms. Concurrent with our work, Dwork and Waarts [10] presented the most efficient read/write register based ctss construction to date, taking only O (n) time for either a scan or update.
Reference: [19] <author> M. Li and P. Vitanyi. </author> <title> A very simple construction for atomic multiwriter registers. </title> <type> Report, </type> <institution> Aiken Computation Laboratory, Harvard University, </institution> <year> 1987. </year>
Reference: [20] <author> M. Li and P. Vitanyi. </author> <title> Uniform construction for wait-free variables. 1988. </title> <type> Unpublished manuscript. </type>
Reference: [21] <author> M. Li and P. Vitanyi. </author> <title> How to share concurrent asynchronous wait-free variables. </title> <booktitle> In Proceedings of the 16 th International Colloquium on Automata, Languages and Programming, </booktitle> <pages> pages 488-505, </pages> <year> 1989. </year> <type> Unpublished manuscript. 29 </type>
Reference-contexts: Sequential timestamp systems prohibit concurrent operations. This work was continued in several interesting papers on sequential systems with weaker ordering requirements by Li and Vitanyi <ref> [21] </ref>, Cori and Sopena [8] and Saks and Zaharoglou [26]. Dolev and Shavit [9] were the first to provide an axiomatic definition and a construction of a bounded concurrent timestamp system using read/write registers.
Reference: [22] <author> N. Lynch and M. Tuttle. </author> <title> Hierarchical correcntess proofs for distributed algorithms. </title> <type> Tecnical Report MIT/LCS/TR-387, </type> <institution> Laboratory for Computer Science, MIT, </institution> <year> 1987. </year>
Reference-contexts: By using a snapshot primitive, we limit the number of interleavings that can occur, and are able to introduce a much simplified version of the labeling algorithm of [9] that is tailored so as to allow a forward simulation proof <ref> [22] </ref>. <p> This system is broader than (i.e. strictly includes) the integer based uctss used in actual applications, yet surprisingly allows for a simpler proof. We then use the forward simulation techniques of the I/O Automata model of Lynch and Tuttle <ref> [22] </ref>, to show that our bounded algorithm implements the real-number based uctss specification. (See [23] for references and a discussion of forward simulation techniques.) The forward simulation techniques allow us to present, what would otherwise be a complicated proof, as an extensive, yet at each step simple case analysis. <p> Some of the invariant proofs are postponed until Section 7. 2 The I/O Automata Model We present our algorithm in the context of the I/O Automata model. This model, introduced by Lynch and Tuttle <ref> [22] </ref>, represents algorithms as I/O Automata which are characterized by states, initial states, a set of actions called an action signature, state transitions called steps and an equivalence relation on some of the actions of the action signature called a partition. <p> We say that an I/O Automaton A implements another I/O Automaton B if the fairbehs (A) fairbehs (B). Our correctness proof uses the following theorem on simulation proofs which is a restricted version of a theorem in <ref> [22] </ref>. Theorem 2.1 Let A and B be I/O Automata with sig (A) = sig (B), part (A) = part (B), and r a relation over the states of A and B. Suppose: 1.
Reference: [23] <author> N. Lynch and F. Vaandrager. </author> <title> Forward and backward simulations for timing based systems. </title> <booktitle> To appear in Proceedings of REX Workshop on Real-time: theory in practice, Mook, </booktitle> <year> 1991. </year>
Reference-contexts: We then use the forward simulation techniques of the I/O Automata model of Lynch and Tuttle [22], to show that our bounded algorithm implements the real-number based uctss specification. (See <ref> [23] </ref> for references and a discussion of forward simulation techniques.) The forward simulation techniques allow us to present, what would otherwise be a complicated proof, as an extensive, yet at each step simple case analysis.
Reference: [24] <author> Y. Riany, N. Shavit, and D. Touito. </author> <title> Towards a practical snapshot algorithm. </title> <booktitle> Proceedings of the Third Israel Symposium on Theory and Computing Systems (ISTCS), </booktitle> <address> Tel-Aviv, </address> <month> January </month> <year> 1995. </year>
Reference-contexts: snapshot algorithm of Inoue, Chen, Masuzawa and Tokura [14] to get an O (n) per operation bounded uctss using multi-reader multi-writer registers, the Chandra and Dwork [7] algorithm to get O (1) label and O (n) scan operations using consensus or randomized consensus objects, or the Riany, Shavit and Touitou <ref> [24] </ref> algorithm to get O (1) label and O (n) scan operations using memory with hardware supported compare-and-swap and fetch-and-add primitives. Note that the most efficient known shared-memory ctss algorithms [10, 11, 16] do not readily imply efficient algorithms in other computation models.
Reference: [25] <author> P. Vitanyi and B. Awerbuch. </author> <title> Shared register access by asynchronous hardware. </title> <booktitle> In 27 th Symposium on the Foundations of Computer Science, </booktitle> <year> 1986. </year>
Reference-contexts: The paradigm of concurrent timestamping is at the heart of solutions to some of the most fundamental problems in multiprocessor concurrency control. Examples of such algorithms include Lamport's first come first served mutual exclusion [17], Vitanyi and Awerbuch's construction of a multi-reader multi-writer atomic register <ref> [25] </ref>, Abrahamson's randomized consensus [1], and Afek, Dolev, Gafni, Merritt, and Shavit's first come first enabled `-exclusion [3]. Solutions to these problems all use an "unbounded number" based concurrent timestamp system (uctss), a construction which is as simple to use as it is to understand. <p> They model their bounded construction after a new type of unbounded ctss construction, where processes choose from "local pools" of label values instead of the simple "global pool" based uctss <ref> [1, 3, 17, 25] </ref>. In order to bound the number of possible label values in the local pool of the bounded implementation, they introduce a form of amortized garbage collection. They then prove that the linear time bounded implementation meets the ctss axioms of [9].
Reference: [26] <author> M. Saks and F. Zaharoglou. </author> <title> Optimal space distributed move-to-front lists. </title> <booktitle> In Proceedings of the 10 th Symposium on the Principals of Distributed Computing, </booktitle> <pages> pages 65-73, </pages> <address> Montreal, </address> <year> 1991. </year>
Reference-contexts: Sequential timestamp systems prohibit concurrent operations. This work was continued in several interesting papers on sequential systems with weaker ordering requirements by Li and Vitanyi [21], Cori and Sopena [8] and Saks and Zaharoglou <ref> [26] </ref>. Dolev and Shavit [9] were the first to provide an axiomatic definition and a construction of a bounded concurrent timestamp system using read/write registers.
Reference: [27] <author> J. Stogard-Andersen, J. Guttag, J. Garland, A. </author> <title> Pogosyants Encoding automata and simulation proofs in LP. </title> <type> Unpublished manuscript, </type> <institution> MIT, </institution> <year> 1992. </year> <month> 30 </month>
Reference-contexts: In fact, we believe that large parts of the forward simulation proof can be checked using an automatic proof checker such as Larch <ref> [27, 12] </ref>. As mentioned, our algorithm provides a wait-free solution in whatever computation model the atomic snapshot object [2] is implemented, be it single-writer multi-reader registers [4], multi-reader multi-writer registers [14], consensus objects [7], or memory with hardware supported compare-and-swap and fetch-and-add primitives. <p> Each case is proved by a simple but tedious argument. Consequently, we view the correctness proof of our bounded timestamp algorithms as an ideal candidate with which to test the effectiveness of automatic theorem provers <ref> [27] </ref>. In testing a theorem prover on our algorithm we hope to determine whether or not I/O Automata proofs might in the future utilize theorem provers on a regular basis.
References-found: 27

