URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-91-1031/CS-TR-91-1031.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-91-1031/
Root-URL: http://www.cs.wisc.edu
Email: tom@cs.wisc.edu larus@cs.wisc.edu  
Title: Optimally Profiling and Tracing Programs  
Author: THOMAS BALL JAMES R. LARUS 
Note: September 6, 1991  
Address: 1210 W. Dayton St. Madison, WI 53706 USA  
Affiliation: Computer Sciences Department University of Wisconsin Madison  
Abstract: Technical Report #1031 Revision 1 An abridged version of this paper will appear in the 19th Symposium on Principles of Programming Languages (January 19-22, 1992). 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A. Aho, R. Sethi, and J. Ullman, </author> <booktitle> Compilers: Principles, Techniques and Tools, </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA (1986). </address>
Reference-contexts: A CFG is reducible iff for each backedge e of G (as defined by a depth-first search from the root vertex), target (e) dominates source (e). Other equivalent characterizations of reducibility are given in <ref> [1] </ref>. The edge EXIT fi root is not counted as a backedge even though it is identified as such by a depth-first search. The weighting algorithm uses natural loops to identify loops and loop-exit edges.
Reference: 2. <author> R. F. Cmelik, S. I. Kong, D. R. Ditzel, and E. J. Kelly, </author> <title> An Analysis of MIPS and SPARC Instruction Set Utilization on the SPEC Benchmarks, </title> <note> ASPLOS-IV Proceedings (published as SIGARCH Computer Architecture News) 19(2) pp. </note> <month> 290-302 (April </month> <year> 1991). </year>
Reference-contexts: These algorithms greatly reduce the cost of measuring programs. Profiling, which counts the number of times each basic block in a program executes, is widely used to measure instruction set utilization of computers, identify program bottlenecks, and estimate program execution times for code optimization <ref> [2, 4, 6, 11, 13, 14, 17] </ref>. Instruction traces are the basis for trace-driven simulation and analysis and are used also in trace-driven debugging [9, 12, 18].
Reference: 3. <institution> Systems Performance Evaluation Cooperative, </institution> <note> SPEC Newsletter (K. Mendoza, editor) 1(1)(1989). </note>
Reference-contexts: QP can either insert counters in every basic block in a program (slow mode) or along the subset of edges identified by our algorithm (quick mode). We used the SPEC benchmark suite to test QP <ref> [3] </ref>. This is a collection of 10 moderately large Fortran and C programs that is widely used to evaluate computer system performance. The programs were compiled at a high level of optimization (either -O2 or -O3, which does interprocedural register allocation). <p> Thus, even though many basic blocks of smaller size executed (which yielded the reduction in counter increments), they contributed little to the running time of the program. The FORTRAN program doduc, while it has a dynamic block size of 10 instructions, has an abundance of short branches <ref> [3] </ref> that accounts for its reduction in counter increments. The decrease in run time overhead for doduc was substantial at 57%-13%. For programs that frequently executed conditional branches, the improvements were large.
Reference: 4. <author> J. A. Fisher, J. R. Ellis, J. C. Ruttenberg, and A. Nicolau, </author> <title> Parallel Processing: A Smart Compiler and a Dumb Machine, </title> <booktitle> Proc. of the ACM SIPLAN 1984 Symposium on Compiler Construction (SIPLAN Notices) 19(6) pp. </booktitle> <month> 37-47 (June </month> <year> 1984). </year>
Reference-contexts: These algorithms greatly reduce the cost of measuring programs. Profiling, which counts the number of times each basic block in a program executes, is widely used to measure instruction set utilization of computers, identify program bottlenecks, and estimate program execution times for code optimization <ref> [2, 4, 6, 11, 13, 14, 17] </ref>. Instruction traces are the basis for trace-driven simulation and analysis and are used also in trace-driven debugging [9, 12, 18].
Reference: 5. <author> M. R. Garey and D. S. Johnson, </author> <title> Computers and Intractability: A Guide to the Theory of NP-Completeness, </title> <editor> W. H. </editor> <publisher> Freeman, </publisher> <address> San Francisco (1979). </address>
Reference-contexts: Finding a minimum size set of edges epl such that E -epl contains no directed cycles (Feedback Arc Set) or diamonds (Uniconnected Subgraph) are NP-complete problems that bear some similarities to TP (G, epl), but we have not succeeded in constructing a reduction <ref> [5, 10] </ref>. There are different constraints on TP (G, epl) that complicate matters. First, the problem is to find a minimum cost set of edges epl with respect to a weighting rather than one of minimum size.
Reference: 6. <author> S. L. Graham, P. B. Kessler, and M. K. McKusick, </author> <title> An Execution Profiler for Modular Programs, </title> <journal> Software Practice and Experience 13 pp. </journal> <month> 671-685 </month> <year> (1983). </year>
Reference-contexts: These algorithms greatly reduce the cost of measuring programs. Profiling, which counts the number of times each basic block in a program executes, is widely used to measure instruction set utilization of computers, identify program bottlenecks, and estimate program execution times for code optimization <ref> [2, 4, 6, 11, 13, 14, 17] </ref>. Instruction traces are the basis for trace-driven simulation and analysis and are used also in trace-driven debugging [9, 12, 18].
Reference: 7. <author> J. L. Kennington and R. V. Helgason, </author> <title> Algorithms for Network Programming, </title> <publisher> Wiley-Interscience, John Wiley and Sons, </publisher> <address> New York (1980). </address>
Reference-contexts: However, this placement uses too many counters. From a well-known result in network programming, it follows that an edge-counter placement epl solves EF (G, epl) iff (E-epl) contains no cycle (possibly undirected) <ref> [7] </ref>. Since a spanning tree of a CFG represents a maximum size subset of edges without a cycle, it follows that epl is a minimum size solution to EF (G, epl) iff E -epl is a spanning tree of G.
Reference: 8. <author> D. E. Knuth and F. R. Stevenson, </author> <title> Optimal Measurement Points for Program Frequency Counts, </title> <note> BIT 13 pp. </note> <month> 313-322 </month> <year> (1973). </year>
Reference-contexts: RELATED WORK This section describes related work on efficiently profiling and tracing programs. 6.1. The Knuth/Stevenson Algorithm Knuth and Stevenson exactly characterize when a set of vertices vpl solves VF (G, vpl) and show how to compute the minimum size vpl that solves VF (G, vpl) <ref> [8] </ref>. They construct a graph G from CFG G such that vpl solves VF (G, vpl) iff epl solves EF (G, epl), where vpl can be derived from epl by a one-to-one and onto map from edges in G to vertices in G that falls out from the construction.
Reference: 9. <author> J. R. Larus, </author> <title> Abstract Execution: A Technique for Efficiently Tracing Programs, </title> <journal> Software Practice and Experience 20(12) pp. </journal> <month> 1241-1258 (December, </month> <year> 1990). </year>
Reference-contexts: Instruction traces are the basis for trace-driven simulation and analysis and are used also in trace-driven debugging <ref> [9, 12, 18] </ref>. The product of this work is an exact basic block profile or traceas opposed to the Unix prof command, which samples the program counter during program execution and does not produce exact measurements. <p> In this case, the trace file need only be read to regenerate the execution. A more efficient method is to write a witness only at basic blocks that are targets of predicates <ref> [9] </ref>. <p> However, the cost was quite reasonable (exact times omitted since QP has not yet been tuned). 5.2. Tracing Performance The witness placement algorithm was also implemented in the AE program tracing system <ref> [9] </ref>. AE originally recorded the outcome of each conditional branch and used this record to regenerate a full control-flow trace. One complication is that AE traces both the instruction and data references so a trace file contains information to reconstruct data addresses as well as the witnesses. <p> vertex frequency problem? How are these problems related to the tracing problem and its optimal solution? Finally, can better weighting approximation algorithms be found? As previously noted, the profiling algorithm has been implemented in a profiling tool called QP and the tracing algorithm is part of the AE tracing system <ref> [9] </ref>. Both tools run on several machines and are available from James Larus. ACKNOWLEDGEMENTS We would like to thank Susan Horwitz for her support of this work. Gary Schultz and Jonathan Yackel provided valuable advice on network programming. Eric Bach pointed out the NP-complete Feedback Arc problem.
Reference: 10. <author> S. Maheshwari, </author> <title> Traversal marker placement problems are NP-complete, </title> <type> Report No. </type> <institution> CU-CS-092-76, Dept. of Computer Science, University of Colorado, Boulder, </institution> <address> CO (1976). </address>
Reference-contexts: Finding a minimum size set of edges epl such that E -epl contains no directed cycles (Feedback Arc Set) or diamonds (Uniconnected Subgraph) are NP-complete problems that bear some similarities to TP (G, epl), but we have not succeeded in constructing a reduction <ref> [5, 10] </ref>. There are different constraints on TP (G, epl) that complicate matters. First, the problem is to find a minimum cost set of edges epl with respect to a weighting rather than one of minimum size. <p> The authors do not give an algorithm for reconstructing an execution from a trace or consider how to handle the problem of tracing multi-procedure programs. The authors are interested in finding a minimal size solution to TP (G, epl), an NP-complete problem <ref> [10] </ref>, and develop an efficient heuristic procedure for constructing a near minimal size solution. However, a minimum size solution does not necessarily yield a minimum cost solution; sometimes a lower cost solution can be obtained by instrumenting more lower cost points rather than fewer higher cost points.
Reference: 11. <author> S. McFarling, </author> <title> Procedure Merging with Instruction Caches, </title> <booktitle> Proceedings of the SIGPLAN 91 Conference on Programming Language Design and Implementation, </booktitle> <address> (Toronto June 26-28, </address> <year> 1991), </year> <journal> ACM SIG-PLAN Notices 26(6) pp. </journal> <month> 71-91 (June, </month> <year> 1991). </year>
Reference-contexts: These algorithms greatly reduce the cost of measuring programs. Profiling, which counts the number of times each basic block in a program executes, is widely used to measure instruction set utilization of computers, identify program bottlenecks, and estimate program execution times for code optimization <ref> [2, 4, 6, 11, 13, 14, 17] </ref>. Instruction traces are the basis for trace-driven simulation and analysis and are used also in trace-driven debugging [9, 12, 18].
Reference: 12. <author> B. P. Miller and J. D. Choi, </author> <title> A Mechanism for Efficient Debugging of Parallel Programs, </title> <booktitle> Proc. of the ACM SIPLAN 1988 Conf. on Prog. Lang. Design and Implementation (SIPLAN Notices) 23(7) pp. </booktitle> <month> 135-144 (June </month> <year> 1988). </year>
Reference-contexts: Instruction traces are the basis for trace-driven simulation and analysis and are used also in trace-driven debugging <ref> [9, 12, 18] </ref>. The product of this work is an exact basic block profile or traceas opposed to the Unix prof command, which samples the program counter during program execution and does not produce exact measurements.
Reference: 13. <author> W. G. Morris, CCG: </author> <title> A Prototype Coagulating Code Generator, </title> <booktitle> Proceedings of the SIGPLAN 91 Conference on Programming Language Design and Implementation, </booktitle> <address> (Toronto June 26-28, </address> <year> 1991), </year> <journal> ACM SIGPLAN Notices 26(6) pp. </journal> <month> 45-58 (June, </month> <year> 1991). </year>
Reference-contexts: These algorithms greatly reduce the cost of measuring programs. Profiling, which counts the number of times each basic block in a program executes, is widely used to measure instruction set utilization of computers, identify program bottlenecks, and estimate program execution times for code optimization <ref> [2, 4, 6, 11, 13, 14, 17] </ref>. Instruction traces are the basis for trace-driven simulation and analysis and are used also in trace-driven debugging [9, 12, 18].
Reference: 14. <author> K. Pettis and R. C. Hanson, </author> <title> Profile Guided Code Positioning, </title> <booktitle> Proceedings of the ACM SIGPLAN '90 Conference on Programming Language Design and Implementation (published as SIGPLAN Notices) 25(6) pp. 16-27 ACM, </booktitle> <month> (June, </month> <year> 1990). </year>
Reference-contexts: These algorithms greatly reduce the cost of measuring programs. Profiling, which counts the number of times each basic block in a program executes, is widely used to measure instruction set utilization of computers, identify program bottlenecks, and estimate program execution times for code optimization <ref> [2, 4, 6, 11, 13, 14, 17] </ref>. Instruction traces are the basis for trace-driven simulation and analysis and are used also in trace-driven debugging [9, 12, 18].
Reference: 15. <author> R. L. Probert, </author> <title> Optimal Insertion of Software Probes in Well-Delimited Programs, </title> <journal> IEEE Transactions on Software Engineering SE-8(1) pp. </journal> <month> 34-42 (January, </month> <year> 1975). </year>
Reference-contexts: We study the problems of optimally solving VF (G, epl), VF (G, vpl), and EF (G, epl). Since there are CFGs for which there are no vpl solutions to EF (G, vpl), it is not considered <ref> [15] </ref>. This section presents three results: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh VF (G, epl) VF (G, vpl)EF (G, epl) VF (G, vpl) EF (G, epl) (b) hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh for general CFGs. <p> The Insertion of Software Probes in Well-Delimited Programs Probert discusses the problem of solving EF (G,vpl) <ref> [15] </ref>, which is not always possible in general. Using graph grammars, he characterizes a set of well-delimited programs for which EF (G, vpl) can always be solved. This class of graphs arises by introducing delimiter vertices into well-structured programs.
Reference: 16. <author> C. V. Ramamoorthy, K. H. Kim, and W. T. Chen, </author> <title> Optimal Placement of Software Monitors Aiding Systematic Testing, </title> <journal> IEEE Transactions on Software Engineering SE-1(4) pp. </journal> <month> 403-410 (December, </month> <year> 1975). </year>
Reference-contexts: Optimal Placement of Traversal Markers Ramamoorthy, Kim, and Chen discuss the problem of instrumenting a single-procedure program with a minimal number of monitors so that the traversal of any path through the program may be ascertained after an execution <ref> [16] </ref>. This is equivalent to the tracing problem for single-procedure programs discussed here. The authors do not give an algorithm for reconstructing an execution from a trace or consider how to handle the problem of tracing multi-procedure programs.
Reference: 17. <author> V. Sarkar, </author> <title> Determining Average Program Execution Times and their Variance, </title> <booktitle> Proceedings of the ACM SIGPLAN '89 Conference on Programming Language Design and Implementation (published as - 27 - SIGPLAN Notices) 24(7) pp. 298-312 ACM, </booktitle> <month> (June 21-23, </month> <year> 1989). </year>
Reference-contexts: These algorithms greatly reduce the cost of measuring programs. Profiling, which counts the number of times each basic block in a program executes, is widely used to measure instruction set utilization of computers, identify program bottlenecks, and estimate program execution times for code optimization <ref> [2, 4, 6, 11, 13, 14, 17] </ref>. Instruction traces are the basis for trace-driven simulation and analysis and are used also in trace-driven debugging [9, 12, 18]. <p> Profiling Using Control Dependence Sarkar describes how to choose profiling points using control dependence and has implemented a profiling tool for the PTRAN system, which uses the profile information to guide the automatic parallelization of FORTRAN programs <ref> [17] </ref>. His algorithm finds a minimum size set of edges epl that solves EF (G, epl) based on a variety of rules relating control dependence and control-flow, as opposed to the spanning tree method given here.
Reference: 18. <author> A. J. Smith, </author> <title> Cache Memories, </title> <journal> ACM Computing Surveys 14(3) pp. </journal> <month> 473-530 </month> <year> (1982). </year>
Reference-contexts: Instruction traces are the basis for trace-driven simulation and analysis and are used also in trace-driven debugging <ref> [9, 12, 18] </ref>. The product of this work is an exact basic block profile or traceas opposed to the Unix prof command, which samples the program counter during program execution and does not produce exact measurements.
Reference: 19. <institution> MIPS Computer Systems, Inc., UMIPS-V Reference Manual (pixie and pixstats), MIPS Computer Systems, </institution> <address> Sunnyvale, CA (1990). </address>
Reference-contexts: The simplest approach places a counter at every basic block (vertex). The counter increments every time the block executes (pixie and other instrumentation tools use this - 4 - method <ref> [19] </ref>). There are two drawbacks to such an approach: too many counters are used and the total number of increments during an execution is larger than necessary. <p> PERFORMANCE This section describes several experiments that demonstrate that the algorithms presented above significantly reduce the cost of profiling and tracing real programs. 5.1. Profiling Performance We implemented the counter placement algorithm for profiling in QP, which is a basic block profiler similar to MIPS's pixie <ref> [19] </ref>. QP can either insert counters in every basic block in a program (slow mode) or along the subset of edges identified by our algorithm (quick mode). We used the SPEC benchmark suite to test QP [3].
Reference: 20. <author> R. E. Tarjan, </author> <title> Data Structures and Network Algorithms, </title> <institution> Society for Industrial and Applied Mathematics, </institution> <address> Philadelphia, PA (1983). </address>
Reference-contexts: The second uses the results from the program's execution to derive a complete profile or trace. Surprisingly, the algorithms for instrumenting a program for profiling and tracing are identical and based on the well-known maximum spanning tree problem applied to the program's control-flow graph <ref> [20] </ref>. <p> A maximum spanning tree G of graph G with weighting W is a spanning tree such that cost (G, E, W) is maximized. The maximum spanning tree for a graph can be computed efficiently by a variety of algorithms <ref> [20] </ref>. been given a weighting as shown by the values accompanying each edge. The second graph is a maximum spanning tree for the given weighting. Note that any vertex in the spanning tree can serve as a root and that the direction of the edges in the tree is unimportant. <p> It is clear that if epl solves EF (G, epl) and minimizes cost (G, epl, W), then E -epl is a maximum spanning tree of G. Any of the well-known maximum spanning tree algorithms described by Tarjan <ref> [20] </ref> will produce the maximum spanning tree of G with respect to weighting W. The edges that are not in the spanning tree (epl) solve EF (G, epl) and minimize cost (G, epl, W).
References-found: 20

