URL: http://www.robotics.stanford.edu/groups/manips/publications/icra94.ps
Refering-URL: http://www.robotics.stanford.edu/groups/manips/home.html
Root-URL: http://www.robotics.stanford.edu
Title: Dynamic Simulation of Interactive Robotic Environment  
Author: Paul U. Lee, Diego C. Ruspini, and Oussama Khatib 
Address: Stanford, CA 94305  
Affiliation: Robotics Laboratory Computer Science Department Stanford University,  
Abstract: A dynamic simulation package has been developed which can accurately model the interactions between robots and their environment. It creates a virtual environment in which various controllers and workcells can be tested. The simulator is divided into two parts: local objects that compute their dynamic equations of motion and a global coordinator that resolves interactive forces between objects. This simulator builds upon previous work on dynamic simulation of simple rigid bodies and extends it to correctly model and efficiently compute the dynamics of multi-link robots. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Baraff, </author> <title> "Analytical methods for dynamic simulation of non-penetrating rigid bodies," </title> <booktitle> Computer Graphics 23, </booktitle> <month> (August </month> <year> 1989), </year> <pages> 223-232. </pages>
Reference-contexts: We have developed a dynamic simulation package to simulate the interactions between robots and other objects in their environment based on dynamic equations of motion with accurate analytical solutions of the constraint equations <ref> [1] </ref>. The dynamic equations of motion can be easily obtained for each object, but interactions (i.e. collision and/or contact) between objects have proved to be more difficult to handle. In recent work, two general approaches have been proposed to address this problem. <p> However, it does not guarantee a physically accurate solution for the dynamic behavior of the objects. The other approach finds analytically correct solutions to the dynamic interactions between rigid bodies by explicitly solving the constraint equations. Baraff <ref> [1] </ref> uses this approach to find constraint forces that prevent inter-penetrations between rigid objects. Although these analytical solutions for rigid body contact yield accurate physical behavior, they are more difficult to implement and are not easily extended to non-rigid bodies. <p> A physically accurate solution is essential in a sim-ulator that is designed to duplicate the motions of real world objects. Since the first approach does not guarantee a physically accurate solution, we have implemented the second approach, which yields accurate analytical solutions <ref> [1] </ref>. Previous algorithms have been developed only for simple rigid-body objects. <p> The collision is resolved by first calculating appropriate impulse forces that correctly model the collisions. If objects remain in contact after the collision is resolved, contact forces are calculated to model the contacts <ref> [1] </ref>. 4 Object Structure The configuration of an n-DOF (degree-of-freedom) object is described by a set q of n independent generalized coordinates. Joint angles are generally used as generalized coordinates for robots, but other sets of parameters that satisfy the above constraints can also be used. <p> The above representation (Eq. 3) finds an efficient solution for robots and other multi-linked objects by taking advantage of well-defined holonomic constraints at their joints. By taking these constraints into account, it solves only for the parameters which affect the dynamics of the system. In contrast, previous works <ref> [1, 3] </ref> treat multi-linked objects as series of simple objects. This approach requires solutions for all the forces, including the internal joint forces, which have no effect on the motion of the system. This unnecessary calculation results in an larger computation time. <p> Therefore the equations of motion are integrated to the time of collision, new values of the generalized velocities _q calculated, and integration continued using the new state. By breaking up the integration at the velocity discontinuity, integration of a stiff set of equations can be avoided. Baraff <ref> [1] </ref> uses three constraint equations for each contact point i to calculate the impulse forces on a body. v + i (6) j i (v + i ) = 0 (8) where * i is the coefficient of restitution, and j i is the magnitude of the impulse force in the <p> Conditions of the con-straint equations (Eq. 6, 7, 8) are such that they can be solved using quadratic programming techniques <ref> [1] </ref>.
Reference: [2] <author> D. Baraff, </author> <title> "Rigid Body Simulation", </title> <booktitle> Lecture Notes for SIGGRAPH '92 Course, </booktitle> <year> (1992). </year>
Reference-contexts: Figure 4 shows two 6 DOF arm robots with appropriate bounding boxes around their links. A naive collision checking implementation, which checks all pairs of objects, produces O (n 2 ) performance, but a sort and sweep algorithm can solve it in O (n log n) <ref> [2] </ref>. Subsequent steps can use an insertion sort for more efficiency. Objects with overlapping bounding boxes require calculation of the minimum distance between them in order to determine inter-penetrations. <p> Baraff uses an algorithm which has O (M 1 M 2 ) performance initially, but uses temporal witnesses to reduce subsequent calculations to O (M ) performance <ref> [2] </ref>. We have implemented an algorithm developed by Gilbert [5], which is considered to be one of the most efficient algorithms for computing distance. <p> Once the impulse forces are found the new generalized velocity can be calculated. _q + = _q + _q (18) While the equations above are for only a simplified environment they can be easily extend to handle multiple, moving, and redundant objects <ref> [2, 10] </ref>. 5.3 Contact Force Resolution If v + i = 0 inter-penetration may still occur if a i = _v + i is negative. When this occurs, the objects are said to be in resting contact.
Reference: [3] <author> R. Barzel and A. H. Barr, </author> <title> "A modeling system based on dynamic constraints," </title> <booktitle> Computer Graphics 22, </booktitle> <month> 4 (August </month> <year> 1988), </year> <pages> 179-188. </pages>
Reference-contexts: The above representation (Eq. 3) finds an efficient solution for robots and other multi-linked objects by taking advantage of well-defined holonomic constraints at their joints. By taking these constraints into account, it solves only for the parameters which affect the dynamics of the system. In contrast, previous works <ref> [1, 3] </ref> treat multi-linked objects as series of simple objects. This approach requires solutions for all the forces, including the internal joint forces, which have no effect on the motion of the system. This unnecessary calculation results in an larger computation time.
Reference: [4] <author> J. Craig, </author> <title> "Introduction to Robotics Mechanics and Control," </title> <publisher> Addison-Wesley Pub. Co., </publisher> <year> 1989. </year>
Reference-contexts: in terms of generalized coordinates are given by = A (q)q + b (q; _q) + g (q) (1) where A (q) designates the kinetic energy matrix, b (q; _q) the centrifugal and Coriolis force vector, g (q) the gravity force vector, and the generalized torque vector of the object <ref> [4] </ref>. <p> The velocity v i (Eq. 5) can be expressed as v i = n T since <ref> [4] </ref> _p i = J i _q (12) where J i is the jacobian that maps _q to the velocity at the i th collision point. <p> The mapping between ext and the applied forces at the contact points <ref> [4] </ref> is given as ext = k=1 i n i f i : (26) Eq. 19, 20, and 21 depend linearly on the unknown forces f i (see Eq. 23, 24, 25, and 26) and have a form similar to the impulse constraint equations (Eq. 6, 7, and 8).
Reference: [5] <author> E. G. Gilbert, et. al., </author> <title> "A Fast Procedure for Computing the Distance between Complex Objects in Three-Dimensional Space," </title> <journal> IEEE J. of Robotics and Automation, Vol.4, </journal> <volume> No. 2, </volume> <month> April </month> <year> 1988. </year>
Reference-contexts: Baraff uses an algorithm which has O (M 1 M 2 ) performance initially, but uses temporal witnesses to reduce subsequent calculations to O (M ) performance [2]. We have implemented an algorithm developed by Gilbert <ref> [5] </ref>, which is considered to be one of the most efficient algorithms for computing distance. <p> For a discussion on finding ext for redundant ma nipulators, and for contacts outside the end effector, see [10]. 6 Implementation Our dynamic simulator is implemented in C on a Silicon Graphics workstation. It uses Gilbert's distance algorithm to find the minimum distance between objects <ref> [5] </ref>. When interaction occurs, the constraint equations (Eq. 6, 7, 8 and 19, 20, 21) are solved using quadratic programming [6]. When the objects are not in contact with each other, they are governed solely by their rigid body dynamics.
Reference: [6] <author> P. Gill, S. Hammarling, W. Murray, M. Saunders and M. Wright, </author> <title> "User's guide to LLSOL," </title> <type> Stanford University Technical Report SOL 86-1, </type> <month> (January </month> <year> 1996). </year>
Reference-contexts: It uses Gilbert's distance algorithm to find the minimum distance between objects [5]. When interaction occurs, the constraint equations (Eq. 6, 7, 8 and 19, 20, 21) are solved using quadratic programming <ref> [6] </ref>. When the objects are not in contact with each other, they are governed solely by their rigid body dynamics. For a given body, these dynamic equations are predetermined and calculated off-line, symbolically using a program based on Kane's formulation [8].
Reference: [7] <author> D. Kahaner, et. al., </author> <title> "Numerical Methods and Software," </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1989. </year>
Reference-contexts: For a given body, these dynamic equations are predetermined and calculated off-line, symbolically using a program based on Kane's formulation [8]. These equations are integrated to obtain position and velocity information. We have used an Adams Bashforth adaptive step-size predictor-corrector ODE integrator <ref> [7] </ref>. We have also developed a graphical user interface (GUI) to make our simulator more accessible to the user. Figure 5 shows our GUI that controls camera views, collision detection, movie record/playback, and simulation. 7 Results We have developed a modeling system to dynamically simulate interactive robotic environments.
Reference: [8] <author> T. Kane, </author> <title> Dynamics: Theory and Applications, </title> <publisher> McGraw-Hill, </publisher> <year> 1985. </year>
Reference-contexts: When the objects are not in contact with each other, they are governed solely by their rigid body dynamics. For a given body, these dynamic equations are predetermined and calculated off-line, symbolically using a program based on Kane's formulation <ref> [8] </ref>. These equations are integrated to obtain position and velocity information. We have used an Adams Bashforth adaptive step-size predictor-corrector ODE integrator [7]. We have also developed a graphical user interface (GUI) to make our simulator more accessible to the user.
Reference: [9] <author> O. Khatib, </author> <title> "A Unified Approach to Motion and Force Control of Robot Manipulators: The Operational Space Formulation," </title> <journal> IEEE J. on Robotics and Automation, </journal> <volume> Vol. 3, No. 1, </volume> <year> 1987. </year>
Reference: [10] <author> O. Khatib, </author> <title> "Object Manipulation in a Multi-Effector Robot System," </title> <booktitle> Int. Sym. of Robotics Research, </booktitle> <address> Santa Cruz, CA, </address> <month> Aug. </month> <year> 1987. </year>
Reference-contexts: Once the impulse forces are found the new generalized velocity can be calculated. _q + = _q + _q (18) While the equations above are for only a simplified environment they can be easily extend to handle multiple, moving, and redundant objects <ref> [2, 10] </ref>. 5.3 Contact Force Resolution If v + i = 0 inter-penetration may still occur if a i = _v + i is negative. When this occurs, the objects are said to be in resting contact. <p> Once the contact forces are found, ext can be computed and the dynamics can be updated to the next time cycle. For a discussion on finding ext for redundant ma nipulators, and for contacts outside the end effector, see <ref> [10] </ref>. 6 Implementation Our dynamic simulator is implemented in C on a Silicon Graphics workstation. It uses Gilbert's distance algorithm to find the minimum distance between objects [5]. When interaction occurs, the constraint equations (Eq. 6, 7, 8 and 19, 20, 21) are solved using quadratic programming [6].
Reference: [11] <author> M. Moore and J. Wilhelms, </author> <title> "Collision detection and response for computer animation," </title> <booktitle> Computer Graphics 22, </booktitle> <year> (1988), </year> <pages> 289-298. </pages>
Reference-contexts: In recent work, two general approaches have been proposed to address this problem. The first approach resolves constraint forces, which keep objects from inter-penetrating, by using "spring-like" repulsion at the collision and/or contact points <ref> [11] </ref>. The advantage of this approach is its ease of implementation and extendibility to non-rigid bodies. However, it does not guarantee a physically accurate solution for the dynamic behavior of the objects.
Reference: [12] <author> M. Orlowski, </author> <title> "The computation of the distance between polyhedra in 3-space," </title> <booktitle> SIAM Conf. on Geometric Modeling and Robotics, Albany, </booktitle> <address> NY, </address> <month> July </month> <year> 1985. </year>
Reference-contexts: Subsequent steps can use an insertion sort for more efficiency. Objects with overlapping bounding boxes require calculation of the minimum distance between them in order to determine inter-penetrations. Orlowski <ref> [12] </ref> uses an algorithm with O (M log M ) performance where M is total number of vertices in the two objects, M = M 1 + M 2 .
References-found: 12

