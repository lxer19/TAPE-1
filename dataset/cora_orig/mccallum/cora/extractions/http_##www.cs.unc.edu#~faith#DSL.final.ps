URL: http://www.cs.unc.edu/~faith/DSL.final.ps
Refering-URL: http://www.cs.unc.edu/~faith/khepera.html
Root-URL: http://www.cs.unc.edu
Email: ffaith,nyland,prinsg@cs.unc.edu  
Title: Khepera: A System for Rapid Implementation of Domain Specific Languages  
Author: Rickard E. Faith Lars S. Nyland Jan F. Prins 
Address: #3175, Sitterson Hall Chapel Hill NC 27599-3175  
Affiliation: Department of Computer Science University of North Carolina CB  
Abstract: The Khepera system is a toolkit for the rapid implementation and long-term maintenance of domain specific languages (DSLs). Our viewpoint is that DSLs are most easily implemented via source-to-source translation from the DSL into another language and that this translation should be based on simple parsing, sophisticated tree-based analysis and manipulation, and source generation using pretty-printing techniques. Khepera emphasizes the use of familiar, pre-existing tools and provides support for transformation replay and debugging for the DSL processor and end-user programs. In this paper, we present an overview of our approach, including implementation details and a short example. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Jon L. Bentley, Lynn W. Jelinski, and Brian W. Kernighan. </author> <title> CHEM|a program for phototype-setting chemical structure diagrams. </title> <journal> Computers and Chemistry, </journal> <volume> 11(4) </volume> <pages> 281-97, </pages> <year> 1987. </year>
Reference-contexts: For example, PIC [8], a classic "little language" for typesetting figures, is translated into troff, a general-purpose typesetting language. Language composition can be extended in either direction: the CHEM language <ref> [1] </ref>, a DSL used for drawing chemical structures, is translated into PIC, while troff is commonly translated into PostScript. Other DSLs translate into general-purpose high-level programming languages.
Reference: [2] <author> Robert D. Cameron. </author> <title> An abstract pretty printer. </title> <journal> IEEE Softw., </journal> <volume> 5(6) </volume> <pages> 61-7, </pages> <month> Nov. </month> <year> 1988. </year>
Reference-contexts: The implementation was straightforward, with modifications added to support source line tracking and formatted pretty-printing. Other algorithms for pretty printing, some of which support a finer-grain control over the formatting, are presented in <ref> [7, 2, 15, 16] </ref>. For each node type in the ast, a short description, using printf-like syntax, tells how to print that node and its children. If the node can have several different numbers of children, several descriptions may be present, one for each variation.
Reference: [3] <author> James R. Cordy and Ian H. </author> <title> Carmichael. The TXL programming language syntax and informal semantics, </title> <type> version 7. </type> <institution> Software Technology Laboratory, Department of Computing and Information Science, Queen's University at Kingston, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: However, these systems usually restrict the scanning and parsing tools used [6]; specify ast transformations using a low-level language, such as C [17] (instead of a high-level transformation-oriented language); or require that the ast always conforms to a single grammar specification, making translation from one language to another difficult <ref> [4, 3, 14] </ref>. Further, some systems rely on an attribute grammars for all ast transformations, without providing for a more general-purpose scheme for tree-pattern matching and replacement.
Reference: [4] <author> James R. Cordy, Charles D. Halpern-Hamu, and Eric Promislow. TXL: </author> <title> a rapid prototyp-ing system for programming language dialects. </title> <journal> Comp. Lang., </journal> <volume> 16(1) </volume> <pages> 97-107, </pages> <month> Jan. </month> <year> 1991. </year>
Reference-contexts: However, these systems usually restrict the scanning and parsing tools used [6]; specify ast transformations using a low-level language, such as C [17] (instead of a high-level transformation-oriented language); or require that the ast always conforms to a single grammar specification, making translation from one language to another difficult <ref> [4, 3, 14] </ref>. Further, some systems rely on an attribute grammars for all ast transformations, without providing for a more general-purpose scheme for tree-pattern matching and replacement.
Reference: [5] <author> Matt Englehart and Mike Jackson. </author> <month> ControlH: </month>
Reference-contexts: Other DSLs translate into general-purpose high-level programming languages. For example, ControlH, a DSL for the domain of real-time Guidance, Navigation, and Control (GN&C) software, translates into Ada <ref> [5] </ref>; and Risla, a DSL for financial engineering, translates into COBOL [18]. The composition of a DSL processor with (for ex ample) a C compiler is attractive because it provides portability over a large class of architectures, while achieving performance through the near universal availability of architecture-specific optimizing C compilers.
References-found: 5

