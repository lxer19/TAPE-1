URL: ftp://ftp.cs.caltech.edu/tr/cs-tr-92-16.ps.Z
Refering-URL: ftp://ftp.cs.caltech.edu/tr/INDEX.html
Root-URL: http://www.cs.caltech.edu
Title: Constructing some Distributed Programs  
Author: H. Peter Hofstee 
Affiliation: Department of Computer Science California Institute of Technology  
Abstract-found: 0
Intro-found: 0
Reference: [1] <author> E.W. Dijkstra, </author> <title> A Discipline of Programming, </title> <publisher> (Prentice Hall, </publisher> <address> Engle-wood Cliffs, NJ 1976). </address>
Reference-contexts: Finally we propose a more efficient solution for the general case. 1.1 Program notation For the sequential part of the algorithms, we use a subset of Edsger W. Dijkstra's guarded command language <ref> [1] </ref>. For (sequential) statements S 0 and S 1, statement S 0kS 1 denotes their concurrent execution. The constituents S 0 and S 1 are then called processes. The statements may share variables (cf. [6]).
Reference: [2] <author> E.W. Dijkstra, </author> <title> Smoothsort, an alternative for sorting in situ, </title> <booktitle> Science of Computer Programming 1, </booktitle> <year> (1982) </year> <month> 223-233. </month>
Reference-contexts: The other difference is that our algorithms are "smooth" (cf. <ref> [2] </ref>) in the sense that the execution time is much less for almost-sorted arrays than for hardly-sorted arrays, with a smooth transition from one to the other behavior. This is due to the conditions under which processes engage in communications. Acknowledgements: We are grateful to Johan J.
Reference: [3] <author> C.A.R. Hoare, </author> <title> Communicating Sequential Processes, </title> <journal> Comm. </journal> <note> ACM (1978) 666-677. </note>
Reference-contexts: We transform our algorithms in such a way, however, that the final code contains no shared variables and all synchronization and communication is performed by message passing. The semantics of the communication primitives is as described in [5]. The main difference with C.A.R. Hoare's proposal in <ref> [3] </ref> is in the naming of channels rather than processes.
Reference: [4] <author> C.A.R. Hoare, </author> <title> Communicating Sequential Processes, </title> <booktitle> (Prentice-Hall International Series in Computer Science, </booktitle> <year> 1985) </year>
Reference-contexts: The semantics of the communication primitives is as described in [5]. The main difference with C.A.R. Hoare's proposal in [3] is in the naming of channels rather than processes. In <ref> [4] </ref>, the same author proposes to name channels instead of processes in communication commands, but differs from our notation by using one name per channel instead of our two: output command R!E in one process is paired with input command L?v in another process by declaring the pair (R; L) to
Reference: [5] <author> A.J. Martin, </author> <title> An axiomatic Definition of Synchronization Primitives, </title> <journal> Acta Informatica 16, </journal> <year> (1981) </year> <month> 219-235. </month> <title> 20 H. </title> <editor> Peter Hofstee, Alain. J. Martin, and Jan L. A. </editor> <publisher> van de Snepscheut </publisher>
Reference-contexts: The statements may share variables (cf. [6]). We transform our algorithms in such a way, however, that the final code contains no shared variables and all synchronization and communication is performed by message passing. The semantics of the communication primitives is as described in <ref> [5] </ref>. The main difference with C.A.R. Hoare's proposal in [3] is in the naming of channels rather than processes. <p> For an arbitrary command A, let c A denote the number of completed A actions, i.e., the number of times that command A has been executed since initiation of the program's execution. The synchronization requirement (cf. 1. Distributed Sorting 5 <ref> [5] </ref>) fulfilled by a channel (R; L) is that c R = c L holds at any point in the computation. Note It is sometimes attractive to weaken the synchronization requirement by putting some bound on c R c L.
Reference: [6] <author> S. Owicki, D. Gries, </author> <title> An Axiomatic Proof Technique for Parallel programs, </title> <journal> Acta Informatica 6, </journal> <year> (1976) </year> <month> 319-340. 2 </month>
Reference-contexts: Dijkstra's guarded command language [1]. For (sequential) statements S 0 and S 1, statement S 0kS 1 denotes their concurrent execution. The constituents S 0 and S 1 are then called processes. The statements may share variables (cf. <ref> [6] </ref>). We transform our algorithms in such a way, however, that the final code contains no shared variables and all synchronization and communication is performed by message passing. The semantics of the communication primitives is as described in [5]. The main difference with C.A.R.
References-found: 6

