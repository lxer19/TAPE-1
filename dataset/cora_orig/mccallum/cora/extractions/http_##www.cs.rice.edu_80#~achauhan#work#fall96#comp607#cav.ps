URL: http://www.cs.rice.edu:80/~achauhan/work/fall96/comp607/cav.ps
Refering-URL: http://www.cs.rice.edu:80/~achauhan/work/courses.html
Root-URL: 
Email: Email: pw@montefiore.ulg.ac.be  
Phone: 4000  Phone: +32-41-562099 Fax: +32-41-562984  
Title: Memory-Efficient Algorithms for the Verification of Temporal Properties  
Author: C. Courcoubetis M. Vardi P. Wolper M. Yannakakis 
Address: Institut Montefiore, B28  Belgium  
Affiliation: Universite de Liege  Liege Sart Tilman  
Note: Contact Author: Pierre Wolper Address:  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> S. Aggarwal, C. Courcoubetis, and P. Wolper. </author> <title> Adding liveness properties to coupled finite-state machines. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(2) </volume> <pages> 303-339, </pages> <year> 1990. </year>
Reference-contexts: This is essential for debugging to be possible. 4 Extensions, Concluding Remarks and Related Work An extension of the verification problem described in Section 2 is the verification of programs with liveness conditions, see <ref> [1] </ref>. In this case the program is given in terms of components, each having it own liveness conditions. Each such component is modeled as a Buchi automaton.
Reference: [2] <author> Alfred V. Aho, John E. Hopcroft, and Jeffrey D. Ullman. </author> <title> The Design and Analysis of Computer Algorithms. </title> <publisher> Addison Wesley, </publisher> <address> Reading, </address> <year> 1974. </year> <month> 15 </month>
Reference-contexts: Unfortunately, we cannot apply Holtzmann's method to the standard algorithm for constructing the strongly connected components of the graph <ref> [2] </ref>. Indeed, although in that algorithm the states of the components are stored in a stack, it requires access to information (depth-first and low-link number) about states randomly placed in the stack, which implies the need of at least O (n log n) bits of randomly accessed memory.
Reference: [3] <author> Alfred V. Aho, John E. Hopcroft, and Jeffrey D. Ullman. </author> <title> Data Struc--tures and Algorithms. </title> <publisher> Addison Wesley, </publisher> <address> Reading, </address> <year> 1982. </year>
Reference-contexts: Another remark is the following. In many applications it is reasonable to assume that the predecessor function of the graph is given as well. In this case one can use the algorithm in Section 6.7 in <ref> [3] </ref> for constructing the strongly connected components of the graph G by using randomly accessed memory of size O (n). Let G r be the directed graph corresponding to G by reversing its edges.
Reference: [4] <author> E. M. Clarke and O. Grumberg. </author> <title> Avoiding the state explosion problem in temporal logic model-checking algorithms. </title> <booktitle> In Proc. 6th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 294-303, </pages> <address> Van-couver, British Columbia, </address> <month> August </month> <year> 1987. </year>
Reference-contexts: Unfortunately, theorem-proving systems are semi-automated at best, and their success at dealing with real-life protocols is not as impressive as that of reachability analysis (cf. [7]). A new approach that emerged in the 1980's is the so-called model-checking approach <ref> [5, 4, 14, 16] </ref>. Model checking is based on the idea that verifying a propositional temporal logic property of a finite-state program amounts to evaluating that formula on the program viewed as a temporal interpretation. <p> This problem, called the state-explosion problem, is the most basic limitation of both approaches. It has been the subject of extensive research both in the context of reachability analysis (cf. [15, 17]) and in the context of model checking (cf. <ref> [4] </ref>). A recent development [9] has substantially pushed back the state-explosion limit for reachability analysis.
Reference: [5] <author> E.M. Clarke, </author> <title> E.A. Emerson, and A.P. Sistla. Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> January </month> <year> 1986. </year>
Reference-contexts: Unfortunately, theorem-proving systems are semi-automated at best, and their success at dealing with real-life protocols is not as impressive as that of reachability analysis (cf. [7]). A new approach that emerged in the 1980's is the so-called model-checking approach <ref> [5, 4, 14, 16] </ref>. Model checking is based on the idea that verifying a propositional temporal logic property of a finite-state program amounts to evaluating that formula on the program viewed as a temporal interpretation.
Reference: [6] <author> P. Godefroid, G. J. Holzmann, and D. Pirottin. </author> <title> State space caching revisited. </title> <booktitle> In Proc. 4th Workshop on Computer Aided Verification, </booktitle> <address> Mon-treal, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Hashing without collision detection is but one technique that reduces the amount of randomly accessed memory needed for a state-space search. Another technique that has been investigated recently is "state-space caching" <ref> [11, 13, 6] </ref>. State-space caching is based on the observation that, when doing 14 a depth-first search of a graph, storing only the states that are on the search stack is sufficient to guarantee that the search terminates. <p> Experimental results, however, show that, below a threshold that is usually between 1=2 and 1=3 of the size of the state space, the run time explodes, unless additional techniques are used to restrict the number of distinct paths that can reach a given state <ref> [6] </ref>. The behavior of state-space caching is quite the opposite of that of the technique we discuss in this paper. Indeed, state-space caching guarantees a correct result, but at the cost of a potentially large increase in the time needed for the state-space search.
Reference: [7] <author> R. Grotz, C. Jard, and C. Lassudrie. </author> <title> Attacking a complex distributed systems from different sides: an experience with complementary validation tools. In Proc. 4th Work. Protocol Specification, Testing, </title> <booktitle> and Verification, </booktitle> <pages> pages 3-17. </pages> <publisher> North-Holland, </publisher> <year> 1984. </year>
Reference-contexts: Unfortunately, theorem-proving systems are semi-automated at best, and their success at dealing with real-life protocols is not as impressive as that of reachability analysis (cf. <ref> [7] </ref>). A new approach that emerged in the 1980's is the so-called model-checking approach [5, 4, 14, 16]. Model checking is based on the idea that verifying a propositional temporal logic property of a finite-state program amounts to evaluating that formula on the program viewed as a temporal interpretation.
Reference: [8] <author> B.T. Hailpern. </author> <title> Tools for verifying network protocols. </title> <editor> In K. Apt, editor, </editor> <booktitle> Logic and Models of Concurrent Systems, NATO ISI Series, </booktitle> <pages> pages 57-76. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: A general approach to protocol verification is to use a theorem-prover for an appropriate logic. Early systems used to focus on input/output behavior of protocols rather than on ongoing behavior (cf. [19]), but systems that are based on temporal logic overcame this shortcoming (cf. <ref> [8] </ref>). Unfortunately, theorem-proving systems are semi-automated at best, and their success at dealing with real-life protocols is not as impressive as that of reachability analysis (cf. [7]). A new approach that emerged in the 1980's is the so-called model-checking approach [5, 4, 14, 16].
Reference: [9] <author> G. Holzmann. </author> <title> An improved protocol reachability analysis technique. </title> <journal> Software Practice and Experience, </journal> <pages> pages 137-161, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: This problem, called the state-explosion problem, is the most basic limitation of both approaches. It has been the subject of extensive research both in the context of reachability analysis (cf. [15, 17]) and in the context of model checking (cf. [4]). A recent development <ref> [9] </ref> has substantially pushed back the state-explosion limit for reachability analysis. <p> This has the advantage of essentially reducing model checking to reachability analysis, though on a state space that is the cross product of the original state space with the state space of an automaton describing the functional specification. It is then possible to adapt techniques inspired by those of <ref> [9] </ref> to solve this problem. However, while Holtzmann's technique is suitable for searching for "bad" states in the state space, model checking involves searching for "bad" cycles. We thus had to develop some special purpose algorithms that are presented here. This paper is organized as follows. <p> The above space can be divided into memory that is randomly accessed and into memory that is sequentially accessed. For example, for implementing a hash table we need randomly accessed memory, while a stack can be implemented with sequentially accessed memory. As correctly pointed out in <ref> [9] </ref>, the bottleneck in the performance of most verification algorithms is directly related to the amount of the randomly accessed memory these algorithms require, and is due to the significant amount of paging involved during the execution of the algorithm. <p> Since there is no collision detection, it follows that the above search is partial; there is always a possibility that a state will be missed. The key assumption behind this method, see <ref> [9] </ref>, is that in general one can choose the value of m large enough and construct a hash function so that the number of collisions becomes arbitrarily small. <p> Hence, given a fixed amount of memory, the size of the problems we could efficiently analyze with the above algorithm is substantially smaller than the size of the problem that can be analyzed with the technique of <ref> [9] </ref>. From the previous discussion the following problem emerges.
Reference: [10] <author> G. Holzmann. </author> <title> Design and Validation of Computer Protocols. </title> <publisher> Prentice-Hall International Editions, </publisher> <year> 1991. </year>
Reference-contexts: To be able to describe our algorithms, we need more details about Buchi automata and how to check their emptiness. A Buchi automaton is a tuple A = (; S; ; s 0 ; F ), where 2 <ref> [10] </ref> is a detailed introduction to the verification of finite-state systems. <p> As the analysis above shows, this is not possible if we just assume that the hash function is random. It can however 4 Actually, <ref> [10] </ref> recommends 2 bits per state. This means using two hash tables, each containing one bit per state and addressed with its own hash function. A collision then only occurs if there is a collision in both hash tables.
Reference: [11] <author> G. J. Holzmann. </author> <title> Tracing protocols. </title> <journal> AT&T Technical Journal, </journal> <volume> 64(12) </volume> <pages> 2413-2434, </pages> <year> 1985. </year>
Reference-contexts: Hashing without collision detection is but one technique that reduces the amount of randomly accessed memory needed for a state-space search. Another technique that has been investigated recently is "state-space caching" <ref> [11, 13, 6] </ref>. State-space caching is based on the observation that, when doing 14 a depth-first search of a graph, storing only the states that are on the search stack is sufficient to guarantee that the search terminates.
Reference: [12] <author> C. Jard and T. Jeron. </author> <title> On-line model-checking for finite linear temporal logic specifications. In Automatic Verification Methods for Finite State Systems, </title> <booktitle> Proc. Int. Workshop, Grenoble, </booktitle> <volume> volume 407, </volume> <pages> pages 189-196, </pages> <address> Grenoble, </address> <month> June </month> <year> 1989. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag. </publisher> <pages> 16 </pages>
Reference-contexts: It is sufficient to keep just enough information for checking that condition 4 above is satisfied. This is exactly what the algorithms we present in Section 3 will do. The advantages of reducing model checking to a reachability problem are also investigated in <ref> [12] </ref>, but only for pure safety properties. In that case, it is sufficient to check that some states are simply reachable and the algorithms we develop in this paper are not needed.
Reference: [13] <author> C. Jard and T. Jeron. </author> <title> Bounded-memory algorithms for verification on the fly. </title> <booktitle> In Proc. Workshop on Computer Aided Verification, </booktitle> <address> Aalborg, </address> <month> July </month> <year> 1991. </year>
Reference-contexts: Hashing without collision detection is but one technique that reduces the amount of randomly accessed memory needed for a state-space search. Another technique that has been investigated recently is "state-space caching" <ref> [11, 13, 6] </ref>. State-space caching is based on the observation that, when doing 14 a depth-first search of a graph, storing only the states that are on the search stack is sufficient to guarantee that the search terminates.
Reference: [14] <author> O. Lichtenstein and A. Pnueli. </author> <title> Checking that finite state concurrent programs satisfy their linear specification. </title> <booktitle> In Proceedings of the Twelfth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 97-107, </pages> <address> New Orleans, </address> <month> January </month> <year> 1985. </year>
Reference-contexts: Unfortunately, theorem-proving systems are semi-automated at best, and their success at dealing with real-life protocols is not as impressive as that of reachability analysis (cf. [7]). A new approach that emerged in the 1980's is the so-called model-checking approach <ref> [5, 4, 14, 16] </ref>. Model checking is based on the idea that verifying a propositional temporal logic property of a finite-state program amounts to evaluating that formula on the program viewed as a temporal interpretation.
Reference: [15] <author> M.T. Liu. </author> <title> Protocol engineering. </title> <booktitle> Advances in Computing, </booktitle> <volume> 29 </volume> <pages> 79-195, </pages> <year> 1989. </year>
Reference-contexts: 1 Introduction Reachability analysis is one of the most successful strategies for analyzing and validating computer protocols. It was first proposed by West [24], and further studied by many researchers (cf. <ref> [15, 17] </ref>. Reachability analysis is applied to a protocol by systematically exercising all the protocol transitions. Such analysis can detect syntactical errors such as static deadlock, unspecified reception, or unexercised code. The simplicity of the strategy lends itself to easy implementation. <p> This problem, called the state-explosion problem, is the most basic limitation of both approaches. It has been the subject of extensive research both in the context of reachability analysis (cf. <ref> [15, 17] </ref>) and in the context of model checking (cf. [4]). A recent development [9] has substantially pushed back the state-explosion limit for reachability analysis.
Reference: [16] <author> J.P. Quielle and J. Sifakis. </author> <title> Specification and verification of concurrent systems in cesar. </title> <booktitle> In Proc. 5th Int'l Symp. on Programming, </booktitle> <volume> volume 137, </volume> <pages> pages 337-351. </pages> <note> Springer-Verlag, Lecture Notes in Computer Science, </note> <year> 1981. </year>
Reference-contexts: Unfortunately, theorem-proving systems are semi-automated at best, and their success at dealing with real-life protocols is not as impressive as that of reachability analysis (cf. [7]). A new approach that emerged in the 1980's is the so-called model-checking approach <ref> [5, 4, 14, 16] </ref>. Model checking is based on the idea that verifying a propositional temporal logic property of a finite-state program amounts to evaluating that formula on the program viewed as a temporal interpretation.
Reference: [17] <author> H. </author> <title> Rudin. Network protocols and tools to help produce them. </title> <booktitle> Annual Review of Computer Science, </booktitle> <volume> 2 </volume> <pages> 291-316, </pages> <year> 1987. </year>
Reference-contexts: 1 Introduction Reachability analysis is one of the most successful strategies for analyzing and validating computer protocols. It was first proposed by West [24], and further studied by many researchers (cf. <ref> [15, 17] </ref>. Reachability analysis is applied to a protocol by systematically exercising all the protocol transitions. Such analysis can detect syntactical errors such as static deadlock, unspecified reception, or unexercised code. The simplicity of the strategy lends itself to easy implementation. <p> This problem, called the state-explosion problem, is the most basic limitation of both approaches. It has been the subject of extensive research both in the context of reachability analysis (cf. <ref> [15, 17] </ref>) and in the context of model checking (cf. [4]). A recent development [9] has substantially pushed back the state-explosion limit for reachability analysis.
Reference: [18] <author> H. Rudin and C.H. West. </author> <title> A validation technique for tightly-coupled protocols. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-312:630-636, </volume> <year> 1982. </year>
Reference-contexts: To apply reachability analysis to such a task, one first has to manually translate the functional specification to a property of the protocol state graph. While this can be done for some specific specifications (cf. <ref> [18] </ref>), it is not a general approach. A general approach to protocol verification is to use a theorem-prover for an appropriate logic.
Reference: [19] <author> C.A. Sunshine. </author> <title> Experience with automated protocol verification. </title> <booktitle> In Proceedings of the International Conference on Communication, </booktitle> <pages> pages 1306-1310, </pages> <year> 1983. </year>
Reference-contexts: While this can be done for some specific specifications (cf. [18]), it is not a general approach. A general approach to protocol verification is to use a theorem-prover for an appropriate logic. Early systems used to focus on input/output behavior of protocols rather than on ongoing behavior (cf. <ref> [19] </ref>), but systems that are based on temporal logic overcame this shortcoming (cf. [8]). Unfortunately, theorem-proving systems are semi-automated at best, and their success at dealing with real-life protocols is not as impressive as that of reachability analysis (cf. [7]).
Reference: [20] <author> Andre Thayse and et al. </author> <title> From Modal Logic to Deductive Databases: Introducing a Logic Based Approach to Artificial Intelligence. </title> <publisher> Wiley, </publisher> <year> 1989. </year>
Reference-contexts: A description of temporal logic and of the construction of automata from temporal logic formulas can be found in [26] and in Chapter 4 of <ref> [20] </ref>. Let thus A :f = (; S; ; s 0 ; F ) be the Buchi automaton constructed from the negation of the formula f .
Reference: [21] <author> M. Vardi. </author> <title> Unified verification theory. </title> <editor> In B. Banieqbal, H. Barringer, and A. Pnueli, editors, </editor> <booktitle> Proc. Temporal Logic in Specification, </booktitle> <volume> volume 398, </volume> <pages> pages 202-212. </pages> <booktitle> Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: As 1 actually, in the size of the global state-space of the program which can be exponential in the size of the program presented as a set of concurrent processes 2 was shown later in the automata-theoretic approach of <ref> [21, 22, 26] </ref>, model checking can be viewed as an augmented reachability analysis; the model-checking algorithm uses the temporal logic specification to guide the search of the protocol state space in order to verify that the protocol satisfies its functional specification. <p> In this paper, we show that model checking can also benefit from a similar reduction in the required randomly accessed memory. This result is obtained by a combination of techniques. We approach model checking from the automata-theoretic perspective of <ref> [21, 22, 26] </ref>. This has the advantage of essentially reducing model checking to reachability analysis, though on a state space that is the cross product of the original state space with the state space of an automaton describing the functional specification.
Reference: [22] <author> M.Y. Vardi and P. Wolper. </author> <title> An automata-theoretic approach to automatic program verification. </title> <booktitle> In Proc. Symp. on Logic in Computer Science, </booktitle> <pages> pages 322-331, </pages> <address> Cambridge, </address> <month> june </month> <year> 1986. </year>
Reference-contexts: As 1 actually, in the size of the global state-space of the program which can be exponential in the size of the program presented as a set of concurrent processes 2 was shown later in the automata-theoretic approach of <ref> [21, 22, 26] </ref>, model checking can be viewed as an augmented reachability analysis; the model-checking algorithm uses the temporal logic specification to guide the search of the protocol state space in order to verify that the protocol satisfies its functional specification. <p> In this paper, we show that model checking can also benefit from a similar reduction in the required randomly accessed memory. This result is obtained by a combination of techniques. We approach model checking from the automata-theoretic perspective of <ref> [21, 22, 26] </ref>. This has the advantage of essentially reducing model checking to reachability analysis, though on a state space that is the cross product of the original state space with the state space of an automaton describing the functional specification. <p> We can construct a Buchi automaton B with kjSj states, such that the emptiness of B is equivalent with the emptiness of P fi A :f (see for instance <ref> [22] </ref>). * The graph of B consists of k copies of G with the transitions modified as follows. Consider the k copies G 1 ; : : : ; G k of G.
Reference: [23] <author> M.Y. Vardi and P. Wolper. </author> <title> Reasoning about infinite computation paths. </title> <institution> IBM Research Report RJ6209, </institution> <year> 1988. </year> <month> 17 </month>
Reference-contexts: From the definition of Buchi automata, it is relatively easy to see that a Buchi automaton is nonempty iff it has some state f 2 F that is reachable from the initial state and reachable from itself (in one or more steps) <ref> [23] </ref>. In graph-theoretic terms, this means that the graph representing the automaton has a reachable cycle that contains at least one state in F . In what follows, we will give a memory-efficient algorithm to solve this problem.
Reference: [24] <author> C.H. West. </author> <title> Generalized technique for communication protocol valida-tion. </title> <journal> IBM J. of Res. and Devel., </journal> <volume> 22 </volume> <pages> 393-404, </pages> <year> 1978. </year>
Reference-contexts: 1 Introduction Reachability analysis is one of the most successful strategies for analyzing and validating computer protocols. It was first proposed by West <ref> [24] </ref>, and further studied by many researchers (cf. [15, 17]. Reachability analysis is applied to a protocol by systematically exercising all the protocol transitions. Such analysis can detect syntactical errors such as static deadlock, unspecified reception, or unexercised code. The simplicity of the strategy lends itself to easy implementation.
Reference: [25] <author> C.H. West and P. Zafiropulo. </author> <title> Automated validation of a communication protocol: the ccitt x.21 recommendation. </title> <journal> IBM Journal of Research and Development, </journal> <volume> 22 </volume> <pages> 60-71, </pages> <year> 1978. </year>
Reference-contexts: Such analysis can detect syntactical errors such as static deadlock, unspecified reception, or unexercised code. The simplicity of the strategy lends itself to easy implementation. Indeed, automated reachability analyses detected errors in published standards such as the X.21 (cf. <ref> [25] </ref>). The approach is less successful when it comes to protocol verification, i.e., verifying that the given protocol achieves its functional specification. This limitation is due to the fact that a functional specification cannot be directly checked by reachability analysis.
Reference: [26] <author> P. Wolper. </author> <title> On the relation of programs and computations to models of temporal logic. </title> <editor> In B. Banieqbal, H. Barringer, and A. Pnueli, editors, </editor> <booktitle> Proc. Temporal Logic in Specification, </booktitle> <volume> volume 398, </volume> <pages> pages 75-123. </pages> <booktitle> Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1989. </year> <month> 18 </month>
Reference-contexts: As 1 actually, in the size of the global state-space of the program which can be exponential in the size of the program presented as a set of concurrent processes 2 was shown later in the automata-theoretic approach of <ref> [21, 22, 26] </ref>, model checking can be viewed as an augmented reachability analysis; the model-checking algorithm uses the temporal logic specification to guide the search of the protocol state space in order to verify that the protocol satisfies its functional specification. <p> In this paper, we show that model checking can also benefit from a similar reduction in the required randomly accessed memory. This result is obtained by a combination of techniques. We approach model checking from the automata-theoretic perspective of <ref> [21, 22, 26] </ref>. This has the advantage of essentially reducing model checking to reachability analysis, though on a state space that is the cross product of the original state space with the state space of an automaton describing the functional specification. <p> A description of temporal logic and of the construction of automata from temporal logic formulas can be found in <ref> [26] </ref> and in Chapter 4 of [20]. Let thus A :f = (; S; ; s 0 ; F ) be the Buchi automaton constructed from the negation of the formula f .
References-found: 26

