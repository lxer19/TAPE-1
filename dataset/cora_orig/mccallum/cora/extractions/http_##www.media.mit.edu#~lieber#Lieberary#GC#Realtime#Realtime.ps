URL: http://www.media.mit.edu/~lieber/Lieberary/GC/Realtime/Realtime.ps
Refering-URL: http://www.media.mit.edu/~lieber/Lieberary/GC/GC.html
Root-URL: http://www.media.mit.edu
Title: A Real-Time Garbage Collector Based on the Lifetimes of Objects  
Author: HENRY LIEBERMAN AND CARL HEWITT Henry Lieberman 
Note: is a Research Scientist at the MIT Artificial Intelligence Laboratory. His research interests include artificial intelligence, programming environments, computer systems for education and beginning users, and computer graphics. Arpa Network address: HENRY@MIT-AI or HENRY@MIT-ML. Carl Hewitt is Professor of Computer Science at MIT. His research interests include message-passing semantics, open systems, organization theory, artificial intelligence, and scientific communities. Arpa Network address: CARL@MIT-AI.  
Affiliation: MIT Artificial Intelligence Laboratory  
Abstract: In previous heap storage systems, the cost of creating objects and garbage collection is independent of the lifetime of the object. Since objects with short lifetimes account for a large portion of storage use, it is worth optimizing a garbage collector to reclaim storage for these objects more quickly. The garbage collector should spend proportionately less effort reclaiming objects with longer lifetimes. We present a garbage collection algorithm that (1) makes storage for short-lived objects cheaper than storage for long-lived objects, (2) that operates in real-time-object creation and access times are bounded, (3) increases locality of reference, for better virtual memory performance, (4) works well with multiple processors and a large address space. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Allen, J. </author> <title> Anatomy of Lisp. </title> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: Others are used by programs to store temporary results: these objects are created, used for a short while, then are no longer needed. These short-lived objects account for a large proportion of storage use. The traditional garbage collection algorithms <ref> [1] </ref> have the defect that storage for objects with short lifetimes is just as costly as storage for objects with long lifetimes. When an object becomes inaccessible, the time needed to recover it is independent of the lifetime of the object.
Reference: 2. <author> Attardi, G., and Hewitt, C. </author> <title> Knowledge embedding in the description system OMEGA. </title> <booktitle> Presented at the American Association for Artificial Intelligence Conf., </booktitle> <institution> Stanford Univ., Stanford, Calif., </institution> <year> 1980. </year>
Reference-contexts: Once an assertion is made, it remains forever, though belief in the assertion may be renounced by further processing. Description languages such as KRL [7] or OMEGA <ref> [2] </ref> currently have this characteristic as well. (However, future versions of ETHER and OMEGA are developing a notion of viewpoints, which may allow some knowledge to become inaccessible and be reclaimed.) These languages have not yet been applied to sufficiently large problems so that reclamation becomes an important issue in present
Reference: 3. <author> Baker, H. </author> <title> Actor systems for real time computation. </title> <type> Tech. </type> <institution> Rept. TR-197, MIT Lab. for Computer Science, </institution> <address> Cambridge, Mass., </address> <year> 1978. </year>
Reference: 4. <author> Baker, H.G. </author> <title> List processing in real time on a serial computer. </title> <journal> Commun. ACM 21, </journal> <month> 4 (April </month> <year> 1978) </year> <month> 280-294. </month>
Reference-contexts: Some have also proposed more complicated systems which combine reference counts with garbage collection [10, 24]. Our garbage collector incorporates a simple extension to a garbage collection algorithm devised by Baker <ref> [4] </ref>. Baker's garbage collector performs garbage collection in real time the elementary object creation and access operations take time which is bounded by a constant, regardless of the size of the memory.
Reference: 5. <author> Baker, H. </author> <title> The paging behavior of the Cheney list copying algorithm. </title> <type> Tech. Note 1, </type> <institution> Symbolics, Inc., </institution> <address> Cambridge, Mass., </address> <year> 1980. </year>
Reference-contexts: Our algorithm is at least no worse in this respect than Baker's since the rate of condemnation can always be adjusted so that the average number of evacuations per object is comparable. Baker <ref> [5] </ref> considers another criterion for the efficiency of garbage collection: the density of accessible objects. A garbage collector is good if it maintains a high proportion of accessible objects to inaccessible objects in the address space, especially in primary memory for virtual memory systems.
Reference: 6. <author> Bishop, P. </author> <title> Computer systems with a very large address space and garbage collection. </title> <type> Tech. </type> <institution> Rept. TR-l78 MIT Lab. for Computer Science, </institution> <address> Cambridge, Mass., </address> <month> May </month> <year> 1977. </year>
Reference-contexts: We would also like a garbage collection algorithm that will work well on machines with a very large address space <ref> [6] </ref>. We believe these properties will be essential in making garbage collection practical on the next generation of computers.
Reference: 7. <author> Bobrow, D., and Winograd, T. </author> <title> An overview of KRL: A language for knowledge representation. </title> <booktitle> Cognitive Science 1, </booktitle> <year> (1977). </year>
Reference-contexts: Once an assertion is made, it remains forever, though belief in the assertion may be renounced by further processing. Description languages such as KRL <ref> [7] </ref> or OMEGA [2] currently have this characteristic as well. (However, future versions of ETHER and OMEGA are developing a notion of viewpoints, which may allow some knowledge to become inaccessible and be reclaimed.) These languages have not yet been applied to sufficiently large problems so that reclamation becomes an important
Reference: 8. <author> Burstall, R.M., and Darlington, J.L. </author> <title> A transformation system for developing recursive programs. </title> <journal> J. ACM 24, </journal> <month> 1 (Jan. </month> <year> 1977), </year> <pages> 24-77. </pages> <note> 9. </note> <author> deKleer, J., Doyle, J., Rich, C., Steele, G., and Sussman, G. </author> <title> AMORD-A deductive procedure system. </title> <type> Memo 435. </type> <institution> MIT Artificial Intelligence Lab., </institution> <address> Cambridge, Mass., </address> <month> Jan. </month> <year> 1978. </year>
Reference-contexts: Another approach for reducing inefficiency due to creating objects to store intermediate results is program transformation <ref> [8, 14] </ref>. The hope is that a smart compiler could replace a program which uses temporary storage with another equivalent version that did not, much as in our two versions of matrix multiplication.
Reference: 10. <author> Deutsch, L.P., and Bobrow, D.G. </author> <title> An efficient, incremental, automatic garbage collector. </title> <journal> Commun. ACM 19, </journal> <month> 9 (Sept. </month> <year> 1976). </year> <pages> 522-526. </pages>
Reference-contexts: If a large proportion of the objects which are created are eventually lost, garbage collectors which trace the accessible objects will be preferred to reference counts, which trace the inaccessible objects. Some have also proposed more complicated systems which combine reference counts with garbage collection <ref> [10, 24] </ref>. Our garbage collector incorporates a simple extension to a garbage collection algorithm devised by Baker [4]. Baker's garbage collector performs garbage collection in real time the elementary object creation and access operations take time which is bounded by a constant, regardless of the size of the memory.
Reference: 11. <author> Dijkstra, E., Lamport, L. et al. </author> <title> On-the-fly garbage collection: An exercise in cooperation. </title> <journal> Commun. ACM 21, </journal> <volume> 11 (Nov. </volume> <year> 1978), </year> <pages> 966-975. </pages>
Reference: 12. <author> Friedman, D., and Wise, D. </author> <title> Garbage collecting a heap which includes a scatter table. </title> <journal> Inf. Process. Lett. </journal> <volume> 5, </volume> <month> 6 (Dec. </month> <year> 1976). </year>
Reference: 13. <author> Greenblatt, R., Knight, T., Holloway, J., and Moon, D. </author> <title> A Lisp Machine. </title> <booktitle> Presented at the Workshop on Computer Architecture for Non-Numeric Processing, </booktitle> <address> Pacific Grove, Calif., </address> <month> March </month> <year> 1980. </year>
Reference-contexts: We believe these properties will be essential in making garbage collection practical on the next generation of computers. The suggestions described in this paper are currently being explored for implementation on the Lisp Machine <ref> [13, 25] </ref>, a high performance personal computer currently in use at MIT, and on the Apiary [16], a proposed multiprocessor machine for objectoriented programming. 2. A REVIEW OF BAKER'S ALGORITHM Baker proposes the address space be divided into fromspace and tospace. <p> There is some flexibility about the order in which scavenging is performed. We would probably recommend always scavenging the oldest objects first. Paging during scavenging might be reduced by adopting a suggestion of Greenblatt's <ref> [13] </ref>, or a similar one by Knuth [19], which would always prefer scavenging a resident page to one which is out on the disk.
Reference: 14. <author> Guibas, L., and Wyatt, D. </author> <title> Compilation and delayed evaluation in APL. </title> <booktitle> Presented at the 5th ACM Conf. Principles of Programming Languages, </booktitle> <year> 1978. </year>
Reference-contexts: Another approach for reducing inefficiency due to creating objects to store intermediate results is program transformation <ref> [8, 14] </ref>. The hope is that a smart compiler could replace a program which uses temporary storage with another equivalent version that did not, much as in our two versions of matrix multiplication.
Reference: 15. <author> Hewitt, C. </author> <title> Viewing control structures as patterns of passing messages. </title> <editor> In P. Winston and R. Brown (Eds.), </editor> <booktitle> Artificial Intelligence: </booktitle> <publisher> An MIT Perspective, MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1979. </year>
Reference-contexts: We were led to work on the garbage collection problem because of the performance needs of applications in artificial intelligence (Al). The performance of the new generation of objectoriented, message-passing systems, which we believe to be the best vehicle for Al applications <ref> [15, 17, 20] </ref>, will rely increasingly on the efficiency of storage for short-lived objects. Programs that do a lot of internal "thinking" will need lots of short-lived objects as "thinking material" before they commit themselves to decisions.
Reference: 16. <author> Hewitt, C. </author> <title> The Apiary network architecture for knowledgeable systems. </title> <booktitle> In Proc. 1980 Lisp Conf., </booktitle> <institution> Stanford Univ., Stanford, Calif., </institution> <year> 1980. </year>
Reference-contexts: The suggestions described in this paper are currently being explored for implementation on the Lisp Machine [13, 25], a high performance personal computer currently in use at MIT, and on the Apiary <ref> [16] </ref>, a proposed multiprocessor machine for objectoriented programming. 2. A REVIEW OF BAKER'S ALGORITHM Baker proposes the address space be divided into fromspace and tospace. Objects are created (by operations like Lisp's CONS) from successive memory locations in tospace. <p> Evacuation operations on the memory must have sufficient synchronization to prevent this. We prefer a multiprocessor architecture such as the Apiary <ref> [16] </ref> in which each worker processor has its own memory, not shared by other processors. We will briefly describe how our algorithm can be extended to operate on such a machine.
Reference: 17. <author> Ingalls, D. </author> <title> The smalltalk-76 programming system: </title> <booktitle> Design and implementation. Presented at the 5th ACM Conf. Principles of Programming Languages, </booktitle> <year> 1978. </year>
Reference-contexts: We were led to work on the garbage collection problem because of the performance needs of applications in artificial intelligence (Al). The performance of the new generation of objectoriented, message-passing systems, which we believe to be the best vehicle for Al applications <ref> [15, 17, 20] </ref>, will rely increasingly on the efficiency of storage for short-lived objects. Programs that do a lot of internal "thinking" will need lots of short-lived objects as "thinking material" before they commit themselves to decisions.
Reference: 18. <author> Kornfeld, W. </author> <title> EtherA parallel problem solving system. </title> <booktitle> Presented at the 6th Joint Conf. Artificial Intelligence, </booktitle> <address> Tokyo, Japan, </address> <month> Aug. </month> <year> 1979. </year>
Reference-contexts: Several recently developed languages for artificial intelligence research produce some types of data which never become inaccessible. Current implementations of new pattern-directed invocation languages like AMORD [9] or ETHER <ref> [18] </ref> do not have any operations that completely remove or let go of assertions in the database. Once an assertion is made, it remains forever, though belief in the assertion may be renounced by further processing.
Reference: 19. <author> Knuth, D. </author> <title> Garbage collection in real time. Class handout for course CS144C. </title> <institution> Stanford Univ., Stanford, Calif., </institution> <month> Spring </month> <year> 1981. </year>
Reference-contexts: There is some flexibility about the order in which scavenging is performed. We would probably recommend always scavenging the oldest objects first. Paging during scavenging might be reduced by adopting a suggestion of Greenblatt's [13], or a similar one by Knuth <ref> [19] </ref>, which would always prefer scavenging a resident page to one which is out on the disk.
Reference: 20. <author> Lieberman, H. </author> <title> A preview of act 1. </title> <type> AI Memo 625, </type> <institution> MIT Artificial Intelligence Lab., </institution> <address> Cambridge, Mass., </address> <year> 1980. </year>
Reference-contexts: We were led to work on the garbage collection problem because of the performance needs of applications in artificial intelligence (Al). The performance of the new generation of objectoriented, message-passing systems, which we believe to be the best vehicle for Al applications <ref> [15, 17, 20] </ref>, will rely increasingly on the efficiency of storage for short-lived objects. Programs that do a lot of internal "thinking" will need lots of short-lived objects as "thinking material" before they commit themselves to decisions.
Reference: 21. <author> Lucassen, J.M. </author> <title> Improvements to the Lieberman-Hewitt garbage collector. Term Paper for MIT course 6.845, </title> <month> May </month> <year> 1981. </year>
Reference-contexts: There are several alternatives, and here we present a suggestion of Lucassen's <ref> [21] </ref>: if we record the name of the region of the originating object with each entry in the entry table, we have a means of detecting inaccessible pointers in the entry table.
Reference: 22. <author> Moon, D. </author> <title> MacLisp Reference Manual. </title> <institution> MIT Lab. for Computer Science. </institution> <address> Cambridge, Mass., </address> <year> 1980. </year>
Reference: 23. <author> Moses, J. </author> <title> The function of Function in Lisp. Memo, </title> <journal> ACM SIGSAM Bull., </journal> <month> July, </month> <year> 1970. </year>
Reference-contexts: The storage used for the arguments on the stack is immediately reusable as soon as the function returns. However, sticking to a strict stack discipline has its well-known problems, leading to the traditional funarg problem of Lisp <ref> [23] </ref>. Objectoriented languages do not follow a stack discipline, and we would like temporary storage in these languages to be efficient. There is currently a sharp discrepancy between cheap stack storage and expensive heap storage.
Reference: 24. <author> Snyder, A. </author> <title> An objectoriented machine architecture. </title> <type> Tech. </type> <institution> Rept. TR-209, MIT Lab for Computer Science, </institution> <address> Cambridge, Mass., </address> <year> 1979. </year>
Reference-contexts: If a large proportion of the objects which are created are eventually lost, garbage collectors which trace the accessible objects will be preferred to reference counts, which trace the inaccessible objects. Some have also proposed more complicated systems which combine reference counts with garbage collection <ref> [10, 24] </ref>. Our garbage collector incorporates a simple extension to a garbage collection algorithm devised by Baker [4]. Baker's garbage collector performs garbage collection in real time the elementary object creation and access operations take time which is bounded by a constant, regardless of the size of the memory.
Reference: 25. <author> Weinreb, D., and Moon, D. </author> <title> Lisp Machine Manual. </title> <institution> MIT Artificial Intelligence Lab., </institution> <address> Cambridge. Mass., </address> <year> 1978. </year>
Reference-contexts: We believe these properties will be essential in making garbage collection practical on the next generation of computers. The suggestions described in this paper are currently being explored for implementation on the Lisp Machine <ref> [13, 25] </ref>, a high performance personal computer currently in use at MIT, and on the Apiary [16], a proposed multiprocessor machine for objectoriented programming. 2. A REVIEW OF BAKER'S ALGORITHM Baker proposes the address space be divided into fromspace and tospace.

References-found: 24

