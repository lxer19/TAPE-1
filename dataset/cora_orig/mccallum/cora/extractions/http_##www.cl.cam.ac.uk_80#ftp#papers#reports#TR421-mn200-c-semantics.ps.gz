URL: http://www.cl.cam.ac.uk:80/ftp/papers/reports/TR421-mn200-c-semantics.ps.gz
Refering-URL: http://www.cl.cam.ac.uk:80/ftp/papers/reports/
Root-URL: 
Title: An abstract dynamic semantics for C  
Author: Michael Norrish 
Note: Contents  
Date: May 6, 1997  
Address: Cambridge  
Affiliation: Computer Laboratory, University of  
Abstract: This report is a presentation of a formal semantics for the C programming language. The semantics has been defined operationally in a structured semantics style and covers the bulk of the core of the language. The semantics has been developed in a theorem prover (HOL), where some expected consequences of the language definition have been proved. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> American National Standards Institute, </institution> <address> 1430 Broadway, New York, NY 10018, USA. </address> <booktitle> American National Standard Programming Language C, ANSI X3.159-1989, </booktitle> <month> December </month> <year> 1989. </year>
Reference-contexts: 1 Introduction This work presents a formal description of the C language <ref> [1] </ref> in the tradition of the formal definition of SML [17]. It is significant in two important ways. Firstly, it is a demonstration that a language as complicated and as inherently unco-operative as C can nonetheless be treated formally. <p> It also suggests that mechanical work on real world verification problems may not be the practical impossibility that common wisdom suggests. The C programming language was first fully defined in 1989, in the ANSI standard <ref> [1] </ref>, subsequently adopted as an ISO standard [15]. However it had been in existence for a long time prior to that date. <p> However it had been in existence for a long time prior to that date. The very effort of standardisation was made "to promote portability, reliability, maintainability, and efficient execution of C language programs on a variety of computing systems" <ref> [1, abstract] </ref>, an effort necessary because of the danger of diverging language implementations blurring exactly what was and was not a C program. <p> Each of the three is described below, and the way in which each form of behaviour is dealt with in Cholera is sketched (c.f. the glossary in <ref> [1, x1.6] </ref>): Implementation-defined: An implementation-defined construct is one which must have a definite meaning, but one for which the standard has passed responsibility to the implementation. The implementation is required to document its choice of meaning. An example is the byte-ordering within multi-byte numeric objects (big-endian vs little-endian).
Reference: [2] <author> Michael A. Arbib and Suad Alagic. </author> <title> Proof rules for gotos. </title> <journal> Acta Informatica, </journal> <volume> 11(2) </volume> <pages> 139-148, </pages> <year> 1979. </year>
Reference-contexts: An example of this is the presentation of a wp semantics for a language with an exit statement [16]. Earlier work along the same lines is found in <ref> [2] </ref>. In C, one would want triples with four postconditions, corresponding to the three different forms of interruption and normal execution. 3.3 Purity analysis Expressions cause would-be "axiomatic" rules about C so much difficulty because they might cause side effects.
Reference: [3] <author> Paul Black and Phil Windley. </author> <title> Inference rules for programming languages with side effects. </title> <editor> In J. von Wright, J. Grundy, and J. Harrison, editors, </editor> <title> Theorem proving in higher order logics. </title> <booktitle> 9th international conference, TPHOLs 96, volume 1125 of Lecture notes in computer science, </booktitle> <pages> pages 51-60. </pages> <publisher> Springer, </publisher> <month> August </month> <year> 1996. </year>
Reference-contexts: A number of other authors have attempted to formalise some aspect of C. However, none of them address the modelling of sequence points and side effects in expression evaluation. The only work for which this is probably not a significant issue is that of Black <ref> [3] </ref>, where the attempt is to describe C at a much higher level than this work. Here, an axiomatic semantics is developed ex nihilo, and expressions are char-acterised at a much higher level than in Cholera. In other work, the details of expression evaluation are simply not correct. <p> Because Cholera doesn't deal with system and library calls, this verification can't attempt anything like the thttpd code of <ref> [3] </ref>, but will rather look at the C code written by John Harrison as part of his work on binary decision diagrams in [13].
Reference: [4] <author> Hans-Juergen Boehm. </author> <title> Side effects and aliasing can have simple axiomatic descriptions. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(4) </volume> <pages> 637-655, </pages> <month> October </month> <year> 1985. </year>
Reference-contexts: Unfortunately, was has no obvious nice properties that might allow it be the basis for a C reasoning system. In particular, it doesn't seem likely that a system such as the one presented in Boehm's work <ref> [4] </ref> could grow out of it. Boehm's system relies on expressions being both terminating and deterministic, properties not true of C expressions in general.
Reference: [5] <author> Edmund M. Clarke Jr. </author> <title> Programming language constructs for which it is impossible to obtain good Hoare axiom systems. </title> <journal> Journal of the ACM, </journal> <volume> 26(1) </volume> <pages> 129-147, </pages> <month> January </month> <year> 1979. </year>
Reference-contexts: Boehm's system relies on expressions being both terminating and deterministic, properties not true of C expressions in general. On the other hand, C does not fall into the category of languages for which "nice" descriptions are impossible, as described in <ref> [5] </ref>, as it does not allow nested function definitions. 3.2 Further analysis of loops The usual rule that one wants to be able to use when analysing loop executions states that the negation of the loop's guard is true when a loop terminates.
Reference: [6] <author> J. V. Cook, E. L. Cohen, and T. S. </author> <title> Redmond. A formal denotational semantics for C. A draft document, </title> <note> available from Trusted Information Systems' web-site at http://www.tis.com/docs/research/assurance/formal-c.html, September 1994. </note>
Reference-contexts: This work has the distinction of having been done in the theorem-prover Nqthm. However, this work assumes a particular order of evaluation for binary operators, and also leaves out such features of the full language as interrupt statements (break, continue etc). Finally, Cook et al. in the unpublished <ref> [6] </ref> present a denotational semantics that denotes C forms as expressions in a custom-built temporal logic.
Reference: [7] <author> M. Felleisen and D. Friedman. </author> <title> Control operators, the SECD-machine, and the -calculus. </title> <booktitle> In Formal Description of Programming Concepts III, </booktitle> <pages> pages 193-217. </pages> <publisher> North-Holland, </publisher> <year> 1986. </year> <month> 30 </month>
Reference-contexts: Once created, this will subsequently bubble its way up to the root of the syntax tree. 2.3.2 Expression evaluation contexts Following the example of other presentations of reduction semantics (e.g., [8], and ultimately <ref> [7] </ref>) Cholera's expression semantics makes use of evaluation contexts. Informally, an evaluation context is a piece of syntax "with a hole in it". Contexts provide a convenient way to generalise a whole family of evaluation rules where independent reductions occur in sub-expressions.
Reference: [8] <author> Andrew D. Gordon. </author> <title> Bisimilarity as a theory of functional programming. </title> <booktitle> Mini-course. BRICS Notes Series NS-95-3, BRICS, </booktitle> <address> Aarhus University, </address> <year> 1995. </year> <note> Extended version of MFPS'95 and Glasgow FP'94 papers. </note>
Reference-contexts: Once created, this will subsequently bubble its way up to the root of the syntax tree. 2.3.2 Expression evaluation contexts Following the example of other presentations of reduction semantics (e.g., <ref> [8] </ref>, and ultimately [7]) Cholera's expression semantics makes use of evaluation contexts. Informally, an evaluation context is a piece of syntax "with a hole in it". Contexts provide a convenient way to generalise a whole family of evaluation rules where independent reductions occur in sub-expressions.
Reference: [9] <author> M. J. C. Gordon. </author> <title> Mechanizing programming logics in higher order logic. </title> <editor> In G. Birtwistle and P. A. Subrahmanyam, editors, </editor> <title> Current trends in hardware verification and automated theorem proving. </title> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: Most of these have been proved with an eye to their later use in verification. They are presented here with that as the underlying motivation (see also [18]). 3.1 A derived "axiomatic" logic Following Gordon <ref> [9] </ref>, I have proved a number of theorems mimicking the axiomatic rules of Hoare [14]. Though Hoare's rules are axioms defining the semantics of his language, here the operational semantics is the ultimate authority.
Reference: [10] <author> M. J. C. Gordon and T. Melham. </author> <title> Introduction to HOL: a theorem proving environment. </title> <publisher> Cambridge University Press, </publisher> <year> 1993. </year>
Reference-contexts: It is significant in two important ways. Firstly, it is a demonstration that a language as complicated and as inherently unco-operative as C can nonetheless be treated formally. Secondly, the model has been mechanised in the HOL theorem prover <ref> [10] </ref>. This provides the theorem proving community with a demonstration that large semantic descriptions are both possible, and that they can be used for the basis of further reasoning. It also suggests that mechanical work on real world verification problems may not be the practical impossibility that common wisdom suggests.
Reference: [11] <author> Yuri Gurevich. </author> <title> Evolving algebras: a tutorial introduction. </title> <journal> Bulletin of EATCS, </journal> <volume> 43 </volume> <pages> 264-284, </pages> <year> 1991. </year>
Reference-contexts: Here, an axiomatic semantics is developed ex nihilo, and expressions are char-acterised at a much higher level than in Cholera. In other work, the details of expression evaluation are simply not correct. The evolving algebra semantics of Gurevich and Huggins <ref> [11, 12] </ref> relies on the mistaken assumption that side effects are applied as they are generated, and that expressions involving binary operators can be evaluated by evaluating all of one argument before switching to the other.
Reference: [12] <author> Yuri Gurevich and James K. Huggins. </author> <title> The semantics of the C programming language. </title> <editor> In E. Borger, editor, </editor> <booktitle> Selected papers from CSL '92, volume 702 of Lecture notes in computer science, </booktitle> <pages> pages 274-308. </pages> <address> Spring-Verlag, </address> <year> 1993. </year> <note> Corrected version available from University of Michigan web-site: http://www.eecs.umich.edu/gasm. </note>
Reference-contexts: Here, an axiomatic semantics is developed ex nihilo, and expressions are char-acterised at a much higher level than in Cholera. In other work, the details of expression evaluation are simply not correct. The evolving algebra semantics of Gurevich and Huggins <ref> [11, 12] </ref> relies on the mistaken assumption that side effects are applied as they are generated, and that expressions involving binary operators can be evaluated by evaluating all of one argument before switching to the other. <p> This code is 12 Although the improvements mentioned might result in the big-step non-determinism of <ref> [12] </ref>. over 300 lines long, uses a hash table, linked lists as buckets, and a promote-to--front strategy when searching the lists. It is thus quite a complicated example of data structure use, and seems a realistic small-scale verification exercise.
Reference: [13] <author> John Harrison. </author> <title> Binary decision diagrams as a HOL derived rule. </title> <journal> Computer Journal, </journal> <volume> 38(2), </volume> <year> 1995. </year>
Reference-contexts: Because Cholera doesn't deal with system and library calls, this verification can't attempt anything like the thttpd code of [3], but will rather look at the C code written by John Harrison as part of his work on binary decision diagrams in <ref> [13] </ref>. This code is 12 Although the improvements mentioned might result in the big-step non-determinism of [12]. over 300 lines long, uses a hash table, linked lists as buckets, and a promote-to--front strategy when searching the lists.
Reference: [14] <author> C. A. R. Hoare. </author> <title> An axiomatic basis for computer programming. </title> <journal> Communications of the ACM, </journal> <volume> 12(10) </volume> <pages> 576-583, </pages> <month> October </month> <year> 1969. </year>
Reference-contexts: Most of these have been proved with an eye to their later use in verification. They are presented here with that as the underlying motivation (see also [18]). 3.1 A derived "axiomatic" logic Following Gordon [9], I have proved a number of theorems mimicking the axiomatic rules of Hoare <ref> [14] </ref>. Though Hoare's rules are axioms defining the semantics of his language, here the operational semantics is the ultimate authority. The theorems do not define the language, but are statements about the properties of an existing logical entity.
Reference: [15] <institution> Programming languages - C, </institution> <year> 1990. </year> <note> ISO/IEC 9899:1990. </note>
Reference-contexts: It also suggests that mechanical work on real world verification problems may not be the practical impossibility that common wisdom suggests. The C programming language was first fully defined in 1989, in the ANSI standard [1], subsequently adopted as an ISO standard <ref> [15] </ref>. However it had been in existence for a long time prior to that date.
Reference: [16] <author> Steve King and Carroll Morgan. </author> <title> Exits in the refinement calculus. </title> <journal> Formal aspects of computing, </journal> <volume> 7(1) </volume> <pages> 54-76, </pages> <year> 1995. </year>
Reference-contexts: If one wishes to keep the analysis of the code at the "axiomatic" level of the previous section, alternatives to this approach involving multiple post-conditions are also possible. An example of this is the presentation of a wp semantics for a language with an exit statement <ref> [16] </ref>. Earlier work along the same lines is found in [2]. In C, one would want triples with four postconditions, corresponding to the three different forms of interruption and normal execution. 3.3 Purity analysis Expressions cause would-be "axiomatic" rules about C so much difficulty because they might cause side effects.
Reference: [17] <author> Robin Milner, Mads Tofte, and Robert W. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: 1 Introduction This work presents a formal description of the C language [1] in the tradition of the formal definition of SML <ref> [17] </ref>. It is significant in two important ways. Firstly, it is a demonstration that a language as complicated and as inherently unco-operative as C can nonetheless be treated formally. Secondly, the model has been mechanised in the HOL theorem prover [10]. <p> However, the standard also makes admirable efforts to accommodate practice as it existed at the time. 2 1.1 Motivation Why C? Formal language semantics have been developed in the past, notably the specification of the language SML in <ref> [17] </ref>. Such formalisations can be very valuable exercises in their own right, and numerous languages have been studied in this light. Nonetheless, the question remains as to why C is a worthwhile object of study. The answer to this question has two facets.
Reference: [18] <author> Michael Norrish. </author> <title> Derivation of verificiation rules for C from operational definitions. </title> <editor> In J. von Wright, J. Grundy, and J. Harrison, editors, </editor> <booktitle> Supplementary proceedings of TPHOLs '96, number 1 in TUCS General Publications, </booktitle> <pages> pages 69-75. </pages> <institution> Turku Centre for Computer Science, </institution> <month> August </month> <year> 1996. </year>
Reference-contexts: This has subsequently supported the proof of a number of results relating to the semantics. Most of these have been proved with an eye to their later use in verification. They are presented here with that as the underlying motivation (see also <ref> [18] </ref>). 3.1 A derived "axiomatic" logic Following Gordon [9], I have proved a number of theorems mimicking the axiomatic rules of Hoare [14]. Though Hoare's rules are axioms defining the semantics of his language, here the operational semantics is the ultimate authority.
Reference: [19] <author> Sakthi Subramanian and J. V. Cook. </author> <title> Mechanical verification of C programs. </title> <booktitle> In First workshop on Formal Methods in Software Practice (FMSP '96). Association for Computing Machinery, </booktitle> <month> January </month> <year> 1996. </year> <month> 31 </month>
Reference-contexts: ! fl e hv 2 ; i e hv 1 fi v 2 ; i e hv 2 ; 0 i he 1 ; 0 i ! fl he 1 fi e 2 ; 0 i ! fl Subramanian and Cook present a semantics for a subset of C in <ref> [19] </ref>. This work has the distinction of having been done in the theorem-prover Nqthm. However, this work assumes a particular order of evaluation for binary operators, and also leaves out such features of the full language as interrupt statements (break, continue etc).
References-found: 19

