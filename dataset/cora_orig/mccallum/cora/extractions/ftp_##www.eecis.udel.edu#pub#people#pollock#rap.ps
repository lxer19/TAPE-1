URL: ftp://www.eecis.udel.edu/pub/people/pollock/rap.ps
Refering-URL: http://www.eecis.udel.edu:80/~norris/
Root-URL: http://www.cis.udel.edu
Email: norris@udel.edu pollock@udel.edu  
Phone: (302) 831-1953  
Title: Register Allocation over the Program Dependence Graph  
Author: Cindy Norris Lori. L. Pollock 
Address: 19716  
Affiliation: Department of Computer and Information Sciences University of Delaware Newark, DE,  
Abstract: This paper describes RAP, a Register Allocator that allocates registers over the Program Dependence Graph (PDG) representation of a program in a hierarchical manner. The PDG program representation has been used successfully for scalar optimizations, the detection and improvement of parallelism for vector machines, multiple processor machines, and machines that exhibit instruction level parallelism, as well as debugging, the integration of different versions of a program, and translation of imperative programs for data flow machines. By basing register allocation on the PDG, the register allocation phase may be more easily integrated and intertwined with other optimization analyses and transformations. In addition, the advantages of a hierarchical approach to global register allocation can be attained without constructing an additional structure used solely for register allocation. Our experimental results have shown that on average, code allocated registers via RAP executed 2.7% faster than code allocated registers via a standard global register allocator. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. Agrawal and J. R. Horgan. </author> <title> Dynamic program slicing. </title> <booktitle> In Proceedings of the SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 246-256, </pages> <address> White Plains, NY, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: Variations of the PDG have also been used for debugging and integrating different versions of fl This work was partially supported by NSF under grant CCR-9300212. a program via program slicing <ref> [29, 1, 18, 22, 21, 26] </ref>, and to enable translation of imperative programs for data flow machines and demand driven graph reducers [4]. This paper describes a register allocator based on the PDG and presents experimental evidence that shows how it usually outperforms a traditional global graph coloring register allocator.
Reference: [2] <author> V. H. Allan, J. Janardhan, R. M. Lee, and M. Srinivas. </author> <title> Enhanced region scheduling on a program dependence graph. </title> <booktitle> In Proceedings of the twenty-fifth International Symposium on Microar-chitecture, </booktitle> <pages> pages 72-80, </pages> <address> Portland, OR, </address> <year> 1992. </year>
Reference-contexts: 1 Introduction The Program Dependence Graph (PDG) representation of a program has been used successfully as the basis for various scalar optimizations [16, 25, 23] as well as for detecting and improving parallelization for vector machines [28, 5], multiple processor machines [30, 3], and architectures that exhibit instruction level parallelism <ref> [19, 7, 2] </ref>. <p> The PDG provides a natural representation for scheduling across basic block boundaries, and thus several global instruction scheduling methods have been expressed as transformations over the PDG <ref> [6, 19, 2] </ref>, for instance, region scheduling [19] and software pipelining [2]. However, we could not find any indication in the literature of a register allocation technique that was based on the PDG. <p> The PDG provides a natural representation for scheduling across basic block boundaries, and thus several global instruction scheduling methods have been expressed as transformations over the PDG [6, 19, 2], for instance, region scheduling [19] and software pipelining <ref> [2] </ref>. However, we could not find any indication in the literature of a register allocation technique that was based on the PDG.
Reference: [3] <author> F. E. Allen, M. Burke, P. Charles, R. Cytron, and J. Ferrante. </author> <title> An overview of the PTRAN analysis system for multiprocessing. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 5 </volume> <pages> 617-640, </pages> <year> 1988. </year>
Reference-contexts: 1 Introduction The Program Dependence Graph (PDG) representation of a program has been used successfully as the basis for various scalar optimizations [16, 25, 23] as well as for detecting and improving parallelization for vector machines [28, 5], multiple processor machines <ref> [30, 3] </ref>, and architectures that exhibit instruction level parallelism [19, 7, 2].
Reference: [4] <author> R. A. Ballance, A. B. Maccabe, and K. J. Ot-tenstein. </author> <title> The program dependence web: a representation supporting control-, data-, and demand-driven interpretation of imperative languages. </title> <booktitle> In Proceedings of the SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 257-271, </pages> <address> White Plains, NY, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: PDG have also been used for debugging and integrating different versions of fl This work was partially supported by NSF under grant CCR-9300212. a program via program slicing [29, 1, 18, 22, 21, 26], and to enable translation of imperative programs for data flow machines and demand driven graph reducers <ref> [4] </ref>. This paper describes a register allocator based on the PDG and presents experimental evidence that shows how it usually outperforms a traditional global graph coloring register allocator.
Reference: [5] <author> W. Baxter and H. R. Bauer, III. </author> <title> The program dependence graph and vectorization. </title> <booktitle> In Proceedings of the Sixteenth Annual ACM SIGACT/SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <address> Austin, TX, </address> <year> 1989. </year>
Reference-contexts: 1 Introduction The Program Dependence Graph (PDG) representation of a program has been used successfully as the basis for various scalar optimizations [16, 25, 23] as well as for detecting and improving parallelization for vector machines <ref> [28, 5] </ref>, multiple processor machines [30, 3], and architectures that exhibit instruction level parallelism [19, 7, 2].
Reference: [6] <author> D. Bernstein and M. Rodeh. </author> <title> Global instruction scheduling for superscalar machines. </title> <booktitle> In Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <address> Toronto, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: The PDG provides a natural representation for scheduling across basic block boundaries, and thus several global instruction scheduling methods have been expressed as transformations over the PDG <ref> [6, 19, 2] </ref>, for instance, region scheduling [19] and software pipelining [2]. However, we could not find any indication in the literature of a register allocation technique that was based on the PDG.
Reference: [7] <author> David Bernstein and Michael Rodeh. </author> <title> Global instruction scheduling for superscalar machines. </title> <booktitle> In Proceedings of the SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <address> Toronto, CANADA, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: 1 Introduction The Program Dependence Graph (PDG) representation of a program has been used successfully as the basis for various scalar optimizations [16, 25, 23] as well as for detecting and improving parallelization for vector machines [28, 5], multiple processor machines [30, 3], and architectures that exhibit instruction level parallelism <ref> [19, 7, 2] </ref>.
Reference: [8] <author> Preston Briggs. </author> <title> Register allocation via graph coloring. </title> <type> PhD thesis, </type> <institution> Rice University, </institution> <month> April </month> <year> 1992. </year>
Reference-contexts: Most recent research casts register allocation as a graph coloring problem <ref> [11, 15, 14, 12, 9, 8, 13] </ref>.
Reference: [9] <author> Preston Briggs, Keith D. Cooper, Ken Kennedy, and Linda Torczon. </author> <title> Coloring heuristics for register allocation. </title> <booktitle> In Proceedings of the ACM SIGPLAN '89 Conference on Programming Language Design and Implementation, </booktitle> <month> July </month> <year> 1989. </year>
Reference-contexts: This paper describes RAP, a Register Allocator that allocates registers over the PDG representation of a program in a hierarchical manner. The register allocation of each region is performed in a bottom up pass over the PDG, using an enhanced version of Chaitin's graph coloring algorithm for each region <ref> [14, 9] </ref>. On a top down pass, RAP attempts to move loads and stores out of loops. A third pass over the PDG removes unnecessary loads and stores created by the hierarchical register allocation process. <p> Most recent research casts register allocation as a graph coloring problem <ref> [11, 15, 14, 12, 9, 8, 13] </ref>. <p> Instead, the technique used in RAP, which delays the identification of nodes to be spilled, is an enhancement to Chaitin's original coloring technique proposed by Briggs, Cooper, Kennedy and Torczon <ref> [9] </ref>. By deferring the spilling until the nodes are popped from the stack, it may be possible to color a node which Chaitin's method would have spilled for two reasons. <p> GRA is basically an implementation of Chaitin's global register allocator with two exceptions: (1) The enhancement suggested by Briggs et. al. <ref> [9] </ref> has been incorporated. (2) No coalescing or rematerialization is done [14, 11]. These modifications were made to GRA in order to present a fair comparison with the current version of our prototype implementation of RAP.
Reference: [10] <author> Preston Briggs, Keith D. Cooper, and Linda Tor-czon. </author> <title> R n programming environment newsletter #44. </title> <institution> Department of Computer Science, Rice University, </institution> <month> September </month> <year> 1987. </year>
Reference-contexts: RAP inputs the PDG representation of the C program and first generates and attaches low-level intermediate code to the corresponding region nodes. The intermediate code representation is iloc developed at Rice University for the development of optimizing compilers <ref> [10] </ref>. RAP performs register allocation over the PDG representation and generates code with a correct register assignment. Alternatively, RAP can simply output the unallocated iloc code which is then used as input to GRA for experimental comparison.
Reference: [11] <author> Preston Briggs, Keith D. Cooper, and Linda Torc--zon. </author> <title> Rematerialization. </title> <booktitle> In Proceedings of the SIG-PLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: Most recent research casts register allocation as a graph coloring problem <ref> [11, 15, 14, 12, 9, 8, 13] </ref>. <p> GRA is basically an implementation of Chaitin's global register allocator with two exceptions: (1) The enhancement suggested by Briggs et. al. [9] has been incorporated. (2) No coalescing or rematerialization is done <ref> [14, 11] </ref>. These modifications were made to GRA in order to present a fair comparison with the current version of our prototype implementation of RAP. We have incorporated the Briggs enhancement into RAP, but RAP currently does not include coalescing in its traditional form or rematerial-ization.
Reference: [12] <author> David Callahan and Brian Koblenz. </author> <title> Register allocation via hierarchical graph coloring. </title> <booktitle> In Proceedings of the SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 192-203, </pages> <address> Toronto, CANADA, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: For example, a variable may be assigned to register R1 in one region, register R2 in another region, and spilled in another region. Like other approaches <ref> [12, 20] </ref>, a space savings can be obtained by performing register allocation for code segments separately, which causes smaller interference graphs to be constructed than one interference graph for the whole program. <p> Although the register allocator performed very well on the Stanford Benchmarks, compile time is significantly increased by this method, primarily due to the frequent recomputation of probabilities. A hierarchical approach to global register allocation was presented by Callahan and Koblenz <ref> [12] </ref> in which they build a tree of "tiles" which covers the basic blocks of the control flow graph. In a bottom up pass, a graph coloring allocation of each tile is performed, summarizing the allocation of subtiles within the interference graph of the parent tile. <p> Most recent research casts register allocation as a graph coloring problem <ref> [11, 15, 14, 12, 9, 8, 13] </ref>. <p> RAP currently attempts to move spill code out of loop regions, but moving spill code out of any subregion is also likely to reduce the amount of spill code executed. Unlike the hierarchical tile structure of Callahan and Koblenz <ref> [12] </ref>, a region of a PDG may contain multiple exits making spill code placement more difficult. The tile structure allows placement of spill code in the single entrance and the single exit of the tile tree.
Reference: [13] <author> G. J. Chaitin. </author> <title> Register allocation and spilling via graph coloring. </title> <booktitle> In SIGPLAN Symposium on Compiler Construction, </booktitle> <address> Boston, </address> <month> June </month> <year> 1982. </year>
Reference-contexts: Most recent research casts register allocation as a graph coloring problem <ref> [11, 15, 14, 12, 9, 8, 13] </ref>.
Reference: [14] <author> Gregory Chaitin, Marc Auslander, Ashok K. Chandra, John Cocke, Martin E. Hopkins, and Peter W. Markstein. </author> <title> Register allocation via coloring. </title> <journal> Computer Languages, </journal> <volume> 6 </volume> <pages> 47-57, </pages> <month> January </month> <year> 1981. </year>
Reference-contexts: This paper describes RAP, a Register Allocator that allocates registers over the PDG representation of a program in a hierarchical manner. The register allocation of each region is performed in a bottom up pass over the PDG, using an enhanced version of Chaitin's graph coloring algorithm for each region <ref> [14, 9] </ref>. On a top down pass, RAP attempts to move loads and stores out of loops. A third pass over the PDG removes unnecessary loads and stores created by the hierarchical register allocation process. <p> Most recent research casts register allocation as a graph coloring problem <ref> [11, 15, 14, 12, 9, 8, 13] </ref>. <p> The add region conflicts procedure builds the part of the interference graph for the parent region interferences, without concern for the subregions. This is similar to standard global register allocation techniques <ref> [14] </ref>, except that RAP adds an interference between any two virtual registers that are live on entrance to the parent region and referenced (either used or defined) within the region. <p> If a node cannot be colored, it is added to a list of nodes to be spilled. If a node cannot be found with degree less than k and instead a node with least spill cost has to be removed, then Chaitin's original technique <ref> [14] </ref> marks this node to be spilled and not pushed on the stack. Instead, the technique used in RAP, which delays the identification of nodes to be spilled, is an enhancement to Chaitin's original coloring technique proposed by Briggs, Cooper, Kennedy and Torczon [9]. <p> GRA is basically an implementation of Chaitin's global register allocator with two exceptions: (1) The enhancement suggested by Briggs et. al. [9] has been incorporated. (2) No coalescing or rematerialization is done <ref> [14, 11] </ref>. These modifications were made to GRA in order to present a fair comparison with the current version of our prototype implementation of RAP. We have incorporated the Briggs enhancement into RAP, but RAP currently does not include coalescing in its traditional form or rematerial-ization.
Reference: [15] <author> Frederick Chow and John Hennessy. </author> <title> Register allocation by priority-based coloring. </title> <booktitle> In Proceedings of the SIGPLAN '84 Symposium on Compiler Construction, </booktitle> <month> June </month> <year> 1984. </year>
Reference-contexts: Most recent research casts register allocation as a graph coloring problem <ref> [11, 15, 14, 12, 9, 8, 13] </ref>.
Reference: [16] <author> Jeanne Ferrante, Karl J. Ottenstein, and Joe D. Warren. </author> <title> The program dependence graph and its use in optimization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(3) </volume> <pages> 319-349, </pages> <year> 1987. </year>
Reference-contexts: 1 Introduction The Program Dependence Graph (PDG) representation of a program has been used successfully as the basis for various scalar optimizations <ref> [16, 25, 23] </ref> as well as for detecting and improving parallelization for vector machines [28, 5], multiple processor machines [30, 3], and architectures that exhibit instruction level parallelism [19, 7, 2].
Reference: [17] <author> Claude-Nicolas Fiechter. </author> <title> PDG C Compiler. </title> <institution> University of Pittsburgh, </institution> <year> 1992. </year>
Reference-contexts: We have incorporated the Briggs enhancement into RAP, but RAP currently does not include coalescing in its traditional form or rematerial-ization. The front end for RAP is the pdgcc compiler, developed at the University of Pittsburgh <ref> [17] </ref>, which accepts C source code as input and outputs the corresponding PDG. RAP inputs the PDG representation of the C program and first generates and attaches low-level intermediate code to the corresponding region nodes.
Reference: [18] <author> J. H. Griffin and K. J. Ottenstein. </author> <title> PROBE: a dependence-based program browser. </title> <type> Technical Report LA-UR-89-1823, </type> <institution> Los Alamos National Laboratory, </institution> <address> Los Alamos, NM, </address> <month> November </month> <year> 1989. </year>
Reference-contexts: Variations of the PDG have also been used for debugging and integrating different versions of fl This work was partially supported by NSF under grant CCR-9300212. a program via program slicing <ref> [29, 1, 18, 22, 21, 26] </ref>, and to enable translation of imperative programs for data flow machines and demand driven graph reducers [4]. This paper describes a register allocator based on the PDG and presents experimental evidence that shows how it usually outperforms a traditional global graph coloring register allocator.
Reference: [19] <author> Rajiv Gupta and Mary Lou Soffa. </author> <title> Region scheduling: An approach for detecting and redistributing parallelism. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(4) </volume> <pages> 421-431, </pages> <year> 1990. </year>
Reference-contexts: 1 Introduction The Program Dependence Graph (PDG) representation of a program has been used successfully as the basis for various scalar optimizations [16, 25, 23] as well as for detecting and improving parallelization for vector machines [28, 5], multiple processor machines [30, 3], and architectures that exhibit instruction level parallelism <ref> [19, 7, 2] </ref>. <p> The PDG provides a natural representation for scheduling across basic block boundaries, and thus several global instruction scheduling methods have been expressed as transformations over the PDG <ref> [6, 19, 2] </ref>, for instance, region scheduling [19] and software pipelining [2]. However, we could not find any indication in the literature of a register allocation technique that was based on the PDG. <p> The PDG provides a natural representation for scheduling across basic block boundaries, and thus several global instruction scheduling methods have been expressed as transformations over the PDG [6, 19, 2], for instance, region scheduling <ref> [19] </ref> and software pipelining [2]. However, we could not find any indication in the literature of a register allocation technique that was based on the PDG.
Reference: [20] <author> Rajiv Gupta, Mary Lou Soffa, and Tim Steele. </author> <title> Register allocation via clique separators. </title> <booktitle> In Proceedings of the SIGPLAN '89 Conference on Programming Language Design and Implementation, </booktitle> <address> Portland, Oregon, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: For example, a variable may be assigned to register R1 in one region, register R2 in another region, and spilled in another region. Like other approaches <ref> [12, 20] </ref>, a space savings can be obtained by performing register allocation for code segments separately, which causes smaller interference graphs to be constructed than one interference graph for the whole program.
Reference: [21] <author> S. Horwitz. </author> <title> Identifying the semantic and textual differences between two versions of a program. </title> <booktitle> In Proceedings of the SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 234-245, </pages> <address> White Plains, NY, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: Variations of the PDG have also been used for debugging and integrating different versions of fl This work was partially supported by NSF under grant CCR-9300212. a program via program slicing <ref> [29, 1, 18, 22, 21, 26] </ref>, and to enable translation of imperative programs for data flow machines and demand driven graph reducers [4]. This paper describes a register allocator based on the PDG and presents experimental evidence that shows how it usually outperforms a traditional global graph coloring register allocator.
Reference: [22] <author> S. Horwitz, J. Prins, and T. Reps. </author> <title> Integrating non-interfering versions of programs. </title> <booktitle> In Proceedings of the Fifteenth Annual ACM SIGACT/SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 133-145, </pages> <address> San Diego, CA, </address> <year> 1988. </year>
Reference-contexts: Variations of the PDG have also been used for debugging and integrating different versions of fl This work was partially supported by NSF under grant CCR-9300212. a program via program slicing <ref> [29, 1, 18, 22, 21, 26] </ref>, and to enable translation of imperative programs for data flow machines and demand driven graph reducers [4]. This paper describes a register allocator based on the PDG and presents experimental evidence that shows how it usually outperforms a traditional global graph coloring register allocator.
Reference: [23] <author> D. J. Kuck, R. H. Kuhn, B. Leasure, D. A. Padua, and M. Wolfe. </author> <title> Dependence graphs and compiler optimizations. </title> <booktitle> In Proceedings of the Eighth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 207-218, </pages> <year> 1981. </year>
Reference-contexts: 1 Introduction The Program Dependence Graph (PDG) representation of a program has been used successfully as the basis for various scalar optimizations <ref> [16, 25, 23] </ref> as well as for detecting and improving parallelization for vector machines [28, 5], multiple processor machines [30, 3], and architectures that exhibit instruction level parallelism [19, 7, 2].
Reference: [24] <author> Cindy Norris and Lori L. Pollock. </author> <title> A scheduler-sensitive global register allocator. </title> <booktitle> In Supercomputing '93 Proceedings, </booktitle> <address> Portland, OR, </address> <month> November </month> <year> 1993. </year>
Reference-contexts: Our overall research interests have been directed toward the problem of the sometimes conflicting goals of various tasks of optimizing and parallelizing compilers. In particular, we have been investigating ways of providing cooperation between a register allocator and an instruction scheduler <ref> [24] </ref>. Our original motivation for building a register allocator based on the PDG was to have a common program representation for both the register allocator and global instruction scheduler, as a first step towards integrating these two phases.
Reference: [25] <author> K. J. Ottenstein. </author> <title> An intermediate program form based on a cyclic data-dependence graph. </title> <type> Technical Report 81-1, </type> <institution> Department of Computer Science, Michigan Tech. University, </institution> <year> 1981. </year>
Reference-contexts: 1 Introduction The Program Dependence Graph (PDG) representation of a program has been used successfully as the basis for various scalar optimizations <ref> [16, 25, 23] </ref> as well as for detecting and improving parallelization for vector machines [28, 5], multiple processor machines [30, 3], and architectures that exhibit instruction level parallelism [19, 7, 2].
Reference: [26] <author> K. J. Ottenstein and L. M. Ottenstein. </author> <title> The program dependence graph in a software development environment. </title> <booktitle> In Proceedings of ACM SIG-PLAN/SIGSOFT Symposium on Practical Software Development Environments, </booktitle> <pages> pages 177-184, </pages> <address> Pittsburgh, PA, </address> <month> April </month> <year> 1984. </year>
Reference-contexts: Variations of the PDG have also been used for debugging and integrating different versions of fl This work was partially supported by NSF under grant CCR-9300212. a program via program slicing <ref> [29, 1, 18, 22, 21, 26] </ref>, and to enable translation of imperative programs for data flow machines and demand driven graph reducers [4]. This paper describes a register allocator based on the PDG and presents experimental evidence that shows how it usually outperforms a traditional global graph coloring register allocator.
Reference: [27] <author> Todd A. Proebsting and Charles N. Fischer. </author> <title> Probabilistic register allocation. </title> <booktitle> In Proceedings of the SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 300-310, </pages> <address> San Francisco, CA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Several other researchers have presented register allocation methods directed specifically toward improving the overall allocation by considering both local register needs and global register usage in making register allocation and assignment decisions. Proebst-ing and Fischer <ref> [27] </ref> developed a probabilistic approach in which local allocation is followed by probabilistic global allocation performed iteratively from inner to outer loops. Although the register allocator performed very well on the Stanford Benchmarks, compile time is significantly increased by this method, primarily due to the frequent recomputation of probabilities.
Reference: [28] <author> J. Warren. </author> <title> A hierarchical basis for reordering transformations. </title> <booktitle> In Proceedings of the Eleventh Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 272-282, </pages> <year> 1984. </year>
Reference-contexts: 1 Introduction The Program Dependence Graph (PDG) representation of a program has been used successfully as the basis for various scalar optimizations [16, 25, 23] as well as for detecting and improving parallelization for vector machines <ref> [28, 5] </ref>, multiple processor machines [30, 3], and architectures that exhibit instruction level parallelism [19, 7, 2].
Reference: [29] <author> M. Weiser. </author> <title> Program slicing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(4):352-357, </volume> <year> 1984. </year>
Reference-contexts: Variations of the PDG have also been used for debugging and integrating different versions of fl This work was partially supported by NSF under grant CCR-9300212. a program via program slicing <ref> [29, 1, 18, 22, 21, 26] </ref>, and to enable translation of imperative programs for data flow machines and demand driven graph reducers [4]. This paper describes a register allocator based on the PDG and presents experimental evidence that shows how it usually outperforms a traditional global graph coloring register allocator.
Reference: [30] <author> M. J. Wolfe. </author> <booktitle> Research Monographs in Parallel and Distributed Computing. </booktitle> <publisher> The MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: 1 Introduction The Program Dependence Graph (PDG) representation of a program has been used successfully as the basis for various scalar optimizations [16, 25, 23] as well as for detecting and improving parallelization for vector machines [28, 5], multiple processor machines <ref> [30, 3] </ref>, and architectures that exhibit instruction level parallelism [19, 7, 2].
References-found: 30

