URL: http://www.cs.utexas.edu/users/boyer/mc-rev3.ps.Z
Refering-URL: http://www.cs.utexas.edu/users/boyer/publications.html
Root-URL: 
Title: Automated Proofs of Object Code for a Widely Used Microprocessor 1  
Author: Robert S. Boyer and Yuan Yu 
Keyword: Key words. Automated reasoning, Boyer-Moore logic, Nqthm, formal methods, machine code, program verification, C, Ada, Common Lisp.  
Note: or  
Address: Austin, Texas 78712  
Affiliation: Department of Computer Sciences University of Texas at Austin  
Email: email: boyer@cs.utexas.edu  yuanyu@src.dec.com  
Phone: telephone: (512) 471-9745  
Abstract: We have formally described a substantial subset of the MC68020, a widely used microprocessor built by Motorola, within the mathematical logic of the automated reasoning system Nqthm, a.k.a. the Boyer-Moore Theorem Prover [6]. Using this formal description, we have mechanically checked the correctness of MC68020 object code programs for binary search, Hoare's Quick Sort, twenty-one functions from the Berkeley Unix C string library, and other well-known algorithms. The object code for these examples was generated using the Gnu C, the Verdix Ada, and the Gnu Common Lisp compilers. We have mechanized a mathematical theory to facilitate automated reasoning about object code programs. We describe a two stage methodology we use to do our proofs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> William Bevier. </author> <title> A Verified Operating System Kernel. </title> <type> PhD thesis, </type> <institution> University of Texas at Austin, </institution> <year> 1987. </year>
Reference-contexts: Our proofs are completely based on this formal model. Simplicity greatly increases our confidence in our formal models and formal proofs. The first example we know of formal, mechanical verification of binary programs based on such an operational semantics for a von Neumann machine is the work of Bevier <ref> [1] </ref>, also reported in [2]. In proving the correctness of a small operating system kernel, Bevier proves the correctness of several hundred lines of machine code produced by his own assembler for a von Neumann style machine of his own design.
Reference: [2] <author> William Bevier, Warren Hunt, J Strother Moore, and William Young. </author> <title> Special issue on system verification. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 5(4), </volume> <year> 1989. </year>
Reference-contexts: Since A Computational Logic [5] was published in 1979, Nqthm has been used by several dozen users to check proofs of over 16,000 theorems from many areas of number theory, proof theory, and computer science. An extensive partial listing may be found in [6, pages 5-9]. See also <ref> [2] </ref>. For a thorough and precise description of the Nqthm logic, we refer the reader to the rigorous treatment in [6], especially Chapter 4, in which the logic is precisely defined. <p> Simplicity greatly increases our confidence in our formal models and formal proofs. The first example we know of formal, mechanical verification of binary programs based on such an operational semantics for a von Neumann machine is the work of Bevier [1], also reported in <ref> [2] </ref>. In proving the correctness of a small operating system kernel, Bevier proves the correctness of several hundred lines of machine code produced by his own assembler for a von Neumann style machine of his own design. <p> Polak's work [25] seems the most ambitious compiler verification effort. Polak mechanically verified a compiler for a fairly substantial subset of Pascal. Moore's Piton and Young's Micro-Gypsy <ref> [2] </ref>, two components of the CLI short stack, are major compiler verification efforts targeted on a more realistic von Neumann architecture|the verified and fabricated FM9001. <p> The general style of Nqthm formalization used in this MC68020 specification is the product of over a decade of study by the authors of Nqthm and their students. Especially influential was the FM8502 and Piton work <ref> [2] </ref>. The development of Nqthm was primarily supported by NSF, ONR, and DARPA.
Reference: [3] <author> R. S. Boyer and J S. Moore. Metafunctions: </author> <title> Proving them correct and using them efficiently as new proof procedures. </title> <editor> In R. S. Boyer and J S. Moore, editors, </editor> <booktitle> The Correctness Problem in Computer Science, </booktitle> <pages> pages 103-184. </pages> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1981. </year>
Reference-contexts: add (n, add (n, x , y), z ) = add (n, x , add (n, y, z )) It is worth noting that some meta lemmas about modulo arithmetic have been proved by Nqthm and incorporated into our theory, which demonstrates the usefulness of the Nqthm's meta extension mechanism <ref> [3, 6] </ref>. This meta extension technique permits the proof of the correctness of simplification procedures, which once proved are then embedded into Nqthm's simplification machinery. A simple example of such a meta lemma is the statement that identical terms may be cancelled from opposite sides of an additive arithmetic equation.
Reference: [4] <author> Robert S. Boyer and J S. Moore. </author> <title> Program verification. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 1(1) </volume> <pages> 17-23, </pages> <year> 1985. </year> <month> 31 </month>
Reference-contexts: Most of these projects are based on Floyd's inductive assertion method. For a survey of many of these projects, see <ref> [4] </ref>. Our work differs from this previous work in that we address the correctness of programs at the machine-code level executed on a widely used processor. 27 In only a very few cases, however, does research on formal, mechanical soft-ware correctness address the machine-code level for actually fabricated processors.
Reference: [5] <author> Robert S. Boyer and J Strother Moore. </author> <title> A Computational Logic. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: Nqthm is a Common Lisp program for proving mathematical theorems. Since A Computational Logic <ref> [5] </ref> was published in 1979, Nqthm has been used by several dozen users to check proofs of over 16,000 theorems from many areas of number theory, proof theory, and computer science. An extensive partial listing may be found in [6, pages 5-9]. See also [2].
Reference: [6] <author> Robert S. Boyer and J Strother Moore. </author> <title> A Computational Logic Handbook. </title> <publisher> Academic Press, </publisher> <year> 1988. </year> <title> For sources and examples, </title> <address> see ftp://ftp.cli.com/pub/nqthm/nqthm-1992/nqthm-1992.tar.Z or ftp://ftp.cs.utexas.edu/pub/boyer/nqthm-1992.tar.Z. </address>
Reference-contexts: Thus far, the bulk of research in formal, mechanical program proving has focused on programs written in higher-level languages. This paper describes how we have formally defined, within the logic of the automated reasoning system Nqthm <ref> [6] </ref>, a substantial subset of the user model of the widely used Motorola MC68020 microprocessor. <p> Since A Computational Logic [5] was published in 1979, Nqthm has been used by several dozen users to check proofs of over 16,000 theorems from many areas of number theory, proof theory, and computer science. An extensive partial listing may be found in <ref> [6, pages 5-9] </ref>. See also [2]. For a thorough and precise description of the Nqthm logic, we refer the reader to the rigorous treatment in [6], especially Chapter 4, in which the logic is precisely defined. <p> An extensive partial listing may be found in [6, pages 5-9]. See also [2]. For a thorough and precise description of the Nqthm logic, we refer the reader to the rigorous treatment in <ref> [6] </ref>, especially Chapter 4, in which the logic is precisely defined. In the body of this paper, we use a conventional syntax rather than the official Lisp-like syntax of Nqthm. 4 2.1 The Logic The logic of Nqthm is a quantifier-free first order logic with equality. <p> add (n, add (n, x , y), z ) = add (n, x , add (n, y, z )) It is worth noting that some meta lemmas about modulo arithmetic have been proved by Nqthm and incorporated into our theory, which demonstrates the usefulness of the Nqthm's meta extension mechanism <ref> [3, 6] </ref>. This meta extension technique permits the proof of the correctness of simplification procedures, which once proved are then embedded into Nqthm's simplification machinery. A simple example of such a meta lemma is the statement that identical terms may be cancelled from opposite sides of an additive arithmetic equation. <p> parameters. * various control structures: if-then-else, loop, goto, and case. * pointer manipulation. * higher-level language programs with embedded assembly code. 30 In pursuit of the objective of ensuring that any change to our collection of lemmas is indeed an improvement, we have fruitfully followed the proveall discipline described in <ref> [6] </ref>, i.e., the practice of making sure that after we make changes, we can still prove the most important of our previous results. 10 Acknowledgments We would like to thank Bill Bevier, Paul Eggert, Don Good, Warren Hunt, Matt Kaufmann, J Moore, and Bill Schelter for their many constructive suggestions and
Reference: [7] <author> Robert S. Boyer and Yuan Yu. </author> <title> A formal specification of some user mode instructions for the Motorola 68020. </title> <type> Technical Report TR-92-04, </type> <institution> Computer Sciences Department, University of Texas at Austin, </institution> <year> 1992. </year> <note> See ftp://ftp.cs.utexas.edu/pub/techreports/tr92-04.ps.Z. Alternatively, see examples/yu/mc20-1.ps in ftp://ftp.cs.utexas.edu/pub/boyer/nqthm-1992.tar.Z. </note>
Reference-contexts: The function `numberp' recognizes nonnegative integers. The function `sub1' returns the predecessor of a non-0 nonnegative inte ger. x 2 N abbreviates numberp (x). 4 The translation between the conventional syntax and the official Lisp-like syntax is dis cussed in <ref> [7] </ref>. 3 Symbols. The data type of symbols, e.g., 'running, is built using the primitive constructor `pack' and 0-terminated lists of ASCII codes. The symbol 'nil, also abbreviated nil, is used to represent the empty list. Ordered Pairs. <p> The complete description may be found in <ref> [7] </ref>. The top-level loop of our specification is defined by a pair of functions, the single-stepper function `stepi' and the stepper function `stepn', which executes n instructions. <p> mbit (dopd , n))), b-and (mbit (sopd , n), b-not (mbit (result , n)))) endlet Definition: add-v (n, sopd , dopd ) = let result be add (n, sopd , dopd ) 6 This is only one of the two cases in the ADD instruction; please refer to [22] and <ref> [7] </ref> for more details. 12 in b-or (b-and (b-and (mbit (sopd , n), mbit (dopd , n)), b-not (mbit (result , n))), b-and (b-and (b-not (mbit (sopd , n)), b-not (mbit (dopd , n))), mbit (result , n))) endlet Definition: add-z (oplen, sopd , dopd ) = if add (oplen, dopd <p> Altogether, our formal specification consists of 569 function definitions. It takes up approximately 80 pages of text. About two thirds of the specification is devoted to the formalization of individual instructions. Rather than giving more details for any particular instruction, all of which have been fully documented in <ref> [7] </ref>, we instead focus on some of the interesting issues that have come up in the specification. Cache Consistency. The MC68020 has an on-chip instruction cache, but a write operation does not invalidate or modify the corresponding entry in the instruction cache.
Reference: [8] <author> D.L. Clutterbuck and B.A. Carre. </author> <title> The verification of low-level code. </title> <journal> IEE Software Engineering Journal, </journal> <month> May </month> <year> 1988. </year>
Reference-contexts: To the best of our knowledge, Maurer [20, 19] was the first to consider the verification, with an automated reasoning system, of machine-code programs for a fabricated microprocessor. Subsequently, Clutterbuck and Carre <ref> [8] </ref> argued for the importance of the verification of low-level code, and, in a separate paper [15], reported their effort to analyze and verify the LUCOL assembly code modules used in the fuel control unit of the Rolls-Royce RB211-524G jet engine designed for Boeing 747-400.
Reference: [9] <author> Avra Cohn. </author> <title> A proof of correctness of the Viper microprocessor: The first level. </title> <type> Technical Report 104, </type> <institution> University of Cambridge, </institution> <month> January </month> <year> 1987. </year>
Reference-contexts: A large majority of the C/30's instructions were proven to be correctly implemented by approximately 1000 MBB microinstructions. Microcode verification is often part of some larger hardware verification effort. Hunt [14] and Cohn <ref> [9] </ref> are two major hardware design verification projects involving microcode verification.
Reference: [10] <author> J. V. Cook. </author> <title> Verification of the C/30 microcode using the State Delta Verification System (SDVS). </title> <booktitle> In 13th National Computer Security Conference, </booktitle> <volume> volume 1, </volume> <pages> pages 20-31, </pages> <year> 1990. </year>
Reference-contexts: Microcode verification is closely related to our work. Among the most significant reported work is the C/30 microcode verification using the State Delta 8 It is no simpler than high-level programming language semantics. 28 Verification System (SDVS) <ref> [10] </ref>. A large majority of the C/30's instructions were proven to be correctly implemented by approximately 1000 MBB microinstructions. Microcode verification is often part of some larger hardware verification effort. Hunt [14] and Cohn [9] are two major hardware design verification projects involving microcode verification.
Reference: [11] <author> Robert W. Floyd. </author> <title> Assigning meanings to programs. </title> <booktitle> In Mathematical Aspects of Computer Science, Proceedings of Symposia in Applied Mathematics, </booktitle> <publisher> American Mathematical Society, </publisher> <pages> pages 19-32, </pages> <address> Providence, Rhode Island, </address> <year> 1967. </year>
Reference-contexts: For each loop in the program, we need to prove two intermediate lemmas that correspond to the base case and inductive case of an inductive proof. These intermediate lemmas are quite analogous to the verification conditions in proof by the Floyd method <ref> [11] </ref>. The lemmas differ from typical verification conditions largely because of very detailed attention to the number of machine instructions being executed. Since we do not consider the mathematical properties of the program here, the typical invariant proofs found in Floyd/Hoare method are delayed to the second step. <p> The informal, hand proof of object code produced by "industrial strength" compilers is not unheard of today for especially critical programs. Methods for program proving have been advanced most notably by Mc-Carthy [21], Floyd <ref> [11] </ref>, and Hoare [13]. In the last twenty years, many research projects have investigated the formal, mechanical verification of programs written in higher-level languages. <p> It might also be asked whether a compiler proof for a higher-level language would make verification of "bits" easier. It is certainly the case that the verification of algorithms written in higher-level languages, using the Floyd <ref> [11] </ref> approach, is somewhat easier than the method we have described because in the Floyd approach one is relieved of attention to such details as instruction counting, the identification of variables with specific machine locations, and, especially, the layout of code in memory.
Reference: [12] <author> Herman H. Goldstine and John von Neumann. </author> <title> Planning and coding problems for an electronic computing instrument. </title> <editor> In John von Neumann, </editor> <booktitle> Collected Works, volume V, </booktitle> <pages> pages 34-235. </pages> <publisher> Pergamon Press, Oxford, </publisher> <year> 1961. </year>
Reference-contexts: Rather, we provide a brief account of related work, with an emphasis on mechanical program proving. Our work has built on the work of many others. Of historic interest is the early work of Turing [28] and Goldstine and von Neumann <ref> [12] </ref>. The careful proof of machine-code programs is coincident with the foundations of the von Neumann machine, first presented in [12]. In those classic papers of von Neu-mann and Goldstine, we find discussed the specification and correctness proofs for fifteen programs at the machine-code level. <p> Our work has built on the work of many others. Of historic interest is the early work of Turing [28] and Goldstine and von Neumann <ref> [12] </ref>. The careful proof of machine-code programs is coincident with the foundations of the von Neumann machine, first presented in [12]. In those classic papers of von Neu-mann and Goldstine, we find discussed the specification and correctness proofs for fifteen programs at the machine-code level. Proving the correctness of programs written in the assembly language MIX is a main feature of Knuth's magnum opus [18].
Reference: [13] <author> C.A.R. Hoare. </author> <title> An axiomatic basis for computer programming. </title> <journal> The Communication of ACM, </journal> <volume> 12(10) </volume> <pages> 576-583, </pages> <year> 1969. </year>
Reference-contexts: The informal, hand proof of object code produced by "industrial strength" compilers is not unheard of today for especially critical programs. Methods for program proving have been advanced most notably by Mc-Carthy [21], Floyd [11], and Hoare <ref> [13] </ref>. In the last twenty years, many research projects have investigated the formal, mechanical verification of programs written in higher-level languages.
Reference: [14] <author> Warren A. Hunt. FM8501: </author> <title> A Verified Microprocessor. </title> <type> PhD thesis, </type> <institution> University of Texas at Austin, </institution> <year> 1985. </year>
Reference-contexts: A large majority of the C/30's instructions were proven to be correctly implemented by approximately 1000 MBB microinstructions. Microcode verification is often part of some larger hardware verification effort. Hunt <ref> [14] </ref> and Cohn [9] are two major hardware design verification projects involving microcode verification.
Reference: [15] <author> I.M. O'Neill, et al. </author> <title> The formal verification of safety-critical assembly code. In Safety of Computer Control System 1988. </title> <publisher> Pergamon Press, </publisher> <month> November </month> <year> 1988. </year>
Reference-contexts: To the best of our knowledge, Maurer [20, 19] was the first to consider the verification, with an automated reasoning system, of machine-code programs for a fabricated microprocessor. Subsequently, Clutterbuck and Carre [8] argued for the importance of the verification of low-level code, and, in a separate paper <ref> [15] </ref>, reported their effort to analyze and verify the LUCOL assembly code modules used in the fuel control unit of the Rolls-Royce RB211-524G jet engine designed for Boeing 747-400. Like most work on software verification, this work is based upon the use of a Floyd-style verification condition generator.
Reference: [16] <author> ISO Committee JTC1/SC22/WG14. </author> <title> ISO/IEC Standard 9899:1990. International Standards Organization, </title> <address> Geneva, </address> <year> 1990. </year> <month> 32 </month>
Reference-contexts: We have also tried to verify the Berkeley Unix C string library. Twenty-one functions out of twenty-two functions specified in the ISO standard <ref> [29, 16] </ref> have been mechanically verified. The function strerror, though mathematically trivial, is the only one left out because of the need to formalize IO, which we have not treated in our work. In the process of verifying the Berkeley C string library, three C programming errors were revealed.
Reference: [17] <author> Brian W. Kernighan and Dennis M. Ritchie. </author> <title> The C Programming Language, Second Edition. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliff, New Jersey, </address> <year> 1988. </year>
Reference-contexts: a quite natural and an easy extension to our specification. 5 The Results Using the techniques described here, we have managed to verify mechanically the object code produced by the Gnu C compiler for hundreds of lines of C, including some of the C code in Kernighan and Ritchie's book <ref> [17] </ref>, in particular binary search and Quick Sort. We have also tried to verify the Berkeley Unix C string library. Twenty-one functions out of twenty-two functions specified in the ISO standard [29, 16] have been mechanically verified.
Reference: [18] <author> Donald E. Knuth. </author> <booktitle> The Art of Computer Programming, </booktitle> <volume> volume 1. </volume> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1981. </year>
Reference-contexts: specifications in the logic of Nqthm. 2 The Automated Reasoning System Nqthm We briefly review the automated reasoning system Nqthm, also known as "the Boyer-Moore Theorem Prover." Detailed knowledge of Nqthm is unnecessary 3 It is relevant to review Knuth's defense, in the Preface to The Art of Computer Programming <ref> [18] </ref>, of his decision to present algorithms in assembly code rather than in a higher-level language. 2 for those who are happy enough with the informal paraphrases of the formulas in the remainder of this paper. Nqthm is a Common Lisp program for proving mathematical theorems. <p> In those classic papers of von Neu-mann and Goldstine, we find discussed the specification and correctness proofs for fifteen programs at the machine-code level. Proving the correctness of programs written in the assembly language MIX is a main feature of Knuth's magnum opus <ref> [18] </ref>. The informal, hand proof of object code produced by "industrial strength" compilers is not unheard of today for especially critical programs. Methods for program proving have been advanced most notably by Mc-Carthy [21], Floyd [11], and Hoare [13].
Reference: [19] <author> W. D. Maurer. </author> <title> An IBM 370 assembly language verifier. </title> <booktitle> In Proceedings of the 16th Annual Technical Symposium on Systems and Software: Operational Reliability and Performance Assurance. ACM, </booktitle> <month> June </month> <year> 1974. </year>
Reference-contexts: To the best of our knowledge, Maurer <ref> [20, 19] </ref> was the first to consider the verification, with an automated reasoning system, of machine-code programs for a fabricated microprocessor.
Reference: [20] <author> W. D. Maurer. </author> <title> Some correctness principles for machine language program and microprocessors. </title> <booktitle> In Proceedings of the Seventh Annual Workshop on Microprogramming, </booktitle> <address> Palo Alto, CA, </address> <year> 1974. </year>
Reference-contexts: To the best of our knowledge, Maurer <ref> [20, 19] </ref> was the first to consider the verification, with an automated reasoning system, of machine-code programs for a fabricated microprocessor.
Reference: [21] <author> John McCarthy. </author> <title> Towards a mathematical science of computation. </title> <booktitle> In Proceedings of IFIP Congress, </booktitle> <pages> pages 21-28, </pages> <year> 1962. </year>
Reference-contexts: The informal, hand proof of object code produced by "industrial strength" compilers is not unheard of today for especially critical programs. Methods for program proving have been advanced most notably by Mc-Carthy <ref> [21] </ref>, Floyd [11], and Hoare [13]. In the last twenty years, many research projects have investigated the formal, mechanical verification of programs written in higher-level languages.
Reference: [22] <author> Motorola, Inc. </author> <title> MC68020 32-bit Microprocessor User's Manual. </title> <publisher> Prentice Hall, </publisher> <address> New Jersey, </address> <year> 1989. </year>
Reference-contexts: The formal specification is intended to reflect as closely as possible the user's manual view of the MC68020 <ref> [22] </ref>. (A closely related instruction set will also be found on other Motorola MC68xxx microprocessors and micro-controllers, but we focused our formalization effort entirely on the MC68020.) We, at the present time, have avoided considering the supervisor level of the MC68020. <p> Our specification consists of about 80% of all the user available instructions. Most of the instructions we have left unspecified have some undefined effects on the machine state. For example, some of the condition codes of the instruction CMP2 are described as undefined in <ref> [22] </ref>. We have deliberately excluded these instructions in our specification. Fortunately, these instructions constitute only a small portion of the instruction set, and most of them are rarely used. 5 We summarize below those instructions formalized. <p> Fortunately, these instructions constitute only a small portion of the instruction set, and most of them are rarely used. 5 We summarize below those instructions formalized. The instructions of the MC68020 instruction set are classified into ten categories according to their functions <ref> [22] </ref>. 5 We have not yet encountered such instructions in the programs we have studied. 6 1. Data Movement. We have included all the data movement instructions: EXG, LEA, LINK, MOVE, MOVEA, MOVEM, MOVEP, MOVEQ, PEA. 2. Integer Arithmetic. <p> An addressing mode can specify a constant that is the operand, a register that contains the operand, or a location in memory where the operand is stored. For a complete description of the MC68020 addressing modes, we refer the reader to Motorola's MC68020 user's manual <ref> [22] </ref>. 3.2 The Formal Instruction-Level Specification Before we present some details of the formal specification, we first formally define the user visible state and its internal representation. 7 3.2.1 The User Visible State The only type of object manipulated at the instruction level is the bit vector, which is represented as <p> We also believe that it is unrealistic to assert the correctness of machine-code programs without carefully characterizing which parts of memory are read and written|few MC68020 chips are connected to a full 4 gigabytes of RAM. Memory protection issues are not specified in <ref> [22] </ref>. The functions `mc-status', `mc-rfile', `mc-pc', `mc-ccr' and `mc-mem' are ac-cessors to the machine status word, the register file, the program counter, the condition codes and the memory, respectively. <p> Condition Codes. We then specify the new values of the five condition codes returned by each of the instructions. In our example, we formalize the five condition codes by the following four functions, paraphrasing the description given in Table 3-11 of the MC68020 manual <ref> [22] </ref>. For the ADD instruction, the X condition is the same as the C condition. The function add-cvznx creates the new condition code register. <p> , n)), mbit (dopd , n))), b-and (mbit (sopd , n), b-not (mbit (result , n)))) endlet Definition: add-v (n, sopd , dopd ) = let result be add (n, sopd , dopd ) 6 This is only one of the two cases in the ADD instruction; please refer to <ref> [22] </ref> and [7] for more details. 12 in b-or (b-and (b-and (mbit (sopd , n), mbit (dopd , n)), b-not (mbit (result , n))), b-and (b-and (b-not (mbit (sopd , n)), b-not (mbit (dopd , n))), mbit (result , n))) endlet Definition: add-z (oplen, sopd , dopd ) = if add <p> Condition Code Computation. Ideally, we would specify the condition codes in a way most natural to the "user." But in order to assure full compliance with the MC68020 specification <ref> [22] </ref>, we have followed the syntactical definition described in Table 3-11 of [22]. <p> Condition Code Computation. Ideally, we would specify the condition codes in a way most natural to the "user." But in order to assure full compliance with the MC68020 specification <ref> [22] </ref>, we have followed the syntactical definition described in Table 3-11 of [22].
Reference: [23] <author> P. J. Plauger. </author> <title> Private communication. </title>
Reference-contexts: The second error had already been fixed by the author [27] when we reported it. A third error was in Plauger's book The Standard C Library [24]. This error had been detected by the author by the time we reported it to him <ref> [23] </ref>. These errors and all the C string library proofs are discussed in detail in Yuan Yu's dissertation [30].
Reference: [24] <author> P. J. Plauger. </author> <title> The Standard C Library. </title> <publisher> Prentice Hall, </publisher> <address> New Jersey, </address> <year> 1992. </year>
Reference-contexts: The second error had already been fixed by the author [27] when we reported it. A third error was in Plauger's book The Standard C Library <ref> [24] </ref>. This error had been detected by the author by the time we reported it to him [23]. These errors and all the C string library proofs are discussed in detail in Yuan Yu's dissertation [30].
Reference: [25] <author> Wolfgang Polak. </author> <title> Compiler Specification and Verification. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1981. </year>
Reference-contexts: In contrast to our approach to machine-code proof, compiler verification attempts to establish the correctness of the compiler, so that we are ensured that the compiler always generates correct binary code. Polak's work <ref> [25] </ref> seems the most ambitious compiler verification effort. Polak mechanically verified a compiler for a fairly substantial subset of Pascal. Moore's Piton and Young's Micro-Gypsy [2], two components of the CLI short stack, are major compiler verification efforts targeted on a more realistic von Neumann architecture|the verified and fabricated FM9001.
Reference: [26] <author> Richard L. </author> <title> Sites. Alpha Architecture Reference Manual. </title> <publisher> Digital Press, </publisher> <address> Bedford, Mass., </address> <year> 1992. </year>
Reference: [27] <author> Chris Torek. </author> <title> Private communication. </title>
Reference-contexts: In the process of verifying the Berkeley C string library, three C programming errors were revealed. Two were in the Berkeley Unix C string library. One error was undetected when we reported it to the 25 author <ref> [27] </ref>, and was to have been corrected for the release of BSD4.4. The second error had already been fixed by the author [27] when we reported it. A third error was in Plauger's book The Standard C Library [24]. <p> Two were in the Berkeley Unix C string library. One error was undetected when we reported it to the 25 author <ref> [27] </ref>, and was to have been corrected for the release of BSD4.4. The second error had already been fixed by the author [27] when we reported it. A third error was in Plauger's book The Standard C Library [24]. This error had been detected by the author by the time we reported it to him [23].
Reference: [28] <author> Alan M. </author> <title> Turing. On checking a large routine. In Report of a Conference on High Speed Automatic Calculating Machines, </title> <type> pages 67-69. </type> <institution> Univ. Math. Laboratory, </institution> <address> Cambridge, </address> <year> 1949. </year>
Reference-contexts: This section is by no means an exhaustive survey of the whole scientific field. Rather, we provide a brief account of related work, with an emphasis on mechanical program proving. Our work has built on the work of many others. Of historic interest is the early work of Turing <ref> [28] </ref> and Goldstine and von Neumann [12]. The careful proof of machine-code programs is coincident with the foundations of the von Neumann machine, first presented in [12].
Reference: [29] <institution> The ANSI Committee X3J11. ANSI Standard X3.159-1989. American National Standards Institute, </institution> <address> New York, </address> <year> 1989. </year>
Reference-contexts: We have also tried to verify the Berkeley Unix C string library. Twenty-one functions out of twenty-two functions specified in the ISO standard <ref> [29, 16] </ref> have been mechanically verified. The function strerror, though mathematically trivial, is the only one left out because of the need to formalize IO, which we have not treated in our work. In the process of verifying the Berkeley C string library, three C programming errors were revealed.
Reference: [30] <author> Yuan Yu. </author> <title> Automated Proofs of Object Code For a Widely Used Microprocessor. </title> <type> PhD thesis, </type> <institution> University of Texas at Austin, </institution> <year> 1992. </year> <title> For the dissertation text, see ftp://ftp.cs.utexas.edu/pub/techreports/tr93-09.ps.Z. See the files ./examples/yu/* in ftp://ftp.cs.utexas.edu/pub/boyer/nqthm-1992.tar.Z for replayable proof scripts of all the definitions and theorems mentioned in this paper and in the thesis. </title> <type> 33 </type>
Reference-contexts: Therefore, the proofs we describe are based solely on the definitions of our MC68020 model, and not on any nondefinitional axioms added during the project. Currently, our library of lemmas consists of approximately 1500 lemmas, about 120 pages of text. The full lemma library is presented in <ref> [30] </ref>. We give a few examples of typical lemmas below. Our experiments with the library, the topic of the next section, have been very satisfactory. <p> In this section, we will explain our approach with the correctness proof of some MC68020 object code that computes the greatest common divisor of two non-negative integers by Euclid's algorithm. One may find the complete script of our GCD proof in <ref> [30] </ref>. <p> A third error was in Plauger's book The Standard C Library [24]. This error had been detected by the author by the time we reported it to him [23]. These errors and all the C string library proofs are discussed in detail in Yuan Yu's dissertation <ref> [30] </ref>. Primarily to provide concrete evidence that this work is easily applicable to many other languages other than C, we have also mechanically verified the object code produced by the Verdix Ada compiler for an integer square root algorithm. <p> In addition to subroutines, we have studied some other interesting C language issues in the context of machine-code programs for the MC68020, such as functional parameters, computed jumps, and embedded assembly code. For a detailed discussion of these issues, we refer interested readers to Chapter 6 of <ref> [30] </ref>. 6 Future Directions As a next step, we plan to apply the mathematics so developed to another computer architecture, say, Alpha or Sparc. <p> Some examples are presented in <ref> [30] </ref>.
References-found: 30

