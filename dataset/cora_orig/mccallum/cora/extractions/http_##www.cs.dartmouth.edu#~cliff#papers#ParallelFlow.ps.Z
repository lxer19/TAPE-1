URL: http://www.cs.dartmouth.edu/~cliff/papers/ParallelFlow.ps.Z
Refering-URL: http://www.cs.dartmouth.edu/~cliff/papers/
Root-URL: http://www.cs.dartmouth.edu
Title: Parallel Algorithms for the Assignment and Minimum-Cost Flow Problems  
Author: James B. Orlin Clifford Stein 
Keyword: matching, assignment, parallel algorithm, scaling, minimum-cost flow  
Note: Research partially supported by NSF Grant DDM-8921835 and by Grant AFOSR-88-0088 from the Air Force Office of Scientific Research. Support provided by NSF PYI Award CCR-89-96272 with matching support from UPS and Sun and by an AT&T Bell Laboratories Graduate Fellowship. This work was done while this author was  
Address: Cambridge, MA  College  
Affiliation: Sloan School of Management M.I.T.  Department of Math and Computer Science Dartmouth  at MIT Laboratory for Computer Science.  
Abstract: Let G = (V; E) be a network for an assignment problem with 2n nodes and m edges, in which the largest edge cost is C. Recently the class of instances of bipartite matching problems has been shown to be in RNC provided that C is O(log k n) for some fixed k. We show how to use scaling so as to develop an improved parallel algorithm and show that bipartite matching problems are in the class RNC provided that C = O(n log k n ) for some fixed k. We then generalize these results to minimum-cost flow problems. Let U be an upper bound on the capacities of the edges and on the largest demand. We show that the minimum-cost flow problem is in the class RNC, provided that log(C + U ) = O(log k n) for some fixed k. Thus the minimum-cost flow problem is in the class RNC even when the magnitude of the costs and capacities are allowed to grow faster than any polynomial in n. The key to our approach is to reduce the number of processors needed from an amount that is proportional to the magnitude of the largest edge cost to an amount that is independent of the magnitude of the largest edge cost. The tradeoff is an increase in the running time that grows linearly in log(C + U ). 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. K. Ahuja, T. L. Magnanti, and J. B. Orlin. </author> <title> Network flows. In G.L. </title> <editor> Nemhauser, A. H. G. Rinnooy Kan, and M. J. Todd, editors, </editor> <booktitle> Handbook in operations research and management science, Volume 1: Optimization, </booktitle> <pages> pages 211-360. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1990. </year>
Reference-contexts: Before proceeding to analyze our algorithm, we address the issue of finding tight duals. In general, given an optimal flow for a minimum-cost flow problem, a single shortest-path computation suffices to find tight dual variables (see, for example <ref> [1] </ref>). As specialized to the assignment problem the algorithm is as follows. <p> We assume familiarity with the minimum-cost flow problem as we will only sketch the ideas needed to extend the class of minimum-cost flow instances that are in RN C. We refer the reader to <ref> [1, 14, 11] </ref> for more detail on minimum-cost flows. 6 The first idea is to show that a general minimum-cost flow problem can be reduced to a series of minimum-cost flow problems, each with small edge capacities. <p> We are now left with the problem of solving a minimum-cost circulation problem with n nodes, m edges, maximum edge cost C and maximum edge capacity m, and total supply m. Using a standard transformation, (see, for example <ref> [1] </ref>, [16]), we can convert this capac-itated flow problem into an uncapacitated transportation problem with m + n nodes, 2m edges, maximum demand m and maximum cost C. We now use another standard transformation (see, for example [14]) that converts an uncapacitated transportation problem into an assignment problem.
Reference: [2] <author> D. Coppersmith and S. Winograd. </author> <title> Matrix multiplication via arithmetic progression. </title> <journal> J. Symbolic Computation, </journal> <volume> 9 </volume> <pages> 251-280, </pages> <year> 1990. </year>
Reference-contexts: Currently M (n) = O (n 2:376 ) <ref> [2] </ref>, and trivially, M (n) = (n 2 ). Subsequently, a faster algorithm was discovered by Mulmuley, Vazirani, and Vazirani [15], that finds an assignment in O (log 2 n) time using nmCM (n) processors, where C is the largest edge cost in the input graph.
Reference: [3] <author> J. Edmonds and R.M. Karp. </author> <title> Theoretical improvements in algorithmic efficiency for network flow problems. </title> <journal> Journal of the ACM, </journal> <volume> 19 </volume> <pages> 248-264, </pages> <year> 1972. </year>
Reference-contexts: This fact is implicit in the algorithm of Edmonds and Karp <ref> [3] </ref>, here we make it explicit. Lemma 4.1 Let P be a minimum-cost flow problem with n nodes, m edges, maximum edge cost C and maximum edge capacity U . <p> Then P can be, in N C, reduced to the solution of O (log U ) minimum-cost circulation problems, each with n nodes, m edges, maximum edge cost C and maximum edge capacity m, and total supply m. Proof: As in <ref> [3] </ref>, we will introduce the capacities one bit at a time. We will now describe how to convert a minimum-cost flow with respect to the first ` bits of the capacities to one with respect to the first ` + 1 bits. <p> Given a flow f that is minimum-cost with respect to capacities u, we first double the flow and double the capacities. This still gives a minimum-cost flow. Next we introduce a new bit of capacity. The new flow may no longer be minimum-cost, but as is discussed in <ref> [3] </ref> it is "close" to a minimum-cost flow. We now bring the edges "in-kilter" by saturating residual edges with negative reduced-cost.
Reference: [4] <author> S. Fortune and J. Wyllie. </author> <title> Parallelism in random access machines. </title> <booktitle> In Proceedings of the 10th Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 114-118, </pages> <year> 1978. </year>
Reference-contexts: By iterating this algorithm on an appropriately derived graph, we also obtain improved results for the minimum-cost flow problem. Our model of computation is a parallel random-access machine (PRAM) <ref> [4] </ref>.
Reference: [5] <author> M.L. Fredman and R.E. Tarjan. </author> <title> Fibonacci heaps and their uses in improved network optimization algorithms. </title> <journal> Journal of the ACM, </journal> <volume> 34 </volume> <pages> 596-615, </pages> <year> 1987. </year>
Reference-contexts: Let M be a matching. We say that a set of dual variables is tight if c d (v; w) 0 8 (v; w) 2 E (1) The first algorithm for the assignment problem was Kuhn's Hungarian algorithm [13]. Implemented with Fibonacci heaps <ref> [5] </ref>, this algorithm runs in O (nm + n 2 log n) time, which remains the fastest strongly polynomial algorithm for the assignment problem. Gabow and Tarjan [8] have developed an algorithm that runs in O ( p nm log (nC)) time.
Reference: [6] <author> H. Gabow. </author> <title> Scaling algorithms for network problems. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 31 </volume> <pages> 148-168, </pages> <year> 1985. </year>
Reference-contexts: The algorithm is similar to the sequential algorithms of <ref> [6] </ref> and [8], as it iteratively finds an assignment and dual variables and then uses these to ensure that during the next iteration the graph contains a matching of small total cost.
Reference: [7] <author> H. N. Gabow and R. E. Tarjan. </author> <title> Almost-optimum parallel speed-ups of algorithms for bipartite matching and related problems. </title> <booktitle> In Proceedings of the 20th Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 514-527, </pages> <year> 1988. </year> <note> To appear in Journal of Algorithms. </note>
Reference-contexts: As neither one of these algorithms does less work than the other on all graphs, we will give our improvements relative to both of these algorithms. Other parallel algorithms for the assignment problem include <ref> [7] </ref>, [10] and [17]. 3 A Scaling Algorithm Our algorithm is a scaling algorithm, similar in general structure to the sequential matching algorithm of Gabow and Tarjan [8]. The algorithm proceeds in log C iterations.
Reference: [8] <author> H. N. Gabow and R. E. Tarjan. </author> <title> Faster scaling algorithms for network problems. </title> <journal> SIAM Journal on Computing, </journal> <volume> 18 </volume> <pages> 1013-1036, </pages> <year> 1989. </year>
Reference-contexts: The algorithm is similar to the sequential algorithms of [6] and <ref> [8] </ref>, as it iteratively finds an assignment and dual variables and then uses these to ensure that during the next iteration the graph contains a matching of small total cost. By iterating this algorithm on an appropriately derived graph, we also obtain improved results for the minimum-cost flow problem. <p> Implemented with Fibonacci heaps [5], this algorithm runs in O (nm + n 2 log n) time, which remains the fastest strongly polynomial algorithm for the assignment problem. Gabow and Tarjan <ref> [8] </ref> have developed an algorithm that runs in O ( p nm log (nC)) time. There are no known N C algorithms for the assignment problem; however, there are RN C algorithms under the assumption that the input is given in unary. <p> Other parallel algorithms for the assignment problem include [7], [10] and [17]. 3 A Scaling Algorithm Our algorithm is a scaling algorithm, similar in general structure to the sequential matching algorithm of Gabow and Tarjan <ref> [8] </ref>. The algorithm proceeds in log C iterations. At the beginning of each iteration, one bit is added to the costs and dual variables. Then a perfect matching and tight dual variables are found on the graph with edges of reduced cost no greater than 2n. <p> Then a perfect matching and tight dual variables are found on the graph with edges of reduced cost no greater than 2n. The new dual variables are added to the old ones and the iteration terminates. The details of the algorithm appear in Figure 1. The algorithm of <ref> [8] </ref> works in a similar manner, except that in their algorithm each iteration involves finding only an approximate matching. At each step, we find an exact matching and tight dual variables.
Reference: [9] <author> Z. Galil and V. Pan. </author> <title> Improved processor bounds for algebraic and combinatorial problems in RN C. </title> <booktitle> In Proceedings of the 26th Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 490-495, </pages> <year> 1985. </year> <note> To appear in Journal of the ACM. </note>
Reference-contexts: The first RN C algorithm under this assumption was given by Karp, Upfal, and Wigderson [12]. An implementation of this algorithm by Galil and Pan <ref> [9] </ref> uses (n + C 0 )M (n) processors and O (log n log 2 (nC 0 )) time where C 0 is an upper bound on the maximum cost of any matching, and M (n) is the minimum number of processors needed to multiply two n fi n matrices. <p> Proof: Immediate from Theorem 3.3 and the algorithms in [12], <ref> [9] </ref>, and [15]. Observe that our algorithm performs less work in the case that C = (n 1+* ) for some * &gt; 0.
Reference: [10] <author> A. V. Goldberg, S. A. Plotkin, and P. M. Vaidya. </author> <title> Sublinear-time parallel algorithms for matching and related problems. </title> <booktitle> In Proceedings of the 29th Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 174-185, </pages> <year> 1988. </year> <month> 8 </month>
Reference-contexts: As neither one of these algorithms does less work than the other on all graphs, we will give our improvements relative to both of these algorithms. Other parallel algorithms for the assignment problem include [7], <ref> [10] </ref> and [17]. 3 A Scaling Algorithm Our algorithm is a scaling algorithm, similar in general structure to the sequential matching algorithm of Gabow and Tarjan [8]. The algorithm proceeds in log C iterations. At the beginning of each iteration, one bit is added to the costs and dual variables.
Reference: [11] <author> A. V. Goldberg, R. E. Tarjan, and /'E. Tardos. </author> <title> Network flow algorithms. </title> <institution> Techni--cal Reprot STAN-CS-89-1252, Department of Computer Science, Stanford University, Stanford, </institution> <address> CA, </address> <month> March </month> <year> 1989. </year>
Reference-contexts: We assume familiarity with the minimum-cost flow problem as we will only sketch the ideas needed to extend the class of minimum-cost flow instances that are in RN C. We refer the reader to <ref> [1, 14, 11] </ref> for more detail on minimum-cost flows. 6 The first idea is to show that a general minimum-cost flow problem can be reduced to a series of minimum-cost flow problems, each with small edge capacities.
Reference: [12] <author> R. Karp, E. Upfal, and A. Wigderson. </author> <title> Constructing a perfect matching is in random N C. </title> <journal> Combinatorica, </journal> <volume> 6 </volume> <pages> 35-48, </pages> <year> 1986. </year>
Reference-contexts: 1 Introduction Karp, Upfal, and Wigderson <ref> [12] </ref>, and Mulmuley, Vazirani, and Vazirani [15], have recently developed randomized N C (RN C) 1 parallel algorithms for the minimum-cost perfect matching problem, assuming that the input is given in unary. <p> There are no known N C algorithms for the assignment problem; however, there are RN C algorithms under the assumption that the input is given in unary. The first RN C algorithm under this assumption was given by Karp, Upfal, and Wigderson <ref> [12] </ref>. <p> All other steps in the algorithm can be implemented in constant time on O (m + n) processors. Combining these observations with the fact that there are only log C iterations of the main loop, the theorem follows. Corollary 3.4 * Algorithm Assignment, combined with the matching algorithm of <ref> [12] </ref>, yields a randomized parallel algorithm for computing an MCPM using n 2 M (n) processors and O (log 3 n log C) time. * Algorithm Assignment, combined with the matching algorithm of [15], yields a randomized parallel algorithm for computing an MCPM using n 2 mM (n) processors in O <p> Proof: Immediate from Theorem 3.3 and the algorithms in <ref> [12] </ref>, [9], and [15]. Observe that our algorithm performs less work in the case that C = (n 1+* ) for some * &gt; 0.
Reference: [13] <author> H.W. Kuhn. </author> <title> The hungarian method for the assignment problem. </title> <journal> In Naval Research Logistics Quarterly, </journal> <volume> volume 2, </volume> <pages> pages 83-97, </pages> <year> 1955. </year>
Reference-contexts: Let M be a matching. We say that a set of dual variables is tight if c d (v; w) 0 8 (v; w) 2 E (1) The first algorithm for the assignment problem was Kuhn's Hungarian algorithm <ref> [13] </ref>. Implemented with Fibonacci heaps [5], this algorithm runs in O (nm + n 2 log n) time, which remains the fastest strongly polynomial algorithm for the assignment problem. Gabow and Tarjan [8] have developed an algorithm that runs in O ( p nm log (nC)) time.
Reference: [14] <author> E.L. Lawler. </author> <title> Combinatorial Optimization: Networks and Matroids. </title> <publisher> Holt, Rinehart and Winston, </publisher> <year> 1976. </year>
Reference-contexts: We assume familiarity with the minimum-cost flow problem as we will only sketch the ideas needed to extend the class of minimum-cost flow instances that are in RN C. We refer the reader to <ref> [1, 14, 11] </ref> for more detail on minimum-cost flows. 6 The first idea is to show that a general minimum-cost flow problem can be reduced to a series of minimum-cost flow problems, each with small edge capacities. <p> Using a standard transformation, (see, for example [1], [16]), we can convert this capac-itated flow problem into an uncapacitated transportation problem with m + n nodes, 2m edges, maximum demand m and maximum cost C. We now use another standard transformation (see, for example <ref> [14] </ref>) that converts an uncapacitated transportation problem into an assignment problem. If node v has demand d, we make d (v) copies of that node. For each edge (v; w) we put an edge between every copy of v and every copy of w.
Reference: [15] <author> K. Mulmuley, U.V. Vazirani, and V.V. Vazirani. </author> <title> Matching is as easy as matrix inversion. </title> <journal> Combinatorica, </journal> <volume> 7(1) </volume> <pages> 105-113, </pages> <year> 1987. </year>
Reference-contexts: 1 Introduction Karp, Upfal, and Wigderson [12], and Mulmuley, Vazirani, and Vazirani <ref> [15] </ref>, have recently developed randomized N C (RN C) 1 parallel algorithms for the minimum-cost perfect matching problem, assuming that the input is given in unary. For both of these algorithms, the number of processors needed is proportional to the magnitude of the largest number. <p> Currently M (n) = O (n 2:376 ) [2], and trivially, M (n) = (n 2 ). Subsequently, a faster algorithm was discovered by Mulmuley, Vazirani, and Vazirani <ref> [15] </ref>, that finds an assignment in O (log 2 n) time using nmCM (n) processors, where C is the largest edge cost in the input graph. <p> Corollary 3.4 * Algorithm Assignment, combined with the matching algorithm of [12], yields a randomized parallel algorithm for computing an MCPM using n 2 M (n) processors and O (log 3 n log C) time. * Algorithm Assignment, combined with the matching algorithm of <ref> [15] </ref>, yields a randomized parallel algorithm for computing an MCPM using n 2 mM (n) processors in O (log 2 n log C) time. Proof: Immediate from Theorem 3.3 and the algorithms in [12], [9], and [15]. <p> 3 n log C) time. * Algorithm Assignment, combined with the matching algorithm of <ref> [15] </ref>, yields a randomized parallel algorithm for computing an MCPM using n 2 mM (n) processors in O (log 2 n log C) time. Proof: Immediate from Theorem 3.3 and the algorithms in [12], [9], and [15]. Observe that our algorithm performs less work in the case that C = (n 1+* ) for some * &gt; 0.
Reference: [16] <author> J.B. Orlin. </author> <title> A faster strongly polynomial minimum cost flow problem. </title> <booktitle> In Proceedings of the 20th Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 377-387, </pages> <year> 1988. </year>
Reference-contexts: We are now left with the problem of solving a minimum-cost circulation problem with n nodes, m edges, maximum edge cost C and maximum edge capacity m, and total supply m. Using a standard transformation, (see, for example [1], <ref> [16] </ref>), we can convert this capac-itated flow problem into an uncapacitated transportation problem with m + n nodes, 2m edges, maximum demand m and maximum cost C. We now use another standard transformation (see, for example [14]) that converts an uncapacitated transportation problem into an assignment problem.
Reference: [17] <author> C.N.K. Osiakwan and S. Akl. </author> <title> A perfect speed-up parallel algorithm for the assignment problem on complete weighted bipartite graphs. </title> <booktitle> In Proceeding of IEEE Parbase 90, </booktitle> <pages> pages 293-304, </pages> <year> 1990. </year> <month> 9 </month>
Reference-contexts: As neither one of these algorithms does less work than the other on all graphs, we will give our improvements relative to both of these algorithms. Other parallel algorithms for the assignment problem include [7], [10] and <ref> [17] </ref>. 3 A Scaling Algorithm Our algorithm is a scaling algorithm, similar in general structure to the sequential matching algorithm of Gabow and Tarjan [8]. The algorithm proceeds in log C iterations. At the beginning of each iteration, one bit is added to the costs and dual variables.
References-found: 17

