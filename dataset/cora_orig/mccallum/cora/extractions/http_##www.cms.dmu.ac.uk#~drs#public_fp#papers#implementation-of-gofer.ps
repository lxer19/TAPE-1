URL: http://www.cms.dmu.ac.uk/~drs/public_fp/papers/implementation-of-gofer.ps
Refering-URL: http://www.cms.dmu.ac.uk/~drs/public_fp/papers/
Root-URL: 
Email: jones-mark@cs.yale.edu  
Title: The implementation of the Gofer functional programming system  
Author: Mark P. Jones 
Date: May 1994  
Address: P.O. Box 208285, New Haven, CT 06520-8285.  
Affiliation: Yale University, Department of Computer Science,  
Pubnum: Research Report YALEU/DCS/RR-1030  
Abstract: This report describes the main ideas and techniques used in the implementation of Gofer. This information will be particularly useful for work using Gofer as a platform to explore the use of new language features or primitives. It should also be of interest to those curious to see how the general techniques of functional programming language compilation are adapted to a simple, but practical, implementation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Tiuryn A.J. Kfoury and P. Urzyczyn. </author> <title> Type reconstruction in the presence of polymorphic recursion. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(2) </volume> <pages> 290-311, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: than we might expect: let id x = x succ y = id y + 1 in id True A proper understanding of this relies on the fact that, in the pure Hindley/Milner type system, all calls to functions within a single binding group are assigned the same monomorphic type <ref> [1] </ref>. Dependency analysis is discussed in more detail in [48, Section 6.2.8] and in [16, Section 4.5.1]. <p> Hence the following example is not permitted: strange :: a -&gt; Bool strange x = strange [x] This restriction is necessary to avoid some of the problems with polymorphic recursion and type inference, as described in <ref> [1] </ref>. However, it is quite likely that future versions of both Haskell and Gofer will be extended to permit a weaker form of polymorphic recursion, requiring an explicit type signature for any let-bound variable that is used in this way.
Reference: [2] <author> Andrew W. Appel. </author> <title> Garbage collection can be faster than stack allocation. </title> <journal> Information Processing Letters, </journal> <volume> 25(4) </volume> <pages> 275-279, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: Indeed, it has even been argued that the use of garbage collection can be faster than other forms of memory allocation <ref> [2] </ref>, although we would not attempt to make any such claims for the particular garbage collection system used in Gofer.
Reference: [3] <author> Andrew W. Appel and David B. MacQueen. </author> <title> Standard ML of New Jersey. </title> <editor> In Martin Wirsing, editor, </editor> <booktitle> Third International Symposium on Programming Language Implementation and Logic Programming, </booktitle> <pages> pages 1-13, </pages> <address> New York, </address> <month> August </month> <year> 1991. </year> <note> Springer-Verlag. Lecture Notes in Computer Science. </note>
Reference-contexts: This approach is often used by designers as a means of testing, and of demonstrating confidence, in the use of a new language for program development. For example, Chalmers LML [4], Standard ML of New Jersey <ref> [3] </ref> and Glasgow Haskell [12] are all able to compile their own source code. However, each of these systems requires substantial machine resources.
Reference: [4] <author> L. Augustsson and T. Johnsson. </author> <title> The Chalmers Lazy-ML compiler. </title> <journal> The computer journal, </journal> <volume> 32(2) </volume> <pages> 127-141, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: This approach is often used by designers as a means of testing, and of demonstrating confidence, in the use of a new language for program development. For example, Chalmers LML <ref> [4] </ref>, Standard ML of New Jersey [3] and Glasgow Haskell [12] are all able to compile their own source code. However, each of these systems requires substantial machine resources. <p> While there are some differences, this part of the Gofer system borrows heavily on the ideas used in the Chalmers G-machine, described in <ref> [4, 48] </ref>. On the other hand, by isolating the details of the abstract machine in a single file, it should, in principle, be possible to replace this part of the Gofer system with alternative back-ends, for example, based on the Three Instruction Machine [60].
Reference: [5] <author> Lennart Augustsson. </author> <title> Implementing haskell overloading. </title> <booktitle> In FPCA '93: Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> Copenhagen, Denmark, New York, June 1993. </address> <publisher> ACM Press. </publisher>
Reference-contexts: In addition, this permits further useful extensions such as the possibility of defining overlapping instances. Several researchers, including this author, have investigated the theory and formal properties of type classes [8, 30, 29, 36, 44, 45, 50, 53] and there has 27 also been some experience with practical implemen-tations <ref> [14, 28, 46, 5] </ref> and applications [27, 38, 13]. Since these topics are so well-documented, we will concentrate here only on the special features in the implementation of Gofer.
Reference: [6] <author> J.E. Hopcroft A.V. Aho and D. Ullman. </author> <title> Design and analysis of algorithms. </title> <publisher> Addison Wesley, </publisher> <year> 1983. </year>
Reference-contexts: In Gofer, the dependency analysis is implemented using a small modified version of a standard algorithm that automatically produces the strongly-connected components in the required order <ref> [51, 6] </ref>. The core of the algorithm is contained in the file scc.c. This file is set up to allow different instances of the dependency analysis algorithm to be generated using the C preprocessor and #includeing several copies of the code.
Reference: [7] <author> R. Bird and P. Wadler. </author> <title> Introduction to functional programming. </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: Instead, new definitions are entered using a text editor to produce a script file of definitions that can then be loaded into the interpreter. The strict separation between sessions and scripts was a conscious design decision, inspired by <ref> [7] </ref> and [58], reflecting the way we expect the system to be used in practice. In particular, this approach allows a programmer to work by switching between scripts and sessions, adding new definitions, testing, 3 and making further changes as necessary. <p> The interpreter allows users to develop special versions of the prelude to suit particular requirements. For example, this feature has been used to support experimental preludes using constructor classes, or to provide closer compatibility with Haskell, or with a textbook such as <ref> [7] </ref> in an introductory course on functional programming. On the other hand, the system is carefully designed to ensure that the prelude file will only be loaded once when the interpreter is started.
Reference: [8] <author> Stephen M. Blott. </author> <title> An approach to overloading with polymorphism. </title> <type> PhD thesis, </type> <institution> Department of Computing Science, University of Glasgow, </institution> <month> July </month> <year> 1991. </year> <note> (draft version). </note>
Reference-contexts: In addition, this permits further useful extensions such as the possibility of defining overlapping instances. Several researchers, including this author, have investigated the theory and formal properties of type classes <ref> [8, 30, 29, 36, 44, 45, 50, 53] </ref> and there has 27 also been some experience with practical implemen-tations [14, 28, 46, 5] and applications [27, 38, 13]. Since these topics are so well-documented, we will concentrate here only on the special features in the implementation of Gofer.
Reference: [9] <author> H.-J. Boehm and M. Weiser. </author> <title> Garbage collection in an uncooperative environment. </title> <journal> Software-Practice and Experience, </journal> <volume> 18(9) </volume> <pages> 807-820, </pages> <month> Septem-ber </month> <year> 1988. </year>
Reference-contexts: As if the limitations of the garbage collector that we have already discussed are not enough, there are some further problems that we should mention. * First, the garbage collector is conservative, in the sense that it may preserve parts of the heap that are not actually needed <ref> [59, 9] </ref>. This happens when the garbage collector misinterprets a value on the C stack as a pointer into the heap. In some situations, this causes a space-leak, preserving large data structures long beyond the point where they are actually needed.
Reference: [10] <author> R.S. Boyer and J.S. Moore. </author> <title> The sharing of structure in theorem proving programs. </title> <journal> Machine Intelligence, </journal> <volume> 7, </volume> <booktitle> 1972. </booktitle> <publisher> Edinburgh University Press. </publisher>
Reference-contexts: Notice that this skeleton is taken directly from the original polymorphic type; there is no need for copying. Since every instance uses the same skeleton, we describe this approach as structure sharing. The same terminology is used for similar purposes, in the implementation of logic programming languages <ref> [10] </ref>.
Reference: [11] <author> L. Damas and R. Milner. </author> <title> Principal type schemes for functional programs. </title> <booktitle> In 9th Annual ACM Symposium on Principles of Programming languages, </booktitle> <pages> pages 207-212, </pages> <address> Albuquerque, N.M., </address> <month> Jan-uary </month> <year> 1982. </year>
Reference-contexts: The Gofer type checker builds on a large body of theoretical work, most of which we will not attempt to describe here. In particular, we will assume some familiarity with the basics of standard type inference algorithms <ref> [41, 11] </ref> and with the extensions of this work to qualified types [26, 30, 29] and to constructor classes [33], on which the type checker depends for its theoretical basis.
Reference: [12] <author> C. Hall, K. Hammond, W. Partain, S.L. Peyton Jones, and P. Wadler. </author> <title> The glasgow haskell compiler: a retrospective. </title> <booktitle> In Proceedings of the 1992 Glasgow Workshop on Functional Programming, </booktitle> <address> Ayr, Scotland, July 1992. </address> <publisher> Springer Verlag Workshops in computing series. </publisher>
Reference-contexts: This approach is often used by designers as a means of testing, and of demonstrating confidence, in the use of a new language for program development. For example, Chalmers LML [4], Standard ML of New Jersey [3] and Glasgow Haskell <ref> [12] </ref> are all able to compile their own source code. However, each of these systems requires substantial machine resources. In addition, we were also concerned about bootstrapping; each of the systems above relies on a compiler to achieve reasonable performance, while Gofer was originally conceived as an interpreter.
Reference: [13] <author> Cordelia V. Hall. </author> <title> Using overloading to express distinctions between evaluators. </title> <journal> Information Processing Letters, </journal> <month> December </month> <year> 1993. </year>
Reference-contexts: Several researchers, including this author, have investigated the theory and formal properties of type classes [8, 30, 29, 36, 44, 45, 50, 53] and there has 27 also been some experience with practical implemen-tations [14, 28, 46, 5] and applications <ref> [27, 38, 13] </ref>. Since these topics are so well-documented, we will concentrate here only on the special features in the implementation of Gofer. We will also assume that the reader is familiar with the syntax and use of type classes in Gofer, as described in [24, Chapter 14].
Reference: [14] <author> K. Hammond and S. Blott. </author> <title> Implementing Haskell type classes. </title> <booktitle> In Proceedings of the 1989 50 Glasgow Workshop on Functional Programming, </booktitle> <address> Fraserburgh, Scotland, 1989. </address> <publisher> Springer Verlag Workshops in computing series. </publisher>
Reference-contexts: In addition, this permits further useful extensions such as the possibility of defining overlapping instances. Several researchers, including this author, have investigated the theory and formal properties of type classes [8, 30, 29, 36, 44, 45, 50, 53] and there has 27 also been some experience with practical implemen-tations <ref> [14, 28, 46, 5] </ref> and applications [27, 38, 13]. Since these topics are so well-documented, we will concentrate here only on the special features in the implementation of Gofer.
Reference: [15] <author> Sho huan Simon Tung. </author> <title> Interactive modular programming in Scheme. </title> <booktitle> In ACM conference on LISP and Functional Programming, </booktitle> <address> San Fran-cisco, CA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: This would require a fair amount of work, but otherwise seems quite feasible. The most difficult task would be to adapt the current interactive user interface to deal properly with collections of program modules. See <ref> [15] </ref> for work dealing with similar problems, targeted at Scheme programmers. On the other hand, the Haskell module system has been criticized as one of the weakest parts of the language definition, and may perhaps change in future versions of the language.
Reference: [16] <editor> P. Hudak, S. Peyton Jones, and P. Wadler (editors). </editor> <title> Report on the Programming Language Haskell, A Non-strict Purely Functional Language (Version 1.2). </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 27(5), </volume> <month> May </month> <year> 1992. </year>
Reference-contexts: Throughout this report, we assume familiarity with the Gofer environment as described in the user documentation [24, 25, 32], with the Haskell functional programming language on which much of the language design is based <ref> [16] </ref>, and with the C programming language in which the system is implemented. Outline of report We begin in Section 1, outlining the principal design goals for the development of the Gofer system. <p> The system was designed with some specific goals in mind: * Compatibility: The language design should be closely based on the definition of Haskell, an emerging and freely available standard for non-strict functional programming languages <ref> [16] </ref>. Of course, Haskell was also a natural choice for work on type class overloading and guaranteed an initial supply of examples on which to base any comparisons. <p> means unique in providing a functional programming environment for smaller systems; Leroy's Caml Light [40], implementing a dialect of ML, is another well-known example. 2 A user's perspective The Gofer system 2 provides an interpreter for an experimental language that is closely based on the definition of Haskell version 1.2 <ref> [16] </ref>. <p> The lexical analyzer is able to read Gofer script files using both the standard and literate styles. In the latter case, program lines in input files must begin with a `&gt;' character in the first column; all other lines are treated as comments. This convention, described more fully in <ref> [16, Appendix c] </ref>, is widely used because it allows program text to be freely mixed with its documentation. The ability to read literate scripts directly without preprocessing does not significantly increase the complexity of the lexical analyzer. <p> In Gofer, the second interpretation is used for both expressions; (n+k) patterns cannot be used at the top-level of a pattern binding, with or without the parentheses. Another interesting aspect of the Gofer parser is the way that expressions involving infix operators are treated. The Haskell grammar <ref> [16, Appendix B] </ref> defines the syntax for infix operators using a complex family of productions indexed by precedence and fixity values. Implementing this directly as a yacc grammar would cause a significant increase in the size of the grammar. <p> For example, the case expression: case expr of True -&gt; branch1 False -&gt; branch2 is transformed, by the insertion of these additional tokens, to: case expr of True -&gt; branch1; False -&gt; branch2 - We refer the reader to [24, Chapter 13] and <ref> [16, Section 1.5] </ref> for a more complete description of the layout rule and its use. The implementation of the layout rule is a little tricky and relies quite heavily on the error recovery features of yacc and on some mildly complicated interactions between the lexer and parser. <p> Dependency analysis is discussed in more detail in [48, Section 6.2.8] and in <ref> [16, Section 4.5.1] </ref>. A secondary reason for using dependency analysis in the current implementation is to make Gofer programs easier for the type checker to digest; as we describe in the next section, the Gofer type checker works best when a program can be split into small binding groups. <p> There are three cases: * If the binding group contains any pattern bindings, or if it contains variable bindings (i.e. bindings in which the left hand side is a single variable) without any explicit type declarations, then the monomorphism restriction applies as described in <ref> [16, Section 4.5.4] </ref> and [24, Section 14.4.6]. <p> On the other hand, the definition of foldr in the Haskell report <ref> [16] </ref>, although equivalent, does not use a local definition. We will see that main effect of lambda-lifting in this example is to convert the definition above into something more closely resembling the definition in the Haskell report.
Reference: [17] <editor> P. Hudak and P. Wadler (editors). </editor> <title> Report on the Programming Language Haskell, A Non-strict Purely Functional Language (Version 1.0). </title> <type> Technical report, </type> <institution> University of Glasgow, </institution> <month> April </month> <year> 1990. </year>
Reference-contexts: Note that, although speed of execution is an important part of making an implementation usable, we did not consider this as a primary design goal. Looking back, we believe that we have been reasonably successful in meeting these goals. Initially based on version 1.0 of the Haskell report <ref> [17] </ref>, Gofer has been modified to track subsequent versions of Haskell. As a result, there is a large class of programs that can be run using either Haskell or Gofer without requiring changes to the source code.
Reference: [18] <author> R.J.M. Hughes. </author> <title> Graph reduction with supercom-binators. </title> <type> Technical monograph PRG-28, </type> <institution> Programming Research Group, Oxford University Computing Laboratory, </institution> <year> 1982. </year>
Reference-contexts: The result is a program containing only closed, global functions known as supercombinators, a term coined by Hughes in his presentation of an algorithm for lambda-lifting <ref> [18] </ref>. The Gofer compiler includes an implementation of an alternative algorithm proposed by Johns-son, who also introduced the term lambda-lifting [20]. Other descriptions of Johnsson's algorithm may be found in [48, Section 14.6] and in [49, Chapter 6].
Reference: [19] <author> S.C. Johnson. </author> <title> Yacc: yet another compiler-compiler. Unix programmer's manual 2B. </title>
Reference-contexts: Combining a hand-written lexical analyzer and a yacc generated parser <ref> [19] </ref>, this part of the system draws on standard techniques of compiler construction. 5.1 Lexical analysis Most of the code for lexical analysis is included in the file input.c.
Reference: [20] <author> T. Johnsson. </author> <title> Lambda lifting: transforming programs to recursive equations. </title> <editor> In Jouannaud, editor, </editor> <booktitle> Proceedings of the IFIP conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 190-205, </pages> <address> New York, </address> <year> 1985. </year> <note> Springer-Verlag. Lecture Notes in Computer Science, 201. </note>
Reference-contexts: The result is a program containing only closed, global functions known as supercombinators, a term coined by Hughes in his presentation of an algorithm for lambda-lifting [18]. The Gofer compiler includes an implementation of an alternative algorithm proposed by Johns-son, who also introduced the term lambda-lifting <ref> [20] </ref>. Other descriptions of Johnsson's algorithm may be found in [48, Section 14.6] and in [49, Chapter 6].
Reference: [21] <author> Mark P. Jones. </author> <title> A new approach to type class overloading. Distributed on Haskell mailing list, </title> <month> February </month> <year> 1991. </year>
Reference-contexts: The initial design included a small interpreter intended only for simple calculations, but this soon became the main focus of the project, motivated in particular by the desire to investigate a new implementation technique for the Haskell overloading mechanism <ref> [21] </ref>. The system was designed with some specific goals in mind: * Compatibility: The language design should be closely based on the definition of Haskell, an emerging and freely available standard for non-strict functional programming languages [16].
Reference: [22] <author> Mark P. Jones. </author> <title> Computing with lattices: An application of type classes. </title> <type> Technical Report PRG-TR-11-90, </type> <institution> Programming Research Group, Oxford University Computing Laboratory, </institution> <address> Oxford, England, </address> <month> June </month> <year> 1990. </year> <note> Superceded by [27]. </note>
Reference: [23] <author> Mark P. Jones, </author> <month> October </month> <year> 1991. </year> <note> Article posted on the internet newsgroup comp.lang.functional. </note>
Reference-contexts: For example, as we will see in the following section, a ROOT 1 instruction is used in the compilation of map. The root optimization was originally described in <ref> [23] </ref>, including figures suggesting a 25-30% reduction in space requirements for some small examples using the optimization.
Reference: [24] <author> Mark P. Jones. </author> <title> Introduction to Gofer 2.20, </title> <month> September </month> <year> 1991. </year> <note> Available by anonymous ftp from nebula.cs.yale.edu in the directory pub/haskell/gofer as part of the standard Gofer distribution. </note>
Reference-contexts: First, that it runs on a wide range of machines, including small home computers. Second, particularly on more powerful systems, the interpreter provides a fast, interactive development environment, avoiding the need for lengthy recompilation. While the user documentation <ref> [24] </ref> and C source code for Gofer have always been included in public distributions, there was no substantial effort to provide details about the implementation. At the time, this seemed unnecessary; although it introduced some new ideas, most of the techniques used were believed to be standard and well-known. <p> Throughout this report, we assume familiarity with the Gofer environment as described in the user documentation <ref> [24, 25, 32] </ref>, with the Haskell functional programming language on which much of the language design is based [16], and with the C programming language in which the system is implemented. <p> For example, the case expression: case expr of True -&gt; branch1 False -&gt; branch2 is transformed, by the insertion of these additional tokens, to: case expr of True -&gt; branch1; False -&gt; branch2 - We refer the reader to <ref> [24, Chapter 13] </ref> and [16, Section 1.5] for a more complete description of the layout rule and its use. <p> Since these topics are so well-documented, we will concentrate here only on the special features in the implementation of Gofer. We will also assume that the reader is familiar with the syntax and use of type classes in Gofer, as described in <ref> [24, Chapter 14] </ref>. Following the suggestions of Wadler and Blott [57], the implementation of overloading in Gofer makes heavy use of dictionary values. Roughly speaking, a dictionary is a tuple of values containing the implementation of overloaded functions corresponding to a particular instance of a class. <p> Note that the superclass/subclass terminology used here is not really appropriate since it is possible to have mutually recursive classes each of which includes the other as a distinct `superclass' (see <ref> [24, Chapter 14] </ref> for example). <p> There are three cases: * If the binding group contains any pattern bindings, or if it contains variable bindings (i.e. bindings in which the left hand side is a single variable) without any explicit type declarations, then the monomorphism restriction applies as described in [16, Section 4.5.4] and <ref> [24, Section 14.4.6] </ref>.
Reference: [25] <author> Mark P. Jones. </author> <note> Release notes for Gofer 2.21, </note> <month> November </month> <year> 1991. </year> <title> Included as part of the standard Gofer distribution. </title>
Reference-contexts: Throughout this report, we assume familiarity with the Gofer environment as described in the user documentation <ref> [24, 25, 32] </ref>, with the Haskell functional programming language on which much of the language design is based [16], and with the C programming language in which the system is implemented.
Reference: [26] <author> Mark P. Jones. </author> <title> Type inference for qualified types. </title> <type> Technical Report PRG-TR-10-91, </type> <institution> Programming Research Group, Oxford University Computing Laboratory, </institution> <address> Oxford, England, </address> <month> May </month> <year> 1991. </year> <note> Largely superceded by [29]. </note>
Reference-contexts: The Gofer type checker builds on a large body of theoretical work, most of which we will not attempt to describe here. In particular, we will assume some familiarity with the basics of standard type inference algorithms [41, 11] and with the extensions of this work to qualified types <ref> [26, 30, 29] </ref> and to constructor classes [33], on which the type checker depends for its theoretical basis. <p> As we started to add the extra mechanisms required to support type classes, it became clear that we did not have sufficient understanding of the underlying theory to complete the implementation. A further three months study, resulting in the work described in <ref> [26] </ref> and later summarized in [30], was necessary before we were able to complete the type checker.
Reference: [27] <author> Mark P. Jones. </author> <title> Computing with lattices: An application of type classes. </title> <journal> Journal of Functional Programming, </journal> <volume> 2(4), </volume> <month> October </month> <year> 1992. </year> <note> Updated and expanded version of [22]. </note>
Reference-contexts: Several researchers, including this author, have investigated the theory and formal properties of type classes [8, 30, 29, 36, 44, 45, 50, 53] and there has 27 also been some experience with practical implemen-tations [14, 28, 46, 5] and applications <ref> [27, 38, 13] </ref>. Since these topics are so well-documented, we will concentrate here only on the special features in the implementation of Gofer. We will also assume that the reader is familiar with the syntax and use of type classes in Gofer, as described in [24, Chapter 14].
Reference: [28] <author> Mark P. Jones. </author> <title> Efficient implementation of type class overloading (draft). </title> <note> Superseded by [29, Chapters 6 and 7], </note> <month> March </month> <year> 1992. </year>
Reference-contexts: In addition, this permits further useful extensions such as the possibility of defining overlapping instances. Several researchers, including this author, have investigated the theory and formal properties of type classes [8, 30, 29, 36, 44, 45, 50, 53] and there has 27 also been some experience with practical implemen-tations <ref> [14, 28, 46, 5] </ref> and applications [27, 38, 13]. Since these topics are so well-documented, we will concentrate here only on the special features in the implementation of Gofer.
Reference: [29] <author> Mark P. Jones. </author> <title> Qualified Types: Theory and Practice. </title> <type> PhD thesis, </type> <institution> Programming Research Group, Oxford University Computing Laboratory, </institution> <month> July </month> <year> 1992. </year> <note> To be published by Cambridge University Press. Currently available as Technical Monograph PRG-106, </note> <institution> Oxford University Computing Laboratory, Programming Research Group, </institution> <address> 11 Keble Road, Oxford OX1 3QD, U.K. email: library@comlab.ox.ac.uk. </address>
Reference-contexts: The Gofer type checker builds on a large body of theoretical work, most of which we will not attempt to describe here. In particular, we will assume some familiarity with the basics of standard type inference algorithms [41, 11] and with the extensions of this work to qualified types <ref> [26, 30, 29] </ref> and to constructor classes [33], on which the type checker depends for its theoretical basis. <p> The reverse process, generalizing a monomorphic type to determine the most general type possible, is also an important operation in a type inference system. The generalization of a qualified type in the presence of an assumption set A is represented by the notation Gen (A; ) in <ref> [29] </ref>. Some authors describe this as the closure of a type with respect to a particular set of assumptions. <p> In addition, this permits further useful extensions such as the possibility of defining overlapping instances. Several researchers, including this author, have investigated the theory and formal properties of type classes <ref> [8, 30, 29, 36, 44, 45, 50, 53] </ref> and there has 27 also been some experience with practical implemen-tations [14, 28, 46, 5] and applications [27, 38, 13]. Since these topics are so well-documented, we will concentrate here only on the special features in the implementation of Gofer. <p> This significantly reduces the amount of space required to store the set of dictionaries that are used in a particular program and avoids the problems of repeated construction discussed in <ref> [29, Chapter 6] </ref>. The sharing of dictionaries is achieved by implementing makeDict () as a kind of memo-function. For each class, there is a corresponding index mapping mono-types or constructors to dictionaries. <p> Instead, the predicate is treated as a constraint on the environment that contains the binding group. These two cases correspond directly to the concepts of constant and locally constant overload ing described in <ref> [30, 29] </ref>. * The remaining predicates in preds are simplified as much as possible to reduce the number of dictionary parameters that will be required. The simplification process eliminates duplicate predicates from preds. <p> The simplification process eliminates duplicate predicates from preds. Predicates can also be eliminated if they can be derived either as super-classes or instance specifics from other members of preds. As described in <ref> [29, Section 8.2.3] </ref>, we now consider the use of instance specifics in this way to be an error in the original design, and may change this behaviour in future releases of the system. <p> A flexible implementation of extensible records, building on the use of qualified types and hence suitable for inclusion in Gofer, has been proposed in <ref> [29] </ref>. We hope to experiment with a prototype implementation of this system in the near future. Performance and optimization Given that execution speed was never a major design Goal, we have been pleasantly surprised by the performance of the Gofer interpreter.
Reference: [30] <author> Mark P. Jones. </author> <title> A theory of qualified types. </title> <booktitle> In ESOP '92: European Symposium on Programming, Rennes, </booktitle> <address> France, New York, </address> <month> February </month> <year> 1992. </year> <note> Springer-Verlag. Lecture Notes in Computer Science, 582. </note>
Reference-contexts: The Gofer type checker builds on a large body of theoretical work, most of which we will not attempt to describe here. In particular, we will assume some familiarity with the basics of standard type inference algorithms [41, 11] and with the extensions of this work to qualified types <ref> [26, 30, 29] </ref> and to constructor classes [33], on which the type checker depends for its theoretical basis. <p> As we started to add the extra mechanisms required to support type classes, it became clear that we did not have sufficient understanding of the underlying theory to complete the implementation. A further three months study, resulting in the work described in [26] and later summarized in <ref> [30] </ref>, was necessary before we were able to complete the type checker. In conclusion, you should not expect to understand the full details of the implementation of the Gofer type checker unless you are prepared to spend a considerable amount of time studying and examining it. <p> In addition, this permits further useful extensions such as the possibility of defining overlapping instances. Several researchers, including this author, have investigated the theory and formal properties of type classes <ref> [8, 30, 29, 36, 44, 45, 50, 53] </ref> and there has 27 also been some experience with practical implemen-tations [14, 28, 46, 5] and applications [27, 38, 13]. Since these topics are so well-documented, we will concentrate here only on the special features in the implementation of Gofer. <p> Instead, the predicate is treated as a constraint on the environment that contains the binding group. These two cases correspond directly to the concepts of constant and locally constant overload ing described in <ref> [30, 29] </ref>. * The remaining predicates in preds are simplified as much as possible to reduce the number of dictionary parameters that will be required. The simplification process eliminates duplicate predicates from preds.
Reference: [31] <author> Mark P. Jones. </author> <title> Partial evaluation for dictionary-free overloading. </title> <institution> Research Report YALEU/DCS/RR-959, Yale University, </institution> <address> New Haven, Connecticut, USA, </address> <month> April </month> <year> 1993. </year>
Reference-contexts: Others, for example, the specialized partial evaluator described in <ref> [31] </ref>, have yet to be included in the standard distribution. Finally, the Gofer system has proved to be fairly portable and includes support for a wide variety of different machine and operating system environments.
Reference: [32] <author> Mark P. Jones. </author> <note> Release notes for Gofer 2.28, </note> <month> February </month> <year> 1993. </year> <title> Included as part of the standard Gofer distribution. </title>
Reference-contexts: Throughout this report, we assume familiarity with the Gofer environment as described in the user documentation <ref> [24, 25, 32] </ref>, with the Haskell functional programming language on which much of the language design is based [16], and with the C programming language in which the system is implemented.
Reference: [33] <author> Mark P. Jones. </author> <title> A system of constructor classes: overloading and implicit higher-order polymor-phism. </title> <booktitle> In FPCA '93: Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> Copenhagen, Denmark, New York, June 1993. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Examples of this include: * A simple-minded compiler, translating Gofer programs to C to enable the development of stan dalone applications written in Gofer. * An system of constructor classes, extending the notion of Haskell type classes, to allow more sophisticated forms of user-defined overloading <ref> [33] </ref>. Others, for example, the specialized partial evaluator described in [31], have yet to be included in the standard distribution. Finally, the Gofer system has proved to be fairly portable and includes support for a wide variety of different machine and operating system environments. <p> UNIT is also used as the representation for the Gofer value (), the only value (other than ?) of type (). WILDCARD, representing the wildcard pat tern _. STAR, representing the kind of all types, an important concept in the treatment of constructor classes <ref> [33] </ref>. Function kinds, mapping constructors of kind k1 to constructors of kind k2, are represented by pair (k1,k2). 8 * Tuples: Used in the representation of tuple types and values. For example, mkTuple (2) is used in the construction of pairs. <p> The details about the type constructor represented by a Cell value tc are recorded in the C structure tycon (tc). For example: - tycon (tc).text gives the name of tc as a Text value. - tycon (tc).kind gives the kind of tc, as described in <ref> [33] </ref>. - tycon (tc).what contains a code indicating whether the type constructor was defined by a data definition (DATATYPE), a type synonym (SYNONYM), or a restricted type synonym (RESTRICTSYN). - tycon (tc).defn contains the expansion of a type synonym or the list of constructor functions for an algebraic datatype. <p> The presence of type variables, signaling a polymorphic type, is represented by POLYTYPE values, with the Sig field used to record the kinds of polymorphic type variables 7 . A full description of the representation of polymorphic types requires a fairly good understanding of the technical issues discussed in <ref> [33] </ref>. We will illustrate the main ideas by describing the representation of the Gofer type a -&gt; m a. <p> In particular, we will assume some familiarity with the basics of standard type inference algorithms [41, 11] and with the extensions of this work to qualified types [26, 30, 29] and to constructor classes <ref> [33] </ref>, on which the type checker depends for its theoretical basis. To give some historical insight to these references, it took approximately three months to develop the first version of Gofer version 2.xx that was capable of running small programs and included a Hindley/Milner style type checker. <p> Although we describe the workings of the type checker in terms of type variables and type expressions, we should remember that the system of constructor classes presented in <ref> [33] </ref> also allows variables and constructors with kinds other than fl, the kind of types. <p> Using the same ideas and notation, Gofer extends the basic system of type classes used in Haskell in a number of ways, for example, allowing multiple parameter classes, mutually recursive class definitions and constructor classes <ref> [33] </ref>. The Gofer type system also differs in subtle ways from that of Haskell in its treatment of type classes. This allows (in fact, requires) the use of arbitrary forms of class constraints in type expressions and leads to a particularly simple implementation. <p> The kind system in Gofer is used primarily to support the implementation of constructor classes described in <ref> [33] </ref> and has two main roles: to calculate suitable kinds for each of the data type constructors and classes in a program, and to use these kinds to ensure that only well-formed type and constructor expressions are used in Gofer programs. <p> Without the complexities of polymorphism or overloading, the kind system is implemented as a greatly simplified version of the type system. Readers struggling to understand the basic features of the type checker may find that a study of the kind inference code in kind.c and of <ref> [33] </ref>, provides a somewhat smoother introduction. As we have already mentioned, kind checking can really be viewed as part of the static analysis of a program, rather than type checking. Nevertheless, we have included it in this section because of its similarity to the main type. <p> For the purposes of kind inference, we use Offset values to form skeleton kinds. Paired with an offset into the current substitution, these represent kinds that are initially unknown. Further details about the kind system are given in <ref> [33] </ref> and the definitions in kind.c are a straightforward implementation of the ideas described there. 7.8 Experiments with type.c To understand how a program works, it is often useful to be able to examine and study the results that it produces for different inputs.
Reference: [34] <author> Simon L. Peyton Jones. </author> <title> Implementing lazy functional languages on stock hardware: </title> <journal> the spineless tagless g-machine. Journal of Functional Programming, </journal> <volume> 2(2) </volume> <pages> 127-202, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: On the other hand, lambda-lifting is not essential for the compilation of such languages; for example, lambda-lifting is not required for either of the implementations by Turner 37 [52] or Peyton Jones <ref> [34] </ref>.
Reference: [35] <author> S.L. Peyton Jones and P. Wadler. </author> <title> A static semantics for haskell (draft). </title> <type> Technical report, </type> <institution> Department of Computing Science, University of Glasgow, </institution> <month> February </month> <year> 1992. </year> <month> 51 </month>
Reference-contexts: On the other hand, this level of complexity is not uncommon when dealing with complete languages, as in the static semantics for Haskell presented in <ref> [35] </ref> and the definition of ML in [42]. 7.6 Abstract syntax for type checked programs produced as the results of type checking.
Reference: [36] <author> Stefan Kaes. </author> <title> Parametric overloading in poly-morphic programming languages. </title> <booktitle> In ESOP '88: European Symposium on Programming, </booktitle> <address> Nancy, France, New York, </address> <year> 1988. </year> <note> Springer-Verlag. Lecture Notes in Computer Science, 300. </note>
Reference-contexts: We will delay further discussion of this until Section 7.5.2. 7.5 Overloading One of the most innovative features in the design of Haskell is its support for user-defined overloading based on the concept of type classes, introduced by Wadler and Blott [57]. Extending earlier work by Kaes <ref> [36] </ref>, type classes were proposed as a general method of dealing with examples like equality and arithmetic functions that do not fit comfortably into a simple polymorphic type system, in contrast with the ad-hoc solutions adopted in earlier languages. <p> In addition, this permits further useful extensions such as the possibility of defining overlapping instances. Several researchers, including this author, have investigated the theory and formal properties of type classes <ref> [8, 30, 29, 36, 44, 45, 50, 53] </ref> and there has 27 also been some experience with practical implemen-tations [14, 28, 46, 5] and applications [27, 38, 13]. Since these topics are so well-documented, we will concentrate here only on the special features in the implementation of Gofer.
Reference: [37] <author> Brian W. Kernighan and Dennis M. Ritchie. </author> <title> The C programming language. </title> <publisher> Prentice Hall, </publisher> <address> first edition, </address> <year> 1978. </year>
Reference-contexts: This is discussed in a little more detail in Section 10. Although compilers for ANSI C were available at the time, the Gofer code was written so that it could also be compiled with older K&R compilers <ref> [37] </ref>. The C preprocessor was used to allow the use of important features of ANSI C where possible.
Reference: [38] <author> Konstantin Laufer and Martin Odersky. </author> <title> Self-interpretation and relfection in a statically typed language. </title> <booktitle> In Proc. OOPSLA '93, Workshop on Reflection and Metalevel Architectures, </booktitle> <month> Septem-ber </month> <year> 1993. </year>
Reference-contexts: Several researchers, including this author, have investigated the theory and formal properties of type classes [8, 30, 29, 36, 44, 45, 50, 53] and there has 27 also been some experience with practical implemen-tations [14, 28, 46, 5] and applications <ref> [27, 38, 13] </ref>. Since these topics are so well-documented, we will concentrate here only on the special features in the implementation of Gofer. We will also assume that the reader is familiar with the syntax and use of type classes in Gofer, as described in [24, Chapter 14].
Reference: [39] <author> J. Launchbury and S.L. Peyton Jones. </author> <title> Lazy functional state threads. </title> <booktitle> In Conference on Programming Language Design and Implementation, </booktitle> <address> Orlando, FL, </address> <month> June </month> <year> 1994. </year> <note> To appear. </note>
Reference-contexts: On the other hand, Gofer also supports several experimental extensions of which constructor classes are perhaps the best known example. The latest release also includes prototype implementations of other recent proposals for extensions to Haskell, including monadic I/O [47] and lazy state threads <ref> [39] </ref>. In a typical Gofer session, the system behaves like an interactive calculator. First, the user enters an expression at the Gofer prompt, usually a ? character.
Reference: [40] <author> Xavier Leroy and Michel Mauny. </author> <title> The Caml Light system, version 0.5 | documentation and user's guide. </title> <type> Technical report L-5, </type> <institution> INRIA, </institution> <year> 1992. </year>
Reference-contexts: However, while some other functional language implementations do require more powerful machines, Gofer is by no means unique in providing a functional programming environment for smaller systems; Leroy's Caml Light <ref> [40] </ref>, implementing a dialect of ML, is another well-known example. 2 A user's perspective The Gofer system 2 provides an interpreter for an experimental language that is closely based on the definition of Haskell version 1.2 [16].
Reference: [41] <author> R. Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17(3), </volume> <year> 1978. </year>
Reference-contexts: The Gofer type checker builds on a large body of theoretical work, most of which we will not attempt to describe here. In particular, we will assume some familiarity with the basics of standard type inference algorithms <ref> [41, 11] </ref> and with the extensions of this work to qualified types [26, 30, 29] and to constructor classes [33], on which the type checker depends for its theoretical basis.
Reference: [42] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The definition of Standard ML. </title> <publisher> The MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: On the other hand, this level of complexity is not uncommon when dealing with complete languages, as in the static semantics for Haskell presented in [35] and the definition of ML in <ref> [42] </ref>. 7.6 Abstract syntax for type checked programs produced as the results of type checking.
Reference: [43] <author> Torben Mogensen. Ratatosk: </author> <title> A Parser Generator and Scanner Generator for Gofer, </title> <year> 1993. </year>
Reference-contexts: More important, programs with very large binding groups require large numbers of type variables. The most common source of programs causing this kind of problem are the machine generated parsers produced by systems like Ratatosk <ref> [43] </ref>.
Reference: [44] <author> T. Nipkow and G. Snelting. </author> <title> Type classes and overloading resolution via order-sorted unification. </title> <booktitle> In 5th ACM conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> New York, </address> <year> 1991. </year> <note> Springer-Verlag. Lecture Notes in Computer Science, 523. </note>
Reference-contexts: In addition, this permits further useful extensions such as the possibility of defining overlapping instances. Several researchers, including this author, have investigated the theory and formal properties of type classes <ref> [8, 30, 29, 36, 44, 45, 50, 53] </ref> and there has 27 also been some experience with practical implemen-tations [14, 28, 46, 5] and applications [27, 38, 13]. Since these topics are so well-documented, we will concentrate here only on the special features in the implementation of Gofer.
Reference: [45] <author> Tobias Nipkow and Christian Prehofer. </author> <title> Type checking type classes. </title> <booktitle> In Proceedings 20th Symposium on Principles of Programming Languages. ACM, </booktitle> <month> January </month> <year> 1993. </year>
Reference-contexts: In addition, this permits further useful extensions such as the possibility of defining overlapping instances. Several researchers, including this author, have investigated the theory and formal properties of type classes <ref> [8, 30, 29, 36, 44, 45, 50, 53] </ref> and there has 27 also been some experience with practical implemen-tations [14, 28, 46, 5] and applications [27, 38, 13]. Since these topics are so well-documented, we will concentrate here only on the special features in the implementation of Gofer.
Reference: [46] <author> J. Peterson and M.P. Jones. </author> <title> Implementing type classes. </title> <booktitle> In Proceedings of ACM SIGPLAN Symposium on Programming Language Design and Implementation. ACM SIGPLAN, </booktitle> <month> June </month> <year> 1993. </year>
Reference-contexts: In addition, this permits further useful extensions such as the possibility of defining overlapping instances. Several researchers, including this author, have investigated the theory and formal properties of type classes [8, 30, 29, 36, 44, 45, 50, 53] and there has 27 also been some experience with practical implemen-tations <ref> [14, 28, 46, 5] </ref> and applications [27, 38, 13]. Since these topics are so well-documented, we will concentrate here only on the special features in the implementation of Gofer.
Reference: [47] <author> S. Peyton Jones and P. Wadler. </author> <title> Imperative functional programming. </title> <booktitle> In Proceedings 20th Symposium on Principles of Programming Languages. ACM, </booktitle> <month> January </month> <year> 1993. </year>
Reference-contexts: On the other hand, Gofer also supports several experimental extensions of which constructor classes are perhaps the best known example. The latest release also includes prototype implementations of other recent proposals for extensions to Haskell, including monadic I/O <ref> [47] </ref> and lazy state threads [39]. In a typical Gofer session, the system behaves like an interactive calculator. First, the user enters an expression at the Gofer prompt, usually a ? character.
Reference: [48] <editor> S.L. Peyton Jones. </editor> <booktitle> The implementation of functional programming languages. </booktitle> <publisher> Prentice Hall, </publisher> <year> 1987. </year>
Reference-contexts: Nor is this report intended as a tutorial on `the implementation of functional languages'; indeed, Simon Peyton Jones' book by that name <ref> [48] </ref> was a constant companion during the development of Gofer, and remains an almost certain prerequisite to this report. <p> An arity of zero indicates a constant applicative form (CAF) as described in <ref> [48] </ref>. - name (n).type: the type of n, if known. - name (n).defn: used to distinguish different kinds of name. The value of this field may indicate a constructor function CFUN or a member function MFUN. For user-defined functions, this field is also used to record dependency information during compilation. <p> Dependency analysis is discussed in more detail in <ref> [48, Section 6.2.8] </ref> and in [16, Section 4.5.1]. <p> This is exactly the same as the fatbar operator, [], used in <ref> [48] </ref>. A simple example is in the compilation of the function: null [] = True null xs = False Writing the definition in this way requires that the second equation is only used if the first fails. <p> The Gofer compiler includes an implementation of an alternative algorithm proposed by Johns-son, who also introduced the term lambda-lifting [20]. Other descriptions of Johnsson's algorithm may be found in <ref> [48, Section 14.6] </ref> and in [49, Chapter 6]. Up to this point, all of the program analyses and transformations that we have described have been fairly general, and largely independent of any particular implementation technique; we would expect to find similar components in any implementation of a non-strict functional language. <p> While there are some differences, this part of the Gofer system borrows heavily on the ideas used in the Chalmers G-machine, described in <ref> [4, 48] </ref>. On the other hand, by isolating the details of the abstract machine in a single file, it should, in principle, be possible to replace this part of the Gofer system with alternative back-ends, for example, based on the Three Instruction Machine [60]. <p> It is also used to save the values of variables bound in a local definition. The indirection cell is used to avoid a loss of laziness <ref> [48, Section 12.4] </ref>. <p> This is not a major shortcoming; indeed this is exactly the kind of application that type classes are intended to be used for! One feature of the translation from machine instructions to C is the use of technique suggested by <ref> [48, Section 19.3.2] </ref> to simulate the run-time stack at compile-time. This allows the code generator to avoid unnecessary use of the stack, but requires a more complicated form of instructions in generated C programs.
Reference: [49] <author> S.L. Peyton Jones and D. Lester. </author> <title> Implementing Functional Languages. </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: The Gofer compiler includes an implementation of an alternative algorithm proposed by Johns-son, who also introduced the term lambda-lifting [20]. Other descriptions of Johnsson's algorithm may be found in [48, Section 14.6] and in <ref> [49, Chapter 6] </ref>. Up to this point, all of the program analyses and transformations that we have described have been fairly general, and largely independent of any particular implementation technique; we would expect to find similar components in any implementation of a non-strict functional language.
Reference: [50] <author> Geoffrey Seward Smith. </author> <title> Polymorphic type inference for languages with overloading and sub-typing. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Cornell University, </institution> <address> Ithaca, New York, </address> <month> August </month> <year> 1991. </year>
Reference-contexts: In addition, this permits further useful extensions such as the possibility of defining overlapping instances. Several researchers, including this author, have investigated the theory and formal properties of type classes <ref> [8, 30, 29, 36, 44, 45, 50, 53] </ref> and there has 27 also been some experience with practical implemen-tations [14, 28, 46, 5] and applications [27, 38, 13]. Since these topics are so well-documented, we will concentrate here only on the special features in the implementation of Gofer.
Reference: [51] <author> Robert Tarjan. </author> <title> Depth-first search and linear graph algorithms. </title> <journal> SIAM J. Comput., </journal> <volume> 1(2) </volume> <pages> 146-160, </pages> <year> 1972. </year>
Reference-contexts: In Gofer, the dependency analysis is implemented using a small modified version of a standard algorithm that automatically produces the strongly-connected components in the required order <ref> [51, 6] </ref>. The core of the algorithm is contained in the file scc.c. This file is set up to allow different instances of the dependency analysis algorithm to be generated using the C preprocessor and #includeing several copies of the code.
Reference: [52] <author> David A. Turner. </author> <title> A new implementation technique for applicative languages. </title> <journal> Software| Practice and Experience, </journal> <volume> 9 </volume> <pages> 31-49, </pages> <year> 1979. </year>
Reference-contexts: On the other hand, lambda-lifting is not essential for the compilation of such languages; for example, lambda-lifting is not required for either of the implementations by Turner 37 <ref> [52] </ref> or Peyton Jones [34].
Reference: [53] <author> D. Volpano and G. Smith. </author> <title> On the complexity of ML typability with overloading. </title> <booktitle> In 5th ACM conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> New York, </address> <year> 1991. </year> <note> Springer-Verlag. Lecture Notes in Computer Science, 523. </note>
Reference-contexts: In addition, this permits further useful extensions such as the possibility of defining overlapping instances. Several researchers, including this author, have investigated the theory and formal properties of type classes <ref> [8, 30, 29, 36, 44, 45, 50, 53] </ref> and there has 27 also been some experience with practical implemen-tations [14, 28, 46, 5] and applications [27, 38, 13]. Since these topics are so well-documented, we will concentrate here only on the special features in the implementation of Gofer.
Reference: [54] <author> P. Wadler. </author> <title> Efficient compilation of pattern matching. </title> <note> Chapter 5 in [48]. </note>
Reference-contexts: This section describes a program transformation, based closely on Wadler's description in <ref> [54] </ref>, that reduces pattern matching in function definitions to a particularly simple form.
Reference: [55] <author> P. Wadler. </author> <title> List comprehensions. </title> <note> Chapter 7 in [48]. </note>
Reference-contexts: such errors back to the input program. 34 * Local definitions, cast into lists of lists of bind-ings during dependency analysis, are flattened into simple LETREC values as suggested by the expansions given in Section 6.2. * List and monad comprehensions are eliminated using the translations suggested by Wadler in <ref> [55] </ref> and [56], respectively. * Case and lambda expressions are eliminated by translating them to equivalent expressions using local definitions.
Reference: [56] <author> P. Wadler. </author> <title> The essence of functional programming (invited talk). </title> <booktitle> In Conference record of the Nineteenth annual ACM SIGPLAN-SIGACT symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-14, </pages> <month> Jan </month> <year> 1992. </year>
Reference-contexts: back to the input program. 34 * Local definitions, cast into lists of lists of bind-ings during dependency analysis, are flattened into simple LETREC values as suggested by the expansions given in Section 6.2. * List and monad comprehensions are eliminated using the translations suggested by Wadler in [55] and <ref> [56] </ref>, respectively. * Case and lambda expressions are eliminated by translating them to equivalent expressions using local definitions.
Reference: [57] <author> P. Wadler and S. Blott. </author> <title> How to make ad hoc polymorphism less ad hoc. </title> <booktitle> In Proceedings of 16th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 60-76, </pages> <month> Jan </month> <year> 1989. </year>
Reference-contexts: We will delay further discussion of this until Section 7.5.2. 7.5 Overloading One of the most innovative features in the design of Haskell is its support for user-defined overloading based on the concept of type classes, introduced by Wadler and Blott <ref> [57] </ref>. Extending earlier work by Kaes [36], type classes were proposed as a general method of dealing with examples like equality and arithmetic functions that do not fit comfortably into a simple polymorphic type system, in contrast with the ad-hoc solutions adopted in earlier languages. <p> We will also assume that the reader is familiar with the syntax and use of type classes in Gofer, as described in [24, Chapter 14]. Following the suggestions of Wadler and Blott <ref> [57] </ref>, the implementation of overloading in Gofer makes heavy use of dictionary values. Roughly speaking, a dictionary is a tuple of values containing the implementation of overloaded functions corresponding to a particular instance of a class.
Reference: [58] <author> P. Wadler and Q. Miller. </author> <title> An introduction to Orwell 6.0. </title> <type> Technical report, </type> <institution> Programming Research Group, Oxford University Computing Laboratory, </institution> <year> 1990. </year>
Reference-contexts: Instead, new definitions are entered using a text editor to produce a script file of definitions that can then be loaded into the interpreter. The strict separation between sessions and scripts was a conscious design decision, inspired by [7] and <ref> [58] </ref>, reflecting the way we expect the system to be used in practice. In particular, this approach allows a programmer to work by switching between scripts and sessions, adding new definitions, testing, 3 and making further changes as necessary. <p> A command of the form: ? :project program.prj can be used to read the file names listed in program.prj and load the corresponding script files into the interpreter. It is important to mention that the original Gofer user interface was closely modeled on the `scrolling' interface of Orwell <ref> [58] </ref> which provided my own introduction to functional programming. For example, following Orwell, early versions of Gofer displayed lines of dots to indicate progress during various stages of reading script files 3 .
Reference: [59] <author> E. P. Wentworth. </author> <title> Pitfalls of conservative garbage collection. </title> <journal> Software|Practice and Experience, </journal> <volume> 20(7) </volume> <pages> 719-727, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: As if the limitations of the garbage collector that we have already discussed are not enough, there are some further problems that we should mention. * First, the garbage collector is conservative, in the sense that it may preserve parts of the heap that are not actually needed <ref> [59, 9] </ref>. This happens when the garbage collector misinterprets a value on the C stack as a pointer into the heap. In some situations, this causes a space-leak, preserving large data structures long beyond the point where they are actually needed.
Reference: [60] <author> S.C. Wray and J. Fairbairn. </author> <title> Non-strict languages|programming and implementation. </title> <journal> The computer journal, </journal> <volume> 32(2) </volume> <pages> 142-151, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: On the other hand, by isolating the details of the abstract machine in a single file, it should, in principle, be possible to replace this part of the Gofer system with alternative back-ends, for example, based on the Three Instruction Machine <ref> [60] </ref>. In practice, this may also require changes elsewhere in the system, for example, in the storage management routines of storage.c to support heap allocation of closures, or in compiler.c to add extra program transformation steps.
References-found: 60

