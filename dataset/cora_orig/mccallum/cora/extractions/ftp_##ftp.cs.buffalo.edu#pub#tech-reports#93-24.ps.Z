URL: ftp://ftp.cs.buffalo.edu/pub/tech-reports/93-24.ps.Z
Refering-URL: ftp://ftp.cs.buffalo.edu/pub/tech-reports/README.html
Root-URL: 
Title: Efficient Reductions from NP to Parity using Error-Correcting Codes (preliminary version)  
Author: Kenneth W. Regan 
Date: July 8, 1993  
Affiliation: State University of New York at Buffalo  
Abstract: This paper proves that every language in NP is recognized by an RP[ P] machine whose time complexity is quasilinear, apart from the time to verify witnesses. The results significantly improve the number of random bits, success probability, and running time of Valiant and Vazirani's original construction [VV86], and beat both the 2n random bits and time/success tradeoff in subsequent methods based on universal hashing. Questions of further improvements are connected to open problems in the theory of error-correcting codes.
Abstract-found: 1
Intro-found: 1
Reference: [ABN + 92] <author> N. Alon, J. Bruck, J. Naor, M. Naor, and R. Roth. </author> <title> Construction of asymptotically good low-rate error-correcting codes through pseudo-random graphs. </title> <journal> IEEE Transactions on Information Theory, </journal> <volume> 38(2) </volume> <pages> 509-512, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: The second is similar to definitions in <ref> [KTV84, TV91, ABN + 92, She93] </ref>. Let C be some complexity class of functions. Definition 2.2. <p> This has been improved to reasonable runtimes by Justesen et.al. [JLJ + 89, JLJH92], who also give efficient decoding algorithms, and more strongly by Shen [She93] (see also <ref> [TV91, ABN + 92] </ref>). In our case, speaking in terms of ^n, we have the problem of whether asymptotically good sequences of codes exist which are NC-uniform. <p> Notes The basic idea of using error-correcting codes to reduce the number of random bits in certain applications, and to isolate unique elements, was observed by Naor and Naor [NN90] (see also <ref> [ABN + 92] </ref>). It was also known to Tarui [Tar92] in a non-uniform context. Large error-correcting codes of constant density are integral to the recent work on transparent (holographic) proofs [BFLS91, AS92, ALM + 92, Sud92, Bab93, BGLR93]. <p> One idea is to have M probe the entries of u in more than one column, but this may involve another kind of product construction that compounds the runtime. We inquire whether deterministic amplification techniques involving expander graphs (cf. <ref> [ABN + 92] </ref>) can be efficiently used in this setting. Finally, we return to the remarks about hashing in Section 1.1.
Reference: [AH90] <author> E. Allender and U. Hertrampf. </author> <title> On the power of uniform families of constant-depth circuits. </title> <booktitle> In The Proceedings of the 15th International Symposium on Mathematical Foundations of Computer Science, volume 452 of Lecture Notes in Computer Science, </booktitle> <pages> pages 158-164. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year> <month> 9 </month>
Reference-contexts: Allender [All89] used the Valiant-Vazirani construction and techniques from the second part of Toda's paper [Tod91] in a circuit setting to prove that AC 0 circuits can be simulated by small depth-3 threshold circuits, and Allender and Hertrampf <ref> [AH90] </ref> gave a uniform version of this construction. Some other fl The author was supported in part by NSF Research Initiation Award CCR-9011248 Author's current address: Computer Science Department, 226 Bell Hall, UB North Campus, Buffalo, NY 14260-2000.
Reference: [AHU74] <author> A. Aho, J. Hopcroft, and J. Ullman. </author> <title> The Design and Analysis of Computer Algorithms. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1974. </year>
Reference-contexts: This leaves step 10. To multiply two polynomials of degree k 1 over GF (2) and reduce them modulo ff in the field GF (2 k ) takes time t 1 = O (k log k log log k) on standard Turing machine models (see <ref> [AHU74] </ref> and [Rab80]). The time to compute a i in GF (2 k ) where i n is t 2 = O (log n 2k log k log log k) via repeated squaring.
Reference: [All89] <author> E. Allender. </author> <title> A note on the power of threshold circuits. </title> <booktitle> In The Proceedings of the 30th Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 580-584, </pages> <year> 1989. </year>
Reference-contexts: Toda [Tod89, Tod91] used this to show that the polynomial hierarchy (PH) is contained in BP [ P]. Toda and Ogiwara [TO91, TO92] extended this to obtain PH BP [C = P] and related results, while Tarui [Tar91, Tar93] obtained similar results with zero error probability. Allender <ref> [All89] </ref> used the Valiant-Vazirani construction and techniques from the second part of Toda's paper [Tod91] in a circuit setting to prove that AC 0 circuits can be simulated by small depth-3 threshold circuits, and Allender and Hertrampf [AH90] gave a uniform version of this construction.
Reference: [ALM + 92] <author> S. Arora, C. Lund, R. Motwani, M. Sudan, and M. Szegedy. </author> <title> Proof verification and hardness of approximation problems. </title> <booktitle> In The Proceedings of the 33rd Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 14-23, </pages> <year> 1992. </year>
Reference-contexts: It was also known to Tarui [Tar92] in a non-uniform context. Large error-correcting codes of constant density are integral to the recent work on transparent (holographic) proofs <ref> [BFLS91, AS92, ALM + 92, Sud92, Bab93, BGLR93] </ref>. Indeed, the code in the next section is a known simplification of the code originally used by Babai et.al. [BFLS91]; see Sudan [Sud92] and the Acknowledgments below.
Reference: [AS92] <author> S. Arora and S. Safra. </author> <title> Probabilistic checking of proofs. </title> <booktitle> In The Proceedings of the 33rd Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 2-13, </pages> <year> 1992. </year>
Reference-contexts: It was also known to Tarui [Tar92] in a non-uniform context. Large error-correcting codes of constant density are integral to the recent work on transparent (holographic) proofs <ref> [BFLS91, AS92, ALM + 92, Sud92, Bab93, BGLR93] </ref>. Indeed, the code in the next section is a known simplification of the code originally used by Babai et.al. [BFLS91]; see Sudan [Sud92] and the Acknowledgments below.
Reference: [Bab93] <author> L. Babai. </author> <title> Transparent (holographic) proofs. </title> <booktitle> In The Proceedings of the 1993 Symposium on Theoretical Aspects of Computer Science, volume 665 of Lecture Notes in Computer Science, </booktitle> <pages> pages 525-534. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: It was also known to Tarui [Tar92] in a non-uniform context. Large error-correcting codes of constant density are integral to the recent work on transparent (holographic) proofs <ref> [BFLS91, AS92, ALM + 92, Sud92, Bab93, BGLR93] </ref>. Indeed, the code in the next section is a known simplification of the code originally used by Babai et.al. [BFLS91]; see Sudan [Sud92] and the Acknowledgments below.
Reference: [BFLS91] <author> L. Babai, L. Fortnow, C. Lund, and M. Szegedy. </author> <title> Checking computations in polylogarithmic time. </title> <booktitle> In The Proceedings of the 23rd Annual ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 21-31, </pages> <year> 1991. </year>
Reference-contexts: It was also known to Tarui [Tar92] in a non-uniform context. Large error-correcting codes of constant density are integral to the recent work on transparent (holographic) proofs <ref> [BFLS91, AS92, ALM + 92, Sud92, Bab93, BGLR93] </ref>. Indeed, the code in the next section is a known simplification of the code originally used by Babai et.al. [BFLS91]; see Sudan [Sud92] and the Acknowledgments below. <p> Large error-correcting codes of constant density are integral to the recent work on transparent (holographic) proofs [BFLS91, AS92, ALM + 92, Sud92, Bab93, BGLR93]. Indeed, the code in the next section is a known simplification of the code originally used by Babai et.al. <ref> [BFLS91] </ref>; see Sudan [Sud92] and the Acknowledgments below. Ours is the first formulation we know of the coding idea in the context of improving the bounds for reducing NP to parity, where large codes are involved and questions of uniformity and 5 efficiency are important. 3. <p> Since r q 1 these monomials are all distinct, and they are all linearly independent, so the dimension is K = ( m+r r ). By the so-called Schwartz inequality [Sch80] (cf. <ref> [BFLS91, Sud92] </ref>), for every two distinct polynomials f and g over F of degree at most r, and for every I F , jf ~a 2 I m : f (~a ) = g (~a ) gj rjIj m1 : (6) With I = F , it follows that every two
Reference: [BG93] <author> J. Buss and J. Goldsmith. </author> <title> Nondeterminism within P. </title> <journal> SIAM Journal on Computing, </journal> <volume> 22:nnn-nnn, </volume> <year> 1993. </year>
Reference-contexts: M can be turned into the above kind of oracle machine M o as follows: M o on input x flips r (n) coins to get w. Then the fixed deterministic recognizer for Q is converted via the efficient construction of Schnorr [Sch76] (see also Buss and Goldsmith <ref> [BG93] </ref>) into a formula x;w of size O (t (n) log t (n)) such that the number of satisfying assignments of x;w equals the number of y such that Q (x; w; y) holds. The time to construct x;w is also O (t (n) log t (n)).
Reference: [BGLR93] <author> M. Bellare, S. Goldwasser, C. Lund, and A. Russell. </author> <title> Efficient probabilistically checkable proofs and applications to approximation. </title> <booktitle> In The Proceedings of the 25th Annual ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 294-304, </pages> <year> 1993. </year>
Reference-contexts: It was also known to Tarui [Tar92] in a non-uniform context. Large error-correcting codes of constant density are integral to the recent work on transparent (holographic) proofs <ref> [BFLS91, AS92, ALM + 92, Sud92, Bab93, BGLR93] </ref>. Indeed, the code in the next section is a known simplification of the code originally used by Babai et.al. [BFLS91]; see Sudan [Sud92] and the Acknowledgments below.
Reference: [BRS91] <author> R. Beigel, N. Reingold, and D. Spielman. </author> <title> The perceptron strikes back. </title> <booktitle> In The Proceedings of the 6th Annual IEEE Conference on Structure in Complexity Theory, </booktitle> <pages> pages 286-291, </pages> <year> 1991. </year>
Reference-contexts: Email: regan@cs.buffalo.edu, tel.: (716) 645-3189, fax: (716) 645-3464. 1 results apprear to require constructions which work under all oracles that have the promise property (see <ref> [BT91, BRS91] </ref>), rather than just the parity oracle.
Reference: [BT91] <author> R. Beigel and J. Tarui. </author> <booktitle> On ACC. In The Proceedings of the 32nd Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 783-792, </pages> <year> 1991. </year>
Reference-contexts: Email: regan@cs.buffalo.edu, tel.: (716) 645-3189, fax: (716) 645-3464. 1 results apprear to require constructions which work under all oracles that have the promise property (see <ref> [BT91, BRS91] </ref>), rather than just the parity oracle.
Reference: [CLR90] <author> T. Cormen, C. Leiserson, and R. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> The MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: property that for some c &gt; 0 and all distinct y 1 ; y 2 2 A, Pr h2H [h (y 1 ) = h (y 2 )] c=jBj. (This is called "c-universal" in [DGMP92], and when c = 1 and the probability is exactly 1=jBj, this is called "universal" <ref> [CLR90] </ref> or "universal 1 " [CW79].) Let S A be nonempty, and put s := jSj, b := jBj.
Reference: [CRS93] <author> S. Chari, P. Rohatgi, and A. Srinivasan. </author> <title> Randomness-optimal unique element isolation, with applications to perfect matching and related problems. </title> <booktitle> In The Proceedings of the 25th Annual ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 458-467, </pages> <year> 1993. </year>
Reference-contexts: M 0 also makes quadratically many nondeterministic moves; we say it works on the "product witness space." The guarantee by M 0 is only for parity, whereas M "isolates a unique element" in the parlance of <ref> [CRS93] </ref>. <p> S. Gupta [Gup93] constructs an M 0 which uses quadratically-many random bits and achieves success probability at least 3=16 for parity. Unlike the above, this construction 3 stays in the original witness space, thus making only p-many nondeterministic moves. Chari, Rohatgi, and Srinivasan <ref> [CRS93] </ref> report that when a bound Z on s is known in advance, then O (log n+log Z) random bits suffice for an M which isolates a unique element, with success probability 1=8p. (In Section 5 we note that this can be achieved via the above hashing method, and analyze the <p> This improves the unspecified constants in the `O' notation used by Chari, Rohatgi, and Srinivasan <ref> [CRS93] </ref> to 1. If Z is not too large, the codes required are relatively short, and it appears that the above-cited families will yield good bounds on time as well as randomness complexity.
Reference: [CW79] <author> J. Carter and M. Wegman. </author> <title> Universal classes of hash functions. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 18 </volume> <pages> 143-154, </pages> <year> 1979. </year> <month> 10 </month>
Reference-contexts: &gt; 0 and all distinct y 1 ; y 2 2 A, Pr h2H [h (y 1 ) = h (y 2 )] c=jBj. (This is called "c-universal" in [DGMP92], and when c = 1 and the probability is exactly 1=jBj, this is called "universal" [CLR90] or "universal 1 " <ref> [CW79] </ref>.) Let S A be nonempty, and put s := jSj, b := jBj.
Reference: [DGMP92] <author> M. Dietzfelbinger, J. Gil, Y. Matias, and N. Pippenger. </author> <title> Polynomial hash func-tions are reliable. </title> <booktitle> In The Proceedings of the 1992 International Conference on Automata, Languages, and Programming, volume 623 of Lecture Notes in Computer Science, </booktitle> <pages> pages 235-246. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: this construction uses families H of hash functions h : A ! B with the collision-avoidance property that for some c &gt; 0 and all distinct y 1 ; y 2 2 A, Pr h2H [h (y 1 ) = h (y 2 )] c=jBj. (This is called "c-universal" in <ref> [DGMP92] </ref>, and when c = 1 and the probability is exactly 1=jBj, this is called "universal" [CLR90] or "universal 1 " [CW79].) Let S A be nonempty, and put s := jSj, b := jBj. <p> The function (p; k) need not increase with k|indeed, for k = p, H kp could consist solely of the identity. There are families of hash functions such that M 0 needs only 2 (p + 1) coin flips (see <ref> [IZ89, DGMP92] </ref>), giving r (n) = 2n + 2 in the case p (n) = n. S. Gupta [Gup93] constructs an M 0 which uses quadratically-many random bits and achieves success probability at least 3=16 for parity.
Reference: [For66] <author> G. Forney. </author> <title> Concatenated Codes. </title> <publisher> MIT Press, </publisher> <year> 1966. </year>
Reference-contexts: Hence these codes fall short of being asymptotically good. This general idea behind the construction of ^ C is called concatenation of codes <ref> [For66] </ref> (see also [MS77]); here R 0 q (r; m) is the outer code and H k is the inner code.
Reference: [Gup93] <author> S. Gupta. </author> <title> On isolating an odd number of elements, </title> <year> 1993. </year>
Reference-contexts: There are families of hash functions such that M 0 needs only 2 (p + 1) coin flips (see [IZ89, DGMP92]), giving r (n) = 2n + 2 in the case p (n) = n. S. Gupta <ref> [Gup93] </ref> constructs an M 0 which uses quadratically-many random bits and achieves success probability at least 3=16 for parity. Unlike the above, this construction 3 stays in the original witness space, thus making only p-many nondeterministic moves.
Reference: [IZ89] <author> R. Impagliazzo and D. Zuckerman. </author> <title> How to recycle random bits. </title> <booktitle> In The Proceedings of the 1989 IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 248-253, </pages> <year> 1989. </year>
Reference-contexts: The function (p; k) need not increase with k|indeed, for k = p, H kp could consist solely of the identity. There are families of hash functions such that M 0 needs only 2 (p + 1) coin flips (see <ref> [IZ89, DGMP92] </ref>), giving r (n) = 2n + 2 in the case p (n) = n. S. Gupta [Gup93] constructs an M 0 which uses quadratically-many random bits and achieves success probability at least 3=16 for parity.
Reference: [JLJ + 89] <author> J. Justesen, K. Larsen, H.E. Jensen, A. Havemose, and T. Hoholdt. </author> <title> Construction and decoding of a class of algebraic geometry codes. </title> <journal> IEEE Transactions on Information Theory, </journal> <volume> 35(4) </volume> <pages> 811-820, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: This was attained by Tsfasman, Vladut, Zink [TVZ82] (see also the paper with Katsman, [KTV84]), with an algorithm running in time approximately O (n 30 ). This has been improved to reasonable runtimes by Justesen et.al. <ref> [JLJ + 89, JLJH92] </ref>, who also give efficient decoding algorithms, and more strongly by Shen [She93] (see also [TV91, ABN + 92]). In our case, speaking in terms of ^n, we have the problem of whether asymptotically good sequences of codes exist which are NC-uniform.
Reference: [JLJH92] <author> J. Justesen, K. Larsen, H.E. Jensen, and T. Hoholdt. </author> <title> Fast decoding of codes from algebraic plane curves. </title> <journal> IEEE Transactions on Information Theory, </journal> <volume> 38(1) </volume> <pages> 111-119, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: This was attained by Tsfasman, Vladut, Zink [TVZ82] (see also the paper with Katsman, [KTV84]), with an algorithm running in time approximately O (n 30 ). This has been improved to reasonable runtimes by Justesen et.al. <ref> [JLJ + 89, JLJH92] </ref>, who also give efficient decoding algorithms, and more strongly by Shen [She93] (see also [TV91, ABN + 92]). In our case, speaking in terms of ^n, we have the problem of whether asymptotically good sequences of codes exist which are NC-uniform.
Reference: [KTV84] <author> G. Katsman, M. Tsfasman, and S. Vladut. </author> <title> Modular curves and codes with a polynomial construction. </title> <journal> IEEE Transactions on Information Theory, </journal> <volume> IT-30:353-355, </volume> <year> 1984. </year>
Reference-contexts: The second is similar to definitions in <ref> [KTV84, TV91, ABN + 92, She93] </ref>. Let C be some complexity class of functions. Definition 2.2. <p> In the 1970's it was considered a major problem in coding theory to find a sequence of asymptotically good codes with l (n) = n O (1) which is polynomial-time uniform. This was attained by Tsfasman, Vladut, Zink [TVZ82] (see also the paper with Katsman, <ref> [KTV84] </ref>), with an algorithm running in time approximately O (n 30 ). This has been improved to reasonable runtimes by Justesen et.al. [JLJ + 89, JLJH92], who also give efficient decoding algorithms, and more strongly by Shen [She93] (see also [TV91, ABN + 92]).
Reference: [MS77] <author> F. MacWilliams and N. Sloane. </author> <title> The Theory of Error-Correcting Codes. </title> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1977. </year>
Reference-contexts: Hence these codes fall short of being asymptotically good. This general idea behind the construction of ^ C is called concatenation of codes [For66] (see also <ref> [MS77] </ref>); here R 0 q (r; m) is the outer code and H k is the inner code. <p> Having c &gt; 1 makes the code density avoid the Plotkin bound (see <ref> [MS77] </ref>), and allows for good families of codes whose lengths are a small constant times (n 1)2 k =c. However, the bound c 39=35 places the codes into the low-rate neighborhood studied by Shen and others.
Reference: [NN90] <author> J. Naor and M. Naor. </author> <title> Small-bias probability spaces. </title> <booktitle> In The Proceedings of the 22nd Annual ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 213-223, </pages> <year> 1990. </year>
Reference-contexts: Notes The basic idea of using error-correcting codes to reduce the number of random bits in certain applications, and to isolate unique elements, was observed by Naor and Naor <ref> [NN90] </ref> (see also [ABN + 92]). It was also known to Tarui [Tar92] in a non-uniform context. Large error-correcting codes of constant density are integral to the recent work on transparent (holographic) proofs [BFLS91, AS92, ALM + 92, Sud92, Bab93, BGLR93]. <p> We inquire whether deterministic amplification techniques involving expander graphs (cf. [ABN + 92]) can be efficiently used in this setting. Finally, we return to the remarks about hashing in Section 1.1. By an observation attributed to Bruck in <ref> [NN90] </ref>, a c-universal family H of hash functions h : f 0; 1 g n ! f 0; 1 g k is the same as a (not necessarily linear) code with alphabet f 0; 1 g k of length = jHj and density ffi = 1 c=2 k over f 0;
Reference: [Rab80] <author> M. Rabin. </author> <title> Probabilistic algorithms in finite fields. </title> <journal> SIAM Journal on Computing, </journal> <pages> pages 273-280, </pages> <year> 1980. </year>
Reference-contexts: This leaves step 10. To multiply two polynomials of degree k 1 over GF (2) and reduce them modulo ff in the field GF (2 k ) takes time t 1 = O (k log k log log k) on standard Turing machine models (see [AHU74] and <ref> [Rab80] </ref>). The time to compute a i in GF (2 k ) where i n is t 2 = O (log n 2k log k log log k) via repeated squaring.
Reference: [Sch76] <author> C. Schnorr. </author> <title> The network complexity and the Turing machine complexity of finite functions. </title> <journal> Acta Informatica, </journal> <volume> 7 </volume> <pages> 95-107, </pages> <year> 1976. </year>
Reference-contexts: M can be turned into the above kind of oracle machine M o as follows: M o on input x flips r (n) coins to get w. Then the fixed deterministic recognizer for Q is converted via the efficient construction of Schnorr <ref> [Sch76] </ref> (see also Buss and Goldsmith [BG93]) into a formula x;w of size O (t (n) log t (n)) such that the number of satisfying assignments of x;w equals the number of y such that Q (x; w; y) holds.
Reference: [Sch80] <author> J.T. Schwartz. </author> <title> Fast probabilistic algorithms for polynomial identities. </title> <journal> Journal of the ACM, </journal> <volume> 27 </volume> <pages> 701-717, </pages> <year> 1980. </year>
Reference-contexts: Since r q 1 these monomials are all distinct, and they are all linearly independent, so the dimension is K = ( m+r r ). By the so-called Schwartz inequality <ref> [Sch80] </ref> (cf. [BFLS91, Sud92]), for every two distinct polynomials f and g over F of degree at most r, and for every I F , jf ~a 2 I m : f (~a ) = g (~a ) gj rjIj m1 : (6) With I = F , it follows that
Reference: [She93] <author> B.-Z. Shen. </author> <title> A Justesen construction of binary concatenated codes than asymptotically meet the Zyablov bound for low rate. </title> <journal> IEEE Transactions on Information Theory, </journal> <volume> 39(1) </volume> <pages> 239-242, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: The second is similar to definitions in <ref> [KTV84, TV91, ABN + 92, She93] </ref>. Let C be some complexity class of functions. Definition 2.2. <p> This has been improved to reasonable runtimes by Justesen et.al. [JLJ + 89, JLJH92], who also give efficient decoding algorithms, and more strongly by Shen <ref> [She93] </ref> (see also [TV91, ABN + 92]). In our case, speaking in terms of ^n, we have the problem of whether asymptotically good sequences of codes exist which are NC-uniform. <p> The lesser one is the use of "bad" Hadamard codes for the inner code; these are responsible for the 1=2 k term in equation 7. Since k = O (log n), the deterministic polynomial-time uniform, asymptotically good binary codes of Shen <ref> [She93] </ref> can be used in place of H k without affecting the order of the running time. However, doing so only subtracts k = O (log n) random bits from r (n).
Reference: [Sho88] <author> V. Shoup. </author> <title> New algorithms for finding irreducible polynomials over finite fields. </title> <booktitle> In The Proceedings of the 29th Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 283-290, </pages> <year> 1988. </year> <month> 11 </month>
Reference-contexts: Construction and Main Theorem The last detail needed to build the code ^ C is to find a representation for GF (2 k ) and its product operation. The standard method is to find a one-variable polynomial ff (x) of degree k which is irreducible over GF (2). Shoup <ref> [Sho88] </ref> gives a deterministic algorithm for finding such a polynomial ff in time O (k 4 log O (1) k). Since k will be about 2 log n, this time is negligible.
Reference: [Sho90] <author> V. Shoup. </author> <title> Searching for primitive roots in finite fields. </title> <booktitle> In The Proceedings of the 22nd Annual ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 546-554, </pages> <year> 1990. </year>
Reference-contexts: It is desirable to construct large fields GF (2 k ) using an element of degree k which is primitive, but this is still only known to be possible in deterministic polynomial time if the prime factorization of 2 k 1 is known. (See Shoup <ref> [Sho90] </ref>.) It is natural to ask how easy it is to amplify the success probability of the RP [ P] machine M beyond 1=2, without using too many more random bits.
Reference: [Sud92] <author> M. Sudan. </author> <title> Efficient checking of polynomials and proofs and the hardness of approximation problems. </title> <type> PhD thesis, </type> <institution> University of California, Berkeley, </institution> <year> 1992. </year>
Reference-contexts: It was also known to Tarui [Tar92] in a non-uniform context. Large error-correcting codes of constant density are integral to the recent work on transparent (holographic) proofs <ref> [BFLS91, AS92, ALM + 92, Sud92, Bab93, BGLR93] </ref>. Indeed, the code in the next section is a known simplification of the code originally used by Babai et.al. [BFLS91]; see Sudan [Sud92] and the Acknowledgments below. <p> Large error-correcting codes of constant density are integral to the recent work on transparent (holographic) proofs [BFLS91, AS92, ALM + 92, Sud92, Bab93, BGLR93]. Indeed, the code in the next section is a known simplification of the code originally used by Babai et.al. [BFLS91]; see Sudan <ref> [Sud92] </ref> and the Acknowledgments below. Ours is the first formulation we know of the coding idea in the context of improving the bounds for reducing NP to parity, where large codes are involved and questions of uniformity and 5 efficiency are important. 3. <p> Since r q 1 these monomials are all distinct, and they are all linearly independent, so the dimension is K = ( m+r r ). By the so-called Schwartz inequality [Sch80] (cf. <ref> [BFLS91, Sud92] </ref>), for every two distinct polynomials f and g over F of degree at most r, and for every I F , jf ~a 2 I m : f (~a ) = g (~a ) gj rjIj m1 : (6) With I = F , it follows that every two
Reference: [Tar91] <author> J. Tarui. </author> <title> Randomized polynomials, threshold circuits, and the polynomial hierarchy. </title> <booktitle> In The Proceedings of the 8th Annual Symposium on Theoretical Aspects of Computer Science, volume 480 of Lecture Notes in Computer Science, </booktitle> <pages> pages 238-250. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Toda [Tod89, Tod91] used this to show that the polynomial hierarchy (PH) is contained in BP [ P]. Toda and Ogiwara [TO91, TO92] extended this to obtain PH BP [C = P] and related results, while Tarui <ref> [Tar91, Tar93] </ref> obtained similar results with zero error probability.
Reference: [Tar92] <author> J. Tarui. </author> <title> On singleton selectors and probabilistic polynomials. </title> <type> Manuscript, </type> <year> 1992. </year>
Reference-contexts: Notes The basic idea of using error-correcting codes to reduce the number of random bits in certain applications, and to isolate unique elements, was observed by Naor and Naor [NN90] (see also [ABN + 92]). It was also known to Tarui <ref> [Tar92] </ref> in a non-uniform context. Large error-correcting codes of constant density are integral to the recent work on transparent (holographic) proofs [BFLS91, AS92, ALM + 92, Sud92, Bab93, BGLR93].
Reference: [Tar93] <author> J. Tarui. </author> <title> Probabilistic polynomials, AC 0 functions, and the polynomial-time hierarchy. </title> <journal> Theoretical Computer Science, </journal> <volume> 113 </volume> <pages> 167-183, </pages> <year> 1993. </year>
Reference-contexts: Toda [Tod89, Tod91] used this to show that the polynomial hierarchy (PH) is contained in BP [ P]. Toda and Ogiwara [TO91, TO92] extended this to obtain PH BP [C = P] and related results, while Tarui <ref> [Tar91, Tar93] </ref> obtained similar results with zero error probability.
Reference: [TO91] <author> S. Toda and M. Ogiwara. </author> <title> Counting classes are at least as hard as the polynomial-time hierarchy. </title> <booktitle> In The Proceedings of the 6th Annual IEEE Conference on Structure in Complexity Theory, page to appear, </booktitle> <year> 1991. </year>
Reference-contexts: An oracle which returns the parity of the number of satisfying assignments has this property, and it follows that NP RP [ P]. Toda [Tod89, Tod91] used this to show that the polynomial hierarchy (PH) is contained in BP [ P]. Toda and Ogiwara <ref> [TO91, TO92] </ref> extended this to obtain PH BP [C = P] and related results, while Tarui [Tar91, Tar93] obtained similar results with zero error probability.
Reference: [TO92] <author> S. Toda and M. Ogiwara. </author> <title> Counting classes are at least as hard as the polynomial-time hierarchy. </title> <journal> SIAM Journal on Computing, </journal> <volume> 21 </volume> <pages> 316-328, </pages> <year> 1992. </year>
Reference-contexts: An oracle which returns the parity of the number of satisfying assignments has this property, and it follows that NP RP [ P]. Toda [Tod89, Tod91] used this to show that the polynomial hierarchy (PH) is contained in BP [ P]. Toda and Ogiwara <ref> [TO91, TO92] </ref> extended this to obtain PH BP [C = P] and related results, while Tarui [Tar91, Tar93] obtained similar results with zero error probability.
Reference: [Tod89] <author> S. </author> <title> Toda. </title> <booktitle> On the computational power of PP and P. In The Proceedings of the 30th Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 514-519, </pages> <year> 1989. </year>
Reference-contexts: An oracle which returns the parity of the number of satisfying assignments has this property, and it follows that NP RP [ P]. Toda <ref> [Tod89, Tod91] </ref> used this to show that the polynomial hierarchy (PH) is contained in BP [ P]. Toda and Ogiwara [TO91, TO92] extended this to obtain PH BP [C = P] and related results, while Tarui [Tar91, Tar93] obtained similar results with zero error probability. <p> For the case L = SAT, [VV86] took p (n) = n. Here we follow Toda <ref> [Tod89] </ref> and write p as short for p (n). The 2 machine M first flips p 2 + dlog (p + 1)e coins to form p-many vectors w 1 ; : : : ; w p 2 f 0; 1 g p and an integer k, 0 k p.
Reference: [Tod91] <author> S. </author> <title> Toda. PP is as hard as the polynomial-time hierarchy. </title> <journal> SIAM Journal on Computing, </journal> <volume> 20 </volume> <pages> 865-877, </pages> <year> 1991. </year>
Reference-contexts: An oracle which returns the parity of the number of satisfying assignments has this property, and it follows that NP RP [ P]. Toda <ref> [Tod89, Tod91] </ref> used this to show that the polynomial hierarchy (PH) is contained in BP [ P]. Toda and Ogiwara [TO91, TO92] extended this to obtain PH BP [C = P] and related results, while Tarui [Tar91, Tar93] obtained similar results with zero error probability. <p> Toda and Ogiwara [TO91, TO92] extended this to obtain PH BP [C = P] and related results, while Tarui [Tar91, Tar93] obtained similar results with zero error probability. Allender [All89] used the Valiant-Vazirani construction and techniques from the second part of Toda's paper <ref> [Tod91] </ref> in a circuit setting to prove that AC 0 circuits can be simulated by small depth-3 threshold circuits, and Allender and Hertrampf [AH90] gave a uniform version of this construction. <p> NQL RQL [ QL]. We have not yet checked thoroughly whether the amplification is good enough to extend this to QLH BQL [ QL], or whether the quasilinear analogue PQL [ QL] QL PQL of Toda's second theorem <ref> [Tod91] </ref> holds. On the face of it, the latter encounters the problem that the amplifying polynomials used are higher than quadratic. 5.
Reference: [TV91] <author> M. Tsfasman and S. Vladut. </author> <title> Algebraic-Geometric Codes, volume 58 of Mathematics and Its Applications (Soviet Series). </title> <publisher> Kluwer Academic, </publisher> <address> Dordrecht, </address> <year> 1991. </year>
Reference-contexts: The second is similar to definitions in <ref> [KTV84, TV91, ABN + 92, She93] </ref>. Let C be some complexity class of functions. Definition 2.2. <p> This has been improved to reasonable runtimes by Justesen et.al. [JLJ + 89, JLJH92], who also give efficient decoding algorithms, and more strongly by Shen [She93] (see also <ref> [TV91, ABN + 92] </ref>). In our case, speaking in terms of ^n, we have the problem of whether asymptotically good sequences of codes exist which are NC-uniform. <p> We follow the description in <ref> [TV91] </ref> (p46) of a reduced code R 0 q (r; m) for the case r q 1. The generator matrix has one row for each monomial x i 1 1 x i 2 m such that i 1 + i 2 + : : : + i m r.
Reference: [TVZ82] <author> M. Tsfasman, S. Vladut, and T. Zink. </author> <title> Modular curves, Shimura curves and Goppa codes, better than Varshamov-Gilbert bound. </title> <journal> Mathematische Nachrichten, </journal> <volume> 109 </volume> <pages> 21-28, </pages> <year> 1982. </year>
Reference-contexts: In the 1970's it was considered a major problem in coding theory to find a sequence of asymptotically good codes with l (n) = n O (1) which is polynomial-time uniform. This was attained by Tsfasman, Vladut, Zink <ref> [TVZ82] </ref> (see also the paper with Katsman, [KTV84]), with an algorithm running in time approximately O (n 30 ).
Reference: [VV86] <author> L. Valiant and V. Vazirani. </author> <title> NP is as easy as detecting unique solutions. </title> <journal> Theoretical Computer Science, </journal> <volume> 47 </volume> <pages> 85-93, </pages> <year> 1986. </year> <month> 12 </month>
Reference-contexts: 1. Introduction Valiant and Vazirani <ref> [VV86] </ref> proved that every language L 2 NP is accepted by a polynomial-time bounded probabilistic oracle Turing machine M o which, on any input x, computes a Boolean formula x as an oracle query, and accepts if the answer is `1'. <p> Given L 2 NP, let R (x; y) be a witness predicate for L; i.e., such that for all x, x 2 L () (9y 2 f 0; 1 g p (n) ) R (x; y), where p is a polynomial. For the case L = SAT, <ref> [VV86] </ref> took p (n) = n. Here we follow Toda [Tod89] and write p as short for p (n). <p> Let N w stand for the NTM which simulates the machines N w;0 w;p +1 in series, accepting iff all of them accept. Since a product of numbers is even iff at least one of the numbers is even, it follows from the lemma of <ref> [VV86] </ref> that Pr w [the number of accepting computations of N w is even] 1=4. Now modify N w so that the path ~c p+1 is not an accepting path.
References-found: 41

