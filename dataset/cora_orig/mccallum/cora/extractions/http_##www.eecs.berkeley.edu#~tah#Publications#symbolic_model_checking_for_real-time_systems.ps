URL: http://www.eecs.berkeley.edu/~tah/Publications/symbolic_model_checking_for_real-time_systems.ps
Refering-URL: http://www.eecs.berkeley.edu/~tah/Publications/symbolic_model_checking_for_real-time_systems.html
Root-URL: 
Title: Symbolic Model Checking for Real-time Systems  
Author: Thomas A. Henzinger Xavier Nicollin Joseph Sifakis Sergio Yovine 
Address: Ithaca, NY 14853, U.S.A.  38330 Montbonnot Saint Martin, France  
Affiliation: Computer Science Department, Cornell University  VERIMAG, Miniparc-ZIRST rue Lavoisier  
Abstract: We describe finite-state programs over real-numbered time in a guarded-command language with real-valued clocks or, equivalently, as finite automata with real-valued clocks. Model checking answers the question which states of a real-time program satisfy a branching-time specification (given in an extension of CTL with clock variables). We develop an algorithm that computes this set of states symbolically as a fixpoint of a functional on state predicates, without constructing the state space. For this purpose, we introduce a -calculus on computation trees over real-numbered time. Unfortunately, many standard program properties, such as response for all nonzeno execution sequences (during which time diverges), cannot be characterized by fixpoints: we show that the expressiveness of the timed -calculus is incomparable to the expressiveness of timed CTL. Fortunately, this result does not impair the symbolic verification of "implementable" real-time programs|those whose safety constraints are machine-closed with respect to diverging time and whose fairness constraints are restricted to finite upper bounds on clock values. All timed CTL properties of such programs are shown to be computable as finitely approximable fixpoints in a simple decidable theory.
Abstract-found: 1
Intro-found: 1
Reference: [ACD90] <author> R. Alur, C. Courcoubetis, and D.L. Dill. </author> <title> Model checking for real-time systems. </title> <booktitle> In Proceedings of the Fifth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 414-425. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1990. </year>
Reference-contexts: Only recently a graph-theoretic model-checking algorithm was found for these systems <ref> [ACD90] </ref>. Since the time component causes the state space to be infinite, the algorithm depends on a clever construction of a finite quotient of the infinite state graph. <p> We wish to conclude this introduction by pointing out that there is, of course, nothing "magical" about symbolic methods. Timed model checking is intrinsically difficult (PSPACE-hard) and already the known graph-theoretic algorithm on the exponential region graph is worst-case near-optimal <ref> [ACD90] </ref>. In practice, however, the "intuitive complexity" [BCM + 92] of the state space is typically much smaller than the region graph. Only a symbolic method can exploit this phenomenon, by representing unions of regions symbolically as state predicates. <p> Our semantics integrates elements from several models that have been proposed in the literature; we are particularly indebted to the clocks of [AD90], the dense trees of <ref> [ACD90] </ref>, the transition-delay dichotomy of [HMP91] and [NSY93], and the relative safety of [Hen92]. 2.1 State trajectories We model time as the nonnegative real numbers R + . <p> Both languages use clocks and arithmetic constraints on clock values to specify timing requirements. 4.1 Timed computation tree logic Many important properties of systems find a natural expression in temporal logic [Eme90]. We first review the real-time temporal logic TCTL <ref> [ACD90] </ref>, which extends the branching-time logic CTL [EC82] with clock variables. The formulas of TCTL, which are interpreted over the states of a given premodel , are built from state predicates by boolean connectives, the two temporal until operators 9U (possibly) and 8U (inevitably), and a reset quantifier for clocks. <p> It follows that the TCTL-formula z: ((z 5)8U (z &gt; 5)) holds in each state of every real-time system. A few comments regarding our particular version of TCTL are in order. First, unlike <ref> [ACD90] </ref>, we have opted for weakly monotonic time. Second, the time-bounded temporal operators used in [ACD90] are definable in TCTL. <p> It follows that the TCTL-formula z: ((z 5)8U (z &gt; 5)) holds in each state of every real-time system. A few comments regarding our particular version of TCTL are in order. First, unlike <ref> [ACD90] </ref>, we have opted for weakly monotonic time. Second, the time-bounded temporal operators used in [ACD90] are definable in TCTL. <p> The model-checking problem for verifying TCTL-specifications ' of real-time programs P was solved by Alur, Courcoubetis, and Dill <ref> [ACD90] </ref>. Their solution relies on the explicit construction of a finite quotient graph, called the region graph, of the infinite state-transition graph that is defined by the input program P. <p> The following theorem tells us that we cannot expect more from a general verification procedure. Theorem 6.1 <ref> [ACD90] </ref> The model-checking problem for real-time programs and TCTL is PSPACE-complete. In practice, however, it is often unnecessary to construct the entire region graph.
Reference: [ACH + 92] <author> R. Alur, C. Courcoubetis, N. Halbwachs, D.L. Dill, and H. Wong-Toi. </author> <title> Minimization of timed transition systems. In S.A. Smolka, editor, </title> <booktitle> CONCUR 92: Theories of Concur-rency, Lecture Notes in Computer Science 630, </booktitle> <pages> pages 340-354. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: A third strategy constructs, also by successive approximation, the coarsest bisimulation of the state space that separates all 1 -states from 2 -states. This strategy, too, can be implemented using the precondition and evolves-to operators <ref> [ACH + 92] </ref>. We conclude by pointing out that a natural extension of our method allows the analysis of so-called hybrid systems, which contain variables that change continuously in more general ways than clocks [ACHH93, NOSY93]. Acknowledgment. We thank Peter Kopke for a careful reading.
Reference: [ACHH93] <author> R. Alur, C. Courcoubetis, T.A. Henzinger, and P.-H. Ho. </author> <title> Hybrid automata: an algorithmic approach to the specification and verification of hybrid systems. In R.L. </title> <editor> Grossman, A. Nerode, A.P. Ravn, and H. Rischel, editors, </editor> <booktitle> Hybrid Systems, Lecture Notes in Computer Science 736, </booktitle> <pages> pages 209-229. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: While our symbolic model-checking procedure will fail to terminate if no such quotient exists, the procedure remains sound and led recently to the verification of systems with very general state spaces <ref> [ACHH93, NOSY93] </ref>. The remainder of the paper is organized as follows. In the next section, we define our model of real-time systems. Section 3 presents a guarded-command language and an automata-based language for the description of real-time systems. <p> This strategy, too, can be implemented using the precondition and evolves-to operators [ACH + 92]. We conclude by pointing out that a natural extension of our method allows the analysis of so-called hybrid systems, which contain variables that change continuously in more general ways than clocks <ref> [ACHH93, NOSY93] </ref>. Acknowledgment. We thank Peter Kopke for a careful reading. Appendix Completion of the proof of Theorem 5.1. To show Claim 3, we define an equivalence relation on pairs consisting of states and clock environments.
Reference: [AD90] <author> R. Alur and D.L. Dill. </author> <title> Automata for modeling real-time systems. In M.S. </title> <editor> Paterson, editor, </editor> <booktitle> ICALP 90: Automata, Languages, and Programming, Lecture Notes in Computer Science 443, </booktitle> <pages> pages 322-335. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: We consider dense time (the reals). A standard dense-time approach models a real-time system as a transition relation together with a finite set of real-valued clocks that proceed at a uniform rate and constrain the times at which transitions may occur <ref> [AD90, Lew90, AFH91, AH92a, NSY93] </ref>. Only recently a graph-theoretic model-checking algorithm was found for these systems [ACD90]. Since the time component causes the state space to be infinite, the algorithm depends on a clever construction of a finite quotient of the infinite state graph. <p> This translation forms the basis of a symbolic model-checking procedure. We apply this theory to a concrete real-time programming language. Real-time systems are defined in a guarded-command language with clocks, which is equivalent to timed safety automata| timed automata <ref> [AD90] </ref> without acceptance conditions. Every guarded-command real-time program defines a divergence-safe real-time system for which all formulas of T and TCTL can be verified symbolically by computing fixpoints (indeed, finitely approximable fixpoints) of appropriate functionals. <p> Our semantics integrates elements from several models that have been proposed in the literature; we are particularly indebted to the clocks of <ref> [AD90] </ref>, the dense trees of [ACD90], the transition-delay dichotomy of [HMP91] and [NSY93], and the relative safety of [Hen92]. 2.1 State trajectories We model time as the nonnegative real numbers R + . <p> each transition e = (` 1 ; ` 2 ) in E, if e is labeled with the guarded command g (e) = ! A, then G contains the guarded command (ff = ` 1 ^ ) ! A [ fff := ` 2 g; 3 The reader familiar with <ref> [AD90] </ref> will notice that we use a nonstandard variety of timed automata that (1) permits clock constraints on both locations and transitions and (2) is interpreted over weakly monotonic time [AH92b]. <p> We can define a product of timed safety automata that combines the train process and the controller process by synchronizing on the app and out signals. Instead of providing a formal definition of parallel composition (see, for instance, <ref> [AD90] </ref>), we present a real-time program P = (G; 2 ) that specifies the resulting system: G = f (ff = 0 ^ fi = 0) ! app ff := 1; fi := 1; x := 0; y := 0; (fi = 1 ^ 1 y &lt; 2) ! down fi
Reference: [ADS86] <author> B. Alpern, A.J. Demers, and F.B. Schneider. </author> <title> Safety without stuttering. </title> <journal> Information Processing Letters, </journal> <volume> 23(4) </volume> <pages> 177-180, </pages> <year> 1986. </year>
Reference-contexts: property is a set of admissible system behaviors that is closed under certain limit behaviors: a set of infinite state sequences is closed under limits iff for any infinite state sequence , whenever all finite prefixes of are prefixes of sequences in , then the limit sequence itself is in <ref> [ADS86] </ref>. We define the corresponding notion of safety for real-time trajectories.
Reference: [AFH91] <author> R. Alur, T. Feder, and T.A. Henzinger. </author> <title> The benefits of relaxing punctuality. </title> <booktitle> In Proceedings of the Tenth Annual Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 139-152. </pages> <publisher> ACM Press, </publisher> <year> 1991. </year>
Reference-contexts: We consider dense time (the reals). A standard dense-time approach models a real-time system as a transition relation together with a finite set of real-valued clocks that proceed at a uniform rate and constrain the times at which transitions may occur <ref> [AD90, Lew90, AFH91, AH92a, NSY93] </ref>. Only recently a graph-theoretic model-checking algorithm was found for these systems [ACD90]. Since the time component causes the state space to be infinite, the algorithm depends on a clever construction of a finite quotient of the infinite state graph.
Reference: [AH89] <author> R. Alur and T.A. Henzinger. </author> <title> A really temporal logic. </title> <booktitle> In Proceedings of the 30th Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 164-169. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1989. </year>
Reference-contexts: The reset quantifier z:, which binds and resets the specification clock z, is inspired by the freeze quantifier of Timed Temporal Logic <ref> [AH89] </ref>: for example, the formula z: (true8U (q ^ z 5)) asserts that the proposition q becomes necessarily true within 5 time units.
Reference: [AH92a] <author> R. Alur and T.A. Henzinger. </author> <title> Back to the future: towards a theory of timed regular languages. </title> <booktitle> In Proceedings of the 33rd Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 177-186. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1992. </year>
Reference-contexts: We consider dense time (the reals). A standard dense-time approach models a real-time system as a transition relation together with a finite set of real-valued clocks that proceed at a uniform rate and constrain the times at which transitions may occur <ref> [AD90, Lew90, AFH91, AH92a, NSY93] </ref>. Only recently a graph-theoretic model-checking algorithm was found for these systems [ACD90]. Since the time component causes the state space to be infinite, the algorithm depends on a clever construction of a finite quotient of the infinite state graph.
Reference: [AH92b] <author> R. Alur and T.A. Henzinger. </author> <title> Logics and models of real time: a survey. </title> <editor> In J.W. de Bakker, K. Huizing, W.-P. de Roever, and G. Rozenberg, editors, </editor> <title> Real Time: </title> <booktitle> Theory in Practice, Lecture Notes in Computer Science 600, </booktitle> <pages> pages 74-106. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: The history of model checking has been considerably shorter in the case of real-time systems. First researchers focused on discrete time (the integers), for which the untimed model-checking methods can be readily extended <ref> [EMSS90, AH92b, Eme92] </ref>. New complexities arise if we insist that for the compositional modeling of asynchronous systems, time should not be discretized [Alu91]. We consider dense time (the reals). <p> We model the timed behavior of a system by a divergent trajectory. This decision reflects several choices we make <ref> [AH92b] </ref>. First, the divergence requirement ensures the progress of time past any real number. Second, we choose time to be weakly monotonic: since a delay ffi i can be 0, time need not advance between consecutive transitions. <p> command (ff = ` 1 ^ ) ! A [ fff := ` 2 g; 3 The reader familiar with [AD90] will notice that we use a nonstandard variety of timed automata that (1) permits clock constraints on both locations and transitions and (2) is interpreted over weakly monotonic time <ref> [AH92b] </ref>.
Reference: [AHH93] <author> R. Alur, T.A. Henzinger, and P.-H. Ho. </author> <title> Automatic symbolic verification of embedded systems. </title> <booktitle> In Proceedings of the 14th Annual Real-time Systems Symposium, </booktitle> <pages> pages 2-11. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1993. </year>
Reference-contexts: A verification system at Grenoble [NSY92] represents state predicates by difference matrices over the integers [Dil89]; a verification system at Cornell <ref> [AHH93] </ref> represents state predicates as Mathematica formulas. 32 6.2 A verification example We consider the gate controller of a railroad crossing. The system consists of two parallel processes, namely, a train and a controller.
Reference: [AL88] <author> M. Abadi and L. Lamport. </author> <title> The existence of refinement mappings. </title> <booktitle> In Proceedings of the Third Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 165-175. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1988. </year>
Reference-contexts: Although both transition relations S 1 and S 2 define the same divergence-safe real-time system, namely 1 , only the former relation suggests an operational semantics for 1 : iterate time delays with transitions from S 1 . 2 The reader familiar with the concept of machine closure <ref> [AL88] </ref> will realize that the nonzenoness requirement is a machine closure condition, namely, machine closure with respect to the liveness property that asserts the divergence of time. 9 We now show the real-time analogues of Proposition 2.7 and Corollary 2.5, which reveal a one--to-one correspondence between divergence-safe real-time systems and nonzeno
Reference: [AL92] <author> M. Abadi and L. Lamport. </author> <title> An old-fashioned recipe for real time. </title> <editor> In J.W. de Bakker, K. Huizing, W.-P. de Roever, and G. Rozenberg, editors, </editor> <title> Real Time: </title> <booktitle> Theory in Practice, Lecture Notes in Computer Science 600, </booktitle> <pages> pages 1-27. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year> <month> 38 </month>
Reference-contexts: The practical computation of these functionals rests on our ability to express, for any given program, the next-state relation symbolically. Indeed, the extraction of the next-state relation from a program turns out to be rather nontrivial in the case that the program is not nonzeno <ref> [AL92, Hen92] </ref> (not machine-closed with respect to the divergence of time); that is, if it may prevent time from diverging. <p> We call a transition relation S that generates 2 nonzeno iff it suggests an operational semantics for 2 ; that is, iff every finite prefix of an S-trajectory can be extended to a divergent S-trajectory <ref> [AL92, Hen92] </ref>. 2 We will see that only one of the transition relations that generate 2 is nonzeno (namely S 2 ), and thus a suitable operational definition for the divergence-safe real-time system 2 .
Reference: [Alu91] <author> R. Alur. </author> <title> Techniques for Automatic Verification of Real-time Systems. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <year> 1991. </year>
Reference-contexts: First researchers focused on discrete time (the integers), for which the untimed model-checking methods can be readily extended [EMSS90, AH92b, Eme92]. New complexities arise if we insist that for the compositional modeling of asynchronous systems, time should not be discretized <ref> [Alu91] </ref>. We consider dense time (the reals). A standard dense-time approach models a real-time system as a transition relation together with a finite set of real-valued clocks that proceed at a uniform rate and constrain the times at which transitions may occur [AD90, Lew90, AFH91, AH92a, NSY93]. <p> However, as hinted above, we are able to give a translation from CTL with clock variables (TCTL of <ref> [Alu91] </ref>) to T that agrees on a class of well-behaved 2 divergence-safe models. This translation forms the basis of a symbolic model-checking procedure. We apply this theory to a concrete real-time programming language. <p> Third, in our version of TCTL freeze quantifiers on static time variables are replaced by reset quantifiers on dynamic clock variables. While both approaches are equivalent <ref> [Alu91] </ref>, the clock-reset style fits in better with our definition of real-time programs. 4.2 Finite variability Given a premodel , every formula ' of TCTL defines a set s of reachable states, namely, those states that satisfy '. <p> Some observations about regions are immediate. Let P be a real-time program and let ' be a TCTL-formula. First, there are only finitely many (P; ')-regions: if P and ' contain n clocks and no constant larger than k, then there are O (n k n!) minimal (P; ')-regions <ref> [Alu91] </ref>; and every (P; ')-region is a finite disjoint union of minimal (P; ')-regions. Second, the (P; ')-regions are closed under all boolean operations. <p> We now restate in our framework the main theorem for timed automata from Alur's thesis. By Proposition 4.1, we obtain the finite variability of TCTL over real-time programs as a corollary. Theorem 4.1 <ref> [Alu91] </ref> For every real-time program P and every TCTL-formula ', the characteristic sets [[']] S P and [[']] P are (P; ')-regions. Corollary 4.1 TCTL is finitely variable over the class of real-time programs. 4.3 The timed -calculus We now introduce T, a dense-time -calculus with clocks. <p> On the other hand, from the PSPACE-hardness of the reachability problem for timed automata <ref> [Alu91] </ref>, it follows that the model-checking problem for real-time programs and T is PSPACE-hard. The exact complexity, however, is not known to date even for the untimed problem of model checking the propositional -calculus.
Reference: [BCM + 92] <author> J.R. Burch, E.M. Clarke, K.L. McMillan, D.L. Dill, and L.J. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <journal> Information and Computation, </journal> <volume> 98(2) </volume> <pages> 142-170, </pages> <year> 1992. </year>
Reference-contexts: BDDs were first used for verification purposes by [CBM89] and for model checking by <ref> [BCM + 92] </ref>. By now implementations of symbolic model-checking techniques have reported spectacular successes, in particular in the area of hardware verification [McM93]. The history of model checking has been considerably shorter in the case of real-time systems. <p> We wish to conclude this introduction by pointing out that there is, of course, nothing "magical" about symbolic methods. Timed model checking is intrinsically difficult (PSPACE-hard) and already the known graph-theoretic algorithm on the exponential region graph is worst-case near-optimal [ACD90]. In practice, however, the "intuitive complexity" <ref> [BCM + 92] </ref> of the state space is typically much smaller than the region graph. Only a symbolic method can exploit this phenomenon, by representing unions of regions symbolically as state predicates.
Reference: [Bry86] <author> R.E. Bryant. </author> <title> Graph-based algorithms for boolean function manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-35(8):677-691, </volume> <year> 1986. </year>
Reference-contexts: of Scientific Research under contract F49620-93-1-0056. z Partially supported by the Esprit Basic Research Action REACT. 1 theoretical possibility of symbolic model checking by computing fixpoints was realized early [EC80, Sif82], the method has become practical only recently through the symbolic representation of state sets by binary decision diagrams (BDDs) <ref> [Bry86] </ref>. BDDs were first used for verification purposes by [CBM89] and for model checking by [BCM + 92]. By now implementations of symbolic model-checking techniques have reported spectacular successes, in particular in the area of hardware verification [McM93].
Reference: [CBM89] <author> O. Coudert, C. Berthet, and J. Madre. </author> <title> Verification of synchronous sequential machines based on symbolic execution. </title> <editor> In J. Sifakis, editor, </editor> <title> CAV 89: Automatic Verification Methods for Finite-state Systems, </title> <booktitle> Lecture Notes in Computer Science 407, </booktitle> <pages> pages 365-373. </pages> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: BDDs were first used for verification purposes by <ref> [CBM89] </ref> and for model checking by [BCM + 92]. By now implementations of symbolic model-checking techniques have reported spectacular successes, in particular in the area of hardware verification [McM93]. The history of model checking has been considerably shorter in the case of real-time systems.
Reference: [CES86] <author> E.M. Clarke, </author> <title> E.A. Emerson, and A.P. Sistla. Automatic verification of finite-state concurrent systems using temporal-logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <year> 1986. </year>
Reference-contexts: 1 Introduction Model checking is a powerful technique for the automatic verification of finite-state systems. Model-checking algorithms determine the states that satisfy a modal formula by a graph-theoretic analysis of the state space (Kripke structure) <ref> [QS81, EC82, CES86] </ref>. The main practical limitation of model-checking algorithms is caused by the size of the state graph, which grows exponentially with the number of parallel components in a system.
Reference: [Dil89] <author> D.L. Dill. </author> <title> Timing assumptions and verification of finite-state concurrent systems. </title> <editor> In J. Sifakis, editor, </editor> <title> CAV 89: Automatic Verification Methods for Finite-state Systems, </title> <booktitle> Lecture Notes in Computer Science 407, </booktitle> <pages> pages 197-212. </pages> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: A verification system at Grenoble [NSY92] represents state predicates by difference matrices over the integers <ref> [Dil89] </ref>; a verification system at Cornell [AHH93] represents state predicates as Mathematica formulas. 32 6.2 A verification example We consider the gate controller of a railroad crossing. The system consists of two parallel processes, namely, a train and a controller.
Reference: [EC80] <author> E.A. Emerson and E.M. Clarke. </author> <title> Characterizing correctness properties of parallel programs as fixpoints. </title> <booktitle> In ICALP 83: Automata, Languages, and Programming, Lecture Notes in Computer Science 85, </booktitle> <pages> pages 169-181. </pages> <publisher> Springer-Verlag, </publisher> <year> 1980. </year>
Reference-contexts: pp. 193-244. y Partially supported by the National Science Foundation under grant CCR-9200794 and by the United States Air Force Office of Scientific Research under contract F49620-93-1-0056. z Partially supported by the Esprit Basic Research Action REACT. 1 theoretical possibility of symbolic model checking by computing fixpoints was realized early <ref> [EC80, Sif82] </ref>, the method has become practical only recently through the symbolic representation of state sets by binary decision diagrams (BDDs) [Bry86]. BDDs were first used for verification purposes by [CBM89] and for model checking by [BCM + 92]. <p> First recall that CTL is strictly less expressive than the propositional -calculus; in particular, the CTL fl -formula 923p = -X: 93 (p ^ 9fl X); which asserts that there is a trajectory that contains infinitely many p-states, cannot be defined in CTL <ref> [EC80] </ref>. We modify a combinatorial proof of this result [EH86] to show that the T-formula ' inf = -X: 93 (x = 0 ^ ((x = 0) . ((x &gt; 0) . X))) is not definable in TCTL over the class of real-time programs. The proof proceeds by contradiction. <p> Theorem 5.1 should come as no surprise. It is true that in the untimed case, the branching-time logic CTL is strictly less expressive than the propositional -calculus <ref> [EC80] </ref>. More precisely, the until operators 9U and 8U are definable in the propositional -calculus over all systems that are generated by transition relations|i.e., all safe systems [Eme83]. The stutter closure of a safe system, however, may no longer be safe.
Reference: [EC82] <author> E.A. Emerson and E.M. Clarke. </author> <title> Using branching-time temporal logic to synthesize synchronization skeletons. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 2(3) </volume> <pages> 241-266, </pages> <year> 1982. </year>
Reference-contexts: 1 Introduction Model checking is a powerful technique for the automatic verification of finite-state systems. Model-checking algorithms determine the states that satisfy a modal formula by a graph-theoretic analysis of the state space (Kripke structure) <ref> [QS81, EC82, CES86] </ref>. The main practical limitation of model-checking algorithms is caused by the size of the state graph, which grows exponentially with the number of parallel components in a system. <p> Both languages use clocks and arithmetic constraints on clock values to specify timing requirements. 4.1 Timed computation tree logic Many important properties of systems find a natural expression in temporal logic [Eme90]. We first review the real-time temporal logic TCTL [ACD90], which extends the branching-time logic CTL <ref> [EC82] </ref> with clock variables. The formulas of TCTL, which are interpreted over the states of a given premodel , are built from state predicates by boolean connectives, the two temporal until operators 9U (possibly) and 8U (inevitably), and a reset quantifier for clocks.
Reference: [EH86] <author> E.A. Emerson and J.Y. Halpern. </author> <title> "Sometimes" and "Not never" revisited: on branching versus linear-time temporal logic. </title> <journal> Journal of the ACM, </journal> <volume> 33(1) </volume> <pages> 151-178, </pages> <year> 1986. </year>
Reference-contexts: We modify a combinatorial proof of this result <ref> [EH86] </ref> to show that the T-formula ' inf = -X: 93 (x = 0 ^ ((x = 0) . ((x &gt; 0) . X))) is not definable in TCTL over the class of real-time programs. The proof proceeds by contradiction. <p> However, one can define an extension TCTL fl of TCTL, analogous to the extension CTL fl <ref> [EH86] </ref> of CTL, which separates the trajectory quantifiers (e.g., 8) from the temporal operators (e.g., 2). In TCTL fl , the formula ' nz can be written as 92z: 3 (z = 1). 35 states).
Reference: [EL86] <author> E.A. Emerson and C. Lei. </author> <title> Efficient model checking in fragments of the propositional - calculus. </title> <booktitle> In Proceedings of the First Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 267-278. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1986. </year>
Reference-contexts: Many optimizations for computing fixpoints of the propositional -calculus apply also to Algorithm 6.1; for example, intermediate results can be reused when nested fixpoints of the same polarity are computed <ref> [EL86] </ref>. The practicality of a symbolic method depends, furthermore, on the representation of state predicates.
Reference: [Eme83] <author> E.A. Emerson. </author> <title> Alternative semantics for temporal logics. </title> <journal> Theoretical Computer Science, </journal> <volume> 26(1) </volume> <pages> 121-130, </pages> <year> 1983. </year>
Reference-contexts: Proposition 2.5 If is a premodel, then the induced relation S is a transition relation. We now generalize a well-known result for infinite state sequences: a set of infinite state sequences is generated by a binary relation on the states iff it is closed under suffixes, fusion, and limits <ref> [Eme83] </ref> (closure under stuttering corresponds to the requirement of self-reflexivity for the generating relation). Every safe premodel is definable by a transition relation, namely S , which generates precisely the trajectories in . Likewise, every divergence-safe real-time system can be defined by the transition relation S . <p> It is true that in the untimed case, the branching-time logic CTL is strictly less expressive than the propositional -calculus [EC80]. More precisely, the until operators 9U and 8U are definable in the propositional -calculus over all systems that are generated by transition relations|i.e., all safe systems <ref> [Eme83] </ref>. The stutter closure of a safe system, however, may no longer be safe. Indeed, the inevitability operator 8U of CTL cannot be defined in the propositional -calculus over the stutter closures of safe systems, because the propositional -calculus cannot distinguish between a system and its safety closure.
Reference: [Eme90] <author> E.A. Emerson. </author> <title> Temporal and modal logic. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> volume B, </volume> <pages> pages 995-1072. </pages> <publisher> Elsevier Science Publishers (North-Holland), </publisher> <year> 1990. </year>
Reference-contexts: Both languages use clocks and arithmetic constraints on clock values to specify timing requirements. 4.1 Timed computation tree logic Many important properties of systems find a natural expression in temporal logic <ref> [Eme90] </ref>. We first review the real-time temporal logic TCTL [ACD90], which extends the branching-time logic CTL [EC82] with clock variables.
Reference: [Eme92] <author> E.A. Emerson. </author> <title> Real time and the -calculus. </title> <editor> In J.W. de Bakker, K. Huizing, W.-P. de Roever, and G. Rozenberg, editors, </editor> <title> Real Time: </title> <booktitle> Theory in Practice, Lecture Notes in Computer Science 600, </booktitle> <pages> pages 176-194. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: The history of model checking has been considerably shorter in the case of real-time systems. First researchers focused on discrete time (the integers), for which the untimed model-checking methods can be readily extended <ref> [EMSS90, AH92b, Eme92] </ref>. New complexities arise if we insist that for the compositional modeling of asynchronous systems, time should not be discretized [Alu91]. We consider dense time (the reals). <p> The formulas of T are built from state predicates by boolean connectives, a temporal next operator, the reset quantifier for clocks, and a least-fixpoint quantifier. While discrete-time -calculi rely on a unary next-time operator <ref> [Koz83, Eme92] </ref>, there is no notion of "next time" when time is modeled by the real numbers.
Reference: [EMSS90] <author> E.A. Emerson, A.K. Mok, A.P. Sistla, and J. Srinivasan. </author> <title> Quantitative temporal reasoning. In R.P. Kurshan and E.M. </title> <editor> Clarke, editors, </editor> <booktitle> CAV 90: Computer-aided Verification, Lecture Notes in Computer Science 531, </booktitle> <pages> pages 136-145. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: The history of model checking has been considerably shorter in the case of real-time systems. First researchers focused on discrete time (the integers), for which the untimed model-checking methods can be readily extended <ref> [EMSS90, AH92b, Eme92] </ref>. New complexities arise if we insist that for the compositional modeling of asynchronous systems, time should not be discretized [Alu91]. We consider dense time (the reals).
Reference: [FR75] <author> J. Ferrante and C. Rackoff. </author> <title> A decision procedure for the first-order theory of real addition with order. </title> <journal> SIAM Journal on Computing, </journal> <volume> 4(1) </volume> <pages> 69-76, </pages> <year> 1975. </year> <month> 39 </month>
Reference-contexts: To ensure that the quantifier-free formula obtained by eliminating the evolves-to operator is a state predicate, however, we cannot use the near-optimal decision procedure of Ferrante and Rackoff for the first-order theory of real addition with order <ref> [FR75] </ref>. We provide a nonelementary translation from evolving state predicates to state predicates; the exact complexity of the satisfiability problem for evolving state predicates is an open problem. Theorem 3.2 For any evolving state predicate we can construct an equivalent state predicate jj.
Reference: [Hen92] <author> T.A. Henzinger. </author> <title> Sooner is safer than later. </title> <journal> Information Processing Letters, </journal> <volume> 43 </volume> <pages> 135-141, </pages> <year> 1992. </year>
Reference-contexts: The practical computation of these functionals rests on our ability to express, for any given program, the next-state relation symbolically. Indeed, the extraction of the next-state relation from a program turns out to be rather nontrivial in the case that the program is not nonzeno <ref> [AL92, Hen92] </ref> (not machine-closed with respect to the divergence of time); that is, if it may prevent time from diverging. <p> Our semantics integrates elements from several models that have been proposed in the literature; we are particularly indebted to the clocks of [AD90], the dense trees of [ACD90], the transition-delay dichotomy of [HMP91] and [NSY93], and the relative safety of <ref> [Hen92] </ref>. 2.1 State trajectories We model time as the nonnegative real numbers R + . <p> To see this, let be a divergent trajectory such that () = false for all positions of . Then every finite prefix of is the prefix of a trajectory in 2 , but itself is not in 2 . 1 The reader familiar with <ref> [Hen92] </ref> will notice that the concept of divergence safety corresponds to the notion of safety relative to the divergence of time. 6 To close a set of trajectories under (divergent) limits, we add a (divergent) trajectory if all finite prefixes of are prefixes of trajectories in . <p> We call a transition relation S that generates 2 nonzeno iff it suggests an operational semantics for 2 ; that is, iff every finite prefix of an S-trajectory can be extended to a divergent S-trajectory <ref> [AL92, Hen92] </ref>. 2 We will see that only one of the transition relations that generate 2 is nonzeno (namely S 2 ), and thus a suitable operational definition for the divergence-safe real-time system 2 . <p> Since is fusion-closed and divergence-safe, 2 . Furthermore, (0; 0) = 0 and, by Condition 3, () 62 s for all positions of . Since s 2 s, it follows that 0 6j= s 1 8U s 2 , a contradiction. There is a folk theorem (formalized in <ref> [Hen92] </ref>) that all time-bounded properties are safety requirements. Consider the two time-bounded properties 82 &lt;5 :q and 83 5 q.
Reference: [HLW91] <author> U. Holmer, K. Larsen, and Y. Wang. </author> <title> Deciding properties of regular real timed processes. </title> <editor> In K. Larsen and A. Skou, editors, </editor> <booktitle> CAV 91: Computer-aided Verification, Lecture Notes in Computer Science 575, </booktitle> <pages> pages 443-453. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: ::= X j p j x + c y + d j :' j ' 1 _ ' 2 j ' 1 . ' 2 j z: ' j X: ' 4 A modal operator similar to our next operator has been proposed for a dense-time extension of Hennessy-Milner logic <ref> [HLW91] </ref>. 21 for formula variables X 2 V , propositions p 2 P , clocks x; y 2 C, specification clocks z 2 C ' , and nonnegative integer constants c; d 2 N.
Reference: [HMP91] <author> T.A. Henzinger, Z. Manna, and A. Pnueli. </author> <title> Temporal proof methodologies for real-time systems. </title> <booktitle> In Proceedings of the 18th Annual Symposium on Principles of Programming Languages, </booktitle> <pages> pages 353-366. </pages> <publisher> ACM Press, </publisher> <year> 1991. </year>
Reference-contexts: Our semantics integrates elements from several models that have been proposed in the literature; we are particularly indebted to the clocks of [AD90], the dense trees of [ACD90], the transition-delay dichotomy of <ref> [HMP91] </ref> and [NSY93], and the relative safety of [Hen92]. 2.1 State trajectories We model time as the nonnegative real numbers R + .
Reference: [Koz83] <author> D. Kozen. </author> <title> Results on the propositional -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 27(3) </volume> <pages> 333-354, </pages> <year> 1983. </year>
Reference-contexts: The formulas of T are built from state predicates by boolean connectives, a temporal next operator, the reset quantifier for clocks, and a least-fixpoint quantifier. While discrete-time -calculi rely on a unary next-time operator <ref> [Koz83, Eme92] </ref>, there is no notion of "next time" when time is modeled by the real numbers.
Reference: [Lew90] <author> H.R. Lewis. </author> <title> A logic of concrete time intervals. </title> <booktitle> In Proceedings of the Fifth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 380-389. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1990. </year>
Reference-contexts: We consider dense time (the reals). A standard dense-time approach models a real-time system as a transition relation together with a finite set of real-valued clocks that proceed at a uniform rate and constrain the times at which transitions may occur <ref> [AD90, Lew90, AFH91, AH92a, NSY93] </ref>. Only recently a graph-theoretic model-checking algorithm was found for these systems [ACD90]. Since the time component causes the state space to be infinite, the algorithm depends on a clever construction of a finite quotient of the infinite state graph.
Reference: [McM93] <author> K.L. McMillan. </author> <title> Symbolic Model Checking: An Approach to the State Explosion Problem. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year>
Reference-contexts: BDDs were first used for verification purposes by [CBM89] and for model checking by [BCM + 92]. By now implementations of symbolic model-checking techniques have reported spectacular successes, in particular in the area of hardware verification <ref> [McM93] </ref>. The history of model checking has been considerably shorter in the case of real-time systems. First researchers focused on discrete time (the integers), for which the untimed model-checking methods can be readily extended [EMSS90, AH92b, Eme92].
Reference: [NOSY93] <author> X. Nicollin, A. Olivero, J. Sifakis, and S. Yovine. </author> <title> An approach to the description and analysis of hybrid systems. In R.L. </title> <editor> Grossman, A. Nerode, A.P. Ravn, and H. Rischel, editors, </editor> <booktitle> Hybrid Systems, Lecture Notes in Computer Science 736, </booktitle> <pages> pages 149-178. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: While our symbolic model-checking procedure will fail to terminate if no such quotient exists, the procedure remains sound and led recently to the verification of systems with very general state spaces <ref> [ACHH93, NOSY93] </ref>. The remainder of the paper is organized as follows. In the next section, we define our model of real-time systems. Section 3 presents a guarded-command language and an automata-based language for the description of real-time systems. <p> This strategy, too, can be implemented using the precondition and evolves-to operators [ACH + 92]. We conclude by pointing out that a natural extension of our method allows the analysis of so-called hybrid systems, which contain variables that change continuously in more general ways than clocks <ref> [ACHH93, NOSY93] </ref>. Acknowledgment. We thank Peter Kopke for a careful reading. Appendix Completion of the proof of Theorem 5.1. To show Claim 3, we define an equivalence relation on pairs consisting of states and clock environments.
Reference: [NS91] <author> X. Nicollin and J. Sifakis. </author> <title> An overview and synthesis on timed process algebras. </title> <editor> In K. Larsen and A. Skou, editors, </editor> <booktitle> CAV 91: Computer-aided Verification, Lecture Notes in Computer Science 575, </booktitle> <pages> pages 376-398. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: This condition, which is sometimes called time additivity <ref> [NS91] </ref>, asserts that any delay of ffi 1 + ffi 2 time units can be split into two consecutive delays of ffi 1 and ffi 2 time units, respectively.
Reference: [NSY92] <author> X. Nicollin, J. Sifakis, and S. Yovine. </author> <title> Compiling real-time specifications into extended automata. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-18(9):794-804, </volume> <year> 1992. </year>
Reference-contexts: While Algorithm 6.1 can be used to compute the characteristic predicates of T-formulas directly on the region graph of the input program, we know of two implementations that represent state sets symbolically and thus avoid the costly construction of the region graph. A verification system at Grenoble <ref> [NSY92] </ref> represents state predicates by difference matrices over the integers [Dil89]; a verification system at Cornell [AHH93] represents state predicates as Mathematica formulas. 32 6.2 A verification example We consider the gate controller of a railroad crossing. The system consists of two parallel processes, namely, a train and a controller.
Reference: [NSY93] <author> X. Nicollin, J. Sifakis, and S. Yovine. </author> <title> From ATP to timed graphs and hybrid systems. </title> <journal> Acta Informatica, </journal> <volume> 30 </volume> <pages> 181-202, </pages> <year> 1993. </year>
Reference-contexts: We consider dense time (the reals). A standard dense-time approach models a real-time system as a transition relation together with a finite set of real-valued clocks that proceed at a uniform rate and constrain the times at which transitions may occur <ref> [AD90, Lew90, AFH91, AH92a, NSY93] </ref>. Only recently a graph-theoretic model-checking algorithm was found for these systems [ACD90]. Since the time component causes the state space to be infinite, the algorithm depends on a clever construction of a finite quotient of the infinite state graph. <p> Our semantics integrates elements from several models that have been proposed in the literature; we are particularly indebted to the clocks of [AD90], the dense trees of [ACD90], the transition-delay dichotomy of [HMP91] and <ref> [NSY93] </ref>, and the relative safety of [Hen92]. 2.1 State trajectories We model time as the nonnegative real numbers R + .
Reference: [QS81] <author> J. Queille and J. Sifakis. </author> <title> Specification and verification of concurrent systems in CESAR. </title> <editor> In M. Dezani-Ciancaglini and U. Montanari, editors, </editor> <booktitle> Fifth International Symposium on Programming, Lecture Notes in Computer Science 137, </booktitle> <pages> pages 337-351. </pages> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: 1 Introduction Model checking is a powerful technique for the automatic verification of finite-state systems. Model-checking algorithms determine the states that satisfy a modal formula by a graph-theoretic analysis of the state space (Kripke structure) <ref> [QS81, EC82, CES86] </ref>. The main practical limitation of model-checking algorithms is caused by the size of the state graph, which grows exponentially with the number of parallel components in a system.
Reference: [Sif82] <author> J. Sifakis. </author> <title> A unified approach for studying the properties of transition systems. </title> <journal> Theoretical Computer Science, </journal> <volume> 18 </volume> <pages> 227-258, </pages> <year> 1982. </year> <month> 40 </month>
Reference-contexts: pp. 193-244. y Partially supported by the National Science Foundation under grant CCR-9200794 and by the United States Air Force Office of Scientific Research under contract F49620-93-1-0056. z Partially supported by the Esprit Basic Research Action REACT. 1 theoretical possibility of symbolic model checking by computing fixpoints was realized early <ref> [EC80, Sif82] </ref>, the method has become practical only recently through the symbolic representation of state sets by binary decision diagrams (BDDs) [Bry86]. BDDs were first used for verification purposes by [CBM89] and for model checking by [BCM + 92].
References-found: 39

