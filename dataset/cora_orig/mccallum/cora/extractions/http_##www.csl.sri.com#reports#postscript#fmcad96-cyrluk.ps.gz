URL: http://www.csl.sri.com/reports/postscript/fmcad96-cyrluk.ps.gz
Refering-URL: http://www.csl.sri.com/reports/postscript/
Root-URL: 
Email: cyrluk@cs.stanford.edu  
Title: Inverting the Abstraction Mapping: A Methodology for Hardware Verification  
Author: David Cyrluk 
Affiliation: Dept. of Computer Science, Stanford University,  Computer Science Laboratory, SRI International,  
Date: November 1996.)  
Address: Palo Alto, CA,  Stanford CA 94305 and  Menlo Park, CA 94025  
Note: (To be presented at Formal Methods in Computer Aided Design (FMCAD'96)  
Abstract: Abstraction mappings have become a standard approach to verifying the correctness of processors. When used in a straightforward manner this approach suffers from generating extremely large intermediate terms that have to be simplified. In an interactive theorem prover the complete expansion of the abstraction mapping is not even possible. Yet, with human guidance it is interactive theorem proving that is applied to examples too large to be handled by automated methods. We present a methodology for verifying the correctness of processors that aims to limit the size of intermediate terms generated in an interactive proof and to manage the complexity of the proof search. The main idea of this methodology is that, instead of expanding the abstraction mapping and thereby introduce large implementation terms into the specification, we try to identify sub-terms of implementation terms that can be replaced by specification state variables. This is done by inverting the equations defining the abstraction mapping so to rewrite implementation terms into abstract state variables. This method has been successfully applied to the verification of the DLX processor. It has also been applied to the verification of the ALU pipeline and Saxe pipeline and has simplified their proofs. Finally, lessons learned from this methodology can help develop better heuristics employed by automatic methods.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Martn Abadi and Leslie Lamport. </author> <title> The existence of refinement mappings. </title> <journal> Theoretical Computer Science, </journal> <volume> 82(2) </volume> <pages> 253-284, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: 1 Introduction The use of abstraction mappings <ref> [1] </ref> for the verification of microprocessors and other sequential hardware circuits is commonplace [3, 7, 11]. Both automated stand-alone tools [3] and automated proof strategies for use in interactive theorem provers [6] have been developed based on the use of abstraction mappings.
Reference: 2. <author> E. Boerger and S. Mazzanti. </author> <title> A correctness proof for pipelining in risc architectures. </title> <type> Dimacs technical report, </type> <institution> DIMACS, </institution> <year> 1996. </year> <note> (To appear). </note>
Reference-contexts: Furthermore, the general purpose nature of the theorem prover sometimes results in inefficiencies that a special purpose tool can avoid. In practice this means that the automated tool can generate much larger terms before blowing up. A separate verification of the DLX was done in <ref> [2] </ref>. This verification was done by hand and represents an extreme in human guidance. This proof was done by decomposing the pipeline into small stepwise refinements that were separately verified. Our approach falls in between these two extremes.
Reference: 3. <author> J. R. Burch and D. L. Dill. </author> <title> Automatic verification of pipelined microprocessor control. </title> <editor> In David Dill, editor, </editor> <booktitle> Computer-Aided Verification, CAV '94, volume 818 of Lecture Notes in Computer Science, </booktitle> <pages> pages 68-80, </pages> <address> Stanford, CA, June 1994. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: 1 Introduction The use of abstraction mappings [1] for the verification of microprocessors and other sequential hardware circuits is commonplace <ref> [3, 7, 11] </ref>. Both automated stand-alone tools [3] and automated proof strategies for use in interactive theorem provers [6] have been developed based on the use of abstraction mappings. <p> 1 Introduction The use of abstraction mappings [1] for the verification of microprocessors and other sequential hardware circuits is commonplace [3, 7, 11]. Both automated stand-alone tools <ref> [3] </ref> and automated proof strategies for use in interactive theorem provers [6] have been developed based on the use of abstraction mappings. <p> following equation: apply (update (reg, value, dstn addr ), src addr ) = cond (src addr = dst addr, value, apply (reg, src addr )). (APP UPD) 3.1 Traditional Method In this section we illustrate the verification of the above pipeline using the traditional method similar to methods discussed in <ref> [3, 6] </ref>. This method simply expands the definitions of the specification machine, implementation machine, and abstraction mapping. The resulting terms which contain embedded conditionals are then compared by case splitting on those conditionals and simplified using reasoning about equalities and updates. <p> The example that we verified was translated from the description used by Burch and Dill in <ref> [3] </ref>. Our verification differs from theirs in two respects. Firstly, we deal with stuttering slightly differently. <p> (NOT bubble_id (s)) AND ( rf1_of (instr_id (s)) = dest_ex (rs) OR rf2_of (instr_id (s)) = dest_ex (s)). 11 Thus the following predicate defines when an implementation state is visible: visible (s) = NOT branch_taken (s) AND NOT stall_issue (s) This is the negation of the stalling condition used in <ref> [3] </ref>. In their approach the user also needs to provide this information. <p> We have seen how this methodology while incomplete allows us to automate much of the verification and provide guidance where human input is needed. The methodology also gives us insight why the automatic methods work well. In the method of <ref> [3] </ref> they generate extremely large if-then-else terms represented in a DAG structure. A large part of this if-then-else term is devoted to different instances of the abstraction mapping being fully expanded. Their method also employs a heuristic to rewrite conditional terms into register file terms [4].
Reference: 4. <author> Jerry Burch. </author> <type> Personal Communication. </type>
Reference-contexts: In the method of [3] they generate extremely large if-then-else terms represented in a DAG structure. A large part of this if-then-else term is devoted to different instances of the abstraction mapping being fully expanded. Their method also employs a heuristic to rewrite conditional terms into register file terms <ref> [4] </ref>. As our proof indicates if this is done only a relatively few number of case analysis (relative to the size of the whole if-then-else) is needed to finish the proof. Our 14 method also indicates that if the specification is not written right this heuristic may not be useful.
Reference: 5. <author> D. Cyrluk and P. Narendran. </author> <title> Ground temporal logic|a logic for hardware verification. </title> <editor> In David Dill, editor, </editor> <booktitle> Computer-Aided Verification, CAV '94, volume 818 of Lecture Notes in Computer Science, </booktitle> <pages> pages 247-259, </pages> <address> Stanford, CA, June 1994. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: 1 Introduction The use of abstraction mappings [1] for the verification of microprocessors and other sequential hardware circuits is commonplace [3, 7, 11]. Both automated stand-alone tools [3] and automated proof strategies for use in interactive theorem provers [6] have been developed based on the use of abstraction mappings. In <ref> [5] </ref> we developed a language GTL2 that is appropriate for specifying the correctness of sequential hardware circuits using abstraction mappings. ? This research was partially supported by SRI International, DARPA contract NAG2-703, and NSF grants CCR-8917606, CCR-8915663. <p> These transition systems are represented as equations that specify how the state variables are updated by the execution of one machine cycle. These equations are implementation equations in GTL2 <ref> [5] </ref> and can be stated in the following form. ^ V j (next (s)) = next j (s) (3) where V j are state variables, next is the next state function (either I or A in Additionally, the abstraction mapping is given as equations that equate state variables in the specification
Reference: 6. <author> D. Cyrluk, S. Rajan, N. Shankar, and M. K. Srivas. </author> <title> Effective theorem proving for hardware verification. </title> <booktitle> In Kumar and Kropf [9], </booktitle> <pages> pages 203-222. </pages>
Reference-contexts: 1 Introduction The use of abstraction mappings [1] for the verification of microprocessors and other sequential hardware circuits is commonplace [3, 7, 11]. Both automated stand-alone tools [3] and automated proof strategies for use in interactive theorem provers <ref> [6] </ref> have been developed based on the use of abstraction mappings. In [5] we developed a language GTL2 that is appropriate for specifying the correctness of sequential hardware circuits using abstraction mappings. ? This research was partially supported by SRI International, DARPA contract NAG2-703, and NSF grants CCR-8917606, CCR-8915663. <p> following equation: apply (update (reg, value, dstn addr ), src addr ) = cond (src addr = dst addr, value, apply (reg, src addr )). (APP UPD) 3.1 Traditional Method In this section we illustrate the verification of the above pipeline using the traditional method similar to methods discussed in <ref> [3, 6] </ref>. This method simply expands the definitions of the specification machine, implementation machine, and abstraction mapping. The resulting terms which contain embedded conditionals are then compared by case splitting on those conditionals and simplified using reasoning about equalities and updates. <p> The first part is the inversion of the abstraction mapping and the generation of the new rules. This requires some understanding of the implementation and, as will be seen, may require some user guidance. The second part is more automatic and essentially uses our core hardware strategy from <ref> [6] </ref> to rewrite using the inverted abstraction mapping, the machine definitions, and the new rules, and then perform case analysis on the resulting terms. If we have generated enough rules the case analysis need only be on specification conditions. <p> given as: pc (vs) = pc (ABS (vs)) reg (next (next (next (next (vs))))) = reg (Abs (vs)) dmem (next (next (next (vs)))) = dmem (Abs (vs)) imem (vs) = imem (Abs (vs)) 4.2 Proof Now the proof proceeds essentially in the manner specified by our microprocessor strategy defined in <ref> [6] </ref>. Case analysis is performed on the num cycles function. This yields different goals for each branch in this function. In each goal the two terms corresponding to the two paths in the commutative diagram are expanded much like in our simple example.
Reference: 7. <author> David Cyrluk. </author> <title> Microprocessor verification in PVS: A methodology and simple example. </title> <type> Technical Report SRI-CSL-93-12, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: 1 Introduction The use of abstraction mappings [1] for the verification of microprocessors and other sequential hardware circuits is commonplace <ref> [3, 7, 11] </ref>. Both automated stand-alone tools [3] and automated proof strategies for use in interactive theorem provers [6] have been developed based on the use of abstraction mappings.
Reference: 8. <author> Nachum Dershowitz and Jean-Pierre Jouannaud. </author> <title> Rewrite systems. </title> <editor> In Jan van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B: Formal Models and Semantics, chapter 6, </booktitle> <pages> pages 243-320. </pages> <publisher> Elsevier and MIT press, </publisher> <address> Ams-terdam, The Netherlands, and Cambridge, MA, </address> <year> 1990. </year>
Reference-contexts: No rewrite rules are applicable and no amount of case analysis can reduce the above equation to true. The reason for this is that when we inverted the abstraction mapping we no longer have a confluent set of rewrite rules. Much like in the Knuth-Bendix completion procedure <ref> [8] </ref>, we need to add equations to make the resulting system canonical.
Reference: 9. <editor> Ramayya Kumar and Thomas Kropf, editors. </editor> <booktitle> Theorem Provers in Circuit Design (TPCD '94), volume 910 of Lecture Notes in Computer Science, </booktitle> <address> Bad Herrenalb, Germany, </address> <month> September </month> <year> 1994. </year> <note> Springer-Verlag. </note>
Reference: 10. <author> Sam Owre, John Rushby, Natarajan Shankar, and Friedrich von Henke. </author> <title> Formal verification for fault-tolerant architectures: Prolegomena to the design of PVS. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(2) </volume> <pages> 107-125, </pages> <month> February </month> <year> 1995. </year>
Reference-contexts: These expressions are then compared by performing case analysis on the conditions appearing in them. In large examples these expressions can get huge. In the PVS verification system <ref> [10] </ref>, the complete expansion of the abstraction mapping for this machine causes PVS to run out of memory! There are over 100 embedded if-then-else expressions in the expansion of the abstraction of the register file. It takes over 10 screens to print the entire expansion.
Reference: 11. <author> Mandayam K. Srivas and Steven P. Miller. </author> <title> Formal verification of the AAMP5 microprocessor. </title> <editor> In Michael G. Hinchey and Jonathan P. Bowen, editors, </editor> <booktitle> Applications of Formal Methods, Prentice Hall International Series in Computer Science, chapter 7, </booktitle> <pages> pages 125-180. </pages> <publisher> Prentice Hall, </publisher> <address> Hemel Hempstead, UK, </address> <year> 1995. </year> <month> 15 </month>
Reference-contexts: 1 Introduction The use of abstraction mappings [1] for the verification of microprocessors and other sequential hardware circuits is commonplace <ref> [3, 7, 11] </ref>. Both automated stand-alone tools [3] and automated proof strategies for use in interactive theorem provers [6] have been developed based on the use of abstraction mappings. <p> It takes over 10 screens to print the entire expansion. In spite of this size, the automated tool finishes the verification in a matter of seconds. In PVS, larger and more complicated processor verifications have been carried out <ref> [11] </ref>.
References-found: 11

