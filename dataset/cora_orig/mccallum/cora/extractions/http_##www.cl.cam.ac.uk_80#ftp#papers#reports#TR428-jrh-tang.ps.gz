URL: http://www.cl.cam.ac.uk:80/ftp/papers/reports/TR428-jrh-tang.ps.gz
Refering-URL: http://www.cl.cam.ac.uk:80/ftp/papers/reports/
Root-URL: 
Email: jrh@cl.cam.ac.uk  
Title: Floating point verification in HOL Light: the exponential function  
Author: John Harrison 
Date: June 1997  
Web: http://www.cl.cam.ac.uk/users/jrh  
Address: New Museums Site Pembroke Street Cambridge CB2 3QG England  
Affiliation: University of Cambridge Computer Laboratory  
Abstract: In that they often embody compact but mathematically sophisticated algorithms, operations for computing the common transcendental functions in floating point arithmetic seem good targets for formal verification using a mechanical theorem prover. We discuss some of the general issues that arise in verifications of this class, and then present a machine-checked verification of an algorithm for computing the exponential function in IEEE-754 standard binary floating point arithmetic. We confirm (indeed strengthen) the main result of a previously published error analysis, though we uncover a minor error in the hand proof and are forced to confront several subtle issues that might easily be overlooked informally. Our main theorem connects the floating point exponential to its abstract mathematical counterpart. The specification we prove is that the function has the correct overflow behaviour and, in the absence of overflow, the error in the result is less than 0:54 units in the last place (0:77 if the answer is denor-malized) compared against the exact mathematical exponential function. The algorithm is expressed in a simple formalized programming language, intended to be a subset of real programming and hardware description languages. It uses underlying floating point operations (addition, multiplication etc.) that are assumed to conform to the IEEE-754 standard for binary floating point arithmetic. The development described here includes, apart from the proof itself, a formalization of IEEE arithmetic, a mathematical semantics for the programming language in which the algorithm is expressed, and the body of pure mathematics needed. All this is developed logically from first principles using the HOL Light prover, which guarantees strict adherence to simple rules of inference while allowing the user to perform proofs using higher-level derived rules. We first present the main ideas and conclusions, and then collect some technical details about the prover and the underlying mathematical theories in appendices. fl Supported by the EPSRC research grant `floating point verification'.
Abstract-found: 1
Intro-found: 1
Reference: <author> Back, R. </author> <title> (1980) Correctness Preserving Program Transformations: Proof Theory and Applications, </title> <booktitle> Volume 131 of Mathematical Centre Tracts. Mathematical Cen-tre, </booktitle> <address> Amsterdam. </address>
Reference-contexts: While we consider verification condition generation to be a reasonable way to perform code verification, the underlying HOL theory does not force one to work in this way. For example, those who prefer to use stepwise refinement to develop programs from specifications <ref> (Back 1980) </ref> are free to do so. 6 HOL can automatically create verification conditions given only loop annotations (thanks to Tobias Nipkow via Mike Gordon for pointing this out to me), but sometimes the VCs are more perspicuous if the user provides guidance using assertions. 7 This program uses abstract mathematical
Reference: <author> Baker, A. </author> <title> (1975) Transcendental Number Theory. </title> <publisher> Cambridge University Press. </publisher>
Reference: <author> Barratt, M. </author> <title> (1989) Formal methods applied to a floating-point system. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 15, </volume> <pages> 611-621. </pages>
Reference: <author> Barwise, J. </author> <title> (1989) Mathematical proofs of computer correctness. </title> <journal> Notices of the American Mathematical Society, </journal> <volume> 7, </volume> <pages> 844-851. </pages>
Reference: <author> Beeson, M. J. </author> <booktitle> (1984) Foundations of constructive mathematics: metamathematical studies, Volume 3 of Ergebnisse der Mathematik und ihrer Grenzgebiete. </booktitle> <publisher> Springer-Verlag. </publisher>
Reference: <author> Benedetti, R. and Risler, J.-J. </author> <title> (1990) Real algebraic and semi-algebraic sets. </title> <address> Her-mann, Paris. </address>
Reference-contexts: Thus we need to prove formally how many (real) roots a polynomial has, and to do this we formalize Sturm's theorem on polynomial remainder sequences <ref> (Benedetti and Risler 1990) </ref>. It is worth noting that the only real error we have found in Tang's proof occurs here. <p> The proof is done automatically by HOL's linear natural number arithmetic package, after case-splitting over whether order a (p) is zero and throwing in the fact that order a (p) = order a (p 0 ) + 1 in the latter case. C.4 Sturm's theorem Sturm's theorem <ref> (Benedetti and Risler 1990) </ref> gives a precise figure for the number of (distinct) real roots a polynomial has in an interval. Assuming the polynomial has rational coefficients and the endpoints of the interval are rational, it requires only rational arithmetic.
Reference: <author> Boulton, R. et al. </author> <title> (1993) Experience with embedding hardware description languages in HOL. </title> <editor> In Stavridou, V., Melham, T. F., and Boute, R. T. (eds.), </editor> <booktitle> Proceedings of the IFIP TC10/WG 10.2 International Conference on Theorem Provers in Circuit Design: Theory, Practice and Experience, Volume A-10 of IFIP Transactions A: Computer Science and Technology, Nijmegen, The Nether-lands, </booktitle> <pages> pp. 129-156. </pages> <publisher> North-Holland. </publisher>
Reference-contexts: In fact HOL Light has a slightly different primitive constant definition rule, and this and others are derived from it. However little would change if things were implemented as above. 30 B Syntax and semantics of our programming lan- guage In HOL jargon <ref> (Boulton et al. 1993) </ref> our programming language semantics is a deep embedding. This means that the (abstract) syntax of programs is represented in HOL and the denotation function is a formal HOL object.
Reference: <author> Brock, B., Kaufmann, M., and Moore, J S. </author> <title> (1996) ACL2 theorems about commercial microprocessors. </title> <booktitle> See Srivas and Camilleri (1996), </booktitle> <pages> pp. 275-293. </pages>
Reference: <author> Church, A. </author> <title> (1940) A formulation of the Simple Theory of Types. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 5, </volume> <pages> 56-68. </pages>
Reference: <author> Clenshaw, C. W. and Olver, F. W. J. </author> <title> (1984) Beyond floating point. </title> <journal> Journal of the ACM , 31, </journal> <pages> 319-328. </pages>
Reference: <author> DeMillo, R., Lipton, R., and Perlis, A. </author> <title> (1979) Social processes and proofs of theorems and programs. </title> <journal> Communications of the ACM , 22, </journal> <pages> 271-280. </pages>
Reference: <author> Dijkstra, E. W. </author> <title> (1976) A Discipline of Programming. </title> <publisher> Prentice-Hall. </publisher>
Reference-contexts: B.3 Weakest preconditions Now we can define the important notions of weakest precondition and weakest liberal precondition <ref> (Dijkstra 1976) </ref>. Given a command c and a postcondition q (a predicate S ! bool that we want to hold in the final state), the corresponding weakest precondition is the set of all states s from which the command c is guaranteed to terminate in a state satisfying q.
Reference: <author> Dutertre, B. </author> <title> (1996) Elements of mathematical analysis in PVS. See von Wright, Grundy, </title> <booktitle> and Harrison (1996), </booktitle> <pages> pp. 141-156. </pages>
Reference-contexts: While some systems have one (e.g. Mizar) and some have the other (e.g. NQTHM), no other system that we are aware of combines these strengths. Probably the best alternative would be PVS, which has already benefited from some excellent work in formalized mathematics <ref> (Dutertre 1996) </ref> and floating point verification (Miner 1995; Miner and Leathrum 1996). Its type system offers some extra features over HOL's that might be helpful in giving a clear specification; for example, it is not necessary to distinguish between N and R.
Reference: <author> Gal, S. </author> <title> (1986) Computing elementary functions: A new approach for achieving high accuracy and good performance. </title> <editor> In Miranker, W. L. and Toupin, R. A. (eds.), </editor> <title> Accurate scientific computations, </title> <booktitle> Volume 235 of Lecture Notes in Computer Science, </booktitle> <pages> pp. 1-16. </pages> <publisher> Springer-Verlag. </publisher>
Reference: <author> Goldberg, D. </author> <title> (1991) What every computer scientist should know about floating point arithmetic. </title> <journal> ACM Computing Surveys, </journal> <volume> 23, </volume> <pages> 5-48. </pages>
Reference: <author> Gordon, M. J. C. </author> <title> (1989) Mechanizing programming logics in higher order logic. </title>
Reference: <editor> In Birtwistle, G. and Subrahmanyam, P. A. (eds.), </editor> <booktitle> Current Trends in Hardware Verification and Automated Theorem Proving, </booktitle> <pages> pp. 387-439. </pages> <publisher> Springer-Verlag. </publisher>
Reference: <editor> Gordon, M. J. C. </editor> <booktitle> (1995) The semantic challenge of Verilog HDL. In Proceedings of the Tenth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <address> San Diego, CA, USA, </address> <pages> pp. 136-145. </pages> <publisher> IEEE Computer Society Press. 107 Gordon, </publisher> <editor> M. J. C. and Melham, T. F. </editor> <title> (1993) Introduction to HOL: a theorem proving environment for higher order logic. </title> <publisher> Cambridge University Press. </publisher>
Reference-contexts: There are projects at the University of Cambridge Computer Laboratory looking at formal HOL-based semantics for the C programming language (Norrish 1997) and the Verilog hardware description language <ref> (Gordon 1995) </ref>, as well as a new project concerned with Handel (Page 1996). We hope in due course to make a more formal connection with at least some of these efforts. For the detailed semantics of our language, we refer the reader to the appropriate appendix.
Reference: <author> Gordon, M. J. C., Milner, R., and Wadsworth, C. P. </author> <title> (1979) Edinburgh LCF: A Mechanised Logic of Computation, </title> <booktitle> Volume 78 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag. </publisher>
Reference-contexts: provide a secure foundation for higher level work in numerical analysis, even when that is of itself out of reach of a formal treatment. 2 HOL Light HOL Light (Harrison 1996b) is our own version of the HOL prover (Gordon and Melham 1993), which is itself descended from Edinburgh LCF <ref> (Gordon, Milner, and Wadsworth 1979) </ref> via Cambridge LCF (Paulson 1987). HOL Light maintains most of the general principles underlying its ancestors, but attempts to be more logically coherent, elegant and usable.
Reference: <author> Grundy, J. </author> <title> (1993) Predicative programming|a survey. </title> <editor> In Bjtrner, D., Broy, M., and Pottosin, I. V. (eds.), </editor> <booktitle> Formal Methods in Programming and Their Applications: Proceedings of the International Conference, Volume 735 of Lecture Notes in Computer Science, </booktitle> <address> Academgorodok, Novosibirsk, Russia, </address> <pages> pp. 8-25. </pages> <publisher> Springer-Verlag. </publisher>
Reference: <author> Harrison, J. </author> <title> (1995) Floating point verification in HOL. </title> <editor> In Windley, P. J., Schubert, T., and Alves-Foss, J. (eds.), </editor> <title> Higher Order Logic Theorem Proving and Its Applications: </title> <booktitle> Proceedings of the 8th International Workshop, Volume 971 of Lecture Notes in Computer Science, </booktitle> <address> Aspen Grove, Utah, </address> <pages> pp. 186-199. </pages> <publisher> Springer-Verlag. </publisher>
Reference-contexts: See Gal (1986) for an example of this kind of correctness result for a floating point logarithm function not dissimilar in structure to the algorithm we are concerned with here. 4 Our implementation language In early versions of this work <ref> (Harrison 1995) </ref>, floating point algorithms were expressed directly by primitive recursive functions in the HOL logic. However such a formalization has only an indirect relationship with any actual implementation of the algorithm, either in hardware or software. Now we opt to express the algorithms in a simple imperative `while language'.
Reference: <author> Harrison, J. </author> <title> (1996a) A Mizar mode for HOL. See von Wright, Grundy, </title> <booktitle> and Harrison (1996), </booktitle> <pages> pp. 203-220. </pages>
Reference-contexts: One of the observed discrepancies turned out to be a bug not in the code but in the coprocessor. 1 proof outlines important, 2 and have recently <ref> (Harrison 1996a) </ref> been experimenting with more readable and declarative proof outlines inspired by the Mizar system (Trybulec 1978). While large ill-defined software systems are far from being verifiable, at least at present, there is no doubt that present verification techniques are applicable to some significant problems.
Reference: <author> Harrison, J. </author> <title> (1996b) HOL light: A tutorial introduction. </title> <booktitle> See Srivas and Camilleri (1996), </booktitle> <pages> pp. 265-269. </pages>
Reference-contexts: They embody relatively small but mathematically sophisticated algorithms. By focusing on them with a high level of formality, we can provide a secure foundation for higher level work in numerical analysis, even when that is of itself out of reach of a formal treatment. 2 HOL Light HOL Light <ref> (Harrison 1996b) </ref> is our own version of the HOL prover (Gordon and Melham 1993), which is itself descended from Edinburgh LCF (Gordon, Milner, and Wadsworth 1979) via Cambridge LCF (Paulson 1987).
Reference: <author> Harrison, J. </author> <title> (1996c) Theorem proving with the real numbers. </title> <type> Technical Report 408, </type> <institution> University of Cambridge Computer Laboratory, </institution> <address> New Museums Site, Pembroke Street, Cambridge, CB2 3QG, </address> <institution> UK. </institution> <type> Author's PhD thesis. </type>
Reference-contexts: A quick summary of HOL's logical basics is given in an appendix; for more details on the development of the HOL mathematical theories of real numbers, real analysis and transcendental functions on which this verification rests, we refer the reader to our PhD thesis <ref> (Harrison 1996c) </ref>. <p> theorem was suggested on the QED mailing list on 17th June 1994 by Andrzej Trybulec as an interesting case study in the relative power and flexibility of theorem proving systems | see ftp://ftp.mcs.anl.gov/pub/qed/archive/56 and ftp://ftp.mcs.anl.gov/pub/qed/archive/66. 25 simple CORDIC example we dealt with some time ago is based on this approach <ref> (Harrison 1996c) </ref>. Indeed, we could attempt to verify some implementations of the IEEE primitives in terms of their low-level components. The proofs would presumably be quite simple compared with those tackled here. <p> On the other hand, most of the arithmetic operations could be done in a more sophisticated way using approximations tailored to the required accuracy rather than relying on exact rational arithmetic <ref> (Harrison 1996c) </ref>. There is an argument though, that forcing the user to think carefully about something as basic as arithmetic in order to make it acceptably efficient is not conducive to great productivity. Perhaps it should simply be made primitive.
Reference: <author> Henkin, L. </author> <title> (1963) A theory of propositional types. </title> <journal> Fundamenta Mathematicae, </journal> <volume> 52, </volume> <pages> 323-344. </pages>
Reference: <author> Hesselink, W. H. </author> <title> (1992) Programs, Recursion and Unbounded Choice, Volume 27 of Cambridge Tracts in Theoretical Computer Science. Cambridge University Press. IEEE (1985) Standard for binary floating point arithmetic. ANSI/IEEE Standard 754-1985, </title> <booktitle> The Institute of Electrical and Electronic Engineers, </booktitle> <publisher> Inc., </publisher> <address> 345 East 47th Street, New York, NY 10017, USA. </address>
Reference: <author> Lindemann, F. </author> <title> (1882) Uber die Zahl . Mathematische Annalen, </title> <booktitle> 120, </booktitle> <pages> 213-225. </pages>
Reference: <author> Loveland, D. W. </author> <title> (1968) Mechanical theorem-proving by model elimination. </title> <journal> Journal of the ACM , 15, </journal> <pages> 236-251. </pages>
Reference-contexts: For another example, we can prove that there is a unique x such that x = f (g (x)) if and only if there is a unique y with y = g (f (y)) using a single standard tactic MESON TAC, which performs model elimination <ref> (Loveland 1968) </ref> to prove theorems about first order logic with equality.
Reference: <author> Milner, R. </author> <title> (1978) A theory of type polymorphism in programming. </title> <journal> Journal of Computer and Systems Sciences, </journal> <volume> 17, </volume> <pages> 348-375. </pages>
Reference: <author> Miner, P. S. </author> <title> (1995) Defining the IEEE-854 floating-point standard in PVS. </title> <type> Technical memorandum 110167, </type> <institution> NASA Langley Research Center, </institution> <address> Hampton, VA 23681-0001, USA. </address>
Reference: <author> Miner, P. S. and Leathrum, J. F. </author> <title> (1996) Verification of IEEE compliant subtractive division algorithms. </title> <booktitle> See Srivas and Camilleri (1996), </booktitle> <pages> pp. 64-78. </pages>
Reference: <author> Moore, J S., Lynch, T., and Kaufmann, M. </author> <title> (1996) A mechanically checked proof of the correctness of the kernel of the AM D5 K 86 floating-point division algorithm. </title> <note> Unpublished; available on the Web as http://devil.ece.utexas.edu:80/~lynch/divide/divide.html. </note>
Reference: <author> Ng, K. C. </author> <title> (1992) Argument reduction for huge arguments: Good to the last bit. </title>
Reference: <institution> Unpublished draft, </institution> <note> available from the author (kwok.ng@eng.sun.com). 108 Nipkow, </note> <author> T. </author> <title> (1996) Winskel is (almost) right: Towards a mechanized semantics text-book. </title> <editor> In Chandru, V. and Vinay, V. (eds.), </editor> <booktitle> Foundations of Software Technology and Theoretical Computer Science, 16th conference, proceedings, Lecture Notes in Computer Science, </booktitle> <pages> pp. 180-192. </pages> <publisher> Springer-Verlag. </publisher>
Reference: <author> Norrish, M. </author> <title> (1997) An abstract dynamic semantics for C. </title> <type> Technical Report 421, </type> <institution> University of Cambridge Computer Laboratory, </institution> <address> New Museums Site, Pembroke Street, Cambridge, CB2 3QG, UK. </address>
Reference-contexts: There are projects at the University of Cambridge Computer Laboratory looking at formal HOL-based semantics for the C programming language <ref> (Norrish 1997) </ref> and the Verilog hardware description language (Gordon 1995), as well as a new project concerned with Handel (Page 1996). We hope in due course to make a more formal connection with at least some of these efforts.
Reference: <author> Page, I. </author> <title> (1996) Constructing hardware-software systems from a single description. </title> <journal> Journal of VLSI Signal Processing, </journal> <volume> 12, </volume> <pages> 87-107. </pages>
Reference-contexts: There are projects at the University of Cambridge Computer Laboratory looking at formal HOL-based semantics for the C programming language (Norrish 1997) and the Verilog hardware description language (Gordon 1995), as well as a new project concerned with Handel <ref> (Page 1996) </ref>. We hope in due course to make a more formal connection with at least some of these efforts. For the detailed semantics of our language, we refer the reader to the appropriate appendix.
Reference: <author> Paulson, L. C. </author> <title> (1987) Logic and computation: interactive proof with Cambridge LCF, </title> <booktitle> Volume 2 of Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press. </publisher>
Reference-contexts: in numerical analysis, even when that is of itself out of reach of a formal treatment. 2 HOL Light HOL Light (Harrison 1996b) is our own version of the HOL prover (Gordon and Melham 1993), which is itself descended from Edinburgh LCF (Gordon, Milner, and Wadsworth 1979) via Cambridge LCF <ref> (Paulson 1987) </ref>. HOL Light maintains most of the general principles underlying its ancestors, but attempts to be more logically coherent, elegant and usable.
Reference: <author> Payne, M. and Hanek, R. </author> <title> (1983) Radian reduction for trigonometric functions. </title> <journal> SIGNUM Newsletter , 18(1), </journal> <pages> 19-24. </pages>
Reference-contexts: So if accurate rounding is required, it's necessary to store 1 or some such number to over a thousand bits, and perform the range reduction calculation to that accuracy <ref> (Payne and Hanek 1983) </ref>. Since this sort of super-accurate computation need only be kicked in when the argument is large, a situation that one hopes will, in the hands of a good numerical programmer, be exceptional, it need not affect average performance.
Reference: <author> Pollack, R. </author> <title> (1996) How to believe a machine-checked proof. </title> <note> Submitted to the 1997 Venice type theory meeting; currently available on the Web as http://www.brics.dk/~pollack/export/BelieveMachineCheckedProof.ps.gz. </note>
Reference: <author> Pour-El, M. B. and Richards, J. I. </author> <title> (1980) Computability in Analysis and Physics. Perspectives in Mathematical Logic. </title> <publisher> Springer-Verlag. </publisher>
Reference: <author> Pratt, V. R. </author> <title> (1995) Anatomy of the Pentium bug. </title> <editor> In Mosses, P. D., Nielsen, M., and Schwartzbach, M. I. (eds.), </editor> <booktitle> Proceedings of the 5th International Joint Conference on the theory and practice of software development (TAPSOFT'95), Volume 915 of Lecture Notes in Computer Science, Aarhus, Denmark, </booktitle> <pages> pp. 97-107. </pages> <publisher> Springer-Verlag. </publisher>
Reference-contexts: 1 Introduction Algorithms for performing floating point operations are often rather complex. It is difficult to make sure they are correct | for example, a bug in the floating-point division instruction of the Intel Pentium gained widespread publicity quite recently <ref> (Pratt 1995) </ref>. Indeed, it is sometimes difficult to say what it means for a floating point operation to be `correct'. We hope here to provide some answers to this question, and show how we can guarantee the correctness of a realistic floating point algorithm according to one of these criteria.
Reference: <author> Remes, M. E. </author> <title> (1934) Sur le calcul effectif des polynomes d'approximation de Tchebichef. </title> <journal> Comptes Rendus Hebdomadaires des Seances de l'Academie des Sciences, </journal> <volume> 199, </volume> <pages> 337-340. </pages>
Reference: <author> Rivlin, T. J. </author> <title> (1962) Polynomials of best uniform approximation to certain rational functions. </title> <journal> Numerische Mathematik , 4, </journal> <pages> 345-349. </pages>
Reference: <editor> Srivas, M. and Camilleri, A. (eds.) </editor> <booktitle> (1996) Proceedings of the First International Conference on Formal Methods in Computer-Aided Design (FMCAD'96), Volume 1166 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag. </publisher>
Reference: <author> Tang, P. T. P. </author> <title> (1989) Table-driven implementation of the exponential function in IEEE floating-point arithmetic. </title> <journal> ACM Transactions on Mathematical Software, </journal> <volume> 15, </volume> <pages> 144-157. </pages>
Reference-contexts: Occasionally we need to dive down to more specialized and intricate results | we will present an example later | but for the most part we can use a standard collection of lemmas. Following <ref> (Tang 1989) </ref>, we define the error resulting from rounding a real number to a floating point value: |- error (x) = Val (float (round (float_format) To_nearest x)) - x Because of the regular way in which the operations are defined, they all relate to their abstract mathematical counterparts according to the
Reference: <author> Trybulec, A. </author> <title> (1978) The Mizar-QC/6000 logic information language. </title> <journal> ALLC Bulletin (Association for Literary and Linguistic Computing), </journal> <volume> 6, </volume> <pages> 136-140. </pages>
Reference-contexts: One of the observed discrepancies turned out to be a bug not in the code but in the coprocessor. 1 proof outlines important, 2 and have recently (Harrison 1996a) been experimenting with more readable and declarative proof outlines inspired by the Mizar system <ref> (Trybulec 1978) </ref>. While large ill-defined software systems are far from being verifiable, at least at present, there is no doubt that present verification techniques are applicable to some significant problems. In particular, basic floating point operations seem to be a good target. They embody relatively small but mathematically sophisticated algorithms.
Reference: <author> Weis, P. and Leroy, X. </author> <title> (1993) Le langage Caml. </title> <journal> InterEditions. </journal> <note> See also the CAML Web page: http://pauillac.inria.fr/caml/. </note>
Reference-contexts: HOL Light maintains most of the general principles underlying its ancestors, but attempts to be more logically coherent, elegant and usable. It is written entirely in CAML Light <ref> (Weis and Leroy 1993) </ref>, giving it advantages of portability and low resource usage compared with its ancestors, which are based on LISP or Standard ML.
Reference: <author> Wilkinson, J. H. </author> <title> (1963) Rounding Errors in Algebraic Processes, </title> <booktitle> Volume 32 of National Physical Laboratory Notes on Applied Science. </booktitle> <address> Her Majesty's Stationery Office (HMSO), </address> <publisher> London. </publisher> <editor> von Wright, J., Grundy, J., and Harrison, J. (eds.) </editor> <title> (1996) Theorem Proving in Higher Order Logics: </title> <booktitle> 9th International Conference, TPHOLs'96, Volume 1125 of Lecture Notes in Computer Science, </booktitle> <address> Turku, Finland. </address> <publisher> Springer-Verlag. 109 von Wright, </publisher> <editor> J., Hekanaho, J., Luostarinen, P., and L-angbacka, T. </editor> <booktitle> (1993) Mecha--nizing some advanced refinement concepts. Formal Methods in System Design, </booktitle> <volume> 3, </volume> <pages> 49-82. </pages>
Reference-contexts: the disparity between its output and the true mathematical answer could be explained by a very small (say 0:5ulp) perturbation of the input: 9: jj 0:5 ulp x ^ f (v (x + )) = v (F (x)) There is an obvious analogy between this approach and backward error analysis <ref> (Wilkinson 1963) </ref>. Nevertheless, as pointed out by Kahan, one sometimes wants the appropriate `input perturbations' for various functions to be correlated in some way.
References-found: 48

