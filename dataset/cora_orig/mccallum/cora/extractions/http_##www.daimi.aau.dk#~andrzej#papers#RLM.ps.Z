URL: http://www.daimi.aau.dk/~andrzej/papers/RLM.ps.Z
Refering-URL: http://www.daimi.aau.dk/~andrzej/papers/
Root-URL: http://www.daimi.aau.dk
Email: andrzej@brics.dk  
Title: Representing Layered Monads  
Author: Andrzej Filinski 
Address: Ny Munkegade, DK-8000 Aarhus C, Denmark  
Affiliation: BRICS Department of Computer Science University of Aarhus  
Abstract: There has already been considerable research on constructing modular, monad-based specifications of computational effects (state, exceptions, nondeterminism, etc.) in programming languages. We present a simple framework in this tradition, based on a Church-style effect-typing system for an ML-like language. The semantics of this language is formally defined by a series of monadic translations, each one expanding away a layer of effects. Such a layered specification is easy to reason about, but its direct implementation (whether by parameterized interpretation or by actual translation) is often prohibitively inefficient. By exploiting deeper semantic properties of monads, however, it is also possible to derive a vastly more efficient implementation: we show that each layer of effects can be uniformly simulated by continuation-passing, and further that multiple such layers can themselves be simulated by a standard semantics for call/cc and mutable state. Thus, even multi-effect programs can be executed in Scheme or SML/NJ at full native speed, generalizing an earlier single-effect result. As an example, we show how a simple resumption-based semantics of concurrency allows us to directly simulate a shared-state program across all possible dynamic interleav-ings of execution threads. 
Abstract-found: 1
Intro-found: 1
Reference: [BCL + 98] <author> Edoardo Biagioni, Ken Cline, Peter Lee, Chris Okasaki, and Chris Stone. </author> <title> Safe-for-space threads in Standard ML. Higher-Order and Symbolic Computation, </title> <type> 11(2), </type> <year> 1998. </year>
Reference-contexts: be seen as a more principled justi fication for the practice of redefining the call/cc made available to the programmer in order to accommodate an implementation of dynamic-wind in Scheme [Ree92, KCR98], and for the implicit adaptation of the callcc/throw primitives in SML/NJ to also save and restore exception handlers <ref> [BCL + 98] </ref>. Theorem 10 (K-CS simulation) Let E be a complete program of L K cs , ` E : b = cs.
Reference: [CF94] <author> Robert Cartwright and Matthias Felleisen. </author> <title> Extensible denotational language specifications. </title> <editor> In Masami Hagiya and John C. Mitchell, editors, </editor> <booktitle> Symposium on Theoretical Aspects of Computer Software, number 789 in Lecture Notes in Computer Science, </booktitle> <pages> pages 244-272, </pages> <address> Sendai, Japan, </address> <month> April </month> <year> 1994. </year>
Reference-contexts: But the situation is less clear for the prospect of using monads to structure multiple, potentially intertwined effects: although a number of frameworks for this have been proposed <ref> [Mog90, Ste94, CF94, LHJ95, Esp95] </ref>, none seem to have gained overwhelming acceptance.
Reference: [DF90] <author> Olivier Danvy and Andrzej Filinski. </author> <title> Abstracting control. </title> <booktitle> In Proceedings of the 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 151-160, </pages> <address> Nice, France, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: This suggests that we can implement L K cs by a simple embedding into L cs 0 , where 0 extends with a new cell to hold the metacontinuation <ref> [DF90, Fil96] </ref> of the original computation. <p> Examples include uses of basic call/cc for thread packages [Wan80] and imperative backtracking [HDM93]; simple composable-control [FWFD88, DF92] for nondeterminism and other basic effects, and a number of proposals for hierarchical control <ref> [DF90, SF90, GRR95] </ref> to represent general layered effects. Most of these are based on operational definitions of the control operators in terms of their actions on evaluation contexts (although many also include sample implementations in terms of Scheme primitives).
Reference: [DF92] <author> Olivier Danvy and Andrzej Filinski. </author> <title> Representing control: A study of the CPS transformation. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 2(4) </volume> <pages> 361-391, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: A second line of related work concerns implementation of various computational paradigms using control operators directly, without involving monads at all. Examples include uses of basic call/cc for thread packages [Wan80] and imperative backtracking [HDM93]; simple composable-control <ref> [FWFD88, DF92] </ref> for nondeterminism and other basic effects, and a number of proposals for hierarchical control [DF90, SF90, GRR95] to represent general layered effects.
Reference: [Esp95] <author> David A. Espinosa. </author> <title> Semantic Lego. </title> <type> PhD thesis, </type> <institution> Graduate School of Arts and Sciences, Columbia University, </institution> <month> May </month> <year> 1995. </year>
Reference-contexts: But the situation is less clear for the prospect of using monads to structure multiple, potentially intertwined effects: although a number of frameworks for this have been proposed <ref> [Mog90, Ste94, CF94, LHJ95, Esp95] </ref>, none seem to have gained overwhelming acceptance. <p> We can add an output monad for tracing, but inspect it only for nondeterministic paths in which an exception is raised, and so on. 5 Related work There are already a large number of proposals for layering effects, both for structuring denotational semantics <ref> [Mog90, Esp95] </ref> and functional programs [KW93, Ste94, LHJ95]. Generally, however, these approaches pursue modularity in a "flat" multi-effect language, without an explicit effect-typing system. Accordingly, a central problem in such frameworks concerns defining the various effect-operations in such a way that they "lift through" other effects that may be present.
Reference: [Fil94] <author> Andrzej Filinski. </author> <title> Representing monads. </title> <booktitle> In Proceedings of the 21st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 446-457, </pages> <address> Portland, Oregon, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: We use this result to show correctness of a direct implementation of the proto-operations in terms of the control operators shift and reset. As previously shown <ref> [Fil94, Fil96] </ref>, these operators can themselves be implemented by Scheme-style primitives call/cc and state, but this "uses up" the call/cc operation of the host language. <p> Given T we construct an extension L T of L, with a new effect t and new proto-operations, monadic reflection and reification <ref> [Fil94] </ref>: reflect t reify t ff : (1 t ! ff) ! T ff When E : To =n, we often write t (E) : o =t for reflect t o E; and conversely, when E : o =t, [E] t : To =n for reify t ((): E). <p> term of L, such that the meanings of complete L 0 -programs are preserved. 3.1 Relating monadic effects to continuation passing It is a fairly simple observation that continuation-passing can simulate monadic style [PW93], but actually showing that the translations are equivalent is surprisingly complicated. 6 This was sketched in <ref> [Fil94] </ref> for a single effect in an other-wise completely pure language; unfortunately the retraction-based approach [MW85] used there does not seem to generalize well to more general settings, such as unrestricted recursion.
Reference: [Fil96] <author> Andrzej Filinski. </author> <title> Controlling Effects. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> May </month> <year> 1996. </year> <note> Technical Report CMU-CS-96-119. </note>
Reference-contexts: We use this result to show correctness of a direct implementation of the proto-operations in terms of the control operators shift and reset. As previously shown <ref> [Fil94, Fil96] </ref>, these operators can themselves be implemented by Scheme-style primitives call/cc and state, but this "uses up" the call/cc operation of the host language. <p> In <ref> [Fil96] </ref>, the proof was redone with admissible relations in the style of [Rey74], and extended to a base language with arbitrary pre-existing effects; and that approach does generalize to the multi-effect language of the previous section, as sketched in the following. <p> Relatively direct verification for both the new effect t and the new constants reflect t and reify t <ref> [Fil96] </ref>. For the latter two, we use the fact that (by Lemma 7) the interpretations of the term components of T are related, even if T does not actually define a monad in L i . <p> This suggests that we can implement L K cs by a simple embedding into L cs 0 , where 0 extends with a new cell to hold the metacontinuation <ref> [DF90, Fil96] </ref> of the original computation. <p> Thus, their existence is not automatic, but can be established fairly easily using Pitts's techniques <ref> [Pit96, Fil96] </ref>. We can then check directly that the interpretations of all constants in the two semantics are related by the corresponding relations, so the result follows by Lemma 7.
Reference: [FSDF93] <author> Cormac Flanagan, Amr Sabry, Bruce F. Duba, and Matthias Felleisen. </author> <title> The essence of compiling with continuations. </title> <booktitle> In Proceedings of the SIGPLAN '93 Conference on Programming Language Design and Implementation, </booktitle> <year> 1993. </year>
Reference-contexts: That is, the results of all non-trivial operations must be explicitly named, as in A-normal or monadic normal forms <ref> [FSDF93, HD94] </ref>. (Ultimately, however, we will still be able to write concrete programs in ML notation, with implicit call-by-value sequencing.) We further refine this language with a type system for keeping track of effects, very similar to Tolmach's and (to a lesser degree) Wadler's intermediate languages for ML [Tol98, Wad98].
Reference: [FWFD88] <author> Matthias Felleisen, Mitchell Wand, Daniel P. Fried-man, and Bruce F. Duba. </author> <title> Abstract continuations: A mathematical semantics for handling full functional jumps. </title> <booktitle> In Proceedings of the 1988 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 52-62, </pages> <address> Snowbird, Utah, </address> <month> July </month> <year> 1988. </year>
Reference-contexts: A second line of related work concerns implementation of various computational paradigms using control operators directly, without involving monads at all. Examples include uses of basic call/cc for thread packages [Wan80] and imperative backtracking [HDM93]; simple composable-control <ref> [FWFD88, DF92] </ref> for nondeterminism and other basic effects, and a number of proposals for hierarchical control [DF90, SF90, GRR95] to represent general layered effects.
Reference: [GRR95] <author> Carl A. Gunter, Didier Remy, and Jon G. Riecke. </author> <title> A generalization of exceptions and control in ML-like languages. </title> <booktitle> In Functional Programming and Computer Architecture, </booktitle> <pages> pages 12-23, </pages> <year> 1995. </year>
Reference-contexts: Examples include uses of basic call/cc for thread packages [Wan80] and imperative backtracking [HDM93]; simple composable-control [FWFD88, DF92] for nondeterminism and other basic effects, and a number of proposals for hierarchical control <ref> [DF90, SF90, GRR95] </ref> to represent general layered effects. Most of these are based on operational definitions of the control operators in terms of their actions on evaluation contexts (although many also include sample implementations in terms of Scheme primitives).
Reference: [HD94] <author> John Hatcliff and Olivier Danvy. </author> <title> A generic account of continuation-passing styles. </title> <booktitle> In Proceedings of the 21st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 458-471, </pages> <address> Portland, Oregon, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: That is, the results of all non-trivial operations must be explicitly named, as in A-normal or monadic normal forms <ref> [FSDF93, HD94] </ref>. (Ultimately, however, we will still be able to write concrete programs in ML notation, with implicit call-by-value sequencing.) We further refine this language with a type system for keeping track of effects, very similar to Tolmach's and (to a lesser degree) Wadler's intermediate languages for ML [Tol98, Wad98].
Reference: [HDM93] <author> Robert Harper, Bruce F. Duba, and David MacQueen. </author> <title> Typing first-class continuations in ML. </title> <journal> Journal of Functional Programming, </journal> <volume> 3(4) </volume> <pages> 465-484, </pages> <month> October </month> <year> 1993. </year> <note> (A preliminary version appeared in Proceedings of the 1991 Symposium on Principles of Programming Languages). </note>
Reference-contexts: A second line of related work concerns implementation of various computational paradigms using control operators directly, without involving monads at all. Examples include uses of basic call/cc for thread packages [Wan80] and imperative backtracking <ref> [HDM93] </ref>; simple composable-control [FWFD88, DF92] for nondeterminism and other basic effects, and a number of proposals for hierarchical control [DF90, SF90, GRR95] to represent general layered effects.
Reference: [KCR98] <editor> Richard Kelsey, William Clinger, and Jonathan Rees, editors. </editor> <title> Revised 5 report on the algorithmic language Scheme. </title> <journal> Higher-Order and Symbolic Computation, </journal> <volume> 11(3) </volume> <pages> 7-105, </pages> <year> 1998. </year> <note> Also appears in ACM SIGPLAN Notices 33(9), </note> <month> September </month> <year> 1998. </year>
Reference-contexts: We usually write !v for get v () and v := E for set v E. The formal semantics of this language is also Scheme-like <ref> [KCR98] </ref>: we interpret cs as the continuation-state monad, T A = A ! S ! P ? cs t ? f = : oe: t (a: oe : f a oe ) oe where S = Q v2dom L [[(v)]]. (Note that, since the types in may themselves contain cs-annotations, S <p> Formally, we have the following result: 1 This redefinition can also be seen as a more principled justi fication for the practice of redefining the call/cc made available to the programmer in order to accommodate an implementation of dynamic-wind in Scheme <ref> [Ree92, KCR98] </ref>, and for the implicit adaptation of the callcc/throw primitives in SML/NJ to also save and restore exception handlers [BCL + 98]. Theorem 10 (K-CS simulation) Let E be a complete program of L K cs , ` E : b = cs.
Reference: [KW93] <author> David J. King and Philip Wadler. </author> <title> Combining monads. </title> <editor> In J. Launchbury and P. M. Sansom, editors, </editor> <booktitle> Functional Programming, Glasgow 1992, </booktitle> <pages> pages 134-143, </pages> <address> Ayr, Scotland, 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Note that we do not require that T denote a monad for all interpretations of the effect e. For example, the formal list monad (used to give a semantics of nondeterminism in Section 4.2) can only be properly layered over a commutative monad <ref> [KW93] </ref>, such as partiality. <p> We can add an output monad for tracing, but inspect it only for nondeterministic paths in which an exception is raised, and so on. 5 Related work There are already a large number of proposals for layering effects, both for structuring denotational semantics [Mog90, Esp95] and functional programs <ref> [KW93, Ste94, LHJ95] </ref>. Generally, however, these approaches pursue modularity in a "flat" multi-effect language, without an explicit effect-typing system. Accordingly, a central problem in such frameworks concerns defining the various effect-operations in such a way that they "lift through" other effects that may be present.
Reference: [LHJ95] <author> Sheng Liang, Paul Hudak, and Mark Jones. </author> <title> Monad transformers and modular interpreters. </title> <booktitle> In Proceedings of the 22nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 333-343, </pages> <address> San Francisco, Cali-fornia, </address> <month> January </month> <year> 1995. </year>
Reference-contexts: But the situation is less clear for the prospect of using monads to structure multiple, potentially intertwined effects: although a number of frameworks for this have been proposed <ref> [Mog90, Ste94, CF94, LHJ95, Esp95] </ref>, none seem to have gained overwhelming acceptance. <p> When T is layered over T , we can also define a computation-inclusion or lifting <ref> [LHJ95, Tol98] </ref> function family i A = i A ffi T j A : T A ! T A. <p> We can add an output monad for tracing, but inspect it only for nondeterministic paths in which an exception is raised, and so on. 5 Related work There are already a large number of proposals for layering effects, both for structuring denotational semantics [Mog90, Esp95] and functional programs <ref> [KW93, Ste94, LHJ95] </ref>. Generally, however, these approaches pursue modularity in a "flat" multi-effect language, without an explicit effect-typing system. Accordingly, a central problem in such frameworks concerns defining the various effect-operations in such a way that they "lift through" other effects that may be present.
Reference: [LPJ95] <author> John Launchbury and Simon L. Peyton Jones. </author> <title> State in Haskell. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 8(4) </volume> <pages> 293-341, </pages> <month> De-cember </month> <year> 1995. </year>
Reference-contexts: A distinct problem with monad-based executable specifications of interacting effects is computational efficiency. Although explicit, purely functional definitions of effects make it easier to reason about programs, in practice key monads (such as state) are usually implemented imperatively by the compiler <ref> [LPJ95] </ref>. The efficiency problems are compounded for multi-level effects: in a naive implementation, the cost of each computational step is generally directly proportional to the total number of effects being modeled; and "built-in" monads are generally not integrable in a multi-effect framework with the same flexibility as user-specified ones.
Reference: [ML71] <author> Saunders Mac Lane. </author> <title> Categories for the Working Mathematician, volume 5 of Graduate Texts in Mathematics. </title> <publisher> Springer-Verlag, </publisher> <year> 1971. </year>
Reference-contexts: now introduce a concept useful for stacking monads: Definition 2 A layering of a monad T over another monad T = (T ; j; ?) consists of a function family i A : T (T A) !T A, such that each (T A; i A ) is a T -algebra <ref> [ML71, VI.2] </ref>, i.e., i A ffi j T A = id T A and i A ffi id T (T A) = i A ffi T i A and such that every f fl is a T -algebra morphism, i.e., f ffi i A = i B ffi T f :
Reference: [Mog89] <author> Eugenio Moggi. </author> <title> Computational lambda-calculus and monads. </title> <booktitle> In Proceedings of the Fourth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 14-23, </pages> <address> Pacific Grove, Cali-fornia, </address> <month> June </month> <year> 1989. </year> <note> IEEE. </note>
Reference-contexts: 1 Introduction By now, monads are firmly established as an key concept in functional programming, both as a semantic framework for ML-like languages <ref> [Mog89] </ref>, and as a structuring technique for purely functional programs with computational effects [Wad92].
Reference: [Mog90] <author> Eugenio Moggi. </author> <title> An abstract view of programming languages. </title> <type> Technical Report ECS-LFCS-90-113, </type> <institution> Laboratory for Foundations of Computer Science, University of Edinburgh, Edinburgh, </institution> <address> Scotland, </address> <month> April </month> <year> 1990. </year>
Reference-contexts: But the situation is less clear for the prospect of using monads to structure multiple, potentially intertwined effects: although a number of frameworks for this have been proposed <ref> [Mog90, Ste94, CF94, LHJ95, Esp95] </ref>, none seem to have gained overwhelming acceptance. <p> When T is layered over T , we can also define a computation-inclusion or lifting [LHJ95, Tol98] function family i A = i A ffi T j A : T A ! T A. This is easily checked to be a monad morphism <ref> [Mog90] </ref>, i.e., to satisfy the equations i A (j A a) = j A a and i B (t ? f ) = i A t ? (a: i B (f a)) Conversely, given a monad morphism i : T ! T , we can obtain a layering by i A <p> ()) funfunfun disp [] = "&lt;fail&gt;" | disp [x] = x | disp (h::t) = h ^ " &lt;or&gt; " ^ disp t funfunfun show t = disp (t ()) endendend; 4.2 Shared-state concurrency As a larger example, we will consider the monadic approach to modeling concurrency, as sketched in <ref> [Mog90] </ref>, based on the semantic concept of resumptions [Sch86]. (Strictly speaking, this example goes beyond the language outlined 11 in Section 2.1 by using a (positive) recursively defined type in the monad specifications. <p> We can add an output monad for tracing, but inspect it only for nondeterministic paths in which an exception is raised, and so on. 5 Related work There are already a large number of proposals for layering effects, both for structuring denotational semantics <ref> [Mog90, Esp95] </ref> and functional programs [KW93, Ste94, LHJ95]. Generally, however, these approaches pursue modularity in a "flat" multi-effect language, without an explicit effect-typing system. Accordingly, a central problem in such frameworks concerns defining the various effect-operations in such a way that they "lift through" other effects that may be present.
Reference: [MTHM97] <author> Robin Milner, Mads Tofte, Robert Harper, and David MacQueen. </author> <title> The Definition of Standard ML. </title> <publisher> The MIT Press, </publisher> <address> revised edition, </address> <year> 1997. </year>
Reference-contexts: We show it here for the latter (in SML'97 syntax <ref> [MTHM97] </ref>), using parameterized modules to represent syntactic realizations. operator construction from Section 3.2. Figure 3 shows a simple implementation of the universal type required for the answer-embedding in Lemma 8; an alternative implementa tion in terms of SML's extensible datatype exn of exception names is also possible.
Reference: [MW85] <author> Albert R. Meyer and Mitchell Wand. </author> <title> Continuation semantics in typed lambda-calculi (summary). </title> <editor> In Rohit Parikh, editor, </editor> <booktitle> Logics of Programs Proceedings, number 193 in Lecture Notes in Computer Science, </booktitle> <pages> pages 219-224, </pages> <address> Brooklyn, </address> <month> June </month> <year> 1985. </year>
Reference-contexts: Relating monadic effects to continuation passing It is a fairly simple observation that continuation-passing can simulate monadic style [PW93], but actually showing that the translations are equivalent is surprisingly complicated. 6 This was sketched in [Fil94] for a single effect in an other-wise completely pure language; unfortunately the retraction-based approach <ref> [MW85] </ref> used there does not seem to generalize well to more general settings, such as unrestricted recursion.
Reference: [Pit96] <author> Andrew M. Pitts. </author> <title> Relational properties of domains. </title> <journal> Information and Computation, </journal> <volume> 127(2) </volume> <pages> 66-90, </pages> <month> June </month> <year> 1996. </year>
Reference-contexts: Thus, their existence is not automatic, but can be established fairly easily using Pitts's techniques <ref> [Pit96, Fil96] </ref>. We can then check directly that the interpretations of all constants in the two semantics are related by the corresponding relations, so the result follows by Lemma 7.
Reference: [Plo77] <author> Gordon D. Plotkin. </author> <title> LCF considered as a programming language. </title> <journal> Theoretical Computer Science, </journal> <volume> 5(3) </volume> <pages> 223-255, </pages> <month> De-cember </month> <year> 1977. </year>
Reference-contexts: The ML representation of the monad and its associated operations can be found in Figure 6. As long as all resumption-computations suspend periodi cally (e.g., by calling yield ()), this setup can directly simu late the parallel-or operation <ref> [Plo77] </ref>, which returns true if either of of its arguments evaluates to true, false if both evaluate to false, and diverges in all other cases. Note that, because por constructs another resumption-computation, the branches of a parallel-or can themselves contain parallel subcomputations.
Reference: [PW93] <editor> Simon L. Peyton Jones and Philip Wadler. </editor> <title> Imperative functional programming. </title> <booktitle> In Proceedings of the Twentieth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 71-84, </pages> <address> Charleston, South Carolina, </address> <month> January </month> <year> 1993. </year>
Reference-contexts: of L 0 with an effect of L, and every new constant of L 0 by a term of L, such that the meanings of complete L 0 -programs are preserved. 3.1 Relating monadic effects to continuation passing It is a fairly simple observation that continuation-passing can simulate monadic style <ref> [PW93] </ref>, but actually showing that the translations are equivalent is surprisingly complicated. 6 This was sketched in [Fil94] for a single effect in an other-wise completely pure language; unfortunately the retraction-based approach [MW85] used there does not seem to generalize well to more general settings, such as unrestricted recursion.
Reference: [Ree92] <author> Jonathan Rees. </author> <title> The Scheme of things: The June 1992 meeting. </title> <journal> Lisp Pointers, </journal> <volume> 5(4) </volume> <pages> 40-45, </pages> <year> 1992. </year>
Reference-contexts: Formally, we have the following result: 1 This redefinition can also be seen as a more principled justi fication for the practice of redefining the call/cc made available to the programmer in order to accommodate an implementation of dynamic-wind in Scheme <ref> [Ree92, KCR98] </ref>, and for the implicit adaptation of the callcc/throw primitives in SML/NJ to also save and restore exception handlers [BCL + 98]. Theorem 10 (K-CS simulation) Let E be a complete program of L K cs , ` E : b = cs.
Reference: [Rey74] <author> John C. Reynolds. </author> <title> On the relation between direct and continuation semantics. </title> <editor> In Jacques Loeckx, editor, </editor> <booktitle> 2nd Colloquium on Automata, Languages and Programming, number 14 in Lecture Notes in Computer Science, </booktitle> <pages> pages 141-156, </pages> <address> Saarbrucken, West Germany, </address> <month> July </month> <year> 1974. </year>
Reference-contexts: In [Fil96], the proof was redone with admissible relations in the style of <ref> [Rey74] </ref>, and extended to a base language with arbitrary pre-existing effects; and that approach does generalize to the multi-effect language of the previous section, as sketched in the following.
Reference: [Sch86] <author> David A. Schmidt. </author> <title> Denotational Semantics: A Methodology for Language Development. </title> <publisher> Allyn and Bacon, Inc., </publisher> <year> 1986. </year>
Reference-contexts: [x] = x | disp (h::t) = h ^ " &lt;or&gt; " ^ disp t funfunfun show t = disp (t ()) endendend; 4.2 Shared-state concurrency As a larger example, we will consider the monadic approach to modeling concurrency, as sketched in [Mog90], based on the semantic concept of resumptions <ref> [Sch86] </ref>. (Strictly speaking, this example goes beyond the language outlined 11 in Section 2.1 by using a (positive) recursively defined type in the monad specifications.
Reference: [SF90] <author> Dorai Sitaram and Matthias Felleisen. </author> <title> Control delimiters and their hierarchies. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 3(1) </volume> <pages> 67-99, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Examples include uses of basic call/cc for thread packages [Wan80] and imperative backtracking [HDM93]; simple composable-control [FWFD88, DF92] for nondeterminism and other basic effects, and a number of proposals for hierarchical control <ref> [DF90, SF90, GRR95] </ref> to represent general layered effects. Most of these are based on operational definitions of the control operators in terms of their actions on evaluation contexts (although many also include sample implementations in terms of Scheme primitives).
Reference: [Ste94] <author> Guy L. Steele, Jr. </author> <title> Building interpreters by composing monads. </title> <booktitle> In Proceedings of the 21st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 472-492, </pages> <address> Portland, Oregon, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: But the situation is less clear for the prospect of using monads to structure multiple, potentially intertwined effects: although a number of frameworks for this have been proposed <ref> [Mog90, Ste94, CF94, LHJ95, Esp95] </ref>, none seem to have gained overwhelming acceptance. <p> We can add an output monad for tracing, but inspect it only for nondeterministic paths in which an exception is raised, and so on. 5 Related work There are already a large number of proposals for layering effects, both for structuring denotational semantics [Mog90, Esp95] and functional programs <ref> [KW93, Ste94, LHJ95] </ref>. Generally, however, these approaches pursue modularity in a "flat" multi-effect language, without an explicit effect-typing system. Accordingly, a central problem in such frameworks concerns defining the various effect-operations in such a way that they "lift through" other effects that may be present.
Reference: [Tol98] <author> Andrew Tolmach. </author> <title> Optimizing ML using a hierarchy of monadic types. In Xavier Leroy and Atsushi Ohori, editors, Types in Compilation, </title> <booktitle> Second International Workshop, number 1473 in Lecture Notes in Computer Science, </booktitle> <pages> pages 97-115, </pages> <address> Kyoto, Japan, </address> <month> March </month> <year> 1998. </year>
Reference-contexts: normal forms [FSDF93, HD94]. (Ultimately, however, we will still be able to write concrete programs in ML notation, with implicit call-by-value sequencing.) We further refine this language with a type system for keeping track of effects, very similar to Tolmach's and (to a lesser degree) Wadler's intermediate languages for ML <ref> [Tol98, Wad98] </ref>. However, we will use effect-types prescrip tively, to define a new language, rather than descriptively, to analyze an already given one. <p> When T is layered over T , we can also define a computation-inclusion or lifting <ref> [LHJ95, Tol98] </ref> function family i A = i A ffi T j A : T A ! T A. <p> In a gen eral optimizer for higher-order programs, however, it seems preferable to maintain explicit effect-types everywhere, as advocated by Tolmach <ref> [Tol98] </ref>.
Reference: [Wad92] <author> Philip Wadler. </author> <title> The essence of functional programming (invited talk). </title> <booktitle> In Proceedings of the Nineteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-14, </pages> <address> Albuquerque, New Mexico, </address> <month> January </month> <year> 1992. </year>
Reference-contexts: 1 Introduction By now, monads are firmly established as an key concept in functional programming, both as a semantic framework for ML-like languages [Mog89], and as a structuring technique for purely functional programs with computational effects <ref> [Wad92] </ref>. But the situation is less clear for the prospect of using monads to structure multiple, potentially intertwined effects: although a number of frameworks for this have been proposed [Mog90, Ste94, CF94, LHJ95, Esp95], none seem to have gained overwhelming acceptance.
Reference: [Wad98] <author> Philip Wadler. </author> <title> The marriage of effects and monads. </title> <booktitle> In International Conference on Functional Programming, </booktitle> <year> 1998. </year>
Reference-contexts: normal forms [FSDF93, HD94]. (Ultimately, however, we will still be able to write concrete programs in ML notation, with implicit call-by-value sequencing.) We further refine this language with a type system for keeping track of effects, very similar to Tolmach's and (to a lesser degree) Wadler's intermediate languages for ML <ref> [Tol98, Wad98] </ref>. However, we will use effect-types prescrip tively, to define a new language, rather than descriptively, to analyze an already given one.
Reference: [Wan80] <author> Mitchell Wand. </author> <title> Continuation-based multiprocessing. </title> <booktitle> In Conference Record of the 1980 LISP Conference, </booktitle> <pages> pages 19-28, </pages> <address> Stanford, California, </address> <month> August </month> <year> 1980. </year> <month> 14 </month>
Reference-contexts: With this setup, and a suitable structure on requests and responses, it is simple to write an scheduler matching up senders and receivers in purely functional style. And while similar in efficiency to a traditional call/cc-based thread package <ref> [Wan80] </ref>, such a system also achieves a direct re lationship to the usual denotational specification. <p> A second line of related work concerns implementation of various computational paradigms using control operators directly, without involving monads at all. Examples include uses of basic call/cc for thread packages <ref> [Wan80] </ref> and imperative backtracking [HDM93]; simple composable-control [FWFD88, DF92] for nondeterminism and other basic effects, and a number of proposals for hierarchical control [DF90, SF90, GRR95] to represent general layered effects.
References-found: 33

