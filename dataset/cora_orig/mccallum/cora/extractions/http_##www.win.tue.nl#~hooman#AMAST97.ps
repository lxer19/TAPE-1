URL: http://www.win.tue.nl/~hooman/AMAST97.ps
Refering-URL: http://www.win.tue.nl/~hooman/AMAST97.html
Root-URL: http://www.win.tue.nl
Email: e-mail: wsinjh@win.tue.nl  
Title: Verification of Distributed Real-Time and Fault-Tolerant Protocols  
Author: Jozef Hooman 
Web: http://www.win.tue.nl/win/cs/tt/hooman/JH.html  
Address: P.O. Box 513, 5600 MB Eindhoven, The Netherlands  
Affiliation: Department of Computing Science, Eindhoven University of Technology  
Abstract: An assertional method to verify distributed real-time and fault-tolerant protocols is presented. To obtain mechanical support, the verification system PVS is used. General PVS theories are developed to deal with timing and failures. As a characteristic example, we verify a processor-group membership protocol, dealing with a dynamically changing network of processors and reasoning in terms of local clocks. Further we show some basic theories for the verification of the underlying synchronous atomic broadcast service. 
Abstract-found: 1
Intro-found: 1
Reference: [AH97] <author> M. Archer and C. Heitmeyer. </author> <title> Verifying hybrid systems modeled as timed automata: A case study. </title> <booktitle> In Hybrid and Real-Time Systems (HART'97), </booktitle> <pages> pages 171-185. </pages> <publisher> LNCS 1201, Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: Sometimes the use of a formal framework structures the specification and the verification; see for instance the use of TLA for a treatment of the Byzantine generals problem [LM94]. Interesting in <ref> [AH97] </ref> is the formulation of a template for specifying Lynch-Vaandrager timed automata in PVS. Generic PVS theories to verify well-known algorithmic techniques such as divide-and-conquer have been formulated by Dold [Dol95]. Specific algorithms can be obtained by adding details to a general scheme.
Reference: [BHMY89] <author> W.R. Brevier, W.A. Hunt, J.S. Moore, and W.D. Young. </author> <title> An approach to systems verification. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 5(4) </volume> <pages> 411-428, </pages> <year> 1989. </year>
Reference-contexts: Relevant is also an extensive treatment of clock synchronization protocols in PVS by Shankar [Sha92]. A classical example of a hierarchical verification is the "CLI short stack", which has been verified using Nqthm <ref> [BHMY89] </ref>. Most of the literature mentioned above does not give a clear methodology that can easily be used by others. Sometimes the use of a formal framework structures the specification and the verification; see for instance the use of TLA for a treatment of the Byzantine generals problem [LM94].
Reference: [CASD95] <author> F. Cristian, H. Aghili, R. Strong, and D. Dolev. </author> <title> Atomic broadcast: From simple message diffusion to Byzantine agreement. </title> <journal> Information and Computation, </journal> <volume> 118 </volume> <pages> 158-179, </pages> <year> 1995. </year>
Reference-contexts: For simplicity, we do not use the group identifiers mentioned in [Cri91] (assuming that the scheduling delay is zero). Further we assume fail-silent processors whereas in [Cri91] processors can suffer both crash and performance failures. The membership algorithm uses a synchronous atomic broadcast service to communicate between processors. In <ref> [CASD95] </ref> it is shown that this broadcast service can indeed be implemented, using a lower-level point-to-point datagram service and internally synchronized local clocks. Here we indicate how to proceed with the verification of this atomic broadcast protocol in PVS. <p> Integrity ^ OwnIdentityOnly^ BroadcastReason ^ StartUp ^ Termination ^ BroadcastPresent ) Agree join verif : lemma JoinDelay 2 fi BroadcastDelay^ ProcJoin ^ StartUp ^ Termination ^ BroadcastPresent ) Join 6 Implementation of Atomic Broadcast An implementation of the atomic broadcast service assumed in the previous section can be found in <ref> [CASD95] </ref>. To verify this protocol, we can again follow the steps of section 3, now using the theory of section 4.3 as a specification of the required service. <p> 2 ; p)]^ Correct (p) during [(T 1 ; p); (T 2 ; p)] ^ Correct (q) during [(T 1 ; p); (T 2 ; p)] ) P in [(T 1 "; q); (T 2 + "; q)] end LocalClockSynchr 6.2 Specification of datagram service The atomic broadcast protocol of <ref> [CASD95] </ref> is based on a datagram service which allows the transmission of messages along links between pairs of nodes. Corresponding to step 3 of our approach, we specify this communication mechanism in theory Datagram, with a type Links as one of the parameters. <p> Following <ref> [CASD95] </ref>, these time bounds are expressed in terms of clock values measured on the clock of any arbitrary correct processor r. <p> l)(T; r) ) 9 p : p 6= q ^ l 2 links (p) ^ Send (p; m; l) in [(T U; r); (T L; r)] Datagram : bool = BoundedCommunication ^ OnlyOmissionFailures end Datagram The next step in the verification is the formulation of properties representing the protocol of <ref> [CASD95] </ref>. Finally, it can be proved that this protocol and the specification of the datagram service lead to the atomic broadcast properties specified before. <p> In future work we also intend to work on the formulation of general proof principles that can be used to prove the correctness of classes of protocols. For instance, for protocols that are based on information diffusion, a general diffusion induction principle <ref> [CASD95] </ref> could be formulated in PVS. Closely related to our aim is an interesting recent paper by Rushby [Rus97] where a general transformation from an untimed synchronous system into a time-triggered implementation of fault-tolerant algorithms is presented.
Reference: [Cri91] <author> F. Cristian. </author> <title> Reaching agreement on processor-group membership in synchronous distributed systems. </title> <journal> Distributed Computing, </journal> <volume> 4 </volume> <pages> 175-187, </pages> <year> 1991. </year>
Reference-contexts: Processors may fail and servers should contain consistent service state information to redistribute workload. E.g., servers must agree on the identity of all correctly functioning processors, which is achieved by group membership services [Cri96]. As an example of such a protocol we consider a processor-group membership protocol of Cristian <ref> [Cri91] </ref> which is intended to achieve agreement on the identity of all correctly functioning processors in a dynamic network that can shrink with failures and grow with joins. We verify a basic version of the protocol, reasoning in terms of local clocks. <p> We verify a basic version of the protocol, reasoning in terms of local clocks. For simplicity, we do not use the group identifiers mentioned in <ref> [Cri91] </ref> (assuming that the scheduling delay is zero). Further we assume fail-silent processors whereas in [Cri91] processors can suffer both crash and performance failures. The membership algorithm uses a synchronous atomic broadcast service to communicate between processors. <p> We verify a basic version of the protocol, reasoning in terms of local clocks. For simplicity, we do not use the group identifiers mentioned in <ref> [Cri91] </ref> (assuming that the scheduling delay is zero). Further we assume fail-silent processors whereas in [Cri91] processors can suffer both crash and performance failures. The membership algorithm uses a synchronous atomic broadcast service to communicate between processors. In [CASD95] it is shown that this broadcast service can indeed be implemented, using a lower-level point-to-point datagram service and internally synchronized local clocks. <p> Our steps for protocol verification are presented in section 3. It is applied to a simple version of the membership protocol in section 4. In section 5 we show how the performance of this protocol can be improved, following <ref> [Cri91] </ref> more closely. A few basic ingredients of the verification of the underlying atomic broadcast protocol are presented in section 6. <p> Following <ref> [Cri91] </ref> such trivial solutions are avoided by requiring that a joined processor is a member of its own view. <p> On the average, the proofs of lemmas and theorems required around twenty user interactions. 5 Improving the join delay To improve the join delay, <ref> [Cri91] </ref> introduces (p,new) messages to indicate the start of processor p. Property StartUp expresses that a processor broadcasts a new message when it starts. A started processor receives its own new message and then, as long as it is correct, periodically broadcast a present message.
Reference: [Cri96] <author> F. Cristian. </author> <title> On the semantics of group communication. </title> <booktitle> In Formal Techniques in Real-Time and Fault-Tolerant Systems, </booktitle> <pages> pages 1-21. </pages> <publisher> LNCS 1135, Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: To achieve reliability, a group of servers is running on distinct processors. Processors may fail and servers should contain consistent service state information to redistribute workload. E.g., servers must agree on the identity of all correctly functioning processors, which is achieved by group membership services <ref> [Cri96] </ref>. As an example of such a protocol we consider a processor-group membership protocol of Cristian [Cri91] which is intended to achieve agreement on the identity of all correctly functioning processors in a dynamic network that can shrink with failures and grow with joins.
Reference: [Dol95] <author> A. Dold. </author> <title> Representing, verifying and applying software development steps using the PVS system. </title> <booktitle> In Algebraic Methodology and Software Technology (AMAST'95), </booktitle> <pages> pages 431-444. </pages> <publisher> LNCS 936, Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Interesting in [AH97] is the formulation of a template for specifying Lynch-Vaandrager timed automata in PVS. Generic PVS theories to verify well-known algorithmic techniques such as divide-and-conquer have been formulated by Dold <ref> [Dol95] </ref>. Specific algorithms can be obtained by adding details to a general scheme. To make our method more accessible, the aim is to formulate a general template of theories that has to be completed by the verifier of a particular protocol.
Reference: [Hoo91] <author> J. Hooman. </author> <title> Specification and Compositional Verification of Real-Time Systems. </title> <publisher> LNCS 558, Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: The last step, where the conjunction of the specifications is taken, is justified by earlier work on compositional proof rules for concurrency (see, e.g., <ref> [Hoo91] </ref>). Note that for a fault-tolerant protocol the specifications also include the failure hypothesis, i.e., assumptions about the correctness of components and about the consequences of failures. 4 Membership Protocol Following the steps of the previous section, we verify the basic part of a membership protocol.
Reference: [Hoo94] <author> J. Hooman. </author> <title> Compositional verification of a distributed real-time arbitration protocol. </title> <booktitle> Real-Time Systems, </booktitle> <volume> 6(2) </volume> <pages> 173-205, </pages> <year> 1994. </year>
Reference-contexts: Here we present our ideas in this direction on the verification of distributed protocols. The approach originates from previous manual verifications (e.g., for a distributed real-time arbitration protocol <ref> [Hoo94] </ref>). Mechanical support is obtained by defining general theories in PVS to reason about timing and failures. To illustrate the approach, we consider a characteristic hierarchy of fault-tolerant protocols that should achieve a particular real-time computing service in spite of component failures.
Reference: [JP96] <author> B. Jonsson and J. Parrow, </author> <title> editors. Formal Techniques in Real-Time and Fault-Tolerant Systems. </title> <publisher> LNCS 1135. Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: One method to increase the confidence in the correctness is the application of formal methods to verify (part of) the protocols. A large number of methods have been devised to specify and verify distributed real-time systems (see, e.g., <ref> [JP96] </ref>), but it is less clear how to deal with failures. A formal treatment of fault-tolerant, however, is important, since informal reasoning about failures is often based on hidden, implicit, assumptions and it is usually not clear whether all failures and combinations of failures have been covered.
Reference: [LM94] <author> L. Lamport and S. Merz. </author> <title> Specifying and verifying fault-tolerant systems. </title> <booktitle> In Formal Techniques in Real-Time and Fault-Tolerant Systems, </booktitle> <pages> pages 41-76. </pages> <note> LNCS 863, </note> <year> 1994. </year>
Reference-contexts: Most of the literature mentioned above does not give a clear methodology that can easily be used by others. Sometimes the use of a formal framework structures the specification and the verification; see for instance the use of TLA for a treatment of the Byzantine generals problem <ref> [LM94] </ref>. Interesting in [AH97] is the formulation of a template for specifying Lynch-Vaandrager timed automata in PVS. Generic PVS theories to verify well-known algorithmic techniques such as divide-and-conquer have been formulated by Dold [Dol95]. Specific algorithms can be obtained by adding details to a general scheme.
Reference: [ORS92] <author> S. Owre, J. Rushby, and N. Shankar. PVS: </author> <title> A prototype verification system. </title> <booktitle> In 11th Conference on Automated Deduction, volume 607 of Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 748-752. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference: [ORSvH95] <author> S. Owre, J. Rushby, N. Shankar, and F. von Henke. </author> <title> Formal verification for fault-tolerant architectures: Prolegomena to the design of PVS. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(2) </volume> <pages> 107-125, </pages> <year> 1995. </year>
Reference-contexts: p 62 view (q) during [T 1 + DetectionDelay; T 2 ] MembSpec : bool = Agree ^ Recognition ^ Join ^ Detect end Membership To get more confidence in a specification, e.g. that it is not contradictory and indeed expresses the desired properties, it is advisable (see, for instance, <ref> [ORSvH95] </ref>) to try to prove some properties that ought to hold. Here we show, as an example, an alternative formulation of the join property. <p> Note that failures of processors and links have been treated in a uniform way. A good overview of related mechanical verifications can be found in <ref> [ORSvH95] </ref>, where mainly applications related to aircraft flight control and their influence on the design of PVS are described. Relevant is also an extensive treatment of clock synchronization protocols in PVS by Shankar [Sha92].
Reference: [Rus97] <author> J. Rushby. </author> <title> Systematic formal verification for fault-tolerant time-triggered algorithms. </title> <editor> In C. Meadows and W. Sanders, editors, </editor> <booktitle> Dependable Computing for Critical Applications 6, </booktitle> <pages> pages 191-210, </pages> <year> 1997. </year>
Reference-contexts: For instance, for protocols that are based on information diffusion, a general diffusion induction principle [CASD95] could be formulated in PVS. Closely related to our aim is an interesting recent paper by Rushby <ref> [Rus97] </ref> where a general transformation from an untimed synchronous system into a time-triggered implementation of fault-tolerant algorithms is presented.
Reference: [Sha92] <author> N. Shankar. </author> <title> Mechanical verification of a generalized proctocol for byzan-tine fault tolerant clock synchronization. </title> <booktitle> In Proceedings Formal Techniques in Real-Time and Fault-Tolerant Systems, </booktitle> <pages> pages 217-236. </pages> <publisher> LNCS 571, Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: A good overview of related mechanical verifications can be found in [ORSvH95], where mainly applications related to aircraft flight control and their influence on the design of PVS are described. Relevant is also an extensive treatment of clock synchronization protocols in PVS by Shankar <ref> [Sha92] </ref>. A classical example of a hierarchical verification is the "CLI short stack", which has been verified using Nqthm [BHMY89]. Most of the literature mentioned above does not give a clear methodology that can easily be used by others.
Reference: [ZH95] <author> P. Zhou and J. Hooman. </author> <title> Formal specification and compositional verification of an atomic broadcast protocol. </title> <booktitle> Real-Time Systems, </booktitle> <volume> 9(2) </volume> <pages> 119-145, </pages> <year> 1995. </year>
References-found: 15

