URL: http://www.cs.toronto.edu/~ftp/pub/reports/na/ned-94-msc.ps.Z
Refering-URL: http://www.cs.toronto.edu/NA/reports.html
Root-URL: http://www.cs.toronto.edu
Title: Precision Control and Exception Handling in Scientific Computing  
Author: by Nedialko Stoyanov Nedialkov 
Degree: A thesis submitted in conformity with the requirements for the degree of Master of Science  
Note: c Copyright Nedialko Stoyanov Nedialkov 1994  
Address: Toronto  
Affiliation: Department of Computer Science University of  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> American National Standards Institute, </author> <title> New York. IEEE standard for binary floating-point arithmetic, </title> <booktitle> 1985. ANSI/IEEE Std. </booktitle> <pages> 754-1985. </pages>
Reference-contexts: The floating-point format (2.1) is characterized by four integer parameters: b, m, E min and E max : The IEEE Standard <ref> [1] </ref> uses the terms single, double and extended to denote different floating-point formats and the corresponding precisions. <p> Since our purpose 1 Note that significand denotes the part of the floating-point format (2.1) which contains (m+1) significant digits, d 0 ; d 1 ; . . . d m . 3 is to use more precisions than specified by the IEEE Standard <ref> [1] </ref> and to provide a simple method of precision control, we denote the precisions by the powers of two: 1; 2; 4; 8; . . .. <p> Our implementation of variable-precision arithmetic has the following properties: 1. the base of the floating-point system is 2; 2. precision 1 is the same as normalized single precision in the IEEE Standard <ref> [1] </ref> and precision 2 is the same as normalized double; 3. the number of significant digits of precision 2flp is more than double the number of significant digits of precision p; 4. the exponent range of precision 2 fl p is significantly larger than double the exponent range of precision p. <p> In the implementation of SciLib, we have E max (2p) and E min (2p) approximately 4 times E max (p) and E min (p), except that when p = 1 the factor is 8 times, to conform to the IEEE Standard <ref> [1] </ref>. See Section A.2.1 for details. 2.2 Language Facilities for Precision Control An environment for scientific computing should have the capability to change precision during program execution. In our system, SciLib, this is accomplished by changing the precision value (power of two). <p> If they occur during computations, they underflow to zero; * the zero is unsigned; * the sets of representable numbers in precisions 1 and 2, excluding denormalized numbers and signed zeros, are the same as those in single and double of the IEEE Standard <ref> [1] </ref>; * the following relation between m (2p) and m (p), p &lt; 2048, holds m (2p) 2m (p) + t; t 6; so doubling the precision ensures more than double the fraction bits. The parameter t increases slightly as p increases. <p> In this section, we consider how real objects can be declared, initialized, and used in arithmetic, relational, and input and output operations. Simple examples are given as illustrations. In this implementation of SciLib, we assume that float and double data types agree with the IEEE Standard <ref> [1] </ref>, to simplify the conversion of float and double to real. The arithmetic operations are carried out in the specified precision. Its value is 1 by default, and it can be changed by the function precset (int), Section A.4, where the integer parameter is as specified in Table A.1. <p> The function raises an exception if n is not an integral value and returns N aN . The result for x = 1 or N aN is not specified in the IEEE Standard <ref> [1] </ref>.
Reference: [2] <author> George Forsythe and Cleve B. Moler. </author> <title> Computer Solution of Linear Algebraic Systems. </title> <publisher> Prentice-Hall, Inc., </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1967. </year>
Reference-contexts: The above algorithm discussed in <ref> [2] </ref> is implemented in the function improve shown in Fig. 4.2. <p> The number of iterations and the stopping criterion are determined as considered in <ref> [2] </ref>. The maximum number of iterations is taken to be 2 fl log 10 (1=tol) = 2 fl log 10 (tol), that is, twice the number of decimal digits specified by tol. <p> called such that the iterations in improve converge; 17 3. correct dec. digits | approximate number of correct decimal digits in x calcu- lated by solve computed in the first iteration of improve by the formula digits = log10 (normres=normx) if normres &gt; 0 and digits = log10 (tol) otherwise <ref> [2] </ref>. This is also approximately how many correct decimal digits are gained at each iteration; 4. iterations | the number of iterations performed in improve at the final precision. Note that if solve has produced the desired accuracy, one iteration is used to satisfy the stopping criterion.
Reference: [3] <author> George E. Forsythe, Michael A. Malcolm, and Cleve B. Moler. </author> <title> Computer Methods for Mathematical Computations. </title> <publisher> Prentice-Hall, Inc., </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1977. </year>
Reference-contexts: The parameters of improve are: A, the coefficient matrix; LU , the L-U decomposition of A obtained by partial pivoting; b, the right side of (4.1); pivot, the integer vector containing information about the row interchanges performed during the decomposition of A <ref> [3] </ref>; x, the vector containing the first solution as input and the corrected solution as output; tol, is a user-specified tolerance; and converged is an output parameter indicating if the tolerance is achieved, converged = 1, or if 12 void residual (vector & r, const vector & b, const matrix &A,
Reference: [4] <author> T. E. Hull, Thomas F. Fairgrieve, and Ping Tak Peter Tang. </author> <title> Implementing complex elementary functions using exception handling. </title> <journal> ACM Trans. Math. Softw., </journal> <volume> 20(2) </volume> <pages> 215-244, </pages> <year> 1994. </year>
Reference-contexts: Although sqrt (xflx+yfly) cannot overflow or underflow in precision 2p, there is still a possibility of overflow in the handle block when the result is assigned to answer; the calling function can detect the exception by using another enable-handle-end construct. The same expression is computed in Fig. 3.3 <ref> [4] </ref>, but the exceptions are handled without using precision control. The handler first tests if x or y is zero. Otherwise, if x and y differ greatly in magnitude, the variable that has the smaller absolute value can be neglected. <p> An implementation of the complex natural logarithm and detailed error analysis can be found in <ref> [4] </ref>. It uses the exception handling construct described in Chapter 3, but does not employ precision control. In this section, we present two functions to compute the complex natural logarithm: clog, Fig. 4.4, as given in [4] and clog2, Fig. 4.5, which is similar to clog, except that clog2 uses double <p> implementation of the complex natural logarithm and detailed error analysis can be found in <ref> [4] </ref>. It uses the exception handling construct described in Chapter 3, but does not employ precision control. In this section, we present two functions to compute the complex natural logarithm: clog, Fig. 4.4, as given in [4] and clog2, Fig. 4.5, which is similar to clog, except that clog2 uses double precision in critical parts to avoid exceptions and loss of accuracy. The functions compute the imaginary part in a similar way. <p> Our implementation, Fig. 4.5, differs from that of <ref> [4] </ref> mainly in how it computes the real part when both M and m are distinct from zero. <p> The technique suggested in <ref> [4] </ref> for handling these exceptions is similar to that used in the hypot2 function, Fig. 3.3: in clog, we scale the arguments, compute the logarithm and then unscale the result. <p> In both clog and clog2, we compute the expression M 2 +m 2 1 = (M 1)(M +1)+m 2 . In clog, we use the same precision, so there is a possibility of serious cancellation, and the error analysis is complicated <ref> [4] </ref>. In clog2, this expression is safely evaluated in double precision, and the result is assigned to the variable tmp which is in the current precision.
Reference: [5] <author> S.M. Rump. </author> <title> Algorithms for verified inclusions-theory and practice. In R.E. </title> <editor> Moore, editor, </editor> <booktitle> Reliability in Computing, </booktitle> <pages> pages 109-126. </pages> <publisher> Academic Press, </publisher> <address> San Diego, Calif, </address> <year> 1988. </year>
Reference-contexts: The reverse occurs on output: the floating-point number is converted to double, and then the double value is output as a decimal string. Example. Consider the evaluation of the following arithmetic expression <ref> [5] </ref> f = 333:75b 6 + a 2 (11a 2 b 2 b 6 121b 4 2) + 5:5b 8 + 2b for a = 77617:0 and b = 33096:0. The function rump example, Fig. A.2, computes (A.5) in variable precision.
Reference: [6] <author> J.H. Wilkinson. </author> <title> Rounding Errors in Algebraic Processes. </title> <publisher> Prentice-Hall, Inc., </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1963. </year> <month> 51 </month>
Reference-contexts: Let x 1 be an approximate solution of (4.1) obtained in precision p. If the matrix A is not too ill-conditioned, the round-off error in the computed solution can be reduced by iterative improvement <ref> [6] </ref>: For m = 1; 2 . . . 1. Compute the residual r m = b Ax m . 2. Solve Ay m = r m 3. x m+1 := x m + y m . The most critical step is (1).
References-found: 6

