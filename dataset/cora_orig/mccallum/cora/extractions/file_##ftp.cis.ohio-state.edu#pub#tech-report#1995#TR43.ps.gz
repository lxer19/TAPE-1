URL: file://ftp.cis.ohio-state.edu/pub/tech-report/1995/TR43.ps.gz
Refering-URL: ftp://ftp.cis.ohio-state.edu/pub/tech-report/TRList.html
Root-URL: 
Email: email: fmanivann, singhalg@cis.ohio-state.edu  
Title: A Quasi-synchronous Algorithm for Checkpointing in Distributed Systems  
Author: D. Manivannan and M. Singhal 
Keyword: distributed checkpointing, global snapshot collection, failure recovery, fault tolerance.  
Address: Columbus, OH 43210.  
Affiliation: Department of Computer and Information Science, The Ohio State University,  
Abstract: In this paper, we propose a quasi-synchronous algorithm for checkpointing in distributed systems. This algorithm preserves process autonomy by allowing them to take checkpoints asynchronously and uses communication-induced checkpoint coordination for the progression of the recovery line which helps in bounding rollback propagation during a recovery. Thus, it has the easeness and low overhead of asynchronous checkpointing and the recovery time advantages of synchronous checkpointing. There is no extra message overhead involved during checkpointing and the additional checkpointing overhead is nominal. The algorithm ensures the existence of a recovery line consistent with the latest checkpoint of any process all the time. This property of the algorithm is a highly desirable feature for rollback recovery because a failed process needs only rollback to its latest checkpoint and request other processes to rollback to a consistent checkpoint, thus avoiding domino effect completely. It also helps in garbage collection because after a process has established a recovery line consistent with its latest checkpoint, all the processes can delete the checkpoints that precede the recovery line. Multiple processes can establish recovery lines consistent with their latest checkpoints simultaneously without intruding other processes. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Acharya, B. R. Badrinath, and T. Imielinski. </author> <title> "Checkpointing Distributed Applications on Mobile Computing Systems". </title> <type> Technical report, </type> <institution> Department of Computer Science, Rutgers University, </institution> <year> 1994. </year>
Reference-contexts: This requires the extra overhead of control messages for each checkpoint taken, whereas the MQSA does not have any additional message overhead. In Acharya et al.'s <ref> [1] </ref> asynchronous checkpointing algorithm for mobile computing systems, a process takes a checkpoint whenever a message reception is preceded by a message transmission.
Reference: [2] <author> B. Bhargava and P. Leu. </author> <title> "Concurrent Robust Checkpointing and Recovery in Distributed Systems". </title> <booktitle> In Proc. of 4 th IEEE Int. Conf. Data Eng., </booktitle> <pages> pages 154-163, </pages> <month> Febru-ary </month> <year> 1988. </year>
Reference-contexts: The algorithms proposed in <ref> [12, 2] </ref> have a two-phase structure. This causes processes to suspend the normal computation for making checkpoint decisions which greatly increases the overhead during normal computation. The MQSA does not cause any such overhead and avoids domino effect completely during recovery.
Reference: [3] <author> B. Bhargava and S. R. Lian. </author> <title> "Independent Checkpointing and Concurrent Rollback for Recovery in Distributed Systems-An Optimistic Approach.". </title> <booktitle> In Proc. 7 th IEEE Symp. Reliable Distributed Syst., </booktitle> <pages> pages 3-12, </pages> <year> 1988. </year>
Reference-contexts: In the literature, several checkpointing schemes have been proposed for distributed systems. They can be broadly classified in to two categories asynchronous and synchronous. In asynchronous checkpointing <ref> [3, 13, 23] </ref>, processes take checkpoints periodically without any coordination with each other. To recover from a failure, processes communicate with each other to restore the system to a consistent set of local states.
Reference: [4] <author> D. Briatico, Ciuffoletti, and L. Simoncini. </author> <title> "A Distributed Domino-Effect free Recovery Algorithm". </title> <booktitle> In Proc. of IEEE 4 th Symposium on Reliability in Distributed Software and Database Systems, </booktitle> <pages> pages 207-215. </pages> <publisher> IEEE, </publisher> <year> 1984. </year>
Reference-contexts: In addition, their algorithm does not ensure the existence of a recovery line consistent with the latest checkpoint of a process; only checkpoints with a particular sequence number form a global checkpoint. In many of the existing checkpointing algorithms in the literature (for example, <ref> [4, 5, 22 6, 22] </ref>), a set S of local checkpoints where S = fC k;m k j1 k N and C k;m k is a checkpoint of process P k g is considered a global checkpoint if and only if 8 i; j; 1 i; j N : m i <p> Thus, only the local checkpoints with the same sequence number form a global checkpoint. This requirement results in high message overhead (as in [5, 6]) and/or high checkpointing overhead (as in <ref> [4, 22] </ref>). Our approach does not require the sequence numbers of all the local checkpoints in a global checkpoint to be equal to each other; any set of local checkpoints satisfying the hypothesis of Corollary 2 forms a global checkpoint.
Reference: [5] <author> F. Cristian and F. Jahanian. </author> <title> "A Timestamp-based Protocol for Long-lived Distributed Computations". </title> <booktitle> In Proc. 10 th Symp. Reliable Distributed Systems, </booktitle> <pages> pages 12-20, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: In addition, their algorithm does not ensure the existence of a recovery line consistent with the latest checkpoint of a process; only checkpoints with a particular sequence number form a global checkpoint. In many of the existing checkpointing algorithms in the literature (for example, <ref> [4, 5, 22 6, 22] </ref>), a set S of local checkpoints where S = fC k;m k j1 k N and C k;m k is a checkpoint of process P k g is considered a global checkpoint if and only if 8 i; j; 1 i; j N : m i <p> Thus, only the local checkpoints with the same sequence number form a global checkpoint. This requirement results in high message overhead (as in <ref> [5, 6] </ref>) and/or high checkpointing overhead (as in [4, 22]). Our approach does not require the sequence numbers of all the local checkpoints in a global checkpoint to be equal to each other; any set of local checkpoints satisfying the hypothesis of Corollary 2 forms a global checkpoint.
Reference: [6] <author> Luis Moura e Silva and Jouao Gabriel Silva. </author> <title> "Global Checkpointing for Distributed Programs". </title> <booktitle> In Proc. Symp. Reliable Distributed Systems, </booktitle> <pages> pages 155-162, </pages> <year> 1992. </year>
Reference-contexts: In synchronous checkpointing schemes, domino-free recovery is achieved by sacrificing process autonomy and incurring extra message overhead during checkpointing. In this approach, processes synchronize their checkpointing activities so that a globally consistent set of checkpoints is always maintained in the system <ref> [6, 12, 15] </ref>. The storage requirement for the checkpoints is minimum because each process keeps only one checkpoint in the stable storage at any given time. Process execution may have to be suspended during the checkpointing coordination as in [10, 12], resulting in performance degradation. <p> In our algorithm, several processes can simultaneously initiate and collect global snapshot successfully without restricting any other process from collecting global snapshot. The synchronous checkpointing algorithm 21 of Silva and Silva <ref> [6] </ref> requires a fixed process to take a checkpoint and send request messages to all the other processes for taking a checkpoint consistent with its latest checkpoint; it also requires the sequence number of the latest checkpoint taken to be piggybacked with each computation message. <p> Thus, only the local checkpoints with the same sequence number form a global checkpoint. This requirement results in high message overhead (as in <ref> [5, 6] </ref>) and/or high checkpointing overhead (as in [4, 22]). Our approach does not require the sequence numbers of all the local checkpoints in a global checkpoint to be equal to each other; any set of local checkpoints satisfying the hypothesis of Corollary 2 forms a global checkpoint.
Reference: [7] <author> D. B. Johnson and W. Zwaenepoel. </author> <title> "Recovery in Distributed Systems Using Optimistic Message Logging and Checkpointing". </title> <booktitle> In Proc. of 17 th IEEE Symp. Fault-Tolerant Comput., </booktitle> <pages> pages 14-19, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: To reduce domino effect, Kim et al. [11] and Venkatesh et al. [21] use the dependency tracking and insert checkpoints before processing a new message that introduces dependency. Message logging <ref> [7, 9, 18, 20, 25] </ref> and message reordering [24] have been suggested in the literature to cope with the domino effect. Asynchronous checkpointing requires multiple checkpoints to be stored at each process. Thus, storage requirement may be large.
Reference: [8] <author> T. T-Y. Juang and S. Venkatesan. </author> <title> "Efficient Algorithm for Crash Recovery in Distributed Systems". </title> <booktitle> In 10 th Conf. on Foundations on Software Technology and Theoretical Computer Science, </booktitle> <pages> pages 349-361, </pages> <year> 1990. </year>
Reference: [9] <author> T. T-Y. Juang and S. Venkatesan. </author> <title> "Crash Recovery with Little Overhead". </title> <booktitle> In Proc. of 11 th International Conf. on Distributed Comput. Syst., </booktitle> <pages> pages 454-461, </pages> <year> 1991. </year> <month> 24 </month>
Reference-contexts: To reduce domino effect, Kim et al. [11] and Venkatesh et al. [21] use the dependency tracking and insert checkpoints before processing a new message that introduces dependency. Message logging <ref> [7, 9, 18, 20, 25] </ref> and message reordering [24] have been suggested in the literature to cope with the domino effect. Asynchronous checkpointing requires multiple checkpoints to be stored at each process. Thus, storage requirement may be large.
Reference: [10] <author> Junguk L. Kim and Taesoon Park. </author> <title> "An Efficient Protocol for Checkpointing recovery in Distributed Systems". </title> <journal> IEEE Trans. on Parallel and Distributed Systems, </journal> <volume> 4(8) </volume> <pages> 955-960, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: Checkpointing is a technique used to store the state of a process in the stable storage so that the process can resume to its normal computation from that state on recovery from a failure, instead of starting from the initial state <ref> [10] </ref>. Such checkpointing-recovery techniques for a single processor system have been extensively studied in the literature [14]. In a distributed system, the states of processes depend on one another due to inter-process communication. <p> The storage requirement for the checkpoints is minimum because each process keeps only one checkpoint in the stable storage at any given time. Process execution may have to be suspended during the checkpointing coordination as in <ref> [10, 12] </ref>, resulting in performance degradation. Paper Objectives The main objective of the paper is to present a checkpointing algorithm which ensures the existence of a recovery line consistent with the latest checkpoint of any process all the time.
Reference: [11] <author> K. H Kim. </author> <title> "A Scheme for Coordinated Execution of Independently Designed Recoverable Distributed Processes". </title> <booktitle> In Proc. of 16 th IEEE Symp. Fault-Tolerant Comput., </booktitle> <pages> pages 130-135, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: This approach allows maximum process autonomy for taking checkpoints and has low checkpointing overhead. However, this approach may suffer from the domino effect, in which the processes rollback recursively while determining a consistent set of checkpoints. To reduce domino effect, Kim et al. <ref> [11] </ref> and Venkatesh et al. [21] use the dependency tracking and insert checkpoints before processing a new message that introduces dependency. Message logging [7, 9, 18, 20, 25] and message reordering [24] have been suggested in the literature to cope with the domino effect.
Reference: [12] <author> R. Koo and S. Toueg. </author> <title> "Checkpointing and Roll-back Recovery for Distributed Systems". </title> <journal> IEEE Trans. on Software Eng., </journal> <volume> SE-13(1):23-31, </volume> <month> January </month> <year> 1987. </year>
Reference-contexts: In synchronous checkpointing schemes, domino-free recovery is achieved by sacrificing process autonomy and incurring extra message overhead during checkpointing. In this approach, processes synchronize their checkpointing activities so that a globally consistent set of checkpoints is always maintained in the system <ref> [6, 12, 15] </ref>. The storage requirement for the checkpoints is minimum because each process keeps only one checkpoint in the stable storage at any given time. Process execution may have to be suspended during the checkpointing coordination as in [10, 12], resulting in performance degradation. <p> The storage requirement for the checkpoints is minimum because each process keeps only one checkpoint in the stable storage at any given time. Process execution may have to be suspended during the checkpointing coordination as in <ref> [10, 12] </ref>, resulting in performance degradation. Paper Objectives The main objective of the paper is to present a checkpointing algorithm which ensures the existence of a recovery line consistent with the latest checkpoint of any process all the time. <p> The algorithms proposed in <ref> [12, 2] </ref> have a two-phase structure. This causes processes to suspend the normal computation for making checkpoint decisions which greatly increases the overhead during normal computation. The MQSA does not cause any such overhead and avoids domino effect completely during recovery. <p> The algorithms proposed in [12, 2] have a two-phase structure. This causes processes to suspend the normal computation for making checkpoint decisions which greatly increases the overhead during normal computation. The MQSA does not cause any such overhead and avoids domino effect completely during recovery. In <ref> [12] </ref>, if multiple global checkpoint collections are initiated concurrently, all of them may have to be aborted in some situations. In our global checkpoint collection algorithm, multiple processes can concurrently initiate global checkpoint collection and all of them will succeed in collecting the global checkpoint without suspending the underlying computation.
Reference: [13] <author> K.Tsuruoka, A. Kaneko, and Y. Nishihara. </author> <title> "Dynamic Recovery Schemes for Distributed Process". </title> <booktitle> In Proceedings of IEEE 2nd Symp. on Reliability in Distributed Software and Database Systems, </booktitle> <pages> pages 124-130, </pages> <year> 1981. </year>
Reference-contexts: In the literature, several checkpointing schemes have been proposed for distributed systems. They can be broadly classified in to two categories asynchronous and synchronous. In asynchronous checkpointing <ref> [3, 13, 23] </ref>, processes take checkpoints periodically without any coordination with each other. To recover from a failure, processes communicate with each other to restore the system to a consistent set of local states.
Reference: [14] <author> P. L'Ecuyer and J. Malenfant. </author> <title> "Computing Optimal Checkpointing Strategies for Rollback and Recovery Systems". </title> <journal> IEEE Trans. Comput., </journal> <volume> 37(4) </volume> <pages> 491-496, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: Such checkpointing-recovery techniques for a single processor system have been extensively studied in the literature <ref> [14] </ref>. In a distributed system, the states of processes depend on one another due to inter-process communication. So, when a process P rolls back after a failure, the processes that have states directly or transitively dependent on P 's state are forced to rollback.
Reference: [15] <author> K. Li, J. F. Naughton, and J. S. Plank. </author> <title> "Checkpointing Multicomputer Applications". </title> <booktitle> In Proc. 10 th Symp. on Reliable Distributed Systems, </booktitle> <pages> pages 2-11, </pages> <year> 1991. </year>
Reference-contexts: In synchronous checkpointing schemes, domino-free recovery is achieved by sacrificing process autonomy and incurring extra message overhead during checkpointing. In this approach, processes synchronize their checkpointing activities so that a globally consistent set of checkpoints is always maintained in the system <ref> [6, 12, 15] </ref>. The storage requirement for the checkpoints is minimum because each process keeps only one checkpoint in the stable storage at any given time. Process execution may have to be suspended during the checkpointing coordination as in [10, 12], resulting in performance degradation.
Reference: [16] <author> S. L. Peterson and Phil Kearns. </author> <title> "Rollback Based on Vector Time". </title> <booktitle> In Proc. 12 th Symp. on Reliable Distributed Systems, </booktitle> <pages> pages 68-77, </pages> <year> 1993. </year>
Reference-contexts: The use of checkpoints on a stable storage and rollback-recovery protocols are well established techniques for dealing with process failures in a distributed system as well. When a failure occurs, a rollback protocol uses the checkpoints and message logs to restore the system to a consistent global state <ref> [16] </ref>. By a consistent global state we mean that if the receipt operation of a message has been recorded in the global state, then the send operation of that message must also have been recorded. In the literature, several checkpointing schemes have been proposed for distributed systems.
Reference: [17] <author> S. Pilarski and T. Kameda. </author> <title> "Checkpointing for Distributed Databases: Starting from the Basics. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 3(5) </volume> <pages> 602-610, </pages> <month> September </month> <year> 1992. </year>
Reference: [18] <author> A. P. Sistla and J. L. Welch. </author> <title> "Efficient Distributed Recovery Using Message Logging". </title> <booktitle> In Proc. of 8 th ACM Symp. Principles Distributed Comput., </booktitle> <pages> pages 223-238, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: To reduce domino effect, Kim et al. [11] and Venkatesh et al. [21] use the dependency tracking and insert checkpoints before processing a new message that introduces dependency. Message logging <ref> [7, 9, 18, 20, 25] </ref> and message reordering [24] have been suggested in the literature to cope with the domino effect. Asynchronous checkpointing requires multiple checkpoints to be stored at each process. Thus, storage requirement may be large.
Reference: [19] <author> M. Spezialetti and J.P. Kearns. </author> <title> "Efficient Distributed Snapshots". </title> <booktitle> In Proceedings of the 6 th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 382-388, </pages> <year> 1986. </year>
Reference-contexts: In our global checkpoint collection algorithm, multiple processes can concurrently initiate global checkpoint collection and all of them will succeed in collecting the global checkpoint without suspending the underlying computation. In <ref> [19] </ref>, concurrent initiations of global checkpoint collections are handled by restricting the propagation of snapshot requests in the system. In our algorithm, several processes can simultaneously initiate and collect global snapshot successfully without restricting any other process from collecting global snapshot.
Reference: [20] <author> R. E. Strom and S. Yemini. </author> <title> "Optimistic Recovery in Distributed Systems". </title> <journal> ACM Trans. Comput. Syst., </journal> <volume> 3(3) </volume> <pages> 204-226, </pages> <month> August </month> <year> 1985. </year>
Reference-contexts: To reduce domino effect, Kim et al. [11] and Venkatesh et al. [21] use the dependency tracking and insert checkpoints before processing a new message that introduces dependency. Message logging <ref> [7, 9, 18, 20, 25] </ref> and message reordering [24] have been suggested in the literature to cope with the domino effect. Asynchronous checkpointing requires multiple checkpoints to be stored at each process. Thus, storage requirement may be large.
Reference: [21] <author> K. Venkatesh and T. Radhakrishnan. </author> <title> "Optimal Checkpointing and Local Encoding for Domino-free Rollback Recovery". </title> <journal> Information Processing Letters, </journal> <volume> 25 </volume> <pages> 295-303, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: This approach allows maximum process autonomy for taking checkpoints and has low checkpointing overhead. However, this approach may suffer from the domino effect, in which the processes rollback recursively while determining a consistent set of checkpoints. To reduce domino effect, Kim et al. [11] and Venkatesh et al. <ref> [21] </ref> use the dependency tracking and insert checkpoints before processing a new message that introduces dependency. Message logging [7, 9, 18, 20, 25] and message reordering [24] have been suggested in the literature to cope with the domino effect. Asynchronous checkpointing requires multiple checkpoints to be stored at each process.
Reference: [22] <author> Y. M. Wang and W. K. Fuchs. </author> <title> "Lazy checkpoint Coordination for Bounding Rollback Propagation". </title> <type> Technical Report CRHC-92-26, </type> <institution> Coordinated Science Laboratory, University of Illinois at Urbana-Champaign, </institution> <year> 1992. </year> <month> 25 </month>
Reference-contexts: The checkpointing overhead of the MQSA however does not depend much on the communication pattern; rather it depends on basic checkpointing pattern of the processes. Wang et al. <ref> [22] </ref> proposed lazy checkpoint coordination for bounding rollback propagation. Like our approach, their technique requires the checkpoint number being piggybacked on the computation messages so that the receiving processes can take an extra checkpoint when required. <p> In addition, their algorithm does not ensure the existence of a recovery line consistent with the latest checkpoint of a process; only checkpoints with a particular sequence number form a global checkpoint. In many of the existing checkpointing algorithms in the literature (for example, <ref> [4, 5, 22 6, 22] </ref>), a set S of local checkpoints where S = fC k;m k j1 k N and C k;m k is a checkpoint of process P k g is considered a global checkpoint if and only if 8 i; j; 1 i; j N : m i <p> Thus, only the local checkpoints with the same sequence number form a global checkpoint. This requirement results in high message overhead (as in [5, 6]) and/or high checkpointing overhead (as in <ref> [4, 22] </ref>). Our approach does not require the sequence numbers of all the local checkpoints in a global checkpoint to be equal to each other; any set of local checkpoints satisfying the hypothesis of Corollary 2 forms a global checkpoint.
Reference: [23] <author> Y. M. Wang and W. K. Fuchs. </author> <title> "Optimistic Message Logging for Independent Check--pointing in Message Passing Systems". </title> <booktitle> In Proc. Symp. on Reliable Distributed Systems, </booktitle> <pages> pages 147-154, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: In the literature, several checkpointing schemes have been proposed for distributed systems. They can be broadly classified in to two categories asynchronous and synchronous. In asynchronous checkpointing <ref> [3, 13, 23] </ref>, processes take checkpoints periodically without any coordination with each other. To recover from a failure, processes communicate with each other to restore the system to a consistent set of local states.
Reference: [24] <author> Y. M. Wang and W. K. Fuchs. </author> <title> "Scheduling Message Processing for Reducing Rollback Propagation". </title> <booktitle> In Proc. IEEE Fault-Tolerant Computing Symposium, </booktitle> <pages> pages 204-211, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: To reduce domino effect, Kim et al. [11] and Venkatesh et al. [21] use the dependency tracking and insert checkpoints before processing a new message that introduces dependency. Message logging [7, 9, 18, 20, 25] and message reordering <ref> [24] </ref> have been suggested in the literature to cope with the domino effect. Asynchronous checkpointing requires multiple checkpoints to be stored at each process. Thus, storage requirement may be large.
Reference: [25] <author> Y. M. Wang, Y. Huang, and W. K. Fuchs. </author> <title> "Progressive Retry for Software Recovery in Distributed Systems". </title> <booktitle> In Proc. IEEE Fault-Tolerant Computing Symposium, </booktitle> <pages> pages 138-144, </pages> <month> June </month> <year> 1993. </year> <month> 26 </month>
Reference-contexts: To reduce domino effect, Kim et al. [11] and Venkatesh et al. [21] use the dependency tracking and insert checkpoints before processing a new message that introduces dependency. Message logging <ref> [7, 9, 18, 20, 25] </ref> and message reordering [24] have been suggested in the literature to cope with the domino effect. Asynchronous checkpointing requires multiple checkpoints to be stored at each process. Thus, storage requirement may be large.
References-found: 25

