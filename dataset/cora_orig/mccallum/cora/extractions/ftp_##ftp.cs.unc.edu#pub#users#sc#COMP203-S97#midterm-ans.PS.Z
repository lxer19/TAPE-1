URL: ftp://ftp.cs.unc.edu/pub/users/sc/COMP203-S97/midterm-ans.PS.Z
Refering-URL: http://www.cs.unc.edu/~sc/teaching/COMP203-S1997/exams.html
Root-URL: http://www.cs.unc.edu
Title: COMP 203: Parallel and Distributed Computing Solutions to Midterm Exam points] A page server and
Author: Siddhartha Chatterjee 
Note: if is blue and has no blue ancestors otherwise Here is the complete code. The work complexity of this algorithm is fi(n) and the step complexity is fi(lg n). 2. [30  
Date: Spring 1997  
Abstract: 1. [30 points] You are given an n-node binary tree in which nodes are colored either blue or white. The tree is represented in Euler tour format using three vectors Left, Right, and Color. Design an efficient EREW PRAM algorithm to form a list consisting of the blue nodes that do not have a blue ancestor. Analyze the step and work complexities of your algorithm. Solution: First, mark nodes with blue ancestors, using an Euler tour technique. This problem is essentially the problem of determining the depth of the nodes, with the slight variation that we want to count blue ancestors rather than all ancestors. We achieve this by permuting 1 and 1 for blue nodes and 0 for white nodes. Now, given this marking, it is trivial to identify blue nodes with no blue ancestors and link them. Doing this with a pack operation is easy, so I will illustrate another technique in which we create a set of pointers to link the appropriate nodes. (The advantage of doing is this that we do not have to move any of the node records, which may have other data components.) We do this by defining an appropriate associative operator and performing an exclusive parallel-suffix operation. The objects on which the operator operates are pointers. Each tree node starts out with a pointer to the next node in the Euler tour ordering. The operator we will use is defined as follows. It is easy to verify that is associative. Now run a parallel suffix computation, so that each element ends up with the of all the elements after it in the original ordering. Since that product is a pointer to the next blue element, the resulting pointers form the desired list. The head of the list is either the first element (if it is blue and has no blue ancestors) or the element it points to. 1 integer A[1::2n] 2 forall i 2 1 : n do 3 A[Left [i]] if Color[i] = blue then 1 else 0 endif 4 A[Right[i]] if Color[i] = blue then 1 else 0 endif 5 enddo 6 B SCAN(A; +) 7 forall i 2 1 : n do 8 D[i] Color[i] = blue and B[Left [i]] = 0 9 enddo 10 forall i 2 1 : n do 11 P [i] if i &lt; n then i + 1 else n endif 12 enddo 13 return REVERSESCAN(P; ) x y =
Abstract-found: 1
Intro-found: 0
References-found: 0

