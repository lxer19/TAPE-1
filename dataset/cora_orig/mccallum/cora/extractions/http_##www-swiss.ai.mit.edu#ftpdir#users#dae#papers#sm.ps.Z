URL: http://www-swiss.ai.mit.edu/ftpdir/users/dae/papers/sm.ps.Z
Refering-URL: http://www-swiss.ai.mit.edu/ftpdir/users/dae/home.html
Root-URL: 
Email: espinosa@cs.columbia.edu  
Title: Building Interpreters by Transforming Stratified Monads  
Author: David Espinosa 
Keyword: Topics: interpreters, functional programming  
Note: Word count: 4200 (8 pages) without examples, figures, and appendices  
Date: June 1994  
Address: New York, NY 10027  
Affiliation: Columbia University Department of Computer Science  
Abstract: This paper shows how to construct programming language interpreters from a set of mix-and-match parts. By composing a sequence of semantic modules, we form an abstract data type (ADT) of computations, which is then used to build an ADT of language constructs. We represent the ADT of computations by a stratified monad and the modules by stratified monad transformers. These results extend previous work on monads and have applications to language extensibility, interpreter construction, and the study of semantic models.
Abstract-found: 1
Intro-found: 1
Reference: [AKHS88] <author> Hal Abelson, Jacob Katzenelson, Matthew Halfant, and Gerald Jay Sussman. </author> <title> The Lisp Experience. </title> <booktitle> Annual Review of Computer Science, </booktitle> <volume> 3 </volume> <pages> 167-195, </pages> <year> 1988. </year>
Reference-contexts: 1 Introduction We describe Semantic Lego, an interpreter construction toolkit capable of building interpreters for a wide variety of languages from a set of reusable parts. By representing a modular theory of language design in computational terms, we raise the level of dialogue between the designer and the computer <ref> [AKHS88] </ref>. Language designers can use the toolkit to prototype new languages, to experiment with new semantics, and to build interpreters for use in other systems. To see the lack of modularity in interpreters, consider adding stores to a language without them.
Reference: [Car89] <author> Luca Cardelli. </author> <title> Typeful programming. </title> <type> Technical Report 45, </type> <institution> DEC Systems Research Center, </institution> <address> Palo Alto, CA, </address> <month> May </month> <year> 1989. </year>
Reference-contexts: The toolkit represents types as values but does not take this approach far enough. Because we need to treat monads and monad transformers as values, ML and Haskell's type systems are not sufficient. We require higher-order types as values, and languages with these features <ref> [Car89] </ref> are not in common use.
Reference: [CR91] <author> Will Clinger and Jonathan Rees. </author> <title> Revised 4 Report on Scheme. Lisp Pointers, </title> <type> 4(3), </type> <year> 1991. </year>
Reference-contexts: Section 2 presents a series of examples, section 3 discusses how the toolkit works, and section 4 compares it to previous work. We assume an elementary understanding of denotational semantics and functional programming; for further background, see [Wad92]. We present all examples and code fragments in Scheme <ref> [CR91] </ref>. 2 Examples We discuss languages as abstract data types, show the toolkit in action, and use it to explore the interaction between nondeterminism and continuations. 2.1 Languages as ADTs To see what the toolkit does, we need to specify what "generating an interpreter" means.
Reference: [DJL88] <author> Pierre Deransart, Martin Jourdan, and Bernard Lorho. </author> <title> Attribute Grammars, </title> <booktitle> volume 323 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1988. </year>
Reference-contexts: To see the lack of modularity in interpreters, consider adding stores to a language without them. Even though most language constructs leave the store unchanged, it is necessary to rewrite the interpreter completely. Tools such as attribute grammars <ref> [DJL88] </ref> and abstract semantic algebras [Mos92] were developed to solve this problem but cannot handle complex semantics. Using the toolkit, we simply add the stores module to the language specification. To achieve these results, we reformulate Moggi's theory of modular denotational semantics [Mog89a, Mog91a].
Reference: [Esp94] <author> David Espinosa. </author> <title> Semantic Lego. </title> <note> FTP from martigny.ai.mit.edu : pub/dae, January 1994. 26 </note>
Reference-contexts: Without access to intermediate levels, we cannot define many language constructs. A possible solution, due to Moggi [Mog89a], is to interleave the definition of operators with the application of transformers. We arrange for transformers to transform operators as well as monads <ref> [Esp94] </ref>. However, it is still difficult (or impossible) to define constructs that interact with multiple levels. For example, if we define %call/cc in the continuations module, it is difficult for it to interact with the environments module (to prepare arguments to procedures). <p> This choice exposes the treatment of types in the semantic equations and abstracts from the existing Scheme types; however, it would be interesting to try various typed approaches. Steele [Ste94] tries to extend the domain of values using monads, and I follow him in <ref> [Esp94] </ref>. However, as he points out, using the exceptions monad to build sums yields behavior such as (compute (%+ (%num 3) (%true))) ) true which is not at all what we want. <p> This crucial ability was missing from his earlier papers; however, it is difficult to understand Moggi's presentation, and few researchers realized that he had made significant progress toward modularizing denotational semantics. After reexplaining and implementing Moggi's methods in <ref> [Esp94] </ref>, I saw that they do not provide sufficient modularity to handle constructs involving multiple semantic levels, such as %call/cc or even %+ (because it raises errors). Stratified monads solve this problem, and, by separating semantic extensions from the language constructs they enable, increase language design flexibility.
Reference: [Fil94] <author> Andrzej Filinski. </author> <title> Representing monads. </title> <booktitle> In Proceedings of the 21st Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> Portland, OR, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: The results are appended and returned. In the example, the list continuation is replaced by a continuation that adds one, hence the result 51. This semantics actually results from using Scheme's call/cc with the amb derived from Filinski's monadic reflection operators <ref> [Fil94] </ref> over the list monad. Monadic reflection is not limited to this semantics; to obtain others, we can reflect over the monad TA = (A -&gt; List A) -&gt; List A and define our own call/cc. In the second semantics (Figure 6), we replace continuations with continuations2.
Reference: [GTWW77] <author> J. A. Goguen, J. W. Thatcher, E. G. Wagner, and J. B. Wright. </author> <title> Initial algebra semantics and continuous algebras. </title> <journal> Journal of the ACM, </journal> <volume> 24 </volume> <pages> 68-95, </pages> <year> 1977. </year>
Reference-contexts: We can represent these functions directly as 2 %var : Name -&gt; Den %lam : Name * Den -&gt; Den %app : Den * Den -&gt; Den These operations form an abstract data type (ADT) of denotations <ref> [GTWW77] </ref>. We trivially define eval as (eval (var v)) = (%var v) (eval (lam v body)) = (%lam v (eval b)) (eval (app f a)) = (%app (eval f) (eval a)) ... <p> Along with the implementations of ADT operators, it is easy to generate an eval function, an ADT of expressions, and a user interface, but there is no a priori need. In algebraic terms, initiality of syntax yields a unique homomorphism to semantics <ref> [GTWW77] </ref>. In the rest of the paper, we usually refer to the ADT of denotations as an ADT of computations.
Reference: [JD93] <author> Mark P. Jones and Luc Duponcheel. </author> <title> Composing monads. </title> <type> Technical Report YALEU / DCS / RR-1004, </type> <institution> Yale University, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: We leave for future work the investigation of principles for reasoning about modularly constructed languages. 3.2 Monad transformers Although type constructors compose, monads do not (at least not without help | see <ref> [JD93] </ref>). To see why (informally), we compose the type constructors of two different environment monads. Figure 9 shows the unique monad that this composition can support, but its bind operator cannot be formed by composition from the two environment mon-ads. In fact, Jones and Duponcheel [JD93] prove rigorously that monads cannot <p> not without help | see <ref> [JD93] </ref>). To see why (informally), we compose the type constructors of two different environment monads. Figure 9 shows the unique monad that this composition can support, but its bind operator cannot be formed by composition from the two environment mon-ads. In fact, Jones and Duponcheel [JD93] prove rigorously that monads cannot in general compose. However, monads do transform. Figure 10 shows the environment monad transformer, which takes a monad T into a monad FT. Applying two (different) environment monad transformers to the identity monad indeed yields the double environment monad. <p> Steele's main contribution is a complete implementation of a modular semantics, which was really inspiring. Mark Jones and Luc Duponcheel <ref> [JD93] </ref> address the problem of composing monads. They find that if one of several auxiliary maps is defined relating the structures of two monads, they can be composed, in an order depending which map is used.
Reference: [KW92] <author> David King and Philip Wadler. </author> <title> Combining monads. </title> <booktitle> In Proceedings of the Fifth Annual Glasgow Workshop on Functional Programming, </booktitle> <address> Ayr, Scotland, 1992. </address> <publisher> Springer Workshops in Computer Science. </publisher>
Reference-contexts: Philip Wadler [Wad92] popularized Moggi's ideas by presenting monadic interpreters written in Haskell. Their restriction to extension by a single monad was the primary motivation for the present work. Also, Wadler and David King <ref> [KW92] </ref> show how to combine continuations and lists with other monads. Despite Moggi's earlier formulation of monad transformers, they discuss "combining M and L" rather than "constructing ML from M".
Reference: [MC93] <author> Eugenio Moggi and Pietro Cenciarelli. </author> <title> A syntactic approach to modularity in denotational semantics. </title> <booktitle> In Category Theory and Computer Science, Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1993. </year>
Reference-contexts: That is, we would like to develop modular calculi for reasoning about the languages that the toolkit can build. Moggi's computational lambda calculus [Mog89b, Mog91b] captures precisely the inferences valid for lambda calculus over an arbitrary monad. Can we go further? Moggi's syntactic approach <ref> [MC93] </ref> is certainly relevant but does not seem to address the problem directly. 19 5 Conclusion We have built a language designer's workbench, a collection of mix-and-match modules that assemble to form programming language interpreters. These interpreters run example programs and can be simplified to yield semantic equations.
Reference: [Mog86] <author> Eugenio Moggi. </author> <title> Categories of partial morphisms and the partial lambda calculus. </title> <booktitle> In Category Theory and Computer Programing, volume 240 of Lecture Notes in Computer Science, Guildford, </booktitle> <address> England, 1986. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: The usual reason for restrictive type systems is the intractability of inference in complex systems, but surely there is a way to make a well-defined class of simple inferences within a complex type system. 4.3 Previous work Through his work on the partial lambda calculus <ref> [Mog86] </ref>, Eugenio Moggi realized that the categorical concept of monads was applicable to the problem of modular semantics. In [Mog89b, Mog91b], he shows how to divide an "applied" lambda calculus into a core (variables and environments) and an extension (other features), expressed as a monad, and presents many such extensions.
Reference: [Mog89a] <author> Eugenio Moggi. </author> <title> An abstract view of programming languages. </title> <type> Technical Report ECS-LFCS-90-113, </type> <institution> Laboratory for Foundations of Computer Science, University of Edinburgh, Edinburgh, </institution> <address> Scotland, </address> <month> June </month> <year> 1989. </year> <note> FTP from theory.doc.ic.ac.uk. </note>
Reference-contexts: Tools such as attribute grammars [DJL88] and abstract semantic algebras [Mos92] were developed to solve this problem but cannot handle complex semantics. Using the toolkit, we simply add the stores module to the language specification. To achieve these results, we reformulate Moggi's theory of modular denotational semantics <ref> [Mog89a, Mog91a] </ref>. We introduce stratified monads, sets of named semantic levels, related in pairs by monads. We define language constructs using the monad operators conceptually relevant to them, independent of other details of the semantics. <p> We realize semantic modules, such as stores and continuations, as stratified monad transformers. 1 This paper is a significant advance over previous work that uses monads as a basis for modular language specification. Specifically, * Moggi <ref> [Mog89a] </ref> presents a complex formalism that is often difficult to understand. We introduce a simpler and more flexible theory. By representing it in computational terms, we render it both more useful and more accessible. * Wadler [Wad92] builds interpreters from two parts, a base and an extension. <p> Applying two (different) environment monad transformers to the identity monad indeed yields the double environment monad. Other monad transformers are listed in Table 1. Notice that composition of transformers is not commutative. The use of monad transformers in semantics originates with Moggi <ref> [Mog89a, Mog91a] </ref>. 3.3 Stratified monads Suppose we build a monad of computations using several monad transformers. <p> Without access to intermediate levels, we cannot define many language constructs. A possible solution, due to Moggi <ref> [Mog89a] </ref>, is to interleave the definition of operators with the application of transformers. We arrange for transformers to transform operators as well as monads [Esp94]. However, it is still difficult (or impossible) to define constructs that interact with multiple levels. <p> In [Mog89b, Mog91b], he shows how to divide an "applied" lambda calculus into a core (variables and environments) and an extension (other features), expressed as a monad, and presents many such extensions. In the second half of <ref> [Mog89a] </ref>, Moggi explains how to use monad transformers to form complex monads from parts. This crucial ability was missing from his earlier papers; however, it is difficult to understand Moggi's presentation, and few researchers realized that he had made significant progress toward modularizing denotational semantics.
Reference: [Mog89b] <author> Eugenio Moggi. </author> <title> Computational lambda calculus and monads. </title> <booktitle> In IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 14-23, </pages> <address> Asilomar, CA, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: In general, juxtaposition denotes application (rather than composition) and associates to the left. Hence FTA, which appears in the next section, is equivalent to the Scheme expression ((F T) A). The intuition behind the use of monads in semantics, due to Moggi <ref> [Mog89b] </ref>, is that TA is the type of computations over the values A. Unit lifts values to computations, bind lifts functions on values to functions on computations, and compute lifts representors of values to representors of computations. Monads capture a wide variety of "notions of computation" [Mog89b]. <p> semantics, due to Moggi <ref> [Mog89b] </ref>, is that TA is the type of computations over the values A. Unit lifts values to computations, bind lifts functions on values to functions on computations, and compute lifts representors of values to representors of computations. Monads capture a wide variety of "notions of computation" [Mog89b]. We can lift operators on values to operators on computations using unit and bind, and we can define new operators on computations directly. For example, Figure 8 defines the environment monad, lifts the operator +v (add values) to +c (add computations), and defines a new variable reference operator. <p> Using this technique, Wadler could have implemented the simply-typed lambda calculus in [Wad92], rather than the untyped, by reusing Haskell's type system. Such a treatment would adhere more closely to Moggi's original <ref> [Mog89b] </ref>. In the toolkit, we compute over a single untyped value domain, represented as an extensible disjoint union. This choice exposes the treatment of types in the semantic equations and abstracts from the existing Scheme types; however, it would be interesting to try various typed approaches. <p> In <ref> [Mog89b, Mog91b] </ref>, he shows how to divide an "applied" lambda calculus into a core (variables and environments) and an extension (other features), expressed as a monad, and presents many such extensions. In the second half of [Mog89a], Moggi explains how to use monad transformers to form complex monads from parts. <p> As stratified monads are a model-theoretic construction, the biggest challenge posed by this work is to find their proof-theoretic counterpart. That is, we would like to develop modular calculi for reasoning about the languages that the toolkit can build. Moggi's computational lambda calculus <ref> [Mog89b, Mog91b] </ref> captures precisely the inferences valid for lambda calculus over an arbitrary monad.
Reference: [Mog91a] <author> Eugenio Moggi. </author> <title> A modular approach to denotational semantics. </title> <booktitle> In Category Theory and Computer Science, volume 530 of Lecture Notes in Computer Science, </booktitle> <pages> pages 138-139. </pages> <publisher> Springer Verlag, </publisher> <month> September </month> <year> 1991. </year>
Reference-contexts: Tools such as attribute grammars [DJL88] and abstract semantic algebras [Mos92] were developed to solve this problem but cannot handle complex semantics. Using the toolkit, we simply add the stores module to the language specification. To achieve these results, we reformulate Moggi's theory of modular denotational semantics <ref> [Mog89a, Mog91a] </ref>. We introduce stratified monads, sets of named semantic levels, related in pairs by monads. We define language constructs using the monad operators conceptually relevant to them, independent of other details of the semantics. <p> Applying two (different) environment monad transformers to the identity monad indeed yields the double environment monad. Other monad transformers are listed in Table 1. Notice that composition of transformers is not commutative. The use of monad transformers in semantics originates with Moggi <ref> [Mog89a, Mog91a] </ref>. 3.3 Stratified monads Suppose we build a monad of computations using several monad transformers.
Reference: [Mog91b] <author> Eugenio Moggi. </author> <title> Notions of computation and monads. </title> <journal> Information and Computation, </journal> <volume> 93 </volume> <pages> 55-92, </pages> <year> 1991. </year>
Reference-contexts: In <ref> [Mog89b, Mog91b] </ref>, he shows how to divide an "applied" lambda calculus into a core (variables and environments) and an extension (other features), expressed as a monad, and presents many such extensions. In the second half of [Mog89a], Moggi explains how to use monad transformers to form complex monads from parts. <p> As stratified monads are a model-theoretic construction, the biggest challenge posed by this work is to find their proof-theoretic counterpart. That is, we would like to develop modular calculi for reasoning about the languages that the toolkit can build. Moggi's computational lambda calculus <ref> [Mog89b, Mog91b] </ref> captures precisely the inferences valid for lambda calculus over an arbitrary monad.
Reference: [Mos92] <author> Peter D. Mosses. </author> <title> Action Semantics, </title> <booktitle> volume 26 of Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: To see the lack of modularity in interpreters, consider adding stores to a language without them. Even though most language constructs leave the store unchanged, it is necessary to rewrite the interpreter completely. Tools such as attribute grammars [DJL88] and abstract semantic algebras <ref> [Mos92] </ref> were developed to solve this problem but cannot handle complex semantics. Using the toolkit, we simply add the stores module to the language specification. To achieve these results, we reformulate Moggi's theory of modular denotational semantics [Mog89a, Mog91a]. <p> They do not attempt to build interpreters, and we note that monad composition is strictly less powerful than monad transformation. Peter Mosses <ref> [Mos92] </ref> describes action semantics, a reformulation of his theory of abstract semantic algebras. Mosses attempts to achieve modularity in semantics by defining an intermediate level, called actions, into which one can translate language constructs.
Reference: [Ste94] <author> Guy L. Steele Jr. </author> <title> Building interpreters by composing monads. </title> <booktitle> In Proceedings of the 21st Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> Portland, OR, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: By representing it in computational terms, we render it both more useful and more accessible. * Wadler [Wad92] builds interpreters from two parts, a base and an extension. Our theory is more general, allowing us to compose languages from any number of semantic modules. * Steele <ref> [Ste94] </ref> uses pseudomonads to build a limited but complex interpreter toolkit. Our work is simpler and handles a wider range of constructions. The paper is organized as follows. Section 2 presents a series of examples, section 3 discusses how the toolkit works, and section 4 compares it to previous work. <p> In the example, invoking the captured continuation aborts this process and returns 4 directly. Hence, the expression has only one value in contrast to the other two semantics. Of the semantics presented here, this is the only one that Steele's system can generate <ref> [Ste94] </ref>. Incidentally, replacing continuations with continuations2 leaves %amb unchanged. 3 Methods This section explains how the toolkit works. <p> In the toolkit, we compute over a single untyped value domain, represented as an extensible disjoint union. This choice exposes the treatment of types in the semantic equations and abstracts from the existing Scheme types; however, it would be interesting to try various typed approaches. Steele <ref> [Ste94] </ref> tries to extend the domain of values using monads, and I follow him in [Esp94]. However, as he points out, using the exceptions monad to build sums yields behavior such as (compute (%+ (%num 3) (%true))) ) true which is not at all what we want. <p> Despite Moggi's earlier formulation of monad transformers, they discuss "combining M and L" rather than "constructing ML from M". Our toolkit treats monad constructors in full generality and exhibits a complete system for building interpreters from multiple modules, not just two. Guy Steele <ref> [Ste94] </ref> shows how to compose pseudomonads, a new construction. Although they compose, pseudomonads are both more complex and less general than monad transformers. In fact, pseudomonads are essentially monad transformers limited to right composition.
Reference: [Wad92] <editor> Philip Wadler. </editor> <booktitle> The essence of functional programming. In Proceedings of the 19th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-14, </pages> <address> Albuquerque, NM, </address> <month> January </month> <year> 1992. </year> <month> 27 </month>
Reference-contexts: Specifically, * Moggi [Mog89a] presents a complex formalism that is often difficult to understand. We introduce a simpler and more flexible theory. By representing it in computational terms, we render it both more useful and more accessible. * Wadler <ref> [Wad92] </ref> builds interpreters from two parts, a base and an extension. Our theory is more general, allowing us to compose languages from any number of semantic modules. * Steele [Ste94] uses pseudomonads to build a limited but complex interpreter toolkit. <p> The paper is organized as follows. Section 2 presents a series of examples, section 3 discusses how the toolkit works, and section 4 compares it to previous work. We assume an elementary understanding of denotational semantics and functional programming; for further background, see <ref> [Wad92] </ref>. <p> (lambda (env) (lambda (k) ((x env) (lambda (a) ((y env) (lambda (a0) (k (append a a0))))))))) ;; Example (compute (%+ (%num 1) (%call/cc (%lambda 'k (%* (%num 10) (%amb (%num 3) (%call (%var 'k) (%num 4)))))))) ) (5) 9 3.1 Monads We briefly review monads; for a longer introduction, see <ref> [Wad92] </ref>. For our purposes, a monad is type constructor T along with operators unit : A -&gt; TA bind : TA * (A -&gt; TB) -&gt; TB compute : TA * (A -&gt; Rep) -&gt; Rep where Rep is a fixed type of observable representations. <p> Using this technique, Wadler could have implemented the simply-typed lambda calculus in <ref> [Wad92] </ref>, rather than the untyped, by reusing Haskell's type system. Such a treatment would adhere more closely to Moggi's original [Mog89b]. In the toolkit, we compute over a single untyped value domain, represented as an extensible disjoint union. <p> Stratified monads solve this problem, and, by separating semantic extensions from the language constructs they enable, increase language design flexibility. Philip Wadler <ref> [Wad92] </ref> popularized Moggi's ideas by presenting monadic interpreters written in Haskell. Their restriction to extension by a single monad was the primary motivation for the present work. Also, Wadler and David King [KW92] show how to combine continuations and lists with other monads.
References-found: 18

