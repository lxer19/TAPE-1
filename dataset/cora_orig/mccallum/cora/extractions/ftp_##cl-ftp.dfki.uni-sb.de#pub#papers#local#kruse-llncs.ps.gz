URL: ftp://cl-ftp.dfki.uni-sb.de/pub/papers/local/kruse-llncs.ps.gz
Refering-URL: http://cl-www.dfki.uni-sb.de/cl/papers/cl-abstracts.html
Root-URL: 
Email: krieger@dfki.uni-sb.de  
Phone: phone: (+49 681) 302-5299 fax: (+49 681) 302-5341  
Title: Classification and Representation of Types in TDL  
Author: Hans-Ulrich Krieger 
Address: Stuhlsatzenhausweg 3, 66123 Saarbrucken, Germany  
Affiliation: German Research Center for Artificial Intelligence (DFKI)  
Abstract: This paper presents TDL, a typed feature-based representation language and inference system, specifically designed to support highly lexicalized constraint-based grammar theories. Type definitions in TDL consist of type and feature constraints over the full Boolean con-nectives together with coreferences, thus making TDL Turing-complete. TDL provides open- and closed-world reasoning over types. Working with partially as well as with fully expanded types is possible. Efficient reasoning in TDL is accomplished through specialized modules. In this paper, we will highlight the type/inheritance hierarchy module of TDL and show how we represent conjunctively and disjunctively defined types. Negated types and incompatible types are handled by specialized bottom symbols. Redefining a type only leads to the redefinition of the dependent types, and not to the redefinition of the whole grammar/lexicon. Undefined types are nothing special. Reasoning over the type hierarchy is partially realized by a bit vector encoding of types, similar to the one used in At-Kaci's LOGIN. However, the underlying semantics does not harmonize with the open-world assumption of TDL. Thus, we have to generalize the GLB/LUB operation to account for this fact. The system, as presented in the paper, has been fully implemented in Common Lisp and is an integrated part of a large NL system. It has been installed and successfully employed at other sites and runs on var ious platforms.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Hassan At-Kaci. </author> <title> An introduction to LIFE|programming with logic, inheritance, functions, and equations. </title> <booktitle> In Proceedings of the International Symposium on Logic Programming, </booktitle> <pages> pages 52-68, </pages> <year> 1993. </year>
Reference-contexts: It is worth noting that TDL does not enforce a grammar writer to specify the type subsumption relation a priori through a set of fs 1 ; : : : ; s n g s statements, as is the case for LOGIN [4], ALE, or LIFE <ref> [1] </ref>. Instead, TDL automatically derives and extends a type hierarchy from the complex type expression t by means of normalized definitions (see below). In general, the type hierarchy only forms a partial order, i.e., we do not require additional ordering properties, e.g., BCPO/lower semilattice.
Reference: 2. <author> Hassan At-Kaci, Robert Boyer, Patrick Lincoln, and Roger Nasr. </author> <title> Efficient implementation of lattice operations. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(1) </volume> <pages> 115-146, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: Moreover, generalizations can be made at the appro priate levels of representation. Efficient Processing Certain type constraints can be compiled into more efficient representations; for instance, <ref> [3, 2] </ref> reduce GLB (greatest lower bound), LUB (least upper bound), and (type subsumption) computation to low-level bit manipulations. Moreover, types can be used to eliminate expensive unification operations, for example, by explicit declaration of type incompatibility. <p> The compilation is based on Hassan At-Kaci's bit vector encoding technique for partial orders <ref> [3, 2] </ref>) and has been further extended to serve our special requirements. Here, every type t is assigned a code fl (t) (represented through a bit vector) such that fl (t) encodes the reflexive and transitive closure of the immediate type subsumption relation with respect to t.
Reference: 3. <author> Hassan At-Kaci, Robert Boyer, and Roger Nasr. </author> <title> An encoding technique for the efficient implementation of type inheritance. </title> <type> Technical Report AI-109-85, </type> <institution> MCC, Austin, TX, </institution> <year> 1985. </year>
Reference-contexts: Moreover, generalizations can be made at the appro priate levels of representation. Efficient Processing Certain type constraints can be compiled into more efficient representations; for instance, <ref> [3, 2] </ref> reduce GLB (greatest lower bound), LUB (least upper bound), and (type subsumption) computation to low-level bit manipulations. Moreover, types can be used to eliminate expensive unification operations, for example, by explicit declaration of type incompatibility. <p> The compilation is based on Hassan At-Kaci's bit vector encoding technique for partial orders <ref> [3, 2] </ref>) and has been further extended to serve our special requirements. Here, every type t is assigned a code fl (t) (represented through a bit vector) such that fl (t) encodes the reflexive and transitive closure of the immediate type subsumption relation with respect to t.
Reference: 4. <author> Hassan At-Kaci and Roger Nasr. </author> <title> LOGIN: A logic programming language with built-in inheritance. </title> <journal> Journal of Logic Programming, </journal> <volume> 3 </volume> <pages> 185-215, </pages> <year> 1986. </year>
Reference-contexts: It is worth noting that TDL does not enforce a grammar writer to specify the type subsumption relation a priori through a set of fs 1 ; : : : ; s n g s statements, as is the case for LOGIN <ref> [4] </ref>, ALE, or LIFE [1]. Instead, TDL automatically derives and extends a type hierarchy from the complex type expression t by means of normalized definitions (see below). In general, the type hierarchy only forms a partial order, i.e., we do not require additional ordering properties, e.g., BCPO/lower semilattice.
Reference: 5. <author> Rolf Backofen and Christoph Weyers. </author> <title> UDiNe|a feature constraint solver with distributed disjunction and classical negation. Unpublished documentation note, </title> <year> 1994. </year>
Reference-contexts: The Disco grammar currently consists of more than 1500 type specifications written in TDL and is the largest HPSG grammar for German [13]. The core machine of Disco consists of TDL and the feature constraint solver UDiNe <ref> [5] </ref>. UDiNe itself is a powerful untyped unification engine which allows the use of distributed disjunctions, general negation, and functional dependencies.
Reference: 6. <author> Bob Carpenter and Gerald Penn. </author> <title> ALE|the attribute logic engine user's guide. version 2.0. </title> <type> Technical report, </type> <institution> Laboratory for Computational Linguistics. Philosophy Department, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> August </month> <year> 1994. </year>
Reference-contexts: Later, additional operations came into play, e.g., negation. Other proposals consider the integration of functional/relational dependencies into the formalism which make them, in general, Turing-complete (e.g., ALE; cf. <ref> [6] </ref>). However the most important extension to formalisms consists of the incorporation of types , for instance in contemporary systems like TFS [20], CUF [8], ALE, or TDL [11]. Types are ordered hierarchically as it is known from object-oriented programming languages.
Reference: 7. <author> Abdel Kader Diagne, Walter Kasper, and Hans-Ulrich Krieger. </author> <title> Distributed parsing with HPSG grammars. </title> <type> Technical report, </type> <institution> German Research Center for Artificial Intelligence (DFKI), Saarbrucken, Germany, </institution> <year> 1995. </year> <note> To appear. </note>
Reference-contexts: Parsing as Deduction [15] is often achieved by replacing the context-free backbone through recursive types. Compiling Types Types are a good starting point for further methods of compilation. We have already mentioned bit vector encoding. Types can also serve as the basis for separating "true" and "spurious" constraints <ref> [7] </ref>, for partial evaluation, or for compiling an HPSG grammar into a weaker formalism (e.g., [9]). 3 TDL|An Overview TDL is a unification-based grammar development environment and run time system supporting in particular HPSG-style grammars. Work on TDL has started within the Disco project of the DFKI [19].
Reference: 8. <author> Jochen Dorre and Michael Dorna. </author> <title> CUF|a formalism for linguistic knowledge representation. </title> <editor> In Jochen Dorre, editor, </editor> <title> Computational Aspects of Constraint-Based Linguistic Description I. </title> <address> DYANA, </address> <year> 1993. </year>
Reference-contexts: Other proposals consider the integration of functional/relational dependencies into the formalism which make them, in general, Turing-complete (e.g., ALE; cf. [6]). However the most important extension to formalisms consists of the incorporation of types , for instance in contemporary systems like TFS [20], CUF <ref> [8] </ref>, ALE, or TDL [11]. Types are ordered hierarchically as it is known from object-oriented programming languages. This often leads to multiple inheritance in the description of linguistic entities.
Reference: 9. <author> Robert T. Kasper, Bernd Kiefer, Klaus Netter, and K. Vijay-Shanker. </author> <title> Compilation of HPSG yo TAG. </title> <booktitle> In Proceedings of the 33rd Annual Meeting of the Association for Computational Linguistics, </booktitle> <address> ACL-95, </address> <year> 1995. </year>
Reference-contexts: Compiling Types Types are a good starting point for further methods of compilation. We have already mentioned bit vector encoding. Types can also serve as the basis for separating "true" and "spurious" constraints [7], for partial evaluation, or for compiling an HPSG grammar into a weaker formalism (e.g., <ref> [9] </ref>). 3 TDL|An Overview TDL is a unification-based grammar development environment and run time system supporting in particular HPSG-style grammars. Work on TDL has started within the Disco project of the DFKI [19].
Reference: 10. <author> Hans-Ulrich Krieger. </author> <title> TDL|A Type Description Language for Constraint-Based Grammars. Foundations, Implementation, and Applications. </title> <type> PhD thesis, </type> <institution> Univer-sitat des Saarlandes, Department of Computer Science, </institution> <year> 1995. </year> <month> Forthcoming. </month>
Reference-contexts: hierarchy as a pure "transport medium" for constraints, we can transform nonmonotonically defined types into a perfectly definite program. 2 Thus, typed feature structures in TDL might be typed with complex types like a ^ b or a ^ (b _ :c), and not with type symbols only. 3 Cf. <ref> [10] </ref> for a precise description of the semantics of TDL, including a fixpoint characterization of recursive types.
Reference: 11. <author> Hans-Ulrich Krieger and Ulrich Schafer. </author> <title> TDL|a type description language for constraint-based grammars. </title> <booktitle> In Proceedings of the 15th International Conference on Computational Linguistics, COLING-94, </booktitle> <pages> pages 893-899, </pages> <year> 1994. </year>
Reference-contexts: Other proposals consider the integration of functional/relational dependencies into the formalism which make them, in general, Turing-complete (e.g., ALE; cf. [6]). However the most important extension to formalisms consists of the incorporation of types , for instance in contemporary systems like TFS [20], CUF [8], ALE, or TDL <ref> [11] </ref>. Types are ordered hierarchically as it is known from object-oriented programming languages. This often leads to multiple inheritance in the description of linguistic entities.
Reference: 12. <author> Hans-Ulrich Krieger and Ulrich Schafer. </author> <title> Efficient parameterizable type expansion for typed feature formalisms. </title> <booktitle> In Proceedings of the 14th International Joint Conference on Artificial Intelligence, IJCAI-95, </booktitle> <address> Montreal, Canada, </address> <year> 1995. </year> <note> To appear. </note>
Reference-contexts: carried out in O (n), where n is the number of types (actually O (1), since n does not change at run time). 6 At-Kaci's method has been extended to account for the open-world nature of avm types, in that potential GLB/LUB candidates (calculated from their codes) 4 Type expansion <ref> [12] </ref> or type unfolding means to make the inherent constraints of a type explicit and to (partially) check for its consistency. 5 At-Kaci has argued that decoding, i.e., calling fl 1 is not necessary at run time.
Reference: 13. <author> Klaus Netter. </author> <title> Architecture and coverage of the DISCO grammar. </title> <editor> In S. Busemann and Karin Harbusch, editors, </editor> <booktitle> Proceedings of the DFKI Workshop on Natural Language Systems: Modularity and Re-Usability, DFKI, </booktitle> <address> D-93-03, </address> <year> 1993. </year>
Reference-contexts: Work on TDL has started within the Disco project of the DFKI [19]. The Disco grammar currently consists of more than 1500 type specifications written in TDL and is the largest HPSG grammar for German <ref> [13] </ref>. The core machine of Disco consists of TDL and the feature constraint solver UDiNe [5]. UDiNe itself is a powerful untyped unification engine which allows the use of distributed disjunctions, general negation, and functional dependencies.
Reference: 14. <author> Peter Norvig. </author> <booktitle> Paradigms of Artificial Intelligence Programming. </booktitle> <publisher> Morgan Kauf-mann, </publisher> <address> San Mateo, CA, </address> <year> 1991. </year>
Reference-contexts: Second, this simplifier is extensively used during type expansion to reduce the costs of typed unification and copying. Third, simplified expressions are memoized <ref> [14] </ref> in order to reuse them later. Here the unsimplified expression serves as the key in a hash table, so that the corresponding value is exactly the simplified formula.
Reference: 15. <author> Fernando C.N. Pereira and David H.D. Warren. </author> <title> Parsing as deduction. </title> <booktitle> In Proceedings of the 21st Annual Meeting of the Association for Computational Linguistics, ACL-83, </booktitle> <pages> pages 137-144, </pages> <year> 1983. </year>
Reference-contexts: Recursive Types Recursive types give a grammar writer the opportunity to formulate certain functions/relations or extensions to the formalism (e.g., functional uncertainty) as recursive type specifications. Parsing as Deduction <ref> [15] </ref> is often achieved by replacing the context-free backbone through recursive types. Compiling Types Types are a good starting point for further methods of compilation. We have already mentioned bit vector encoding.
Reference: 16. <author> Carl Pollard and Ivan A. Sag. </author> <title> Information-Based Syntax and Semantics. Vol. I: Fundamentals. CSLI Lecture Notes, Number 13. Center for the Study of Language and Information, </title> <publisher> Stanford, </publisher> <year> 1987. </year>
Reference-contexts: Types are a necessary requirement for a grammar development environment because they serve as abbreviations for lexicon entries, immediate dominance rule schemata, and universal as well as language-specific principles, as is familiar from Head-Driven Phrase Structure Grammar (HPSG) <ref> [16] </ref>. Types in TDL not 1 For instance, ALE employs a bottom-up chart parser, whereas TFS relies entirely on type deduction.
Reference: 17. <author> Gert Smolka. </author> <title> A feature logic with subsorts. </title> <type> LILOG Report 33, </type> <institution> WT LILOG-IBM Germany, Stuttgart, </institution> <month> May </month> <year> 1988. </year> <note> Also in J. </note> <editor> Wedekind and C. Rohrer (eds.), </editor> <title> Unification in Grammar, </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: One can even declare sets of avm types as incompatible, meaning that their conjunction yields ?, so that specific types can be "closed", if desired. The kernel of TDL (and of most other systems) can be given a set-theoretical semantics, e.g., along the lines of <ref> [17] </ref>.
Reference: 18. <author> Gert Smolka. </author> <title> Residuation and guarded rules for constraint-logic programming. </title> <institution> Research Report RR-91-13, German Research Center for Artificial Intelligence (DFKI), Saarbrucken, </institution> <year> 1991. </year>
Reference-contexts: The kernel of TDL (and of most other systems) can be given a set-theoretical semantics, e.g., along the lines of [17]. It is easy to translate TDL statements into denotation-preserving expressions of Smolka's feature logic or even into a set of definite equivalences <ref> [18] </ref>, i.e., a definite program, thus viewing TDL as just syntactic sugar for first-order predicate logic. 3 The latter point is of special importance, since by viewing the type hierarchy as a pure "transport medium" for constraints, we can transform nonmonotonically defined types into a perfectly definite program. 2 Thus, typed
Reference: 19. <author> Hans Uszkoreit, Rolf Backofen, Stephan Busemann, Abdel Kader Diagne, Eliz-abeth A. Hinkelman, Walter Kasper, Bernd Kiefer, Hans-Ulrich Krieger, Klaus Netter, Gunter Neumann, Stephan Oepen, and Stephen P. Spackman. </author> <title> DISCO| an HPSG-based NLP system and its application for appointment scheduling. </title> <booktitle> In Proceedings of COLING-94, </booktitle> <pages> pages 436-440, </pages> <year> 1994. </year> <note> A version of this paper is available as DFKI Research Report RR-94-38. </note>
Reference-contexts: Work on TDL has started within the Disco project of the DFKI <ref> [19] </ref>. The Disco grammar currently consists of more than 1500 type specifications written in TDL and is the largest HPSG grammar for German [13]. The core machine of Disco consists of TDL and the feature constraint solver UDiNe [5].
Reference: 20. <author> Remi Zajac. </author> <title> Inheritance and constraint-based grammar formalisms. </title> <journal> Computational Linguistics, </journal> <volume> 18(2) </volume> <pages> 159-182, </pages> <year> 1992. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: Other proposals consider the integration of functional/relational dependencies into the formalism which make them, in general, Turing-complete (e.g., ALE; cf. [6]). However the most important extension to formalisms consists of the incorporation of types , for instance in contemporary systems like TFS <ref> [20] </ref>, CUF [8], ALE, or TDL [11]. Types are ordered hierarchically as it is known from object-oriented programming languages. This often leads to multiple inheritance in the description of linguistic entities.
References-found: 20

