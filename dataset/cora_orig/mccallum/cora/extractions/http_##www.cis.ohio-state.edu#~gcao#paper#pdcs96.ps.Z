URL: http://www.cis.ohio-state.edu/~gcao/paper/pdcs96.ps.Z
Refering-URL: http://www.cis.ohio-state.edu/~gcao/publications.html
Root-URL: 
Email: gcao@cis.ohio-state.edu rishen@fiu.edu  
Title: A Nonblocking Consistent Checkpointing Algorithm for Distributed Systems  
Author: Guohong Cao Naphtali Rishe 
Address: Columbus, OH43201 Miami, FL 33199  
Affiliation: Computer and Information Science School of Computer Science The Ohio-State University Florida International University  
Note: The 8 th International Conference on Parallel and Distributed Computing and Systems, pp. 302-307 1  
Abstract: Consistent checkpointing simplifies failure recovery and eliminates the domino effect in case of failure by preserving a consistent global checkpoint in stable storage. However, the approach suffers from high overhead associated with the checkpointing process. This paper presents an efficient non-block scheme to address this problem. In the proposed scheme, a checkpoint sequence number vector is used to identify orphan messages; as a result, processes involved in checkpointing need not to be blocked. Based on inter-process dependencies created since the last checkpointing, our scheme only forces a minimal set of processes to take their checkpoints. It is shown that the proposed algorithm ensures the global state consistency of the distributed system. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. Barigazzi and L. Strigini. </author> <title> "Application-Transparent Setting of Recovery Points". </title> <booktitle> Digest of Papers FTCS-13, </booktitle> <pages> pages 48-55, </pages> <year> 1983. </year>
Reference-contexts: The checkpointing algorithm terminates within a finite time. The proof is similar to [11] and [6]. 5 Related Work The first consistent checkpointing algorithm was presented in <ref> [1] </ref>. However, the algorithm assumes that all communications between processes are atomic, which is too restrict. The Koo and Toueg algorithm [8] relaxes this assumption, and only requires message exchange between processes that have dependency relationship, thus reducing the number of messages required.
Reference: [2] <author> B. Bhargava, S.R. Lian, and P.J. Leu. </author> " <title> Experimental Evaluation of Concurrent Checkpointing and Rollback-Recovery Algorithms". </title> <booktitle> Proceedings of the International Conference on Data Engineering, </booktitle> <pages> pages 182-189, </pages> <year> 1990. </year>
Reference-contexts: A checkpointing process includes the time to trace the dependency tree and save the state of processes on stable storage, which needs a long time. Therefore, blocking algorithms dramatically reduce the performance of the system <ref> [2, 5] </ref>. Recently, some nonblocking algorithms [5, 12] have received considerable attention. They avoid the need for processes to be blocked during checkpointing by using a checkpointing sequence number to identify orphan messages. However, these algorithms [5, 12] assume that a distinguished initiator decides when to take a checkpoint. <p> Deng and Park [4] proposed an algorithm, which addresses both orphan message and lost inconsistencies. In these consistent checkpointing algorithms, the processes are blocked when taking checkpoint and during rollback recovery. The blocking dramatically reduces the performance of the system <ref> [2, 5] </ref>. Kim and Park [7] at-temped to solve this problem.
Reference: [3] <author> K.M. Chandy and L. Lamport. </author> <title> "Distributed Snap shots: Determining Global States of Distributed Systems". </title> <journal> ACM Transactions on Computer Systems, </journal> <month> Febru-ary </month> <year> 1985. </year>
Reference-contexts: A system state is said to be consistent if it contains no orphan message; i.e., a message whose receiving event is recorded in the state of the destination process, but its sending event is lost <ref> [3, 8, 13] </ref>. In order to record a consistent global checkpoint in stable storage, processes must be synchronized during checkpointing. In other words, before a process takes a checkpoint, it asks (by sending checkpoint requests to) all relevant processes to take checkpoints.
Reference: [4] <author> Y. Deng and E.K. Park. </author> <title> "Checkpointing and Rollback Recovery Algorithms in Distributed Systems". </title> <journal> Journal of Systems and Software, </journal> <month> April </month> <year> 1994. </year>
Reference-contexts: Therefore, consistent checkpointing suffers from high overhead associated with the checkpointing process. Much of the previous work in consistent checkpoint-ing has focused on minimizing the number of processes that must participate in taking a consistent checkpoint <ref> [4, 8, 9] </ref> or to reduce the number of messages required to synchronize the consistent checkpoint [14, 15]. However, these algorithms (called blocking algorithm) force all relevant processes in the system to freeze their computations during the checkpointing process. <p> These two algorithms have a common drawback in that they assume a complex scheme (such as slide window) to deal with the message loss problem, and do not consider lost messages in checkpointing and recovery. Deng and Park <ref> [4] </ref> proposed an algorithm, which addresses both orphan message and lost inconsistencies. In these consistent checkpointing algorithms, the processes are blocked when taking checkpoint and during rollback recovery. The blocking dramatically reduces the performance of the system [2, 5]. Kim and Park [7] at-temped to solve this problem.
Reference: [5] <author> E.N. Elnozahy, D.B. Johnson, and W. Zwaenepoel. </author> <title> "The Performance of Consistent Checkpointing". </title> <booktitle> Proceedings of the 11th Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 86-95, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: A checkpointing process includes the time to trace the dependency tree and save the state of processes on stable storage, which needs a long time. Therefore, blocking algorithms dramatically reduce the performance of the system <ref> [2, 5] </ref>. Recently, some nonblocking algorithms [5, 12] have received considerable attention. They avoid the need for processes to be blocked during checkpointing by using a checkpointing sequence number to identify orphan messages. However, these algorithms [5, 12] assume that a distinguished initiator decides when to take a checkpoint. <p> A checkpointing process includes the time to trace the dependency tree and save the state of processes on stable storage, which needs a long time. Therefore, blocking algorithms dramatically reduce the performance of the system [2, 5]. Recently, some nonblocking algorithms <ref> [5, 12] </ref> have received considerable attention. They avoid the need for processes to be blocked during checkpointing by using a checkpointing sequence number to identify orphan messages. However, these algorithms [5, 12] assume that a distinguished initiator decides when to take a checkpoint. <p> Therefore, blocking algorithms dramatically reduce the performance of the system [2, 5]. Recently, some nonblocking algorithms <ref> [5, 12] </ref> have received considerable attention. They avoid the need for processes to be blocked during checkpointing by using a checkpointing sequence number to identify orphan messages. However, these algorithms [5, 12] assume that a distinguished initiator decides when to take a checkpoint. Therefore, they suffer from the disadvantages of centralized algorithms, such as one-site failure, bottle-neck, etc. <p> Most of algorithms <ref> [5, 12] </ref> use a Checkpoint Sequence Number (csn) to avoid inconsistency. More specifically, a process takes a checkpoint if it receives an application message whose appended csn is greater than the local csn. <p> Deng and Park [4] proposed an algorithm, which addresses both orphan message and lost inconsistencies. In these consistent checkpointing algorithms, the processes are blocked when taking checkpoint and during rollback recovery. The blocking dramatically reduces the performance of the system <ref> [2, 5] </ref>. Kim and Park [7] at-temped to solve this problem. <p> However, this scheme requires each process to log every message sent, which may introduce some performance degradation, and require the system to be deterministic. 5 The Elnozahy-Johnson-Zwaenepoel algorithm <ref> [5] </ref> uses the checkpoint sequence number to identify orphan messages, thus avoiding the need for processes to be blocked during checkpointing. However, this approach requires the initiator to communicate with all of the processes in the computation. The algorithm proposed by Silva and Silva [12] uses the same idea as [5], <p> <ref> [5] </ref> uses the checkpoint sequence number to identify orphan messages, thus avoiding the need for processes to be blocked during checkpointing. However, this approach requires the initiator to communicate with all of the processes in the computation. The algorithm proposed by Silva and Silva [12] uses the same idea as [5], except that the processes which did not communicate with others during a previous checkpoint period do not need to take a new checkpoint. Both algorithms [5, 12] assume that a distinguished initiator decides when to take a checkpoint. <p> The algorithm proposed by Silva and Silva [12] uses the same idea as [5], except that the processes which did not communicate with others during a previous checkpoint period do not need to take a new checkpoint. Both algorithms <ref> [5, 12] </ref> assume that a distinguished initiator decides when to take a checkpoint. Therefore, they suffer from the disadvantages of centralized algorithms, such as one-site failure, bottleneck, etc.
Reference: [6] <author> S.T. Huang. </author> <title> "Detecting Termination of Distributed Computations by External Agents". </title> <booktitle> Proceedings of the 9th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 79-84, </pages> <year> 1989. </year>
Reference-contexts: Note that P i 's csn [i] may be different from P j 's csn [j] if there is no communication between them during several checkpoint periods. By using the csn and the initiator identification number (id), we can avoid inconsistency and unnecessary checkpoints during the checkpointing. Huang's algorithm <ref> [6] </ref> has been modified to detect the termination of the first phase in our algorithm. When a process (the initiator) initiates a checkpointing, it sets its weight to 1, then sends checkpoint request message to all the processes on which it depends. <p> Similar to Case 2, the sequence number of m is greater than P i :csn [j] and then we have a similar contradiction. The checkpointing algorithm terminates within a finite time. The proof is similar to [11] and <ref> [6] </ref>. 5 Related Work The first consistent checkpointing algorithm was presented in [1]. However, the algorithm assumes that all communications between processes are atomic, which is too restrict.
Reference: [7] <author> J.L. Kim and T. Park. </author> <title> "An Efficient Protocol For Checkpointing Recovery in Distributed Systems". </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <pages> pages 955-960, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: Deng and Park [4] proposed an algorithm, which addresses both orphan message and lost inconsistencies. In these consistent checkpointing algorithms, the processes are blocked when taking checkpoint and during rollback recovery. The blocking dramatically reduces the performance of the system [2, 5]. Kim and Park <ref> [7] </ref> at-temped to solve this problem. Their basic idea is: A process takes a checkpoint when it knows that all processes on which it computationally depends have taken their checkpoints, and hence the process need not always wait for the decision made by the checkpoint initiator's decision.
Reference: [8] <author> R. Koo and S. Toueg. </author> <title> "Checkpointing and Rollback Recovery for Distributed Systems". </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pages 23-31, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: A system state is said to be consistent if it contains no orphan message; i.e., a message whose receiving event is recorded in the state of the destination process, but its sending event is lost <ref> [3, 8, 13] </ref>. In order to record a consistent global checkpoint in stable storage, processes must be synchronized during checkpointing. In other words, before a process takes a checkpoint, it asks (by sending checkpoint requests to) all relevant processes to take checkpoints. <p> Therefore, consistent checkpointing suffers from high overhead associated with the checkpointing process. Much of the previous work in consistent checkpoint-ing has focused on minimizing the number of processes that must participate in taking a consistent checkpoint <ref> [4, 8, 9] </ref> or to reduce the number of messages required to synchronize the consistent checkpoint [14, 15]. However, these algorithms (called blocking algorithm) force all relevant processes in the system to freeze their computations during the checkpointing process. <p> In order to clearly present the algorithm, we assume that at any time, at most one checkpointing is in progress. Techniques to handle concurrent initiators of checkpointing by multiple processes can be found in <ref> [8, 10] </ref>. <p> The checkpointing algorithm terminates within a finite time. The proof is similar to [11] and [6]. 5 Related Work The first consistent checkpointing algorithm was presented in [1]. However, the algorithm assumes that all communications between processes are atomic, which is too restrict. The Koo and Toueg algorithm <ref> [8] </ref> relaxes this assumption, and only requires message exchange between processes that have dependency relationship, thus reducing the number of messages required. Later, Leu and Bhargava [9] presented another algorithm, which is resilient to multiple process failures, and does not assume that the channel is FIFO, which is necessary in [8]. <p> <ref> [8] </ref> relaxes this assumption, and only requires message exchange between processes that have dependency relationship, thus reducing the number of messages required. Later, Leu and Bhargava [9] presented another algorithm, which is resilient to multiple process failures, and does not assume that the channel is FIFO, which is necessary in [8]. These two algorithms have a common drawback in that they assume a complex scheme (such as slide window) to deal with the message loss problem, and do not consider lost messages in checkpointing and recovery.
Reference: [9] <author> P.Y. Leu and B. Bhargava. </author> <title> "Concurrent Robust Check pointing and Recovery in Distributed Systems". Pro. </title> <booktitle> 4th IEEE Int. Conf. on Data Eng., </booktitle> <pages> pages 154-163, </pages> <year> 1988. </year>
Reference-contexts: Therefore, consistent checkpointing suffers from high overhead associated with the checkpointing process. Much of the previous work in consistent checkpoint-ing has focused on minimizing the number of processes that must participate in taking a consistent checkpoint <ref> [4, 8, 9] </ref> or to reduce the number of messages required to synchronize the consistent checkpoint [14, 15]. However, these algorithms (called blocking algorithm) force all relevant processes in the system to freeze their computations during the checkpointing process. <p> However, the algorithm assumes that all communications between processes are atomic, which is too restrict. The Koo and Toueg algorithm [8] relaxes this assumption, and only requires message exchange between processes that have dependency relationship, thus reducing the number of messages required. Later, Leu and Bhargava <ref> [9] </ref> presented another algorithm, which is resilient to multiple process failures, and does not assume that the channel is FIFO, which is necessary in [8].
Reference: [10] <author> Ravi Prakash and Mukesh Singhal. </author> " <title> Maximal Global Snapshot with Concurrent Initiators". </title> <booktitle> Proceedings of the Sixth IEEE symposium on Parallel and Distributed Processing, </booktitle> <pages> pages 344-351, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: In order to clearly present the algorithm, we assume that at any time, at most one checkpointing is in progress. Techniques to handle concurrent initiators of checkpointing by multiple processes can be found in <ref> [8, 10] </ref>.
Reference: [11] <author> Ravi Prakash and Mukesh Singhal. </author> <title> "Low-Cost Check pointing and Failure Recovery in Mobile Computing Systems". </title> <type> Technical Report, </type> <institution> the Ohio-state University, </institution> <year> 1994. </year>
Reference-contexts: However, it needs to propagate this checkpoint request to P 5 , because its current checkpoint is triggered by a computation message m4 and P 3 depends on P 5 . In <ref> [11] </ref>, P 3 first propagates the request when it receives m4, then propagates again when it receives the request from P 1 . But our algorithm only propagates once. Note that the propagation is transitive, therefore our algorithm significantly reduces the message complexity. <p> Suppose P 4 takes another checkpoint after it receives m6, it sends a checkpoint request to P 3 . If the channel is not FIFO, there is a possibility that m7 arrives at P 3 earlier than the request. In <ref> [11] </ref>, P 3 does not take checkpoint until it receives the request, which results in inconsistency (m7 will be an orphan). <p> Similar to Case 2, the sequence number of m is greater than P i :csn [j] and then we have a similar contradiction. The checkpointing algorithm terminates within a finite time. The proof is similar to <ref> [11] </ref> and [6]. 5 Related Work The first consistent checkpointing algorithm was presented in [1]. However, the algorithm assumes that all communications between processes are atomic, which is too restrict. <p> If every process can initiate checkpointing, the network would be flooded with control messages and processes might waste their time making unnecessary checkpoints. The Prakash-Singhal <ref> [11] </ref> is also a non-block algorithm. However their algorithm is designed for mobile computing system and has FIFO assumption. Moreover, if a checkpoint is triggered by a computation message, their algorithm propagates the checkpoint request to all dependent processes twice in order to detect the termination of the checkpointing.
Reference: [12] <author> L.M. Silva and J.G. Silva. </author> <title> "Global Checkpointing for Distributed Programs". </title> <booktitle> Proceedings of the 11th Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 155-162, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: A checkpointing process includes the time to trace the dependency tree and save the state of processes on stable storage, which needs a long time. Therefore, blocking algorithms dramatically reduce the performance of the system [2, 5]. Recently, some nonblocking algorithms <ref> [5, 12] </ref> have received considerable attention. They avoid the need for processes to be blocked during checkpointing by using a checkpointing sequence number to identify orphan messages. However, these algorithms [5, 12] assume that a distinguished initiator decides when to take a checkpoint. <p> Therefore, blocking algorithms dramatically reduce the performance of the system [2, 5]. Recently, some nonblocking algorithms <ref> [5, 12] </ref> have received considerable attention. They avoid the need for processes to be blocked during checkpointing by using a checkpointing sequence number to identify orphan messages. However, these algorithms [5, 12] assume that a distinguished initiator decides when to take a checkpoint. Therefore, they suffer from the disadvantages of centralized algorithms, such as one-site failure, bottle-neck, etc. <p> Most of algorithms <ref> [5, 12] </ref> use a Checkpoint Sequence Number (csn) to avoid inconsistency. More specifically, a process takes a checkpoint if it receives an application message whose appended csn is greater than the local csn. <p> However, this approach requires the initiator to communicate with all of the processes in the computation. The algorithm proposed by Silva and Silva <ref> [12] </ref> uses the same idea as [5], except that the processes which did not communicate with others during a previous checkpoint period do not need to take a new checkpoint. Both algorithms [5, 12] assume that a distinguished initiator decides when to take a checkpoint. <p> The algorithm proposed by Silva and Silva [12] uses the same idea as [5], except that the processes which did not communicate with others during a previous checkpoint period do not need to take a new checkpoint. Both algorithms <ref> [5, 12] </ref> assume that a distinguished initiator decides when to take a checkpoint. Therefore, they suffer from the disadvantages of centralized algorithms, such as one-site failure, bottleneck, etc.
Reference: [13] <author> R.E. Strom and S.A. Yemini. </author> <title> "Optimistic Recovery In Distributed Systems". </title> <journal> ACM Transactions on Computer Systems, </journal> <pages> pages 204-226, </pages> <month> August </month> <year> 1985. </year>
Reference-contexts: A system state is said to be consistent if it contains no orphan message; i.e., a message whose receiving event is recorded in the state of the destination process, but its sending event is lost <ref> [3, 8, 13] </ref>. In order to record a consistent global checkpoint in stable storage, processes must be synchronized during checkpointing. In other words, before a process takes a checkpoint, it asks (by sending checkpoint requests to) all relevant processes to take checkpoints.
Reference: [14] <author> Z. Tong, R.Y. Kain, and W.T. Tsai. </author> <title> "A Lower Overhead Checkpointing and Rollback Recovery Scheme for Distributed Systems". </title> <booktitle> Proceedings of the 8th Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 12-20, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: Much of the previous work in consistent checkpoint-ing has focused on minimizing the number of processes that must participate in taking a consistent checkpoint [4, 8, 9] or to reduce the number of messages required to synchronize the consistent checkpoint <ref> [14, 15] </ref>. However, these algorithms (called blocking algorithm) force all relevant processes in the system to freeze their computations during the checkpointing process. A checkpointing process includes the time to trace the dependency tree and save the state of processes on stable storage, which needs a long time.
Reference: [15] <author> K. Venkatesh, T. Radhakrishnan, and H.F. Li. </author> <title> "Op timal Checkpointing and Local Recording for Domino-free Rollback Recovery". </title> <journal> Information Processing Letters, </journal> <pages> pages 25 295-303, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: Much of the previous work in consistent checkpoint-ing has focused on minimizing the number of processes that must participate in taking a consistent checkpoint [4, 8, 9] or to reduce the number of messages required to synchronize the consistent checkpoint <ref> [14, 15] </ref>. However, these algorithms (called blocking algorithm) force all relevant processes in the system to freeze their computations during the checkpointing process. A checkpointing process includes the time to trace the dependency tree and save the state of processes on stable storage, which needs a long time.
Reference: [16] <author> Z. </author> <title> Wojcik and B.E. Wojcik. "Fault Tolerant Distributed Computing Using Atomic Send Receive Checkpoints". </title> <booktitle> Proc. 2nd IEEE Symp. on Parallel and Distributed Processing, </booktitle> <pages> pages 215-222, </pages> <year> 1990. </year> <month> 6 </month>
Reference-contexts: However, based on their algorithms, the processes in the system are still often need to be blocked. In <ref> [16] </ref>, when a process makes a checkpoint it may continue its normal operation without blocking, because processes keep track of any delayed message. Their algorithm is based on the idea of atomic send-receive checkpoints.
References-found: 16

