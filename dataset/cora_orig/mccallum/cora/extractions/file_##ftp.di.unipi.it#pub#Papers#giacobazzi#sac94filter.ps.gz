URL: file://ftp.di.unipi.it/pub/Papers/giacobazzi/sac94filter.ps.gz
Refering-URL: http://www.di.unipi.it/di/groups/lp/papers.html
Root-URL: 
Title: Abstract Filters: Improving Bottom-up Execution of Logic Programs by Two-phase Abstract Interpretation  
Author: Byeong-Mo Chang Kwang-Moo Choe Roberto Giacobazzi 
Note: (Extended Abstract)  
Affiliation: Korea Advanced Institute of Science and Technology  Ecole Polytechnique  
Abstract: Bottom-up evaluation of logic programs may be inefficient as it may generate many irrelevant facts to a given query. The filtering strategy prevents possible irrelevant facts from being processed in the bottom-up evaluation on system graphs. This paper defines the filtered bottom-up evaluation formally, and provides a new filter called abstract filter which is computed by two-phase abstract interpretation at compile time. The abstract filter is defined on a generic abstract domain. This framework is specialized on the depth k abstract domain of Sato and Tamaki. The abstract filter is shown to be at least as powerful as the static filter on the depth k abstract domain. Some performance results are provided. Keywords: abstract interpretation, bottom-up evaluation, filtering, logic programming. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Bancilhon, F., Maier, D., Sagiv, Y. and Ullman, </author> <title> J.D , Magic sets and other strange ways to implement logic programs, </title> <booktitle> Proc. ACM SIGACT-SIGMOD Symp. on Principles of Database Systems, </booktitle> <year> 1986, </year> <pages> pp. 1-15. </pages>
Reference-contexts: However, bottom-up query evaluation may be inefficient since it may generate many irrelevant facts to a given query. In order to overcome this drawback, a number of optimization strategies has been proposed, in particular for seminaive bottom-up evaluation <ref> [1, 2, 7, 8, 10] </ref>. <p> In order to overcome this drawback, a number of optimization strategies has been proposed, in particular for seminaive bottom-up evaluation [1, 2, 7, 8, 10]. For example, the program transformation strategy, like Magic Sets in <ref> [1] </ref>, transforms original programs so that the transformed programs can compute call patterns (which are called magic sets in Magic Sets) and use them to reduce the generation of irrelevant facts during the bottom-up query evaluation. Another approach has been introduced to solve these problems: the filtering strategy. <p> See Example 4 for details. Magic Sets in <ref> [1] </ref> transforms original programs so that they can compute call patterns of atoms (which is called magic sets) and can reduce the generation of irrelevant facts using them.
Reference: [2] <author> Bancilhon, F. and Ramakrishnan, R., </author> <title> An amateur's introduction to recursive query processing strategies, </title> <booktitle> Proc. SIGMOD Int. Conf. on Management of Data, </booktitle> <year> 1986, </year> <pages> pp. 16-52. </pages>
Reference-contexts: However, bottom-up query evaluation may be inefficient since it may generate many irrelevant facts to a given query. In order to overcome this drawback, a number of optimization strategies has been proposed, in particular for seminaive bottom-up evaluation <ref> [1, 2, 7, 8, 10] </ref>.
Reference: [3] <author> Barbuti, R., Giacobazzi R., and Levi, G. </author> <title> A general framework for semantics-based bottom-up abstract interpretation of logic programs, </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15 </volume> <month> 133-181 </month> <year> (1993). </year>
Reference-contexts: We follow <ref> [3] </ref> by defining abstract interpretations as abstractions of concrete interpretations (i.e. subsets of B P ). Let P be a program and ((-(B P ); ); ff; (H; v); fl) be a Ga-lois insertion. In this case, (H; v) is a domain of abstract interpretations for P . <p> type abstraction (see [11]) and show that, in rela tion with static filters, the relatively more abstract domain of depth k abstractions can provide relevant filters once a more precise (two-phase) abstract interpretation process is considered. 5.1 Bottom-up phase In this section we extend the bottom-up abstract interpretation framework in <ref> [3] </ref> in order to include clauses as well as atoms as semantic objects. Let (t) be a function which maps a term t to its depth k abstract term. <p> It is shown in <ref> [3] </ref> that T A P is correct i.e. fl a (lf p (T A The bottom-up phase is defined by extending the framework in [3] to deal with clauses as semantic objects. Let C be the set of (equivalence classes of) clauses up to renaming: i.e. Clause= ~ . <p> It is shown in <ref> [3] </ref> that T A P is correct i.e. fl a (lf p (T A The bottom-up phase is defined by extending the framework in [3] to deal with clauses as semantic objects. Let C be the set of (equivalence classes of) clauses up to renaming: i.e. Clause= ~ .
Reference: [4] <author> Chang, B.-M., Choe, K.-M., and Han., T. </author> <title> Optimized bottom-up evaluation of function-free logic programs with dynamic filtering: an incremental approach. </title> <type> Technical Report, </type> <institution> CS-TR-92-66, Dept. of Computer Science, KAIST, </institution> <month> Feb. </month> <year> 1992. </year>
Reference-contexts: Static filters, however, have their own limit since they are always computed using only data-independent bindings. This drawback can be cured by dynamic filtering, which however incurs runtime overhead because dynamic filters are always computed during program evaluation <ref> [4, 7] </ref>. In this paper we introduce a new family of filters called abstract filters. They are obtained at compile time by abstract interpretation. The definition of abstract filter is presented for a generic abstract domain and provides a suitable generalization of the (static) filter notion. <p> Equivalence means that the answers for the query are the same in both the fixpoint semantics. 3.2 Implementation on system graphs The filtering on system graphs has been introduced as a tool for the filtered bottom-up evaluation <ref> [4, 7, 8] </ref>. It computes the least fixpoint lf p (T F P ) in a seminaive manner. Let Arg V ar (ffi; i) denote the argument variables of the i-th body atom of a rule ffi. <p> The system graph with a filter function F for a program P is denoted by SG F P . The simplistic bottom-up evaluation evaluates a query in terms of bottom-up data flow on system graphs <ref> [4, 8] </ref>. In the following a pred-node is called a base pred-node if it does not have its input ports, and called a derived pred-node otherwise. Each base pred-node in P has its facts initially. <p> It may be be considered as a top-down phase without a bottom-up phase. Dynamic filters are computed at run-time by sideways information propagation and backward information propagation which propagate actual data generated during the evaluation <ref> [4, 7] </ref>. Roughly speaking, the abstract filters approximate dynamic filters. The bottom-up phase can be compared to the sideways information propagation while the top-down phase corresponds to the backward information propagation.
Reference: [5] <author> Cousot, P., and Cousot., R. </author> <title> Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixed points, </title> <booktitle> Proc. of Fourth ACM Symp. Principles of Programming Languages, </booktitle> <year> 1977, </year> <pages> pp. 238-252. </pages>
Reference-contexts: = ff (fl (d)) and e v fl (ff (e)), and (2) E P (fl (d)) v fl (D P (d)) (correctness), specifying that D P faithfully mimics E P . &gt;From the definition it follows that lf p (E P ) v fl (lf p (D P )) (see <ref> [5] </ref>). We follow [3] by defining abstract interpretations as abstractions of concrete interpretations (i.e. subsets of B P ). Let P be a program and ((-(B P ); ); ff; (H; v); fl) be a Ga-lois insertion.
Reference: [6] <author> Falaschi, M., Levi, G., Palamidessi, C. and Martelli, M., </author> <title> Declarative modeling of the operational behavior of logic languages, </title> <journal> Theoretical Computer Science, </journal> <volume> 69 </volume> <month> 289-318 </month> <year> (1989). </year>
Reference-contexts: Let B P = Atoms=~ where Atoms= ~ is the set of equivalence classes on Atoms with respect to ~. The (bottom-up) semantics of a logic program P , characterizing computed answer substitutions is defined in <ref> [6] </ref> in terms of an immediate consequence operator T P on the domain of interpretations -(B P ). <p> A filter F (ffi; i) can also be denoted by F ffi;i for short. If (the tuple associated with) an atom b satisfies a filter F ffi;i , we write b 2 F ffi;i . We formally define filtered bottom-up evaluations by modi fying the T P operator in <ref> [6] </ref>. Definition 1 Let P be a program and F be a filter.
Reference: [7] <author> Kifer, M., and Lozinskii., E. L., </author> <title> A framework for an efficient implementation of deductive databases. </title> <booktitle> In Proc. of the 6-th Advanced Database Symposium, </booktitle> <year> 1986. </year>
Reference-contexts: However, bottom-up query evaluation may be inefficient since it may generate many irrelevant facts to a given query. In order to overcome this drawback, a number of optimization strategies has been proposed, in particular for seminaive bottom-up evaluation <ref> [1, 2, 7, 8, 10] </ref>. <p> Another approach has been introduced to solve these problems: the filtering strategy. It prevents irrelevant facts from being generated at evaluation time by applying filters over the bottom-up evaluation on system graphs <ref> [7, 8] </ref>. A filter fl The work of R. <p> The basic proposal is static filtering <ref> [7, 8] </ref>. It restricts data flow during evaluation by using static filters, which are computed at compile-time by propagating data-independent bindings (selections) in the query and rules. Static filters, however, have their own limit since they are always computed using only data-independent bindings. <p> Static filters, however, have their own limit since they are always computed using only data-independent bindings. This drawback can be cured by dynamic filtering, which however incurs runtime overhead because dynamic filters are always computed during program evaluation <ref> [4, 7] </ref>. In this paper we introduce a new family of filters called abstract filters. They are obtained at compile time by abstract interpretation. The definition of abstract filter is presented for a generic abstract domain and provides a suitable generalization of the (static) filter notion. <p> Equivalence means that the answers for the query are the same in both the fixpoint semantics. 3.2 Implementation on system graphs The filtering on system graphs has been introduced as a tool for the filtered bottom-up evaluation <ref> [4, 7, 8] </ref>. It computes the least fixpoint lf p (T F P ) in a seminaive manner. Let Arg V ar (ffi; i) denote the argument variables of the i-th body atom of a rule ffi. <p> It may be be considered as a top-down phase without a bottom-up phase. Dynamic filters are computed at run-time by sideways information propagation and backward information propagation which propagate actual data generated during the evaluation <ref> [4, 7] </ref>. Roughly speaking, the abstract filters approximate dynamic filters. The bottom-up phase can be compared to the sideways information propagation while the top-down phase corresponds to the backward information propagation.
Reference: [8] <author> Kifer, M., and Lozinskii., E. L., SYGRAF: </author> <title> Implementing logic programs in a database style. </title> <journal> IEEE Trans. on Soft. Eng., </journal> <year> 1988, </year> <pages> pp. 922-935. </pages>
Reference-contexts: 1 Introduction Because of a number of advantages, the bottom-up evaluation of logic programs has recently attracted much attention in logic programming and deductive database <ref> [8, 9, 10] </ref>. It guarantees logical completeness which strict top-down approaches sacrifice in favor of implementational efficiency as in Prolog. In particular, if the number of all possible facts is finite, the bottom-up evaluation terminates while strict top-down one like Prolog may not. <p> However, bottom-up query evaluation may be inefficient since it may generate many irrelevant facts to a given query. In order to overcome this drawback, a number of optimization strategies has been proposed, in particular for seminaive bottom-up evaluation <ref> [1, 2, 7, 8, 10] </ref>. <p> Another approach has been introduced to solve these problems: the filtering strategy. It prevents irrelevant facts from being generated at evaluation time by applying filters over the bottom-up evaluation on system graphs <ref> [7, 8] </ref>. A filter fl The work of R. <p> The basic proposal is static filtering <ref> [7, 8] </ref>. It restricts data flow during evaluation by using static filters, which are computed at compile-time by propagating data-independent bindings (selections) in the query and rules. Static filters, however, have their own limit since they are always computed using only data-independent bindings. <p> Equivalence means that the answers for the query are the same in both the fixpoint semantics. 3.2 Implementation on system graphs The filtering on system graphs has been introduced as a tool for the filtered bottom-up evaluation <ref> [4, 7, 8] </ref>. It computes the least fixpoint lf p (T F P ) in a seminaive manner. Let Arg V ar (ffi; i) denote the argument variables of the i-th body atom of a rule ffi. <p> The system graph with a filter function F for a program P is denoted by SG F P . The simplistic bottom-up evaluation evaluates a query in terms of bottom-up data flow on system graphs <ref> [4, 8] </ref>. In the following a pred-node is called a base pred-node if it does not have its input ports, and called a derived pred-node otherwise. Each base pred-node in P has its facts initially. <p> The evaluation on SG F P computes lf p (T F P ) in a seminaive manner. As an example, we briefly review the static filter computation in <ref> [8] </ref>. <p> The depth k abstract term of a term t is the term t 0 which is obtained by substituting every level k sub-term of t with a fresh variable. The k-signature of a term is defined in <ref> [8] </ref> which extends the depth k abstraction in [11]. The basic idea of the static filter computation is to simulate top-down execution on the system graph. <p> The basic idea of the static filter computation is to simulate top-down execution on the system graph. It propagates bindings in the query backward on the system graph until no more new calling (binding) patterns are found, with every calling pattern being maintained in its k-signature form <ref> [8] </ref>. The abstraction by k-signature guarantees the termination of the algorithm. <p> It provides an abstract filter for each input port of every rule-node. The bottom-up evaluator reads (abstract or static) filters and finds solutions by the system graph evaluation with the filters. The abstract filtering has been compared with the Kifer's static filtering <ref> [8] </ref>. We use two measures: the number of generated tuples and the number of filtered tuples during evaluation , which is a measure of the total traffic through ports. The performance of the evaluation is largely dominated by them.
Reference: [9] <author> Lloyd, J.W., </author> <title> Foundation of Logic Programming, </title> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: 1 Introduction Because of a number of advantages, the bottom-up evaluation of logic programs has recently attracted much attention in logic programming and deductive database <ref> [8, 9, 10] </ref>. It guarantees logical completeness which strict top-down approaches sacrifice in favor of implementational efficiency as in Prolog. In particular, if the number of all possible facts is finite, the bottom-up evaluation terminates while strict top-down one like Prolog may not.
Reference: [10] <author> Ramakrishnan, R., </author> <title> Magic Templates: A spellbinding approach to logic programs, </title> <booktitle> Proc. of the 1988 International Conference and Symposium on Logic Programming (Seattle), </booktitle> <year> 1988, </year> <month> pp.140-159. </month>
Reference-contexts: 1 Introduction Because of a number of advantages, the bottom-up evaluation of logic programs has recently attracted much attention in logic programming and deductive database <ref> [8, 9, 10] </ref>. It guarantees logical completeness which strict top-down approaches sacrifice in favor of implementational efficiency as in Prolog. In particular, if the number of all possible facts is finite, the bottom-up evaluation terminates while strict top-down one like Prolog may not. <p> However, bottom-up query evaluation may be inefficient since it may generate many irrelevant facts to a given query. In order to overcome this drawback, a number of optimization strategies has been proposed, in particular for seminaive bottom-up evaluation <ref> [1, 2, 7, 8, 10] </ref>.
Reference: [11] <author> Sato, T., and Tamaki, H., </author> <title> Enumeration of success patterns in logic programs, </title> <journal> Theoretical Computer Science, </journal> <volume> 34 </volume> <month> 227-240 </month> <year> (1984). </year>
Reference-contexts: The two-phase abstract interpretation consists of a bottom-up phase followed by a top-down one, and it provides an approximation of success patterns of clauses which are relevant to a given query. We will specialize this framework by considering the depth k abstraction <ref> [11] </ref> as abstraction function. The abstract filter constructed from the two-phase analysis prevents facts not generated by the analysis (i.e. facts which are neither success patterns nor relevant to the query) from being processed in the bottom-up evaluation. <p> The depth k abstract term of a term t is the term t 0 which is obtained by substituting every level k sub-term of t with a fresh variable. The k-signature of a term is defined in [8] which extends the depth k abstraction in <ref> [11] </ref>. The basic idea of the static filter computation is to simulate top-down execution on the system graph. It propagates bindings in the query backward on the system graph until no more new calling (binding) patterns are found, with every calling pattern being maintained in its k-signature form [8]. <p> More precise AF can be obtained either by a more refined abstract interpretation technique or by a more precise (less abstract) abstract domain. 5 Two-phase abstract interpretation In this section we will consider abstract filters on the simple depth k type abstraction (see <ref> [11] </ref>) and show that, in rela tion with static filters, the relatively more abstract domain of depth k abstractions can provide relevant filters once a more precise (two-phase) abstract interpretation process is considered. 5.1 Bottom-up phase In this section we extend the bottom-up abstract interpretation framework in [3] in order to
Reference: [12] <author> Sterling, L., and Shapiro, E., </author> <title> The art of Prolog. </title> <publisher> The MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: In the following table, in the cases of rev and acker-man programs, we represent the numbers until the first solution is found. The abstract filtering generates only about 30 percentage of the tuples generated by the static filtering for the program parser in <ref> [12] </ref>, which also optimizes the naive system graph evaluation considerably. For the program rev, both the static filtering and abstract filtering make almost no improvement. It is, however, a matter of course since every atom generated during the evaluation is necessary for answering a given query. <p> The abstract filtering optimizes the bottom-up evaluation considerably for the program, while the static filtering falls into the naive evaluation. For the program path=md with multiple destinations in <ref> [12] </ref>, the abstract filtering generates about half of the tuples generated by the static filtering, which also optimizes the naive system graph evaluation considerably. We can see through the table that the abstract filtering is useful in optimizing nondeterministic program rather than deterministic programs like the program rev.
References-found: 12

