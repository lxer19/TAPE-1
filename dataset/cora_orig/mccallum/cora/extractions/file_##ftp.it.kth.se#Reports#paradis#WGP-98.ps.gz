URL: file://ftp.it.kth.se/Reports/paradis/WGP-98.ps.gz
Refering-URL: http://www.it.kth.se/~lisper/
Root-URL: http://www.it.kth.se
Email: lisper@it.kth.se  
Title: Data Fields  
Author: Bjorn Lisper 
Date: May 15, 1998  
Address: Electrum 204 S-164 40 Kista, Sweden  
Affiliation: Dept. of Teleinformatics, KTH  
Abstract: This position paper describes the data field model, a general model for indexed data structures. The aim of this model is to capture the essence of the style of programming where computing on data structures is expressed by operations directly on the structures rather than operations on the individual elements. Array and and data parallel languages support this programming style, and functional languages often provide second order operations on lists and other data structures for the same purpose. The data field model is designed to be abstract enough to encompass a wide range of explicitly or implicitly indexed structures. Thus, algorithms which are expressed in terms of data fields and general operations on them will be independent of the choice of structure from this range - i.e., generic w.r.t. this choice. This means that the data field approach has some in common with polytypic programming and the theory of shapes. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Eugene Albert, Joan D. Lukas, and Guy L. Steele Jr. </author> <title> Data parallel computers and the forall statement. </title> <journal> J. Parallel Distrib. Comput., </journal> <volume> 13 </volume> <pages> 185-192, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: A third form of notation "quantifies" over a given range of indices, e.g., in Sisal, for i in 1,n returns array of X [i]+Y [i] adds X and Y elementwise for the indices 1 to n. The imperative FORALL statement <ref> [1] </ref> in HPF is very related. 2 1.2 The Data Field View of Indexed Data Structures Data fields are pairs (f; b) where f is a function and the "bound" (or shape) b is an entity that can be interpreted as a predicate [[b]]. (f; b) can be interpreted as a
Reference: [2] <author> Guy E. Blelloch, Siddhartha Chatterjee, Jonathan C. Hardwick, Jay Sipelstein, and Marco Zagha. </author> <title> Implementation of a portable nested data-parallel language. </title> <journal> J. Parallel Distrib. Comput., </journal> <volume> 21(1) </volume> <pages> 4-14, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: The data parallel programming model [10] is an exponent of this style (albeit often with a close connection to some underlying parallel architecture providing support for these operations). Modern array- and data parallel languages like Fortran 90 [3], High Performance Fortran (HPF) [7], NESL <ref> [2] </ref>, and Sisal [6, 17] provide support, as well as many functional languages which have a rich set of list operations corresponding to the array- and data parallel operations.
Reference: [3] <author> Walter S. Brainerd, Charles H. Goldberg, and Jeanne C. Adams. </author> <title> Programmer's Guide to FORTRAN 90. Programming Languages. </title> <publisher> McGraw-Hill, </publisher> <year> 1990. </year>
Reference-contexts: The data parallel programming model [10] is an exponent of this style (albeit often with a close connection to some underlying parallel architecture providing support for these operations). Modern array- and data parallel languages like Fortran 90 <ref> [3] </ref>, High Performance Fortran (HPF) [7], NESL [2], and Sisal [6, 17] provide support, as well as many functional languages which have a rich set of list operations corresponding to the array- and data parallel operations.
Reference: [4] <author> Marina C. Chen, Young-Il Choo, and Jingke Li. </author> <title> Crystal: Theory and pragmatics of generating efficient parallel code. </title> <editor> In Boleslaw K. Szymanski, editor, </editor> <booktitle> Parallel Functional Languages and Compilers, chapter 7, </booktitle> <pages> pages 255-308. </pages> <publisher> Addison-Wesley, </publisher> <year> 1991. </year>
Reference-contexts: Thus, before providing a more exact definition of data fields and their operations we will develop the more abstract model of indexed data structures as partial functions. The term "data fields" is borrowed from Crystal <ref> [4] </ref>. 2 Partial Functions We use the following representation of partial functions. "Calls" to a partial function falling "out of bounds" return a distinguished error value fl. Semantically this is a total, isolated element.
Reference: [5] <author> A.D. Falkoff and K.E. Iverson. </author> <title> The Design of APL. </title> <journal> IBM Journal of Research and Development, </journal> <pages> pages 324-333, </pages> <month> July </month> <year> 1973. </year>
Reference-contexts: Examples of the latter is when solving partial differential equations (PDE's), where the index is closely related to a physical coordinate, in image and signal processing, and in linear algebra. Since the time of APL <ref> [5] </ref> it has been recognized that a programming model which provides operations directly on data structures can be very convenient. The data parallel programming model [10] is an exponent of this style (albeit often with a close connection to some underlying parallel architecture providing support for these operations).
Reference: [6] <author> John T. Feo, David C. Cann, and Rodney R. Oldehoeft. </author> <title> A report on the Sisal language project. </title> <journal> J. Parallel Distrib. Comput., </journal> <volume> 10 </volume> <pages> 349-366, </pages> <year> 1990. </year>
Reference-contexts: The data parallel programming model [10] is an exponent of this style (albeit often with a close connection to some underlying parallel architecture providing support for these operations). Modern array- and data parallel languages like Fortran 90 [3], High Performance Fortran (HPF) [7], NESL [2], and Sisal <ref> [6, 17] </ref> provide support, as well as many functional languages which have a rich set of list operations corresponding to the array- and data parallel operations.
Reference: [7] <author> High Performance Fortran Forum. </author> <title> High Performance Fortran language specification. </title> <journal> Scientific Programming, </journal> <volume> 2(1) </volume> <pages> 1-170, </pages> <month> June </month> <year> 1993. </year> <note> HPF Version 1.0. </note>
Reference-contexts: The data parallel programming model [10] is an exponent of this style (albeit often with a close connection to some underlying parallel architecture providing support for these operations). Modern array- and data parallel languages like Fortran 90 [3], High Performance Fortran (HPF) <ref> [7] </ref>, NESL [2], and Sisal [6, 17] provide support, as well as many functional languages which have a rich set of list operations corresponding to the array- and data parallel operations.
Reference: [8] <author> Joacim Halen, Per Hammarlund, and Bjorn Lisper. </author> <title> An experimental implementation of a highly abstract model of data parallel programming. </title> <institution> Technical Report TRITA-IT R 97:02, Dept. of Teleinformatics, KTH, Stockholm, </institution> <month> March </month> <year> 1997. </year>
Reference-contexts: Exact definitions for [[ ]], size, enum, u and t are given in [15]. For a simple case, see Fig 2. 8 4 Ongoing Work Our work so far has mainly consisted of the formulation of abstract models. Besides a small early implementation experiment <ref> [8] </ref>, little implementation work has been done. We are currently investigating the possibility to extend Haskell with data fields.
Reference: [9] <author> Per Hammarlund and Bjorn Lisper. </author> <title> On the relation between functional and data parallel programming languages. </title> <booktitle> In Proc. Sixth Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 210-222. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1993. </year>
Reference-contexts: The goal is to provide a model with a uniform semantics over a wide range of structures, which is flexible, expressive and not boxed in by the idiosyncrasies of a certain kind of structure. Some papers on the data field model have been published. The early <ref> [9] </ref> gives an account of the data-structure-as-partial-function view and uses an informal met-alanguage for partial functions to define common operations on data structures as operations on partial functions. <p> Parallel write is not so straightforward to model, due to its nondeterministic nature, but certain deterministic variants can be defined with the aid of reduction <ref> [9, 15] </ref>. * Replication is -abstraction with respect to a fresh variable. <p> a partial function f w.r.t. the predicate b is defined viz.: f n b = x:if (b (x ); f (x ); fl). * Reduction, finally, can be expressed through a simple recursion, if the size of the index set as well as an enumeration of this set is provided <ref> [9, 15] </ref>. 3 It should now be fairly obvious how the three syntactical styles for operations on indexed data structures in Sect. 1.1 appear in our metalanguage for partial functions.
Reference: [10] <author> W. Daniel Hillis and Guy L. Steele, Jr. </author> <title> Data parallel algorithms. </title> <journal> Comm. ACM, </journal> <volume> 29(12) </volume> <pages> 1170-1183, </pages> <month> December </month> <year> 1986. </year> <month> 9 </month>
Reference-contexts: Since the time of APL [5] it has been recognized that a programming model which provides operations directly on data structures can be very convenient. The data parallel programming model <ref> [10] </ref> is an exponent of this style (albeit often with a close connection to some underlying parallel architecture providing support for these operations).
Reference: [11] <author> Jan Willem Klop. </author> <title> Combinatory Reduction Systems. </title> <type> PhD thesis, </type> <institution> CWI, Ams--terdam, </institution> <year> 1980. </year> <note> Mathematical Centre Tracts Nr. 127. </note>
Reference-contexts: We define '-abstraction to propagate bounds similar to the laws for explicit restriction in Sect. 2.2. The semantics of '-abstraction over a given host language is given as a higher order rewrite system (R) (a Combinatory Reduction System, or CRS <ref> [11, 12] </ref>).
Reference: [12] <author> Jan Willem Klop, Vincent van Oostrom, and Femke van Raamsdonk. </author> <title> Com-binatory reduction systems: Introduction and survey. </title> <journal> Theoret. Comput. Sci., </journal> <volume> 121 </volume> <pages> 279-308, </pages> <year> 1993. </year>
Reference-contexts: We define '-abstraction to propagate bounds similar to the laws for explicit restriction in Sect. 2.2. The semantics of '-abstraction over a given host language is given as a higher order rewrite system (R) (a Combinatory Reduction System, or CRS <ref> [11, 12] </ref>).
Reference: [13] <author> Bjorn Lisper. </author> <title> Data parallelism and functional programming. </title> <editor> In Guy-Renee Per-rin and Alain Darte, editors, </editor> <title> The Data Parallel Programming Model: Foundations, HPF Realization, </title> <journal> and Scientific Applications, </journal> <volume> Vol. </volume> <booktitle> 1132 of Lecture Notes in Comput. Sci., </booktitle> <pages> pages 220-251, </pages> <address> Les Menuires, France, March 1996. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: In [14] an abstract interpretation called extent analysis is developed, which can find the domain of definition for certain recursively defined partial functions. A tutorial on the early data field model of indexed data structures as partial functions is found in <ref> [13] </ref>. This position paper gives a short account for the present data field model which is presented in full detail in [15]. 1.1 Operations on indexed data structures Which operations on indexed data structures are there, then? One can distinguish five major groups of operations which occur throughout.
Reference: [14] <author> Bjorn Lisper and Jean-Francois Collard. </author> <title> Extent analysis of data fields. </title> <editor> In Bau-douin Le Charlier, editor, </editor> <booktitle> Proc. International Symposium on Static Analysis, Vol. 864 of Lecture Notes in Comput. Sci., </booktitle> <pages> pages 208-222, </pages> <address> Namur, Belgium, </address> <month> September </month> <year> 1994. </year> <note> Springer-Verlag. </note>
Reference-contexts: Some papers on the data field model have been published. The early [9] gives an account of the data-structure-as-partial-function view and uses an informal met-alanguage for partial functions to define common operations on data structures as operations on partial functions. In <ref> [14] </ref> an abstract interpretation called extent analysis is developed, which can find the domain of definition for certain recursively defined partial functions. A tutorial on the early data field model of indexed data structures as partial functions is found in [13].
Reference: [15] <author> Bjorn Lisper and Per Hammarlund. </author> <title> The data field model. </title> <note> Submitted., </note> <year> 1998. </year>
Reference-contexts: A tutorial on the early data field model of indexed data structures as partial functions is found in [13]. This position paper gives a short account for the present data field model which is presented in full detail in <ref> [15] </ref>. 1.1 Operations on indexed data structures Which operations on indexed data structures are there, then? One can distinguish five major groups of operations which occur throughout. Elementwise applied operations apply a "scalar" operation f to every element in a data structure A. <p> It is thus distinct from the bottom element ? although it is supposed to have similar algebraic properties, i.e., strict functions are supposed to be strict in fl as well (some complications will however arise for operations strict in more than one argument <ref> [15] </ref>). For any function f : D ! D 0 where fl 2 D 0 we define the index set of f as the set of all x 2 D such that x is a total, compact element and f (x) 6= ?. <p> Parallel write is not so straightforward to model, due to its nondeterministic nature, but certain deterministic variants can be defined with the aid of reduction <ref> [9, 15] </ref>. * Replication is -abstraction with respect to a fresh variable. <p> a partial function f w.r.t. the predicate b is defined viz.: f n b = x:if (b (x ); f (x ); fl). * Reduction, finally, can be expressed through a simple recursion, if the size of the index set as well as an enumeration of this set is provided <ref> [9, 15] </ref>. 3 It should now be fairly obvious how the three syntactical styles for operations on indexed data structures in Sect. 1.1 appear in our metalanguage for partial functions. <p> : : ; f n n b n ) = g (f 1 ; : : : ; f n ) n (b 1 ^ : : : ^ b n ) (4) It is possible to find conditions under which (4) holds also when fl and ? are distinguished <ref> [15] </ref>. <p> The complexity is motivated by the need to perform operations on array- and array-like data like transposition, selection of a row or column, etc., which are covered by our definition. The details are found in <ref> [15] </ref>. As an example, consider B ((f; b) ! (c; x 3 ; x 2 ; x 2 ); (x 1 ; x 2 ; x 3 ); ;), where b = fi 4 (b 1 ; b 2 ; b 3 ; b 4 ). <p> Some more developed examples are given in <ref> [15] </ref>. 3.3 Bounds for Sparse and Dense Arrays As an example how the data fields can go beyond traditional arrays, we define domains of array bounds B arr (int n ) for array-like mixed sparse-dense data fields: B fin arr (int ) = (int fi int ) + List int + <p> All other bounds in B arr (int n ) are infinite. Exact definitions for [[ ]], size, enum, u and t are given in <ref> [15] </ref>. For a simple case, see Fig 2. 8 4 Ongoing Work Our work so far has mainly consisted of the formulation of abstract models. Besides a small early implementation experiment [8], little implementation work has been done. We are currently investigating the possibility to extend Haskell with data fields.
Reference: [16] <author> Gordon Plotkin. </author> <title> LCF considered as a programming language. </title> <journal> Theoret. Com-put. Sci., </journal> <volume> 5(3) </volume> <pages> 223-256, </pages> <month> December </month> <year> 1977. </year>
Reference-contexts: If we add recursion we have a PCF-like language <ref> [16] </ref>.
Reference: [17] <author> Stephen K. Skedzielewski. </author> <title> Sisal. </title> <editor> In Boleslaw K. Szymanski, editor, </editor> <booktitle> Parallel Functional Languages and Compilers, chapter 4, </booktitle> <pages> pages 105-157. </pages> <publisher> Addison-Wesley, </publisher> <year> 1991. </year>
Reference-contexts: The data parallel programming model [10] is an exponent of this style (albeit often with a close connection to some underlying parallel architecture providing support for these operations). Modern array- and data parallel languages like Fortran 90 [3], High Performance Fortran (HPF) [7], NESL [2], and Sisal <ref> [6, 17] </ref> provide support, as well as many functional languages which have a rich set of list operations corresponding to the array- and data parallel operations.
Reference: [18] <author> Claes Thornberg. </author> <title> Polymorphic type inference with elemental function overloading. Licentiate Proposal, </title> <month> June </month> <year> 1997. </year> <month> 10 </month>
Reference-contexts: In Haskell, this overloading could be defined on a per-operator basis but it would be nice to have it automatically available for all functions, including user-defined ones. We are currently working on a modified Hindley-Milner type system which provides this <ref> [18] </ref>.
References-found: 18

