URL: http://www.cs.purdue.edu/research/cse/papers/theses/saw-phd.ps.Z
Refering-URL: http://www.cs.purdue.edu/research/cse/pdelab/hrefs.html
Root-URL: http://www.cs.purdue.edu
Title: PROBLEM SOLVING ENVIRONMENTS FOR PARTIAL DIFFERENTIAL EQUATION BASED APPLICATIONS  
Author: by Sanjiva Weerawarana 
Degree: A Thesis Submitted to the Faculty of  In Partial Fulfillment of the Requirements for the Degree of Doctor of Philosophy  
Date: August 1994  
Affiliation: Purdue University  
Abstract-found: 0
Intro-found: 1
Reference: <institution> 157 BIBLIOGRAPHY </institution>
Reference: [AB94] <author> V. Anupam and C. Bajaj. Shastra: </author> <title> An architecture for development of collaborative applications. </title> <journal> International Journal of Intelligent and Cooperative Information Systems, </journal> <note> 1994. to appear. </note>
Reference-contexts: Other protocols supported may include the Shastra protocol, the communication protocol used in the Shastra project <ref> [AB94] </ref>. Supporting this protocol would allow PDELab clients to communicate with Shastra clients directly. The services provided by PDEBus to clients can be categorized into three groups: location services, process management services and messaging services.
Reference: [AM90] <author> M. Ader and S. McMahon. </author> <title> The ITHACA technology: A landscape for object-oriented application development. </title> <booktitle> In ESPRIT '90 Conference Proceedings, </booktitle> <pages> pages 31-51. </pages> <publisher> Kluwer Academic Publishers, </publisher> <year> 1990. </year>
Reference-contexts: ABE was designed to support the development of intelligent systems, where intelligent systems are defined as large-scale software systems that reuse and integrate knowledge-based and conventional systems. It has been used successfully in the development of a Pilot's Assistant program. The ITHACA <ref> [AM90] </ref> object-oriented application development environment is a PSE framework designed for C* applications such as Computer Aided Design (CAD) and Computer Aided Manufacturing (CAM).
Reference: [Bar86] <author> Ray Bareiss. </author> <title> Exemplar-Based Knowledge Analysis. </title> <publisher> Academic Press, </publisher> <year> 1986. </year>
Reference-contexts: The knowledge base (KB) of PYTHIA consists of a priori defined rules and facts together with a posteriori ones derived from the known data (DB, H, P) using the exemplar-based knowledge acquisition and learning approach <ref> [Bar86] </ref>. PYTHIA's inference strategy consists of matching the characteristics of the given PDE problems with those of one PDE problem P 0 in P or a subclass S 2 P.
Reference: [BBP + 92] <author> P. Baras, J. Blum, J. C. Paumier, P. Witomski, and F. Rechenmann. EVE: </author> <title> An object-centered knowledge-based PDE solver. </title> <editor> In E. N. Houstis, J. R. Rice, and R. Vichnevetsky, editors, </editor> <booktitle> Expert Systems for Scientific Computing, </booktitle> <pages> pages 1-18. </pages> <publisher> North-Holland, </publisher> <year> 1992. </year>
Reference-contexts: While this generally provides more latitude for reasoning than in other cases (as detail understanding of the numerical methods are then available), solution capabilities of such systems are limited due to the difficultly (in terms of human cost) of performing this tight coupling (e.g., EVE <ref> [BBP + 92] </ref>). In other cases, the knowledge-based analysis behaves as a preprocessor to an interactive or language based system (e.g., Elliptic Expert [DG89]). Table 1.1 lists some example existing systems that belong to each category described above. 7 Table 1.1 Classification of existing PDE solving systems.
Reference: [BD90] <author> John Bonomo and Wayne Dyksen. XELLPACK: </author> <title> An interactive problem solving environment for elliptic partial differential equations. </title> <editor> In E. N. Houstis, J. R. Rice, and R. Vichnevetsky, editors, </editor> <booktitle> Intelligent Mathematical Software Systems, </booktitle> <pages> pages 331-342. </pages> <publisher> North-Holland, </publisher> <year> 1990. </year>
Reference-contexts: High level languages for PDE problem and solution scheme specification are almost as old as are high-level languages themselves [CK70]. More modern languages include the ELLPACK family of languages <ref> [RB85, HRC + 90, BD90] </ref>, the closely related PDE/PROTRAN language [IMS86], the DEQSOL language of PDEQSOL [Hit90] and others such as the object-oriented model developed by Ruppelt and Wirtz [RW89] and more application dependent systems such as Thornburg's PDE compiler [Tho89].
Reference: [BDG + 92] <author> Adam Beguelin, Jack Dongarra, Al Geist, Robert Manchek, and Vaidy Sunderam. </author> <title> A users' guide to PVM: Parallel virtual machine. </title> <type> Technical Report ORNL/TM-11826, </type> <institution> Engineering Physics and Mathematics Division, Mathematical Sciences Section, Oak Ridge National Laboratory, </institution> <year> 1992. </year>
Reference-contexts: Let us classify existing distributed communication environments into three classes and then address this question in the context of each class: * message passing libraries (e.g., PVM <ref> [BDG + 92] </ref>, PICL [GHPW92] and ISIS [Bir91]) * distributed computing environments (e.g., Sun's ONC [Sun91] and ToolTalk [Sun93] and OSF's DCE [Fou92]) * software bus systems (e.g., Glish [PS93], Polylith [Pur94]) The message passing libraries generally provide send () and recv () primitives for transmitting byte sequences between processes running
Reference: [BG92] <author> C. Bischoff and A. Griewank. ADIFOR: </author> <title> A FORTRAN system for portable automatic differentiation. </title> <type> Technical Report MCS-P317-0792, </type> <institution> Mathematics and Computer Science Division, Argonne National Laboratory, </institution> <year> 1992. </year>
Reference-contexts: PDESpec automatically generates the Jacobian in any desired representation by using the symbolic 73 differentiation capabilities of MACSYMA. In some cases, when user-defined functions are part of the PDE operator, automatic differentiation <ref> [BG92] </ref> is needed as well.
Reference: [BH92] <author> Douglas C. Beethe and William L. Hunt. </author> <title> A visual engineering environment for test software development. </title> <journal> Hewlett-Packard Journal, </journal> <pages> pages 72-77, </pages> <year> 1992. </year> <month> 158 </month>
Reference-contexts: With this revolution comes the need to integrate these diverse paradigms into cohesive systems that scientists can use to achieve their scientific ideals. While hardware/software for controlling laboratory instrumentation, gathering data and for analyzing that data generally exists today (see for example [Nat92] and <ref> [BH92] </ref>), there has been little work on integrating experimentation and computation in one cohesive environment. The general state-of-the-art in such integration is to manually (off-line) understand and apply the interactions between them (see for example [CWW91a] and [TK89]).
Reference: [Bir91] <author> Kenneth P. Birman. </author> <title> The process group approach to reliable distributed computing. </title> <type> Technical Report TR91-1216, </type> <institution> Department of Computer Science, Cornell University, </institution> <year> 1991. </year>
Reference-contexts: Let us classify existing distributed communication environments into three classes and then address this question in the context of each class: * message passing libraries (e.g., PVM [BDG + 92], PICL [GHPW92] and ISIS <ref> [Bir91] </ref>) * distributed computing environments (e.g., Sun's ONC [Sun91] and ToolTalk [Sun93] and OSF's DCE [Fou92]) * software bus systems (e.g., Glish [PS93], Polylith [Pur94]) The message passing libraries generally provide send () and recv () primitives for transmitting byte sequences between processes running on different machines.
Reference: [Bis88] <author> R. Bisiani. </author> <title> A software and hardware environment for developing AI applications on parallel processors. </title> <editor> In Alan H. Bond and Les Gasser, editors, </editor> <booktitle> Readings in Distributed Artificial Intelligence, </booktitle> <pages> pages 451-456. </pages> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <year> 1988. </year>
Reference-contexts: Several application specific workbenches consisting of SIBs have been constructed. 20 Other application development frameworks include Explorer [Sil92], Agora <ref> [Bis88] </ref>, Mathematica [Wol88] and Maple [Gro87]. 2.2.3 Software Bus Environments While the idea of a software bus is not recent, it appears that the implementation of the idea is recently becoming more and more popular (see for example [PAP + 89], [SG93], [OPSS93], [HGJ + 89] and [MV88]).
Reference: [BL93] <author> T. Berners-Lee. </author> <title> Uniform Resource Locators: A unifying syntax for the expression of names and addresses of objects on the network. (Draft) Internet RFC from http://info.cern.ch at hypertext/WWW/Addressing/URL/Overview.html, </title> <year> 1993. </year>
Reference-contexts: The services provided by PDEBus to clients can be categorized into three groups: location services, process management services and messaging services. For client and object location purposes, a global naming scheme based on uniform resource locators 29 (URLs) <ref> [BL93] </ref>, a highly flexible emerging standard for naming arbitrary resources, is used. The software bus provides various directory services with URLs being the naming standard.
Reference: [BRH79] <author> Ronald F. Boisvert, John R. Rice, and Elias N. Houstis. </author> <title> A system for performance evaluation of partial differential equations software. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-5(4):418-425, </volume> <year> 1979. </year>
Reference-contexts: The population has been structured by introducing measures of complexity of the operator, boundary conditions, solution and problem. Figure 4.1 shows an example problem from the PDE population. The actual implementation of this population is reported in <ref> [BRH79] </ref>. The population also contains information about the properties of the problems. <p> True unknown Operator Self-adjoint, discontinuous coefficients Right Side Constant Boundary Conditions Dirichlet, homogeneous Solution Approximate solutions given for ff = 1; 10; 100: Strong wave fronts for ff 1: Parameter ff adjusts size of discontinuity in operator coefficients which introduces large, sharp jumps in solution. 93 Performance Evaluation System (PES) <ref> [BRH79] </ref>. These properties are transferred to the PYTHIA characteristic vector representation by an automated procedure explained later in Section 4.8. Characteristics not identified in the ELLPACK PES are identified by the characteristic extraction component of PYTHIA. <p> These profiles are generated by linear least squares approximation to raw performance data. The above three types of performance profiles are currently generated by the performance evaluation system (PES) system <ref> [BRH79] </ref>. For example, Figure 4.2 shows the raw performance data and Figure 4.3 displays the dofs vs. time profiles for seven //ELLPACK solvers on a problem from the PDE population P.
Reference: [BWZW91] <author> J. A. Berninger, R. D. Whitley, X. Zhang, and N.-H. L. Wang. </author> <title> A Versatile model for simulation of reaction and nonequlibrium dynamics in multicomponent fixed-bed adsorption processes. </title> <journal> Computers in Chemical Engineering, </journal> <volume> 15(11) </volume> <pages> 749-768, </pages> <year> 1991. </year>
Reference-contexts: Bioseparation is the process for separating a compound solution into its constituent parts by passing it through an absorbent column so that each component adsorbs to the surface differently from the others, and thus eludes at different times <ref> [BWZW91] </ref>. This process is used in the purification of proteins and biochemicals, in the manufacture of pharmaceutical products, in water treatment, and in many other biochemical processes. The physical behavior of this process is mathematically modeled by a system of 1-D and 2-D nonlinear, time-dependent PDEs. <p> In light of those challenges, computer simulation of these 144 complex systems becomes very attractive. Experiments are still required, but feedback from computer modeling can greatly reduce the number of experiments needed to understand and optimize the process. In <ref> [BWZW91] </ref>, Berninger, Whitley, Zhang and Wang develop a versatile partial differential equation model for simulating reaction and nonequilibrium dynamics in multicomponent fixed-bed adsorption processes. Using this model and the corresponding implementation as a basis, we are developing an instance of the SoftLab environment for bioseparation processes. <p> the eluding concentrations and generates a trace on a strip chart recorder and also sends the information via a special card on the personal computer to the software running on that machine. 146 On the simulation side, the bioseparation group has a custom implementation of a numerical simulator called VERSE <ref> [BWZW91] </ref> that solves the experiment's model (partial differential) equations. Simulations are run on a Sun workstation and take on the order of hours to execute.
Reference: [CF63] <author> G. J. Culler and B. D. Fried. </author> <title> An on-line computing center for scientific problems. </title> <booktitle> In Proceedings of the IEEE Pacific Computer Conference, </booktitle> <pages> page 221, </pages> <year> 1963. </year>
Reference: [CK70] <author> A. F. Cardenas and W. J. Karplus. </author> <title> PDEL a language for partial differential equations. </title> <journal> Communications of the ACM, </journal> <volume> 13(3) </volume> <pages> 184-191, </pages> <month> March </month> <year> 1970. </year>
Reference-contexts: Symbolic manipulation of PDE operators, boundary conditions and even domains can transform seemingly intractable problems into problems that can be solved for example, by some iterative composition of existing solvers. High level languages for PDE problem and solution scheme specification are almost as old as are high-level languages themselves <ref> [CK70] </ref>. <p> We consider first those languages that have taken a program translation approach and then those that have taken a program generation approach. 3.2.1 Program Translation-Type Languages The earliest high-level PDE specification language is PDEL, the Partial Differential Equation Language <ref> [CK70] </ref>. The goal of PDEL was to significantly ease the (PDE) problem solving process by allowing users to specify the problem in a high level syntax which is automatically translated to a program in some other language.
Reference: [CW88] <author> Thomas Cooper and Nancy Wogrin. </author> <title> Rule-based programming with OPS5. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1988. </year>
Reference-contexts: CLIPS was originally only a forward chaining rule language based on the Rete algorithm (hence the production system part of the CLIPS acronym) <ref> [CW88] </ref>. However, it now supports two more programming paradigms: Procedural programming and object-oriented programming. The object-oriented programming language provided within CLIPS is called the CLIPS Object-Oriented Language (COOL).
Reference: [CWW91a] <author> K. E. Van Cott, R. D. Whitley, and N.-H. L. Wang. </author> <title> Effects of temperature and flow rate on frontal and elution chromatography of aggregating systems. </title> <journal> Separt. Technol., </journal> <volume> 1 </volume> <pages> 142-152, </pages> <year> 1991. </year>
Reference-contexts: The general state-of-the-art in such integration is to manually (off-line) understand and apply the interactions between them (see for example <ref> [CWW91a] </ref> and [TK89]). Our own PDELab work concentrates on building problem solving environments for the computational aspects 127 of a problem. In this work, we address the issues involved with building software environments that integrate experimentation and computation and describe a prototype implementation currently in progress.
Reference: [CWW91b] <author> K. E. Van Cott, R. D. Whitley, and N.-H. L. Wang. </author> <title> Effects of temperature and flow rate on frontal and elution chromatography of aggregating systems. </title> <journal> Separat. Technol., </journal> <volume> 1 </volume> <pages> 142-152, </pages> <year> 1991. </year>
Reference-contexts: Figure 5.5 illustrates this architecture. 142 143 5.6 SoftBioLab: The Bioseparation SoftLab Chromatography is the process of separating components in a fluid by passing a solution mixture through an absorbent column so that each component adsorbs to the surface differently than the others, and thus eludes at different times <ref> [CWW91b] </ref>. The process is used for a final purification of proteins, chemicals and biochemicals used for the manufacturing of pharmaceutical and food products, water treatment and many other biochemical processes. Chromatography of biological molecules is often quite complex, and many of the dynamic aspects are not well understood.
Reference: [DG89] <author> Wayne R. Dyksen and Carl R. Gritter. </author> <title> Elliptic expert: An expert system for elliptic partial differential equations. </title> <booktitle> Mathematics and Computers in Simulation, </booktitle> <volume> 31 </volume> <pages> 333-343, </pages> <year> 1989. </year> <month> 159 </month>
Reference-contexts: In other cases, the knowledge-based analysis behaves as a preprocessor to an interactive or language based system (e.g., Elliptic Expert <ref> [DG89] </ref>). Table 1.1 lists some example existing systems that belong to each category described above. 7 Table 1.1 Classification of existing PDE solving systems. <p> This particular expert system applies self-validating methods in an economical manner to systems of linear equations. Other expert systems that assist in the selection of an appropriate linear equation solver for a particular matrix are also currently being researched and developed. In <ref> [DG89, DG92] </ref>, Dyksen and Gritter describe an expert system for selecting solution methods for elliptic PDE problems based on problem characteristics. Problem characteristics are determined by textual parsing or with user interaction and are then used to select applicable solvers and to select the best solver.
Reference: [DG92] <author> Wayne R. Dyksen and Carl R. Gritter. </author> <title> Scientific computing and the algorithm selection problem. </title> <editor> In E. N. Houstis, J. R. Rice, and R. Vich-nevetsky, editors, </editor> <booktitle> Expert Systems for Scientific Computing, </booktitle> <pages> pages 19-31. </pages> <publisher> North-Holland, </publisher> <year> 1992. </year>
Reference-contexts: This particular expert system applies self-validating methods in an economical manner to systems of linear equations. Other expert systems that assist in the selection of an appropriate linear equation solver for a particular matrix are also currently being researched and developed. In <ref> [DG89, DG92] </ref>, Dyksen and Gritter describe an expert system for selecting solution methods for elliptic PDE problems based on problem characteristics. Problem characteristics are determined by textual parsing or with user interaction and are then used to select applicable solvers and to select the best solver.
Reference: [DHHW93] <author> Jack. J. Dongarra, Rolf Hempel, Anthony J. G. Hey, and David W. Walker. </author> <title> A proposal for a user-level message passing interface in a distributed memory environment. </title> <type> Technical Report ORNL/TM-12231, </type> <institution> Oak Ridge National Laboratory, </institution> <year> 1993. </year>
Reference-contexts: PDEVpe is a framework within the PDELab environment which provides a platform for developing portable parallel PDE solvers, along with facilities and tools for analyzing their performance. PDEVpe includes parallel computational kernels such as the basic linear algebra subroutines (BLAS), portable communication libraries such as MPI <ref> [DHHW93] </ref> and PICL [GHPW92], parallel languages such as HPF [KLS + 94], parallelizing methodologies for re-using sequential code in a parallel environment, geometry and matrix partitioning tools, instrumentation tools and skeletons (templates) for parallel methods such as PTS [WH94]. 2.4.3 PSE Development Framework This upper layer of the PDELab architecture provides
Reference: [DRR88] <author> Wayne R. Dyksen, Calvin J. Ribbens, and John R. Rice. </author> <title> The performance of numerical methods for elliptic problems with mixed boundary conditions. Numerical Methods for Partial Differential Equations, </title> <booktitle> 4 </booktitle> <pages> 347-361, </pages> <year> 1988. </year>
Reference-contexts: In some instances these rules have general acceptance 101 while in many others these rules are subject to opinion. We plan to incorporate rules of this type that are the results of some a posteriori analysis <ref> [HR82, DRR88] </ref>. 4.5 The Inference Algorithm There are two significant parts of PYTHIA: the learning process and the selection task or the inference algorithm. In this section we address the latter.
Reference: [ELHR88] <author> L. D. Erman, J. S. Lark, and F. Hayes-Roth. Abe: </author> <title> An environment for engineering intelligent systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14 </volume> <pages> 1758-1770, </pages> <year> 1988. </year>
Reference-contexts: However, the idea of such frameworks for other application domains has been implemented in several cases. ABE <ref> [ELHR88] </ref> is a programming environment supporting the abstraction "Module Oriented Programming" (MOP). MOP is somewhat similar to object-oriented programming, except that a module in ABE also has a thread of control.
Reference: [Fou92] <author> Open Software Foundation. </author> <title> Distributed computing environment: An overview. </title> <type> Technical report, OSF, </type> <month> January </month> <year> 1992. </year>
Reference-contexts: Let us classify existing distributed communication environments into three classes and then address this question in the context of each class: * message passing libraries (e.g., PVM [BDG + 92], PICL [GHPW92] and ISIS [Bir91]) * distributed computing environments (e.g., Sun's ONC [Sun91] and ToolTalk [Sun93] and OSF's DCE <ref> [Fou92] </ref>) * software bus systems (e.g., Glish [PS93], Polylith [Pur94]) The message passing libraries generally provide send () and recv () primitives for transmitting byte sequences between processes running on different machines.
Reference: [GHPW92] <author> G. A. Geist, M. T. Heath, B. W. Peyton, and P. H. Worley. </author> <title> A users' guide to PICL: A portable instrumented communication library. </title> <type> Technical Report ORNL/TM-11616, </type> <institution> Engineering Physics and Mathematics Division, Mathematical Sciences Section, Oak Ridge National Laboratory, </institution> <year> 1992. </year>
Reference-contexts: PDEVpe is a framework within the PDELab environment which provides a platform for developing portable parallel PDE solvers, along with facilities and tools for analyzing their performance. PDEVpe includes parallel computational kernels such as the basic linear algebra subroutines (BLAS), portable communication libraries such as MPI [DHHW93] and PICL <ref> [GHPW92] </ref>, parallel languages such as HPF [KLS + 94], parallelizing methodologies for re-using sequential code in a parallel environment, geometry and matrix partitioning tools, instrumentation tools and skeletons (templates) for parallel methods such as PTS [WH94]. 2.4.3 PSE Development Framework This upper layer of the PDELab architecture provides application PSE developers <p> Let us classify existing distributed communication environments into three classes and then address this question in the context of each class: * message passing libraries (e.g., PVM [BDG + 92], PICL <ref> [GHPW92] </ref> and ISIS [Bir91]) * distributed computing environments (e.g., Sun's ONC [Sun91] and ToolTalk [Sun93] and OSF's DCE [Fou92]) * software bus systems (e.g., Glish [PS93], Polylith [Pur94]) The message passing libraries generally provide send () and recv () primitives for transmitting byte sequences between processes running on different machines.
Reference: [GHR92] <author> Stratis Gallopoulos, Elias Houstis, and John Rice. </author> <title> Future research directions in problem solving environments for computational science. </title> <type> Technical Report CSD-TR-92-032, </type> <institution> Department of Computer Sciences, Pur-due University, </institution> <year> 1992. </year>
Reference-contexts: general, the PSE technology is expected to reduce the time between an idea and validation of the discovery, to get a "quick" answer to almost any question that has a readily computed answer, support programming-in-the-large, provide "knowbots" (intelligent agents) that implement various scientific problem solving processes, and allow easy prototyping <ref> [GHR92] </ref>. We describe the design of a software platform (PDELab) for the development of PSEs for PDE based applications that realize to a degree some of the above expectations. PDELab consists of three layers. <p> 85 PYTHIA's framework and methodology is general and applicable to any class of PDE problems and solvers. 4.1 Introduction It has been predicted that future problem solving environments will include at least by some form of intelligence and will provide some "natural" user interface within well defined domains of applications <ref> [GHR92] </ref>. The purpose of this study is to address the issue of intelligence within a specific class of applications that can be described by a mathematical model involving PDEs defined on general geometric regions. The design objectives and architecture of such PSEs are described in [WHR + 94b].
Reference: [Gia91] <author> J. C. Giarratano. </author> <note> CLIPS User's Guide, Version 5.1. </note> <editor> NASA Lyndon B. Johnson Space Center, </editor> <year> 1991. </year>
Reference-contexts: PYTHIA supports this type of "soft" reasoning by providing an environment where one can integrate rule and knowledge bases and associated reasoning systems. PYTHIA is accessed as a tool in the PDELab environment and is implemented with an embedded version of CLIPS <ref> [Gia91] </ref>. Chapter 4 discusses PYTHIA in more detail. 39 2.6.5 Component Composition A major step in building an application PSE with PDELab is combining a set of components together into a PSE using PDEBus. <p> These components exist as tools in the //ELLPACK system and are therefore accessible through //ELLPACK for general use. Both components of PYTHIA are implemented using CLIPS <ref> [Gia91] </ref>, an expert system development shell developed by NASA. 4.8.1 CLIPS: C Language Integrated Production System CLIPS is an expert system development shell implemented in C. CLIPS was originally only a forward chaining rule language based on the Rete algorithm (hence the production system part of the CLIPS acronym) [CW88].
Reference: [Gro77] <author> The MATHLAB Group. </author> <title> MACSYMA Reference Manual, </title> <type> Version 9. </type> <institution> Laboratory for Computer Science, M.I.T., </institution> <address> Cambridge, MA, </address> <year> 1977. </year>
Reference-contexts: We 2 MAXIMA is the Austin Kyoto Common Lisp version of the well-known computer algebra system MACSYMA <ref> [Gro77] </ref>. 35 ("Component's Functional Core") could itself be built using facilities of PDEVpe, PDEKit and PDEBus. <p> PDESpec supports both a compiled execution model and an interpreted execution model and its syntax is defined as an extension of that of the MACSYMA <ref> [Gro77] </ref> language. The MACSYMA parser is used to parse a PDE-Spec program and the compiler (implemented in MACSYMA, Common LISP and C) generates a program in FORTRAN using the GENCRAY [WW92] code generation package.
Reference: [Gro87] <institution> Symbolic Computation Group. Maple User's Manual. University of Waterloo, Department of Computer Science, Waterloo, Canada, </institution> <year> 1987. </year>
Reference-contexts: Several application specific workbenches consisting of SIBs have been constructed. 20 Other application development frameworks include Explorer [Sil92], Agora [Bis88], Mathematica [Wol88] and Maple <ref> [Gro87] </ref>. 2.2.3 Software Bus Environments While the idea of a software bus is not recent, it appears that the implementation of the idea is recently becoming more and more popular (see for example [PAP + 89], [SG93], [OPSS93], [HGJ + 89] and [MV88]).
Reference: [GS91] <author> L. Gross and P. Sternecker. </author> <title> The Finite Element Tool Package VECFEM. </title> <institution> University of Karlsruhe, </institution> <year> 1991. </year>
Reference-contexts: The most flexibility in terms of being adaptable to developing specific application environments is, of course, provided by the low-level library type systems. Examples of these systems include VECFEM <ref> [GS91] </ref>, PDECOL [MS79], PDETWO [MS81], FIDISOL [SSM85] and CADSOL [WSS92]. The price for flexibility is that one must develop all the related software necessary to build an application problem solving environment; not a trivial task by any measure. <p> The general (partial or ordinary) differential form is as a nonlinear function of the unknowns, the derivatives of the unknowns and the independent variables. In the variational formulation, the coefficient functions of all the components of the variational formulation must be entered as functions of the independent variables (see <ref> [GS91] </ref> for details). Other forms (which PDESpec does not as yet support) are integro-differential equations, and linear and nonlinear algebraic equations. Once the equations themselves have been specified, one must define the domains over which they hold.
Reference: [Ham62] <author> R. W. </author> <title> Hamming. Numerical Methods for Scientists and Engineers. </title> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <year> 1962. </year> <month> 160 </month>
Reference-contexts: A problem solving environment (PSE) is then a software environment that provides support for this entire process. That is, a PSE is a software environment that epitomizes Hamming's quote: "The purpose of computing is insight, not numbers." <ref> [Ham62] </ref>. 1.3.1 Properties of PSEs A key feature of PSEs is their ability to converse with the scientist in his/her own terms. For example, a PSE assisting a civil engineer must understand what "stress" means and should use that term when it communicates with the scientist.
Reference: [HGJ + 89] <author> D. E. Hall, W. H. Greiman, W. F. Johnston, A. X. Merola, S. C. Loken, and D. W. Robertson. </author> <title> The software bus: A vision for scientific software development. </title> <journal> Computer Physics Communications, </journal> <volume> 57 </volume> <pages> 211-216, </pages> <year> 1989. </year>
Reference-contexts: application development frameworks include Explorer [Sil92], Agora [Bis88], Mathematica [Wol88] and Maple [Gro87]. 2.2.3 Software Bus Environments While the idea of a software bus is not recent, it appears that the implementation of the idea is recently becoming more and more popular (see for example [PAP + 89], [SG93], [OPSS93], <ref> [HGJ + 89] </ref> and [MV88]). We very briefly review the Polylith and Glish systems below. The Polylith [Pur94] software bus is a software component decoupling agent. Software components are built using some abstract bus interface and the component's interface is specified using a "Module Interconnection Language" (MIL).
Reference: [Hib89] <author> Hibbitt, Karlsson & Sorensen, Inc. </author> <note> ABAQUS User's Manual, Version 4.8, </note> <year> 1989. </year>
Reference-contexts: Once the solution is available, the engineer may use the computed stress and displacement information to optimize the bridge design and finally generate a set of specifications that are sent to the builders. For these types of "standard" PDE models, there are commercially available software packages (for example, <ref> [Swa85, Mac91a, Hib89] </ref>) that have very good built-in solvers. They also include some "pre-processing" component that helps the engineer specify the material properties, etc. and a "post-processing" environment where the engineer can visualize solutions in terms of the effect on the particular design (s)he is working with.
Reference: [Hit90] <institution> Hitachi, Ltd., Computer Division. </institution> <note> PDEQSOL User's Manual, </note> <year> 1990. </year>
Reference-contexts: The price for flexibility is that one must develop all the related software necessary to build an application problem solving environment; not a trivial task by any measure. High level language based systems (for example, ELLPACK [RB85], DEQSOL <ref> [Hit90] </ref> and PDE/PROTRAN [IMS86]) and their recent interactive system counterparts, //ELLPACK [HRC + 90] and Visual DEQSOL [UKO92], provide significantly more functionality for the application developer. <p> High level languages for PDE problem and solution scheme specification are almost as old as are high-level languages themselves [CK70]. More modern languages include the ELLPACK family of languages [RB85, HRC + 90, BD90], the closely related PDE/PROTRAN language [IMS86], the DEQSOL language of PDEQSOL <ref> [Hit90] </ref> and others such as the object-oriented model developed by Ruppelt and Wirtz [RW89] and more application dependent systems such as Thornburg's PDE compiler [Tho89]. <p> The solution scheme is finite element type and all iterations, etc., are internally performed (i.e., there is no user level iteration scheme specification). The language translator generates a FORTRAN driver program which is linked with libraries to solve the problem. 3.2.2 Code Generation Based Languages PDEQSOL <ref> [Hit90] </ref> is a Japanese project with a similar vision as the ELLPACK and //ELLPACK systems. The DEQSOL language is a complete language that is compiled into vectorized FORTRAN by a compiler that performs various symbolic transformations on the operators.
Reference: [HR82] <author> E. N. Houstis and J. R. Rice. </author> <title> High order methods for elliptic partial differential equations with singularities. </title> <journal> International Journal for Numerical Methods in Engineering, </journal> <volume> 18 </volume> <pages> 737-754, </pages> <year> 1982. </year>
Reference-contexts: In some instances these rules have general acceptance 101 while in many others these rules are subject to opinion. We plan to incorporate rules of this type that are the results of some a posteriori analysis <ref> [HR82, DRR88] </ref>. 4.5 The Inference Algorithm There are two significant parts of PYTHIA: the learning process and the selection task or the inference algorithm. In this section we address the latter. <p> We used the class of problems studied in <ref> [HR82] </ref> as the test class which we denote by c. Then, we use different parts of c as a "training set" 3 to make predictions for the rest of c. In the first test, we use c 4 as a training set.
Reference: [HR92] <author> E. N. Houstis and J. R. Rice. </author> <title> Parallel ELLPACK: A development and problem solving environment for high performance computing machines. </title> <editor> In P. W. Gaffney and E. N. Houstis, editors, </editor> <booktitle> Programming Environments for High-Level Scientific Problem Solving, </booktitle> <pages> pages 229-243. </pages> <publisher> North-Holland, </publisher> <year> 1992. </year>
Reference-contexts: As a representative of this generation of software, we will consider the Purdue //ELLPACK system, which is generally considered to be the state-of-the-art in this area. The //ELLPACK PDE solving system <ref> [HRC + 90, HR92] </ref> evolved from the ELL-PACK [RB85] system. These systems have taken the approach of using a high level mathematical language to allow users to specify the particular mathematical model as well as how they want it solved.
Reference: [HRC + 90] <author> E. N. Houstis, J. R. Rice, N. P. Chrisochoides, H. C. Karathanasis, P. N. Papachiou, M. K. Samartzis, E. A. Vavalis, Ko-Yang Wang, and S. Weerawarana. </author> <title> //ELLPACK: A numerical simulation programming environment for parallel MIMD machines. </title> <editor> In J. Sopka, editor, </editor> <booktitle> Proceedings of Supercomputing '90, </booktitle> <pages> pages 96-107. </pages> <publisher> ACM Press, </publisher> <year> 1990. </year>
Reference-contexts: The price for flexibility is that one must develop all the related software necessary to build an application problem solving environment; not a trivial task by any measure. High level language based systems (for example, ELLPACK [RB85], DEQSOL [Hit90] and PDE/PROTRAN [IMS86]) and their recent interactive system counterparts, //ELLPACK <ref> [HRC + 90] </ref> and Visual DEQSOL [UKO92], provide significantly more functionality for the application developer. <p> As a representative of this generation of software, we will consider the Purdue //ELLPACK system, which is generally considered to be the state-of-the-art in this area. The //ELLPACK PDE solving system <ref> [HRC + 90, HR92] </ref> evolved from the ELL-PACK [RB85] system. These systems have taken the approach of using a high level mathematical language to allow users to specify the particular mathematical model as well as how they want it solved. <p> High level languages for PDE problem and solution scheme specification are almost as old as are high-level languages themselves [CK70]. More modern languages include the ELLPACK family of languages <ref> [RB85, HRC + 90, BD90] </ref>, the closely related PDE/PROTRAN language [IMS86], the DEQSOL language of PDEQSOL [Hit90] and others such as the object-oriented model developed by Ruppelt and Wirtz [RW89] and more application dependent systems such as Thornburg's PDE compiler [Tho89]. <p> Standard interfaces are defined between these modules with the goal of being a repository for contributor provided modules. The language is implemented as a translator that generates a FORTRAN program which is them linked with pre-written libraries to solve the problem at hand. The //ELLPACK 2 project <ref> [HRC + 90] </ref> started with extending the ELLPACK system to support parallelism but has evolved into a complete interactive problem solving environment. <p> We apply an expert system methodology based on the so-called exemplar reasoning approach. In this chapter we describe the PYTHIA expert system that implements this methodology within the domain of applicability of the parallel ELLPACK library <ref> [HRC + 90] </ref> that includes the sequential ELLPACK [RB85] modules. PYTHIA's reasoning approach is based on the performance profiles of various ELLPACK solvers observed for a population of a priori determined elliptic PDE problems. <p> For type characteristics (for example, Laplace and Dirichlet), we assign binary values to the related entries of the 91 characteristic vector. The type characteristics can be easily extracted by parsing the representation of (4.1) described in Chapters 2 and 3. This is done within the PSE environment (see //ELLPACK <ref> [HRC + 90] </ref>). The identification of the mathematical behavior of the functions is a much harder problem. Depending on their assumed representation, this information can be extracted by symbolic, numeric and imagistics (computational vision) techniques.
Reference: [HRCV88] <author> E. N. Houstis, J. R. Rice, C. C. Christara, and E. A. Vavalis. </author> <title> Performance of scientific software. </title> <editor> In J. R. Rice, editor, </editor> <booktitle> Mathematical Aspects of Scientific Software, </booktitle> <pages> pages 123-155. </pages> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: This vector represents the centroid of all the member problems. 4.4.2 Rules This information is characterized by some level of uncertainty or degree of confidence and it is usually derived by some approximate analysis <ref> [HRCV88] </ref> or provided by an expert. In order to control the level of uncertainty, PYTHIA also develops rules for specified classes of problems and applicable methods from the performance knowledge acquired through actual runs of methods for each member of the class.
Reference: [HRW94] <author> Elias N. Houstis, John R. Rice, and Sanjiva Weerawarana. </author> <title> An open structure for PDE solving systems. </title> <booktitle> In Proceedings of the 14th IMACS World Congress on Computation and Applied Mathematics, </booktitle> <year> 1994. </year> <note> to appear. </note>
Reference-contexts: Furthermore, textual representations allow easy modifications to produce similar models. In terms of solution schemes, having a language for expressing algorithms allow users to combine PDE solving software parts to build complex solution strategies that were not previously available <ref> [HRW94, Ric89] </ref>.
Reference: [HRWH94] <author> E. N. Houstis, J. R. Rice, S. Weerawarana, and C. E. Houstis. </author> <title> PYTHIA: A computationally intelligent paradigm to support smart problem solving environments for PDE based applications. </title> <note> 1994. to appear. </note>
Reference-contexts: At this level, application PSE developers compose new PSEs by combining together components from PDELab and the application specific components they implement using PDELab provided development tools. This framework consists of several subsystems: PDE object editing tools, a graphical worksheet editor, the PDESpec language and associated tools, the PYTHIA <ref> [HRWH94] </ref> reasoning environment, the composer, and of course the developer's kit described earlier. We 2 MAXIMA is the Austin Kyoto Common Lisp version of the well-known computer algebra system MACSYMA [Gro77]. 35 ("Component's Functional Core") could itself be built using facilities of PDEVpe, PDEKit and PDEBus.
Reference: [IK79] <author> L. Imre and T. Kornyey. </author> <title> Applied Numerical Methods. </title> <publisher> Academic Press, </publisher> <year> 1979. </year>
Reference-contexts: From page 768 of <ref> [IK79] </ref> we quote: Salami is modelled by a hygroscopically covered homogeneous and isotropic equivalent colloidal material by interpreting the water concentration as a distributed parameter based on the dry mass. The sorption equilibrium of the salami is determined by the state of the casing in the given air-technical surroundings.
Reference: [IMS86] <institution> IMSL, Inc. </institution> <note> PDE/PROTRAN User's Manual, </note> <year> 1986. </year>
Reference-contexts: The price for flexibility is that one must develop all the related software necessary to build an application problem solving environment; not a trivial task by any measure. High level language based systems (for example, ELLPACK [RB85], DEQSOL [Hit90] and PDE/PROTRAN <ref> [IMS86] </ref>) and their recent interactive system counterparts, //ELLPACK [HRC + 90] and Visual DEQSOL [UKO92], provide significantly more functionality for the application developer. <p> High level languages for PDE problem and solution scheme specification are almost as old as are high-level languages themselves [CK70]. More modern languages include the ELLPACK family of languages [RB85, HRC + 90, BD90], the closely related PDE/PROTRAN language <ref> [IMS86] </ref>, the DEQSOL language of PDEQSOL [Hit90] and others such as the object-oriented model developed by Ruppelt and Wirtz [RW89] and more application dependent systems such as Thornburg's PDE compiler [Tho89]. <p> The basic execution philosophy of the language was not changed however. The PDE/PROTRAN <ref> [IMS86] </ref> system is a high level problem solving environment for solving systems of linear or nonlinear elliptic and parabolic PDEs in general 2-dimensional domains. The PDE/PROTRAN language is similar in spirit to the ELLPACK language and is implemented as an extension of FORTRAN.
Reference: [JP92] <author> G. O. Cook Jr. and J. F. Painter. </author> <title> ALPAL: A tool to generate simulation codes from natural descriptions. </title> <editor> In E. N. Houstis, J. R. Rice, and R. Vichnevetsky, editors, </editor> <booktitle> Expert Systems for Scientific Computing, </booktitle> <pages> pages 401-420. </pages> <publisher> North-Holland, </publisher> <year> 1992. </year> <month> 161 </month>
Reference-contexts: Most of these languages are non-symbolic in their manipulation of the PDE problem and tend to be direct translators from the mathematical representation to a run-time representation in a traditional imperative language. There are also systems that take a purely symbolic view; see for example <ref> [JP92] </ref> and [Wan86]. In these systems, the mathematical models are translated into an imperative language by performing most of the discretizations directly in the symbolic environments. That is, they tend to apply a pure program generation approach rather than the (mostly) pure program translation approach taken by the other systems. <p> Two-dimensional domains can be described textually in PDEQSOL while an interface to a CAD system is supported for 3-dimensional domains. The compiler is implemented in Pascal. ALPAL (A Livermore Physics Application Language) <ref> [JP92] </ref> is a system that automatically generates FORTRAN or C code to solve nonlinear integro-differential equations. The ALPAL language allows users to specify the equations in a symbolic manner and applies difference operators and quadrature rules to generate the resulting code.
Reference: [KDMW92] <author> E. Kant, F. Daube, W. MacGregor, and J. Wald. </author> <title> Knowledge-based program generation for mathematical modeling. </title> <editor> In E. N. Houstis, J. R. Rice, and R. Vichnevetsky, editors, </editor> <booktitle> Expert Systems for Scientific Computing, </booktitle> <pages> pages 371-392. </pages> <publisher> North-Holland, </publisher> <year> 1992. </year>
Reference-contexts: Logically rectangular grids on arbitrary dimensions are supported with either built-in or user-defined difference operators. ALPAL also generates Jacobian matrices and allows the use of external packages for solving systems of equations, for example. The system is implemented in MACSYMA. SINAPSE <ref> [KDMW92] </ref> is a program synthesis system that generates numerical code for solving PDE or matrix equations using symbolic discretization. SINAPSE is implemented on top of Mathematica [Wol88] and uses a custom syntax for describing the PDE operators.
Reference: [KLS + 94] <author> C. H. Koelbel, D. B. Loveman, R. S. Schreiber, G. L. Steel Jr., and M. E. Zosel. </author> <title> The High Performance Fortran Handbook. </title> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: PDEVpe includes parallel computational kernels such as the basic linear algebra subroutines (BLAS), portable communication libraries such as MPI [DHHW93] and PICL [GHPW92], parallel languages such as HPF <ref> [KLS + 94] </ref>, parallelizing methodologies for re-using sequential code in a parallel environment, geometry and matrix partitioning tools, instrumentation tools and skeletons (templates) for parallel methods such as PTS [WH94]. 2.4.3 PSE Development Framework This upper layer of the PDELab architecture provides application PSE developers with a collection of tools and
Reference: [KME93] <author> M. S. Kamel, K. S. Ma, and W. H. Enright. ODEXPERT: </author> <title> An expert system to select numerical solvers for initial value ode systems. </title> <journal> ACM Transactions on Mathematical Software, </journal> <volume> 19(1) </volume> <pages> 44-62, </pages> <year> 1993. </year>
Reference-contexts: We argue that using problem characteristics solely is not sufficient because the characterization of a problem includes many symbolically and a priori immeasurable quantities, and also because practical software performance depends not only on the algorithms used, but on the particular implementations of those algorithms as well. 88 In <ref> [KME93] </ref> Kamel et. al. describe an expert system called ODEXPERT for selecting numerical solvers for initial value ordinary differential equation (ODE) systems. ODEXPERT uses textual parsing to determine some properties of the ODEs and performs some automatic tests (e.g., a stiffness test) to determine others.
Reference: [KR68] <author> M. Klerer and J. Reinfelds. </author> <title> Interactive Systems for Experimental Applied Mathematics. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1968. </year>
Reference: [KU90] <author> S. Konig and C. Ullrich. </author> <title> An expert system for the economical application of self-validating methods for linear equations. </title> <editor> In E. N. Houstis, J. R. Rice, and R. Vichnevetsky, editors, </editor> <booktitle> Intelligent Mathematical Software Systems, </booktitle> <pages> pages 195-220. </pages> <publisher> North-Holland, </publisher> <year> 1990. </year>
Reference-contexts: The refinement process is guided by various "refinement indicators" and refinement is affected by one of three mesh enrichment strategies. At the other end of the PDE solution process, expert systems such as <ref> [KU90] </ref> can be used to guide the internals of a linear system solver. This particular expert system applies self-validating methods in an economical manner to systems of linear equations.
Reference: [Mac91a] <author> MacNeal-Schwendler Corporation. </author> <title> MSC/NASTRAN User's Manual, </title> <booktitle> Volume 1, </booktitle> <year> 1991. </year>
Reference-contexts: Once the solution is available, the engineer may use the computed stress and displacement information to optimize the bridge design and finally generate a set of specifications that are sent to the builders. For these types of "standard" PDE models, there are commercially available software packages (for example, <ref> [Swa85, Mac91a, Hib89] </ref>) that have very good built-in solvers. They also include some "pre-processing" component that helps the engineer specify the material properties, etc. and a "post-processing" environment where the engineer can visualize solutions in terms of the effect on the particular design (s)he is working with.
Reference: [Mac91b] <author> G. J. MacRae. </author> <title> Role of high performance computing in environmental modeling. </title> <booktitle> In Proceedings of Very Large Scale Computations in the 21st Century, </booktitle> <pages> pages 41-72. </pages> <publisher> SIAM, </publisher> <year> 1991. </year>
Reference-contexts: Restricting to PDE based problems, in <ref> [Mac91b] </ref> MacRae decomposes the problem solution to the stages of 1) formulating ideas into mathematical representation, 2) describing variables and relations, 3) setting up equations and selecting approximations, 4) selecting (PDE) models, 5) optimizing models using experimentation, 6) solving the models, and 7) interpreting results and modifying the models if necessary. <p> Despite their positive impact and potential, their introduction has significantly increased the complexity of the scientific problem solving process. Figure 2.1 displays the PDELab view of the modern problem solving process for PDE based applications <ref> [Mac91b] </ref>. It includes processes such as brain storming, trial and error reasoning, numeric and experimental data I/O and calibration, numeric and symbolic simulation, advanced reasoning, optimization, visualization and interpretation of results.
Reference: [Man90] <author> SunOS Reference Manual. </author> <title> Network Programming: External Data Representation Standard. Sun Microsystems, </title> <publisher> Inc., </publisher> <year> 1990. </year>
Reference-contexts: Second, PDEBus allows clients to register their own convertors to/from the data structure and some transport representation. Using this latter mechanism, one can transmit and receive data in the eXternal Data Representation (XDR <ref> [Man90] </ref>), for example. A set of utility functions for supporting XDR data communication is included in the current implementation of PDEBus. 31 The software architecture of PDEBus is a layered architecture with the lowest level providing a packet-based messaging system implemented over a reliable byte-stream protocol such as TCP/IP.
Reference: [MOF90] <author> Peter K. Moore, Can Ozturan, and Joseph E. Flaherty. </author> <title> Towards the automatic numerical solution of partial differential equations. </title> <editor> In E. N. Houstis, J. R. Rice, and R. Vichnevetsky, editors, </editor> <booktitle> Intelligent Mathematical Software Systems, </booktitle> <pages> pages 15-22. </pages> <publisher> North-Holland, </publisher> <year> 1990. </year>
Reference-contexts: Using this abstract model, in [Ric79] Rice describes an experimental methodology for applying the abstract model in the performance evaluation of numerical software. In <ref> [MOF90] </ref>, Moore et. al. describe a strategy for the automatic solution of PDEs at a different level. They are concerned with the problem of determining (automatically) a geometry discretization that leads to a solution guaranteed to be within a prescribed accuracy.
Reference: [MS79] <author> N. K. Madsen and R. F. Sincovec. </author> <title> PDECOL: General collocation software for partial differential equations. </title> <journal> ACM Transactions on Mathematical Software, </journal> <volume> 5(3) </volume> <pages> 326-351, </pages> <year> 1979. </year>
Reference-contexts: The most flexibility in terms of being adaptable to developing specific application environments is, of course, provided by the low-level library type systems. Examples of these systems include VECFEM [GS91], PDECOL <ref> [MS79] </ref>, PDETWO [MS81], FIDISOL [SSM85] and CADSOL [WSS92]. The price for flexibility is that one must develop all the related software necessary to build an application problem solving environment; not a trivial task by any measure.
Reference: [MS81] <author> David K. Melgaard and Richard F. Sincovec. </author> <title> General software for two-dimensional nonlinear partial differential equations. </title> <journal> ACM Transactions on Mathematical Software, </journal> <volume> 7(1) </volume> <pages> 106-125, </pages> <year> 1981. </year>
Reference-contexts: The most flexibility in terms of being adaptable to developing specific application environments is, of course, provided by the low-level library type systems. Examples of these systems include VECFEM [GS91], PDECOL [MS79], PDETWO <ref> [MS81] </ref>, FIDISOL [SSM85] and CADSOL [WSS92]. The price for flexibility is that one must develop all the related software necessary to build an application problem solving environment; not a trivial task by any measure.
Reference: [MV88] <author> J. O. Mouton and J. Valusek. </author> <title> E&P software integration: </title> <booktitle> An elusive goal? World Oil, </booktitle> <pages> pages 48-55, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: Explorer [Sil92], Agora [Bis88], Mathematica [Wol88] and Maple [Gro87]. 2.2.3 Software Bus Environments While the idea of a software bus is not recent, it appears that the implementation of the idea is recently becoming more and more popular (see for example [PAP + 89], [SG93], [OPSS93], [HGJ + 89] and <ref> [MV88] </ref>). We very briefly review the Polylith and Glish systems below. The Polylith [Pur94] software bus is a software component decoupling agent. Software components are built using some abstract bus interface and the component's interface is specified using a "Module Interconnection Language" (MIL).
Reference: [Nat] <institution> National Instruments Corporation, Austin, Texas. </institution> <note> IEEE 488 and VX-Ibus Control, Data Acquisition, and Analysis, 1994 edition. 162 </note>
Reference-contexts: Introduced in 1987, VXI is seeing rapid growth and acceptance worldwide. VXI uses a mainframe cha-sis with slots to hold modular instruments on plug-in boards. The VXI backplane 129 includes a 32-bit VME bus as well as high-performance instrumentation buses for precision timing and synchronization between instrument components. <ref> [Nat] </ref> Along with these hardware standards have come software that provide convenient access to instruments. The current state of the art in software for instrument control, data acquisition and data analysis is exemplified by LabView [Nat92].
Reference: [Nat92] <institution> National Instruments Coporation, Austin, Texas. </institution> <note> LabView User's Manual, </note> <year> 1992. </year>
Reference-contexts: With this revolution comes the need to integrate these diverse paradigms into cohesive systems that scientists can use to achieve their scientific ideals. While hardware/software for controlling laboratory instrumentation, gathering data and for analyzing that data generally exists today (see for example <ref> [Nat92] </ref> and [BH92]), there has been little work on integrating experimentation and computation in one cohesive environment. The general state-of-the-art in such integration is to manually (off-line) understand and apply the interactions between them (see for example [CWW91a] and [TK89]). <p> The current state of the art in software for instrument control, data acquisition and data analysis is exemplified by LabView <ref> [Nat92] </ref>. The facilities available include graphical program development tools, graphical user interface building support, and a notion of "virtual instruments" (VIs). A VI is a software interface to the physical instrument; the software interface provides mechanisms to perform all the operations provided by the actual instrument.
Reference: [OPSS93] <author> B. Oki, M. Pfluegl, A. Siegel, and D. </author> <title> Skeen. </title> <booktitle> The information bus-an architecture for exensible distributed systems. In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 58-68. </pages> <publisher> ACM, </publisher> <year> 1993. </year>
Reference-contexts: Other application development frameworks include Explorer [Sil92], Agora [Bis88], Mathematica [Wol88] and Maple [Gro87]. 2.2.3 Software Bus Environments While the idea of a software bus is not recent, it appears that the implementation of the idea is recently becoming more and more popular (see for example [PAP + 89], [SG93], <ref> [OPSS93] </ref>, [HGJ + 89] and [MV88]). We very briefly review the Polylith and Glish systems below. The Polylith [Pur94] software bus is a software component decoupling agent. Software components are built using some abstract bus interface and the component's interface is specified using a "Module Interconnection Language" (MIL).
Reference: [Ous90] <author> J. Ousterhout. </author> <title> Tcl: An embeddable command language. </title> <booktitle> In Proceedings of the USENIX Winter Conference, </booktitle> <pages> pages 133-146, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Since inter-component communication is transparently achieved via URLs and PDEBus' messaging system, once the components are built, one only needs to have PDEBus initiate and manage those components. This is achieved via the session initiation script mechanism of PDEBus. This script (implemented using Tcl <ref> [Ous90] </ref>) instructs PDEBus to initiate the components required for the session.
Reference: [PAP + 89] <author> V. Paxson, C. Aragon, S. Peggs, C. Saltmarsh, and L. Schachinger. </author> <title> A unified approach to building accelerator simulation software for the SSC. </title> <booktitle> In Proceedings of the 1989 IEEE Particle Accelerator Conference, </booktitle> <volume> volume 1, </volume> <pages> pages 82-84, </pages> <year> 1989. </year>
Reference-contexts: have been constructed. 20 Other application development frameworks include Explorer [Sil92], Agora [Bis88], Mathematica [Wol88] and Maple [Gro87]. 2.2.3 Software Bus Environments While the idea of a software bus is not recent, it appears that the implementation of the idea is recently becoming more and more popular (see for example <ref> [PAP + 89] </ref>, [SG93], [OPSS93], [HGJ + 89] and [MV88]). We very briefly review the Polylith and Glish systems below. The Polylith [Pur94] software bus is a software component decoupling agent.
Reference: [Pea88] <author> Judea Pearl. </author> <title> Probabilistic Reasoning in Intelligent Systems: Networks of Plausible Inference. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1988. </year>
Reference-contexts: The inferencing logic in PYTHIA is organized as a Bayesian belief propagation network <ref> [Pea88] </ref>. Figure 4.8 shows a pictorial view of the PYTHIA reasoning framework. A detailed discussion of the techniques used for handling uncertainty is given in the next section. This section describes the overall algorithm without explaining in detail the logic used to compute the various numbers involved.
Reference: [PS93] <author> Vern Paxson and Chris Saltmarsh. Glish: </author> <title> A user-level software bus for loosely-coupled distributed systems. </title> <booktitle> In Proceedings of the Winter 1993 Usenix Conference, </booktitle> <pages> pages 217-276. </pages> <publisher> USENIX Association, </publisher> <year> 1993. </year>
Reference-contexts: Each component is not aware of the structure of the entire application itself; it has symbolic knowledge about itself and any other components it needs to interact with. The symbolic knowledge is transformed to actual locations at run-time by the software bus environment. Glish <ref> [PS93] </ref> is a user-level software bus system implemented as an interpreted language for building distributed systems from modular, event-driven programs components. The Glish language is a full arrray-oriented programming language which can be used to manipulate events as they are being sent between clients. <p> environments into three classes and then address this question in the context of each class: * message passing libraries (e.g., PVM [BDG + 92], PICL [GHPW92] and ISIS [Bir91]) * distributed computing environments (e.g., Sun's ONC [Sun91] and ToolTalk [Sun93] and OSF's DCE [Fou92]) * software bus systems (e.g., Glish <ref> [PS93] </ref>, Polylith [Pur94]) The message passing libraries generally provide send () and recv () primitives for transmitting byte sequences between processes running on different machines.
Reference: [PSW91] <author> J. Purtilo, R. T. Snodgrass, and A. L. Wolf. </author> <title> Software bus organization: Reference model and comparison of two existing systems. Technical Report TR-8, ARPA Module Interconnection Formalism Working Group, </title> <year> 1991. </year> <month> (file://thumper.cs.umd.edu/files/doc/refmodel.ps.Z). </month>
Reference-contexts: The custom interface communicates with the user in application domain terms (and not in mathematical PDE terms) by translating domain terminology to/from the appropriate mathematical representations. 2.5 Communication: The PDELab Software Bus The underlying communication fabric for PDELab is based on the software bus <ref> [PSW91] </ref> model. The software bus concept is an attempt to emulate the hardware bus mechanism that provides a standard hardware interface to attach additional capabilities to a machine. <p> This script (implemented using Tcl [Ous90]) instructs PDEBus to initiate the components required for the session. A graphical 32 development tool at the upper layer of PDELab will assist in developing these session initialization scripts. 2.5.4 Comparison with Software Bus Reference Model In <ref> [PSW91] </ref>, Purtilo, Snodgrass and Wolff define a reference model for software bus systems consisting of three components: the abstract bus specification, the language used to interact with the abstract bus and the implementation of the abstract bus. In this section we apply this model to PDEBus.
Reference: [Pur94] <author> J. M. Purtilo. </author> <title> The polylith software bus. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(1) </volume> <pages> 151-174, </pages> <year> 1994. </year>
Reference-contexts: We very briefly review the Polylith and Glish systems below. The Polylith <ref> [Pur94] </ref> software bus is a software component decoupling agent. Software components are built using some abstract bus interface and the component's interface is specified using a "Module Interconnection Language" (MIL). The module interface definition is used to automatically generate stubs that can be used by other modules. <p> three classes and then address this question in the context of each class: * message passing libraries (e.g., PVM [BDG + 92], PICL [GHPW92] and ISIS [Bir91]) * distributed computing environments (e.g., Sun's ONC [Sun91] and ToolTalk [Sun93] and OSF's DCE [Fou92]) * software bus systems (e.g., Glish [PS93], Polylith <ref> [Pur94] </ref>) The message passing libraries generally provide send () and recv () primitives for transmitting byte sequences between processes running on different machines.
Reference: [RB85] <author> J. R. Rice and R. F. Boisvert. </author> <title> Solving Elliptic Problems Using ELL-PACK. </title> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: The price for flexibility is that one must develop all the related software necessary to build an application problem solving environment; not a trivial task by any measure. High level language based systems (for example, ELLPACK <ref> [RB85] </ref>, DEQSOL [Hit90] and PDE/PROTRAN [IMS86]) and their recent interactive system counterparts, //ELLPACK [HRC + 90] and Visual DEQSOL [UKO92], provide significantly more functionality for the application developer. <p> As a representative of this generation of software, we will consider the Purdue //ELLPACK system, which is generally considered to be the state-of-the-art in this area. The //ELLPACK PDE solving system [HRC + 90, HR92] evolved from the ELL-PACK <ref> [RB85] </ref> system. These systems have taken the approach of using a high level mathematical language to allow users to specify the particular mathematical model as well as how they want it solved. <p> High level languages for PDE problem and solution scheme specification are almost as old as are high-level languages themselves [CK70]. More modern languages include the ELLPACK family of languages <ref> [RB85, HRC + 90, BD90] </ref>, the closely related PDE/PROTRAN language [IMS86], the DEQSOL language of PDEQSOL [Hit90] and others such as the object-oriented model developed by Ruppelt and Wirtz [RW89] and more application dependent systems such as Thornburg's PDE compiler [Tho89]. <p> The language supported a wide range of PDE operators over 1, 2 and 3 dimensional rectangular regions and generated tabular output and even contour plots of the solution. The ELLPACK project <ref> [RB85] </ref> is a high level problem solving environment for solving a single elliptic PDE. The ELLPACK language is a high level language similar to PDEL. It is viewed as an extension of FORTRAN and, similar to PDEL, allows experienced users to insert arbitrary FORTRAN code to create complex programs. <p> We apply an expert system methodology based on the so-called exemplar reasoning approach. In this chapter we describe the PYTHIA expert system that implements this methodology within the domain of applicability of the parallel ELLPACK library [HRC + 90] that includes the sequential ELLPACK <ref> [RB85] </ref> modules. PYTHIA's reasoning approach is based on the performance profiles of various ELLPACK solvers observed for a population of a priori determined elliptic PDE problems. These profiles are automatically generated out of known sets of performance data for each module of the library. <p> Figure 4.1 shows an example problem from the PDE population. The actual implementation of this population is reported in [BRH79]. The population also contains information about the properties of the problems. This information is encoded as a bit-string and is accessible via the ELLPACK <ref> [RB85] </ref> 92 Problem #28 (w u x ) x + (w u y ) y = 1; where w = 8 &gt; : 1; otherwise: Domain [1; 1] fi [1; 1] BC u = 0 True unknown Operator Self-adjoint, discontinuous coefficients Right Side Constant Boundary Conditions Dirichlet, homogeneous Solution Approximate solutions <p> In addition, we have facts about the types of PDE problems to which solvers can be applied. This information allows PYTHIA to automatically form legal PDE solvers out of software parts. In the case of elliptic solvers, we have four types of modules <ref> [RB85] </ref>: discretization, indexing, solution and triple.
Reference: [RHD81] <author> John R. Rice, Elias N. Houstis, and Wayne R. Dyksen. </author> <title> A population of linear, second order, elliptic partial differential equations on rectangular domains, part I. </title> <journal> Mathematics of Computation, </journal> <volume> 36 </volume> <pages> 475-484, </pages> <year> 1981. </year>
Reference-contexts: The success of this approach thus relies greatly on having available a reasonably large population of various PDE problems about which some performance information is known. For the class of linear second order elliptic PDEs we are currently using the population created in <ref> [RHD81] </ref> for use in the evaluation of numerical methods and software for solving PDEs. It consists of fifty-six linear, two-dimensional elliptic PDEs defined on rectangular domains. Forty-two of the problems are parametrized which leads to an actual problem space of more than two-hundred and fifty PDEs. <p> Figure 4.7 indicates an example of a class rules for a class of problems from the population in <ref> [RHD81] </ref>. User-Specified Rules This information consists of assumptions about the performance of methods for various classes of problems. They are products of a priori and a posteriori analyses or observations made by experts. <p> See [RM86] for more details. As we have mentioned earlier, we have reduced our problem to one of pattern matching. Backpropagation has been successfully used to solve similar pattern matching problems. In this case, our input consists of the characteristic vector, which has 32 elements <ref> [RHD81] </ref>. The output consists of a vector with 5 elements, corresponding to the number of classes that we use in our simulations and therefore to the number of classes that we wish to categorize the data into.
Reference: [Ric76] <author> J. R. Rice. </author> <title> The algorithm selection problem. </title> <booktitle> Advances in Computers, </booktitle> <volume> 15 </volume> <pages> 65-118, </pages> <year> 1976. </year>
Reference-contexts: The overall PYTHIA architecture and its implementation is discussed in Section 4.8. Finally, in Section 4.9 we present the performance evaluation of PYTHIA for several scenarios. 4.2 Related Work There have been several attempts at developing expert systems for assisting in various aspects of the PDE solution process. In <ref> [Ric76] </ref>, Rice describes an abstract 87 model for the algorithm selection problem. The algorithm selection problem is defined as the problem of determining a selection (or mapping) from the problem space (or its more accessible counterpart, the feature space) to the algorithm space.
Reference: [Ric79] <author> J. R. Rice. </author> <title> Methodology for the algorithm selection problem. </title> <editor> In L. D. Fosdick, editor, </editor> <booktitle> Performance Evaluation of Numerical Software, </booktitle> <pages> pages 301-307. </pages> <publisher> North-Holland, </publisher> <year> 1979. </year>
Reference-contexts: The "best" selection is then the mapping that is better (in the sense of having a better performance indicator in the performance measure space) than other possible mappings. Using this abstract model, in <ref> [Ric79] </ref> Rice describes an experimental methodology for applying the abstract model in the performance evaluation of numerical software. In [MOF90], Moore et. al. describe a strategy for the automatic solution of PDEs at a different level.
Reference: [Ric89] <author> John R. Rice. </author> <title> Composition of libraries, software parts and problem solving environments. </title> <type> Technical Report CSD-TR-852, </type> <institution> Department of Computer Sciences, Purdue University, </institution> <year> 1989. </year> <month> 163 </month>
Reference-contexts: Furthermore, textual representations allow easy modifications to produce similar models. In terms of solution schemes, having a language for expressing algorithms allow users to combine PDE solving software parts to build complex solution strategies that were not previously available <ref> [HRW94, Ric89] </ref>.
Reference: [RM86] <author> D. E. Rumelhart and J. L. McClelland. </author> <title> Parallel Distributed Processing, Explorations into the microstructure of Cognition. </title> <publisher> MIT Press, </publisher> <address> Cam-bridge, MA, USA, </address> <year> 1986. </year>
Reference-contexts: Weights are then changed in a way so as to reduce this error. This is essentially doing gradient descent on the error surface with respect to the weight values. This cycle is repeated until the error falls below some predefined measure. See <ref> [RM86] </ref> for more details. As we have mentioned earlier, we have reduced our problem to one of pattern matching. Backpropagation has been successfully used to solve similar pattern matching problems. In this case, our input consists of the characteristic vector, which has 32 elements [RHD81].
Reference: [RW89] <author> Th. Ruppelt and G. Wirtz. </author> <title> Automatic transformation of high-level object-oriented specifications into parallel programs. </title> <journal> Parallel Computing, </journal> <volume> 10 </volume> <pages> 15-28, </pages> <year> 1989. </year>
Reference-contexts: More modern languages include the ELLPACK family of languages [RB85, HRC + 90, BD90], the closely related PDE/PROTRAN language [IMS86], the DEQSOL language of PDEQSOL [Hit90] and others such as the object-oriented model developed by Ruppelt and Wirtz <ref> [RW89] </ref> and more application dependent systems such as Thornburg's PDE compiler [Tho89]. Most of these languages are non-symbolic in their manipulation of the PDE problem and tend to be direct translators from the mathematical representation to a run-time representation in a traditional imperative language.
Reference: [SG93] <author> K. Sayre and M. A. Gray. </author> <title> Backtalk: A generalized dynamic communication system for DAI. </title> <journal> Software-Practice and Experience, </journal> <volume> 23(9) </volume> <pages> 1043-1057, </pages> <year> 1993. </year>
Reference-contexts: 20 Other application development frameworks include Explorer [Sil92], Agora [Bis88], Mathematica [Wol88] and Maple [Gro87]. 2.2.3 Software Bus Environments While the idea of a software bus is not recent, it appears that the implementation of the idea is recently becoming more and more popular (see for example [PAP + 89], <ref> [SG93] </ref>, [OPSS93], [HGJ + 89] and [MV88]). We very briefly review the Polylith and Glish systems below. The Polylith [Pur94] software bus is a software component decoupling agent. Software components are built using some abstract bus interface and the component's interface is specified using a "Module Interconnection Language" (MIL).
Reference: [Sil92] <institution> Silicon Graphics, Inc. </institution> <type> IRIS Explorer. Technical report, </type> <institution> Silicon Graphics, Inc., </institution> <year> 1992. </year>
Reference-contexts: Such a PSE generator would basically consist of a database of PSE "components", navigation tools to search through the database and a (visual) PSE synthesizer language to connect together several components to form a PSE. The Explorer <ref> [Sil92] </ref> software from Silicon Graphics, Inc. can be viewed as an example of a PSE generator environment for generating PSEs for the problem of scientific visualization. 1.4 PDE Based Applications and Application PSEs Our goal is to improve the software infrastructure available for building PSEs for PDE based applications. <p> Several application specific workbenches consisting of SIBs have been constructed. 20 Other application development frameworks include Explorer <ref> [Sil92] </ref>, Agora [Bis88], Mathematica [Wol88] and Maple [Gro87]. 2.2.3 Software Bus Environments While the idea of a software bus is not recent, it appears that the implementation of the idea is recently becoming more and more popular (see for example [PAP + 89], [SG93], [OPSS93], [HGJ + 89] and [MV88]).
Reference: [SSM85] <author> W. Schonauer, E. Schnepf, and M. Muller. </author> <title> The FIDISOL Program Package. </title> <institution> University of Karlsruhe, Karlsruhe, Germany, </institution> <year> 1985. </year>
Reference-contexts: The most flexibility in terms of being adaptable to developing specific application environments is, of course, provided by the low-level library type systems. Examples of these systems include VECFEM [GS91], PDECOL [MS79], PDETWO [MS81], FIDISOL <ref> [SSM85] </ref> and CADSOL [WSS92]. The price for flexibility is that one must develop all the related software necessary to build an application problem solving environment; not a trivial task by any measure.
Reference: [Sun91] <author> SunSoft. </author> <title> Open network computing. </title> <type> Technical report, </type> <institution> Sun Microsystems Inc., </institution> <year> 1991. </year>
Reference-contexts: Let us classify existing distributed communication environments into three classes and then address this question in the context of each class: * message passing libraries (e.g., PVM [BDG + 92], PICL [GHPW92] and ISIS [Bir91]) * distributed computing environments (e.g., Sun's ONC <ref> [Sun91] </ref> and ToolTalk [Sun93] and OSF's DCE [Fou92]) * software bus systems (e.g., Glish [PS93], Polylith [Pur94]) The message passing libraries generally provide send () and recv () primitives for transmitting byte sequences between processes running on different machines.
Reference: [Sun93] <author> SunSoft. </author> <title> ToolTalk 1.1 User's Guide. Sun Microsystems, </title> <publisher> Inc., </publisher> <address> Mountain View, CA, </address> <year> 1993. </year>
Reference-contexts: Let us classify existing distributed communication environments into three classes and then address this question in the context of each class: * message passing libraries (e.g., PVM [BDG + 92], PICL [GHPW92] and ISIS [Bir91]) * distributed computing environments (e.g., Sun's ONC [Sun91] and ToolTalk <ref> [Sun93] </ref> and OSF's DCE [Fou92]) * software bus systems (e.g., Glish [PS93], Polylith [Pur94]) The message passing libraries generally provide send () and recv () primitives for transmitting byte sequences between processes running on different machines.
Reference: [Swa85] <institution> Swanson Analysis Systems, Inc. </institution> <note> ANSYS User's Manual, Version 4.2, </note> <year> 1985. </year>
Reference-contexts: Once the solution is available, the engineer may use the computed stress and displacement information to optimize the bridge design and finally generate a set of specifications that are sent to the builders. For these types of "standard" PDE models, there are commercially available software packages (for example, <ref> [Swa85, Mac91a, Hib89] </ref>) that have very good built-in solvers. They also include some "pre-processing" component that helps the engineer specify the material properties, etc. and a "post-processing" environment where the engineer can visualize solutions in terms of the effect on the particular design (s)he is working with.
Reference: [Tho89] <author> Jonathan Thornburg. </author> <title> A PDE compiler for full-metric numerical relativity. </title> <editor> In C. R. Evans, L. S. Finn, and D. W. Hobill, editors, </editor> <booktitle> Frontiers in Numerical Relativity, </booktitle> <pages> pages 370-383. </pages> <publisher> Cambridge University Press, </publisher> <year> 1989. </year>
Reference-contexts: More modern languages include the ELLPACK family of languages [RB85, HRC + 90, BD90], the closely related PDE/PROTRAN language [IMS86], the DEQSOL language of PDEQSOL [Hit90] and others such as the object-oriented model developed by Ruppelt and Wirtz [RW89] and more application dependent systems such as Thornburg's PDE compiler <ref> [Tho89] </ref>. Most of these languages are non-symbolic in their manipulation of the PDE problem and tend to be direct translators from the mathematical representation to a run-time representation in a traditional imperative language. There are also systems that take a purely symbolic view; see for example [JP92] and [Wan86].
Reference: [TK89] <author> C. G. Takoudis and M. Kastelic. </author> <title> Selective epitaxial growth of silicon in a barrel reactor. </title> <journal> Chem. Engng. Sci., </journal> <volume> 44 </volume> <pages> 2049-2062, </pages> <year> 1989. </year>
Reference-contexts: The general state-of-the-art in such integration is to manually (off-line) understand and apply the interactions between them (see for example [CWW91a] and <ref> [TK89] </ref>). Our own PDELab work concentrates on building problem solving environments for the computational aspects 127 of a problem. In this work, we address the issues involved with building software environments that integrate experimentation and computation and describe a prototype implementation currently in progress.
Reference: [UKO92] <author> Y. Umetani, C. Konno, and T. Ohta. </author> <title> Visual PDEQSOL: A visual and interactive environment for numerical simulation. </title> <editor> In P. W. Gaffney and E. N. Houstis, editors, </editor> <booktitle> Programming Environments for High-Level Scientific Problem Solving, </booktitle> <pages> pages 259-269. </pages> <publisher> North-Holland, </publisher> <year> 1992. </year>
Reference-contexts: High level language based systems (for example, ELLPACK [RB85], DEQSOL [Hit90] and PDE/PROTRAN [IMS86]) and their recent interactive system counterparts, //ELLPACK [HRC + 90] and Visual DEQSOL <ref> [UKO92] </ref>, provide significantly more functionality for the application developer.
Reference: [Wan86] <author> Paul S. Wang. </author> <title> FINGER: A symbolic system for automatic generation of numerical programs in finite element analysis. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 2 </volume> <pages> 305-316, </pages> <year> 1986. </year>
Reference-contexts: Most of these languages are non-symbolic in their manipulation of the PDE problem and tend to be direct translators from the mathematical representation to a run-time representation in a traditional imperative language. There are also systems that take a purely symbolic view; see for example [JP92] and <ref> [Wan86] </ref>. In these systems, the mathematical models are translated into an imperative language by performing most of the discretizations directly in the symbolic environments. That is, they tend to apply a pure program generation approach rather than the (mostly) pure program translation approach taken by the other systems.
Reference: [WCHR92] <author> Sanjiva Weerawarana, Ann C. Catlin, Elias N. Houstis, and John R. Rice. </author> <title> Integrated symbolic-numeric computing in //ELLPACK: Experiences and plans. </title> <type> Technical Report CSD-TR-92-092, </type> <institution> Department of Computer Sciences, Purdue University, </institution> <year> 1992. </year> <month> 164 </month>
Reference-contexts: The primary reason for this lack of interaction between these two computing methodologies is the difficulty in achieving this interaction in practice. In this section, we highlight the convenient and ubiquitous integration of symbolic computation that we have achieved in PDELab. See [WHR94a] and <ref> [WCHR92] </ref> for details. 2.7.1 Symbolic Computation in PDELab As mentioned above, the PDESpec language is defined using MACSYMA. The PDESpec parser that is invoked when users textually enter PDE objects is implemented within MACSYMA.
Reference: [We94] <author> Sanjiva Weerawarana and etal. </author> <title> The PDESpec language specification. </title> <type> Technical report, </type> <institution> Department of Computer Sciences, Purdue University, </institution> <year> 1994. </year> <note> to appear. </note>
Reference-contexts: A rigorous definition of PDESpec is given elsewhere <ref> [We94] </ref>. 3.8.1 Basic Syntax In developing PDESpec's syntax, we have chosen to use the MACSYMA language syntax as a base. This allows us easy access to MACSYMA's symbolic manipulation facilities and also allows us to avoid developing yet another syntax for basic language facilities.
Reference: [WH94] <author> Reginald L. Walker and Elias N. Houstis. </author> <title> A parallel time stepping scheme. </title> <type> Technical report, </type> <institution> Department of Computer Sciences, Purdue University, </institution> <year> 1994. </year> <note> to appear. </note>
Reference-contexts: the basic linear algebra subroutines (BLAS), portable communication libraries such as MPI [DHHW93] and PICL [GHPW92], parallel languages such as HPF [KLS + 94], parallelizing methodologies for re-using sequential code in a parallel environment, geometry and matrix partitioning tools, instrumentation tools and skeletons (templates) for parallel methods such as PTS <ref> [WH94] </ref>. 2.4.3 PSE Development Framework This upper layer of the PDELab architecture provides application PSE developers with a collection of tools and services required to build such PSEs.
Reference: [WHR92] <author> S. Weerawarana, E. N. Houstis, and J. R. Rice. </author> <title> An interactive symbolic-numeric interface to parallel ELLPACK for building general PDE solvers. </title> <editor> In Bruce Randall Donald, Deepak Kapur, and Joseph L. Mundy, editors, </editor> <booktitle> Symbolic and Numerical Computation for Artificial Intelligence, chapter 13, </booktitle> <pages> pages 303-322. </pages> <publisher> Academic Press, </publisher> <year> 1992. </year>
Reference-contexts: The last two numbers are the subjective measures of the smoothness and local variation properties of the operator. In this study, we have assumed only linear PDE problems and solvers. Usually solving nonlinear problems is reduced symbolically to solving a sequence of linear ones <ref> [WHR92] </ref>. In these cases, PYTHIA can be applied to select the appropriate solver for the linearized PDE problem. Class Facts This information consists of the set of member identifiers and the average characteristic vector of the class as defined in Section 4.3.3.
Reference: [WHR94a] <author> Sanjiva Weerawarana, Elias N. Houstis, and John R. Rice. </author> <title> A software platform for integrating symbolic computation with a PDE solving environment. </title> <booktitle> In Proceedings of the 14th IMACS World Congress on Computation and Applied Mathematics, </booktitle> <year> 1994. </year> <note> to appear. </note>
Reference-contexts: The primary reason for this lack of interaction between these two computing methodologies is the difficulty in achieving this interaction in practice. In this section, we highlight the convenient and ubiquitous integration of symbolic computation that we have achieved in PDELab. See <ref> [WHR94a] </ref> and [WCHR92] for details. 2.7.1 Symbolic Computation in PDELab As mentioned above, the PDESpec language is defined using MACSYMA. The PDESpec parser that is invoked when users textually enter PDE objects is implemented within MACSYMA.
Reference: [WHR + 94b] <author> Sanjiva Weerawarana, Elias N. Houstis, John R. Rice, Ann Christine Catlin, Cheryl L. Crabill, Chi Ching Chui, and Shahani Markus. PDE-Lab: </author> <title> An object-oriented framework for building problem solving environments for PDE based applications. </title> <booktitle> In Proceedings of the Second Annual Object-Oriented Numerics Conference, </booktitle> <pages> pages 79-92, </pages> <institution> Rogue-Wave Software, Corvallis, </institution> <address> OR, </address> <year> 1994. </year>
Reference-contexts: The purpose of this study is to address the issue of intelligence within a specific class of applications that can be described by a mathematical model involving PDEs defined on general geometric regions. The design objectives and architecture of such PSEs are described in <ref> [WHR + 94b] </ref>. The goal of these PSEs is to assist the user to carry out the numerical solution of these models and visualize their solutions.
Reference: [Wol88] <author> Stephen Wolfram. </author> <title> Mathematica: A System for Doing Mathematics by Computer. </title> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: Several application specific workbenches consisting of SIBs have been constructed. 20 Other application development frameworks include Explorer [Sil92], Agora [Bis88], Mathematica <ref> [Wol88] </ref> and Maple [Gro87]. 2.2.3 Software Bus Environments While the idea of a software bus is not recent, it appears that the implementation of the idea is recently becoming more and more popular (see for example [PAP + 89], [SG93], [OPSS93], [HGJ + 89] and [MV88]). <p> The system is implemented in MACSYMA. SINAPSE [KDMW92] is a program synthesis system that generates numerical code for solving PDE or matrix equations using symbolic discretization. SINAPSE is implemented on top of Mathematica <ref> [Wol88] </ref> and uses a custom syntax for describing the PDE operators. The mathematical descriptions are then translated into an abstract algorithm description targeted to a specific machine architecture.
Reference: [WSS92] <author> H. Wietschorke, M. Schmauder, and W. Schonauer. </author> <title> The CADSOL Program Package. </title> <institution> University of Karlsruhe, Karlsruhe, Germany, </institution> <year> 1992. </year>
Reference-contexts: The most flexibility in terms of being adaptable to developing specific application environments is, of course, provided by the low-level library type systems. Examples of these systems include VECFEM [GS91], PDECOL [MS79], PDETWO [MS81], FIDISOL [SSM85] and CADSOL <ref> [WSS92] </ref>. The price for flexibility is that one must develop all the related software necessary to build an application problem solving environment; not a trivial task by any measure.
Reference: [WW92] <author> S. Weerawarana and P. S. Wang. </author> <title> A portable code generator for CRAY FORTRAN. </title> <journal> ACM Transactions on Mathematical Software, </journal> <volume> 18(3) </volume> <pages> 241-255, </pages> <year> 1992. </year>
Reference-contexts: The MACSYMA parser is used to parse a PDE-Spec program and the compiler (implemented in MACSYMA, Common LISP and C) generates a program in FORTRAN using the GENCRAY <ref> [WW92] </ref> code generation package. For interpreted programs, a parsed version of the program is handed over to the PDESpec interpreter for execution. By implementing the language as an extension of the MACSYMA computer algebra system's language, PDELab supports direct symbolic transformations at the language level. <p> Symbolic transformations on PDESpec objects (for example, linearizing a nonlinear equation or discretizing a PDE operator) are also supported. When a PDESpec program is to be executed, a translator in MACSYMA symbolically analyzes the program and generates the target code using the GEN-CRAY code generation system <ref> [WW92] </ref>. <p> In some cases, when user-defined functions are part of the PDE operator, automatic differentiation [BG92] is needed as well. Once PDESpec has completed the manipulation of the program, it uses an automatic code generation tool to generate code from the symbolic representation it has of the program <ref> [WW92] </ref>. 3.11 Examples 3.11.1 Steady-State Heat Flow in a Reactor Consider a reactor with a steel dome and a concrete base as shown in Figure 3.2. The inside surface of the dome is initially 450 ffi K and the ambient temperature around the reactor is 80 ffi K.

References-found: 91

