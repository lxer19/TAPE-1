URL: http://www.cs.mu.oz.au/tr_db/mu_95_30.ps.gz
Refering-URL: http://www.cs.mu.oz.au/tr_db/TR.html
Root-URL: 
Email: (fwarwick,pjsg@cs.mu.OZ.AU)  
Title: A Unit Two Variable Per Inequality Integer Constraint Solver for Constraint Logic Programming  
Author: Warwick Harvey Peter J. Stuckey 
Address: Parkville 3052  
Affiliation: Department of Computer Science University of Melbourne  
Pubnum: Technical Report 95/30  
Abstract: One of the problems with the traditional finite domains approach to solving integer problems in a constraint logic programming context is that all variables require explicit bounds. If no explicit bounds are available then the finite domain solver can be very inefficient on certain classes of problem. We present an alternative approach to solving integer constraints based on a polynomial-time solver for a restricted class of integer constraints. This approach does not require bounds information, avoids bad behaviour for a larger class of problems, and is competitive with bounds propagation for the types of problem examined. We give a detailed description of the implementation of the core solver, discuss how it can be used to as the basis of a more general solver, and present some computational results. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Bengt Aspvall and Yossi Shiloach. </author> <title> A polynomial time algorithm for solving systems of linear inequalities with two variables per inequality. </title> <journal> SIAM J. Comput., </journal> <volume> Volume 9, Number 4, </volume> <pages> pages 827-845, </pages> <month> November </month> <year> 1980. </year>
Reference-contexts: This class appears to be strictly simpler than the general problem (unlike the three-variable-per-inequality problem), but surprisingly solving them is still NP-complete [7]. However TVPI integer constraints seem more directly amenable than general integer constraints to transitivity-based methods similar to those employed for solving real TVPI constraints <ref> [1, 2, 3, 13] </ref>. A class of constraints intermediate between SVPI and TVPI was introduced in [4]. This is the class of TVPI constraints ax + by d with unit coefficients, that is, a; b 2 f1; 0; 1g. We call these unit TVPI constraints.
Reference: [2] <author> Edith Cohen and Nimrod Megiddo. </author> <title> Improved algorithms for linear inequalities with two variables per inequality. </title> <journal> SIAM J. Comput., </journal> <volume> Volume 23, Number 6, </volume> <pages> pages 1313-1347, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: This class appears to be strictly simpler than the general problem (unlike the three-variable-per-inequality problem), but surprisingly solving them is still NP-complete [7]. However TVPI integer constraints seem more directly amenable than general integer constraints to transitivity-based methods similar to those employed for solving real TVPI constraints <ref> [1, 2, 3, 13] </ref>. A class of constraints intermediate between SVPI and TVPI was introduced in [4]. This is the class of TVPI constraints ax + by d with unit coefficients, that is, a; b 2 f1; 0; 1g. We call these unit TVPI constraints.
Reference: [3] <author> Dorit S. Hochbaum and Joseph Naor. </author> <title> Simple and fast algorithms for linear and integer programs with two variables per inequality. </title> <journal> SIAM J. Comput., </journal> <volume> Volume 23, Number 6, </volume> <pages> pages 1179-1192, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: This class appears to be strictly simpler than the general problem (unlike the three-variable-per-inequality problem), but surprisingly solving them is still NP-complete [7]. However TVPI integer constraints seem more directly amenable than general integer constraints to transitivity-based methods similar to those employed for solving real TVPI constraints <ref> [1, 2, 3, 13] </ref>. A class of constraints intermediate between SVPI and TVPI was introduced in [4]. This is the class of TVPI constraints ax + by d with unit coefficients, that is, a; b 2 f1; 0; 1g. We call these unit TVPI constraints.
Reference: [4] <author> J. Jaffar, M. Maher, P. Stuckey and R. Yap. </author> <title> Beyond finite domains. </title> <editor> In Alan Borning (editor), PPCP'94: </editor> <booktitle> Second Workshop on Principles and Practice of Constraint Programming, </booktitle> <address> Seattle WA, </address> <month> May </month> <year> 1994. </year> <month> 14 </month>
Reference-contexts: Clearly this system is unsatisfiable, by a simple transitivity argument. However, detecting this by bounds propagation requires cost proportional to k. Note that this problem is compounded if good, natural bounds are not available. In an earlier paper <ref> [4] </ref>, we suggested an alternative to the FD approach which is based on the class of two variable per inequality constraints with unit coefficients (UTVPI). <p> However TVPI integer constraints seem more directly amenable than general integer constraints to transitivity-based methods similar to those employed for solving real TVPI constraints [1, 2, 3, 13]. A class of constraints intermediate between SVPI and TVPI was introduced in <ref> [4] </ref>. This is the class of TVPI constraints ax + by d with unit coefficients, that is, a; b 2 f1; 0; 1g. We call these unit TVPI constraints.
Reference: [5] <author> Joxan Jaffar and Michael J. Maher. </author> <title> Constraint logic programming: A survey. </title> <journal> Journal of Logic Programming, </journal> <volume> Volume 19 / 20, </volume> <month> May </month> <year> 1994. </year>
Reference-contexts: What follows is a brief introduction to CLP, biased towards integer solvers. A more comprehensive introduction can be found in <ref> [5] </ref>. A primitive constraint is any fundamental constraint handled by the constraint solver. For example, X 2 and Y = X + 1 are primitive (integer) constraints. A constraint is a (possibly empty) conjunction of primitive constraints.
Reference: [6] <author> Joxan Jaffar, Spiro Michaylov, Peter J. Stuckey and Roland H. C. Yap. </author> <title> The CLP(R) language and system. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Volume 14, Number 3, </volume> <pages> pages 339-395, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: Since our solver is embedded in the CLP (R) system <ref> [6] </ref>, we have included timings for CLP (R) v1.2 in our results (clpr-real). This allows a direct comparison between using the UTVPI solver and using a general real solver on these problems. Naturally the source programs for the real solver sometimes required extra code to avoid generating non-integral solutions.
Reference: [7] <author> J. C. Lagarias. </author> <title> The computational complexity of simultaneous Diophantine approximation problems. </title> <journal> SIAM J. Comput., </journal> <volume> Volume 14, Number 1, </volume> <pages> pages 196-209, </pages> <month> February </month> <year> 1985. </year>
Reference-contexts: An obvious generalization of SVPI is the class of (linear) two-variable-per-inequality (TVPI) integer constraints. This class appears to be strictly simpler than the general problem (unlike the three-variable-per-inequality problem), but surprisingly solving them is still NP-complete <ref> [7] </ref>. However TVPI integer constraints seem more directly amenable than general integer constraints to transitivity-based methods similar to those employed for solving real TVPI constraints [1, 2, 3, 13]. A class of constraints intermediate between SVPI and TVPI was introduced in [4].
Reference: [8] <author> Jean-Louis Lassez and Michael J. Maher. </author> <title> On Fourier's algorithm for linear arithmetic constraints. </title> <journal> Journal of Automated Reasoning, </journal> <volume> Volume 9, </volume> <pages> pages 373-379, </pages> <year> 1992. </year>
Reference-contexts: We also detect implicit equalities (those implied by the constraint store without having been added explicitly), since such detection can be done very cheaply. This detection is based on a result of Lassez and Maher <ref> [8] </ref>, and their Corollary 9 is re-stated here: 10 y Int Eqn Info: Var Next Occ Const Coef ID z 3 - - Var Info: Int Eqn Int Info Int Info Var Info: Int Eqn Int Info: Upper Bound Lower Bound Int Info: Neg Pos Upper Bound Lower Bound Int Eqn <p> 9 is re-stated here: 10 y Int Eqn Info: Var Next Occ Const Coef ID z 3 - - Var Info: Int Eqn Int Info Int Info Var Info: Int Eqn Int Info: Upper Bound Lower Bound Int Info: Neg Pos Upper Bound Lower Bound Int Eqn Occ Theorem 2 <ref> [8] </ref> An inequality C k in a set P is an implicit equality iff 0 0 is a positive linear combination of a subset of the inequalities of P which contains C k . This means whenever we produce 0 0 during transitive closure, we have discovered an implicit equality.
Reference: [9] <author> A. K. Mackworth. </author> <title> Constraint Satisfaction. </title> <publisher> Wiley, </publisher> <address> New York, </address> <year> 1987. </year>
Reference-contexts: These bounds are propagated through the constraint store until certain local consistency conditions are met, such as arc-consistency <ref> [16, 9] </ref>. These methods usually work very well when all variables involved have natural bounds, but problems can arise if this is not the case, for instance in some scheduling and temporal reasoning problems.
Reference: [10] <author> Jonathan S. Ostroff. </author> <title> Temporal Logic for Real-Time Systems. </title> <publisher> Wiley, </publisher> <year> 1989. </year>
Reference-contexts: Since there were no explicit bounds for the variables in these problems, we included two alternative approaches for handling this with the ECL i PS e solver. The first was to leave the variables unbounded, which meant they were given default bounds of <ref> [10; 000; 000 : : : 10; 000; 000] </ref> (eclipse-u). The other involved adding code to calculate (at run-time) worst case bounds before proceeding with the computation (eclipse-b). <p> Clearly, if there is any risk of such a situation arising, bounds must be calculated, and even then the UTVPI solver can be an order of magnitude faster, depending on how good the bounds are. The next class of problems evaluated were some temporal reasoning problems, taken from <ref> [10] </ref>. The programs used are essentially those given there (adapted for the UTVPI and FD solvers), using the "shared-track" knowledge base (temp-st-*). Results are given in Table 2.
Reference: [11] <author> V. R. Pratt. </author> <title> Two easy theories whose combination is hard. </title> <type> Technical report, </type> <institution> Massachusetts Institute of Technology, </institution> <month> September </month> <year> 1977. </year>
Reference-contexts: The main advantage of this class of constraints is that they can be solved in polynomial time. Much earlier, Pratt <ref> [11] </ref> had considered a restricted class of unit TVPI constraints, those of the form ax + d by; a; b 2 f0; 1g, and presented an efficient algorithm for their solution. (Essentially, the integer and real satisfiability problems for these constraints are equivalent, and hence real-based methods are applicable.) However, unlike
Reference: [12] <author> D. J. Rosenkrantz and H. B. Hunt, III. </author> <title> Processing conjunctive predicates and queries. </title> <booktitle> In Proc. Conf. on Very Large Data Bases, </booktitle> <pages> pages 64-72, </pages> <year> 1980. </year>
Reference-contexts: However we note that the addition of disequalities such as x 6= y to the class of SVPI constraints results in an NP-complete satisfiability problem (see, for example, <ref> [12] </ref>). 2 B C e:3 a:5 4 Unit TVPI Constraints Unit two-variable-per-inequality (UTVPI) constraints are expressive enough to capture the constraints involved in scheduling problems and temporal logic problems. For example consider the project represented in Figure 1.
Reference: [13] <author> Robert Shostak. </author> <title> Deciding linear inequalities by computing loop residues. </title> <journal> Journal of the ACM, </journal> <volume> Volume 28, Number 4, </volume> <pages> pages 769-779, </pages> <month> October </month> <year> 1981. </year>
Reference-contexts: This class appears to be strictly simpler than the general problem (unlike the three-variable-per-inequality problem), but surprisingly solving them is still NP-complete [7]. However TVPI integer constraints seem more directly amenable than general integer constraints to transitivity-based methods similar to those employed for solving real TVPI constraints <ref> [1, 2, 3, 13] </ref>. A class of constraints intermediate between SVPI and TVPI was introduced in [4]. This is the class of TVPI constraints ax + by d with unit coefficients, that is, a; b 2 f1; 0; 1g. We call these unit TVPI constraints. <p> Similarly, propagating this new constraint through (1c), we obtain w + y 1 (after tightening), which with (1d) immediately implies unsatisfiability. Note that a bounds-propagation solver would not be able to detect this unsatisfiability without resorting to enumeration. 4.1 A UTVPI Constraint Solver Shostak <ref> [13] </ref> gave an algorithm for satisfiability of real TVPI problems, not restricted to unit coefficients. One nice feature of this algorithm is that it maintains integer coefficients for integer problems.
Reference: [14] <author> P. van Hentenryck, V. Saraswat and Y. Deville. </author> <title> Constraint processing in cc(FD). </title> <type> manuscript, </type> <year> 1991. </year>
Reference-contexts: Given an incomplete solver, it is highly desirable to be able to characterize classes of constraints for which the solver is complete. On the practical front, the algorithm should be efficient, incremental and should support backtracking. Propagation-based solvers (e.g. <ref> [16, 14] </ref>) are a prime example of the choice of an efficient algorithm which is relatively incomplete. These solvers are complete when each of the constraints they handle involves only a single variable.
Reference: [15] <author> Pascal Van Hentenryck. </author> <title> Constraint Satisfaction in Logic Programming. Logic Programming Series. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1989. </year>
Reference-contexts: 1 Introduction Integer constraints are an important class used to represent many forms of problems of practical interest. For example scheduling, resource allocation and route planning. Constraint logic programming (CLP) has successfully tackled these kinds of problems (e.g. <ref> [15] </ref>), using integer solvers based on a finite domains (FD) approach, where each variable has explicit upper and lower bounds. These bounds are propagated through the constraint store until certain local consistency conditions are met, such as arc-consistency [16, 9]. <p> The results are given in Table 1. The first set of these problems (sched-bridge-*) were based on the data from the bridge construction example in <ref> [15] </ref>. The tests included finding a first solution, and a "good" solution. The "good" solution is found by giving a reasonably tight bound on the finish time of the project as a priori knowledge.
Reference: [16] <author> Pascal van Hentenryck, Yves Deville and Choh-Man Teng. </author> <title> A generic arc-consistency algorithm and its specializations. </title> <journal> Artificial Intelligence, </journal> <volume> Volume 57, </volume> <pages> Number 2-3, pages 291-321, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: These bounds are propagated through the constraint store until certain local consistency conditions are met, such as arc-consistency <ref> [16, 9] </ref>. These methods usually work very well when all variables involved have natural bounds, but problems can arise if this is not the case, for instance in some scheduling and temporal reasoning problems. <p> Given an incomplete solver, it is highly desirable to be able to characterize classes of constraints for which the solver is complete. On the practical front, the algorithm should be efficient, incremental and should support backtracking. Propagation-based solvers (e.g. <ref> [16, 14] </ref>) are a prime example of the choice of an efficient algorithm which is relatively incomplete. These solvers are complete when each of the constraints they handle involves only a single variable. <p> For example it cannot express the mutual exclusion :(x ^ y) which has a unit TVPI representation x + y 1; x 0; y 0. The generalization of Pratt's class to permit any positive a; b can be solved using arc-consistency techniques, provided all variables have finite domains <ref> [16] </ref>. 1 In this paper we ignore disequality (6=) constraints.
References-found: 16

