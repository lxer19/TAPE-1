URL: http://www.cs.rice.edu:80/~rjf/papers/isca93.ps.gz
Refering-URL: http://www.cs.rice.edu:80/~rjf/pubs.html
Root-URL: 
Title: Adaptive Cache Coherency for Detecting Migratory Shared Data  
Author: Alan L. Cox Robert. J. Fowler 
Address: Rochester  
Affiliation: Department of Computer Science Rice University  Department of Computer Science University of  
Date: May 1993  
Note: Appeared in: ISCA93,  
Abstract: Parallel programs exhibit a small number of distinct data-sharing patterns. A common data-sharing pattern, migratory access, is characterized by exclusive read and write access by one processor at a time to a shared datum. We describe a family of adaptive cache coherency protocols that dynamically identify migratory shared data in order to reduce the cost of moving them. The protocols use a standard memory model and processor-cache interface. They do not require any compile-time or run-time software support. We describe implementations for bus-based multiprocessors and for shared-memory multiprocessors that use directory-based caches. These implementations are simple and would not significantly increase hardware cost. We use trace- and execution-driven simulation to compare the performance of the adaptive protocols to standard write-invalidate protocols. These simulations indicate that, compared to conventional protocols, the use of the adaptive protocol can almost halve the number of inter-node messages on some applications. Since cache coherency traffic represents a larger part of the total communication as cache size increases, the relative benefit of using the adaptive protocol also increases. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J.K. Bennett, J.B. Carter, and W. Zwaenepoel. </author> <title> Adaptive software cache management for distributed shared memory architectures. </title> <booktitle> In Proceedings of the 17th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 125-134, </pages> <month> May </month> <year> 1990. </year>
Reference: [2] <author> B.N. Bershad and M.J. Zekauskas. Midway: </author> <title> Shared Memory Parallel Programming with Entry Consistency for Distributed Memory Multiprocessors. </title> <type> Technical Report CMU-CS-91-170, </type> <institution> Carnegie-Mellon University, </institution> <month> September </month> <year> 1991. </year>
Reference-contexts: Several software distributed shared-memory systems have used lock acquisition to indicate the intent to access migratory data. Midway requires the programmer to associate shared data with synchronization <ref> [2] </ref>. Munin permits, but does not require, the programmer to associate shared data with synchronization [4]. Our results suggest that more data is migratory at a fine grain than may be recognized by a programmer at a coarse grain.
Reference: [3] <author> W.J. Bolosky, R.P. Fitzgerald, </author> <title> and M.L. Scott. Simple but effective techniques for NUMA memory management. </title> <booktitle> In Proceedings of the 12th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 19-31, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: The simulator therefore attempts to find a reasonable page placement. Rather than attempting to simulate a general dynamic NUMA page-placement protocol [7], we use a simple dynamic technique for finding a good static placement that is similar to those used by Bolosky et al. <ref> [3] </ref> and Stenstrom et al. [21]. We assume that private data and code could have been placed and replicated perfectly to eliminate inter-node message traffic. In contrast, our execution-driven simulations with dixie use the standard round-robin memory allocation.
Reference: [4] <author> J.B. Carter, J.K. Bennett, and W. Zwaenepoel. </author> <title> Implementation and performance of Munin. </title> <booktitle> In Proceedings of the 13th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 152-164, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Several software distributed shared-memory systems have used lock acquisition to indicate the intent to access migratory data. Midway requires the programmer to associate shared data with synchronization [2]. Munin permits, but does not require, the programmer to associate shared data with synchronization <ref> [4] </ref>. Our results suggest that more data is migratory at a fine grain than may be recognized by a programmer at a coarse grain. The Sequent Symmetry multiprocessor (model B) [16] has a non-adaptive snooping protocol that uses a migrate-on-read-miss policy for all modified blocks.
Reference: [5] <author> D. Chaiken, J. Kubiatowicz, and A. Agarwal. </author> <title> LimitLESS directories: a scalable cache coherence scheme. </title> <booktitle> In Proceedings of the 4th Symposium on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 224-234, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: The Sequent Symmetry multiprocessor (model B) [16] has a non-adaptive snooping protocol that uses a migrate-on-read-miss policy for all modified blocks. This policy is also used in the directory-based coherency mechanism of the MIT Alewife <ref> [5] </ref> system. While this policy is optimal for migratory data, using it on data with other sharing patterns causes additonal read misses. Thakkar [22] observes that read cycles dominate bus traffic on the Sequent and states that the extra read misses caused by this policy contribute significantly to this traffic.
Reference: [6] <author> A. L. Cox. </author> <title> The Implementation and Evaluation of a Coherent Memory Abstraction for NUMA Multiprocessors. </title> <type> PhD thesis, </type> <institution> University of Rochester, Rochester, </institution> <address> NY, </address> <month> May </month> <year> 1992. </year>
Reference: [7] <author> A.L. Cox and R.J. Fowler. </author> <title> The implementation of a coherent memory abstraction on a NUMA multiprocessor: experiences with PLATINUM. </title> <booktitle> In Proceedings of the 12th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 32-44, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: Although these effects are minimal for migratory data, using a poor page placement algorithm would result in a overall inflated estimate of the total number of messages needed. The simulator therefore attempts to find a reasonable page placement. Rather than attempting to simulate a general dynamic NUMA page-placement protocol <ref> [7] </ref>, we use a simple dynamic technique for finding a good static placement that is similar to those used by Bolosky et al. [3] and Stenstrom et al. [21]. We assume that private data and code could have been placed and replicated perfectly to eliminate inter-node message traffic.
Reference: [8] <author> H. Davis, S. Goldschmidt, and J. L. Hennessy. </author> <note> Tango: </note>
Reference-contexts: We used Tango <ref> [8] </ref> to perform execution-driven simulation and to generate shared-memory access traces for each program in our benchmark suite. To estimate the impact on execution time for one architecture, we performed execution-driven simulation using a version of dixie, a Tango memory system simulator for DASH, that implements the adaptive protocol.
References-found: 8

