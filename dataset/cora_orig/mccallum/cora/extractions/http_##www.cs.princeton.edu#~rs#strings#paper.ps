URL: http://www.cs.princeton.edu/~rs/strings/paper.ps
Refering-URL: http://www.cs.princeton.edu/~rs/strings/index.html
Root-URL: http://www.cs.princeton.edu
Title: Fast Algorithms for Sorting and Searching Strings  
Author: Jon L. Bentley* Robert Sedgewick# 
Abstract: We present theoretical algorithms for sorting and searching multikey data, and derive from them practical C implementations for applications in which keys are character strings. The sorting algorithm blends Quicksort and radix sort; it is competitive with the best known C sort codes. The searching algorithm blends tries and binary search trees; it is faster than hashing and other commonly used search methods. The basic ideas behind the algorithms date back at least to the 1960s, but their practical utility has been overlooked. We also present extensions to more complex string problems, such as partial-match searching. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Appel, A.W. and Jacobson, G.J. </author> <title> The World's Fastest Scrabble Program. </title> <journal> Communications of the ACM 31, </journal> <month> 5 (May </month> <year> 1988), </year> <pages> 572-578. </pages>
Reference-contexts: Searching the dictionary for the pattern ``.o.o.o'' matches the single word rococo, while the pattern ``.a.a.a'' matches many words, including banana, casaba, and pajama. This problem has been studied by many researchers, including Appel and Jacobson <ref> [1] </ref> and Manber and Baeza-Yates [13]. Rivest [19] presents an algorithm for partial-match searching in tries: take the single given branch if a letter is specified, for a don't-care character, recursively search all branches.
Reference: 2. <author> Bentley, J.L. and McIlroy, </author> <title> M.D. Engineering A Sort Function. </title> <journal> Software-Practice and Experience 23, </journal> <volume> 1 (1993), </volume> <pages> 1249-1265. </pages>
Reference-contexts: Dijkstra's ternary algorithm requires linear time (it looks at each element exactly once), but code to implement it has a significantly larger constant factor than Hoare's binary partitioning code. Wegner [27] describes more efficient ternary partitioning schemes. Bentley and McIlroy <ref> [2] </ref> present a ternary partition based on this counterintuitive loop invariant: = &lt; ? &gt; = The main partitioning loop has two inner loops. The first inner loop moves up the index b: it scans over lesser elements, swaps equal elements to a, and halts on a greater element. <p> the array back to their proper place in the middle. void vecswap (int i, int j, int n, char *x []) - while (n-- &gt; 0) - swap (i, j); i++; - The complete sorting algorithm is in Program 1; it is similar to the code of Bentley and McIlroy <ref> [2] </ref>. The function is originally called by void ssort1main (char *x [], int n) - ssort1 (x, n, 0); - After partitioning, we recursively sort the lesser and greater segments, and sort the equal segment if the corresponding character is not zero.
Reference: 3. <author> Bentley, J.L., McIlroy, M.D., and Knuth, D.E. </author> <title> Programming Pearls: A Literate Program. </title> <journal> Communications of the ACM 29, </journal> <month> 6 (June </month> <year> 1986), </year> <pages> 471-483. </pages>
Reference-contexts: Ternary search trees may be thought of as a trie implementation that gracefully adapts to handle this case, at the cost of slightly more work for full nodes. Ternary search trees are also easy to implement; compare our code, for instance, to Knuth's implementation of ``hash tries'' <ref> [3] </ref> . Ternary search trees have been used for over a year to represent English dictionaries in a commercial Optical Character Recognition (OCR) system built at Bell Labs. The trees were faster than hashing for the task, and they gracefully handle the 34,000-character set of the Unicode Standard.
Reference: 4. <author> Bentley, J.L. and Saxe, J.B. </author> <title> Algorithms on Vector Sets. SIGACT News 11, </title> <booktitle> 9 (Fall 1979), </booktitle> <pages> 36-39. </pages>
Reference-contexts: Mehlhorn [17] proposes a weight-balanced ternary search tree that searches, inserts and deletes ele ments in a set of n strings of length k in O ( log n + k) time; a similar structure is described in Section III.6.3 of Mehlhorn's text [16]. Bentley and Saxe <ref> [4] </ref> propose a perfectly balanced ternary search tree structure. The value of each node is the median of the set of elements in the relevant dimension; the tree in Figure 1 was constructed by this criterion. <p> Vaishnavi [25] and Sleator and Tar-jan [24] present schemes for balancing ternary search trees. 4. Analysis We will start by analyzing ternary search trees, and then apply those results to multikey Quicksort. Our first theorem is due to Bentley and Saxe <ref> [4] </ref>. Theorem 5. [Bentley and Saxe] A search in a perfectly balanced ternary search tree representing n k-vectors requires at most lg n + k scalar comparisons, and this is optimal. Proof Sketch.
Reference: 5. <author> Clampett, H.A. Jr. </author> <title> Randomized Binary Searching with Tree Structures. </title> <journal> Communications of the ACM 7, </journal> <month> 3 (March </month> <year> 1964), </year> <pages> 163-165. </pages>
Reference-contexts: A search for ``ax'' makes three comparisons to the first letter (``a'') and two comparisons to the second letter (``x'') before reporting that the word is not in the tree. This idea dates back at least as far as 1964; see, for example, Clampett <ref> [5] </ref>. Prior authors had proposed representing the children of a trie node by an array or by a linked list; Clampett represents the set of children with a binary search tree; his structure can be viewed as a ternary search tree.
Reference: 6. <author> Dijkstra, </author> <title> E.W. A Discipline of Programming. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1976. </year>
Reference-contexts: Unfortunately, no efficient method for doing so has yet been devised....'' Dijkstra <ref> [6] </ref> popularized this as ``The Problem of the Dutch National Flag'': we are to order a sequence of red, white and blue pebbles to appear in their order on Holland's ensign.
Reference: 7. <author> Flajolet, P. and Puech, C. </author> <title> Partial Match Retrieval of Multidimensional Data. </title> <journal> Journal of the ACM 33, </journal> <month> 2 (April </month> <year> 1986), </year> <pages> 371-407. </pages>
Reference-contexts: For this very reason, Rivest suggests that binary tries should ``branch on the first bit of the representation of each character ... before branching on the second bit of each''. Fla-jolet and Puech <ref> [7] </ref> analyzed this phenomenon in detail for bit tries; their methods can be extended to provide a detailed explanation of search costs as a function of unspecified query positions. - 9 - Nodes _ __________________ Pattern Matches Balanced Random _ ___________________________________________ television 1 18 24 tele...... 17 261 265 t.l.v.s..n 1
Reference: 8. <author> Floyd, R.W. and Rivest, </author> <title> R.L. Expected Time Bounds for Selection. </title> <journal> Communications of the ACM 18, </journal> <month> 3 (March </month> <year> 1975), </year> <pages> 165-172. </pages>
Reference-contexts: To guarantee worst-case performance, we partition 31 41 59 26 53 26 41 59 53 53 26 41 53 around the true median, which can be computed in cn comparisons. (Schoenhage, Paterson and Pippenger [20] give a worst-case algorithm that establishes the constant c = 3; Floyd and Rivest <ref> [8] </ref> give an expected-time algorithm with c = 3/2.) Theorem 3. A Quicksort that partitions around a median computed in cn comparisons sorts n elements in cn lg n + O (n) comparisons.
Reference: 9. <author> Hoare, </author> <title> C.A.R. Quicksort. </title> <journal> Computer Journal 5, </journal> <month> 1 (April </month> <year> 1962), </year> <pages> 10-15. </pages>
Reference-contexts: 1. Introduction Section 2 briefly reviews Hoare's <ref> [9] </ref> Quicksort and binary search trees. We emphasize a well-known isomor-phism relating the two, and summarize other basic facts. The multikey algorithms and data structures are presented in Section 3. Multikey Quicksort orders a set of n vectors with k components each. <p> This code partitions an n-element array using n - 1 comparisons. Quicksort has been extensively analyzed by authors including Hoare <ref> [9] </ref>, van Emden [26], Knuth [11], and Sedgewick [23]. Most detailed analyses involve the har monic numbers H n = S 1in 1/ i. <p> The primitive operation is to perform a ternary comparison between two components. Munro and Raman [18] describe an algorithm for sorting vector sets in-place, and their references describe previous work in the area. Hoare <ref> [9] </ref> sketches a Quicksort modification due to P.
Reference: 10. <author> Kernighan, B.W. and Ritchie, </author> <title> D.M. The C Programming Language, Second Edition. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1988. </year>
Reference-contexts: This is the primary practical contribution of this paper. We assume that the reader is familiar with the C programming language described by Kernighan and Ritchie <ref> [10] </ref>. C represents characters as small integers, which can be easily compared. Strings are represented as vectors of characters. The structures and theorems that we have seen so far apply immediately to sets of strings of a fixed length. <p> The typical implementation of symbol tables is hashing. To represent n strings, we will use a chained hash table of size tabsize = n. The hash function is from Section 6.6 of Kernighan and Ritchie <ref> [10] </ref>; it is reasonably efficient and produces good spread. int hashfunc (char *s) - unsigned n = 0; for ( ; *s; s++) return n % tabsize; - Here is the body of the search function: for (p = tab [hashfunc (s)]; p; p = p-&gt;next) if (strcmp (s, p-&gt;str) ==
Reference: 11. <author> Knuth, D.E. </author> <title> The Art of Computer Programming, volume 3: Sorting and Searching. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1975. </year>
Reference-contexts: This code partitions an n-element array using n - 1 comparisons. Quicksort has been extensively analyzed by authors including Hoare [9], van Emden [26], Knuth <ref> [11] </ref>, and Sedgewick [23]. Most detailed analyses involve the har monic numbers H n = S 1in 1/ i. Theorem 1. [Hoare] A Quicksort that partitions around a single randomly selected element sorts n distinct items in 2nH n + O (n) ~ ~ 1. 386n lg n expected comparisons. <p> The proof observes that the recursion tree has about lg n levels and does at most cn comparisons on each level. The Quicksort algorithm is closely related to the data structure of binary search trees (for more on the data structure, see Knuth <ref> [11] </ref>). Figure 1 shows the operation of both on the input sequence ``31 41 59 26 53''. The tree on the right is the standard binary search tree formed by inserting the elements in input order. <p> By analogy to Theorem 3, a perfectly balanced subtree decreases the search time to about lg n. - 3 - 3. The Algorithms Just as Quicksort is isomorphic to binary search trees, so (most-significant-digit) radix sort is isomorphic to digital search tries (see Knuth <ref> [11] </ref>). These isomorphisms are described in this table: ____________________________________ ____________________________________ Algorithm Data Structure ____________________________________ Quicksort Binary Search Trees Multikey Quicksort Ternary Search Trees MSD Radix Sort Tries ____________________________________ This section introduces the algorithm and data structure in the middle row of the table. <p> segment comprises all the items, and only those items, which have key values identical to a given value over the first n words, in partitioning this segment, comparison is made of the (n + 1 )th word of the keys.'' Hoare gives an awkward implementation of this elegant idea; Knuth <ref> [11] </ref> gives details on Shackleton's scheme in Solution 5.2.2.30. A ternary partitioning algorithm provides an elegant implementation of Hoare's multikey Quicksort. <p> As with binary search trees, ternary trees may be perfectly balanced, constructed by inserting elements in random order, or partially balanced by a variety of schemes. In Section 6.2.2, Knuth <ref> [11] </ref> builds an optimal binary search tree to represent the 31 most common words in English; twelve of those words have two letters. <p> Ternary search trees appear to be quite robust. - 7 - We conducted simple experiments to see how ternary search trees compare to other symbol table structures described by Knuth <ref> [11] </ref>. We first measured binary search, which can be viewed as an implementation of perfectly balanced binary search trees. For the same input set, binary search uses 15.19 string comparisons and inspects 51.74 characters, on the average (the average string comparison inspects 3.41 characters).
Reference: 12. <author> Linderman, J.P. </author> <title> Theory and Practice in the Construction of a Working Sort Routine. </title> <journal> Bell System Technical Journal 63, </journal> <month> 8 (October </month> <year> 1984), </year> <pages> 1827-1843. </pages>
Reference-contexts: This does not, however, exhaust the application of the underlying algorithm. We believe that multikey Quicksort might also be practical in multifield system sorts, such as that described by Linder-man <ref> [12] </ref>. One might also use the algorithm to sort integers, for instance, by comparing them byte-by-byte. Section 5 shows that ternary search trees provide an efficient implementation of string symbol tables, and Section 6 shows that the structures can quickly answer more advanced queries.
Reference: 13. <author> Manber, U. and Baeza-Yates, R. </author> <title> An Algorithm for String Matching with a Sequence of Don't Cares. </title> <journal> Information Processing Letters 37, </journal> <month> 3 (February </month> <year> 1991), </year> <pages> 133-136. </pages>
Reference-contexts: Searching the dictionary for the pattern ``.o.o.o'' matches the single word rococo, while the pattern ``.a.a.a'' matches many words, including banana, casaba, and pajama. This problem has been studied by many researchers, including Appel and Jacobson [1] and Manber and Baeza-Yates <ref> [13] </ref>. Rivest [19] presents an algorithm for partial-match searching in tries: take the single given branch if a letter is specified, for a don't-care character, recursively search all branches.
Reference: 14. <author> Manber, U. and Myers, G. </author> <title> Suffix Arrays: A New Method for On-Line String Searches. </title> <journal> SIAM Journal on Computing 22 (1993), </journal> <pages> 935-948. </pages>
Reference-contexts: For the lower bound, consider a vector set in which all elements are equal in the first k - 1 dimensions and distinct in the k th dimension. Similar search times for the suffix tree data structure are reported by Manber and Myers <ref> [14] </ref>. We will next consider the multikey Quicksort that always partitions around the median element of the subset. This theorem corresponds to Theorem 3. Theorem 6.
Reference: 15. <author> McIlroy, P.M., Bostic, K., and McIlroy, </author> <title> M.D. Engineering Radix Sort. </title> <booktitle> Computing Systems 6, 1 (1993), </booktitle> <pages> 5-27. </pages>
Reference-contexts: A C program to sort strings of our tuned sort, which is always substantially faster than the simple version. As a benchmark, the final column describes the run time of the highly tuned radix sort of McIlroy, Bostic and McIlroy <ref> [15] </ref>; it is the fastest string sort that we know.
Reference: 16. <author> Mehlhorn, K. </author> <title> Data Structures and Algorithms 1: Sorting and Searching. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1984. </year>
Reference-contexts: Mehlhorn [17] proposes a weight-balanced ternary search tree that searches, inserts and deletes ele ments in a set of n strings of length k in O ( log n + k) time; a similar structure is described in Section III.6.3 of Mehlhorn's text <ref> [16] </ref>. Bentley and Saxe [4] propose a perfectly balanced ternary search tree structure. The value of each node is the median of the set of elements in the relevant dimension; the tree in Figure 1 was constructed by this criterion.
Reference: 17. <author> Mehlhorn, K. </author> <title> Dynamic Binary Search. </title> <journal> SIAM Journal on Computing 8, </journal> <month> 2 (May </month> <year> 1979), </year> <pages> 175-198. </pages>
Reference-contexts: Prior authors had proposed representing the children of a trie node by an array or by a linked list; Clampett represents the set of children with a binary search tree; his structure can be viewed as a ternary search tree. Mehlhorn <ref> [17] </ref> proposes a weight-balanced ternary search tree that searches, inserts and deletes ele ments in a set of n strings of length k in O ( log n + k) time; a similar structure is described in Section III.6.3 of Mehlhorn's text [16].
Reference: 18. <author> Munro, J.I. and Raman, V. </author> <title> Sorting Multisets and Vectors In-Place. </title> <booktitle> Proceedings of the Second Workshop on Algorithms and Data Structures, Springer Verlag Lecture Notes in Computer Science 519 (1991), </booktitle> <pages> 473-480. </pages>
Reference-contexts: We will phrase the problems in terms of a set of n vectors, each of which has k components. The primitive operation is to perform a ternary comparison between two components. Munro and Raman <ref> [18] </ref> describe an algorithm for sorting vector sets in-place, and their references describe previous work in the area. Hoare [9] sketches a Quicksort modification due to P. <p> Combine Theorem 2 with the observation that equal elements strictly decrease the number of comparisons. The additive cost of O (kn) accounts for inspecting all k keys. By increasing the sample size t, one can reduce the time to near n lg n + O (kn). (Munro and Raman <ref> [18] </ref> describe an in-place vector sort with that running time.) We will now turn from sorting to analogous results about building ternary search trees.
Reference: 19. <author> Rivest, </author> <title> R.L. Partial-Match Retrieval Algorithms. </title> <journal> SIAM Journal on Computing 5, </journal> <volume> 1 (1976), </volume> <pages> 19-50. </pages>
Reference-contexts: Searching the dictionary for the pattern ``.o.o.o'' matches the single word rococo, while the pattern ``.a.a.a'' matches many words, including banana, casaba, and pajama. This problem has been studied by many researchers, including Appel and Jacobson [1] and Manber and Baeza-Yates [13]. Rivest <ref> [19] </ref> presents an algorithm for partial-match searching in tries: take the single given branch if a letter is specified, for a don't-care character, recursively search all branches.
Reference: 20. <author> Schoenhage, A.M., Paterson, M., and Pippenger, N. </author> <title> Finding the Median. </title> <journal> Journal of Computer and Systems Sciences 13 (1976), </journal> <pages> 184-199. </pages>
Reference-contexts: The theorems so far deal only with the expected performance. To guarantee worst-case performance, we partition 31 41 59 26 53 26 41 59 53 53 26 41 53 around the true median, which can be computed in cn comparisons. (Schoenhage, Paterson and Pippenger <ref> [20] </ref> give a worst-case algorithm that establishes the constant c = 3; Floyd and Rivest [8] give an expected-time algorithm with c = 3/2.) Theorem 3. A Quicksort that partitions around a median computed in cn comparisons sorts n elements in cn lg n + O (n) comparisons.
Reference: 21. <author> Sedgewick, R. </author> <title> Implementing Quicksort Programs. </title> <journal> Communications of the ACM 21, </journal> <month> 10 (October </month> <year> 1978), </year> <pages> 847-857. </pages>
Reference-contexts: We can tune the performance of Program 1 using standard techniques such as those described by Sedgewick <ref> [21] </ref>. Algorithmic speedups include sorting small subar-rays with insertion sort and partitioning around the median of three elements (and on larger arrays, the median of three medians of three) to exploit Theorem 7. Standard C coding techniques include replacing array indices with pointers.
Reference: 22. <author> Sedgewick, R. </author> <title> Quicksort With Equal Keys. </title> <journal> SIAM J. </journal> <volume> Comp 6, </volume> <month> 2 (June </month> <year> 1977), </year> <pages> 240-267. </pages>
Reference-contexts: Algorithm designers have long recognized the desirability and difficulty of a ternary partitioning method. Sedgewick <ref> [22] </ref> observes on page 244: ``Ideally, we would like to get all [equal keys] into position in the file, with all - 2 - the keys with a smaller value to their left, and all the keys with a larger value to their right.
Reference: 23. <author> Sedgewick, R. </author> <title> The Analysis of Quicksort Programs. </title> <journal> Acta Informatica 7 (1977), </journal> <pages> 327-355. </pages>
Reference-contexts: This code partitions an n-element array using n - 1 comparisons. Quicksort has been extensively analyzed by authors including Hoare [9], van Emden [26], Knuth [11], and Sedgewick <ref> [23] </ref>. Most detailed analyses involve the har monic numbers H n = S 1in 1/ i. Theorem 1. [Hoare] A Quicksort that partitions around a single randomly selected element sorts n distinct items in 2nH n + O (n) ~ ~ 1. 386n lg n expected comparisons.
Reference: 24. <author> Sleator, D.D. and Tarjan, R.E. </author> <title> Self-Adjusting Binary Search Trees. </title> <journal> Journal of the ACM 32, </journal> <month> 3 (July </month> <year> 1985), </year> <pages> 652-686. </pages>
Reference-contexts: Ternary search trees may be built in a variety of ways, such as by inserting elements in input order or by building a perfectly balanced tree for a completely specified set. Vaishnavi [25] and Sleator and Tar-jan <ref> [24] </ref> present schemes for balancing ternary search trees. 4. Analysis We will start by analyzing ternary search trees, and then apply those results to multikey Quicksort. Our first theorem is due to Bentley and Saxe [4].
Reference: 25. <author> Vaishnavi, V.K. </author> <title> Multidimensional Height-Balanced Trees. </title> <journal> IEEE Transactions on Computers C-33, </journal> <month> 4 (April </month> <year> 1984), </year> <pages> 334-343. </pages> <note> 26. </note> <author> van Emden, M.H. </author> <title> Increasing the Efficiency of Quick-sort. </title> <journal> Communications of the ACM 13, </journal> <month> 9 (September </month> <year> 1970), </year> <pages> 563-567. </pages>
Reference-contexts: Ternary search trees may be built in a variety of ways, such as by inserting elements in input order or by building a perfectly balanced tree for a completely specified set. Vaishnavi <ref> [25] </ref> and Sleator and Tar-jan [24] present schemes for balancing ternary search trees. 4. Analysis We will start by analyzing ternary search trees, and then apply those results to multikey Quicksort. Our first theorem is due to Bentley and Saxe [4].
Reference: 27. <author> Wegner, L.M. </author> <title> Quicksort for Equal Keys. </title> <journal> IEEE Transactions on Computers C-34, </journal> <month> 4 (April </month> <year> 1985), </year> <pages> 362-367. </pages>
Reference-contexts: Dijkstra's ternary algorithm requires linear time (it looks at each element exactly once), but code to implement it has a significantly larger constant factor than Hoare's binary partitioning code. Wegner <ref> [27] </ref> describes more efficient ternary partitioning schemes. Bentley and McIlroy [2] present a ternary partition based on this counterintuitive loop invariant: = &lt; ? &gt; = The main partitioning loop has two inner loops.
References-found: 26

