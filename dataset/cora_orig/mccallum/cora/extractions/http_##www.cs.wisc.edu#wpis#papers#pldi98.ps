URL: http://www.cs.wisc.edu/wpis/papers/pldi98.ps
Refering-URL: http://www.cs.wisc.edu/~hasti/
Root-URL: 
Email: horwitzg@cs.wisc.edu  
Title: Using Static Single Assignment Form to Improve Flow-Insensitive Pointer Analysis  
Author: Rebecca Hasti and Susan Horwitz 
Note: Electronic mail: fhasti,  
Address: 1210 West Dayton Street, Madison, WI 53706 USA  
Affiliation: Computer Sciences Department, University of Wisconsin-Madison  
Abstract: A pointer-analysis algorithm can be either flowsensitive or flow-insensitive. While flow-sensitive analysis usually provides more precise information, it is also usually considerably more costly in terms of time and space. The main contribution of this paper is the presentation of another option in the form of an algorithm that can be `tuned' to provide a range of results that fall between the results of flow-insensitive and flow-sensitive analysis. The algorithm combines a flow-insensitive pointer analysis with static single assignment (SSA) form and uses an iterative process to obtain progressively better results. 
Abstract-found: 1
Intro-found: 1
Reference: [And94] <author> L. O. Andersen. </author> <title> Program Analysis and Specialization for the C Programming Language. </title> <type> PhD thesis, </type> <institution> DIKU, University of Copenhagen, </institution> <month> May </month> <year> 1994. </year> <type> (DIKU report 94/19). </type>
Reference-contexts: Moreover, the resulting program can be quadratic in the size of the original program. However, experimental evidence suggests that both the time to translate and the size of the translated program are linear in practice [CFR + 91] [CC95]. Andersen <ref> [And94] </ref> gives a flow-insensitive pointer-analysis algorithm that computes the greatest fixed point of the set of equations (2) given in Section 1.1. Andersen's algorithm is cubic in the worst case. <p> We are currently working on implementations of our algorithm using the flow-insensitive pointer analyses defined in <ref> [And94] </ref>, [Ste96], and [SH97]. We plan to use the implementations to explore how our algorithm compares to flowsensitive points-to analysis in practice. 5 Acknowledgement Thanks to Charles Consel, whose question about using SSA form in pointer analysis inspired this work.
Reference: [BCCH94] <author> M. Burke, P. Carini, J.D. Choi, and M. Hind. </author> <title> Flow-insensitive interprocedural alias analysis in the presence of pointers. </title> <editor> In K. Pingali, U. Baner-jee, D. Galernter, A. Nicolau, and D. Padua, editors, </editor> <booktitle> Languages and Compilers for Parallel Computing: Proceedings of the 7th International Workshop, volume 892 of Lecture Notes in Computer Science, </booktitle> <pages> pages 234-250, </pages> <address> Ithaca, NY, </address> <month> August </month> <year> 1994. </year> <note> Springer-Verlag. </note>
Reference-contexts: Lapkowski and Hendren [LH96] also discuss the problems with SSA form in the presence of pointers. However, they abandon SSA form and develop instead a related analysis called SSA Numbering. Others have worked on improving the precision of flow-insensitive alias analysis. In <ref> [BCCH94] </ref> Burke et al. develop an approach that involves using pre-computed kill information, although an empirical study by Hind and Pioli [HP97] does not show it to be more precise in practice than a flow-insensitive analysis.
Reference: [CC95] <author> C. Click and K.D. Cooper. </author> <title> Combining analyses, combining optimizations. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(2) </volume> <pages> 181-196, </pages> <year> 1995. </year>
Reference-contexts: Moreover, the resulting program can be quadratic in the size of the original program. However, experimental evidence suggests that both the time to translate and the size of the translated program are linear in practice [CFR + 91] <ref> [CC95] </ref>. Andersen [And94] gives a flow-insensitive pointer-analysis algorithm that computes the greatest fixed point of the set of equations (2) given in Section 1.1. Andersen's algorithm is cubic in the worst case.
Reference: [CFR + 91] <author> R. Cytron, J. Ferrante, B.K. Rosen, M.N. Weg-man, and F.K. Zadeck. </author> <title> Efficiently computing static single assignment form and the control dependence graph. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(4) </volume> <pages> 451-490, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Also note that, although the results of flow-insensitive analysis are not as precise as the results of flowsensitive analysis, they do provide some useful information. 1.2 Using SSA form to improve flow-insensitive analysis Static Single Assignment (SSA) form <ref> [CFR + 91] </ref> is a program representation in which variables are renamed (via subscripting) and new definitions inserted to ensure that: 1 When we say that some fact is true at a particular point, we mean that the fact is true immediately before that point. 1. <p> Moreover, the resulting program can be quadratic in the size of the original program. However, experimental evidence suggests that both the time to translate and the size of the translated program are linear in practice <ref> [CFR + 91] </ref> [CC95]. Andersen [And94] gives a flow-insensitive pointer-analysis algorithm that computes the greatest fixed point of the set of equations (2) given in Section 1.1. Andersen's algorithm is cubic in the worst case.
Reference: [CG93] <author> R. Cytron and R. Gershbein. </author> <title> Efficient accommodation of may-alias information in SSA form. </title> <booktitle> SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <volume> 28(6) </volume> <pages> 36-45, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: that it would be as good as a flow-sensitive analysis that computes the greatest fixed point of the set of equations (1). 7 Original CFGs Corresponding Supergraph (a) (b) 8 3 Related Work A program representation similar to the intermediate form described here was used by Cytron and Gershbein in <ref> [CG93] </ref>, where they give an algorithm for incrementally incorporating points-to information into SSA form. Our intermediate representation is essentially an inlined version of Cytron and Gershbein's IsAlias function.
Reference: [Hor97] <author> S. Horwitz. </author> <title> Precise flow-insensitive may-alias analysis is NP-hard. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 19(1) </volume> <pages> 1-6, </pages> <month> January </month> <year> 1997. </year>
Reference-contexts: a 1 = 3 a 2 = (a 1 ; a 0 ) c = a + b c 1 = a 2 + b 0 (2) print (c) print (c 1 ) (3) (a) Original (b) SSA Form an edge from each node to every other node (including itself) <ref> [Hor97] </ref>.
Reference: [HP97] <author> M. Hind and A. Pioli. </author> <title> An empirical comparison of interprocedural pointer alias analyses. </title> <type> IBM Research Report RC 21058, </type> <institution> IBM Research Division, </institution> <month> December </month> <year> 1997. </year>
Reference-contexts: However, they abandon SSA form and develop instead a related analysis called SSA Numbering. Others have worked on improving the precision of flow-insensitive alias analysis. In [BCCH94] Burke et al. develop an approach that involves using pre-computed kill information, although an empirical study by Hind and Pioli <ref> [HP97] </ref> does not show it to be more precise in practice than a flow-insensitive analysis.
Reference: [Kil73] <author> G.A. Kildall. </author> <title> A unified approach to global program optimization. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 194-206, </pages> <month> January </month> <year> 1973. </year>
Reference-contexts: In this paper, all analyses are assumed to be context-insensitive.) One way to think about flow-insensitive analysis is in terms of a variation on the standard dataflow framework <ref> [Kil73] </ref>. The standard framework includes: 1. a lattice of dataflow facts, 2. a set of monotonic dataflow functions, 3. a control flow graph (CFG), 4. a mapping that associates one dataflow function with each graph node (we use f n to denote the function mapped to node n). <p> The ideal goal of a flow-sensitive analysis is to find the meet-over-all-paths solution to the dataflow problem <ref> [Kil73] </ref>.
Reference: [LH96] <author> C. Lapkowski and L.J. Hendren. </author> <title> Extended SSA numbering: Introducing SSA properties to languages with multi-level pointers. </title> <type> ACAPS Technical Memo 102, </type> <institution> School of Computer Science, McGill University, Montreal, Canada, </institution> <month> April </month> <year> 1996. </year>
Reference-contexts: Our intermediate representation is essentially an inlined version of Cytron and Gershbein's IsAlias function. However, their algorithm requires pre-computed may-alias information and incorporates points-to information as needed into a partial SSA form while solving another dataflow problem (constant propagation, in their paper). Lapkowski and Hendren <ref> [LH96] </ref> also discuss the problems with SSA form in the presence of pointers. However, they abandon SSA form and develop instead a related analysis called SSA Numbering. Others have worked on improving the precision of flow-insensitive alias analysis.
Reference: [LR91] <author> W. Landi and B.G. Ryder. </author> <title> Pointer induced aliasing: A problem classification. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 93-103, </pages> <year> 1991. </year>
Reference-contexts: Figure 7 (a) shows the CFGs for the program in 2 The term supergraph was first used by Eugene Myers in [Mye81]. William Landi and Barbara Ryder <ref> [LR91] </ref> use the term interprocedu-ral control flow graph (ICFG).
Reference: [Mye81] <author> E.W. Myers. </author> <title> A precise inter-procedural data flow algorithm. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 219-230, </pages> <year> 1981. </year>
Reference-contexts: Figure 7 (a) shows the CFGs for the program in 2 The term supergraph was first used by Eugene Myers in <ref> [Mye81] </ref>. William Landi and Barbara Ryder [LR91] use the term interprocedu-ral control flow graph (ICFG).
Reference: [SG95] <author> V.C. Sreedhar and G.R. Gao. </author> <title> A linear time algorithm for placing -nodes. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 62-73, </pages> <year> 1995. </year>
Reference-contexts: Figure 8 gives the algorithm from Figure 3 updated to handle multiple CFGs. 2.2 Complexity Each iteration of our algorithm requires a transformation to SSA form and a flow-insensitive pointer analysis. Although there exists a linear-time algorithm for placing nodes <ref> [SG95] </ref>, the renaming phase of translation to SSA form can take cubic time in the worst case. Thus, in the worst case, the time needed to completely translate a program into SSA form (including renaming) is cubic.
Reference: [SH97] <author> M. Shapiro and S. Horwitz. </author> <title> Fast and accurate flow-insensitive points-to analysis. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-14, </pages> <month> January </month> <year> 1997. </year>
Reference-contexts: Andersen [And94] gives a flow-insensitive pointer-analysis algorithm that computes the greatest fixed point of the set of equations (2) given in Section 1.1. Andersen's algorithm is cubic in the worst case. Experimental evidence intended to evaluate the algorithm's performance in practice <ref> [SH97] </ref> is inconclusive: on small programs (up to about 10,000 lines) its performance is very similar to that of Steensgaard's (essentially) linear-time algorithm [Ste96]; however, lines of code alone does not seem to be a good predictor of runtime (for example, one 6,000 line program required over 700 CPU seconds, while <p> In [BCCH94] Burke et al. develop an approach that involves using pre-computed kill information, although an empirical study by Hind and Pioli [HP97] does not show it to be more precise in practice than a flow-insensitive analysis. Shapiro and Horwitz <ref> [SH97] </ref> give an algorithm that can be `tuned' so that its precision as well as worst-case time and space requirements range from those of Steensgaard's (almost linear, less precise flow-insensitive) algorithm to those of Andersen's (cubic worst-case but more precise flow-insensitive) algorithm. 4 Conclusions We have presented a new iterative points-to <p> We are currently working on implementations of our algorithm using the flow-insensitive pointer analyses defined in [And94], [Ste96], and <ref> [SH97] </ref>. We plan to use the implementations to explore how our algorithm compares to flowsensitive points-to analysis in practice. 5 Acknowledgement Thanks to Charles Consel, whose question about using SSA form in pointer analysis inspired this work.
Reference: [Ste96] <author> B. Steensgaard. </author> <title> Points-to analysis in almost linear time. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 32-41, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: Andersen's algorithm is cubic in the worst case. Experimental evidence intended to evaluate the algorithm's performance in practice [SH97] is inconclusive: on small programs (up to about 10,000 lines) its performance is very similar to that of Steensgaard's (essentially) linear-time algorithm <ref> [Ste96] </ref>; however, lines of code alone does not seem to be a good predictor of runtime (for example, one 6,000 line program required over 700 CPU seconds, while several 7,000 line programs required only 3 seconds). Note that our algorithm could make use of a fast algorithm like Steensgaard's. <p> We are currently working on implementations of our algorithm using the flow-insensitive pointer analyses defined in [And94], <ref> [Ste96] </ref>, and [SH97]. We plan to use the implementations to explore how our algorithm compares to flowsensitive points-to analysis in practice. 5 Acknowledgement Thanks to Charles Consel, whose question about using SSA form in pointer analysis inspired this work.
References-found: 14

