URL: http://www.cse.psu.edu/~catuscia/papers/concon/tapsoft.ps.gz
Refering-URL: http://www.cse.psu.edu/~catuscia/publications.html
Root-URL: http://www.cse.psu.edu
Email: email: katuscia@cwi.nl  
Phone: 2  2  
Title: A Fully Abstract Model for Concurrent Constraint Programming  
Author: Frank S. de Boer and Catuscia Palamidessi 
Date: February 19, 1996  
Address: P.O. Box 513, 5600 MB Eindhoven, The Netherlands  Corso Italia 40, 56125 Pisa, Italy  P.O. Box 4079, 1009 AB Amsterdam, The Netherlands  
Affiliation: 1 Technische Universiteit Eindhoven,  Dipartimento di Informatica, Universita di Pisa,  Centre for Mathematics and Computer Science,  
Abstract: Recent results [5] have shown that concurrent Logic programming has a very simple model, based on linear sequences, which is fully abstract with respect to the parallel operator and finite observables. This is intrinsically related to the asynchronous and monotonic nature of the communication mechanism, which consists of asking and telling constraints on a common store. We consider here a paradigm for (asynchronous) concurrent programming, based on the above mechanism, and provided with the standard operators of choice, parallelism, prefixing, and hiding of local variables. It comes out that linear sequences still suffice for a compositional description of all the operators. Moreover, we consider the problem of full abstraction. Since our notion of observables implies the removal of silent steps, the presence of the choice operator induces the same problems (for compositionality) as bisimulation in CCS. We show that in our framework this problem has a simple solution which consists of introducing a semantical distinction between the various ways in which deadlock and failure might occur. The resulting semantics is fully abstract and still based on linear sequences. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J.W. de Bakker and J.N. Kok. </author> <title> Uniform abstraction, atomicity and contractions in the comparative semantics of Concurrent Prolog. </title> <booktitle> In Proc. of the International Conference on Fifth Generation Computer Systems, </booktitle> <pages> pages 347-355, </pages> <address> Tokyo, Japan, </address> <year> 1988. </year> <note> OHMSHA, LTD. Extended Abstract, full version available as CWI report CS-8834. </note>
Reference: [2] <author> F.S. de Boer, J.N. Kok, C. Palamidessi, and J.J.M.M. Rutten. </author> <title> Control flow versus logic: a denotational and a declarative model for Guarded Horn Clauses. </title> <editor> In A. Kreczmar and G. Mirkowska, editors, </editor> <booktitle> Proc. of the Symposium on Mathematical Foundations of Computer Science, volume 379 of Lecture Notes in Computer Science, </booktitle> <pages> pages 165-176. </pages> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: As a consequence, the structural operational semantics and the problems of compositionality and full abstraction have been approached mostly by the standard methods (failure sets, trees, etc.) of the semantics of concurrency ([1], [11], <ref> [2] </ref>, [3], [7], [16], [9], [8]). We think that concurrent constraint languages require a different approach.
Reference: [3] <author> F.S. de Boer, J.N. Kok, C. Palamidessi, and J.J.M.M. Rutten. </author> <title> Semantic models for a version of PARLOG. </title> <editor> In Giorgio Levi and Maurizio Martelli, editors, </editor> <booktitle> Proc. of the Sixth International Conference on Logic Programming, Series in Logic Programming, </booktitle> <pages> pages 621-636, </pages> <address> Lisboa, </address> <year> 1989. </year> <note> The MIT Press. Extended version to appear in Theoretical Computer Science. </note>
Reference-contexts: As a consequence, the structural operational semantics and the problems of compositionality and full abstraction have been approached mostly by the standard methods (failure sets, trees, etc.) of the semantics of concurrency ([1], [11], [2], <ref> [3] </ref>, [7], [16], [9], [8]). We think that concurrent constraint languages require a different approach.
Reference: [4] <author> F.S. de Boer and C. Palamidessi. </author> <title> Concurrent logic languages: Asynchronism and language comparison. </title> <booktitle> In Proc. of the North American Conference on Logic Programming, Series in Logic Programming. </booktitle> <publisher> The MIT Press, </publisher> <year> 1990. </year> <type> Technical Report TR 6/90, </type> <institution> Dipartimento di Informatica, Universita di Pisa. </institution>
Reference-contexts: Again, this extended model is based on sequences of ask/tell actions plus some failure information coding the branching structure. To our knowledge, the first example of a compositional semantics just based on (assume/tell) linear sequences was given in <ref> [4] </ref>, [5] 1 . Those works, however, deal with a concurrent logic language, based on substitutions, which is indeterminate, but with no explicit choice operator (it is "hidden" in the clause union). The compositionality is treated only with respect to the parallel operator. <p> For the sake of simplicity we do not describe this mechanism in T . In the next section (when describing the compositional semantics) we will show a solution to the problem of renaming. The interested reader can find in <ref> [16, 4, 5] </ref> various alternative approaches to this problem. R1 and R2 indicate that Success and Fail end immediately in their corresponding termination modes. R3-R6 describe the way in which the communication actions deal with the store.
Reference: [5] <author> F.S. de Boer and C. Palamidessi. </author> <title> On the asynchronous nature of communication in concurrent logic languages: A fully abstract model based on sequences. </title> <booktitle> In Proc. of Concur 90, </booktitle> <address> The Netherlands, </address> <year> 1990. </year> <note> Full version available as report at the Technische Universiteit Eindhoven. </note>
Reference-contexts: Again, this extended model is based on sequences of ask/tell actions plus some failure information coding the branching structure. To our knowledge, the first example of a compositional semantics just based on (assume/tell) linear sequences was given in [4], <ref> [5] </ref> 1 . Those works, however, deal with a concurrent logic language, based on substitutions, which is indeterminate, but with no explicit choice operator (it is "hidden" in the clause union). The compositionality is treated only with respect to the parallel operator. <p> A similar solution was proposed in <ref> [5] </ref>, but the framework we use here (existentially quantified constraints) allows to express the saturation operator in a far more simple and elegant way. <p> For the sake of simplicity we do not describe this mechanism in T . In the next section (when describing the compositional semantics) we will show a solution to the problem of renaming. The interested reader can find in <ref> [16, 4, 5] </ref> various alternative approaches to this problem. R1 and R2 indicate that Success and Fail end immediately in their corresponding termination modes. R3-R6 describe the way in which the communication actions deal with the store.
Reference: [6] <author> M. Falaschi, M. Gabbrielli, G. Levi, and M. Murakami. </author> <title> Nested Guarded Horn Clauses: a language provided with a complete set of Unfolding Rules. </title> <booktitle> In Proc. of the Japanese National Conference on Logic Programming '89, </booktitle> <year> 1989. </year>
Reference-contexts: 1 Introduction The concurrent constraint paradigm [15], [16], [8], <ref> [6] </ref>, [7] represents a considerable improvement with respect to "classical" concurrent logic languages.
Reference: [7] <author> M. Gabbrielli and G. Levi. </author> <title> Unfolding and fixpoint semantics for concurrent constraint logic programs. </title> <editor> In Springer-Verlag, editor, </editor> <booktitle> Proc. of the Second Int. Conf. on Algebraic and Logic Programming, Lecture Notes in Computer Science, </booktitle> <address> Nancy, France, </address> <year> 1990. </year>
Reference-contexts: 1 Introduction The concurrent constraint paradigm [15], [16], [8], [6], <ref> [7] </ref> represents a considerable improvement with respect to "classical" concurrent logic languages. <p> As a consequence, the structural operational semantics and the problems of compositionality and full abstraction have been approached mostly by the standard methods (failure sets, trees, etc.) of the semantics of concurrency ([1], [11], [2], [3], <ref> [7] </ref>, [16], [9], [8]). We think that concurrent constraint languages require a different approach. <p> Moreover, we don't need an interleaving operator to compose these sequences. It is sufficient to pick up the ones that "match". Our sequences must not be confused with similar structures (sequences of ask/tell constraints, input/output substitutions etc.) used in [13], [8], <ref> [7] </ref> and [16]. Those structures are used there to represent the sequel of actions that a process will engage. <p> As a consequence, sequences of that kind contain less information and they are compositional only for the success set [13], whereas failure and deadlock still require some branching information. In [8] this branching information is given by failure and suspension sets, in <ref> [7] </ref> and [16] it is explicitly represented by a tree-like structure. A totally different approach has been developed in [17] for the determinate subcase of constraint logic programming.
Reference: [8] <author> H. Gaifman, M. J. Maher, and E. Shapiro. </author> <title> Reactive Behaviour semantics for Concurrent Constraint Logic Programs. </title> <editor> In E. Lusk and R. Overbeck, editors, </editor> <booktitle> North American Conference on Logic Programming, </booktitle> <year> 1989. </year>
Reference-contexts: 1 Introduction The concurrent constraint paradigm [15], [16], <ref> [8] </ref>, [6], [7] represents a considerable improvement with respect to "classical" concurrent logic languages. <p> As a consequence, the structural operational semantics and the problems of compositionality and full abstraction have been approached mostly by the standard methods (failure sets, trees, etc.) of the semantics of concurrency ([1], [11], [2], [3], [7], [16], [9], <ref> [8] </ref>). We think that concurrent constraint languages require a different approach. <p> Moreover, we don't need an interleaving operator to compose these sequences. It is sufficient to pick up the ones that "match". Our sequences must not be confused with similar structures (sequences of ask/tell constraints, input/output substitutions etc.) used in [13], <ref> [8] </ref>, [7] and [16]. Those structures are used there to represent the sequel of actions that a process will engage. <p> As a consequence, sequences of that kind contain less information and they are compositional only for the success set [13], whereas failure and deadlock still require some branching information. In <ref> [8] </ref> this branching information is given by failure and suspension sets, in [7] and [16] it is explicitly represented by a tree-like structure. A totally different approach has been developed in [17] for the determinate subcase of constraint logic programming.
Reference: [9] <author> R. Gerth, M. Codish, Y. Lichtenstein, and E. Shapiro. </author> <title> Fully abstract denotational semantics for Concurrent Prolog. </title> <booktitle> In Proc. of the Third IEEE Symposium on Logic In Computer Science, </booktitle> <pages> pages 320-335. </pages> <publisher> IEEE Computer Society Press, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: As a consequence, the structural operational semantics and the problems of compositionality and full abstraction have been approached mostly by the standard methods (failure sets, trees, etc.) of the semantics of concurrency ([1], [11], [2], [3], [7], [16], <ref> [9] </ref>, [8]). We think that concurrent constraint languages require a different approach. <p> They should be distinguished, since the composition of these computations with a successful alternative choice 1 The idea of considering arbitrary assumptions (in the framework of substitutions) has been first suggested in <ref> [9] </ref> for Flat Concurrent Prolog. <p> (s) ) c * c ; ss 0 ff = sff if 6j= Store (sc ) * c ; ss 0 ff = sdd if j= 9 (Store (sc )) and 6j= Store (s) ) c * c ; s?= s? Parallel composition) The operator ~ k, first introduced in <ref> [9] </ref>, allows to combine sequences of assume/tell constraints that are equal at each point, apart from the modes, so modeling the interaction of a process with its environment.
Reference: [10] <author> J. Jaffar and J.-L. Lassez. </author> <title> Constraint Logic Programming. </title> <booktitle> In 14th ACM Principles of Programming Languages Conference, </booktitle> <pages> pages 111-119, </pages> <address> Munich, F.R.G., 1987. </address> <publisher> ACM, </publisher> <address> New York. </address>
Reference-contexts: 1 Introduction The concurrent constraint paradigm [15], [16], [8], [6], [7] represents a considerable improvement with respect to "classical" concurrent logic languages. The combination with Constraint Logic Programming <ref> [10] </ref> has allowed on one hand to increase the expressiveness, and, on the other hand, to model in a logical manner the synchronization mechanism [12], [14], thus integrating it with the declarative reading of the language. Constraint programming is based on the notion of computing with systems of partial information.
Reference: [11] <author> J.N. Kok. </author> <title> A compositional semantics for Concurrent Prolog. </title> <editor> In R. Cori and M. Wirsing, editors, </editor> <booktitle> Proc. Fifth Symposium on Theoretical Aspects of Computer Science, volume 294 of Lecture Notes in Computer Science, </booktitle> <pages> pages 373-388. </pages> <publisher> Springer-Verlag, </publisher> <year> 1988. </year> <month> 22 </month>
Reference-contexts: As a consequence, the structural operational semantics and the problems of compositionality and full abstraction have been approached mostly by the standard methods (failure sets, trees, etc.) of the semantics of concurrency ([1], <ref> [11] </ref>, [2], [3], [7], [16], [9], [8]). We think that concurrent constraint languages require a different approach.
Reference: [12] <author> M. J. Maher. </author> <title> Logic semantics for a class of committed-choice programs. </title> <editor> In Jean-Louis Lassez, editor, </editor> <booktitle> Proc. of the Fourth International Conference on Logic Programming, Series in Logic Programming, </booktitle> <pages> pages 858-876, </pages> <address> Melbourne, 1987. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: The combination with Constraint Logic Programming [10] has allowed on one hand to increase the expressiveness, and, on the other hand, to model in a logical manner the synchronization mechanism <ref> [12] </ref>, [14], thus integrating it with the declarative reading of the language. Constraint programming is based on the notion of computing with systems of partial information.
Reference: [13] <author> V.A. Saraswat. </author> <title> Partial Correctness Semantics for CP(;; j; &). In Proc. </title> <booktitle> of the Conference on Foundations of Software Computing and Theoretical Computer Science, volume 206 of Lecture Notes in Computer Science, </booktitle> <pages> pages 347-368. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Moreover, we don't need an interleaving operator to compose these sequences. It is sufficient to pick up the ones that "match". Our sequences must not be confused with similar structures (sequences of ask/tell constraints, input/output substitutions etc.) used in <ref> [13] </ref>, [8], [7] and [16]. Those structures are used there to represent the sequel of actions that a process will engage. <p> As a consequence, sequences of that kind contain less information and they are compositional only for the success set <ref> [13] </ref>, whereas failure and deadlock still require some branching information. In [8] this branching information is given by failure and suspension sets, in [7] and [16] it is explicitly represented by a tree-like structure.
Reference: [14] <author> V.A. Saraswat. </author> <title> A somewhat logical formulation of CLP synchronization primitives. </title> <editor> In Robert A. Kowalski and Kenneth A. Bowen, editors, </editor> <booktitle> Proc. of the Fifth International Conference on Logic Programming, Series in Logic Programming, </booktitle> <pages> pages 1298-1314, </pages> <address> Seattle, USA, 1988. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: The combination with Constraint Logic Programming [10] has allowed on one hand to increase the expressiveness, and, on the other hand, to model in a logical manner the synchronization mechanism [12], <ref> [14] </ref>, thus integrating it with the declarative reading of the language. Constraint programming is based on the notion of computing with systems of partial information.
Reference: [15] <author> V.A. Saraswat. </author> <title> Concurrent Constraint Programming Languages. </title> <type> PhD thesis, </type> <month> january </month> <year> 1989. </year> <note> To be published by the MIT Press. </note>
Reference-contexts: 1 Introduction The concurrent constraint paradigm <ref> [15] </ref>, [16], [8], [6], [7] represents a considerable improvement with respect to "classical" concurrent logic languages. <p> For instance, a constraint can be a first order formula, like fx = f (y)g, representing the set ffy = a; x = f (a)g; fy = b; x = f (b)g; : : :g. Constraints are naturally ordered with respect to (reverse) logical implication. As discussed in <ref> [15] </ref>, [16], this fl Part of this work was supported by the ESPRIT BRA project "Integration" 1 notion of store leads naturally to a paradigm for concurrent programming. All processes share a common store, that represents the constraint established until that moment.
Reference: [16] <author> V.A. Saraswat and M. Rinard. </author> <title> Concurrent constraint programming. </title> <booktitle> In Proc. of the seventeenth ACM Symposium on Principles of Programming Languages. ACM, </booktitle> <address> New York, </address> <year> 1990. </year>
Reference-contexts: 1 Introduction The concurrent constraint paradigm [15], <ref> [16] </ref>, [8], [6], [7] represents a considerable improvement with respect to "classical" concurrent logic languages. <p> For instance, a constraint can be a first order formula, like fx = f (y)g, representing the set ffy = a; x = f (a)g; fy = b; x = f (b)g; : : :g. Constraints are naturally ordered with respect to (reverse) logical implication. As discussed in [15], <ref> [16] </ref>, this fl Part of this work was supported by the ESPRIT BRA project "Integration" 1 notion of store leads naturally to a paradigm for concurrent programming. All processes share a common store, that represents the constraint established until that moment. <p> The main operators of concurrent constraint programming are the communication actions, the prefixing, the parallel composition, the nondeterministic choice, and the hiding of local variables <ref> [16] </ref>. Concerning the control structure, these operators have been regarded just as a particular case of the classical concurrent paradigms, like CCS and TCSP. <p> As a consequence, the structural operational semantics and the problems of compositionality and full abstraction have been approached mostly by the standard methods (failure sets, trees, etc.) of the semantics of concurrency ([1], [11], [2], [3], [7], <ref> [16] </ref>, [9], [8]). We think that concurrent constraint languages require a different approach. <p> Moreover, we don't need an interleaving operator to compose these sequences. It is sufficient to pick up the ones that "match". Our sequences must not be confused with similar structures (sequences of ask/tell constraints, input/output substitutions etc.) used in [13], [8], [7] and <ref> [16] </ref>. Those structures are used there to represent the sequel of actions that a process will engage. <p> As a consequence, sequences of that kind contain less information and they are compositional only for the success set [13], whereas failure and deadlock still require some branching information. In [8] this branching information is given by failure and suspension sets, in [7] and <ref> [16] </ref> it is explicitly represented by a tree-like structure. A totally different approach has been developed in [17] for the determinate subcase of constraint logic programming. <p> This model is also more simple and elegant, since the hiding of local variables is here modeled by the existential quantifier. Since it is induced by linear sequence, the congruence associated to M is coarser than reactive equality (a congruence, on tree-like structures, based on strong bisimulation) <ref> [16] </ref>. One may believe that this model, being linear, has good chances to be fully abstract. This is not the case, for the notion of observables described at the beginning of this section 2 . <p> It is well known that this might cause the loss of compositionality with respect to the choice operator. It happens, for instance, in the (weak) bisimulation semantics for CCS, and in the reactive equivalence semantics defined in <ref> [16] </ref>. Essentially this is because the distinction is lost between a computation that deadlocks [fails] immediately, and a computation that deadlocks [fails] after some silent steps. <p> For the sake of simplicity we do not describe this mechanism in T . In the next section (when describing the compositional semantics) we will show a solution to the problem of renaming. The interested reader can find in <ref> [16, 4, 5] </ref> various alternative approaches to this problem. R1 and R2 indicate that Success and Fail end immediately in their corresponding termination modes. R3-R6 describe the way in which the communication actions deal with the store. <p> Therefore, also A 2 can bring to a failure by choosing c 3 . 3 In this framework, a step is silent if does not modify the store (like, for instance, tell (true)). 12 As a conclusion, M is coarser than the congruence based on strong bisimulation (reactive equality, <ref> [16] </ref>), and, we think, more appropriate for concurrent constraint. However, one may argue that this notion of equivalence is too fine and that it would be more interesting, for instance, to abstract from silent steps or, even, from intermediate steps (i.e. to identify processes that give the same final results).
Reference: [17] <author> V.A. Saraswat, M. Rinard and P. Panangaden. </author> <title> A model for concurrent constraint programming. </title> <month> July </month> <year> 1990. </year> <month> 23 </month>
Reference-contexts: In [8] this branching information is given by failure and suspension sets, in [7] and [16] it is explicitly represented by a tree-like structure. A totally different approach has been developed in <ref> [17] </ref> for the determinate subcase of constraint logic programming. The basic idea consists of mapping processes into Scott's closure operators, which have the nice property of being representable as the set of their fixpoints. The operators of the language can then be described just as operations on those sets. <p> However, suspension sets, although not necessary, were still present there. 2 It would be fully abstract if we considered a stronger notion of observables based on sequences of ask/tell actions, similarly to what is done in <ref> [17] </ref> (for the indeterminate case), but this is out of the scope of this paper. 3 gives different results (the second may still deadlock [fail] while the first cannot). In our framework it is possible to solve the problem in a quite simple way.
References-found: 17

