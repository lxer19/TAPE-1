URL: http://swarm.cs.wustl.edu/csg/papers/1997-1.ps.Z
Refering-URL: http://swarm.cs.wustl.edu/cgi-bin/pubs/papers/
Root-URL: http://www.cs.wustl.edu
Email: picco@polito.it  [roman mccap]@cs.wustl.edu  
Phone: 2  
Title: Expressing Code Mobility in Mobile UNITY  
Author: Gian Pietro Picco ; Gruia-Catalin Roman and Peter J. McCann 
Address: C.so Duca degli Abruzzi 24, 10129 Torino, Italy  Campus Box 1045, One Brookings Drive, Saint Louis, MO 63130-4899, USA  
Affiliation: 1 Dipartimento di Automatica e Informatica, Politecnico di Torino,  Department of Computer Science, Washington University,  
Abstract: Advancements in network technology have led to the emergence of new computing paradigms that challenge established programming practices by employing weak forms of consistency and dynamic forms of binding. Code mobility, for instance, allows for invocation-time binding between a code fragment and the location where it executes. Similarly, mobile computing allows hosts (and the software they execute) to alter their physical location. Despite apparent similarities, the two paradigms are distinct in their treatment of location and movement. This paper seeks to uncover a common foundation for the two paradigms by exploring the manner in which stereotypical forms of code mobility can be expressed in a programming notation developed for mobile computing. Several solutions to a distributed simulation problem are used to illustrate the modeling strategy for programs that employ code mobility. Keywords. Code mobility, UNITY, Mobile UNITY, coordination, mobile computing, mobile code languages. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A. Black, N. Hutchinson, E. Jul, and H. Levy. </author> <title> Fine-Grained Mobility in the Emerald System. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1), </volume> <month> February </month> <year> 1988. </year>
Reference-contexts: Further information, including a proof logic that has been developed to match the new operational model, can be found in [7]. 4 Mobile Code Design Paradigms The idea behind code mobility is not new, as witnessed by the work of Stamos et al. [6] and Black et al. <ref> [1] </ref>. Nevertheless, these technologies were conceived mostly to provide operating system support on a LAN, while MCLs explicitly target large scale distributed systems|like the Internet. On the Internet, client-server is the most used paradigm for the development of applications.
Reference: 2. <author> A. Carzaniga, G.P. Picco, and G. Vigna. </author> <title> Designing Distributed Applications with Mobile Code Paradigms. </title> <editor> In R.N. Taylor, editor, </editor> <booktitle> Proceedings of the 19 th International Conference on Software Engineering, </booktitle> <year> 1997. </year>
Reference-contexts: 1 Introduction Code mobility is defined informally as the capability, in a distributed application, to dynamically reconfigure the binding between code fragments and the location where they are executed <ref> [2] </ref>. Mobile code languages (MCLs) [12,11] provide specialized abstractions and run-time support capabilities designed to support various forms of code mobility. They assume that hosts and communication links are part of a highly dynamic global computing platform, where the application code can move freely among the computing nodes. <p> Section 4 introduces basic concepts relevant to code mobility, provides some background information, and presents mobile code solutions to the distributed simulation problem. They illustrate our strategies for modeling mobile code in Mobile UNITY and are modeled after the taxonomy of mobile code design paradigms found in <ref> [2] </ref>. Finally, Section 5 explores some of the issues raised by this investigation. 2 A Distributed Simulation Problem In this section we present an example that will be used for illustration purposes throughout the remainder of the paper and as a vehicle to introduce the reader to the UNITY notation. <p> The essential features of the interaction patterns found in MCLs can be characterized by considering the kinds of pairwise interactions that are possible between two software design components located on different hosts. In <ref> [2] </ref>, Remote Evaluation (REV), Mobile Agent (MA), and Code on Demand (COD) are identified as the key mobile code design paradigms. A schematic view of all the paradigms appears in Fig. 4.
Reference: 3. <author> K.M. Chandy and J. Misra. </author> <title> Distributed Simulation: A Case Study in Design and Verification of Distributed Programs. </title> <journal> IEEE Transaction on Software Engineering, </journal> <volume> 5(5) </volume> <pages> 440-452, </pages> <month> September </month> <year> 1979. </year>
Reference-contexts: The example is inspired by the work of Chandy and Misra who provided a formal characterization and solution for a distributed simulation problem <ref> [3] </ref>. The basic idea is to simulate the behavior of a physical system such as an electronic circuit on a network of computing nodes which communicate asynchronously and in the absence of global shared memory.
Reference: 4. <author> K.M. Chandy and J. Misra. </author> <title> Parallel Program Design. </title> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: Relating these new paradigms to previous research on distributed computing is the main theme of this paper. The model we use in our study is called Mobile UNITY [7,10], an extension of work by Chandy and Misra on UNITY <ref> [4] </ref>. Mobile UNITY provides a programming notation that captures the notion of mobility and transient interactions among mobile nodes and includes an assertional-style proof logic. <p> The value of a local timer can never be behind the GVT. For such cases the function f is undefined. In this section, we discuss a solution for the distributed simulation problem that uses the UNITY notation described in <ref> [4] </ref>. In the UNITY program shown in Fig. 1, the declare section contains variable declarations. The array t contains the value of the local timer for each process i. T stores the current value for the GVT and z represents the simulation mode.
Reference: 5. <author> G. Cugola, C. Ghezzi, </author> <title> G.P. </title> <editor> Picco, and G. Vigna. </editor> <booktitle> Analyzing Mobile Code Languages. </booktitle> <pages> pages 93-111. </pages> <note> In [12]. </note>
Reference-contexts: This network centric style of computing is at the center of the emerging mobile code languages. For a comprehensive survey of MCLs, the reader is directed to <ref> [5] </ref> which reviews a number of existing languages and attempts to extract their essential features. The unit of mobility, that in [5] is called executing unit, is implemented differently in different languages, but can be thought of as a process in an operating system or a thread in a multithreaded environment. <p> This network centric style of computing is at the center of the emerging mobile code languages. For a comprehensive survey of MCLs, the reader is directed to <ref> [5] </ref> which reviews a number of existing languages and attempts to extract their essential features. The unit of mobility, that in [5] is called executing unit, is implemented differently in different languages, but can be thought of as a process in an operating system or a thread in a multithreaded environment. Strong mobility allows executing units to move their code and their execution state to a different site. <p> In the REV solution, 2 Mobile code languages implement parameter passing either explicitly by referring to input parameters and code using RPC-like primitives or implicitly by attaching to the procedure to be executed remotely the portion of data space needed for remote computation <ref> [5] </ref>. We chose the second alternative, in order to illustrate how to dynamically establish and remove bindings among variables in Mobile UNITY.
Reference: 6. <author> J.W. Stamos and D.K. Gifford. </author> <title> Remote Evaluation. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(4) </volume> <pages> 537-565, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: Further information, including a proof logic that has been developed to match the new operational model, can be found in [7]. 4 Mobile Code Design Paradigms The idea behind code mobility is not new, as witnessed by the work of Stamos et al. <ref> [6] </ref> and Black et al. [1]. Nevertheless, these technologies were conceived mostly to provide operating system support on a LAN, while MCLs explicitly target large scale distributed systems|like the Internet. On the Internet, client-server is the most used paradigm for the development of applications. <p> Eventually, a result will be sent back to the client component via a message, like in a CS paradigm. Hence, the REV paradigm leverages off the flexibility provided by the server, instead of relying on a fixed functionality. The REV paradigm is inspired by work on the REV <ref> [6] </ref> system, which extends remote procedure call with one additional parameter containing the code to execute on the server. Among recent MCLs, the paradigm is supported natively in TACOMA, Agent Tcl, Facile, and M0. <p> Hence, in both solutions the client component is given a uniform interface (the request buffer) to the rest of the system, whose details are handled within the Interactions sections|thus modeling the run-time support for communication provided by implementations of RPC and of the REV <ref> [6] </ref> system. Analogous considerations hold for the output buffer of Server.
Reference: 7. <author> P.J. McCann and G-.C. Roman. </author> <title> Mobile UNITY: A Language and Logic for Concurrent Mobile Systems. </title> <type> Technical Report WUCS-97-01, </type> <institution> Dept. of Computer Science, Washington University, St.Louis, </institution> <year> 1996. </year>
Reference-contexts: The reader should keep in mind that transient sharing is really a shorthand notation for a set of reactive statements. Further information, including a proof logic that has been developed to match the new operational model, can be found in <ref> [7] </ref>. 4 Mobile Code Design Paradigms The idea behind code mobility is not new, as witnessed by the work of Stamos et al. [6] and Black et al. [1].
Reference: 8. <author> P.J. McCann and G-.C. Roman. </author> <title> Mobile UNITY Coordination Constructs Applied to Packet Forwarding for Mobile Hosts. </title> <type> Technical Report WUCS-96-15, </type> <institution> Dept. of Computer Science, Washington University, St.Louis, </institution> <year> 1996. </year> <booktitle> To appear at the 2 nd Intl. Conf. on Coordination Models and Languages, </booktitle> <address> Berlin, </address> <month> September 1-3, </month> <year> 1997. </year>
Reference-contexts: Restricted forms of these proposed interaction constructs appear to have efficient implementations and more abstract and powerful interaction constructs can be built from the basic forms. In addition, the Mobile UNITY proof logic has been tentatively evaluated in the verification of the Mobile IP protocol <ref> [8] </ref>. Against this background of promising technical developments, this paper raised a simple question: Can Mobile UNITY model in straightforward manner the kinds of interactions that take place in applications involving mobile code? The investigative style of this paper is empirical.
Reference: 9. <institution> Object Management Group. CORBA: Architecture and Specification, </institution> <month> August </month> <year> 1995. </year>
Reference-contexts: Each interaction between the client and the server makes use of the communication infrastructure through message passing or some higher level mechanism like remote procedure call (RPC). Mechanisms that actually hide the location of components from the application programmer are also being considered, e.g., CORBA <ref> [9] </ref>. By contrast, in MCLs component locations are not hidden. Location is explicitly handled by the programmer who is able to specify where the computation of a given code fragment must take place.
Reference: 10. <author> G-.C. Roman, P.J. McCann, and J.Y. Plun. </author> <title> Mobile UNITY: Reasoning and Specification in Mobile Computing. </title> <type> Technical Report WUCS-96-08, </type> <institution> Dept. of Computer Science, Washington University, St.Louis, </institution> <year> 1996. </year> <note> To appear in ACM Transactions on Software Engineering and Methodology. </note>
Reference: 11. <editor> K. Rothermel and R. Popescu-Zeletin, editors. </editor> <booktitle> Mobile Agents, volume 1219 of Lecture Notes on Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference: 12. <author> J. Vitek and C. Tschudin, </author> <title> editors. Mobile Object Systems: Towards the Programmable Internet, </title> <booktitle> volume 1222 of Lecture Notes on Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
References-found: 12

