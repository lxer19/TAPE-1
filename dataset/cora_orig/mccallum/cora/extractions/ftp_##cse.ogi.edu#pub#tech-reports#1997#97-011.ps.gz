URL: ftp://cse.ogi.edu/pub/tech-reports/1997/97-011.ps.gz
Refering-URL: ftp://cse.ogi.edu/pub/tech-reports/README.html
Root-URL: http://www.cse.ogi.edu
Title: On Type-Directed Partial Evaluation  
Author: Walid Taha 
Keyword: val compiled_0 fn f =&gt; fn :int =&gt; fn :int =&gt; fn :int =&gt; f (f val compiled_0 fn (int int -&gt; int) -&gt; int -&gt; int -&gt; int -&gt; int val compiled_1 compiled_0 (fn =&gt; val compiled_1 fn int -&gt; int -&gt; int -&gt; int val term_1 residualize (int -&gt; int -&gt; int -&gt; int) compiled_1 val term_1 "fn =&gt; fn =&gt; fn =&gt; term  
Date: October 13, 1997  
Abstract: Type Directed Partial Evaluation (TDPE) is a new development in partial evaluation that has two properties that make it attractive for formal investigation: First, it is concise; it is defined in about six lines [Dan96b]. Second, it is easy to implement; the definition can be coded directly in a functional language like Scheme, yielding a demonstrably efficient and effective partial evaluator [DV96, Ves97]. In this note, we present a taste of TDPE, review the theoretical foundations and developments relating to TDPE, and highlight some major open research questions. Type-Directed Partial Evaluation: We begin with an example of using TDPE in an interactive loop based on a compiler, similar to that of SML/NJ. Let residualize represent the main function of TDPE, which takes a (representation of) a type, a compiled object, and returns a normalized term based on that object: Note that the syntax of the new term (or program) term_1 has been derived from the compiled_1 object code, and that the expression f (f (x,y),z) has been replaced (working under the - abstractions) by a renaming of x. The object passed to residualize must be the compiled form of a closed term. Free variables, primitives, and recursion can all handled by -abstracting them from the original term (using an explicit Y-combinator for recursion). The significance of being able to take compiled code as input is two fold: First, it alleviates the need for the symbolic execution of the source program, and hence, can be done more efficiently. Second, in standard partial evaluation we sometimes find that we need to insert a "static" function value into a "dynamic" context [JGS93]. Traditionally, this meant replacing the static value by the text of the computation that produced it. In the above example, it would mean symbolically replacing both occurances of f in the expression f (f (x,y),z) with the syntax syntax (fn (x,y) =&gt; x). With residualize, we arrive at the simpler expression x directly. Theoretical Foundations: There appear to be some strong ties between TDPE and some new developments in proof theory [Dan96b]. Berger and Schwichtenberg developed a mathematical theory that could take advantage of modern functional language compilers to perform efficient proof normalization [BS91]. They presented an inversion algorithm for deriving a unique -term 
Abstract-found: 1
Intro-found: 1
Reference: [Ber93] <author> U. Berger. </author> <title> Program extraction from normalization proofs. </title> <booktitle> In Proceedings of the International Conference on Typed Lambda Calculi and Applications, </booktitle> <year> 1993. </year>
Reference-contexts: What then is F ? There are also many interesting challenges relating to implementation, including: * Long normal forms can be quite large in practice [She97]. Generating short normal form directly is theoretically possible <ref> [Ber93] </ref>.
Reference: [BS91] <author> U. Berger and H. Schwichtenberg. </author> <title> An inverse of the evaluation functional for typed - calculus. </title> <editor> In Rao Vemuri, editor, </editor> <booktitle> Proceedings of the Sixth Annual IEEE Symposium on Logic in Computer Science. </booktitle> <publisher> IEEE Computer Society Press, Loss Alamitos, </publisher> <year> 1991. </year>
Reference: [Car86] <author> L. Cardelli. </author> <title> A polymorphic -calculus with Type:Type, </title> <year> 1986. </year>
Reference: [CD97] <author> T. Coquand and P. Dybjer. </author> <title> Intiuitionistic model constructions and normalization proofs. </title> <journal> Math. </journal> <note> Struct. in Comp. Science, </note> <year> 1997. </year>
Reference-contexts: Generating short normal form directly is theoretically possible [Ber93]. Can this be done efficiently in practice? * Coquand remarks that the evaluation strategy for normalization follows exactly the evaluation strategy for the meta-language <ref> [CD97] </ref>, which suggests that in a compiled implementation maintaining both the semantic and syntactic representation, the overhead of maintaining the syntactic one can be reduced if a lazy meta-language is employed.
Reference: [Coq93] <author> C. Coquand. </author> <title> From semantics to rules: a machine assisted analysis. </title> <publisher> LNCS, </publisher> <address> 832, </address> <year> 1993. </year>
Reference: [Coq96] <author> T. Coquand. </author> <title> An algorithm for type-checking dependent types, </title> <year> 1996. </year>
Reference: [Dan96a] <author> O. Danvy. </author> <title> Pragmatics of type-directed partial evaluation. </title> <booktitle> LNCS, 1110, 1996. iii </booktitle>
Reference: [Dan96b] <author> O. Danvy. </author> <title> Type-directed partial evaluation. </title> <booktitle> In POPL'96: The 23rd ACM SIGPLAN--SIGACT Symposium on Principles of Programming Languages, </booktitle> <address> St. Petersburg, Florida, </address> <month> January </month> <year> 1996. </year> <note> ACM, </note> <year> 1996. </year>
Reference-contexts: Hindley [Hin97, Pg. 110] remarks that both are used in the literature interchangeably, but also that such terms are fi-normal and not necessarily -normal. Berger uses the neutral term "long normal form". ii T erm <ref> [Dan96b] </ref>. But this type does not explicitly reflect the relationships between the param-eters. <p> On close inspection of the implementation of residualize <ref> [Dan96b, Ves97] </ref>, we see that F cannot be the identity coercion. What then is F ? There are also many interesting challenges relating to implementation, including: * Long normal forms can be quite large in practice [She97]. Generating short normal form directly is theoretically possible [Ber93].
Reference: [DF90] <author> O. Danvy and A. Filinski. </author> <title> Abstracting control. </title> <booktitle> In 1990 ACM Conference on Lisp and Functional Programming90. ACM, </booktitle> <year> 1990. </year>
Reference: [DMP95] <author> O. Danvy, K. Malmkjaer, and J. Palsberg. </author> <title> The essence of eta-expansion in partial evaluation. </title> <booktitle> LISP and Symbolic Computation, </booktitle> <year> 1995. </year>
Reference: [DV96] <author> O. Danvy and R. Vestergaard. </author> <title> Semantics-based compiling: A case study in type-directed partial evaluation. </title> <publisher> LNCS, </publisher> <address> 1140, </address> <year> 1996. </year>
Reference: [GJ95] <author> A. Gluck and J. Jtrgensen. </author> <title> Efficient multi-level generating extensions for program specialization. </title> <publisher> LNCS, </publisher> <address> 982, </address> <year> 1995. </year>
Reference: [JGS93] <author> N. D. Jones, C.K. Gomard, and P. Sestoft. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <publisher> Prentic Hall, </publisher> <year> 1993. </year>
Reference: [NN92] <author> F. Nielson and H. R. Nielson. </author> <title> Two-Level Functional Programming Languages. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference: [She97] <author> T. Sheard. </author> <title> A type-directed, on-line, partial evaluator for a polymorphic language. </title> <booktitle> In ACM SIGPLAN Symposium on Partial Evaluation and Semantics-Based Program Manipulation. ACM, </booktitle> <year> 1997. </year>
Reference-contexts: On close inspection of the implementation of residualize [Dan96b, Ves97], we see that F cannot be the identity coercion. What then is F ? There are also many interesting challenges relating to implementation, including: * Long normal forms can be quite large in practice <ref> [She97] </ref>. Generating short normal form directly is theoretically possible [Ber93].
Reference: [Sta94] <author> I. Stark. </author> <title> Names and Higher-Order Functions. </title> <type> PhD thesis, </type> <institution> University of Cambridge, </institution> <note> De-cember 1994. Also published as Technical Report 363, </note> <institution> University of Cambridge Computer Laboratory. </institution>
Reference: [TS97] <author> W. Taha and T. Sheard. </author> <title> Multi-stage programming with explicit annotations. </title> <booktitle> In ACM SIGPLAN Symposium on Partial Evaluation and Semantics-Based Program Manipulation. ACM, </booktitle> <year> 1997. </year>
Reference: [Ves97] <author> R. Vestergaard. </author> <title> From proof normalization to compiler generation and type-directed change-of-representation. </title> <type> Masters Thesis, </type> <year> 1997. </year> <pages> iv </pages>
Reference-contexts: On close inspection of the implementation of residualize <ref> [Dan96b, Ves97] </ref>, we see that F cannot be the identity coercion. What then is F ? There are also many interesting challenges relating to implementation, including: * Long normal forms can be quite large in practice [She97]. Generating short normal form directly is theoretically possible [Ber93].
References-found: 18

