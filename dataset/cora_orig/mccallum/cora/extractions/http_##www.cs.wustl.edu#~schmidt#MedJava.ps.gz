URL: http://www.cs.wustl.edu/~schmidt/MedJava.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/ACE-members.html
Root-URL: 
Email: fpjain,sbw1,schmidtg@cs.wustl.edu  
Title: The Design and Performance of MedJava A Distributed Electronic Medical Imaging System Developed with Java
Author: Prashant Jain, Seth Widoff, and Douglas C. Schmidt 
Note: performance-sensitive distributed applications where C and C++ are currently used.  
Address: St. Louis, MO 63130, (314) 935-4215  
Affiliation: Department of Computer Science Washington University  
Abstract: This paper appeared in the 4 th USENIX Conference on Object-Oriented Technologies and Systems (COOTS), Sante Fe, New Mexico, April 1998. Abstract The Java programming language has gained substantial popularity in the past two years. Java's networking features, along with the growing number of Web browsers that execute Java applets, facilitate Internet programming. Despite the popularity of Java, however, there are many concerns about its efficiency. In particular, networking and computation performance are key concerns when considering the use of Java to develop performance-sensitive distributed applications. This paper makes three contributions to the study of Java for performance-sensitive distributed applications. First, we describe an architecture using Java and the Web to develop Med-Java, which is a distributed electronic medical imaging system with stringent networking and computation requirements. Second, we present benchmarks of MedJava image processing and compare the results to the performance of xv, which is an equivalent image processing application written in C. Finally, we present performance benchmarks using Java as a transport interface to exchange large medical images over high-speed ATM networks. For computationally intensive algorithms, such as image filters, hand-optimized Java code, coupled with use of a JIT compiler, can sometimes compensate for the lack of compile-time optimization and yield performance commensurate with identical compiled C code. With rigorous compile-time optimizations employed, C compilers still tend to generate more efficient code. However, with the advent of highly optimizing Java compilers, it should be feasible to use Java for the fl This research is supported in part by a grant from Siemens Medical Engineering, Erlangen, Germany.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> W. L. R. J. J. Conklin, </author> <title> Digital Management and Regulatory Submission of Medical Images from Clinical Trials: Role and Benefits of the Core Laboratory, </title> <booktitle> Proc. SPIE, Health Care Technology Policy II: The Role of Technology in the Cost of Health Care: Providing the Solutions, </booktitle> <volume> vol. 2499, </volume> <month> Oct. </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Medical imaging plays a key role in the development of a regulatory review process for radiologists and physicians <ref> [1] </ref>. The demand for electronic medical imaging systems (EMISs) that allow visualization and processing of medical images has increased significantly [2].
Reference: [2] <author> G. Blaine, M. Boyd, and S. Crider, </author> <title> Project Spectrum: Scalable Bandwidth for the BJC Health System, </title> <journal> HIMSS, Health Care Communications, </journal> <pages> pp. 7181, </pages> <year> 1994. </year>
Reference-contexts: 1 Introduction Medical imaging plays a key role in the development of a regulatory review process for radiologists and physicians [1]. The demand for electronic medical imaging systems (EMISs) that allow visualization and processing of medical images has increased significantly <ref> [2] </ref>. The advent of modalities, such as angiography, CT, MRI, nuclear medicine, and ultrasound, that acquire data digitally and the ability to digitize medical images from film has heightened the demand for EMISs. <p> The need for distributed EMISs is also driven by economic factors. As independent health hospitals consolidate into integrated health care delivery systems <ref> [2] </ref>, they will require distributed computer systems to unify their multiple and distinct image repositories. In this environment, medical images are captured by modalities and transferred to appropriate Image Stores. Radiologists and physicians can then download these images to diagnostic workstations for viewing, image processing, and diagnosis. <p> must be usable to make it as convenient to practice radiology as conventional film-based technology. * Efficient: An EMIS must be efficient to process and deliver medical images rapidly to radiologists. * Scalable: An EMIS must be scalable to support the growing demands of large-scale integrated health care delivery systems <ref> [2] </ref>. * Flexible: An EMIS must be flexible to transfer different types of images and to dynamically reconfigure image processing features to cope with changing requirements. * Reliable: An EMIS must be reliable to ensure that medical images are delivered correctly and are available when requested by users. * Secure: An
Reference: [3] <author> I. Pyarali, T. H. Harrison, and D. C. Schmidt, </author> <title> Design and Performance of an Object-Oriented Framework for High-Performance Electronic Medical Imaging, </title> <booktitle> USENIX Computing Systems, </booktitle> <volume> vol. 9, </volume> <month> November/December </month> <year> 1996. </year>
Reference-contexts: The growing demand for EMISs has been coupled with a need to access medical images and other diagnostic information remotely across networks <ref> [3] </ref>. Connecting radiologists electronically with patients increases the availability of health care. In addition, it can facilitate the delivery of remote diagnostics and remote surgery [4]. As a result of these forces, there is also increasing demand for distributed EMISs.
Reference: [4] <author> F. L. Kitson, </author> <title> Multimedia, Visual Computing, </title> <booktitle> and the Information Superhighway, Proc. SPIE, Medical Imaging 1996: Image Display, </booktitle> <volume> vol. 2707, </volume> <month> Apr. </month> <year> 1996. </year>
Reference-contexts: The growing demand for EMISs has been coupled with a need to access medical images and other diagnostic information remotely across networks [3]. Connecting radiologists electronically with patients increases the availability of health care. In addition, it can facilitate the delivery of remote diagnostics and remote surgery <ref> [4] </ref>. As a result of these forces, there is also increasing demand for distributed EMISs. These systems supply health care providers with the capability to access medical images and related clinical studies across a network in order to analyze and diagnose patient records and exams.
Reference: [5] <author> P. Jain and D. Schmidt, </author> <title> Experiences Converting a C++ Communication Software Framework to Java, </title> <journal> C++ Report, </journal> <volume> vol. 9, </volume> <month> January </month> <year> 1997. </year>
Reference-contexts: Its popularity stems from its flexibility, portability, and relative simplicity compared with other object-oriented programming languages <ref> [5] </ref>. The strong interest in the Java language has coincided with the ubiquity of inexpensive Web browsers. This has brought the Web technology to the desktop of many computer users, including radiologists and physicians. A feature supported by Java that is particularly relevant to distributed EMISs is the applet. <p> However, Blob Streaming can only be used to upload images to the server where the MedJava applet was downloaded. 2.5.4 Java ACE Java ACE <ref> [5] </ref> is a port of the C++ version of the ADAPTIVE Communication Environment (ACE) [15]. ACE is an OO net work programming toolkit that provides reusable components for building distributed applications.
Reference: [6] <author> P. Jain and D. C. Schmidt, </author> <title> Service Configurator: A Pattern for Dynamic Configuration of Services, </title> <booktitle> in Proceedings of the 3 rd Conference on Object-Oriented Technologies and Systems, USENIX, </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: The ability to download Java classes across a network can simplify the development and configuration of efficient and reliable distributed applications <ref> [6] </ref>. Once downloaded from a Web server, applets run as applications within the local machine's Java run-time environment, which is typically a Web browser. <p> Once the edges of an image are detected, additional operations such as pseudo-coloring can be applied to the image. Image filters can be dynamically configured and re-configured into MedJava via the Service Configurator pattern <ref> [6] </ref>. This makes it convenient to enhance filter implementation or install new filters without restarting the MedJava applet. <p> This allows the user to save processed images persistently at the server. Filter Configurator: which downloads image filters from the Server and configures them in the applet. The Filter Con-figurator uses the Service Configurator pattern <ref> [6] </ref> to dynamically configure the image filters. 2.5.2 JAWS JAWS is a high-performance, multi-threaded, HTTP Web Server [11]. For the purposes of MedJava, JAWS stores the MedJava client applet, the image filter repository, and the images. The MedJava client applet uses the image filter repository to download specific image filters. <p> This makes it easier to developing networking applications using Java ACE compared to programming directly with the lower-level Java APIs. Java ACE. MedJava uses several components in Java ACE. For example, Java ACE provides an implementation of the Service Configurator pattern <ref> [6] </ref>. MedJava uses this pattern to dynamically configure and reconfigure image filters. Likewise, Med-Java uses Java ACE profile timers to compute performance in benchmark mode. 3 Performance Benchmarks This section presents the results of performance benchmarks conducted with the MedJava image processing system.
Reference: [7] <author> A. Wollrath, R. Riggs, and J. Waldo, </author> <title> A Distributed Object Model for the Java System, </title> <booktitle> USENIX Computing Systems, </booktitle> <volume> vol. 9, </volume> <month> November/December </month> <year> 1996. </year>
Reference-contexts: In theory, therefore, applets can be very efficient since they harness the power of the local machine on which they run, rather than requiring high latency RPC calls to remote servers <ref> [7] </ref>. The MedJava distributed EMIS was developed as a Java applet. Therefore, it exploits the functionality of front-ends offered by Web browsers. An increasing number of browsers (such as Internet Explorer and Netscape Navigator and Communicator) are Java-enabled and provide a run-time environment for Java applets.
Reference: [8] <institution> Java API Documentation Version 1.0.2. </institution> <note> Available from http://java.sun.com:80/products/jdk/1.0.2/api. </note>
Reference-contexts: In addition, Java provides standard packages that support GUI development, networking, and image processing. For example, the package java.awt.image contains reusable classes for managing and manipulating image data, including color models, cropping, color filtering, setting pixel values, and grabbing bitmaps <ref> [8] </ref>. Since Java is written to a virtual machine, an EMIS developer need only compile the Java source code to Java bytecode. The EMIS applet will execute on any platform that has a Java Virtual Machine implementation. Many Java bytecode compilers and interpreters are available on a variety of platforms.
Reference: [9] <author> M. P. Plezbert and R. Cytron, </author> <title> Does Just in Time = Better Late than Never?, </title> <booktitle> in ACM 1997 Symposium on the Principles of Programming Languages, </booktitle> <year> 1997. </year>
Reference-contexts: JIT compilers are just-in-time since they compile Java bytecode into native code on a per-method basis immediately before calling the methods. Several browsers, such as Netscape and Internet Explorer, provide JIT compilers as part of their JVM. Although Java JIT compilers avoid the penalty of interpretation, previous studies <ref> [9] </ref> show that the cost of compilation can significantly interrupt the flow of execution. This performance degradation can cause Java code to run significantly slower than compiled C/C++ code.
Reference: [10] <author> H. R. Myler and A. R. Weeks, </author> <title> Computer Imaging Recipes in C. </title> <publisher> Prentice Hall, Inc. </publisher> <address> Englewoods Cliffs, New Jersey, </address> <year> 1993. </year>
Reference-contexts: These filters are useful for processing non-medical images. For example, edge detection serves as an important initial step in many computer vision processes because edges contain the bulk of the information within an image <ref> [10] </ref>. Once the edges of an image are detected, additional operations such as pseudo-coloring can be applied to the image. Image filters can be dynamically configured and re-configured into MedJava via the Service Configurator pattern [6].
Reference: [11] <author> J. Hu, S. Mungee, and D. C. Schmidt, </author> <title> Principles for Developing and Measuring High-performance Web Servers over ATM, </title> <booktitle> in Proceeedings of INFOCOM '98, </booktitle> <month> March/April </month> <year> 1998. </year>
Reference-contexts: Doing this substitution in MedJava is straightforward and can be done without reloading the entire applet. Once an image has been processed by applying the filter (s), it can be uploaded to the server where the applet was downloaded. HTTP server implementations, such as JAWS <ref> [11, 12] </ref> and Jigsaw, support file uploading and can be used by MedJava to upload images. In addition, the MedJava applet provides a hierarchical browser that allows users to traverse directories of images on remote servers. <p> The two primary components in the architecture include the MedJava client applet and JAWS, which is a high-performance HTTP server also developed at Washington University <ref> [12, 11] </ref>. The MedJava applet was implemented with components from Java ACE [13], the Blob Streaming framework [14], and standard Java packages such as java.awt and java.awt.image. <p> Filter Configurator: which downloads image filters from the Server and configures them in the applet. The Filter Con-figurator uses the Service Configurator pattern [6] to dynamically configure the image filters. 2.5.2 JAWS JAWS is a high-performance, multi-threaded, HTTP Web Server <ref> [11] </ref>. For the purposes of MedJava, JAWS stores the MedJava client applet, the image filter repository, and the images. The MedJava client applet uses the image filter repository to download specific image filters. Each image filter is a Java class that can be downloaded by MedJava.
Reference: [12] <author> J. Hu, I. Pyarali, and D. C. Schmidt, </author> <title> Measuring the Impact of Event Dispatching and Concurrency Models on Web Server Performance Over High-speed Networks, </title> <booktitle> in Proceedings of the 2 nd Global Internet Conference, IEEE, </booktitle> <month> November </month> <year> 1997. </year>
Reference-contexts: Doing this substitution in MedJava is straightforward and can be done without reloading the entire applet. Once an image has been processed by applying the filter (s), it can be uploaded to the server where the applet was downloaded. HTTP server implementations, such as JAWS <ref> [11, 12] </ref> and Jigsaw, support file uploading and can be used by MedJava to upload images. In addition, the MedJava applet provides a hierarchical browser that allows users to traverse directories of images on remote servers. <p> The two primary components in the architecture include the MedJava client applet and JAWS, which is a high-performance HTTP server also developed at Washington University <ref> [12, 11] </ref>. The MedJava applet was implemented with components from Java ACE [13], the Blob Streaming framework [14], and standard Java packages such as java.awt and java.awt.image.
Reference: [13] <institution> Java ACE Home Page. </institution> <note> Available from http://www.cs.wustl.edu/ schmidt/JACE.html. </note>
Reference-contexts: The two primary components in the architecture include the MedJava client applet and JAWS, which is a high-performance HTTP server also developed at Washington University [12, 11]. The MedJava applet was implemented with components from Java ACE <ref> [13] </ref>, the Blob Streaming framework [14], and standard Java packages such as java.awt and java.awt.image. Each of these components is outlined below. 2.5.1 MedJava Applet The MedJava client applet contains the following components shown in Figure 2: Graphical User Interface: which provides a front-end to the image processing tool.
Reference: [14] <author> I. Pyarali, T. H. Harrison, and D. C. Schmidt, </author> <title> Design and Performance of an Object-Oriented Framework for High-Performance Electronic Medical Imaging, </title> <booktitle> in Proceedings of the 2 nd Conference on Object-Oriented Technologies and Systems, </booktitle> <institution> (Toronto, Canada), USENIX, </institution> <month> June </month> <year> 1996. </year>
Reference-contexts: The two primary components in the architecture include the MedJava client applet and JAWS, which is a high-performance HTTP server also developed at Washington University [12, 11]. The MedJava applet was implemented with components from Java ACE [13], the Blob Streaming framework <ref> [14] </ref>, and standard Java packages such as java.awt and java.awt.image. Each of these components is outlined below. 2.5.1 MedJava Applet The MedJava client applet contains the following components shown in Figure 2: Graphical User Interface: which provides a front-end to the image processing tool. <p> To measure the performance of C/C++ as a transport interface, we used an extended version of TTCP protocol benchmarking tool [22]. 12 This TTCP tool measures the throughput of transferring un--typed bytestream data (i.e., Blobs <ref> [14] </ref>) between two hosts. We chose untyped bytestream data, since untyped bytestream traffic is representative of image pixel data, which need not be marshaled or demarshaled. 3.2.2 Benchmarking Methodology We measured throughput as a function of sender buffer size.
Reference: [15] <author> D. C. Schmidt and T. Suda, </author> <title> An Object-Oriented Framework for Dynamically Configuring Extensible Distributed Communication Systems, </title> <journal> IEE/BCS Distributed Systems Engineering Journal (Special Issue on Configurable Distributed Systems), </journal> <volume> vol. 2, </volume> <pages> pp. 280293, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: However, Blob Streaming can only be used to upload images to the server where the MedJava applet was downloaded. 2.5.4 Java ACE Java ACE [5] is a port of the C++ version of the ADAPTIVE Communication Environment (ACE) <ref> [15] </ref>. ACE is an OO net work programming toolkit that provides reusable components for building distributed applications.
Reference: [16] <author> D. C. Schmidt, </author> <title> Acceptor and Connector: Design Patterns for Initializing Communication Services, in Pattern Languages of Program Design (R. </title> <editor> Martin, F. Buschmann, and D. Riehle, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1997. </year>
Reference-contexts: Java ACE implements several key design patterns for concurrent network programming, such as Acceptor and Connector <ref> [16] </ref> and Active Object [17]. This makes it easier to developing networking applications using Java ACE compared to programming directly with the lower-level Java APIs. Java ACE. MedJava uses several components in Java ACE. For example, Java ACE provides an implementation of the Service Configurator pattern [6].
Reference: [17] <author> R. G. Lavender and D. C. Schmidt, </author> <title> Active Object: an Object Behavioral Pattern for Concurrent Programming, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien, J. Vlissides, and N. Kerth, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: Java ACE implements several key design patterns for concurrent network programming, such as Acceptor and Connector [16] and Active Object <ref> [17] </ref>. This makes it easier to developing networking applications using Java ACE compared to programming directly with the lower-level Java APIs. Java ACE. MedJava uses several components in Java ACE. For example, Java ACE provides an implementation of the Service Configurator pattern [6].
Reference: [18] <author> F. Buschmann, R. Meunier, H. Rohnert, P. Sommerlad, and M. Stal, </author> <title> Pattern-Oriented Software Architecture A System of Patterns. </title> <publisher> Wiley and Sons, </publisher> <year> 1996. </year>
Reference-contexts: For large images, this processing can dominate the loading and display times. Therefore, the running time of the algorithms is an appropriate measure of the overall performance of an image processing application. Image processing configuration: The standard Java image processing framework uses a Pipes and Filters pattern architecture <ref> [18] </ref>. Downstream sits an java.image.ImageConsumer that has registered with an upstream java.image.ImageProducer for pixel delivery. The ImageProducer invokes the setPixels method on the ImageConsumer, delivering portions of the image array until it completes by invoking the ImageComplete method.
Reference: [19] <author> D. Bell, </author> <title> Make Java fast: Optimize!. </title> <address> JavaWorld, </address> <month> April </month> <year> 1997. </year> <note> Available from http://www.javaworld.com/javaworld/jw-04-1997/jw-04-optimize.html. </note>
Reference-contexts: The image filters in MedJava leveraged the following canonical techniques and insight on how to best optimize computation-ally intensive source code in Java <ref> [19] </ref>: Strength reduction: which replaces costly operations with a faster equivalent. For instance, the Image Filters converted multiplications and divides by factors of two into lefts and rights shifts. Common subexpression elimination: which removes redundant calculations. Image Filters store the pixel values in a one dimensional array.
Reference: [20] <author> T. Lindholm and F. Yellin, </author> <title> The Java Virtual Machine Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1997. </year>
Reference-contexts: Also, the iload and istore instructions allow the JVM to quickly load and store the first four local variables to and from the operand stack <ref> [20] </ref>. Integer variables, floats, and object references: which are most directly supported by the JVM since the operand stack and local variables are each one word in width, the size of integers, floating points, and references. <p> Smaller types, such as short and byte are not directly supported in the instruction set. Therefore, each must be converted to an int prior to an operation and then subsequently back to the smaller type, accruing the cost of a valid truncation <ref> [20] </ref>. Manually inlining methods: eliminates the overhead associated with method invocation. Although static, final, and private methods can be resolved at compile time, eliminating method calls entirely, especially simple calls on the java.lang.Math package (e.g., ceil, floor, min, and max), in critical sections of looping code will further improve performance.
Reference: [21] <author> J. Gosling, B. Joy, and G. Steele, </author> <title> The Java Programming Language Specification. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: However, because classes are linked together at run-time, changes made to a final method in one class would not be reflected in other already compiled classes that invoke that method, unless they too were recompiled <ref> [21] </ref>. Naturally, when invoking methods internal to a class, this is not a problem. Moreover, the -O option on the Sun javac source to bytecode compiler requests that it attempt to inline methods. As an example of worthwhile manual method in-lining, an ImageFilter contains a method called setColorModel.
Reference: [22] <author> A. Gokhale and D. C. Schmidt, </author> <title> Measuring the Performance of Communication Middleware on High-Speed Networks, </title> <booktitle> in Proceedings of SIGCOMM '96, </booktitle> <address> (Stanford, CA), </address> <pages> pp. 306317, </pages> <publisher> ACM, </publisher> <month> August </month> <year> 1996. </year>
Reference-contexts: To evaluate the performance of Java as a transport interface for exchanging large images over high-speed networks, we performed a series of network benchmark-ing tests over ATM. This section compares the results with the performance of C/C++ as a transport interface <ref> [22] </ref>. 3.2.1 Benchmarking Configuration Benchmarking testbed: The network benchmarking tests were conducted using a FORE systems ASX-1000 ATM switch connected to two dual-processor UltraSPARC-2s running SunOS 5.5.1. The ASX-1000 is a 96 Port, OC12 622 Mbs/port switch. <p> This allows up to eight switched virtual connections per card. Performance metrics: To evaluate the performance of Java, we developed a test suite using Java ACE. To measure the performance of C/C++ as a transport interface, we used an extended version of TTCP protocol benchmarking tool <ref> [22] </ref>. 12 This TTCP tool measures the throughput of transferring un--typed bytestream data (i.e., Blobs [14]) between two hosts.
Reference: [23] <author> D. C. Schmidt, T. H. Harrison, and E. Al-Shaer, </author> <title> Object-Oriented Components for High-speed Network Programming, </title> <booktitle> in Proceedings of the 1 st Conference on Object-Oriented Technologies and Systems, </booktitle> <address> (Monterey, CA), </address> <publisher> USENIX, </publisher> <month> June </month> <year> 1995. </year>
Reference-contexts: However, it is important to note that despite the differences in performance between Java and C/C++, Java performs comparably well. A throughput of about 110 Mbps on a 155 Mbps ATM network is quite efficient considering the default socket queue size is only 8 Kbytes. Results <ref> [23] </ref> show that network performance can improve significantly if the maximum socket queue size (64 Kbytes) is used.
Reference: [24] <author> H. Shiffman, </author> <title> Boosting Java Performance: Native Code & JIT Compilers. </title> <note> Available from http://reality.sgi.com/shiffman/Java-JIT.html, 1996. </note>
Reference-contexts: The following is a summary of the related work in this area. 4.1 Measuring Java's Performance Several studies have compared the execution time of Java interpreted code and Java compiled code with the execution time of C/C++ compiled code. Shiffman <ref> [24] </ref> has measured and compared the performance of several programs written both in Java and in C++. For the tests performed, Java interpreted code performed 6 to 20 times slower than compiled C++ code, while Java compiled code performed only about 1.1 to 1.5 times slower than C++ code. <p> For the tests performed, Java interpreted code performed 6 to 20 times slower than compiled C++ code, while Java compiled code performed only about 1.1 to 1.5 times slower than C++ code. The results obtained in <ref> [24] </ref> differ from the ones we obtained because the tests run were also different. The tests carried out by Shiffman involved measuring the timings for iterative and recursive versions of a calculator of numbers in the Fibonacci series, as well as a calculator of prime numbers.
Reference: [25] <author> T. A. Proebsting, G. Townsend, P. Bridges, J. H. H. T. New-sham, and S. Watterson, Toba: </author> <title> Java For Applications, A Way Ahead of Time (WAT) Compiler, </title> <booktitle> in Proceedings of the 3rd Conference on Object-Oriented Technologies and Systems, </booktitle> <year> 1997. </year>
Reference-contexts: Toba: A system for generating efficient stand-alone Java applications has been developed at the University of Arizona <ref> [25] </ref>. The system is called Toba and generates executables that are 1.5 to 4.4 times faster than alternative JVM implementations. Toba is a Way-Ahead-of-Time compiler and therefore converts Java code into machine code before the application is run.
Reference: [26] <author> G. Muller, B. Moura, F. Bellard, and C. Consel, </author> <month> Harissa: </month>
Reference-contexts: Although such a compiler can be very useful for stand-alone Java applications, it can not, unfortunately, be used for Java applets. Harrisa: An efficient environment for the execution of Java programs called Harissa has been developed at the University of Rennes <ref> [26] </ref>. Harissa mixes compiled and interpreted code. It translates Java bytecode to C and in the process makes several optimizations. The resulting C code produced by Harissa is up to 140 times faster than the JDK interpreter and 30% faster than the Toba compiler described above.
References-found: 26

