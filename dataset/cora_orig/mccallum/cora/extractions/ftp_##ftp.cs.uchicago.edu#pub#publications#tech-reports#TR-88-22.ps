URL: ftp://ftp.cs.uchicago.edu/pub/publications/tech-reports/TR-88-22.ps
Refering-URL: http://cs-www.uchicago.edu/publications/tech-reports/
Root-URL: 
Title: Practical Zero-Knowledge Proofs: Giving Hints and Using Deficiencies  
Author: Joan Boyar, Katalin Friedl and Carsten Lund 
Date: August 4, 1994  
Address: Chicago  
Affiliation: Computer Science Department University of  
Abstract: New zero-knowledge proofs are given for some number-theoretic problems. All of the problems are in NP, but the proofs given here are much more efficient than the previously known proofs. In addition, these proofs do not require the prover to be super-polynomial in power. A probabilistic polynomial time prover with the appropriate trap-door knowledge is sufficient. The proofs are perfect or statistical zero-knowledge in all cases except one.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Adleman, L., and M.-D. Huang, </author> <title> Recognizing primes in random polynomial time, </title> <booktitle> Proc. 19th ACM Symp. on Theory of Computing, </booktitle> <year> 1987, </year> <pages> pp. 462-469. </pages>
Reference-contexts: In most applications, this is a reasonable assumption because it is possible in expected polynomial time to create a random prime p with a given length, along with the complete factorization of p 1 [3], <ref> [1] </ref>. Now, we will modify the above zero-knowledge proof to include the following steps, which should be repeated k = dlog 2 pe times: Protocol 2 0. The verifier rejects if g (p1)=2 = 1. 1. The verifier randomly and uniformly chooses r 2 Z fl p1 . 2. <p> If g was a generator, however, each element would have only one discrete logarithm in the range <ref> [1; p 1] </ref>. The protocol consists of dlog 2 pe independent repetitions of the following: 10 Protocol 5 1. The prover chooses a random r uniformly from the range [1; t]. 2. The prover sends the verifier h g r (mod p). 3. <p> If g was a generator, however, each element would have only one discrete logarithm in the range [1; p 1]. The protocol consists of dlog 2 pe independent repetitions of the following: 10 Protocol 5 1. The prover chooses a random r uniformly from the range <ref> [1; t] </ref>. 2. The prover sends the verifier h g r (mod p). 3. The verifier chooses fi 2 f0; 1g randomly with equal probabilities and sends fi to the prover. 4. If fi = 0, the prover chooses a random z uniformly from [0; b s 2 c 1]. <p> If fi = 1, the prover chooses a random z uniformly from [d s 2 e; s 1]. 5. The prover sends the verifier r 0 = r + zt who checks that h g r 0 (mod p) and that r 0 2 <ref> [1; p1 2 ] </ref> if fi = 0, or that r 0 2 [ p1 2 + 1; p 1] otherwise. <p> Zero-Knowledge: Let us look at a simulator for this protocol. The simulator would choose a random r uniformly from <ref> [1; p 1] </ref>. The simulator would then run the program for the verifier with the value g r being sent from the prover. The simulator has a 50-50 chance of answering the verifier's question each time simply by revealing r. <p> He sends (t 1 ; t 2 ; : : : ; t k ) to the prover. 3. For 1 i k, the prover chooses a random r i uniformly from the range <ref> [1; t] </ref>. 4. The prover sends the verifier (h 1 ; : : : ; h k ), where h i g r i (mod p). 5. <p> The prover sends (r 0 1 ; : : : ; r 0 k ), where r 0 i = r i + z i t. 9. The verifier checks that h i g r 0 i (mod p) and that r 0 i 2 <ref> [1; p1 2 ] </ref> if fi i = 0, or that r 0 2 + 1; p 1] otherwise. Furthermore, he checks that f = g x . Completeness: The completeness is obvious from the completeness of the non-parallel version of the protocol.
Reference: [2] <author> Adleman, L., K. Manders, and G. Miller, </author> <title> On taking roots in finite fields, </title> <booktitle> Proc. 18th IEEE Symp. on Foundations of Computer Science, </booktitle> <year> 1977, </year> <pages> pp. 175-178. </pages>
Reference-contexts: But we show how the prover can find the one equal to r modulo q l . The prover finds in polynomial time the two square roots r 1 and r 2 of x modulo q l by using <ref> [2] </ref>, [6], [26] or [27] to find the square roots modulo q and then lifting these solutions up to solutions modulo q l . Without loss of generality, suppose r 1 r (mod q l ) and r 2 r (mod q l ).
Reference: [3] <author> Bach, E., </author> <title> How to generate factored random numbers, </title> <journal> SIAM Journal on Computing, </journal> <volume> vol. 17, No. 2, </volume> <month> April </month> <year> 1988, </year> <pages> pp. 179-193. </pages>
Reference-contexts: In most applications, this is a reasonable assumption because it is possible in expected polynomial time to create a random prime p with a given length, along with the complete factorization of p 1 <ref> [3] </ref>, [1]. Now, we will modify the above zero-knowledge proof to include the following steps, which should be repeated k = dlog 2 pe times: Protocol 2 0. The verifier rejects if g (p1)=2 = 1. 1. The verifier randomly and uniformly chooses r 2 Z fl p1 . 2. <p> To find p, one can use Bach's method <ref> [3] </ref> to produce an appropriate a randomly, along with the complete factorization of a. Another way to find an appropriate p is by trying n + 1; 2n + 1; 3n + 1; : : : until we find a prime.
Reference: [4] <author> Bellare, M., S. Micali and R. Ostrovsky, </author> <title> Perfect zero-knowledge in constant rounds, </title> <booktitle> Proc. 22nd ACM Symp. on Theory of Computing, </booktitle> <year> 1990, </year> <pages> pp. 482-493. </pages>
Reference-contexts: In this case the simulation succeeds; otherwise the simulator backs up the verifier, chooses new random fl and r, and tries again. Thus the simulation is expected polynomial time, and this protocol is perfect zero-knowledge: 2 9 Furthermore, the protocol can be parallelized following the lines of <ref> [4] </ref>, as protocol 5 below is parallelized in protocol 6, giving a bounded round, perfect zero-knowledge proof system. <p> Furthermore the protocol can be parallelized using techniques similar to those of <ref> [4] </ref>. Let k = dlog pe. Protocol 6 1. The prover chooses randomly and uniformly x 2 Z fl p1 , computes f g x (mod p), and sends f to the verifier. 2.
Reference: [5] <author> Benaloh, J., </author> <title> Cryptographic capsules: a disjunctive primitive for interactive protocols, </title> <booktitle> Advances in Cryptology - Crypto '86 Proceedings, </booktitle> <year> 1987, </year> <pages> pp. 213-222. </pages>
Reference-contexts: Then, the verifier chooses a random r 2 Z fl n and a random bit fi. The verifier then sends y r n x fi (modn) to the prover. Next, using the technique due to Benaloh <ref> [5] </ref> of using cryptographic capsules, the verifier gives a zero-knowledge proof that he knows n and fi. Finally, the prover reveals the bit fi.
Reference: [6] <author> Berlekamp, E. </author> <title> Factoring polynomials over large finite fields, </title> <journal> Mathematics of Computations, </journal> <volume> vol. 24, </volume> <year> 1970, </year> <pages> pp. 713-735. </pages>
Reference-contexts: But we show how the prover can find the one equal to r modulo q l . The prover finds in polynomial time the two square roots r 1 and r 2 of x modulo q l by using [2], <ref> [6] </ref>, [26] or [27] to find the square roots modulo q and then lifting these solutions up to solutions modulo q l . Without loss of generality, suppose r 1 r (mod q l ) and r 2 r (mod q l ).
Reference: [7] <author> Boppana, R., J. Hastad, and S. Zachos, </author> <title> Does co-NP have short interactive proofs?, </title> <journal> Inf. Proc. Letters, </journal> <volume> vol. 25, </volume> <year> 1987, </year> <pages> pp. 127-132. </pages>
Reference-contexts: It has been shown that if there exist any one-way functions, then every NP-language has a zero-knowledge proof system [19]. On the other hand it is unlikely that there are perfect zero-knowledge proof systems for all problems with zero-knowledge proofs. The results of [17] and <ref> [7] </ref> show that NP-complete languages do not have perfect zero-knowledge proof systems unless the polynomial hierarchy collapses to the second level, which would be a major surprising result in complexity theory. Zero-knowledge interactive proofs can be very useful in designing cryptographic protocols.
Reference: [8] <author> Brassard, G., and C. Crepeau, </author> <title> Non-transitive transfer of confidence: a perfect zero-knowledge interactive protocol for SAT and beyond, </title> <booktitle> Proc. 27th IEEE Symp. on Foundations of Computer Science, </booktitle> <year> 1986, </year> <pages> pp. 188-195. </pages>
Reference-contexts: 1 Introduction Many researchers have studied zero-knowledge proofs and the classes of problems which have such zero-knowledge proofs. Little attention, however, has been paid to the practicality of these proofs. It is known, for example, that, under certain cryptographic assumptions, all problems in NP have zero-knowledge proofs [19], <ref> [8] </ref>, [10]. Although these proofs can be performed with probabilistic polynomial time provers who have the appropriate trapdoor information, these proofs may involve a transformation to a circuit or to an NP-complete problem, so they are often quite inefficient.
Reference: [9] <author> Brassard, G., C. Crepeau, and J.M. Robert, </author> <title> All-or-nothing disclosure of secrets, </title> <booktitle> Advances in Cryptology - Crypto '86 Proceedings, </booktitle> <year> 1987, </year> <pages> pp. 234-238. </pages>
Reference-contexts: The first zero-knowledge proofs, those for quadratic residuosity and non-residuosity [22], were practical; they were efficient and the prover could be probabilistic polynomial time if she 1 had the appropriate trap-door knowledge. Other efficient zero-knowledge proofs are given in <ref> [9] </ref>, [11], [12], [15], [23], [30]. In this paper we present a practical zero-knowledge proof for a special case of primitivity.
Reference: [10] <author> Chaum, D., </author> <title> Demonstrating that a public predicate can be satisfied without revealing any information about how, </title> <booktitle> Advances in Cryptology - Crypto '86 Proceedings, </booktitle> <year> 1987, </year> <pages> pp. 195-199. </pages>
Reference-contexts: 1 Introduction Many researchers have studied zero-knowledge proofs and the classes of problems which have such zero-knowledge proofs. Little attention, however, has been paid to the practicality of these proofs. It is known, for example, that, under certain cryptographic assumptions, all problems in NP have zero-knowledge proofs [19], [8], <ref> [10] </ref>. Although these proofs can be performed with probabilistic polynomial time provers who have the appropriate trapdoor information, these proofs may involve a transformation to a circuit or to an NP-complete problem, so they are often quite inefficient.
Reference: [11] <author> Chaum, D. J.-H. Evertse, J. van de Graaf, </author> <title> An improved protocol for demonstrating possession of discrete logarithms and some generalizations, </title> <booktitle> Advances in Cryptology - EUROCRYPT '87 Proceedings, </booktitle> <year> 1988, </year> <pages> pp. 127-141. </pages>
Reference-contexts: The first zero-knowledge proofs, those for quadratic residuosity and non-residuosity [22], were practical; they were efficient and the prover could be probabilistic polynomial time if she 1 had the appropriate trap-door knowledge. Other efficient zero-knowledge proofs are given in [9], <ref> [11] </ref>, [12], [15], [23], [30]. In this paper we present a practical zero-knowledge proof for a special case of primitivity. <p> Let us first describe 6 the subprotocol used in step 3. This is the parallel version of the discrete logarithm protocol of <ref> [11] </ref> with the roles of the prover and the verifier switched. We are doing it in parallel to make it clearer that the entire primitivity protocol can be done in parallel. The following is done in parallel for 1 i k = dlog 2 pe.
Reference: [12] <author> Chaum, D., J.-H. Evertse, J. van de Graaf, and R. Peralta, </author> <title> Demonstrating possession of a discrete logarithm without revealing it, </title> <booktitle> Advances in Cryptology - Crypto '86 Proceedings, </booktitle> <year> 1987, </year> <pages> pp. 200-212. 17 </pages>
Reference-contexts: The first zero-knowledge proofs, those for quadratic residuosity and non-residuosity [22], were practical; they were efficient and the prover could be probabilistic polynomial time if she 1 had the appropriate trap-door knowledge. Other efficient zero-knowledge proofs are given in [9], [11], <ref> [12] </ref>, [15], [23], [30]. In this paper we present a practical zero-knowledge proof for a special case of primitivity.
Reference: [13] <author> Davenport, H., </author> <title> Multiplicative Number Theory, </title> <publisher> Markham Publishing Company, </publisher> <year> 1967. </year>
Reference: [14] <author> Even, S., A. L. Selman and Y. Yacobi, </author> <title> The complexity of promise problems with applications to public-key cryptography, </title> <journal> Information and Control, </journal> <volume> vol. 61, </volume> <year> 1984, </year> <pages> pp. 159-173. </pages>
Reference-contexts: The tools which have been most useful in cryptography have been number theoretic, so we are concentrating on proofs for number theoretic problems. Some of our proofs only work on a well-defined subset of the possible inputs, so these problems can be viewed as promise problems <ref> [14] </ref> [18]. From [14] we get the notation that a promise problem (Q; R) is deciding if the input x belongs to R given that we know that x belongs to Q. <p> The tools which have been most useful in cryptography have been number theoretic, so we are concentrating on proofs for number theoretic problems. Some of our proofs only work on a well-defined subset of the possible inputs, so these problems can be viewed as promise problems <ref> [14] </ref> [18]. From [14] we get the notation that a promise problem (Q; R) is deciding if the input x belongs to R given that we know that x belongs to Q.
Reference: [15] <author> Feige, U., A. Fiat, and A. Shamir, </author> <title> Zero-knowledge proofs of identity, </title> <journal> Journal of Cryptology, </journal> <volume> 1(2), </volume> <year> 1988, </year> <pages> pp. 77-94. </pages>
Reference-contexts: The first zero-knowledge proofs, those for quadratic residuosity and non-residuosity [22], were practical; they were efficient and the prover could be probabilistic polynomial time if she 1 had the appropriate trap-door knowledge. Other efficient zero-knowledge proofs are given in [9], [11], [12], <ref> [15] </ref>, [23], [30]. In this paper we present a practical zero-knowledge proof for a special case of primitivity. <p> The verifier computes h g r (mod p) and sends it to the prover. 3. The verifier and the prover execute Protocol 3 (see below). This will convince the prover that the verifier knows, in the sense of <ref> [15] </ref>, the discrete logarithm of h. 4. The prover takes the discrete logarithm of h to get r. 5. The prover sends r back to the verifier who checks that it is correct. <p> The verifier computes x r 2 (mod p 1) and sends it to the prover. 5 3. The verifier and prover execute Protocol 3 (see below). This will convince the prover that the verifier knows, in the sense of <ref> [15] </ref>, the discrete logarithm of h. 4 0 : The prover takes the discrete logarithm of h to get r and checks that x has the correct form. If something fails, the prover terminates the protocol. 5. <p> Then he reveals ^r i . 3.5 The prover checks that h i = g ^r i =h fi i . This protocol is in fact a witness hiding proof of knowledge <ref> [15, 16] </ref> of the discrete logarithm of h.
Reference: [16] <author> Feige, U. and A. Shamir, </author> <title> Zero knowledge proofs of knowledge in two rounds., </title> <note> to appear in the proceedings of Crypto '89. </note>
Reference-contexts: Then he reveals ^r i . 3.5 The prover checks that h i = g ^r i =h fi i . This protocol is in fact a witness hiding proof of knowledge <ref> [15, 16] </ref> of the discrete logarithm of h.
Reference: [17] <author> Fortnow, L. </author> <title> The complexity of perfect zero-knowledge, </title> <booktitle> Proc. 19th ACM Symp. on Theory of Computing, </booktitle> <year> 1987, </year> <pages> pp. 204-209. </pages>
Reference-contexts: It has been shown that if there exist any one-way functions, then every NP-language has a zero-knowledge proof system [19]. On the other hand it is unlikely that there are perfect zero-knowledge proof systems for all problems with zero-knowledge proofs. The results of <ref> [17] </ref> and [7] show that NP-complete languages do not have perfect zero-knowledge proof systems unless the polynomial hierarchy collapses to the second level, which would be a major surprising result in complexity theory. Zero-knowledge interactive proofs can be very useful in designing cryptographic protocols.
Reference: [18] <author> Goldreich, O. and E. Kushilevitz, </author> <title> A perfect zero-knowledge proof for a problem equivalent to discrete logarithm, </title> <booktitle> Advances in Cryptology - Crypto '88 Proceedings, </booktitle> <year> 1990, </year> <pages> pp. 57-70. </pages>
Reference-contexts: The tools which have been most useful in cryptography have been number theoretic, so we are concentrating on proofs for number theoretic problems. Some of our proofs only work on a well-defined subset of the possible inputs, so these problems can be viewed as promise problems [14] <ref> [18] </ref>. From [14] we get the notation that a promise problem (Q; R) is deciding if the input x belongs to R given that we know that x belongs to Q.
Reference: [19] <author> Goldreich, O., S. Micali, and A. Wigderson, </author> <title> Proofs that yield nothing but their validity and a methodology of cryptographic protocol design, </title> <booktitle> Proc. 27th IEEE Symp. on Foundations of Computer Science, </booktitle> <year> 1986, </year> <pages> pp. 174-187. </pages>
Reference-contexts: 1 Introduction Many researchers have studied zero-knowledge proofs and the classes of problems which have such zero-knowledge proofs. Little attention, however, has been paid to the practicality of these proofs. It is known, for example, that, under certain cryptographic assumptions, all problems in NP have zero-knowledge proofs <ref> [19] </ref>, [8], [10]. Although these proofs can be performed with probabilistic polynomial time provers who have the appropriate trapdoor information, these proofs may involve a transformation to a circuit or to an NP-complete problem, so they are often quite inefficient. <p> Our imprimitivity protocol is an example of an interactive proof which is statistical, but not perfect, zero-knowledge. It has been shown that if there exist any one-way functions, then every NP-language has a zero-knowledge proof system <ref> [19] </ref>. On the other hand it is unlikely that there are perfect zero-knowledge proof systems for all problems with zero-knowledge proofs. <p> Notice that the above protocol does not involve any encryption. All previous "natural" zero-knowledge proofs which are neither perfect nor statistical zero-knowledge, such as the zero-knowledge proof in <ref> [19] </ref> that a graph is 3-colorable, have used some encryption. 4 Open Problems One would like to find efficient prover-practical zero-knowledge proofs for other problems.
Reference: [20] <author> Goldreich, O., S. Micali, and A. Wigderson, </author> <title> Proofs that yield nothing but their validity and a methodology of cryptographic protocol design, </title> <note> to appear. </note>
Reference-contexts: Zero-Knowledge: We will sketch some of the ideas for the construction of the simulator. The ideas follow the lines of <ref> [20] </ref>. The main idea is to use the verifier (here he can be any probabilistic polynomial time machine), and his proof in step 3 that he knows r, to find this r.
Reference: [21] <author> Goldwasser, S., and S. Micali, </author> <title> Probabilistic encryption, </title> <journal> Journal of Computer and System Sciences, </journal> <volume> vol. 28, </volume> <year> 1984, </year> <pages> pp. 270-299. </pages>
Reference: [22] <author> Goldwasser, S., S. Micali, and C. Rackoff, </author> <title> The knowledge complexity of interactive proof systems, </title> <journal> SIAM Journal on Computing, </journal> <volume> vol. 18, </volume> <year> 1989, </year> <pages> pp. 186-208. </pages>
Reference-contexts: Although these proofs can be performed with probabilistic polynomial time provers who have the appropriate trapdoor information, these proofs may involve a transformation to a circuit or to an NP-complete problem, so they are often quite inefficient. The first zero-knowledge proofs, those for quadratic residuosity and non-residuosity <ref> [22] </ref>, were practical; they were efficient and the prover could be probabilistic polynomial time if she 1 had the appropriate trap-door knowledge. Other efficient zero-knowledge proofs are given in [9], [11], [12], [15], [23], [30]. In this paper we present a practical zero-knowledge proof for a special case of primitivity. <p> We also give practical zero-knowledge proofs for non-primitivity, and for membership and non-membership in fnj n and '(n) are relatively primeg. None of these proofs require that the prover be more than probabilistic polynomial time. 2 Definitions This section contains definitions for interactive proofs and zero-knowledge <ref> [22] </ref>. Definition 1 An interactive proof system for a language L is a protocol for two probabilistic interactive Turing machines, the prover and the verifier. They have a common tape with the input string x. <p> In order to formalize this idea of very similar transcripts, Goldwasser, Micali and Rackoff <ref> [22] </ref> consider probabilistic polynomial time distinguishers, which output 0 on some transcripts and 1 on others. If no distinguisher D can effectively differentiate between two distributions, they are considered similar.
Reference: [23] <author> Van de Graaf, J., and R. Peralta, </author> <title> A simple and secure way to show the validity of your public key, </title> <booktitle> Advances in Cryptology - Crypto '87 Proceedings, </booktitle> <year> 1988, </year> <pages> pp. 128-134. </pages>
Reference-contexts: The first zero-knowledge proofs, those for quadratic residuosity and non-residuosity [22], were practical; they were efficient and the prover could be probabilistic polynomial time if she 1 had the appropriate trap-door knowledge. Other efficient zero-knowledge proofs are given in [9], [11], [12], [15], <ref> [23] </ref>, [30]. In this paper we present a practical zero-knowledge proof for a special case of primitivity.
Reference: [24] <author> Knuth, D. E. </author> <booktitle> The Art of Computer Programming Vol 2, </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1969. </year>
Reference-contexts: Now the simulator will repeat the above procedure until it 13 succeeds in getting another random multiple a 0 t or until it has run the procedure 2 k times, in which case it will find t by brute force. We know from <ref> [24] </ref> that Pr [gcd (at; a 0 t) = t] = 6= 2 .
Reference: [25] <author> Oren, Y. </author> <title> On the Cunning Power of Cheating Verifiers: some Observations About Zero Knowledge Proofs, </title> <booktitle> Proc. 28th IEEE Symp. on Foundations of Computer Science, </booktitle> <year> 1987, </year> <pages> pp. 462-471. </pages>
Reference-contexts: Definition 3 A transcript of a conversation between machines V fl and P consists of the input string, the random bits of V fl , and the messages sent by the two parties. 2 In the following definitions, we are using Oren's notation <ref> [25] </ref>. The verifier may have some auxiliary input y on his private auxiliary input tape. In his definitions of zero-knowledge, Oren takes into account the effect that this auxiliary input has on the communication between the two parties. <p> Hence the simulator is expected polynomial time for fixed c. Other than allowing the simulator's running time to vary depending on c, this definition is identical to Oren's <ref> [25] </ref>, and we are using similar notation. Definition 8 Let (P; V ) be a interactive proof system for L.
Reference: [26] <author> Rabin, M.O., </author> <title> Digitalized signatures and public-key functions as intractable as factorization, </title> <type> Technical Report MIT/LCS/TR-212, </type> <institution> M.I.T., </institution> <month> January </month> <year> 1979. </year>
Reference-contexts: But we show how the prover can find the one equal to r modulo q l . The prover finds in polynomial time the two square roots r 1 and r 2 of x modulo q l by using [2], [6], <ref> [26] </ref> or [27] to find the square roots modulo q and then lifting these solutions up to solutions modulo q l . Without loss of generality, suppose r 1 r (mod q l ) and r 2 r (mod q l ).
Reference: [27] <author> Rabin, M.O., </author> <title> Probabilistic algorithms in finite fields, </title> <journal> SIAM Journal on Computing, </journal> <volume> vol. 9, </volume> <year> 1980, </year> <pages> pp. 273-280. </pages>
Reference-contexts: But we show how the prover can find the one equal to r modulo q l . The prover finds in polynomial time the two square roots r 1 and r 2 of x modulo q l by using [2], [6], [26] or <ref> [27] </ref> to find the square roots modulo q and then lifting these solutions up to solutions modulo q l . Without loss of generality, suppose r 1 r (mod q l ) and r 2 r (mod q l ).
Reference: [28] <author> Rosser, J. B., and Schoenfeld, L., </author> <title> approximate formulas for some functions of prime numbers, </title> <journal> Illinois Journal of Math. </journal> <volume> vol. 6, </volume> <year> 1962, </year> <pages> pp. 64-94. </pages>
Reference-contexts: (x 2 log x); where lix = 2 log t x log 2 Z x 1 dt &gt; log x Hence the probability that a random m, chosen so that m 1 (mod n) and m x, is prime is x O (1) 1 b (x 1)=nc We have from <ref> [28] </ref> that '(n) C (n= log log n); hence if x = n 3 the above is greater than C 0 log log n + O (n 1 Note that x = n 2+* is sufficient if * &gt; 0.
Reference: [29] <author> Schwarz, W., </author> <title> in American Math. </title> <journal> Monthly, </journal> <volume> vol. 73, </volume> <year> 1966, </year> <pages> pp. 426-427. </pages>
Reference-contexts: The set of primes, for which this protocol can be used to "prove" that an element is a generator, is of reasonable size since <ref> [29] </ref> proved that 9c &gt; 0 : fpj p x; p prime and p 1 square-freeg fpj p x and p primeg c for x sufficiently large. Throughout this section, we have been looking at the multiplicative group Z fl p of the integers modulo a prime p.
Reference: [30] <author> Tompa, M., and H. Woll, </author> <title> Random self-reducibility and zero knowledge interactive proofs of possession of information, </title> <booktitle> Proc. 28th IEEE Symp. on Foundations of Computer Science, </booktitle> <year> 1987, </year> <pages> pp. 472-482. 18 </pages>
Reference-contexts: The first zero-knowledge proofs, those for quadratic residuosity and non-residuosity [22], were practical; they were efficient and the prover could be probabilistic polynomial time if she 1 had the appropriate trap-door knowledge. Other efficient zero-knowledge proofs are given in [9], [11], [12], [15], [23], <ref> [30] </ref>. In this paper we present a practical zero-knowledge proof for a special case of primitivity. <p> This protocol, which shows that an element of the multiplicative group modulo a prime is a generator, only requires that the prover be probabilistic polynomial time, though she must know the complete factorization of p1. Note that the protocol given in <ref> [30] </ref> is not practical because the prover must be able to compute discrete logarithms. In order to avoid that problem in our protocol, we have the verifier give the prover "hints" which will help her find the discrete logarithms in question. <p> The prover takes the discrete logarithm of h to get r. 5. The prover sends r back to the verifier who checks that it is correct. This is slightly more complicated than the zero-knowledge proof in <ref> [30] </ref>, and it still has the problem that the prover needs to be able to take discrete logarithms. If instead of proving that g is a generator, we just want an interactive proof that g is a quasi-generator, then we don't need such a powerful prover. <p> The proof is statistical zero-knowledge if p1 large enough. The major advantage of the protocol given here over that in <ref> [30] </ref> is that we do not need to assume that a generator for Z fl p is publicly available. <p> The prover's auxiliary input tape contains t. 12 With this new definition of zero-knowledge we can also remove the assumption, in the protocol in <ref> [30] </ref> for the same problem, that one generator is publicly known. We can let the prover give the verifier a random generator.
Reference: [31] <author> Wagstaff, S. S., </author> <title> Greatest of the least primes in arithmetic progressions having a given modulus, </title> <journal> Mathematics of Computation, </journal> <volume> vol. 33 no. 147, </volume> <month> July </month> <year> 1979, </year> <pages> pp. 1073-1080. </pages>
Reference-contexts: Another way to find an appropriate p is by trying n + 1; 2n + 1; 3n + 1; : : : until we find a prime. Wagstaff <ref> [31] </ref> has given an heuristic argument which says that we would usually only have to try up to O (log 2 n) numbers. Observe that we can factor a since it is so small.
References-found: 31

