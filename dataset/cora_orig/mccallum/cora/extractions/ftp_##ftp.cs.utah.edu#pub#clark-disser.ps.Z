URL: ftp://ftp.cs.utah.edu/pub/clark-disser.ps.Z
Refering-URL: http://www.cs.utah.edu/~cs678/schedule.html
Root-URL: 
Title: THE DYNAMIC EXPANSION OF CLASS HIERARCHY  
Author: by Charles F. Clark 
Degree: A thesis submitted to the faculty of The University of Utah in partial fulfillment of the requirements for the degree of Doctor of Philosophy  
Date: August 1994  
Affiliation: Department of Computer Science The University of Utah  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Agrawal, R., Dar, S., and Gehani, N. H. </author> <title> The O++ database programming language: Implementation and experience. </title> <booktitle> In Proceedings of the IEEE 9th International Conference on Data Engineering (1993), </booktitle> <publisher> IEEE Computer Press. </publisher>
Reference-contexts: No extensions or modifications to the syntax of the language. Commercial and research efforts that have added persistence to the C++ programming language 8 often do so by extending or modifying the language. These extensions or modifications typically take the form of new keywords added to the language <ref> [1, 4, 9, 27] </ref>. When adding persistence and dynamic expansion to a language it is advantageous to avoid these modifications. Usually, programs written for one system must be re-written for execution under another system. <p> However, language restrictions, in general, will also tend to limit experimentation and acceptance. No specific class hierarchy. Many object store systems require that a specific system-provided class be used as the basis for the classes of all persistent objects within a program <ref> [1, 6, 9, 27] </ref>. For example, the declaration of a class Persistent may be provided, from which the classes of all objects that may be saved must be derived.
Reference: [2] <author> Bracha, G., and Lindstrom, G. </author> <title> Modularity meets inheritance. </title> <booktitle> In Proc. International Conference on Computer Languages (San Francisco, </booktitle> <address> CA, April 20-23 1992), </address> <publisher> IEEE Computer Society, </publisher> <pages> pp. 282-290. </pages> <note> Also available as Technical Report UUCS-91-017. </note>
Reference-contexts: These are objects, classes, inheritance, polymorphism, and dynamic binding [33]. Inheritance coupled with dynamic binding is a novel contribution; it is this concept that constitutes a significant advance toward constructing software systems from reusable parts <ref> [2] </ref>. It is inheritance, coupled with polymorphism and dynamic binding, that facilitates extensibility of a given object-oriented system. Inheritance supports software reuse by providing a mechanism whereby an existing class definition may be used as a basis for the definition of a new class.
Reference: [3] <author> Call, L. A., Cohrs, D. L., and Miller, B. P. </author> <title> CLAM | An open system for graphical user interfaces. </title> <booktitle> In OOPSLA '87 Proceedings (October 1987), </booktitle> <editor> N. Meyrowitz, Ed., </editor> <publisher> ACM Press, </publisher> <pages> pp. 277-286. </pages>
Reference-contexts: Koskimies and J. Vihavainen [17], all of which discuss the capability to dynamically load class implementations or expand the class hierarchy of a C++ program at the expense of additions to the programming language and/or restrictions on the class hierarchy of programs. The CLAM <ref> [3] </ref> and Andrew [23] projects also supported a restricted form of class hierarchy expansion. * SOS, P. Gautron and M. Shapiro, 1987, 1989 [10] [27] The design and implementation of a dynamic loader and linker for the C++ language is discussed in [10, 27]. <p> A static function also defined within the subclass is relied upon for runtime access to the entrance class instance. * CLAM, L. Call, D. Cohrs and B. Miller, 1987 <ref> [3] </ref> An early experiment in extensibility and object-oriented languages is described in [3]. This system is designed to support the building of graphical user interfaces using the client/server model. The functionality of the CLAM server 69 may be extended by dynamically loading C++ member functions. <p> A static function also defined within the subclass is relied upon for runtime access to the entrance class instance. * CLAM, L. Call, D. Cohrs and B. Miller, 1987 <ref> [3] </ref> An early experiment in extensibility and object-oriented languages is described in [3]. This system is designed to support the building of graphical user interfaces using the client/server model. The functionality of the CLAM server 69 may be extended by dynamically loading C++ member functions. These dynamically loaded functions provide a way to introduce extensions to the user interface.
Reference: [4] <author> Casais, E., Ranft, M., Schiefer, B., mar Theobald, D., and Zim-mer, W. </author> <title> OBST an overview. </title> <type> Tech. rep., </type> <institution> Forschungszentrum Informatik (FZI), D-76131 Karlsruhe, Germany, </institution> <year> 1993. </year>
Reference-contexts: No extensions or modifications to the syntax of the language. Commercial and research efforts that have added persistence to the C++ programming language 8 often do so by extending or modifying the language. These extensions or modifications typically take the form of new keywords added to the language <ref> [1, 4, 9, 27] </ref>. When adding persistence and dynamic expansion to a language it is advantageous to avoid these modifications. Usually, programs written for one system must be re-written for execution under another system.
Reference: [5] <author> Coplien, J. O. </author> <title> Advanced C++ Programming Styles and Idioms. </title> <publisher> Addison-Wesley, </publisher> <year> 1992. </year>
Reference-contexts: The former posed problems because our system does not support the storage of pointers to functions. If pointer to virtual member functions were used, then this would not be a problem. After first modifying the simulation framework to use pointers to virtual member functions, we found that functor objects <ref> [5] </ref> provided a more elegant and powerful solution. The second problem was troublesome because it necessitated the loading and storing of many separate objects when check-pointing or restarting the simulation. Through linking the state of the simulation into a single object graph, only one load or store operation is required.
Reference: [6] <author> Dixon, G., Parrington, G., Shrivastava, S., and Wheater, S. </author> <title> The treatment of persistent objects in Arjuna. </title> <booktitle> In Proceedings of the 1989 European Conference on Object-Oriented Programming (University of Not-tingham, </booktitle> <month> July 10-14, </month> <year> 1989), </year> <editor> S. Cook, Ed., </editor> <publisher> Cambridge University Press, </publisher> <pages> pp. 169-189. </pages>
Reference-contexts: Moreover, the ease with which persistent operations may be added to existing programs will largely determine the scope of programmer experimentation with a persistent object store system. No language restrictions. Some C++ persistent object systems support only a subset of the C++ language <ref> [6, 26] </ref>. There are features in the language, for C compatibility reasons, that are best left unused in object-oriented programs. However, language restrictions, in general, will also tend to limit experimentation and acceptance. No specific class hierarchy. <p> However, language restrictions, in general, will also tend to limit experimentation and acceptance. No specific class hierarchy. Many object store systems require that a specific system-provided class be used as the basis for the classes of all persistent objects within a program <ref> [1, 6, 9, 27] </ref>. For example, the declaration of a class Persistent may be provided, from which the classes of all objects that may be saved must be derived.
Reference: [7] <author> Dorward, S. M., Sethi, R., and Shopiro, J. E. </author> <title> Adding new code to a running C++ program. </title> <booktitle> In USENIX Proceedings C++ Conference (1990), USENIX Association, </booktitle> <pages> pp. 279-292. </pages>
Reference-contexts: Gautron and M. Shapiro [27]; work done at AT&T Bell Laboratories by S. Dorward, R. Sethi, and J. Shopiro <ref> [7] </ref>; and research at the University of Tampere, Finland by K. Koskimies and J. <p> It is possible to associate a specific method table with an object, so it is possible to have two objects of the same "class" that are using different implementations of that "class". * Adding New Code to a Running C++ Program, S. Dorward, et al., 1990 <ref> [7] </ref> An implementation of class hierarchy expansion in C++ is described in [7]. This work focuses on the following problem: after a new class definition has been added to a process, objects of that class must be created in order to take advantage of the addition. <p> Dorward, et al., 1990 <ref> [7] </ref> An implementation of class hierarchy expansion in C++ is described in [7]. This work focuses on the following problem: after a new class definition has been added to a process, objects of that class must be created in order to take advantage of the addition.
Reference: [8] <author> Ellis, M. A., and Stroustrup, B. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference-contexts: For those unfamiliar with techniques used by C++ compilers, an overview of the object layout and virtual function dispatch scheme used by the GNU compiler is presented in the Appendix to this document and a general discussion of the topic is presented in <ref> [8] </ref>. A summary of the changes we made to the GNU compiler is given in Section 6.4.4. The modified compiler generates type descriptors that contain the fields listed in Table 6.1. <p> The modified data structures are as follows 1 : struct Vtbl_Header // Element 0: Table Header - short unused_1; short unused_2; int size; -; struct Vtbl_Rtti // Element 1: Type Information - short delta; short offset; Type_Desc *type; -; struct Vtbl_Function // Element 2, N: Function Pointers 1 See <ref> [8] </ref> for a description of these structures, particularly the delta and offset data members. 43 short delta; short offset; void (*function)(); -; union Vtbl - Vtbl_Header header; Vtbl_Rtti rtti; // Addition for Type Information Vtbl_Function function; -; Thus, the dispatch tables generated by the modified compiler consist of an array of <p> Similar techniques are commonly used in other C++ language compilers. For an in-depth study of these, and related, techniques it is suggested that the reader consult <ref> [8] </ref>. 81 Figure A.1. Single Inheritance: (i) base, (ii) derived virtual functions defined for a given class. In this case, only one function has been declared virtual, A::f (), so there is only one entry in the vtable, see Figure A.1 (i).
Reference: [9] <author> Eppinger, J. L., Mummert, L. B., and Spector, A. Z. ., Eds. Camelot and Avalon: </author> <title> A Distributed Transaction Facility. Data Management Systems. </title> <publisher> Morgan Kaufmann Publishers, </publisher> <address> Menlo Park, CA, </address> <year> 1991. </year>
Reference-contexts: No extensions or modifications to the syntax of the language. Commercial and research efforts that have added persistence to the C++ programming language 8 often do so by extending or modifying the language. These extensions or modifications typically take the form of new keywords added to the language <ref> [1, 4, 9, 27] </ref>. When adding persistence and dynamic expansion to a language it is advantageous to avoid these modifications. Usually, programs written for one system must be re-written for execution under another system. <p> However, language restrictions, in general, will also tend to limit experimentation and acceptance. No specific class hierarchy. Many object store systems require that a specific system-provided class be used as the basis for the classes of all persistent objects within a program <ref> [1, 6, 9, 27] </ref>. For example, the declaration of a class Persistent may be provided, from which the classes of all objects that may be saved must be derived.
Reference: [10] <author> Gautron, P., and Shapiro, M. </author> <title> Two extensions to C++: A dynamic link editor and inner data. </title> <booktitle> In USENIX Proceedings and Additional Papers C++ Workshop (1987), USENIX Association, </booktitle> <pages> pp. 23-34. 86 </pages>
Reference-contexts: The CLAM [3] and Andrew [23] projects also supported a restricted form of class hierarchy expansion. * SOS, P. Gautron and M. Shapiro, 1987, 1989 <ref> [10] </ref> [27] The design and implementation of a dynamic loader and linker for the C++ language is discussed in [10, 27]. In support of the dynamic loading of class methods, new keywords are introduced into the C++ language. <p> The CLAM [3] and Andrew [23] projects also supported a restricted form of class hierarchy expansion. * SOS, P. Gautron and M. Shapiro, 1987, 1989 [10] [27] The design and implementation of a dynamic loader and linker for the C++ language is discussed in <ref> [10, 27] </ref>. In support of the dynamic loading of class methods, new keywords are introduced into the C++ language. The declaration of a dynamic class causes all method invocations for that class to use 67 indirection through a table of function pointers.
Reference: [11] <author> Gingell, R. A. </author> <title> Shared libraries. Unix Review 7, </title> <month> 8 (August </month> <year> 1989), </year> <pages> 56-66. </pages>
Reference-contexts: In addition, memory resources are shared among concurrently running programs that use the same shared library functions. These benefits attributed to shared libraries can also apply to dynamically linked class implementations <ref> [11] </ref>. Dynamic expansion is, in fact, the application of dynamic and deferred linking to the implementations of C++ classes. By taking advantage of the inheritance, polymorphism and dynamic binding in C++ we are able to defer the linking of certain derived class implementations until they are actually needed.
Reference: [12] <author> Goldstein, T. C., and Sloane, A. D. </author> <title> The Object Binary Interface| C++ objects for evolvable shared class libraries. </title> <booktitle> In Proceedings of the C++ Conference (Cambridge, </booktitle> <address> MA, </address> <month> April </month> <year> 1994), </year> <booktitle> USENIX Association, </booktitle> <pages> pp. 1-19. </pages>
Reference-contexts: In particular, commercial software vendors have placed an emphasis on these problems. Three such efforts are work done at Sun Microsystems Laboratories by Theodore C. Goldstein and Alan D. Sloane <ref> [12] </ref>, an extensive study on persistent objects at IBM with key participants William Harrison and Harold Ossher [14], and the ObjectStore Database System by Charles Lamb, Gordon Landis, Jack Orenstein and Dan Weinreb [19]. * The Object Binary Interface | C++ Objects for Evolvable Shared Class Li braries, Theodore C. <p> Goldstein and Alan D. Sloane, 1994 <ref> [12] </ref>. 72 This object and implementation model provides a mechanism for allowing instances to span versions and multiple implementations of a class to reside concurrently in a program.
Reference: [13] <author> Grossman, M. </author> <title> Object I/O and runtime type information via automatic code generation in C++. </title> <booktitle> Journal of Object-Oriented Programming 6, 4 (July/August 1993), </booktitle> <pages> 34-42. </pages>
Reference-contexts: Our implementation of dynamic expansion, presented in Chapter 6, is based on a modified compiler which generates type descriptors. The definition of these type descriptors is given in Section 6.4.2. See [21] for a preprocessor which generates a type descriptor, or dossier, for each user-defined class and structure and <ref> [13] </ref> 15 for a preprocessor that modifies the original source code while generating type information. Preprocessor There are advantages to both techniques for type descriptor generation. For a preprocessor, the advantages are: Portability. A compiler back-end is platform specific. The preprocessor, however, can be written in portable source code. Compatibility.
Reference: [14] <author> Harrison, W., and Ossher, H. </author> <title> Checking evolving interfaces in the presence of persistent objects. </title> <note> Computer Science Research Report RC 15520 (#69030), </note> <institution> IBM Research Division, </institution> <month> February 23, </month> <year> 1990. </year>
Reference-contexts: In particular, commercial software vendors have placed an emphasis on these problems. Three such efforts are work done at Sun Microsystems Laboratories by Theodore C. Goldstein and Alan D. Sloane [12], an extensive study on persistent objects at IBM with key participants William Harrison and Harold Ossher <ref> [14] </ref>, and the ObjectStore Database System by Charles Lamb, Gordon Landis, Jack Orenstein and Dan Weinreb [19]. * The Object Binary Interface | C++ Objects for Evolvable Shared Class Li braries, Theodore C. Goldstein and Alan D. <p> The object model employs an offset table that describes the object layout and has pointers to the virtual functions of the class. * Checking evolving interfaces in the presence of persistent objects, W. Harrison and H. Ossher, 1990 <ref> [14] </ref>. The RP DE 3 project is an exploration in the use of a persistent object store for the storage of a structural representation of software. One part of this effort includes developing an approach to the type-checking of object-oriented systems using roles.
Reference: [15] <author> Ho, W., and Olsson, R. </author> <title> An approach to genuine dynamic linking. </title> <journal> Software| Practice and Experience 21, </journal> <month> 4 (April </month> <year> 1991), </year> <pages> 375-390. </pages>
Reference-contexts: As noted above, the reconstructor function for a particular class is emitted into the file containing that class's type descriptor. 6.4.8 Dynamic Loading When dynamic expansion is needed, the registered implementation is dynamically loaded into the running program. This dynamic linking is performed by the GNU dld dynamic linker <ref> [15] </ref>. Since the implementation contains the class member functions, virtual function dispatch tables and the type descriptors, this file is all that is typically needed. <p> Two components of the system fall into this category; they are the GNU compiler [29, 32] and the GNU Dynamic Link Editor <ref> [15] </ref>. * Using and Porting the GNU CC, R. M. Stallman, 1990 [29] The GNU C/C++ compiler is a product of the Free Software Foundation, and is freely available in source code form. <p> Wallace, 1992 [32] The Free Software Foundation's GNU C++ 2.2 compiler provided a commandline switch to optionally create type-descriptor objects. This feature was implemented in 1992 by David Wallace [32]. * An Approach to Genuine Dynamic Linking, W. Ho and R. Olsson, 1990 <ref> [15] </ref> A library of C functions that perform dynamic link editing is described in [15]. The functions in this package provide the capability to add compiled code to a process any time during its execution. <p> This feature was implemented in 1992 by David Wallace [32]. * An Approach to Genuine Dynamic Linking, W. Ho and R. Olsson, 1990 <ref> [15] </ref> A library of C functions that perform dynamic link editing is described in [15]. The functions in this package provide the capability to add compiled code to a process any time during its execution. The newly loaded code is linked into the running process by resolving the external symbols with those present in the original process.
Reference: [16] <author> Interrante, J. A., and Linton, M. A. </author> <title> Runtime access to type information in C++. </title> <booktitle> In USENIX Proceedings C++ Conference (1990), USENIX Association, </booktitle> <pages> pp. 233-240. </pages>
Reference-contexts: The term "dossier" was coined by J. Interrante and M. Linton in their work on runtime type information for C++ <ref> [16] </ref> and is synonymous with "type descriptor." Two research efforts that generate type descriptors for use in support of persistent objects are: a system developed at the University of Utah (in which the author participated) [21], and work done at the University of Texas [28]. * A Dossier Driven Persistent Objects <p> These descriptors give the size of data types and the location of pointers within these types. The output of this preprocessor can then be linked into the application to provide run-time type information. * Runtime Access to Type Information in C++, J. Interrante and M.Linton, 1990 <ref> [16] </ref> 71 This paper proposes a "Dossier" class as a standard interface for accessing type information from within a C++ program. It advocates the addition of a predefined member in all classes to provide this information.
Reference: [17] <author> Koskimies, K., and Vihavainen, J. </author> <title> The problem of unexpected subclasses. </title> <type> Tech. rep., </type> <institution> University of Tampere, SF-33101 Tampere, Finland, </institution> <year> 1991. </year>
Reference-contexts: Gautron and M. Shapiro [27]; work done at AT&T Bell Laboratories by S. Dorward, R. Sethi, and J. Shopiro [7]; and research at the University of Tampere, Finland by K. Koskimies and J. Vihavainen <ref> [17] </ref>, all of which discuss the capability to dynamically load class implementations or expand the class hierarchy of a C++ program at the expense of additions to the programming language and/or restrictions on the class hierarchy of programs. <p> Only the class hierarchies rooted by class Class and class Promotable are dynamically expandable. * The Problem of Unexpected Subclasses, K. Koskimies and J. Vihavainen, 1991 <ref> [17] </ref> It is argued that object-oriented languages should allow systems to be extended with subclasses, even though the definitions of those subclasses were not known when the system was constructed.
Reference: [18] <author> Lamb, C., Landis, G., Orenstein, J., and Weinreb, D. </author> <title> The Object-Store database system. </title> <journal> Communications of the ACM 34, </journal> <month> 10 (October </month> <year> 1991), </year> <pages> 50-63. </pages>
Reference-contexts: The store operation described in Section 6.6 uses this policy. Other solutions are to require the programmer to discriminate the union through the use of a special notation [21], or for the programmer to supply a discrimination function <ref> [18] </ref>. Ultimately, the best solution is to deprecate the use of unions. Inheritance may be used in situations where unions are thought to be needed. Dynamically sized arrays. Storing the target of a pointer when the type of the pointer may be an array is difficult.
Reference: [19] <author> Lamb, D. A. </author> <title> Software Engineering: Planning for Change. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1988. </year>
Reference-contexts: Indeed, the development of a program rarely ends with its first release, and the maintenance results in new versions of the source code for that program. It has been estimated that 40 percent of the software development effort is in maintaining and enhancing old systems <ref> [19] </ref>. This maintenance is simplified when the changes are isolated within encapsulated classes. With dynamic expansion, maintenance can be further simplified by allowing changes to the class definitions used by a suite of programs without requiring the rewriting or recompilation of all of these programs. <p> Goldstein and Alan D. Sloane [12], an extensive study on persistent objects at IBM with key participants William Harrison and Harold Ossher [14], and the ObjectStore Database System by Charles Lamb, Gordon Landis, Jack Orenstein and Dan Weinreb <ref> [19] </ref>. * The Object Binary Interface | C++ Objects for Evolvable Shared Class Li braries, Theodore C. Goldstein and Alan D. <p> An important aspect of this is an efficient approach to checking type-consistency with existing persistent objects when code changes are made. This entails querying the persistent store at compilation time to determine whether type-consistency has been violated. * The ObjectStore Database System, C. Lamb, et al., 1991 <ref> [19] </ref>. A goal of the ObjectStore system was to develop a persistent object system that was closely integrated with the programming language.
Reference: [20] <author> Linton, M. A., Calder, P. R., and Vlissides, J. M. </author> <month> InterViews: </month>
Reference-contexts: This chapter gives a brief description of these two applications and the results of our assessment. 7.1 Regression Test As a regression test, we used our modified C++ compiler to build the InterViews library <ref> [20] </ref>. The InterViews library, with associated applications, contains over 45,000 lines of C++ code and makes extensive use of class inheritance and virtual functions. A drawing program, idraw, distributed with the library was also built with the modified compiler, and this application ran without error.
References-found: 20

