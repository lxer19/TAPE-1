URL: http://www.research.microsoft.com/users/dsyme/papers/uitp98.ps.gz
Refering-URL: http://www.research.microsoft.com/users/dsyme/publications.html
Root-URL: http://www.research.microsoft.com
Title: Formal Aspects of  Interaction for Declarative Theorem Proving  
Author: Don Syme 
Keyword: User interfaces; Theorem provers; Declarative proof; Interactive development environments; Formal methods  
Address: St. George House, 1 Guildhall Street, Cambridge, CB2 3NH, UK  
Affiliation: 1 Microsoft Research Limited,  
Note: c  
Pubnum: Computing  
Date: (1998) 3: 1-000  1998 BCS  
Abstract: This article is concerned with interactive support for "declarative theorem proving". After introducing declarative theorem proving, both in general and as implemented in the Declare system, we outline the requirements of an interactive system in this context. We describe Ideclare, the interactive environment for Declare, and in particular its support for visualisation, logical navigation and debugging. We argue why declarative proof is particularly suited to interactive support, in contrast to general tactic proof, especially because it allows logical navigation without having to discharge proof obligations or execute user-defined tactics along the way. We informally evaluate Ideclare with respect to a number of tasks and discuss several plausible extensions to the proposed mechanisms. 
Abstract-found: 1
Intro-found: 1
Reference: [AGMT98] <author> J. S. Aitken, P. Gray, T. Melham, and M. Thomas. </author> <title> Interactive theorem proving: An empirical study of user activity. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 25(2) </volume> <pages> 263-284, </pages> <month> February </month> <year> 1998. </year>
Reference-contexts: You can analyse such mechanisms at several levels, e.g. as "abstract interactions" such as writing a proof outline or interpreting feedback from a failed proof attempt, or "concrete interactions" such as pressing keys and moving a mouse <ref> [AGMT98] </ref>. We shall be primarily concerned mechanisms and tasks analysed at an abstract level. In this setting, traditional IDEs like Visual C++ are, naturally, mechanisms for constructing correct programs. In our setting, we are interested in IDEs that support the task of constructing correct proofs. 3.1. <p> Comparing two systems on a specified set of tasks makes things considerably simpler. This, of course, begs the obvious question: how do we measure "mean time to task completion"? Controlled experiments to determine task completion times for complex tasks are expensive and difficult. For example, Aitken et al. <ref> [AGMT98] </ref> have used controlled quantitative experiments to investigate interaction (but not proof style) in HOL and PVS. Similar experiments investigating proof style would be interesting but are beyond the scope of this work. Truly controlled experiments would be very difficult, after all "real" verifications can take several man-years to construct.
Reference: [BM81] <author> R. S. Boyer and J Strother Moore. </author> <title> Integrating decision procedures into heuristic theorem provers. </title> <type> Technical report, </type> <institution> Univ. of Texas, </institution> <year> 1981. </year>
Reference-contexts: The justification language is for giving small, declarative hints to the automated engine and is quite different to the proof outlining language. Existing theorem provers with strong automation effectively support a kind of declarative proof at the top level. For example, the Boyer-Moore prover <ref> [BM81] </ref> is declarative in this sense. Declare extends this approach to allow declarative decompositions in a structured fashion. We defined "declarative" to mean "relatively free of operational detail", i.e. 4 Don Syme "what" not "how".
Reference: [COR + 95] <author> Judy Crow, Sam Owre, John Rushby, Natarajan Shankar, and Mandayam Srivas. </author> <title> A tutorial introduction to PVS. </title> <booktitle> In Proceedings of the Workshop on Industrial-Strength Formal Specification Techniques, </booktitle> <address> Baco Raton, Florida, </address> <year> 1995. </year>
Reference-contexts: Interaction for Declarative Theorem Proving 3 To take a simple concrete example, proofs in interactive theorem provers (e.g. HOL, PVS and Isabelle <ref> [Pau90, GM93, COR + 95] </ref>) are typically sensitive to the order in which subgoals are produced by an induction utility. That is, if the N-induction utility suddenly produced the step case before the base case, then most proofs using this construct would break. <p> Specification is succinct and a wide range of notational conventions are supported. Proofs are described using tactics, and a number of powerful generic proof routines including first order provers and simplification engines are available. * PVS <ref> [COR + 95] </ref>. This is an implementation of a rich higher order logic, including predicate subtypes, and is notable for its excellent interactive environment, powerful integrated decision procedures and pragmatic approach to integrating model checking. It has not been widely applied to operational semantics. * ACL2 [KM96]. <p> Thus, in Ideclare, essentially the same apparatus can be used for displaying the environment inside a proof. Other theorem provers implement visualisation environments similar to Ide-clare's, e.g. PVS <ref> [COR + 95] </ref> has theory browsing windows, and TkHol [Sym95], the author's interface for the HOL theorem prover, displayed a hierarchy of theories and the theorems and definitions contained in each.
Reference: [DT96] <author> D. Nazareth and T. Nipkow. </author> <title> Formal verification of algorithm W: The monomor-phic case. </title> <editor> In J. Von Wright, J. Grundy, and J. Harrison, editors, </editor> <booktitle> Ninth international Conference on Theorem Proving in Higher Order Logics TPHOL, volume 1125 of Lecture Notes in Computer Science, </booktitle> <pages> pages 331-346, </pages> <address> Turku, Finland, August 1996. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: We give one example from Isabelle. We make no attempt to explain the proof, precisely because it is so just hard to know what's going on. The proof of the correctness of the W type inference algorithm in Nipkow and Nazareth's formulation <ref> [DT96] </ref> begins: (* correctness of W with respect to has_type *) goal W.thy "!A S t m n . new_tv n A --&gt; Some (S,t,m) = W e A n --&gt; $S A |- e :: t"; by (expr.induct_tac "e" 1); (* case Var n *) by (asm_full_simp_tac (simpset () addsplits
Reference: [GM93] <author> M.J.C Gordon and T.F Melham. </author> <title> Introduction to HOL: A Theorem Proving Assistant for Higher Order Logic. </title> <publisher> Cambridge University Press, </publisher> <year> 1993. </year>
Reference-contexts: Interaction for Declarative Theorem Proving 3 To take a simple concrete example, proofs in interactive theorem provers (e.g. HOL, PVS and Isabelle <ref> [Pau90, GM93, COR + 95] </ref>) are typically sensitive to the order in which subgoals are produced by an induction utility. That is, if the N-induction utility suddenly produced the step case before the base case, then most proofs using this construct would break. <p> Rather it was used to explore mechanisms of specification, proof and interaction that may eventually be incorporated into those systems, and thus complement them. Some of the systems that have most influenced Declare are: * HOL <ref> [GM93] </ref>. This is an implementation of polymorphic higher order logic implemented in an "LCF-style" [GMW77], that is the logic is mechanized starting with a simple set of rules and axioms, and relies heavily on user-programmed rules of inference written in a dialect of ML.
Reference: [GMW77] <author> Michael Gordon, R. Milner, and Christopher Wadsworth. </author> <title> Edinburgh LCF. </title> <type> Internal Report CSR-11-77, </type> <institution> University of Edinburgh, Department of Computer Science, </institution> <month> September </month> <year> 1977. </year>
Reference-contexts: The aim of declarative proof is to eliminate such fragility where possible. Some declarative systems allow access to a "procedural level" when necessary (e.g. L A T E X). One could certainly allow this in a declarative theorem proving system, e.g. via LCF-like programmabiliy <ref> [GMW77] </ref>. In this work, however, we shall not give in to such temptations! 2.2. Principles of Declarative Proof We now proceed to summarize some of the defining features of declarative proof languages. For a description of other issues relating to declarative theorem proving, such as declarative specification, see [Sym98]. <p> Some of the systems that have most influenced Declare are: * HOL [GM93]. This is an implementation of polymorphic higher order logic implemented in an "LCF-style" <ref> [GMW77] </ref>, that is the logic is mechanized starting with a simple set of rules and axioms, and relies heavily on user-programmed rules of inference written in a dialect of ML. HOL supports a wide range of specification constructs and automated reasoning routines. Proofs are described using tactics. * Isabelle [Pau90]. <p> The obligation is normally justified by an appeal to automated reasoning, but a nested proof outline can also be given. The special derived forms for the "linear" case n = 1 are shown in Table 1. 2.6. Comparison with Tactics Tactics, first used in LCF <ref> [GMW77] </ref>, are the traditional mechanism for proof de scription in LCF-style systems.
Reference: [Har96] <author> J. Harrison. </author> <title> A Mizar Mode for HOL. </title> <editor> In J. Von Wright, J. Grundy, and J. Harrison, editors, </editor> <booktitle> Ninth international Conference on Theorem Proving in Higher Order Logics TPHOL, volume 1125 of Lecture Notes in Computer Science, </booktitle> <pages> pages 203-220, </pages> <address> Turku, Finland, August 1996. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: We use "proof outline" to mean a script to be presented to a machine for checking that may require significant effort to fill in the gaps in reasoning. This builds on work done with similar languages by the Mizar group [Rud92] and Harrison <ref> [Har96] </ref>. One traditional form of proof description is "tactic" proof.
Reference: [Ker97] <author> Manfred Kerber. </author> <title> Proof planning: A practical approach to mechanised reasoning in mathematics. </title> <type> Technical Report CSRP-97-24, </type> <institution> University of Birmingham, School of Computer Science, </institution> <month> September </month> <year> 1997. </year>
Reference-contexts: The choice would be recorded as an entry in the proof document. * Presenting the user with expansions and simplifications of existing formulae, again recording the results in the proof document. * Performing proof planning <ref> [Ker97] </ref> and inserting the resulting proof plan as a part of the proof outline. A trial version of the induction CAPW mechanism was implemented in an early 22 Don Syme implementation of Declare to demonstrate its feasibility [Sym97], however it has not since been maintained.
Reference: [KM96] <author> Matt Kaufmann and J Strother Moore. ACL2: </author> <title> An industrial strength version of nqthm. </title> <booktitle> In Compass'96: Eleventh Annual Conference on Computer Assurance, </booktitle> <pages> page 23, </pages> <address> Gaithersburg, Maryland, </address> <year> 1996. </year> <institution> National Institute of Standards and Technology. </institution>
Reference-contexts: This is an implementation of a rich higher order logic, including predicate subtypes, and is notable for its excellent interactive environment, powerful integrated decision procedures and pragmatic approach to integrating model checking. It has not been widely applied to operational semantics. * ACL2 <ref> [KM96] </ref>. ACL2 implements an integrated collection of rules for defining 6 Don Syme (or axiomatizing) recursive functions, stating properties of those functions, and rigorously establishing those properties.
Reference: [NL95] <author> William Newman and Mik Lamming. </author> <title> Interactive Systems Design. </title> <publisher> Addison-Wesley, </publisher> <month> December </month> <year> 1995. </year>
Reference-contexts: There are, of course, other issues involved in overall usability, e.g. the magnitude of the learning task, the user's retention of learned skills, and the user's satisfaction with the system (see Chapter 1 of <ref> [NL95] </ref> for an excellent informal description). For now we restrict ourselves to the above metric. Note that we measure mechanisms with respect to some task T . We do this to avoid having to measure the relative merits of completing different tasks. <p> Approximate time analysis for batch-mode Declare. See notes for Table 2. represent the outcome of a controlled experiment. They are merely indicative, and based on the author's experience. This method of analysis is adapted from the analysis techniques in Section 8 of Newman and Lamming's Interactive System Design <ref> [NL95] </ref>. The task we shall analyse is that described in the previous section: correcting an error in a justification in a proof. We have already outlined the steps required to do this in Ideclare.
Reference: [Pau90] <author> L. C. Paulson. </author> <title> Isabelle: The next 700 theorem provers. </title> <editor> In P. Odifreddi, editor, </editor> <booktitle> Logic and Computer Science, </booktitle> <pages> pages 361-385. </pages> <publisher> Academic Press, </publisher> <year> 1990. </year>
Reference-contexts: Interaction for Declarative Theorem Proving 3 To take a simple concrete example, proofs in interactive theorem provers (e.g. HOL, PVS and Isabelle <ref> [Pau90, GM93, COR + 95] </ref>) are typically sensitive to the order in which subgoals are produced by an induction utility. That is, if the N-induction utility suddenly produced the step case before the base case, then most proofs using this construct would break. <p> HOL supports a wide range of specification constructs and automated reasoning routines. Proofs are described using tactics. * Isabelle <ref> [Pau90] </ref>. This is also an LCF-style system, but is generic and may be instantiated to a number of different "object logics," including polymorphic higher order logic and set theory. Specification is succinct and a wide range of notational conventions are supported.
Reference: [PR98] <author> F. Pessaux and F. Rouaix. </author> <title> The O'Caml-Tk implementation, 1998. From the O'Caml system distribution., </title> <note> available at http://pauillac.inria.fr/caml. </note>
Reference-contexts: It will then move the textual cursor to the start of the next declaration, provided the previous declaration was accepted. 4.3. Implementation Ideclare is implemented in O'Caml-Tk <ref> [PR98] </ref> in 2000 lines of code, plus 10,000 lines shared with the batch-mode Declare implementation. Declare typically utilises 6-10 MB of memory, and Ideclare does not add significantly to this total.
Reference: [Rud92] <author> P. Rudnicki. </author> <title> An overview of the MIZAR project, </title> <note> 1992. Unpublished; available by anonymous FTP from menaik.cs.ualberta.ca as pub/Mizar/Mizar Over.tar.Z. </note>
Reference-contexts: We use "proof outline" to mean a script to be presented to a machine for checking that may require significant effort to fill in the gaps in reasoning. This builds on work done with similar languages by the Mizar group <ref> [Rud92] </ref> and Harrison [Har96]. One traditional form of proof description is "tactic" proof. <p> ACL2 implements an integrated collection of rules for defining 6 Don Syme (or axiomatizing) recursive functions, stating properties of those functions, and rigorously establishing those properties. It is notable for its use of decision procedures, its pioneering use of rewriting, its underlying computational model and induction heuristics. * Mizar <ref> [Rud92] </ref>. This is a system for formalizing general mathematics, designed and used by mathematicians, and a phenomenal amount of the mathematical corpus has been covered. The foundation is set theory, which pervades the system, and proofs are expressed as detailed proof outlines, leaving the machine to fill in the gaps.
Reference: [Sta95] <author> Richard Stallman. </author> <title> GNU Emacs manual. Free Software Foundation, </title> <address> 675 Mass Ave, Cambridge, MA 02139, USA, Tel: (617) 876-3296, USA, </address> <note> 11th, Emacs version 19.29 edition, June 1995. Includes GNU Emacs reference card. </note>
Reference-contexts: That is, Ideclare is not a structure editor, and the cursor of the text editor is not the same as the the logical cursor. Like many Emacs based environments <ref> [Sta95] </ref>, Ideclare does have some understanding of the syntactic structure of a Declare article | for example, it can syntactically detect the textual bounds on the next declaration when executing a "Declare" step.
Reference: [Sym95] <author> D. Syme. </author> <title> A new interface for HOL | ideas, </title> <booktitle> issues and implementation. Lecture Notes in Computer Science, </booktitle> <address> 971:324-??, </address> <year> 1995. </year>
Reference-contexts: Thus, in Ideclare, essentially the same apparatus can be used for displaying the environment inside a proof. Other theorem provers implement visualisation environments similar to Ide-clare's, e.g. PVS [COR + 95] has theory browsing windows, and TkHol <ref> [Sym95] </ref>, the author's interface for the HOL theorem prover, displayed a hierarchy of theories and the theorems and definitions contained in each. <p> Ideclare provides a substantially more compact representation of data via its collapsible/expandable nodes, though clearly it is "just a matter of programming" to achieve in other systems once the data is available. In TkHol <ref> [Sym95] </ref> the theory visualisation apparatus could only be used at the "toplevel," and a separate apparatus was required when debugging proofs. 5 Not all details are displayed in the current implementation, though it is a straightforward programming task to complete them. 6 We have not discussed pragma tags in this article, <p> This is precisely because a declarative description of a proof step tells us "what" is proved, and not "how." Interactive logical navigation and debugging for tactic proofs was first developed in TkHol <ref> [Sym95] </ref>, the author's interface for the HOL theorem prover, where it was possible to interactively move through the THEN/THENL structure of a HOL proof. <p> Multiple Active Logical Cursors The current system allows only one active logical cursor. Experience with TkHol <ref> [Sym95] </ref> indicates that multiple active proofs are sometimes useful, because the user spends less time switching between related proofs such as lemmas and main theorems. <p> Multiple edit buffers reduce the time taken to perform all sorts of editing tasks, as is clear from current IDEs. 6.3. Computer Aided Proof Writing One possible feature we could integrate with Ideclare is a degree of computer aided proof writing (CAPW) <ref> [Sym95] </ref>. CAPW supports the process of constructing a proof document by getting the computer to actually write parts of the document for you. <p> The computer cannot sensibly layout the cases of an induction without knowing the logical environment at the point of interest. Some instances of CAPW have been implemented in CHOL and TkHOL <ref> [The92, Sym95] </ref>, where fragments of tactic scripts are produced by interaction in a structure editor. Simplifying the generated language greatly improves the quality of the results of CAPW. 7.
Reference: [Sym97] <author> Don Syme. DECLARE: </author> <title> A prototype declarative proof system for higher order logic. </title> <type> Technical Report 416, </type> <institution> University of Cambridge Computer Laboratory, </institution> <address> Cam-bridge, CB2 3QG, U.K., </address> <month> March </month> <year> 1997. </year>
Reference-contexts: A trial version of the induction CAPW mechanism was implemented in an early 22 Don Syme implementation of Declare to demonstrate its feasibility <ref> [Sym97] </ref>, however it has not since been maintained. A future challenge is to generalise and simplify the range of CAPW features that may be provided in such a system.
Reference: [Sym98] <author> Don Syme. </author> <title> Declarative Proof for Operational Semantics. </title> <type> PhD thesis, </type> <institution> The Computer Laboratory, University of Cambridge, </institution> <year> 1998. </year> <note> Submitted for examination; available from www.cl.cam.ac.uk/users/drs1004. </note>
Reference-contexts: 1. Introduction This article analyses issues related to interactive support for a style of mechanized specification and proof called declarative theorem proving. 1 The author's dissertation <ref> [Sym98] </ref> describes a particular variant of declarative theorem proving and discusses its impact on interactive theorem proving systems. <p> Correspondence and offprint requests to: dsyme@microsoft.com or Don Syme, Microsoft Re search Limited, St. George House, 1 Guildhall Street, Cambridge, CB2 3NH, UK 2 Don Syme A range of the declarative techniques described in <ref> [Sym98] </ref> have been implemented as the theorem prover Declare, and the IDE for this system is called Ideclare. We descrbe these systems in some detail, and assess the latter via an informal task analysis. <p> These issues are discussed further in <ref> [Sym98] </ref>. 2. Declarative Theorem Proving and DECLARE In this section we describe what we mean by declarative theorem proving and a declarative proof language. <p> In this work, however, we shall not give in to such temptations! 2.2. Principles of Declarative Proof We now proceed to summarize some of the defining features of declarative proof languages. For a description of other issues relating to declarative theorem proving, such as declarative specification, see <ref> [Sym98] </ref>. We use "proof outline" to mean a script to be presented to a machine for checking that may require significant effort to fill in the gaps in reasoning. This builds on work done with similar languages by the Mizar group [Rud92] and Harrison [Har96]. <p> The user manages the logical context by naming facts and goals, and specifying meaningful names for local constants. This allows coherent reasoning within a complicated logical context. The particular proof language described in <ref> [Sym98] </ref> separates proof outlining from automated reasoning. These are separate activities so that the proof outline does not invoke complicated routines such as simplification, except to discharge obligations. The link between the two is provided by justifications. <p> We omit some aspects of Declare, such as the pragmas that give additional hints to the automated reasoning engine | see <ref> [Sym98] </ref> for full details. <p> See <ref> [Sym98] </ref> for more details. 7 Again, we have not discussed Declare's module system in detail, though in essence it is a simple namespace mechanism with an instantiation capability. Interaction for Declarative Theorem Proving 17 4.2.
Reference: [The92] <author> Laurent Thery. </author> <title> Real theorem provers deserve real interfaces. </title> <booktitle> In Software Engineering Notes, </booktitle> <volume> volume 17. </volume> <publisher> ACM Press, </publisher> <year> 1992. </year>
Reference-contexts: The computer cannot sensibly layout the cases of an induction without knowing the logical environment at the point of interest. Some instances of CAPW have been implemented in CHOL and TkHOL <ref> [The92, Sym95] </ref>, where fragments of tactic scripts are produced by interaction in a structure editor. Simplifying the generated language greatly improves the quality of the results of CAPW. 7.
References-found: 18

