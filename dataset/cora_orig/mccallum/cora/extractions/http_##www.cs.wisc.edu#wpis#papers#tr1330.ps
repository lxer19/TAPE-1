URL: http://www.cs.wisc.edu/wpis/papers/tr1330.ps
Refering-URL: http://www.cs.wisc.edu/wpis/papers/
Root-URL: 
Title: Interconvertibility of Set Constraints and Context-Free Language Reachability  
Author: David Melski Thomas Reps Melski Thomas Reps 
Address: 1210 W. Dayton St. 1210 W. Dayton St. Madison, WI 53706 Madison, WI 53706  
Affiliation: Computer Sciences Department Computer Sciences Department University of Wisconsin University of Wisconsin  
Note: David  
Email: melski@cs.wisc.edu  reps@cs.wisc.edu  
Phone: 608/262-0016 608/262-2091  608/262-9777 (fax)  
Date: November 18, 1996  
Abstract: We show the interconvertibility of context-free-language reachability problems and a class of set-constraint problems: given a context-free-language reachability problem, we show how to construct a set-constraint problem whose answer gives a solution to the reachability problem; given a set-constraint problem, we show how to construct a context-free-language reachability problem whose answer gives a solution to the set-constraint problem. The interconvertibility of these two formalisms offers an conceptual advantage akin to the advantage gained from the interconvertibility of finite-state automata and regular expressions in language theory, namely, a problem can be formulated in whichever formalism is most natural. It also offers some insight into the "O(n 3 ) bottleneck" for different types of program-analysis problems, and allows results previously obtained for context-free-language reachability problems to be applied to set constraint problems.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Das and T. Reps. </author> <title> BTA termination using CFL-reachability. </title> <type> Technical Report 1329, </type> <institution> Computer Sciences Department, University of Wisconsin-Madison, </institution> <month> November </month> <year> 1996. </year>
Reference-contexts: Context-free-language reachability (CFL-reachability) is a generalization of ordinary graph reachability (i.e., transitive closure). It has been used for a number of program-analysis applications, including interproce-dural slicing [7, 9], interprocedural dataflow analysis [8], shape analysis [12], and binding-time analysis for partial evaluation <ref> [1] </ref>. Set constraints are used for program analysis by using them to collect (a superset of) the set of values that the program's variables may hold during execution. Typically, a set variable is created for each program variable at each program point.
Reference: [2] <author> M. J. Fischer and A. R. Meyer. </author> <title> Boolean matrix multiplication and transitive closure. </title> <booktitle> In Conference Recordings of the IEEE 12th Symposium on Switching and Automata Theory, </booktitle> <year> 1971. </year>
Reference-contexts: However, because transitive closure can be performed in sub-cubic time <ref> [2] </ref>, this is not the correct explanation. We have long believed that the real source of the O (n 3 ) bottleneck is that a CFL-reachability problem needs to be solved.
Reference: [3] <author> Ferenc Gecseg and Magnus Steinby. </author> <title> Tree Automata. </title> <publisher> Akademiai Kiado, </publisher> <year> 1984. </year>
Reference-contexts: Heintze formalizes this idea in [4]. The solution to a collection of set constraints can be written as a regular term grammar <ref> [3] </ref>, which is a formalism that allows certain infinite sets of terms to be represented in a finite manner. There are standard algorithms for dealing with regular term grammars (e.g., for determining membership)[3]. 5 A regular term grammar consists of a finite, non-empty set of non-terminals, a set of function symbols,
Reference: [4] <author> N. Heintze. </author> <title> Set-based program analysis. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: Typically, a set variable is created for each program variable at each program point. Set constraints are then generated that approximate the program's behavior. Program analysis then becomes a problem of finding the least solution of the set-constraint problem <ref> [4] </ref>. The principal contribution of this paper is to relate these two techniques: * We give a construction for converting a CFL-reachability problem into a set-constraint problem. <p> Set-constraints lead to natural formulations of shape-analysis <ref> [4] </ref>. <p> be solved in time O (n 3 ) (where the constant of proportionality is cubic in jj). 4 2.2 Set Constraints In this section, we define the class of set constraints considered in this paper. (The material in this section is a summary of work done by Heintze and Jaffar <ref> [4, 5, 6] </ref>.) 2.2.1 Set Expressions and Set Constraints In the class of set constraints we deal with, a set expression is either a set variable (denoted by V , W , X, etc.) or has one of the following forms: * c (V 1 ; : : : ; V <p> Heintze formalizes this idea in <ref> [4] </ref>. The solution to a collection of set constraints can be written as a regular term grammar [3], which is a formalism that allows certain infinite sets of terms to be represented in a finite manner. <p> Such constraints are said to be in explicit form <ref> [4] </ref>: A constraint is in explicit form if it is of the form V c (V 1 ; : : : ; V r ). A collection of constraints in explicit form is converted to a term grammar by taking the variables to be non-terminals and converting each into ). <p> When C reaches a fixed point, the constraints in explicit form are converted to a regular term grammar; this describes the least solution <ref> [4] </ref>. 2 The SC-Reduction Algorithm never generates new atomic expressions; this means that when the algorithm finishes, for a fixed variable Y , the number of constraints of the form Y c (V a 1 ; V a 2 ; : : : ; V a r ) in C is
Reference: [5] <author> Nevin Heintze. </author> <title> Set based analyis of ML programs. </title> <type> Technical Report CMU-CS-93-193, </type> <institution> Carnegie Mellon University, </institution> <year> 1993. </year>
Reference-contexts: be solved in time O (n 3 ) (where the constant of proportionality is cubic in jj). 4 2.2 Set Constraints In this section, we define the class of set constraints considered in this paper. (The material in this section is a summary of work done by Heintze and Jaffar <ref> [4, 5, 6] </ref>.) 2.2.1 Set Expressions and Set Constraints In the class of set constraints we deal with, a set expression is either a set variable (denoted by V , W , X, etc.) or has one of the following forms: * c (V 1 ; : : : ; V <p> the worst case proportional to t, the total running time of the algorithm is bounded by O (t 3 ). 5 Concluding Remarks The techniques described in this paper can be extended to apply to the class of set constraints used by Heintze to do set-based analysis of ML programs <ref> [5] </ref>. This class of set constraints is effectively a superset of the class of set constraints used in this paper. In particular, Heintze extends the set constraints to handle -terms and function applications.
Reference: [6] <author> Nevin Heintze and Joxan Jaffar. </author> <title> A decision procedure for a class of set constraints. </title> <type> Technical Report CMU-CS-91-110, </type> <institution> Carnegie Mellon University, </institution> <year> 1991. </year>
Reference-contexts: be solved in time O (n 3 ) (where the constant of proportionality is cubic in jj). 4 2.2 Set Constraints In this section, we define the class of set constraints considered in this paper. (The material in this section is a summary of work done by Heintze and Jaffar <ref> [4, 5, 6] </ref>.) 2.2.1 Set Expressions and Set Constraints In the class of set constraints we deal with, a set expression is either a set variable (denoted by V , W , X, etc.) or has one of the following forms: * c (V 1 ; : : : ; V
Reference: [7] <author> S. Horwitz, T. Reps, and D. Binkley. </author> <title> Interprocedural slicing using dependence graphs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(1) </volume> <pages> 26-60, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: 1 Introduction This paper concerns algorithms for converting between two techniques for formalizing program-analysis problems: context-free-language reachability and a class of set constraints. Context-free-language reachability (CFL-reachability) is a generalization of ordinary graph reachability (i.e., transitive closure). It has been used for a number of program-analysis applications, including interproce-dural slicing <ref> [7, 9] </ref>, interprocedural dataflow analysis [8], shape analysis [12], and binding-time analysis for partial evaluation [1]. Set constraints are used for program analysis by using them to collect (a superset of) the set of values that the program's variables may hold during execution. <p> think and reason in terms of whichever paradigm is most appropriate. (This is analogous to the situation one has in language theory with finite-state automata and regular expressions, or with pushdown automata and context-free grammars.) For example, CFL-reachability leads to natural formulations of interprocedural dataflow analysis [9] and interprocedural slicing <ref> [11, 7] </ref>. Set-constraints lead to natural formulations of shape-analysis [4].
Reference: [8] <author> S. Horwitz, T. Reps, and M. Sagiv. </author> <title> Demand interprocedural dataflow analysis. </title> <booktitle> In Proceedings of the Third ACM SIGSOFT Symposium on the Foundations of Software 21 Table 4: 22 Engineering, </booktitle> <pages> pages 104-115, </pages> <month> October </month> <year> 1995. </year> <note> (Available on the WWW from URL http://www.cs.wisc.edu/wpis/papers/fse95.ps). </note>
Reference-contexts: Context-free-language reachability (CFL-reachability) is a generalization of ordinary graph reachability (i.e., transitive closure). It has been used for a number of program-analysis applications, including interproce-dural slicing [7, 9], interprocedural dataflow analysis <ref> [8] </ref>, shape analysis [12], and binding-time analysis for partial evaluation [1]. Set constraints are used for program analysis by using them to collect (a superset of) the set of values that the program's variables may hold during execution.
Reference: [9] <author> S. Horwitz, T. Reps, M. Sagiv, and G. Rosay. </author> <title> Speeding up slicing. </title> <booktitle> In Proceedings of the Third ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 11-20, </pages> <note> Decem-ber 1994. (Available on the WWW from URL http://www.cs.wisc.edu/wpis/papers/fse94.ps). </note>
Reference-contexts: 1 Introduction This paper concerns algorithms for converting between two techniques for formalizing program-analysis problems: context-free-language reachability and a class of set constraints. Context-free-language reachability (CFL-reachability) is a generalization of ordinary graph reachability (i.e., transitive closure). It has been used for a number of program-analysis applications, including interproce-dural slicing <ref> [7, 9] </ref>, interprocedural dataflow analysis [8], shape analysis [12], and binding-time analysis for partial evaluation [1]. Set constraints are used for program analysis by using them to collect (a superset of) the set of values that the program's variables may hold during execution. <p> program-analysis problem, one can think and reason in terms of whichever paradigm is most appropriate. (This is analogous to the situation one has in language theory with finite-state automata and regular expressions, or with pushdown automata and context-free grammars.) For example, CFL-reachability leads to natural formulations of interprocedural dataflow analysis <ref> [9] </ref> and interprocedural slicing [11, 7]. Set-constraints lead to natural formulations of shape-analysis [4].
Reference: [10] <author> T. Reps. </author> <title> Demand interprocedural program analysis using logic databases. </title> <editor> In R. Ramakrishnan, editor, </editor> <booktitle> Applications of Logic Databases. </booktitle> <publisher> Kluwer Academic Publishers, </publisher> <year> 1994. </year>
Reference-contexts: In fact, the CFL-reachability Algorithm presented here in effect emulates semi-naive bottom-up evaluation of the equivalent DATALOG program. This suggests that the class of DATALOG programs that run in cubic time may be useful for program analysis (see also <ref> [10] </ref>). Many parts of a constructed CFL-reachability problem are more easily expressed in a DATA-LOG program. In particular, the addition of reverse edges, and the tracking of ground information is easy to express. The program would not necessarily be a chain program, but it would still run in cubic time.
Reference: [11] <author> T. Reps, S. Horwitz, and M. Sagiv. </author> <title> Precise interprocedural dataflow analysis via graph reach-ability. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 49-61, </pages> <year> 1995. </year> <note> (Available on the WWW from URL http://www.cs.wisc.edu/wpis/papers/popl95.ps). </note>
Reference-contexts: think and reason in terms of whichever paradigm is most appropriate. (This is analogous to the situation one has in language theory with finite-state automata and regular expressions, or with pushdown automata and context-free grammars.) For example, CFL-reachability leads to natural formulations of interprocedural dataflow analysis [9] and interprocedural slicing <ref> [11, 7] </ref>. Set-constraints lead to natural formulations of shape-analysis [4].
Reference: [12] <author> Thomas Reps. </author> <title> Shape analysis as a generalized path problem. </title> <booktitle> In PEPM '95: Proceedings of the ACM SIGPLAN Symposium on Partial Evaluatoin and Semantics-Based Program Manipulation, </booktitle> <address> New York, NY, 1995. </address> <publisher> ACM. </publisher>
Reference-contexts: Context-free-language reachability (CFL-reachability) is a generalization of ordinary graph reachability (i.e., transitive closure). It has been used for a number of program-analysis applications, including interproce-dural slicing [7, 9], interprocedural dataflow analysis [8], shape analysis <ref> [12] </ref>, and binding-time analysis for partial evaluation [1]. Set constraints are used for program analysis by using them to collect (a superset of) the set of values that the program's variables may hold during execution. Typically, a set variable is created for each program variable at each program point. <p> The basic technique is a modification of work done by Reps in using CFL-reachability to do shape analysis <ref> [12] </ref>. In essence, our encoding involves simulating the steps of the SC-Reduction Algorithm with the productions of a reachability problem.
Reference: [13] <author> Thomas Reps. </author> <title> On the sequential nature of interprocedural program-analysis problems. </title> <journal> Acta Inf., </journal> <note> To appear. </note>
Reference: [14] <author> Mihalis Yannakakis. </author> <title> Graph-theoretic methods in database theory. </title> <booktitle> In Proceedings of the Symposium on Principles of Database Systems, </booktitle> <pages> pages 230-242, </pages> <year> 1990. </year> <month> 23 </month>
Reference-contexts: The techniques might also be used to do slicing of higher-order functional languages. It is also interesting to note an old result about CFL-reachability: every CFL-reachability problem can be stated as a chain program in DATALOG <ref> [14] </ref>; edges are represented as facts, and productions are encoded as Horn clauses. In fact, the CFL-reachability Algorithm presented here in effect emulates semi-naive bottom-up evaluation of the equivalent DATALOG program.
References-found: 14

