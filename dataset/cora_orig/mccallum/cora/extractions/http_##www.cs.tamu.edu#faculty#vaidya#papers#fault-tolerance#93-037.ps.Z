URL: http://www.cs.tamu.edu/faculty/vaidya/papers/fault-tolerance/93-037.ps.Z
Refering-URL: http://www.cs.tamu.edu/faculty/vaidya/Vaidya-ftc.html
Root-URL: http://www.cs.tamu.edu
Email: E-mail: vaidya@cs.tamu.edu  
Phone: Phone: 409-845-0512  
Title: Degradable Agreement with Hybrid Faults (An Algorithm and Reliability-Safety Analysis)  
Author: Nitin H. Vaidya 
Date: August 1993  
Address: College Station, TX 77843-3112  
Affiliation: Department of Computer Science Texas A&M University  
Pubnum: Technical Report 93-037  
Abstract: Achieving traditional Byzantine agreement in the presence of arbitrary faults requires that the total number of nodes be larger than three times the number of faulty nodes. Two approaches have been proposed in the literature to circumvent this requirement: (i) hybrid fault model approach [4, 7] considers three types of faults of varying degree of severity, and (ii) degradable agreement approach [10, 11] relaxes the definition of agreement in the presence of excessive faults. This report combines the above two approaches and presents a degradable agreement algorithm for the hybrid fault model. The report defines and evaluates reliability and safety measures for the proposed degradable agreement algorithm and concludes that degradable agreement can be used to trade reliability with safety. It is shown that the hybrid fault model results in better algorithms (with respect to reliability and/or safety) only when the probability of arbitrary faults is not very small. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Dolev, </author> <title> "The Byzantine generals strike again," </title> <journal> J. </journal> <volume> Algo., </volume> <pages> pp. 14-30, </pages> <year> 1982. </year>
Reference-contexts: 1 Introduction Consider a system consisting of a sender that wants to send a value to certain receivers. Various agreement algorithms have been proposed for this purpose (e.g <ref> [1, 2, 3] </ref>). that tolerate arbitrary (possibly malicious) failures. The requirement is typically that the fault-free receivers must all agree on the same value [2, 3]. Dolev [1] analyzes a weaker form of agreement. <p> Various agreement algorithms have been proposed for this purpose (e.g [1, 2, 3]). that tolerate arbitrary (possibly malicious) failures. The requirement is typically that the fault-free receivers must all agree on the same value [2, 3]. Dolev <ref> [1] </ref> analyzes a weaker form of agreement. Prior work has shown that such agreements are impossible if a third of the nodes (or more) are faulty. In other words, the number of nodes in the system must be larger than three times the number of faulty nodes.
Reference: [2] <author> L. Lamport, </author> <title> "The weak Byzantine generals problem," </title> <journal> J. ACM, </journal> <volume> vol. 30, </volume> <pages> pp. 668-676, </pages> <month> July </month> <year> 1983. </year>
Reference-contexts: 1 Introduction Consider a system consisting of a sender that wants to send a value to certain receivers. Various agreement algorithms have been proposed for this purpose (e.g <ref> [1, 2, 3] </ref>). that tolerate arbitrary (possibly malicious) failures. The requirement is typically that the fault-free receivers must all agree on the same value [2, 3]. Dolev [1] analyzes a weaker form of agreement. <p> Various agreement algorithms have been proposed for this purpose (e.g [1, 2, 3]). that tolerate arbitrary (possibly malicious) failures. The requirement is typically that the fault-free receivers must all agree on the same value <ref> [2, 3] </ref>. Dolev [1] analyzes a weaker form of agreement. Prior work has shown that such agreements are impossible if a third of the nodes (or more) are faulty. In other words, the number of nodes in the system must be larger than three times the number of faulty nodes.
Reference: [3] <author> L. Lamport, R. Shostak, and M. Pease, </author> <title> "The Byzantine generals problem," </title> <journal> ACM Trans. Prog. Lang. Syst., </journal> <volume> vol. 4, </volume> <pages> pp. 382-401, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: 1 Introduction Consider a system consisting of a sender that wants to send a value to certain receivers. Various agreement algorithms have been proposed for this purpose (e.g <ref> [1, 2, 3] </ref>). that tolerate arbitrary (possibly malicious) failures. The requirement is typically that the fault-free receivers must all agree on the same value [2, 3]. Dolev [1] analyzes a weaker form of agreement. <p> Various agreement algorithms have been proposed for this purpose (e.g [1, 2, 3]). that tolerate arbitrary (possibly malicious) failures. The requirement is typically that the fault-free receivers must all agree on the same value <ref> [2, 3] </ref>. Dolev [1] analyzes a weaker form of agreement. Prior work has shown that such agreements are impossible if a third of the nodes (or more) are faulty. In other words, the number of nodes in the system must be larger than three times the number of faulty nodes. <p> We will use the hybrid fault model [4] that divides faults into three classes: arbitrary, symmetric and manifest (elaborated later). * We recently presented the degradable agreement [11] approach for Byzantine faults. The degradable agreement protocol achieves traditional Byzantine agreement 1 <ref> [3] </ref> (hereafter referred to as Lamport's Byzantine agreement) up to a certain number of Byzan-tine faults and a degraded form of agreement with a higher number of faults. <p> By weakening the definition of agreement when excessive faults exist, our approach can tolerate more than a third of the nodes being faulty. 1 Although Byzantine agreement was defined by Lamport, Shostak and Pease <ref> [3] </ref>, for brevity we refer to it as Lamport's Byzantine agreement. 2 Default value, denoted V d , is distinguishable from all other values. 1 This report presents an agreement protocol that combines the above two approaches. <p> Both symmetric and arbitrary faults can produce values that are not detectably bad. However, a symmetric fault delivers identical value to all recipients, whereas, an arbitrary fault behavior is unconstrained (e.g. may deliver different wrong values to different recipients). Thus, an arbitrary fault is equivalent to a Byzantine fault <ref> [3] </ref>. A value sent by a manifest-faulty node can always be detected to be erroneous by the recipient. Therefore, it is assumed that a manifest-faulty node always sends a value denoted by E; E is a value distinguishable from all other values including default value V d . <p> The fault-free receivers in one class must agree on the default value, and the fault-free receivers in the other class must all agree on an identical value. Conditions D.1 and D.2 are identical to those satisfied by Lamport's Byzantine agreement <ref> [3] </ref>. Conditions D.3 and D.4 define degraded agreement. Observe that conditions D.3 and D.4 are strictly weaker than D.1 and D.2, respectively, i.e., satisfying D.1 (D.2) is sufficient to satisfy D.3 (D.4) but not vice-versa.
Reference: [4] <author> P. Lincoln and J. Rushby, </author> <title> "A formally verified algorithm for interactive consistency under a hybrid fault model," </title> <booktitle> in Digest of papers: The 23 rd Int. Symp. Fault-Tolerant Comp., </booktitle> <pages> pp. 402-411, </pages> <year> 1993. </year>
Reference-contexts: In other words, the number of nodes in the system must be larger than three times the number of faulty nodes. Two very different approaches have been presented to circumvent this requirement. These approaches either weaken the fault model or weaken the definition of agreement. * Various researchers <ref> [4, 5, 7] </ref> have presented agreement protocols that tolerate a mix of Byzantine failures and other less severe types of failures. As all the faults in the system are not necessarily Byzantine, these protocols are often able to tolerate more than a third of the nodes being faulty. <p> As all the faults in the system are not necessarily Byzantine, these protocols are often able to tolerate more than a third of the nodes being faulty. We will use the hybrid fault model <ref> [4] </ref> that divides faults into three classes: arbitrary, symmetric and manifest (elaborated later). * We recently presented the degradable agreement [11] approach for Byzantine faults. <p> Specifically, we present a degradable agreement algorithm for the hybrid fault model presented in <ref> [4] </ref>. Also, we define safety and reliability measures and show that the proposed algorithm effectively trades reliability with safety. This report is organized as follows. Section 2 presents the hybrid fault model and Section 3 defines degradable agreement. <p> Section 5 evaluates reliability and safety measures for the proposed algorithm, and also shows that the hybrid fault model is useful only when arbitrary faults occur with non-negligible probability. Conclusions are presented in Section 6. 2 Hybrid Fault Model In the hybrid fault model <ref> [4, 7] </ref>, the faults are divided into three classes (in order of increasing severity): manifest faults, symmetric faults and arbitrary faults. A manifest fault is one that produces detectably missing values or values that can be detected as bad by all non-faulty recipients [4]. <p> A manifest fault is one that produces detectably missing values or values that can be detected as bad by all non-faulty recipients <ref> [4] </ref>. Both symmetric and arbitrary faults can produce values that are not detectably bad. However, a symmetric fault delivers identical value to all recipients, whereas, an arbitrary fault behavior is unconstrained (e.g. may deliver different wrong values to different recipients). <p> As noted earlier, V d denotes the default value, which is distinguishable from all other relevant values. Degradable Agreement with Hybrid Faults: The degradable agreement algorithm presented in this report satisfies the following two conditions. Note that the algorithm presented by Lincoln and Rushby <ref> [4] </ref> only satisfies a condition similar to first of the two conditions. * if N &gt; 2 (a + s) + c + u and a m, then D.1 and D.2 stated below are satisfied. * if N &gt; a + 2m + 2s + c and a u, then D.3 <p> Observe that conditions D.3 and D.4 are strictly weaker than D.1 and D.2, respectively, i.e., satisfying D.1 (D.2) is sufficient to satisfy D.3 (D.4) but not vice-versa. Note that when m = u, condition 1 above is equivalent to that satisfied by the algorithm in <ref> [7, 4] </ref>. <p> The algorithm presented here uses two functions R and U nR, called the wrapper and unwrapper functions, respectively <ref> [4] </ref>. <p> Lincoln and Rushby <ref> [4] </ref> suggest a simple implementation of R and U nR using bounded integers. 3 A similar implementation can be used here. Algorithm HBYZ presented below may be viewed as a combination of the algorithms in [4] and [11]. HBYZ assumes that the nodes are fully connected. <p> Lincoln and Rushby <ref> [4] </ref> suggest a simple implementation of R and U nR using bounded integers. 3 A similar implementation can be used here. Algorithm HBYZ presented below may be viewed as a combination of the algorithms in [4] and [11]. HBYZ assumes that the nodes are fully connected. <p> Below we present numerical results, for = 0:001, which indicate that degradable agreement results in poorer reliability and safety when a (or probability of arbitrary failure) is too small. The next subsection presents numerical results to show that similar reliability degradation occurs for the algorithm presented in <ref> [4] </ref>. 11 = 0:001 a = :001 s = :019 c = 0:98 t = 10 n m u 1reliability 1safety 6 1 1 3.583387e08 3.583387e08 Note that when u is increased, both (1reliability) and (1safety) increase, implying that both reliability and safety decrease. <p> We claim that the hybrid fault model itself is useful only when a is not very small. To justify this claim we compare reliability of the Byzantine agreement algorithm OMH for hybrid faults presented in <ref> [4, 7] </ref> with the reliability of the agreement algorithm (named X) that tolerates only symmetric and manifest faults. <p> This implies that, if reliability is the only parameter of interest, with low values of a , it is beneficial to ignore the arbitrary-faults altogether. In other words, the hybrid fault model in <ref> [4, 7] </ref> is not necessarily appropriate. While this observation applies to both algorithm OMH as well as HBYZ, there is a quantitative difference: there exist (small) values of a for which algorithm OMH achieves higher reliability than algorithm X, but algorithm HBYZ may not yield a good trade-off. <p> Numerical results are presented for various parameter values to support this conclusion. It is shown that, it does not pay to design algorithms for that tolerate arbitrary-faults, 13 unless the probability of such faults is non-negligible. In other words, the hybrid fault model <ref> [4, 7] </ref> is effective only when arbitrary-faults are sufficiently likely to occur. Specifically, we show that (i) the reliability-safety trade-off achieved by HBYZ is effective only for non-negligible values of a , and (ii) reliability achieved by the Byzantine agreement algorithms previously proposed for the hybrid fault model [4, 7] is <p> fault model <ref> [4, 7] </ref> is effective only when arbitrary-faults are sufficiently likely to occur. Specifically, we show that (i) the reliability-safety trade-off achieved by HBYZ is effective only for non-negligible values of a , and (ii) reliability achieved by the Byzantine agreement algorithms previously proposed for the hybrid fault model [4, 7] is worse than an algorithm that ignores arbitrary-faults, when the probability of arbitrary-faults is small. A Proof of Correctness: Algorithm HBYZ The proof presented here parallels the proof presented in [11], however, proofs of some of the lemmas below are more complicated than those in [11].
Reference: [5] <author> F. J. Meyer and D. K. Pradhan, </author> <title> "Consensus with dual failure modes," </title> <journal> IEEE Trans. Par. Distr. Syst., </journal> <volume> vol. 2, </volume> <pages> pp. 214-222, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: In other words, the number of nodes in the system must be larger than three times the number of faulty nodes. Two very different approaches have been presented to circumvent this requirement. These approaches either weaken the fault model or weaken the definition of agreement. * Various researchers <ref> [4, 5, 7] </ref> have presented agreement protocols that tolerate a mix of Byzantine failures and other less severe types of failures. As all the faults in the system are not necessarily Byzantine, these protocols are often able to tolerate more than a third of the nodes being faulty.
Reference: [6] <author> K. Rothermel, </author> <title> "An open commit protocol preserving consistency in the presence of commission failures," </title> <booktitle> in International Conf. Distributed Computing Systems, </booktitle> <pages> pp. 168-177, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: In fact, as seen later, it may not be worthwhile using even the Byzantine agreement algorithm. Although the likelihood of arbitrary hardware failures may be small in practice, arbitrary-failure model is of interest in open distributed systems (ODS) <ref> [6] </ref>. An ODS consists of trusted as well as non-trusted nodes. The non-trusted nodes may demonstrate arbitrary behavior, possibly in the hands of a malicious user. The degradable agreement algorithm would be suitable in such environments. To evaluate degradable agreement, we define two parameters: reliability and safety.
Reference: [7] <author> P. Thambidurai and Y.-K. Park, </author> <title> "Interactive consistency with multiple failure modes," </title> <booktitle> in 7th Symposium on Reliable Distributed Systems, </booktitle> <pages> pp. 93-100, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: In other words, the number of nodes in the system must be larger than three times the number of faulty nodes. Two very different approaches have been presented to circumvent this requirement. These approaches either weaken the fault model or weaken the definition of agreement. * Various researchers <ref> [4, 5, 7] </ref> have presented agreement protocols that tolerate a mix of Byzantine failures and other less severe types of failures. As all the faults in the system are not necessarily Byzantine, these protocols are often able to tolerate more than a third of the nodes being faulty. <p> Section 5 evaluates reliability and safety measures for the proposed algorithm, and also shows that the hybrid fault model is useful only when arbitrary faults occur with non-negligible probability. Conclusions are presented in Section 6. 2 Hybrid Fault Model In the hybrid fault model <ref> [4, 7] </ref>, the faults are divided into three classes (in order of increasing severity): manifest faults, symmetric faults and arbitrary faults. A manifest fault is one that produces detectably missing values or values that can be detected as bad by all non-faulty recipients [4]. <p> Observe that conditions D.3 and D.4 are strictly weaker than D.1 and D.2, respectively, i.e., satisfying D.1 (D.2) is sufficient to satisfy D.3 (D.4) but not vice-versa. Note that when m = u, condition 1 above is equivalent to that satisfied by the algorithm in <ref> [7, 4] </ref>. <p> We claim that the hybrid fault model itself is useful only when a is not very small. To justify this claim we compare reliability of the Byzantine agreement algorithm OMH for hybrid faults presented in <ref> [4, 7] </ref> with the reliability of the agreement algorithm (named X) that tolerates only symmetric and manifest faults. <p> This implies that, if reliability is the only parameter of interest, with low values of a , it is beneficial to ignore the arbitrary-faults altogether. In other words, the hybrid fault model in <ref> [4, 7] </ref> is not necessarily appropriate. While this observation applies to both algorithm OMH as well as HBYZ, there is a quantitative difference: there exist (small) values of a for which algorithm OMH achieves higher reliability than algorithm X, but algorithm HBYZ may not yield a good trade-off. <p> Numerical results are presented for various parameter values to support this conclusion. It is shown that, it does not pay to design algorithms for that tolerate arbitrary-faults, 13 unless the probability of such faults is non-negligible. In other words, the hybrid fault model <ref> [4, 7] </ref> is effective only when arbitrary-faults are sufficiently likely to occur. Specifically, we show that (i) the reliability-safety trade-off achieved by HBYZ is effective only for non-negligible values of a , and (ii) reliability achieved by the Byzantine agreement algorithms previously proposed for the hybrid fault model [4, 7] is <p> fault model <ref> [4, 7] </ref> is effective only when arbitrary-faults are sufficiently likely to occur. Specifically, we show that (i) the reliability-safety trade-off achieved by HBYZ is effective only for non-negligible values of a , and (ii) reliability achieved by the Byzantine agreement algorithms previously proposed for the hybrid fault model [4, 7] is worse than an algorithm that ignores arbitrary-faults, when the probability of arbitrary-faults is small. A Proof of Correctness: Algorithm HBYZ The proof presented here parallels the proof presented in [11], however, proofs of some of the lemmas below are more complicated than those in [11].
Reference: [8] <author> P. Thambidurai, Y.-K. Park, and K. S. Trivedi, </author> <title> "On reliability modelling of fault-tolerant distributed systems," </title> <booktitle> in International Conf. Distributed Computing Systems, </booktitle> <pages> pp. 136-142, </pages> <year> 1989. </year>
Reference-contexts: Reliability is defined as the probability that the system is in a state where it can be guaranteed that conditions D.1 and D.2 can be satisfied. The state of the system is defined by the 3-tuple (a; s; c). Our definition of reliability is identical to that used in <ref> [8] </ref>. Safety is defined as the probability that the system is in a state where it can be guaranteed that conditions D.3 and D.4 can be satisfied. As noted in Section 3, conditions D.3 and D.4 are strictly weaker than D.1 and D.2. This implies that reliability safety.
Reference: [9] <author> N. H. Vaidya and D. K. Pradhan, </author> <title> "System level diagnosis: Combining detection and location," </title> <booktitle> in Digest of papers: The 21 st Int. Symp. Fault-Tolerant Comp., </booktitle> <pages> pp. 488-495, </pages> <year> 1991. </year>
Reference-contexts: In general, the trade-off is more favorable for larger values of a . Reliability-safety trade-off is fundamental to many areas of fault tolerance. For results on reliability-safety trade-off in system diagnosis and modular redundant systems, refer to <ref> [9, 13] </ref> and [12], respectively. 5.2 Small values of a In the examples presented above, increasing value of u resulted in increasing safety and decreasing reliability. Thus, reliability was traded for safety. This trend holds only of the value of a is not too small.
Reference: [10] <author> N. H. Vaidya, </author> <title> "Degradable agreement in the presence of Byzantine faults," </title> <type> Tech. Rep. 92-020, </type> <institution> Computer Science Department, Texas A&M University, College Station, </institution> <year> 1992. </year> <month> 22 </month>
Reference: [11] <author> N. H. Vaidya and D. K. Pradhan, </author> <title> "Degradable agreement in the presence of Byzantine faults," </title> <booktitle> in International Conf. Distributed Computing Systems, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: We will use the hybrid fault model [4] that divides faults into three classes: arbitrary, symmetric and manifest (elaborated later). * We recently presented the degradable agreement <ref> [11] </ref> approach for Byzantine faults. The degradable agreement protocol achieves traditional Byzantine agreement 1 [3] (hereafter referred to as Lamport's Byzantine agreement) up to a certain number of Byzan-tine faults and a degraded form of agreement with a higher number of faults. <p> Note that when m = u, condition 1 above is equivalent to that satisfied by the algorithm in [7, 4]. Also, when only arbitrary failures occur, our algorithm achieves m=u-degradable agreement, as defined in <ref> [11] </ref>. 4 Definition 1 A system is said to be a conforming system, if at least one of the following conditions hold, where m u: 1. a m and N &gt; 2 (a + s) + c + u, and 4 An Algorithm for Degradable Agreement We begin with definition of <p> Lincoln and Rushby [4] suggest a simple implementation of R and U nR using bounded integers. 3 A similar implementation can be used here. Algorithm HBYZ presented below may be viewed as a combination of the algorithms in [4] and <ref> [11] </ref>. HBYZ assumes that the nodes are fully connected. <p> Whenever a node detects a message to be absent, it assumes that the message contains value E. Detecting presence and absence of messages correctly requires that the clocks of various nodes be synchronized. This issue was discussed in <ref> [11] </ref>. We now present HBYZ (1) and HBYZ (t) (algorithm for m = 0 is omitted here). In these algorithms, the following notation is used. In HBYZ (1), n 1 is the number of nodes to which algorithm HBYZ (1) is applied. <p> A Proof of Correctness: Algorithm HBYZ The proof presented here parallels the proof presented in <ref> [11] </ref>, however, proofs of some of the lemmas below are more complicated than those in [11]. The correctness of algorithm HBYZ is being proved under assumptions (a) through (c) listed earlier in Section 4. <p> A Proof of Correctness: Algorithm HBYZ The proof presented here parallels the proof presented in <ref> [11] </ref>, however, proofs of some of the lemmas below are more complicated than those in [11]. The correctness of algorithm HBYZ is being proved under assumptions (a) through (c) listed earlier in Section 4. When a message is detected to be absent by a node, that node considers the absent message to contain value E.
Reference: [12] <author> N. H. Vaidya and D. K. Pradhan, </author> <title> "Fault-tolerant design strategies for high reliability and safety," </title> <journal> IEEE Trans. Computers, </journal> <note> accepted for publication, </note> <year> 1993. </year>
Reference-contexts: In general, the trade-off is more favorable for larger values of a . Reliability-safety trade-off is fundamental to many areas of fault tolerance. For results on reliability-safety trade-off in system diagnosis and modular redundant systems, refer to [9, 13] and <ref> [12] </ref>, respectively. 5.2 Small values of a In the examples presented above, increasing value of u resulted in increasing safety and decreasing reliability. Thus, reliability was traded for safety. This trend holds only of the value of a is not too small.
Reference: [13] <author> N. H. Vaidya and D. K. Pradhan, </author> <title> "Safe system level diagnosis," </title> <journal> IEEE Trans. Computers, </journal> <note> accepted for publication, 1993. 23 </note>
Reference-contexts: In general, the trade-off is more favorable for larger values of a . Reliability-safety trade-off is fundamental to many areas of fault tolerance. For results on reliability-safety trade-off in system diagnosis and modular redundant systems, refer to <ref> [9, 13] </ref> and [12], respectively. 5.2 Small values of a In the examples presented above, increasing value of u resulted in increasing safety and decreasing reliability. Thus, reliability was traded for safety. This trend holds only of the value of a is not too small.
References-found: 13

