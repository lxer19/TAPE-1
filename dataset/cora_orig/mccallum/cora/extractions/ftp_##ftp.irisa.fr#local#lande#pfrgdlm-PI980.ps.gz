URL: ftp://ftp.irisa.fr/local/lande/pfrgdlm-PI980.ps.gz
Refering-URL: http://www.irisa.fr/lande/fradet/Fradet.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: 980 AN INFERENCE ALGORITHM FOR THE STATIC VERIFICATION OF POINTER MANIPULATION  
Author: PASCAL FRADET, RONAN GAUGNE AND DANIEL LE M ETAYER 
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> A. Aho, R. Sethi and J. D. Ullman, </author> <booktitle> Compilers: Principles, Techniques and Tools, </booktitle> <publisher> Addison-Wesley publishing company, </publisher> <year> 1988. </year>
Reference-contexts: j) (x 7! y) ^ (&y = x) then Closure (P ^ (flx = y)) elseif P j) (x 7! y) then Closure (P ^ (flx = y)) _ Insert (P; flx; y) else Add (P; flx) The rule for while implements an iterative algorithm akin to traditional data-flow algorithms <ref> [1] </ref>. The iteration must converge because the sequence P i is strictly increasing: P i1 j) P i P i 6j) P i1 and the set of properties under consideration is finite. The rule for assignment statements is by far the most complex.
Reference: [2] <author> R. Altucher and W. Landi, </author> <title> An extended form of must-alias analysis for dynamic allocation, </title> <booktitle> in 22 nd Annual ACM Symp. on Principles of Programming Languages POPL'95, </booktitle> <month> Jan. </month> <year> 1995, </year> <month> pp.74-85. </month>
Reference-contexts: accurate may-alias information (because numerical coefficients are used to record precise positions in a structure); on the other hand, our properties include both may-alias and must-alias information which allows us to gain accuracy in certain situations (the significance of must-alias properties to get more accurate may-alias properties is stressed in <ref> [2] </ref>). This extra level of precision is required to the analysis of correctness-related properties (for instance, the example treated in Section 4 could not be analysed successfully without a form of must-alias information). * Axiomatisation of pointer and alias relations has been studied for Pascal (see e.g. [7, 8, 22]).
Reference: [3] <author> L. Andersen, </author> <title> Program analysis and specialisation for the C programming language, </title> <type> Ph.D Thesis, </type> <institution> DIKU, University of Copenhagen, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: PI n-980 4 Pascal Fradet, Ronan Gaugne and Daniel Le Metayer 2 A Hoare Logic for Pointers The syntax and semantics of the subset of C considered in this paper are provided in Fig. 11 and 12 in appendix 1. They are variations of definitions appearing in <ref> [3] </ref>. We use the exception value illegal to denote the result of a computation involving the dereference of an invalid pointer. The set of valid pointers of the store S D is D.
Reference: [4] <author> M.A. Arbib, S. Alagic, </author> <title> Proof rules for gotos, </title> <journal> Acta Informatica 11,2, pp.139-148,1979. </journal>
Reference-contexts: We therefore describe the extension of our approach to forward gotos, the most common form of control transfer in C programs. Several proposals have been made to extend Hoare's logic to goto statements. We choose here a notation close to Arbib and Alagic's <ref> [4] </ref>. The rules add to the normal post-condition an environment where every label occurring in the statement is associated with a condition.
Reference: [5] <author> J.-P. Ban^atre, C. Bryce, D. Le Metayer, </author> <title> Compile-time detection of information flow in sequential programs, </title> <booktitle> proc. European Symposium on Research in Computer Security, </booktitle> <publisher> Springer Verlag, LNCS 875, </publisher> <pages> pp. 55-74. </pages>
Reference-contexts: Exploiting this extra information usually reduces dramatically the size of the properties manipulated by the algorithm. We are also studying the use of the pointer analysis described here to enhance the information flow analysis proposed in <ref> [5] </ref>. Other applications of this analysis include the detection of unsafe programming styles (which rely on specific implementation choices like the order of evaluation of subexpressions) or memory leaks.
Reference: [6] <author> J.F. Bergeretti and B. Carre, </author> <title> Information-flow and data-flow analysis of while-programs, </title> <journal> in ACM Transactions on Programming Languages and Systems,Vol. </journal> <volume> 7, No. 1, </volume> <month> Jan. </month> <pages> 85, pp. 37-61. </pages>
Reference-contexts: We sketch related work in each of these areas in turn. * There are relatively few papers about the design of program analysers to help in the program development process. Most related contributions <ref> [6, 13, 15, 25] </ref> and tools [19] can provide information about uninitialised variables but are unable to track illegal accesses in recursive data structures.
Reference: [7] <author> A. Bijlsma, </author> <title> Calculating with pointers, </title> <booktitle> in Science of Computer Programming 12 (1989) 191-205, </booktitle> <publisher> North-Holland. </publisher>
Reference-contexts: This extra level of precision is required to the analysis of correctness-related properties (for instance, the example treated in Section 4 could not be analysed successfully without a form of must-alias information). * Axiomatisation of pointer and alias relations has been studied for Pascal (see e.g. <ref> [7, 8, 22] </ref>). Most contributions in this area focus on generality and completeness issues and do not consider automatisation. An exception is the work by Luckham and Suzuki [21] which presents an axiom-based verifier for Pascal programs.
Reference: [8] <author> R. Cartwright and D. Oppen, </author> <title> The logic of aliasing, </title> <journal> in Acta Informatica 15, 365-384, 1981 ACM TOPLAS, </journal> <volume> Vol. 7, </volume> <year> 1985, </year> <pages> pp. 299-310. </pages>
Reference-contexts: This extra level of precision is required to the analysis of correctness-related properties (for instance, the example treated in Section 4 could not be analysed successfully without a form of must-alias information). * Axiomatisation of pointer and alias relations has been studied for Pascal (see e.g. <ref> [7, 8, 22] </ref>). Most contributions in this area focus on generality and completeness issues and do not consider automatisation. An exception is the work by Luckham and Suzuki [21] which presents an axiom-based verifier for Pascal programs.
Reference: [9] <author> P. Cousot and R. Cousot, </author> <title> Systematic design of program analysis frameworks, </title> <booktitle> in 6 th Annual ACM Symp. on Principles of Programming Languages POPL'79, </booktitle> <month> Jan. </month> <pages> 79, pp. 269-282. </pages>
Reference-contexts: Again, the most difficult rule is the assignment. It is not clear whether the overall effort would be less important but the formulation in terms of abstract interpretation would make it easier to show the optimality of the analyser (in terms of precision) <ref> [9] </ref>. Also, the approximation techniques studied in this framework can be applied to get more efficient analysers. So, the two approaches are complementary: we have focussed in this paper on the derivation of an analysis from the axiomatisation of a property, emphasizing a clear separation between logical and algorithmic concerns.
Reference: [10] <author> A. Deutsch, </author> <title> A storeless model of aliasing and its abstraction using finite representations of right-regular equivalence relations, </title> <booktitle> in Proc. of the IEEE 1992 Conf. on Computer Languages, Apr. </booktitle> <volume> 92, </volume> <pages> pp. 2-13. </pages> <note> PI n-980 18 Pascal Fradet, Ronan Gaugne and Daniel Le Metayer </note>
Reference-contexts: Irisa An inference algorithm for the static verification of pointer manipulation 17 the operational semantics (see <ref> [10] </ref> for an illustration of this approach). Again, the most difficult rule is the assignment.
Reference: [11] <author> A. Deutsch, </author> <title> Interprocedural may-alias analysis for pointers: Beyond k-limiting, </title> <booktitle> in SIGPLAN'94 Conf. on Programming Language Design and Implementation PLDI'94, </booktitle> <month> Jun. </month> <year> 1994, </year> <pages> pp. 230-241. </pages>
Reference-contexts: Other techniques like [14, 18] perform different kinds of analyses (like aspects, program slicing) which are complementary to the work described here. * There is an extensive body of literature on alias analysis but most of the contributions are concerned with may-alias analysis and are targeted towards compiler optimisations <ref> [11, 12] </ref>. The alias pairs (x; y) of [11] correspond to &x = &y here and the x points-to y relationship of [12] is equivalent to x = &y. One of the most precise published alias analysis is the framework described in [11]. <p> The alias pairs (x; y) of <ref> [11] </ref> correspond to &x = &y here and the x points-to y relationship of [12] is equivalent to x = &y. One of the most precise published alias analysis is the framework described in [11]. <p> The alias pairs (x; y) of <ref> [11] </ref> correspond to &x = &y here and the x points-to y relationship of [12] is equivalent to x = &y. One of the most precise published alias analysis is the framework described in [11]. Our analysis is not directly comparable to this one in terms of precision: on one hand, the symbolic access paths used in [11] provide a much more accurate may-alias information (because numerical coefficients are used to record precise positions in a structure); on the other hand, our properties include both <p> One of the most precise published alias analysis is the framework described in <ref> [11] </ref>. Our analysis is not directly comparable to this one in terms of precision: on one hand, the symbolic access paths used in [11] provide a much more accurate may-alias information (because numerical coefficients are used to record precise positions in a structure); on the other hand, our properties include both may-alias and must-alias information which allows us to gain accuracy in certain situations (the significance of must-alias properties to get more accurate may-alias
Reference: [12] <author> M. Emami, R. Ghiya and L. Hendren, </author> <title> Context-sensitive interprocedural points-to analysis in the presence of function pointers, </title> <booktitle> in SIGPLAN'94 Conf. on Programming Language Design and Implementation PLDI'94, </booktitle> <month> Jun. </month> <year> 1994, </year> <pages> pp. 242-256. </pages>
Reference-contexts: Other techniques like [14, 18] perform different kinds of analyses (like aspects, program slicing) which are complementary to the work described here. * There is an extensive body of literature on alias analysis but most of the contributions are concerned with may-alias analysis and are targeted towards compiler optimisations <ref> [11, 12] </ref>. The alias pairs (x; y) of [11] correspond to &x = &y here and the x points-to y relationship of [12] is equivalent to x = &y. One of the most precise published alias analysis is the framework described in [11]. <p> The alias pairs (x; y) of [11] correspond to &x = &y here and the x points-to y relationship of <ref> [12] </ref> is equivalent to x = &y. One of the most precise published alias analysis is the framework described in [11].
Reference: [13] <author> D. Evans, </author> <title> Using specifications to check source code, </title> <type> in Technical Report, </type> <institution> MIT Lab for computer science, </institution> <month> Jun. </month> <year> 1994. </year>
Reference-contexts: We sketch related work in each of these areas in turn. * There are relatively few papers about the design of program analysers to help in the program development process. Most related contributions <ref> [6, 13, 15, 25] </ref> and tools [19] can provide information about uninitialised variables but are unable to track illegal accesses in recursive data structures.
Reference: [14] <author> J. Field, G. Ramalingam and F. </author> <title> Tip, Parametric program slicing, </title> <booktitle> in 22 th Annual ACM Symp. on Principles of Programming Languages POPL'95, </booktitle> <month> Jan. </month> <pages> 95, pp. 379-392. </pages>
Reference-contexts: Most related contributions [6, 13, 15, 25] and tools [19] can provide information about uninitialised variables but are unable to track illegal accesses in recursive data structures. Other techniques like <ref> [14, 18] </ref> perform different kinds of analyses (like aspects, program slicing) which are complementary to the work described here. * There is an extensive body of literature on alias analysis but most of the contributions are concerned with may-alias analysis and are targeted towards compiler optimisations [11, 12].
Reference: [15] <author> L. Fosdick and L. Osterweil, </author> <title> Data flow analysis in software reliability, </title> <journal> ACM Computing surveys, </journal> <volume> 8(3), </volume> <month> Sept. </month> <year> 1976. </year>
Reference-contexts: We sketch related work in each of these areas in turn. * There are relatively few papers about the design of program analysers to help in the program development process. Most related contributions <ref> [6, 13, 15, 25] </ref> and tools [19] can provide information about uninitialised variables but are unable to track illegal accesses in recursive data structures.
Reference: [16] <author> C. L. Hankin, D. Le Metayer, </author> <title> Deriving algorithms from type inference systems: Application to strictness analysis, </title> <booktitle> proc. ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1994, </year> <pages> pp. 202-212, </pages> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: One solution leads to a representation of properties as matrices of a three- value domain (instead of sets of matrices of a boolean domain as suggested in this paper). * Computing only the necessary part of each property using a form of lazy type inference <ref> [16] </ref>. * Using (standard) types to filter properties which cannot be true. Exploiting this extra information usually reduces dramatically the size of the properties manipulated by the algorithm. We are also studying the use of the pointer analysis described here to enhance the information flow analysis proposed in [5].
Reference: [17] <author> L. Hendren and A. Nicolau, </author> <title> Parallelizing programs with recursive data structures, </title> <journal> in IEEE Transactions on Parallel and Distributed Systems, Jan. </journal> <volume> 90, Vol. 1(1), </volume> <pages> pp. 35-47. </pages>
Reference-contexts: The abstract domain is the disjunctive completion of a lattice of matrices (associating each pair (v 1 ; v 2 ) with truth values of the basic relations = and 7!). This domain has some similarities with the path matrices used in <ref> [17] </ref> for the analysis of a restricted form of regular acyclic structures. The abstraction and concretisation functions follow directly from the correspondence relation of Fig. 1.
Reference: [18] <author> D. Jackson, </author> <title> Aspect: an economical bug-detector, </title> <booktitle> in Proceedings of 13 th International Conference on Software Engineering, </booktitle> <month> May </month> <year> 1994, </year> <pages> pp. 13-22. </pages>
Reference-contexts: Most related contributions [6, 13, 15, 25] and tools [19] can provide information about uninitialised variables but are unable to track illegal accesses in recursive data structures. Other techniques like <ref> [14, 18] </ref> perform different kinds of analyses (like aspects, program slicing) which are complementary to the work described here. * There is an extensive body of literature on alias analysis but most of the contributions are concerned with may-alias analysis and are targeted towards compiler optimisations [11, 12].
Reference: [19] <author> S. Johnson, </author> <title> Lint, a C program checker, </title> <institution> Computer Science technical report, Bell Laboratories, </institution> <address> Murray Hill, NH, </address> <month> July </month> <year> 1978. </year>
Reference-contexts: We sketch related work in each of these areas in turn. * There are relatively few papers about the design of program analysers to help in the program development process. Most related contributions [6, 13, 15, 25] and tools <ref> [19] </ref> can provide information about uninitialised variables but are unable to track illegal accesses in recursive data structures.
Reference: [20] <author> W. Landi and B. Ryder, </author> <title> A safe approximate algorithm for interprocedural pointer aliasing, </title> <booktitle> in Proceedings of the ACM SIGPLAN'92 Conf. on Programming Language Design and Implementation PLDI'92, </booktitle> <month> Jun. </month> <year> 1992, </year> <pages> pp. 235-248. </pages>
Reference-contexts: If we prove fP r g f () fQ r g we can deduce fP g f () fQ r ^ P i g . Actually, much more factorisation is possible. As noted in <ref> [20] </ref>, a procedure f has the same effect on all alias pairs which contain variable x (in the scope of f) and any non-visible variable. This property can be formally justified and exploited in our framework.
Reference: [21] <author> D. Luckham and N. Suzuki, </author> <title> Verification of array, record, and pointer operations in Pascal, </title> <journal> in ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 1, </volume> <pages> No.2, </pages> <month> Oct. </month> <year> 1979, </year> <pages> pp. 226-244. </pages>
Reference-contexts: Most contributions in this area focus on generality and completeness issues and do not consider automatisation. An exception is the work by Luckham and Suzuki <ref> [21] </ref> which presents an axiom-based verifier for Pascal programs. The language of properties encompasses ours but is too rich to make the analysis fully automatic. The verifier (actually a theorem prover) depends heavily on user-supplied properties such as loop invariants.
Reference: [22] <author> J. Morris, </author> <title> A general axiom of assignment and Assignment and linked data structures, </title> <booktitle> in Theoretical Foundations of Programming Methodology, </booktitle> <editor> M. Broy and G. Schmidt (eds), </editor> <booktitle> pp. </booktitle> <pages> 25-41, </pages> <year> 1982. </year>
Reference-contexts: This extra level of precision is required to the analysis of correctness-related properties (for instance, the example treated in Section 4 could not be analysed successfully without a form of must-alias information). * Axiomatisation of pointer and alias relations has been studied for Pascal (see e.g. <ref> [7, 8, 22] </ref>). Most contributions in this area focus on generality and completeness issues and do not consider automatisation. An exception is the work by Luckham and Suzuki [21] which presents an axiom-based verifier for Pascal programs.
Reference: [23] <author> S. Sagiv, N. Francez, M. Rodeh and R. Wilhelm, </author> <title> A logic-based approach to data flow analysis problems, </title> <booktitle> in Programming Language Implementation and Logic Programming PLILP'90, </booktitle> <volume> LNCS 456, </volume> <pages> pp. 277-292, </pages> <year> 1990. </year>
Reference-contexts: The language of properties encompasses ours but is too rich to make the analysis fully automatic. The verifier (actually a theorem prover) depends heavily on user-supplied properties such as loop invariants. The work whose spirit is the closest to our approach is the analysis framework presented in <ref> [23] </ref>. Environments are described as sets of assertions specified as Horn clauses. They define optimal analyses which exploit all the information available.
Reference: [24] <author> R. Sedgewick, </author> <title> Algorithms, </title> <publisher> Addison-Wesley publishing company, </publisher> <year> 1988. </year>
Reference-contexts: follows from the lemma: Lemma 3.4 P ) Assign v 1 v 2 (P )[[v 2 =v 1 ]] V Proofs can be found in Appendix 3. 4 Checking a program manipulating circular data structures In this section, we illustrate our analysis with the Josephus program (Figure 9) borrowed from <ref> [24] </ref>, page 22. The program first builds a circular list, then proceeds through the list, counting through m 1 items and PI n-980 12 Pascal Fradet, Ronan Gaugne and Daniel Le Metayer deleting the next, until only one is left (which points to itself).
Reference: [25] <author> R. Strom and D. Yellin, </author> <title> Extending typestate checking using conditional liveness analysis, </title> <journal> in IEEE Transactions on Software Engineering, </journal> <volume> Vol. 19, No 5, </volume> <month> May. </month> <pages> 93, pp. 478-485. </pages>
Reference-contexts: We sketch related work in each of these areas in turn. * There are relatively few papers about the design of program analysers to help in the program development process. Most related contributions <ref> [6, 13, 15, 25] </ref> and tools [19] can provide information about uninitialised variables but are unable to track illegal accesses in recursive data structures.
Reference: [26] <author> R.P. Wilson and M.S. Lam, </author> <title> Efficient context-sensitive pointer analysis for C programs in Proceedings of the ACM SIGPLAN'95 Conf. </title> <booktitle> on Programming Language Design and Implementation PLDI'95, </booktitle> <month> Jun. </month> <year> 1995, </year> <pages> pp. </pages> <month> 1-12. </month> <title> Irisa An inference algorithm for the static verification of pointer manipulation 19 </title>
References-found: 26

