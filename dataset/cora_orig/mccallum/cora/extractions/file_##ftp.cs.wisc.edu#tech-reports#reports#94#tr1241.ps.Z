URL: file://ftp.cs.wisc.edu/tech-reports/reports/94/tr1241.ps.Z
Refering-URL: http://www.cs.wisc.edu/shore/shore.papers.html
Root-URL: 
Email: white@cs.wisc.edu dewitt@cs.wisc.edu  
Title: QuickStore: A High Performance Mapped Object Store  
Author: Seth J. White David J. DeWitt 
Address: Madison, WI 53706 Madison, WI 53706  
Affiliation: Computer Sciences Department Computer Sciences Department University of Wisconsin University of Wisconsin  
Abstract: This paper presents, QuickStore, a memory-mapped storage system for persistent C++ built on top of the EXODUS Storage Manager. QuickStore provides fast access to in-memory objects by allowing application programs to access objects via normal virtual memory pointers. The paper also presents the results of a detailed performance study using the OO7 benchmark. The study compares the performance of QuickStore with the latest implementation of the E programming language. These systems (QuickStore and E) exemplify the two basic approaches (hardware and software) that have been used to implement persistence in object-oriented database systems. In addition, both systems use the same underlying storage manager and compiler allowing us to make a truly apples-to-apples comparison of the hardware and software techniques. 
Abstract-found: 1
Intro-found: 1
Reference: [Ball92] <author> T. Ball, J. Larus, </author> <title> "Optimally Profiling and Tracing Programs", </title> <booktitle> POPL 1992, </booktitle> <pages> pp. 59-70, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: As one would expect, the performance of QS is generally better than E. It is somewhat surprising, however, that E is just 23% slower than QS during T1. To determine the reasons for this relatively small difference, we used qpt <ref> [Ball92] </ref> to profile the benchmark application. Table 7 presents the profiling results for T1. The T1 hot traversal time has been broken down in Table 7 based on the percentage of CPU time spent in several groups of functions.
Reference: [Carey89] <author> M. Carey et al., </author> <title> "Storage Management for Objects in EXODUS," in Object-Oriented Concepts, Databases, and Applications, </title> <editor> W. Kim and F. Lochovsky, eds., </editor> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: 1. Introduction This paper presents, QuickStore, a memory-mapped storage system for persistent C++ built on top of the EXODUS Storage Manager (ESM) <ref> [Carey89] </ref>. QuickStore uses standard virtual memory hardware to trigger the transfer of persistent data from secondary storage into main memory [Wilso90].
Reference: [Carey93] <author> M. Carey, D. DeWitt, J. Naughton, </author> <title> "The OO7 Benchmark", </title> <booktitle> Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <address> Washington, DC, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: The paper also presents the results of a detailed performance study, in which we use the OO7 benchmark <ref> [Carey93] </ref> to compare the performance of QuickStore with the latest implementation of E [Rich93], a persistent programming language developed at Wisconsin that is also based on C++. The comparison between QuickStore and E is interesting because each of the systems takes a radically different approach toward implementing persistence. <p> The queries were hand coded in C++ since neither QuickStore or E provide a declarative query language. We comment on the implementation used to execute the queries, although this is not part of the OO7 specification <ref> [Carey93] </ref>. 4.2.1. Traversals The T1 traversal performs a depth-first traversal of the assembly hierarchy. As each base assembly is visited, each of its composite parts is visited and a depth-first search on the graph of atomic parts is performed. <p> T8 scans the manual object associated with the module and counts the occurrences of a specified character, and T9 compares the first and last characters of the manual to see if they are the same. hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 1 <ref> [Carey93] </ref> specifies that the (x, y) attributes should be swapped. We increment them instead so that multiple updates of the same object change the object's value. This guarantees that the diffing scheme used for recovery by QuickStore will always generate a log record. - 19 - 4.2.2.
Reference: [DeWitt90] <author> D. DeWitt, P. Futtersack, D. Maier, F. Velez, </author> <title> "A Study of Three Alternative Workstation-Server Architectures for Object-Oriented Database Systems", </title> <booktitle> Proceedings of the 16th International Conferece on Very Large Data Bases, </booktitle> <address> Brisbane, Australia, </address> <month> August, </month> <year> 1990. </year>
Reference-contexts: QuickStore Design Concepts As mentioned in Section 1, QuickStore uses ESM to store persistent objects on disk. ESM features a page-shipping <ref> [DeWitt90] </ref> architecture, in which objects are transferred from the server to the client a page-at-a-time.
Reference: [Frank92] <author> M. Franklin, M. Zwilling, C. Tan, M. Carey, D. DeWitt, </author> <title> "Crash Recovery in Client-Server EXODUS", </title> <booktitle> Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <address> California, </address> <year> 1992. </year>
Reference-contexts: Log records are created and managed using the normal recovery services provided by ESM <ref> [Frank92] </ref>. The processes of diffing and generating log records are interleaved in QuickStore. To understand why this is the so, consider as an example the case when the first and last byte of an 1 K-byte object have been updated.
Reference: [Hoski93a] <author> A. Hosking, J. E. B. Moss, </author> <title> "Object Fault Handling for Persistent Programming Languages: A Performance Evaluation", </title> <booktitle> Proceedings of the ACM Conference on Object-Oriented Programming Systems and Languages (OOPSLA), </booktitle> <pages> pp. 288-303, </pages> <year> 1993. </year>
Reference-contexts: The systems we examine also include concurrency control and recovery, while those examined in [Moss92] did not. <ref> [Hoski93a] </ref> examines the performance of several object faulting schemes in the context of a persistent Smalltalk implementation. [Hoski93a] includes one scheme that uses virtual memory techniques to detect accesses to non-resident objects. The approach described in [Hoski93a] allocates fault-blocks, special objects that stand in for non-resident objects, in protected pages. <p> The systems we examine also include concurrency control and recovery, while those examined in [Moss92] did not. <ref> [Hoski93a] </ref> examines the performance of several object faulting schemes in the context of a persistent Smalltalk implementation. [Hoski93a] includes one scheme that uses virtual memory techniques to detect accesses to non-resident objects. The approach described in [Hoski93a] allocates fault-blocks, special objects that stand in for non-resident objects, in protected pages. <p> examine also include concurrency control and recovery, while those examined in [Moss92] did not. <ref> [Hoski93a] </ref> examines the performance of several object faulting schemes in the context of a persistent Smalltalk implementation. [Hoski93a] includes one scheme that uses virtual memory techniques to detect accesses to non-resident objects. The approach described in [Hoski93a] allocates fault-blocks, special objects that stand in for non-resident objects, in protected pages. When the application tries to access an object through its corresponding fault block, an access violation is signaled. The results presented in [Hoski93a] show this scheme to have very poor performance. <p> The approach described in <ref> [Hoski93a] </ref> allocates fault-blocks, special objects that stand in for non-resident objects, in protected pages. When the application tries to access an object through its corresponding fault block, an access violation is signaled. The results presented in [Hoski93a] show this scheme to have very poor performance. <p> This work involves examining the pointer fields of all transient and persistent objects that contain pointers to the fault block. Finally, we note that the effects of page replacement in the buffer pool and updates are also not considered in <ref> [Hoski93a] </ref>. In [White92] the performance of several implementations of the E language [Rich93, Schuh90] and ObjectStore [Objec90, Lamb91], a commercial OODBMS, are compared.
Reference: [Hoski93b] <author> A. Hosking, E. Brown, J. Moss, </author> <title> "Update Logging in Persistent Programming Languages: A Comparative Performance Evaluation", </title> <booktitle> Proceedings of the 19th International Conferece on Very Large Data Bases, </booktitle> <address> Dublin, Ireland, </address> <year> 1993. </year>
Reference-contexts: Finally, we note that <ref> [Hoski93b] </ref> examines the performance of several alternative methods for detecting and recording the occurrence of updates in a persistent programming language, i.e. Smalltalk, that supports recovery from system failures. The techniques studied in [Hoski93b] use differencing to generate log records, as does QuickStore. The study presented here differs from [Hoski93b] in <p> Finally, we note that <ref> [Hoski93b] </ref> examines the performance of several alternative methods for detecting and recording the occurrence of updates in a persistent programming language, i.e. Smalltalk, that supports recovery from system failures. The techniques studied in [Hoski93b] use differencing to generate log records, as does QuickStore. The study presented here differs from [Hoski93b] in that, the goal of [Hoski93b] is to compare different techniques for detecting and recording updates in the context of a single underlying language implementation, while the goal of our study is to compare <p> that <ref> [Hoski93b] </ref> examines the performance of several alternative methods for detecting and recording the occurrence of updates in a persistent programming language, i.e. Smalltalk, that supports recovery from system failures. The techniques studied in [Hoski93b] use differencing to generate log records, as does QuickStore. The study presented here differs from [Hoski93b] in that, the goal of [Hoski93b] is to compare different techniques for detecting and recording updates in the context of a single underlying language implementation, while the goal of our study is to compare the performance of software and hardware-based pointer swizzling. However, [Hoski93b] does examine one scheme that uses <p> Smalltalk, that supports recovery from system failures. The techniques studied in <ref> [Hoski93b] </ref> use differencing to generate log records, as does QuickStore. The study presented here differs from [Hoski93b] in that, the goal of [Hoski93b] is to compare different techniques for detecting and recording updates in the context of a single underlying language implementation, while the goal of our study is to compare the performance of software and hardware-based pointer swizzling. However, [Hoski93b] does examine one scheme that uses virtual memory page faults to detect <p> The study presented here differs from <ref> [Hoski93b] </ref> in that, the goal of [Hoski93b] is to compare different techniques for detecting and recording updates in the context of a single underlying language implementation, while the goal of our study is to compare the performance of software and hardware-based pointer swizzling. However, [Hoski93b] does examine one scheme that uses virtual memory page faults to detect the occurrence of updates, so we briefly compare QuickStore to the approach examined in [Hoski93b]. [Hoski93b] uses a copy swizzling approach in which objects are copied out the buffer pool of the underlying object manager - 4 - <p> However, <ref> [Hoski93b] </ref> does examine one scheme that uses virtual memory page faults to detect the occurrence of updates, so we briefly compare QuickStore to the approach examined in [Hoski93b]. [Hoski93b] uses a copy swizzling approach in which objects are copied out the buffer pool of the underlying object manager - 4 - and into a separate object cache located in memory, before they can be accessed by the application program. The hardware--based detection scheme used in [Hoski93b] requires that <p> However, <ref> [Hoski93b] </ref> does examine one scheme that uses virtual memory page faults to detect the occurrence of updates, so we briefly compare QuickStore to the approach examined in [Hoski93b]. [Hoski93b] uses a copy swizzling approach in which objects are copied out the buffer pool of the underlying object manager - 4 - and into a separate object cache located in memory, before they can be accessed by the application program. The hardware--based detection scheme used in [Hoski93b] requires that the <p> examined in <ref> [Hoski93b] </ref>. [Hoski93b] uses a copy swizzling approach in which objects are copied out the buffer pool of the underlying object manager - 4 - and into a separate object cache located in memory, before they can be accessed by the application program. The hardware--based detection scheme used in [Hoski93b] requires that the virtual memory page in the object cache that will hold an object be unprotected and then reprotected each time an object is copied into the pageproducing a substantial amount of overhead (up to 100%), even for read-only transactions. <p> The technique used in QuickStore doesn't impact the performance of read-only transactions, and we expect that detecting updates is much cheaper in QuickStore than in the scheme studied in <ref> [Hoski93b] </ref>. 3. QuickStore Design Concepts As mentioned in Section 1, QuickStore uses ESM to store persistent objects on disk. ESM features a page-shipping [DeWitt90] architecture, in which objects are transferred from the server to the client a page-at-a-time.
Reference: [Jagad94] <author> H. Jagadish, D. Lieuwen, R. Rastogi, A. Silberschatz, </author> <title> "Dali: A High Performance Main Memory Storage Manager", </title> <booktitle> to appear in Proceedings of the 20th International Conferece on Very Large Data Bases, </booktitle> <address> Santiago, Chile, </address> <month> September 12-15, </month> <year> 1994. </year>
Reference-contexts: Cricket, on the other hand, uses the Mach external pager facility to map persistent data into an application's address space (see [Shek90] for details). A very recent related system is Dali <ref> [Jagad94] </ref> which is designed to be a main memory storage manager. Dali uses memory mapping techniques, but since it is specifically designed to handle main memory databases, it differs substantially from QuickStore. For example, Dali itself performs no pointer swizzling.
Reference: [Khosh86] <author> S. Khoshafian, G. Copeland, </author> <title> "Object Identity", </title> <booktitle> Proceedings of the ACM Conference on Object-Oriented Programming Systems and Languages (OOPSLA), </booktitle> <pages> pages 408-416, </pages> <month> November </month> <year> 1986. </year>
Reference-contexts: Although QuickStore and E offer nearly the same functionality, it is important to point out one fundamental way in which the two systems differ. This has to do with the degree to which the two systems support the notion of object identity <ref> [Khosh86] </ref>. Section 3 described the scheme used by QuickStore to implement a mapping between virtual memory frames and disk pages. This mapping is maintained for pages when they are in memory as well as when they reside on disk.
Reference: [Lamb91] <author> C. Lamb, G. Landis, J. Orenstein, D. Weinreb, </author> <title> "The ObjectStore Database System", </title> <journal> Communications of the ACM, </journal> <volume> Vol. 34, No. 10, </volume> <month> October </month> <year> 1991. </year>
Reference-contexts: The technique described in [Wilso90] allows programs to access persistent objects by dereferencing standard virtual memory pointers, eliminating the need for software residency checks. The basic ideas presented in [Wilso90] were, at the same time, independently used by the designers of ObjectStore <ref> [Objec90, Lamb91] </ref>, a commercial OODBMS product from Object Design, Inc. The implementation of ObjectStore, outlined briefly in [Objec90], differs in some interesting ways from the scheme described in [Wilso90]; most notably in the way that pointer swizzling is implemented, and in how pointers are represented on disk. <p> Finally, we note that the effects of page replacement in the buffer pool and updates are also not considered in [Hoski93a]. In [White92] the performance of several implementations of the E language [Rich93, Schuh90] and ObjectStore <ref> [Objec90, Lamb91] </ref>, a commercial OODBMS, are compared. The results presented in [White92] were inconclusive, however, in providing a true comparison of software and hardware-based schemes since the underlying storage managers used by the systems were different and because the systems used different compilers.
Reference: [Moss92] <author> J. Eliot B. Moss, </author> <title> "Working with Persistent Objects: To Swizzle or Not to Swizzle", </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(8) </volume> <pages> 657-673, </pages> <month> August </month> <year> 1992. </year> <month> - 39 </month> - 
Reference-contexts: The advantage of this approach is that access to in-memory persistent objects is just as efficient as access to transient objects, i.e. application programs access objects by dereferencing normal virtual memory pointers, with no overhead for software residency checks as in <ref> [Moss92, Schuh90, White92] </ref>. QuickStore is implemented as a C++ class library that can be linked with an application, requiring no special compiler support. Instead, QuickStore uses a modified version of the GNU debugger (gdb) to obtain information describing the physical layout of persistent objects. <p> We next discuss previous performance studies of pointer swizzling and object faulting techniques, and point out how the study presented here differs from them. <ref> [Moss92] </ref> contains a study of several software swizzling techniques and examines various issues relevant to pointer swizzling. <p> Among these are whether swizzling has better performance than simply using object identifiers to locate objects, and whether objects should be manipulated in the buffer pool of the underlying storage manager, or copied out into a separate area of memory before swizzling takes place. <ref> [Moss92] </ref> also looks at lazy vs. eager swizzling. Eager swizzling involves prefetching the entire collection of objects into memory so that all pointers can be swizzled, while lazy swizzling swizzles pointers incrementally as objects are accessed and faulted into memory by the application program. <p> We do not consider copy swizzling approaches since [White92] showed that they do not perform well when the database size is larger than physical memory. The study presented here also differs from <ref> [Moss92] </ref> in that we allow - 3 - pages of objects to be replaced in the buffer pool, while [Moss92] only considers small data sets where no paging occurs. The systems we examine also include concurrency control and recovery, while those examined in [Moss92] did not. [Hoski93a] examines the performance of <p> The study presented here also differs from <ref> [Moss92] </ref> in that we allow - 3 - pages of objects to be replaced in the buffer pool, while [Moss92] only considers small data sets where no paging occurs. The systems we examine also include concurrency control and recovery, while those examined in [Moss92] did not. [Hoski93a] examines the performance of several object faulting schemes in the context of a persistent Smalltalk implementation. [Hoski93a] includes one scheme that uses virtual <p> The study presented here also differs from <ref> [Moss92] </ref> in that we allow - 3 - pages of objects to be replaced in the buffer pool, while [Moss92] only considers small data sets where no paging occurs. The systems we examine also include concurrency control and recovery, while those examined in [Moss92] did not. [Hoski93a] examines the performance of several object faulting schemes in the context of a persistent Smalltalk implementation. [Hoski93a] includes one scheme that uses virtual memory techniques to detect accesses to non-resident objects.
Reference: [Objec90] <institution> Object Design, Inc., </institution> <note> "ObjectStore User Guide", Release 1.0, </note> <month> October </month> <year> 1990. </year>
Reference-contexts: The technique described in [Wilso90] allows programs to access persistent objects by dereferencing standard virtual memory pointers, eliminating the need for software residency checks. The basic ideas presented in [Wilso90] were, at the same time, independently used by the designers of ObjectStore <ref> [Objec90, Lamb91] </ref>, a commercial OODBMS product from Object Design, Inc. The implementation of ObjectStore, outlined briefly in [Objec90], differs in some interesting ways from the scheme described in [Wilso90]; most notably in the way that pointer swizzling is implemented, and in how pointers are represented on disk. <p> The basic ideas presented in [Wilso90] were, at the same time, independently used by the designers of ObjectStore [Objec90, Lamb91], a commercial OODBMS product from Object Design, Inc. The implementation of ObjectStore, outlined briefly in <ref> [Objec90] </ref>, differs in some interesting ways from the scheme described in [Wilso90]; most notably in the way that pointer swizzling is implemented, and in how pointers are represented on disk. Under the approach outlined in [Objec90], pointers between persistent objects are stored on disk as virtual memory pointers instead of being <p> The implementation of ObjectStore, outlined briefly in <ref> [Objec90] </ref>, differs in some interesting ways from the scheme described in [Wilso90]; most notably in the way that pointer swizzling is implemented, and in how pointers are represented on disk. Under the approach outlined in [Objec90], pointers between persistent objects are stored on disk as virtual memory pointers instead of being stored in a different disk format as in [Wilso90]. <p> Finally, we note that the effects of page replacement in the buffer pool and updates are also not considered in [Hoski93a]. In [White92] the performance of several implementations of the E language [Rich93, Schuh90] and ObjectStore <ref> [Objec90, Lamb91] </ref>, a commercial OODBMS, are compared. The results presented in [White92] were inconclusive, however, in providing a true comparison of software and hardware-based schemes since the underlying storage managers used by the systems were different and because the systems used different compilers.
Reference: [Rich93] <author> J. Richardson, M. Carey, and D. Schuh, </author> <title> "The Design of the E Programming Language", </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 15, No. 3, </volume> <month> July </month> <year> 1993. </year>
Reference-contexts: The paper also presents the results of a detailed performance study, in which we use the OO7 benchmark [Carey93] to compare the performance of QuickStore with the latest implementation of E <ref> [Rich93] </ref>, a persistent programming language developed at Wisconsin that is also based on C++. The comparison between QuickStore and E is interesting because each of the systems takes a radically different approach toward implementing persistence. <p> Finally, we note that the effects of page replacement in the buffer pool and updates are also not considered in [Hoski93a]. In [White92] the performance of several implementations of the E language <ref> [Rich93, Schuh90] </ref> and ObjectStore [Objec90, Lamb91], a commercial OODBMS, are compared. The results presented in [White92] were inconclusive, however, in providing a true comparison of software and hardware-based schemes since the underlying storage managers used by the systems were different and because the systems used different compilers.
Reference: [Schuh90] <author> D. Schuh, M. Carey, and D. Dewitt, </author> <title> "Persistence in E Revisited---Implementation Experiences", </title> <booktitle> Proceedings of the Fourth International Workshop on Persistent Object Systems, </booktitle> <address> Martha's Vineyard, MA, </address> <month> Sept. </month> <year> 1990. </year>
Reference-contexts: The advantage of this approach is that access to in-memory persistent objects is just as efficient as access to transient objects, i.e. application programs access objects by dereferencing normal virtual memory pointers, with no overhead for software residency checks as in <ref> [Moss92, Schuh90, White92] </ref>. QuickStore is implemented as a C++ class library that can be linked with an application, requiring no special compiler support. Instead, QuickStore uses a modified version of the GNU debugger (gdb) to obtain information describing the physical layout of persistent objects. <p> Finally, we note that the effects of page replacement in the buffer pool and updates are also not considered in [Hoski93a]. In [White92] the performance of several implementations of the E language <ref> [Rich93, Schuh90] </ref> and ObjectStore [Objec90, Lamb91], a commercial OODBMS, are compared. The results presented in [White92] were inconclusive, however, in providing a true comparison of software and hardware-based schemes since the underlying storage managers used by the systems were different and because the systems used different compilers. <p> The interpreter maintains a hash table that contains an entry for each page of objects that is currently in memory. The pointer swizzling scheme used in EPVM 3.0 is similar to the scheme used in EPVM 1.0 <ref> [Schuh90] </ref> except that swizzled pointers point directly to objects in the buffer pool. This swizzling scheme only swizzles pointers that are local variables in C++ functions. Pointers within persistent objects are not swizzled because this makes page replacement in the buffer pool difficult [White92].
Reference: [Shek90] <author> E. Shekita and M. Zwilling, "Cricket: </author> <title> A Mapped Persistent Object Store", </title> <booktitle> Proceedings of the Fourth International Wor kshop on Persistent Object Systems, </booktitle> <address> Martha's Vineyard, MA, </address> <month> Sept. </month> <year> 1990. </year>
Reference-contexts: We note here that QuickStore is similar to ObjectStore in that QuickStore also stores pointers on disk as virtual memory pointers. Section 3 contains a detailed discussion of the implementation of QuickStore. The Texas [Singh92] and Cricket <ref> [Shek90] </ref> storage systems also use virtual memory techniques to implement persistence. Texas stores pointers on disk as 8-byte file offsets, and swizzles pointers to virtual addresses as described in [Wilso90] at fault time. <p> Cricket, on the other hand, uses the Mach external pager facility to map persistent data into an application's address space (see <ref> [Shek90] </ref> for details). A very recent related system is Dali [Jagad94] which is designed to be a main memory storage manager. Dali uses memory mapping techniques, but since it is specifically designed to handle main memory databases, it differs substantially from QuickStore. For example, Dali itself performs no pointer swizzling.
Reference: [Wilso90] <author> Paul R. Wilson, </author> <title> "Pointer Swizzling at Page Fault Time: Efficiently Supporting Huge Address Spaces on Standard Hardware", </title> <type> Technical Report UIC-EECS-90-6, </type> <institution> University of Illinois at Chicago, </institution> <month> December </month> <year> 1990. </year> <month> - 40 </month> - 
Reference-contexts: 1. Introduction This paper presents, QuickStore, a memory-mapped storage system for persistent C++ built on top of the EXODUS Storage Manager (ESM) [Carey89]. QuickStore uses standard virtual memory hardware to trigger the transfer of persistent data from secondary storage into main memory <ref> [Wilso90] </ref>. The advantage of this approach is that access to in-memory persistent objects is just as efficient as access to transient objects, i.e. application programs access objects by dereferencing normal virtual memory pointers, with no overhead for software residency checks as in [Moss92, Schuh90, White92]. <p> Army Research Laboratory under contract DAAB07-91-C-Q518. - 1 - 2. Related Work A detailed proposal advocating the use of virtual memory techniques to trigger the transfer of persistent objects from disk to main memory, first appeared in <ref> [Wilso90] </ref>. The basic approach described in [Wilso90] is termed "pointer swizzling at page fault time" since under this scheme all pointers on a page are converted from their disk format to normal virtual memory pointers (i.e. swizzled) by a page-fault handling routine before an application is given access to a newly <p> Army Research Laboratory under contract DAAB07-91-C-Q518. - 1 - 2. Related Work A detailed proposal advocating the use of virtual memory techniques to trigger the transfer of persistent objects from disk to main memory, first appeared in <ref> [Wilso90] </ref>. The basic approach described in [Wilso90] is termed "pointer swizzling at page fault time" since under this scheme all pointers on a page are converted from their disk format to normal virtual memory pointers (i.e. swizzled) by a page-fault handling routine before an application is given access to a newly resident page. <p> In addition, pages of virtual memory are allocated for non-resident pages one step ahead of their actual use and access protected, so that references to these pages will cause a page-fault to be signaled. The technique described in <ref> [Wilso90] </ref> allows programs to access persistent objects by dereferencing standard virtual memory pointers, eliminating the need for software residency checks. The basic ideas presented in [Wilso90] were, at the same time, independently used by the designers of ObjectStore [Objec90, Lamb91], a commercial OODBMS product from Object Design, Inc. <p> The technique described in <ref> [Wilso90] </ref> allows programs to access persistent objects by dereferencing standard virtual memory pointers, eliminating the need for software residency checks. The basic ideas presented in [Wilso90] were, at the same time, independently used by the designers of ObjectStore [Objec90, Lamb91], a commercial OODBMS product from Object Design, Inc. The implementation of ObjectStore, outlined briefly in [Objec90], differs in some interesting ways from the scheme described in [Wilso90]; most notably in the way that pointer swizzling is <p> The basic ideas presented in <ref> [Wilso90] </ref> were, at the same time, independently used by the designers of ObjectStore [Objec90, Lamb91], a commercial OODBMS product from Object Design, Inc. The implementation of ObjectStore, outlined briefly in [Objec90], differs in some interesting ways from the scheme described in [Wilso90]; most notably in the way that pointer swizzling is implemented, and in how pointers are represented on disk. Under the approach outlined in [Objec90], pointers between persistent objects are stored on disk as virtual memory pointers instead of being stored in a different disk format as in [Wilso90]. <p> described in <ref> [Wilso90] </ref>; most notably in the way that pointer swizzling is implemented, and in how pointers are represented on disk. Under the approach outlined in [Objec90], pointers between persistent objects are stored on disk as virtual memory pointers instead of being stored in a different disk format as in [Wilso90]. In other words, pointer fields in objects simply contain the value that they last were assigned when the page was resident in main memory in ObjectStore. <p> Section 3 contains a detailed discussion of the implementation of QuickStore. The Texas [Singh92] and Cricket [Shek90] storage systems also use virtual memory techniques to implement persistence. Texas stores pointers on disk as 8-byte file offsets, and swizzles pointers to virtual addresses as described in <ref> [Wilso90] </ref> at fault time. Currently, all data is stored in a single file (implemented on a raw Unix disk partition) in Texas - 2 - [Singh92]. Although, QuickStore and Texas are different in their implementation details, there are some similarities between the two systems.
References-found: 16

