URL: http://www.psrg.lcs.mit.edu/ftpdir/james/papers/iwmm92.ps
Refering-URL: http://www.psrg.lcs.mit.edu/publications.html
Root-URL: 
Title: Replication-Based Incremental Copying Collection  
Author: Scott Nettles James O'Toole David Pierce Nicholas Haines 
Keyword: replication, garbage collection, incremental collection, concurrent collection, real-time garbage collection  
Abstract: We introduce a new replication-based copying garbage collection technique. We have implemented one simple variation of this method to provide incremental garbage collection on stock hardware with no special operating system or virtual memory support. The performance of the prototype implementation is excellent: major garbage collection pauses are completely eliminated with only a slight increase in minor collection pause times. Unlike the standard copying algorithm, the replication-based method does not destroy the original replica when a copy is created. Instead, multiple copies may exist, and various standard strategies for maintaining consistency may be applied. In our implementation for Standard ML of New Jersey, the mutator continues to use the from-space replicas until the collector has achieved a consistent replica of all live data in to-space. We present a design for a concurrent garbage collector using the replication-based technique. We also expect replication-based gc methods to be useful in providing services for persistence and distribution, and briefly discuss these pos sibilities.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Appel. </author> <title> Simple generational garbage collection and fast allocation. </title> <journal> Software-Practice and Experience, </journal> <volume> 19(2) </volume> <pages> 171-183, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: Therefore, the mutator need not adhere to a consistency protocol, and so only one small change to the SML/NJ compiler was required. The rest of the implementation work required modifications to the standard SML/NJ garbage collector. SML/NJ uses a simple generational copying collector <ref> [1] </ref>, with two generations known as new-space and old-space. The new-space is used for newly allocated data, and the old-space contains data which has survived at least one collection. When the new-space fills, a `minor' collection is performed, copying data from the new-space to the old-space.
Reference: [2] <author> Andrew W. Appel, John R. Ellis, and Kai Li. </author> <title> Real-time concurrent garbage collection on stock multiprocessors. </title> <booktitle> In SIGPLAN Symposium on Programming Language Design and Implementation, </booktitle> <pages> pages 11-20, </pages> <year> 1988. </year>
Reference-contexts: Real-time collectors interleave garbage collection with program execution, thus spreading out the copying work so that the individual interruptions are unobtrusive. These incremental collectors fall into one of two groups: those that require special hardware [6], and those that use virtual memory protection <ref> [2] </ref>. The disadvantage of techniques which use special hardware is that they are not portable. <p> Recent work includes that by Ellis, Li, and Appel <ref> [2] </ref>, which exemplifies the use of the virtual-memory system to control the GC behavior, and Hal-stead [5], using hardware improvements. The first real-time copying collector, by Baker [3] requires special hardware, and paved the way for many other such systems.
Reference: [3] <author> H. G. Baker. </author> <title> List processing in real time on a serial computer. </title> <journal> Communications of the ACM, </journal> <volume> 21(4) </volume> <pages> 280-294, </pages> <year> 1978. </year>
Reference-contexts: Recent work includes that by Ellis, Li, and Appel [2], which exemplifies the use of the virtual-memory system to control the GC behavior, and Hal-stead [5], using hardware improvements. The first real-time copying collector, by Baker <ref> [3] </ref> requires special hardware, and paved the way for many other such systems.
Reference: [4] <author> Rodney A. Brooks. </author> <title> Trading data space for reduced time and code space in real-time garbage collection. </title> <booktitle> In SIGPLAN Symposium on LISP and Functional Programming, </booktitle> <pages> pages 256-262, </pages> <year> 1984. </year>
Reference-contexts: The first real-time copying collector, by Baker [3] requires special hardware, and paved the way for many other such systems. Some existing algorithms work on stock hardware without operating systems support, such as those by Brooks <ref> [4] </ref> and later North [8], but none of these show such small time and space overheads as our technique. 7 Future Work Since the overhead for this new technique appears to be acceptable, we believe it will be useful when applied to several other interesting GC-related algorithms.
Reference: [5] <author> Robert H. Halstead, Jr. </author> <title> Implementation of multilisp: LISP on a multiprocessor. </title> <booktitle> In ACM Symposium on LISP and Functional Programming, </booktitle> <pages> pages 9-17, </pages> <year> 1984. </year>
Reference-contexts: Recent work includes that by Ellis, Li, and Appel [2], which exemplifies the use of the virtual-memory system to control the GC behavior, and Hal-stead <ref> [5] </ref>, using hardware improvements. The first real-time copying collector, by Baker [3] requires special hardware, and paved the way for many other such systems.
Reference: [6] <author> David A. Moon. </author> <title> Garbage collection in a large lisp system. </title> <booktitle> In Proceedings of the 1984 ACM Symposium on Lisp and Functional Programming, </booktitle> <pages> pages 235-246. </pages> <publisher> ACM, </publisher> <month> August </month> <year> 1984. </year>
Reference-contexts: Government. "real time," i.e. that limit GC pauses to small bounded intervals. Real-time collectors interleave garbage collection with program execution, thus spreading out the copying work so that the individual interruptions are unobtrusive. These incremental collectors fall into one of two groups: those that require special hardware <ref> [6] </ref>, and those that use virtual memory protection [2]. The disadvantage of techniques which use special hardware is that they are not portable.
Reference: [7] <author> Scott M. Nettles and J.M. Wing. </author> <title> Persistence + Undoability = Transactions. </title> <type> Technical Report CMU-CS-91-173, </type> <institution> Carnegie Mellon University, </institution> <month> August </month> <year> 1991. </year>
Reference-contexts: One such algorithm is used to implement persistent storage. One of us has implemented a persistent storage system based on copying objects from the heap into a persistent heap <ref> [7] </ref>. A major performance bottleneck is the need to scan the entire heap for pointers to objects which have been copied. Nondestructive copying will eliminate this scan. We are also interested in using copying to implement mechanisms for distributed computing, such as those required by object repositories.
Reference: [8] <author> S. C. North and J.H. Reppy. </author> <title> Concurrent garbage collection on stock hardware. </title> <editor> In Gilles Kahn, editor, </editor> <booktitle> Functional Programming Languages and Computer Architecture (LNCS 274), </booktitle> <pages> pages 113-133. </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: The first real-time copying collector, by Baker [3] requires special hardware, and paved the way for many other such systems. Some existing algorithms work on stock hardware without operating systems support, such as those by Brooks [4] and later North <ref> [8] </ref>, but none of these show such small time and space overheads as our technique. 7 Future Work Since the overhead for this new technique appears to be acceptable, we believe it will be useful when applied to several other interesting GC-related algorithms.
Reference: [9] <author> Paul R. Wilson and Thomas G. Moher. </author> <title> Design of the opportunistic garbage collector. </title> <booktitle> In Proceedings of ACM SIGPLAN 1989 Conference on Object-Oriented Programming: Systems, Languages, and Applications, </booktitle> <year> 1989. </year>
Reference-contexts: This merge can be implemented by nondestructively adding a forwarding pointer from one object to the other. This technique may greatly reduce the amount of heap space needed. We are extending our implementation in these directions and exploring some ideas for "opportunistic" GC <ref> [9] </ref>, in which the timing of garbage collections is chosen to minimize disruptiveness. We are investigating triggering GC within the user-interaction loop, immediately before prompting for input, and after long waits for input.
References-found: 9

