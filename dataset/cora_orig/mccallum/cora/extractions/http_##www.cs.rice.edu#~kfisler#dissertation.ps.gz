URL: http://www.cs.rice.edu/~kfisler/dissertation.ps.gz
Refering-URL: http://www.cs.rice.edu/~kfisler/info.html
Root-URL: 
Title: A UNIFIED APPROACH TO HARDWARE VERIFICATION THROUGH A HETEROGENEOUS LOGIC OF DESIGN DIAGRAMS  
Author: Kathryn Fisler 
Degree: Submitted to the faculty of the Graduate School in partial fulfillment of the requirements for the degree Doctor of Philosophy in the  
Date: August 1996  
Affiliation: Department of Computer Science Indiana University  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> R. Alur, G.J. Holzmann, and D. Peled. </author> <title> An analyzer for message sequence charts. </title> <booktitle> In Proceedings of TACAS96, 2nd Intl. Workshop on Tools and Algorithms for the Construction and Analysis of Systems, </booktitle> <pages> pages 5-48, </pages> <month> March </month> <year> 1996. </year>
Reference-contexts: The first and second components of each successor edge object are called the source and target objects, respectively. 5. B is a partial function from E S to time-bound expressions called the time bound objects. The icons pictured below represent time-bound expressions [l; u], [l; l], <ref> [1; u 1] </ref>, and [l + 1; 1] attached to elements of E S , respectively. 2. Syntax and Semantics 73 6. A is a partial function from transition objects, level objects, and concurrent edge objects to discrete time expressions called the time anchors. <p> B is a partial function from E S to time-bound expressions called the time bound objects. The icons pictured below represent time-bound expressions [l; u], [l; l], [1; u 1], and <ref> [l + 1; 1] </ref> attached to elements of E S , respectively. 2. Syntax and Semantics 73 6. A is a partial function from transition objects, level objects, and concurrent edge objects to discrete time expressions called the time anchors. <p> STOP ((startdtcond.#: -1)) #ifdef SimOpen monitor sim open: STARVATION ((Elev.open <ref> [1] </ref>*Elev.open [2]) + (Elev.open [2]*Elev.open [3]) + (Elev.open [1]*Elev.open [3]), false) #else #ifdef DoorsMove monitor closemove: STARVATION ((Elev.Current.up: 1)*(Elev Env.door open: 1) + (Elev.Current.dn: 1)*(Elev Env.door open: 1), false) #else #ifdef DoorsAt monitor doors at floors: STARVATION ((Elev.open [1]*(Elev Env.at [1]: 0)) + (Elev.open [2]*(Elev Env.at [2]: 0)) + (Elev.open [3]*(Elev Env.at [3]: 0)), false) #else B. COSPAN Verification of Elevator Controller 278 #ifdef ReqAns #ifdef f1 monitor req ans1: STARVATION ((Elev Env.req [1]: 1)+(Elev Env.req up [1]: 1)+ (Elev Env.req dn [1]: 1), (Elev Env.at [1]: 1)) #else #ifdef f2 <p> (Elev.Current.dn: 1)*(Elev Env.door open: 1), false) #else #ifdef DoorsAt monitor doors at floors: STARVATION ((Elev.open <ref> [1] </ref>*(Elev Env.at [1]: 0)) + (Elev.open [2]*(Elev Env.at [2]: 0)) + (Elev.open [3]*(Elev Env.at [3]: 0)), false) #else B. COSPAN Verification of Elevator Controller 278 #ifdef ReqAns #ifdef f1 monitor req ans1: STARVATION ((Elev Env.req [1]: 1)+(Elev Env.req up [1]: 1)+ (Elev Env.req dn [1]: 1), (Elev Env.at [1]: 1)) #else #ifdef f2 monitor req ans2: STARVATION ((Elev Env.req [2]: 1)+(Elev Env.req up [2]: 1)+ (Elev Env.req dn [2]: 1), (Elev Env.at [2]: 1)) #else monitor req ans3: STARVATION ((Elev Env.req [3]: 1)+(Elev Env.req up [3]: <p> 1), false) #else #ifdef DoorsAt monitor doors at floors: STARVATION ((Elev.open <ref> [1] </ref>*(Elev Env.at [1]: 0)) + (Elev.open [2]*(Elev Env.at [2]: 0)) + (Elev.open [3]*(Elev Env.at [3]: 0)), false) #else B. COSPAN Verification of Elevator Controller 278 #ifdef ReqAns #ifdef f1 monitor req ans1: STARVATION ((Elev Env.req [1]: 1)+(Elev Env.req up [1]: 1)+ (Elev Env.req dn [1]: 1), (Elev Env.at [1]: 1)) #else #ifdef f2 monitor req ans2: STARVATION ((Elev Env.req [2]: 1)+(Elev Env.req up [2]: 1)+ (Elev Env.req dn [2]: 1), (Elev Env.at [2]: 1)) #else monitor req ans3: STARVATION ((Elev Env.req [3]: 1)+(Elev Env.req up [3]: 1)+ (Elev Env.req dn <p> monitor doors at floors: STARVATION ((Elev.open <ref> [1] </ref>*(Elev Env.at [1]: 0)) + (Elev.open [2]*(Elev Env.at [2]: 0)) + (Elev.open [3]*(Elev Env.at [3]: 0)), false) #else B. COSPAN Verification of Elevator Controller 278 #ifdef ReqAns #ifdef f1 monitor req ans1: STARVATION ((Elev Env.req [1]: 1)+(Elev Env.req up [1]: 1)+ (Elev Env.req dn [1]: 1), (Elev Env.at [1]: 1)) #else #ifdef f2 monitor req ans2: STARVATION ((Elev Env.req [2]: 1)+(Elev Env.req up [2]: 1)+ (Elev Env.req dn [2]: 1), (Elev Env.at [2]: 1)) #else monitor req ans3: STARVATION ((Elev Env.req [3]: 1)+(Elev Env.req up [3]: 1)+ (Elev Env.req dn [3]: 1), (Elev Env.at [3]: <p> STARVATION ((Elev.open <ref> [1] </ref>*(Elev Env.at [1]: 0)) + (Elev.open [2]*(Elev Env.at [2]: 0)) + (Elev.open [3]*(Elev Env.at [3]: 0)), false) #else B. COSPAN Verification of Elevator Controller 278 #ifdef ReqAns #ifdef f1 monitor req ans1: STARVATION ((Elev Env.req [1]: 1)+(Elev Env.req up [1]: 1)+ (Elev Env.req dn [1]: 1), (Elev Env.at [1]: 1)) #else #ifdef f2 monitor req ans2: STARVATION ((Elev Env.req [2]: 1)+(Elev Env.req up [2]: 1)+ (Elev Env.req dn [2]: 1), (Elev Env.at [2]: 1)) #else monitor req ans3: STARVATION ((Elev Env.req [3]: 1)+(Elev Env.req up [3]: 1)+ (Elev Env.req dn [3]: 1), (Elev Env.at [3]: 1)) #endif #endif #else <p> ((Elev Env.req [2]: 1)+(Elev Env.req up [2]: 1)+ (Elev Env.req dn [2]: 1), (Elev Env.at [2]: 1)) #else monitor req ans3: STARVATION ((Elev Env.req [3]: 1)+(Elev Env.req up [3]: 1)+ (Elev Env.req dn [3]: 1), (Elev Env.at [3]: 1)) #endif #endif #else #ifdef ReqToOpen #ifdef f1 monitor open1: STARVATION (Elev.open <ref> [1] </ref>* ~ ((Elev Env.req [1]: 1) + (Elev Env.req up [1]: 1) + (Elev Env.req dn [1]: 1)), false) #endif #ifdef f2 monitor open2: STARVATION (Elev.open [2]* ~ ((Elev Env.req [2]: 1) + (Elev Env.req up [2]: 1) + (Elev Env.req dn [2]: 1)), false) #endif #ifdef f3 monitor open3: STARVATION <p> Env.req up [2]: 1)+ (Elev Env.req dn [2]: 1), (Elev Env.at [2]: 1)) #else monitor req ans3: STARVATION ((Elev Env.req [3]: 1)+(Elev Env.req up [3]: 1)+ (Elev Env.req dn [3]: 1), (Elev Env.at [3]: 1)) #endif #endif #else #ifdef ReqToOpen #ifdef f1 monitor open1: STARVATION (Elev.open <ref> [1] </ref>* ~ ((Elev Env.req [1]: 1) + (Elev Env.req up [1]: 1) + (Elev Env.req dn [1]: 1)), false) #endif #ifdef f2 monitor open2: STARVATION (Elev.open [2]* ~ ((Elev Env.req [2]: 1) + (Elev Env.req up [2]: 1) + (Elev Env.req dn [2]: 1)), false) #endif #ifdef f3 monitor open3: STARVATION (Elev.open [3]* ~ ((Elev <p> dn [2]: 1), (Elev Env.at [2]: 1)) #else monitor req ans3: STARVATION ((Elev Env.req [3]: 1)+(Elev Env.req up [3]: 1)+ (Elev Env.req dn [3]: 1), (Elev Env.at [3]: 1)) #endif #endif #else #ifdef ReqToOpen #ifdef f1 monitor open1: STARVATION (Elev.open <ref> [1] </ref>* ~ ((Elev Env.req [1]: 1) + (Elev Env.req up [1]: 1) + (Elev Env.req dn [1]: 1)), false) #endif #ifdef f2 monitor open2: STARVATION (Elev.open [2]* ~ ((Elev Env.req [2]: 1) + (Elev Env.req up [2]: 1) + (Elev Env.req dn [2]: 1)), false) #endif #ifdef f3 monitor open3: STARVATION (Elev.open [3]* ~ ((Elev Env.req [3]: 1) + (Elev Env.req <p> 1)) #else monitor req ans3: STARVATION ((Elev Env.req [3]: 1)+(Elev Env.req up [3]: 1)+ (Elev Env.req dn [3]: 1), (Elev Env.at [3]: 1)) #endif #endif #else #ifdef ReqToOpen #ifdef f1 monitor open1: STARVATION (Elev.open <ref> [1] </ref>* ~ ((Elev Env.req [1]: 1) + (Elev Env.req up [1]: 1) + (Elev Env.req dn [1]: 1)), false) #endif #ifdef f2 monitor open2: STARVATION (Elev.open [2]* ~ ((Elev Env.req [2]: 1) + (Elev Env.req up [2]: 1) + (Elev Env.req dn [2]: 1)), false) #endif #ifdef f3 monitor open3: STARVATION (Elev.open [3]* ~ ((Elev Env.req [3]: 1) + (Elev Env.req up [3]: 1) + (Elev Env.req <p> $ ! 3 ? (Elev Env.req [3]: 1) j 2 ? else*((Elev Env.req [2]: 1)+(Elev Env.req up [2]: 1)) j 1 monitor lowest dn req import Elev Env stvar $ : (min floor..max floor) selvar # := $ init $ := max floor asgn $ ! 1 ? (Elev Env.req <ref> [1] </ref>: 1) j 2 ? else*((Elev Env.req [2]: 1)+(Elev Env.req dn [2]: 1)) j 3 #ifdef Up monitor catch max up import Elev Env, Elev, highest up req stvar $ : (0, 1, -1) cyset $=0 recur 0 ! 1 init $ := 0 asgn $ ! 1 ? ($ = <p> asgn $ ! 1 ? ($ = 0)*(Elev.Current.$ &gt; 2)* ~ (Elev.open [2]: 1)*((Elev Env.req [2]: 1)+ (Elev Env.req dn [2]: 1)) j 0 ? ($ = 1)*(Elev.open [2]: 1) j -1 ? ($ = 1)*(Elev.Current.$ &lt; 2) j $ #endif #else #ifdef DoorClose #ifdef f1 monitor close1: STARVATION ((Elev.open <ref> [1] </ref>: 1), (Elev Env.door open: 0)) #else #ifdef f2 monitor close2: STARVATION ((Elev.open [2]: 1), (Elev Env.door open: 0)) B. COSPAN Verification of Elevator Controller 281 #else monitor close3: STARVATION ((Elev.open [3]: 1), (Elev Env.door open: 0)) #endif #endif #endif #endif #endif #endif #endif #endif #endif #endif
Reference: [2] <author> Rajeev Alur. </author> <title> Techniques for Automated Verification of Real-time Systems. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <year> 1991. </year>
Reference-contexts: Proof 1 Given Given Inverter Rules [Rule 33] Delay Rules [Rule 35] And Rules [Rule 34] Bounds Slide [Rule 17] 5. Examples 241 Simplification [Rule 42] CTR Or Intro [Rule 37] 5.2 The Elevator Controller Timing constraints are generally handled in verification through timed automata <ref> [2] </ref>. Most timed automata models, however, accept only concrete constraints, rather than symbolic or parametric constraints. An extension of timed automata to handling certain parametric constraints appears in [3]; tool support for these techniques is still forthcoming. The goal is to design a controller for a three-floor elevator. <p> = 1)) j -1 ? ($ = 1) * Elev.Floors [1].start dt j 0 ? ($ = 1) * (Elev.Floors [1].start dt + ( ~ Elev.Floors <ref> [2] </ref>.start dt * ~ Elev.Floors [3].start dt)) j $ end startdtcond monitor dttest: STOP ((startdtcond.#: -1)) #ifdef SimOpen monitor sim open: STARVATION ((Elev.open [1]*Elev.open [2]) + (Elev.open [2]*Elev.open [3]) + (Elev.open [1]*Elev.open [3]), false) #else #ifdef DoorsMove monitor closemove: STARVATION ((Elev.Current.up: 1)*(Elev Env.door open: 1) + (Elev.Current.dn: 1)*(Elev Env.door open: 1), false) #else #ifdef DoorsAt monitor doors at floors: STARVATION ((Elev.open [1]*(Elev Env.at [1]: 0)) + (Elev.open [2]*(Elev Env.at [2]: 0)) + (Elev.open [3]*(Elev Env.at <p> sim open: STARVATION ((Elev.open [1]*Elev.open <ref> [2] </ref>) + (Elev.open [2]*Elev.open [3]) + (Elev.open [1]*Elev.open [3]), false) #else #ifdef DoorsMove monitor closemove: STARVATION ((Elev.Current.up: 1)*(Elev Env.door open: 1) + (Elev.Current.dn: 1)*(Elev Env.door open: 1), false) #else #ifdef DoorsAt monitor doors at floors: STARVATION ((Elev.open [1]*(Elev Env.at [1]: 0)) + (Elev.open [2]*(Elev Env.at [2]: 0)) + (Elev.open [3]*(Elev Env.at [3]: 0)), false) #else B. <p> COSPAN Verification of Elevator Controller 278 #ifdef ReqAns #ifdef f1 monitor req ans1: STARVATION ((Elev Env.req [1]: 1)+(Elev Env.req up [1]: 1)+ (Elev Env.req dn [1]: 1), (Elev Env.at [1]: 1)) #else #ifdef f2 monitor req ans2: STARVATION ((Elev Env.req <ref> [2] </ref>: 1)+(Elev Env.req up [2]: 1)+ (Elev Env.req dn [2]: 1), (Elev Env.at [2]: 1)) #else monitor req ans3: STARVATION ((Elev Env.req [3]: 1)+(Elev Env.req up [3]: 1)+ (Elev Env.req dn [3]: 1), (Elev Env.at [3]: 1)) #endif #endif #else #ifdef ReqToOpen #ifdef f1 monitor open1: STARVATION (Elev.open [1]* ~ ((Elev <p> COSPAN Verification of Elevator Controller 278 #ifdef ReqAns #ifdef f1 monitor req ans1: STARVATION ((Elev Env.req [1]: 1)+(Elev Env.req up [1]: 1)+ (Elev Env.req dn [1]: 1), (Elev Env.at [1]: 1)) #else #ifdef f2 monitor req ans2: STARVATION ((Elev Env.req <ref> [2] </ref>: 1)+(Elev Env.req up [2]: 1)+ (Elev Env.req dn [2]: 1), (Elev Env.at [2]: 1)) #else monitor req ans3: STARVATION ((Elev Env.req [3]: 1)+(Elev Env.req up [3]: 1)+ (Elev Env.req dn [3]: 1), (Elev Env.at [3]: 1)) #endif #endif #else #ifdef ReqToOpen #ifdef f1 monitor open1: STARVATION (Elev.open [1]* ~ ((Elev Env.req [1]: 1) + <p> COSPAN Verification of Elevator Controller 278 #ifdef ReqAns #ifdef f1 monitor req ans1: STARVATION ((Elev Env.req [1]: 1)+(Elev Env.req up [1]: 1)+ (Elev Env.req dn [1]: 1), (Elev Env.at [1]: 1)) #else #ifdef f2 monitor req ans2: STARVATION ((Elev Env.req <ref> [2] </ref>: 1)+(Elev Env.req up [2]: 1)+ (Elev Env.req dn [2]: 1), (Elev Env.at [2]: 1)) #else monitor req ans3: STARVATION ((Elev Env.req [3]: 1)+(Elev Env.req up [3]: 1)+ (Elev Env.req dn [3]: 1), (Elev Env.at [3]: 1)) #endif #endif #else #ifdef ReqToOpen #ifdef f1 monitor open1: STARVATION (Elev.open [1]* ~ ((Elev Env.req [1]: 1) + (Elev Env.req up [1]: 1) <p> Elevator Controller 278 #ifdef ReqAns #ifdef f1 monitor req ans1: STARVATION ((Elev Env.req [1]: 1)+(Elev Env.req up [1]: 1)+ (Elev Env.req dn [1]: 1), (Elev Env.at [1]: 1)) #else #ifdef f2 monitor req ans2: STARVATION ((Elev Env.req <ref> [2] </ref>: 1)+(Elev Env.req up [2]: 1)+ (Elev Env.req dn [2]: 1), (Elev Env.at [2]: 1)) #else monitor req ans3: STARVATION ((Elev Env.req [3]: 1)+(Elev Env.req up [3]: 1)+ (Elev Env.req dn [3]: 1), (Elev Env.at [3]: 1)) #endif #endif #else #ifdef ReqToOpen #ifdef f1 monitor open1: STARVATION (Elev.open [1]* ~ ((Elev Env.req [1]: 1) + (Elev Env.req up [1]: 1) + (Elev Env.req dn <p> Env.req up [3]: 1)+ (Elev Env.req dn [3]: 1), (Elev Env.at [3]: 1)) #endif #endif #else #ifdef ReqToOpen #ifdef f1 monitor open1: STARVATION (Elev.open [1]* ~ ((Elev Env.req [1]: 1) + (Elev Env.req up [1]: 1) + (Elev Env.req dn [1]: 1)), false) #endif #ifdef f2 monitor open2: STARVATION (Elev.open <ref> [2] </ref>* ~ ((Elev Env.req [2]: 1) + (Elev Env.req up [2]: 1) + (Elev Env.req dn [2]: 1)), false) #endif #ifdef f3 monitor open3: STARVATION (Elev.open [3]* ~ ((Elev Env.req [3]: 1) + (Elev Env.req up [3]: 1) + (Elev Env.req dn [3]: 1)), false) #endif #else #ifdef DirChange B. <p> (Elev Env.req dn [3]: 1), (Elev Env.at [3]: 1)) #endif #endif #else #ifdef ReqToOpen #ifdef f1 monitor open1: STARVATION (Elev.open [1]* ~ ((Elev Env.req [1]: 1) + (Elev Env.req up [1]: 1) + (Elev Env.req dn [1]: 1)), false) #endif #ifdef f2 monitor open2: STARVATION (Elev.open <ref> [2] </ref>* ~ ((Elev Env.req [2]: 1) + (Elev Env.req up [2]: 1) + (Elev Env.req dn [2]: 1)), false) #endif #ifdef f3 monitor open3: STARVATION (Elev.open [3]* ~ ((Elev Env.req [3]: 1) + (Elev Env.req up [3]: 1) + (Elev Env.req dn [3]: 1)), false) #endif #else #ifdef DirChange B. <p> Env.at [3]: 1)) #endif #endif #else #ifdef ReqToOpen #ifdef f1 monitor open1: STARVATION (Elev.open [1]* ~ ((Elev Env.req [1]: 1) + (Elev Env.req up [1]: 1) + (Elev Env.req dn [1]: 1)), false) #endif #ifdef f2 monitor open2: STARVATION (Elev.open <ref> [2] </ref>* ~ ((Elev Env.req [2]: 1) + (Elev Env.req up [2]: 1) + (Elev Env.req dn [2]: 1)), false) #endif #ifdef f3 monitor open3: STARVATION (Elev.open [3]* ~ ((Elev Env.req [3]: 1) + (Elev Env.req up [3]: 1) + (Elev Env.req dn [3]: 1)), false) #endif #else #ifdef DirChange B. <p> #ifdef ReqToOpen #ifdef f1 monitor open1: STARVATION (Elev.open [1]* ~ ((Elev Env.req [1]: 1) + (Elev Env.req up [1]: 1) + (Elev Env.req dn [1]: 1)), false) #endif #ifdef f2 monitor open2: STARVATION (Elev.open <ref> [2] </ref>* ~ ((Elev Env.req [2]: 1) + (Elev Env.req up [2]: 1) + (Elev Env.req dn [2]: 1)), false) #endif #ifdef f3 monitor open3: STARVATION (Elev.open [3]* ~ ((Elev Env.req [3]: 1) + (Elev Env.req up [3]: 1) + (Elev Env.req dn [3]: 1)), false) #endif #else #ifdef DirChange B. <p> COSPAN Verification of Elevator Controller 279 monitor highest up req import Elev Env stvar $ : (min floor..max floor) selvar # := $ init $ := min floor asgn $ ! 3 ? (Elev Env.req [3]: 1) j 2 ? else*((Elev Env.req <ref> [2] </ref>: 1)+(Elev Env.req up [2]: 1)) j 1 monitor lowest dn req import Elev Env stvar $ : (min floor..max floor) selvar # := $ init $ := max floor asgn $ ! 1 ? (Elev Env.req [1]: 1) j 2 ? else*((Elev Env.req [2]: 1)+(Elev Env.req dn [2]: 1)) j <p> COSPAN Verification of Elevator Controller 279 monitor highest up req import Elev Env stvar $ : (min floor..max floor) selvar # := $ init $ := min floor asgn $ ! 3 ? (Elev Env.req [3]: 1) j 2 ? else*((Elev Env.req <ref> [2] </ref>: 1)+(Elev Env.req up [2]: 1)) j 1 monitor lowest dn req import Elev Env stvar $ : (min floor..max floor) selvar # := $ init $ := max floor asgn $ ! 1 ? (Elev Env.req [1]: 1) j 2 ? else*((Elev Env.req [2]: 1)+(Elev Env.req dn [2]: 1)) j 3 #ifdef Up monitor <p> 1) j 2 ? else*((Elev Env.req <ref> [2] </ref>: 1)+(Elev Env.req up [2]: 1)) j 1 monitor lowest dn req import Elev Env stvar $ : (min floor..max floor) selvar # := $ init $ := max floor asgn $ ! 1 ? (Elev Env.req [1]: 1) j 2 ? else*((Elev Env.req [2]: 1)+(Elev Env.req dn [2]: 1)) j 3 #ifdef Up monitor catch max up import Elev Env, Elev, highest up req stvar $ : (0, 1, -1) cyset $=0 recur 0 ! 1 init $ := 0 asgn $ ! 1 ? ($ = 0)*(Elev.Current.$ &lt; highest up req.$)*(Elev.moving up: 1) <p> else*((Elev Env.req <ref> [2] </ref>: 1)+(Elev Env.req up [2]: 1)) j 1 monitor lowest dn req import Elev Env stvar $ : (min floor..max floor) selvar # := $ init $ := max floor asgn $ ! 1 ? (Elev Env.req [1]: 1) j 2 ? else*((Elev Env.req [2]: 1)+(Elev Env.req dn [2]: 1)) j 3 #ifdef Up monitor catch max up import Elev Env, Elev, highest up req stvar $ : (0, 1, -1) cyset $=0 recur 0 ! 1 init $ := 0 asgn $ ! 1 ? ($ = 0)*(Elev.Current.$ &lt; highest up req.$)*(Elev.moving up: 1) j 0 ? ($ <p> COSPAN Verification of Elevator Controller 280 #endif #else #ifdef CatchAll #ifdef up2 monitor catch all up import Elev, Elev Env stvar $ : (0, 1, -1) cyset $=0 recur 1 ! 0 init $ := 0 asgn $ ! 1 ? ($ = 0)*(Elev.Current.$ &lt; 2)* ~ (Elev.open <ref> [2] </ref>: 1)*((Elev Env.req [2]: 1)+ (Elev Env.req up [2]: 1)) j 0 ? ($ = 1)*(Elev.open [2]: 1) j -1 ? ($ = 1)*(Elev.Current.$ &gt; 2) j $ #endif #ifdef dn2 monitor catch all dn import Elev, Elev Env stvar $ : (0, 1, -1) cyset $=0 recur 1 ! 0 <p> Verification of Elevator Controller 280 #endif #else #ifdef CatchAll #ifdef up2 monitor catch all up import Elev, Elev Env stvar $ : (0, 1, -1) cyset $=0 recur 1 ! 0 init $ := 0 asgn $ ! 1 ? ($ = 0)*(Elev.Current.$ &lt; 2)* ~ (Elev.open <ref> [2] </ref>: 1)*((Elev Env.req [2]: 1)+ (Elev Env.req up [2]: 1)) j 0 ? ($ = 1)*(Elev.open [2]: 1) j -1 ? ($ = 1)*(Elev.Current.$ &gt; 2) j $ #endif #ifdef dn2 monitor catch all dn import Elev, Elev Env stvar $ : (0, 1, -1) cyset $=0 recur 1 ! 0 init $ := <p> #endif #else #ifdef CatchAll #ifdef up2 monitor catch all up import Elev, Elev Env stvar $ : (0, 1, -1) cyset $=0 recur 1 ! 0 init $ := 0 asgn $ ! 1 ? ($ = 0)*(Elev.Current.$ &lt; 2)* ~ (Elev.open <ref> [2] </ref>: 1)*((Elev Env.req [2]: 1)+ (Elev Env.req up [2]: 1)) j 0 ? ($ = 1)*(Elev.open [2]: 1) j -1 ? ($ = 1)*(Elev.Current.$ &gt; 2) j $ #endif #ifdef dn2 monitor catch all dn import Elev, Elev Env stvar $ : (0, 1, -1) cyset $=0 recur 1 ! 0 init $ := 0 asgn $ ! 1 <p> all up import Elev, Elev Env stvar $ : (0, 1, -1) cyset $=0 recur 1 ! 0 init $ := 0 asgn $ ! 1 ? ($ = 0)*(Elev.Current.$ &lt; 2)* ~ (Elev.open <ref> [2] </ref>: 1)*((Elev Env.req [2]: 1)+ (Elev Env.req up [2]: 1)) j 0 ? ($ = 1)*(Elev.open [2]: 1) j -1 ? ($ = 1)*(Elev.Current.$ &gt; 2) j $ #endif #ifdef dn2 monitor catch all dn import Elev, Elev Env stvar $ : (0, 1, -1) cyset $=0 recur 1 ! 0 init $ := 0 asgn $ ! 1 ? ($ = 0)*(Elev.Current.$ &gt; 2)* ~ (Elev.open <p> 1) j -1 ? ($ = 1)*(Elev.Current.$ &gt; 2) j $ #endif #ifdef dn2 monitor catch all dn import Elev, Elev Env stvar $ : (0, 1, -1) cyset $=0 recur 1 ! 0 init $ := 0 asgn $ ! 1 ? ($ = 0)*(Elev.Current.$ &gt; 2)* ~ (Elev.open <ref> [2] </ref>: 1)*((Elev Env.req [2]: 1)+ (Elev Env.req dn [2]: 1)) j 0 ? ($ = 1)*(Elev.open [2]: 1) j -1 ? ($ = 1)*(Elev.Current.$ &lt; 2) j $ #endif #else #ifdef DoorClose #ifdef f1 monitor close1: STARVATION ((Elev.open [1]: 1), (Elev Env.door open: 0)) #else #ifdef f2 monitor close2: STARVATION ((Elev.open <p> ? ($ = 1)*(Elev.Current.$ &gt; 2) j $ #endif #ifdef dn2 monitor catch all dn import Elev, Elev Env stvar $ : (0, 1, -1) cyset $=0 recur 1 ! 0 init $ := 0 asgn $ ! 1 ? ($ = 0)*(Elev.Current.$ &gt; 2)* ~ (Elev.open <ref> [2] </ref>: 1)*((Elev Env.req [2]: 1)+ (Elev Env.req dn [2]: 1)) j 0 ? ($ = 1)*(Elev.open [2]: 1) j -1 ? ($ = 1)*(Elev.Current.$ &lt; 2) j $ #endif #else #ifdef DoorClose #ifdef f1 monitor close1: STARVATION ((Elev.open [1]: 1), (Elev Env.door open: 0)) #else #ifdef f2 monitor close2: STARVATION ((Elev.open [2]: 1), (Elev <p> 2) j $ #endif #ifdef dn2 monitor catch all dn import Elev, Elev Env stvar $ : (0, 1, -1) cyset $=0 recur 1 ! 0 init $ := 0 asgn $ ! 1 ? ($ = 0)*(Elev.Current.$ &gt; 2)* ~ (Elev.open <ref> [2] </ref>: 1)*((Elev Env.req [2]: 1)+ (Elev Env.req dn [2]: 1)) j 0 ? ($ = 1)*(Elev.open [2]: 1) j -1 ? ($ = 1)*(Elev.Current.$ &lt; 2) j $ #endif #else #ifdef DoorClose #ifdef f1 monitor close1: STARVATION ((Elev.open [1]: 1), (Elev Env.door open: 0)) #else #ifdef f2 monitor close2: STARVATION ((Elev.open [2]: 1), (Elev Env.door open: 0)) B. <p> all dn import Elev, Elev Env stvar $ : (0, 1, -1) cyset $=0 recur 1 ! 0 init $ := 0 asgn $ ! 1 ? ($ = 0)*(Elev.Current.$ &gt; 2)* ~ (Elev.open <ref> [2] </ref>: 1)*((Elev Env.req [2]: 1)+ (Elev Env.req dn [2]: 1)) j 0 ? ($ = 1)*(Elev.open [2]: 1) j -1 ? ($ = 1)*(Elev.Current.$ &lt; 2) j $ #endif #else #ifdef DoorClose #ifdef f1 monitor close1: STARVATION ((Elev.open [1]: 1), (Elev Env.door open: 0)) #else #ifdef f2 monitor close2: STARVATION ((Elev.open [2]: 1), (Elev Env.door open: 0)) B. <p> 1)*((Elev Env.req <ref> [2] </ref>: 1)+ (Elev Env.req dn [2]: 1)) j 0 ? ($ = 1)*(Elev.open [2]: 1) j -1 ? ($ = 1)*(Elev.Current.$ &lt; 2) j $ #endif #else #ifdef DoorClose #ifdef f1 monitor close1: STARVATION ((Elev.open [1]: 1), (Elev Env.door open: 0)) #else #ifdef f2 monitor close2: STARVATION ((Elev.open [2]: 1), (Elev Env.door open: 0)) B. COSPAN Verification of Elevator Controller 281 #else monitor close3: STARVATION ((Elev.open [3]: 1), (Elev Env.door open: 0)) #endif #endif #endif #endif #endif #endif #endif #endif #endif #endif
Reference: [3] <author> Rajeev Alur, Thomas A. Henzinger, and Moshe Y. Vardi. </author> <title> Parametric real-time reasoning. </title> <booktitle> In Proceedings of the 25th ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 592-601, </pages> <year> 1993. </year>
Reference-contexts: Their characterizations are based partially on the structural features of the machines accepting the languages. Alur, Henzinger, and Vardi have studied timed automata with symbolic, as opposed to strictly concrete, real-time constraints <ref> [3] </ref>. Their work is the most closely related to the decidability results in Chapter 3. They extended a timed automata model with sets of clocks that all progress at the same rate. <p> Syntax and Semantics 105 where timeout represents a constant amount of discrete time. The abstract component treats timeout as a parameter. Support for parameterized time constraints is an important issue in verification because concrete time constraints are often too specific for general-purpose verification <ref> [3] </ref>. <p> Most timed automata models, however, accept only concrete constraints, rather than symbolic or parametric constraints. An extension of timed automata to handling certain parametric constraints appears in <ref> [3] </ref>; tool support for these techniques is still forthcoming. The goal is to design a controller for a three-floor elevator. The elevator should be equipped with an alarm that goes off if the door is kept open past a certain amount of time. <p> ? ($ = 1) * Elev.Floors [1].start dt j 0 ? ($ = 1) * (Elev.Floors [1].start dt + ( ~ Elev.Floors [2].start dt * ~ Elev.Floors <ref> [3] </ref>.start dt)) j $ end startdtcond monitor dttest: STOP ((startdtcond.#: -1)) #ifdef SimOpen monitor sim open: STARVATION ((Elev.open [1]*Elev.open [2]) + (Elev.open [2]*Elev.open [3]) + (Elev.open [1]*Elev.open [3]), false) #else #ifdef DoorsMove monitor closemove: STARVATION ((Elev.Current.up: 1)*(Elev Env.door open: 1) + (Elev.Current.dn: 1)*(Elev Env.door open: 1), false) #else #ifdef DoorsAt monitor doors at floors: STARVATION ((Elev.open [1]*(Elev Env.at [1]: 0)) + (Elev.open [2]*(Elev Env.at [2]: 0)) + (Elev.open [3]*(Elev Env.at [3]: 0)), false) #else <p> * Elev.Floors [1].start dt j 0 ? ($ = 1) * (Elev.Floors [1].start dt + ( ~ Elev.Floors [2].start dt * ~ Elev.Floors <ref> [3] </ref>.start dt)) j $ end startdtcond monitor dttest: STOP ((startdtcond.#: -1)) #ifdef SimOpen monitor sim open: STARVATION ((Elev.open [1]*Elev.open [2]) + (Elev.open [2]*Elev.open [3]) + (Elev.open [1]*Elev.open [3]), false) #else #ifdef DoorsMove monitor closemove: STARVATION ((Elev.Current.up: 1)*(Elev Env.door open: 1) + (Elev.Current.dn: 1)*(Elev Env.door open: 1), false) #else #ifdef DoorsAt monitor doors at floors: STARVATION ((Elev.open [1]*(Elev Env.at [1]: 0)) + (Elev.open [2]*(Elev Env.at [2]: 0)) + (Elev.open [3]*(Elev Env.at [3]: 0)), false) #else B. <p> + (Elev.open [2]*Elev.open <ref> [3] </ref>) + (Elev.open [1]*Elev.open [3]), false) #else #ifdef DoorsMove monitor closemove: STARVATION ((Elev.Current.up: 1)*(Elev Env.door open: 1) + (Elev.Current.dn: 1)*(Elev Env.door open: 1), false) #else #ifdef DoorsAt monitor doors at floors: STARVATION ((Elev.open [1]*(Elev Env.at [1]: 0)) + (Elev.open [2]*(Elev Env.at [2]: 0)) + (Elev.open [3]*(Elev Env.at [3]: 0)), false) #else B. <p> ans1: STARVATION ((Elev Env.req [1]: 1)+(Elev Env.req up [1]: 1)+ (Elev Env.req dn [1]: 1), (Elev Env.at [1]: 1)) #else #ifdef f2 monitor req ans2: STARVATION ((Elev Env.req [2]: 1)+(Elev Env.req up [2]: 1)+ (Elev Env.req dn [2]: 1), (Elev Env.at [2]: 1)) #else monitor req ans3: STARVATION ((Elev Env.req <ref> [3] </ref>: 1)+(Elev Env.req up [3]: 1)+ (Elev Env.req dn [3]: 1), (Elev Env.at [3]: 1)) #endif #endif #else #ifdef ReqToOpen #ifdef f1 monitor open1: STARVATION (Elev.open [1]* ~ ((Elev Env.req [1]: 1) + (Elev Env.req up [1]: 1) + (Elev Env.req dn [1]: 1)), false) #endif #ifdef f2 monitor open2: STARVATION <p> [1]: 1)+(Elev Env.req up [1]: 1)+ (Elev Env.req dn [1]: 1), (Elev Env.at [1]: 1)) #else #ifdef f2 monitor req ans2: STARVATION ((Elev Env.req [2]: 1)+(Elev Env.req up [2]: 1)+ (Elev Env.req dn [2]: 1), (Elev Env.at [2]: 1)) #else monitor req ans3: STARVATION ((Elev Env.req <ref> [3] </ref>: 1)+(Elev Env.req up [3]: 1)+ (Elev Env.req dn [3]: 1), (Elev Env.at [3]: 1)) #endif #endif #else #ifdef ReqToOpen #ifdef f1 monitor open1: STARVATION (Elev.open [1]* ~ ((Elev Env.req [1]: 1) + (Elev Env.req up [1]: 1) + (Elev Env.req dn [1]: 1)), false) #endif #ifdef f2 monitor open2: STARVATION (Elev.open [2]* ~ ((Elev <p> 1)+ (Elev Env.req dn [1]: 1), (Elev Env.at [1]: 1)) #else #ifdef f2 monitor req ans2: STARVATION ((Elev Env.req [2]: 1)+(Elev Env.req up [2]: 1)+ (Elev Env.req dn [2]: 1), (Elev Env.at [2]: 1)) #else monitor req ans3: STARVATION ((Elev Env.req <ref> [3] </ref>: 1)+(Elev Env.req up [3]: 1)+ (Elev Env.req dn [3]: 1), (Elev Env.at [3]: 1)) #endif #endif #else #ifdef ReqToOpen #ifdef f1 monitor open1: STARVATION (Elev.open [1]* ~ ((Elev Env.req [1]: 1) + (Elev Env.req up [1]: 1) + (Elev Env.req dn [1]: 1)), false) #endif #ifdef f2 monitor open2: STARVATION (Elev.open [2]* ~ ((Elev Env.req [2]: 1) + (Elev <p> [1]: 1), (Elev Env.at [1]: 1)) #else #ifdef f2 monitor req ans2: STARVATION ((Elev Env.req [2]: 1)+(Elev Env.req up [2]: 1)+ (Elev Env.req dn [2]: 1), (Elev Env.at [2]: 1)) #else monitor req ans3: STARVATION ((Elev Env.req <ref> [3] </ref>: 1)+(Elev Env.req up [3]: 1)+ (Elev Env.req dn [3]: 1), (Elev Env.at [3]: 1)) #endif #endif #else #ifdef ReqToOpen #ifdef f1 monitor open1: STARVATION (Elev.open [1]* ~ ((Elev Env.req [1]: 1) + (Elev Env.req up [1]: 1) + (Elev Env.req dn [1]: 1)), false) #endif #ifdef f2 monitor open2: STARVATION (Elev.open [2]* ~ ((Elev Env.req [2]: 1) + (Elev Env.req up [2]: 1) <p> ((Elev Env.req [1]: 1) + (Elev Env.req up [1]: 1) + (Elev Env.req dn [1]: 1)), false) #endif #ifdef f2 monitor open2: STARVATION (Elev.open [2]* ~ ((Elev Env.req [2]: 1) + (Elev Env.req up [2]: 1) + (Elev Env.req dn [2]: 1)), false) #endif #ifdef f3 monitor open3: STARVATION (Elev.open <ref> [3] </ref>* ~ ((Elev Env.req [3]: 1) + (Elev Env.req up [3]: 1) + (Elev Env.req dn [3]: 1)), false) #endif #else #ifdef DirChange B. <p> + (Elev Env.req up [1]: 1) + (Elev Env.req dn [1]: 1)), false) #endif #ifdef f2 monitor open2: STARVATION (Elev.open [2]* ~ ((Elev Env.req [2]: 1) + (Elev Env.req up [2]: 1) + (Elev Env.req dn [2]: 1)), false) #endif #ifdef f3 monitor open3: STARVATION (Elev.open <ref> [3] </ref>* ~ ((Elev Env.req [3]: 1) + (Elev Env.req up [3]: 1) + (Elev Env.req dn [3]: 1)), false) #endif #else #ifdef DirChange B. <p> + (Elev Env.req dn [1]: 1)), false) #endif #ifdef f2 monitor open2: STARVATION (Elev.open [2]* ~ ((Elev Env.req [2]: 1) + (Elev Env.req up [2]: 1) + (Elev Env.req dn [2]: 1)), false) #endif #ifdef f3 monitor open3: STARVATION (Elev.open <ref> [3] </ref>* ~ ((Elev Env.req [3]: 1) + (Elev Env.req up [3]: 1) + (Elev Env.req dn [3]: 1)), false) #endif #else #ifdef DirChange B. COSPAN Verification of Elevator Controller 279 monitor highest up req import Elev Env stvar $ : (min floor..max floor) selvar # := $ init $ := min floor asgn $ ! 3 ? (Elev Env.req [3]: 1) <p> false) #endif #ifdef f2 monitor open2: STARVATION (Elev.open [2]* ~ ((Elev Env.req [2]: 1) + (Elev Env.req up [2]: 1) + (Elev Env.req dn [2]: 1)), false) #endif #ifdef f3 monitor open3: STARVATION (Elev.open <ref> [3] </ref>* ~ ((Elev Env.req [3]: 1) + (Elev Env.req up [3]: 1) + (Elev Env.req dn [3]: 1)), false) #endif #else #ifdef DirChange B. COSPAN Verification of Elevator Controller 279 monitor highest up req import Elev Env stvar $ : (min floor..max floor) selvar # := $ init $ := min floor asgn $ ! 3 ? (Elev Env.req [3]: 1) j 2 ? else*((Elev Env.req [2]: <p> up <ref> [3] </ref>: 1) + (Elev Env.req dn [3]: 1)), false) #endif #else #ifdef DirChange B. COSPAN Verification of Elevator Controller 279 monitor highest up req import Elev Env stvar $ : (min floor..max floor) selvar # := $ init $ := min floor asgn $ ! 3 ? (Elev Env.req [3]: 1) j 2 ? else*((Elev Env.req [2]: 1)+(Elev Env.req up [2]: 1)) j 1 monitor lowest dn req import Elev Env stvar $ : (min floor..max floor) selvar # := $ init $ := max floor asgn $ ! 1 ? (Elev Env.req [1]: 1) j 2 ? else*((Elev Env.req <p> COSPAN Verification of Elevator Controller 281 #else monitor close3: STARVATION ((Elev.open <ref> [3] </ref>: 1), (Elev Env.door open: 0)) #endif #endif #endif #endif #endif #endif #endif #endif #endif #endif
Reference: [4] <author> A. Aziz et al. HSIS: </author> <title> A BDD-based environment for formal verification. </title> <booktitle> In Proceedings of the Design Automation Conference, </booktitle> <year> 1994. </year>
Reference: [5] <author> Dave Barker-Plummer and Sidney C. Bailin. </author> <title> Proofs and pictures: Proving the Diamond Lemma with the GROVER theorem proving system. </title> <booktitle> In AAAI Symposium on Reasoning with Diagrammatic Representations, </booktitle> <month> November </month> <year> 1995. </year>
Reference: [6] <author> Dave Barker-Plummer, Sidney C. Bailin, and Samuel M. Ehrlichman. </author> <title> Diagrams and mathematics. Unpublished manuscript, Center for the Study of Language and Information (CSLI), </title> <institution> Stanford University, </institution> <month> November </month> <year> 1995. </year>
Reference: [7] <editor> Jon Barwise and John Etchemendy. Hyperproof. </editor> <publisher> CSLI Lecture Notes. University of Chicago Press, </publisher> <year> 1994. </year> <note> 282 BIBLIOGRAPHY 283 </note>
Reference-contexts: Observe, Apply, and the methods of proof are based on similar rules in Hyperproof <ref> [7] </ref>. Algebraic rules are standard in most logical calculi. The remaining rules in HHL are particular to the hardware domain, and operate over multiple syntactic representations. The rules are presented in several sections, grouped by the representations they relate.
Reference: [8] <author> Jon Barwise and John Etchemendy. </author> <title> Heterogeneous logic. </title> <editor> In Janice Glasgow, N. Hari Narayanan, and B. Chandrasekaran, editors, </editor> <booktitle> Diagrammatic Reasoning: Cognitive and Computational Perspectives, </booktitle> <pages> pages 211-234. </pages> <publisher> MIT Press, </publisher> <year> 1995. </year>
Reference-contexts: The third parallels the approach taken in logical frameworks [19]. Heterogeneous logic research advocates choosing semantic models and notations that are homomorphic, meaning structurally similar to one another and to any physical objects they describe <ref> [8] </ref>. 1 This is fairly simple in a heterogeneous logic with a single diagrammatic representation. For HHL, however, it is difficult to find a model homomorphic to both circuit diagrams and timing diagrams. Circuit diagrams describe hardware at the state level. <p> A related issue is determining a set of notations that form a suitable basis for a diagrammatic macro system. Barwise and Etchemendy have argued against the likelihood of finding a Hilbert's-program for diagrams, a set of diagrammatic notations that could capture all diagrammatic logics <ref> [8] </ref>. Accordingly, diagrammatic macro systems would likely be highly specialized to particular problem domains. 6. Conclusions 265 Finally, the work done here for hardware systems should be investigated in the context of software systems.
Reference: [9] <author> Jon Barwise and John Etchemendy. </author> <title> Logic, proof, and reasoning. </title> <editor> In Alan Makinowski, editor, </editor> <title> Companion to Logic. Blackwell, </title> <note> To appear. </note>
Reference-contexts: Once implemented, the tool will provide a framework for investigating several questions: * Which types of hardware reasoning proofs are easier to develop in HHL as opposed to existing sentential formalisms? * Diagrammatic logics have yielded more compact proofs than sentential logics in other problem domains <ref> [9] </ref>.
Reference: [10] <author> Bachi Berkane, Simona Gandrabur, and Eduard Cerny. </author> <title> Timing diagrams:semantics and timing analysis. </title> <institution> LASSO Laboratory, University of Montreal, </institution> <year> 1996. </year>
Reference: [11] <author> Orna Bernholtz, Moshe Y. Vardi, and Pierre Wolper. </author> <title> An automata-theoretic approach to branching-time model checking. </title> <booktitle> In Proceedings of Computer Aided Verification (CAV). </booktitle> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1994. </year> <note> Lecture Notes in Computer Science 818. </note>
Reference-contexts: A decision procedure for these instances would require an algorithm for constructing a finite-state automaton from a timing diagram. Similar algorithms exist from several temporal logics into automata <ref> [11] </ref> [84] [85], so such a construction seems feasible. The timing diagram containment problem is still open when T 1 is not regular. There exist 1-counter non-reversal-bounded languages that cannot be captured in any timing diagram.
Reference: [12] <author> Bhaskar Bose, Steven D. Johnson, and Shyam Pullela. </author> <title> Integrating boolean verification with formal derivation. </title> <editor> In D. Agnew, L. Claesen, and R. Camposano, editors, </editor> <booktitle> Proceedings of IFIP Conference on Hardware Description Languages and their Applications, </booktitle> <pages> pages 127-134. </pages> <publisher> Elsevier, </publisher> <month> April </month> <year> 1993. </year> <note> Also published as Technical Report No. 372, </note> <institution> Dept. of Computer Science, Indiana University. </institution>
Reference: [13] <author> R. S. Boyer and J. S. Moore. </author> <title> A Computational Logic Handbook. </title> <publisher> Academic Press, </publisher> <year> 1988. </year>
Reference: [14] <author> Robert S. Boyer and J. Strother Moore. Proof-checking, </author> <title> theorem-proving and program verification. </title> <type> Technical report, </type> <institution> Institute for Computing Science and Computer Applications, University of Texas at Austin, </institution> <month> January </month> <year> 1983. </year>
Reference: [15] <author> R.K. Brayton et al. </author> <title> VIS: A system for verification and synthesis. </title> <type> Technical Report UCB/ERL M95, </type> <institution> Electronic Research Lab, University of California at Berkeley, </institution> <year> 1995. </year>
Reference: [16] <author> I.A. Browne, Z. Manna, and H.B. Sipma. </author> <title> Generalized temporal verification diagrams. </title> <booktitle> In Foundations of Software Technology and Theoretical Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <month> December </month> <year> 1995. </year> <note> Lecture Notes in Computer Science. </note>
Reference: [17] <author> R.E. Bryant. </author> <title> Graph-based algorithms for boolean function manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-35(8):677-691, </volume> <month> August </month> <year> 1986. </year> <note> BIBLIOGRAPHY 284 </note>
Reference-contexts: Diagrams naturally represent structural and spatial information; diagrammatic logic can therefore be viewed as a form of structural logic. Structural information has already proven useful in formal methods through binary-decision diagrams, which dramatically increased the capabilities of automated verification <ref> [17, 61] </ref>; it has proven useful in mathematical theorem-proving through Barker-Plummer and Bailin's GROVER/& system. HHL provides a framework for further studies of structural information in formal methods.
Reference: [18] <author> J. Burch, E.M. Clarke, K. McMillan, D. Dill, and J. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <booktitle> In Proceedings of the Fifth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 428-439. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> June </month> <year> 1990. </year>
Reference: [19] <author> Maura Cerioli and Jose Meseguer. </author> <title> May I borrow your logic? In Proceedings of MFCS, </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <year> 1993. </year>
Reference-contexts: Single-headed arrows denote translation, double-headed arrows denote semantic linkage, and plain lines denote the assignment of semantics to syntax. logics use the second. The third parallels the approach taken in logical frameworks <ref> [19] </ref>. Heterogeneous logic research advocates choosing semantic models and notations that are homomorphic, meaning structurally similar to one another and to any physical objects they describe [8]. 1 This is fairly simple in a heterogeneous logic with a single diagrammatic representation.
Reference: [20] <author> E. Cerny and K. Khordoc. </author> <title> Interface specifications with conjunctive timing constraints: Realiz-ability and compatibility. </title> <booktitle> In Second AMAST Workshop on Real-Time Systems, </booktitle> <month> June </month> <year> 1995. </year>
Reference: [21] <author> Soma Chaudhuri and Richard E. Ladner. </author> <title> Safety and liveness of !-context-free languages. </title> <journal> Information Processing Letters, </journal> <volume> 37 </volume> <pages> 13-20, </pages> <year> 1991. </year>
Reference: [22] <author> Tam-Anh Chu. </author> <title> Synthesis of Self-timed VLSI circuits from graph-theoretic specfications. </title> <type> PhD thesis, </type> <institution> MIT, </institution> <month> June </month> <year> 1987. </year>
Reference: [23] <author> E.M. Clarke and E.A. Emerson. </author> <title> Design and synthesis of synchronization skeletons using branching-time temporal logic. </title> <booktitle> In Proceedings of the Workshop on Logics of Programs, </booktitle> <pages> pages 52-71. </pages> <publisher> Springer-Verlag, </publisher> <year> 1981. </year> <note> Lecture Notes in Computer Science 131. </note>
Reference-contexts: Timing diagrams are a form of linear temporal logic, as they depict only one possible future. Supporting a branching time logic gives HHL additional flexibility. Within the branching-time logic family, CTL is perhaps the most commonly used, both due to tools available for using it and its theoretical properties <ref> [23, 61] </ref>. Syntax This definition is taken from [38]. Definition 72 The formulas of CTL are the state formulas hstate fi as generated by the following grammars.
Reference: [24] <author> Avra Cohn. </author> <title> The notion of proof in hardware verification. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 5(2) </volume> <pages> 127-139, </pages> <year> 1989. </year>
Reference: [25] <institution> National Semiconductor Corporation. LS/S/TTL logic databook, </institution> <year> 1987. </year>
Reference-contexts: Question 3 is challenging because more than one interpretation is used in practice. Databooks use timing diagrams to specify timing restrictions on read/write cycles of memory components <ref> [25] </ref>. In such components, one cycle completes before the next one begins: the timing diagram is therefore viewed as an infinite concatenation. In contrast, timing diagrams are also being used as graphical depictions of temporal logic to state properties for verification [74].
Reference: [26] <author> D. Van Dalen. </author> <title> Logic and Structure. </title> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: Rules of Inference 199 In 8-elimination (second rule from right), t must be free for x in '; formally, this requires one of the following cases to hold <ref> [26] </ref>: * ' is an atomic formula * ' is of the form :' 1 or ' 1 ^ ' 2 and t is free for x in ' 1 and ' 2 * ' is of the form 8y and either x is not in the free variables of '
Reference: [27] <author> Ruth Eberle. </author> <title> Diagrams and Natural Deduction: Theory and Pedagogy of Hyperproof. </title> <type> PhD thesis, </type> <institution> Indiana University, 1995. Department of Philosophy. </institution>
Reference-contexts: If the intersection is empty, no information can be determined regarding CTA. Similar techniques are applicable to probabilitically test close and to search for counterexamples to exhaust and merge. 4.14 Proofs HHL supports natural deduction proofs, defined in the style of Prawitz [69] and Eberle <ref> [27] </ref>. Intuitively, a proof is a sequence of valid formulas, each of which is derivable from earlier formulas in the sequence. Checking whether a particular sequence of formulas represents a valid proof involves examining the order of the formulas and their nesting levels in subproofs. As per Eberle [27], strings of <p> and Eberle <ref> [27] </ref>. Intuitively, a proof is a sequence of valid formulas, each of which is derivable from earlier formulas in the sequence. Checking whether a particular sequence of formulas represents a valid proof involves examining the order of the formulas and their nesting levels in subproofs. As per Eberle [27], strings of natural numbers capture nesting information, as demonstrated in Example 37. Example 37 Each line in the Fitch-style proof on the left is represented by the corresponding string on the right. 4. Rules of Inference 236 Each string is called an address.
Reference: [28] <author> E.A. Emerson. </author> <title> Temporal and modal logic. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B, chapter 16, </booktitle> <pages> pages 997-1072. </pages> <publisher> Elsevier Science Publishers, </publisher> <year> 1990. </year>
Reference-contexts: Linear-time temporal logics view time as having a single future, or execution path [59]. Branching-time temporal logics view time as having many possible futures [29]. These views of futures are reflected in the formulas of the respective logics. Good surveys of temporal logic appear in <ref> [28] </ref> and [67]. HHL includes the branching-time logic CTL as one sentential representation. Timing diagrams are a form of linear temporal logic, as they depict only one possible future. Supporting a branching time logic gives HHL additional flexibility. <p> The size of a CTL formula is the count of its operands and operators <ref> [28] </ref>. The size of a timing diagram is the count of its transition objects, concurrent edge objects, successor edge objects, and time-bound expressions. These are captured using two parameters: the number of waveforms (n) and the number of time points (p). <p> AXr))) ! (r ! :E [pUq]) * AG (p ! q) ! (EXp ! EXq) The Inference Rules of CTL: * If ` p and ` p ! q, then ` q (modus ponens) * If ` p then ` AGp (Generalization) These axioms and inference rules are reproduced from <ref> [28] </ref>, where they are proven sound and complete. 4.4 SOL to SOL The rules of SOL are the standard inference rules of second order logic. ', ' ^ ' ^ ', ' ! 8x'(x) '(t) 4.
Reference: [29] <author> E.A. Emerson and J.Y. Halpern. </author> <title> "Sometimes" and "Not Never" revisted: Branching time strikes back. </title> <journal> Journal of the ACM, </journal> <volume> 33(1) </volume> <pages> 151-178, </pages> <year> 1986. </year> <note> BIBLIOGRAPHY 285 </note>
Reference-contexts: Logics reflecting what happens at states, rather than between them, fall into two general classes: linear-time temporal logics and branching-time temporal logics. Linear-time temporal logics view time as having a single future, or execution path [59]. Branching-time temporal logics view time as having many possible futures <ref> [29] </ref>. These views of futures are reflected in the formulas of the respective logics. Good surveys of temporal logic appear in [28] and [67]. HHL includes the branching-time logic CTL as one sentential representation. Timing diagrams are a form of linear temporal logic, as they depict only one possible future.
Reference: [30] <editor> Werner Grass et. al. </editor> <title> Transformation of timing diagram specifications into VHDL code. </title> <booktitle> In Proceedings of Computer Hardware Description Languages and Their Applications, </booktitle> <pages> pages 659-668, </pages> <month> August </month> <year> 1995. </year>
Reference: [31] <author> Simon Finn, Michael P. Fourman, Michael Francis, and Robert Harris. </author> <title> Formal system design | interactive synthesis based on computer-assisted formal reasoning. </title> <editor> In Luc Claesen, editor, </editor> <title> Formal VLSI Specification and Synthesis: VLSI Design-Methods-I. </title> <publisher> North-Holland, </publisher> <year> 1990. </year>
Reference: [32] <author> Kathi Fisler. </author> <title> A canonical form for circuit diagrams. </title> <type> Technical Report TR432, </type> <institution> Indiana University, </institution> <month> May </month> <year> 1995. </year>
Reference-contexts: The soundness proofs all share a similar structure: any model described by all of the F i 's is shown to be described by f . Completeness is not addressed for HHL, although portions of the logic, such as circuit diagrams, are expected to be complete <ref> [32] </ref>. 170 4. Rules of Inference 171 Inference rules are either primitive or derived. Primitive rules provide a basis for the inference system. Derived rules are shorthand for sequences of primitive rules. This chapter presents primitive rules, unless otherwise noted.
Reference: [33] <author> Seymour Ginsburg. </author> <title> The Mathematical Theory of Context-Free Languages. </title> <publisher> McGraw-Hill, </publisher> <year> 1966. </year>
Reference-contexts: 1. Introduction 15 1.3.5 Decision Procedures and Non-Regular Languages Several researchers have investigated the decidability of problems on non-regular languages. Gins-burg shows the decidability of language emptiness, containment, and equivalence for bounded languages, those of the form w 1 fl w 2 fl , such as a n b n <ref> [33] </ref>. Ibarra et al. extended these results to the general class of languages accepted by two-way, one counter machines [48]. <p> Timing diagram languages resemble bounded languages, those with form w 1 fl w 2 fl , where each w i is a word <ref> [33] </ref>. In the case of timing diagrams, each w i represents a time slice. Language containment is decidable for bounded languages, regardless of their position in the Chomsky hierarchy [48]. Unfortunately, this result does not apply directly to timing diagrams.
Reference: [34] <author> Janice Glasgow, N. Hari Narayanan, and B. Chandrasekaran. </author> <title> Diagrammatic Reasoning: Cognitive and Computational Perspectives. </title> <publisher> MIT Press, </publisher> <year> 1995. </year>
Reference: [35] <author> M.J.C. Gordon. </author> <title> Why higher order logic is a good formalism for specifying and verifying hardware. </title> <editor> In G.J. Milne and P.A. Subrahmanyam, editors, </editor> <booktitle> Formal Aspects of VLSI Design: Proceedings of the 1985 Edinburgh Conference on VLSI, </booktitle> <pages> pages 153-177. </pages> <publisher> North Holland, </publisher> <year> 1986. </year>
Reference-contexts: Viewed as a structural logic, HHL forms the next step in an evolution of formal methods logics as demonstrated by the handshaking protocol discussed in Example 2, Chapter 1. In the mid-eighties, Gordon advocated higher-order logics for hardware reasoning due to their generality <ref> [35] </ref>. Temporal logics, previously advocated by Pnueli, have since become extremely popular, partially because their implicit time variables provide more compact statements of properties [68]. Diagrammatic logics compact representations further still through implicit structural information. This evolution moves towards domain-specific formal methods tools and away from general-purpose reasoning systems.
Reference: [36] <author> M.J.C. Gordon. </author> <title> HOL: A proof generating system for higher-order logic. </title> <editor> In G. Birtwistle and P.A. Subrahmanyam, editors, </editor> <booktitle> VLSI Specification, Verification and Syntesis, </booktitle> <pages> pages 73-128. </pages> <publisher> Kluwer Academic Publishers, </publisher> <year> 1987. </year>
Reference: [37] <author> O. Grumberg and D.E. </author> <title> Long. Model checking and modular verification. </title> <booktitle> In Proceedings of CONCUR '91: Second International Conference on Concurrency Theory. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> volume 527. </volume>
Reference-contexts: The subset of CTL representable in timing diagrams is still undetermined. The subset is expected to lie in 8CTL, the subset of CTL that allows the A path quantifier, but not the E path quantifier <ref> [37] </ref>. This makes intuitive sense since timing diagrams express linear, rather than branching, properties. However, even within 8CTL, there are formulas that cannot be represented in timing diagrams, such as AF rising (a) ! rising (b).
Reference: [38] <author> Aarti Gupta. </author> <title> Formal hardware verification methods: A survey. </title> <editor> In Robert Kurshan, editor, </editor> <title> Computer-Aided Verification. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1992. </year> <title> Reprinted from Formal Methods in System Design, </title> <journal> Vol. </journal> <volume> 1, </volume> <pages> Nos. 2-3. </pages>
Reference-contexts: Supporting a branching time logic gives HHL additional flexibility. Within the branching-time logic family, CTL is perhaps the most commonly used, both due to tools available for using it and its theoretical properties [23, 61]. Syntax This definition is taken from <ref> [38] </ref>. Definition 72 The formulas of CTL are the state formulas hstate fi as generated by the following grammars. An atomic proposition is any element of SigNames. hstate fi := hatomic propositioni j :hstate fi j hstate fi ^ hstate fi j A (hpath fi) j E (hpath fi) 2. <p> It is standard to assume that each Kripke structure is defined relative to a set of atomic propositions; SigNames will be used for this purpose. This semantic definition is also taken from <ref> [38] </ref>. <p> Timing diagrams in TD TI [N ] are not translated because, as discussed in Section 3.3, they can express non-regular properties whereas CTL can only express regular properties <ref> [38] </ref>. The algorithm generates expressions of the form "in all states, if the assume portion is satisfied, then the entire diagram is satisfied." The translation is straightforward for timing diagrams containing no time bound objects, as shown in Example 27.
Reference: [39] <author> John V. Guttag, James J. Horning with S.J. Garland, K.D. Jones, A. Modet, and J.M. Wing. </author> <title> Larch: Languages and Tools for Formal Specification. Texts and Monographs in Computer Science. </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <note> BIBLIOGRAPHY 286 </note>
Reference: [40] <author> P. Halmos. </author> <title> Lectures on Boolean Algebras. </title> <publisher> Springer-Verlag, </publisher> <year> 1974. </year>
Reference-contexts: The first four rules correspond to equivalences of boolean algebra: distributivity, commutativity, identity, and excluded middle. All other rules corresponding to boolean equivalences are derivable from this set <ref> [40] </ref>. The circuit diagram inference rules are all defined relative to the behavioral implementation relationship, j= b (Defn. 28).
Reference: [41] <author> J. Halpern, Z. Manna, and B. Moszkowski. </author> <title> A hardware semantics based on temporal intervals. </title> <booktitle> In Proceedings of the Tenth International Colloquium on Automata, Language, and Programming, </booktitle> <pages> pages 278-291. </pages> <publisher> Springer-Verlag, </publisher> <year> 1983. </year>
Reference-contexts: Unless otherwise specified, G denotes G [N ; +]. 2. Syntax and Semantics 97 2.2.4 CTL Sentential temporal logic, a form of modal logic, is a popular formalism for hardware verification. Some temporal logics are interval-based, meaning that their formulas reflect what happens between states of a computation <ref> [41] </ref>. Logics reflecting what happens at states, rather than between them, fall into two general classes: linear-time temporal logics and branching-time temporal logics. Linear-time temporal logics view time as having a single future, or execution path [59]. Branching-time temporal logics view time as having many possible futures [29].
Reference: [42] <author> D. Harel, A. Pnueli, J.P. Schmidt, and R. Sherman. </author> <title> On the formal semantics of Statecharts. </title> <booktitle> In Proceedings of the 2nd IEEE Symposium on Logic in Computer Science, </booktitle> <address> Ithaca NY, </address> <pages> pages 54-64, </pages> <year> 1987. </year>
Reference: [43] <author> David Harel. </author> <title> On visual formalisms. </title> <type> Technical Report CMU-CS-87-126, </type> <institution> Carnegie-Mellon University, </institution> <month> June </month> <year> 1987. </year>
Reference: [44] <author> David Harel and Danny Raz. </author> <title> Deciding properties of nonregular programs. </title> <journal> SIAM Journal of Computing, </journal> <volume> 22(4) </volume> <pages> 857-874, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: Harel and Raz investigated non-regular extensions of PDL (Propositional Dynamic Logic) programs, identifying three classes of non-regular languages such that PDL extended with any language from one of the classes remains decidable <ref> [44] </ref>. Their characterizations are based partially on the structural features of the machines accepting the languages. Alur, Henzinger, and Vardi have studied timed automata with symbolic, as opposed to strictly concrete, real-time constraints [3]. Their work is the most closely related to the decidability results in Chapter 3.
Reference: [45] <author> J. E. Hopcroft and J. D. Ullman. </author> <title> Introduction to Automata Theory, Languages and Computation. </title> <publisher> Addison-Wesley, </publisher> <year> 1979. </year>
Reference-contexts: Automated language containment verification relies on the problems of language emptiness, containment, and equivalence [55]. These problems are all decidable for regular languages, emptiness is decidable for context-free languages but undecidable for context-sensitive languages, and containment and equivalence are undecidable for context free languages <ref> [45] </ref>. As a result, existing language containment verification systems support only regular languages. 3. Theoretical Results 126 This section discusses the decidability of verification problems for timing diagram languages. Timing diagram languages cut across the Chomsky hierarchy. <p> This problem is proven decidable for temporally unambiguous timing diagrams and finite regular languages. The decision procedure provides a first step in providing algorithmic support for testing timing diagram properties against circuit diagrams and ASM charts, both of which correspond to 3. Theoretical Results 127 regular languages <ref> [45, 81] </ref>. Section 3.3.3 discusses the applicability of the regular containment decision method to the timing diagram containment problem, the general language containment problem on timing diagram languages. <p> Let x be in fl . It must be established that x is accepted by A iff x is accepted by M . By definition <ref> [45] </ref>, a string x is accepted by A iff ffi A (q 0 ; x) = q f for some q f 2 F .
Reference: [46] <author> W.A. Hunt Jr. </author> <title> FM 8501: A Verified Microprocessor. </title> <type> PhD thesis, </type> <institution> University of Texas at Austin, </institution> <year> 1985. </year>
Reference: [47] <author> Oscar H. Ibarra. </author> <title> Reversal-bounded multicounter machines and their decision problems. </title> <journal> Journal of the ACM, </journal> <volume> 25(1) </volume> <pages> 116-133, </pages> <month> January </month> <year> 1978. </year>
Reference-contexts: Transitions are based on the current state, the letter being read, and whether each counter contains zero; the transition indicates a next state, which direction, if any, to move the input head, and whether to increment, decrement, or hold each counter. The formal definition is reproduced from <ref> [47] </ref>. Definition 94 1.
Reference: [48] <author> Oscar H. Ibarra, Tao Jiang, Nicholas Tran, and Hui Wang. </author> <title> New decidability results concerning two-way counter machines and applications. </title> <booktitle> In Proceedings of the 20th International Colloquium on Automata, Languages, and Programming (ICALP), 1993. Lecture Notes in Computer Science, </booktitle> <pages> 700. </pages>
Reference-contexts: Gins-burg shows the decidability of language emptiness, containment, and equivalence for bounded languages, those of the form w 1 fl w 2 fl , such as a n b n [33]. Ibarra et al. extended these results to the general class of languages accepted by two-way, one counter machines <ref> [48] </ref>. Harel and Raz investigated non-regular extensions of PDL (Propositional Dynamic Logic) programs, identifying three classes of non-regular languages such that PDL extended with any language from one of the classes remains decidable [44]. Their characterizations are based partially on the structural features of the machines accepting the languages. <p> In the case of timing diagrams, each w i represents a time slice. Language containment is decidable for bounded languages, regardless of their position in the Chomsky hierarchy <ref> [48] </ref>. Unfortunately, this result does not apply directly to timing diagrams. The bounded language correlation captures a single instance of a timing diagram, but it cannot capture the multiple instances allowed by the iterative and invariant semantics. <p> This class, the finite unions of languages accepted by reversal-bounded, 1-counter machines, was recently proved by Ibarra to be the largest for which these three problems are known to be decidable <ref> [48] </ref>. Such machines contain a two-way read-only head and one counter which can hold any natural number. Reversal-bounded means that the input head makes at most a bounded number of changes of direction while reading any string. Without bounded reversals, the emptiness, containment, and equivalence problems are undecidable. <p> Languages accepted by counter machines are characterized by two parameters: the number of counters required and the number of times the head changes direction on the input tape. Denoting these by c and r, respectively, the following results about 2DCM (c; r) are due to Ibarra <ref> [48] </ref>: Theorem 10 (Ibarra, et al., 1993) * The emptiness problem for 2DCM (1, r) is decidable for every r 1. * For each c, S r 2DCM (c; r) is effectively closed under complementation, intersection, and union. <p> As the intersection of two 2DCM is effectively constructable <ref> [48] </ref>, the first step is to produce a 2DCM from a regular automaton. This is a straightforward construction; the transitions of the finite automaton are merely augmented with a counter whose value is never changed. 3. <p> Chapter 3 constructs a 2DCM M T given timing diagram T . Containment is decidable for 2DCM and unions and intersections of 2DCM are effectively constructable <ref> [48] </ref>. The methods can therefore be tested against the partial timing diagram languages accepted by M T . For example, suppose T 1 and T 2 are non-regular timing diagrams. Consider the intersection of M T 1 and M T 2 .
Reference: [49] <institution> International Telecommunication Union (ITU). Message sequence chart (MSC). ITU-T Recommendation Z.120, </institution> <year> 1993. </year>
Reference: [50] <author> Geraint Jones and Mary Sheeran. </author> <title> Relations and refinement in circuit design. </title> <editor> In Carroll Morgan and Jim Woodcock, editors, </editor> <booktitle> Proceedings of the 3rd Refinement Workshop. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year> <note> BIBLIOGRAPHY 287 </note>
Reference: [51] <author> Geraint Jones and Mary Sheeran. </author> <title> Designing arithmetic circuits by refinement in ruby. </title> <editor> In R. S. Bird, C. C. Morgan, and J. C. P. Woodcock, editors, </editor> <booktitle> Mathematics of Program Construction. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <note> Lecture Notes in Computer Science 669. </note>
Reference: [52] <author> K. Khordoc, M. Dufresne, E. Cerny, P.A. Babkine, and A. Silburt. </author> <title> Integrating behavior and timing in executable specifications. </title> <booktitle> In CHDL, </booktitle> <pages> pages 385-402, </pages> <month> April </month> <year> 1993. </year>
Reference: [53] <author> Karim Khordoc and Eduard Cerny. </author> <title> Modeling cell processing hardware with action diagrams. </title> <booktitle> In International Symposium on Circuits and Systems, </booktitle> <year> 1994. </year>
Reference: [54] <author> R. Kumar, C. Blumenrohr, D. Eisenbiegler, and D. Schmid. </author> <title> Formal synthesis in circuit design | a survey. </title> <booktitle> In Proceedings of the Conference on Formal Methods in Computer-Aided Design (FMCAD), </booktitle> <year> 1996. </year>
Reference: [55] <author> Robert P. Kurshan. </author> <title> Computer-Aided Verification of Coordinating Processes: The Automata-Theoretic Approach. </title> <publisher> Princeton University Press, </publisher> <year> 1994. </year>
Reference-contexts: Automated language containment verification relies on the problems of language emptiness, containment, and equivalence <ref> [55] </ref>. These problems are all decidable for regular languages, emptiness is decidable for context-free languages but undecidable for context-sensitive languages, and containment and equivalence are undecidable for context free languages [45]. As a result, existing language containment verification systems support only regular languages. 3.
Reference: [56] <author> R.P. Kurshan and Leslie Lamport. </author> <title> Verification of a multiplier: 64 bits and beyond. </title> <booktitle> In Proceedings of Computer-Aided Verification (CAV), </booktitle> <pages> pages 166-179, </pages> <year> 1993. </year>
Reference: [57] <author> Miriam E. Leeser. </author> <title> Using Nuprl for the verification and synthesis of hardware. In C.A.R. </title> <editor> Hoare and M.J.C. Gordon, editors, </editor> <title> Mechanized Reasoning and Hardware Design. </title> <publisher> Prentice-Hall, </publisher> <year> 1992. </year>
Reference: [58] <author> Isabel Luengo. </author> <title> Diagrams in Geometry. </title> <type> PhD thesis, </type> <institution> Indiana University, 1995. Department of Philosophy. </institution>
Reference: [59] <author> Z. Manna and A. Pnueli. </author> <title> Verification of concurrent programs: The temporal framework. In R.S. </title> <editor> Boyer and J.S. Moore, editors, </editor> <booktitle> Correctness Problem in Computer Science, </booktitle> <pages> pages 215-273. </pages> <publisher> Academic Press, </publisher> <year> 1982. </year>
Reference-contexts: Logics reflecting what happens at states, rather than between them, fall into two general classes: linear-time temporal logics and branching-time temporal logics. Linear-time temporal logics view time as having a single future, or execution path <ref> [59] </ref>. Branching-time temporal logics view time as having many possible futures [29]. These views of futures are reflected in the formulas of the respective logics. Good surveys of temporal logic appear in [28] and [67]. HHL includes the branching-time logic CTL as one sentential representation.
Reference: [60] <author> Zohar Manna et al. </author> <title> STeP: the Stanford Temporal Prover. </title> <type> Technical Report STAN-CS-TR-94-1518, </type> <institution> Stanford University, </institution> <year> 1994. </year>
Reference: [61] <author> K.L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year> <note> BIBLIOGRAPHY 288 </note>
Reference-contexts: Timing diagrams are a form of linear temporal logic, as they depict only one possible future. Supporting a branching time logic gives HHL additional flexibility. Within the branching-time logic family, CTL is perhaps the most commonly used, both due to tools available for using it and its theoretical properties <ref> [23, 61] </ref>. Syntax This definition is taken from [38]. Definition 72 The formulas of CTL are the state formulas hstate fi as generated by the following grammars. <p> Diagrams naturally represent structural and spatial information; diagrammatic logic can therefore be viewed as a form of structural logic. Structural information has already proven useful in formal methods through binary-decision diagrams, which dramatically increased the capabilities of automated verification <ref> [17, 61] </ref>; it has proven useful in mathematical theorem-proving through Barker-Plummer and Bailin's GROVER/& system. HHL provides a framework for further studies of structural information in formal methods.
Reference: [62] <author> Thomas Frederick Melham. </author> <title> Formalizing abstraction mechanisms for hardware verification in higher order logic. </title> <type> Technical Report TR 201, </type> <institution> University of Cambridge Computer Laboratory, </institution> <month> August </month> <year> 1990. </year>
Reference: [63] <author> Paul S. Miner and Steven D. Johnson. </author> <title> Verification of an optimized fault-tolerant clock synchronization circuit: A case study exploring the boundary between formal reasoning systems. </title> <editor> In Satnam Singh, Mary Sheeran, and Geraint Jones, editors, </editor> <booktitle> Third Workshop on Designing Correct Circuits, </booktitle> <year> 1996. </year>
Reference: [64] <author> Cho Woo Moon. </author> <title> Synthesis and Verification of Asynchronous Circuits from Graphical Specifications. </title> <type> PhD thesis, </type> <institution> University of California at Berkeley, </institution> <year> 1992. </year>
Reference: [65] <author> Edward F. Moore. </author> <title> Gedanken-experiments on sequential machines. </title> <editor> In Claude Shannon and John McCarthy, editors, </editor> <booktitle> Automata Studies, </booktitle> <pages> pages 129-153. </pages> <publisher> Princeton University Press, </publisher> <year> 1956. </year>
Reference-contexts: Proof This is a direct result of the correlation between AndGates, Inverters, UnitDelay elements, and their respective circuit diagram icons. 2 2.2.2 ASM Charts ASM charts are a variant of state machine notation that combines the traditional Mealy and Moore machines <ref> [65] </ref>. They have an appearance reminiscent of flow-charts: rectangles represent states, diamonds represent conditional branches, and ovals represent conditional (Mealy) outputs. Placing a variable within a state rectangle designates a Moore output. Example 10 provides simple ASM charts; more extensive examples and details can be found in [70].
Reference: [66] <author> S. Owre, S. Rajan, J.M. Rushby, N. Shankar, and M. Srivas. </author> <title> PVS:combining specification, proof checking, and model checking. </title> <note> To be presented at CAV '96, </note> <month> July </month> <year> 1996. </year>
Reference: [67] <author> A. Pnueli. </author> <title> Applications of temporal logic to the specification and verification of reactive systems: A survey of current trends. </title> <editor> In J.W. de Bakker, W.P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Current Trends in Concurrency, </booktitle> <pages> pages 510-584. </pages> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference-contexts: Linear-time temporal logics view time as having a single future, or execution path [59]. Branching-time temporal logics view time as having many possible futures [29]. These views of futures are reflected in the formulas of the respective logics. Good surveys of temporal logic appear in [28] and <ref> [67] </ref>. HHL includes the branching-time logic CTL as one sentential representation. Timing diagrams are a form of linear temporal logic, as they depict only one possible future. Supporting a branching time logic gives HHL additional flexibility.
Reference: [68] <author> Amir Pnueli. </author> <title> The temporal logic of programs. </title> <booktitle> In Proceedings of the Eighth Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 46-57. </pages> <publisher> IEEE, </publisher> <year> 1977. </year>
Reference-contexts: The temporal logic interpretation views timing diagrams as being time invariant, meaning that the depicted relationship should hold in every state of a computation, regardless of the status of previous iterations <ref> [68] </ref>. Choosing between the time invariant and concatenation interpretations is analogous to choosing between natural support for verification or natural support for design. Rather than choose, this section defines two semantic relationships: one time invariant and one iterative. These are discussed after the presentation of timing diagram syntax. 2. <p> In the mid-eighties, Gordon advocated higher-order logics for hardware reasoning due to their generality [35]. Temporal logics, previously advocated by Pnueli, have since become extremely popular, partially because their implicit time variables provide more compact statements of properties <ref> [68] </ref>. Diagrammatic logics compact representations further still through implicit structural information. This evolution moves towards domain-specific formal methods tools and away from general-purpose reasoning systems.
Reference: [69] <author> Dag Prawitz. </author> <title> Natural Deduction: A Proof-Theoretic Study. </title> <publisher> Almqvist & Wiksells, </publisher> <year> 1965. </year>
Reference-contexts: If the intersection is empty, no information can be determined regarding CTA. Similar techniques are applicable to probabilitically test close and to search for counterexamples to exhaust and merge. 4.14 Proofs HHL supports natural deduction proofs, defined in the style of Prawitz <ref> [69] </ref> and Eberle [27]. Intuitively, a proof is a sequence of valid formulas, each of which is derivable from earlier formulas in the sequence. Checking whether a particular sequence of formulas represents a valid proof involves examining the order of the formulas and their nesting levels in subproofs.
Reference: [70] <author> Franklin P. Prosser and David E. </author> <title> Winkel. </title> <booktitle> The Art of Digital Design. Prentice-Hall, 2nd edition, </booktitle> <year> 1987. </year>
Reference-contexts: They have an appearance reminiscent of flow-charts: rectangles represent states, diamonds represent conditional branches, and ovals represent conditional (Mealy) outputs. Placing a variable within a state rectangle designates a Moore output. Example 10 provides simple ASM charts; more extensive examples and details can be found in <ref> [70] </ref>. As in the section on circuit diagrams, the term ASM chart is reserved for well-formed diagrams; ASM sketch is used for the general case. Example 10 ASM chart 1 waits for the value of signal a to be true and then asserts b. <p> Assume the number of state objects in M is a power of two. This result follows from the state-encoded implementation technique presented in <ref> [70] </ref>. 2 The following lemma provides a sufficiency result for behavioral equivalence of two ASM charts. <p> The overriding emphasis is to let the problem solution dictate the hardware, rather than allowing premature commitments to hardware to coerce the solution. <ref> [70] </ref> Franklin P. Prosser and David E. Winkel Formal methods aims to provide mathematical foundations for system design. Such a foundation is most effective when it models actual practice. Unfortunately, most formal methods tools are rooted in mathematical logic, which is not the lingua-franca of hardware design.
Reference: [71] <author> Y.S. Ramakrishna, L.K. Dillon, L.E. Moser, P.M. Melliar-Smith, and G. Kutty. </author> <title> A real-time interval logic and its decision procedure. </title> <booktitle> In Proceedings of the Thirteenth Conference on Foundations of Software Technology and Theoretical Computer Science, </booktitle> <pages> pages 173-192, </pages> <month> December </month> <year> 1993. </year> <note> Springer-Verlag Lecture Notes in Computer Science volume 761. BIBLIOGRAPHY 289 </note>
Reference: [72] <author> John Rushby. </author> <title> Formal methods and digital systems validation for airborne systems. </title> <type> Contractor Report 4551, </type> <institution> NASA, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: Such movement echos Rushby's apprehension as quoted in the introduction: "a formal specification method built around a particular diagrammatic or tabular notation may have rather restricted application, and limited mechanized support for general forms of analysis" <ref> [72] </ref>. This is true. Although heterogeneous logics could theoretically circumvent this problem, tools supporting diagrammatic representations would likely be used for applications suited to those 6. Conclusions 263 diagrams.
Reference: [73] <author> Hossein Saiedian. </author> <title> An invitation to formal methods. </title> <journal> IEEE Computer, </journal> <volume> 29(4) </volume> <pages> 16-30, </pages> <month> April </month> <year> 1996. </year>
Reference-contexts: Experience recommends the use of automated techniques to test deadlock conditions whenever possible. 5. Examples 259 6 Conclusions The principles, objects, and relationships offered by [finite state machines, typed set theory, algebra, logic] are absurdly different from the principles, objects, and relationships about which these engineers are concerned. <ref> [73] </ref> Pamela Zave It is particularly important that you understand our approach to the details of digital hardware. The overriding emphasis is to let the problem solution dictate the hardware, rather than allowing premature commitments to hardware to coerce the solution. [70] Franklin P. Prosser and David E. <p> Instead, they use tables, charts, and equations that capture the phenomena of interest the mathematics, while abstract, is expressed in terms of the problem at hand" <ref> [73] </ref>. 6.1 Future Work This work suggests several future projects, some directly related to HHL and some in the general areas of verification and diagrammatic reasoning. Implementing a tool based on HHL is of primary importance. <p> As noted by Parnas, software formal methods suffers from similar notational difficulties to hardware formal methods: "We need a lot more work on notation. The notation that is purveyed by most formal methods researchers is cumbersome and hard to read" <ref> [73] </ref>. Software formal methods differs from hardware formal methods in several ways. Hardware systems are usually finite-state, which lends them naturally to algorithmic verification, while infinite-state software systems must be abstracted to finite-state systems before algorithmic verification can be applied.
Reference: [74] <author> Rainer Schlor. </author> <title> A prover for VHDL-based hardware design. </title> <booktitle> In Proceedings of the Conference on Hardware Description Languages and Their Applications, </booktitle> <month> August </month> <year> 1995. </year>
Reference-contexts: In such components, one cycle completes before the next one begins: the timing diagram is therefore viewed as an infinite concatenation. In contrast, timing diagrams are also being used as graphical depictions of temporal logic to state properties for verification <ref> [74] </ref>. The temporal logic interpretation views timing diagrams as being time invariant, meaning that the depicted relationship should hold in every state of a computation, regardless of the status of previous iterations [68]. <p> f describes D whenever D is structurally described by every circuit diagram in F and D is functionally structurally described by every time-free ASM chart in F . 3 Theoretical Results 3.1 Representing Timing Diagrams in CTL Timing diagrams have occasionally been given semantics via translation into sentential temporal logics <ref> [74] </ref> [75]. As discussed in Chapter 1, this method of assigning semantics is problematic because the correctness of the translation cannot be verified without an existing timing diagram semantics.
Reference: [75] <author> Rainer Schlor and Werner Damm. </author> <title> Specification and verification of system-level hardware designs using timing diagrams. </title> <booktitle> In Proc. European Conf. on Design and Automation, </booktitle> <address> Paris, </address> <month> February </month> <year> 1993. </year>
Reference-contexts: describes D whenever D is structurally described by every circuit diagram in F and D is functionally structurally described by every time-free ASM chart in F . 3 Theoretical Results 3.1 Representing Timing Diagrams in CTL Timing diagrams have occasionally been given semantics via translation into sentential temporal logics [74] <ref> [75] </ref>. As discussed in Chapter 1, this method of assigning semantics is problematic because the correctness of the translation cannot be verified without an existing timing diagram semantics. This section presents a translation algorithm from temporally unambiguous diagrams in TD TI [C 1] into CTL and verifies its semantic correctness.
Reference: [76] <author> Sun-Joo Shin. </author> <title> The Logical Status of Diagrams. </title> <publisher> Cambridge University Press, </publisher> <year> 1994. </year>
Reference: [77] <author> Robert Shostak. </author> <title> Deciding linear inequalities by computing loop residues. </title> <journal> Journal of the ACM, </journal> <volume> 28(4) </volume> <pages> 769-779, </pages> <month> October </month> <year> 1981. </year>
Reference-contexts: Algorithm 5 in Chapter 3 shows how to construct a set of linear inequalities corresponding to the bounds restrictions in a temporally unambiguous timing diagram, the satisfiability of which is decidable by a procedure due to Shostak <ref> [77] </ref>. The time-bounds expressions in a temporally ambiguous timing diagram are satisfiable if the time-bound expressions in any of its corresponding temporally unambiguous diagrams are satisfiable. Semantics Timing diagram semantics are defined relative to the language model.
Reference: [78] <author> V. Singhal and C. Pixley. </author> <title> The verification problem for safe replaceability. </title> <editor> In D. Dill, editor, </editor> <booktitle> Proc. 6th International Conference on Computer Aided Verification, Springer-Verlag Lecture Notes in Computer Science vol. </booktitle> <volume> 818, </volume> <pages> pages 311-323, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Subdevices can be replaced by behaviorally equivalent devices without affecting the behavior of the overall device. This property is useful when optimizing devices with respect to their numbers of gates. Stronger notions of when one subdevice can replace another have been studied in <ref> [78] </ref>; the behavioral equivalence notion is sufficient to prove certain inference rules on circuit diagrams in Chapter 4. 2. Syntax and Semantics 33 Lemma 3 Let D be a device and let D 1 be a subdevice of D.
Reference: [79] <author> SRI International, </author> <title> Formal Methods Group. The PVS2 verification system. </title> <note> Information available at http://www.csl.sri.com/pvs.html. </note>
Reference: [80] <author> Stenning, R. K. Cox, and J. Oberlander. </author> <title> Contrasting the cognitive effects of graphical and sentential logic teaching: reasoning, representation and individual differences. </title> <booktitle> Language and Cognitive Processes, </booktitle> 10(3/4):333-354, 1995. 
Reference: [81] <author> Howard Straubing. </author> <title> Finite Automata, Formal Logic, and Circuit Complexity. </title> <publisher> Birkhauser, </publisher> <year> 1994. </year>
Reference-contexts: This problem is proven decidable for temporally unambiguous timing diagrams and finite regular languages. The decision procedure provides a first step in providing algorithmic support for testing timing diagram properties against circuit diagrams and ASM charts, both of which correspond to 3. Theoretical Results 127 regular languages <ref> [45, 81] </ref>. Section 3.3.3 discusses the applicability of the regular containment decision method to the timing diagram containment problem, the general language containment problem on timing diagram languages. <p> For regular languages, these problems are decidable and constructable, respectively. Timing diagrams and CTR are the two non-regular HHL representations; the variant of SOL supported in monadic, which is equivalent to the regular languages <ref> [81] </ref>. Section 3.3.1 argues that timing diagrams languages are always non-empty. Section 3.3.2 discussed the decidability of language containment for timing diagrams. Whether unions and intersections of timing diagram languages are effectively constructable are still open questions.
Reference: [82] <author> Bell Laboratories/Lucent Technologies. </author> <title> Cospan verification system. </title>
Reference-contexts: Examples 257 Anchor Align [Rule 16] Simplification [Rule 42] Composition [Rule 21], Proof 2 Merge [Rule 39] Time Generalization [Rule 19] The remaining two cases of Property 3 have similar proofs. The proofs of the remaining properties have been done in COSPAN <ref> [82] </ref>; the COSPAN statements of the design, the properties, and a description of the COSPAN system appear in Appendix B. Admittedly, working between COSPAN and HHL without a provable syntax translation is not rigorous.
Reference: [83] <author> W. Thomas. </author> <title> Automata on infinite objects. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> Volume B, </volume> <pages> pages 133-191. </pages> <publisher> Elsevier Science Publishers, </publisher> <year> 1990. </year> <note> BIBLIOGRAPHY 290 </note>
Reference: [84] <author> Moshe Y. Vardi and Pierre Wolper. </author> <title> An automata-theoretic approach to automatic program verification. </title> <booktitle> In Proceedings of the First IEEE Symposium on Logic and Computer Science (LICS), </booktitle> <year> 1986. </year>
Reference-contexts: A decision procedure for these instances would require an algorithm for constructing a finite-state automaton from a timing diagram. Similar algorithms exist from several temporal logics into automata [11] <ref> [84] </ref> [85], so such a construction seems feasible. The timing diagram containment problem is still open when T 1 is not regular. There exist 1-counter non-reversal-bounded languages that cannot be captured in any timing diagram.

References-found: 84

