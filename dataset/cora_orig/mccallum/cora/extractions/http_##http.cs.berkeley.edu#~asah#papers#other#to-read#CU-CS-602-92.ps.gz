URL: http://http.cs.berkeley.edu/~asah/papers/other/to-read/CU-CS-602-92.ps.gz
Refering-URL: http://http.cs.berkeley.edu/~asah/papers/other/to-read/
Root-URL: http://www.cs.berkeley.edu
Title: CustoMalloc: Efficient Synthesized Memory Allocators  
Author: Dirk Grunwald Benjamin Zorn 
Date: July 1992  
Address: Campus Box #430  Boulder 80309-0430  Boulder  
Affiliation: Department of Computer Science  University of Colorado,  ffi University of Colorado at  
Pubnum: CU-CS-602-92  
Abstract: Technical Report CU-CS-602-92 Department of Computer Science Campus Box 430 University of Colorado Boulder, Colorado 80309 
Abstract-found: 1
Intro-found: 1
Reference: [Ball & Larus 92] <author> Ball, T. and Larus, J. R. </author> <title> Optimally profiling and tracing programs. </title> <booktitle> In Conference Record of the Nineteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 59-70, </pages> <month> January </month> <year> 1992. </year> <month> 20 </month>
Reference-contexts: We measured the memory efficiency of each allocator by recording the amount of dynamic memory requested from the operating system via the Unix sbrk function. This is a coarse metric, but does illustrate the peak usage requested by the program. We measured execution time using the qp utility <ref> [Ball & Larus 92] </ref>. This tool provides a dynamic execution count for each subroutine in terms of instructions. This removes any variability in measuring execution time, greatly simplifying the experimental design.
Reference: [Batson et al. 70] <author> Batson, A. P., Ju, S. M., and Wood, D. C. </author> <title> Measurements of segment size. </title> <journal> Communications of the ACM, </journal> <volume> 13(3) </volume> <pages> 155-159, </pages> <month> March </month> <year> 1970. </year>
Reference: [Bozman 84] <author> Bozman, G. </author> <title> The software lookasize buffer reduces search overhead with linked lists. </title> <journal> Communications of the ACM, </journal> <volume> 27(3) </volume> <pages> 222-227, </pages> <month> March </month> <year> 1984. </year>
Reference-contexts: If a freelist does not exist, a new freelist entry is created. In both allocation and deallocation, the most recently accessed freelist entry is moved to the front of the list of freelists. Variants on this algorithm have been suggested <ref> [Bozman 84, Oldehoeft & Allan 85, Leverett & Hibbard 82] </ref>, although we were unable to find a previous implementation of our exact algorithm.
Reference: [Bozman et al. 84] <author> Bozman, G., Buco, W., Daly, T. P., and Tetzlaff, W. H. </author> <title> Analysis of free-storage algorithms|revisited. </title> <journal> IBM Systems Journal, </journal> <volume> 23(1) </volume> <pages> 44-64, </pages> <year> 1984. </year>
Reference: [DeTreville 90] <author> DeTreville, J. </author> <title> Heap usage in the Topaz environment. </title> <type> Technical Report 63, </type> <institution> Digital Equipment Corporation System Research Center, </institution> <address> Palo Alto, CA, </address> <month> August </month> <year> 1990. </year>
Reference: [Kingsley 82] <author> Kingsley, C. </author> <title> Description of a very fast storage allocator. Documentation of 4.2 BSD Unix malloc implementation, </title> <month> February </month> <year> 1982. </year>
Reference-contexts: Com parison to other "first-fit" implementations indicates this is very a efficient implementation. Bsd As an alternative to a more conventional first-fit algorithm, Chris Kingsley implemented a very fast buddy algorithm that was distributed with the 4.2 BSD Unix release <ref> [Kingsley 82] </ref>. Kingsley's algorithm allocates objects in a limited number of different size classes, namely powers of two minus a constant. Allocation requests are rounded up to the nearest size class and a freelist of objects of each size class is maintained.
Reference: [Knuth 73] <author> Knuth, D. E. </author> <title> Fundamental Algorithms, </title> <booktitle> volume 1 of The Art of Computer Programming, chapter 2, </booktitle> <pages> pages 435-451. </pages> <publisher> Addison Wesley, </publisher> <address> Reading, MA, 2nd edition, </address> <year> 1973. </year>
Reference-contexts: Source code was not available for the last algorithm (Cartesian), but it is provided with a widely used operating system, and we assume it has been extensively optimized. FirstFit This algorithm, described by Knuth, is a straightforward implementation of a first-fit strategy with several optimizations <ref> [Knuth 73] </ref>. We measured a publicly available implementation of the classic Knuth algorithm written by Doug Lea. This variant uses an array of freelists. In each freelist, free blocks are connected together in a double-linked list.
Reference: [Lea ] <author> Lea, D. </author> <title> An efficient first-fit memory allocator. (From comments in source and personal communication). </title>
Reference-contexts: Likewise, some size classes may have their storage reclaimed from the freelists, and thus require a more general allocator. We use an efficient first-fit coalescing allocator for the general allocator <ref> [Lea ] </ref>. In x4, we compare the performance of CustoMalloc to that allocator as well as a number of other allocation algorithms. The decision to use the fast or general allocator is based on the ratio of the mean freelist length to the mean number of allocated objects in use.
Reference: [Leverett & Hibbard 82] <author> Leverett, B. W. and Hibbard, P. G. </author> <title> An adaptive system for dyanmic storage allocation. </title> <journal> Software Practice and Experience, </journal> <volume> 12 </volume> <pages> 543-555, </pages> <year> 1982. </year>
Reference-contexts: If a freelist does not exist, a new freelist entry is created. In both allocation and deallocation, the most recently accessed freelist entry is moved to the front of the list of freelists. Variants on this algorithm have been suggested <ref> [Bozman 84, Oldehoeft & Allan 85, Leverett & Hibbard 82] </ref>, although we were unable to find a previous implementation of our exact algorithm.
Reference: [Margolin et al. 71] <author> Margolin, B. H., Parmelee, R. P., and Schatzoff, M. </author> <title> Analysis of free-storage algorithms. </title> <journal> IBM Systems Journal, </journal> <volume> 10(4) </volume> <pages> 283-304, </pages> <year> 1971. </year>
Reference: [Oldehoeft & Allan 85] <author> Oldehoeft, R. R. and Allan, S. J. </author> <title> Adaptive exact-fit storage management. </title> <journal> Communications of the ACM, </journal> <volume> 28(5) </volume> <pages> 506-511, </pages> <month> May </month> <year> 1985. </year>
Reference-contexts: In effect, there was a great degree of temporal locality in the sizes of memory requests. Numerous memory allocation mechanisms have also made use of this observation; for example, Oldehoft <ref> [Oldehoeft & Allan 85] </ref> measured the performance of adaptive caching strategies for memory allocation. Likewise, numerous programs use this property for ad hoc allocation strategies, that is, static caching strategies based on the (commonly misjudged) relative allocation frequency of objects of different sizes. <p> If a freelist does not exist, a new freelist entry is created. In both allocation and deallocation, the most recently accessed freelist entry is moved to the front of the list of freelists. Variants on this algorithm have been suggested <ref> [Bozman 84, Oldehoeft & Allan 85, Leverett & Hibbard 82] </ref>, although we were unable to find a previous implementation of our exact algorithm.
Reference: [Standish 80] <author> Standish, T. </author> <title> Data Structures Techniques. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1980. </year>
Reference-contexts: The central idea of CustoMalloc is simple: the allocation pattern of a program is measured across multiple input sets, and a customized memory allocator is generated using the information collected in the measurement phase. A similar strategy has been used to produce the QuickFit memory allocator <ref> [Weinstock & Wulf 88, Standish 80] </ref>; however, the QuickFit algorithms depends on the observation that many programs allocate a large number of small objects and generalizes that common condition, treating all programs similarly. <p> This algorithm is attractive because the worst-case cost of all operations on the tree (allocation, deallocation, and moving blocks around) is O (d), where d is the depth of the tree. QuickFit This is the quick-fit algorithm described by <ref> [Weinstock & Wulf 88, Standish 80] </ref>, and is somewhat similar to CustoMalloc. Allocation requests less than 32 bytes are grouped into eight size classes rounded to four byte sizes. Allocations in those size classes use the same fast allocator used in CustoMalloc.
Reference: [Stephenson 83] <author> Stephenson, C. J. </author> <title> Fast fits: New methods for dynamic storage allocation. </title> <booktitle> In Proceedings of the Ninth ACM Symposium on Operating System Principles, </booktitle> <pages> pages 30-32, </pages> <address> Bretton Woods, NH, </address> <month> October </month> <year> 1983. </year>
Reference-contexts: Interestingly, its widespread use would suggest that users often consider CPU performance more important than memory usage in these systems (or, perhaps, users are not aware of the penalty). Cartesian This algorithm, sometimes called "better-fit", is provided by the Sun Operating System library routines malloc and free <ref> [Stephenson 83, Sun 90] </ref>. Rather than place the free blocks in a linear list, they are placed in a Cartesian tree [Vuillemin 80].
Reference: [Sun 90] <institution> Sun Microsystems, Mountain View, CA. </institution> <note> Unix Manual Page for malloc, SunOS 4.1 edition, </note> <year> 1990. </year>
Reference-contexts: Interestingly, its widespread use would suggest that users often consider CPU performance more important than memory usage in these systems (or, perhaps, users are not aware of the penalty). Cartesian This algorithm, sometimes called "better-fit", is provided by the Sun Operating System library routines malloc and free <ref> [Stephenson 83, Sun 90] </ref>. Rather than place the free blocks in a linear list, they are placed in a Cartesian tree [Vuillemin 80].
Reference: [Vuillemin 80] <author> Vuillemin, J. </author> <title> A unifying look at data structures. </title> <journal> Communications of the ACM, </journal> <volume> 23(4) </volume> <pages> 229-239, </pages> <month> April </month> <year> 1980. </year>
Reference-contexts: Cartesian This algorithm, sometimes called "better-fit", is provided by the Sun Operating System library routines malloc and free [Stephenson 83, Sun 90]. Rather than place the free blocks in a linear list, they are placed in a Cartesian tree <ref> [Vuillemin 80] </ref>. Descendents in the tree are ordered both by address (left descendents have lower addresses than right descendents), and by size (descendents on the left are smaller than descendents on the right).
Reference: [Weinstock & Wulf 88] <author> Weinstock, C. B. and Wulf, W. A. Quickfit: </author> <title> An efficient algorithm for heap storage allocation. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 23(10) </volume> <pages> 141-144, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: The central idea of CustoMalloc is simple: the allocation pattern of a program is measured across multiple input sets, and a customized memory allocator is generated using the information collected in the measurement phase. A similar strategy has been used to produce the QuickFit memory allocator <ref> [Weinstock & Wulf 88, Standish 80] </ref>; however, the QuickFit algorithms depends on the observation that many programs allocate a large number of small objects and generalizes that common condition, treating all programs similarly. <p> These results are similar to those noted by others <ref> [Weinstock & Wulf 88] </ref>. We stress that this is not a contrived or atypical example; the previous code fragment was taken from one of the applications we instrumented. The program modifications to include the inlined allocators are fairly simple, again taking a few minutes. <p> This algorithm is attractive because the worst-case cost of all operations on the tree (allocation, deallocation, and moving blocks around) is O (d), where d is the depth of the tree. QuickFit This is the quick-fit algorithm described by <ref> [Weinstock & Wulf 88, Standish 80] </ref>, and is somewhat similar to CustoMalloc. Allocation requests less than 32 bytes are grouped into eight size classes rounded to four byte sizes. Allocations in those size classes use the same fast allocator used in CustoMalloc.
Reference: [Zorn & Grunwald 92a] <author> Zorn, B. and Grunwald, D. </author> <title> Empirical measurements of six allocation-intensive c programs. </title> <type> Technical Report CS-CS-604-92, </type> <institution> Department of Computer Science, University of Colorado, Boulder, Boulder, CO, </institution> <month> July </month> <year> 1992. </year> <month> 21 </month>
Reference-contexts: By comparison, CustoMalloc tailors the allocator design to each application, and can accomodate applications that do not fit this pattern. During a study to determine appropriate models of program allocation <ref> [Zorn & Grunwald 92b, Zorn & Grunwald 92a] </ref>, we noticed a common pattern in many of the programs we examined. We recorded the frequency of different size classes, or amount of memory requested for each allocation request. <p> Previously, we examined numerous synthetic models for comparing memory allocators <ref> [Zorn & Grunwald 92a, Zorn & Grunwald 92b] </ref>, and considered using one of those models. However, to measure the sensitivity of allocation distribution to the input set, we needed to instrument actual applications; once this was done, it was as simple to use those applications to compare performance.
Reference: [Zorn & Grunwald 92b] <author> Zorn, B. and Grunwald, D. </author> <title> Evaluating models of memory allocation. </title> <type> Tech--nical Report CS-CS-603-92, </type> <institution> Department of Computer Science, University of Colorado, Boulder, Boulder, CO, </institution> <month> July </month> <year> 1992. </year> <note> In preparation. </note>
Reference-contexts: By comparison, CustoMalloc tailors the allocator design to each application, and can accomodate applications that do not fit this pattern. During a study to determine appropriate models of program allocation <ref> [Zorn & Grunwald 92b, Zorn & Grunwald 92a] </ref>, we noticed a common pattern in many of the programs we examined. We recorded the frequency of different size classes, or amount of memory requested for each allocation request. <p> The measurement allocation pool is structured as a list of lists; each list maintains statistics for objects of a specific size and a pointer to a freelist of objects at least that large. Although our previous study <ref> [Zorn & Grunwald 92b] </ref> showed that a plurality of requests were for a specific number of bytes, it also showed that a greater majority could be satisfied by rounding the request size to a small R-byte size boundary. <p> We also measure the freelist length each time an item is added to or removed from the freelist to compute the mean freelist length. In effect, the number of allocations and releases defines a time order for mean usage. Our previous study <ref> [Zorn & Grunwald 92b] </ref> showed this is an accurate approximation to the true mean freelist length. 3 MallocPtrType malloc (MallocArgType bytes) - unsigned int size = size_external_to_internal (bytes); if ( size == 32 ) - if (__customalloc_FreeList [0]) return (__customalloc_unlink (0)); else return ( __fast_malloc (32) ); - else if ( <p> Previously, we examined numerous synthetic models for comparing memory allocators <ref> [Zorn & Grunwald 92a, Zorn & Grunwald 92b] </ref>, and considered using one of those models. However, to measure the sensitivity of allocation distribution to the input set, we needed to instrument actual applications; once this was done, it was as simple to use those applications to compare performance. <p> The programs were all written in the C programming language. The version of yacr that we measured did not release much allocated memory by calling free. The empirical behavior of these problems is presented in <ref> [Zorn & Grunwald 92b] </ref>. We had limited detailed knowledge about the sample programs; we did not have to concern ourselves with the internal structure of the programs because measurement was performed by 8 cfrac A program to factor large integers using the continued fraction method.
Reference: [Zorn 92] <author> Zorn, B. </author> <title> The measured cost of conservative garbage collection. </title> <type> Technical Report CU-CS-573-92, </type> <institution> Department of Computer Science, University of Colorado, Boulder, Boulder, CO, </institution> <month> February </month> <year> 1992. </year> <month> 22 </month>
Reference-contexts: How well do these ad hoc solutions perform compared to CustoMalloc? Surprisingly, such optimizations are occasionally "de-optimizations" they actually slow the program execution. For example, in a previous comparison of different memory allocators and a conservative garbage collection algorithm, one of us collected the data shown in Table 6 <ref> [Zorn 92] </ref>. The values in the table are the execution time for each application normalized to that of the optimized Cartesian allocator. Larger values indicate that the program took longer to execute. Three of the applications uniformly benefit from the added ad hoc optimizations, although not to a great extent.
References-found: 19

