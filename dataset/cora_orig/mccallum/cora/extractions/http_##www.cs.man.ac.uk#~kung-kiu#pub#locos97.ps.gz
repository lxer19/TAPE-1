URL: http://www.cs.man.ac.uk/~kung-kiu/pub/locos97.ps.gz
Refering-URL: http://www.cs.man.ac.uk/~kung-kiu/pub/
Root-URL: http://www.cs.man.ac.uk
Email: kung-kiu@cs.man.ac.uk  ornaghi@dsi.unimi.it  
Title: Modules, Reuse and Correctness  
Author: Kung-Kiu Lau Mario Ornaghi 
Address: Oxford Road, Manchester M13 9PL, United Kingdom  Milano, Via Comelico 39/41, 20135 Milano, Italy  
Affiliation: Department of Computer Science, University of Manchester  Dipartimento di Scienze dell'Informazione Universita' degli studi di  
Abstract: Modules are essential for systematic software development. For formal software development, where (formal) correctness is paramount, modules should have suitable forms and a formal semantics for (reasoning about) their correctness and reuse. In this paper, we define modules as first-order theories (with isoinitial semantics) that contain logic programs, and define and discuss such modules, their reuse and composition, and their correctness. We show that our approach provides a logical basis for formal program development in an object-oriented fashion. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Bertoni, G. Mauri and P. Miglioli. </author> <title> On the power of model theory in specifying abstract data types and in capturing their recursiveness. </title> <note> Fundamenta Informaticae VI(2):127-170, </note> <year> 1983. </year>
Reference-contexts: Like initial semantics (e.g. [6]), isoinitial semantics also guarantees `no junk' and `no confusion', but has the additional capability to handle negation, which is important in database applications. (Isoinitial theories are discussed in detail in <ref> [1, 18] </ref>.) Example 2.2 The isoinitial model of the closed framework LIST (I nt; &lt;), i.e. the instance of the framework LIST (E lem; ) with the parameters E lem and instantiated to the integer type I nt and &lt; respectively, is the usual list structure (viz. the term model generated
Reference: [2] <author> A. Brogi, P. Mancarella, D. Pedreschi and F. Turini. </author> <title> Modular logic programming. </title> <journal> ACM TOPLAS 16(4) </journal> <pages> 1361-1398, </pages> <year> 1994. </year>
Reference-contexts: It follows that declarative paradigms such as logic programming are well-equipped to provide such an abstract semantics of modules, and to some extent, logic programming has succeeded in promulgating this approach (see e.g. <ref> [8, 2] </ref>). On the other hand, in our view, other approaches in logic programming which define modules as pieces of `in-line' subtext of a program will always run into difficulty when it comes to reasoning about composition and correctness (see [4] for a survey on modularity in logic programming).
Reference: [3] <author> K.M. Bruce. </author> <title> A paradigmatic object-oriented programming language: Design, static typing and semantics. </title> <editor> J. </editor> <booktitle> Functional Programming 4(2) </booktitle> <pages> 127-206, </pages> <year> 1994. </year> <title> Special issue: Type systems for object-oriented programming. </title>
Reference-contexts: However, for formal program development, i.e. developing programs that are formally correct wrt their (formal) specifications, current modular and object-oriented programming languages lack a suitable formal semantics in our view. Although some of them do have type-system based rules for program composition (see e.g. <ref> [3, 20] </ref>), we believe these languages tend to define modules at too low a level, often at a syntactic level. To reason formally about modules, their correctness, and the correctness of their reuse and composition, it is necessary to view modules very abstractly as (logical) theories.
Reference: [4] <author> M. Bugliesi, E. Lamma and P. Mello. </author> <title> Modularity in logic programming. </title> <journal> J. Logic Programming 19,20:443-502, </journal> <note> 1994. Special issue: Ten years of logic programming. </note>
Reference-contexts: On the other hand, in our view, other approaches in logic programming which define modules as pieces of `in-line' subtext of a program will always run into difficulty when it comes to reasoning about composition and correctness (see <ref> [4] </ref> for a survey on modularity in logic programming). In this paper, we define modules as first-order theories (with isoinitial semantics) that contain logic programs, and express their correctness, reuse, and the correctness of their reuse in model-theoretic terms.
Reference: [5] <author> J.A. Goguen and R.M. Burstall. Institutions: </author> <title> Abstract model theory for specification and programming. </title> <editor> J. </editor> <booktitle> ACM 39(1) </booktitle> <pages> 95-146, </pages> <year> 1992. </year>
Reference-contexts: This definition of composition essentially coincides with that of institutions <ref> [5] </ref>. However, the theory of institutions is not useful for our purposes, since it does not deal with the problem of preserving consistency. 3 Example 4.1 In our approach, framework composition is effected via parameter instantiation.
Reference: [6] <author> J. Goguen and J. Meseguer. </author> <title> Unifying functional, object-oriented and relational programming with logical semantics. </title> <editor> In B. Shriver and P. Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <pages> pages 417-477, </pages> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: In LIST , we can also use induction on lists. This illustrates the fact that in a framework we may have more than just ADT definitions. The syntax of a framework is thus similar to that of an algebraic ADT (e.g. <ref> [6, 23] </ref>). However, whereas an algebraic ADT is an initial model of its specification, the intended model of a closed framework is an isoinitial model , and an open framework has a class of isoinitial models. <p> Like initial semantics (e.g. <ref> [6] </ref>), isoinitial semantics also guarantees `no junk' and `no confusion', but has the additional capability to handle negation, which is important in database applications. (Isoinitial theories are discussed in detail in [1, 18].) Example 2.2 The isoinitial model of the closed framework LIST (I nt; &lt;), i.e. the instance of the <p> Example 4.4 (Explicit relation definitions) The (open) framework F () consisting of 2 The p-axioms of F 1 are therefore like proof obligations, or requirement theories in <ref> [6] </ref>. 3 Equational or strict Horn axioms are guaranteed to be consistent. * the signature of a specification r (x) $ R (x), where R (x) is a quantifier-free formula that does not contain r; * the axiom 8x : (r (x) $ R (x)) where is the signature of R
Reference: [7] <author> C. Kreitz, K.-K. Lau, and M. Ornaghi. </author> <title> Formal reasoning about modules, reuse and their correctness. In D.M. </title> <editor> Gabbay and H.J. Ohlbach, editors, </editor> <booktitle> Proc. Int. Conf. on Formal and Applied Practical Reasoning, LNAI 1085 </booktitle> <pages> 384-399, </pages> <publisher> Springer-Verlag 1996. </publisher>
Reference-contexts: We can show that framework composition preserves adequacy: Theorem 4.1 If F 1 ( 1 ) and F 2 ( 2 ) are adequate, and F 1 [ae; F 2 ] is defined, then F 1 [ae; F 2 ] is adequate. (A proof is given in <ref> [7] </ref>.) Theorem 4.1 provides the basis for our strategy for constructing adequate frameworks, namely to start from small adequate (closed or open) frameworks, and incrementally construct larger adequate frameworks.
Reference: [8] <author> P.M. Hill. </author> <title> A parameterised module system for constructing typed logic programs. </title> <editor> In R. Bajcsy, editor, </editor> <booktitle> Proc. 13th IJCAI , pages 874-880, </booktitle> <address> Morgan-Kaufman, </address> <year> 1993. </year>
Reference-contexts: It follows that declarative paradigms such as logic programming are well-equipped to provide such an abstract semantics of modules, and to some extent, logic programming has succeeded in promulgating this approach (see e.g. <ref> [8, 2] </ref>). On the other hand, in our view, other approaches in logic programming which define modules as pieces of `in-line' subtext of a program will always run into difficulty when it comes to reasoning about composition and correctness (see [4] for a survey on modularity in logic programming).
Reference: [9] <author> P.M. Hill and J.W. Lloyd. </author> <title> The Godel Programming Language. </title> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: 1 Introduction The idea of modules has been around for a long time, and has more recently evolved into objects in object-oriented programming. Various forms of modules and objects can be found in a variety of modern programming languages, e.g. Godel <ref> [9] </ref> and Eiffel [17]. They are important because they facilitate structured design as well as code reuse through module instantiation and composition.
Reference: [10] <author> K.-K. Lau, C.D.M. Moss and M. Ornaghi. </author> <title> Formal development of correct classes in computational logic. In D.J. Duke and A.S. </title> <editor> Evans, editors, </editor> <booktitle> Proc. BCS-FACS Northern Formal Methods Workshop, Springer-Verlag, electronic Workshops in Computing Series, </booktitle> <year> 1997. </year> <note> Abstract on page 3. (http://ewic.springer.co.uk) </note>
Reference-contexts: For brevity and clarity, we shall give a mainly informal presentation, avoiding complex notational and theoretical details. 2 Modules We define a module as follows: fl This paper is largely a revised version of <ref> [10] </ref>.
Reference: [11] <author> K.-K. Lau and M. Ornaghi. </author> <title> On specification frameworks and deductive synthesis of logic programs. </title> <editor> In L. Fribourg and F. Turini, editors, </editor> <booktitle> Proc. LOPSTR 94 and META 94 , LNCS 883, </booktitle> <pages> pages 104-121, </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Consequently, as we will see in Section 3, we can also use model-theoretic semantics to reason about the correctness of modules. A more formal treatment of frameworks is given in <ref> [11] </ref>. 2.2 Specifications A framework is the context where a specification must be written, where it receives its proper meaning, and where we can reason about it and derive correct programs from it. <p> So we say a framework is adequate if it is constructed only from adequate expansions. A useful criterion for the adequacy of an expansion is the existence of a steadfast program to compute the relation defined by the expansion (see <ref> [11] </ref>). Thus program synthesis itself provides a means of adequately expanding a framework. To extend this discussion to open frameworks, we need to address closed instances of an open framework F , i.e. compositions of F with closed frameworks C's that are closed frameworks themselves.
Reference: [12] <author> K.-K. Lau and M. Ornaghi. </author> <title> Forms of logic specifications: A preliminary study. </title> <editor> In J. Gallagher, editor, </editor> <booktitle> Proc. LOPSTR'96, </booktitle> <pages> pages 295-312, </pages> <publisher> LNCS 1207, Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: We say that S ffi is strict if it defines just one expansion; it is non-strict if it defines more than one expansion. A finer taxonomy and a more detailed discussion of specifications can be found in <ref> [12] </ref>. 2.3 Program Correctness The programs in a module M have been synthesised from their specifications. This means that they are correct wrt their specifications. We define program correctness also in a model-theoretic manner.
Reference: [13] <author> K.-K. Lau and M. Ornaghi. </author> <title> The relationship between logic programs and specifications: The subset example revisited. </title> <journal> J. Logic Programming, </journal> <volume> 30(3) </volume> <pages> 239-257, </pages> <year> 1997. </year>
Reference-contexts: This is illustrated in Figure 3. Framework F P r interpretation of r in interpretations of r wrt S r isoinitial model i of F min model h of P r The correctness relationship between programs and specifications is discussed in detail in <ref> [13] </ref>. 3 Correct Modules Now we will define the meaning of correctness for modules. Reasoning about the correctness of a module M has to be done at two levels: framework and program levels.
Reference: [14] <author> K.-K. Lau, M. Ornaghi and S.-. A. </author> <title> Tarnlund. The halting problem for deductive synthesis of logic programs. </title> <editor> In P. van Hentenryck, editor, </editor> <booktitle> Proc. 11 th Int. Conf. on Logic Programming, </booktitle> <pages> pages 665-683, </pages> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: We can also show that the framework LIST (E lem; ) in Example 3.1 (defined in Example 2.1) is an adequate open framework. 4.2 Constructing and Reusing Steadfast Programs The synthesis of steadfast programs is beyond the scope of this paper. An account can be found in <ref> [14] </ref>. Here, we will show a hierarchy of steadfast programs that can be synthesised in an open framework in a module M, to illustrate how steadfast programs can be used as correct program units in M and all its instances.
Reference: [15] <author> K.-K. Lau, M. Ornaghi and S.-. A. </author> <title> Tarnlund. Steadfast logic programs. </title> <note> Submitted to J. Logic Programming. </note>
Reference-contexts: A more abstract, formal characterisation of steadfastness is given in <ref> [15] </ref>, in both model-theoretic and proof-theoretic terms. 4 Constructing and Reusing Correct Modules To construct and/or reuse correct modules, we need to construct and compose adequate frameworks and steadfast programs. 4.1 Constructing and Reusing Adequate Frameworks In Section 3, we have already defined adequate closed frameworks.
Reference: [16] <author> F.G. McCabe. </author> <title> L& O: Logic and Objects. </title> <publisher> Prentice-Hall, </publisher> <year> 1992. </year>
Reference-contexts: It would be interesting to study how the advantages of both approaches could be combined, perhaps through the vehicle of object-oriented logic programming languages such as <ref> [16, 19] </ref>.
Reference: [17] <author> B. Meyer. </author> <title> Eiffel the Language. </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: 1 Introduction The idea of modules has been around for a long time, and has more recently evolved into objects in object-oriented programming. Various forms of modules and objects can be found in a variety of modern programming languages, e.g. Godel [9] and Eiffel <ref> [17] </ref>. They are important because they facilitate structured design as well as code reuse through module instantiation and composition. However, for formal program development, i.e. developing programs that are formally correct wrt their (formal) specifications, current modular and object-oriented programming languages lack a suitable formal semantics in our view. <p> As illustrated in Figure 5, such Module = Framework + Programs # # # (Generic) Class = ADT + Methods a module contains ADT's as well as programs or methods that work on these ADT's, and is therefore a generic class in object-oriented terminology (e.g. <ref> [22, 17] </ref>). (It is, however, not a class of objects with internal states.) However, in contrast to classes in object-oriented programming, which usually have a type-theoretic characterisation, our classes have a model-theoretic semantics. Thus a correct module is a correct class.
Reference: [18] <author> P. Miglioli, U. Moscato and M. Ornaghi. </author> <title> Abstract parametric classes and abstract data types defined by classical and constructive logical methods. </title> <journal> J. Symb. Comp. </journal> <volume> 18 </volume> <pages> 41-81, </pages> <year> 1994. </year>
Reference-contexts: Like initial semantics (e.g. [6]), isoinitial semantics also guarantees `no junk' and `no confusion', but has the additional capability to handle negation, which is important in database applications. (Isoinitial theories are discussed in detail in <ref> [1, 18] </ref>.) Example 2.2 The isoinitial model of the closed framework LIST (I nt; &lt;), i.e. the instance of the framework LIST (E lem; ) with the parameters E lem and instantiated to the integer type I nt and &lt; respectively, is the usual list structure (viz. the term model generated
Reference: [19] <author> C.D.S. Moss. </author> <title> Prolog++ The Power of Object-Oriented and Logic Programming. </title> <publisher> Addison Wesley, </publisher> <year> 1994. </year>
Reference-contexts: It would be interesting to study how the advantages of both approaches could be combined, perhaps through the vehicle of object-oriented logic programming languages such as <ref> [16, 19] </ref>.
Reference: [20] <author> J. Palsberg and M.I. Schwartzbach. </author> <title> Object-Oriented Type Systems. </title> <publisher> Wiley, </publisher> <year> 1994. </year>
Reference-contexts: However, for formal program development, i.e. developing programs that are formally correct wrt their (formal) specifications, current modular and object-oriented programming languages lack a suitable formal semantics in our view. Although some of them do have type-system based rules for program composition (see e.g. <ref> [3, 20] </ref>), we believe these languages tend to define modules at too low a level, often at a syntactic level. To reason formally about modules, their correctness, and the correctness of their reuse and composition, it is necessary to view modules very abstractly as (logical) theories.
Reference: [21] <author> J.C. Shepherdson. </author> <title> Negation in logic programming. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 19-88. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1988. </year>
Reference: [22] <author> P. Wegner. </author> <title> The object-oriented classification paradigm. </title> <editor> In B. Shriver and P. Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <pages> pages 479-560, </pages> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: As illustrated in Figure 5, such Module = Framework + Programs # # # (Generic) Class = ADT + Methods a module contains ADT's as well as programs or methods that work on these ADT's, and is therefore a generic class in object-oriented terminology (e.g. <ref> [22, 17] </ref>). (It is, however, not a class of objects with internal states.) However, in contrast to classes in object-oriented programming, which usually have a type-theoretic characterisation, our classes have a model-theoretic semantics. Thus a correct module is a correct class.
Reference: [23] <author> M. Wirsing. </author> <title> Algebraic specification. </title> <editor> In J. Van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <pages> pages 675-788. </pages> <publisher> Elsevier, </publisher> <year> 1990. </year>
Reference-contexts: In LIST , we can also use induction on lists. This illustrates the fact that in a framework we may have more than just ADT definitions. The syntax of a framework is thus similar to that of an algebraic ADT (e.g. <ref> [6, 23] </ref>). However, whereas an algebraic ADT is an initial model of its specification, the intended model of a closed framework is an isoinitial model , and an open framework has a class of isoinitial models.
References-found: 23

