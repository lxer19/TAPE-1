URL: ftp://ftp.cs.utah.edu/pub/iccl92.ps
Refering-URL: http://www.cs.utah.edu/~gary/MSO-publications.html
Root-URL: 
Title: Modularity meets Inheritance a previously unobtainable spectrum of features to be combined in a cohesive
Author: Gilad Bracha Gary Lindstrom 
Note: This allows  
Address: Salt Lake City, Utah 84112 Salt Lake City, Utah 84112  
Affiliation: Department of Computer Science Department of Computer Science University of Utah University of Utah  
Abstract: We "unbundle" several roles of classes in existing languages, by providing a suite of operators independently controlling such effects as combination, modification, encapsulation, name resolution, and sharing, all on the single notion of module. All module operators are forms of inheritance. Thus, inheritance not only is not in conflict with modularity in our system, but is its foundation. We demonstrate our approach in a language (called Jigsaw, as in the tool, not the puzzle!). Our language is modular in two senses: it manipulates modules, and it is highly modular in its own conception, permitting various module combinators to be included, omitted, or newly constructed in various realizations. 1 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> America, P. </author> <title> A parallel object-oriented language with inheritance and subtyping. </title> <booktitle> In Proc. of the Joint ACM Conf. on Object-Oriented Programming, Systems, Languages and Applications and the European Conference on Object-Oriented Programming (Oct. </booktitle> <year> 1990), </year> <pages> pp. 161-168. </pages>
Reference-contexts: In addition, if the language is strongly typed, we often find that a class fulfills additional roles: 10. Defining a type. 11. Defining a subtyping relation. Following other modern object-oriented language designs (e.g., <ref> [1, 5] </ref>), we separate inheritance from sub-typing. The following section presents Jigsaw's operator suite.
Reference: [2] <author> Bentley, J. L. </author> <title> More Programming Pearls. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1988. </year>
Reference-contexts: Second, our framework can be applied to object oriented languages, to enhance their expressive power. 5.1 Adding modules to existing languages Many languages do not have adequate modularity constructs. These include widely used programming languages (e.g., C [16], Pascal [13]), as well as countless special-purpose and "little-languages" <ref> [2, Column 9] </ref>, where the effort of designing specific mechanisms for modularity is difficult to justify, but which could still benefit from such mechanisms. The simple notions of module and interface defined above are largely language independent.
Reference: [3] <author> Bracha, G. </author> <title> The Programming Language Jigsaw: Mixins, Modularity and Multiple Inheritance. </title> <type> PhD thesis, </type> <institution> University of Utah, </institution> <year> 1992. </year>
Reference-contexts: The resulting language is not object-oriented, since it does not support first class objects. Nevertheless, it 3 Imperative versions of these operators have been defined in <ref> [3] </ref>. employs inheritance. Inheritance supports module in-terconnection by combining self reference among modules, and, of course, allows existing code to be extended and modified. A wide range of languages can be extended as described here. Many of these languages are dynamically typed. <p> The main subtlety lies in manipulating these offsets, since previously published schemes [18, 29, 10] cannot be used in the presence of mixins. The details of the implementation are beyond the scope of this paper, and are discussed in <ref> [3] </ref>. 6 Related work 6.1 Generator operations Many of the operators presented here were first proposed by Cook in [9]. There, a general mechanism for deriving generator operations from record operations was described.
Reference: [4] <author> Bracha, G., and Cook, W. </author> <title> Mixin-based inheritance. </title> <booktitle> In Proc. of the Joint ACM Conf. on Object-Oriented Programming, Systems, Languages and Applications and the European Conference on Object-Oriented Programming (Oct. </booktitle> <year> 1990). </year>
Reference-contexts: Such a denotable modification is called a mixin. Mix-ins represent an important form of reuse, but have been expressible only in dynamically typed languages (e.g., [15, 30]), where inheritance violates encapsulation. Support for mixins in an encapsulated manner has been been the topic of recent research <ref> [4, 12] </ref>. 2.5 Abstract classes and frameworks One of the most useful ideas in object-oriented programming is that of an abstract class. An abstract class is an incomplete definition, in which one or more of the methods declared by the class are not given definitions. <p> In modeling language constructs, more elaborate operators were used. In particular, it was necessary to introduce parametric abstractions called wrappers. These were later elevated to explicit language constructs called mixins in <ref> [4] </ref>, and, independently, in [12]. 4 An early, less ambitious version of this work appeared in [4]. The novelty here is in providing a comprehensive suite of operations, and making them explicit linguistic constructs. In addition, the uniform use of generators to model all definitional structures is new. <p> In modeling language constructs, more elaborate operators were used. In particular, it was necessary to introduce parametric abstractions called wrappers. These were later elevated to explicit language constructs called mixins in <ref> [4] </ref>, and, independently, in [12]. 4 An early, less ambitious version of this work appeared in [4]. The novelty here is in providing a comprehensive suite of operations, and making them explicit linguistic constructs. In addition, the uniform use of generators to model all definitional structures is new. <p> In addition, the uniform use of generators to model all definitional structures is new. The operator suite also includes new operations (namely hide, show, freeze, freeze-except and copy-as). 6.2 Mixins This work grew out of an earlier study of mixin-based inheritance <ref> [4] </ref>. Some of the limitations of mixin based inheritance have been addressed here. These include the absence of fine-grain sharing, of renaming facilities and of a symmetric merge operation. Until now, mixins have been modeled as parametric abstractions called wrappers. <p> Until now, mixins have been modeled as parametric abstractions called wrappers. Cook used an operator combining a generator and a wrapper in his compositional semantics of inheritance [9]. This operator was also used by Hense [12]. In <ref> [4] </ref>, the override operation was defined as a binary operation on wrappers, enabling composition of mixins. The main purpose of wrappers was to allow access to overridden definitions. The required functionality can be achieved using explicit operator for this purpose.
Reference: [5] <author> Cardelli, L., Donahue, J., Glassman, L., Jordan, M., Kalsow, B., and Nelson, G. </author> <type> Modula-3 report (revised). Tech. Rep. 52, </type> <institution> Digital Equipment Corporation Systems Research Center, </institution> <month> Dec. </month> <year> 1989. </year>
Reference-contexts: In addition, if the language is strongly typed, we often find that a class fulfills additional roles: 10. Defining a type. 11. Defining a subtyping relation. Following other modern object-oriented language designs (e.g., <ref> [1, 5] </ref>), we separate inheritance from sub-typing. The following section presents Jigsaw's operator suite. <p> However, any language that is extended with Jigsaw style modules gains substantial benefits from encapsulation, separate compilation (for compiled languages), modifiability and the ability to define partially specified modules analogous to abstract classes. 5.2 Extending an object-oriented lan guage We are currently implementing an upwardly compatible extension of Modula-3 <ref> [5] </ref>, incorporating most of the operators described in this paper. In this extension, the operators are applied not to the modules of Modula-3 but to its classes (known as object types). 4 Naturally, the full flexibility of Jigsaw is not supported.
Reference: [6] <author> Cardelli, L., Donahue, J., Jordan, M., Kalsow, B., and Nelson, G. </author> <title> The Modula-3 type system. </title> <booktitle> In Proc. of the ACM Symp. on Principles of Programming Languages (Jan. 1989), Association for Computing Machinery, </booktitle> <pages> pp. 202-212. </pages>
Reference-contexts: However, we face technical difficulties related to the typing of existential data types. A related issue is our use of structural subtyping, in contrast to "name-based" subtyping in [25]. Both forms are useful; currently, we focus on structural sub-typing, which is more appropriate between different modules or programs <ref> [6] </ref>.
Reference: [7] <author> Cardelli, L., and Mitchell, J. C. </author> <title> Operations on records. </title> <type> Tech. Rep. 48, </type> <institution> Digital Equipment Corporation Systems Research Center, </institution> <month> Aug. </month> <year> 1989. </year>
Reference-contexts: The desired object is the least fixed point of the generator function Y (P gen). 2.2 Record operations We now define our record operations. Similar operations have been used in the study of typed record calculi <ref> [7, 11, 32, 27] </ref>. However, this paper is not concerned with the typing problems raised by these operators. Here, record operations are only used in the definitions of module operators.
Reference: [8] <author> Cardelli, L., and Wegner, P. </author> <title> On understanding types, data abstraction, </title> <journal> and polymor-phism. Computing Surveys 17, </journal> <volume> 4 (1985), </volume> <pages> 471-522. </pages>
Reference-contexts: We demonstrate these points via the module manipulation language Jigsaw. For concreteness, we assume that Jigsaw manipulates modules written in an applicative language with a type system based upon bounded universal quantification <ref> [8] </ref>. However, the discussion remains virtually unchanged if modules are written in another language. In particular, our operator definitions are not significantly impacted by the use of an imperative language. Similarly, though we assume a subtype relation, we do not rely on its particulars.
Reference: [9] <author> Cook, W. </author> <title> A Denotational Semantics of Inheritance. </title> <type> PhD thesis, </type> <institution> Brown University, </institution> <year> 1989. </year>
Reference-contexts: Objects are thus inherently self-referential. The standard technique for modeling self reference is fixpoint theory [23]. Using fixpoint theory, an object may be modeled using a record-generating function (called a generator following Cook <ref> [9] </ref>). Figure 1 shows a simple object and its associated generator function. This function takes a record as a parameter, and returns a record as a result. The result record is similar to the object being modeled. <p> The name a must be defined in r, and b must not. 2.3 Inheritance This subsection discusses the denotational semantics of inheritance <ref> [14, 26, 9] </ref>. Inheritance provides a way of modifying self-referential structures [9]. When a value is modified via inheritance, all self reference within the result refers to the modified value. Inheritance involves manipulating the self reference within objects. <p> The name a must be defined in r, and b must not. 2.3 Inheritance This subsection discusses the denotational semantics of inheritance [14, 26, 9]. Inheritance provides a way of modifying self-referential structures <ref> [9] </ref>. When a value is modified via inheritance, all self reference within the result refers to the modified value. Inheritance involves manipulating the self reference within objects. Technically, this is achieved by manipulating generators, before taking their fixpoint [26], [9]. Figure 2 illustrates this process. <p> Inheritance provides a way of modifying self-referential structures <ref> [9] </ref>. When a value is modified via inheritance, all self reference within the result refers to the modified value. Inheritance involves manipulating the self reference within objects. Technically, this is achieved by manipulating generators, before taking their fixpoint [26], [9]. Figure 2 illustrates this process. The object MP inherits from P, but specializes the dist method. MP is modeled by a generator that invokes the generator for P. <p> Semantically, an abstract class may be modeled as an inconsistent generator. An inconsistent generator has the form s: :e, where e : 0 and is a subtype of 0 <ref> [9] </ref>. This captures the fact that self reference within the class () assumes more methods than the class provides ( 0 ). One cannot take the fixpoint of such a generator, since its domain is a proper subtype of its range. <p> The details of the implementation are beyond the scope of this paper, and are discussed in [3]. 6 Related work 6.1 Generator operations Many of the operators presented here were first proposed by Cook in <ref> [9] </ref>. There, a general mechanism for deriving generator operations from record operations was described. However, the operators defined by Cook were used to illustrate the principle of manipulating self-reference by means of generators. In modeling language constructs, more elaborate operators were used. <p> These include the absence of fine-grain sharing, of renaming facilities and of a symmetric merge operation. Until now, mixins have been modeled as parametric abstractions called wrappers. Cook used an operator combining a generator and a wrapper in his compositional semantics of inheritance <ref> [9] </ref>. This operator was also used by Hense [12]. In [4], the override operation was defined as a binary operation on wrappers, enabling composition of mixins. The main purpose of wrappers was to allow access to overridden definitions. The required functionality can be achieved using explicit operator for this purpose.
Reference: [10] <author> Ellis, M. A., and Stroustrup, B. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: 1 Introduction This paper argues that inheritance, properly formulated, is a powerful modularity mechanism, and can constitute the basis of a module manipulation language. We arrive at our formulation of inheritance by observing that in languages supporting multiple inheritance (e.g., <ref> [10, 24, 28] </ref>), classes are burdened with too many roles. The class construct is "large" and monolithic. We opt to simplify classes, and partition their functionality among separate operators. Classes are reduced to a simple notion of module a mutually recursive scope. <p> The expectation is that these missing method definitions will be provided in subsequently defined subclasses. In some languages, abstract classes have no special linguistic support. Programmers define "dummy" routines that typically produce a run-time error. More recent languages <ref> [10, 24] </ref> explicitly support abstract classes. In these languages, methods that are undefined in the abstract class are identified by special syntax. Here we use the C++ terminology, and refer to such methods as pure virtuals. Abstract classes are essential to the definition of frameworks. <p> The tables include both pointers to code for method execution, and offsets within objects. Offsets are necessary because under multiple inheritance, instances of subclasses do not necessarily share a common prefix with instances of parent classes. The main subtlety lies in manipulating these offsets, since previously published schemes <ref> [18, 29, 10] </ref> cannot be used in the presence of mixins. The details of the implementation are beyond the scope of this paper, and are discussed in [3]. 6 Related work 6.1 Generator operations Many of the operators presented here were first proposed by Cook in [9].
Reference: [11] <author> Harper, R., and Pierce, B. </author> <title> A record calculus based on symmetric concatenation. </title> <booktitle> In Proc. of the ACM Symp. on Principles of Programming Languages (Jan. </booktitle> <year> 1991), </year> <pages> pp. 131-142. </pages>
Reference-contexts: The desired object is the least fixed point of the generator function Y (P gen). 2.2 Record operations We now define our record operations. Similar operations have been used in the study of typed record calculi <ref> [7, 11, 32, 27] </ref>. However, this paper is not concerned with the typing problems raised by these operators. Here, record operations are only used in the definitions of module operators.
Reference: [12] <author> Hense, A. V. </author> <title> Denotational semantics of an object oriented programming language with explicit wrappers. </title> <type> Tech. Rep. </type> <institution> A 11/90, Fachbereich Infor-matik, Universitaet des Saarlandes, </institution> <month> Nov. </month> <year> 1990. </year>
Reference-contexts: Such a denotable modification is called a mixin. Mix-ins represent an important form of reuse, but have been expressible only in dynamically typed languages (e.g., [15, 30]), where inheritance violates encapsulation. Support for mixins in an encapsulated manner has been been the topic of recent research <ref> [4, 12] </ref>. 2.5 Abstract classes and frameworks One of the most useful ideas in object-oriented programming is that of an abstract class. An abstract class is an incomplete definition, in which one or more of the methods declared by the class are not given definitions. <p> In modeling language constructs, more elaborate operators were used. In particular, it was necessary to introduce parametric abstractions called wrappers. These were later elevated to explicit language constructs called mixins in [4], and, independently, in <ref> [12] </ref>. 4 An early, less ambitious version of this work appeared in [4]. The novelty here is in providing a comprehensive suite of operations, and making them explicit linguistic constructs. In addition, the uniform use of generators to model all definitional structures is new. <p> Until now, mixins have been modeled as parametric abstractions called wrappers. Cook used an operator combining a generator and a wrapper in his compositional semantics of inheritance [9]. This operator was also used by Hense <ref> [12] </ref>. In [4], the override operation was defined as a binary operation on wrappers, enabling composition of mixins. The main purpose of wrappers was to allow access to overridden definitions. The required functionality can be achieved using explicit operator for this purpose.
Reference: [13] <author> Jensen, K., and Wirth, N. </author> <title> Pascal User Manual and Report, second ed. </title> <publisher> Springer-Verlag, </publisher> <year> 1978. </year>
Reference-contexts: Second, our framework can be applied to object oriented languages, to enhance their expressive power. 5.1 Adding modules to existing languages Many languages do not have adequate modularity constructs. These include widely used programming languages (e.g., C [16], Pascal <ref> [13] </ref>), as well as countless special-purpose and "little-languages" [2, Column 9], where the effort of designing specific mechanisms for modularity is difficult to justify, but which could still benefit from such mechanisms. The simple notions of module and interface defined above are largely language independent.
Reference: [14] <author> Kamin, S. </author> <title> Inheritance in Smalltalk-80: A deno--tational definition. </title> <booktitle> In Proc. of the ACM Symp. on Principles of Programming Languages. Association for Computing Machinery, </booktitle> <year> 1988, </year> <pages> pp. 80-87. </pages>
Reference-contexts: The name a must be defined in r, and b must not. 2.3 Inheritance This subsection discusses the denotational semantics of inheritance <ref> [14, 26, 9] </ref>. Inheritance provides a way of modifying self-referential structures [9]. When a value is modified via inheritance, all self reference within the result refers to the modified value. Inheritance involves manipulating the self reference within objects.
Reference: [15] <author> Keene, S. E. </author> <title> Object-Oriented Programming in Common Lisp. </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: It is often desirable to denote such a modification indepen-dently, and reuse it. An example is given in Figure 4. Such a denotable modification is called a mixin. Mix-ins represent an important form of reuse, but have been expressible only in dynamically typed languages (e.g., <ref> [15, 30] </ref>), where inheritance violates encapsulation. Support for mixins in an encapsulated manner has been been the topic of recent research [4, 12]. 2.5 Abstract classes and frameworks One of the most useful ideas in object-oriented programming is that of an abstract class.
Reference: [16] <author> Kernighan, B. W., and Ritchie, D. M. </author> <title> The C Programming Language. </title> <publisher> Prentice-Hall, </publisher> <address> Engle-wood Cliffs, N.J., </address> <year> 1978. </year>
Reference-contexts: Second, our framework can be applied to object oriented languages, to enhance their expressive power. 5.1 Adding modules to existing languages Many languages do not have adequate modularity constructs. These include widely used programming languages (e.g., C <ref> [16] </ref>, Pascal [13]), as well as countless special-purpose and "little-languages" [2, Column 9], where the effort of designing specific mechanisms for modularity is difficult to justify, but which could still benefit from such mechanisms. The simple notions of module and interface defined above are largely language independent.
Reference: [17] <author> Kristensen, B. B., Madsen, O. L., Moller-Pedersen, B., and Nygaard, K. </author> <title> The Beta Programming Language. </title> <booktitle> In Research Directions in Object-Oriented Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1987, </year> <pages> pp. 7-48. </pages>
Reference-contexts: Some languages support this using the notion of non-virtual attributes (static binding). Static binding can be achieved by simply not referencing an attribute through self. However, this does not allow for changing the status of a virtual attribute to non-virtual (e.g. as in Beta <ref> [17] </ref>). In addition, it complicates the model, since not all attributes are referenced in the same way - there are two kinds, declared differently. In our model, it is preferable to have only virtual attributes declared, and perform the change by means of an operator on generators.
Reference: [18] <author> Krogdahl, S. </author> <title> An efficient implementation of Simula classes with multiple prefixing. </title> <type> Tech. Rep. 83, </type> <institution> Institute for Informatics, University of Oslo, </institution> <year> 1984. </year>
Reference-contexts: The tables include both pointers to code for method execution, and offsets within objects. Offsets are necessary because under multiple inheritance, instances of subclasses do not necessarily share a common prefix with instances of parent classes. The main subtlety lies in manipulating these offsets, since previously published schemes <ref> [18, 29, 10] </ref> cannot be used in the presence of mixins. The details of the implementation are beyond the scope of this paper, and are discussed in [3]. 6 Related work 6.1 Generator operations Many of the operators presented here were first proposed by Cook in [9].
Reference: [19] <author> Linton, M. A., Calder, P. R., and M.Vlissides, J. InterViews: </author> <title> A C++ graphical interface toolkit. </title> <type> Tech. Rep. </type> <institution> CSL-TR-88-358, Stanford University, </institution> <month> July </month> <year> 1988. </year>
Reference-contexts: The user of a framework will adopt it as a basis for his or her application, typically modifying some of the framework's abstract classes to tailor them to specific needs. Examples of frameworks are <ref> [19, 21, 31, 34] </ref>. Abstract classes support a powerful form of parameterization, unique to the object oriented paradigm. While standard parametrization allows entities to refer to parameters, abstract classes close the loop by also allowing parameters to refer to the parameterized entity (i.e., via a self construct).
Reference: [20] <author> MacQueen, D. </author> <title> Modules for Standard ML. </title> <booktitle> In Proc. of the ACM Conf. on Lisp and Functional Programming (Aug. </booktitle> <year> 1984), </year> <pages> pp. 198-207. </pages>
Reference-contexts: A module is a self-referential scope, binding names to values. A binding of name to a value is a definition. Unlike ML <ref> [20] </ref>, modules do not bind names to types. Type abbreviations may be used, as syntactic sugar. 2 Typing in Jigsaw is purely structural. Modules may include not only definitions, but declarations. A declaration gives the type of an attribute, but no value for it. <p> Mitchell also chose to incorporate inheritance into a module language, an extension of the ML module system <ref> [20] </ref>. Some similar operations are supported, embedded in a more conventional syntax. Underlying both systems are denotational models involving the manipulation of self reference, and typing based on bounded quantification. There are many differences, however.
Reference: [21] <author> Madany, P. W., Campbell, R. H., Russo, V. F., and Leyens, D. E. </author> <title> A class hierarchy for building stream-oriented file systems. </title> <booktitle> In Eu-ropean Conference on Object-Oriented Programming (July 1989), </booktitle> <editor> S. Cook, Ed., </editor> <booktitle> British Computer Society Workshop Series, </booktitle> <publisher> Cambridge University Press, </publisher> <pages> pp. 311-328. </pages>
Reference-contexts: The user of a framework will adopt it as a basis for his or her application, typically modifying some of the framework's abstract classes to tailor them to specific needs. Examples of frameworks are <ref> [19, 21, 31, 34] </ref>. Abstract classes support a powerful form of parameterization, unique to the object oriented paradigm. While standard parametrization allows entities to refer to parameters, abstract classes close the loop by also allowing parameters to refer to the parameterized entity (i.e., via a self construct).
Reference: [22] <author> Madhav, N., </author> <month> September </month> <year> 1991. </year> <type> Personal communication. </type>
Reference-contexts: A consequence of the semantics of copy except, copy only is that separate compilation is compromised. A parent module must always be compiled before its use, and any change to it requires recompilation of its heir modules <ref> [22] </ref>. We support inheriting from separately compiled modules without restriction. Our approach has the benefits of simplicity and modularity. It does not rely upon dependent sums or products, or on multiple universes of types.
Reference: [23] <author> Manna, Z. </author> <title> The Mathematical Theory of Computation. </title> <publisher> McGraw-Hill, </publisher> <year> 1974. </year>
Reference-contexts: Finally, we present our conclusions. 2 Background 2.1 Generators In object oriented programming, objects include data and code that operates upon that data. Objects are thus inherently self-referential. The standard technique for modeling self reference is fixpoint theory <ref> [23] </ref>. Using fixpoint theory, an object may be modeled using a record-generating function (called a generator following Cook [9]). Figure 1 shows a simple object and its associated generator function. This function takes a record as a parameter, and returns a record as a result.
Reference: [24] <author> Meyer, B. </author> <title> Object Oriented Software Construction. </title> <booktitle> Prentice-Hall International, </booktitle> <address> Hertfordshire, England, </address> <year> 1988. </year>
Reference-contexts: 1 Introduction This paper argues that inheritance, properly formulated, is a powerful modularity mechanism, and can constitute the basis of a module manipulation language. We arrive at our formulation of inheritance by observing that in languages supporting multiple inheritance (e.g., <ref> [10, 24, 28] </ref>), classes are burdened with too many roles. The class construct is "large" and monolithic. We opt to simplify classes, and partition their functionality among separate operators. Classes are reduced to a simple notion of module a mutually recursive scope. <p> The expectation is that these missing method definitions will be provided in subsequently defined subclasses. In some languages, abstract classes have no special linguistic support. Programmers define "dummy" routines that typically produce a run-time error. More recent languages <ref> [10, 24] </ref> explicitly support abstract classes. In these languages, methods that are undefined in the abstract class are identified by special syntax. Here we use the C++ terminology, and refer to such methods as pure virtuals. Abstract classes are essential to the definition of frameworks.
Reference: [25] <author> Mitchell, J., Meldal, S., and Madhav, N. </author> <title> An extension of Standard ML modules with sub-typing and inheritance. </title> <booktitle> In Proc. of the ACM Symp. on Principles of Programming Languages (Jan. </booktitle> <year> 1991), </year> <pages> pp. 270-278. </pages>
Reference-contexts: The required functionality can be achieved using explicit operator for this purpose. This allows the use of generators instead of wrappers, simplifying definitions. This reflects our strategy of simplifying the structure and pushing more functionality into the operator set. 6.3 Mitchell Mitchell, in <ref> [25] </ref>, presented an extension to the ML module system that is in some ways similar to our work. Mitchell also chose to incorporate inheritance into a module language, an extension of the ML module system [20]. Some similar operations are supported, embedded in a more conventional syntax. <p> Even though inheritance is part of the module system, it is not essential to it. Instead, the ML notions of structures and functors are used to define and interconnect modules. Some of the inheritance constructs defined in <ref> [25] </ref> violate encapsulation (viz. copy except, copy only). These constructs inherently require knowledge of the internal structure of the "parent" module. A consequence of the semantics of copy except, copy only is that separate compilation is compromised. <p> Language designers may easily add or modify operations as necessary. An expression based language also allows users to compose operations more freely. Our framework supports abstract classes and mixins. 5 Mixins cannot be expressed in the framework of <ref> [25] </ref>, and there is no explicit support for abstract classes (though the traditional device of giving dummy definitions for pure virtual methods is always available, with its concomitant disadvantages). On the other hand, Mitchell's approach supports modules implementing abstract data types. <p> We would like to extend our framework with an analogous set of operators for abstract data types. However, we face technical difficulties related to the typing of existential data types. A related issue is our use of structural subtyping, in contrast to "name-based" subtyping in <ref> [25] </ref>. Both forms are useful; currently, we focus on structural sub-typing, which is more appropriate between different modules or programs [6]. Finally, unlike [25], we give semantic definitions of all operations. 7 Conclusion We have presented a collection of operations on modules, that supports a uniquely wide range of object oriented <p> A related issue is our use of structural subtyping, in contrast to "name-based" subtyping in <ref> [25] </ref>. Both forms are useful; currently, we focus on structural sub-typing, which is more appropriate between different modules or programs [6]. Finally, unlike [25], we give semantic definitions of all operations. 7 Conclusion We have presented a collection of operations on modules, that supports a uniquely wide range of object oriented programming techniques, including frameworks, multiple inheritance and mixins, as well as separate compilation, all in a type safe and encapsulated manner. <p> The language is itself modular, allowing for easier extension, modification and experimentation. Finally, we believe such a language is also easier to learn, use and reason about. 5 Abstract classes are mentioned in <ref> [25] </ref>, but only as substitutes for interfaces.
Reference: [26] <author> Reddy, U. S. </author> <title> Objects as closures: Abstract semantics of object-oriented languages. </title> <booktitle> In Proc. ACM Conf. on Lisp and Functional Programming (1988), </booktitle> <pages> pp. 289-297. </pages>
Reference-contexts: The name a must be defined in r, and b must not. 2.3 Inheritance This subsection discusses the denotational semantics of inheritance <ref> [14, 26, 9] </ref>. Inheritance provides a way of modifying self-referential structures [9]. When a value is modified via inheritance, all self reference within the result refers to the modified value. Inheritance involves manipulating the self reference within objects. <p> Inheritance provides a way of modifying self-referential structures [9]. When a value is modified via inheritance, all self reference within the result refers to the modified value. Inheritance involves manipulating the self reference within objects. Technically, this is achieved by manipulating generators, before taking their fixpoint <ref> [26] </ref>, [9]. Figure 2 illustrates this process. The object MP inherits from P, but specializes the dist method. MP is modeled by a generator that invokes the generator for P.
Reference: [27] <author> Remy, D. </author> <title> Typechecking records and variants in a natural extension to ML. </title> <booktitle> In Proc. of the ACM Symp. on Principles of Programming Languages (1989), </booktitle> <pages> pp. 77-88. </pages>
Reference-contexts: The desired object is the least fixed point of the generator function Y (P gen). 2.2 Record operations We now define our record operations. Similar operations have been used in the study of typed record calculi <ref> [7, 11, 32, 27] </ref>. However, this paper is not concerned with the typing problems raised by these operators. Here, record operations are only used in the definitions of module operators.
Reference: [28] <author> Schaffert, C., Cooper, T., Bullis, B., Kil-ian, M., and Wilpolt, C. </author> <title> An introduction to Trellis/Owl. </title> <booktitle> In Proc. of the ACM Conf. on Object-Oriented Programming, Systems, Languages and Applications (1986), </booktitle> <pages> pp. 9-16. </pages>
Reference-contexts: 1 Introduction This paper argues that inheritance, properly formulated, is a powerful modularity mechanism, and can constitute the basis of a module manipulation language. We arrive at our formulation of inheritance by observing that in languages supporting multiple inheritance (e.g., <ref> [10, 24, 28] </ref>), classes are burdened with too many roles. The class construct is "large" and monolithic. We opt to simplify classes, and partition their functionality among separate operators. Classes are reduced to a simple notion of module a mutually recursive scope.
Reference: [29] <author> Stroustrup, B. </author> <title> Multiple Inheritance for C++. </title> <booktitle> In European Unix User Group Spring Conference (May 1987). </booktitle>
Reference-contexts: The tables include both pointers to code for method execution, and offsets within objects. Offsets are necessary because under multiple inheritance, instances of subclasses do not necessarily share a common prefix with instances of parent classes. The main subtlety lies in manipulating these offsets, since previously published schemes <ref> [18, 29, 10] </ref> cannot be used in the presence of mixins. The details of the implementation are beyond the scope of this paper, and are discussed in [3]. 6 Related work 6.1 Generator operations Many of the operators presented here were first proposed by Cook in [9].
Reference: [30] <author> Ungar, D., and Smith, R. </author> <title> SELF: The power of simplicity. </title> <booktitle> In Proc. of the ACM Conf. on Object-Oriented Programming, Systems, Languages and Applications (Oct. </booktitle> <year> 1987). </year>
Reference-contexts: It is often desirable to denote such a modification indepen-dently, and reuse it. An example is given in Figure 4. Such a denotable modification is called a mixin. Mix-ins represent an important form of reuse, but have been expressible only in dynamically typed languages (e.g., <ref> [15, 30] </ref>), where inheritance violates encapsulation. Support for mixins in an encapsulated manner has been been the topic of recent research [4, 12]. 2.5 Abstract classes and frameworks One of the most useful ideas in object-oriented programming is that of an abstract class.
Reference: [31] <author> Vlissides, J., and Linton, M. Unidraw: </author> <title> A framework for building domain-specific graphical editors. </title> <type> Tech. Rep. </type> <institution> CSL-TR-89-380, Stanford University, </institution> <month> July </month> <year> 1989. </year>
Reference-contexts: The user of a framework will adopt it as a basis for his or her application, typically modifying some of the framework's abstract classes to tailor them to specific needs. Examples of frameworks are <ref> [19, 21, 31, 34] </ref>. Abstract classes support a powerful form of parameterization, unique to the object oriented paradigm. While standard parametrization allows entities to refer to parameters, abstract classes close the loop by also allowing parameters to refer to the parameterized entity (i.e., via a self construct).
Reference: [32] <author> Wand, M. </author> <title> Type inference for record concatenation and multiple inheritance. </title> <booktitle> In Proc. IEEE Symposium on Logic in Computer Science (1989), </booktitle> <pages> pp. 92-97. </pages>
Reference-contexts: The desired object is the least fixed point of the generator function Y (P gen). 2.2 Record operations We now define our record operations. Similar operations have been used in the study of typed record calculi <ref> [7, 11, 32, 27] </ref>. However, this paper is not concerned with the typing problems raised by these operators. Here, record operations are only used in the definitions of module operators.
Reference: [33] <author> Wegner, P. </author> <title> The object-oriented classification paradigm. </title> <booktitle> In Research Directions in Object-Oriented Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1987, </year> <pages> pp. 479-560. </pages>
Reference-contexts: This solution is more verbose. Also, our solution is more natural, since modules do denote a different type of value (generators) than objects (which denote records). Another reason for keeping modules and instances distinct is that the decision to make module instances first class values (as in "Class-based" languages <ref> [33] </ref>) need not imply that modules themselves are first class values. If modules are identified with instances, the two decisions cannot be separated. We do not want the use of our approach to constrain language designers in this way.
Reference: [34] <author> Weinand, A., Gamma, E., and Marty, R. </author> <title> ET++ an object-oriented application framework in C++. </title> <booktitle> In Proc. of the ACM Conf. on Object-Oriented Programming, Systems, Languages and Applications (1988), </booktitle> <pages> pp. 46-57. </pages>
Reference-contexts: The user of a framework will adopt it as a basis for his or her application, typically modifying some of the framework's abstract classes to tailor them to specific needs. Examples of frameworks are <ref> [19, 21, 31, 34] </ref>. Abstract classes support a powerful form of parameterization, unique to the object oriented paradigm. While standard parametrization allows entities to refer to parameters, abstract classes close the loop by also allowing parameters to refer to the parameterized entity (i.e., via a self construct).
References-found: 34

