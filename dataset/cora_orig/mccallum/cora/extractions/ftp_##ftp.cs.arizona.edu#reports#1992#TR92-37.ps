URL: ftp://ftp.cs.arizona.edu/reports/1992/TR92-37.ps
Refering-URL: http://www.cs.arizona.edu/research/reports.html
Root-URL: http://www.cs.arizona.edu
Title: Combinatorial algorithms for DNA sequence assembly  
Author: John D. Kececioglu Eugene W. Myers 
Date: Revised October 20, 1992; revised January 15, 1993  
Pubnum: TR 92-37  
Abstract: The trend towards very large DNA sequencing projects, such as those being undertaken as part of the human genome initiative, necessitates the development of efficient and precise algorithms for assembling a long DNA sequence from the fragments obtained by shotgun sequencing or other methods. The sequence reconstruction problem that we take as our formulation of DNA sequence assembly is a variation of the shortest common superstring problem, complicated by the presence of sequencing errors and reverse complements of fragments. Since the simpler superstring problem is NP-hard, any efficient reconstruction procedure must resort to heuristics. In this paper, however, a four phase approach based on rigorous design criteria is presented, and has been found to be very accurate in practice. Our method is robust in the sense that it can accommodate high sequencing error rates and list a series of alternate solutions in the event that several appear equally good. Moreover it uses a limited form of multiple sequence alignment to detect, and often correct, errors in the data. Our combined algorithm has successfully reconstructed non-repetitive sequences of length 50,000 sampled at error rates of as high as 10 percent. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Blum, Avrim, Tao Jiang, Ming Li, John Tromp, and Mihalis Yannakakis. </author> <title> Linear approximation of shortest superstrings. </title> <booktitle> Proceedings of the 23rd ACM Symposium on Theory of Computation, </booktitle> <pages> 328-336, </pages> <year> 1991. </year>
Reference-contexts: Tarhio and Ukkonen [36], Turner [38], and Ukkonen [39] show that a simple greedy algorithm finds a superstring whose amount of compression is within a factor of 1 2 of the maximum, and give efficient implementations. Blum, Avrim, Jiang, Li, Tromp and Yannkakis <ref> [1] </ref> prove that the greedy algorithm delivers a super-string at most 4 times longer than the shortest, and that a simple variant delivers a superstring at most 3 times longer than the shortest. It is not known whether these bounds are tight.
Reference: [2] <author> Camerini, P., L. Fratta, and F. Maffioli. </author> <title> A note on finding optimum branchings. </title> <booktitle> Networks 9, </booktitle> <pages> 309-312, </pages> <year> 1979. </year>
Reference: [3] <author> Camerini, P., L. Fratta, and F. Maffioli. </author> <title> The k best spanning arborescences of a network. </title> <booktitle> Networks 10, </booktitle> <pages> 91-110, </pages> <year> 1980. </year>
Reference-contexts: The K branchings of greatest weight can be generated in O (KE log V ) time and O (K + E + V ) space, as shown by Camerini, Fratta and Maffioli <ref> [3] </ref>. Our method of generating branchings is similar to Camerini et al., which applies the branchings algorithm of Tarjan [37], but has some differences. <p> Choosing an edge from the root to vertex v in a rooted spanning arborescence means no in-edge to v is chosen in the corresponding branching. The branchings algorithms of Camerini et al. <ref> [3] </ref> and Gabow et al. [11] actually compute maximum weight rooted spanning arborescences. The second step of the transformation removes the edge constraints. <p> Clearly the set of unconstrained arbores-cences over this new graph is the same as the set of constrained arborescences over the original graph. 4.2.3 Time and space The method we have outlined, which is essentially the method of Camerini et al. <ref> [3] </ref>, simplified by the fact that we can more easily identify the edges e and f on which to decompose a subproblem, can be implemented efficiently in terms of the number of iterations and the size of the original graph.
Reference: [4] <author> Chang, William and Eugene Lawler. </author> <title> Approximate string matching in sublinear expected time. </title> <booktitle> Proceedings of the 31st IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> 118-124, </pages> <year> 1990. </year>
Reference-contexts: Huang [16] applies a local alignment algorithm of Smith and Waterman [34] to compute an overlap that maximizes a linear function of the number exact matches and errors in the alignment, and uses a filtering technique of Chang and Lawler <ref> [4] </ref> to avoid considering some of the pairs of fragments whose alignment score is below a fixed threshold. Our work may be distinguished from prior theoretical investigations in that we address both sequencing errors and unknown orientation, and in contrast to earlier software, each phase is a well-defined problem.
Reference: [5] <author> Chvatal, Vaclav and David Sankoff. </author> <title> Longest common subsequences of two random sequences. </title> <journal> Journal of Applied Probability 12, </journal> <pages> 306-315, </pages> <year> 1975. </year>
Reference-contexts: While the exact probability of an alignment is unknown even for this model, a result of Chvatal and Sankoff <ref> [5] </ref> on random common subsequences gives a good upper bound. The alignments that we compute match a pair of characters only when they are equal.
Reference: [6] <author> Cull, Paul and Jim Holloway. </author> <title> Reconstructing sequences from shotgun data. </title> <type> Manuscript, </type> <year> 1992. </year>
Reference-contexts: Cull and Holloway <ref> [6] </ref> apply the suffix array data structure of Manber and Myers [22] to find overlaps, where fragments are assumed to contain only substitution errors, and the suffix and prefix of each fragment is assumed to match only one other fragment in an overlap longer than a given threshold.
Reference: [7] <author> Foulser, David. </author> <title> A linear time algorithm for DNA sequencing. </title> <type> Technical Report 812, </type> <institution> Department of Computer Science, Yale University, </institution> <address> New Haven, Connecticut 06520, </address> <year> 1990. </year>
Reference-contexts: Details may be found in [18]. Related work Prior work related to DNA sequence assembly may be classified into three categories. In the first class of papers, Shapiro [32], Hutchinson [17], Smetanic and Polozov [33], Gallant [12], and Foulser <ref> [7] </ref> examine an early model of the problem where fragments do not contain errors and are partitioned into classes such that concatenating the fragments within each class, in some order, gives the underlying sequence.
Reference: [8] <author> Fredman, Michael, Robert Sedgewick, Daniel Sleator, and Robert Tarjan. </author> <title> The pairing heap: A new form of self-adjusting heap. </title> <journal> Algorithmica 1, </journal> <pages> 111-129, </pages> <year> 1986. </year>
Reference-contexts: For a layout of coverage depth D, this is O (D 2 ) time. In practice we recommend a different spanning tree algorithm. The O (E + V log V ) time algorithm requires a Fibonacci heap [9] or in practice a pairing heap <ref> [8] </ref> and since a spanning tree is computed for every column, the overhead of these data structures is unappealing. DNA sequence assembly 30 Moreover, our spanning tree problems often vary only slightly from window to window, in which case it is unnecessary to repeatedly compute a tree from scratch.
Reference: [9] <author> Fredman, Michael and Robert Tarjan. </author> <title> Fibonacci heaps and their uses in improved network optimization algorithms. </title> <journal> Journal of the Association for Computing Machinery 34:3, </journal> <pages> 596-615, </pages> <year> 1987. </year>
Reference-contexts: Constructing the graph takes O (E + V ) time, where V is the number of fragments and E is the number pairs of fragments with nonzero same or opp. Tree T can be found in O (E + V log V ) time <ref> [9] </ref>. We can locate R in O (V ) time by two passes over T . The first pass computes the total distance of each vertex A to all vertices in the subtree rooted at A bottom-up, along with the size of the subtree at A. <p> For overlaps with a total of M pairs of matched characters, weighting the overlaps takes O (M ) time. For a closure of e E overlaps, computing a maximum weight spanning tree takes O ( e E + V log V ) time <ref> [9] </ref>. This delivers a trace in O (E + M + V log V ) time. Kececioglu [18] shows the resulting trace has weight at least 2 V of the maximum. This bound is tight, but pessimistic. <p> For a layout of coverage depth D, this is O (D 2 ) time. In practice we recommend a different spanning tree algorithm. The O (E + V log V ) time algorithm requires a Fibonacci heap <ref> [9] </ref> or in practice a pairing heap [8] and since a spanning tree is computed for every column, the overhead of these data structures is unappealing.
Reference: [10] <author> Gabow, Harold. </author> <title> Two algorithms for generating weighted spanning trees in order. </title> <journal> SIAM Journal on Computing 6:2, </journal> <pages> 139-150, </pages> <year> 1977. </year>
Reference-contexts: The computation tree appears to require O (KE) spaceit has O (K) nodes and each node has an in- and out-list of size O (E)but this can be reduced to constant space per node using the following idea of Gabow <ref> [10] </ref>. The in- and out-sets for a left child l in the computation tree may be obtained from its parent p by adding one edge e to p's out-set to form l's out-set, and by copying p's in-set.
Reference: [11] <author> Gabow, Harold, Zvi Galil, Thomas Spencer, </author> <title> and Robert Tarjan.Efficient algorithms for finding minimum spanning trees in undirected and directed graphs. </title> <type> Combinatorica 6, </type> <pages> 109-122, </pages> <year> 1986. </year>
Reference-contexts: A maximum weight branching over a graph of E edges and V vertices can be computed in O (E + V log V ) time and O (E + V ) space, as shown by Gabow, Galil, Spencer and Tarjan <ref> [11] </ref>. The K branchings of greatest weight can be generated in O (KE log V ) time and O (K + E + V ) space, as shown by Camerini, Fratta and Maffioli [3]. <p> These differences are due to our particular application, namely generating branchings to meet a dovetail-chain constraint, which allows us to apply the algorithm of Gabow et al. <ref> [11] </ref> to generate K branchings in O (K (E + V log V )) time. 4.2.1 Forming constraints Suppose we have computed a maximum weight branching, which is not dovetail-chain. <p> Choosing an edge from the root to vertex v in a rooted spanning arborescence means no in-edge to v is chosen in the corresponding branching. The branchings algorithms of Camerini et al. [3] and Gabow et al. <ref> [11] </ref> actually compute maximum weight rooted spanning arborescences. The second step of the transformation removes the edge constraints. <p> Each maximum weight branching computation involves reducing the constrained branching problem to an unconstrained arborescence problem. The reduction takes O (V ) time, and computing a maximum DNA sequence assembly 19 weight rooted spanning arborescence takes O (E + V log V ) time <ref> [11] </ref>. The time for heap operations can be bounded as follows. The heap contains leaves of the computation tree, and generating a branching creates one leaf. Thus the heap is of size O (K) = O (2 E ). <p> Space is required for the constrained branchings algorithm, the computation tree, and the heap. Computing a branching takes O (E + V ) space <ref> [11] </ref>. The heap uses constant space per leaf, or O (K) space in all.
Reference: [12] <author> Gallant, John. </author> <title> The complexity of the overlap method for sequencing biopolymers. </title> <journal> Journal of Theoretical Biology 101, </journal> <pages> 1-17, </pages> <year> 1983. </year>
Reference-contexts: Since SUPERSTRING is NP-complete [13], this implies that RECONSTRUCT is NP-complete. Details may be found in [18]. Related work Prior work related to DNA sequence assembly may be classified into three categories. In the first class of papers, Shapiro [32], Hutchinson [17], Smetanic and Polozov [33], Gallant <ref> [12] </ref>, and Foulser [7] examine an early model of the problem where fragments do not contain errors and are partitioned into classes such that concatenating the fragments within each class, in some order, gives the underlying sequence.
Reference: [13] <author> Gallant, John, David Maier, and James Storer. </author> <title> On finding minimal length superstrings. </title> <journal> Journal of Computer and System Sciences 20:1, </journal> <pages> 50-58, </pages> <year> 1980. </year> <title> DNA sequence assembly 41 </title>
Reference-contexts: In fact, SUPERSTRING can be reduced to the sequence reconstruction problem with * = 0. Since SUPERSTRING is NP-complete <ref> [13] </ref>, this implies that RECONSTRUCT is NP-complete. Details may be found in [18]. Related work Prior work related to DNA sequence assembly may be classified into three categories.
Reference: [14] <author> Gingeras, T., J. Milazzo, D. Sciaky, and R. Roberts. </author> <title> Computer programs for the assembly of DNA sequences. </title> <journal> Nucleic Acids Research 7:2, </journal> <pages> 529-545, </pages> <year> 1979. </year>
Reference-contexts: In the third category of papers, Staden [35], Gingeras, Milazzo, Sciaky and Roberts <ref> [14] </ref>, and Peltola, S oderlund and Ukkonen [27] develop software for sequence assembly. Peltola, Soderlund, Tarhio and Ukkonen [26] describes the algorithms used in [27], and also gives the first statement of the sequence reconstruction problem. <p> The packages of Staden [35] and Gingeras et al. <ref> [14] </ref> use rules of thumb, such as, extend an alignment with 5 matches if this can be done with only 3 errors, while the system of Peltola et al. [26] tries to minimize d=l, which has the rough behavior of L (l; d), but does not discriminate between longer and shorter
Reference: [15] <author> Gusfield, Dan, Gad Landau, and Baruch Schieber. </author> <title> An efficient algorithm for the all pairs suffix-prefix problem. </title> <journal> Information Processing Letters 41, </journal> <pages> 181-185, </pages> <year> 1992. </year>
Reference-contexts: These papers deal with error, and with orientation, but do not characterize the quality of the reconstruction that is output. In addition, three papers have recently come to our attention that look at the subtask of computing overlaps between pairs of fragments. Gusfield, Landau and Schieber <ref> [15] </ref> show that with the suffix tree data structure the longest overlap beween a suffix of one fragment and a prefix of another can be determined for all pairs of fragments in time linear in the size of the input DNA sequence assembly 3 and output, if no errors are permitted
Reference: [16] <author> Huang, Xiaoqiu. </author> <title> A contig assembly program based on sensitive detection of fragment overlaps. </title> <booktitle> Genomics 14, </booktitle> <pages> 18-25, </pages> <year> 1992. </year>
Reference-contexts: Huang <ref> [16] </ref> applies a local alignment algorithm of Smith and Waterman [34] to compute an overlap that maximizes a linear function of the number exact matches and errors in the alignment, and uses a filtering technique of Chang and Lawler [4] to avoid considering some of the pairs of fragments whose alignment <p> Huang <ref> [16] </ref> minimizes l d, which also approximates L (l; d), but trades matches against errors linearly, which from an objective point of view, is arbitrary. However, both Peltola et al. [26] and Huang [16] are able to accomodate substitution errors within their objective function. <p> Huang <ref> [16] </ref> minimizes l d, which also approximates L (l; d), but trades matches against errors linearly, which from an objective point of view, is arbitrary. However, both Peltola et al. [26] and Huang [16] are able to accomodate substitution errors within their objective function.
Reference: [17] <author> Hutchinson, George. </author> <title> Evaluation of polymer sequence fragment data using graph theory. </title> <journal> Bulletin of Mathematical Biophysics 31, </journal> <pages> 541-562, </pages> <year> 1969. </year>
Reference-contexts: Since SUPERSTRING is NP-complete [13], this implies that RECONSTRUCT is NP-complete. Details may be found in [18]. Related work Prior work related to DNA sequence assembly may be classified into three categories. In the first class of papers, Shapiro [32], Hutchinson <ref> [17] </ref>, Smetanic and Polozov [33], Gallant [12], and Foulser [7] examine an early model of the problem where fragments do not contain errors and are partitioned into classes such that concatenating the fragments within each class, in some order, gives the underlying sequence.
Reference: [18] <author> Kececioglu, John. </author> <title> Exact and Approximation Algorithms for DNA Sequence Reconstruction. </title> <type> PhD dissertation, Technical Report 91-26, </type> <institution> Department of Computer Science, The University of Arizona, </institution> <address> Tucson, Arizona 85721, </address> <year> 1991. </year>
Reference-contexts: In fact, SUPERSTRING can be reduced to the sequence reconstruction problem with * = 0. Since SUPERSTRING is NP-complete [13], this implies that RECONSTRUCT is NP-complete. Details may be found in <ref> [18] </ref>. Related work Prior work related to DNA sequence assembly may be classified into three categories. <p> Figure 4 gives an illustration. ORIENT is NP-complete. As may be suspected, it is polynomial-time equivalent to the maximum weight cut problem <ref> [18] </ref>. 3.2 An approximation algorithm While finding an optimal orientation is hard, it is easy to find an orientation that is close to optimal. <p> We take our problem to be the following. Definition The maximum weight dovetail-chain branching problem, BRANCHING, is, given a directed graph (V; E) with edge weight function w, with edges classified as either dovetails or containments, find a dovetail-chain branching B E maximizing w (B). Kececioglu <ref> [18] </ref> generalizes the correspondence between dovetail-chain branchings and layouts to the case of error, and reduces the sequence reconstruction problem to the maximum weight dovetail-chain branching problem. The reduction requires two assumptions on fragment error: that error is evenly distributed and approximate matching is transitive at the input error rate. <p> For overlap graphs with * 6= 0, the tightest analysis we know of for the totally greedy algorithm gives a factor of 1 3 . In fact there are graphs where totally greedy performs better than partially greedy, and vice versa <ref> [18] </ref>. Even so, we conjecture that the partially greedy algorithm achieves at least a factor of 1 3 . Moreover, the weight of the last branching generated is an upper bound on the weight of an optimal dovetail-chain branching. <p> Our problem is the following. Definition The maximum weight trace problem, TRACE, is, given an alignment graph (V; E; ) with edge weight function w, find a trace T E maximizing P TRACE is NP-complete <ref> [18] </ref> and remains so even when, as in our application, the edges between any two sequences form an alignment and the length of a sequence is bounded by a constant. <p> For a closure of e E overlaps, computing a maximum weight spanning tree takes O ( e E + V log V ) time [9]. This delivers a trace in O (E + M + V log V ) time. Kececioglu <ref> [18] </ref> shows the resulting trace has weight at least 2 V of the maximum. This bound is tight, but pessimistic. <p> DNA sequence assembly 40 Another weakness of our method is that it artificially separates orientation and layout. (See <ref> [18] </ref> for an explanation of why this is necessary, given our choice of a relaxation to maximum weight branchings.) As we have noted, solving each of these problems optimally does not guarantee an optimal solution to the combined reconstruction problem. What is desired is an algorithm that solves both simultaneously.
Reference: [19] <author> Kececioglu, John and Eugene Myers. </author> <title> A procedural interface for a fragment assembly tool. </title> <type> Technical Report 89-5, </type> <institution> Department of Computer Science, The University of Arizona, </institution> <address> Tucson, Ari-zona 85721, </address> <year> 1989. </year>
Reference-contexts: a multiple sequence alignment of L columns in O (N + D 2 L) time, and O (D + E + *N 2 ) space. 6 Experimental results To explore the viability of this approach to sequence reconstruction, we have implemented a software package embodying the preceding suite of algorithms <ref> [19] </ref>. In both the orientation and layout phases, the exact algorithms are run first. If the size of a search tree becomes too large, for example when K = 500, the phases switch to the approximation algorithms to produce a solution.
Reference: [20] <author> Lawler, Eugene. </author> <title> A procedure for computing the k best solutions to discrete optimization problems and its application to the shortest path problem. </title> <booktitle> Management Science 18, </booktitle> <pages> 401-405, </pages> <year> 1972. </year>
Reference-contexts: Let I and O be the in- and out-sets for P. One subproblem receives constraints I and O [ feg, and the other receives constraints I [ feg and O [ ff g. This follows a general method of Lawler <ref> [20] </ref> for generating next-best solutions to combinatorial optimization problems. The resulting collection of problems is conveniently represented by a computation tree.
Reference: [21] <author> Li, Ming. </author> <title> Towards a DNA sequencing theory. </title> <booktitle> Proceedings of the 31st IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> 125-134, </pages> <year> 1990. </year>
Reference-contexts: It is not known whether these bounds are tight. Li <ref> [21] </ref> examines sequence assembly from the viewpoint of computational learning theory and shows that an approximation algorithm for SUPERSTRING will learn the underlying sequence in polynomial time in the PAC model of learning, given fragments without error and with known orientation.
Reference: [22] <author> Manber, Udi and Gene Myers. </author> <title> Suffix arrays: A new method for on-line string searches. </title> <booktitle> Proceedings of the 1st Annual ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <pages> 319-327, </pages> <year> 1990. </year> <note> To appear in SIAM Journal on Computing. </note>
Reference-contexts: Cull and Holloway [6] apply the suffix array data structure of Manber and Myers <ref> [22] </ref> to find overlaps, where fragments are assumed to contain only substitution errors, and the suffix and prefix of each fragment is assumed to match only one other fragment in an overlap longer than a given threshold.
Reference: [23] <author> Margot, Jean, G. William Demers, and Ross Hardison. </author> <title> Complete nucleotide sequence of the rabbit fi-like globin gene cluster: Analysis of intergenic sequences and comparison with the human fi-like globin gene cluster. </title> <journal> Journal of Molecular Biology 205, </journal> <pages> 15-40, </pages> <year> 1989. </year>
Reference-contexts: Our intention here was to explore the robustness of our approach to error in the data. A random sequence has no structure, while biological sequences contain repeats. In the remaining experiments, numbered 4 through 12, we used the human fi-like globin gene cluster sequence <ref> [23] </ref>. This 73,360 character sequence contains many approximate repeats, and presents a challenging reconstruction problem. Thirteen short interspersed Alu repeats are present, nine in the forward direction and four in the reverse, as well as eight long interspersed L1Hs repeats, of which two are forward and six reversed.
Reference: [24] <author> Mehlhorn, Kurt. </author> <title> Data Structures and Algorithms, Volume 1: Sorting and Searching. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1984. </year>
Reference-contexts: over several unmatched characters, but the total time is proportional to the number of alignment columns and the length of the sequences. 13 The time can be reduced to O (n + k log (m=k)) = O (n + k log n) using a balanced tree to perform the insertions <ref> [24, pages 222-224] </ref> though this is unnecessary for our small window graphs. DNA sequence assembly 31 5.3.5 Weighting trace edges Biologists often denote the nucleotides of the DNA sequence for a fragment with ambiguous base codes.
Reference: [25] <author> Myers, Eugene. </author> <title> Incremental alignment algorithms and their applications. </title> <type> Technical Report 86-2, </type> <institution> Department of Computer Science, The University of Arizona, </institution> <address> Tucson, Arizona 85721, </address> <year> 1986. </year>
Reference-contexts: Here we assume m n. Myers <ref> [25] </ref> has shown that it is possible to solve all O (mn) subproblems in O (ffin) time, where ffi is the maximum edit distance allowed. 5 In our application, ffi = b*m + *nc, so this gives an O (*n 2 ) time algorithm.
Reference: [26] <author> Peltola, Hannu, Hans Soderlund, Jorma Tarhio, and Esko Ukkonen. </author> <title> Algorithms for some string matching problems arising in molecular genetics. </title> <booktitle> Proceedings of the 9th IFIP World Computer Congress, </booktitle> <pages> 59-64, </pages> <year> 1983. </year>
Reference-contexts: In the third category of papers, Staden [35], Gingeras, Milazzo, Sciaky and Roberts [14], and Peltola, S oderlund and Ukkonen [27] develop software for sequence assembly. Peltola, Soderlund, Tarhio and Ukkonen <ref> [26] </ref> describes the algorithms used in [27], and also gives the first statement of the sequence reconstruction problem. These papers deal with error, and with orientation, but do not characterize the quality of the reconstruction that is output. <p> Our work may be distinguished from prior theoretical investigations in that we address both sequencing errors and unknown orientation, and in contrast to earlier software, each phase is a well-defined problem. Like Peltola et al. <ref> [26] </ref> we cannot claim that our algorithm as a whole solves RECONSTRUCT, but in distinction, each phase solves or approximates a precise optimization problem. Moreover, for the case of no error and known orientation we can say that our algorithm, without modification, solves RECONSTRUCT, which is equivalent to SUPER STRING. <p> The packages of Staden [35] and Gingeras et al. [14] use rules of thumb, such as, extend an alignment with 5 matches if this can be done with only 3 errors, while the system of Peltola et al. <ref> [26] </ref> tries to minimize d=l, which has the rough behavior of L (l; d), but does not discriminate between longer and shorter overlaps with the same error density. <p> Huang [16] minimizes l d, which also approximates L (l; d), but trades matches against errors linearly, which from an objective point of view, is arbitrary. However, both Peltola et al. <ref> [26] </ref> and Huang [16] are able to accomodate substitution errors within their objective function.
Reference: [27] <author> Peltola, Hannu, Hans Soderlund, and Esko Ukkonen. SEQAID: </author> <title> a DNA sequence assembly program based on a mathematical model. </title> <journal> Nucleic Acids Research 12:1, </journal> <pages> 307-321, </pages> <year> 1984. </year>
Reference-contexts: In the third category of papers, Staden [35], Gingeras, Milazzo, Sciaky and Roberts [14], and Peltola, S oderlund and Ukkonen <ref> [27] </ref> develop software for sequence assembly. Peltola, Soderlund, Tarhio and Ukkonen [26] describes the algorithms used in [27], and also gives the first statement of the sequence reconstruction problem. These papers deal with error, and with orientation, but do not characterize the quality of the reconstruction that is output. <p> In the third category of papers, Staden [35], Gingeras, Milazzo, Sciaky and Roberts [14], and Peltola, S oderlund and Ukkonen <ref> [27] </ref> develop software for sequence assembly. Peltola, Soderlund, Tarhio and Ukkonen [26] describes the algorithms used in [27], and also gives the first statement of the sequence reconstruction problem. These papers deal with error, and with orientation, but do not characterize the quality of the reconstruction that is output.
Reference: [28] <author> Press, William, Brian Flannery, Saul Teukolsky, and William Vetterling. </author> <title> Numerical Recipes in C: </title> <booktitle> The Art of Scientific Computing. </booktitle> <publisher> Cambridge University Press, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: The probability PrfD dg is equal to I p (d; n d + 1), where I x (a; b) is the incomplete beta function. There are fast numerical methods for evaluating I x (a; b), which yield an efficient test of inequality (3). (See for instance <ref> [28, pages 178-180] </ref>.) Finally, we note that both the match significance and the error distribution criteria are needed. Without a match significance criterion, time and space are wasted on short overlaps, such as those that align one character.
Reference: [29] <author> Sankoff, David. </author> <title> Minimal mutation trees of sequences. </title> <journal> SIAM Journal on Applied Mathematics 28:1, </journal> <pages> 35-42, </pages> <year> 1975. </year>
Reference-contexts: To do this, we start with the alignment produced by the heuristic. A window containing a fixed 12 This observation, expressed in different language, can be found in many papers. Perhaps the first occurrence is in <ref> [29] </ref>. DNA sequence assembly 27 number of columns is then swept across the alignment. The width of the window is a parameter to the algorithm. Over the alignment subgraph defined by the characters in the window, we compute a maximum weight spanning tree.
Reference: [30] <author> Sankoff, David and Vaclav Chvatal. </author> <title> An upper bound technique for lengths of common subsequences. Time Warps, String Edits, and Macromolecules: The Theory and Practice of Sequence Comparison, </title> <editor> David Sankoff and Joseph Kruskal editors, </editor> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachu-setts, 353-357, </address> <year> 1983. </year> <title> DNA sequence assembly 42 </title>
Reference-contexts: Thus a substitution is counted as a deletion error followed by an insertion error. The quantities that we measure for an alignment are l, the length of the common subsequence, and d, the number of errors. Sankoff and Chvatal <ref> [30] </ref> show that the number of sequences of length l + d over an alphabet of size s that contain a fixed subsequence of length l is N s (l; d) = 0id l + d ! independent of the particular subsequence.
Reference: [31] <author> Sankoff, David and Joseph Kruskal, </author> <title> editors. Time Warps, String Edits, and Macromolecules: The Theory and Practice of Sequence Comparison. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1983. </year>
Reference-contexts: However, both Peltola et al. [26] and Huang [16] are able to accomodate substitution errors within their objective function. DNA sequence assembly 7 distance for each dovetail and containment may be computed in O (mn) time by the standard dynamic programming algorithm <ref> [31] </ref>, this gives an O (m 2 n 2 ) time algorithm, and it is easy to bring this down to O (m 2 n) time by combining subproblems. Here we assume m n. <p> In other words the constraints of T are satisfiable if and only if fl on the components of T is acyclic. We call a satisfiable set T a multiple sequence trace. This generalizes the standard notion of trace in sequence comparison <ref> [31, page 12] </ref>. Given a trace, we can form a multiple sequence alignment by determining its connected components and topologically sorting them. For a trace of M edges over a graph of N vertices, finding the connected components takes O (M +N ) time.
Reference: [32] <author> Shapiro, Marvin. </author> <title> An algorithm for reconstructing protein and RNA sequences. </title> <journal> Journal of the Association for Computing Machinery 14, </journal> <pages> 720-731, </pages> <year> 1967. </year>
Reference-contexts: Since SUPERSTRING is NP-complete [13], this implies that RECONSTRUCT is NP-complete. Details may be found in [18]. Related work Prior work related to DNA sequence assembly may be classified into three categories. In the first class of papers, Shapiro <ref> [32] </ref>, Hutchinson [17], Smetanic and Polozov [33], Gallant [12], and Foulser [7] examine an early model of the problem where fragments do not contain errors and are partitioned into classes such that concatenating the fragments within each class, in some order, gives the underlying sequence.
Reference: [33] <author> Smetanic, Y. and R. Polozov. </author> <title> On the algorithms for determining the primary structure of biopolymers. </title> <journal> Bulletin of Mathematical Biology 41, </journal> <pages> 1-20, </pages> <year> 1979. </year>
Reference-contexts: Since SUPERSTRING is NP-complete [13], this implies that RECONSTRUCT is NP-complete. Details may be found in [18]. Related work Prior work related to DNA sequence assembly may be classified into three categories. In the first class of papers, Shapiro [32], Hutchinson [17], Smetanic and Polozov <ref> [33] </ref>, Gallant [12], and Foulser [7] examine an early model of the problem where fragments do not contain errors and are partitioned into classes such that concatenating the fragments within each class, in some order, gives the underlying sequence.
Reference: [34] <author> Smith, Temple F. and Michael S. Waterman. </author> <title> Identification of common molecular subsequences. </title> <journal> Journal of Molecular Biology 147, </journal> <pages> 195-197, </pages> <year> 1981. </year>
Reference-contexts: Huang [16] applies a local alignment algorithm of Smith and Waterman <ref> [34] </ref> to compute an overlap that maximizes a linear function of the number exact matches and errors in the alignment, and uses a filtering technique of Chang and Lawler [4] to avoid considering some of the pairs of fragments whose alignment score is below a fixed threshold.
Reference: [35] <author> Staden, R. </author> <title> A strategy of DNA sequencing employing computer programs. </title> <journal> Nucleic Acids Research 6:7, </journal> <pages> 2601-2610, </pages> <year> 1979. </year>
Reference-contexts: Li [21] examines sequence assembly from the viewpoint of computational learning theory and shows that an approximation algorithm for SUPERSTRING will learn the underlying sequence in polynomial time in the PAC model of learning, given fragments without error and with known orientation. In the third category of papers, Staden <ref> [35] </ref>, Gingeras, Milazzo, Sciaky and Roberts [14], and Peltola, S oderlund and Ukkonen [27] develop software for sequence assembly. Peltola, Soderlund, Tarhio and Ukkonen [26] describes the algorithms used in [27], and also gives the first statement of the sequence reconstruction problem. <p> The packages of Staden <ref> [35] </ref> and Gingeras et al. [14] use rules of thumb, such as, extend an alignment with 5 matches if this can be done with only 3 errors, while the system of Peltola et al. [26] tries to minimize d=l, which has the rough behavior of L (l; d), but does not <p> Each directed tree of the branching is called an arborescence. A set of edges that in addition satisfies properties (3) and (4) we call a dovetail-chain branching. Its dovetail edges form disjoint chains that procede from the roots. Following Staden <ref> [35] </ref>, we call a maximal set of fragments that cover a contiguous interval in the layout, a contig. Note that the contigs of the layout correspond to the arborescences of the branching.
Reference: [36] <author> Tarhio, Jorma and Esko Ukkonen. </author> <title> A greedy approximation algorithm for constructing shortest common superstrings. </title> <booktitle> Theoretical Computer Science 57, </booktitle> <pages> 131-145, </pages> <year> 1988. </year>
Reference-contexts: These papers show that the problem can be solved in polynomial time. The second category of papers analyze approximation algorithms for the shortest common superstring problem, which we have indicated is equivalent to the sequence reconstruction problem without error and with fragment orientation known. Tarhio and Ukkonen <ref> [36] </ref>, Turner [38], and Ukkonen [39] show that a simple greedy algorithm finds a superstring whose amount of compression is within a factor of 1 2 of the maximum, and give efficient implementations. <p> We note that greedy repair is essentially a greedy algorithm for dovetail-chain branchings, started from a partial branching. In a sense it is partially greedy, since the initial branching is obtained by a global optimization. Tarhio and Ukkonen <ref> [36] </ref> and Turner [38] analyze the totally greedy algorithm on overlap graphs with * = 0, and show that it finds a solution of weight at least 1 2 the maximum.
Reference: [37] <author> Tarjan, Robert. </author> <title> Finding optimum branchings. </title> <booktitle> Networks 7, </booktitle> <pages> 25-35, </pages> <year> 1977. </year>
Reference-contexts: Our method of generating branchings is similar to Camerini et al., which applies the branchings algorithm of Tarjan <ref> [37] </ref>, but has some differences. <p> Since (A;B) forms a cycle if and only if A and B are members of the same arborescence, we can test for cycle creation in essentially constant time by maintaining a partition of fragments into arborescences with disjoint sets <ref> [37] </ref>. Thus the dominant step is sorting the edges. In short greedy repair can be performed in O (E log V ) time worst-case. Interestingly it is asymptotically more expensive to greedily repair a branching than to compute one of maximum weight. This is in the worst-case, however.
Reference: [38] <author> Turner, Jonathan. </author> <title> Approximation algorithms for the shortest common superstring problem. </title> <booktitle> Information and Computation 83, </booktitle> <pages> 1-20, </pages> <year> 1989. </year>
Reference-contexts: These papers show that the problem can be solved in polynomial time. The second category of papers analyze approximation algorithms for the shortest common superstring problem, which we have indicated is equivalent to the sequence reconstruction problem without error and with fragment orientation known. Tarhio and Ukkonen [36], Turner <ref> [38] </ref>, and Ukkonen [39] show that a simple greedy algorithm finds a superstring whose amount of compression is within a factor of 1 2 of the maximum, and give efficient implementations. <p> We note that greedy repair is essentially a greedy algorithm for dovetail-chain branchings, started from a partial branching. In a sense it is partially greedy, since the initial branching is obtained by a global optimization. Tarhio and Ukkonen [36] and Turner <ref> [38] </ref> analyze the totally greedy algorithm on overlap graphs with * = 0, and show that it finds a solution of weight at least 1 2 the maximum.
Reference: [39] <author> Ukkonen, Esko. </author> <title> A linear time algorithm for finding approximate shortest common superstrings. </title> <journal> Algorithmica 5, </journal> <pages> 313-323, </pages> <year> 1990. </year>
Reference-contexts: The second category of papers analyze approximation algorithms for the shortest common superstring problem, which we have indicated is equivalent to the sequence reconstruction problem without error and with fragment orientation known. Tarhio and Ukkonen [36], Turner [38], and Ukkonen <ref> [39] </ref> show that a simple greedy algorithm finds a superstring whose amount of compression is within a factor of 1 2 of the maximum, and give efficient implementations.
References-found: 39

