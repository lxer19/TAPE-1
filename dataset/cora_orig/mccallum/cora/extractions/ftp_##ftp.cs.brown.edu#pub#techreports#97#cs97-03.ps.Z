URL: ftp://ftp.cs.brown.edu/pub/techreports/97/cs97-03.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-97-03.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> R. Fourer, D. Gay, and B.W. Kernighan. AMPL: </author> <title> A Modeling Language for Mathematical Programming. </title> <publisher> The Scientific Press, </publisher> <address> San Francisco, CA, </address> <year> 1993. </year>
Reference-contexts: The two approaches have complementary strengths, weaknesses, and application areas. The design of global search algorithms is now supported by a variety of tools, ranging from modeling languages such as AMPL <ref> [1] </ref> and Nu-merica [10] to constraint programming languages such CHIP, Ilog Solver, CLP (&lt;), Prolog-IV, and Oz to name only a few.
Reference: [2] <author> F. Glover. </author> <title> Tabu Search. </title> <journal> Orsa Journal of Computing, </journal> <volume> 1 </volume> <pages> 190-206, </pages> <year> 1989. </year>
Reference-contexts: Local-izer statements are organized around the traditional concepts of LS algorithms (e.g., neighborhoods, acceptance criteria, and restarting states), they support the essence of many LS algorithms (e.g., local improvement [6], simulated annealing [4], tabu search <ref> [2] </ref>, and GSAT [8]), and they can be tailored to the application at hand to exploit its underlying structure. The main technical tool in Localizer is the concept of invariant which relieves users from the need of maintaining complex data structures incrementally and makes it simpler to define neighborhoods concisely.
Reference: [3] <author> D. Johnson, C. Aragon, L. McGeoch, and C. Schevon. </author> <title> Optimization by Simulated Annealing: An Experimental Evaluation; Part II, Graph Coloring and Number Partitioning. </title> <journal> Operations Research, </journal> <volume> 39(3) </volume> <pages> 378-406, </pages> <year> 1991. </year>
Reference-contexts: The design of LS algorithms is not an easy task however. The same problem can be modeled in many different ways (see for instance <ref> [3] </ref>), making the design process an inherently experimental enterprise. In addition, efficient implementations of LS algorithms often require maintaining complex data structures incrementally, which is a tedious and error-prone activity. This paper reports on an attempt to support the design and implementation of LS algorithms. <p> It shows how a simulated annealing algorithm proposed in <ref> [3] </ref> can be expressed in Localizer. Of particular interest is once again the close similarity between the problem description and the model. Note that graph coloring could be expressed as an instance of SAT as could any NP-Complete problem.
Reference: [4] <author> S. Kirkpatrick, C. Gelatt, and M. Vecchi. </author> <title> Optimization by Simulated Annealing. </title> <journal> Science, </journal> <volume> 220 </volume> <pages> 671-680, </pages> <year> 1983. </year>
Reference-contexts: Local-izer statements are organized around the traditional concepts of LS algorithms (e.g., neighborhoods, acceptance criteria, and restarting states), they support the essence of many LS algorithms (e.g., local improvement [6], simulated annealing <ref> [4] </ref>, tabu search [2], and GSAT [8]), and they can be tailored to the application at hand to exploit its underlying structure.
Reference: [5] <author> S. Minton, M.D. Johnston, </author> <title> and A.B. Philips. Solving Large-Scale Constraint Satisfaction and Scheduling Problems using a Heuristic Repair Method. </title> <booktitle> In AAAI-90, </booktitle> <month> August </month> <year> 1990. </year>
Reference-contexts: q [i] := v where i in Conflicts; v in 1..n minimizing sizeof (f j in 1::n j q [j] = v or q [j] = v + i j or q [j] = v + j ig); accept when : : :; is an example of min-conflict heuristics of <ref> [5] </ref>. The GSAT statement simply states to flip the value of the literal a [i] (1 i n) which produces the best improvement in the objective function (keyword best).
Reference: [6] <author> C.H. Papadimitriou and K. Steiglitz. </author> <title> Combinatorial Optimization: Algorithms and Complexity. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1982. </year>
Reference-contexts: Local-izer statements are organized around the traditional concepts of LS algorithms (e.g., neighborhoods, acceptance criteria, and restarting states), they support the essence of many LS algorithms (e.g., local improvement <ref> [6] </ref>, simulated annealing [4], tabu search [2], and GSAT [8]), and they can be tailored to the application at hand to exploit its underlying structure. <p> Our current research focuses on building a large collection of applications in Localizer to understand the strengths and limitations of the language, to study how frameworks such as Guided Local Search [11] and dynamic k-opt <ref> [6] </ref> can be supported, and to identify which extensions are needed to turn our initial design into a practical tool. We are also contemplating extensions of the language to support genetic algorithms (e.g., maintaining multiple configurations) and to integrate consistency techniques to enhance the expressivity of invariants.
Reference: [7] <author> B. Selman and H. Kautz. </author> <title> An Empirical Study of Greedy Local Search for Satisfiability Testing. </title> <booktitle> In AAAI-93, </booktitle> <pages> pages 46-51, </pages> <year> 1993. </year>
Reference-contexts: They clearly illustrate the significant support provided by Localizer. Users can focus on describing the data needed for their application, while Localizer takes care of maintaining these data efficiently. 3.4 Adding Weights Reference <ref> [7] </ref> proposes to handle the special structure of some SAT problems by associating weights to the clauses and updating these weights each time a new local search is initiated. We now show how easy it is to integrate this feature.
Reference: [8] <author> B. Selman, H. Levesque, and D. Mitchell. </author> <title> A New Method for Solving Hard Satisfiability Problems. </title> <booktitle> In AAAI-92, </booktitle> <pages> pages 440-446, </pages> <year> 1992. </year>
Reference-contexts: Local-izer statements are organized around the traditional concepts of LS algorithms (e.g., neighborhoods, acceptance criteria, and restarting states), they support the essence of many LS algorithms (e.g., local improvement [6], simulated annealing [4], tabu search [2], and GSAT <ref> [8] </ref>), and they can be tailored to the application at hand to exploit its underlying structure. The main technical tool in Localizer is the concept of invariant which relieves users from the need of maintaining complex data structures incrementally and makes it simpler to define neighborhoods concisely. <p> Our first application is satisfiability (SAT) and we illustrate how GSAT <ref> [8] </ref> can be expressed in Localizer. GSAT illustrates many aspects of Localizer as well as several interesting modeling issues. 3.1 The Local Search Problems in GSAT are described in terms of a number of clauses, each clause consisting of a number of literals. <p> The experimental results were carried out as specified in <ref> [8] </ref>. Table 1 gives the number of variables (V ), the number of clauses (C), and MaxIterations (I) for each class of benchmarks as well as the CPU times in seconds of Localizer (L), the CPU times in seconds of GSAT (G) as reported in [8], and the ratio L=G. <p> carried out as specified in <ref> [8] </ref>. Table 1 gives the number of variables (V ), the number of clauses (C), and MaxIterations (I) for each class of benchmarks as well as the CPU times in seconds of Localizer (L), the CPU times in seconds of GSAT (G) as reported in [8], and the ratio L=G. The times of GSAT are given on a SGI Challenge with a 70 MHz MIPS R4400 processor. The times of Localizer were obtained on a SUN SPARC-10 40MHz and scaled by a factor 1.5 to account for the speed difference between the two machines.
Reference: [9] <author> P. Stuckey and V. Tam. </author> <title> Models for Using Stochastic Constraint Solvers in Constraint Logic Programming. </title> <booktitle> In PLILP-96, </booktitle> <address> Aachen, </address> <month> August </month> <year> 1996. </year>
Reference-contexts: In contrast, little attention has been devoted to the support of local search (LS), despite the increasing interest in these algorithms in recent years. (Note however there are various efforts to integrate local search in CLP languages, e.g., <ref> [9] </ref>). The design of LS algorithms is not an easy task however. The same problem can be modeled in many different ways (see for instance [3]), making the design process an inherently experimental enterprise.
Reference: [10] <author> P. Van Hentenryck, L. Michel, and Y. Deville. </author> <title> Numerica: a Modeling Language for Global Optimization. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1997. </year>
Reference-contexts: The two approaches have complementary strengths, weaknesses, and application areas. The design of global search algorithms is now supported by a variety of tools, ranging from modeling languages such as AMPL [1] and Nu-merica <ref> [10] </ref> to constraint programming languages such CHIP, Ilog Solver, CLP (&lt;), Prolog-IV, and Oz to name only a few.
Reference: [11] <author> C. Voudouris and E. Tsang. </author> <title> Partial Constraint Satisfaction Problems and Guided Local Search. </title> <booktitle> In PACT-96, </booktitle> <address> London, </address> <month> April </month> <year> 1996. </year> <month> 15 </month>
Reference-contexts: Our current research focuses on building a large collection of applications in Localizer to understand the strengths and limitations of the language, to study how frameworks such as Guided Local Search <ref> [11] </ref> and dynamic k-opt [6] can be supported, and to identify which extensions are needed to turn our initial design into a practical tool.
References-found: 11

