URL: http://www.eecs.umich.edu/techreports/cse/1997/CSE-TR-329-97.ps.gz
Refering-URL: http://www.eecs.umich.edu/home/techreports/cse97.html
Root-URL: http://www.eecs.umich.edu
Email: email:fpjensen,soparkar,mathurg@eecs.umich.edu  
Title: Characterizing Multicast Orderings using Concurrency Control Theory  
Author: P.A. Jensen N.R. Soparkar A.G. Mathur 
Address: Ann Arbor, MI 48109-2122 USA  
Affiliation: Electrical Engineering Computer Science The University of Michigan  
Abstract: Coordinating distributed executions is achieved by two widely used approaches: process groups and transactions. Typically, the two represent a trade-off in terms of the degrees of consistency and performance. By applying transaction concurrency control techniques to characterize and design process group multicast orderings, we aim to provide aspects of both ends of the tradeoff. In particular, we propose a framework in which each message multicast is regarded as a transaction. Appropriate message ordering protocols are devised and shown to be correct using a variant of concurrency control theory. Also, we are able to incorporate certain aspects of application semantics for which existing process group approaches are inadequate. Finally, our framework provides a means to characterize the performance of orderings to allow a comparison of different ordering protocols. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. A. Bernstein, V. Hadzilacos, and N. Goodman. </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1987. </year>
Reference-contexts: 1 Introduction Distributed applications typically require that the largely autonomous executions at the separate sites be coordinated with one another in some way. For this purpose, there are two widely used approaches: the process group model [6, 4] and the transaction model <ref> [1] </ref>. The process group model is characterized by modeling the distributed system as a collection of processes that communicate by sending (multicasting) messages. <p> In effect, we are using concurrency control theory. Our development follows concurrency control theory closely (e.g., see <ref> [1] </ref>). In particular, each message is treated as a transaction, the global history is treated as a distributed schedule, and techniques similar to serializability theory are applied in our approach. <p> Equivalence Theorem For a given set of conflict relations M , a global history H is conflict equivalent wrt M to a serial history iff P G (H) is acyclic. Proof Sketch: Similar to concurrency control theory (e.g., see <ref> [11, 1] </ref>). ()) Given H is conflict equivalent to a serial history H s . If P G (H ) is cyclic, then there exists two messages m i ; m j 2 P G (H) such that m i pg fl pg ! m i . <p> If it were permissible to abort any message for which all the receive events could not be processed, a protocol can be derived (in principle) for any given class of orderings by using precedence graph testing (much the same as for transactions | see <ref> [1] </ref>). The 12 Semantic FIFO Semantic Causal Semantic Total idea is for delivery modules to maintain a global P G, and for each receive event, check to see whether a cycle is generated in the graph. If the graph remains acyclic, the event is executed (i.e., the message is delivered).
Reference: [2] <author> K. Birman. </author> <title> A Response to Cheriton and Skeen's Criticism of Causal and Totally Ordered Communication. </title> <journal> ACM Operating System Review, </journal> <volume> 28(1) </volume> <pages> 11-21, </pages> <month> Jan. </month> <year> 1994. </year> <month> 13 </month>
Reference-contexts: Furthermore, in both models there is a need to ensure atomicity of these concurrent events in the presence of failures. Some applications are better coordinated by group multicast techniques whereas others are better suited to transactions (e.g., see <ref> [2, 5] </ref>). Generally, the multicast approach is more efficient and provides adequate consistency criteria for some applications, and transactional systems are better suited to cases where a high degree of consistency criteria are needed. <p> However, there are numerous other distributed applications which could benefit from a good meld of the performance and consistency criteria (e.g., see <ref> [2, 5] </ref>). To this end, more efficient multicast techniques based on 1 applications semantics and advanced transaction models have been proposed. In this paper, we examine the former approach with respect to message ordering, and to do so, we use techniques prevalent in the latter. <p> They argue for using semantic information in specifying these various ordering. Our framework is adequate for a wide range of ordering constraints, and also allows one to use certain application-specific semantics in specifying these constraints. Other aspects of orderings such as false causality and hidden channels <ref> [5, 2] </ref> can also be captured within our framework. Essentially both of these anomalies can be alleviated by defining appropriate conflict relations. Schmuck [13] analyzed message ordering protocols, and also used the notion of conflicts between events.
Reference: [3] <author> K. P. Birman and T. A. Joseph. </author> <title> Low-Cost Management of Replicated Data in Fault-Tolerant Distributed Systems. </title> <journal> ACM Trans. on Computer Systems, </journal> <volume> 4(1) </volume> <pages> 54-70, </pages> <month> Feb. </month> <year> 1986. </year>
Reference-contexts: Many replication schemes are based on the state-machine approach of Schneider [14], which can be implemented using totally ordered multicasts. Replication schemes based on weaker message orderings have been proposed, (e.g., see Birman and Joseph <ref> [3, 4] </ref>, Ladin et al [7], Mishra et al [9]). Such weaker orderings can be represented within our framework. 3 Rationale for Concurrency Theory In order to reason about consistency or correctness requirements of distributed applications, it is generally the case that application semantics must be understood rigorously.
Reference: [4] <author> K. P. Birman and T. A. Joseph. </author> <title> Reliable Communication in the Presence of Failures. </title> <journal> ACM Trans. on Computer Systems, </journal> <volume> 5(1) </volume> <pages> 47-76, </pages> <month> Feb. </month> <year> 1987. </year>
Reference-contexts: 1 Introduction Distributed applications typically require that the largely autonomous executions at the separate sites be coordinated with one another in some way. For this purpose, there are two widely used approaches: the process group model <ref> [6, 4] </ref> and the transaction model [1]. The process group model is characterized by modeling the distributed system as a collection of processes that communicate by sending (multicasting) messages. <p> Many replication schemes are based on the state-machine approach of Schneider [14], which can be implemented using totally ordered multicasts. Replication schemes based on weaker message orderings have been proposed, (e.g., see Birman and Joseph <ref> [3, 4] </ref>, Ladin et al [7], Mishra et al [9]). Such weaker orderings can be represented within our framework. 3 Rationale for Concurrency Theory In order to reason about consistency or correctness requirements of distributed applications, it is generally the case that application semantics must be understood rigorously.
Reference: [5] <author> D. R. Cheriton and D. Skeen. </author> <title> Understanding the Limitations of Causally and Totally Ordered Communication. </title> <booktitle> In Proc. of the 14th ACM Symp. on Operating Systems Principles, </booktitle> <pages> pages 44-57, </pages> <address> Asheville, NC, </address> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: Furthermore, in both models there is a need to ensure atomicity of these concurrent events in the presence of failures. Some applications are better coordinated by group multicast techniques whereas others are better suited to transactions (e.g., see <ref> [2, 5] </ref>). Generally, the multicast approach is more efficient and provides adequate consistency criteria for some applications, and transactional systems are better suited to cases where a high degree of consistency criteria are needed. <p> However, there are numerous other distributed applications which could benefit from a good meld of the performance and consistency criteria (e.g., see <ref> [2, 5] </ref>). To this end, more efficient multicast techniques based on 1 applications semantics and advanced transaction models have been proposed. In this paper, we examine the former approach with respect to message ordering, and to do so, we use techniques prevalent in the latter. <p> Note that our approach primarily helps in ratifying larger classes of message orderings as being correct, thereby increasing the potential for improved performance. We consider variations of standard message orderings to exhibit our approach in incorporating (hitherto difficult <ref> [5, 12] </ref>) application semantics. We describe protocols to effect these orderings, and using the theoretical development of our approach, we explain how they meet the required correctness criteria. Furthermore, we consider a qualitative approach based on a characterization of delivery delay to measure the performance for such multicast orderings. <p> We demonstrate how to handle the correctness issues for multicasts in section 5. In Section 6 we examine protocols for effecting various multicast, and discuss qualitative performance issues in Section 7. Finally, we present our conclusions in Section 8. 2 Related Work Cheriton and Skeen <ref> [5] </ref> discuss the kinds of ordering constraints that are appropriate for a variety of distributed application classes. They argue for using semantic information in specifying these various ordering. <p> They argue for using semantic information in specifying these various ordering. Our framework is adequate for a wide range of ordering constraints, and also allows one to use certain application-specific semantics in specifying these constraints. Other aspects of orderings such as false causality and hidden channels <ref> [5, 2] </ref> can also be captured within our framework. Essentially both of these anomalies can be alleviated by defining appropriate conflict relations. Schmuck [13] analyzed message ordering protocols, and also used the notion of conflicts between events. <p> concepts of the framework (i.e., serial histories, conflict equivalence, and serializability graphs) which we use to reason about classes of message orderings. 4.1 Incidental Orderings We use the term incidental to refer to classes of message orderings whose conflict relations only rely upon incidents of communication among the processes (see <ref> [5] </ref>) , and their relationships with respect to the happened-before relation. These are distinguished from the classes of orderings we discuss following which use semantic information where the conflict relations are based on information which the messages themselves contain.
Reference: [6] <author> D. R. Cheriton and W. Zwaenepoel. </author> <title> Distributed Process Groups in the V Kernel. </title> <journal> ACM Trans. on Computer Systems, </journal> <volume> 3(2) </volume> <pages> 77-107, </pages> <month> May </month> <year> 1985. </year>
Reference-contexts: 1 Introduction Distributed applications typically require that the largely autonomous executions at the separate sites be coordinated with one another in some way. For this purpose, there are two widely used approaches: the process group model <ref> [6, 4] </ref> and the transaction model [1]. The process group model is characterized by modeling the distributed system as a collection of processes that communicate by sending (multicasting) messages.
Reference: [7] <author> R. Ladin, B. Liskov, L. Shrira, and S. Ghemawat. </author> <title> Providing High Availability Using Lazy Replication. </title> <journal> ACM Trans. on Computer Systems, </journal> <volume> 10(4) </volume> <pages> 360-391, </pages> <month> Nov. </month> <year> 1992. </year>
Reference-contexts: Many replication schemes are based on the state-machine approach of Schneider [14], which can be implemented using totally ordered multicasts. Replication schemes based on weaker message orderings have been proposed, (e.g., see Birman and Joseph [3, 4], Ladin et al <ref> [7] </ref>, Mishra et al [9]). Such weaker orderings can be represented within our framework. 3 Rationale for Concurrency Theory In order to reason about consistency or correctness requirements of distributed applications, it is generally the case that application semantics must be understood rigorously.
Reference: [8] <author> L. Lamport. </author> <title> Time, Clocks, and the Ordering of Events in a Distributed System. </title> <journal> Comm. of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: A receive event, rcv, is executed by a process to receive an incoming physical message. A local event is executed by a process locally, and it does not involve the other processes. A global history H is the "happened-before relation" <ref> [8] </ref> on the process events which we denote with the symbol !. Consider a groupware application that allows for sharing of documents. The document being edited is replicated at each user site.
Reference: [9] <author> S. Mishra, L. L. Peterson, and R. D. Schlichting. </author> <title> Implementing Fault-Tolerant Replicated Objects Using Psync. </title> <booktitle> In Proc. of IEEE 8th. Symp. on Reliable Distributed Systems, </booktitle> <pages> pages 42-52, </pages> <address> Seattle, WA, </address> <month> Oct. </month> <year> 1989. </year>
Reference-contexts: Many replication schemes are based on the state-machine approach of Schneider [14], which can be implemented using totally ordered multicasts. Replication schemes based on weaker message orderings have been proposed, (e.g., see Birman and Joseph [3, 4], Ladin et al [7], Mishra et al <ref> [9] </ref>). Such weaker orderings can be represented within our framework. 3 Rationale for Concurrency Theory In order to reason about consistency or correctness requirements of distributed applications, it is generally the case that application semantics must be understood rigorously.
Reference: [10] <author> P. Panangaden and K. Taylor. </author> <title> Concurrent common knowledge: defining agreement for asynchronous systems. </title> <journal> Distributed Computing, </journal> <volume> 6(2) </volume> <pages> 73-94, </pages> <year> 1992. </year>
Reference-contexts: The second phase involves distributing the message along with the timestamp obtained to each process. The delivery modules at each process can then look at the timestamp and deliver the message in the right order. It is possible to show, using knowledge-theoretic arguments, in a manner similar to <ref> [10] </ref>, that these number of message phases is minimal and it is not possible to do any better. 7.2 Delivery Delay Consider the delivery module as a scheduler which takes a message sequence as input and produces an output message sequence such that the specified tests indicated in our protocols hold
Reference: [11] <author> C. Papadimitriou. </author> <title> Serializability of Concurrent Database Updates. </title> <journal> Journal of the ACM, </journal> <volume> 26(4) </volume> <pages> 631-653, </pages> <month> October </month> <year> 1979. </year>
Reference-contexts: Equivalence Theorem For a given set of conflict relations M , a global history H is conflict equivalent wrt M to a serial history iff P G (H) is acyclic. Proof Sketch: Similar to concurrency control theory (e.g., see <ref> [11, 1] </ref>). ()) Given H is conflict equivalent to a serial history H s . If P G (H ) is cyclic, then there exists two messages m i ; m j 2 P G (H) such that m i pg fl pg ! m i . <p> The scheduler executes in an online manner in that it examines the next arriving message and delivers it if permissible. Also, a delivery module should impose the minimum delay on an arriving sequence, which is characterized by requiring that the arriving sequence be altered minimally: As in <ref> [11] </ref>, for message sequences x n and y n of length n each, let the metric d (x n ; y n ) be defined as n c (x n ; y n ), where c (x n ; y n ) is the length of the longest common prefix of <p> Our characterization could use a more refined metric for schedules not in A, but our approach suffices for the coarse qualitative characterization we are providing here. In principle, our characterization provides an indication of the availability of delivery schedulers as well (e.g., as in <ref> [11] </ref>). For a class A of message sequences, A has an efficient scheduler S A iff the prefixes of the schedules in A can be recognized in polynomial time in the number of input messages.
Reference: [12] <author> J. H. Saltzer, D. P. Reed, and D. D. Clark. </author> <title> End-To-End Arguments in System Design. </title> <journal> ACM Trans. on Computer Systems, </journal> <volume> 2(4) </volume> <pages> 277-288, </pages> <month> Nov. </month> <year> 1984. </year>
Reference-contexts: Note that our approach primarily helps in ratifying larger classes of message orderings as being correct, thereby increasing the potential for improved performance. We consider variations of standard message orderings to exhibit our approach in incorporating (hitherto difficult <ref> [5, 12] </ref>) application semantics. We describe protocols to effect these orderings, and using the theoretical development of our approach, we explain how they meet the required correctness criteria. Furthermore, we consider a qualitative approach based on a characterization of delivery delay to measure the performance for such multicast orderings.
Reference: [13] <author> F. Schmuck. </author> <title> The Use of Efficient Broadcast Protocols in Asynchronous Distributed Systems. </title> <type> Technical Report TR CS88-928 (Ph.D. Thesis), </type> <institution> Computer Science Dept., Cornell University, </institution> <month> Aug. </month> <year> 1988. </year>
Reference-contexts: Other aspects of orderings such as false causality and hidden channels [5, 2] can also be captured within our framework. Essentially both of these anomalies can be alleviated by defining appropriate conflict relations. Schmuck <ref> [13] </ref> analyzed message ordering protocols, and also used the notion of conflicts between events. However their approach is different in that it involves finding an appropriate linearization operator, which maps partially ordered sets of events to totally ordered histories.
Reference: [14] <author> F. B. Schneider. </author> <title> Implementing Fault-Tolerant Services using the State-Machine Approach. </title> <journal> ACM Computing Surveys, </journal> <volume> 22, </volume> <month> Dec. </month> <year> 1990. </year>
Reference-contexts: Linearization is a very specific approach of concurrency control theory. Work on managing the consistency of replicas in a distributed environment is also related to our work. Many replication schemes are based on the state-machine approach of Schneider <ref> [14] </ref>, which can be implemented using totally ordered multicasts. Replication schemes based on weaker message orderings have been proposed, (e.g., see Birman and Joseph [3, 4], Ladin et al [7], Mishra et al [9]).
Reference: [15] <author> R. Schwarz and F. Mattern. </author> <title> Detecting causal relationships in distributed computations: in search of the holy grail. </title> <journal> Distributed Computing, </journal> <volume> 7 </volume> <pages> 149-174, </pages> <year> 1994. </year> <month> 14 </month>
Reference-contexts: The key idea of the semantic causal ordering protocol is to make the causal ordering protocol cognizant of the conflict relations. Now, causal delivery can be effected, in principle, by piggy-backing on each message the causal history of that message <ref> [15] </ref>. To ensure semantic causal ordering, the delivery of a message is delayed only if a message in its causal history has not been delivered (i.e., causal ordering) and the receive events at that site for the two messages conflict.
References-found: 15

