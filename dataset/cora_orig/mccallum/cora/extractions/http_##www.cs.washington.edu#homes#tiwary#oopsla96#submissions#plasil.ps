URL: http://www.cs.washington.edu/homes/tiwary/oopsla96/submissions/plasil.ps
Refering-URL: http://www.cs.washington.edu/homes/tiwary/oopsla96/submissions/program.html
Root-URL: 
Email: e-mail:-plasil, tuma-@kki.ms.mff.cuni.cz  e-mail: -kleindie, plasil-@uivt.cas.cz  
Phone: phone: (42 2) 2191 4266 fax: (42 2) 532 742  2  phone: (42 2) 6605 3291 fax: (42 2) 858 5789  
Keyword: Persistent Object Service Specification  (relationship, externalization, compound externalization, and naming).  
Address: ma 1  Malostransk nmest 25, 118 00 Prague 1, Czech Republic  Pod vodrenskou ve 180 00 Prague 8 Czech Republic  
Affiliation: Tu  Faculty of Mathematics and Physics, Department of Software Engineering  Institute of Computer Science Czech Academy of Sciences  
Note: Jan Kleindienst 2 Franti*ek Pl*il 1,2 Petr  
Abstract: What We Are Missing in the CORBA Abstract. In the paper we try to summarize the weaknesses of the CORBA Persistent Object Service standard we felt were most significant while designing and implementing a Persistent Object Service compliant with the standard. The issues discussed in detail include: underspecified semantics of operations, underspecified functionality of POM, lack of "compound persistence", reusability of other services 
Abstract-found: 1
Intro-found: 1
Reference: [Ben95] <author> R. Ben-Nathar: </author> <title> CORBA: A guide to Common Object Request Broker Architecture. </title> <publisher> McGraw-Hill. </publisher> <year> 1995. </year>
Reference: [IBM94a] <institution> IBM Corp. </institution> <note> SOMobjects Developer Toolkit Users Guide, Version 2.1, </note> <year> 1994. </year>
Reference: [IBM94b] <institution> IBM Corp. </institution> <note> SOMobjects Developer Toolkit Programmers Reference Manual Version 2.1, </note> <year> 1994. </year>
Reference: [KPT96a] <author> J. Kleindienst, F. Pl*il, P. Tuma: </author> <title> CORBA and its Object Services. </title> <type> Invited Paper, </type> <address> SOFSEM'96, </address> <publisher> Springer LNCS, </publisher> <year> 1996, </year> <note> to appear. </note>
Reference: [KPT96b] <author> J. Kleindienst, F. Pl*il, P. Tuma: </author> <title> Lessons Learned from Implementing the CORBA Persistence Service, </title> <booktitle> In Proceedings of OOPSLA'96, </booktitle> <address> San Jose, </address> <month> Oct </month> <year> 1996 </year>
Reference-contexts: 1 Introduction At OOPSLA'96, we will present the paper "Lessons Learned from Implementing the CORBA Persistent Object Service" <ref> [KPT96b] </ref>. Compared to that paper, this contribution is more focused on the CORBA Persistent Object Service (POS) standard itself ([OMG94b]). <p> Except for mentioning such an option, the Standard does not go into any details in this respect. In this section, we briefly analyze the prospects of reusing the Relationship, Externalization, and Naming Services. For details we refer the reader to <ref> [KPT96b] </ref>. 3.4.1 Relationship To handle relations among CORBA objects in a unified way, the Standard recommends using the Relationship Service. In the article [KPT96b], we showed that combining the Relationship Service with the POS raises several issues that must be solved, such as providing the client with a way to specify <p> In this section, we briefly analyze the prospects of reusing the Relationship, Externalization, and Naming Services. For details we refer the reader to <ref> [KPT96b] </ref>. 3.4.1 Relationship To handle relations among CORBA objects in a unified way, the Standard recommends using the Relationship Service. In the article [KPT96b], we showed that combining the Relationship Service with the POS raises several issues that must be solved, such as providing the client with a way to specify a TraversalCriteria object used for traversing a persistent object graph, or specifying the semantics of merging subgraphs when storing/restoring parts of a given <p> In fact, as shown in <ref> [KPT96b] </ref>, the Externalization Service can support the POS, inherently based on random access to individual objects, only in a very special case when a POS implementation does not support fine-grained updating of parts of an externalized transitive closure of dependencies. As we also showed in [KPT96b], it would be possible to <p> In fact, as shown in <ref> [KPT96b] </ref>, the Externalization Service can support the POS, inherently based on random access to individual objects, only in a very special case when a POS implementation does not support fine-grained updating of parts of an externalized transitive closure of dependencies. As we also showed in [KPT96b], it would be possible to implement a specialized StreamIO interface such that the Streamable interface could be used to access the persistent state of an object without using the remaining parts of the Externalization Service, thus not imposing the limit of not supporting fine-grained updating of parts of an externalized <p> an object without using the remaining parts of the Externalization Service, thus not imposing the limit of not supporting fine-grained updating of parts of an externalized transitive closure of dependencies. (Such a protocol is also proposed in [Sess96] as we have found out recently). 3.4.3 Compound Externalization As described in <ref> [KPT96b] </ref>, combining the Compound Externalization Service with the POS introduces an unexpected conceptual mismatch. Basically, the Compound Externalization Service uses the externalize_node () method for externalizing a node together with all its roles.
Reference: [MoZa95] <author> T. J. Mowbray, R. Zahavi: </author> <title> The Essential CORBA, </title> <editor> J. </editor> <publisher> Wiley & Sons, </publisher> <year> 1995. </year>
Reference: [OHE96] <author> R. Orfali, D. Harkey, J. Edwards: </author> <title> The Essential Distributed Objects. Survival Guide. </title> <publisher> John Wiley & Sons, </publisher> <year> 1996 </year>
Reference: [OMG92a] <institution> Object Service Architecture, OMG 92-8-4, </institution> <year> 1992. </year>
Reference: [OMG92b] <institution> Object Services Request for Proposal 1, OMG 92-8-6, </institution> <year> 1992 </year>
Reference-contexts: Consequently, the implementation will introduce a proprietary solution to handling the situations not treated in the Standard. 3.2 Underspecified functionality of POM Unjustifiably, the Standard does not delve into details of the Persistent Object Manager functionality. Contrary to the technical requirements of <ref> [OMG92b] </ref>, the criteria used by POM to dispatch calls to attached PDSs are outlined very briefly. Again, vendors can be expected to introduce proprietary mechanisms for dispatching requests.
Reference: [OMG94a] <institution> Common Object Services Volume I, OMG 94-1-1, </institution> <year> 1994. </year>
Reference-contexts: A more flexible approach could be based upon allowing for arranging PDSs into hierarchies (replacing thus POM by the root PDS). In fact, this would be similar to the concept of GenericFactory in the LifeCycle Service <ref> [OMG94a] </ref> which also benefits from such a recursive architecture. 3.3 Lack of "Compound Persistent Object Service" One of the classical key issues of object persistency is the handling of inter-object references. The Standard, however, is mute in this respect. <p> The latter problem is especially hard since CORBA lacks means for checking an object identity (this functionality should have originally been provided by the LifeCycle Service, but has been omitted in the final version of its OMG specification <ref> [OMG94a] </ref>). 3.4.4 Naming The Standard suggests using the Naming Service for translating human-readable names of PDSs into CORBA references. In our opinion, the Naming Service can also be used to provide mapping from human-readable names to PIDs.
Reference: [OMG94b] <institution> Persistent Object Service Specification, OMG 94-10-7, </institution> <year> 1994. </year>
Reference-contexts: Another component, the Persistent Object Manager (POM), provides uniform access to different Persistent Data Service instances/types. The relationship of these components is summarized on Fig. 1 (basically taken from <ref> [OMG94b] </ref>). The goal of making the POS architecture open is achieved by allowing almost all meaningful n:m combination of these components (both instances and types).
Reference: [OMG94c] <institution> Relationship Service Specification, Joint Object Services Submission, OMG 94-5-5, </institution> <year> 1994. </year>
Reference-contexts: Again, vendors can be expected to introduce proprietary mechanisms for dispatching requests. For example, a potential dispatching mechanism might be based upon introducing user objects capable of providing the information necessary to route the request to the appropriate PDS (similar to the TraversalCriteria object defined in the Relationship Service <ref> [OMG94c] </ref>). In our opinion, this mechanism would have very little or no impact on the service flexibility. Moreover, a mechanism for dynamically registering available PDSs could be analogously introduced.
Reference: [OMG94d] <editor> Compound LifeCycle Addendum. </editor> <booktitle> Joint Object Services Submission. OMG 94-5-6, </booktitle> <year> 1994. </year>
Reference: [OMG94e] <institution> Object Externalization Service. OMG 94-9-15, </institution> <year> 1995. </year>
Reference: [OMG95a] <institution> Common Object Request Broker Architecture and Specification Revision 2.0, OMG 96-3-4, </institution> <year> 1995. </year>
Reference: [OMG95b] <institution> Object Management Architecture Guide, </institution> <note> 3rd Edition, </note> <editor> R. M. Soley (Editor), </editor> <publisher> John Wiley & Sons, </publisher> <year> 1990. </year>
Reference: [ORBIXa] <author> Orbix, </author> <title> Programmer's Guide. </title> <publisher> IONA Technologies Ltd. </publisher> <address> Dublin, </address> <year> 1994 </year>
Reference-contexts: level of indirection introduced by such a mapping may be beneficial for hiding the datastore-dependence of PIDs. 4 Conclusion This contribution is based upon a thorough study of the Standard (originally without knowing the motivations published in [Sess96]) and our experience gained during an implementation of the POS for Orbix <ref> [ORBIXa, ORBIXb] </ref>. The main weaknesses we have identified include: underspecified semantics of the POS operations, underspecified functionality of POM, and very weak specification of how other Object Services may be reused in the POS.
Reference: [ORBIXb] <author> Orbix, </author> <title> Advanced Programmer's Guide. </title> <publisher> IONA Technologies Ltd. </publisher> <address> Dublin, </address> <year> 1994. </year>
Reference-contexts: level of indirection introduced by such a mapping may be beneficial for hiding the datastore-dependence of PIDs. 4 Conclusion This contribution is based upon a thorough study of the Standard (originally without knowing the motivations published in [Sess96]) and our experience gained during an implementation of the POS for Orbix <ref> [ORBIXa, ORBIXb] </ref>. The main weaknesses we have identified include: underspecified semantics of the POS operations, underspecified functionality of POM, and very weak specification of how other Object Services may be reused in the POS.
Reference: [Sess96] <author> R. </author> <title> Sessions: Object Persistence, Beyond Object-Oriented Databases. </title> <publisher> Prentice-Hall 1996 </publisher>
Reference-contexts: It also tries to summarize the weaknesses of the standard we felt were most significant while designing and implementing a Persistent Object Service compliant with the Standard. 2 Overview of the POS Architecture 2.1 Goals According to <ref> [Sess96] </ref>, the Persistent Object Service (POS) specification (the Standard for short) was prepared as a trade-off based on the original IBM and SunSoft submissions to the OMG Request for Proposal (RFP) issued in 1992 ([OMG92b]). <p> In addition to the requirements stated by the RFP, the POS specification was designed to meet the following goals <ref> [Sess96] </ref>: support for corporate-centric datastores (including databases of all types, filesystem based datastores, etc.), datastore independence (a single client API independent of a particular datastore; a single mechanism for storing/restoring objects to be used on the object server side), open architecture (new datastores to be plugged in at any time). 2.2 <p> that the Streamable interface could be used to access the persistent state of an object without using the remaining parts of the Externalization Service, thus not imposing the limit of not supporting fine-grained updating of parts of an externalized transitive closure of dependencies. (Such a protocol is also proposed in <ref> [Sess96] </ref> as we have found out recently). 3.4.3 Compound Externalization As described in [KPT96b], combining the Compound Externalization Service with the POS introduces an unexpected conceptual mismatch. Basically, the Compound Externalization Service uses the externalize_node () method for externalizing a node together with all its roles. <p> The level of indirection introduced by such a mapping may be beneficial for hiding the datastore-dependence of PIDs. 4 Conclusion This contribution is based upon a thorough study of the Standard (originally without knowing the motivations published in <ref> [Sess96] </ref>) and our experience gained during an implementation of the POS for Orbix [ORBIXa, ORBIXb]. The main weaknesses we have identified include: underspecified semantics of the POS operations, underspecified functionality of POM, and very weak specification of how other Object Services may be reused in the POS.
Reference: [Sie96] <author> J. Siegel: </author> <title> CORBA. Fundamentals and Programming. </title> <editor> J. </editor> <publisher> Wiley & Sons, </publisher> <year> 1996 </year>
References-found: 20

