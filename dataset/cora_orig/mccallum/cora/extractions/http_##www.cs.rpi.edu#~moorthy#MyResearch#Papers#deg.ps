URL: http://www.cs.rpi.edu/~moorthy/MyResearch/Papers/deg.ps
Refering-URL: http://www.cs.rpi.edu/~moorthy/MyResearch/graphdraw.html
Root-URL: http://www.cs.rpi.edu
Title: Interfaces and Applications of Graph Packages  
Author: Mukkai S. Krishnamoorthy, Ugur Dogrusoz, Mark Gilder, John Punin, Andrew Shapira, Bhaskar Vasudevan and David Zelnis 
Date: August 25, 1995  
Address: Troy, NY 12180  
Affiliation: Department of Computer Science Rensselaer Polytechnic Institute  
Abstract: This paper discusses two applications of graph packages. Some of these packages were developed at Rensselaer [6, 10, 2]; others were developed elsewhere [5, 8]. By properly interfacing with other packages, we can solve a rich variety of graph problems. In this paper, we show how these packages can be interfaced, and provide two representative examples. In the first example, we used Nauty to generate all non-isomorphic regular graphs (undirected and unlabeled) of degree 3. We used GraphPack to draw these graphs. We also used the Maple interface to GraphPack to calculate the characteristic polynomials of these graphs. In the second example, we used GraphPack with an object oriented parallelizing compiler called HICOR [2] to display the results of different scheduling disciplines. We have also developed a new graph drawing system called Zgraph, using Motif under X Windows system [10]. Using Zgraph one can draw graphs of up to 10,000 vertices. We were also able to interface Zgraph with other packages. All of our packages are written in C and run under X Windows. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B.W. Char et al. </author> , <title> Maple V Language Reference Manual, </title> <publisher> Springer-Verlag, </publisher> <address> NY, </address> <year> 1991. </year>
Reference-contexts: The drawback of this system is that it can only draw graphs of up to 60 vertices. Also, it cannot perform any symbolic computation. Nauty [8] is a system developed by B. McKay which tests for isomorphism between graphs, but contains no display features. Maple <ref> [1] </ref> is a symbolic computation system which has limited display facilities. The HICOR system [2] developed at Rensselaer is a parallelizing compiler based on an object oriented intermediate code representation. This compiler utilizes GraphPack to display the control flow digraph and the schedule digraph.
Reference: [2] <author> M. Gilder and M. Krishnamoorthy, </author> <title> "An Object-Oriented Intermediate Code Representation for the Development of Parallelization Tools," Journal of Object Oriented Programming, </title> <month> January </month> <year> 1995, </year> <pages> pp. 50-57. </pages>
Reference-contexts: Also, it cannot perform any symbolic computation. Nauty [8] is a system developed by B. McKay which tests for isomorphism between graphs, but contains no display features. Maple [1] is a symbolic computation system which has limited display facilities. The HICOR system <ref> [2] </ref> developed at Rensselaer is a parallelizing compiler based on an object oriented intermediate code representation. This compiler utilizes GraphPack to display the control flow digraph and the schedule digraph. The Stanford GraphBase, or GraphBase, developed at Stanford is a carefully crafted system that performs efficient computations on large graphs.
Reference: [3] <author> M. Gilder and M. Krishnamoorthy, </author> <title> "Automatic Source-Code Parallelization using HICOR Objects," </title> <journal> International Journal of Parallel Programming, </journal> <volume> Vol. 22, No.3, </volume> <year> 1994, </year> <pages> pp. 309-356. </pages>
Reference-contexts: Once each task number is known, the methods applicable to the Dag object are invoked to extract detailed information; i.e., estimated execution costs and data communication costs. Three schedules are presented in the following Figures <ref> [3] </ref>, [4]. Figure 3 displays a schedule for execution of an object (which corresponds to a segment of code in the source program). There are three layers. Two items in Layer 1 can be executed simultaneously. Two items in Layer 3 can also be executed simultaneously.
Reference: [4] <author> M. Gilder, J. Punin and M. Krishnamoorthy, </author> <title> "A GUI for Parallel Code Generation," in Programming Environments for Massively Parallel Distributed Systems, </title> <editor> Karsten M. Decker and Rene M. Rehmann (ed), </editor> <publisher> Birkhauser Verlag, </publisher> <address> Basel, Switzerland, </address> <month> July </month> <year> 1994, </year> <pages> pp. 69-79. </pages>
Reference-contexts: Once each task number is known, the methods applicable to the Dag object are invoked to extract detailed information; i.e., estimated execution costs and data communication costs. Three schedules are presented in the following Figures [3], <ref> [4] </ref>. Figure 3 displays a schedule for execution of an object (which corresponds to a segment of code in the source program). There are three layers. Two items in Layer 1 can be executed simultaneously. Two items in Layer 3 can also be executed simultaneously.
Reference: [5] <author> D. Knuth, </author> <title> The Stanford GraphBase, </title> <publisher> Addison Wesley, </publisher> <address> Reading, Mass. </address> <year> 1994. </year>
Reference: [6] <author> M. Krishnamoorthy, A. Suess, M. Onghena, F. Oxaal and T. </author> <note> Spencer "Improvements to GraphPack: </note>
References-found: 6

