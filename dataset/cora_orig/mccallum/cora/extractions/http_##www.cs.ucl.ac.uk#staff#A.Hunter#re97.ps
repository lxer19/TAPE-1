URL: http://www.cs.ucl.ac.uk/staff/A.Hunter/re97.ps
Refering-URL: http://www.cs.ucl.ac.uk/staff/A.Hunter/papers.html
Root-URL: http://www.cs.ucl.ac.uk
Email: Email: (abh, ban@doc.ic.ac.uk  
Title: Analysing Inconsistent Specifications  
Author: Anthony Hunter Bashar Nuseibeh 
Address: 180 Queens Gate, London SW7 2BZ, UK  
Affiliation: Department of Computing, Imperial College  
Note: (to appear in) Proc. of 3rd Int. Symposium on Requirements Engineering (RE97), Annapolis, USA, Jan 97, IEEE CS Press.  
Abstract: In previous work we advocated continued development of specifications in the presence of inconsistency. To support this we presented quasi-classical (QC) logic for reasoning with inconsistent specifications. The logic allows the derivation of nontrivial classical inferences from inconsistent information. In this paper we present a development called labelled QC logic, and some associated analysis tools, that allows the tracking and diagnosis of inconsistent information. The results of analysis are then used to guide further development in the presence of inconsistency. We illustrate the logic and our tools by specifying and analysing parts of the London Ambulance Service. We argue that the scalability of our approach is made possible by deploying the ViewPoints framework for multi-perspective development, such that our analysis tools are only used on partial specifications of a manageable size. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> W. Atkinson and R. J. </author> <title> Cunningham (1991); Proving Properties of Safety-Critical Systems; S o f t w a r e Engineering Journal, </title> <booktitle> 6(2): </booktitle> <pages> 41-50, </pages> <month> March </month> <year> 1991; </year> <month> IEE/BCS. </month>
Reference: [2] <author> R. </author> <booktitle> Balzer (1991); Tolerating Inconsistency; Proceedings of 13th International Conference on Software Engineering (ICSE-13), </booktitle> <address> Austin, Texas, USA, </address> <month> 13-17th May </month> <year> 1991, </year> <note> 158-165; IEEE CS Press. </note>
Reference-contexts: Increasingly however, researchers have begun to study the notion of consistency in software systems, have recognised the need to formalise this notion, and have proposed techniques for tolerating or even living with inconsistencies; e.g., <ref> [2, 5, 14, 18, 22, 28, 29] </ref>. A review of this work can be found in [19, 20, 23]. Other related approaches address inconsistencies that arise in software development processes themselves. For example, an inconsistency may occur between a software development process definition and the actual (enacted) process instance [9].
Reference: [3] <author> S. Benferhat, D. Dubois and H. </author> <booktitle> Prade (1993); Argumentative Inference in Uncertain and Inconsistent Knowledge Bases; Proceedings of Uncertainty in Artificial Intelligence, </booktitle> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: These include ordering sets of formulae according to their relative degree of contradiction [17]. Second, there are a number of analyses of ways of handling ordered formulae and sets of ordered formulae. These include the use of specificity [26], ordered theory presentations [27], and prioritised syntax-based entailment <ref> [3] </ref>. 4.2. Qualifying inferences from inconsistent information When considering inconsistent information, we have more confidence in some inferences over others.
Reference: [4] <author> P. Besnard and A. </author> <title> Hunter (1995); Quasi-classical Logic: Nontrivializable classical reasoning from inconsistent information; (In) Symbolic and Quantitative Approaches to Uncertainty (ECSQARU 95); C. </title> <editor> Froidevaux and J. Kohlas (Ed.); </editor> <publisher> 44-51; LNCS, 946, Springer-Verlag. </publisher>
Reference: [5] <author> A. </author> <title> Borgida (1985); Language Features for Flexible Handling of Exceptions in Information Systems; Transactions on Database Systems, </title> <booktitle> 10(4): </booktitle> <pages> 565-603, </pages> <note> December 1985; ACM Press. </note>
Reference-contexts: Increasingly however, researchers have begun to study the notion of consistency in software systems, have recognised the need to formalise this notion, and have proposed techniques for tolerating or even living with inconsistencies; e.g., <ref> [2, 5, 14, 18, 22, 28, 29] </ref>. A review of this work can be found in [19, 20, 23]. Other related approaches address inconsistencies that arise in software development processes themselves. For example, an inconsistency may occur between a software development process definition and the actual (enacted) process instance [9].
Reference: [6] <author> M. Costa, R. J. Cunningham and J. </author> <booktitle> Booth (1990); Logical Animation; Proceedings of 12th International Conference of Software Engineering, </booktitle> <address> Nice, France, </address> <publisher> 144-149; IEEE CS Press. </publisher>
Reference: [7] <author> G. Cugola, E. Di Nitto, C. Ghezzi and M. </author> <title> Mantione (1995); How To Deal With Deviations During Process Model Enactment; Proceedings of 17th International Conference on Software Engineering (ICSE-17), </title> <address> Seattle, USA, 23-30th April 1995, </address> <publisher> 265-273; ACM Press. </publisher>
Reference-contexts: Since this policy is overly restrictive, many developers attempt to fake conformance to the process definition (for example, by fooling a tool into thinking that a certain task has been performed in order to continue development). Cugola et al. <ref> [7] </ref> have addressed exactly this problem in their temporal logic--based approach which is used to capture and tolerate some deviations from a process description during execution.
Reference: [8] <author> J. </author> <booktitle> De Kleer (1986); An Assumption-based TMS; Artificial Intelligence, </booktitle> <volume> 28: </volume> <pages> 127-162. </pages>
Reference-contexts: Furthermore, they provide a useful vocabulary for participants in the development process to discuss the inconsistent information. Whilst there is an overlap for existential inferencing with the approach of truth maintenance systems (for example [10], <ref> [8] </ref>), we go beyond this by adopting universal and free inferencing. Furthermore, by adopting labelling, we integrate our inconsistency management with QC reasoning and with identifying likely sources of inconsistency. 4.3.
Reference: [9] <author> M. </author> <title> Dowson (1993); Consistency Maintenance in Process Sensitive Environments; Proceedings of Workshop on Process Sensitive Environments A rc h it e ct ur e s, </title> <institution> Boulder, Colorado, USA, Rocky Mountain Institute of Software Engineering (RMISE). </institution>
Reference-contexts: A review of this work can be found in [19, 20, 23]. Other related approaches address inconsistencies that arise in software development processes themselves. For example, an inconsistency may occur between a software development process definition and the actual (enacted) process instance <ref> [9] </ref>. Such an inconsistency between enactment state and performance state is often avoided by blocking further development activities until some precondition is made to hold.
Reference: [10] <author> J. </author> <booktitle> Doyle (1979); A Truth Maintenance System; Artificial Intelligence, </booktitle> <volume> 12: </volume> <pages> 231-272. </pages>
Reference-contexts: Furthermore, they provide a useful vocabulary for participants in the development process to discuss the inconsistent information. Whilst there is an overlap for existential inferencing with the approach of truth maintenance systems (for example <ref> [10] </ref>, [8]), we go beyond this by adopting universal and free inferencing. Furthermore, by adopting labelling, we integrate our inconsistency management with QC reasoning and with identifying likely sources of inconsistency. 4.3.
Reference: [11] <author> S. Easterbrook and B. </author> <booktitle> Nuseibeh (1995); Inconsistency Management in an Evolving Specification; Proceedings of 2nd International Symposium on Requirements Engineering (RE 95), </booktitle> <address> York, UK, </address> <publisher> 48-55; IEEE CS Press. </publisher>
Reference: [12] <author> S. Easterbrook and B. </author> <title> Nuseibeh (1996); Using ViewPoints for Inconsistency Management; Software Engineering Journal, </title> <booktitle> 11(1): </booktitle> <pages> 31-43, </pages> <month> January </month> <year> 1996; </year> <month> IEE/BCS. </month>
Reference-contexts: ViewPoints encapsulate partial specifications that can be deliberately chosen to be of a size that can be handled by our techniques. Moreover, the ViewPoints framework itself and its support tools have been constructed with the intention of tolerating inconsistency <ref> [12, 24] </ref>. Thus, the tools we have presented can be added to our framework without hindering the ViewPoint-oriented development process. So for example, while a requirements engineer is developing his/her ViewPoint specification, our tools can be happily churning out (potentially) useful inferences and analysis results. 5.
Reference: [13] <author> M. Elvang-Goransson and A. </author> <booktitle> Hunter (1995); Argumentative Logics; Data and Knowledge Engineering, </booktitle> <volume> 16: </volume> <pages> 125-145. </pages>
Reference-contexts: MI (D) = -Labels (G) | G e INC (D) and "F e INC (D) F C G MC (D) = -Labels (G) | G e CON (D) and "F e CON (D) G C F FREE (D) = MC (D) 6 The approach is a derivative of argumentative logics <ref> [13] </ref>. specification. Finally, a formula is a free inference if it is an inference from the intersection of the maximally consistent subsets of the specification. If a is a free inference, it is also a universal inference. Similarly, if a is a universal inference, it is also an existential inference.
Reference: [14] <author> M. </author> <note> Feather (1995); Modularized Exception Handling; Draft technical report, 9th February 1995; USC/Information Sciences Institute, </note> <institution> Marina del Rey, California, USA. </institution>
Reference-contexts: Increasingly however, researchers have begun to study the notion of consistency in software systems, have recognised the need to formalise this notion, and have proposed techniques for tolerating or even living with inconsistencies; e.g., <ref> [2, 5, 14, 18, 22, 28, 29] </ref>. A review of this work can be found in [19, 20, 23]. Other related approaches address inconsistencies that arise in software development processes themselves. For example, an inconsistency may occur between a software development process definition and the actual (enacted) process instance [9].
Reference: [15] <author> A. Finkelstein and J. </author> <title> Dowell (1996); A Comedy of Errors: </title> <booktitle> the London Ambulance Service case study; Proceedings of 8th International Workshop on Software Specification and Design (IWSSD-8), </booktitle> <address> Schloss Velen, Germany, 22-23rd March 1996, </address> <publisher> 2-4; IEEE CS Press. </publisher>
Reference-contexts: This case study was the focus of, and common example used by, delegates at the Eighth International Workshop on Software Specification and Design (IWSSD-8) <ref> [15] </ref>. As mentioned earlier (4.3), by examining this case study we are not attempting to demonstrate the scalability of our approach, but rather to demonstrate its potential usefulness when used in conjunction with a host of other tools from the requirements engineers toolbox.
Reference: [16] <author> A. Finkelstein, D. Gabbay, A. Hunter, J. Kramer and B. </author> <title> Nuseibeh (1994); Inconsistency Handling in Multi-Perspective Specifications; Transactions on Software Engineering, </title> <booktitle> 20(8): </booktitle> <pages> 569-578, </pages> <note> August 1994; IEEE CS Press. </note>
Reference: [17] <author> D. Gabbay and A. </author> <title> Hunter (1995); Negation and Contradiction; (In) What is Negation; Oxford University Press. </title>
Reference-contexts: There are a number of ways that this approach can be developed. First, there are further intuitive ways of deriving orderings over formulae and sets of formulae. These include ordering sets of formulae according to their relative degree of contradiction <ref> [17] </ref>. Second, there are a number of analyses of ways of handling ordered formulae and sets of ordered formulae. These include the use of specificity [26], ordered theory presentations [27], and prioritised syntax-based entailment [3]. 4.2.
Reference: [18] <author> T. M. Hagensen and B. B. </author> <title> Kristensen (1992); Consistency in Software System Development: Framework, Model, </title> <booktitle> Techniques & Tools; Software Engineering Notes (Proceedings of ACM SIGSOFT Symposium on Software Development Environments), </booktitle> <volume> 17(5): </volume> <pages> 58-67, </pages> <note> 9-11th December 1992; SIGSOFT & ACM Press. </note>
Reference-contexts: Increasingly however, researchers have begun to study the notion of consistency in software systems, have recognised the need to formalise this notion, and have proposed techniques for tolerating or even living with inconsistencies; e.g., <ref> [2, 5, 14, 18, 22, 28, 29] </ref>. A review of this work can be found in [19, 20, 23]. Other related approaches address inconsistencies that arise in software development processes themselves. For example, an inconsistency may occur between a software development process definition and the actual (enacted) process instance [9].
Reference: [19] <author> A. </author> <note> Hunter (1996); Uncertainty in Information Systems; McGraw-Hill. </note>
Reference-contexts: A review of this work can be found in <ref> [19, 20, 23] </ref>. Other related approaches address inconsistencies that arise in software development processes themselves. For example, an inconsistency may occur between a software development process definition and the actual (enacted) process instance [9]. <p> From the AI and logics communities there have been a number of other related contributions that are relevant, including fuzzy sets and non-monotonic logics (for a review, see <ref> [19, 21] </ref>). Whilst they constitute important developments that could be incorporated in our framework, they are not directly oriented to the inconsistency management issues that we consider with in this paper.
Reference: [20] <author> A. Hunter and B. </author> <title> Nuseibeh (1995); Managing Inconsistent Specifications: Reasoning, Analysis and Action; Technical report, </title> <institution> June 1995; Department of Computing, Imperial College, </institution> <address> London, UK. </address>
Reference-contexts: A review of this work can be found in <ref> [19, 20, 23] </ref>. Other related approaches address inconsistencies that arise in software development processes themselves. For example, an inconsistency may occur between a software development process definition and the actual (enacted) process instance [9].
Reference: [21] <author> P. Krause and D. </author> <title> Clark (1993); Representing Uncertain Knowledge; Intellect. </title>
Reference-contexts: From the AI and logics communities there have been a number of other related contributions that are relevant, including fuzzy sets and non-monotonic logics (for a review, see <ref> [19, 21] </ref>). Whilst they constitute important developments that could be incorporated in our framework, they are not directly oriented to the inconsistency management issues that we consider with in this paper.
Reference: [22] <author> K. Narayanaswamy and N. </author> <title> Goldman (1992); Lazy Consistency: </title> <booktitle> A Basis for Cooperative Software Development; Proceedings of International Conference on ComputerSupported Cooperative Work (CSCW 92), </booktitle> <address> Toronto, Ontario, Canada, </address> <note> 31st October - 4th November, 257-264; ACM SIGCHI & SIGOIS. </note>
Reference-contexts: Increasingly however, researchers have begun to study the notion of consistency in software systems, have recognised the need to formalise this notion, and have proposed techniques for tolerating or even living with inconsistencies; e.g., <ref> [2, 5, 14, 18, 22, 28, 29] </ref>. A review of this work can be found in [19, 20, 23]. Other related approaches address inconsistencies that arise in software development processes themselves. For example, an inconsistency may occur between a software development process definition and the actual (enacted) process instance [9].
Reference: [23] <author> B. </author> <title> Nuseibeh (1996); To Be And Not To Be: </title> <booktitle> On Managing Inconsistency in Software Development; Proceedings of 8th International Workshop on Software Specification and Design (IWSSD-8), </booktitle> <address> Schloss Velen, Germany, 22-23rd March 1996, </address> <publisher> 164-169; IEEE CS Press. </publisher>
Reference-contexts: A review of this work can be found in <ref> [19, 20, 23] </ref>. Other related approaches address inconsistencies that arise in software development processes themselves. For example, an inconsistency may occur between a software development process definition and the actual (enacted) process instance [9].
Reference: [24] <author> B. Nuseibeh and A. </author> <title> Finkelstein (1992); ViewPoints: A Vehicle for Method and Tool Integration; Proceedings of 5th International Workshop on Computer-Aided Software Engineering (CASE 92), </title> <address> Montreal, Canada, </address> <month> 6-10th July </month> <year> 1992, </year> <note> 50-60; IEEE CS Press. </note>
Reference-contexts: ViewPoints encapsulate partial specifications that can be deliberately chosen to be of a size that can be handled by our techniques. Moreover, the ViewPoints framework itself and its support tools have been constructed with the intention of tolerating inconsistency <ref> [12, 24] </ref>. Thus, the tools we have presented can be added to our framework without hindering the ViewPoint-oriented development process. So for example, while a requirements engineer is developing his/her ViewPoint specification, our tools can be happily churning out (potentially) useful inferences and analysis results. 5.
Reference: [25] <author> B. Nuseibeh, J. Kramer and A. </author> <title> Finkelstein (1994); A Framework for Expressing the Relationships Between Multiple Views in Requirements Specification; Transactions on Software Engineering, </title> <booktitle> 20(10): </booktitle> <pages> 760-773, </pages> <note> October 1994; IEEE CS Press. </note>
Reference: [26] <author> D. </author> <booktitle> Poole (1985); An Assumption-based TMS; Artificial Intelligence, </booktitle> <volume> 36: </volume> <pages> 24-47. </pages>
Reference-contexts: These include ordering sets of formulae according to their relative degree of contradiction [17]. Second, there are a number of analyses of ways of handling ordered formulae and sets of ordered formulae. These include the use of specificity <ref> [26] </ref>, ordered theory presentations [27], and prioritised syntax-based entailment [3]. 4.2. Qualifying inferences from inconsistent information When considering inconsistent information, we have more confidence in some inferences over others.
Reference: [27] <author> M. </author> <title> Ryan (1992); Representing Defaults as Sentences with Reduced Priority; Proceedings of 3rd International Conference on Principles of Knowledge Representation and Reasoning, </title> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: These include ordering sets of formulae according to their relative degree of contradiction [17]. Second, there are a number of analyses of ways of handling ordered formulae and sets of ordered formulae. These include the use of specificity [26], ordered theory presentations <ref> [27] </ref>, and prioritised syntax-based entailment [3]. 4.2. Qualifying inferences from inconsistent information When considering inconsistent information, we have more confidence in some inferences over others.
Reference: [28] <author> R. W. Schwanke and G. E. </author> <title> Kaiser (1988); Living With Inconsistency in Large Systems; Proceedings of the International Workshop on Software Version and Configuration Control, </title> <address> Grassau, Germany, </address> <month> 27-29 January </month> <year> 1988, </year> <editor> 98-118; B. G. </editor> <publisher> Teubner, Stuttgart. </publisher>
Reference-contexts: Increasingly however, researchers have begun to study the notion of consistency in software systems, have recognised the need to formalise this notion, and have proposed techniques for tolerating or even living with inconsistencies; e.g., <ref> [2, 5, 14, 18, 22, 28, 29] </ref>. A review of this work can be found in [19, 20, 23]. Other related approaches address inconsistencies that arise in software development processes themselves. For example, an inconsistency may occur between a software development process definition and the actual (enacted) process instance [9].

References-found: 28

