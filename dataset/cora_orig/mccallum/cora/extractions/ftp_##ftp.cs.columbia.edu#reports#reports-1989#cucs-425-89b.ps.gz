URL: ftp://ftp.cs.columbia.edu/reports/reports-1989/cucs-425-89b.ps.gz
Refering-URL: http://www.cs.columbia.edu/~library/1989.html
Root-URL: http://www.cs.columbia.edu
Title: Concurrency Control in Advanced Database Applications  
Author: Naser S. Barghouti and Gail E. Kaiser 
Keyword: Categories and Subject Descriptors: H.2.4 [Database Management]: Systemsconcurrency; transaction process-Copyright  ing; H.2.8 [Database Management]: Applications; D.2.6 [Software Engineering]: Programming Environments interactive; D.2.9 [Software Engineering]: Managementprogramming teams General Terms: Algorithms, Design, Management Additional Key Words and Phrases: Concurrency control, design environments, advanced database applications, object-oriented databases, extended transaction models, cooperative transactions, long transactions, relaxing serializability  
Note: 1991 Naser S. Barghouti and Gail E. Kaiser  
Date: 29 May 1990  
Address: New York, NY 10027  
Affiliation: Columbia University Department of Computer Science  
Abstract: Concurrency control has been thoroughly studied in the context of traditional database applications such as banking and airline reservations systems. There are relatively few studies, however, that address the concurrency control issues of advanced database applications such as CAD/CAM and software development environments. The concur-rency control requirements in such applications are different from those in conventional database applications; in particular, there is a need to support non-serializable cooperation among users whose transactions are long-lived and interactive, and to integrate concurrency control mechanisms with version and configuration control. This paper outlines the characteristics of data and operations in some advanced database applications, discusses their concur-rency control requirements, and surveys the mechanisms proposed to address these requirements. 
Abstract-found: 1
Intro-found: 1
Reference: [Adams et al. 89] <author> Adams, E. W., Honda, M., and Miller, T. C. </author> <title> Object Management in a CASE Environment. </title> <booktitle> Proceedings of the 11th International Conference on Software Engineering, </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> May, </month> <year> 1989, </year> <pages> pp. 154-163. </pages>
Reference-contexts: Domain relative addressing is the concurrency control mechanism used in the Cosmos software development environment [Walpole et al. 88a]. 7.3.2 Copy/Modify/Merge Like Infuse, Sun's Network Software Environment (NSE) supports a nested transaction mechanism that operates on a multilevel hierarchical database structure <ref> [Adams et al. 89] </ref>. Like Cosmos (and unlike Infuse), NSE supports concurrent access to the same data objects by combining the reserve/deposit model with an extension to the classical optimistic concurrency control policy, thus allowing limited cooperation among programmers.
Reference: [Bancilhon et al. 85] <author> Bancilhon, F., Kim, W., and Korth, H. </author> <title> A Model of CAD Transactions. </title> <booktitle> Proceedings of the 11th International Conference on Very Large Data Bases, </booktitle> <publisher> Morgan Kaufmann, </publisher> <month> August, </month> <year> 1985, </year> <pages> pp. 25-33. </pages>
Reference-contexts: Several researchers have thus studied the nature of concurrent behavior in advanced applications, and have arrived at new requirements for concurrency control <ref> [Bancilhon et al. 85; Yeh et al. 87] </ref>: 1. Supporting long transactions: Long-lived operations on objects in design environments (such as compiling and circuit layout) imply that the transactions, in which these operations may be embedded, are also long-lived. Long transactions need different support than short transactions. <p> Instead, the concept of database consistency preservation needs to be refined along the lines of the previous section to allow non-serializable cooperative interaction. Such a refinement can be based on four observations <ref> [Bancilhon et al. 85] </ref>: (1) design efforts are usually partitioned into 46 separate projects, where each project is developed by a team of designers; (2) available workstations provide multiple windows, in which multiple tasks can be executed concurrently by the same designer; (3) projects are divided into subtasks were a group <p> the designers doing the development. 50 8.2.2 Cooperating CAD Transactions Like the group-oriented model, the cooperating CAD transactions model, introduced by Bancilhon, Kim and Korth, envisions a design workspace to consist of a global database that contains a public database for each project and private databases of active designers' transactions <ref> [Bancilhon et al. 85] </ref>. Traditional two-phase locking is used to synchronize access to shared data among different projects in the database. Within the same project, however, each designer is responsible for a well-defined subtask and he invokes a long transaction to complete the subtask.
Reference: [Beeri et al. 86] <author> Beeri, C., Bernstein, P. A., and Goodman, N. </author> <title> A Model for Concurrency in Nested Transaction Systems. </title> <type> Technical Report TR-86-03, </type> <institution> The Wang Institute for Graduate Studies, </institution> <address> Tyngaboro, MA, </address> <month> March, </month> <year> 1986. </year>
Reference-contexts: Beeri, Bernstein and Goodman introduced the notion of order-preserving correctness as the necessary property that layer-specific protocols must use to guarantee consistency <ref> [Beeri et al. 86; Beeri et al. 89] </ref>. This notion was used earlier in a concurrency control model for multilevel transactions implemented in the DASDBS system [Weikum and Schek 84; Weikum 86].
Reference: [Beeri et al. 88] <author> Beeri, C., Schek, H. -J., and Weikum, G. </author> <title> Multilevel Transaction Management, Theoretical Art or Practical Need? Advances in Database Technology - EDBT '88, </title> <year> 1988. </year>
Reference-contexts: Beeri, Weikum and Schek have observed that concurrency can be increased if long-duration operations are abstracted into subtransactions that are implemented by a set of lower-level operations. If these lower-level operations are themselves translated into yet more lower-level operations, then the abstraction can be extended to multiple levels <ref> [Beeri et al. 88] </ref>. <p> This notion was used earlier in a concurrency control model for multilevel transactions implemented in the DASDBS system [Weikum and Schek 84; Weikum 86]. A combined report on both of these efforts appears in <ref> [Beeri et al. 88] </ref> The basic idea of order-preserving serializability is to extend the concept of commutativity which states that order transformation cannot be applied to two operations belonging to the same transaction because that changes the order of execution of operations within a transaction. <p> Walter observes that it is possible to define all other nested transaction models in his model. Moss' model for example is defined as creating subtransactions with attributes set to BACK-OUT, NOCOMMIT, SYNC. Beeri, Schek and Weikum's multilevel transaction model <ref> [Beeri et al. 88] </ref>, described in the previous section, supports the combination COMMIT, BACKOUT, NOSYNC.
Reference: [Beeri et al. 89] <author> Beeri, C., Bernstein, P. A., and Goodman, N. </author> <title> ``A Model for Concurrency in Nested Transaction Systems .'' Journal of the ACM 36, </title> <type> 1, </type> <year> 1989. </year>
Reference-contexts: Beeri, Bernstein and Goodman introduced the notion of order-preserving correctness as the necessary property that layer-specific protocols must use to guarantee consistency <ref> [Beeri et al. 86; Beeri et al. 89] </ref>. This notion was used earlier in a concurrency control model for multilevel transactions implemented in the DASDBS system [Weikum and Schek 84; Weikum 86]. <p> Most design applications are multilevel, that is, several levels of nesting are needed to support high-level operations that are translated into a set of component sub-operations <ref> [Beeri et al. 89] </ref>. In software development, for example, a high-level operation such as modifying a subsystem translates into a set of operations to modify its component modules, each of which in turn is an abstraction for modifying the procedures that make up the module.
Reference: [Bernstein 87] <author> Bernstein, P. </author> <title> Database System Support for Software Engineering -- An Extended Abstract. </title> <booktitle> Proceedings of the 9th International Conference on Software Engineering, </booktitle> <month> March, </month> <year> 1987, </year> <pages> pp. 166-178. </pages>
Reference-contexts: Since there are numerous commercial database systems available, several projects have tried to use them in advanced applications. Researchers discovered quite rapidly, however, that even the most sophisticated of today's DBMSs are inadequate for requirements of advanced applications <ref> [Korth and Silberschatz 86; Bernstein 87] </ref>. One of the shortcomings of traditional general-purpose databases is the inability to provide flexible concurrency control mechanisms that can support the needs of users in advanced applications.
Reference: [Bernstein and Goodman 81] <author> Bernstein, P., and Goodman, N. </author> <title> ``Concurrency Control in Distributed Database Systems.'' </title> <journal> ACM Computing Surveys 13, </journal> <volume> 2, </volume> <month> June </month> <year> 1981, </year> <pages> pp. 185-221. </pages>
Reference-contexts: Each operation within a transaction is abstracted into either reading a data item or writing it. Achieving serializability in DBMSs can thus be decomposed into two subproblems: read-write synchronization and write-write synchronization, denoted rw and ww synchronization, respectively <ref> [Bernstein and Goodman 81] </ref>. Accordingly, concurrency control algorithms can be categorized into those that guarantee rw synchronization, those that are concerned with ww synchronization, and those that integrate the two. <p> In this section, we briefly describe these five approaches. For a comprehensive discussion and survey of the topic, the reader is referred to <ref> [Bernstein and Goodman 81] </ref> and [Kohler 81]. 4.1 Locking Mechanisms 4.1.1 Two-Phase Locking The two-phase locking mechanism (2PL) introduced by Eswaran et al. is now accepted as the standard solution to the concurrency control problem in conventional database systems. 2PL guarantees serializability in a centralized database when transactions are executed concurrently.
Reference: [Bernstein et al. 87] <author> Bernstein, P. A., Hadzilacos, V., and Goodman, N. </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1987. </year>
Reference-contexts: can guarantee: (1) that each of the transactions submitted to the DBMS by a user eventually gets executed; and (2) that the results of the computation performed by each transaction are the same whether it is executed on a dedicated system or concurrently with other transactions in a multi-programmed system <ref> [Bernstein et al. 87; Papadimitriou 86] </ref>. Let us follow up on our previous example to demonstrate the concept of transactions. John and Mary are assigned the task of fixing two bugs that were suspected to be in modules A and B. <p> The existence of multiple versions eliminates the need for write-write synchronization since each write operation produces a new version and thus can not conflict with another write operation. The only possible conflicts are those corresponding to read-from relationships <ref> [Bernstein et al. 87] </ref>, as demonstrated by the following example. Let R (x) be a read operation with timestamp TS (R). R (x) is processed by reading the value of the version of x whose timestamp is the largest timestamp smaller than TS (R).
Reference: [Bjork 73] <author> Bjork, L. A. </author> <title> Recovery Scenario for a DB/DC System. </title> <booktitle> Proceedings of the 28th ACM National Conference, </booktitle> <publisher> ACM Press., </publisher> <month> August, </month> <year> 1973, </year> <pages> pp. 142-146. </pages>
Reference-contexts: The idea of nested spheres of control, which is the origin of the nested transactions concept, 14 was first introduced by Davies [Davies 73] and expanded by Bjork <ref> [Bjork 73] </ref>. Reed presented a comprehensive solution to the problem of composing transactions by formulating the concept of nested transactions [Reed 78]. A nested transaction is a composition of a set of subtransactions; each subtransaction can itself be a nested transaction.
Reference: [Chrysanthis and Ramamritham 90] <author> Chrysantis. P. K., and Ramamritham, K. </author> . <title> Acta: A Framework for Specifying and Reasoning about Transaction Structure and Behavior. </title> <booktitle> Proceedings of the 1990 ACM SIGMOD International Conference on the Management of Data, </booktitle> <publisher> ACM Press, </publisher> <month> May, </month> <year> 1990, </year> <pages> pp. 194-203. </pages>
Reference-contexts: This approach was pursued in developing the ACTA framework, which is capable of specifying both the structure and behavior of transactions, as well as concurrency and recovery properties <ref> [Chrysanthis and Ramamritham 90] </ref>. Although all of the extended transaction models presented in the paper address at least one of the concurrency control requirements, which include supporting long duration transactions, user control over transactions and cooperation among multiple users, none of them supports all requirements.
Reference: [Davies 73] <author> Davies, C. T. </author> <title> Recovery Semantics for A DB/DC System. </title> <booktitle> Proceedings of the 28th ACM National Conference, </booktitle> <publisher> ACM Press., </publisher> <month> August, </month> <year> 1973, </year> <pages> pp. 136-141. </pages>
Reference-contexts: What is needed is to execute the composition of transactions as a transaction in its own right, and to provide concurrency control within the transaction. The idea of nested spheres of control, which is the origin of the nested transactions concept, 14 was first introduced by Davies <ref> [Davies 73] </ref> and expanded by Bjork [Bjork 73]. Reed presented a comprehensive solution to the problem of composing transactions by formulating the concept of nested transactions [Reed 78]. A nested transaction is a composition of a set of subtransactions; each subtransaction can itself be a nested transaction.
Reference: [Davies 78] <author> Davies, C. T. </author> <title> ``Data Processing Spheres of Control.'' </title> <journal> IBM System Journal 17, </journal> <volume> 2, </volume> <year> 1978, </year> <pages> pp. 179-198. </pages>
Reference-contexts: For instance, some of the ideas related to multilevel transactions, long transactions and cooperative transactions were discussed by Davies in <ref> [Davies 78] </ref>. 17 6 SUPPORTING LONG TRANSACTIONS Many of the operations performed on data in advanced database applications are long-lived. Some last for several minutes or hours such as compiling code or printing a complete layout of a VLSI chip.
Reference: [Dittrich et al. 87] <author> Dittrich, K., Gotthard, W., and Lockemann, P. </author> <title> ``DAMOKLES -- The Database System for the UNIBASE Software Engineering Environment.'' </title> <journal> IEEE Bulletin on Database Engineering 10, </journal> <volume> 1, </volume> <month> March </month> <year> 1987, </year> <pages> pp. 37-47. </pages>
Reference: [Dowson and Nejmeh 89] <author> Dowson, M., and Nejmeh, B. </author> <title> Nested Transactions and Visibility Domains. </title> <booktitle> Proceedings of the 1989 ACM SIGMOD Workshop on Software CAD Databases, </booktitle> <publisher> ACM Press, </publisher> <month> February, </month> <year> 1989, </year> <pages> pp. 36-38. </pages> <note> Position paper. 60 </note>
Reference-contexts: Toueg and Abbadi do not sketch the compatibility requirements between global and local policies. Dowson and Nejmeh have applied the group concept to model teams of programmers. The have introduced the notion of visibility domains, which models groups of programmers executing nested transactions on immutable objects <ref> [Dowson and Nejmeh 89] </ref>. A visibility domain is a set of users who can share the same data items. Each transaction has a particular visibility domain associated with it.
Reference: [Eastman 80] <author> Eastman, C. </author> <title> System Facilities for CAD Databases. </title> <booktitle> Proceedings of the 17th ACM Design Automation Conference, </booktitle> <publisher> ACM Press, </publisher> <month> June, </month> <year> 1980, </year> <pages> pp. 50-56. </pages>
Reference-contexts: In some advanced applications such as CAD, where the different parts of the design are stored in a project database, it is possible to supply semantic information in the form of integrity constraints on database entities. Design operations incrementally change those entities in order to reach the final design <ref> [Eastman 80; Eastman 81] </ref>. By definition, full integrity of the design, in the sense of satisfying its specification, exists only when it is complete.
Reference: [Eastman 81] <author> Eastman, C. </author> <title> Database Facilities for Engineering Design. </title> <booktitle> Proceedings of the IEEE, </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> October, </month> <year> 1981, </year> <pages> pp. 1249-1263. </pages>
Reference-contexts: In some advanced applications such as CAD, where the different parts of the design are stored in a project database, it is possible to supply semantic information in the form of integrity constraints on database entities. Design operations incrementally change those entities in order to reach the final design <ref> [Eastman 80; Eastman 81] </ref>. By definition, full integrity of the design, in the sense of satisfying its specification, exists only when it is complete.
Reference: [Ege and Ellis 87] <author> Ege, A., and Ellis, C. A. </author> . <title> Design and implementation of Gordion, an Object Base Management System. </title> <booktitle> Proceedings of the 3rd International Conference on Data Engineering, </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> February, </month> <year> 1987, </year> <pages> pp. 226-234. </pages>
Reference-contexts: To do this, the Gordion database system provides a notification primitive that can be used in conjunction with other primitives (such as different lock modes) to implement cooperative concurrency control policies <ref> [Ege and Ellis 87] </ref>. Notification alerts users about "interesting" events such as breaking a non-exclusive lock. Two policies that use notification in conjunction with non-exclusive locks and versions were implemented in the Gordion system; these are immediate notification and delayed notification.
Reference: [El Abbadi and Toueg 89] <author> El Abbadi, A. and Toueg, S. </author> <title> ``The Group Paradigm for Concur-rency Control Protocols.'' </title> <journal> IEEE Transactions on Knowledge and Data Engineering 1, </journal> <volume> 3, </volume> <month> Sep-tember </month> <year> 1989, </year> <pages> pp. 376-386. </pages>
Reference-contexts: Abbadi and Toueg defined the concept of a group as a set of transactions, that when executed transforms the database from one consistent state to another <ref> [El Abbadi and Toueg 89] </ref>. Groups, like nested transactions, is a higher level abstraction than a transaction.
Reference: [Eswaran et al. 76] <author> Eswaran, K., Gray, J., Lorie, R., and Traiger, I. </author> <title> ``The Notions of Consistency and Predicate Locks in a Database System.'' </title> <journal> Communications of the ACM 19, </journal> <volume> 11, </volume> <month> Novem-ber </month> <year> 1976, </year> <pages> pp. 624-632. </pages>
Reference-contexts: operating system or a disk crash in the middle of operations, and (2) concurrent access of the same data item by multiple users or programs. 3.1 The Transaction Concept To solve these problems, the operations performed by a process that is accessing the database are grouped into sequences called transactions <ref> [Eswaran et al. 76] </ref>. Thus, users would interact with a DBMS by executing transactions. <p> The mechanism depends on well-formed transactions, which (1) do not relock entities that have been locked earlier in the transaction, and (2) are divided into a growing phase, in which locks are only acquired, and a shrinking phase, in which locks are only released <ref> [Eswaran et al. 76] </ref>. During the shrinking phase, a transaction is prohibited from acquiring locks. If a transaction tries during its growing phase to acquire a lock that has already been acquired by another transaction, it is forced to wait.
Reference: [Feldman 79] <author> Feldman, S. I. </author> <title> ``Make A Program for Maintaining Computer Programs.'' </title> <journal> Software Practice & Experience 9, </journal> <volume> 4, </volume> <month> April </month> <year> 1979, </year> <pages> pp. 255-265. </pages>
Reference-contexts: Traditionally, users of such systems managed the data they generate either manually or by the help of special-purpose tools. For example, programmers working on a large-scale software project use system configuration management (SCM) tools such as Make <ref> [Feldman 79] </ref> and RCS [Tichy 85] to manage the configurations and versions of the programs they are developing. Releases of the finished project are stored in different directories manually.
Reference: [Fernandez and Zdonik 89] <author> Fernandez, M. F., and Zdonik, S. B. </author> <title> Transaction Groups: A Model for Controlling Cooperative Work. </title> <booktitle> Proceedings of the 3rd International Workshop on Persistent Object Systems: Their Design, Implementation and Use, </booktitle> <month> January, </month> <year> 1989, </year> <pages> pp. 128-138. </pages>
Reference-contexts: The transaction groups model proposed for the ObServer system replaces classical locks with &lt;lock mode, communication mode&gt; pairs to support the implementation of a nested framework for cooperating transactions <ref> [Skarra and Zdonik 89; Fernandez and Zdonik 89] </ref>. A transaction group (TG) is defined as a process that controls the access of a set of cooperating transactions (members of the transaction group) to objects from the object server.
Reference: [Garcia-Molina 83] <author> Garcia-Molina, H. </author> <title> ``Using Semanti c Knowledge for Transaction Processing in a Distributed Database.'' </title> <journal> ACM Transactions on Database Systems 8, </journal> <volume> 2, </volume> <month> June </month> <year> 1983, </year> <pages> pp. 186-213. </pages>
Reference-contexts: Relaxing serializability increases the level of con-currency in a system of concurrent transactions, and thus improves its performance. 6.2.1 Semantics-Based Concurrency Control Garcia-Molina observed that by using semantic information, a DBMS can replace the serializability constraint by the semantic consistency constraint <ref> [Garcia-Molina 83] </ref>. The gist of this approach is that from a user's point of view, not all transactions need to be atomic. Garcia-Molina introduced the notion of sensitive transactions to guarantee that users see consistent data on their terminals. <p> Even if all the consistency constraints were given to the system (which is not possible in the general case), there is no way for the concurrency control mechanism to guess which schedules maintain semantic consistency without running the schedules and checking the constraints on the resulting state of the database <ref> [Garcia-Molina 83] </ref>. Doing that, however, would be equivalent to implementing an optimistic concurrency control scheme which suffers from the problem of rollback. <p> Mary1 John2 6.2.3 Sagas Both semantic atomicity and multilevel atomicity are theoretical concepts that are not immediately practical. For example, neither Garcia-Molina <ref> [Garcia-Molina 83] </ref> nor Lynch [Lynch 83] explain how a multilevel atomicity scheme might be implemented (e.g., it is not clear how the user decides on the levels of atomicity and breakpoint sets). Simplifying assumptions are needed to make these concepts practical.
Reference: [Garcia-Molina and Salem 87] <author> Garcia-Molina, H., and Salem, K. SAGAS. </author> <booktitle> Proceedings of the ACM SIGMOD 1987 Annual Conference, </booktitle> <publisher> ACM Press, </publisher> <month> May, </month> <year> 1987, </year> <pages> pp. 249-259. </pages>
Reference-contexts: Simplifying assumptions are needed to make these concepts practical. One restriction that simplifies the multilevel atomicity 30 concept is to allow only two levels of nesting: the LT at the top level and simple transactions. Making this simplifying restriction, Garcia-Molina and Salem introduced the concept of sagas <ref> [Garcia-Molina and Salem 87] </ref>, which are LTs that can be broken up into a collection of sub-transactions that can be interleaved in any way with other transactions.
Reference: [Garza and Kim 88] <author> Garza, J., and Kim, W. </author> <title> Transaction Management in an Object-Oriented Database System. </title> <booktitle> Proceedings of the ACM SIGMOD International Conference on the Management of Data, </booktitle> <publisher> ACM Press, </publisher> <month> June, </month> <year> 1988, </year> <pages> pp. 37-45. </pages>
Reference-contexts: The Orion object-oriented database system provides a concurrency control mechanism based on the multi-granularity mechanism described above <ref> [Kim et al. 88; Garza and Kim 88] </ref>. 4.6 Nested Transactions A transaction, as presented above, is a set of primitive atomic actions abstracted as read and write operations. Each transaction is independent of other transactions.
Reference: [Gray 78] <author> Gray, J. </author> <booktitle> Notes On Database Operating Systems. </booktitle> <institution> IBM Research Report RJ2188, IBM Research Laboratory, </institution> <address> San Jose, CA, </address> <year> 1978. </year>
Reference-contexts: This is clearly inefficient. To solve this problem, a third kind of lock mode called intention lock mode was introduced <ref> [Gray 78] </ref>. All the ancestors of a node must be locked in intention mode before an explicit lock can be put on the node. In particular, nodes can be locked in five different modes.
Reference: [Gray et al. 75] <author> Gray, J., Lorie R., and Putzolu, G. </author> <title> Granularity of Locks and Degrees of Consistency in a Shared Database. </title> <institution> IBM Research Report RJ1654, IBM Research Laboratory, </institution> <address> San Jose, CA, </address> <year> 1975. </year>
Reference-contexts: Gray et al. presented a multiple granularity concurrency control protocol, which aims to minimize the number of locks used while accessing sets of objects in a database <ref> [Gray et al. 75] </ref>. In their model, Gray et al. organize data items in a tree where items of small granularity are nested within larger ones. Each non-leaf item represents the data associated with its descendants.
Reference: [Kaiser 89] <author> Kaiser, G. E. </author> <title> A Marvelous Extended Transaction Processing Model. </title> <booktitle> Proceedings of the 11th World Computer Conference IFIP Congress '89, </booktitle> <publisher> Elsevier Science Publishers B.V., </publisher> <month> August, </month> <year> 1989, </year> <pages> pp. 707-712. </pages>
Reference-contexts: To solve this problem, Pu et al. introduced two new operations, split-transaction and join-transaction, which are used to reconfigure long transactions while in progress [Pu et al. 88]. These two mechanisms are the basis of a concurrency control policy that they now call commit-serializability <ref> [Kaiser 89] </ref>. The basic idea of commit-serializability is that all sets of database actions that are included in a set of concurrent transactions are performed in a schedule that is serializable when the actions are committed.
Reference: [Kaiser 90] <author> Kaiser, G. E. </author> <title> A Flexible Transaction Model for Software Engineering. </title> <booktitle> Proceedings of the 6th International Conference on Data Engineering, </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> February, </month> <year> 1990, </year> <pages> pp. 560-567. 61 </pages>
Reference-contexts: Another approach is to define a group of users as participants in a specific set of transactions, meaning that these transactions need not appear to have been performed in some serial order with respect to these participants <ref> [Kaiser 90] </ref>. 1 A set of transactions, with a particular set of participants, is called a domain . Other users remain observers, and this set of transactions must appear serial to these users. Participation is always with respect to some specific set of transactions.
Reference: [Kaiser and Feiler 87] <author> Kaiser, G. E., and Feiler, P. H. </author> <title> Intelligent Assistance without Artificial Intelligence. </title> <booktitle> Proceedings of the 32nd IEEE Computer Society International Conference, </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> February, </month> <year> 1987, </year> <pages> pp. 236-241. </pages>
Reference-contexts: This mechanism solves the first problem described above with the reserve/deposit model. A concurrency control mechanism similar to conversational transactions is used in Smile, a multi-user software development environment <ref> [Kaiser and Feiler 87] </ref>. Smile adds semantics 37 based consistency preservation to the conversational transactions model by enforcing global consistency checks before allowing a set of objects to be checked back in.
Reference: [Kaiser and Perry 87] <author> Kaiser, G. E., and Perry, D. E. </author> <title> Workspaces and Experimental Databases: Automated Support for Software Maintenance and Evolution. </title> <booktitle> Proceedings of the Conference on Software Maintenance, </booktitle> <month> September, </month> <year> 1987, </year> <pages> pp. 108-114. </pages>
Reference-contexts: the previous section. 7.2 Multilevel Pessimistic Coordination A more recent system, Infuse, supports a multilevel hierarchy of experimental databases rather than a two-level hierarchy, and relaxes application-specific consistency constraints by enforcing only that modules in an experimental database have to be self-consistent before they are deposited to the parent database <ref> [Kaiser and Perry 87] </ref>. More global consistency is enforced only when the modules reserved in top level experimental databases are deposited to the main database. Returning to our example, let us assume that both Bob and Mary are involved in a task that requires modifying modules A and C.
Reference: [Katz and Weiss 84] <author> Katz, R., and Weiss, S. </author> <title> Design Transaction Management. </title> <booktitle> Proceedings of the ACM IEEE 21st Design Automation Conference, </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> June, </month> <year> 1984, </year> <pages> pp. 692-693. </pages>
Reference-contexts: Two mechanisms that provide partial solutions to both of the problems described above are the conversational transactions mechanism provided as an extension to System R [Lorie and Plouffe 83; William et al. 81], and the design transactions mechanism <ref> [Katz and Weiss 84] </ref>. In both mechanisms, the database of a design project consists of a public database, which is shared among all designers, and several private databases, each of which is only accessed by a single designer.
Reference: [Kim et al. 84] <author> Kim, W., Lorie, R. A., McNabb, D., and Plouffe, W. </author> <title> A Transaction Mechanism for Engineering Databases. </title> <booktitle> Proceedings of the 10th International Conference on Very Large Data Bases, </booktitle> <publisher> Morgan Kaufmann, </publisher> <month> August, </month> <year> 1984, </year> <pages> pp. 355-362. </pages>
Reference-contexts: Realizing the multilevel nature of advanced applications, several researchers have proposed models and proof techniques that address multilevel transactions. We have already described three related models in the previous subsection [Weikum and Schek 84; Beeri et al. 89; Beeri et al. 88]. Two other nested transaction models <ref> [Walter 84; Kim et al. 84] </ref> are described in section 7, since these two models address the issue of groups of users and coordinated changes.
Reference: [Kim et al. 88] <author> Kim, W., Ballou, N., Chou, H., and Garza, J. </author> <title> Integrating an Object-Oriented Programming System with a Database System. </title> <booktitle> Proceedings of the 3rd International Conference on Object Oriented Programming Systems, Languages and Applications, </booktitle> <month> September, </month> <year> 1988, </year> <pages> pp. 142-152. </pages>
Reference-contexts: The Orion object-oriented database system provides a concurrency control mechanism based on the multi-granularity mechanism described above <ref> [Kim et al. 88; Garza and Kim 88] </ref>. 4.6 Nested Transactions A transaction, as presented above, is a set of primitive atomic actions abstracted as read and write operations. Each transaction is independent of other transactions.
Reference: [Klahold et al. 85] <author> Klahold, P.,Schlageter, G., Unland, R., and Wilkes, W. </author> <title> A Transaction Model Supporting Complex Applications in Integrated Information Systems. </title> <booktitle> Proceedings of the ACM SIGMOD International Conference on the Management of Data, </booktitle> <publisher> ACM Press, </publisher> <month> May, </month> <year> 1985, </year> <pages> pp. 388-401. </pages>
Reference-contexts: It is worth mentioning that the four mechanisms avoid using blocking to synchronize transactions, thus eliminating the problem of deadlock. 8.2.1 Group-Oriented CAD Transactions An extension to the conversational transactions model, described in section 7, that provides such a range of lock modes, is the group-oriented model <ref> [Klahold et al. 85] </ref>. Unlike the conversational transactions model, which sets long-lived locks on objects that are reserved in a private database for a long period of time (until they are deposited to the public database), the group-oriented model avoids the problem of long-lived locks.
Reference: [Kohler 81] <author> Kohler, W. </author> <title> ``A Survey of Techniques for Synchronization and Recovery in Decentralized Computer Systems.'' </title> <journal> ACM Computing Surveys 13, </journal> <volume> 2, </volume> <month> June </month> <year> 1981, </year> <pages> pp. 149-183. </pages>
Reference-contexts: In this section, we briefly describe these five approaches. For a comprehensive discussion and survey of the topic, the reader is referred to [Bernstein and Goodman 81] and <ref> [Kohler 81] </ref>. 4.1 Locking Mechanisms 4.1.1 Two-Phase Locking The two-phase locking mechanism (2PL) introduced by Eswaran et al. is now accepted as the standard solution to the concurrency control problem in conventional database systems. 2PL guarantees serializability in a centralized database when transactions are executed concurrently. <p> This problem can be solved by assigning each transaction a unique number, called a timestamp, chosen from a monotonically increasing sequence, which is often a function of the time of the day <ref> [Kohler 81] </ref>. Using times tamps, a concurrency control mechanism can totally order requests from transactions according to the transactions' timestamps [Rosenkrantz et al. 78].
Reference: [Korth and Silberschatz 86] <author> Korth, H., and Silberschatz, A. </author> <title> Database System Concepts. </title> <publisher> McGraw-Hill Book Company, </publisher> <address> New York, NY, </address> <year> 1986. </year>
Reference-contexts: Since there are numerous commercial database systems available, several projects have tried to use them in advanced applications. Researchers discovered quite rapidly, however, that even the most sophisticated of today's DBMSs are inadequate for requirements of advanced applications <ref> [Korth and Silberschatz 86; Bernstein 87] </ref>. One of the shortcomings of traditional general-purpose databases is the inability to provide flexible concurrency control mechanisms that can support the needs of users in advanced applications. <p> From the perspective of a DBMS, all computations in a transaction either read or write a data item from the database. Thus, two schedules S1 and S2 are said to be computationally equivalent if <ref> [Korth and Silberschatz 86] </ref>: 7 1. The set of transactions that participate in S and S are the same. 1 2 2.
Reference: [Korth and Speegle 88] <author> Korth, H., and Speegle, G. </author> <title> Formal Model of Correctness Without Serializability. </title> <booktitle> Proceedings of the ACM SIGMOD International Conference on the Management of Data, </booktitle> <publisher> ACM Press, </publisher> <month> June, </month> <year> 1988, </year> <pages> pp. 379-386. </pages>
Reference-contexts: We now describe a formal model of correctness without serializability that is based on multilevel transactions. 6.2.4 Conflict Predicate Correctness Korth and Speegle have presented a formal model that allows mathematical characterization of correctness without serializability <ref> [Korth and Speegle 88] </ref>. Their model combines three features that lead to enhancing concurrency over the serializability-based models: (1) versions of objects; (2) multilevel transactions; and (3) explicit consistency predicates, similar to Kutay and Eastman's predicates, described earlier. We describe their model intuitively. <p> T T John Mary | | read (B) | read (A) | write (A) | write (A) | write (B) | write (B) "/ Time 33 To illustrate, consider the schedule shown in figure 11 (which is adapted from <ref> [Korth and Speegle 88] </ref>). This schedule is clearly not serializable and is not allowed by any of the traditional protocols. However, suppose that the database consistency constraint is a conjunct of the form P1 OR P2, and P1 is over A while P2 is over B.
Reference: [Kung and Robinson 81] <author> Kung, H., and Robinson, J. </author> <title> ``On Optimistic Methods for Concur-rency Control.'' </title> <journal> ACM Transactions on Database Systems 6, </journal> <volume> 2, </volume> <month> June </month> <year> 1981, </year> <pages> pp. 213-226. </pages>
Reference-contexts: Otherwise, W is allowed to create a new version of x. 11 4.4 Optimistic Non-Locking Mechanisms In many applications, locking has been found to constrain concurrency and to add an unnecessary overhead. The locking approach has the following disadvantages <ref> [Kung and Robinson 81] </ref>: 1. Lock maintenance represents an unnecessary overhead for read-only transactions, which do not affect the integrity of the database. 2. Most of the general-purpose deadlock-free locking mechanisms work well only in some cases but perform rather poorly in other cases.
Reference: [Kutay and Eastman 83] <author> Kutay, A., and Eastman, C. </author> <title> Transaction Management in Engineering Databases. </title> <booktitle> Proceedings of the Annual Meeting of Database Week; Engineering Design Applications, </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> May, </month> <year> 1983, </year> <pages> pp. 73-80. </pages>
Reference-contexts: There is a need to define transactions that maintain the partial integrity required by design operations. Kutay and Eastman proposed a transaction model that is based on the concept of entity state, which describes the degree of integrity satisfied by an entity <ref> [Kutay and Eastman 83] </ref> 27 Each entity in the database is associated with a state that is defined in terms of a set of integrity constraints.
Reference: [Leblang and Chase, Jr. 87] <author> Leblang, D. B., and Chase, R. P., Jr. </author> <title> ``Parallel Software Configuration Management in a Network Environment.'' </title> <journal> IEEE Software 4, </journal> <volume> 6, </volume> <month> November </month> <year> 1987, </year> <pages> pp. 28-35. </pages>
Reference-contexts: There is a need to group sets of versions that are self-consistent into configurations that would enable programmers to reconstruct a system using the correct versions of the objects that comprise the system. This notion of configurations is supported by many software development systems (e.g., <ref> [Leblang and Chase, Jr. 87] </ref>). Thus, immutability of versions of objects in design environments, where objects have multiple versions, reduces the problem of consistency to the problem of explicitly naming the set of consistent versions in configuration objects.
Reference: [Lorie and Plouffe 83] <author> Lorie, R., and Plouffe, W. </author> <title> Complex Objects and Their Use in Design Transactions. </title> <booktitle> Proceedings of the Annual Meeting of Database Week; Engineering Design Applications, </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> May, </month> <year> 1983, </year> <pages> pp. 115-121. 62 </pages>
Reference-contexts: Two mechanisms that provide partial solutions to both of the problems described above are the conversational transactions mechanism provided as an extension to System R <ref> [Lorie and Plouffe 83; William et al. 81] </ref>, and the design transactions mechanism [Katz and Weiss 84].
Reference: [Lynch 83] <author> Lynch, N. A. </author> <title> ``Multilevel Atomicity A New Correctness Criterion for Database Concurrency Control.'' </title> <journal> ACM Transactions on Database Systems 8, </journal> <volume> 4, </volume> <month> December </month> <year> 1983, </year> <pages> pp. 484-502. </pages>
Reference-contexts: Thus, users would interact with a DBMS by executing transactions. In traditional DBMSs, transactions serve three distinct purposes <ref> [Lynch 83] </ref>: (1) they are logical units that group together operations that comprise a complete task; (2) they are atomicity units whose execution preserves the consistency of the database; and (3) they are recovery units that ensure that either all the steps enclosed within them are executed, or none are. <p> There is thus no distinction between interleaving with respect to Y and interleaving with respect to Z. Lynch observed that it might be more appropriate to have different sets of inter-leavings (in the form of specific breakpoints) with respect to different transaction types <ref> [Lynch 83] </ref>. This observation seems to be valid for systems in which activities tend to be hierarchical in nature, for example, software development environments. <p> Mary1 John2 6.2.3 Sagas Both semantic atomicity and multilevel atomicity are theoretical concepts that are not immediately practical. For example, neither Garcia-Molina [Garcia-Molina 83] nor Lynch <ref> [Lynch 83] </ref> explain how a multilevel atomicity scheme might be implemented (e.g., it is not clear how the user decides on the levels of atomicity and breakpoint sets). Simplifying assumptions are needed to make these concepts practical.
Reference: [Martin 87] <author> Martin, B. </author> <title> Modeling Concurrent Activities with Nested Objects. </title> <booktitle> Proceedings of the 7th International Conference on Distributed Computing Systems, </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> September, </month> <year> 1987, </year> <pages> pp. 432-439. </pages>
Reference-contexts: Although the 24 schedule is not order-preserving serializable, it is correct because it could be serialized as shown in figure 9 (b) by changing the order of the two compile operations, and since these are nonconflicting subtransactions, the change of order preserves correctness. Martin <ref> [Martin 87] </ref> presented a similar model based on the paradigm of nested objects, which models hierarchical access to data by defining a nested object system. Each object in the system exists at a particular level of data abstraction in the system.
Reference: [Moss 85] <author> Moss, J. E. B. </author> <title> Nested Transactions: An Approach to Reliable Distributed Computing. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1985. </year>
Reference-contexts: In Reed's design, timestamp ordering is used to synchronize the concurrent actions of subtransactions within a nested transaction. Moss designed a nested transaction system that uses locking for synchronization <ref> [Moss 85] </ref>. Moss's design also manages nested transactions in a distributed system. As far as concurrency is concerned, the nested transaction model presented above does not change the meaning of transactions (in terms of being atomic) and it does not alter the concept of serializability. <p> If these lower-level operations are themselves translated into yet more lower-level operations, then the abstraction can be extended to multiple levels [Beeri et al. 88]. This is distinct from the traditional nested transactions model presented in section 4 <ref> [Reed 78; Moss 85] </ref> in two main respects: (1) a multilevel transaction has a fixed number of levels, of which each two adjacent pairs define a layer of the system, whereas nested transactions have no predefined notion of layers; and (2) in contrast to nested transactions where there need not be
Reference: [Nestor 86] <author> Nestor, J. R. </author> <title> Toward a Persistent Object Base. In Advanced Programming Environments, Conradi, </title> <editor> R., Didriksen, T. M., and Wanvik, D. H., Eds., </editor> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1986, </year> <pages> pp. 372-394. </pages>
Reference: [Papadimitriou 86] <author> Papadimitriou, C. </author> <title> The Theory of Database Concurrency Control. </title> <publisher> Computer Science Press, </publisher> <address> Rochville, MD, </address> <year> 1986. </year>
Reference-contexts: can guarantee: (1) that each of the transactions submitted to the DBMS by a user eventually gets executed; and (2) that the results of the computation performed by each transaction are the same whether it is executed on a dedicated system or concurrently with other transactions in a multi-programmed system <ref> [Bernstein et al. 87; Papadimitriou 86] </ref>. Let us follow up on our previous example to demonstrate the concept of transactions. John and Mary are assigned the task of fixing two bugs that were suspected to be in modules A and B.
Reference: [Pradel et al. 86] <author> Pradel, U., Schlageter, G., and Unland, R. </author> <title> Redesign of Optimistic Methods: Improving Performance and Availability. </title> <booktitle> Proceedings of the 2nd International Conference on Data Engineering, </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> February, </month> <year> 1986, </year> <pages> pp. 466-473. </pages>
Reference-contexts: Pradel et al. observed that the risk of restarting a transaction can be reduced by distinguishing between serious conflicts, which require restart, and non-serious conflicts, which do not. One mechanism that uses this approach is called snapshot validation <ref> [Pradel et al. 86] </ref>. Going back to our example, let us assume that Bob, John, and Mary start three transactions T , T and T simultaneously.
Reference: [Pu et al. 88] <author> Pu, C., Kaiser, G., and Hutchinson, N. </author> <title> Split Transactions for Open-Ended Activities. </title> <booktitle> Proceedings of the 14th International Conference on Very Large Databases, </booktitle> <publisher> Morgan Kaufmann, </publisher> <month> August, </month> <year> 1988, </year> <pages> pp. 26-37. </pages>
Reference-contexts: Specifically, neither sagas nor long transactions in the altruistic locking scheme can be restructured dynamically to reflect a change in the needs of the user. To solve this problem, Pu et al. introduced two new operations, split-transaction and join-transaction, which are used to reconfigure long transactions while in progress <ref> [Pu et al. 88] </ref>. These two mechanisms are the basis of a concurrency control policy that they now call commit-serializability [Kaiser 89].
Reference: [Reed 78] <author> Reed, R. </author> <title> Naming and Synchronization in a Decentralized Computer System. </title> <type> Ph.D. Thesis, </type> <institution> MIT Laboratory of Computer Science, </institution> <month> September </month> <year> 1978. </year> <type> MIT Technical Report 205 </type>
Reference-contexts: This is the basic idea of the multiversion scheme introduced by Reed <ref> [Reed 78] </ref>. In Reed's mechanism, each transaction is assigned a unique timestamp when it starts; all operations of the transaction are assigned the same timestamp. For each data item x there is a set of read timestamps and a set of &lt;write timestamp, value&gt; pairs, called transient versions. <p> The idea of nested spheres of control, which is the origin of the nested transactions concept, 14 was first introduced by Davies [Davies 73] and expanded by Bjork [Bjork 73]. Reed presented a comprehensive solution to the problem of composing transactions by formulating the concept of nested transactions <ref> [Reed 78] </ref>. A nested transaction is a composition of a set of subtransactions; each subtransaction can itself be a nested transaction. To other transactions, the top-level nested transaction is visible and appears as a normal atomic transaction. <p> If these lower-level operations are themselves translated into yet more lower-level operations, then the abstraction can be extended to multiple levels [Beeri et al. 88]. This is distinct from the traditional nested transactions model presented in section 4 <ref> [Reed 78; Moss 85] </ref> in two main respects: (1) a multilevel transaction has a fixed number of levels, of which each two adjacent pairs define a layer of the system, whereas nested transactions have no predefined notion of layers; and (2) in contrast to nested transactions where there need not be
Reference: [Rochkind 75] <author> Rochkind, M. J. </author> <title> ``The Source Code Control System.'' </title> <journal> IEEE Transactions on Software Engineering SE-1, </journal> <year> 1975, </year> <pages> pp. 364-370. </pages>
Reference-contexts: One approach that has been implemented by widely-used software development tools like version control tools, such as SCCS <ref> [Rochkind 75] </ref> and RCS [Tichy 85], is the reserve/deposit mechanism (also called reserve/replace and checkout/checkin). Each data object is considered to be a collection of different versions, where each version represents the state of the object at some time in the history of its development.
Reference: [Rosenkrantz et al. 78] <author> Rosenkrantz, D., Stearns, R., and Lewis P. </author> <title> ``System level concurrency control for distributed database systems.'' </title> <journal> ACM Transactions on Database Systems 3, </journal> <volume> 2, </volume> <month> June </month> <year> 1978, </year> <pages> pp. 178-198. </pages> <booktitle> [Rowe and Wensel 89] 1989 ACM SIGMOD Workshop on Software CAD Databases, </booktitle> <address> Napa, CA, </address> <month> February, </month> <year> 1989. </year>
Reference-contexts: Using times tamps, a concurrency control mechanism can totally order requests from transactions according to the transactions' timestamps <ref> [Rosenkrantz et al. 78] </ref>.
Reference: [Salem et al. 87] <author> Salem, K., Garcia-Molina, H., and Alonso, R. </author> <title> Altruistic Locking: A Strategy for Coping with Long Lived Transactions. </title> <booktitle> Proceedings of the 2nd International Workshop on High Performance Transaction Systems , September, </booktitle> <year> 1987, </year> <pages> pp. </pages> <address> 19.1 - 19.24. </address>
Reference-contexts: One formal mechanism that follows this approach is altruistic locking, which is an extension of the basic two-phase locking algorithm <ref> [Salem et al. 87] </ref>. Altruistic locking makes use of information about access patterns of a transaction to decide which resources it can release.
Reference: [Skarra and Zdonik 89] <author> Skarra, A. H., and Zdonik, S. B. </author> <title> Concurrency Control and Object-Oriented Databases. </title> <editor> In Kim, W., and Lochovsky, F. H., Ed., </editor> <title> Object-Oriented Concepts, Databases, and Applications, </title> <publisher> ACM Press, </publisher> <address> New York, NY, </address> <year> 1989, </year> <pages> pp. 395-421. </pages>
Reference-contexts: The transaction groups model proposed for the ObServer system replaces classical locks with &lt;lock mode, communication mode&gt; pairs to support the implementation of a nested framework for cooperating transactions <ref> [Skarra and Zdonik 89; Fernandez and Zdonik 89] </ref>. A transaction group (TG) is defined as a process that controls the access of a set of cooperating transactions (members of the transaction group) to objects from the object server.
Reference: [Stonebraker et al. 88] <author> Stonebraker, M., Katz, R., Patterson, D. and Ousterhout, J. </author> <booktitle> The Design of XPRS. Proceedings of the 14th International Conference on Very Large Databases, </booktitle> <publisher> Morgan Kaufmann, </publisher> <month> August, </month> <year> 1988, </year> <pages> pp. 318-330. 63 </pages>
Reference-contexts: It is important, however, for the DBMS of an advanced application to be active in the sense that it be able to monitor the activities in the database and automatically perform some operations in response to changes made to the database (this is what the database community calls triggers <ref> [Stonebraker et al. 88] </ref>). Notification must be expanded, perhaps in combination with triggers, to detect a wide variety of database conditions, to consider indirect as well as direct consequences of database updates, and to notify appropriate monitor and automation elements provided by the software development environment.
Reference: [Tichy 85] <author> Tichy, W. F., </author> <title> ``RCS A System for Version Control.'' </title> <journal> Software Practice and Experience 15, </journal> <volume> 7, </volume> <month> July </month> <year> 1985, </year> <pages> pp. 637-654. </pages>
Reference-contexts: Traditionally, users of such systems managed the data they generate either manually or by the help of special-purpose tools. For example, programmers working on a large-scale software project use system configuration management (SCM) tools such as Make [Feldman 79] and RCS <ref> [Tichy 85] </ref> to manage the configurations and versions of the programs they are developing. Releases of the finished project are stored in different directories manually. <p> One approach that has been implemented by widely-used software development tools like version control tools, such as SCCS [Rochkind 75] and RCS <ref> [Tichy 85] </ref>, is the reserve/deposit mechanism (also called reserve/replace and checkout/checkin). Each data object is considered to be a collection of different versions, where each version represents the state of the object at some time in the history of its development.
Reference: [Walpole et al. 87] <author> Walpole, J., Blair, G., Hutchison, D., and Nicol, J. </author> <title> ``Transaction mechanisms for distributed programming environments.'' </title> <journal> Software Engineering Journal 2, </journal> <volume> 5, </volume> <month> September </month> <year> 1987, </year> <pages> pp. 169-177. </pages>
Reference-contexts: mechanisms are responsible for naming consistent groups of versions of related objects [Walpole et al. 88a]. 40 7.3.1 Domain Relative Addressing Walpole et al. have addressed the problem of consistency in immutable object systems and introduced a consistency control notion called domain relative addressing that supports versions of configuration objects <ref> [Walpole et al. 87; Walpole et al. 88b] </ref>. Domain relative addressing extends the notion of time relative addressing (multiversion concurrency control) introduced by Reed.
Reference: [Walpole et al. 88a] <author> Walpole, J., Blair, G., Malik, J., and Nicol, J. </author> <title> Maintaining Consistency in Distributed Software Engineering Environments. </title> <booktitle> Proceedings of the 8th International Conference on Distributed Computing Systems, </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> June, </month> <year> 1988, </year> <pages> pp. 418-425. </pages>
Reference-contexts: This basically solves the problem of reserve/deposit where only ad hoc ways (associating attributes with versions deposited at the same time) can be used to keep track of which versions of different objects belong together. Therefore, transaction mechanisms are responsible for naming consistent groups of versions of related objects <ref> [Walpole et al. 88a] </ref>. 40 7.3.1 Domain Relative Addressing Walpole et al. have addressed the problem of consistency in immutable object systems and introduced a consistency control notion called domain relative addressing that supports versions of configuration objects [Walpole et al. 87; Walpole et al. 88b]. <p> All of A , A , B , and B become immutable versions. Domain relative addressing is the concurrency control mechanism used in the Cosmos software development environment <ref> [Walpole et al. 88a] </ref>. 7.3.2 Copy/Modify/Merge Like Infuse, Sun's Network Software Environment (NSE) supports a nested transaction mechanism that operates on a multilevel hierarchical database structure [Adams et al. 89].
Reference: [Walpole et al. 88b] <author> Walpole, J., Blair, G., Malik, J., and Nicol, J. </author> <title> A Unifying Model for Consistent Distributed Software Development Environments. </title> <booktitle> Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <publisher> ACM Press, </publisher> <month> November, </month> <year> 1988, </year> <pages> pp. 183-190. </pages>
Reference-contexts: mechanisms are responsible for naming consistent groups of versions of related objects [Walpole et al. 88a]. 40 7.3.1 Domain Relative Addressing Walpole et al. have addressed the problem of consistency in immutable object systems and introduced a consistency control notion called domain relative addressing that supports versions of configuration objects <ref> [Walpole et al. 87; Walpole et al. 88b] </ref>. Domain relative addressing extends the notion of time relative addressing (multiversion concurrency control) introduced by Reed.
Reference: [Walter 84] <author> Walter, B. </author> <title> Nested Transactions with Multiple Commit Points: An Approach to the Structuring of Advanced Database Applications. </title> <booktitle> Proceedings of the 10th International Conference on Very Large Data Bases, </booktitle> <publisher> Morgan Kaufmann, </publisher> <month> August, </month> <year> 1984, </year> <pages> pp. 161-171. </pages>
Reference-contexts: Realizing the multilevel nature of advanced applications, several researchers have proposed models and proof techniques that address multilevel transactions. We have already described three related models in the previous subsection [Weikum and Schek 84; Beeri et al. 89; Beeri et al. 88]. Two other nested transaction models <ref> [Walter 84; Kim et al. 84] </ref> are described in section 7, since these two models address the issue of groups of users and coordinated changes. <p> A more general model is needed in order to support a higher level of coordination among transactions. Walter observed that there are three aspects that define the relationship between a parent transaction and child subtransaction <ref> [Walter 84] </ref>: (1) the interface aspect; (2) the dependency aspect; and (3) the synchronization aspect.
Reference: [Weikum 86] <author> Weikum, G. </author> <title> A Theoretical Foundation of Multi-level Concurrency Control. </title> <booktitle> Proceedings of the 5th ACM Symposium on Principles of Database Systems, </booktitle> <publisher> ACM Press, </publisher> <month> March, </month> <year> 1986, </year> <pages> pp. 31-42. </pages>
Reference-contexts: Beeri, Bernstein and Goodman introduced the notion of order-preserving correctness as the necessary property that layer-specific protocols must use to guarantee consistency [Beeri et al. 86; Beeri et al. 89]. This notion was used earlier in a concurrency control model for multilevel transactions implemented in the DASDBS system <ref> [Weikum and Schek 84; Weikum 86] </ref>.
Reference: [Weikum and Schek 84] <author> Weikum, G., and Schek, H. -J. </author> <title> Architectural Issues of Transaction Management in Multi-Level Systems. </title> <booktitle> Proceedings of the 10th International Conference on Very Large Data Bases, </booktitle> <publisher> Morgan Kaufmann, </publisher> <month> August, </month> <year> 1984. </year> * <editor> [William et al. 81] Williams, R., et al. </editor> <title> R : An Overview of the Architecture. </title> <institution> IBM Research Laboratory, </institution> <address> San Jose, CA, </address> <month> December, </month> <year> 1981. </year>
Reference-contexts: Beeri, Bernstein and Goodman introduced the notion of order-preserving correctness as the necessary property that layer-specific protocols must use to guarantee consistency [Beeri et al. 86; Beeri et al. 89]. This notion was used earlier in a concurrency control model for multilevel transactions implemented in the DASDBS system <ref> [Weikum and Schek 84; Weikum 86] </ref>.
Reference: [Yannakakis 82] <author> Yannakakis, M. </author> <title> ``Issues of Correctness in Database Concurrency Control by Locking.'' </title> <journal> Journal of the ACM 29, </journal> <volume> 3, </volume> <month> July </month> <year> 1982, </year> <pages> pp. 718-740. </pages>
Reference-contexts: This situation might result in deadlock if transactions are mutually waiting for each other's resources. 2PL allows only a subset of serializable schedules. In the absence of information about how and when the data items are accessed, however, 2PL is both necessary and sufficient to ensure serializability by locking <ref> [Yannakakis 82] </ref>. If we have prior knowledge about the order of access of data items, which is often the case in advanced applications, we can construct locking protocols that are not 2PL but ensure serializability.

References-found: 62

