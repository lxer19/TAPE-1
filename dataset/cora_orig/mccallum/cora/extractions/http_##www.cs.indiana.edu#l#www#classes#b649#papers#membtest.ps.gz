URL: http://www.cs.indiana.edu/l/www/classes/b649/papers/membtest.ps.gz
Refering-URL: http://www.cs.indiana.edu/l/www/classes/b649/project.html
Root-URL: http://www.cs.indiana.edu
Email: fgalvarez, flaviug@cs.ucsd.edu  
Title: Simulation-based Test of Fault-tolerant Group Membership Services  1997.  
Author: Guillermo A. Alvarez Flaviu Cristian 
Address: La Jolla, CA 920930114, USA  
Affiliation: Department of Computer Science and Engineering University of California, San Diego  
Date: June  
Note: Published in Proc. of the 12th Annual Conference on Computer Assurance (COMPASS'97), Gaithersburg, Maryland,  
Abstract: We address the problem of gaining assurance on the correctness of fault-tolerant and real-time distributed protocols. We validate implementations of two group membership protocols by running a centralized simulation of the distributed system, and testing whether the protocols satisfy the safety and timeliness properties prescribed by their specifications. Our testing environment performs deterministic experiments that include both normal workloads and failures injected into the execution, to test protocol behavior under failure scenarios the protocols are supposed to tolerate. The two membership protocols assume different system models, and depend on quite different sets of underlying services. Even though their specifications contain properties that cannot be evaluated accurately in a distributed platform, our testing environment overcomes this limitation. The tests performed uncovered several flaws in the implementations. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. Alvarez and F. Cristian. </author> <title> Centralized failure injection for distributed, fault-tolerant protocol testing. </title> <booktitle> In Proc. of the 17th IEEE International Conference on Distributed Computing Systems, </booktitle> <address> Baltimore, Maryland, </address> <month> May </month> <year> 1997. </year>
Reference-contexts: The most viable approaches test implementations by subjecting them to experiments that include both normal workloads and failures injected into the execution, to test the service's behavior under failure scenarios it is supposed to tolerate [2, 9, 12, 16]. However, we have found <ref> [1] </ref> that testing protocol properties on distributed platforms presents considerable difficulties; among them, we can cite the inaccessibility of the instantaneous global state of the system, the occurrence of spurious, unwanted failures, and the lack of control over the evolution of testing experiments. <p> Our approach to experimental validation is based on performing a set of test experiments on the implementation under test, and verifying that the properties of the specification hold at every time during them. We designed and implemented a tool based on a centralized simulator <ref> [1] </ref>, that executes all the processes of the distributed system in a single address space. This centralization is transparent for the processes under test, that run the same uninstrumented code that would be used in the real distributed system. <p> CESIUM <ref> [1] </ref> is a testing environment that allows the tester to perform deterministic experiments on a fault-tolerant, real-time protocol implementation, while verifying that it satisfies its specification at every time during the experiments. <p> Thus, CESIUM introduces no timing perturbation in the execution being observed. No spurious failures ever occur as the protocol executes in a totally controlled simulation environment. We proved in <ref> [1] </ref> that CESIUM can execute exactly the set of runs that can occur in the real system being simulated. We also proved that CESIUM tests exactly the safety and timeliness properties of the protocol implementationonly real violations are reported, and no violation can occur without being detected. <p> Asynchronous membership properties testing agents. Even if this load can be tolerated without changing the natural timing of the run, it is not possible to achieve an exact coordination with real time from within the system. In contrast, CESIUM can evaluate all these properties exactly, as we prove in <ref> [1] </ref>. 4.2.
Reference: [2] <author> J. Arlat, A. Costes, Y. Crouzet, J.-C. Laprie, and D. Pow-ell. </author> <title> Fault injection and dependability evaluation of fault-tolerant systems. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 42(8) </volume> <pages> 913-23, </pages> <month> Aug. </month> <year> 1993. </year>
Reference-contexts: The most viable approaches test implementations by subjecting them to experiments that include both normal workloads and failures injected into the execution, to test the service's behavior under failure scenarios it is supposed to tolerate <ref> [2, 9, 12, 16] </ref>. <p> This resulted in a violation of the AM s d property, as correct nodes were excluded from the spurious group. After these errors were fixed, subsequent executions of our experiment sets did not detect any more problems. 5. Related work The Messaline tool <ref> [2] </ref> uses hardware-level fault injection as an alternative to analytical modeling, to evaluate the dependability and fail-silence properties of the Delta-4 fault-tolerant architecture. Echtle and Chen [11] describe heuristics for achieving control path coverage by manipulating the messages exchanged between tasks. <p> In probabilistic approaches that run a large number of random experiments to determine statistical measures (like <ref> [2, 15, 17] </ref>) it is usually difficult to establish a correspondence between the low-level faults injected and the failures observed at the level of the protocol under test.
Reference: [3] <author> E. Brewer, C. Dellarocas, A. Colbrook, and W. Weihl. Proteus: </author> <title> A high-performance parallel-architecture simulator. </title> <booktitle> In Proc. of ACM Sigmetrics and Performance, </booktitle> <pages> pages 247-58, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: Testing performed on distributed platforms [9, 11, 16, 17] is subject to the limitations discussed in Section 3 and 4 for coordination and property testing. Proteus <ref> [3] </ref> and Tango [14] are centralized simulators of MIMD parallel architectures. Even though they are well suited for debugging and performance evaluation, they cannot simulate the occurrence of any fault, and do not provide support for timely testing of protocol properties.
Reference: [4] <author> S. Budkowski. </author> <title> Estelle development toolset (EDT). </title> <journal> Computer Networks and ISDN Systems, </journal> <volume> 25(1) </volume> <pages> 63-82, </pages> <month> Aug. </month> <year> 1992. </year>
Reference-contexts: Even though they are well suited for debugging and performance evaluation, they cannot simulate the occurrence of any fault, and do not provide support for timely testing of protocol properties. Furthermore, they assume a fixed set of L-services, and require that the code under test be instrumented. EDT <ref> [4] </ref> simulates the execution of specifications written in the Estelle language. Safety properties can be tested, but Estelle's time semantics is not well suited for the evaluation of hard real-time properties as relevant events can be arbitrarily late.
Reference: [5] <author> F. Cristian. </author> <title> A rigorous approach to fault-tolerant programming. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-11(1):23-31, </volume> <month> Jan. </month> <year> 1985. </year>
Reference-contexts: Each node has a local clock, that can be accessed only by tasks running locally; there is also a global time reference (real time) that is inaccessible from within the system. The tester forces the occurrence of failures during the execution by invoking failure operations <ref> [5] </ref> written for the particular failure semantics of the protocol under test in terms of CESIUM primitives, or invoking the primitives directly in simpler cases.
Reference: [6] <author> F. Cristian. </author> <title> Reaching agreement on processor-group membership in synchronous distributed systems. </title> <journal> Distributed Computing, </journal> <volume> 4 </volume> <pages> 175-187, </pages> <year> 1991. </year>
Reference-contexts: A group membership service provides each client process with a view of the nodes that are correct and connected to it. This paper reports the experimental evaluation of the correctness and fault-tolerance of two implementations of group membership protocols. One of these protocols <ref> [6] </ref> is for synchronous (hard real-time) systems, and the other [8] is for asynchronous systems, where network partitions can occur and there is no bound on communication delays. For each protocol, we list the properties that it must satisfy. <p> The workload and the injected failures are supervised by a centralized task, the driver, that controls the progress of the experiment by monitoring the global state of the system. The protocol under test, in general, depends upon hierarchy other lower-level services (l-services). For example, the synchronous membership protocol <ref> [6] </ref> tested in this paper depends upon a synchronous atomic broadcast service, clocks internally synchronized within a maximum deviation of *, and an unreliable datagram service. Figure 1 shows the service hierarchy for this protocol. <p> Synchronous group membership We performed several testing experiments on an implementation of the attendance list synchronous group membership protocol <ref> [6] </ref>. The attendance list protocol ensures that every correct processor perceives the same sequence of failures and restarts in the system, which result in the formation of successive groups. <p> The list returns to its originator after being relayed by all other group members in the logical ring. The details, analysis, and pseudocode of the attendance list protocol can be found in <ref> [6] </ref>. 3.1. Properties of the synchronous service Table 1 shows the set of properties that every correct implementation of the protocol must satisfy. Properties with names of the form SM s are safety properties, and those with names of the form SM t are timeliness properties. <p> Results The following errors were found in the attendance list protocol's implementation during our experiments: * Each s-server checks at membership confirmation time whether it has received a timely attendance list or not. A missing term of j in the pseudocode of <ref> [6] </ref> resulted in a comparison that could never succeed, even if the list had been received timely.
Reference: [7] <author> F. Cristian. </author> <title> Understanding fault-tolerant distributed systems. </title> <journal> Communications of ACM, </journal> <volume> 34(2) </volume> <pages> 56-78, </pages> <month> Feb </month> <year> 1991. </year>
Reference-contexts: 1. Introduction Distributed fault-tolerant group services such as group membership, atomic broadcast, and clock synchronization, allow a set of processors to cooperate in providing highly available services despite the occurrence of component failures <ref> [7] </ref>. These services are basic building blocks for the development of dependable applications, for they exhibit a well-defined behavior when failures occureither masking them completely, or degrading the quality of service in a predictable way. Real-time services must, in addition, deliver the correct results within bounded time intervals.
Reference: [8] <author> F. Cristian and F. Schmuck. </author> <title> Agreeing on processor-group membership in asynchronous distributed systems. </title> <type> Technical Report CS95-428, </type> <institution> Dept. of Computer Science and Engineering, University of California, </institution> <address> San Diego, </address> <year> 1995. </year> <note> ftp:// cs.ucsd.edu/ pub/ team/ asyncmembership.ps.Z. </note>
Reference-contexts: This paper reports the experimental evaluation of the correctness and fault-tolerance of two implementations of group membership protocols. One of these protocols [6] is for synchronous (hard real-time) systems, and the other <ref> [8] </ref> is for asynchronous systems, where network partitions can occur and there is no bound on communication delays. For each protocol, we list the properties that it must satisfy. <p> We repeated all three experiment sets after correcting each error, and there were no property violations for our erarchy final version. 4. Asynchronous group membership The three-round with partition detection group membership protocol was originally presented in <ref> [8] </ref>. The protocol assumes the timed asynchronous system model. Every participating node has a hardware clock that drifts from real time at a rate bounded by a known constant. Local clocks need not be synchronized. The protocol depends upon an unreliable datagram service for communication, as shown in Figure 2. <p> The system is stable during a time interval if there are no crashes or recoveries during the interval, every pair of processors is either connected or disconnected, and the `connected' relation is constant and transitive <ref> [8] </ref>. Practical, well-tuned asynchronous systems are likely to alternate between long stability periods and comparatively short instability intervals. In the three-round protocol, failures are detected by circulating an attendance list as before. <p> The detailed pseudocode and proof of correctness for the three-round protocol can be found in <ref> [8] </ref>. 4.1. Properties of the asynchronous service Table 2 lists the properties satisfied by the asynchronous membership service. The set of all possible group identifiers is constructed in such a way that they can be totally ordered [8]. <p> pseudocode and proof of correctness for the three-round protocol can be found in <ref> [8] </ref>. 4.1. Properties of the asynchronous service Table 2 lists the properties satisfied by the asynchronous membership service. The set of all possible group identifiers is constructed in such a way that they can be totally ordered [8]. As before, J and D denote the maximum delays to form a new group as a result of nodes becoming connected and disconnected, respectively. <p> Results We found the following flaws in our version of the three-round membership protocol. Our experiments found some errors in the protocol pseudocode in a draft version of <ref> [8] </ref> as well; CESIUM proved a valuable tool for validating the pseudocodes. * When a proposer creates a new group, it waits for accept messages for 2ffi time units until the timeout occurs, or until all the remaining processors have respondedwhatever is earlier.
Reference: [9] <author> S. Dawson, F. Jahanian, T. Mitton, and T. Tung. </author> <title> Testing of fault-tolerant and real-time distributed systems via protocol fault injection. </title> <booktitle> In Proc. of the 26th Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pages 404-14, </pages> <month> June </month> <year> 1996. </year>
Reference-contexts: The most viable approaches test implementations by subjecting them to experiments that include both normal workloads and failures injected into the execution, to test the service's behavior under failure scenarios it is supposed to tolerate <ref> [2, 9, 12, 16] </ref>. <p> In probabilistic approaches that run a large number of random experiments to determine statistical measures (like [2, 15, 17]) it is usually difficult to establish a correspondence between the low-level faults injected and the failures observed at the level of the protocol under test. The Orchestra tool <ref> [9] </ref> inserts an additional layer below the layer under test by reimple-menting the standard socket interface, and can simulate communication failures by filtering and altering the messages that pass through the test layer. <p> Orchestra does not address the problem of coordinating the separate injection agents to coerce the execution into hard-to-reach states, provides no mechanism for testing safety properties, and will in general introduce timing perturbations in the execution. Testing performed on distributed platforms <ref> [9, 11, 16, 17] </ref> is subject to the limitations discussed in Section 3 and 4 for coordination and property testing. Proteus [3] and Tango [14] are centralized simulators of MIMD parallel architectures.
Reference: [10] <author> D. Dolev, J. Halpern, and R. </author> <title> Strong. On the possibility and impossibility of achieving clock synchronization. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 32(2) </volume> <pages> 230-250, </pages> <year> 1986. </year>
Reference-contexts: In general, it is provably impossible to determine the exact interval of real time during which a real distributed system is stable. There are several rea sons for that. First, it is impossible to have perfectly synchronized local clocks in a distributed system <ref> [10] </ref>. Clocks can be externally synchronized within a non-zero deviation D from real time, that depends on the communication uncertainty of the datagram service, the number of nodes, and the interval between successive clock synchronizations. Typical values for D are in the order of several milliseconds.
Reference: [11] <author> K. Echtle and Y. Chen. </author> <title> Evaluation of deterministic fault injection for fault-tolerant protocol testing. </title> <booktitle> In Proc. of the 21rd Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pages 418-25, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: After these errors were fixed, subsequent executions of our experiment sets did not detect any more problems. 5. Related work The Messaline tool [2] uses hardware-level fault injection as an alternative to analytical modeling, to evaluate the dependability and fail-silence properties of the Delta-4 fault-tolerant architecture. Echtle and Chen <ref> [11] </ref> describe heuristics for achieving control path coverage by manipulating the messages exchanged between tasks. A similar approach has been followed by Tao et al [19] to validate software-implemented mechanisms in the Voltan distributed system. <p> Orchestra does not address the problem of coordinating the separate injection agents to coerce the execution into hard-to-reach states, provides no mechanism for testing safety properties, and will in general introduce timing perturbations in the execution. Testing performed on distributed platforms <ref> [9, 11, 16, 17] </ref> is subject to the limitations discussed in Section 3 and 4 for coordination and property testing. Proteus [3] and Tango [14] are centralized simulators of MIMD parallel architectures.
Reference: [12] <author> K. Echtle and M. Leu. </author> <title> Test of fault tolerant distributed systems by fault injection. </title> <booktitle> In Proc. of the IEEE Workshop on Fault-Tolerant Parallel and Distributed Systems, </booktitle> <pages> pages 244-51, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: The most viable approaches test implementations by subjecting them to experiments that include both normal workloads and failures injected into the execution, to test the service's behavior under failure scenarios it is supposed to tolerate <ref> [2, 9, 12, 16] </ref>.
Reference: [13] <author> J. Gait. </author> <title> A probe effect in concurrent programs. </title> <journal> Software-Practice and Experience, </journal> <volume> 16(3) </volume> <pages> 225-33, </pages> <month> Mar. </month> <year> 1986. </year>
Reference-contexts: Related to this is the issue of execution repeatability: if the testing process uncovers a violation of a protocol property, the same execution should be re-run deterministically possibly many times until the software fault is corrected. Finally, intrusiveness (called the probe effect in <ref> [13] </ref>) can invalidate test results: since we are interested in testing timeliness properties such as those found in hard real-time systems, the testing process with its associated instrumentation should not alter the `natural' timing of events during test executions (in particular, code instrumentation should not cause spurious delays, or prevent synchronization-related
Reference: [14] <author> S. Goldschmidt and J. Hennessy. </author> <title> The accuracy of trace-driven simulations of multiprocessors. </title> <booktitle> In Proc. of ACM Sigmetrics Conf. on Measurement and Modeling of Computer Systems, </booktitle> <pages> pages 146-57, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Testing performed on distributed platforms [9, 11, 16, 17] is subject to the limitations discussed in Section 3 and 4 for coordination and property testing. Proteus [3] and Tango <ref> [14] </ref> are centralized simulators of MIMD parallel architectures. Even though they are well suited for debugging and performance evaluation, they cannot simulate the occurrence of any fault, and do not provide support for timely testing of protocol properties.
Reference: [15] <author> K. Goswami and R. Iyer. </author> <title> Simulation of software behavior under hardware faults. </title> <booktitle> In Proc. of the 23rd Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pages 218-27, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: In probabilistic approaches that run a large number of random experiments to determine statistical measures (like <ref> [2, 15, 17] </ref>) it is usually difficult to establish a correspondence between the low-level faults injected and the failures observed at the level of the protocol under test. <p> EDT [4] simulates the execution of specifications written in the Estelle language. Safety properties can be tested, but Estelle's time semantics is not well suited for the evaluation of hard real-time properties as relevant events can be arbitrarily late. Finally, Depend <ref> [15] </ref> simulates the occurrence of hardware faults by executing a user-provided graph representation of the program. 6. Conclusions We described the experimental validation of two group membership protocol implementations. The protocols were tested by executing them under fully controlled conditions in a centralized simulation environment.
Reference: [16] <author> S. Han, K. Shin, and H. Rosenberg. Doctor: </author> <title> An integrated software fault injection environment for distributed real-time systems. </title> <booktitle> In Proc. of the Int'l Computer Performance and Dependability Symp., </booktitle> <pages> pages 204-13, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: The most viable approaches test implementations by subjecting them to experiments that include both normal workloads and failures injected into the execution, to test the service's behavior under failure scenarios it is supposed to tolerate <ref> [2, 9, 12, 16] </ref>. <p> Echtle and Chen [11] describe heuristics for achieving control path coverage by manipulating the messages exchanged between tasks. A similar approach has been followed by Tao et al [19] to validate software-implemented mechanisms in the Voltan distributed system. Fiat [17] and Doctor <ref> [16] </ref> rely on a central process to control fault injection and monitoring agents at each participating node. <p> Orchestra does not address the problem of coordinating the separate injection agents to coerce the execution into hard-to-reach states, provides no mechanism for testing safety properties, and will in general introduce timing perturbations in the execution. Testing performed on distributed platforms <ref> [9, 11, 16, 17] </ref> is subject to the limitations discussed in Section 3 and 4 for coordination and property testing. Proteus [3] and Tango [14] are centralized simulators of MIMD parallel architectures.
Reference: [17] <author> Z. Segall, D. Vrsalovic, D. Siewiorek, D. Yaskin, J. Kow-nacki, J. Barton, R. Dancey, A. Robinson, and T. Lin. FIAT: </author> <title> Fault-injection based automated testing environment. </title> <booktitle> In Proc. of the 18th Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pages 102-7, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: Echtle and Chen [11] describe heuristics for achieving control path coverage by manipulating the messages exchanged between tasks. A similar approach has been followed by Tao et al [19] to validate software-implemented mechanisms in the Voltan distributed system. Fiat <ref> [17] </ref> and Doctor [16] rely on a central process to control fault injection and monitoring agents at each participating node. <p> In probabilistic approaches that run a large number of random experiments to determine statistical measures (like <ref> [2, 15, 17] </ref>) it is usually difficult to establish a correspondence between the low-level faults injected and the failures observed at the level of the protocol under test. <p> Orchestra does not address the problem of coordinating the separate injection agents to coerce the execution into hard-to-reach states, provides no mechanism for testing safety properties, and will in general introduce timing perturbations in the execution. Testing performed on distributed platforms <ref> [9, 11, 16, 17] </ref> is subject to the limitations discussed in Section 3 and 4 for coordination and property testing. Proteus [3] and Tango [14] are centralized simulators of MIMD parallel architectures.
Reference: [18] <author> Sun Microsystems, Inc. </author> <title> The Java Language Specification, V1.0 Beta, </title> <month> Aug. </month> <year> 1996. </year> <note> Available at http:// java.sun.com/ doc/ language specification.html. </note>
Reference-contexts: Figure 1 shows the service hierarchy for this protocol. In general, the tester provides the code for the driver, the protocol under test, and the necessary l-servers. Modules are written in the Java programming language <ref> [18] </ref>, augmented with extensions for multithreaded event-driven programming. The driver runs as a centralized task, thus eliminating the limitations of distributed testing agents. The servers of the protocol under test (s-servers) are distributed among the participating simulated processors; l-servers can be a mix of distributed and centralized implementations.
Reference: [19] <author> S. Tao, P. Ezhilchelvan, and R. Shrivastava. </author> <title> Focused fault injection of software implemented fault tolerance mechanisms of Voltan TMR nodes. </title> <journal> Distributed Systems Engineering, </journal> <volume> 2(1) </volume> <pages> 39-49, </pages> <month> Mar. </month> <year> 1995. </year>
Reference-contexts: Echtle and Chen [11] describe heuristics for achieving control path coverage by manipulating the messages exchanged between tasks. A similar approach has been followed by Tao et al <ref> [19] </ref> to validate software-implemented mechanisms in the Voltan distributed system. Fiat [17] and Doctor [16] rely on a central process to control fault injection and monitoring agents at each participating node.
References-found: 19

