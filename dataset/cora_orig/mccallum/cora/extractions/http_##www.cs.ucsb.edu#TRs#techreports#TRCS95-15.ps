URL: http://www.cs.ucsb.edu/TRs/techreports/TRCS95-15.ps
Refering-URL: http://www.cs.ucsb.edu/TRs/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Generating Oracles from Your Favorite Temporal Specifications  
Author: L.K. Dillon Y.S. Ramakrishna 
Keyword: formal specification and validation methods, specification-based test oracles, trace checking, tableau methods, temporal logic, interval logic, concurrent systems  
Address: Santa Barbara  Bombay  
Affiliation: Computer Science Department University of California  Computer Science Group T.I.F.R.  
Abstract: The paper describes a generic tableau algorithm, which is the basis for a general customizable method for producing oracles from temporal logic specifications. A generic argument gives semantic rules with which to build the semantic tableau for a specification. Parameterizing the tableau algorithm by semantic rules permits it to easily accommodate a variety of temporal operators and provides a clean mechanism for fine-tuning the algorithm to produce efficient oracles. The paper develops conditions that ensure a set of rules results in a correct tableau procedure. It gives sample rules for a variety of linear-time temporal operators and shows how rules are tailored to reduce the size of an oracle. To illustrate the versatility of this method, its application to a high level interval logic is discussed. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Blum and H. Wasserman. </author> <title> Program result-checking: A theory of testing meets a test of theory. </title> <booktitle> In Proc. IEEE Symp. Foundations of Computer Science, </booktitle> <year> 1994. </year>
Reference-contexts: Such oracles are needed during system testing to uncover temporal faults in test executions [15]. Proactive debuggers and run time monitors can use temporal oracles to detect faults, and notify the user when they occur [8,10]. If efficient, temporal oracles can also be incorporated into robust self-checking programs <ref> [1] </ref>. Methods for checking that traces conform to temporal specifications are usually designed for specific notations [2, 7, 12]. Details of the methods are motivated by the specific semantics of the operators provided for expressing specifications. <p> (S; i; flp) = &gt; &gt; &gt; &gt; &gt; &gt; &lt; ? if i = jSj and fl is . i if S (i) j= p and is null loc (S; i; ) if S (i) j= p and is non null loc (S; i + 1; flp) otherwise 16 <ref> [1] </ref> If ! hf I 0 f gi where either I is [[[flp 1 jjj 2 ))) and I 0 is [[[ 1 jjj 2 ))), I is [[[flpjjj 2 ))) and I 0 is [[[jjj 2 ))) or I is [[[jjjflp 2 ))) and I 0 is [[[jjj 2 )))
Reference: [2] <author> G. V. Bochmann, R. Dssouli, and J. R. Zhao. </author> <title> Trace analysis for conformance and arbitration testing. </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> 15(11) </volume> <pages> 1347-1355, </pages> <month> November </month> <year> 1989. </year> <month> 20 </month>
Reference-contexts: Proactive debuggers and run time monitors can use temporal oracles to detect faults, and notify the user when they occur [8,10]. If efficient, temporal oracles can also be incorporated into robust self-checking programs [1]. Methods for checking that traces conform to temporal specifications are usually designed for specific notations <ref> [2, 7, 12] </ref>. Details of the methods are motivated by the specific semantics of the operators provided for expressing specifications. This makes it difficult to adapt the method for use with additional operators or different notations. <p> If ! hf I 0 f gi where either I is [[[flp 1 jjj 2 ))) and I 0 is [[[ 1 jjj 2 ))), I is [[[flpjjj 2 ))) and I 0 is [[[jjj 2 ))) or I is [[[jjjflp 2 ))) and I 0 is [[[jjj 2 ))) <ref> [2] </ref> [[[flpjjj.)))f p [3] [jflp)f p [4] [[jjflp))f p ! hf false gi [5] If ! hf If gi where I is [[[flp 1 jjj 2 ))) [Ap] If true ! hf p; If g; f :p; If gi where I is [[[flp 1 jjj 2 ))) or [[[jjjflp 2 )))
Reference: [3] <author> L. K. Dillon, G. Kutty, L. E. Moser, P. M. Melliar-Smith, and Y. S. Ramakrishna. </author> <title> A graphical interval logic for specifying concurrent systems. </title> <journal> ACM Trans. Software Engineering and Methodology, </journal> <volume> 3(2) </volume> <pages> 131-165, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: I 0 f gi where either I is [[[flp 1 jjj 2 ))) and I 0 is [[[ 1 jjj 2 ))), I is [[[flpjjj 2 ))) and I 0 is [[[jjj 2 ))) or I is [[[jjjflp 2 ))) and I 0 is [[[jjj 2 ))) [2] [[[flpjjj.)))f p <ref> [3] </ref> [jflp)f p [4] [[jjflp))f p ! hf false gi [5] If ! hf If gi where I is [[[flp 1 jjj 2 ))) [Ap] If true ! hf p; If g; f :p; If gi where I is [[[flp 1 jjj 2 ))) or [[[jjjflp 2 ))) [Iq] Iq ! <p> When a trace violates a specification, the oracle can provide feedback regarding the fault that was detected, as described in [4]. The tableau method described above is the basis for an oracle synthesizer that we are developing for use with specifications expressed in Graphical Interval Logic (GIL) <ref> [3] </ref>. The GIL oracle 18 synthesizer will permit us to experiment with heuristics for determining an elaboration order for sets of formulas and with different reduction and replacement rules.
Reference: [4] <author> L. K. Dillon and Q. Yu. </author> <title> Oracles for checking temporal properties of concurrent systems. </title> <booktitle> In Proc. 2nd ACM SIGSOFT Symp. Foundations of Software Engineering, </booktitle> <pages> pp. 140-153, </pages> <address> New Orleans, </address> <month> December </month> <year> 1994. </year> <note> ACM Press. </note>
Reference-contexts: A much smaller tableau can often be built directly from a high level specification using rules that express the semantics of the high level operators. Moreover, the direct approach makes it easier to provide the user with meaningful feedback about faults that are detected in system executions <ref> [4] </ref>. When constructing a tableau for use in validating execution traces, the size of the tableau is more critical than the time required to build it. The tableau is built once, but it is used repeatedly during testing and debugging to validate (typically, very long) execution traces. <p> gi where either I is [[[flp 1 jjj 2 ))) and I 0 is [[[ 1 jjj 2 ))), I is [[[flpjjj 2 ))) and I 0 is [[[jjj 2 ))) or I is [[[jjjflp 2 ))) and I 0 is [[[jjj 2 ))) [2] [[[flpjjj.)))f p [3] [jflp)f p <ref> [4] </ref> [[jjflp))f p ! hf false gi [5] If ! hf If gi where I is [[[flp 1 jjj 2 ))) [Ap] If true ! hf p; If g; f :p; If gi where I is [[[flp 1 jjj 2 ))) or [[[jjjflp 2 ))) [Iq] Iq ! hf q; I <p> They can therefore support run time monitoring and debugging, in addition to post execution checking of logged traces. When a trace violates a specification, the oracle can provide feedback regarding the fault that was detected, as described in <ref> [4] </ref>. The tableau method described above is the basis for an oracle synthesizer that we are developing for use with specifications expressed in Graphical Interval Logic (GIL) [3].
Reference: [5] <author> E. A. Emerson and J. Y. Halpern. </author> <title> Decision procedures and expressiveness in the temporal logic of branching time. </title> <booktitle> In Proc. 14th Symp. Theory of Computing, </booktitle> <pages> pp. 169-180, </pages> <address> San Francisco, </address> <month> May </month> <year> 1982. </year>
Reference-contexts: Finally, conclusions and on-going research are presented. 2 Tableau Decision Procedures Tableau procedures were invented for deciding the validity of logical formulas. Tableau decision procedures for linear time temporal logics are discussed in [18]; similar procedures for branching time temporal logics are presented in <ref> [5] </ref>; and a tableau decision procedure for the interval temporal logic of [16] appears in [13]. Differences between these procedures and the tableau procedures discussed below are motivated by demands of the different applications. <p> jjj 2 ))) and I 0 is [[[ 1 jjj 2 ))), I is [[[flpjjj 2 ))) and I 0 is [[[jjj 2 ))) or I is [[[jjjflp 2 ))) and I 0 is [[[jjj 2 ))) [2] [[[flpjjj.)))f p [3] [jflp)f p [4] [[jjflp))f p ! hf false gi <ref> [5] </ref> If ! hf If gi where I is [[[flp 1 jjj 2 ))) [Ap] If true ! hf p; If g; f :p; If gi where I is [[[flp 1 jjj 2 ))) or [[[jjjflp 2 ))) [Iq] Iq ! hf q; I w true g; f N I s
Reference: [6] <author> E. A. Emerson and A. P. Sistla. </author> <title> Deciding branching time logic. </title> <booktitle> In Proc. 16th Symp. Theory of Computing, </booktitle> <pages> pp. 14-24, </pages> <address> Washington, </address> <month> May </month> <year> 1984. </year>
Reference-contexts: The tableau decision procedure for linear time propositional temporal logic (PTL) requires time and space exponential in the length of the input formula [17], while the decision problem for the branching time temporal logic CTL fl is EXPTIME <ref> [6] </ref>. Individual specifications for a system and formulas expressing properties that require verification tend to be short and concise. However, complex systems generally require large numbers of specifications.
Reference: [7] <author> C. Ghezzi, D. Mandrioli, and A. Morzenti. </author> <title> TRIO, a logic language for executable specifications of real-time systems. </title> <journal> Journal of Systems and Software, </journal> <volume> 12(2) </volume> <pages> 107-123, </pages> <month> February </month> <year> 1990. </year>
Reference-contexts: Proactive debuggers and run time monitors can use temporal oracles to detect faults, and notify the user when they occur [8,10]. If efficient, temporal oracles can also be incorporated into robust self-checking programs [1]. Methods for checking that traces conform to temporal specifications are usually designed for specific notations <ref> [2, 7, 12] </ref>. Details of the methods are motivated by the specific semantics of the operators provided for expressing specifications. This makes it difficult to adapt the method for use with additional operators or different notations.
Reference: [8] <author> V. J. Griswold. </author> <title> Core algorithms for autonomous monitoring of distributed systems. </title> <booktitle> In Proc. ACM/ONR Work. Parallel and Distributed Debugging, </booktitle> <pages> pp. 23-34, </pages> <month> May </month> <year> 1991. </year>
Reference: [9] <author> D. Harel. Statecharts: </author> <title> A visual formalism for complex systems. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8(3) </volume> <pages> 231-274, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: This method does not support run time checking of execution traces and does not scale for use with long traces. A method for directly translating GIL into a hierarchical finite state machine (HFSM) formalism resembling Statecharts <ref> [9] </ref> is described in [12]. The HFSMs are designed for expressing the semantics of GIL and the translation is specific to GIL. It is not known if this method generalizes for use with other temporal notations.
Reference: [10] <author> P. K. Harter, D. M. Heimbigner, and R. King. IDD: </author> <title> An interactive distributed debugger. </title> <booktitle> In IEEE Inter. Conf. Distributed Computer Systems, </booktitle> <pages> pp. 498-506, </pages> <year> 1985. </year>
Reference: [11] <author> O. Lichtenstein, A. Pnueli, and L. Zuck. </author> <title> The glory of the past. </title> <booktitle> In Proc. Conf. Logics of Programs, </booktitle> <pages> pp. 196-218. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year> <note> LNCS 193. </note>
Reference-contexts: The treatment in this paper is quite natural when a logic provides only "future" temporal operators. However, it is not immediately evident how to express the semantics of "past" operators <ref> [11] </ref> in rules that are valid by definition (4.5). We are therefore currently investigating a modified tableau method for linear time logics with "past" operators. This method constructs a flow graph in a manner symmetric to that described above.
Reference: [12] <author> T. O. O'Malley, D. J. Richardson, and L. K. Dillon. </author> <title> Efficient Specification-based Oracles for Critical Systems. </title> <note> Submitted, </note> <month> August </month> <year> 1995. </year>
Reference-contexts: Proactive debuggers and run time monitors can use temporal oracles to detect faults, and notify the user when they occur [8,10]. If efficient, temporal oracles can also be incorporated into robust self-checking programs [1]. Methods for checking that traces conform to temporal specifications are usually designed for specific notations <ref> [2, 7, 12] </ref>. Details of the methods are motivated by the specific semantics of the operators provided for expressing specifications. This makes it difficult to adapt the method for use with additional operators or different notations. <p> This method does not support run time checking of execution traces and does not scale for use with long traces. A method for directly translating GIL into a hierarchical finite state machine (HFSM) formalism resembling Statecharts [9] is described in <ref> [12] </ref>. The HFSMs are designed for expressing the semantics of GIL and the translation is specific to GIL. It is not known if this method generalizes for use with other temporal notations.
Reference: [13] <author> D. Plaisted. </author> <title> A low level language for obtaining decision procedures for classes of temporal logics. In An Interval Logic for Higher Level Temporal Reasoning, </title> <publisher> LNCS 164, </publisher> <pages> pp. 403-420. </pages> <publisher> Springer-Verlag, </publisher> <year> 1983. </year>
Reference-contexts: Tableau decision procedures for linear time temporal logics are discussed in [18]; similar procedures for branching time temporal logics are presented in [5]; and a tableau decision procedure for the interval temporal logic of [16] appears in <ref> [13] </ref>. Differences between these procedures and the tableau procedures discussed below are motivated by demands of the different applications. Tableau decision procedures are intended for proving properties of concurrent systems, while we use a tableau to validate system executions.
Reference: [14] <author> D. J. Richardson. TAOS: </author> <title> Testing with analysis and oracle support. </title> <booktitle> In Proc. Inter. Symp. Software Testing and Analysis, </booktitle> <pages> pp. 138-153, </pages> <address> Seattle, WA, </address> <month> August </month> <year> 1994. </year>
Reference-contexts: It will permit us to compare the efficiency of the oracles generated by this method with GIL-based oracles generated by other methods. The straightforward method in <ref> [14] </ref> scans a trace to locate intervals and then recursively evaluates formulas within the intervals. This method does not support run time checking of execution traces and does not scale for use with long traces.
Reference: [15] <author> D. J. Richardson, S. L. Aha, and T. O. O'Malley. </author> <title> Specification-based test oracles for reactive systems. </title> <booktitle> In Proc. 14th Inter. Conf. Software Engineering, </booktitle> <pages> pp. 105-118, </pages> <address> Melbourne, AUS, </address> <month> May </month> <year> 1992. </year>
Reference-contexts: Oracles produced from these specifications can verify that traces generated by executing a system conform to the specifications. Such oracles are needed during system testing to uncover temporal faults in test executions <ref> [15] </ref>. Proactive debuggers and run time monitors can use temporal oracles to detect faults, and notify the user when they occur [8,10]. If efficient, temporal oracles can also be incorporated into robust self-checking programs [1].
Reference: [16] <author> R. L. Schwartz, P. M. Melliar-Smith, and F. H. Vogt. </author> <title> An interval logic for higher-level temporal reasoning. </title> <booktitle> In Proc. 2nd ACM Symp. Principles of Distributed Computing, </booktitle> <pages> pp. 173-186, </pages> <address> Montreal, Canada, </address> <month> August </month> <year> 1983. </year>
Reference-contexts: Tableau decision procedures for linear time temporal logics are discussed in [18]; similar procedures for branching time temporal logics are presented in [5]; and a tableau decision procedure for the interval temporal logic of <ref> [16] </ref> appears in [13]. Differences between these procedures and the tableau procedures discussed below are motivated by demands of the different applications. Tableau decision procedures are intended for proving properties of concurrent systems, while we use a tableau to validate system executions.
Reference: [17] <author> A. P. Sistla and E. M. Clarke. </author> <title> The complexity of propositional linear time temporal logic. </title> <booktitle> In Proc. 14th ACM Symp. Theory of Computing, </booktitle> <pages> pp. 159-168, </pages> <address> San Francisco, </address> <month> May </month> <year> 1982. </year>
Reference-contexts: The practicality of verification is severely limited by problems of scaling decision procedures for use with large formulas. The tableau decision procedure for linear time propositional temporal logic (PTL) requires time and space exponential in the length of the input formula <ref> [17] </ref>, while the decision problem for the branching time temporal logic CTL fl is EXPTIME [6]. Individual specifications for a system and formulas expressing properties that require verification tend to be short and concise. However, complex systems generally require large numbers of specifications.
Reference: [18] <author> P. Wolper. </author> <title> The tableau method for temporal logic: An overview. In Logique et Analyse, </title> <address> Novelle Serie 28 e Annee, </address> <note> 110-111 Numero Special (Automated Reasoning in Non-Classical Logic), pp. 119-136, June-September 1985. 21 </note>
Reference-contexts: Finally, conclusions and on-going research are presented. 2 Tableau Decision Procedures Tableau procedures were invented for deciding the validity of logical formulas. Tableau decision procedures for linear time temporal logics are discussed in <ref> [18] </ref>; similar procedures for branching time temporal logics are presented in [5]; and a tableau decision procedure for the interval temporal logic of [16] appears in [13]. Differences between these procedures and the tableau procedures discussed below are motivated by demands of the different applications. <p> The semantic tableau for a formula is a directed graph in which nodes are labeled with sets of formulas <ref> [18] </ref>. We find it useful to represent the tableau for a formula as a bipartite graph, called a flow graph, in a manner that accords equal status to transitions and locations (nodes of a finite state automaton).
References-found: 18

