URL: http://www.cs.ucsb.edu/~schauser/courses/cs595i/papers/cc++-description.ps
Refering-URL: http://www.cs.ucsb.edu/~schauser/courses/cs595i/
Root-URL: http://www.cs.ucsb.edu
Title: CC A Declarative Concurrent Object Oriented Programming Notation Abstract CC is Compositional C a parallel
Author: K. Mani Chandy Carl Kesselman 
Note: C is provided.  
Date: September 18, 1992  
Affiliation: California Institute of Technology  
Abstract: This paper is a brief description of the motivation for CC ++ , the extensions to C ++ , a few examples of CC ++ programs with reasoning about their correctness, and an evaluation of CC ++ in the context of other research on concurrent computation. A short description of 
Abstract-found: 1
Intro-found: 1
Reference: [Ack82] <author> William B. Ackerman. </author> <title> Data flow languages. </title> <journal> Computer, </journal> <volume> 15(2) </volume> <pages> 15-25, </pages> <month> feb </month> <year> 1982. </year>
Reference-contexts: The design of CC ++ draws ideas from a wide range of parallel programming languages. These include data flow languages with single-assignment variables <ref> [TE68, Ack82] </ref>, remote procedure calls [TA90], message passing [Sei91], actors [Agh86], concurrent logic programming [FT90, Ued86, Sha86] and compositional languages, particularly PCN [CT91]. <p> In particular, the assignment x = y suspends until y has a value; variable-to-variable assignments are not made. Consequently, structured sync data behaves more like an I-Structure [AT80] from the dataflow language Id <ref> [Ack82] </ref> than a tuple from a logic programming language. The use of single assignment variables in place of logical variables has the advantages that assignment semantics are completely consistent with C ++ , and that pointer dereferencing is not required prior to variable use.
Reference: [Agh86] <author> Gul Agha. </author> <title> ACTORS: A Model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: The design of CC ++ draws ideas from a wide range of parallel programming languages. These include data flow languages with single-assignment variables [TE68, Ack82], remote procedure calls [TA90], message passing [Sei91], actors <ref> [Agh86] </ref>, concurrent logic programming [FT90, Ued86, Sha86] and compositional languages, particularly PCN [CT91]. In this section, we discuss how significant aspects of CC ++ relate to other parallel programming notations. 40 Parallel composition as defined by par blocks can be found in a number of other parallel programming notations. <p> The use of par blocks differs from most other concurrent object-oriented languages in that with a par block, multiple threads of control exist within a single object. Other languages tend to associate thread creation with object creation <ref> [BLL88, Gri91, SS87, Agh86] </ref>. Consequently, only one thread of control is ever associated with an object. The spawn statement in CC ++ can be used to achieve the same effect. The advantage of par blocks and parfor statements over the tying thread creation to object creation approach is twofold. <p> In addition, sync variables differ from variables in programming languages such as Strand [FT89] and PCN [CT91] in that the blocking rule for sync variables prohibits the use of variable-to-variable assignment found in these languages. Many concurrent object-oriented languages <ref> [Agh86, AS88, WHD89] </ref> use function call as the basis for communication. In actor based languages, a function call is interpreted as sending a message to the target object to perform the requested operation. The arguments in the function call are 41 passed to the target object as well.
Reference: [AS88] <author> William C. Athas and C.L. Seitz. </author> <title> Multicomputers: Message-passing concurrent computers. </title> <booktitle> IEEE Computer, </booktitle> <month> aug </month> <year> 1988. </year>
Reference-contexts: In addition, sync variables differ from variables in programming languages such as Strand [FT89] and PCN [CT91] in that the blocking rule for sync variables prohibits the use of variable-to-variable assignment found in these languages. Many concurrent object-oriented languages <ref> [Agh86, AS88, WHD89] </ref> use function call as the basis for communication. In actor based languages, a function call is interpreted as sending a message to the target object to perform the requested operation. The arguments in the function call are 41 passed to the target object as well.
Reference: [AT80] <author> Arvind and R.E. Thomas. I-Structures: </author> <title> An efficient data structure for functional languages. </title> <type> Technical Report TM-178, </type> <institution> MIT, </institution> <year> 1980. </year>
Reference-contexts: No doubt, some readers will have recognized sync variables as being single assignment variables from dataflow languages [M + 85] or from languages based in concurrent logic programming [FT89]. A reference to a structure which contains sync objects behaves much like an I-Structure in the dataflow language ID <ref> [AT80] </ref>. sync variables differ in that the sync attribute can be extended to abstract and concrete data types as definable in C ++ . <p> In particular, the assignment x = y suspends until y has a value; variable-to-variable assignments are not made. Consequently, structured sync data behaves more like an I-Structure <ref> [AT80] </ref> from the dataflow language Id [Ack82] than a tuple from a logic programming language. The use of single assignment variables in place of logical variables has the advantages that assignment semantics are completely consistent with C ++ , and that pointer dereferencing is not required prior to variable use.
Reference: [BLL88] <author> Brian Bershad, Edward Lazowska, and Henry Levy. </author> <title> Presto: A system of object-oriented parallel programming. </title> <journal> Software: Practice and Experience, </journal> <volume> 18(8) </volume> <pages> 713-732, </pages> <month> aug </month> <year> 1988. </year>
Reference-contexts: Multiple threads of control are provided by any lightweight process library; an existing C ++ thread package such as <ref> [BLL88, SS87] </ref> could also be used. <p> The use of par blocks differs from most other concurrent object-oriented languages in that with a par block, multiple threads of control exist within a single object. Other languages tend to associate thread creation with object creation <ref> [BLL88, Gri91, SS87, Agh86] </ref>. Consequently, only one thread of control is ever associated with an object. The spawn statement in CC ++ can be used to achieve the same effect. The advantage of par blocks and parfor statements over the tying thread creation to object creation approach is twofold.
Reference: [CM88] <author> K. Mani Chandy and Jayadev Misra. </author> <title> Parallel Program Design. </title> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference: [CT91] <author> K. Mani Chandy and Stephen Taylor. </author> <title> An Introduction to Parallel Programming. </title> <editor> Bartlett and Jones, </editor> <year> 1991. </year>
Reference-contexts: The design of CC ++ draws ideas from a wide range of parallel programming languages. These include data flow languages with single-assignment variables [TE68, Ack82], remote procedure calls [TA90], message passing [Sei91], actors [Agh86], concurrent logic programming [FT90, Ued86, Sha86] and compositional languages, particularly PCN <ref> [CT91] </ref>. In this section, we discuss how significant aspects of CC ++ relate to other parallel programming notations. 40 Parallel composition as defined by par blocks can be found in a number of other parallel programming notations. <p> For example, a par is equivalent to the use of cobegin and coend in [OG76] and the parallel composition operator in PCN <ref> [CT91] </ref>. The use of par blocks differs from most other concurrent object-oriented languages in that with a par block, multiple threads of control exist within a single object. Other languages tend to associate thread creation with object creation [BLL88, Gri91, SS87, Agh86]. <p> In addition, sync variables differ from variables in programming languages such as Strand [FT89] and PCN <ref> [CT91] </ref> in that the blocking rule for sync variables prohibits the use of variable-to-variable assignment found in these languages. Many concurrent object-oriented languages [Agh86, AS88, WHD89] use function call as the basis for communication. <p> It is important to recognize that a sync variable in CC ++ is a pure single assignment variable and not a logical variable as found in concurrent logic programming languages such as Strand [FT90], FCP [Sha86], GHC [Ued86] or Parlog [Gre87] or compositional languages such as PCN <ref> [CT91] </ref>. In particular, the assignment x = y suspends until y has a value; variable-to-variable assignments are not made. Consequently, structured sync data behaves more like an I-Structure [AT80] from the dataflow language Id [Ack82] than a tuple from a logic programming language. <p> The disadvantage is that some concurrent logic programming techniques, such as the short circuit technique [Tak89] become sequentialized. This is not a significant drawback, however, because termination of parallel blocks is easily determined. CC ++ has many ideas in common with the parallel programming language PCN <ref> [CT91] </ref> which in turn draws heavily from committed choice concurrent logic programming languages such as Strand [FT90]. There are, however, fundamental differences between them. These include: * CC ++ provides a general shared-memory programming model.
Reference: [Fos91] <author> Ian Foster. </author> <title> Program transformation notation: A tutorial. </title> <type> Technical Report ANL-91/38, </type> <institution> Argonne National Laboratory, </institution> <year> 1991. </year>
Reference: [Fos92] <author> Ian Foster. </author> <title> Information hiding in parallel programs. </title> <type> Technical Report MCS-P290-0292, </type> <institution> Argonne National Laboratory, </institution> <year> 1992. </year>
Reference-contexts: Note that the -&gt; operator can be overloaded, eliminating the need for an application program to ever refer directly to a processor object. This provides a flexible, user-defined scheme for addressing logical processors (for examples, see <ref> [Fos92] </ref>).
Reference: [FT89] <author> Ian Foster and Stephen Taylor. STRAND: </author> <title> New Concepts in Parallel Programming. </title> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: Thus one has no choice but to resort to a temporal operator such as the leads-to operator. No doubt, some readers will have recognized sync variables as being single assignment variables from dataflow languages [M + 85] or from languages based in concurrent logic programming <ref> [FT89] </ref>. A reference to a structure which contains sync objects behaves much like an I-Structure in the dataflow language ID [AT80]. sync variables differ in that the sync attribute can be extended to abstract and concrete data types as definable in C ++ . <p> In addition, sync variables differ from variables in programming languages such as Strand <ref> [FT89] </ref> and PCN [CT91] in that the blocking rule for sync variables prohibits the use of variable-to-variable assignment found in these languages. Many concurrent object-oriented languages [Agh86, AS88, WHD89] use function call as the basis for communication.
Reference: [FT90] <author> Ian Foster and Stephen Taylor. Strand: </author> <title> New Concepts in Parallel Programming. </title> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: The design of CC ++ draws ideas from a wide range of parallel programming languages. These include data flow languages with single-assignment variables [TE68, Ack82], remote procedure calls [TA90], message passing [Sei91], actors [Agh86], concurrent logic programming <ref> [FT90, Ued86, Sha86] </ref> and compositional languages, particularly PCN [CT91]. In this section, we discuss how significant aspects of CC ++ relate to other parallel programming notations. 40 Parallel composition as defined by par blocks can be found in a number of other parallel programming notations. <p> It is important to recognize that a sync variable in CC ++ is a pure single assignment variable and not a logical variable as found in concurrent logic programming languages such as Strand <ref> [FT90] </ref>, FCP [Sha86], GHC [Ued86] or Parlog [Gre87] or compositional languages such as PCN [CT91]. In particular, the assignment x = y suspends until y has a value; variable-to-variable assignments are not made. <p> This is not a significant drawback, however, because termination of parallel blocks is easily determined. CC ++ has many ideas in common with the parallel programming language PCN [CT91] which in turn draws heavily from committed choice concurrent logic programming languages such as Strand <ref> [FT90] </ref>. There are, however, fundamental differences between them. These include: * CC ++ provides a general shared-memory programming model. This includes having pointers to data objects anywhere in distributed mem ory. * CC ++ is a tiny extension to an object-oriented language whereas PCN is a new language.
Reference: [FT92] <author> Ian Foster and Steve Tuecke. </author> <title> Parallel programming with PCN. </title> <type> Technical Report ANL-91/32, </type> <institution> Argonne National Laboratory, </institution> <year> 1992. </year>
Reference: [Gre87] <author> Steve Gregory. </author> <title> Parallel Logic Programming in PARLOG. </title> <booktitle> International Series in Logic Programming. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1987. </year> <month> 44 </month>
Reference-contexts: It is important to recognize that a sync variable in CC ++ is a pure single assignment variable and not a logical variable as found in concurrent logic programming languages such as Strand [FT90], FCP [Sha86], GHC [Ued86] or Parlog <ref> [Gre87] </ref> or compositional languages such as PCN [CT91]. In particular, the assignment x = y suspends until y has a value; variable-to-variable assignments are not made. Consequently, structured sync data behaves more like an I-Structure [AT80] from the dataflow language Id [Ack82] than a tuple from a logic programming language.
Reference: [Gri91] <author> Andrew S. Grimshaw. </author> <title> An introduction to parallel object-oriented programming with Mentat. </title> <institution> Computer Science Report TR-91-07, University of Virginia, </institution> <year> 1991. </year>
Reference-contexts: The use of par blocks differs from most other concurrent object-oriented languages in that with a par block, multiple threads of control exist within a single object. Other languages tend to associate thread creation with object creation <ref> [BLL88, Gri91, SS87, Agh86] </ref>. Consequently, only one thread of control is ever associated with an object. The spawn statement in CC ++ can be used to achieve the same effect. The advantage of par blocks and parfor statements over the tying thread creation to object creation approach is twofold.
Reference: [Hoa74] <author> C.A.R Hoare. </author> <title> Monitors: An operating system structuring concept. </title> <journal> cacm, </journal> <volume> 17(10) </volume> <pages> 549-557, </pages> <month> oct </month> <year> 1974. </year>
Reference: [Hou92] <author> C. Houck. </author> <title> Run-time system support for distributed actor programs. </title> <type> Master's thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <year> 1992. </year>
Reference: [LS89] <author> Kai Li and Richard Schaefer. </author> <title> A hypercube shared virtual memory system. </title> <booktitle> In Proceedings of the 1989 International Conference on Parallel Processing, </booktitle> <pages> pages 125-132, </pages> <month> aug </month> <year> 1989. </year>
Reference-contexts: On such machines, the CC ++ implementation maps global references into regular references. However, many scalable parallel architectures do not directly support shared address spaces. While operating systems can support a global address space with page level sharing <ref> [LS89] </ref>, finer resolutions are required for CC ++ . On machines that don't provide a global address space, global pointers must be implemented in software. A global pointer is represented by an identifier for the address space being pointed into and the address within 39 that address space.
Reference: [M + 85] <author> J. McGraw et al. </author> <title> SISAL: Streams and iteration in a single assignment language, language reference manual, version 1.2. </title> <type> Technical Report M-146, </type> <institution> LLNL, </institution> <month> mar </month> <year> 1985. </year>
Reference-contexts: Thus one has no choice but to resort to a temporal operator such as the leads-to operator. No doubt, some readers will have recognized sync variables as being single assignment variables from dataflow languages <ref> [M + 85] </ref> or from languages based in concurrent logic programming [FT89].
Reference: [Mey88] <author> Bertrand Meyer. </author> <title> Object-oriented Software Construction. </title> <publisher> Prentice Hall International, </publisher> <year> 1988. </year>
Reference: [OG76] <author> S. Owicki and D. Gries. </author> <title> An axiomatic proof technique for parallel programs I. </title> <journal> Acta Informatica, </journal> <volume> 6(1) </volume> <pages> 319-340, </pages> <year> 1976. </year>
Reference-contexts: For example, a par is equivalent to the use of cobegin and coend in <ref> [OG76] </ref> and the parallel composition operator in PCN [CT91]. The use of par blocks differs from most other concurrent object-oriented languages in that with a par block, multiple threads of control exist within a single object. Other languages tend to associate thread creation with object creation [BLL88, Gri91, SS87, Agh86].
Reference: [PBH77] <author> Per Brinch Hansen. </author> <title> The Architecture of Concurrent Programs. </title> <publisher> Prentice-Hall, </publisher> <year> 1977. </year>
Reference: [Sei91] <author> Charles Seitz. </author> <title> Developments in Concurrency and Communication, </title> <booktitle> chapter 5, </booktitle> <pages> pages 131-200. </pages> <publisher> Addison Wesley, </publisher> <year> 1991. </year>
Reference-contexts: The design of CC ++ draws ideas from a wide range of parallel programming languages. These include data flow languages with single-assignment variables [TE68, Ack82], remote procedure calls [TA90], message passing <ref> [Sei91] </ref>, actors [Agh86], concurrent logic programming [FT90, Ued86, Sha86] and compositional languages, particularly PCN [CT91].
Reference: [Sha86] <author> Ehud Shapiro. </author> <title> Concurrent Prolog: A program report. </title> <journal> IEEE Computer, </journal> <volume> 19(8) </volume> <pages> 44-58, </pages> <month> aug </month> <year> 1986. </year>
Reference-contexts: The design of CC ++ draws ideas from a wide range of parallel programming languages. These include data flow languages with single-assignment variables [TE68, Ack82], remote procedure calls [TA90], message passing [Sei91], actors [Agh86], concurrent logic programming <ref> [FT90, Ued86, Sha86] </ref> and compositional languages, particularly PCN [CT91]. In this section, we discuss how significant aspects of CC ++ relate to other parallel programming notations. 40 Parallel composition as defined by par blocks can be found in a number of other parallel programming notations. <p> It is important to recognize that a sync variable in CC ++ is a pure single assignment variable and not a logical variable as found in concurrent logic programming languages such as Strand [FT90], FCP <ref> [Sha86] </ref>, GHC [Ued86] or Parlog [Gre87] or compositional languages such as PCN [CT91]. In particular, the assignment x = y suspends until y has a value; variable-to-variable assignments are not made.
Reference: [SS87] <author> Bjarne Stroustrup and Jonathan Shopiro. </author> <title> A set of C ++ classes for co-routine style programming. </title> <booktitle> In Proceedings of the USENIX C ++ Workshop, </booktitle> <month> nov </month> <year> 1987. </year>
Reference-contexts: Multiple threads of control are provided by any lightweight process library; an existing C ++ thread package such as <ref> [BLL88, SS87] </ref> could also be used. <p> The use of par blocks differs from most other concurrent object-oriented languages in that with a par block, multiple threads of control exist within a single object. Other languages tend to associate thread creation with object creation <ref> [BLL88, Gri91, SS87, Agh86] </ref>. Consequently, only one thread of control is ever associated with an object. The spawn statement in CC ++ can be used to achieve the same effect. The advantage of par blocks and parfor statements over the tying thread creation to object creation approach is twofold.
Reference: [TA90] <author> B. H. Tay and A. L. Ananda. </author> <title> A survey of remote procedure calls. </title> <journal> ACM Operating Systems Review, </journal> <volume> 24(3), </volume> <month> jul </month> <year> 1990. </year> <month> 45 </month>
Reference-contexts: The design of CC ++ draws ideas from a wide range of parallel programming languages. These include data flow languages with single-assignment variables [TE68, Ack82], remote procedure calls <ref> [TA90] </ref>, message passing [Sei91], actors [Agh86], concurrent logic programming [FT90, Ued86, Sha86] and compositional languages, particularly PCN [CT91].
Reference: [Tak89] <author> Akikazu Takeuchi. </author> <title> How to solve it in Concurrent Prolog. Unpub--lished note., </title> <year> 1989. </year>
Reference-contexts: The disadvantage is that some concurrent logic programming techniques, such as the short circuit technique <ref> [Tak89] </ref> become sequentialized. This is not a significant drawback, however, because termination of parallel blocks is easily determined. CC ++ has many ideas in common with the parallel programming language PCN [CT91] which in turn draws heavily from committed choice concurrent logic programming languages such as Strand [FT90].
Reference: [TE68] <author> L. Tesler and H. Enea. </author> <title> A language for concurrent processes. </title> <booktitle> In Proceedings of AFIPS SJCC, number ANL-91/38, </booktitle> <year> 1968. </year>
Reference-contexts: The design of CC ++ draws ideas from a wide range of parallel programming languages. These include data flow languages with single-assignment variables <ref> [TE68, Ack82] </ref>, remote procedure calls [TA90], message passing [Sei91], actors [Agh86], concurrent logic programming [FT90, Ued86, Sha86] and compositional languages, particularly PCN [CT91].
Reference: [Tie91] <author> Michael D. Tiemann. </author> <title> User's Guide to GNU C ++ . Free Software Foundation, </title> <publisher> Inc., </publisher> <month> oct </month> <year> 1991. </year>
Reference-contexts: The parse tree is then modified, converting it into a C ++ parse tree and then written out in textual form. The CC ++ parser is a modified version of the GNU C ++ (G ++ ) <ref> [Tie91] </ref> parser. There are some minor syntactic limitations on the C ++ accepted by G ++ and the current CC ++ implementation inherits these. The hardest part of the transformation process is to ensure that the semantic restrictions outlined in Section 4 are checked as carefully as possible.
Reference: [Ued86] <author> Kazunori Ueda. </author> <title> Guarded horn clauses. </title> <booktitle> In Logic Programming '85, </booktitle> <pages> pages 168-179. </pages> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference-contexts: The design of CC ++ draws ideas from a wide range of parallel programming languages. These include data flow languages with single-assignment variables [TE68, Ack82], remote procedure calls [TA90], message passing [Sei91], actors [Agh86], concurrent logic programming <ref> [FT90, Ued86, Sha86] </ref> and compositional languages, particularly PCN [CT91]. In this section, we discuss how significant aspects of CC ++ relate to other parallel programming notations. 40 Parallel composition as defined by par blocks can be found in a number of other parallel programming notations. <p> It is important to recognize that a sync variable in CC ++ is a pure single assignment variable and not a logical variable as found in concurrent logic programming languages such as Strand [FT90], FCP [Sha86], GHC <ref> [Ued86] </ref> or Parlog [Gre87] or compositional languages such as PCN [CT91]. In particular, the assignment x = y suspends until y has a value; variable-to-variable assignments are not made.
Reference: [WHD89] <author> Andrew A. Chien Waldemar Horwat and William J. Dally. </author> <title> Experience with CST: </title> <booktitle> Programming and implementation. In SIGPLAN 89 Conference on Programming Language Design and Implementation, </booktitle> <year> 1989. </year> <month> 46 </month>
Reference-contexts: In addition, sync variables differ from variables in programming languages such as Strand [FT89] and PCN [CT91] in that the blocking rule for sync variables prohibits the use of variable-to-variable assignment found in these languages. Many concurrent object-oriented languages <ref> [Agh86, AS88, WHD89] </ref> use function call as the basis for communication. In actor based languages, a function call is interpreted as sending a message to the target object to perform the requested operation. The arguments in the function call are 41 passed to the target object as well.
References-found: 30

