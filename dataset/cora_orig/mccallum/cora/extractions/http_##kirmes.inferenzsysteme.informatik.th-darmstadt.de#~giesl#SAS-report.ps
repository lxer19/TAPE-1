URL: http://kirmes.inferenzsysteme.informatik.th-darmstadt.de/~giesl/SAS-report.ps
Refering-URL: http://www.inferenzsysteme.informatik.tu-darmstadt.de/~giesl/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: Email: giesl@inferenzsysteme.informatik.th-darmstadt.de  
Title: Termination Analysis for Functional Programs using Term Orderings  
Author: Jurgen Giesl 
Address: Alexanderstr. 10, 64283 Darmstadt, Germany  
Affiliation: FB Informatik, Technische Hochschule Darmstadt,  
Abstract: To prove the termination of a functional program there has to be a well-founded ordering such that the arguments in each recursive call are smaller than the corresponding inputs. In this paper we present a procedure for automated termination proofs of functional programs. In contrast to previously presented methods a suited well-founded ordering does not have to be fixed in advance by the user, but can be synthesized automatically. For that purpose we use approaches developed in the area of term rewriting systems for the automated generation of suited well-founded term orderings. But unfortunately term orderings cannot be directly used for termination proofs of functional programs which call other algorithms in the arguments of their recursive calls. The reason is that while for the termination of term rewriting systems orderings between terms are needed, for functional programs we need orderings between objects of algebraic data types. Our method solves this problem and enables term orderings to be used for termination proofs of functional programs.
Abstract-found: 1
Intro-found: 1
Reference: [At85] <author> H. At-Kaci. </author> <title> An Algorithm for Finding a Minimal Recursive Path Ordering. </title> <journal> RAIRO, </journal> <volume> 19(4) </volume> <pages> 359-382, </pages> <year> 1985. </year>
Reference-contexts: To prove termination of term rewriting systems several methods for the au-tomated synthesis of term orderings have been developed [Ste94]. For instance, there exist procedures for the automated generation of Knuth-Bendix orderings [Mar87], of polynomial orderings [Col75], [BCL87], [Ste94], [Gie95a] and of path orderings <ref> [At85] </ref>, [DF85], [DH93]. Our aim is to use these synthesis methods for automated termination proofs of functional programs. Unfortunately, while term orderings can easily be used for termination proofs of term rewriting systems, they cannot be directly applied for termination proofs of functional programs, cf. Section 2.
Reference: [BL90] <author> F. Bellegarde & P. Lescanne. </author> <title> Termination by Completion. Applicable Algebra in Engineering, </title> <journal> Communication and Computing, </journal> <volume> 1 </volume> <pages> 79-96, </pages> <year> 1990. </year>
Reference-contexts: TH i+1 j= TH i 4 In this paper we only refer to those term orderings that are amenable to automation. There also exist classes of term orderings which can orient every terminating term rewriting system (e.g. semantical path orderings [KL80] or transformation orderings <ref> [BL90] </ref>). But the disadvantage of these powerful approaches is that up to now there are only very few suggestions for their automated generation [Ste95]. TH 0 ! TH 1 ! TH 2 ! : : : ! TH n 0 1 2 : : : n Fig. 3.
Reference: [BCL87] <author> A. Ben Cherifa & P. Lescanne. </author> <title> Termination of Rewriting Systems by Polynomial Interpretations and its Implementation. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 9(2) </volume> <pages> 137-159, </pages> <year> 1987. </year>
Reference-contexts: To prove termination of term rewriting systems several methods for the au-tomated synthesis of term orderings have been developed [Ste94]. For instance, there exist procedures for the automated generation of Knuth-Bendix orderings [Mar87], of polynomial orderings [Col75], <ref> [BCL87] </ref>, [Ste94], [Gie95a] and of path orderings [At85], [DF85], [DH93]. Our aim is to use these synthesis methods for automated termination proofs of functional programs.
Reference: [BL93] <author> E. Bevers & J. Lewi. </author> <title> Proving Termination of (Conditional) Rewrite Systems. </title> <journal> Acta Informatica, </journal> <volume> 30 </volume> <pages> 537-568, </pages> <year> 1993. </year>
Reference-contexts: Methods for termination proofs of functional programs have for instance been developed by R. S. Boyer and J S. Moore [BM79], C. Walther [Wal88], [Wal94] and F. and H. R. Nielson [NN95]. The procedure of Boyer and Moore has also been adapted for conditional rewrite systems <ref> [BL93] </ref>. But both the technique of Boyer and Moore and the methods for logic programs (e.g. [UV88], [Plu90], [SV91], [DSF93]) are only semi-automatic, i.e. for every termination proof at least the main characteristics of the suited well-founded ordering have to be given in advance by the user.
Reference: [BHHW86] <author> S. Biundo, B. Hummel, D. Hutter & C. Walther. </author> <title> The Karlsruhe Induction Theorem Proving System. </title> <booktitle> In Proceedings of the 8th International Conference on Automated Deduction, </booktitle> <address> Oxford, England, </address> <year> 1986. </year>
Reference-contexts: The resulting method is more powerful than Walther's approach and has a higher degree of automation than the technique of Boyer and Moore. It has been implemented and integrated within the induction theorem proving system inka <ref> [BHHW86] </ref>. We introduce some refinements of our method in Section 5 and end up with a conclusion and an outlook on future work. 2 Functional Programs and Term Orderings In this paper we regard an eager functional language with algebraic data types. <p> To eliminate strictness predicates we have to prove that certain inequalities (like (22)) are sufficient for formulas like x 6= empty ! ffi rm rm (: : :). To perform such proofs automatically we make use of an induction theorem proving system (e.g. those described in [BM79], <ref> [BHHW86] </ref>, [BHHS90]). So to eliminate the defined strictness predicate ffi gg from a formula of the form ' ! t s _ ffi gg (: : :) we proceed as follows: 8 A proof for this observation can be found in the appendix. 1. <p> Therefore in Section 4 and 5 we have developed a method to eliminate defined function symbols from the termination hypotheses of an algorithm. Our method has been implemented within the induction theorem proving system inka <ref> [BHHW86] </ref> (using a procedure for the automated generation of polynomial orderings [Gie95a]) and proved successful on several examples.
Reference: [BM79] <author> R. S. Boyer & J S. Moore. </author> <title> A Computational Logic. </title> <publisher> Academic Press, </publisher> <year> 1979. </year>
Reference-contexts: Methods for termination proofs of functional programs have for instance been developed by R. S. Boyer and J S. Moore <ref> [BM79] </ref>, C. Walther [Wal88], [Wal94] and F. and H. R. Nielson [NN95]. The procedure of Boyer and Moore has also been adapted for conditional rewrite systems [BL93]. <p> To eliminate strictness predicates we have to prove that certain inequalities (like (22)) are sufficient for formulas like x 6= empty ! ffi rm rm (: : :). To perform such proofs automatically we make use of an induction theorem proving system (e.g. those described in <ref> [BM79] </ref>, [BHHW86], [BHHS90]). So to eliminate the defined strictness predicate ffi gg from a formula of the form ' ! t s _ ffi gg (: : :) we proceed as follows: 8 A proof for this observation can be found in the appendix. 1. <p> For instance, it can fully automatically prove the termination of all 60 algorithms from the database of [Wal88], [Wal94] and of all 82 algorithms from <ref> [BM79] </ref> (where one algorithm (greatest.factor) must be slightly modified). In all other methods for termination proofs of functional programs (e.g. [BM79], [Wal94], [NN95]) the orderings for proving termination are either fixed or have to be provided in advance by the user while in our method the right ordering can be synthesized <p> For instance, it can fully automatically prove the termination of all 60 algorithms from the database of [Wal88], [Wal94] and of all 82 algorithms from <ref> [BM79] </ref> (where one algorithm (greatest.factor) must be slightly modified). In all other methods for termination proofs of functional programs (e.g. [BM79], [Wal94], [NN95]) the orderings for proving termination are either fixed or have to be provided in advance by the user while in our method the right ordering can be synthesized automatically.
Reference: [BHHS90] <author> A. Bundy, F. van Harmelen, C. Horn & A. Smaill. </author> <title> The oyster-clam System. </title> <booktitle> In Proceedings of the 10th International Conference on Automated Deduction, </booktitle> <address> Kaiserslautern, Germany, </address> <year> 1990. </year>
Reference-contexts: To eliminate strictness predicates we have to prove that certain inequalities (like (22)) are sufficient for formulas like x 6= empty ! ffi rm rm (: : :). To perform such proofs automatically we make use of an induction theorem proving system (e.g. those described in [BM79], [BHHW86], <ref> [BHHS90] </ref>). So to eliminate the defined strictness predicate ffi gg from a formula of the form ' ! t s _ ffi gg (: : :) we proceed as follows: 8 A proof for this observation can be found in the appendix. 1.
Reference: [Col75] <author> G. E. Collins. </author> <title> Quantifier Elimination for Real Closed Fields by Cylindrical Algebraic Decomposition. </title> <booktitle> In Proceedings of the Second GI Conference on Automata Theory and Formal Languages, </booktitle> <address> Kaiserslautern, Germany, </address> <year> 1975. </year>
Reference-contexts: To prove termination of term rewriting systems several methods for the au-tomated synthesis of term orderings have been developed [Ste94]. For instance, there exist procedures for the automated generation of Knuth-Bendix orderings [Mar87], of polynomial orderings <ref> [Col75] </ref>, [BCL87], [Ste94], [Gie95a] and of path orderings [At85], [DF85], [DH93]. Our aim is to use these synthesis methods for automated termination proofs of functional programs. <p> Therefore the termination of sort is proved. For the synthesis of such well-founded term orderings we apply procedures which are used in the area of term rewriting systems, cf. Section 1. For instance, the algorithm of G. E. Collins <ref> [Col75] </ref> can decide whether there exists a real polynomial ordering of a given degree which satisfies a set of constraints.
Reference: [DSF93] <author> S. Decorte, D. De Schreye & M. Fabris. </author> <title> Automatic Inference of Norms: A Missing Link in Automatic Termination Analysis. </title> <booktitle> In Proceedings of the International Logic Programming Symposium, </booktitle> <address> Vancouver, Canada, </address> <year> 1993. </year>
Reference-contexts: Moore [BM79], C. Walther [Wal88], [Wal94] and F. and H. R. Nielson [NN95]. The procedure of Boyer and Moore has also been adapted for conditional rewrite systems [BL93]. But both the technique of Boyer and Moore and the methods for logic programs (e.g. [UV88], [Plu90], [SV91], <ref> [DSF93] </ref>) are only semi-automatic, i.e. for every termination proof at least the main characteristics of the suited well-founded ordering have to be given in advance by the user.
Reference: [DF85] <author> D. Detlefs & R. Forgaard. </author> <title> A Procedure for Automatically Proving the Termination of a Set of Rewrite Rules. </title> <booktitle> In Proceedings of the First International Conference on Rewriting Techniques and Applications, </booktitle> <address> Dijon, France, </address> <year> 1985. </year>
Reference-contexts: To prove termination of term rewriting systems several methods for the au-tomated synthesis of term orderings have been developed [Ste94]. For instance, there exist procedures for the automated generation of Knuth-Bendix orderings [Mar87], of polynomial orderings [Col75], [BCL87], [Ste94], [Gie95a] and of path orderings [At85], <ref> [DF85] </ref>, [DH93]. Our aim is to use these synthesis methods for automated termination proofs of functional programs. Unfortunately, while term orderings can easily be used for termination proofs of term rewriting systems, they cannot be directly applied for termination proofs of functional programs, cf. Section 2.
Reference: [Der79] <author> N. Dershowitz. </author> <title> A Note on Simplification Orderings. </title> <journal> Information Processing Letters, </journal> <volume> 9(5) </volume> <pages> 212-215, </pages> <year> 1979. </year>
Reference-contexts: Virtually all other term orderings used in the area of term rewriting systems are simplification orderings <ref> [Der79] </ref>, [Ste94]. As these orderings possess the subterm property (i.e. f (: : : t : : :) t), simplification orderings do not respect the semantics of the algorithm min.
Reference: [Der87] <author> N. Dershowitz. </author> <title> Termination of Rewriting. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 3(1, </volume> 2):69-115, 1987. 
Reference-contexts: Of course due to the undecidability of the halting problem no procedure can prove or disprove the termination of all algorithms. Most work on the automation of termination proofs has been done in the areas of term rewriting systems and logic programs (for surveys on these topics see <ref> [Der87] </ref> and [SD93] resp.). Methods for termination proofs of functional programs have for instance been developed by R. S. Boyer and J S. Moore [BM79], C. Walther [Wal88], [Wal94] and F. and H. R. Nielson [NN95]. <p> this observation can be found in the appendix. is sufficient to compare the input arguments with the arguments in the corre-sponding recursive calls, while for term rewriting systems left and right hand sides of all rules have to be compared (and moreover, the term ordering has to be monotonic), cf. <ref> [Der87] </ref>. Therefore by the transformation of functional programs into a term rewriting system we impose unnecessarily strong requirements for the termination proof. For instance, with most of the commonly used 4 term orderings the termination of the term rewriting system resulting from sort, min and rm cannot be proved.
Reference: [DH93] <author> N. Dershowitz & C. Hoot. </author> <title> Topics in Termination. </title> <booktitle> In Proceedings of the 5th International Conference on Rewriting Techniques and Applications, </booktitle> <address> Montreal, Canada, </address> <year> 1993. </year>
Reference-contexts: To prove termination of term rewriting systems several methods for the au-tomated synthesis of term orderings have been developed [Ste94]. For instance, there exist procedures for the automated generation of Knuth-Bendix orderings [Mar87], of polynomial orderings [Col75], [BCL87], [Ste94], [Gie95a] and of path orderings [At85], [DF85], <ref> [DH93] </ref>. Our aim is to use these synthesis methods for automated termination proofs of functional programs. Unfortunately, while term orderings can easily be used for termination proofs of term rewriting systems, they cannot be directly applied for termination proofs of functional programs, cf. Section 2.
Reference: [Gie95a] <author> J. Giesl. </author> <title> Generating Polynomial Orderings for Termination Proofs. </title> <booktitle> In Proceedings of the 6th International Conference on Rewriting Techniques and Applications, </booktitle> <address> Kaiserslautern, Germany, </address> <year> 1995. </year>
Reference-contexts: To prove termination of term rewriting systems several methods for the au-tomated synthesis of term orderings have been developed [Ste94]. For instance, there exist procedures for the automated generation of Knuth-Bendix orderings [Mar87], of polynomial orderings [Col75], [BCL87], [Ste94], <ref> [Gie95a] </ref> and of path orderings [At85], [DF85], [DH93]. Our aim is to use these synthesis methods for automated termination proofs of functional programs. Unfortunately, while term orderings can easily be used for termination proofs of term rewriting systems, they cannot be directly applied for termination proofs of functional programs, cf. <p> Section 1. For instance, the algorithm of G. E. Collins [Col75] can decide whether there exists a real polynomial ordering of a given degree which satisfies a set of constraints. A procedure to generate polynomial orderings using an efficient, incomplete modification of Collins' algorithm has been presented in <ref> [Gie95a] </ref>. 5 Comments and Refinements To enable the use of term orderings for termination proofs of functional programs defined function symbols in the recursive calls have to be eliminated. This elimination proceeds in three steps. <p> Therefore in Section 4 and 5 we have developed a method to eliminate defined function symbols from the termination hypotheses of an algorithm. Our method has been implemented within the induction theorem proving system inka [BHHW86] (using a procedure for the automated generation of polynomial orderings <ref> [Gie95a] </ref>) and proved successful on several examples. For instance, it can fully automatically prove the termination of all 60 algorithms from the database of [Wal88], [Wal94] and of all 82 algorithms from [BM79] (where one algorithm (greatest.factor) must be slightly modified).
Reference: [Gie95b] <institution> J. Giesl. Automatisierung von Terminierungsbeweisen fur rekursiv definier-te Algorithmen. Doctoral Dissertation, Technische Hochschule Darmstadt, Germany, </institution> <year> 1995. </year>
Reference-contexts: To improve the efficiency of our method, we have also developed heuristics for choosing the "right" derivation tree <ref> [Gie95b] </ref>. These heuristics have proved successful in practice. An alternative method for termination proofs with user provided orderings which avoids such choice points is presented in [Gie95c]. Our method can easily be extended to algorithms with several formal parameters.
Reference: [Gie95c] <author> J. Giesl. </author> <title> Automated Termination Proofs with Measure Functions. </title> <booktitle> In Proceedings of the 19th Annual German Conference on Artificial Intelligence, </booktitle> <address> Bielefeld, Germany, </address> <year> 1995. </year>
Reference-contexts: To improve the efficiency of our method, we have also developed heuristics for choosing the "right" derivation tree [Gie95b]. These heuristics have proved successful in practice. An alternative method for termination proofs with user provided orderings which avoids such choice points is presented in <ref> [Gie95c] </ref>. Our method can easily be extended to algorithms with several formal parameters.
Reference: [KL80] <author> S. Kamin & J.-J. Levy. </author> <title> Two Generalizations of the Recursive Path Order--ing. Unpublished Note, </title> <institution> Department of Computer Science, University of Illinois, Urbana, IL, </institution> <year> 1980. </year>
Reference-contexts: This transformation is an abduction process [Pei31], i.e. TH i+1 j= TH i 4 In this paper we only refer to those term orderings that are amenable to automation. There also exist classes of term orderings which can orient every terminating term rewriting system (e.g. semantical path orderings <ref> [KL80] </ref> or transformation orderings [BL90]). But the disadvantage of these powerful approaches is that up to now there are only very few suggestions for their automated generation [Ste95].
Reference: [Lan79] <author> D. S. Lankford. </author> <title> On Proving Term Rewriting Systems are Noetherian. </title> <type> Technical Report Memo MTP-3, </type> <institution> Mathematics Department, Louisiana Technical University, </institution> <year> 1979. </year>
Reference-contexts: Techniques for the automated generation of well-founded term orderings satisfying such constraints have been developed in the area of term rewriting systems. For instance, termination of flatten can be proved with a polynomial ordering <ref> [Lan79] </ref>, where every n-ary function symbol is associated with an n-ary polynomial over the natural numbers. Then a ground term t is greater than a ground term s with respect to the polynomial ordering iff the number corresponding to t is greater than the number corresponding to s.
Reference: [Mar87] <author> U. Martin. </author> <title> How to choose Weights in the Knuth-Bendix Ordering. </title> <booktitle> In Proceedings of the Second International Conference on Rewriting Techniques and Applications, </booktitle> <address> Bordeaux, France, </address> <year> 1987. </year>
Reference-contexts: To prove termination of term rewriting systems several methods for the au-tomated synthesis of term orderings have been developed [Ste94]. For instance, there exist procedures for the automated generation of Knuth-Bendix orderings <ref> [Mar87] </ref>, of polynomial orderings [Col75], [BCL87], [Ste94], [Gie95a] and of path orderings [At85], [DF85], [DH93]. Our aim is to use these synthesis methods for automated termination proofs of functional programs.
Reference: [NN95] <author> F. Nielson & H. R. Nielson. </author> <title> Termination Analysis based on Operational Semantics. </title> <type> Technical Report, </type> <institution> Aarhus University, Denmark, </institution> <year> 1995. </year> <note> Available from http://www.daimi.aau.dk/~fn/Papers/PB492.ps.Z. </note>
Reference-contexts: Methods for termination proofs of functional programs have for instance been developed by R. S. Boyer and J S. Moore [BM79], C. Walther [Wal88], [Wal94] and F. and H. R. Nielson <ref> [NN95] </ref>. The procedure of Boyer and Moore has also been adapted for conditional rewrite systems [BL93]. <p> For termination analysis of higher order functional programs we suggest to integrate our method into the type inference system presented by Nielson and Nielson <ref> [NN95] </ref>. In their system functional types have an annotation to distinguish total functions from probably partial ones. To prove termination of a recursive function, they use a rule which infers the annotated type of the function under the assumption that the recursive calls of the function are terminating. <p> For instance, it can fully automatically prove the termination of all 60 algorithms from the database of [Wal88], [Wal94] and of all 82 algorithms from [BM79] (where one algorithm (greatest.factor) must be slightly modified). In all other methods for termination proofs of functional programs (e.g. [BM79], [Wal94], <ref> [NN95] </ref>) the orderings for proving termination are either fixed or have to be provided in advance by the user while in our method the right ordering can be synthesized automatically.
Reference: [Pei31] <author> C. S. </author> <title> Peirce. Collected Papers of C. </title> <journal> Sanders Peirce, </journal> <volume> vol. 2. </volume> <editor> Hartshorne et al. (eds.), </editor> <publisher> Harvard University Press, </publisher> <address> Cambridge, MA, </address> <year> 1931. </year>
Reference-contexts: In this way the termination hypotheses TH 0 of an algorithm are transformed into TH 1 , TH 2 etc. until we obtain a set of formulas TH n containing no defined function symbols any more. This transformation is an abduction process <ref> [Pei31] </ref>, i.e. TH i+1 j= TH i 4 In this paper we only refer to those term orderings that are amenable to automation. There also exist classes of term orderings which can orient every terminating term rewriting system (e.g. semantical path orderings [KL80] or transformation orderings [BL90]).
Reference: [Plu90] <author> L. Plumer. </author> <title> Termination Proofs for Logic Programs. </title> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: S. Boyer and J S. Moore [BM79], C. Walther [Wal88], [Wal94] and F. and H. R. Nielson [NN95]. The procedure of Boyer and Moore has also been adapted for conditional rewrite systems [BL93]. But both the technique of Boyer and Moore and the methods for logic programs (e.g. [UV88], <ref> [Plu90] </ref>, [SV91], [DSF93]) are only semi-automatic, i.e. for every termination proof at least the main characteristics of the suited well-founded ordering have to be given in advance by the user.
Reference: [SD93] <author> D. De Schreye & S. Decorte. </author> <title> Termination of Logic Programs: The NeverEnding Story. Technical Report Compulog II, </title> <editor> D 8.1.1, K. U. </editor> <address> Leuven, Bel-gium, </address> <year> 1993. </year>
Reference-contexts: Most work on the automation of termination proofs has been done in the areas of term rewriting systems and logic programs (for surveys on these topics see [Der87] and <ref> [SD93] </ref> resp.). Methods for termination proofs of functional programs have for instance been developed by R. S. Boyer and J S. Moore [BM79], C. Walther [Wal88], [Wal94] and F. and H. R. Nielson [NN95]. The procedure of Boyer and Moore has also been adapted for conditional rewrite systems [BL93].
Reference: [SV91] <author> K. Sohn & A. van Gelder. </author> <title> Termination Detection in Logic Programs using Argument Sizes. </title> <booktitle> In Proceedings of the 10th ACM Symposium on Principles of Database Systems, </booktitle> <address> Denver, Colorado, </address> <year> 1991. </year>
Reference-contexts: Boyer and J S. Moore [BM79], C. Walther [Wal88], [Wal94] and F. and H. R. Nielson [NN95]. The procedure of Boyer and Moore has also been adapted for conditional rewrite systems [BL93]. But both the technique of Boyer and Moore and the methods for logic programs (e.g. [UV88], [Plu90], <ref> [SV91] </ref>, [DSF93]) are only semi-automatic, i.e. for every termination proof at least the main characteristics of the suited well-founded ordering have to be given in advance by the user.
Reference: [Ste94] <author> J. Steinbach. </author> <title> Termination of Rewriting | Extensions, Comparison and Automatic Generation of Simplification Orderings. </title> <type> Doctoral Dissertation, </type> <institution> Universitat Kaiserslautern, Germany, </institution> <year> 1994. </year>
Reference-contexts: To prove termination of term rewriting systems several methods for the au-tomated synthesis of term orderings have been developed <ref> [Ste94] </ref>. For instance, there exist procedures for the automated generation of Knuth-Bendix orderings [Mar87], of polynomial orderings [Col75], [BCL87], [Ste94], [Gie95a] and of path orderings [At85], [DF85], [DH93]. Our aim is to use these synthesis methods for automated termination proofs of functional programs. <p> To prove termination of term rewriting systems several methods for the au-tomated synthesis of term orderings have been developed <ref> [Ste94] </ref>. For instance, there exist procedures for the automated generation of Knuth-Bendix orderings [Mar87], of polynomial orderings [Col75], [BCL87], [Ste94], [Gie95a] and of path orderings [At85], [DF85], [DH93]. Our aim is to use these synthesis methods for automated termination proofs of functional programs. <p> Virtually all other term orderings used in the area of term rewriting systems are simplification orderings [Der79], <ref> [Ste94] </ref>. As these orderings possess the subterm property (i.e. f (: : : t : : :) t), simplification orderings do not respect the semantics of the algorithm min.
Reference: [Ste95] <author> J. Steinbach. </author> <title> Automatic Termination Proofs with Transformation Order-ings. </title> <booktitle> In Proceedings of the 6th International Conference on Rewriting Techniques and Applications, </booktitle> <address> Kaiserslautern, Germany, </address> <year> 1995. </year>
Reference-contexts: There also exist classes of term orderings which can orient every terminating term rewriting system (e.g. semantical path orderings [KL80] or transformation orderings [BL90]). But the disadvantage of these powerful approaches is that up to now there are only very few suggestions for their automated generation <ref> [Ste95] </ref>. TH 0 ! TH 1 ! TH 2 ! : : : ! TH n 0 1 2 : : : n Fig. 3. Elimination of defined function symbols from termination hypotheses. holds for all i.
Reference: [UV88] <author> J. D. Ullman & A. van Gelder. </author> <title> Efficient Tests for Top-Down Termination of Logical Rules. </title> <journal> Journal of the ACM, </journal> <volume> 35(2) </volume> <pages> 345-373, </pages> <year> 1988. </year>
Reference-contexts: S. Boyer and J S. Moore [BM79], C. Walther [Wal88], [Wal94] and F. and H. R. Nielson [NN95]. The procedure of Boyer and Moore has also been adapted for conditional rewrite systems [BL93]. But both the technique of Boyer and Moore and the methods for logic programs (e.g. <ref> [UV88] </ref>, [Plu90], [SV91], [DSF93]) are only semi-automatic, i.e. for every termination proof at least the main characteristics of the suited well-founded ordering have to be given in advance by the user.
Reference: [Wal88] <author> C. Walther. </author> <title> Argument-Bounded Algorithms as as Basis for Automated Termination Proofs. </title> <booktitle> In Proceedings of the 9th International Conference on Automated Deduction, </booktitle> <address> Argonne, IL, </address> <year> 1988. </year>
Reference-contexts: Methods for termination proofs of functional programs have for instance been developed by R. S. Boyer and J S. Moore [BM79], C. Walther <ref> [Wal88] </ref>, [Wal94] and F. and H. R. Nielson [NN95]. The procedure of Boyer and Moore has also been adapted for conditional rewrite systems [BL93]. <p> Our method has been implemented within the induction theorem proving system inka [BHHW86] (using a procedure for the automated generation of polynomial orderings [Gie95a]) and proved successful on several examples. For instance, it can fully automatically prove the termination of all 60 algorithms from the database of <ref> [Wal88] </ref>, [Wal94] and of all 82 algorithms from [BM79] (where one algorithm (greatest.factor) must be slightly modified).
Reference: [Wal94] <author> C. Walther. </author> <title> On Proving the Termination of Algorithms by Machine. </title> <journal> Artificial Intelligence, </journal> <volume> 71(1) </volume> <pages> 101-157, </pages> <year> 1994. </year>
Reference-contexts: Methods for termination proofs of functional programs have for instance been developed by R. S. Boyer and J S. Moore [BM79], C. Walther [Wal88], <ref> [Wal94] </ref> and F. and H. R. Nielson [NN95]. The procedure of Boyer and Moore has also been adapted for conditional rewrite systems [BL93]. <p> Our method has been implemented within the induction theorem proving system inka [BHHW86] (using a procedure for the automated generation of polynomial orderings [Gie95a]) and proved successful on several examples. For instance, it can fully automatically prove the termination of all 60 algorithms from the database of [Wal88], <ref> [Wal94] </ref> and of all 82 algorithms from [BM79] (where one algorithm (greatest.factor) must be slightly modified). In all other methods for termination proofs of functional programs (e.g. [BM79], [Wal94], [NN95]) the orderings for proving termination are either fixed or have to be provided in advance by the user while in our <p> For instance, it can fully automatically prove the termination of all 60 algorithms from the database of [Wal88], <ref> [Wal94] </ref> and of all 82 algorithms from [BM79] (where one algorithm (greatest.factor) must be slightly modified). In all other methods for termination proofs of functional programs (e.g. [BM79], [Wal94], [NN95]) the orderings for proving termination are either fixed or have to be provided in advance by the user while in our method the right ordering can be synthesized automatically.
References-found: 29

