URL: file://ftp.cis.ohio-state.edu/pub/tech-report/1995/TR11.ps.gz
Refering-URL: ftp://ftp.cis.ohio-state.edu/pub/tech-report/TRList.html
Root-URL: 
Email: -law, yagel-@cis.ohio-state.edu  
Title: CellFlow: A Parallel Rendering Scheme for Distributed Memory Architectures  
Author: Asish Law and Roni Yagel 
Address: Columbus, Ohio  
Affiliation: Department of Computer and Information Science The Ohio State University  
Abstract: We present the CellFlow method for object space subdivision that exploits frame coherency to implement a look-ahead scheme of object dataow. The implementation of this scheme exploits the communication features of modern scalable multicomput-ers to achieve near linear speedup by means of latency hiding. We demonstrate the performance of our approach in the field of volume rendering by implementing incremental rotation of the volumetric object about its center. The simplicity of the algorithm, its optimal embedding in popular network topologies, and minimal congestion-free communication among processors are its main advantages. Results are shown for implementation on the Cray T3D, a distributed memory 3D torus architecture. Computation and communication load balancing issues among processors are also addressed.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Cameron, G.G, and Underill, </author> <title> P.E.,Rendering Volumetric Medical Image Data on a SIMD Archi tecture Computer, </title> <booktitle> SPIE, Visualization in Biomedical Computing 1992, </booktitle> <volume> Vol. 1808, </volume> <pages> pp. </pages> <address> 137- 142. </address>
Reference-contexts: A few of them exist on experimental parallel processors, such as the Princeton Engine [15] or the DASH parallel system [13]. Other implementations have been conducted on commercially available parallel machines such as the AMT DAP <ref> [1] </ref>, Connection Machine CM-2 ([14], [15]), MasPar MP-1 ([18], [20]), Intel iPSC-2 [12], nCube [5], Cray Y-MP [16], IBM PVS [11], Silicon Graphics multiprocessor workstation [6] and network of Suns [17]. The viewing algorithms adopted in these implementations are many and varied. Several are based on backward-feed methods. <p> The viewing algorithms adopted in these implementations are many and varied. Several are based on backward-feed methods. In [12] and [13] ray-casting is used, while in [14] our template-based ray-casting [19] was implemented. Others, including <ref> [1] </ref>, [14], and [20] adopted a feed-forward method, wherein the multiple shear decomposition was implemented while others ([5], [11]) used splatting as the reconstruction method of choice.
Reference: 2. <author> Cohen, D. and S. Fleishman, </author> <title> An Incremental Rotation Algorithm for Parallel Volume Rendering, </title> <type> unpublished report, </type> <institution> Ben Gurion University. </institution>
Reference: 3. <author> Drebin, R. A, Carpenter, L., Hanrahan, </author> <title> P.,Volume Rendering, </title> <journal> Computer Graphics, </journal> <volume> Vol. 22, No. 4, </volume> <month> August </month> <year> 1988, </year> <pages> pp. 65-74. 21 </pages>
Reference-contexts: Image order techniques, on the other hand, 2 determine all the voxels of a volume which affect a given pixel on the screen [9]. Hybrid methods exist in which the volume is traversed in both object and image order <ref> [3] </ref>. Westover [17] employs the synonymous terms feed-forward and backward-feed for object and image order methods, respectively. We shall also use these terms to classify volume rendering methods.
Reference: 4. <author> Ebert, D. S., R. Yagel, J. Scott, and Y. Kurzion, </author> <title> Volume Rendering Methods for Computational Fluid Dynamics Visualization, </title> <booktitle> Proceedings of Visualization'94, </booktitle> <address> Washington, DC, </address> <month> October </month> <year> 1994, </year> <pages> pp. 232-239. </pages>
Reference: 5. <author> Elvins, T. </author> <title> T.,Volume Rendering on a Distributed Memory Parallel Computer, </title> <booktitle> Proceedings of Visualization92, </booktitle> <address> Boston MA, </address> <month> October </month> <year> 1992, </year> <pages> pp. 93-98. </pages>
Reference-contexts: Other implementations have been conducted on commercially available parallel machines such as the AMT DAP [1], Connection Machine CM-2 ([14], [15]), MasPar MP-1 ([18], [20]), Intel iPSC-2 [12], nCube <ref> [5] </ref>, Cray Y-MP [16], IBM PVS [11], Silicon Graphics multiprocessor workstation [6] and network of Suns [17]. The viewing algorithms adopted in these implementations are many and varied. Several are based on backward-feed methods. In [12] and [13] ray-casting is used, while in [14] our template-based ray-casting [19] was implemented.
Reference: 6. <author> Fruhauf, </author> <title> M.,Volume Rendering on a Multiprocessor Architecture with Shared Memory: A Concurrent Volume Rendering Algorithm, </title> <booktitle> Proceedings of Second Eurographics Workshop on Visual ization in Scientific Computing, </booktitle> <year> 1992. </year>
Reference-contexts: Other implementations have been conducted on commercially available parallel machines such as the AMT DAP [1], Connection Machine CM-2 ([14], [15]), MasPar MP-1 ([18], [20]), Intel iPSC-2 [12], nCube [5], Cray Y-MP [16], IBM PVS [11], Silicon Graphics multiprocessor workstation <ref> [6] </ref> and network of Suns [17]. The viewing algorithms adopted in these implementations are many and varied. Several are based on backward-feed methods. In [12] and [13] ray-casting is used, while in [14] our template-based ray-casting [19] was implemented.
Reference: 7. <author> Fujimoto, A., T. Tanaka, K.Iwata. </author> <title> ARTS: Accelerated Ray-Tracing System. </title> <journal> IEEE Computer Graphics & Applications. </journal> <month> April </month> <year> 1986. </year> <pages> pp. 16-26. </pages>
Reference-contexts: One way to implement the incremental rotation scheme for polygonal objects is to divide the object space into cells, with each cell containing all the primitives falling within it. A method similar to the spatial enumeration approach taken by Fujimoto et al <ref> [7] </ref> in their SEEDS method can be applied in this case. After such an object-space division as a preprocessing step, the method described here can be directly applied to polygon based objects.
Reference: 8. <author> Law, A., R. Yagel, D. N. Jayasimha. VoxelFlow: </author> <title> A Parallel Volume Rendering Method for Scientific Visualization, </title> <booktitle> Proceedings of ISCA International Conference. </booktitle> <month> March 15-17, </month> <year> 1995. </year> <pages> pp. 260 264. </pages>
Reference-contexts: The two wedge shaped grey areas in Figure 3 correspond to the padding in the CellFlow scheme. This ow of voxel data between adjacent processor gave our earlier method its name: VoxelFlow <ref> [8] </ref>. As the rotation angle increases, the size of the black area decreases, that is, most of the data has to be brought in (communicated) from other processors. If the angle of rotation is very large some of the information that is needed might reside more than one processor away.
Reference: 9. <author> Levoy, M., </author> <title> Display of Surfaces from Volume Data, </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> Vol. 8, No. 5, </volume> <month> May </month> <year> 1988, </year> <pages> pp. 29-37. </pages>
Reference-contexts: Object order methods require the enumeration of all voxels of a volume and the determination of the affected pixels on a screen [17]. Image order techniques, on the other hand, 2 determine all the voxels of a volume which affect a given pixel on the screen <ref> [9] </ref>. Hybrid methods exist in which the volume is traversed in both object and image order [3]. Westover [17] employs the synonymous terms feed-forward and backward-feed for object and image order methods, respectively. We shall also use these terms to classify volume rendering methods.
Reference: 10. <author> Lorenson, W. E., Cline, H. E., </author> <title> Marching Cubes: A High Resolution 3D Surface Construction Algorithm, </title> <journal> Computer Graphics, </journal> <volume> Vol. 21, No. 4, </volume> <month> July </month> <year> 1987, </year> <pages> pp. 163 - 169. </pages>
Reference-contexts: Due to these reasons, it often becomes infeasible to apply direct volume visualization techniques for generating numerous images for animation on a uniprocessor machine. Several methods exist for the rendering of volumes. One class of these methods converts the voxel representation into surface primitives <ref> [10] </ref>. However, methods of this class suffer from various disadvantages that mainly arise from the ambiguity of determining the exact position of the surface. As an alternative, direct methods have been developed to render volumes. These methods can be classified as object order or image order.
Reference: 11. <author> Machiraju R. and R. Yagel, </author> <title> Efficient Feed-Forward Volume Rendering Techniques for Vector and Parallel Processors, </title> <address> SUPERCOMPUTING'93, Portland, Oregon, </address> <month> November </month> <year> 1993, </year> <pages> pp. 699-708. </pages>
Reference-contexts: Other implementations have been conducted on commercially available parallel machines such as the AMT DAP [1], Connection Machine CM-2 ([14], [15]), MasPar MP-1 ([18], [20]), Intel iPSC-2 [12], nCube [5], Cray Y-MP [16], IBM PVS <ref> [11] </ref>, Silicon Graphics multiprocessor workstation [6] and network of Suns [17]. The viewing algorithms adopted in these implementations are many and varied. Several are based on backward-feed methods. In [12] and [13] ray-casting is used, while in [14] our template-based ray-casting [19] was implemented. <p> Several are based on backward-feed methods. In [12] and [13] ray-casting is used, while in [14] our template-based ray-casting [19] was implemented. Others, including [1], [14], and [20] adopted a feed-forward method, wherein the multiple shear decomposition was implemented while others ([5], <ref> [11] </ref>) used splatting as the reconstruction method of choice.
Reference: 12. <author> Montani, C., Perego, R., Scopigno R., </author> <title> Parallel Volume Visualization on a Hypercube Architecture, </title> <booktitle> Proceedings of 1992 Workshop on Volume Visualization, </booktitle> <address> October 1992, Boston, MA, </address> <pages> pp. 9 15. </pages>
Reference-contexts: A few of them exist on experimental parallel processors, such as the Princeton Engine [15] or the DASH parallel system [13]. Other implementations have been conducted on commercially available parallel machines such as the AMT DAP [1], Connection Machine CM-2 ([14], [15]), MasPar MP-1 ([18], [20]), Intel iPSC-2 <ref> [12] </ref>, nCube [5], Cray Y-MP [16], IBM PVS [11], Silicon Graphics multiprocessor workstation [6] and network of Suns [17]. The viewing algorithms adopted in these implementations are many and varied. Several are based on backward-feed methods. In [12] and [13] ray-casting is used, while in [14] our template-based ray-casting [19] was <p> DAP [1], Connection Machine CM-2 ([14], [15]), MasPar MP-1 ([18], [20]), Intel iPSC-2 <ref> [12] </ref>, nCube [5], Cray Y-MP [16], IBM PVS [11], Silicon Graphics multiprocessor workstation [6] and network of Suns [17]. The viewing algorithms adopted in these implementations are many and varied. Several are based on backward-feed methods. In [12] and [13] ray-casting is used, while in [14] our template-based ray-casting [19] was implemented. Others, including [1], [14], and [20] adopted a feed-forward method, wherein the multiple shear decomposition was implemented while others ([5], [11]) used splatting as the reconstruction method of choice.
Reference: 13. <author> Nieh, J., Levoy, </author> <title> M.,Volume Rendering on Scalable Shared-Memory MIMD Architecture, </title> <booktitle> Pro ceedings of 1992 Workshop on Volume Visualization, </booktitle> <address> Boston, MA, </address> <pages> pp. 17-24. </pages>
Reference-contexts: Some implementations of direct volume rendering have recently been reported for a variety of parallel architectures. A few of them exist on experimental parallel processors, such as the Princeton Engine [15] or the DASH parallel system <ref> [13] </ref>. Other implementations have been conducted on commercially available parallel machines such as the AMT DAP [1], Connection Machine CM-2 ([14], [15]), MasPar MP-1 ([18], [20]), Intel iPSC-2 [12], nCube [5], Cray Y-MP [16], IBM PVS [11], Silicon Graphics multiprocessor workstation [6] and network of Suns [17]. <p> The viewing algorithms adopted in these implementations are many and varied. Several are based on backward-feed methods. In [12] and <ref> [13] </ref> ray-casting is used, while in [14] our template-based ray-casting [19] was implemented. Others, including [1], [14], and [20] adopted a feed-forward method, wherein the multiple shear decomposition was implemented while others ([5], [11]) used splatting as the reconstruction method of choice.
Reference: 14. <author> Schroder, P., Salem, J. B., </author> <title> Fast Rotation of Volume Data on Data Parallel Architecture, </title> <booktitle> Proceed ings of Visualization91, </booktitle> <address> San Diego, CA, </address> <pages> pp. 50-57. </pages>
Reference-contexts: The viewing algorithms adopted in these implementations are many and varied. Several are based on backward-feed methods. In [12] and [13] ray-casting is used, while in <ref> [14] </ref> our template-based ray-casting [19] was implemented. Others, including [1], [14], and [20] adopted a feed-forward method, wherein the multiple shear decomposition was implemented while others ([5], [11]) used splatting as the reconstruction method of choice. <p> The viewing algorithms adopted in these implementations are many and varied. Several are based on backward-feed methods. In [12] and [13] ray-casting is used, while in <ref> [14] </ref> our template-based ray-casting [19] was implemented. Others, including [1], [14], and [20] adopted a feed-forward method, wherein the multiple shear decomposition was implemented while others ([5], [11]) used splatting as the reconstruction method of choice.
Reference: 15. <author> Schroder, P., Stoll, </author> <title> G.,Data Parallel Volume Rendering as Line Drawing, </title> <booktitle> Proceedings of 1992 Workshop on Volume Visualization, </booktitle> <address> October 1992, Boston, MA, </address> <pages> pp. 25-32. </pages>
Reference-contexts: Some implementations of direct volume rendering have recently been reported for a variety of parallel architectures. A few of them exist on experimental parallel processors, such as the Princeton Engine <ref> [15] </ref> or the DASH parallel system [13]. Other implementations have been conducted on commercially available parallel machines such as the AMT DAP [1], Connection Machine CM-2 ([14], [15]), MasPar MP-1 ([18], [20]), Intel iPSC-2 [12], nCube [5], Cray Y-MP [16], IBM PVS [11], Silicon Graphics multiprocessor workstation [6] and network of <p> A few of them exist on experimental parallel processors, such as the Princeton Engine <ref> [15] </ref> or the DASH parallel system [13]. Other implementations have been conducted on commercially available parallel machines such as the AMT DAP [1], Connection Machine CM-2 ([14], [15]), MasPar MP-1 ([18], [20]), Intel iPSC-2 [12], nCube [5], Cray Y-MP [16], IBM PVS [11], Silicon Graphics multiprocessor workstation [6] and network of Suns [17]. The viewing algorithms adopted in these implementations are many and varied. Several are based on backward-feed methods.
Reference: 16. <author> Stredney, D., Yagel, R., May, S. F., Torello, M., </author> <title> Supercomputer Assisted Brain Visualization with an Extended Ray Tracer,1992 Workshop on Volume Visualization, </title> <address> Boston, MA, </address> <pages> pp. 33-38. </pages>
Reference-contexts: Other implementations have been conducted on commercially available parallel machines such as the AMT DAP [1], Connection Machine CM-2 ([14], [15]), MasPar MP-1 ([18], [20]), Intel iPSC-2 [12], nCube [5], Cray Y-MP <ref> [16] </ref>, IBM PVS [11], Silicon Graphics multiprocessor workstation [6] and network of Suns [17]. The viewing algorithms adopted in these implementations are many and varied. Several are based on backward-feed methods. In [12] and [13] ray-casting is used, while in [14] our template-based ray-casting [19] was implemented.
Reference: 17. <author> Westover, L., Splatting: </author> <title> A Parallel, Feed-Forward Volume Rendering Algorithm, </title> <type> Ph.D Thesis, </type> <institution> Department of Computer Science, University of North Carolina at Chapel Hill, </institution> <month> July </month> <year> 1991. </year>
Reference-contexts: As an alternative, direct methods have been developed to render volumes. These methods can be classified as object order or image order. Object order methods require the enumeration of all voxels of a volume and the determination of the affected pixels on a screen <ref> [17] </ref>. Image order techniques, on the other hand, 2 determine all the voxels of a volume which affect a given pixel on the screen [9]. Hybrid methods exist in which the volume is traversed in both object and image order [3]. Westover [17] employs the synonymous terms feed-forward and backward-feed for <p> determination of the affected pixels on a screen <ref> [17] </ref>. Image order techniques, on the other hand, 2 determine all the voxels of a volume which affect a given pixel on the screen [9]. Hybrid methods exist in which the volume is traversed in both object and image order [3]. Westover [17] employs the synonymous terms feed-forward and backward-feed for object and image order methods, respectively. We shall also use these terms to classify volume rendering methods. <p> Other implementations have been conducted on commercially available parallel machines such as the AMT DAP [1], Connection Machine CM-2 ([14], [15]), MasPar MP-1 ([18], [20]), Intel iPSC-2 [12], nCube [5], Cray Y-MP [16], IBM PVS [11], Silicon Graphics multiprocessor workstation [6] and network of Suns <ref> [17] </ref>. The viewing algorithms adopted in these implementations are many and varied. Several are based on backward-feed methods. In [12] and [13] ray-casting is used, while in [14] our template-based ray-casting [19] was implemented.
Reference: 18. <author> Wittenbrink, C., Somani, A., </author> <title> Permutation Warping for Data Parallel Volume Rendering, </title> <booktitle> 1993 Parallel Rendering Symposium, </booktitle> <address> San Jose, CA, </address> <month> October, </month> <year> 1993, </year> <pages> pp. 57-60. </pages>
Reference: 19. <author> Yagel, R., Kaufman, A., </author> <title> Efficient Methods for Volume Rendering, </title> <journal> Computers and Graphics, Pro ceedings of Eurographics92, </journal> <month> September </month> <year> 1992, </year> <title> Cambridge, </title> <booktitle> England, </booktitle> <pages> pp. 153-157. </pages>
Reference-contexts: The viewing algorithms adopted in these implementations are many and varied. Several are based on backward-feed methods. In [12] and [13] ray-casting is used, while in [14] our template-based ray-casting <ref> [19] </ref> was implemented. Others, including [1], [14], and [20] adopted a feed-forward method, wherein the multiple shear decomposition was implemented while others ([5], [11]) used splatting as the reconstruction method of choice.
Reference: 20. <author> Veznia, G., Fletcher, P. A., Robertson, P. K., </author> <title> Volume Rendering on the MasPar MP-1, </title> <booktitle> Proceed ings of 1992 Workshop on Volume Visualization, </booktitle> <address> October 1992, Boston, MA, </address> <pages> pp. 3-8. </pages>
Reference-contexts: A few of them exist on experimental parallel processors, such as the Princeton Engine [15] or the DASH parallel system [13]. Other implementations have been conducted on commercially available parallel machines such as the AMT DAP [1], Connection Machine CM-2 ([14], [15]), MasPar MP-1 ([18], <ref> [20] </ref>), Intel iPSC-2 [12], nCube [5], Cray Y-MP [16], IBM PVS [11], Silicon Graphics multiprocessor workstation [6] and network of Suns [17]. The viewing algorithms adopted in these implementations are many and varied. Several are based on backward-feed methods. <p> The viewing algorithms adopted in these implementations are many and varied. Several are based on backward-feed methods. In [12] and [13] ray-casting is used, while in [14] our template-based ray-casting [19] was implemented. Others, including [1], [14], and <ref> [20] </ref> adopted a feed-forward method, wherein the multiple shear decomposition was implemented while others ([5], [11]) used splatting as the reconstruction method of choice.
References-found: 20

