URL: ftp://rtcl.eecs.umich.edu/outgoing/zaher/comment.ps
Refering-URL: http://www.eecs.umich.edu/~zaher/publications.html
Root-URL: http://www.cs.umich.edu
Email: fzaher,kgshing@eecs.umich.edu  
Phone: 313-763-0391 (voice); 313-963-4617 (fax)  
Title: Comment on "A Pre-Run-Time Scheduling Algorithm for Hard Real-Time Systems"  
Author: Tarek F. Abdelzaher, and Kang G. Shin 
Keyword: Key Words Pre-run-time scheduling, hard real-time systems, branch and bound scheduling algorithm, multiprocessors, precedence constraints.  
Address: Ann Arbor, Michigan 48109-2122  
Affiliation: Real-time Computing Laboratory Department of Electrical Engineering and Computer Science The University of Michigan  
Abstract: In [1] a branch-and-bound implicit enumeration algorithm is described to generate a feasible schedule, if any, for each processor on a multiprocessing node running hard real-time processes. The optimization criterion is to minimize process lateness defined as the difference between the process completion time and deadline. We show in this correspondence that this algorithm does not always succeed in finding a feasible solution, and describe the reason why the algorithm might fail. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> T. Shepard and M. Gagne, </author> <title> "A pre-run-time scheduling algorithm for hard real-time systems," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 17, no. 7, </volume> <pages> pp. 669-677, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: 1 Introduction The authors of <ref> [1] </ref> describe a pre-run-time branch-and-bound implicit enumeration algorithm which determines a feasible schedule for a set of hard real-time processes subject to precedence and exclusion constraints. Processes are assumed to be statically assigned to processors on a multiprocessing node. <p> Unless the application violates its load specification, pre-run-time scheduling also provides a means to verify and guarantee the observance of timing constraints throughout the life cycle of the system. In addition, the scheduling model used in <ref> [1] </ref> provides a systematic and tractable approach to modifying application software. Namely, when the software is modified, the applicable scheduling model parameters may be altered, and a new set of run-time schedules can be generated. <p> This approach eliminates the need for fine tuning the code via repeated stochastic simulations and may reduce the cost of software maintenance. An important contribution of <ref> [1] </ref> is applying their algorithm to a model of a real system, namely the F18 Mission Computer Operational Flight Program [2]. <p> Due to the importance of automated pre-run-time scheduling to the design and maintenance of hard real-time systems, we would like to clarify in this correspondence the fact that the algorithm in <ref> [1] </ref> is not guaranteed to find a feasible solution (where no process misses its deadline), when one exists. We also provide the reason why it occasionally fails. The general idea of the branch-and-bound algorithm in [1] is to minimize schedule lateness defined as the maximum process lateness over all scheduled processes. <p> systems, we would like to clarify in this correspondence the fact that the algorithm in <ref> [1] </ref> is not guaranteed to find a feasible solution (where no process misses its deadline), when one exists. We also provide the reason why it occasionally fails. The general idea of the branch-and-bound algorithm in [1] is to minimize schedule lateness defined as the maximum process lateness over all scheduled processes. <p> At each search vertex an earliest deadline first (EDF) schedule is found for each processor (subject to the defined constraints between processes), a process with the maximum lateness (the latest process) is identified, and an attempt to reduce its lateness is made. The authors of <ref> [1] </ref> argue that "to improve the lateness of the latest process in a schedule, that process must be forced to precede or preempt another process presently preceding it on the same schedule" (p. 673). This is accomplished by appropriately introducing an extra precedence or preemption constraint. <p> Each process T i has an arrival time r i , a computation time c i , and a deadline d i as shown in Table 1. To account for precedence constraints, task arrival times and deadlines are modified as described in <ref> [1] </ref>. Thus, the arrival time r 2 becomes r 2 = 0 + c 3 = 2. Similarly, the deadline d 3 becomes d 3 = 12 c 2 = 7. Assume the system has two processors, P 1 and P 2 . <p> Figure 1-a depicts the EDF schedule obtained at the root of the search. The latest process is T 2 which is scheduled after process T 1 on P 1 . The schedule is not feasible because T 2 misses its deadline. According to <ref> [1] </ref>, since T 1 has an earlier deadline than T 2 , forcing T 2 to precede or preempt T 1 can only increase schedule lateness. Thus, the root vertex cannot be expanded and the algorithm terminates with no feasible solution. <p> In general, if the latest process has predecessors on other processors it is possible to improve lateness by shifting these predecessors earlier in their schedules. This aspect was apparently overlooked by the authors of <ref> [1] </ref>. 1 To obtain the schedule in Figure 1-b we also need to permit T 1 to preempt T 2 by introducing a corresponding preemption constraint [1]. 2 Task c i r i d i T 1 4 4 11 T 3 2 0 12 Table 1: Process data. <p> This aspect was apparently overlooked by the authors of <ref> [1] </ref>. 1 To obtain the schedule in Figure 1-b we also need to permit T 1 to preempt T 2 by introducing a corresponding preemption constraint [1]. 2 Task c i r i d i T 1 4 4 11 T 3 2 0 12 Table 1: Process data. It is conjectured that one way to fix this flaw is to extend the notion of a contiguous set, used in [1], to span over multiple processors 2 <p> by introducing a corresponding preemption constraint <ref> [1] </ref>. 2 Task c i r i d i T 1 4 4 11 T 3 2 0 12 Table 1: Process data. It is conjectured that one way to fix this flaw is to extend the notion of a contiguous set, used in [1], to span over multiple processors 2 . The contiguous set, as defined in [1], is the set of all processes immediately preceding the latest process on the same processor in a continuous execution sequence (including the latest process itself). <p> It is conjectured that one way to fix this flaw is to extend the notion of a contiguous set, used in <ref> [1] </ref>, to span over multiple processors 2 . The contiguous set, as defined in [1], is the set of all processes immediately preceding the latest process on the same processor in a continuous execution sequence (including the latest process itself). The branching function considers rescheduling only the processes in the contiguous set, all of which are on the same processor with the latest process. <p> This allows the branching function to modify schedules of other processors when rescheduling processes in the contiguous set. Further intuition behind this definition is described in [3]. It should be noted that [3] does not supersede the algorithm in <ref> [1] </ref> because it attempts to solve a slightly different multiprocessor scheduling problem. While [3] allows processes to run/resume on any processor, [1] assumes a static process-to-processor assignment which is an extra constraint. Also, [3] considers non-preemptive scheduling, while [1] allows preemption. <p> Further intuition behind this definition is described in [3]. It should be noted that [3] does not supersede the algorithm in <ref> [1] </ref> because it attempts to solve a slightly different multiprocessor scheduling problem. While [3] allows processes to run/resume on any processor, [1] assumes a static process-to-processor assignment which is an extra constraint. Also, [3] considers non-preemptive scheduling, while [1] allows preemption. <p> It should be noted that [3] does not supersede the algorithm in <ref> [1] </ref> because it attempts to solve a slightly different multiprocessor scheduling problem. While [3] allows processes to run/resume on any processor, [1] assumes a static process-to-processor assignment which is an extra constraint. Also, [3] considers non-preemptive scheduling, while [1] allows preemption.
Reference: [2] <author> T. Shepard and M. Gagne, </author> <title> "A model of the f-18 mission computer software for pre-run-time scheduling," </title> <booktitle> in IEEE 10th International Conference on Distributed Computing Systems, </booktitle> <address> Paris, France, </address> <month> May </month> <year> 1990. </year>
Reference-contexts: This approach eliminates the need for fine tuning the code via repeated stochastic simulations and may reduce the cost of software maintenance. An important contribution of [1] is applying their algorithm to a model of a real system, namely the F18 Mission Computer Operational Flight Program <ref> [2] </ref>. Due to the importance of automated pre-run-time scheduling to the design and maintenance of hard real-time systems, we would like to clarify in this correspondence the fact that the algorithm in [1] is not guaranteed to find a feasible solution (where no process misses its deadline), when one exists.
Reference: [3] <author> J. Xu, </author> <title> "Multiprocessor scheduling of processes with release times, deadlines, precedence and exclusion relations," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 19, no. 2, </volume> , <month> February </month> <year> 1993. </year> <title> 2 The application of this idea to the algorithm in [1] was suggested by one of the referees reviewing an earlier version of this correspondence. </title> <type> 3 4 </type>
Reference-contexts: The branching function considers rescheduling only the processes in the contiguous set, all of which are on the same processor with the latest process. A pre-run-time multiprocessor scheduling algorithm which uses the extended notion of the contiguous set is proposed in <ref> [3] </ref>. It defines it as a set Z [l] of all processes in the period preceding and including the latest process such that within that period there does not exist any time where all processors are idle. <p> This allows the branching function to modify schedules of other processors when rescheduling processes in the contiguous set. Further intuition behind this definition is described in <ref> [3] </ref>. It should be noted that [3] does not supersede the algorithm in [1] because it attempts to solve a slightly different multiprocessor scheduling problem. While [3] allows processes to run/resume on any processor, [1] assumes a static process-to-processor assignment which is an extra constraint. Also, [3] considers non-preemptive scheduling, while <p> This allows the branching function to modify schedules of other processors when rescheduling processes in the contiguous set. Further intuition behind this definition is described in <ref> [3] </ref>. It should be noted that [3] does not supersede the algorithm in [1] because it attempts to solve a slightly different multiprocessor scheduling problem. While [3] allows processes to run/resume on any processor, [1] assumes a static process-to-processor assignment which is an extra constraint. Also, [3] considers non-preemptive scheduling, while [1] allows preemption. <p> Further intuition behind this definition is described in <ref> [3] </ref>. It should be noted that [3] does not supersede the algorithm in [1] because it attempts to solve a slightly different multiprocessor scheduling problem. While [3] allows processes to run/resume on any processor, [1] assumes a static process-to-processor assignment which is an extra constraint. Also, [3] considers non-preemptive scheduling, while [1] allows preemption. <p> definition is described in <ref> [3] </ref>. It should be noted that [3] does not supersede the algorithm in [1] because it attempts to solve a slightly different multiprocessor scheduling problem. While [3] allows processes to run/resume on any processor, [1] assumes a static process-to-processor assignment which is an extra constraint. Also, [3] considers non-preemptive scheduling, while [1] allows preemption.
References-found: 3

