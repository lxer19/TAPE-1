URL: ftp://ftp.csd.uu.se/pub/papers/reports/0115.ps.gz
Refering-URL: http://www.csd.uu.se/papers/reports.html
Root-URL: 
Email: email fd90mar,voronkovg@csd.uu.se  
Title: Semantics of Constraint Logic Programs with Bounded Quantifiers  
Author: Martin Argenius Andrei Voronkov 
Note: Supported by a TFR grant  
Address: Box 311, S-751 05 Uppsala, Sweden  
Affiliation: Computing Science Department Uppsala University  
Abstract: UPMAIL Technical Report No. 115 September 20, 1995 
Abstract-found: 1
Intro-found: 1
Reference: [Andrews 89] <author> J.H. Andrews. </author> <title> Proof-theoretic characterizations of logic programming. </title> <booktitle> In Mathematical Foundations of Computer Science, number 379 in Lecture Notes in Computer Science, </booktitle> <pages> pages 145-154, </pages> <address> Por~abka-Kozubnik, Poland, </address> <year> 1989. </year>
Reference-contexts: The natural semantics does reflect computations by CBQ-resolution, which is the main procedure to execute CBQ-programs. The natural calculus has something in common with the foundations of logic programming proposed in <ref> [HagSak 84, Andrews 89, HalSch 90] </ref>. Definition 3.14 (Calculus Nat (P)) The provable objects of the calculus Nat (P) are closed -formulas of the language L. Its inference rules are shown in Figure 3.2.
Reference: [BarHil 95] <author> J. Barklund and P.M. Hill. </author> <title> Extending Godel for expressing restricted quantification and arrays. </title> <type> UPMAIL Technical Report 102, </type> <institution> Uppsala University, Computing Science Department, </institution> <month> March </month> <year> 1995. </year>
Reference-contexts: Those papers study the expressive power and practical applications of languages with collection types. Bounded quantification over hereditarily finite sets is introduced in [DOPR 91]. In that paper sets are added to logic programming using a special set unification algorithm. In <ref> [BarMil 92, BarHil 95] </ref> a limited version of bounded quantification (lists of a fixed length only) has been introduced to Prolog and Godel. The motivation was to provide a support for arrays, and in particular for their parallel processing. General constraints over finite sets are considered in [Kozen 95].
Reference: [BarMil 92] <author> J. Barklund and H. Millroth. </author> <title> Providing iteration and concurrency in logic programs through bounded quantifications. </title> <booktitle> In Proc. of the International Conference on Fifth Generation Computer Systems, </booktitle> <pages> pages 817-824, </pages> <address> Tokyo, 1992. </address> <publisher> ICOT. </publisher>
Reference-contexts: Those papers study the expressive power and practical applications of languages with collection types. Bounded quantification over hereditarily finite sets is introduced in [DOPR 91]. In that paper sets are added to logic programming using a special set unification algorithm. In <ref> [BarMil 92, BarHil 95] </ref> a limited version of bounded quantification (lists of a fixed length only) has been introduced to Prolog and Godel. The motivation was to provide a support for arrays, and in particular for their parallel processing. General constraints over finite sets are considered in [Kozen 95].
Reference: [BNRST 87] <author> C. Beeri, Sh. Naqvi, R. Ramakrishnan, O. Shmueli, and Sh. Tsur. </author> <title> Sets and negation in a logic database language (LDL1). </title> <booktitle> In Proc. 6th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 21-36. </pages> <publisher> ACM Press, </publisher> <year> 1987. </year>
Reference: [BNST 91] <author> C. Beeri, S. Naqvi, O. Schmueli, and S. Tsur. </author> <title> Set constructors in a logic database language. </title> <journal> Journal of Logic Programming, </journal> <volume> 10 </volume> <pages> 181-232, </pages> <year> 1991. </year>
Reference: [Clark 78] <author> K.L. Clark. </author> <title> Negation as failure. </title> <editor> In H. Gallaire and J. Minker, editors, </editor> <booktitle> Logic and Data Base, </booktitle> <pages> pages 293-322. </pages> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: set of formulas f' i P ( t i ) j i 2 f1; : : : ; ngg, denoted P ( t 1 ) :- ' 1 P ( t n ) :- ' n This notation is similar to the translation used in the completion of logic programs <ref> [Clark 78] </ref>. We call such formulas clauses and often alternatively consider a CBQ-program as a finite set of clauses. 4 Following the Prolog syntax, we shall sometimes terminate clauses or predicate definitions with a period. A formal semantics of bounded quantifiers will be introduced in Section 3.
Reference: [DOPR 91] <author> A. Dovier, E.G. Omodeo, E. Pontelli, and G. Rossi. flogg: </author> <title> A logic programming language with finite sets. </title> <booktitle> In Proc. ICLP'91, </booktitle> <pages> pages 109-124. </pages> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: Sets and other collection types were also considered in the database-related papers [BNRST 87, BNST 91, ScTsZa 92, GruMil 93, Wong 93, Vadaparty 94]. Those papers study the expressive power and practical applications of languages with collection types. Bounded quantification over hereditarily finite sets is introduced in <ref> [DOPR 91] </ref>. In that paper sets are added to logic programming using a special set unification algorithm. In [BarMil 92, BarHil 95] a limited version of bounded quantification (lists of a fixed length only) has been introduced to Prolog and Godel.
Reference: [GaDoLe 95] <author> M. Gabbrielli, G.M. Dore, and G. Levi. </author> <title> Observable semantics for constraint logic programs. </title> <journal> Journal of Logic and Computation, </journal> <volume> 5(2) </volume> <pages> 133-171, </pages> <year> 1995. </year>
Reference-contexts: Any substitution that makes the answer constraint true is a correct answer substitution. This semantics is not oriented to a particular collection of built-in relations R i , but rather to a general constraint logic programming scheme. The definitions and notations used here are similar to those in <ref> [GaDoLe 95] </ref>. The difference comes out in bounded quantification. <p> General constraints over finite sets are considered in [Kozen 95]. The semantics of constraint logic programs were described in many papers (see the recent survey [JafMah 94]). Our presentation is very similar to that of <ref> [GaDoLe 95] </ref>, except for the handling of bounded quantifiers and a slightly different treatment of bound variables in constraints. The operational semantics for finite domains that is similar to our semantics is introduced in the form of cardinality operators of [VaSiDi 92, VaSaDe 95].
Reference: [GoErSv 86] <editor> S.S. Goncharov, Yu.L. Ershov, and D.I. Sviridenko. </editor> <booktitle> Semantic programming. In IFIP'86, </booktitle> <pages> pages 1093-1100. </pages> <publisher> Elsevier Science, </publisher> <year> 1986. </year>
Reference-contexts: In <ref> [GonSvi 85, GonSvi 86, GoErSv 86] </ref> the concept of -programs have been defined using -formulas. The model-theoretic and the fixpoint semantics of our paper are very similar to those of [GonSvi 85, GonSvi 86, GoErSv 86]. <p> In <ref> [GonSvi 85, GonSvi 86, GoErSv 86] </ref> the concept of -programs have been defined using -formulas. The model-theoretic and the fixpoint semantics of our paper are very similar to those of [GonSvi 85, GonSvi 86, GoErSv 86]. In [Kuper 87, Kuper 90] it is shown how to integrate (flat) finite sets in logic programming with the idea of database applications.
Reference: [GonSvi 85] <author> S.S. Goncharov and D.I. Sviridenko. </author> <title> -programming (in Russian). </title> <booktitle> volume 120 of Vychis-litelnye Systemy, </booktitle> <pages> pages 3-29. </pages> <address> Novosibirsk, </address> <year> 1985. </year>
Reference-contexts: In <ref> [GonSvi 85, GonSvi 86, GoErSv 86] </ref> the concept of -programs have been defined using -formulas. The model-theoretic and the fixpoint semantics of our paper are very similar to those of [GonSvi 85, GonSvi 86, GoErSv 86]. <p> In <ref> [GonSvi 85, GonSvi 86, GoErSv 86] </ref> the concept of -programs have been defined using -formulas. The model-theoretic and the fixpoint semantics of our paper are very similar to those of [GonSvi 85, GonSvi 86, GoErSv 86]. In [Kuper 87, Kuper 90] it is shown how to integrate (flat) finite sets in logic programming with the idea of database applications.
Reference: [GonSvi 86] <author> S.S. Goncharov and D.I. Sviridenko. </author> <title> Theoretical aspects of -programming. In Mathematical Methods of Specification and Synthesis of Software Systems'85, </title> <booktitle> volume 215 of Lecture Notes in Computer Science, </booktitle> <pages> pages 169-179, </pages> <year> 1986. </year>
Reference-contexts: In <ref> [GonSvi 85, GonSvi 86, GoErSv 86] </ref> the concept of -programs have been defined using -formulas. The model-theoretic and the fixpoint semantics of our paper are very similar to those of [GonSvi 85, GonSvi 86, GoErSv 86]. <p> In <ref> [GonSvi 85, GonSvi 86, GoErSv 86] </ref> the concept of -programs have been defined using -formulas. The model-theoretic and the fixpoint semantics of our paper are very similar to those of [GonSvi 85, GonSvi 86, GoErSv 86]. In [Kuper 87, Kuper 90] it is shown how to integrate (flat) finite sets in logic programming with the idea of database applications.
Reference: [GruMil 93] <author> S. Grumbach and T. Milo. </author> <title> Towards tractable algebras for bags. </title> <booktitle> In ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 49-58, </pages> <year> 1993. </year>
Reference: [HagSak 84] <author> M. Hagiya and T. Sakurai. </author> <title> Foundation of logic programming based on inductive definition. </title> <journal> New Generation Computing, </journal> <volume> 2(1) </volume> <pages> 59-77, </pages> <year> 1984. </year>
Reference-contexts: The natural semantics does reflect computations by CBQ-resolution, which is the main procedure to execute CBQ-programs. The natural calculus has something in common with the foundations of logic programming proposed in <ref> [HagSak 84, Andrews 89, HalSch 90] </ref>. Definition 3.14 (Calculus Nat (P)) The provable objects of the calculus Nat (P) are closed -formulas of the language L. Its inference rules are shown in Figure 3.2.
Reference: [HalSch 90] <author> L. Hallnas and P. Schroeder-Heister. </author> <title> A proof-theoretic approach to logic programming I. Clauses as rules. </title> <journal> Journal of Logic and Computation, </journal> <volume> 1(2), </volume> <year> 1990. </year> <month> 21 </month>
Reference-contexts: The natural semantics does reflect computations by CBQ-resolution, which is the main procedure to execute CBQ-programs. The natural calculus has something in common with the foundations of logic programming proposed in <ref> [HagSak 84, Andrews 89, HalSch 90] </ref>. Definition 3.14 (Calculus Nat (P)) The provable objects of the calculus Nat (P) are closed -formulas of the language L. Its inference rules are shown in Figure 3.2.
Reference: [JafMah 94] <author> J. Jaffar and M. Maher. </author> <title> Constraint logic programming: a survey. </title> <journal> Journal of Logic Pro--gramming, </journal> <volume> 19,20:503-581, </volume> <year> 1994. </year>
Reference-contexts: The motivation was to provide a support for arrays, and in particular for their parallel processing. General constraints over finite sets are considered in [Kozen 95]. The semantics of constraint logic programs were described in many papers (see the recent survey <ref> [JafMah 94] </ref>). Our presentation is very similar to that of [GaDoLe 95], except for the handling of bounded quantifiers and a slightly different treatment of bound variables in constraints.
Reference: [Kozen 95] <author> D. Kozen. </author> <title> Rational spaces and set constraints. </title> <editor> In P.D. Mosses, M. Nielsen, and M.I. Schwartzbach, editors, TAPSOFT'95: </editor> <booktitle> Theory and Practice of Software Development, volume 915 of Lecture Notes in Computer Science, </booktitle> <pages> pages 42-61. </pages> <publisher> Springer Verlag, </publisher> <year> 1995. </year>
Reference-contexts: In [BarMil 92, BarHil 95] a limited version of bounded quantification (lists of a fixed length only) has been introduced to Prolog and Godel. The motivation was to provide a support for arrays, and in particular for their parallel processing. General constraints over finite sets are considered in <ref> [Kozen 95] </ref>. The semantics of constraint logic programs were described in many papers (see the recent survey [JafMah 94]). Our presentation is very similar to that of [GaDoLe 95], except for the handling of bounded quantifiers and a slightly different treatment of bound variables in constraints.
Reference: [Kuper 87] <author> G.M. Kuper. </author> <title> Logic programming with sets. </title> <booktitle> In Proc. 6th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 11-20. </pages> <publisher> ACM Press, </publisher> <year> 1987. </year>
Reference-contexts: In [GonSvi 85, GonSvi 86, GoErSv 86] the concept of -programs have been defined using -formulas. The model-theoretic and the fixpoint semantics of our paper are very similar to those of [GonSvi 85, GonSvi 86, GoErSv 86]. In <ref> [Kuper 87, Kuper 90] </ref> it is shown how to integrate (flat) finite sets in logic programming with the idea of database applications. Sets and other collection types were also considered in the database-related papers [BNRST 87, BNST 91, ScTsZa 92, GruMil 93, Wong 93, Vadaparty 94].
Reference: [Kuper 90] <author> G.M. Kuper. </author> <title> Logic programming with sets. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 41 </volume> <pages> 44-64, </pages> <year> 1990. </year>
Reference-contexts: In [GonSvi 85, GonSvi 86, GoErSv 86] the concept of -programs have been defined using -formulas. The model-theoretic and the fixpoint semantics of our paper are very similar to those of [GonSvi 85, GonSvi 86, GoErSv 86]. In <ref> [Kuper 87, Kuper 90] </ref> it is shown how to integrate (flat) finite sets in logic programming with the idea of database applications. Sets and other collection types were also considered in the database-related papers [BNRST 87, BNST 91, ScTsZa 92, GruMil 93, Wong 93, Vadaparty 94].
Reference: [ScTsZa 92] <author> O. Schmueli, S. Tsur, and C. Zaniolo. </author> <title> Compilation of set terms in the logic data language (LDL). </title> <journal> Journal of Logic Programming, </journal> <volume> 12 </volume> <pages> 89-119, </pages> <year> 1992. </year>
Reference: [Vadaparty 94] <author> K. Vadaparty. </author> <title> On the power of rule-based languages for nested data models. </title> <journal> Journal of Logic Programming, </journal> <volume> 21 </volume> <pages> 155-175, </pages> <year> 1994. </year>
Reference: [VaSaDe 95] <author> P. Van Hentenryck, W. Saraswat, and Y. Deville. </author> <title> Design, implementation and evaluation of the constraint language cc(fd). </title> <editor> In A. Podelski, editor, </editor> <title> Constraint Programming: Basics and Tools, </title> <booktitle> volume 910 of Lecture Notes in Computer Science, </booktitle> <pages> pages 293-316. </pages> <publisher> Springer Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Our presentation is very similar to that of [GaDoLe 95], except for the handling of bounded quantifiers and a slightly different treatment of bound variables in constraints. The operational semantics for finite domains that is similar to our semantics is introduced in the form of cardinality operators of <ref> [VaSiDi 92, VaSaDe 95] </ref>. Our paper is different from the above mentioned papers in the systematic treatment of logic programming both with constraints and bounded quantifiers. As a consequence, we obtain a uniform semantics for handling constraints both over finite and infinite domains. <p> As a consequence, we obtain a uniform semantics for handling constraints both over finite and infinite domains. With some modifications, we can apply our semantics to characterize existing constraint logic programming languages, like cc (FD) of <ref> [VaSiDi 92, VaSaDe 95] </ref>. For example, the cardinality operators may be described as bounded quantifiers like 9 n ', although for their correct treatment one needs to consider negation which is outside of the scope of this paper. Our presentation was not bound to any particular domain.
Reference: [VaSiDi 92] <author> P. Van Hentenryck, H. Simonis, and M. Dincbas. </author> <title> Constraint satisfaction using constraint logic programming. </title> <journal> Artificial Intelligence, </journal> <volume> 58 </volume> <pages> 113-159, </pages> <year> 1992. </year>
Reference-contexts: Our presentation is very similar to that of [GaDoLe 95], except for the handling of bounded quantifiers and a slightly different treatment of bound variables in constraints. The operational semantics for finite domains that is similar to our semantics is introduced in the form of cardinality operators of <ref> [VaSiDi 92, VaSaDe 95] </ref>. Our paper is different from the above mentioned papers in the systematic treatment of logic programming both with constraints and bounded quantifiers. As a consequence, we obtain a uniform semantics for handling constraints both over finite and infinite domains. <p> As a consequence, we obtain a uniform semantics for handling constraints both over finite and infinite domains. With some modifications, we can apply our semantics to characterize existing constraint logic programming languages, like cc (FD) of <ref> [VaSiDi 92, VaSaDe 95] </ref>. For example, the cardinality operators may be described as bounded quantifiers like 9 n ', although for their correct treatment one needs to consider negation which is outside of the scope of this paper. Our presentation was not bound to any particular domain.
Reference: [Voronkov 92] <author> A. Voronkov. </author> <title> Logic programming with bounded quantifiers. </title> <editor> In A. Voronkov, editor, </editor> <booktitle> Logic Programming, volume 592 of Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 486-514. </pages> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Introduction Constraint logic programming is a declarative extension of Horn clause logic programming. In <ref> [Voronkov 92, Voronkov 95] </ref> the second author defined another declarative extension of Horn clause logic programming by bounded quantifiers. Bounded quantifiers allow one to naturally express the search over finite domains. In this paper we show how to include bounded quantifiers into the constraint logic programming paradigm. <p> For the pure logic programming case (the only built-in predicate is equality =) we proved in <ref> [Voronkov 92, Voronkov 95] </ref> that there are CBQ-programs, consisting of only one nonrecursive definition, which can express arbitrary computable sets of ground terms. For such programs the least fixpoint construction stabilizes on the first step (I 1 ), which does not correspond to real computations.
Reference: [Voronkov 95] <author> A. Voronkov. </author> <title> Logic programming with bounded quantifiers revisited. </title> <type> UPMAIL Technical Report 114, </type> <institution> Uppsala University, Computing Science Department, </institution> <month> September </month> <year> 1995. </year>
Reference-contexts: Introduction Constraint logic programming is a declarative extension of Horn clause logic programming. In <ref> [Voronkov 92, Voronkov 95] </ref> the second author defined another declarative extension of Horn clause logic programming by bounded quantifiers. Bounded quantifiers allow one to naturally express the search over finite domains. In this paper we show how to include bounded quantifiers into the constraint logic programming paradigm. <p> Then we can use the following specification: 1 good enterprise (E) :- enterprise (E), (8X 2 E)(9B 2 E)boss of (X; B). This specification using bounded quantifiers can be executed using BQ-resolution defined in <ref> [Voronkov 95] </ref>. The usual way of treating such a problem in constraint logic programming with finite domains is to introduce the (finite) domain E and restrict the variables X and B to this domain. Using the unbounded existencial quantifier, we can also include infinite domains. <p> We can even use the following clause good enterprise (E) :- (8X 2 E)(9B 2 E)boss of (X; B). with the purpose of constructing arbitrary lists of persons that form a good enterprise. The paper <ref> [Voronkov 95] </ref> discusses the use of bounded quantifiers in logic programming. This paper extends the results of [Voronkov 95] to constraint logic programming. We only treat semantics and a procedural interpretation in this paper. The results on the expressive power and on negation from [Voronkov 95] could also be straightforwardly generalized <p> The paper <ref> [Voronkov 95] </ref> discusses the use of bounded quantifiers in logic programming. This paper extends the results of [Voronkov 95] to constraint logic programming. We only treat semantics and a procedural interpretation in this paper. The results on the expressive power and on negation from [Voronkov 95] could also be straightforwardly generalized to constraint logic programs. <p> The paper <ref> [Voronkov 95] </ref> discusses the use of bounded quantifiers in logic programming. This paper extends the results of [Voronkov 95] to constraint logic programming. We only treat semantics and a procedural interpretation in this paper. The results on the expressive power and on negation from [Voronkov 95] could also be straightforwardly generalized to constraint logic programs. In Section 2 we give the basic definitions of sorts, lists and CBQ-programs, i.e. constraint logic programs with bounded quantifiers. In Section 3 we introduce several semantics of logic programs with bounded quantifiers and prove their equivalence. <p> Since all formulas in P fl are provable in Clt (P), we have Clt (P) ` '. 2 The provability semantics here is based on classical logic. We can also define the sound and complete constructive provability semantics for CBQ-programs based on intuitionistic logic in the way similar to <ref> [Voronkov 95] </ref>. 3.4 The natural semantics The natural semantics of this section is based on the natural calculus. The rules of the natural calculus treat -formulas in a simple and elegant way. The calculus Nat (P) introduced below is similar to the ground positive hyperresolution on Horn clauses. <p> For the pure logic programming case (the only built-in predicate is equality =) we proved in <ref> [Voronkov 92, Voronkov 95] </ref> that there are CBQ-programs, consisting of only one nonrecursive definition, which can express arbitrary computable sets of ground terms. For such programs the least fixpoint construction stabilizes on the first step (I 1 ), which does not correspond to real computations. <p> Results of this paper can be extended to such integer intervals as well, with the difference that integers are considered as a predefined sort. Other applications of bounded quantifiers in logic programming are considered in <ref> [Voronkov 95] </ref>. 20
Reference: [Wong 93] <author> L. Wong. </author> <title> Normal forms and conservative properties for query languages over collection types. </title> <booktitle> In ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 26-36, </pages> <year> 1993. </year> <month> 22 </month>
References-found: 25

