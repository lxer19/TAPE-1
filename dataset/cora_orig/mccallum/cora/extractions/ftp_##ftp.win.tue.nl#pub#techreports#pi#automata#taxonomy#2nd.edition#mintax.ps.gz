URL: ftp://ftp.win.tue.nl/pub/techreports/pi/automata/taxonomy/2nd.edition/mintax.ps.gz
Refering-URL: http://www.win.tue.nl/cs/pa/research/tax-n-tool.html
Root-URL: http://www.win.tue.nl
Email: e-mail: watson@win.tue.nl  
Phone: Tel: +31 40 474319  
Title: A taxonomy of finite automata minimization algorithms  
Author: Bruce W. Watson 
Note: Reprinted with corrections.  
Address: P.O. Box 513, 5600 MB Eindhoven The Netherlands  
Affiliation: Faculty of Mathematics and Computing Science Eindhoven University of Technology  
Abstract: This paper presents a taxonomy of finite automata minimization algorithms. Brzozowski's elegant minimization algorithm differs from all other known minimization algorithms, and is derived separately. All of the remaining algorithms depend upon computing an equivalence relation on states. We define the equivalence relation, the partition that it induces, and its complement. Additionally, some useful properties are derived. It is shown that the equivalence relation is the greatest fixed point of an equation, providing a useful characterization of the required computation. We derive an upperbound on the number of approximation steps required to compute the fixed point. Algorithms computing the equivalence relation (or the partition, or its complement) are derived systematically in the same framework. The algorithms include Hopcroft's, several algorithms from text-books (including Hopcroft and Ullman's [HU79], Wood's [Wood87], and Aho, Sethi, and Ullman's [ASU86]), and several new algorithms or variants of existing algorithms. 
Abstract-found: 1
Intro-found: 1
Reference: [ASU86] <author> Aho, A.V., R. Sethi, and J.D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools, </booktitle> <publisher> Addison-Wesley Publishing Co., </publisher> <address> Reading, M.A., </address> <year> 1988. </year>
Reference-contexts: This algorithm does not appear in the literature. When we convert the above algorithm to compute [Q] E , the resulting algorithm is the following one, given by Aho, Sethi, and Ullman in <ref> [ASU86, Alg. 3.6] </ref>: Algorithm 4.4: P := [Q] E 0 ; finvariant: [Q] E v P v [Q] E 0 g do (9 Q 0 ; Q 1 ; a : Q 0 2 P ^ Q 1 2 P ^ a 2 V : Splittable (Q 0 ; Q 1
Reference: [AU92] <author> Aho, A.V. and J.D. Ullman. </author> <booktitle> Foundations of Computer Science, </booktitle> <publisher> Computer Science Press, </publisher> <address> New York, N.Y. </address> <year> 1992. </year>
Reference: [Brau88] <author> Brauer, W. </author> <title> "On minimizing finite automata," </title> <journal> EATCS Bulletin 35, </journal> <month> June </month> <year> 1988. </year>
Reference-contexts: According to Wood, it is based on the work of Moore [Moor56]. Its running times is O (jQj 3 ). Brauer uses some encoding techniques to provide an O (jQj 2 ) version of this algorithm in <ref> [Brau88] </ref>, while Urbanek improves upon the space requirements of Brauer's version in [Urba89]. None of these variants is given here. The algorithm computing only D does not appear in the literature.
Reference: [Brzo62] <author> Brzozowski, J.A. </author> <title> "Canonical regular expressions and minimal state graphs for definite events," </title> <booktitle> in Mathematical theory of Automata, Vol. 12 of MRI Symposia Series, </booktitle> <pages> pp. 529-561, </pages> <institution> Polytechnic Press, Polytechnic Institute of Brooklyn, </institution> <address> N.Y., </address> <year> 1962. </year>
Reference-contexts: The complete minimization algorithm (for any *-free M 0 2 FA) is M 2 = useful s ffi subsetopt ffi R ffi useful s ffi subsetopt ffi R (M 0 ) This algorithm was originally given by Brzozowski in <ref> [Brzo62] </ref>. The origin of this algorithm was obscured when Jan van de Snepscheut presented the algorithm in his Ph.D thesis [vdSn85]. In this thesis, the algorithm is attributed to a private communication from Prof. Peremans of the Eindhoven University of Technology.
Reference: [Brzo64] <author> Brzozowski, J.A. </author> <title> "Derivatives of regular expressions," </title> <editor> J. </editor> <booktitle> ACM 11(4): </booktitle> <pages> 481-494, </pages> <year> 1964. </year>
Reference-contexts: In this thesis, the algorithm is attributed to a private communication from Prof. Peremans of the Eindhoven University of Technology. Peremans had originally found the algorithm in an article by Mirkin [Mirk65]. Although Mirkin does cite a paper by Brzozowski <ref> [Brzo64] </ref>, it is not clear whether Mirkin's work was influenced by Brzozowki's work on minimization.
Reference: [Dijk76] <author> Dijkstra, </author> <title> E.W. A discipline of programming, </title> <publisher> Prentice-Hall Inc., </publisher> <address> N.J., </address> <year> 1976. </year> <title> [t-Ei91] ten Eikelder, H.M.M. "Some algorithms to decide the equivalence of recursive types," </title> <note> Computing Science Note 91/31, </note> <institution> Eindhoven University of Technology, </institution> <address> The Netherlands, </address> <year> 1991. </year>
Reference: [Grie73] <author> Gries, D. </author> <title> "Describing an algorithm by Hopcroft," </title> <journal> Acta Inf. </journal> <volume> 2: </volume> <pages> 97-109, </pages> <year> 1973. </year>
Reference-contexts: This algorithm (Algorithm 4.7) computes the inequivalence (distinguishability) relation. Although it is based upon the algorithms of Huffman and Moore [Huff54, Moor56], this algorithm uses some interesting encoding techniques. * Hopcroft's algorithm as presented in <ref> [Hopc71, Grie73] </ref>. This algorithm (Algorithm 4.8) is the best known algorithm (in terms of running time analysis) for minimization. As the original presentation by Hopcroft is difficult to understand, the presentation in this paper is based upon the one given by Gries. * Pointwise computation of equivalence. <p> It is possible to modify the above algorithm to compute E. Such an algorithm does not appear in the literature. 4.5 Hopcroft's algorithm to compute [Q] E efficiently We now derive an efficient algorithm due to Hopcroft [Hopc71]. This algorithm has also been derived by Gries <ref> [Grie73] </ref>. This algorithm presently has the best known running time analysis of all DFA minimization algorithms. We begin with Algorithm 4.6. Recall that the inner repetition "splits" each equivalence class Q 0 with respect to pair (Q 1 ; a). <p> observation (due to Hopcroft) is that once all equivalence classes have been split with respect to a particular (Q 1 ; a), no equivalence classes need to be split with respect to the same (Q 1 ; a) on any subsequent iteration step of the outer repetition [Hopc71, pp. 190-191], <ref> [Grie73, Lemma 5] </ref>. <p> We will then split the equivalence classes with respect to elements of L. In the original presentations of this algorithm <ref> [Hopc71, Grie73] </ref>, L is a list. As this is not necessary, we retain L's type as a set. <p> Q 0 0 ; b) and (Q 0 Another observation due to Hopcroft is that splitting an equivalence class with respect to any two of (Q 0 ; b), (Q 0 0 ; b) is the same as splitting the equivalence class with respect to all three [Hopc71, pp. 190-191], <ref> [Grie73, Lemma 6] </ref>. This is shown in the following intermezzo. <p> As a result, we need only split with respect to either (Q n F; b) or (F; b) (for all b 2 V ) [Hopc71, pp. 190-191], <ref> [Grie73, Lemma 7] </ref>. <p> It is shown by both Hopcroft and Gries that it is O (jQj log jQj), <ref> [Grie73, Hopc71] </ref>. 4 Part of the invariant has been omitted, being rather complicated to derive. 4 ALGORITHMS COMPUTING E, D, OR [Q] E 15 4.6 Computing (p; q) 2 E From the problem of deciding the structural equivalence of two types, it is known that equivalence of two states can be <p> ^ T (s; w) = q (respectively T (p; w) = r ^ T (q; w) = s), then r; s are also distinguished (respectively equivalent). 4 ALGORITHMS COMPUTING E, D, OR [Q] E 17 This algorithm has worse running time than the O (jQj log jQj) of Hopcroft's algorithm <ref> [Hopc71, Grie73] </ref>. This algorithm has a significant advantage over all of the known algorithms: although function equiv computes E pointwise from above (with respect to , refinement), the main program computes E from below (with respect to , normal set inclusion 5 ). <p> Our presentation highlights the fact that the main data-structure in the algorithm need not be a list | a set suffices. * Hopcroft's minimization algorithm [Hopc71] was originally presented in a style that is not very understandable. As with Gries's paper <ref> [Grie73] </ref>, we strive to derive this algorithm in a clear and precise manner.
Reference: [HU79] <author> Hopcroft, J.E. and J.D. Ullman. </author> <title> Introduction to Automata Theory, Languages, and Computation, </title> <publisher> Addison-Wesley Publishing Co., </publisher> <address> Reading, M.A., </address> <year> 1979. </year>
Reference-contexts: This algorithm (Algorithm 4.6, not appearing in the literature) is a modification of the above algorithm to compute the equivalence classes of states. This algorithm is used in the derivation of Hopcroft's minimization algorithm. * Hopcroft and Ullman's algorithm as presented in <ref> [HU79] </ref>. This algorithm (Algorithm 4.7) computes the inequivalence (distinguishability) relation. Although it is based upon the algorithms of Huffman and Moore [Huff54, Moor56], this algorithm uses some interesting encoding techniques. * Hopcroft's algorithm as presented in [Hopc71, Grie73]. <p> 2 V : T (p; a) 6= T (q; a) do L (T (p; a); T (q; a)) := L (T (p; a); T (q; a)) [ f (p; q)g fi roffG = Dg This algorithm has running time O (jQj 2 ) and is given by Hopcroft and Ullman <ref> [HU79, Fig. 3.8] </ref>. In [HU79] it is attributed to Huffman [Huff54] and Moore [Moor56]. In their description, Hopcroft and Ullman describe L as mapping each pair of states to a list of pairs of states. The list data-type is not required here, and a set is used instead. <p> In <ref> [HU79] </ref> it is attributed to Huffman [Huff54] and Moore [Moor56]. In their description, Hopcroft and Ullman describe L as mapping each pair of states to a list of pairs of states. The list data-type is not required here, and a set is used instead. <p> Most of them were shown to be essentially the same, with minor differences in their loop structures. One exception was Hopcroft and Ullman's algorithm <ref> [HU79] </ref>, which has a distinctly different loop structure. The presentation of that algorithm (with invariants) in this paper is arguably easier to understand than the original presentation. <p> Introductory presentations of the theorem appear in <ref> [HU79, Wats93] </ref>. 2 Property B.21 (An alternate definition of minimality of a DFA): For the purposes of minimizing a DFA, we use the definition (defined only on DFA's): Minimal (Q; V; T; ;; S; F ) j (8 q 0 ; q 1 : q 0 2 Q ^ q 1
Reference: [Hopc71] <author> Hopcroft, </author> <title> J.E. "An n log n algorithm for minimizing the states in a finite automaton," in The Theory of Machines and Computations (Z. Kohavi, </title> <publisher> ed.), </publisher> <pages> pp. 189-196, </pages> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1971. </year>
Reference-contexts: This algorithm (Algorithm 4.7) computes the inequivalence (distinguishability) relation. Although it is based upon the algorithms of Huffman and Moore [Huff54, Moor56], this algorithm uses some interesting encoding techniques. * Hopcroft's algorithm as presented in <ref> [Hopc71, Grie73] </ref>. This algorithm (Algorithm 4.8) is the best known algorithm (in terms of running time analysis) for minimization. As the original presentation by Hopcroft is difficult to understand, the presentation in this paper is based upon the one given by Gries. * Pointwise computation of equivalence. <p> It is possible to modify the above algorithm to compute E. Such an algorithm does not appear in the literature. 4.5 Hopcroft's algorithm to compute [Q] E efficiently We now derive an efficient algorithm due to Hopcroft <ref> [Hopc71] </ref>. This algorithm has also been derived by Gries [Grie73]. This algorithm presently has the best known running time analysis of all DFA minimization algorithms. We begin with Algorithm 4.6. Recall that the inner repetition "splits" each equivalence class Q 0 with respect to pair (Q 1 ; a). <p> An observation (due to Hopcroft) is that once all equivalence classes have been split with respect to a particular (Q 1 ; a), no equivalence classes need to be split with respect to the same (Q 1 ; a) on any subsequent iteration step of the outer repetition <ref> [Hopc71, pp. 190-191] </ref>, [Grie73, Lemma 5]. <p> We will then split the equivalence classes with respect to elements of L. In the original presentations of this algorithm <ref> [Hopc71, Grie73] </ref>, L is a list. As this is not necessary, we retain L's type as a set. <p> (Q 0 n Q 0 0 ; b) and (Q 0 Another observation due to Hopcroft is that splitting an equivalence class with respect to any two of (Q 0 ; b), (Q 0 0 ; b) is the same as splitting the equivalence class with respect to all three <ref> [Hopc71, pp. 190-191] </ref>, [Grie73, Lemma 6]. This is shown in the following intermezzo. <p> Lastly, we observe that by starting with P = [Q] E 0 = fQ n F; F g we have already split Q. As a result, we need only split with respect to either (Q n F; b) or (F; b) (for all b 2 V ) <ref> [Hopc71, pp. 190-191] </ref>, [Grie73, Lemma 7]. <p> It is shown by both Hopcroft and Gries that it is O (jQj log jQj), <ref> [Grie73, Hopc71] </ref>. 4 Part of the invariant has been omitted, being rather complicated to derive. 4 ALGORITHMS COMPUTING E, D, OR [Q] E 15 4.6 Computing (p; q) 2 E From the problem of deciding the structural equivalence of two types, it is known that equivalence of two states can be <p> ^ T (s; w) = q (respectively T (p; w) = r ^ T (q; w) = s), then r; s are also distinguished (respectively equivalent). 4 ALGORITHMS COMPUTING E, D, OR [Q] E 17 This algorithm has worse running time than the O (jQj log jQj) of Hopcroft's algorithm <ref> [Hopc71, Grie73] </ref>. This algorithm has a significant advantage over all of the known algorithms: although function equiv computes E pointwise from above (with respect to , refinement), the main program computes E from below (with respect to , normal set inclusion 5 ). <p> The presentation of that algorithm (with invariants) in this paper is arguably easier to understand than the original presentation. Our presentation highlights the fact that the main data-structure in the algorithm need not be a list | a set suffices. * Hopcroft's minimization algorithm <ref> [Hopc71] </ref> was originally presented in a style that is not very understandable. As with Gries's paper [Grie73], we strive to derive this algorithm in a clear and precise manner.
Reference: [Huff54] <author> Huffman, D.A. </author> <title> "The synthesis of sequential switching circuits," </title> <journal> J. Franklin Institute, </journal> <volume> 257(3): 161-190 and 257(4): </volume> <pages> 275-303, </pages> <year> 1954. </year>
Reference-contexts: This algorithm is used in the derivation of Hopcroft's minimization algorithm. * Hopcroft and Ullman's algorithm as presented in [HU79]. This algorithm (Algorithm 4.7) computes the inequivalence (distinguishability) relation. Although it is based upon the algorithms of Huffman and Moore <ref> [Huff54, Moor56] </ref>, this algorithm uses some interesting encoding techniques. * Hopcroft's algorithm as presented in [Hopc71, Grie73]. This algorithm (Algorithm 4.8) is the best known algorithm (in terms of running time analysis) for minimization. <p> In [HU79] it is attributed to Huffman <ref> [Huff54] </ref> and Moore [Moor56]. In their description, Hopcroft and Ullman describe L as mapping each pair of states to a list of pairs of states. The list data-type is not required here, and a set is used instead. It is possible to modify the above algorithm to compute E.
Reference: [Mirk65] <author> Mirkin, B.G. </author> <title> "On dual automata," </title> <type> Kibernetika 2(1): </type> <pages> 7-10, </pages> <year> 1966. </year>
Reference-contexts: In this thesis, the algorithm is attributed to a private communication from Prof. Peremans of the Eindhoven University of Technology. Peremans had originally found the algorithm in an article by Mirkin <ref> [Mirk65] </ref>. Although Mirkin does cite a paper by Brzozowski [Brzo64], it is not clear whether Mirkin's work was influenced by Brzozowki's work on minimization.
Reference: [Moor56] <author> Moore, E.F. </author> <title> "Gedanken-experiments on sequential machines," in Automata Studies, </title> <editor> (C.E. Shannon and J. McCarthy, </editor> <booktitle> eds.), </booktitle> <pages> pp. 129-153, </pages> <publisher> Princeton University Press, </publisher> <address> Princeton, N.J., </address> <year> 1956. </year>
Reference-contexts: This algorithm is used in the derivation of Hopcroft's minimization algorithm. * Hopcroft and Ullman's algorithm as presented in [HU79]. This algorithm (Algorithm 4.7) computes the inequivalence (distinguishability) relation. Although it is based upon the algorithms of Huffman and Moore <ref> [Huff54, Moor56] </ref>, this algorithm uses some interesting encoding techniques. * Hopcroft's algorithm as presented in [Hopc71, Grie73]. This algorithm (Algorithm 4.8) is the best known algorithm (in terms of running time analysis) for minimization. <p> The algorithm computing only E is essentially the algorithm presented by Wood in [Wood87, pg. 132]. According to Wood, it is based on the work of Moore <ref> [Moor56] </ref>. Its running times is O (jQj 3 ). Brauer uses some encoding techniques to provide an O (jQj 2 ) version of this algorithm in [Brau88], while Urbanek improves upon the space requirements of Brauer's version in [Urba89]. None of these variants is given here. <p> In [HU79] it is attributed to Huffman [Huff54] and Moore <ref> [Moor56] </ref>. In their description, Hopcroft and Ullman describe L as mapping each pair of states to a list of pairs of states. The list data-type is not required here, and a set is used instead. It is possible to modify the above algorithm to compute E.
Reference: [Myhi57] <author> Myhill, J. </author> <title> "Finite automata and the representation of events," </title> <booktitle> WADD TR-57-624, </booktitle> <pages> pp. 112-137, </pages> <institution> Wright Patterson AFB, Ohio, </institution> <year> 1957. </year>
Reference: [Nero58] <author> Nerode, A. </author> <title> "Linear automaton transformations," </title> <booktitle> Proc. AMS 9: </booktitle> <pages> 541-544, </pages> <year> 1958. </year>
Reference: [RS59] <author> Rabin, M.O and D. Scott. </author> <title> "Finite automata and their decision problems," </title> <journal> IBM J. Res. </journal> <volume> 3(2): </volume> <pages> 115-125, </pages> <year> 1959. </year> <editor> [vdSn85] van de Snepscheut, J.L.A. </editor> <title> "Trace theory and VLSI design," </title> <type> PhD Thesis, </type> <institution> Faculty of Mathematics and Computing Science, Eindhoven University of Technology, </institution> <address> The Netherlands, </address> <year> 1985. </year> <note> Also available as Lecture Notes in Computer Science 200, Springer-Verlag, Berlin, 1985. </note> <author> [vdSn93] van de Snepscheut, J.L.A. </author> <title> What computing is all about, </title> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1993. </year>
Reference: [Urba89] <author> Urbanek, F. </author> <title> "On minimizing finite automata," </title> <journal> EATCS Bulletin 39, </journal> <month> Oct. </month> <year> 1989. </year>
Reference-contexts: According to Wood, it is based on the work of Moore [Moor56]. Its running times is O (jQj 3 ). Brauer uses some encoding techniques to provide an O (jQj 2 ) version of this algorithm in [Brau88], while Urbanek improves upon the space requirements of Brauer's version in <ref> [Urba89] </ref>. None of these variants is given here. The algorithm computing only D does not appear in the literature.
Reference: [Wats93] <author> Watson, B.W. </author> <title> "A taxonomy of finite automata constructions," </title> <note> Computing Science Note 93/43, </note> <institution> Eindhoven University of Technology, </institution> <address> The Netherlands, </address> <year> 1993. </year>
Reference-contexts: Most of these definitions are taken directly from <ref> [Wats93] </ref>. <p> Introductory presentations of the theorem appear in <ref> [HU79, Wats93] </ref>. 2 Property B.21 (An alternate definition of minimality of a DFA): For the purposes of minimizing a DFA, we use the definition (defined only on DFA's): Minimal (Q; V; T; ;; S; F ) j (8 q 0 ; q 1 : q 0 2 Q ^ q 1
Reference: [Wood87] <author> Wood, D. </author> <title> Theory of Computation, </title> <publisher> Harper & Row, Publishers, </publisher> <address> New York, N.Y., </address> <year> 1987. </year>
Reference-contexts: A consequence of this upperbound is that E = E (jQj2) max 0 . As we shall see later, this can lead to some efficiency improvements to algorithms computing E. This result is also noted by Wood <ref> [Wood87, Lemma 2.4.1] </ref>. This upperbound also holds for computing D and [Q] E by approximation. 3.3 Characterizing the equivalence classes of E It is also practical to compute [Q] E : the set of equivalence classes of E. <p> The algorithm computing only E is essentially the algorithm presented by Wood in <ref> [Wood87, pg. 132] </ref>. According to Wood, it is based on the work of Moore [Moor56]. Its running times is O (jQj 3 ).
References-found: 18

