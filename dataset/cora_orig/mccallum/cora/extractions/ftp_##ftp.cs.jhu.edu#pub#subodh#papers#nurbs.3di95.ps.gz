URL: ftp://ftp.cs.jhu.edu/pub/subodh/papers/nurbs.3di95.ps.gz
Refering-URL: http://www.cs.jhu.edu/~subodh/research/pub.html
Root-URL: http://www.cs.jhu.edu
Email: fkumar,manocha,lastrag@cs.unc.edu  
Title: Interactive Display of Large-Scale NURBS Models  
Author: Subodh Kumar Dinesh Manocha Anselmo Lastra 
Address: Chapel Hill NC 27599  
Affiliation: Department of Computer Science University of North Carolina  
Abstract: We present serial and parallel algorithms for interactive rendering of large scale and complex NURBS models on current graphics systems. The algorithms tessellate the NURBS surfaces into triangles and render them using triangle rendering engines. The main characteristics of the algorithms are improved polygonization algorithms, exploitation of spatial and temporal coherence and back-patch culling. Polygoniza-tion anomalies like cracks and angularities are avoided. We analyze a number of issues in parallelization of these techniques, as well. The algorithms work well in practice and are able to display models consisting of thousands of surfaces at interactive frame rates. on the highly parallel graphics system, Pixel-Planes 5. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S.S. Abi-Ezzi and L.A. Shirman. </author> <title> Tessellation of curved surfaces under highly varying transformations. </title> <booktitle> Proceedings of Eurographics'91, </booktitle> <pages> pages 385-97, </pages> <year> 1991. </year>
Reference-contexts: Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current systems. As a result, only algorithms based on polygonization are capable of real time display. Different methods have been proposed for polygo-nization <ref> [2, 10, 26, 27, 13, 24, 23, 1, 12] </ref>. These are based on adaptive or uniform subdivision of NURBS surfaces. A real time algorithm for trimmed surfaces was proposed in [24]. <p> A real time algorithm for trimmed surfaces was proposed in [24]. However the bounds used for tessellating the Bezier surfaces are loose for rational surfaces and in some cases even under-sample the surface. Some techniques to improve the tessellation and their computations are presented in <ref> [12, 1, 2] </ref>. The algorithm presented in this paper has considerable improvements over these algorithms. Organization: The rest of the paper is organized in the following manner. In Section 2 we analyze the problem of computing polygonal approximations to surface models and give an overview of our approach. <p> On such models the uniform tessellation may supersample the surface. The performance of uniform tessellation algorithms is a direct function of the step sizes. 4.1 Uniform Subdivision There is considerable literature on computation of bounds on polynomials <ref> [19, 12, 23, 1] </ref>. There are two main criteria for computing bounds for step sizes: size criterion and deviation criterion. <p> These bounds can be applied in two ways for step size computation: 1. Compute the bounds on the surface in the object space as a preprocessing step. The step size is computed as a function of these bounds and viewing parameters <ref> [19, 12, 1] </ref>. 2. Transform the surface into screen space based on the transformation matrix. Use the transformed representation to compute the bounds, and the step size as a function of these bounds [23, 24]. We start with the size criterion for bound computations. <p> They are used to compute the step sizes as a function of the viewing parameters as shown in [12, 2]. An algorithm for compu tation of bounds based on the size criterion has been high lighted in <ref> [1] </ref>. However, the derivation of bounds in [1] is inaccurate and for a given T OL, our bounds are tighter. We illustrate the derivation on a Bezier curve (it is applied in a similar manner to the surfaces). <p> They are used to compute the step sizes as a function of the viewing parameters as shown in [12, 2]. An algorithm for compu tation of bounds based on the size criterion has been high lighted in <ref> [1] </ref>. However, the derivation of bounds in [1] is inaccurate and for a given T OL, our bounds are tighter. We illustrate the derivation on a Bezier curve (it is applied in a similar manner to the surfaces). Given a rational curve C (t) = (x (t); y (t); z (t); w (t). <p> As a result k C (t + ffi) C (t) k= ffi k X (t 1 ); Y (t 2 ); Z (t 3 ) k 0 0 0 where X 0 0 0 (t) represent the maximum magni tude of X 0 0 0 (t), respectively, in the domain <ref> [0; 1] </ref>. <p> tessellation param eters are computed in the object space as: n u =k W (u; v) u Y (u; v) ; W (u; v) u where X (u;v) corresponds to the maximum magnitude of the partial derivative of X (u; v)=W (u; v) with respect to u in the domain <ref> [0; 1] </ref> fi [0; 1]. n v is computed analogously. The maximum values of the partial derivates are computed in the following way. <p> are computed in the object space as: n u =k W (u; v) u Y (u; v) ; W (u; v) u where X (u;v) corresponds to the maximum magnitude of the partial derivative of X (u; v)=W (u; v) with respect to u in the domain <ref> [0; 1] </ref> fi [0; 1]. n v is computed analogously. The maximum values of the partial derivates are computed in the following way. <p> Based on the solutions of these equations, we compute the maximum values of f x (u; v) in the domain <ref> [0; 1] </ref> fi [0; 1]. Let the maximum value be at [u x ; v x ]. Similar computations are performed on f y (u; v) and f z (u; v). <p> Based on the solutions of these equations, we compute the maximum values of f x (u; v) in the domain <ref> [0; 1] </ref> fi [0; 1]. Let the maximum value be at [u x ; v x ]. Similar computations are performed on f y (u; v) and f z (u; v). <p> In case the surface area is small and curvature is high, they may undersample the surface. For example see Fig. 4 (a): the curve C is tessellated into two Our Algorithm [23] <ref> [1] </ref> 1 1.43 1.22 Table 1: Ratio of the # triangles generated for a tolerance segments P Q and QR, each of magnitude less than T OL. The optimal solution to that problem would be based on the deviation criterion. <p> as (R i1 ; R i2 ; : : : ; R in ) for all 1 i m and take the maximum of n 0 0 v is computed in a similar manner. 4.4 Comparison of Methods We empirically compared our bound with those of Rock-wood [23] and Abi-Ezzi/Shirman <ref> [1] </ref>. These comparisons were performed over a number of models and we computed the averages of the number of polygons generated. The average has been taken over seven models and the number of patches varied from 72 to 5354. <p> The degrees of the models were between two and three in u as well as v. For the same tolerance, our bounds result in about 33% fewer triangles than [23] and about 20% fewer than <ref> [1] </ref>. 4.5 Frame to Frame Coherence Typically, there is not much change in the position of the model in the object space between successive frames. As a result, the bounds for tessellation do not change much between successive frames. <p> Let us consider the case when n u &gt; n u . As a result, we need to choose n u n u additional points in the domain <ref> [0; 1] </ref>, such that the resulting polygonization is smooth. One simple solution is to choose n u = 2n u and thereby making the step size as half and computing n u additional evaluations.
Reference: [2] <author> S.S. Abi-Ezzi and L.A. Shirman. </author> <title> The scaling behavior of viewing transformations. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 13(3) </volume> <pages> 48-54, </pages> <year> 1993. </year>
Reference-contexts: Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current systems. As a result, only algorithms based on polygonization are capable of real time display. Different methods have been proposed for polygo-nization <ref> [2, 10, 26, 27, 13, 24, 23, 1, 12] </ref>. These are based on adaptive or uniform subdivision of NURBS surfaces. A real time algorithm for trimmed surfaces was proposed in [24]. <p> A real time algorithm for trimmed surfaces was proposed in [24]. However the bounds used for tessellating the Bezier surfaces are loose for rational surfaces and in some cases even under-sample the surface. Some techniques to improve the tessellation and their computations are presented in <ref> [12, 1, 2] </ref>. The algorithm presented in this paper has considerable improvements over these algorithms. Organization: The rest of the paper is organized in the following manner. In Section 2 we analyze the problem of computing polygonal approximations to surface models and give an overview of our approach. <p> They are used to compute the step sizes as a function of the viewing parameters as shown in <ref> [12, 2] </ref>. An algorithm for compu tation of bounds based on the size criterion has been high lighted in [1]. However, the derivation of bounds in [1] is inaccurate and for a given T OL, our bounds are tighter. <p> Given these bounds in the object space, we compute the step size in the screen space as a function of the viewing transformations. These bounds are invariant to rigid body transformations like rotations and translations. They vary with the perspective transformation matrix as shown in <ref> [2] </ref>. 4.3 Curvature Bounds For small values of T OL the size criterion bounds, derived above, work quite well. In case the surface area is small and curvature is high, they may undersample the surface.
Reference: [3] <author> K. Akeley. </author> <title> Reality engine graphics. </title> <booktitle> In Proceedings of ACM Siggraph, </booktitle> <pages> pages 109-1116, </pages> <year> 1993. </year>
Reference-contexts: 1 Introduction Current graphics systems have reached the capability of rendering millions of transformed, shaded and z-buffered polygons per second <ref> [3, 14] </ref>. However in many applications involving CAD/CAM, virtual reality, animation and visualization the object models are described in terms of non-uniform rational B-spline (NURBS) surfaces. This class includes Bezier surfaces and other rational parametric surfaces like tensor product and triangular patches. <p> Currently, we are able to render model consisting of seven to eight hundred Bezier patches at 12 16 frames a second. 6.1 Parallel Implementation Pixel-Planes 5 [14] uses extensive parallelism to increase rendering performance. This has become the practice in high-performance graphics accelerators <ref> [3] </ref>. Figure 4 presents a block diagram of the Pixel-Planes 5 system. Front-end geometry processing, such as transformation, clipping, and setup for rasterization, is performed on theGraphics Processors (GPs) which contain Intel i860 RISC microprocessors running at 40 MHz, 8 MB of main memory, and communications hardware.
Reference: [4] <author> C.L. Bajaj and A. Royappa. </author> <title> Triangulation and display of rational parametric surfaces. </title> <booktitle> In Proceedings of Visualization'94, </booktitle> <pages> pages 69-76, </pages> <publisher> IEEE Computer Society, Los Alamitos, </publisher> <address> CA, </address> <year> 1994. </year>
Reference: [5] <author> D.C. </author> <title> Banks. Interactive manipulation and display of two-dimensional surfaces in four-dimensional space. </title> <booktitle> In Symposium on Interactive 3D Graphics, </booktitle> <pages> pages 197-207, </pages> <year> 1992. </year>
Reference-contexts: These routines may generate arbitrary geometry in immediate mode for the rendering engine to display. This feature has been used successfully for problems which require close coupling between computation and the generation of geometry <ref> [5] </ref>. The tessellation algorithm is implemented as a set of user functions running on the graphics processors. Load balancing is achieved by distributing the individual patches to the GPs in round-robbin order.
Reference: [6] <author> E. Catmull. </author> <title> A subdivision algorithm for computer display of curved surfaces. </title> <type> PhD thesis, </type> <institution> University of Utah, </institution> <year> 1974. </year>
Reference-contexts: On parallel graphics systems, the algorithm minimizes communication between processors, and load balances the work. Previous Work: Curved surface rendering has been an active topic of research for more than two decades. The main techniques are based on pixel level surface subdivision, ray tracing, scan-line display and polygonization <ref> [6, 7, 15, 18] </ref>. Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current systems. As a result, only algorithms based on polygonization are capable of real time display.
Reference: [7] <author> J. H. Clark. </author> <title> A fast algorithm for rendering parametric surfaces. </title> <booktitle> Proceedings of ACM Siggraph, </booktitle> <pages> pages 289-99, </pages> <year> 1979. </year>
Reference-contexts: On parallel graphics systems, the algorithm minimizes communication between processors, and load balances the work. Previous Work: Curved surface rendering has been an active topic of research for more than two decades. The main techniques are based on pixel level surface subdivision, ray tracing, scan-line display and polygonization <ref> [6, 7, 15, 18] </ref>. Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current systems. As a result, only algorithms based on polygonization are capable of real time display.
Reference: [8] <author> M.F. Deering and S.R. Nelson. Leo: </author> <title> A system for cost effective 3d shaded graphics. </title> <booktitle> In Proceedings of ACM Siggraph, </booktitle> <pages> pages 101-108, </pages> <year> 1993. </year>
Reference: [9] <author> D. Ellsworth, H. Goods, and B. Tebbs. </author> <title> Distributing display lists on a multicomputer. In Symposium on Interactive 3D Graphics, </title> <address> Snowbird, UT, </address> <year> 1990. </year>
Reference-contexts: Load balancing is achieved by distributing the individual patches to the GPs in round-robbin order. We have found this technique of distributing by primitive to be the best way to maintain good load balancing <ref> [9] </ref>. The algorithm does not require any inter-processor communication during execution. This property not only improves the parallel speedup, but also will make it easier to port the code to another multi-processor machine.
Reference: [10] <author> T. Derose et. al. Apex: </author> <title> two architectures for generating parametric curves and surfaces. </title> <journal> The Visual Computer, </journal> <volume> 5 </volume> <pages> 264-276, </pages> <year> 1989. </year>
Reference-contexts: Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current systems. As a result, only algorithms based on polygonization are capable of real time display. Different methods have been proposed for polygo-nization <ref> [2, 10, 26, 27, 13, 24, 23, 1, 12] </ref>. These are based on adaptive or uniform subdivision of NURBS surfaces. A real time algorithm for trimmed surfaces was proposed in [24].
Reference: [11] <author> G. Farin. </author> <title> Curves and Surfaces for Computer Aided Geometric Design: A Practical Guide. </title> <publisher> Academic Press Inc., </publisher> <year> 1990. </year>
Reference-contexts: In particular, we perform incre mental computations. 4. Parallelization : We make use of hardware on parallel graphics systems and distribute the computations over multiple processors. 2.1 Background Given a NURBS model, we use knot insertion to decompose them into a series of Bezier patches <ref> [11] </ref>. In the process, we insert the minimum number of knots as a function of the knot sequence of the original surface and its order. Closely spaced knots, with tolerance less than 2 fi 10 5 are coerced to the same value before knot insertion. <p> A Bezier surface, defined in homogeneous coordinates as F (u; v) = (X (u; v); Y (u; v); Z (u; v); W (u; v)), is specified by a mesh of control points. Furthermore, the entire surface is contained in the convex polytope of the control points <ref> [11] </ref>. Let us denote this convex polytope as P F .
Reference: [12] <author> D. Filip, R. Magedson, and R. Markot. </author> <title> Surface algorithms using bounds on derivatives. </title> <journal> CAGD, </journal> <volume> 3 </volume> <pages> 295-311, </pages> <year> 1986. </year>
Reference-contexts: Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current systems. As a result, only algorithms based on polygonization are capable of real time display. Different methods have been proposed for polygo-nization <ref> [2, 10, 26, 27, 13, 24, 23, 1, 12] </ref>. These are based on adaptive or uniform subdivision of NURBS surfaces. A real time algorithm for trimmed surfaces was proposed in [24]. <p> A real time algorithm for trimmed surfaces was proposed in [24]. However the bounds used for tessellating the Bezier surfaces are loose for rational surfaces and in some cases even under-sample the surface. Some techniques to improve the tessellation and their computations are presented in <ref> [12, 1, 2] </ref>. The algorithm presented in this paper has considerable improvements over these algorithms. Organization: The rest of the paper is organized in the following manner. In Section 2 we analyze the problem of computing polygonal approximations to surface models and give an overview of our approach. <p> On such models the uniform tessellation may supersample the surface. The performance of uniform tessellation algorithms is a direct function of the step sizes. 4.1 Uniform Subdivision There is considerable literature on computation of bounds on polynomials <ref> [19, 12, 23, 1] </ref>. There are two main criteria for computing bounds for step sizes: size criterion and deviation criterion. <p> These bounds can be applied in two ways for step size computation: 1. Compute the bounds on the surface in the object space as a preprocessing step. The step size is computed as a function of these bounds and viewing parameters <ref> [19, 12, 1] </ref>. 2. Transform the surface into screen space based on the transformation matrix. Use the transformed representation to compute the bounds, and the step size as a function of these bounds [23, 24]. We start with the size criterion for bound computations. <p> They are used to compute the step sizes as a function of the viewing parameters as shown in <ref> [12, 2] </ref>. An algorithm for compu tation of bounds based on the size criterion has been high lighted in [1]. However, the derivation of bounds in [1] is inaccurate and for a given T OL, our bounds are tighter. <p> The coherence is equally effective in such cases. 4.6 Crack Prevention Since the bound for required tessellation for each patch is evaluated independently, we may mandate different tessellations on two adjacent patches. This can result in cracks in the rendered image. To address this issue <ref> [12, 24] </ref> suggested that the amount of tessellation at the boundary be based solely on the boundary curve, and a strip of coving triangles be generated at the boundary.
Reference: [13] <author> D.R. Forsey and V. Klassen. </author> <title> An adaptive subdivision algorithm for crack prevention in the display of parametric surfaces. </title> <booktitle> Proceedings of Graphics Interface, </booktitle> <pages> pages 1-8, </pages> <year> 1990. </year>
Reference-contexts: Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current systems. As a result, only algorithms based on polygonization are capable of real time display. Different methods have been proposed for polygo-nization <ref> [2, 10, 26, 27, 13, 24, 23, 1, 12] </ref>. These are based on adaptive or uniform subdivision of NURBS surfaces. A real time algorithm for trimmed surfaces was proposed in [24].
Reference: [14] <author> H. Fuchs and J. Poulton et. al. </author> <title> Pixel-planes 5: A heterogeneous multiprocessor graphics system using processor-enhanced memories. </title> <booktitle> In Proceedings of ACM Siggraph, </booktitle> <pages> pages 79-88, </pages> <year> 1989. </year>
Reference-contexts: 1 Introduction Current graphics systems have reached the capability of rendering millions of transformed, shaded and z-buffered polygons per second <ref> [3, 14] </ref>. However in many applications involving CAD/CAM, virtual reality, animation and visualization the object models are described in terms of non-uniform rational B-spline (NURBS) surfaces. This class includes Bezier surfaces and other rational parametric surfaces like tensor product and triangular patches. <p> We have been able to display many complex models in real time using our algorithm. In particular, our current implementation on the SGI-Onyx with a Reality Engine 2 can display about four hundred surfaces and on Pixel-planes 5, <ref> [14] </ref> more than ten thousand surfaces at interactive frame rates (about 12 15 frames a second). On parallel graphics systems, the algorithm minimizes communication between processors, and load balances the work. Previous Work: Curved surface rendering has been an active topic of research for more than two decades. <p> Currently, we are able to render model consisting of seven to eight hundred Bezier patches at 12 16 frames a second. 6.1 Parallel Implementation Pixel-Planes 5 <ref> [14] </ref> uses extensive parallelism to increase rendering performance. This has become the practice in high-performance graphics accelerators [3]. Figure 4 presents a block diagram of the Pixel-Planes 5 system. <p> Polygon rasterization, and shading is performed on renderer boards which contain arrays of 128 by 128 1-bit processors with local memory <ref> [14] </ref> and an instruction sequencer. The processing units are connected by a 160 million word per second ring communications network. Since we have access to the graphics processors of Pixel-Planes 5, a parallel implementation of the tessellation algorithm seemed natural.
Reference: [15] <author> J. Kajiya. </author> <title> Ray tracing parametric patches. </title> <journal> Computer Graphics, </journal> <volume> 16(3) </volume> <pages> 245-254, </pages> <year> 1982. </year>
Reference-contexts: On parallel graphics systems, the algorithm minimizes communication between processors, and load balances the work. Previous Work: Curved surface rendering has been an active topic of research for more than two decades. The main techniques are based on pixel level surface subdivision, ray tracing, scan-line display and polygonization <ref> [6, 7, 15, 18] </ref>. Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current systems. As a result, only algorithms based on polygonization are capable of real time display.
Reference: [16] <author> S. Krishnan and D. Manocha. </author> <title> Global visibility and hidden surface algorithms for free form surfaces. </title> <type> Technical Report TR94-063, </type> <institution> Department of Computer Science, University of North Carolina, </institution> <year> 1994. </year>
Reference-contexts: In general, the exact computation of the visible portions of a NURBS model is a non-trivial problem requiring silhouette computation <ref> [16] </ref>. We show that it is relatively simple to perform a visibility check to find most of the patches that are completely non-visible.
Reference: [17] <author> S. Kumar and D. Manocha. </author> <title> Efficient rendering of trimmed nurbs surfaces. </title> <booktitle> Computer-Aided Design, </booktitle> <year> 1994. </year> <note> to appear. </note>
Reference-contexts: If two trim curves intersect, we combine them to make one curve. The trimmed surfaces are rendered by computing the visible portions of the domain. This involves computing the intersection of the curve with the domain subdivision, coving and tiling and triangulation <ref> [17] </ref>. The basic idea of this algorithm is to treat the trimmed curve as patch boundaries. For untrimmed surfaces, we described an algorithm to partition the domain into rectangles in the interior of the patch and triangles at the boundary.
Reference: [18] <author> J.M. Lane, L.C. Carpenter, J. T. Whitted, and J.F. </author> <title> Blinn. Scan line methods for displaying parametrically defined surfaces. </title> <journal> Communications of ACM, </journal> <volume> 23(1) </volume> <pages> 23-34, </pages> <year> 1980. </year>
Reference-contexts: On parallel graphics systems, the algorithm minimizes communication between processors, and load balances the work. Previous Work: Curved surface rendering has been an active topic of research for more than two decades. The main techniques are based on pixel level surface subdivision, ray tracing, scan-line display and polygonization <ref> [6, 7, 15, 18] </ref>. Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current systems. As a result, only algorithms based on polygonization are capable of real time display.
Reference: [19] <author> J.M. Lane and R.F. Riesenfeld. </author> <title> Bounds on polynomials. </title> <journal> BIT, </journal> <volume> 2 </volume> <pages> 112-117, </pages> <year> 1981. </year>
Reference-contexts: On such models the uniform tessellation may supersample the surface. The performance of uniform tessellation algorithms is a direct function of the step sizes. 4.1 Uniform Subdivision There is considerable literature on computation of bounds on polynomials <ref> [19, 12, 23, 1] </ref>. There are two main criteria for computing bounds for step sizes: size criterion and deviation criterion. <p> These bounds can be applied in two ways for step size computation: 1. Compute the bounds on the surface in the object space as a preprocessing step. The step size is computed as a function of these bounds and viewing parameters <ref> [19, 12, 1] </ref>. 2. Transform the surface into screen space based on the transformation matrix. Use the transformed representation to compute the bounds, and the step size as a function of these bounds [23, 24]. We start with the size criterion for bound computations. <p> All these computations are part of a preprocessing stage. Similarly, the maximum of f x (0; v) corresponds to computing the roots of f x v (0; v) = 0, which can be computed using root-finders or subdivision properties of Bezier curves <ref> [19] </ref>. Based on the solutions of these equations, we compute the maximum values of f x (u; v) in the domain [0; 1] fi [0; 1]. Let the maximum value be at [u x ; v x ].
Reference: [20] <author> W.L. Luken and Fuhua Cheng. </author> <title> Rendering trimmed nurb surfaces. </title> <institution> Computer science research report 18669(81711), IBM Research Division, </institution> <year> 1993. </year>
Reference: [21] <author> D. Manocha and J. Demmel. </author> <title> Algorithms for intersecting parametric and algebraic curves i: simple intersections. </title> <journal> ACM Transactions on Graphics, </journal> <volume> 13(1) </volume> <pages> 73-100, </pages> <year> 1994. </year>
Reference-contexts: Thus the problem of computing the maximum derivative vector reduces to computing zeros of polynomial equations. In fact, it geometrically corresponds to curve intersection <ref> [21, 25] </ref>. <p> This is rather high. However, we are able to compute accurate solutions in double precision arithmetic using the algorithm highlighted in <ref> [21] </ref>. In particular, it reduces the problem to computing eigenvalues of a matrix. Good implementations of eigenvalues are available as part of numerical libraries like EISPACK and LAPACK. The resulting algorithms are fast, accurate and need no initial guess to the solutions. <p> This query reduces to an inversion problem: given a point P and a curve C, find the parameter value t such that C (t) = P . We solve it using techniques from elimination theory <ref> [21] </ref>. For each patch boundary we now know the two sets of representations of the same curves: we store one of them (chosen arbitrarily) with both the patches. To calculate the bounds on the curves and tessellate them we use this stored representation.
Reference: [22] <author> R. Nash. </author> <title> Silicon Graphics, </title> <type> Personal Communication, </type> <year> 1993. </year>
Reference-contexts: The Pixel-Planes implementation is fully parallel, using the maximum number of available processors. The performance of the algorithm on the SGI Onyx is shown in Table 2. The images were rendered with Gouraud shading. The standard SGI-GL implementation is based on the algorithm presented in <ref> [24, 22] </ref> and has a microcoded geometry engine implementation for surface evaluations. Although it is difficult to compare two different algorithms and implementations (for example, the design constraints may be different), we performed the following experiments using identical sets of viewing parameters.
Reference: [23] <author> A. Rockwood. </author> <title> A generalized scanning technique for display of parametrically defined surface. </title> <journal> IEEE Computer Graphics and Applications, </journal> <pages> pages 15-26, </pages> <month> August </month> <year> 1987. </year>
Reference-contexts: Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current systems. As a result, only algorithms based on polygonization are capable of real time display. Different methods have been proposed for polygo-nization <ref> [2, 10, 26, 27, 13, 24, 23, 1, 12] </ref>. These are based on adaptive or uniform subdivision of NURBS surfaces. A real time algorithm for trimmed surfaces was proposed in [24]. <p> On such models the uniform tessellation may supersample the surface. The performance of uniform tessellation algorithms is a direct function of the step sizes. 4.1 Uniform Subdivision There is considerable literature on computation of bounds on polynomials <ref> [19, 12, 23, 1] </ref>. There are two main criteria for computing bounds for step sizes: size criterion and deviation criterion. <p> The step size is computed as a function of these bounds and viewing parameters [19, 12, 1]. 2. Transform the surface into screen space based on the transformation matrix. Use the transformed representation to compute the bounds, and the step size as a function of these bounds <ref> [23, 24] </ref>. We start with the size criterion for bound computations. To avoid undersampling highly curved surfaces with low areas, we use an additional estimate based on the geometry of the control points. <p> Let T OL be the user specified tolerance in screen space. The step sizes along the u and v directions are given as <ref> [23] </ref>: n u = m max (k W ij R ij W i+1;j R i+1;j k)=(T OLflmin (W ij )) n v = n max (k W ij R ij W i;j+1 R i;j+1 k)=(T OLflmin (W ij )) for (1 i m, 1 j n). <p> In case the surface area is small and curvature is high, they may undersample the surface. For example see Fig. 4 (a): the curve C is tessellated into two Our Algorithm <ref> [23] </ref> [1] 1 1.43 1.22 Table 1: Ratio of the # triangles generated for a tolerance segments P Q and QR, each of magnitude less than T OL. The optimal solution to that problem would be based on the deviation criterion. <p> Bezier curves defined as (R i1 ; R i2 ; : : : ; R in ) for all 1 i m and take the maximum of n 0 0 v is computed in a similar manner. 4.4 Comparison of Methods We empirically compared our bound with those of Rock-wood <ref> [23] </ref> and Abi-Ezzi/Shirman [1]. These comparisons were performed over a number of models and we computed the averages of the number of polygons generated. The average has been taken over seven models and the number of patches varied from 72 to 5354. <p> The average has been taken over seven models and the number of patches varied from 72 to 5354. The degrees of the models were between two and three in u as well as v. For the same tolerance, our bounds result in about 33% fewer triangles than <ref> [23] </ref> and about 20% fewer than [1]. 4.5 Frame to Frame Coherence Typically, there is not much change in the position of the model in the object space between successive frames. As a result, the bounds for tessellation do not change much between successive frames.
Reference: [24] <author> A. Rockwood, K. Heaton, and T. Davis. </author> <title> Real-time rendering of trimmed surfaces. </title> <booktitle> In Proceedings of ACM Siggraph, </booktitle> <pages> pages 107-17, </pages> <year> 1989. </year>
Reference-contexts: Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current systems. As a result, only algorithms based on polygonization are capable of real time display. Different methods have been proposed for polygo-nization <ref> [2, 10, 26, 27, 13, 24, 23, 1, 12] </ref>. These are based on adaptive or uniform subdivision of NURBS surfaces. A real time algorithm for trimmed surfaces was proposed in [24]. <p> Different methods have been proposed for polygo-nization [2, 10, 26, 27, 13, 24, 23, 1, 12]. These are based on adaptive or uniform subdivision of NURBS surfaces. A real time algorithm for trimmed surfaces was proposed in <ref> [24] </ref>. However the bounds used for tessellating the Bezier surfaces are loose for rational surfaces and in some cases even under-sample the surface. Some techniques to improve the tessellation and their computations are presented in [12, 1, 2]. The algorithm presented in this paper has considerable improvements over these algorithms. <p> The step size is computed as a function of these bounds and viewing parameters [19, 12, 1]. 2. Transform the surface into screen space based on the transformation matrix. Use the transformed representation to compute the bounds, and the step size as a function of these bounds <ref> [23, 24] </ref>. We start with the size criterion for bound computations. To avoid undersampling highly curved surfaces with low areas, we use an additional estimate based on the geometry of the control points. <p> The coherence is equally effective in such cases. 4.6 Crack Prevention Since the bound for required tessellation for each patch is evaluated independently, we may mandate different tessellations on two adjacent patches. This can result in cracks in the rendered image. To address this issue <ref> [12, 24] </ref> suggested that the amount of tessellation at the boundary be based solely on the boundary curve, and a strip of coving triangles be generated at the boundary. <p> In case c i is intersected by a trim curve, we triangulate the non-trimmed region of c i . Since most trim curves are fairly smooth, in the general case, the algorithm performs well in practice and coving and tiling is no longer the bottleneck, as it is in <ref> [24] </ref>. Furthermore we do not need to break up the trimmed curves into monotonic segments, as is the case in [24]. 6 Implementation and performance We have implemented our algorithm on a Silicon Graphics (SGI) R3000 with a VGX graphics accelerator, a SGI Onyx (single processor) with a RealityEngine 2, and <p> Since most trim curves are fairly smooth, in the general case, the algorithm performs well in practice and coving and tiling is no longer the bottleneck, as it is in <ref> [24] </ref>. Furthermore we do not need to break up the trimmed curves into monotonic segments, as is the case in [24]. 6 Implementation and performance We have implemented our algorithm on a Silicon Graphics (SGI) R3000 with a VGX graphics accelerator, a SGI Onyx (single processor) with a RealityEngine 2, and on the Pixel-Planes 5 system. The Pixel-Planes implementation is fully parallel, using the maximum number of available processors. <p> The Pixel-Planes implementation is fully parallel, using the maximum number of available processors. The performance of the algorithm on the SGI Onyx is shown in Table 2. The images were rendered with Gouraud shading. The standard SGI-GL implementation is based on the algorithm presented in <ref> [24, 22] </ref> and has a microcoded geometry engine implementation for surface evaluations. Although it is difficult to compare two different algorithms and implementations (for example, the design constraints may be different), we performed the following experiments using identical sets of viewing parameters.
Reference: [25] <author> T.W. </author> <title> Sederberg. Algorithms for algebraic curve intersection. </title> <booktitle> Computer-Aided Design, </booktitle> <volume> 21(9) </volume> <pages> 547-555, </pages> <year> 1989. </year>
Reference-contexts: Thus the problem of computing the maximum derivative vector reduces to computing zeros of polynomial equations. In fact, it geometrically corresponds to curve intersection <ref> [21, 25] </ref>.
Reference: [26] <author> M. Shantz and S. Chang. </author> <title> Rendering trimmed nurbs with adaptive forward differencing. </title> <booktitle> In Proceedings of ACM Sig-graph, </booktitle> <pages> pages 189-198, </pages> <year> 1988. </year>
Reference-contexts: Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current systems. As a result, only algorithms based on polygonization are capable of real time display. Different methods have been proposed for polygo-nization <ref> [2, 10, 26, 27, 13, 24, 23, 1, 12] </ref>. These are based on adaptive or uniform subdivision of NURBS surfaces. A real time algorithm for trimmed surfaces was proposed in [24].
Reference: [27] <author> M. Shantz and S. Lien. </author> <title> Shading bicubic patches. </title> <booktitle> In Proceedings of ACM Siggraph, </booktitle> <pages> pages 189-196, </pages> <year> 1987. </year>
Reference-contexts: Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current systems. As a result, only algorithms based on polygonization are capable of real time display. Different methods have been proposed for polygo-nization <ref> [2, 10, 26, 27, 13, 24, 23, 1, 12] </ref>. These are based on adaptive or uniform subdivision of NURBS surfaces. A real time algorithm for trimmed surfaces was proposed in [24].
References-found: 27

