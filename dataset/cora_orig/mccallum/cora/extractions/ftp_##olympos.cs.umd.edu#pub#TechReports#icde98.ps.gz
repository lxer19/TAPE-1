URL: ftp://olympos.cs.umd.edu/pub/TechReports/icde98.ps.gz
Refering-URL: http://www.cs.umd.edu/~christos/cpub.html
Root-URL: 
Title: Efficient Retrieval of Similar Time Sequences Under Time Warping  
Author: Byoung-Kee Yi H.V. Jagadish Christos Faloutsos 
Date: October 9, 1997  
Abstract: Fast similarity searching in large time-sequence databases has attracted a lot of research interest [1, 5, 2, 6, 3, 10]. All of them use the Euclidean distance (L 2 ), or some variation of L p metrics. L p metrics lead to efficient indexing, thanks to feature extraction (e.g., by keeping the first few DFT coefficients) and subsequent use of fast spatial access methods for the points in feature space. In this work we examine a popular, field-tested dissimilarity function, the "time warping" distance function which permits local accelerations and decelerations in the rate of the signals or sequences. This function is natural and suitable for several applications, like matching of voice, audio and medical signals (e.g., electrocardiograms) However, from the indexing viewpoint it presents two major challenges: (a) it does not lead to any natural "features", precluding the use of spatial access methods (b) it is quadratic (O(len 1 fl len 2 )) on the length of the sequences involved. Here we show how to overcome both problems: for the former, we propose using a modification of the so- called "FastMap", to map sequences into points, trading off a tiny amount of "recall" (typically zero) for large gains in speed. For the latter, we provide a fast, linear test, to help us discard quickly many of the false alarms that FastMap will typically introduce. Using both ideas in cascade, our proposed method consistently outperformed the straightforward sequential scanning on both real and synthetic datasets and achieved up to 7.8-time speed-up (780%).
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Rakesh Agrawal, Christos Faloutsos, and Arun Swami. </author> <title> Efficient similarity search in sequence databases. </title> <booktitle> In Proceedings of the FODO Conference, </booktitle> <address> Evansotn, IL, USA, </address> <month> October </month> <year> 1993. </year> <month> 16 </month>
Reference-contexts: EEC-94-02384, IRI-9205273 and IRI-9625428. 1 Applications of approximate sequence matching abound: in financial time sequences ("find stocks that move like Microsoft"); digital audio/voice clips ("find clips that sound like a given person") <ref> [1, 5] </ref>; scientific databases ("find times in the past that had similar solar magnetic wind patterns with the ones today" [14]). In the area of speech recognition, this problem has been studied extensively, and is called the "(dynamic) time warping". <p> However, they assumed a small dataset (e.g., a few tens of phonemes) and were more concerned with the precision rather than efficiency in the presence of large datasets. Speed is the main focus in the recent database work on sequence matching. In <ref> [1] </ref>, we examined the Euclidean distance, and suggest using the Discrete Fourier Transform (DFT). We argued that most of real signals need only a few DFT coefficients to approximate them. <p> A topic that none of the above articles has tackled is the problem of indexing, when local, time-warping transformations are allowed. This is a difficult problem, because the DFT methods of <ref> [1, 5] </ref> do not work any more.
Reference: [2] <author> Rakesh Agrawal, King-Ip Lin, Harpreet S. Sawhney, and Kyuseok Shim. </author> <title> Fast similarity search in the presence of noise, scaling, and translation in time-series database. </title> <booktitle> In Proceedings of the 21st VLDB Conference, </booktitle> <address> Zurich, Switzerland, </address> <year> 1995. </year>
Reference-contexts: In [5] we generalized the approach for subsequence matching. Follow-up work by Goldin and Kanellakis [6] suggested that we normalize the sequences first, to allow for differences in level and scale. 2 All the above approaches assume Euclidean distance as the underlying similarity measure. Agrawal et al <ref> [2] </ref> introduce a new distance function for time sequences, aiming to capture the intuitive notion that two sequences should be considered similar if they have enough non-overlapping time-ordered pairs of similar subsequences. <p> Their lengths vary from 640 to 840. * STOCK: Stock price time sequences were generated by extracting 150 most recent (as of 6/5/96) daily high values from 640 stocks. These time sequences were normalized by subtracting the average, as was done in <ref> [6, 2] </ref>. (a) SINE (b) ECG (c) STOCK Before building a FastMap index, we must determine the dimensionality k of the target space. In experiments not reported here for brevity, we observed that k = 6 was a good choice for all our the datasets.
Reference: [3] <author> C. Faloutsos, H. V. Jagadish, A. O. Mendelzon, and T. Milo. </author> <title> A signature technique for similarity-based queries. </title> <booktitle> In Proceedings of SEQUENCES97, Salerno, </booktitle> <address> Italy, </address> <month> June </month> <year> 1997. </year>
Reference: [4] <author> Christos Faloutsos and King-Ip Lin. </author> <title> Fastmap: A fast algorithm for indexing, data-mining and visualization of traditional and multimedia datasets. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference, </booktitle> <address> San Jose, CA, USA, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: We would like to have a very fast matching technique, and ideally even an indexing technique for this purpose. In this paper we propose two such techniques. The first technique is based on FastMap <ref> [4] </ref>. The idea here is to make use of the given distance measures to map sequences into points in k-d space, and to finally build an index structure. The other technique we propose defines a new distance function which uniformly underestimates the original distance function. <p> Since the two techniques are independent of each other, they can be combined in a pipelined manner. In the subsequent sections, we describe precisely the proposed techniques. 4.1 FastMap-Based Technique The first technique we propose is based on a method called "FastMap" <ref> [4] </ref>. It works as follows: Given N objects and a distance function, it maps the objects into N points in a kd space, so that the original distances are preserved well.
Reference: [5] <author> Christos Faloutsos, M. Ranganathan, and Yannis manolopoulos. </author> <title> Fast subsequence matching in time-series databases. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference, </booktitle> <month> May </month> <year> 1994. </year>
Reference-contexts: EEC-94-02384, IRI-9205273 and IRI-9625428. 1 Applications of approximate sequence matching abound: in financial time sequences ("find stocks that move like Microsoft"); digital audio/voice clips ("find clips that sound like a given person") <ref> [1, 5] </ref>; scientific databases ("find times in the past that had similar solar magnetic wind patterns with the ones today" [14]). In the area of speech recognition, this problem has been studied extensively, and is called the "(dynamic) time warping". <p> The proposed method may allow a few false alarms which can be removed in the post-processing stage, but guarantees no false dismissals. This method was proposed for matching sequences of equal length. In <ref> [5] </ref> we generalized the approach for subsequence matching. Follow-up work by Goldin and Kanellakis [6] suggested that we normalize the sequences first, to allow for differences in level and scale. 2 All the above approaches assume Euclidean distance as the underlying similarity measure. <p> A topic that none of the above articles has tackled is the problem of indexing, when local, time-warping transformations are allowed. This is a difficult problem, because the DFT methods of <ref> [1, 5] </ref> do not work any more. <p> As we have shown in a previous paper <ref> [5] </ref>, lower-bounding the actual distance with another distance is a condition that guarantees no false dismissals for range queries and nearest neighbor queries [8]. Algorithm 2 describes how range queries can be processed. Other types of queries can be handled similarly.
Reference: [6] <author> Dina Q. Goldin and Paris C. Kanellakis. </author> <title> On similarity queries for time-series data: Constraint specification and implementation. </title> <booktitle> In Proceedings of Constraint Programming 95, </booktitle> <address> Marseilles, </address> <month> September </month> <year> 1995. </year>
Reference-contexts: The proposed method may allow a few false alarms which can be removed in the post-processing stage, but guarantees no false dismissals. This method was proposed for matching sequences of equal length. In [5] we generalized the approach for subsequence matching. Follow-up work by Goldin and Kanellakis <ref> [6] </ref> suggested that we normalize the sequences first, to allow for differences in level and scale. 2 All the above approaches assume Euclidean distance as the underlying similarity measure. <p> Their lengths vary from 640 to 840. * STOCK: Stock price time sequences were generated by extracting 150 most recent (as of 6/5/96) daily high values from 640 stocks. These time sequences were normalized by subtracting the average, as was done in <ref> [6, 2] </ref>. (a) SINE (b) ECG (c) STOCK Before building a FastMap index, we must determine the dimensionality k of the target space. In experiments not reported here for brevity, we observed that k = 6 was a good choice for all our the datasets.
Reference: [7] <author> H. V. Jagadish, Alberto O. Mendelzon, and Tova Milo. </author> <title> Similarity-based queries. </title> <booktitle> In Proceedings of the ACM PODS Conference, </booktitle> <address> San Jose, CA, USA, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: It also allows non-matching gaps in the matching subsequences. Rafiei and Mendelzon [10] extend previous work by proposing techniques to handle moving average and time scaling (i.e., globally stretching or shrinking of the time axis), but not time warping. In <ref> [7] </ref>, we et al develop domain independent framework for defining queries in terms of similarity of objects. Our framework has three components: a pattern language, a transformation rule language, and a query language.
Reference: [8] <author> Flip Korn, Nicolaos Sidropoulos, and Christos Faloutsos. </author> <title> Fast nearest neighbor search in medical image databases. </title> <booktitle> In Proceedings of VLDB Conference, </booktitle> <pages> pages 215-226, </pages> <address> Bombay, India, </address> <month> September </month> <year> 1996. </year>
Reference-contexts: As we have shown in a previous paper [5], lower-bounding the actual distance with another distance is a condition that guarantees no false dismissals for range queries and nearest neighbor queries <ref> [8] </ref>. Algorithm 2 describes how range queries can be processed. Other types of queries can be handled similarly. In the filtering step, irrelevant sequences are filtered out quickly because the D lb distance can be computed fast (linear time on the dimensionality k, typically k 10).
Reference: [9] <author> Lawrence Rabiner and Biing-Hwang Juang. </author> <title> Fundamentals of Speech Recognition. </title> <publisher> Prentice Hall, </publisher> <year> 1993. </year>
Reference-contexts: Then, we want to allow the stuttering transformation on a sequence, possibly with a penalty ("cost"): * stutter i (~x) : repeats x i and shifts the elements to the right. Following <ref> [9] </ref>, for any non-null sequences ~x and ~y, the (dynamic) time warping distance is defined as follows. 3 Symbol Definition D p L p -based distance function D base base distance function, e.g., D 1 or D 2 D warp time warping distance D lb distance function to lower-bound D warp <p> In the case of time warping distance, we allow as many stuttering as needed at no cost. Defined as a recurrence, the time-warping distance can be computed by a dynamic programming algorithm (see Appendix A or <ref> [9] </ref>) whose complexity is O (j~xj fi j~yj). See [12] for more details and other variants of the basic algorithm. Figure 1 shows two time sequences, before and after the time warping. <p> proposed method was 1, hence there were no false dismissals. (a) Scale in Sequence Length (b) Scale in Database Size (Naive with diamonds; FM+LB with crosses). 6 Conclusions We focused on the fast similarity search on a large collection of time sequences, when the dissimilarity function is the "time-warping" distance <ref> [9] </ref>, as it happens in audio and biological time sequences.
Reference: [10] <author> Davood Rafiei and Alberto Mendelzon. </author> <title> Similarity-based queries for time series data. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference, </booktitle> <address> Tucson, AZ, </address> <month> May </month> <year> 1997. </year>
Reference-contexts: The model allows the amplitude of one of the two sequences to be scaled by any suitable amount and its offset adjusted appropriately. It also allows non-matching gaps in the matching subsequences. Rafiei and Mendelzon <ref> [10] </ref> extend previous work by proposing techniques to handle moving average and time scaling (i.e., globally stretching or shrinking of the time axis), but not time warping. In [7], we et al develop domain independent framework for defining queries in terms of similarity of objects.
Reference: [11] <author> G. Salton and M.J. McGill. </author> <title> Introduction to Modern Information Retrieval. </title> <publisher> McGraw-Hill, </publisher> <year> 1983. </year>
Reference-contexts: To measure how many false-dismissals are introduced by FastMap, we use the "recall" concept from Information Retrieval <ref> [11] </ref>. 11 Definition 3 Recall is defined as follows: recall retrieved and relevant relevant The (ideal) recall value of 1.0 means there are no false-dismissals, while a recall value of 0.0 means that no relevant objects are retrieved. 5.2 Average Response Time and Recall To compare the various proposed method, we
Reference: [12] <author> David Sankoff and Joseph B. Kruskal. </author> <title> Time Warps, String Edits and Macromolecules: the Theory and Practice of Sequence Comparisons. </title> <publisher> Addison-Wesley Publishing Company, Inc., </publisher> <address> Reading, MA, </address> <year> 1983. </year>
Reference-contexts: In the case of time warping distance, we allow as many stuttering as needed at no cost. Defined as a recurrence, the time-warping distance can be computed by a dynamic programming algorithm (see Appendix A or [9]) whose complexity is O (j~xj fi j~yj). See <ref> [12] </ref> for more details and other variants of the basic algorithm. Figure 1 shows two time sequences, before and after the time warping.
Reference: [13] <author> Praveen Seshadri, Miron Livny, and Raghu Ramakrishnan. </author> <title> Sequnce query processing. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference, </booktitle> <pages> pages 430-441, </pages> <address> Minneapolis, MN, USA, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: Our framework has three components: a pattern language, a transformation rule language, and a query language. The framework can be tuned to the needs of a specific application domain, such as time sequences, molecules, text strings or images, by the choice of these languages. Sheshadri et al <ref> [13] </ref> suggest a new data model and an algebraic language for sequences in general. They also propose a sophisticated optimization technique, but do not mention about similarity among sequences and query processing technique based on similarity.
Reference: [14] <author> Dimitris Vassiliadis. </author> <title> The input-state space approach to the prediction of auroral geomagnetic activity from solar wind variables. </title> <booktitle> Int. Workshop on Applications of Artificial Intelligence in Solar Terrestrial Physics, </booktitle> <month> September </month> <year> 1993. </year> <month> 17 </month>
Reference-contexts: and IRI-9625428. 1 Applications of approximate sequence matching abound: in financial time sequences ("find stocks that move like Microsoft"); digital audio/voice clips ("find clips that sound like a given person") [1, 5]; scientific databases ("find times in the past that had similar solar magnetic wind patterns with the ones today" <ref> [14] </ref>). In the area of speech recognition, this problem has been studied extensively, and is called the "(dynamic) time warping". Virtually all speech recognition systems speed-up and slow down portions of the speech samples to be matched.
References-found: 14

