URL: http://www.informatik.uni-hildesheim.de:80/~sirene/publ/HePP_93FSS_more.ps.gz
Refering-URL: http://www.informatik.uni-hildesheim.de:80/~sirene/lit/sirene.lit.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: New Constructions of FailStop Signatures and Lower Bounds (Extended Abstract)  
Author: Eugne van Heijst Torben Pryds Pedersen Birgit Pfitzmann 
Note: To appear in Proc. Crypto '92, Santa Barbara, 16.-20.8.1992, LNCS, Springer-Verlag  
Abstract: With a failstop signature scheme, the supposed signer of a forged signature can prove to everybody else that it was a forgery. Thus the signer is secure even against computationally unrestricted forgers. Until recently, efficient constructions were only known for restricted cases, but at Eurocrypt 92, van Heijst and Pedersen presented an efficient general scheme, where the unforgeability is based on the discrete logarithm. We present a similar scheme based on factoring: Signing a message block requires approximately one modular exponentiation, and testing it requires a little more than two exponentiations. It is useful to have such alternative constructions in case one of the unproven assumptions is broken. With all failstop signatures so far, the size of the secret key is linear in the number of messages to be signed. In one sense, we prove that this cannot be avoided: The signer needs so many secretly chosen random bits. However, this does not imply that these bits ever have to be secretly stored at the same time: We present a practical construction with only logarithmic secret storage and a less practical one where the amount of secret storage is constant. We also prove rather small lower bounds for the length of public keys and signatures. All three lower bounds are within a small factor of what can be achieved with one of the known schemes. Finally, we prove that with unconditionally secure signatures, like those presented by Chaum and Roijakkers at Crypto 90, the length of a signature is at least linear in the number of participants who can test it. This shows that such schemes cannot be as efficient as failstop 1 Introduction and Overview over the Results signatures.
Abstract-found: 1
Intro-found: 1
Reference: [BPW91] <author> Gerrit Bleumer, Birgit Pfitzmann, Michael Waidner: </author> <title> A remark on a signature scheme where forgery can be proved; Eurocrypt 90, </title> <publisher> LNCS 473, Springer-Verlag, </publisher> <address> Berlin 1991, </address> <pages> 441-445. </pages>
Reference-contexts: Previous Constructions So far, there have been three significantly different results about failstop signatures. Theoretically, failstop signature schemes are known to exist if claw-free pairs of permutations (not necessarily with trapdoor) exist; see <ref> [BPW91, PW91] </ref> for descriptions and [PW90] for a proof. In particular, this shows that failstop signatures exist if factoring large integers or computing discrete logarithms is hard. The construction uses onetime signatures, similar to [L79], i.e., messages are basically signed bit by bit. <p> This size depends on the chosen family of homomorphisms. E. van Heijst, T. Pedersen, B. Pfitzmann: FailStop Signatures 7 3.2 The Special Case with Factoring Our family of bundling homomorphisms was defined in <ref> [BPW91] </ref>, using ideas from [GMR88, G87]: A member of the family is characterized by t and a k-bit integer n = pq, with p, q prime and p 3 and q 7 mod 8. We omit t and n in the following. <p> Furthermore, if n is chosen correctly or at least as n = p r q s where p and q are correct and r, s odd, then for any a, z, there exists exactly one x so that h ((a, x)) = z. Proof: See <ref> [BPW91] </ref>. The last sentence is only proved for correctly chosen n there, but the same proof is valid for the more general form.
Reference: [CA90] <author> David Chaum, Hans van Antwerpen: </author> <title> Undeniable signatures; Crypto 89, </title> <publisher> LNCS 435, Springer-Verlag, </publisher> <address> Heidelberg 1990, </address> <pages> 212-216. </pages>
Reference-contexts: However, fast hash functions can be used without reducing the security of the signer. Related Types of Systems In [CHP92], unconditional security for the signer was achieved in undeniable signatures (cf. <ref> [CA90] </ref>). The construction was the first not to use bit-by-bit signing.
Reference: [CHP92] <author> David Chaum, Eugne van Heijst, Birgit Pfitzmann: </author> <title> Cryptographically Strong Undeniable Signatures, Unconditionally Secure for the Signer; Crypto 91, </title> <publisher> LNCS 576, Springer-Verlag, </publisher> <address> Berlin 1992, </address> <pages> 470-484. </pages>
Reference-contexts: In contrast to RSA, the signer needs some new random bits for each new signature, and tree authentication is needed to keep the public keys short. However, fast hash functions can be used without reducing the security of the signer. Related Types of Systems In <ref> [CHP92] </ref>, unconditional security for the signer was achieved in undeniable signatures (cf. [CA90]). The construction was the first not to use bit-by-bit signing.
Reference: [CR91] <author> David Chaum, Sandra Roijakkers: </author> <title> Unconditionally Secure Digital Signatures; Crypto 90, </title> <publisher> LNCS 537, Springer-Verlag, </publisher> <address> Berlin 1991, </address> <pages> 206-214. </pages>
Reference-contexts: Pedersen, B. Pfitzmann: FailStop Signatures 3 whether they are disavowed due to a proof of forgery). In particular, one cannot stop the scheme as soon as this happens. In <ref> [CR91] </ref>, unconditionally secure signatures were introduced, i.e., signature-like schemes where both the signer and the recipient are unconditionally secure.
Reference: [D88] <author> Ivan Bjerre Damgfird: </author> <title> Collision free hash functions and public key signature schemes; Eurocrypt 87, </title> <publisher> LNCS 304, Springer-Verlag, </publisher> <address> Berlin 1988, </address> <pages> 203-216. </pages>
Reference-contexts: We can choose any fixed message length r; long messages are hashed before signing. Since even the hash functions as secure as factoring from <ref> [D88] </ref> take only one multiplication per message bit, i.e., not more than signing or testing, one should always hash messages as short as possible. Thus r is determined by the size of the output of the hash function.
Reference: [DH76] <author> Whitfield Diffie, Martin E. Hellman: </author> <booktitle> New Directions in Cryptography; IEEE Transactions on Information Theory 22/6 (1976) 644-654. </booktitle>
Reference-contexts: 1 Introduction and Overview over the Results Ordinary and FailStop Signatures Ordinary digital signatures, as introduced in <ref> [DH76] </ref> and formally defined in [GMR88], allow a person who knows a secret key to make signatures that everybody else can verify with a corresponding public key. Such signatures can only be computationally secure: A forger with unrestricted computing power can always forge signatures of other persons.
Reference: [F71] <author> William Feller: </author> <title> An Introduction to Probability Theory and Its Applications, </title> <booktitle> Vol. II (2nd. </booktitle> <publisher> ed.); John Wiley & Sons, </publisher> <address> New York 1971. </address>
Reference-contexts: Additionally, when we know that the probability that something can be guessed correctly is small, and want to derive that a conditional entropy is large, we often need Jensens inequality for the special case of the logarithm <ref> [F71] </ref>: If p i 0 and x i &gt; 0 for all i, and the sum of the p i s is 1, then log ( p i x i ) p i log (x i ) . 4.1 Secret Keys, or Rather, Secret Random Choices The basic reason why the
Reference: [G68] <author> Robert G. Gallager: </author> <title> Information Theory and Reliable Communication; John Wiley & Sons, </title> <address> New York 1968. </address> <note> E. </note> <author> van Heijst, T. Pedersen, B. Pfitzmann: </author> <note> FailStop Signatures 16 </note>
Reference-contexts: For the formal sketches, we assume the reader knows the notions of conditional entropy, H (X | Y), and mutual information, I (X; Y); see [S49, G68 Sect. 2.2, 2.3]. Like in <ref> [G68] </ref>, we use capital letters for random variables and small letters for corresponding values, and abbreviate P (X = x) by P (x) etc.
Reference: [G87] <author> Oded Goldreich: </author> <title> Two Remarks Concerning the Goldwasser-Micali-Rivest Signature Scheme; Crypto 86, </title> <publisher> LNCS 263, Springer-Verlag, </publisher> <address> Berlin 1987, </address> <pages> 104-110. </pages>
Reference-contexts: This size depends on the chosen family of homomorphisms. E. van Heijst, T. Pedersen, B. Pfitzmann: FailStop Signatures 7 3.2 The Special Case with Factoring Our family of bundling homomorphisms was defined in [BPW91], using ideas from <ref> [GMR88, G87] </ref>: A member of the family is characterized by t and a k-bit integer n = pq, with p, q prime and p 3 and q 7 mod 8. We omit t and n in the following.
Reference: [GMR88] <author> Shafi Goldwasser, Silvio Micali, Ronald L. Rivest: </author> <title> A Digital Signature Scheme Secure Against Adaptive Chosen-Message Attacks; SIAM J. </title> <institution> Comput. </institution> <month> 17/2 </month> <year> (1988) </year> <month> 281-308. </month>
Reference-contexts: 1 Introduction and Overview over the Results Ordinary and FailStop Signatures Ordinary digital signatures, as introduced in [DH76] and formally defined in <ref> [GMR88] </ref>, allow a person who knows a secret key to make signatures that everybody else can verify with a corresponding public key. Such signatures can only be computationally secure: A forger with unrestricted computing power can always forge signatures of other persons. <p> This size depends on the chosen family of homomorphisms. E. van Heijst, T. Pedersen, B. Pfitzmann: FailStop Signatures 7 3.2 The Special Case with Factoring Our family of bundling homomorphisms was defined in [BPW91], using ideas from <ref> [GMR88, G87] </ref>: A member of the family is characterized by t and a k-bit integer n = pq, with p, q prime and p 3 and q 7 mod 8. We omit t and n in the following. <p> We use the scheme described in Section 3.1 combined with message hashing. Hence the construction works for the schemes from [HP92] and Section 3.2. E. van Heijst, T. Pedersen, B. Pfitzmann: FailStop Signatures 13 (a) Small amount of secret information at the start: Use top-down tree-authentication similar to <ref> [M88, GMR88] </ref>. (Note that a different bottom-up version, which is a little more efficient if one does not consider secret storage space, was normally used with failstop signatures so far.) Let a prekey, i.e., a bundling homomorphism h, be given.
Reference: [GP88] <author> Jeroen van de Graaf, Ren Peralta: </author> <title> A simple and secure way to show the validity of your public key; Crypto 87, </title> <publisher> LNCS 293, Springer-Verlag, </publisher> <address> Berlin 1988, </address> <pages> 128-134. </pages>
Reference-contexts: To use these homomorphism in a failstop signature scheme according to Sect. 3.1, let the message space be -0, , 2 r 1- for some r and t := r + s. As an efficient prekey test, we use the protocol from <ref> [GP88] </ref> and a test that n 5 mod 8. Actually, this does not completely prove that n is of the correct form, but it ensures that n = p r q s where p and q are correct and r, s odd.
Reference: [HP92] <author> Eugne van Heijst, Torben Pryds Pedersen: </author> <title> How to Make Efficient Failstop Signatures; Eurocrypt 92, Extended Abstracts, </title> <journal> 24.-28. </journal> <volume> 5. </volume> <year> 1992, </year> <title> Balatonfred, </title> <booktitle> Hungary, </booktitle> <pages> 337-346. </pages>
Reference-contexts: However, in this scheme, all signatures by one client (with one key) must have the same recipient, like the bank in a payment system. Furthermore, signing is a 3-round protocol between the signer and the recipient. The first efficient general failstop signature scheme was presented in <ref> [HP92] </ref>. The unforgeability relies on a discrete logarithm assumption. Signatures for one message block are about as efficient as with RSA. Messages can be hashed before signing. <p> Hence they cannot replace ordinary or failstop signatures at present. Overview over the New Results We present two new constructions of efficient failstop signatures (Ch. 3 and 5) and some general lower bounds (Ch. 4). The first construction has similar properties to that from <ref> [HP92] </ref>, but the unforgeability is based on factoring instead of the discrete logarithm. Signing a message block requires about one modular exponentiation, testing a little more than two. Key exchange is in general more complicated than for the discrete logarithm scheme. <p> To emphasize the generality of the construction, the scheme is first described in general terms. Like in <ref> [HP92] </ref>, we first present a version for signing just one message block. 3.1 General Structure of the Construction The following construction generalizes that from [HP92]. <p> To emphasize the generality of the construction, the scheme is first described in general terms. Like in <ref> [HP92] </ref>, we first present a version for signing just one message block. 3.1 General Structure of the Construction The following construction generalizes that from [HP92]. We base it on socalled bundling homomorphisms, i.e., functions h with the following properties: 1 . h is a homomorphism between two Abelian groups. 2 . Given an image h (a), there exist at least 2 t possible preimages. 3 . <p> E. van Heijst, T. Pedersen, B. Pfitzmann: FailStop Signatures 8 sign: k multiplications test: 2k + s multiplications Length of pk: 2k Length of sk: 4k + 2s Signature length: 2k + s To sign several messages, one can use tree authentication as in <ref> [PW91, HP92] </ref>, after [M80]. <p> Note that key exchange is more efficient in <ref> [HP92] </ref> because the choice of the prekey is just a choice of random numbers, and no prekey test is necessary even if there is no trusted device to choose the prekey. 4 Lower Bounds The idea of each of our proofs will first be described informally. <p> The basis of this section is a failstop signature scheme for signing just one message of arbitrary length. We use the scheme described in Section 3.1 combined with message hashing. Hence the construction works for the schemes from <ref> [HP92] </ref> and Section 3.2. E. van Heijst, T. Pedersen, B. <p> Thus the list-like version should only be used with a fixed recipient, who can store the part of the list he already received, like in [P91]. One can also use trees of other forms or combine it with other methods to sign several messages from <ref> [HP92] </ref>. 6 Conclusion We have constructed efficient failstop signatures based on the assumption that factoring large integers is hard, giving an alternative to the previous scheme based on a discrete logarithm assumption.
Reference: [L79] <author> Leslie Lamport: </author> <title> Constructing Digital Signatures from a One-Way Function; SRI Intl. </title> <address> CSL-98, </address> <month> Oct. </month> <year> 1979. </year>
Reference-contexts: In particular, this shows that failstop signatures exist if factoring large integers or computing discrete logarithms is hard. The construction uses onetime signatures, similar to <ref> [L79] </ref>, i.e., messages are basically signed bit by bit. Therefore, although messages can be hashed before signing and tree-authentication is used (similar to [M80]), this general construction is not very efficient. There is an efficient variant especially suited for making clients unconditionally secure in online payment systems, see [P91].
Reference: [M80] <author> Ralph C. Merkle: </author> <title> Protocols for Public Key Cryptosystems; Proc. </title> <booktitle> 1980 Symposium on Security and Privacy, Oakland 1980, </booktitle> <pages> 122-134. </pages>
Reference-contexts: In particular, this shows that failstop signatures exist if factoring large integers or computing discrete logarithms is hard. The construction uses onetime signatures, similar to [L79], i.e., messages are basically signed bit by bit. Therefore, although messages can be hashed before signing and tree-authentication is used (similar to <ref> [M80] </ref>), this general construction is not very efficient. There is an efficient variant especially suited for making clients unconditionally secure in online payment systems, see [P91]. However, in this scheme, all signatures by one client (with one key) must have the same recipient, like the bank in a payment system. <p> E. van Heijst, T. Pedersen, B. Pfitzmann: FailStop Signatures 8 sign: k multiplications test: 2k + s multiplications Length of pk: 2k Length of sk: 4k + 2s Signature length: 2k + s To sign several messages, one can use tree authentication as in [PW91, HP92], after <ref> [M80] </ref>.
Reference: [M88] <author> Ralph C. Merkle: </author> <title> A digital signature based on a conventional encryption function; Crypto 87, </title> <publisher> LNCS 293, Springer-Verlag, </publisher> <address> Berlin 1988, </address> <pages> 369-378. </pages>
Reference-contexts: We use the scheme described in Section 3.1 combined with message hashing. Hence the construction works for the schemes from [HP92] and Section 3.2. E. van Heijst, T. Pedersen, B. Pfitzmann: FailStop Signatures 13 (a) Small amount of secret information at the start: Use top-down tree-authentication similar to <ref> [M88, GMR88] </ref>. (Note that a different bottom-up version, which is a little more efficient if one does not consider secret storage space, was normally used with failstop signatures so far.) Let a prekey, i.e., a bundling homomorphism h, be given.
Reference: [P91] <author> Birgit Pfitzmann: </author> <booktitle> Failstop Signatures; Principles and Applications; Proc. Compsec 91, 8th world conference on computer security, audit and control, </booktitle> <publisher> Elsevier, Oxford 1991, </publisher> <pages> 125-134. </pages>
Reference-contexts: This is where the name fail-stop comes from. For more details about possible benefits of failstop signatures in applications, e.g., in electronic payment systems, and possible advantages for the acceptability of digital signatures in law, see <ref> [PW91, P91] </ref>. Previous Constructions So far, there have been three significantly different results about failstop signatures. Theoretically, failstop signature schemes are known to exist if claw-free pairs of permutations (not necessarily with trapdoor) exist; see [BPW91, PW91] for descriptions and [PW90] for a proof. <p> Therefore, although messages can be hashed before signing and tree-authentication is used (similar to [M80]), this general construction is not very efficient. There is an efficient variant especially suited for making clients unconditionally secure in online payment systems, see <ref> [P91] </ref>. However, in this scheme, all signatures by one client (with one key) must have the same recipient, like the bank in a payment system. Furthermore, signing is a 3-round protocol between the signer and the recipient. The first efficient general failstop signature scheme was presented in [HP92]. <p> However, later signatures are very long. Thus the list-like version should only be used with a fixed recipient, who can store the part of the list he already received, like in <ref> [P91] </ref>.
Reference: [PW90] <author> Birgit Pfitzmann, Michael Waidner: </author> <title> Formal Aspects of Failstop Signatures; Fakultt fr Informatik, </title> <institution> University Karlsruhe, </institution> <type> Report 22/90, </type> <month> Dec. </month> <year> 1990. </year>
Reference-contexts: Pedersen, B. Pfitzmann: FailStop Signatures 2 With failstop signatures, introduced in [WP90] and formally defined in <ref> [PW90] </ref>, unforgeability also relies on a computational assumption. If nevertheless a signature is forged, the alleged signer can prove that the signature is a forgery. More precisely, she can prove that the underlying computational assumption has been broken. <p> Previous Constructions So far, there have been three significantly different results about failstop signatures. Theoretically, failstop signature schemes are known to exist if claw-free pairs of permutations (not necessarily with trapdoor) exist; see [BPW91, PW91] for descriptions and <ref> [PW90] </ref> for a proof. In particular, this shows that failstop signatures exist if factoring large integers or computing discrete logarithms is hard. The construction uses onetime signatures, similar to [L79], i.e., messages are basically signed bit by bit. <p> However, it is no problem to make proofs of forgery specific to the keys of individual signers or even (although currently with some loss in efficiency) to each particular signature. For a complete formal definition, see <ref> [PW90] </ref>. In this abstract, we will only make those parts more precise that are actually needed in the proofs of the lower bounds. 3 Efficient FailStop Signatures based on Factoring This section presents a failstop signature scheme based on the assumption that it is infeasible to factor large integers.
Reference: [PW91] <author> Birgit Pfitzmann, Michael Waidner: </author> <title> Failstop Signatures and their Application; Securicom 91, </title> <address> Paris, 19.-22. </address> <month> March </month> <year> 1991, </year> <pages> 145-160. </pages>
Reference-contexts: This is where the name fail-stop comes from. For more details about possible benefits of failstop signatures in applications, e.g., in electronic payment systems, and possible advantages for the acceptability of digital signatures in law, see <ref> [PW91, P91] </ref>. Previous Constructions So far, there have been three significantly different results about failstop signatures. Theoretically, failstop signature schemes are known to exist if claw-free pairs of permutations (not necessarily with trapdoor) exist; see [BPW91, PW91] for descriptions and [PW90] for a proof. <p> Previous Constructions So far, there have been three significantly different results about failstop signatures. Theoretically, failstop signature schemes are known to exist if claw-free pairs of permutations (not necessarily with trapdoor) exist; see <ref> [BPW91, PW91] </ref> for descriptions and [PW90] for a proof. In particular, this shows that failstop signatures exist if factoring large integers or computing discrete logarithms is hard. The construction uses onetime signatures, similar to [L79], i.e., messages are basically signed bit by bit. <p> E. van Heijst, T. Pedersen, B. Pfitzmann: FailStop Signatures 8 sign: k multiplications test: 2k + s multiplications Length of pk: 2k Length of sk: 4k + 2s Signature length: 2k + s To sign several messages, one can use tree authentication as in <ref> [PW91, HP92] </ref>, after [M80].
Reference: [PW92] <author> Birgit Pfitzmann, Michael Waidner: </author> <title> Unconditional Byzantine Agreement for any Number of Faulty Processors; STACS 92, </title> <publisher> LNCS 577, Springer-Verlag, </publisher> <address> Berlin 1992, </address> <pages> 339-350. </pages>
Reference-contexts: Pedersen, B. Pfitzmann: FailStop Signatures 3 whether they are disavowed due to a proof of forgery). In particular, one cannot stop the scheme as soon as this happens. In [CR91], unconditionally secure signatures were introduced, i.e., signature-like schemes where both the signer and the recipient are unconditionally secure. In <ref> [PW92] </ref>, a transferable version was presented, i.e., signatures can be passed on from one recipient to another, and security against active attacks on recipients was achieved; such attacks must be considered because the recipients, too, have secret information in such schemes.
Reference: [S49] <author> Claude E. </author> <title> Shannon: </title> <booktitle> Communication in the Presence of Noise; Proceedings of the Institute of Radio Engineers 37/1 (1949) 10-21. </booktitle>
Reference-contexts: For the formal sketches, we assume the reader knows the notions of conditional entropy, H (X | Y), and mutual information, I (X; Y); see <ref> [S49, G68 Sect. 2.2, 2.3] </ref>. Like in [G68], we use capital letters for random variables and small letters for corresponding values, and abbreviate P (X = x) by P (x) etc.
Reference: [WP90] <author> Michael Waidner, Birgit Pfitzmann: </author> <title> The Dining Cryptographers in the Disco: Unconditional Sender and Recipient Untraceability with Computationally Secure Serviceability; Eurocrypt 89, </title> <publisher> LNCS 434, Springer-Verlag, </publisher> <address> Berlin 1990, </address> <note> 690. (Full version: </note> <institution> Unconditional Sender and Recipient Untraceability in spite of Active Attacks Some Remarks; Fakultt fr Informatik, University Karlsruhe, </institution> <type> Report 5/89, </type> <month> March </month> <year> 1989.) </year>
Reference-contexts: Pedersen, B. Pfitzmann: FailStop Signatures 2 With failstop signatures, introduced in <ref> [WP90] </ref> and formally defined in [PW90], unforgeability also relies on a computational assumption. If nevertheless a signature is forged, the alleged signer can prove that the signature is a forgery. More precisely, she can prove that the underlying computational assumption has been broken.
References-found: 21

