URL: http://www.cs.uoregon.edu/paracomp/proj/ariadne/papers/front95/front95.ps.gz
Refering-URL: http://www.cs.uoregon.edu/paracomp/proj/ariadne/publications.html
Root-URL: http://www.cs.uoregon.edu
Title: A Scalable, Visual Interface for Debugging with Event-Based Behavioral Abstraction  
Author: Joydip Kundu Janice E. Cuny 
Address: Amherst, MA 01003 Eugene, OR 97403  
Affiliation: Department of Computer Science Department of Computer Science University of Massachusetts University of Oregon  
Abstract: Event-based behavioral abstraction, in which models of intended program behavior are compared to actual program behavior, offers solutions to many of the debugging problems introduced by parallelism. Currently, however, its widespread application is limited by an inability to provide sufficient feedback on the mismatches between intended and actual behaviors, and an inability to provide output that scales for large or complex systems. The AVE/Ariadne debugging system was developed to address these limitations. Ariadne is a post mortem debugger that combines a simple modeling language with functional queries to support thorough exploration of execution traces. AVE is a visual interface to Ariadne that provides scalable, visual feedback. AVE features hierarchical visualizations that reflect the structure of user-defined behavioral models, dynamic attribute calculation, and automatic partitioning of matched behaviors and attributes. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abrams, N. Doraswamy, and A. Mathur. Chi-tra: </author> <title> visual analysis of parallel and distributed programs in time, event and frequency domains. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> Vol. 3, No. 6, </volume> <pages> pages 672-685, </pages> <month> Nov. </month> <year> 1992. </year>
Reference: [2] <author> F. Baiardi, N. De Fransesco, and G. Vaglini. </author> <title> Development of a debugger for a concurrent language. </title> <journal> In IEEE Transactions on Software Engineering, </journal> <volume> Vol. SE-12, No. 4, </volume> <pages> pages 547-553, </pages> <month> Apr. </month> <year> 1986. </year>
Reference-contexts: Event-based techniques offer an alternative in which user-specified models of intended program behavior are compared to actual program behavior as captured in execution traces <ref> [2, 3, 16, 19] </ref>.
Reference: [3] <author> P. C. Bates. </author> <title> Debugging Programs in a Distributed System Environment. </title> <type> PhD Thesis, </type> <institution> University of Massachusetts, </institution> <year> 1986. </year>
Reference-contexts: Event-based techniques offer an alternative in which user-specified models of intended program behavior are compared to actual program behavior as captured in execution traces <ref> [2, 3, 16, 19] </ref>. <p> The matching algorithm for our language is straightforward: a pt-chain is recognized by a finite state machine that invokes copies of other finite state machines to recognize chains on specific processes. This matching can be done efficiently 2 , avoiding the costliness of pattern matching approaches <ref> [3, 15] </ref> and the expensive implementations (number of states can potentially be exponential in the length of the parallel expression to be recognized) of previous languages [19].
Reference: [4] <author> P. C. Bates, </author> <title> private communication. </title>
Reference-contexts: The EBBA toolset also provides visualizations of match trees but it does not have automatic partitioning and dynamic attribute calculation <ref> [4] </ref>. Issues related to scalable visualization have been explored in the context of performance visualization in other systems [1,6,27]. None of these, however, deal with the multi-dimensionality of logical time or provide complex user-defined abstraction mechanisms.
Reference: [5] <author> R. Cooper and K. Marzullo. </author> <title> Consistent detection of global predicates. </title> <booktitle> In Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 167-174, </pages> <year> 1991. </year>
Reference-contexts: Event-based techniques offer an alternative in which user-specified models of intended program behavior are compared to actual program behavior as captured in execution traces [2, 3, 16, 19]. The use of event traces with replay mechanisms avoids issues of global state consistency <ref> [5, 27] </ref> and reproducibility; the use of abstraction makes it possible to contend with large quantities of data; and the use of logical time transformations filters out perturbations due to asynchrony [8, 23].
Reference: [6] <author> A. Couch. </author> <title> Graphical Representations of Program Performance on Hypercube Message-Passing Multiprocessors, </title> <type> Ph.D. Thesis, </type> <institution> Tufts University, </institution> <year> 1988. </year>
Reference: [7] <author> A. Couch, </author> <title> "Categories and Context in Scalable Execution Visualization," </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> Vol. 18, </volume> <pages> pages 195-203 (1993). </pages>
Reference-contexts: of attribute values with each partition mapped to a color; note that automatic color binning has been used with the color black representing the range of values f1, 2, 4, 8, 16, 32, 64g, while the color white is used to represent the values f96, 112, 120, 124, 126, 127g <ref> [7] </ref>. Here, because of reproduction limitations, we set the number of colors to 2 so only black and white were used. The scatter plot led us to the bug.
Reference: [8] <author> J. E. Cuny, A. Hough, and J. Kundu. </author> <title> Logical time in visualizations produced by parallel programs. </title> <booktitle> Proceedings of Visualization '92, </booktitle> <pages> pages 186-193 (1992). </pages>
Reference-contexts: The use of event traces with replay mechanisms avoids issues of global state consistency [5, 27] and reproducibility; the use of abstraction makes it possible to contend with large quantities of data; and the use of logical time transformations filters out perturbations due to asynchrony <ref> [8, 23] </ref>. Currently, however, event-based parallel debugging tools are limited because (1) they can not provide sufficient feedback on the mismatches between intended and actual behaviors, and (2) their outputs do not scale well for large or complex programs.
Reference: [9] <author> J. E. Cuny, G. Forman, A. Hough, J. Kundu, C. Lin, L. Snyder, and D. Stemple. </author> <title> The Ari-adne debugger: scalable application of event-based abstraction. </title> <journal> SIGPLAN Notices, </journal> <volume> Vol. 28, No. 12, </volume> <pages> pages 85-95, </pages> <year> 1994. </year>
Reference-contexts: Currently, however, event-based parallel debugging tools are limited because (1) they can not provide sufficient feedback on the mismatches between intended and actual behaviors, and (2) their outputs do not scale well for large or complex programs. The Ariadne 1 debugger <ref> [9] </ref> was developed to address the first of these limitations. Most existing tools that support event-based behavioral abstraction use a powerful, expressive modeling language that requires complex recognition strategies with only "match/no match" outcomes.
Reference: [10] <author> C. J. Fidge. </author> <title> Partial orders for parallel debugging. </title> <journal> SIGPLAN Notices, </journal> <volume> Vol. 24, No. 1, </volume> <pages> pages 183-194, </pages> <year> 1989. </year>
Reference-contexts: Similar extensions have previously been proposed <ref> [10, 12, 19, 22] </ref> but we have found our definitions to be more appropriate for debugging.
Reference: [11] <author> R. J. Fowler, T. J. Leblanc, and J. M. Mellor-Crummey. </author> <title> An integrated approach to parallel program debugging and performance analysis on large-scale multiprocessors. </title> <journal> SIGPLAN Notices, </journal> <volume> Vol. 24, No. 1, </volume> <pages> pages 163-173, </pages> <year> 1989. </year>
Reference-contexts: Existing parallel debuggers use either process-oriented or event-oriented visualizations. Process-oriented visualizations depict event activity on a set of interconnected process icons [16, 31] and, thus, are limited to systems with relatively small numbers of processes. Event-oriented visualizations allow the user to scroll through event traces or process-time graphs <ref> [11, 13, 14, 25] </ref> but typically do not show user-defined abstractions.
Reference: [12] <author> D. Haban, and W. Weigel. </author> <title> Global events and global breakpoints in distributed systems. </title> <booktitle> 21st Annual Hawaii International Conference on System Sciences, </booktitle> <pages> pages 166-174, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: Similar extensions have previously been proposed <ref> [10, 12, 19, 22] </ref> but we have found our definitions to be more appropriate for debugging.
Reference: [13] <author> P. K. Harter, D. M. Heimbigner and R. King. IDD: </author> <title> an interactive distributed debugger. </title> <booktitle> In Proceedings of the 5th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 498-506, </pages> <year> 1985. </year>
Reference-contexts: Existing parallel debuggers use either process-oriented or event-oriented visualizations. Process-oriented visualizations depict event activity on a set of interconnected process icons [16, 31] and, thus, are limited to systems with relatively small numbers of processes. Event-oriented visualizations allow the user to scroll through event traces or process-time graphs <ref> [11, 13, 14, 25] </ref> but typically do not show user-defined abstractions.
Reference: [14] <author> M. Heath and J. Etheridge. </author> <title> Visualizing the performance of parallel programs. </title> <journal> IEEE Software, </journal> <volume> Vol. 8, No. 5, </volume> <pages> pages 29-39, </pages> <year> 1991. </year>
Reference-contexts: Existing parallel debuggers use either process-oriented or event-oriented visualizations. Process-oriented visualizations depict event activity on a set of interconnected process icons [16, 31] and, thus, are limited to systems with relatively small numbers of processes. Event-oriented visualizations allow the user to scroll through event traces or process-time graphs <ref> [11, 13, 14, 25] </ref> but typically do not show user-defined abstractions.
Reference: [15] <author> D. Hembold and D. Luckham. </author> <title> Debugging Ada tasking programs. </title> <journal> IEEE Software, </journal> <volume> Vol. 2, No. 2, </volume> <pages> pages 47-57, </pages> <month> Mar. </month> <year> 1985. </year>
Reference-contexts: The matching algorithm for our language is straightforward: a pt-chain is recognized by a finite state machine that invokes copies of other finite state machines to recognize chains on specific processes. This matching can be done efficiently 2 , avoiding the costliness of pattern matching approaches <ref> [3, 15] </ref> and the expensive implementations (number of states can potentially be exponential in the length of the parallel expression to be recognized) of previous languages [19].
Reference: [16] <author> A. A. Hough. </author> <title> Debugging Parallel Programs Using Abstract Visualizations. </title> <type> PhD Thesis, </type> <institution> University of Massachusetts, </institution> <year> 1991. </year>
Reference-contexts: Event-based techniques offer an alternative in which user-specified models of intended program behavior are compared to actual program behavior as captured in execution traces <ref> [2, 3, 16, 19] </ref>. <p> The Ariadne Visualization Engine (AVE), introduced in this paper, was developed to address the second of these limitations: it provides scalable visualizations of debugging output. Existing parallel debuggers use either process-oriented or event-oriented visualizations. Process-oriented visualizations depict event activity on a set of interconnected process icons <ref> [16, 31] </ref> and, thus, are limited to systems with relatively small numbers of processes. Event-oriented visualizations allow the user to scroll through event traces or process-time graphs [11, 13, 14, 25] but typically do not show user-defined abstractions.
Reference: [17] <author> A. A. Hough and J. E. Cuny. </author> <title> Perspective views: A technique for enchancing visualizations of parallel programs. </title> <booktitle> In 1990 International Conference on Parallel Processing, </booktitle> <pages> pages II 124-132, </pages> <month> Aug. </month> <year> 1990. </year>
Reference-contexts: Thus, we are interested in the ordering of events not in physical time but in logical time. At the primitive event level, this ordering is captured by Lamport's happened before relation. We extend Lamport's relation to sets of primitive events; defining three relations: precedes, parallels, and overlaps <ref> [17] </ref> for use in the construction of pt-chains.
Reference: [18] <author> P. Hudak, S. Peyton Jones, and P. Wadler. </author> <title> Report on the programming language Haskell, a non-strict purely functional language Version 1.2. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> Vol 27, No. 5, </volume> <month> May </month> <year> 1992. </year>
Reference-contexts: Ariadne can also repartition the displayed tree structure based on attribute values (not shown here) with a mechanism similar to set comprehension that is available in functional languages like Haskell <ref> [18] </ref>. This feature allows the user to determine whether a set of events satisfy a number of different constraints. All functions in Ariadne walk the same match tree, making it easy to add new functional queries.
Reference: [19] <author> W. Hseush and G. E. Kaiser. </author> <title> Modeling concur-rency in parallel debugging. </title> <booktitle> In Proceedings of the Second ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 11-20, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: Event-based techniques offer an alternative in which user-specified models of intended program behavior are compared to actual program behavior as captured in execution traces <ref> [2, 3, 16, 19] </ref>. <p> This matching can be done efficiently 2 , avoiding the costliness of pattern matching approaches [3, 15] and the expensive implementations (number of states can potentially be exponential in the length of the parallel expression to be recognized) of previous languages <ref> [19] </ref>. <p> Similar extensions have previously been proposed <ref> [10, 12, 19, 22] </ref> but we have found our definitions to be more appropriate for debugging.
Reference: [20] <institution> Kendall Square Research. </institution> <note> UDB User's Guide. KSR1 Documentation, </note> <month> Feb </month> <year> 1992. </year>
Reference-contexts: 1 Introduction The debugging of parallel programs is often difficult. Standard state-based techniques <ref> [20, 28] </ref> are not effective because of the sparsity of consistent global states, the large volume of trace data, the effects of asynchrony, and the lack of reproducibility.
Reference: [21] <author> L. Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> Vol. 21, No. 7, </volume> <pages> pages 558-565, </pages> <year> 1978. </year>
Reference-contexts: It facilitates the exploration of execution traces stored internally as execution history graphs in which nodes represent events and edges represent Lamport's happened before relation <ref> [21] </ref>. Primitive events include all of the standard interprocess communication events such as send, receive, and barrier synchronization as well as user-specified events such as procedure entries and exits.
Reference: [22] <author> L. Lamport. </author> <title> The mutual exclusion problem: Part I-A theory of interprocess communication. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> Vol. 33, No. 2, </volume> <pages> pages 313-326, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: Similar extensions have previously been proposed <ref> [10, 12, 19, 22] </ref> but we have found our definitions to be more appropriate for debugging.
Reference: [23] <author> R. J. LeBlanc and A. D. Robbins. </author> <title> Event-driven monitoring of distributed programs. </title> <booktitle> In Proceedings of the 5th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 515-522, </pages> <year> 1985. </year>
Reference-contexts: The use of event traces with replay mechanisms avoids issues of global state consistency [5, 27] and reproducibility; the use of abstraction makes it possible to contend with large quantities of data; and the use of logical time transformations filters out perturbations due to asynchrony <ref> [8, 23] </ref>. Currently, however, event-based parallel debugging tools are limited because (1) they can not provide sufficient feedback on the mismatches between intended and actual behaviors, and (2) their outputs do not scale well for large or complex programs.
Reference: [24] <author> T. J. LeBlanc and J. M. Mellor-Crummey. </author> <title> Debugging parallel programs with instant replay. </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol C-36, No. 4, </volume> <pages> pages 471-482, </pages> <month> Apr. </month> <year> 1987. </year>
Reference-contexts: Primitive events include all of the standard interprocess communication events such as send, receive, and barrier synchronization as well as user-specified events such as procedure entries and exits. Eventually Ariadne will have replay capabilities <ref> [24] </ref> and a facility for incremental instrumentation and re-execution; at the moment, our instrumentation is hand-coded. Ariadne matches models of expected behavior against the execution history graph in order to extract matched or partially matched subgraphs.
Reference: [25] <author> T. J. LeBlanc, J. M. Mellor-Crummey, and R. J. Fowler. </author> <title> Analyzing parallel program executions using multiple views. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> Vol 9, </volume> <pages> pages 203-217, </pages> <year> 1990. </year>
Reference-contexts: Existing parallel debuggers use either process-oriented or event-oriented visualizations. Process-oriented visualizations depict event activity on a set of interconnected process icons [16, 31] and, thus, are limited to systems with relatively small numbers of processes. Event-oriented visualizations allow the user to scroll through event traces or process-time graphs <ref> [11, 13, 14, 25] </ref> but typically do not show user-defined abstractions.
Reference: [26] <author> V. M. Lo, S. Rajopadhye, M. A. Mohamed, S. Gupta, B. Nitzberg, J. A. Telle, X. X. Zhong. LaRCS: </author> <title> A language for describing parallel computations for the purpose of mapping. </title> <type> Technical Report CIS-TR-90-16, </type> <institution> University of Oregon Dept. of Computer Science, </institution> <year> 1990. </year>
Reference-contexts: The three definitional levels appear to form a natural mechanism for describing parallel systems, as evidenced by their use in other contexts such as the XYZ levels of Phase Abstractions [30] and the LaRCS specification language <ref> [26] </ref>. The matching algorithm for our language is straightforward: a pt-chain is recognized by a finite state machine that invokes copies of other finite state machines to recognize chains on specific processes.
Reference: [27] <author> Y. Manabe, and M. Imase. </author> <title> Global conditions in debugging distributed programs. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> Vol. 15, </volume> <pages> pages 62-69, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: Event-based techniques offer an alternative in which user-specified models of intended program behavior are compared to actual program behavior as captured in execution traces [2, 3, 16, 19]. The use of event traces with replay mechanisms avoids issues of global state consistency <ref> [5, 27] </ref> and reproducibility; the use of abstraction makes it possible to contend with large quantities of data; and the use of logical time transformations filters out perturbations due to asynchrony [8, 23].
Reference: [28] <institution> Sequent Computer Systems, Inc. </institution> <note> DYNIX Pdbx Debugger User's Manual. </note> <year> 1986. </year>
Reference-contexts: 1 Introduction The debugging of parallel programs is often difficult. Standard state-based techniques <ref> [20, 28] </ref> are not effective because of the sparsity of consistent global states, the large volume of trace data, the effects of asynchrony, and the lack of reproducibility.
Reference: [29] <institution> Sequent Computer Systems, Inc. </institution> <note> Guide to Parallel Programming on Sequent Computer Systems. </note> <year> 1987. </year>
Reference-contexts: Note that the numbers in the Category Statistics does not signify the value of the attribute dist, but the frequency distribution of the attribute 4 . 3.3 Dynamic Task Allocation. This program was taken directly from the Sequent Programming Guide <ref> [29] </ref>. It was written for shared memory and uses a dynamic task allocation scheme to search a list of cities for the one closest to an origin. Each process repeatedly gets a sublist of cities and determines whether any of them is closer than the closest city currently known.
Reference: [30] <author> L. Snyder. </author> <title> The XYZ abstraction levels of Poker-like languages. Languages and Compilers for Parallel Computing, </title> <editor> David Gelernter and Alexandru Nicolau and David Padua(eds.), </editor> <publisher> MIT Press, </publisher> <pages> pages 470-489, </pages> <year> 1990. </year>
Reference-contexts: The three definitional levels appear to form a natural mechanism for describing parallel systems, as evidenced by their use in other contexts such as the XYZ levels of Phase Abstractions <ref> [30] </ref> and the LaRCS specification language [26]. The matching algorithm for our language is straightforward: a pt-chain is recognized by a finite state machine that invokes copies of other finite state machines to recognize chains on specific processes.
Reference: [31] <author> D. Socha, M. L. Bailey, and D. Notkin, Voyeur: </author> <title> graphical views of parallel programs. </title> <booktitle> SIGPLAN Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 206-215 (May, </pages> <year> 1988). </year>
Reference-contexts: The Ariadne Visualization Engine (AVE), introduced in this paper, was developed to address the second of these limitations: it provides scalable visualizations of debugging output. Existing parallel debuggers use either process-oriented or event-oriented visualizations. Process-oriented visualizations depict event activity on a set of interconnected process icons <ref> [16, 31] </ref> and, thus, are limited to systems with relatively small numbers of processes. Event-oriented visualizations allow the user to scroll through event traces or process-time graphs [11, 13, 14, 25] but typically do not show user-defined abstractions.
References-found: 31

