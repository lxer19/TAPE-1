URL: http://osl.cs.uiuc.edu/Papers/tocs-sturman.ps
Refering-URL: http://osl.cs.uiuc.edu/ExMembers/sturman/
Root-URL: http://www.cs.uiuc.edu
Email: Email: fsturman j aghag@cs.uiuc.edu  
Phone: Phone: (217) 244-3087 Fax: (217) 333-3501  
Title: Customizing Dependability with Reusable Software Components  
Author: Daniel C. Sturman and Gul A. Agha 
Keyword: Dependability, Actors, Customization, Reflection, Distributed Systems  
Date: 15, 1995  
Note: September  
Address: 1304 W. Springfield Avenue  Urbana, IL 61801, USA  
Affiliation: Department of Computer Science  University of Illinois at Urbana-Champaign  
Abstract: Many large software systems have different components with varying requirements for robustness and performance. Moreover, dependability requirements often change throughout their software life-cycle. Thus any single dependability technique is insufficient for implementing large systems. Software developers need to be able to modify dependability code without modifying application code. We outline a methodology for the separate development and maintenance of dependability and application codes. The advantage of our methodology is that dependability of each component may be customized and the dependability techniques reused with different application components. We demonstrate that our approach may be implemented efficiently, providing comparable performance to applications with hand-coded dependable behavior. We discuss a run-time system to implement our techniques and some optimizations it uses. 
Abstract-found: 1
Intro-found: 1
Reference: [Agh86] <author> Gul Agha. </author> <title> Actors: A Model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: A model of the computational environment is critical when developing linguistic tools. Without a consistent model, a language becomes cluttered with constructs that overlap in functionality. We address the observations made in Section 2 in the context of the Actor model of concurrent computations <ref> [Agh86] </ref>. In this section we describe the actor model and illustrate how we may satisfy the requirements outline in Section 2. 3.1 The Actor Model Actors are an abstract representation for distributed system in terms of concurrent object-based programming.
Reference: [AMST92] <author> G. Agha, I. Mason, S. Smith, and C. Talcott. </author> <title> Towards a Theory of Actor Computation. </title> <editor> In R. Cleaveland, editor, </editor> <booktitle> The Third International Conference on Concurrency Theory (CONCUR '92), </booktitle> <pages> pages 565-579. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year> <note> LNCS 630. </note>
Reference-contexts: Such an approach was taken by the Carnot project at MCC [TCMW93]. In Carnot, the actor language Rosette "glues" sequential components together to facilitate heterogeneous distributed computing for enterprise integration. Actor operators have also been combined with functional languages. Specifically, actor operators have been added to the call-by-value -calculus <ref> [AMST92] </ref>. In this case, local computation is modeled as sequential functional computation. An operational semantics is developed for the resulting language that supports operational reasoning. In [VT95], the semantics is extended to support formal reasoning about meta-level systems.
Reference: [AS94] <author> Gul Agha and Daniel C. Sturman. </author> <title> A Methodology for Adapting to Patterns of Faults. </title> <editor> In Gary M. Koob and Clifford G. Lau, editors, </editor> <title> Foundations of Dependable Computing: Models and Frameworks for Dependable Systems, chapter 1.2. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1994. </year>
Reference-contexts: Using Broadway, developers of distributed programs may use a well known language | C++ | to develop distributed programs. Besides the basic primitives presented above, Broadway supports exception handling <ref> [AS94] </ref> and synchronization constraints [Frt92]. Synchronization constraints provide local control over when messages may be processed. Individual methods may be disabled or enabled based on the state of the actor to ensure state consistency. <p> Through several examples we demonstrate how dependability techniques may be expressed using the architecture. 10 4.1 Customizing Communication maud supports the customization of transmission and reception behavior of a component <ref> [AS94] </ref>. Specifically, actor behavior may be modified by installing a communication meta-level actor called a communicator. A communicator provides a representation of both the actor's dispatch and reception behaviors. Each actor may be customized by its own meta-level object, enabling customization on a per-component basis. <p> Broadway provides C++ support for distributed actor programs including asynchronous communication, dynamic actor creation, and scheduling of actors. Basic actor functionality is augmented with support for migration, exception handling <ref> [AS94] </ref>, and synchronization constraints [Frt92]. These additional features greatly simplify the development of distributed programs. The platform currently runs on Ultrix for DEC MIPS workstations, on Solaris for SUN Sparc-stations, and IRIX 5 for SGI workstations.
Reference: [BDD + 89] <author> Russel A. Benel, Robert D. Dancey, Jon D. Dehn, James C. Gutmann, and Donald M. Smith. </author> <title> Advanced Automation System Design. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 77(11) </volume> <pages> 1653-1660, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: For example, the FAA air traffic control Advanced Automation System (AAS) is a large, complex distributed system which requires a high level of availability: the core set of application functions must be available all but three seconds per year <ref> [BDD + 89] </ref>. Dependability is achieved through a mixture of techniques including primary-backup, active replication, redundant networks, and error correcting codes. The software fault-tolerance techniques used with each component depend on the required availability and the degree of fault-tolerance supported through hardware.
Reference: [Ber94] <author> Lodewijk Bergmans. </author> <title> Composing Concurrent Objects. </title> <type> PhD thesis, </type> <institution> University of Twente, </institution> <year> 1994. </year>
Reference-contexts: The flexibility of this approach, although desirable for priority-based messaging schemes, greatly complicates the semantics of the reflective state operators and message processing, and therefore makes it more difficult to express protocols. The composition-filter model allows customization of communication through the use of filters <ref> [Ber94] </ref>. Although filters simplify coordination between distributed components, filters have no state and may not receive messages thereby making them inappropriate for developing fault-tolerant protocols. Our approach allows communication modification to be expressed as objects using the same techniques already familiar to the programmer in designing application objects.
Reference: [Bir93] <author> Kenneth P. Birman. </author> <title> The Process Group Approach to Reliable Distributed Computing. </title> <journal> Communications of the ACM, </journal> <volume> 36(12) </volume> <pages> 37-53, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: In Argus [Lis88], Avalon [EMS91] and Arjuna [SDP91], the concept of nested transactions is used to structure distributed systems. Consistency and resilience are ensured by atomic actions whose effects are check-pointed at commit time. The focus in [MPS91], [Coo90] and <ref> [Bir93] </ref> is to provide a set of protocols that represent common communication patterns found in fault-tolerant systems. None of the above systems support the factorization of fault-tolerance characteristics from application specific code, although Arjuna does use inheritance to allow the customization of transaction management policies.
Reference: [BMST92] <author> Navin Budhiraja, Keith Marzullo, Fred B. Schneider, and Sam Toueg. </author> <title> Primary-Backup Protocols: Lower Bounds and Optimal Implementations. </title> <type> Technical Report TR92-1265, </type> <institution> Cornell University, Department of Computer Science, </institution> <month> January </month> <year> 1992. </year>
Reference-contexts: The first example illustrates a primary-backup protocol. The second illustrates a checkpoint protocol. The third will show the composition of these two protocols. For all examples, we assume the underlying system implements FIFO ordering on all messages channels. Primary-Backup B <ref> [BMST92] </ref>. Client A has a communicator which holds messages until an acknowledgment 14 is received. The communicator of B delivers messages to B, forwards the messages to the backup and then generates acknowledgments. <p> The application is a simple data base application. A client repeatedly sets values in the database. After 1000 writes, the client reads back each value written. The dependability technique used is a simple primary-backup protocol <ref> [BMST92] </ref>. Whenever the server receives a request it: 1. processes the message, 2. sends the message to the backup, 26 3. without waiting for an acknowledgment from the backup, replies to the client that the task is complete.
Reference: [CIRM93] <author> Roy Campbell, Nayeem Islam, David Raila, and Peter Madany. </author> <title> Designing and Implementing Choices: An Object-Oriented System in C++. </title> <journal> Communications of the ACM, </journal> <pages> pages 117-126, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: Another unique aspect of our approach is that different fault-tolerance schemes may be composed in a modular fashion. Non-reflective systems which support customization tend to do so only on a system-wide basis. In an object-oriented operating system such as Choices <ref> [CIRM93] </ref>, frameworks may be customized for a particular application. However, once customized the characteristics are fixed for all objects linked with the framework. Reflection in an object based system allows customization of the underlying system independently for each object.
Reference: [CKP93] <author> Andrew Chien, Vijay Karamcheti, and John Plevyak. </author> <title> The Concert System Compiler and Runtime Support for Efficient Fine-Grained Concurrent Object-Oriented Programs. </title> <type> Technical Report UIUCDCS-R-93-1815, </type> <institution> Department of Computer Science, University of Illinois, Urbana, Illinois, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: To eliminate this cost, we build on previous work aimed at optimizing concurrent object-oriented languages for parallel systems <ref> [KA95, CKP93, PZC95] </ref>. Specifically, we concentrate on converting communication between a meta-actor and its base-actor into a series of function calls. Many techniques have been proposed for using the information resulting from type-inference [PS91] to replace local message sends with function calls.
Reference: [CL85] <author> K. Mani Chandy and Leslie Lamport. </author> <title> Distributed Snapshots: Determining Global States of Distributed Systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(1) </volume> <pages> 63-75, </pages> <month> February </month> <year> 1985. </year>
Reference-contexts: We conclude in Section 8 with a discussion of our approach. 2 A Motivating Example Consider a service implemented by a set of distributed components. To achieve fault-tolerance, the designers of the system wish to implement the Chandy/Lamport distributed checkpoint algorithm <ref> [CL85] </ref>. The checkpoint algorithm runs periodically, saving a consistent state of the distributed components to stable-storage. A high level representation of the protocol is shown in Figure 1. When the protocol runs, 4 the state of the initiating component is saved and channels are flushed.
Reference: [Coo90] <author> E. Cooper. </author> <title> Programming Language Support for Multicast Communication in Distributed Systems. </title> <booktitle> In Tenth International Conference on Distributed Computer Systems, </booktitle> <year> 1990. </year>
Reference-contexts: In Argus [Lis88], Avalon [EMS91] and Arjuna [SDP91], the concept of nested transactions is used to structure distributed systems. Consistency and resilience are ensured by atomic actions whose effects are check-pointed at commit time. The focus in [MPS91], <ref> [Coo90] </ref> and [Bir93] is to provide a set of protocols that represent common communication patterns found in fault-tolerant systems. None of the above systems support the factorization of fault-tolerance characteristics from application specific code, although Arjuna does use inheritance to allow the customization of transaction management policies.
Reference: [EMS91] <author> Jeffrey L. Eppinger, Lily B. Mummert, and Alfred Z. Spector, </author> <title> editors. CAMELOT AND AVALON: A Distributed Transaction Facility. </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <year> 1991. </year> <month> 34 </month>
Reference-contexts: In [VT95], the semantics is extended to support formal reasoning about meta-level systems. Traditional Approaches to Dependability Other systems and languages for developing dependable systems usually require that all components share a single or small set of failure semantics. In Argus [Lis88], Avalon <ref> [EMS91] </ref> and Arjuna [SDP91], the concept of nested transactions is used to structure distributed systems. Consistency and resilience are ensured by atomic actions whose effects are check-pointed at commit time.
Reference: [FB88] <author> Jacques Ferber and Jean-Pierre Briot. </author> <booktitle> Design of a Concurrent Language for Distributed Artificial Intelligence. In Proceedings of the International Conference on Fifth Generation Computer Systems, </booktitle> <volume> volume 2, </volume> <pages> pages 755-762. </pages> <institution> Institute for New Generation Computer Technology, </institution> <year> 1988. </year>
Reference-contexts: Reflection has been used to address a number of issues in concurrent systems. Reflection has been used in the Muse Operating System [YMFT91] for dynamically modifying system behavior. Reflective frameworks for the Actor languages MERING IV and Rosette have been proposed in <ref> [FB88] </ref> and [TS89], respectively. In MERING IV, programs may access meta-instances to modify an object or meta-classes to change a class definition.
Reference: [Frt92] <author> S. Frtlund. </author> <title> Inheritance of Synchronization Constraints in Concurrent Object-Oriented Programming Languages. </title> <booktitle> In Proceedings of ECOOP 1992. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1992. </year> <note> LNCS 615. </note>
Reference-contexts: Using Broadway, developers of distributed programs may use a well known language | C++ | to develop distributed programs. Besides the basic primitives presented above, Broadway supports exception handling [AS94] and synchronization constraints <ref> [Frt92] </ref>. Synchronization constraints provide local control over when messages may be processed. Individual methods may be disabled or enabled based on the state of the actor to ensure state consistency. <p> Broadway provides C++ support for distributed actor programs including asynchronous communication, dynamic actor creation, and scheduling of actors. Basic actor functionality is augmented with support for migration, exception handling [AS94], and synchronization constraints <ref> [Frt92] </ref>. These additional features greatly simplify the development of distributed programs. The platform currently runs on Ultrix for DEC MIPS workstations, on Solaris for SUN Sparc-stations, and IRIX 5 for SGI workstations. Broadway supports basic actor functionality using a multi-thread scheduler, distributed name service, and platform independent communication service.
Reference: [Gib94] <author> W. Wayt Gibbs. </author> <title> Software's Chronic Crisis. </title> <journal> Scientific American, </journal> <volume> 271(3) </volume> <pages> 86-95, </pages> <month> Septem-ber </month> <year> 1994. </year>
Reference-contexts: Dependability requirements are rarely fixed and often change throughout the software life-cycle. For example, changes by FAA managers in the requirements of the AAS have been a significant cause of delay and cost in its development <ref> [Gib94] </ref>. With conventional software design either the dependability techniques are fixed in the operating system or application code must be interspersed with code enforcing dependability. Thus, developers must be familiar with both application and dependability code: the resulting interdependence severely complicates the development process of large, dependable software systems. <p> We believe that the low completion rate of large software systems is a consequence of their code complexity. These projects suffer up to a fifty percent cancelation rate and those that are completed often are months or years overdue <ref> [Gib94] </ref>. Reducing the complexity of software development requires software methods which simplify and separate design components. Our research has focused on developing methods for separating dependability code from application code; such separation allows for their independent development, testing, and reuse.
Reference: [HPM93] <author> Graham Hamilton, Michael L. Powell, and James G. Mitchell. Subcontract: </author> <title> A Flexible Base for Distributed Programming. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, volume 17(5) of Operating Systems Review, </booktitle> <pages> pages 69-79. </pages> <booktitle> ACM Special Interest Group on Operating Systems, </booktitle> <month> December </month> <year> 1993. </year>
Reference-contexts: Because different protocols are generally required for very specific subsets of the objects in a system, such flexibility is required for implementing dependability protocols. Furthermore, existing system support for customization often requires additional knowl 30 edge of the system's operation on the part of the programmer. For example, sub-contracts <ref> [HPM93] </ref> may be used in the Spring operating system to allow customization of communication, but sub-contracts must explicitly interact with Interface Definition Language (IDL) stubs. IDL allows interfaces to be specified independent of the implementation language. IDL definitions are converted into implementation language stubs by a stub generator.
Reference: [KA95] <author> W. Kim and G. Agha. </author> <title> Efficient Support of Location Transparency in Concurrent Object-Oriented Programming Languages. </title> <booktitle> In Supercomputing '95, </booktitle> <year> 1995. </year> <note> (to appear). </note>
Reference-contexts: To eliminate this cost, we build on previous work aimed at optimizing concurrent object-oriented languages for parallel systems <ref> [KA95, CKP93, PZC95] </ref>. Specifically, we concentrate on converting communication between a meta-actor and its base-actor into a series of function calls. Many techniques have been proposed for using the information resulting from type-inference [PS91] to replace local message sends with function calls.
Reference: [Kep93] <author> David Keppel. </author> <title> Tools and Techniques for Building Fast Portable Threads Packages. </title> <type> Technical Report UWCSE 93-05-06, </type> <institution> University of Washington, Department of Computer Science and Engineering, </institution> <year> 1993. </year>
Reference-contexts: With one notable exception | replies from RPC invocations | only one method may be active for a single actor: there is no internal concurrency. User threads have been implemented using the QuickThreads package <ref> [Kep93] </ref>. Threads provide fairness in our actor environment: a method which does not terminate cannot prevent the progress of other actors. Threads also allow us to implement an RPC mechanism.
Reference: [Lis88] <author> Barbara Liskov. </author> <title> Distributed Programming in Argus. </title> <journal> Communications of the ACM, </journal> <volume> 31(3) </volume> <pages> 300-312, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: In [VT95], the semantics is extended to support formal reasoning about meta-level systems. Traditional Approaches to Dependability Other systems and languages for developing dependable systems usually require that all components share a single or small set of failure semantics. In Argus <ref> [Lis88] </ref>, Avalon [EMS91] and Arjuna [SDP91], the concept of nested transactions is used to structure distributed systems. Consistency and resilience are ensured by atomic actions whose effects are check-pointed at commit time.
Reference: [Mae87] <author> P. Maes. </author> <title> Computational Reflection. </title> <type> Technical Report 87-2, </type> <institution> Artificial Intelligence Laboratory, Vrije University, </institution> <year> 1987. </year>
Reference-contexts: The operators allow user-level access to traditionally system-level operators. We realize these operators through the use of reflection. Reflection means that objects in a system can manipulate a causally connected description of their system-level behavior <ref> [Smi82, Mae87] </ref>. A change in these descriptions or 8 meta-objects results in a change in how objects are implemented. The object for which a meta-object represents certain aspects of the implementation is called the base-object. This relationship is shown in Figure 3. meta-objects.
Reference: [MPS91] <author> S. Mishra, L. L. Peterson, and R. D. Schlichting. </author> <title> Consul: A communication Substrate for Fault-Tolerant Distributed Programs. </title> <type> Technical Report TR91-32, </type> <institution> University of Arizona, Tucson, </institution> <year> 1991. </year>
Reference-contexts: In Argus [Lis88], Avalon [EMS91] and Arjuna [SDP91], the concept of nested transactions is used to structure distributed systems. Consistency and resilience are ensured by atomic actions whose effects are check-pointed at commit time. The focus in <ref> [MPS91] </ref>, [Coo90] and [Bir93] is to provide a set of protocols that represent common communication patterns found in fault-tolerant systems. None of the above systems support the factorization of fault-tolerance characteristics from application specific code, although Arjuna does use inheritance to allow the customization of transaction management policies.
Reference: [Ng90] <author> Tony P. Ng. </author> <title> Probabilistic Failure Detection Using Watchdog Timers. </title> <type> Technical Report UIUCDCS-R-90-1521, </type> <institution> University of Illinois, Department of Computer Science, </institution> <month> March </month> <year> 1990. </year>
Reference-contexts: In addition to run-time functionality, Broadway includes a library of system actors. These actors include an i/o and file system interface, a failure detector, and a migration controller. The failure detector uses a watch-dog timer approach <ref> [Ng90] </ref> to detect crash failures in remote workstations.
Reference: [OMG91] <author> Object Management Group. </author> <title> Common Object Request Broker: Architecture and Specification, 1991. OMG Document Number 91.12.1. </title>
Reference-contexts: Thus, programmers may exploit the flexibility provided by reflection without a significant sacrifice in performance. The techniques described in this paper are directly applicable to distributed object systems based on message passing. For example, reflection may be implemented in CORBA <ref> [OMG91, SA95] </ref> through an augmented stub generator and object adaptor. Rather than generating a stub to perform RPC, stubs to interface with communicators are generated. The object adaptor implements the meta-level state operators.
Reference: [OOW91] <author> M. H. Olsen, E. Oskiewicz, and J. P. Warne. </author> <title> A Model for Interface Groups. </title> <booktitle> In Tenth Symposium on Reliable Distributed Systems, </booktitle> <address> Pisa, Italy, </address> <year> 1991. </year>
Reference-contexts: Providing separation of dependability code from application code while providing the benefits of recovery blocks is an open question. Transparency and Customization In Aeolus [WL88], replication can be described separate from the service being replicated. A similar idea has been implemented for CORBA with Interface Groups <ref> [OOW91] </ref>. However, both of these techniques only address replication. Our approach supports the manipulation of state as well as the addition and removal of messages. Another unique aspect of our approach is that different fault-tolerance schemes may be composed in a modular fashion.
Reference: [PS91] <author> J. Palsberg and M. I. Schwartzbach. </author> <title> Object-Oriented Type Inference. </title> <booktitle> In Proceedings OOPSLA '91, ACM SIGPLAN Sixth Annual Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 146-161. </pages> <publisher> ACM Press, </publisher> <month> October </month> <year> 1991. </year>
Reference-contexts: Specifically, we concentrate on converting communication between a meta-actor and its base-actor into a series of function calls. Many techniques have been proposed for using the information resulting from type-inference <ref> [PS91] </ref> to replace local message sends with function calls. These techniques utilize type-inference to determine which methods to invoke and a locality check to ensure that the target of the message is local.
Reference: [PZC95] <author> John Plevyak, Xingbin Zhang, and Andrew A. Chien. </author> <title> Obtaining Sequential Efficiency in Concurrent Object-Oriented Programs. </title> <booktitle> In Proceedings of the ACM Symposium on the Principles of Programming Languages, </booktitle> <month> January </month> <year> 1995. </year>
Reference-contexts: To eliminate this cost, we build on previous work aimed at optimizing concurrent object-oriented languages for parallel systems <ref> [KA95, CKP93, PZC95] </ref>. Specifically, we concentrate on converting communication between a meta-actor and its base-actor into a series of function calls. Many techniques have been proposed for using the information resulting from type-inference [PS91] to replace local message sends with function calls.
Reference: [RX95] <author> Brian Randell and Jie Xu. </author> <title> The Evolution of the Recovery Block Concept. </title> <editor> In Michael R. Lyu, editor, </editor> <title> Software Fault Tolerance, </title> <booktitle> number 3 in Trends in Software, chapter 1, </booktitle> <pages> pages 1-21. </pages> <publisher> John Wiley & Sons, Inc., </publisher> <year> 1995. </year>
Reference-contexts: The Horus project supports customization of protocols for each group [vRHB94]. Protocol layers share a common API and may be stacked dynamically. However, the protocols provided by Horus are limited to communication and multi-cast protocols. 29 Recovery blocks and conversations <ref> [RX95] </ref> support components with more general failure semantics. A recovery block is a series of atomic actions, each of which has an associated acceptance test. Failure of the primary action's test results in the roll-back of state and invocation of the second action.
Reference: [SA94] <author> Daniel C. Sturman and Gul Agha. </author> <title> A Protocol Description Language for Customizing Failure Semantics. </title> <booktitle> In Proceedings of the Thirteenth Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 148-157. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> October </month> <year> 1994. </year> <month> 35 </month>
Reference-contexts: In addition, splitting fault-tolerant behavior across different classes makes it difficult to parameterize protocols. For example, it would be desirable to specify the number of backup servers as a parameter to a replication protocol. These problems are addressed by the Protocol abstraction developed in the DIL language <ref> [SA94] </ref>. The Protocol abstraction exploits the functionality provided by communicators to support per-component customized failure semantics. The complex issues of 33 distributed installation and consistency are hidden from the programmer.
Reference: [SA95] <author> Daniel C. Sturman and Gul Agha. </author> <title> Extending CORBA to Customize Fault-Tolerance. </title> <type> Technical report, </type> <institution> University of Illinois, Department of Computer Science, </institution> <month> February </month> <year> 1995. </year>
Reference-contexts: Thus, programmers may exploit the flexibility provided by reflection without a significant sacrifice in performance. The techniques described in this paper are directly applicable to distributed object systems based on message passing. For example, reflection may be implemented in CORBA <ref> [OMG91, SA95] </ref> through an augmented stub generator and object adaptor. Rather than generating a stub to perform RPC, stubs to interface with communicators are generated. The object adaptor implements the meta-level state operators.
Reference: [SDP91] <author> Santosh Shrivastava, Graeme Dixon, and Graham Parrington. </author> <title> An Overview of the Arjuna Distributed Programming System. </title> <journal> IEEE Software, </journal> <pages> pages 66-73, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: In [VT95], the semantics is extended to support formal reasoning about meta-level systems. Traditional Approaches to Dependability Other systems and languages for developing dependable systems usually require that all components share a single or small set of failure semantics. In Argus [Lis88], Avalon [EMS91] and Arjuna <ref> [SDP91] </ref>, the concept of nested transactions is used to structure distributed systems. Consistency and resilience are ensured by atomic actions whose effects are check-pointed at commit time. The focus in [MPS91], [Coo90] and [Bir93] is to provide a set of protocols that represent common communication patterns found in fault-tolerant systems.
Reference: [Smi82] <author> B. C. Smith. </author> <title> Reflection and Semantics in a Procedural Language. </title> <type> Technical Report 272, </type> <institution> Massachusetts Institute of Technology. Laboratory for Computer Science, </institution> <year> 1982. </year>
Reference-contexts: Dependability techniques may be attached and detached dynamically, enabling fast prototyping and optimization through refinement. Furthermore, the implementations of these techniques may be collected into a library for reuse with other components. The techniques we present exploit concurrent object-oriented programming and reflection <ref> [Smi82] </ref>. Reflection is the ability of an application to access and manipulate a meta-level description of its own behavior and execution environment. We have implemented a reflective architecture which allows separate specification of dependability and application code. <p> The operators allow user-level access to traditionally system-level operators. We realize these operators through the use of reflection. Reflection means that objects in a system can manipulate a causally connected description of their system-level behavior <ref> [Smi82, Mae87] </ref>. A change in these descriptions or 8 meta-objects results in a change in how objects are implemented. The object for which a meta-object represents certain aspects of the implementation is called the base-object. This relationship is shown in Figure 3. meta-objects.
Reference: [Stu94] <author> Daniel C. Sturman. </author> <title> Fault-Adaptation for Systems in Unpredictable Environments. </title> <type> Master's thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: Most importantly, the language must support facilities supporting dynamic creation of software components and dynamic reconfiguration of the communication topology. Broadway is a run-time platform that allows actors to be implemented in C++ <ref> [Stu94] </ref>. We use Broadway to implement the ideas described in this paper. The platform supports C++ calls for both send and new; the become operator is implicit at the end of each method. <p> Our goal in implementing maud is to develop a system 20 where protocols expressed as communicators provide comparable performance to the same protocols hard-coded into applications. 5.1 Run-time Environment We have implemented maud on the actor platform Broadway <ref> [Stu94] </ref>. Broadway provides C++ support for distributed actor programs including asynchronous communication, dynamic actor creation, and scheduling of actors. Basic actor functionality is augmented with support for migration, exception handling [AS94], and synchronization constraints [Frt92]. These additional features greatly simplify the development of distributed programs.
Reference: [TCMW93] <author> Christine Tomlinson, Phil Cannata, Greg Meredith, and Darrell Woelk. </author> <title> The Extensible Services Switch in Carnot. </title> <journal> IEEE Parallel & Distributed Technology: Systems & Applications, </journal> <volume> 1(2) </volume> <pages> 16-20, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Each method in an actor class invokes a subroutine, or set of routines, written in a sequential language and dispatches messages based on the values returned. Such an approach was taken by the Carnot project at MCC <ref> [TCMW93] </ref>. In Carnot, the actor language Rosette "glues" sequential components together to facilitate heterogeneous distributed computing for enterprise integration. Actor operators have also been combined with functional languages. Specifically, actor operators have been added to the call-by-value -calculus [AMST92]. In this case, local computation is modeled as sequential functional computation.
Reference: [TS89] <author> C. Tomlinson and V. Singh. </author> <title> Inheritance and Synchronization with Enabled-Sets. </title> <booktitle> In OOPSLA Proceedings, </booktitle> <year> 1989. </year>
Reference-contexts: Reflection has been used to address a number of issues in concurrent systems. Reflection has been used in the Muse Operating System [YMFT91] for dynamically modifying system behavior. Reflective frameworks for the Actor languages MERING IV and Rosette have been proposed in [FB88] and <ref> [TS89] </ref>, respectively. In MERING IV, programs may access meta-instances to modify an object or meta-classes to change a class definition.
Reference: [vRHB94] <author> Robbert van Renesse, Takako M. Hickey, and Kenneth P. Birman. </author> <title> Design and Performance of Horus: A Lightweight Group Communications System. </title> <type> Technical Report TR94-1442, </type> <institution> Department of Computer Science, </institution> <month> August </month> <year> 1994. </year>
Reference-contexts: None of the above systems support the factorization of fault-tolerance characteristics from application specific code, although Arjuna does use inheritance to allow the customization of transaction management policies. The Horus project supports customization of protocols for each group <ref> [vRHB94] </ref>. Protocol layers share a common API and may be stacked dynamically. However, the protocols provided by Horus are limited to communication and multi-cast protocols. 29 Recovery blocks and conversations [RX95] support components with more general failure semantics.
Reference: [VT95] <author> Nalini Venkatasubramanian and Caroyln Talcott. </author> <title> Reasoning About Meta-Level Activities in Open Distributed Systems. </title> <booktitle> In Proceedings of ACM Principles of Distributed Computing, </booktitle> <address> Ottawa, Canada, </address> <month> August </month> <year> 1995. </year>
Reference-contexts: Actor operators have also been combined with functional languages. Specifically, actor operators have been added to the call-by-value -calculus [AMST92]. In this case, local computation is modeled as sequential functional computation. An operational semantics is developed for the resulting language that supports operational reasoning. In <ref> [VT95] </ref>, the semantics is extended to support formal reasoning about meta-level systems. Traditional Approaches to Dependability Other systems and languages for developing dependable systems usually require that all components share a single or small set of failure semantics.
Reference: [WL88] <author> C. T. Wilkes and R. J. LeBlanc. </author> <title> Distributed Locking: A Mechanism for Constructing Highly Available Objects. </title> <booktitle> In Proceedings of the Seventh Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 194-203, </pages> <year> 1988. </year>
Reference-contexts: Acceptance tests and the delineation of atomic actions must be specified by the application programmer. Providing separation of dependability code from application code while providing the benefits of recovery blocks is an open question. Transparency and Customization In Aeolus <ref> [WL88] </ref>, replication can be described separate from the service being replicated. A similar idea has been implemented for CORBA with Interface Groups [OOW91]. However, both of these techniques only address replication. Our approach supports the manipulation of state as well as the addition and removal of messages.
Reference: [YMFT91] <author> Y. Yokote, A. Mitsuzawa, N. Fujinami, and M. Tokoro. </author> <title> The Muse Object Architecture: </title>
Reference-contexts: Our approach allows communication modification to be expressed as objects using the same techniques already familiar to the programmer in designing application objects. Reflection has been used to address a number of issues in concurrent systems. Reflection has been used in the Muse Operating System <ref> [YMFT91] </ref> for dynamically modifying system behavior. Reflective frameworks for the Actor languages MERING IV and Rosette have been proposed in [FB88] and [TS89], respectively. In MERING IV, programs may access meta-instances to modify an object or meta-classes to change a class definition.
References-found: 38

