URL: ftp://ftp.eecs.umich.edu/groups/gasm/typedgm.ps.gz
Refering-URL: http://www.eecs.umich.edu/gasm/papers.html
Root-URL: http://www.eecs.umich.edu
Title: Typed Gurevich Machines Revisited  
Author: A.V. Zamulin 
Keyword: evolving algebras, Gurevich Machines, Abstract State Machines, algebraic specifications, implicit state.  
Date: 5 (1997), 1-26  
Note: Joint NCC IIS Bull., Comp. Science,  c 1997 NCC Publisher  
Abstract: An approach to combining type-structured algebraic specifications with Gure-vich Machines (evolving algebras) is proposed. A type-structured algebraic specification, in its simplest form, consists of data type specifications and independent function (detached operation) specifications. Concrete and generic specification components (data types and functions) are distinguished in a more developed case. A type-structured algebraic specification is augmented by a number of transition rules of a conventional Gurevich Machine indicating in which way an algebra of a given signature evolves to another algebra of the same signature. A function update is a primitive algebra transformation. Two classes of functions are distinguished, static functions which do not change when an algebra evolves, and dynamic functions which do change when an algebra evolves. Data type operations are static. The semantics of data types and static functions is given by axioms, the semantics of dynamic functions is given by transition rules. 1 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Y. Gurevich, </author> <title> Evolving Algebras 1993: Lipary Guide, Specification and Validation Methods, </title> <publisher> Oxford University Press, </publisher> <year> 1994. </year>
Reference-contexts: 1. Introduction Evolving algebras proposed by Gurevich <ref> [1] </ref> have been intensively used for formal definition of various algorithms and programming language semantics [2, 3, 4, 5, 6, 7, 8, 9]. The success of the approach can be attributed to two reasons: (1) sound mathematical background and (2) imperative specification style. <p> The main idea behind the choice of basic specification constructs has been to use the notions most familiar to the programming society. Such notions are mainly functions, data types, generic (parameterized) functions and data types, and type constructors (in contrast to such strange notions as "universe" <ref> [1] </ref>, "concept" [12], "trait" [13], "sort" [14], etc.). The author believes that the closer the notions used in a specification language to the notions used in a programming language, the more chances exist that a programmer will ever pay attention to a specification. <p> Another task has been avoidence of any other logic except the first-order many-sorted logic which is most familiar to the computer science specialists. 3 The set of transition rules proposed in the paper is mainly based on the set of basic rules of <ref> [1] </ref> with the addition of a tagcase constructor resembling a tagcase statement of some programming languages. The current proposal ignores algebra evolving by means of importing/discarding algebra elements as a strange mechanism to the programming community. <p> The facilities include concrete and generic data types, type classes, independent concrete and generic functions, procedures, and transition rules. The use of well-specified data types has allowed us to propose the exclusion of such a "strange" transition rule as import constructor <ref> [1] </ref> serving to extend a universe with a new element. At the same time it is proposed to include a tagcase transition rule which is highly useful in operations with objects of union types. <p> A careful choice of a set of transition rules and specification constructs is still needed before a concrete specification language can be proposed. A move to it is demonstrated by the extension of the basic set of transition rules given in <ref> [1] </ref> with sequential updates [24] and a kind of for-loop [29]. The approach presented is based on static signatures, which means that all algebra transformations are done within the same signature.
Reference: [2] <author> E. Borger and E. Riccobene, </author> <title> A formal specification of Parlog, Semantics of Programming Languages and Model Theory, </title> <publisher> Gordon and Breach, </publisher> <year> 1993, </year> <pages> 1-42. </pages>
Reference-contexts: 1. Introduction Evolving algebras proposed by Gurevich [1] have been intensively used for formal definition of various algorithms and programming language semantics <ref> [2, 3, 4, 5, 6, 7, 8, 9] </ref>. The success of the approach can be attributed to two reasons: (1) sound mathematical background and (2) imperative specification style.
Reference: [3] <author> E. Borger and D. Rosenzweig, </author> <title> A matematical definition of full Prolog, </title> <booktitle> Science of Computer Programming, </booktitle> <year> 1994. </year>
Reference-contexts: 1. Introduction Evolving algebras proposed by Gurevich [1] have been intensively used for formal definition of various algorithms and programming language semantics <ref> [2, 3, 4, 5, 6, 7, 8, 9] </ref>. The success of the approach can be attributed to two reasons: (1) sound mathematical background and (2) imperative specification style.
Reference: [4] <author> E. Borger, Y. Gurevich, and D. Rosenzweig, </author> <title> The bakery algorithm: Yet another specification and verification, Specification and Validation Methods, </title> <publisher> Oxford University Press, </publisher> <year> 1994. </year>
Reference-contexts: 1. Introduction Evolving algebras proposed by Gurevich [1] have been intensively used for formal definition of various algorithms and programming language semantics <ref> [2, 3, 4, 5, 6, 7, 8, 9] </ref>. The success of the approach can be attributed to two reasons: (1) sound mathematical background and (2) imperative specification style.
Reference: [5] <author> E. Borger, I. Durdanovich, and D. Rosenzweig, </author> <title> Occam: Specification and Compiler Correctness. Part 1: Simple mathematical interpreters, </title> <booktitle> Proc. PRO-COMET'94 (IFIP Working Conference on Programming Concepts, Methods and Calculi), </booktitle> <publisher> North-Holland, </publisher> <year> 1994, </year> <pages> 489-508. </pages>
Reference-contexts: 1. Introduction Evolving algebras proposed by Gurevich [1] have been intensively used for formal definition of various algorithms and programming language semantics <ref> [2, 3, 4, 5, 6, 7, 8, 9] </ref>. The success of the approach can be attributed to two reasons: (1) sound mathematical background and (2) imperative specification style.
Reference: [6] <author> Y. Gurevich and J. Huggins, </author> <title> The semantics of the C programming language, </title> <booktitle> Computer Science Logic, LNCS, </booktitle> <volume> 702, </volume> <year> 1993, </year> <pages> 274-309. </pages>
Reference-contexts: 1. Introduction Evolving algebras proposed by Gurevich [1] have been intensively used for formal definition of various algorithms and programming language semantics <ref> [2, 3, 4, 5, 6, 7, 8, 9] </ref>. The success of the approach can be attributed to two reasons: (1) sound mathematical background and (2) imperative specification style. <p> It is assumed that the behavior of all static functions is either well known or defined by some external tools; in the majority of cases, the same refers to universes (one can make sure of this, looking at the definition of C <ref> [6] </ref> where almost all static functions and universes are defined in plain words).
Reference: [7] <author> P. Glavan and D. Rosenzweig, </author> <title> Evolving Algebra Model of Programming Language Semantics, </title> <booktitle> IFIP 13th World Computer Congress 1994, </booktitle> <volume> vol. 1: </volume> <publisher> Technology/Foundations, Elsevier, Amsterdam, </publisher> <pages> 416-422. </pages>
Reference-contexts: 1. Introduction Evolving algebras proposed by Gurevich [1] have been intensively used for formal definition of various algorithms and programming language semantics <ref> [2, 3, 4, 5, 6, 7, 8, 9] </ref>. The success of the approach can be attributed to two reasons: (1) sound mathematical background and (2) imperative specification style.
Reference: [8] <author> C. Wallace, </author> <title> The semantics of the C++ Programming Language, Specification and Validation Methods, </title> <publisher> Oxford University Press, </publisher> <year> 1994. </year>
Reference-contexts: 1. Introduction Evolving algebras proposed by Gurevich [1] have been intensively used for formal definition of various algorithms and programming language semantics <ref> [2, 3, 4, 5, 6, 7, 8, 9] </ref>. The success of the approach can be attributed to two reasons: (1) sound mathematical background and (2) imperative specification style.
Reference: [9] <author> P.W.Kutter, </author> <title> Dynamic Semantics of the Oberon Programming Language. </title> <type> Term thesis, </type> <institution> ETH Zurich, </institution> <year> 1996. </year>
Reference-contexts: 1. Introduction Evolving algebras proposed by Gurevich [1] have been intensively used for formal definition of various algorithms and programming language semantics <ref> [2, 3, 4, 5, 6, 7, 8, 9] </ref>. The success of the approach can be attributed to two reasons: (1) sound mathematical background and (2) imperative specification style.
Reference: [10] <author> A.V. Zamulin, </author> <title> The Database Specification Language RUSLAN. </title> <institution> Siberian Division of the Russian Academy of Sciences, Institute of Informatics Systems, </institution> <note> Preprints 28, 29, Novosibirsk 1994, 35 p. (ftp:// math.tulane.edu, directory "pub/zamulin", files "Ruslan1.ps.Z", "Ruslan2.ps.Z"). </note>
Reference-contexts: A facility for defining independent static functions (i.e. functions not attributed to particular data types) should also be provided. The mechanism of data type specifications proposed in this paper is a refined version of that of the specification language Ruslan <ref> [10, 11] </ref> (one-level specification versus multi-level specification) which better fits the evolving algebras environment. The main idea behind the choice of basic specification constructs has been to use the notions most familiar to the programming society.
Reference: [11] <author> A.V. Zamulin, </author> <title> The Database Specification Language RUSLAN: Main Features. </title> <booktitle> East-West Database Workshop (proc. Second International East-West Database Workshop, </booktitle> <address> Klagenfurt, Austria, </address> <month> September 25-28, </month> <year> 1994), </year> <note> Springer (Workshops in Computing), 1994, 315-327. </note> <author> [12] . D. Kapur and D.R. Musser, Tecton: </author> <title> a framework for specifying and verifying generic system components. </title> <institution> Rensselaer Polytechnic Institute, Computer Science Technical Report 92-20, </institution> <month> July, </month> <year> 1992. </year>
Reference-contexts: A facility for defining independent static functions (i.e. functions not attributed to particular data types) should also be provided. The mechanism of data type specifications proposed in this paper is a refined version of that of the specification language Ruslan <ref> [10, 11] </ref> (one-level specification versus multi-level specification) which better fits the evolving algebras environment. The main idea behind the choice of basic specification constructs has been to use the notions most familiar to the programming society.
Reference: [13] <author> J. V. Guttag and J. J. Horning, </author> <title> Larch: Languages and Tools for Formal Specification, </title> <publisher> Springer, </publisher> <year> 1993. </year>
Reference-contexts: Such notions are mainly functions, data types, generic (parameterized) functions and data types, and type constructors (in contrast to such strange notions as "universe" [1], "concept" [12], "trait" <ref> [13] </ref>, "sort" [14], etc.). The author believes that the closer the notions used in a specification language to the notions used in a programming language, the more chances exist that a programmer will ever pay attention to a specification.
Reference: [14] <author> M. Broy, C. Facchi, R. Grosu, et al, </author> <title> The Requirement and Design Specification, Language Spectrum, An Informal Introduction, </title> <type> Version 1.0. </type> <institution> Technische Universitaet Muenchen, Instituet fuer Informatik, </institution> <month> April </month> <year> 1993. </year> <month> 26 </month>
Reference-contexts: Such notions are mainly functions, data types, generic (parameterized) functions and data types, and type constructors (in contrast to such strange notions as "universe" [1], "concept" [12], "trait" [13], "sort" <ref> [14] </ref>, etc.). The author believes that the closer the notions used in a specification language to the notions used in a programming language, the more chances exist that a programmer will ever pay attention to a specification.
Reference: [15] <author> A.V. Zamulin, </author> <title> Typed Gurevich Machines, </title> <journal> Institute of Informatics Systems, </journal> <volume> Preprint No 36, </volume> <month> (ftp://xsite.iis.nsk.su/pub/articles/tgm.ps.gz). </month>
Reference-contexts: The current proposal ignores algebra evolving by means of importing/discarding algebra elements as a strange mechanism to the programming community. The author believes that a proper choice of data types needed in a specification can solve this problem. The previous paper <ref> [15] </ref> on the subject has presented an approach to combining type-structured algebraic specifications and Gurevich Machines. The present version of the approach takes into account some features proposed by the work of P. Dauchy and M. C. Gaudel on algebraic specifications with implicit state [16].
Reference: [16] <author> P. Dauchy and M.C. </author> <title> Gaudel, Implicit State in Algebraic Specifications, </title> <booktitle> International Workshop on Information Systems Correctness and Reusability (IS-CORE'93), Informatik-Berichte, 1993, </booktitle> <volume> No 01/93. </volume>
Reference-contexts: The previous paper [15] on the subject has presented an approach to combining type-structured algebraic specifications and Gurevich Machines. The present version of the approach takes into account some features proposed by the work of P. Dauchy and M. C. Gaudel on algebraic specifications with implicit state <ref> [16] </ref>. The approach is tested by formal definition of an Oberon compiler [17]. The rest of the paper is organized in the following way. Type-structured signatures and underlying algebras are defined in Section 2. The construction and interpretation of well-formed terms are described in Section 3. <p> We call such a function (constant) a dependent function (constant) and introduce it with a special keyword depend. A dependent function corresponds to a function in programming languages which uses a global variable and to a non-elementary access function of <ref> [16] </ref>. With the use of dependent functions, an algebra update proceeds in two stages: 1. At stage 1 a transition rule is executed. 6 The idea is suggested to the author by Giuseppe Del Castillo. 19 2. At stage 2 all dependent functions touched by the transition rule are reimplemented. <p> Remark2: a procedure can be called recursively. Remark3: procedures are counterparts of modifiers introduced in <ref> [16] </ref>. 10. <p> A specification consisting of parts 1, 2, and 5 defines an algorithm in the manner close to that of the traditional Gurevich Machine. A specification without the last part defines the behavior of a dynamic system in the manner close to that described in <ref> [16] </ref>. A specification including all the parts describes a particular algorithm in terms of the behavior of a dynamic system. 11. Sample examples 11.1. Specification of a stack machine This is an example from [21] rewritten with the use of data types. <p> Some related work A concept of an algebraic specification with implicit state is introduced in <ref> [16] </ref>. The main idea is to represent states of a system by algebras and dynamic operations by transformations between them. Transformations are defined by means of so-called modifiers which are counterparts of transition rules of Gurevich Machines. A state can be analyzed by a number of simple and complex analyzers. <p> A d-oid is a set of instant structures (e.g., algebras) and a set of dynamic operations (transformations of instant structures with a possible result of a definite sort). Here transition rules of Gurevich machines and modifiers of <ref> [16] </ref> are replaced with dynamic operations. The approach is highly associated with object-oriented data representation. With this purpose, algebra elements are considered as objects supplied with unique identifiers preserving object identities in the process of algebra transformations. <p> The approach deals with models, e.g., it assumes that sorts (like in a conventional Gurevich machine) can grow and shrink, and do not address the issue of specifying the class of such behaviors, which is (like in <ref> [16] </ref>) our aim. We also doubt that a dynamic operation producing a side-effect (i.e. an operation both transforming an instant structure and yielding a result) and resembling a side-effect function in programming languages should be part of a specification language.
Reference: [17] <author> A.V. Zamulin, </author> <title> Specification of an Oberon Compiler by means of a Typed Gure-vich Machine, </title> <institution> Institute of Informatics Systems of the Siberian Division of the Russian Academy of Sciences, Report No. 589.3945009.00007-01, Novosibirsk, </institution> <year> 1997. </year>
Reference-contexts: The present version of the approach takes into account some features proposed by the work of P. Dauchy and M. C. Gaudel on algebraic specifications with implicit state [16]. The approach is tested by formal definition of an Oberon compiler <ref> [17] </ref>. The rest of the paper is organized in the following way. Type-structured signatures and underlying algebras are defined in Section 2. The construction and interpretation of well-formed terms are described in Section 3. Type-structured specifications are introduced in Section 4. <p> The rule has proved to be useful in defining the formal semantics of the Oberon WITH statement <ref> [17] </ref>. 9.6. Procedures A procedure generally serves for the execution of the same transition rule for different terms.
Reference: [18] <author> P. Wadler and S.Blott, </author> <title> How to make ad-hoc polymorphism less ad-hoc, </title> <booktitle> Conf. Record of the 16th ACM Annual Symp. on Principles of Progr. </booktitle> <address> Lang., Austin, Texas, </address> <month> January </month> <year> 1989. </year>
Reference-contexts: The rest of the paper is organized in the following way. Type-structured signatures and underlying algebras are defined in Section 2. The construction and interpretation of well-formed terms are described in Section 3. Type-structured specifications are introduced in Section 4. Specification classes serving to "make ad-hoc polymorphism less ad-hoc" <ref> [18] </ref> are presented in Section 5. Generic data types are defined in Section 6, and some built-in type constructors are described in Section 7. A mechanism for specifying generic functions is proposed in Section 8. <p> The notion of a specification class is introduced to make use of this feature. This notion corresponds to the notion of a type class which has become widely known due to <ref> [18] </ref> and which was originally proposed under the name sype in [20]. Let be a signature, C be a set of names (of specification classes), C be a name from C, and E = &lt; ; E &gt; be a specification constructed like a data type specification (Section 4).
Reference: [19] <author> M. Broy and M. Wirsing, </author> <title> Partial Abstract Data Types. </title> <journal> Acta Informatica, </journal> <volume> 18, </volume> <year> 1982, </year> <pages> 47-64. </pages>
Reference-contexts: To express the definedness of a term t of a type-structured specification, we use a special semantic predicate D, such that D (t) holds in an algebra A iff eval A (t) produces some object in A <ref> [19] </ref>. It is assumed that a detached constant can also be partial, i.e., it can be undefined in some algebras of a given signature. 2 Notation. When constructing a specification, we build the function int t as a set of pairs &lt;type-term, data-type-specification&gt;.
Reference: [20] <author> R. Nakajima, M. Honda, and H. Nakahara, </author> <title> Hierarchical Program Specification: a Many-sorted Logical Approach. </title> <journal> Acta Informatica, </journal> <volume> 14, No. 2, </volume> <year> 1980, </year> <pages> 135-155. </pages>
Reference-contexts: called a codomain unit; an operation signature be a pair op : O, where op is an operator (function symbol) and O is an operation type; a data type signature be a set of operation signatures constructed as above by extending the set TYPE with the symbol "@" meaning "myself" <ref> [20] </ref> and used at least once as domain and/or codomain unit in each operation signature; 4 then a type-structured signature is a tuple &lt; T Y P E; ; ; int t &gt;, where is a set of data type signatures, is a set of (detached) operation signatures, and int t <p> The notion of a specification class is introduced to make use of this feature. This notion corresponds to the notion of a type class which has become widely known due to [18] and which was originally proposed under the name sype in <ref> [20] </ref>. Let be a signature, C be a set of names (of specification classes), C be a name from C, and E = &lt; ; E &gt; be a specification constructed like a data type specification (Section 4).
Reference: [21] <author> Y. Gurevich, </author> <title> Evolving Algebras: An Attempt to Discover Semantics, </title> <booktitle> Current Trends in Theoretical Computer Science, World Scientific, </booktitle> <year> 1993, </year> <pages> 266-292. </pages>
Reference-contexts: A specification including all the parts describes a particular algorithm in terms of the behavior of a dynamic system. 11. Sample examples 11.1. Specification of a stack machine This is an example from <ref> [21] </ref> rewritten with the use of data types. The stack machine computes expressions given in reverse Polish notation, or PRN. It is supposed that the PRN expression is given in the form of a list where each entry denotes a natural number or an operation. <p> pop (S) else begin S := push (apply (head (F), Arg1, Arg2), S), F := tail (F), Arg1 := undef, Arg1 is undefined now Arg2 := undef Arg2 is undefined now end endif endtag Note that all the operations used in the example are now formally defined in contrast to <ref> [21] </ref>. 11.2. Identifier table manipulation The identifier table stores some data for each identifier definition. It can be block-structured according to block nesting.
Reference: [22] <author> E. Asteziano and E. Zucca, </author> <title> A Semantic Model for Dynamic Systems, Modeling Database Dynamics, </title> <booktitle> Volkse 1992, Workshops in Computing, </booktitle> <publisher> Springer Verlag, </publisher> <year> 1993, </year> <pages> 63-83. </pages>
Reference-contexts: However, complex modifiers gave rise to procedures, and complex analyzers gave rise to dependent functions presented in this paper. The same idea of an implicit state in terms of a new mathematical structure, d-oid (dynamic object identity), is given in <ref> [22, 23] </ref>. A d-oid is a set of instant structures (e.g., algebras) and a set of dynamic operations (transformations of instant structures with a possible result of a definite sort). Here transition rules of Gurevich machines and modifiers of [16] are replaced with dynamic operations. <p> These papers are closely related in the sense that while the first one gives an informal proposal, the second one proposes concrete mechanisms of static and dynamic frameworks according to the approach stated in <ref> [22, 23] </ref>. In contrast to this approach, we are still satisfied with static data types which taken together with dynamic functions provide a simple and powerful 24 mechanism for the formal definition of dynamic systems. 13.
Reference: [23] <author> E. Asteziano and E. Zucca, D-oids: </author> <title> a Model for Dynamic Data Types, </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 5(2), </volume> <month> June </month> <year> 1995, </year> <pages> 257-282. </pages>
Reference-contexts: However, complex modifiers gave rise to procedures, and complex analyzers gave rise to dependent functions presented in this paper. The same idea of an implicit state in terms of a new mathematical structure, d-oid (dynamic object identity), is given in <ref> [22, 23] </ref>. A d-oid is a set of instant structures (e.g., algebras) and a set of dynamic operations (transformations of instant structures with a possible result of a definite sort). Here transition rules of Gurevich machines and modifiers of [16] are replaced with dynamic operations. <p> These papers are closely related in the sense that while the first one gives an informal proposal, the second one proposes concrete mechanisms of static and dynamic frameworks according to the approach stated in <ref> [22, 23] </ref>. In contrast to this approach, we are still satisfied with static data types which taken together with dynamic functions provide a simple and powerful 24 mechanism for the formal definition of dynamic systems. 13.
Reference: [24] <author> R. Groenboom and R. Renardel de Lavalette, </author> <title> Reasoning about Dynamic Features in Specification Languages, </title> <booktitle> Workshop in Semantics of Specification Languages, </booktitle> <publisher> Springer Verlag, </publisher> <year> 1994, </year> <pages> 340-355. </pages>
Reference-contexts: A multimodal logic MLCM (Modal Logic of Creation and Modification), which is a variant of dynamic logic, is used in <ref> [24] </ref> to formalize reasoning about evolving algebras. Another formalism for the formal definition of Gurevich Machines (Evolving Algebras in the paper) based on Di-algebras is suggested in [25]. These papers are just two other formalizations of the Gurevich's idea of evolving algebras. Dynamic abstract types are introduced in [26, 27]. <p> A careful choice of a set of transition rules and specification constructs is still needed before a concrete specification language can be proposed. A move to it is demonstrated by the extension of the basic set of transition rules given in [1] with sequential updates <ref> [24] </ref> and a kind of for-loop [29]. The approach presented is based on static signatures, which means that all algebra transformations are done within the same signature.
Reference: [25] <author> H. Reichel, </author> <title> Unifying ADT and Evolving Algebra Specifications, </title> <journal> Bull. of EATCS, </journal> <volume> No. 59, </volume> <year> 1996, </year> <pages> 112-126. </pages>
Reference-contexts: A multimodal logic MLCM (Modal Logic of Creation and Modification), which is a variant of dynamic logic, is used in [24] to formalize reasoning about evolving algebras. Another formalism for the formal definition of Gurevich Machines (Evolving Algebras in the paper) based on Di-algebras is suggested in <ref> [25] </ref>. These papers are just two other formalizations of the Gurevich's idea of evolving algebras. Dynamic abstract types are introduced in [26, 27].
Reference: [26] <author> H. Ehrig and F. Orejas, </author> <title> Dynamic Abstract Types: An Informal Proposal, </title> <journal> Bull of EATCS, </journal> <volume> No. 53, </volume> <year> 1994, </year> <pages> 162-169. </pages>
Reference-contexts: Another formalism for the formal definition of Gurevich Machines (Evolving Algebras in the paper) based on Di-algebras is suggested in [25]. These papers are just two other formalizations of the Gurevich's idea of evolving algebras. Dynamic abstract types are introduced in <ref> [26, 27] </ref>. In [26], a dynamic abstract type consists of an abstract data type and a collection of dynamic operations; four levels of its specification are proposed: value type specification, instant structure specification, dynamic operation specification, and higher-level specification. <p> Another formalism for the formal definition of Gurevich Machines (Evolving Algebras in the paper) based on Di-algebras is suggested in [25]. These papers are just two other formalizations of the Gurevich's idea of evolving algebras. Dynamic abstract types are introduced in [26, 27]. In <ref> [26] </ref>, a dynamic abstract type consists of an abstract data type and a collection of dynamic operations; four levels of its specification are proposed: value type specification, instant structure specification, dynamic operation specification, and higher-level specification.
Reference: [27] <author> E. Zucca, </author> <title> From Static to Dynamic Data Types, </title> <booktitle> Mathematical Foundations of Computer Science 1996, LNCS, </booktitle> <volume> 1113, </volume> <year> 1996, </year> <pages> 579-590. </pages>
Reference-contexts: Another formalism for the formal definition of Gurevich Machines (Evolving Algebras in the paper) based on Di-algebras is suggested in [25]. These papers are just two other formalizations of the Gurevich's idea of evolving algebras. Dynamic abstract types are introduced in <ref> [26, 27] </ref>. In [26], a dynamic abstract type consists of an abstract data type and a collection of dynamic operations; four levels of its specification are proposed: value type specification, instant structure specification, dynamic operation specification, and higher-level specification. <p> The specification of the third level is a suitable extension of algebraic specification to define transformations between instant structures. The specification of the fourth level includes higher-level dynamic generators and dynamic operations for update, composition and communication of different instances of dynamic abstract types. In <ref> [27] </ref>, no direct definition of a dynamic abstract type is given. Instead of this, formal definitions of a static framework and of a dynamic framework over a static framework are given.
Reference: [28] <author> Y. Gurevich, </author> <title> ASM Guide 1997, </title> <institution> University of Michigan, </institution> <year> 1997. </year>
Reference-contexts: At the same time it is proposed to include a tagcase transition rule which is highly useful in operations with objects of union types. The proposal does not prohibit the inclusion of some other transition rules like Elect, Collect, and Choose <ref> [28] </ref>. The structure of a specification resembles the structure of a program written in a modern programming language: static part, where specifications of data types and static functions are counterparts of data type and function definitions, and dynamic part, where transition rules are counterparts of imperative statements.
Reference: [29] <author> E. Boerger and D. Rosenzweig, </author> <title> The WAM-Definition and Compiler Correctness, Logic Programming: Formal Methods and Practical Applications, </title> <booktitle> North-Holland Series in Computer Science and Artificial Intelligence, </booktitle> <year> 1994. </year>
Reference-contexts: A move to it is demonstrated by the extension of the basic set of transition rules given in [1] with sequential updates [24] and a kind of for-loop <ref> [29] </ref>. The approach presented is based on static signatures, which means that all algebra transformations are done within the same signature.
References-found: 28

