URL: http://www.cse.psu.edu/~catuscia/papers/Book_Integration/root.ps.gz
Refering-URL: http://www.cse.psu.edu/~catuscia/publications.html
Root-URL: http://www.cse.psu.edu
Title: A Paradigm for Asynchronous Communication and its Application to Concurrent Constraint Programming  
Author: Frank S. de Boer Joost N. Kok Catuscia Palamidessi Jan J.M.M. Rutten 
Abstract: We develop a general semantic theory of asynchronous communication in concurrent logic and concurrent constraint languages. The main characteristic of these languages, from the point of view of the communication mechanism, is that processes interact by querying and updating some common data structure. We abstract from the specific features of the underlying data structure by means of a uniform language of which the actions are interpreted as transformations on an abstract set of states. This approach shows that there exists a basic similarity between concurrent logic (constraint) languages and other languages based on asynchrononous communication, like dataflow and asynchronous CSP. Actually, our intention is to capture languages based on asynchronous communication as instances of this uniform language, such an instance being determined by a specific set of states and interpretation of the actions. The computational model of our paradigm is described by a transition system in the style of Plotkin's SOS. A compositional model is presented that is based on reactive sequences, i.e., sequences of pairs of states. 
Abstract-found: 1
Intro-found: 1
Reference: [BHR84] <author> S.D. Brookes, C.A.R. Hoare, and W. Roscoe. </author> <title> A theory of communicating sequential processes. </title> <journal> Journal of ACM, </journal> <volume> 31 </volume> <pages> 499-560, </pages> <year> 1984. </year>
Reference-contexts: In most cases, asynchronous languages have been studied 2 as special instances of the synchronous paradigm. For example, in [GMS89] the semantics of FCP is defined by using an adaptation of the failure set semantics of TCSP <ref> [BHR84] </ref>, and [SR90] uses for a concurrent constraint language the bisimulation equivalence on trees of CCS [Mil80].
Reference: [BK86] <author> J.A. Bergstra and J.W. Klop. </author> <title> A complete inference system for regular processes with silent moves. </title> <editor> In F.R. Drake and J.K. Truss, editors, </editor> <booktitle> Proceedings Logic Colloquium 1986, </booktitle> <pages> pages 21-81, </pages> <address> Hull, 1986. </address> <publisher> North-Holland. </publisher>
Reference-contexts: The above characterisation of D ns is reminiscent of the way one can model weak observational congruence ([Mil80]) (or rooted tau-bisimulation ([BK86])), as strong bisimulation by adding rules like, for instance, if s ! s 0 and s 0 a ! s 00 then s a (See <ref> [BK86, vG87] </ref>.) The present case is by its non-uniform nature more intricate.
Reference: [Cla79] <author> K.L. Clark. </author> <title> Predicate logic as a computational formalism. </title> <type> Technical Report DOC 79/59, </type> <institution> Imperial College, Dept. of Computing, </institution> <address> London, </address> <year> 1979. </year>
Reference-contexts: The Herbrand constraint system hH; `i is the structure generated by the simple constraint system hEq; `i, where Eq is the set of equations on T , and ` is the entailment relation generated by Clark's equality axioms <ref> [Cla79] </ref>, i.e. the minimal relation satisfying the requirements in Definition 3.1 and the following: 1. 8t 2 T: ; ` t = t 3. 8t; u; v 2 T: ft = u; u = vg ` t = v 4.
Reference: [dBK90] <author> J.W. de Bakker and J.N. Kok. </author> <title> Comparative metric semantics for concurrent prolog. </title> <journal> Theoretical Computer Science, </journal> <volume> 75 </volume> <pages> 15-43, </pages> <year> 1990. </year>
Reference-contexts: Concurrent logic languages, like Flat Concurrent Prolog [Sha89], can be obtained as instances of L by interpreting the proper states (excluding suspension and failure) as the bindings established on the logical variables, and the actions as the unification steps (see <ref> [dBK90] </ref>). Apart from the concurrent constraint languages, many languages for asynchronously communicating processes can be obtained as instances of L by choosing the appropriate set of actions, the set of (proper) states and the interpretation of the basic actions.
Reference: [dBKPR91] <author> F.S. de Boer, J.N. Kok, C. Palamidessi, and J.J.M.M. Rutten. </author> <title> The failure of failures: Towards a paradigm for asynchronous communication. </title> <editor> In J.C.M. Baeten and J.F. Groote, editors, </editor> <booktitle> Proc. of CONCUR 91, volume 527 of Lecture Notes in Computer Science, </booktitle> <pages> pages 111 - 126. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: The naturalness of the compositional model for our paradigm derives from the fact that its definition is based on, essentially, sequences, and does not need additional structures like failure sets, which are needed for describing deadlock in the case of synchronously communicating processes. In <ref> [dBKPR91] </ref> we showed that our model is more abstract than the classical failure set semantics, and for that reason more suitable for describing asynchronous communication. 1.1 Comparison with related work In spite of the general interest for asynchronous communication as a natural mechanism for concur-rency in many different programming styles, not <p> The main contribution of both this chapter and <ref> [dBKPR91] </ref> is the generalization of the results obtained in [dBP90, dBP91, JHJ90, HdBR90] to a general language for asynchronous communication, in this way providing a uniform framework for reasoning about this kind of concurrency. <p> In <ref> [dBKPR91] </ref>, it is shown that D ns is fully abstract with respect to O ns for two classes of interpretations (generalizing earlier results of [HdBR90] and [dBP91]). 3 Concurrent constraint programming In this section we present `concurrent constraint programming' (cc programming), and show that it is an instance of the language <p> Recall that an instance consists of a specific choice for the set of states , the interpretation I, and the set of atomic actions A. More examples of instances (like asynchronous CSP and asynchronous CCS) can be found in <ref> [dBKPR91] </ref>. 17 4.1 An imperative language Let A be the set of assignments x := e, where x 2 V ar is a variable and e 2 Exp is an expression.
Reference: [dBP90] <author> F.S. de Boer and C. Palamidessi. </author> <title> Concurrent logic languages: Asynchronism and language comparison. </title> <booktitle> In Proc. of the North American Conference on Logic Programming, </booktitle> <pages> pages 175-194. </pages> <publisher> The MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: The main contribution of both this chapter and [dBKPR91] is the generalization of the results obtained in <ref> [dBP90, dBP91, JHJ90, HdBR90] </ref> to a general language for asynchronous communication, in this way providing a uniform framework for reasoning about this kind of concurrency. However, in this chapter we elaborate in more detail on how one can obtain various languages as instances of this general paradigm.
Reference: [dBP91] <author> F.S. de Boer and C. Palamidessi. </author> <title> A fully abstract model for concurrent constraint programming. </title> <editor> In S. Abramsky and T.S.E. Maibaum, editors, </editor> <booktitle> Proc. of TAPSOFT/CAAP, volume 493 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: For example, in [GMS89] the semantics of FCP is defined by using an adaptation of the failure set semantics of TCSP [BHR84], and [SR90] uses for a concurrent constraint language the bisimulation equivalence on trees of CCS [Mil80]. Only recently <ref> [dBP91] </ref> it has been shown that for concurrent logic and constraint languages reactive sequences of assume/tell-constraints are sufficiently expressive for defining a compositional model (both for the success and for the deadlock case). <p> The main contribution of both this chapter and [dBKPR91] is the generalization of the results obtained in <ref> [dBP90, dBP91, JHJ90, HdBR90] </ref> to a general language for asynchronous communication, in this way providing a uniform framework for reasoning about this kind of concurrency. However, in this chapter we elaborate in more detail on how one can obtain various languages as instances of this general paradigm. <p> In [dBKPR91], it is shown that D ns is fully abstract with respect to O ns for two classes of interpretations (generalizing earlier results of [HdBR90] and <ref> [dBP91] </ref>). 3 Concurrent constraint programming In this section we present `concurrent constraint programming' (cc programming), and show that it is an instance of the language L introduced in the previous section.
Reference: [dBZ82] <author> J.W. de Bakker and J.I. Zucker. </author> <title> Processes and the denotational semantics of concur-rency. </title> <journal> Information and Control, </journal> <volume> 54 </volume> <pages> 70-120, </pages> <year> 1982. </year>
Reference-contexts: A suitable framework would be the family of complete metric spaces (see <ref> [dBZ82] </ref>). 4 R1 a ! E if I (a)(oe)=oe 0 D1 a hoe;ffii ! E if I (a)(oe)=ffi F1 a ! E if I (a)(oe)= hoe;oe 0 i s; t ! s 0 ; t hoe;ffii ! E hoe;ffii ! E hoe;i s; t ! E hoe;oe 0 i s k
Reference: [GMS89] <author> H. Gaifman, M. J. Maher, and E. Shapiro. </author> <title> Reactive Behaviour semantics for Concurrent Constraint Logic Programs. </title> <editor> In E. Lusk and R. Overbeck, editors, </editor> <booktitle> North American Conference on Logic Programming, </booktitle> <year> 1989. </year>
Reference-contexts: In most cases, asynchronous languages have been studied 2 as special instances of the synchronous paradigm. For example, in <ref> [GMS89] </ref> the semantics of FCP is defined by using an adaptation of the failure set semantics of TCSP [BHR84], and [SR90] uses for a concurrent constraint language the bisimulation equivalence on trees of CCS [Mil80].
Reference: [HdBR90] <author> E. Horita, J.W. de Bakker, and J.J.M.M. Rutten. </author> <title> Fully abstract denotational models for nonuniform concurrent languages. </title> <type> Technical Report CS-R9027, </type> <institution> Centre for Mathematics and Computer Science, </institution> <address> Amsterdam, </address> <year> 1990. </year> <note> To appear in Information and Computation. </note>
Reference-contexts: Apart from the concurrent constraint languages, many languages for asynchronously communicating processes can be obtained as instances of L by choosing the appropriate set of actions, the set of (proper) states and the interpretation of the basic actions. For example, the imperative language described in <ref> [HdBR90] </ref>, based on shared variables, can be modeled by taking as states functions from variables to values, as actions the set of assignments, and then the usual interpretation of an assignment as a state transformation. <p> For an overview consult [Kok89]. Related languages (receptive processes communicating via asynchronous channels) have been recently studied in [JHJ90] and [Jos90]. In these papers as well, the authors propose a semantics which is based on sequences of input-output events. Finally, in <ref> [HdBR90] </ref>, a semantics based on sequences of pair of states, similar to the one we study in this chapter, has been developed for an imperative language; it is shown to be correct and fully abstract with respect to successful computations. <p> The main contribution of both this chapter and [dBKPR91] is the generalization of the results obtained in <ref> [dBP90, dBP91, JHJ90, HdBR90] </ref> to a general language for asynchronous communication, in this way providing a uniform framework for reasoning about this kind of concurrency. However, in this chapter we elaborate in more detail on how one can obtain various languages as instances of this general paradigm. <p> In [dBKPR91], it is shown that D ns is fully abstract with respect to O ns for two classes of interpretations (generalizing earlier results of <ref> [HdBR90] </ref> and [dBP91]). 3 Concurrent constraint programming In this section we present `concurrent constraint programming' (cc programming), and show that it is an instance of the language L introduced in the previous section. <p> Then define I by I (x := e)(oe)(y) = oe (y) if y 6= x With this choice for A, and I, the semantic models for L are essentially the same as the operational and denotational semantics presented for a concurrent language with assignment in <ref> [HdBR90] </ref>. One could include in this language a suspension mechanism by associating with each assignment a boolean expression, which must be true to enable the execution of the assignment (otherwise it suspends). A basic action is then an object of the form b:x := e.
Reference: [Hoa78] <author> C.A.R. Hoare. </author> <title> Communicating sequential processes. </title> <journal> Communications of the ACM, </journal> <volume> 21(8) </volume> <pages> 666-677, </pages> <year> 1978. </year>
Reference-contexts: The asynchronous nature of the communication stems from the independency of the update and query operations in the sense that they can take place at different times. This marks an essential difference with languages like CSP <ref> [Hoa78] </ref>, where processes communicate by means of a "handshaking" mechanism, i.e., the simultaneous execution of (complementary) actions. Our paradigm consists of a concurrent language L which assumes as given a set of basic (or atomic) actions.
Reference: [JHJ90] <author> M.B. Josephs, </author> <title> C.A.R. Hoare, and He Jifeng. A theory of asynchronous processes. </title> <type> Technical report, </type> <institution> Oxford University Computing Laboratories, </institution> <year> 1990. </year>
Reference-contexts: For an overview consult [Kok89]. Related languages (receptive processes communicating via asynchronous channels) have been recently studied in <ref> [JHJ90] </ref> and [Jos90]. In these papers as well, the authors propose a semantics which is based on sequences of input-output events. <p> The main contribution of both this chapter and [dBKPR91] is the generalization of the results obtained in <ref> [dBP90, dBP91, JHJ90, HdBR90] </ref> to a general language for asynchronous communication, in this way providing a uniform framework for reasoning about this kind of concurrency. However, in this chapter we elaborate in more detail on how one can obtain various languages as instances of this general paradigm.
Reference: [JJH90] <author> He Jifeng, </author> <title> M.B. Josephs, and C.A.R. Hoare. A theory of synchrony and asynchrony. </title> <booktitle> In Proc. of IFIP Working Conference on Programming Concepts and Methods, </booktitle> <pages> pages 459-478, </pages> <year> 1990. </year>
Reference-contexts: An asynchronous version of CSP, where processes communicate via asynchronous channels (see <ref> [JJH90] </ref>), can be obtained by taking as states the configurations of the channels and as actions the input-output primitives on these channels. Other interesting instances of L are IO-automata and data flow.
Reference: [Jon85] <author> B. Jonsson. </author> <title> A model and a proof system for asynchronous processes. </title> <booktitle> In Proc. of the 4th ACM Symp. on Principles of Distributed Computing, </booktitle> <pages> pages 49-58, </pages> <year> 1985. </year>
Reference-contexts: In the field of data flow, compositional models based on an appropriate notion of sequences called quiescent traces have been developed (for example in <ref> [Jon85] </ref>) and have been shown to be fully abstract. For an overview consult [Kok89]. Related languages (receptive processes communicating via asynchronous channels) have been recently studied in [JHJ90] and [Jos90]. In these papers as well, the authors propose a semantics which is based on sequences of input-output events.
Reference: [Jon90] <author> B. Jonsson. </author> <title> A hiearchy of compositional models of I/O-automata. </title> <booktitle> In Proc. MFCS, volume 452 of Lecture Notes in Computer Science, </booktitle> <pages> pages 347-354, </pages> <year> 1990. </year>
Reference-contexts: However, as our instance shows, the fact that an IO-automaton is not allowed to refuse inputs makes its communication mechanism asynchronous. We first give a short introduction to IO-automata. More information can be found in [LT87], and in <ref> [Jon90] </ref> on which this introduction is based. We assume given a set of events (e 2) Event.
Reference: [Jos90] <author> M.B. Josephs. </author> <title> Receptive process theory. </title> <type> Technical report, </type> <institution> Eindhoven University, </institution> <year> 1990. </year>
Reference-contexts: For an overview consult [Kok89]. Related languages (receptive processes communicating via asynchronous channels) have been recently studied in [JHJ90] and <ref> [Jos90] </ref>. In these papers as well, the authors propose a semantics which is based on sequences of input-output events.
Reference: [Kok89] <author> J.N. Kok. </author> <title> Traces, histories and streams in the semantics of nondeterministic dataflow. </title> <type> Technical Report 91, </type> <institution> Abo Akademi, Finland, </institution> <year> 1989. </year>
Reference-contexts: In the field of data flow, compositional models based on an appropriate notion of sequences called quiescent traces have been developed (for example in [Jon85]) and have been shown to be fully abstract. For an overview consult <ref> [Kok89] </ref>. Related languages (receptive processes communicating via asynchronous channels) have been recently studied in [JHJ90] and [Jos90]. In these papers as well, the authors propose a semantics which is based on sequences of input-output events.
Reference: [LT87] <author> N. Lynch and M. Tuttle. </author> <title> Hierarchical correctness proofs for distributed algorithms. </title> <booktitle> In Proc. 6 th ACM PoDC, </booktitle> <pages> pages 137-151, </pages> <year> 1987. </year>
Reference-contexts: However, as our instance shows, the fact that an IO-automaton is not allowed to refuse inputs makes its communication mechanism asynchronous. We first give a short introduction to IO-automata. More information can be found in <ref> [LT87] </ref>, and in [Jon90] on which this introduction is based. We assume given a set of events (e 2) Event. <p> The set Steps (L k Y ) is fon light of f on light; on off on lightg: There is a hiding operator on IO-automata (see <ref> [LT87] </ref>), but we cannot model this operator in the present framework: it requires a block construct in the language L. (This extension will be discussed in a forthcoming paper.) Next we describe how IO-automata can be embedded into an instantiation of the language L.
Reference: [Mil80] <author> R. Milner. </author> <title> Calculus of Communicating Systems, </title> <booktitle> volume 92 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1980. </year>
Reference-contexts: For example, in [GMS89] the semantics of FCP is defined by using an adaptation of the failure set semantics of TCSP [BHR84], and [SR90] uses for a concurrent constraint language the bisimulation equivalence on trees of CCS <ref> [Mil80] </ref>. Only recently [dBP91] it has been shown that for concurrent logic and constraint languages reactive sequences of assume/tell-constraints are sufficiently expressive for defining a compositional model (both for the success and for the deadlock case).
Reference: [Plo81] <author> G.D. Plotkin. </author> <title> A structural approach to operational semantics. </title> <type> Technical Report DAIMI FN-19, </type> <institution> Aarhus University, Computer Science Department, </institution> <year> 1981. </year>
Reference-contexts: This is at the same time the basis for their correctness with respect to the operational model O. In the semantics for concurrency, it is often the case that operational semantics (in Plotkin's SOS style, see <ref> [Plo81] </ref>) is more basic than denotational semantics in the sense that the latter can be derived from the former. See [Rut90] for a systematic development of this idea in the context of bisimulation equivalence. Example 2.8 Consider A = f?0; ?1; ffig, = f0; 1g.
Reference: [Rut90] <author> J.J.M.M. Rutten. </author> <title> Deriving denotational models for bisimulation from Structured Operational Semantics. </title> <editor> In M. Broy and C.B. Jones, editors, </editor> <booktitle> Programming concepts and methods, proceedings of the IFIP Working Group 2.2/2.3 Working Conference, </booktitle> <pages> pages 155-177. </pages> <publisher> North-Holland, </publisher> <year> 1990. </year>
Reference-contexts: In the semantics for concurrency, it is often the case that operational semantics (in Plotkin's SOS style, see [Plo81]) is more basic than denotational semantics in the sense that the latter can be derived from the former. See <ref> [Rut90] </ref> for a systematic development of this idea in the context of bisimulation equivalence. Example 2.8 Consider A = f?0; ?1; ffig, = f0; 1g.
Reference: [Sar89] <author> V.A. Saraswat. </author> <title> Concurrent Constraint Programming Languages. </title> <type> PhD thesis, </type> <institution> Carnegie-Mellon University, </institution> <month> January </month> <year> 1989. </year> <note> Published by The MIT Press, </note> <institution> U.S.A., </institution> <year> 1990. </year>
Reference-contexts: In case the result of the update gives rise to an inconsistency, a special state representing failure is delivered. In general, an action can embody both an update and a query component. The concurrent constraint languages <ref> [Sar89] </ref> are modeled by interpreting the abstract set of states as a constraint system and the actions as ask/tell primitives. <p> Namely, we show that the computational model of cc and its compositional semantics can be described by instantiating properly the set of actions, the set of states, and the interpretation function which constitute the parameters of L. Concurrent constraint programming was proposed by Saraswat <ref> [Sar89, SR90, SRP90] </ref>. We follow here the definition given in [SR90], which is more general than the later formulations, because it deals with a more general notion of guard. <p> In this version, concurrent constraint programming can be regarded as a generalization of most of the concurrent logic languages, including the `more powerful' ones like Concurrent Prolog. See <ref> [Sar89] </ref> for a detailed list of the logic languages which are subsumed by the cc language, and the corresponding justification. Before describing the cc paradigm we have to introduce the notion of constraint system.
Reference: [Sha86] <author> E. Y. Shapiro. </author> <title> Concurrent Prolog: A progress report. </title> <journal> Computer, </journal> <volume> 19(8) </volume> <pages> 44-58, </pages> <year> 1986. </year>
Reference: [Sha89] <author> E.Y. Shapiro. </author> <title> The family of concurrent logic programming languages. </title> <journal> ACM Computing Surveys, </journal> <volume> 21(3) </volume> <pages> 412-510, </pages> <year> 1989. </year>
Reference-contexts: In general, an action can embody both an update and a query component. The concurrent constraint languages [Sar89] are modeled by interpreting the abstract set of states as a constraint system and the actions as ask/tell primitives. Concurrent logic languages, like Flat Concurrent Prolog <ref> [Sha89] </ref>, can be obtained as instances of L by interpreting the proper states (excluding suspension and failure) as the bindings established on the logical variables, and the actions as the unification steps (see [dBK90]).
Reference: [SR90] <author> V.A. Saraswat and M. Rinard. </author> <title> Concurrent constraint programming. </title> <booktitle> In Proc. of the seventeenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 232-245, </pages> <address> New York, 1990. </address> <publisher> ACM. </publisher>
Reference-contexts: In most cases, asynchronous languages have been studied 2 as special instances of the synchronous paradigm. For example, in [GMS89] the semantics of FCP is defined by using an adaptation of the failure set semantics of TCSP [BHR84], and <ref> [SR90] </ref> uses for a concurrent constraint language the bisimulation equivalence on trees of CCS [Mil80]. Only recently [dBP91] it has been shown that for concurrent logic and constraint languages reactive sequences of assume/tell-constraints are sufficiently expressive for defining a compositional model (both for the success and for the deadlock case). <p> Namely, we show that the computational model of cc and its compositional semantics can be described by instantiating properly the set of actions, the set of states, and the interpretation function which constitute the parameters of L. Concurrent constraint programming was proposed by Saraswat <ref> [Sar89, SR90, SRP90] </ref>. We follow here the definition given in [SR90], which is more general than the later formulations, because it deals with a more general notion of guard. <p> Concurrent constraint programming was proposed by Saraswat [Sar89, SR90, SRP90]. We follow here the definition given in <ref> [SR90] </ref>, which is more general than the later formulations, because it deals with a more general notion of guard. In this version, concurrent constraint programming can be regarded as a generalization of most of the concurrent logic languages, including the `more powerful' ones like Concurrent Prolog. <p> Actually, the only visible activity of a process consists of manipulating this data structure. 3.1 Constraint systems The definition of constraint system we will give here is a slightly modified version of the one described in <ref> [SR90] </ref>. We first need to introduce the notion of simple constraint system. <p> Some of them check for the consistency of ff with respect to the current store, before executing tell (ff). Others just add ff regardless of whether or not it will lead to an inconsistent situation. The two kinds of tell are called atomic tell and eventual tell respectively in <ref> [SR90] </ref>. The different definitions of this operation are already present in the literature concerning concurrent logic programming. There the consistency check is usually called atomic unification (this explains the terminology "atomic tell": unification on the Herbrand universe corresponds, roughly, to adding a constraint to the store). <p> Furthermore, the cc computational model of <ref> [SR90] </ref> prescribes the following laws for the suspension mechanism: * a process can suspend only if it has no possibility to proceed with a `proper transition', and 15 * the system can suspend only if all processes suspend (as long as some processes can proceed and hopefully- modify the store, suspension <p> The computational model of cc <ref> [SR90] </ref> prescribes the following laws concerning the detection of an unavoidable inconsistency (failure): * it can happen only when there are no other alternatives, and * it can immediately be propagated to the whole system. We see that the failure corresponds to a transition (cfr the transition system table).
Reference: [SRP90] <author> V.A. Saraswat, M. Rinard, and P. Panangaden. </author> <title> A fully abstract semantics for concurrent constraint programming. </title> <booktitle> In Proc. of the eighteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> New York, 1990. </address> <publisher> ACM. </publisher>
Reference-contexts: Namely, we show that the computational model of cc and its compositional semantics can be described by instantiating properly the set of actions, the set of states, and the interpretation function which constitute the parameters of L. Concurrent constraint programming was proposed by Saraswat <ref> [Sar89, SR90, SRP90] </ref>. We follow here the definition given in [SR90], which is more general than the later formulations, because it deals with a more general notion of guard.
Reference: [Ued87] <author> K. Ueda. </author> <title> Guarded Horn Clauses. </title> <editor> In E. Y. Shapiro, editor, </editor> <title> Concurrent Prolog: Collected Papers. </title> <publisher> The MIT Press, </publisher> <year> 1987. </year>
Reference: [vG87] <author> R.J. van Glabbeek. </author> <title> Bounded nondeterminism and the approximation induction principle in process algebra. </title> <editor> In F.J. Brandenburg, G. Vidal-Naquet, and M. Wirsing, editors, </editor> <booktitle> Proceedings STACS 1987, volume 247 of Lecture Notes in Computer Science, </booktitle> <pages> pages 336-447. </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year> <month> 25 </month>
Reference-contexts: The above characterisation of D ns is reminiscent of the way one can model weak observational congruence ([Mil80]) (or rooted tau-bisimulation ([BK86])), as strong bisimulation by adding rules like, for instance, if s ! s 0 and s 0 a ! s 00 then s a (See <ref> [BK86, vG87] </ref>.) The present case is by its non-uniform nature more intricate.
References-found: 28

