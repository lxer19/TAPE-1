URL: ftp://dirleton.csres.utexas.edu/pub/reports/041.ps
Refering-URL: http://www.cli.com/reports/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Phone: (512) 322-9951  
Title: An Approach to Systems Verification  
Author: William R. Bevier, Warren A. Hunt, Jr., J Strother Moore, William D. Young 
Note: This work was supported in part at Computational Logic, Inc., by the Defense Advanced Research Projects Agency, ARPA Orders 6082 and 9151. The views and conclusions contained in this document are those of the author(s) and should not be interpreted as representing the official policies, either expressed or implied, of Computational Logic, Inc., the Defense Advanced Research Projects Agency or the U.S. Government.  
Address: 1717 W. 6th St. Suite 290 Austin, Texas 78703  
Affiliation: Computational Logic Inc.  
Date: 41 April, 1989  
Pubnum: Technical Report  
Abstract-found: 0
Intro-found: 1
Reference: 1. <author> W.R. Bevier. </author> <title> Kit: A Study in Operating System Verification. </title> <type> Tech. </type> <institution> Rept. </institution> <month> 28, </month> <title> Computational Logic, </title> <publisher> Inc., 1717 W. </publisher> <address> 6th St., Suite 290, Austin, Texas, 78703, </address> <month> March, </month> <year> 1988&gt;. </year>
Reference-contexts: In this paper we outline our approach to systems verification, and summarize the application of our approach to several systems components. These components consist of a code generator for a simple high-level language [16], an assembler and linking loader [14], a simple operating system kernel <ref> [2, 1] </ref>, and a microprocessor design [11]. Each of these is formally specified by an abstract finite state machine, and each is proved correct by showing that a lower level machine implements the abstract machine.
Reference: 2. <author> W.R. Bevier. </author> <title> Kit and the Short Stack. </title> <note> To appear in The Journal of Automated Reasoning. </note>
Reference-contexts: In this paper we outline our approach to systems verification, and summarize the application of our approach to several systems components. These components consist of a code generator for a simple high-level language [16], an assembler and linking loader [14], a simple operating system kernel <ref> [2, 1] </ref>, and a microprocessor design [11]. Each of these is formally specified by an abstract finite state machine, and each is proved correct by showing that a lower level machine implements the abstract machine. <p> C C C A C A To see this, substitute MapDown (s ) for s in (2). Figure 1-(b) illustrates the correspondence which this A C 10 theorem establishes. This is the general form, for example, of the interpreter equivalence theorem proven for our simple operating system Kit <ref> [2] </ref>. <p> The full specification of Kit, the correctness theorem, and its proof are described in <ref> [2] </ref>. While Kit is not big enough to be considered a kernel for a general purpose operating system, it does confront some important operating system phenomena. It is adequate for a small special purpose system such as a communications processor. <p> This will allow us to run several communicating parallel Piton processes. It may also permit Micro-Gypsy to be extended to include Gypsy concurrent processing capabilities [9], and I/O. See <ref> [2] </ref> for a discussion of how an operating system can be placed in the stack. 5. Conclusion The key to our approach to systems verification is the use of formally-defined abstract machines. These machines are defined explicitly as functions in the Boyer-Moore logic. <p> This latter remark is the key to hierarchical system verification and the formal explanation of abstraction. The idea of producing a verified system by stacking machine descriptions of increasing abstraction is not new. (The papers which describe the individual components of our system <ref> [16, 14, 2, 11] </ref> contain references to previous work.) What is new is the degree of integration we have been able to achieve among our verified components. 6.
Reference: 3. <author> R.S. Boyer, J S. Moore. Metafunctions: </author> <title> Proving Them Correct and Using them Efficiently as New Proof Procedures. In R.S. </title> <editor> Boyer, J S. Moore, Ed., </editor> <booktitle> The Correctness Problem in Computer Science, </booktitle> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1981. </year>
Reference-contexts: The theorem prover has checked the proof of invertibility of the RSA public key encryption algorithm [7], the correctness of metatheoretic simplifiers for the logic <ref> [3] </ref>, and the optimality of a transformation for introducing concurrency into sorting networks [13].
Reference: 4. <author> R. S. Boyer and J S. Moore. </author> <title> "A Fast String Searching Algorithm". </title> <journal> Comm. ACM 20, </journal> <volume> 10 (1977), </volume> <pages> 762-772. </pages>
Reference-contexts: When connected to a verification condition generator for Fortran [5], the system has proved the correctness of Fortran implementations of the Boyer-Moore fast string searching algorithm <ref> [4, 5] </ref> and Moore's linear time majority vote algorithm [6]. 6 2.3 An Interactive Enhancement to the Prover Also available for assistance in proving theorems stated in the Boyer-Moore logic is an interactive interface to the prover written by Matt Kaufmann [12].
Reference: 5. <author> R. S. Boyer and J S. Moore. </author> <title> A Verification Condition Generator for FORTRAN. In The Correctness Problem in Computer Science, </title> <editor> R. S. Boyer and J S. Moore, Eds., </editor> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1981. </year>
Reference-contexts: The theorem prover has checked the proof of invertibility of the RSA public key encryption algorithm [7], the correctness of metatheoretic simplifiers for the logic [3], and the optimality of a transformation for introducing concurrency into sorting networks [13]. When connected to a verification condition generator for Fortran <ref> [5] </ref>, the system has proved the correctness of Fortran implementations of the Boyer-Moore fast string searching algorithm [4, 5] and Moore's linear time majority vote algorithm [6]. 6 2.3 An Interactive Enhancement to the Prover Also available for assistance in proving theorems stated in the Boyer-Moore logic is an interactive interface <p> When connected to a verification condition generator for Fortran [5], the system has proved the correctness of Fortran implementations of the Boyer-Moore fast string searching algorithm <ref> [4, 5] </ref> and Moore's linear time majority vote algorithm [6]. 6 2.3 An Interactive Enhancement to the Prover Also available for assistance in proving theorems stated in the Boyer-Moore logic is an interactive interface to the prover written by Matt Kaufmann [12].
Reference: 6. <author> R. S. Boyer and J S. Moore. </author> <title> MJRTY - A Fast Majority Vote Algorithm. </title> <type> Tech. </type> <institution> Rept. ICSCA-CMP-32, Institute for Computing Science and Computer Applications, University of Texas at Austin, </institution> <year> 1982. </year> <note> Also available through Computational Logic, </note> <institution> Inc., </institution> <address> Suite 290, 1717 West Sixth Street, Austin, TX 78703.. </address>
Reference-contexts: When connected to a verification condition generator for Fortran [5], the system has proved the correctness of Fortran implementations of the Boyer-Moore fast string searching algorithm [4, 5] and Moore's linear time majority vote algorithm <ref> [6] </ref>. 6 2.3 An Interactive Enhancement to the Prover Also available for assistance in proving theorems stated in the Boyer-Moore logic is an interactive interface to the prover written by Matt Kaufmann [12].
Reference: 7. <author> R. S. Boyer and J S. Moore. </author> <title> "Proof Checking the RSA Public Key Encryption Algorithm". </title> <journal> American Mathematical Monthly 91, </journal> <volume> 3 (1984), </volume> <pages> 181-189. </pages>
Reference-contexts: The theorem prover has checked the proof of invertibility of the RSA public key encryption algorithm <ref> [7] </ref>, the correctness of metatheoretic simplifiers for the logic [3], and the optimality of a transformation for introducing concurrency into sorting networks [13].
Reference: 8. <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic Handbook. </title> <publisher> Academic Press, </publisher> <address> Boston, </address> <year> 1988. </year>
Reference-contexts: The Boyer-Moore theorem prover is a computer program that can be used interactively to prove theorems in the Boyer-Moore logic. Both the formal logic and the Boyer-Moore theorem prover are fully described in <ref> [8] </ref>. In the current section we give a short overview of the logic and the theorem prover. <p> The system has been used to formalize and prove a wide variety of problems including the gate-level hardware designs, operating system functionality, and language implementations described in this series of papers. Other interesting theorems proved by the system are: Gauss' law of quadratic reciprocity <ref> [8] </ref>, the so-called "jewel of elementary number theory;" the Church-Rosser theorem for lambda calculus [15]; and th Goedel's incompleteness theorem, the deepest and most stunning theorem in 20 century mathematics [15].
Reference: 9. <author> D.I. Good, R.M. Cohen, J. Keeton-Williams. </author> <title> Principles of Proving Concurrent Programs in Gypsy. </title> <type> Tech. </type> <institution> Rept. ICSCA-CMP-15, Institute for Computer Science and Computing Applications, The University of Texas at Austin, </institution> <month> January, </month> <year> 1979. </year>
Reference-contexts: This will allow us to run several communicating parallel Piton processes. It may also permit Micro-Gypsy to be extended to include Gypsy concurrent processing capabilities <ref> [9] </ref>, and I/O. See [2] for a discussion of how an operating system can be placed in the stack. 5. Conclusion The key to our approach to systems verification is the use of formally-defined abstract machines. These machines are defined explicitly as functions in the Boyer-Moore logic.
Reference: 10. <author> M. J. Gordon, A. J. Milner, and C. P. </author> <title> Wadsworth. </title> <publisher> Edinburgh LCF. Springer-Verlag, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: The system is goal-directed: a proof is completed when the main goal and all subgoals have been proved. A notion of macro commands lets the user create compound commands, in the spirit of the tactics and tacticals of LCF <ref> [10] </ref>. Upon completion of an interactive proof, the lemma proved may be stored in the database of the Boyer-Moore theorem prover. The interactively constructed proof is also stored so that it is possible to "replay" the proof in the event that the evolving database is modified in the future.
Reference: 11. <author> W.A. Hunt. </author> <title> Microprocessor Design Verification. </title> <note> To appear in The Journal of Automated Reasoning. </note>
Reference-contexts: These components consist of a code generator for a simple high-level language [16], an assembler and linking loader [14], a simple operating system kernel [2, 1], and a microprocessor design <ref> [11] </ref>. Each of these is formally specified by an abstract finite state machine, and each is proved correct by showing that a lower level machine implements the abstract machine. <p> Complete descriptions of the relevant machines, implementations, MapUp functions, correctness theorems, and proofs are given in the accompanying papers in this collection <ref> [11, 14, 16] </ref>. We have proved the additional results necessary to let us "stack" the three correctness results. For example, a legal Micro-Gypsy program that executes without high-level errors is compiled into a legal Piton program that executes without Piton-level errors, etc. <p> This latter remark is the key to hierarchical system verification and the formal explanation of abstraction. The idea of producing a verified system by stacking machine descriptions of increasing abstraction is not new. (The papers which describe the individual components of our system <ref> [16, 14, 2, 11] </ref> contain references to previous work.) What is new is the degree of integration we have been able to achieve among our verified components. 6.
Reference: 12. <author> Matt Kaufmann. </author> <title> A User's Manual for an Interactive Enhancement to the Boyer-Moore Theorem Prover. </title> <type> Tech. </type> <institution> Rept. </institution> <month> 19, </month> <title> Computational Logic, </title> <publisher> Inc., 1717 W. </publisher> <address> 6th St., Suite 290, Austin, Texas, 78703, </address> <month> May, </month> <year> 1988. </year>
Reference-contexts: Another theorem proving tool which was used for part of the work reported in this series of papers is 3 an interactive interface to the Boyer-Moore prover written by Matt Kaufmann and fully described in <ref> [12] </ref>. We briefly describe this as well. 2.1 The Boyer-Moore Logic Terms in the Boyer-Moore logic are written using a prefix syntax similar to Pure Lisp. For example, we write (PLUS I J) where others might write PLUS (I,J) or I+J. <p> Fortran implementations of the Boyer-Moore fast string searching algorithm [4, 5] and Moore's linear time majority vote algorithm [6]. 6 2.3 An Interactive Enhancement to the Prover Also available for assistance in proving theorems stated in the Boyer-Moore logic is an interactive interface to the prover written by Matt Kaufmann <ref> [12] </ref>. The purpose of the interface is to give the user more precise control of the theorem prover in the search for a proof. The user can give commands at a low level (such as deleting a hypothesis) or at a high level (such as calling the Boyer-Moore Theorem Prover).
Reference: 13. <author> Lengauer, C., and Huang, C.-H. </author> <title> A Mechanically Certified Theorem about Optimal Concurrency of Sorting Networks. </title> <booktitle> Proc. 13th Ann. ACM Symp. on Principles of Programming Languages, </booktitle> <year> 1986, </year> <pages> pp. 307-317. </pages>
Reference-contexts: The theorem prover has checked the proof of invertibility of the RSA public key encryption algorithm [7], the correctness of metatheoretic simplifiers for the logic [3], and the optimality of a transformation for introducing concurrency into sorting networks <ref> [13] </ref>.
Reference: 14. <author> J S. Moore. </author> <title> A Mechanically Verified Language Implementation. </title> <note> To appear in The Journal of Automated Reasoning. Also available as Technical Report 30, Computational Logic, </note> <institution> Inc., 1717 W. </institution> <address> 6th St., Suite 290, Austin, Texas, </address> <month> 78703. </month>
Reference-contexts: In this paper we outline our approach to systems verification, and summarize the application of our approach to several systems components. These components consist of a code generator for a simple high-level language [16], an assembler and linking loader <ref> [14] </ref>, a simple operating system kernel [2, 1], and a microprocessor design [11]. Each of these is formally specified by an abstract finite state machine, and each is proved correct by showing that a lower level machine implements the abstract machine. <p> Complete descriptions of the relevant machines, implementations, MapUp functions, correctness theorems, and proofs are given in the accompanying papers in this collection <ref> [11, 14, 16] </ref>. We have proved the additional results necessary to let us "stack" the three correctness results. For example, a legal Micro-Gypsy program that executes without high-level errors is compiled into a legal Piton program that executes without Piton-level errors, etc. <p> This latter remark is the key to hierarchical system verification and the formal explanation of abstraction. The idea of producing a verified system by stacking machine descriptions of increasing abstraction is not new. (The papers which describe the individual components of our system <ref> [16, 14, 2, 11] </ref> contain references to previous work.) What is new is the degree of integration we have been able to achieve among our verified components. 6.
Reference: 15. <author> N. Shankar. </author> <title> Proof Checking Metamathematics. </title> <institution> University of Texas at Austin, </institution> <year> 1986. </year> <note> Also available through Computational Logic, </note> <institution> Inc., </institution> <address> Suite 290, 1717 West Sixth Street, Austin, TX 78703.. </address>
Reference-contexts: Other interesting theorems proved by the system are: Gauss' law of quadratic reciprocity [8], the so-called "jewel of elementary number theory;" the Church-Rosser theorem for lambda calculus <ref> [15] </ref>; and th Goedel's incompleteness theorem, the deepest and most stunning theorem in 20 century mathematics [15]. <p> Other interesting theorems proved by the system are: Gauss' law of quadratic reciprocity [8], the so-called "jewel of elementary number theory;" the Church-Rosser theorem for lambda calculus <ref> [15] </ref>; and th Goedel's incompleteness theorem, the deepest and most stunning theorem in 20 century mathematics [15]. The theorem prover has checked the proof of invertibility of the RSA public key encryption algorithm [7], the correctness of metatheoretic simplifiers for the logic [3], and the optimality of a transformation for introducing concurrency into sorting networks [13].
Reference: 16. <author> W.D. Young. </author> <title> A Mechanically Verified Code Generator. </title> <note> To appear in The Journal of Automated Reasoning. Also available as Technical Report 36, Computational Logic, </note> <institution> Inc., 1717 W. </institution> <address> 6th St., Suite 290, Austin, Texas, </address> <month> 78703. </month> <title> Table of Contents </title>
Reference-contexts: In this paper we outline our approach to systems verification, and summarize the application of our approach to several systems components. These components consist of a code generator for a simple high-level language <ref> [16] </ref>, an assembler and linking loader [14], a simple operating system kernel [2, 1], and a microprocessor design [11]. Each of these is formally specified by an abstract finite state machine, and each is proved correct by showing that a lower level machine implements the abstract machine. <p> The proof checker was used extensively in the proof of our code generator <ref> [16] </ref>. <p> A A A C A C This is the relation illustrated in the commuting diagram in figure 1-(c). This is the form of interpreter equivalence theorem established for our high-level language compiler <ref> [16] </ref>, for example. We cannot state any of (1), (2), or (3) in the quantifier-free Boyer-Moore logic. To address this 11 difficulty, we replace the existential quantification with an explicit "witness" function ORACLE which computes the value of the concrete oracle. <p> Complete descriptions of the relevant machines, implementations, MapUp functions, correctness theorems, and proofs are given in the accompanying papers in this collection <ref> [11, 14, 16] </ref>. We have proved the additional results necessary to let us "stack" the three correctness results. For example, a legal Micro-Gypsy program that executes without high-level errors is compiled into a legal Piton program that executes without Piton-level errors, etc. <p> This latter remark is the key to hierarchical system verification and the formal explanation of abstraction. The idea of producing a verified system by stacking machine descriptions of increasing abstraction is not new. (The papers which describe the individual components of our system <ref> [16, 14, 2, 11] </ref> contain references to previous work.) What is new is the degree of integration we have been able to achieve among our verified components. 6.
Reference: 1. <institution> Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 </institution>
Reference-contexts: In this paper we outline our approach to systems verification, and summarize the application of our approach to several systems components. These components consist of a code generator for a simple high-level language [16], an assembler and linking loader [14], a simple operating system kernel <ref> [2, 1] </ref>, and a microprocessor design [11]. Each of these is formally specified by an abstract finite state machine, and each is proved correct by showing that a lower level machine implements the abstract machine.



Reference: 5. <institution> Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17 </institution>
Reference-contexts: The theorem prover has checked the proof of invertibility of the RSA public key encryption algorithm [7], the correctness of metatheoretic simplifiers for the logic [3], and the optimality of a transformation for introducing concurrency into sorting networks [13]. When connected to a verification condition generator for Fortran <ref> [5] </ref>, the system has proved the correctness of Fortran implementations of the Boyer-Moore fast string searching algorithm [4, 5] and Moore's linear time majority vote algorithm [6]. 6 2.3 An Interactive Enhancement to the Prover Also available for assistance in proving theorems stated in the Boyer-Moore logic is an interactive interface <p> When connected to a verification condition generator for Fortran [5], the system has proved the correctness of Fortran implementations of the Boyer-Moore fast string searching algorithm <ref> [4, 5] </ref> and Moore's linear time majority vote algorithm [6]. 6 2.3 An Interactive Enhancement to the Prover Also available for assistance in proving theorems stated in the Boyer-Moore logic is an interactive interface to the prover written by Matt Kaufmann [12].
Reference: 6. <institution> Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18 i </institution>
Reference-contexts: When connected to a verification condition generator for Fortran [5], the system has proved the correctness of Fortran implementations of the Boyer-Moore fast string searching algorithm [4, 5] and Moore's linear time majority vote algorithm <ref> [6] </ref>. 6 2.3 An Interactive Enhancement to the Prover Also available for assistance in proving theorems stated in the Boyer-Moore logic is an interactive interface to the prover written by Matt Kaufmann [12].
References-found: 19

