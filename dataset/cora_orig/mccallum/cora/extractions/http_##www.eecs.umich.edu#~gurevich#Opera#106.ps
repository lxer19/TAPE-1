URL: http://www.eecs.umich.edu/~gurevich/Opera/106.ps
Refering-URL: http://www.eecs.umich.edu/~gurevich/annotated.html
Root-URL: http://www.cs.umich.edu
Title: Group Membership Protocol: Specification and Verification  
Author: Yuri Gurevich Raghu Mani 
Address: Ann Arbor, MI, 48109-2122, USA  
Affiliation: EECS Department, University of Michigan  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> E. Borger, Y. Gurevich and D. Rosenzweig. </author> <title> The Bakery Algorithm: Yet Another Specification and Verification. </title> <note> To appear in E. </note> <editor> Borger, editor, </editor> <title> Specification and Validation Methods for Programming Languages and Systems, </title> <publisher> Oxford University Press, </publisher> <year> 1994. </year>
Reference-contexts: 1 Introduction According to the Evolving Algebra thesis [3], evolving algebras should allow one to specify succinctly any algorithm. There exists substantial evidence confirming this thesis in the case of sequential algorithms (see the annotated bibliography in [3]). In other papers, e.g., <ref> [1, 5] </ref>, evolving algebras are used to specify distributed algorithms. For this paper, we wanted to look at a time-constrained algorithm that does something useful and poses some challenge to specify and verify. Our colleague Farnam Jahanian brought Cristian's article on group membership protocols [2] to our attention. <p> There exists m 0 = (x; y; z 0 ) in InBox (p) b+1 where z 0 z and 3. 0 &lt; Clock (q) b Clock (p) a d c . 4.2 Discussion We could use real-time semantics with either zero-time or prolonged actions, like in <ref> [1] </ref>, but the material lends itself to simpler semantics which is more general in a sense. Sequential Runs: According to [4], a sequential run is a sequence of states together with the agent-witness function.
Reference: [2] <author> F. Cristian. </author> <title> Reaching Agreement on Processor-Group Membership in Synchronous Distributed Systems. </title> <journal> Distributed Computing, </journal> <volume> 6 </volume> <pages> 175-187, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: In other papers, e.g., [1, 5], evolving algebras are used to specify distributed algorithms. For this paper, we wanted to look at a time-constrained algorithm that does something useful and poses some challenge to specify and verify. Our colleague Farnam Jahanian brought Cristian's article on group membership protocols <ref> [2] </ref> to our attention. In this paper, we specify and verify one of the protocols presented in that article. It is an interesting protocol to verify as we need to specify and prove both timing as well as functional properties. <p> In this paper, we specify and verify one of the protocols presented in that article. It is an interesting protocol to verify as we need to specify and prove both timing as well as functional properties. Group membership protocols <ref> [2, 6, 7] </ref> are used mainly to provide fault tolerance for distributed computing services. <p> It is also assumed that performance failures can be detected and turned into crashes. We make the same assumptions here. Moreover, there is a bound on the time taken to carry m over from p to any processor q. The time can be "measured on any processor clock" <ref> [2] </ref>. It seems a little more natural to measure the time of sending on Clock (p) and the time of delivery on Clock (q). <p> In this protocol, a group identifier is a timestamp that indicates when the group was formed. * Identifiers of the processors in p's current group the membership view of p. In <ref> [2] </ref> the state information includes a flag that indicates whether or not p is currently part of a group. We can do away with this as the desired property can be determined from whether or not the group id (or the membership view) is defined.
Reference: [3] <author> Y. Gurevich. </author> <title> Evolving Algebras: An Attempt to Discover Semantics. </title> <editor> In G. Rozenberg and A. Salomaa, editors, </editor> <booktitle> Current Trends in Theoretical Computer Science, </booktitle> <pages> pages 266-292. </pages> <address> World-Scientific, </address> <year> 1993. </year>
Reference-contexts: 1 Introduction According to the Evolving Algebra thesis <ref> [3] </ref>, evolving algebras should allow one to specify succinctly any algorithm. There exists substantial evidence confirming this thesis in the case of sequential algorithms (see the annotated bibliography in [3]). In other papers, e.g., [1, 5], evolving algebras are used to specify distributed algorithms. <p> 1 Introduction According to the Evolving Algebra thesis <ref> [3] </ref>, evolving algebras should allow one to specify succinctly any algorithm. There exists substantial evidence confirming this thesis in the case of sequential algorithms (see the annotated bibliography in [3]). In other papers, e.g., [1, 5], evolving algebras are used to specify distributed algorithms. For this paper, we wanted to look at a time-constrained algorithm that does something useful and poses some challenge to specify and verify.
Reference: [4] <author> Y. Gurevich. </author> <title> Evolving Algebras 1993: Lipari Guide. </title> <note> To appear in E. </note> <editor> Borger, editor, </editor> <title> Specification and Validation Methods for Programming Languages and Systems, </title> <publisher> Oxford University Press, </publisher> <year> 1994. </year>
Reference-contexts: time t then, by time t + d f , all the members of g that that stay correct in the interval [t; t + d f ] will join a group g 0 that does not contain p. 3 The Program The semantics of evolving algebras are described in <ref> [4] </ref>. In order to understand the material in this paper, the reader need only read about ground distributed evolving algebras. We use variables in this paper only to make the rules easier to read. <p> Sequential Runs: According to <ref> [4] </ref>, a sequential run is a sequence of states together with the agent-witness function. Since the sequence of states uniquely determines the agent-witness function in our case, we have simplified the definition. <p> Partially Ordered Runs: We restrict attention to sequential runs only to simplify the exposition. There are no significant changes in the correctness proof if one uses partially ordered runs as defined in <ref> [4] </ref>. 10 Stages: Usually stages of a run p = hS n : n 2 Ii are pairs (n; S n ). The first component ensures that the distinctness of stages and is not needed in the case of our monotone runs. Initial states: Condition R3 can be generalized.
Reference: [5] <author> J. Huggins. </author> <title> Kermit: Specification and Verification. </title> <note> To appear in E. </note> <editor> Borger, editor, </editor> <title> Specification and Validation Methods for Programming Languages and Systems, </title> <publisher> Oxford University Press, </publisher> <year> 1994. </year>
Reference-contexts: 1 Introduction According to the Evolving Algebra thesis [3], evolving algebras should allow one to specify succinctly any algorithm. There exists substantial evidence confirming this thesis in the case of sequential algorithms (see the annotated bibliography in [3]). In other papers, e.g., <ref> [1, 5] </ref>, evolving algebras are used to specify distributed algorithms. For this paper, we wanted to look at a time-constrained algorithm that does something useful and poses some challenge to specify and verify. Our colleague Farnam Jahanian brought Cristian's article on group membership protocols [2] to our attention.
Reference: [6] <author> F. Jahanian, R. Rajkumar and S. Fakhouri. </author> <title> Processor Group Membership Protocols: Specification, </title> <booktitle> Design and Implementation. In Symposium on Reliable Distributed Systems, </booktitle> <year> 1993. </year>
Reference-contexts: In this paper, we specify and verify one of the protocols presented in that article. It is an interesting protocol to verify as we need to specify and prove both timing as well as functional properties. Group membership protocols <ref> [2, 6, 7] </ref> are used mainly to provide fault tolerance for distributed computing services.
Reference: [7] <author> A. M. Ricciardi and K. P. Birman. </author> <title> Using Process Groups to Implement Failure Detection in Asynchronous Environments. </title> <booktitle> In 11th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 341-353, </pages> <year> 1991. </year>
Reference-contexts: In this paper, we specify and verify one of the protocols presented in that article. It is an interesting protocol to verify as we need to specify and prove both timing as well as functional properties. Group membership protocols <ref> [2, 6, 7] </ref> are used mainly to provide fault tolerance for distributed computing services.
Reference: [8] <author> W. R. Stevens. </author> <title> UNIX Network Programming. </title> <publisher> Prentice-Hall, </publisher> <year> 1990. </year> <month> 27 </month>
References-found: 8

