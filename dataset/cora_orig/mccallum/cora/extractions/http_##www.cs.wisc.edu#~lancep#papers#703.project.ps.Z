URL: http://www.cs.wisc.edu/~lancep/papers/703.project.ps.Z
Refering-URL: http://www.cs.wisc.edu/~lancep/lancep.html
Root-URL: 
Title: SYMBOLIC COMPOSITION: OPPORTUNITIES FOR PROGRAM SPECIALIZATION  
Author: Lance Paavola 
Affiliation: University of Wisconsin  
Date: May 1, 1995  
Pubnum: CS 703Class Project Lance Paavola Monday,  
Abstract: When one program is "composed" with another, we may be able to increase program efficiency (and reduce code size) through a new kind of program specialization. Sources of possible improvement include a variant of partial evaluation; program merging; and program splitting into producer and consumer sections. Some approaches and opportunities are considered, and two techniques are illustrated. 
Abstract-found: 1
Intro-found: 1
Reference: [Jones] <author> Jones, N.D., Gomard, C.K., and Sestoft, P., </author> <title> Partial Evaluation and Automatic Program Generation, </title> <booktitle> Prentice-Hall International, </booktitle> <address> Englewood Cliffs, NJ, </address> <note> 1993. </note> <author> [Reps] Reps, T., </author> <title> Shape analysis as a generalized path problem. </title> <booktitle> To appear in PEPM '95: Proceedings of the ACM SIGPLAN Symposium on Partial Evaluation and Semantics-Based Program Manipulation (La Jolla, </booktitle> <address> California, </address> <month> June 21-23, </month> <year> 1995). </year> <editor> [Wadler] Wadler, P., </editor> <title> Deforestation: Transforming programs to eliminate trees. </title> <booktitle> Theoretical Computer Science 73, </booktitle> <year> 1990, </year> <pages> pp. 231-248. </pages>
Reference-contexts: Examples Following are two examples meant to illustrate ways that function-composition specialization might be performed. The first takes a Type I approach and assumes an enumeration of inputs. The second is Type II specialization using a shape description. 7.1. Example 1 The program specializer mix given by <ref> [Jones] </ref> is designed to take as input program, division, and vs 0 , where program is the program to be specialized, division is a division of program's variables into static and dynamic, and vs 0 is a list of the (initial) values of the static variables, and produce a version of <p> That is, reduce' performs constant folding for variables that have a constant value. Now we're ready to rewrite the mix algorithm given in Figure 4.7 of <ref> [Jones] </ref>. The differences are so few that it's clearer to describe them than to write out the entire modified algorithm. <p> We'll give only lines 15-16 and 20-21; the only other difference is that all occurrences of vs are changed to vss, vs 0 to vss 0 , eval to eval', and reduce to reduce'. iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Line # <ref> [Jones] </ref> mix ss iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii 15 if X is classified as static by division if X is classified as set-static by division 16 then vs := then vss := vs [X | fi eval (exp, vs)]; vss [X | fi eval'(exp, vss)]; iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii 20 if exp then goto pp' else goto pp'':
References-found: 1

