URL: http://www.cs.wisc.edu/wpis/papers/jalg96.ps
Refering-URL: http://www.cs.wisc.edu/~reps/
Root-URL: 
Email: E-mail: rama@watson.ibm.com.  E-mail: reps@cs.wisc.edu  
Title: An Incremental Algorithm for a Generalization of the Shortest-Path Problem*  
Author: G. Ramalingam and Thomas Reps 
Note: This work was done when this author was at the  
Address: Wisconsin Madison  P.O. Box 704, Yorktown Heights, NY 10598.  1210 W. Dayton St., Madison, WI 53706.  
Affiliation: University of  IBM T.J. Watson Research Center,  University of Wisconsin. Computer Sciences Department, University of Wisconsin-Madison,  
Abstract: hhhhhhhhhhhhhhhhhhhhhhhhhhhhh *This work was supported in part by a David and Lucile Packard Fellowship for Science and Engineering, by the National Science Foundation under grants DCR-8552602 and CCR-9100424, by the Defense Advanced Research Projects Agency, monitored by the Office of Naval Research under contract N00014-88-K-0590, as well as by a grant from the Digital Equipment Corporation. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Alpern, B., Hoover, R., Rosen, B.K., Sweeney, P.F., and Zadeck, F.K., </author> <title> Incremental evaluation of computational circuits, pp. </title> <booktitle> 32-42 in Proceedings of the First Annual ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <address> (San Francisco, CA, </address> <month> Jan. </month> <pages> 22-24, </pages> <year> 1990), </year> <institution> Society for Industrial and Applied Mathematics, </institution> <address> Philadelphia, PA (1990). </address>
Reference-contexts: Let [i,k ] denote the set of integers - j | i j k -. We say a function g : D k fi D is a weakly superior function (abbreviated w.s.f .) if it is mono tone non-decreasing in each variable and if for every i <ref> [1, k ] </ref>, g (x 1 , . . . , x i , . . . , x k ) &lt; x i fi g (x 1 , . . . , x i , . . . , x k ) = g (x 1 , . . . <p> For our purposes, a more useful measure of the size of K is the extended size || K || G of K, which is defined to be the sum of the number of vertices in K and the number of edges which have at least one endpoint in K <ref> [1, 32, 33] </ref>. Thus, the two parameters we will find useful are | Changed G,d | , which we abbreviate to | d | G , and || Changed G,d || G+d , which we abbreviate to || d || G . <p> We now present an outline of the algorithm in Figure 2. The algorithm works by repeatedly select hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh procedure IncrementalFP (Q) declare Q : a set of SWSF equations rhs (u) = def g u (d [x 1 ], . . . , d [x k ]) begin <ref> [1] </ref> while there exist inconsistent variables in Q do [2] let u be an inconsistent vertex with minimum key value [3] if rhs [u ] &lt; d (u) then // u is over-consistent [4] d [u ] := rhs (u) [5] else if d [u ] &lt; rhs (u) then // <p> operations are performed. - 16 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh procedure DynamicSWSF-FP (G, U) declare G : a dependence graph of a set of SWSF equations U : the set of modified vertices in G u, v, w: vertices Heap: a heap of vertices preconditions Every vertex in V (G)-U is consistent begin <ref> [1] </ref> Heap := [2] for u U do [4] if rhs [u ] d [u ] then [5] InsertIntoHeap ( Heap, u, min (rhs [u ],d [u ])) [6] fi [8] while Heap do [9] u := ExtractAndDeleteMin ( Heap ) [10] if rhs [u ] &lt; d [u ] then <p> G : a SSF grammar; P : the set of modified productions in G GlobalHeap: a heap of non-terminals Heap: array [Nonterminals] of heap of productions; SP: array [Nonterminals] of set of productions preconditions: Every production in G-P is consistent. (See Definition 4.1) procedure recomputeProductionValue (p : a production) begin <ref> [1] </ref> let p be the production Y fi g (X 1 , . . . , X k ) [2] value = g (d [X 1 ], . . . , d [X k ]) [3] if (value &lt; d [Y]) then [4] AdjustHeap ( Heap [Y], p, value) [5] else <p> Let d (x,y) denote the length of a shortest path from x to y. Then, for any two vertices s and t, d (s,t) can change only if for some i <ref> [1, k ] </ref> both d (s,v i ) and d (u i ,t) change. Hence, by updating the single-source solution for every u i , we can identify the set of vertices t for which the single-sink solution will change.
Reference: 2. <editor> Ausiello, G., Italiano, G.F., Spaccamela, A.M., and Nanni, U., </editor> <title> Incremental algorithms for minimal length paths, pp. </title> <booktitle> 12-21 in Proceedings of the First Annual ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <address> (San Francisco, CA, </address> <month> Jan. </month> <pages> 22-24, </pages> <year> 1990), </year> <institution> Society for Industrial and Applied Mathematics, </institution> <address> Phi-ladelphia, PA (1990). </address>
Reference-contexts: The algorithm works by repeatedly select hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh procedure IncrementalFP (Q) declare Q : a set of SWSF equations rhs (u) = def g u (d [x 1 ], . . . , d [x k ]) begin [1] while there exist inconsistent variables in Q do <ref> [2] </ref> let u be an inconsistent vertex with minimum key value [3] if rhs [u ] &lt; d (u) then // u is over-consistent [4] d [u ] := rhs (u) [5] else if d [u ] &lt; rhs (u) then // u is under-consistent [6] d [u ] := [8] <p> These results follow once we establish the following two claims: Claim (1): If the vertex u chosen in line <ref> [2] </ref> is assigned a value in line [4] (in some particular iteration), then ver tex u becomes consistent and remains consistent subsequently. Claim (2): If the vertex u chosen in line [2] is assigned a value in line [6] (in some particular iteration), then u will never subsequently be assigned the <p> These results follow once we establish the following two claims: Claim (1): If the vertex u chosen in line <ref> [2] </ref> is assigned a value in line [4] (in some particular iteration), then ver tex u becomes consistent and remains consistent subsequently. Claim (2): If the vertex u chosen in line [2] is assigned a value in line [6] (in some particular iteration), then u will never subsequently be assigned the same value it had before the execution of line [6]. <p> It follows that the algorithm performs a bounded number of iterations. We will show later that line <ref> [2] </ref> can be implemented to run in bounded time, which suffices to establish that the algorithm is bounded. Before proving Claims (1) and (2), we need to first establish some properties of s.w.s.f . functions. <p> These claims follow from the fact that the keys of vertices chosen in line <ref> [2] </ref> over the iterations form a non-decreasing sequence. We first consider the change in the consistency status and the key value of vertices when a vertex u is processed (lines [3]-[7]) in some particular iteration. <p> In the following propositions u denotes the vertex chosen in line <ref> [2] </ref> of the particular iteration under consideration. - 14 - Proposition 3.2. If rhs new (w) rhs old (w) then rhs new (w) &gt; key old (u) and rhs old (w) &gt; key old (u). Proof. <p> Proposition 3.5. If i &lt; j then key i (u i ) key j (u j ). In other words, the keys of variables chosen in line <ref> [2] </ref> form a monotonically non-decreasing sequence. Proof. This follows trivially from repeated applications of Proposition 3.4. ` Proposition 3.6. Assume that the vertex u i chosen in line [2] of the i-th iteration is an over-consistent vertex. Then, u i remains consistent in all subsequent iterations. <p> In other words, the keys of variables chosen in line <ref> [2] </ref> form a monotonically non-decreasing sequence. Proof. This follows trivially from repeated applications of Proposition 3.4. ` Proposition 3.6. Assume that the vertex u i chosen in line [2] of the i-th iteration is an over-consistent vertex. Then, u i remains consistent in all subsequent iterations. In particular, its value is never again changed. Proof. We showed above in Proposition 3.3 that variable u i is consistent at the end of the i-th iteration. <p> But this contradicts Proposition 3.5. Since only the values of inconsistent variables are ever changed it follows that d [u i ] is never again changed. ` Proposition 3.7. Assume that the vertex u i chosen in line <ref> [2] </ref> of the i-th iteration is an under-consistent vertex. Then, u i is never assigned its original value, d i [u i ], again. Proof. We need to show that the rhs value of variable u i never becomes d i [u i ]. <p> In other words, vertices not in U are guaranteed to be consistent. This is the precondition for the algorithm to compute the correct solution to the modified set of equations. In order to implement line <ref> [2] </ref> of procedure IncrementalFP efficiently, we maintain a heap of all the inconsistent vertices in the graph. <p> - 16 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh procedure DynamicSWSF-FP (G, U) declare G : a dependence graph of a set of SWSF equations U : the set of modified vertices in G u, v, w: vertices Heap: a heap of vertices preconditions Every vertex in V (G)-U is consistent begin [1] Heap := <ref> [2] </ref> for u U do [4] if rhs [u ] d [u ] then [5] InsertIntoHeap ( Heap, u, min (rhs [u ],d [u ])) [6] fi [8] while Heap do [9] u := ExtractAndDeleteMin ( Heap ) [10] if rhs [u ] &lt; d [u ] then /* u is <p> Heap: array [Nonterminals] of heap of productions; SP: array [Nonterminals] of set of productions preconditions: Every production in G-P is consistent. (See Definition 4.1) procedure recomputeProductionValue (p : a production) begin [1] let p be the production Y fi g (X 1 , . . . , X k ) <ref> [2] </ref> value = g (d [X 1 ], . . . , d [X k ]) [3] if (value &lt; d [Y]) then [4] AdjustHeap ( Heap [Y], p, value) [5] else [6] if p Heap [Y] then Remove p from Heap [Y] fi [7] fi [8] if (value d [Y]) <p> The postcondition established by the algorithm is that every production and non-terminal in the grammar will be consistent. The procedure recomputeProductionValue (p) makes production p consistent by computing its value (in line <ref> [2] </ref>) and updating the data structures SP [Y ] (line [8]) and Heap [Y ] (lines [3]-[7]) appropriately, where Y is the left-hand side of p. <p> Let us now consider the time taken by a single execution of procedure recomputeProductionValue. The procedure essentially performs (a) one function computation (line <ref> [2] </ref>), (b) O (1) set operations (lines [8] and [9]), (c) O (1) Heap [Y ] operations (lines [4] or [6]), and (d) O (1) GlobalHeap operations (lines [10], [12] or [14]). <p> on algorithms for the dynamic shortest-path problem include papers by Murchland [27, 28], Loubal [26], Rodionov [34], Halder [21], Pape [29], Hsieh et al. [22], Cheston [9], Dionne [12], Goto et al. [20], Cheston and Corneil [10], Rohnert [35], Even and Gazit [15], Lin and Chang [25], Ausiello et al. <ref> [2, 4] </ref>, and Ramalingam and Reps [30]. The work described in this paper differs from these algorithms in several ways.
Reference: 3. <author> Ausiello, G., Nanni, U., </author> <title> and Italiano, G.F., Dynamic maintenance of directed hypergraphs, </title> <note> Theoretical Computer Science 72(3) pp. </note> <month> 97-117 (May </month> <year> 1990). </year>
Reference-contexts: In addition to the single-source shortest-path problem, Knuth lists a variety of other applications and special cases of the grammar problem, including the generation of optimal code for expression trees and the construction of optimal binary-search trees. The grammar problem also subsumes a number of hypergraph problems <ref> [3, 6, 7, 18, 23] </ref>, in particular, the problem of finding optimal hyperpaths in directed hypergraphs [5]. A directed hypergraph consists of a set of nodes and a set of hyperarcs, where each hyperarc connects a set of source nodes to a single target node. <p> procedure IncrementalFP (Q) declare Q : a set of SWSF equations rhs (u) = def g u (d [x 1 ], . . . , d [x k ]) begin [1] while there exist inconsistent variables in Q do [2] let u be an inconsistent vertex with minimum key value <ref> [3] </ref> if rhs [u ] &lt; d (u) then // u is over-consistent [4] d [u ] := rhs (u) [5] else if d [u ] &lt; rhs (u) then // u is under-consistent [6] d [u ] := [8] od hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh - 12 - ing an inconsistent variable whose key <p> executed at most once for each vertex u; line [6], too, can be executed at most once for each vertex u, since once d [u ] is set to , u cannot subsequently become an under-consistent vertexas long as d [u ] is , it satisfies the condition in line <ref> [3] </ref>; hence d [u ] can only be changed subsequently in line [4], in which case the vertex becomes consistent and remains so, from Claim (1). Hence, the algorithm performs at most two iterations for each vertex, and consequently the algorithm must halt. <p> production in G-P is consistent. (See Definition 4.1) procedure recomputeProductionValue (p : a production) begin [1] let p be the production Y fi g (X 1 , . . . , X k ) [2] value = g (d [X 1 ], . . . , d [X k ]) <ref> [3] </ref> if (value &lt; d [Y]) then [4] AdjustHeap ( Heap [Y], p, value) [5] else [6] if p Heap [Y] then Remove p from Heap [Y] fi [7] fi [8] if (value d [Y]) then SP [Y] := SP [Y] -pelse SP [Y] := SP [Y]-p- fi [9] if (SP
Reference: 4. <editor> Ausiello, G., Italiano, G.F., Spaccamela, A.M., and Nanni, U., </editor> <title> Incremental algorithms for minimal length paths, </title> <journal> Journal of Algorithms, </journal> <pages> (12) pp. </pages> <month> 615-638 </month> <year> (1991). </year>
Reference-contexts: = def g u (d [x 1 ], . . . , d [x k ]) begin [1] while there exist inconsistent variables in Q do [2] let u be an inconsistent vertex with minimum key value [3] if rhs [u ] &lt; d (u) then // u is over-consistent <ref> [4] </ref> d [u ] := rhs (u) [5] else if d [u ] &lt; rhs (u) then // u is under-consistent [6] d [u ] := [8] od hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh - 12 - ing an inconsistent variable whose key is less than or equal to the key of every other inconsistent variable <p> These results follow once we establish the following two claims: Claim (1): If the vertex u chosen in line [2] is assigned a value in line <ref> [4] </ref> (in some particular iteration), then ver tex u becomes consistent and remains consistent subsequently. <p> The correctness of the algorithm will follow from Claim (1): it follows from the claim that line <ref> [4] </ref> can be executed at most once for each vertex u; line [6], too, can be executed at most once for each vertex u, since once d [u ] is set to , u cannot subsequently become an under-consistent vertexas long as d [u ] is , it satisfies the condition <p> be executed at most once for each vertex u, since once d [u ] is set to , u cannot subsequently become an under-consistent vertexas long as d [u ] is , it satisfies the condition in line [3]; hence d [u ] can only be changed subsequently in line <ref> [4] </ref>, in which case the vertex becomes consistent and remains so, from Claim (1). Hence, the algorithm performs at most two iterations for each vertex, and consequently the algorithm must halt. The correctness follows immediately from the termination condition for the loop. <p> DynamicSWSF-FP (G, U) declare G : a dependence graph of a set of SWSF equations U : the set of modified vertices in G u, v, w: vertices Heap: a heap of vertices preconditions Every vertex in V (G)-U is consistent begin [1] Heap := [2] for u U do <ref> [4] </ref> if rhs [u ] d [u ] then [5] InsertIntoHeap ( Heap, u, min (rhs [u ],d [u ])) [6] fi [8] while Heap do [9] u := ExtractAndDeleteMin ( Heap ) [10] if rhs [u ] &lt; d [u ] then /* u is over-consistent */ [11] d [u <p> 4.1) procedure recomputeProductionValue (p : a production) begin [1] let p be the production Y fi g (X 1 , . . . , X k ) [2] value = g (d [X 1 ], . . . , d [X k ]) [3] if (value &lt; d [Y]) then <ref> [4] </ref> AdjustHeap ( Heap [Y], p, value) [5] else [6] if p Heap [Y] then Remove p from Heap [Y] fi [7] fi [8] if (value d [Y]) then SP [Y] := SP [Y] -pelse SP [Y] := SP [Y]-p- fi [9] if (SP [Y] = ) then /* Y is <p> Let us now consider the time taken by a single execution of procedure recomputeProductionValue. The procedure essentially performs (a) one function computation (line [2]), (b) O (1) set operations (lines [8] and [9]), (c) O (1) Heap [Y ] operations (lines <ref> [4] </ref> or [6]), and (d) O (1) GlobalHeap operations (lines [10], [12] or [14]). <p> In other words, no edges are deleted and no edge-length is increased. In this case it can be seen that no under-consistent vertex exists, and that the value of no vertex increases during the update. In particular, the AdjustHeap operations (in lines <ref> [4] </ref>, [10], and [12]) either perform an insertion or decrease the key of an item. Lines [6] and [14] are never executed. <p> on algorithms for the dynamic shortest-path problem include papers by Murchland [27, 28], Loubal [26], Rodionov [34], Halder [21], Pape [29], Hsieh et al. [22], Cheston [9], Dionne [12], Goto et al. [20], Cheston and Corneil [10], Rohnert [35], Even and Gazit [15], Lin and Chang [25], Ausiello et al. <ref> [2, 4] </ref>, and Ramalingam and Reps [30]. The work described in this paper differs from these algorithms in several ways.
Reference: 5. <editor> Ausiello, G., Italiano, G.F., and Nanni, U., </editor> <title> Optimal traversal of directed hypergraphs, </title> <month> TR-92-073 (September </month> <year> 1992). </year>
Reference-contexts: The grammar problem also subsumes a number of hypergraph problems [3, 6, 7, 18, 23], in particular, the problem of finding optimal hyperpaths in directed hypergraphs <ref> [5] </ref>. A directed hypergraph consists of a set of nodes and a set of hyperarcs, where each hyperarc connects a set of source nodes to a single target node. A hypergraph corresponds to a context-free grammar, nodes correspond to non-terminals, and hyperarcs correspond to productions. <p> A hypergraph corresponds to a context-free grammar, nodes correspond to non-terminals, and hyperarcs correspond to productions. A hyperpath in a hypergraph corresponds to a derivation in the grammar. The concept of a value-based measure for a hyperpath that Ausiello et al. introduce in <ref> [5] </ref> is similar to the cost assigned to a derivation in Knuth's grammar problem, and an optimal hyperpath corresponds to a minimum-cost derivation. <p> ], . . . , d [x k ]) begin [1] while there exist inconsistent variables in Q do [2] let u be an inconsistent vertex with minimum key value [3] if rhs [u ] &lt; d (u) then // u is over-consistent [4] d [u ] := rhs (u) <ref> [5] </ref> else if d [u ] &lt; rhs (u) then // u is under-consistent [6] d [u ] := [8] od hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh - 12 - ing an inconsistent variable whose key is less than or equal to the key of every other inconsistent variable and processing it. <p> of a set of SWSF equations U : the set of modified vertices in G u, v, w: vertices Heap: a heap of vertices preconditions Every vertex in V (G)-U is consistent begin [1] Heap := [2] for u U do [4] if rhs [u ] d [u ] then <ref> [5] </ref> InsertIntoHeap ( Heap, u, min (rhs [u ],d [u ])) [6] fi [8] while Heap do [9] u := ExtractAndDeleteMin ( Heap ) [10] if rhs [u ] &lt; d [u ] then /* u is over-consistent */ [11] d [u ] := rhs [u ] [12] for v Succ <p> begin [1] let p be the production Y fi g (X 1 , . . . , X k ) [2] value = g (d [X 1 ], . . . , d [X k ]) [3] if (value &lt; d [Y]) then [4] AdjustHeap ( Heap [Y], p, value) <ref> [5] </ref> else [6] if p Heap [Y] then Remove p from Heap [Y] fi [7] fi [8] if (value d [Y]) then SP [Y] := SP [Y] -pelse SP [Y] := SP [Y]-p- fi [9] if (SP [Y] = ) then /* Y is under-consistent */ [10] AdjustHeap ( GlobalHeap, Y, <p> Knuth [24] introduced the grammar problem as a generalization of the shortest-path problem, and generalized Dijkstra's algorithm to solve the batch SF grammar problem. We know of no previous work on incremental algorithms for the dynamic grammar problem. - 26 - Recently, Ausiello et al <ref> [5] </ref>. presented a semi-dynamic algorithm for maintaining optimal hyper-paths in directed hypergraphs. This algorithm is quite similar to our algorithm, except that it handles only the insertion of hyperarcs (productions) into the hypergraph (grammar). The relationship between the hypergraph problem and grammar problem is discussed below. <p> A non-empty hyperpath from a set S of nodes to a node t consists of an hyperarc from a set S to t and a hyperpath from S to s for every node s in S. Ausiello et al. <ref> [5] </ref> introduced the concept of a value-based measure for hyperpaths. Assume that every hyperarc e has an associated weight wt (e ).
Reference: 6. <author> Berge, C., </author> <title> Graphs and Hypergraphs, </title> <publisher> North-Holland, </publisher> <address> Amsterdam (1973). </address>
Reference-contexts: In addition to the single-source shortest-path problem, Knuth lists a variety of other applications and special cases of the grammar problem, including the generation of optimal code for expression trees and the construction of optimal binary-search trees. The grammar problem also subsumes a number of hypergraph problems <ref> [3, 6, 7, 18, 23] </ref>, in particular, the problem of finding optimal hyperpaths in directed hypergraphs [5]. A directed hypergraph consists of a set of nodes and a set of hyperarcs, where each hyperarc connects a set of source nodes to a single target node. <p> inconsistent variables in Q do [2] let u be an inconsistent vertex with minimum key value [3] if rhs [u ] &lt; d (u) then // u is over-consistent [4] d [u ] := rhs (u) [5] else if d [u ] &lt; rhs (u) then // u is under-consistent <ref> [6] </ref> d [u ] := [8] od hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh - 12 - ing an inconsistent variable whose key is less than or equal to the key of every other inconsistent variable and processing it. <p> Claim (2): If the vertex u chosen in line [2] is assigned a value in line <ref> [6] </ref> (in some particular iteration), then u will never subsequently be assigned the same value it had before the execution of line [6]. <p> Claim (2): If the vertex u chosen in line [2] is assigned a value in line <ref> [6] </ref> (in some particular iteration), then u will never subsequently be assigned the same value it had before the execution of line [6]. The correctness of the algorithm will follow from Claim (1): it follows from the claim that line [4] can be executed at most once for each vertex u; line [6], too, can be executed at most once for each vertex u, since once d [u ] is set to , <p> some particular iteration), then u will never subsequently be assigned the same value it had before the execution of line <ref> [6] </ref>. The correctness of the algorithm will follow from Claim (1): it follows from the claim that line [4] can be executed at most once for each vertex u; line [6], too, can be executed at most once for each vertex u, since once d [u ] is set to , u cannot subsequently become an under-consistent vertexas long as d [u ] is , it satisfies the condition in line [3]; hence d [u ] can only be changed subsequently <p> modified vertices in G u, v, w: vertices Heap: a heap of vertices preconditions Every vertex in V (G)-U is consistent begin [1] Heap := [2] for u U do [4] if rhs [u ] d [u ] then [5] InsertIntoHeap ( Heap, u, min (rhs [u ],d [u ])) <ref> [6] </ref> fi [8] while Heap do [9] u := ExtractAndDeleteMin ( Heap ) [10] if rhs [u ] &lt; d [u ] then /* u is over-consistent */ [11] d [u ] := rhs [u ] [12] for v Succ (u) do [13] rhs [v ] := g v (d [x <p> let p be the production Y fi g (X 1 , . . . , X k ) [2] value = g (d [X 1 ], . . . , d [X k ]) [3] if (value &lt; d [Y]) then [4] AdjustHeap ( Heap [Y], p, value) [5] else <ref> [6] </ref> if p Heap [Y] then Remove p from Heap [Y] fi [7] fi [8] if (value d [Y]) then SP [Y] := SP [Y] -pelse SP [Y] := SP [Y]-p- fi [9] if (SP [Y] = ) then /* Y is under-consistent */ [10] AdjustHeap ( GlobalHeap, Y, d [Y]) <p> Let us now consider the time taken by a single execution of procedure recomputeProductionValue. The procedure essentially performs (a) one function computation (line [2]), (b) O (1) set operations (lines [8] and [9]), (c) O (1) Heap [Y ] operations (lines [4] or <ref> [6] </ref>), and (d) O (1) GlobalHeap operations (lines [10], [12] or [14]). <p> In this case it can be seen that no under-consistent vertex exists, and that the value of no vertex increases during the update. In particular, the AdjustHeap operations (in lines [4], [10], and [12]) either perform an insertion or decrease the key of an item. Lines <ref> [6] </ref> and [14] are never executed.
Reference: 7. <author> Berge, C., </author> <title> Hypergraphs: Combinatorics of Finite Sets, </title> <publisher> North-Holland, </publisher> <address> Amsterdam (1989). </address>
Reference-contexts: In addition to the single-source shortest-path problem, Knuth lists a variety of other applications and special cases of the grammar problem, including the generation of optimal code for expression trees and the construction of optimal binary-search trees. The grammar problem also subsumes a number of hypergraph problems <ref> [3, 6, 7, 18, 23] </ref>, in particular, the problem of finding optimal hyperpaths in directed hypergraphs [5]. A directed hypergraph consists of a set of nodes and a set of hyperarcs, where each hyperarc connects a set of source nodes to a single target node. <p> . . , X k ) [2] value = g (d [X 1 ], . . . , d [X k ]) [3] if (value &lt; d [Y]) then [4] AdjustHeap ( Heap [Y], p, value) [5] else [6] if p Heap [Y] then Remove p from Heap [Y] fi <ref> [7] </ref> fi [8] if (value d [Y]) then SP [Y] := SP [Y] -pelse SP [Y] := SP [Y]-p- fi [9] if (SP [Y] = ) then /* Y is under-consistent */ [10] AdjustHeap ( GlobalHeap, Y, d [Y]) [11] elseif Heap [Y] then /* Y is over-consistent */ [12] AdjustHeap
Reference: 8. <author> Carroll, </author> <title> M.D., Data flow update via dominator and attribute updates, </title> <type> Ph.D. dissertation, </type> <institution> Rutgers University, </institution> <address> New Brunswick, NJ (May 1988). </address>
Reference-contexts: [2] let u be an inconsistent vertex with minimum key value [3] if rhs [u ] &lt; d (u) then // u is over-consistent [4] d [u ] := rhs (u) [5] else if d [u ] &lt; rhs (u) then // u is under-consistent [6] d [u ] := <ref> [8] </ref> od hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh - 12 - ing an inconsistent variable whose key is less than or equal to the key of every other inconsistent variable and processing it. <p> in G u, v, w: vertices Heap: a heap of vertices preconditions Every vertex in V (G)-U is consistent begin [1] Heap := [2] for u U do [4] if rhs [u ] d [u ] then [5] InsertIntoHeap ( Heap, u, min (rhs [u ],d [u ])) [6] fi <ref> [8] </ref> while Heap do [9] u := ExtractAndDeleteMin ( Heap ) [10] if rhs [u ] &lt; d [u ] then /* u is over-consistent */ [11] d [u ] := rhs [u ] [12] for v Succ (u) do [13] rhs [v ] := g v (d [x 1 ], <p> , X k ) [2] value = g (d [X 1 ], . . . , d [X k ]) [3] if (value &lt; d [Y]) then [4] AdjustHeap ( Heap [Y], p, value) [5] else [6] if p Heap [Y] then Remove p from Heap [Y] fi [7] fi <ref> [8] </ref> if (value d [Y]) then SP [Y] := SP [Y] -pelse SP [Y] := SP [Y]-p- fi [9] if (SP [Y] = ) then /* Y is under-consistent */ [10] AdjustHeap ( GlobalHeap, Y, d [Y]) [11] elseif Heap [Y] then /* Y is over-consistent */ [12] AdjustHeap ( GlobalHeap, <p> The postcondition established by the algorithm is that every production and non-terminal in the grammar will be consistent. The procedure recomputeProductionValue (p) makes production p consistent by computing its value (in line [2]) and updating the data structures SP [Y ] (line <ref> [8] </ref>) and Heap [Y ] (lines [3]-[7]) appropriately, where Y is the left-hand side of p. <p> Let us now consider the time taken by a single execution of procedure recomputeProductionValue. The procedure essentially performs (a) one function computation (line [2]), (b) O (1) set operations (lines <ref> [8] </ref> and [9]), (c) O (1) Heap [Y ] operations (lines [4] or [6]), and (d) O (1) GlobalHeap operations (lines [10], [12] or [14]).
Reference: 9. <author> Cheston, </author> <title> G.A., Incremental algorithms in graph theory, </title> <type> Ph.D. dissertation and Tech. Rep. 91, </type> <institution> Dept. of Computer Science, University of Toronto, Toronto, </institution> <address> Canada (March 1976). </address>
Reference-contexts: w: vertices Heap: a heap of vertices preconditions Every vertex in V (G)-U is consistent begin [1] Heap := [2] for u U do [4] if rhs [u ] d [u ] then [5] InsertIntoHeap ( Heap, u, min (rhs [u ],d [u ])) [6] fi [8] while Heap do <ref> [9] </ref> u := ExtractAndDeleteMin ( Heap ) [10] if rhs [u ] &lt; d [u ] then /* u is over-consistent */ [11] d [u ] := rhs [u ] [12] for v Succ (u) do [13] rhs [v ] := g v (d [x 1 ], . . . , <p> k ]) [3] if (value &lt; d [Y]) then [4] AdjustHeap ( Heap [Y], p, value) [5] else [6] if p Heap [Y] then Remove p from Heap [Y] fi [7] fi [8] if (value d [Y]) then SP [Y] := SP [Y] -pelse SP [Y] := SP [Y]-p- fi <ref> [9] </ref> if (SP [Y] = ) then /* Y is under-consistent */ [10] AdjustHeap ( GlobalHeap, Y, d [Y]) [11] elseif Heap [Y] then /* Y is over-consistent */ [12] AdjustHeap ( GlobalHeap, Y, min key (Heap [Y])) [13] else /* Y is consistent */ [14] if Y GlobalHeap then Remove <p> Let us now consider the time taken by a single execution of procedure recomputeProductionValue. The procedure essentially performs (a) one function computation (line [2]), (b) O (1) set operations (lines [8] and <ref> [9] </ref>), (c) O (1) Heap [Y ] operations (lines [4] or [6]), and (d) O (1) GlobalHeap operations (lines [10], [12] or [14]). <p> Such hyperpaths can be represented in the grammar by derivations by simply adding epsilon productions for all the relevant non-terminals. Previous work on algorithms for the dynamic shortest-path problem include papers by Murchland [27, 28], Loubal [26], Rodionov [34], Halder [21], Pape [29], Hsieh et al. [22], Cheston <ref> [9] </ref>, Dionne [12], Goto et al. [20], Cheston and Corneil [10], Rohnert [35], Even and Gazit [15], Lin and Chang [25], Ausiello et al. [2, 4], and Ramalingam and Reps [30]. The work described in this paper differs from these algorithms in several ways.
Reference: 10. <author> Cheston, G.A. and Corneil, D.G., </author> <title> Graph property update algorithms and their application to distance matrices, </title> <note> INFOR 20(3) pp. </note> <month> 178-201 (August </month> <year> 1982). </year>
Reference-contexts: preconditions Every vertex in V (G)-U is consistent begin [1] Heap := [2] for u U do [4] if rhs [u ] d [u ] then [5] InsertIntoHeap ( Heap, u, min (rhs [u ],d [u ])) [6] fi [8] while Heap do [9] u := ExtractAndDeleteMin ( Heap ) <ref> [10] </ref> if rhs [u ] &lt; d [u ] then /* u is over-consistent */ [11] d [u ] := rhs [u ] [12] for v Succ (u) do [13] rhs [v ] := g v (d [x 1 ], . . . , d [x k ]) [14] if rhs <p> Heap [Y], p, value) [5] else [6] if p Heap [Y] then Remove p from Heap [Y] fi [7] fi [8] if (value d [Y]) then SP [Y] := SP [Y] -pelse SP [Y] := SP [Y]-p- fi [9] if (SP [Y] = ) then /* Y is under-consistent */ <ref> [10] </ref> AdjustHeap ( GlobalHeap, Y, d [Y]) [11] elseif Heap [Y] then /* Y is over-consistent */ [12] AdjustHeap ( GlobalHeap, Y, min key (Heap [Y])) [13] else /* Y is consistent */ [14] if Y GlobalHeap then Remove Y from GlobalHeap fi [15] fi begin [16] GlobalHeap := [17] for <p> The procedure essentially performs (a) one function computation (line [2]), (b) O (1) set operations (lines [8] and [9]), (c) O (1) Heap [Y ] operations (lines [4] or [6]), and (d) O (1) GlobalHeap operations (lines <ref> [10] </ref>, [12] or [14]). The set operations on SP [Y ] can be done in constant time by associating every production Y fi g (X 1 , . . . , X k ) with a bit that indicates if it is in the set SP [Y ] or not. <p> In other words, no edges are deleted and no edge-length is increased. In this case it can be seen that no under-consistent vertex exists, and that the value of no vertex increases during the update. In particular, the AdjustHeap operations (in lines [4], <ref> [10] </ref>, and [12]) either perform an insertion or decrease the key of an item. Lines [6] and [14] are never executed. <p> Previous work on algorithms for the dynamic shortest-path problem include papers by Murchland [27, 28], Loubal [26], Rodionov [34], Halder [21], Pape [29], Hsieh et al. [22], Cheston [9], Dionne [12], Goto et al. [20], Cheston and Corneil <ref> [10] </ref>, Rohnert [35], Even and Gazit [15], Lin and Chang [25], Ausiello et al. [2, 4], and Ramalingam and Reps [30]. The work described in this paper differs from these algorithms in several ways.
Reference: 11. <author> Dijkstra, </author> <title> E.W., A note on two problems in connexion with graphs, </title> <journal> Numerische Mathematik 1 pp. </journal> <month> 269-271 </month> <year> (1959). </year>
Reference-contexts: The goal of the grammar problem is to compute the minimum-cost derivation of a terminal string from each non-terminal of the given grammar. Knuth showed that it is possible to adapt Dijkstra's shortest-path algorithm <ref> [11] </ref> to solve the grammar problem if the functions defining the costs of derivations satisfy a simple property (see Section 2). <p> In addition, the algorithm also has to identify the change in consistency status of vertices and changes in the keys of inconsistent vertices as a result of the assignment of a new value to d [u ] in line <ref> [11] </ref> or line [21]. This is done in lines [12]-[19] and lines [22]-[29]. Let us now determine the time complexity of the algorithm. Let M d be a bound on the time required to compute the function associated with any vertex in Changed Succ (Changed). <p> U do [4] if rhs [u ] d [u ] then [5] InsertIntoHeap ( Heap, u, min (rhs [u ],d [u ])) [6] fi [8] while Heap do [9] u := ExtractAndDeleteMin ( Heap ) [10] if rhs [u ] &lt; d [u ] then /* u is over-consistent */ <ref> [11] </ref> d [u ] := rhs [u ] [12] for v Succ (u) do [13] rhs [v ] := g v (d [x 1 ], . . . , d [x k ]) [14] if rhs [v ] d [v ] then [15] AdjustHeap (Heap, v, min (rhs [v ],d [v <p> if p Heap [Y] then Remove p from Heap [Y] fi [7] fi [8] if (value d [Y]) then SP [Y] := SP [Y] -pelse SP [Y] := SP [Y]-p- fi [9] if (SP [Y] = ) then /* Y is under-consistent */ [10] AdjustHeap ( GlobalHeap, Y, d [Y]) <ref> [11] </ref> elseif Heap [Y] then /* Y is over-consistent */ [12] AdjustHeap ( GlobalHeap, Y, min key (Heap [Y])) [13] else /* Y is consistent */ [14] if Y GlobalHeap then Remove Y from GlobalHeap fi [15] fi begin [16] GlobalHeap := [17] for every production p P do [18] recomputeProductionValue
Reference: 12. <author> Dionne, R., </author> <title> Etude et extension d'un algorithme de Murchland, </title> <note> INFOR 16(2) pp. </note> <month> 132-146 (June </month> <year> 1978). </year>
Reference-contexts: [u ] then [5] InsertIntoHeap ( Heap, u, min (rhs [u ],d [u ])) [6] fi [8] while Heap do [9] u := ExtractAndDeleteMin ( Heap ) [10] if rhs [u ] &lt; d [u ] then /* u is over-consistent */ [11] d [u ] := rhs [u ] <ref> [12] </ref> for v Succ (u) do [13] rhs [v ] := g v (d [x 1 ], . . . , d [x k ]) [14] if rhs [v ] d [v ] then [15] AdjustHeap (Heap, v, min (rhs [v ],d [v ])) [16] else [17] if v Heap then <p> fi [7] fi [8] if (value d [Y]) then SP [Y] := SP [Y] -pelse SP [Y] := SP [Y]-p- fi [9] if (SP [Y] = ) then /* Y is under-consistent */ [10] AdjustHeap ( GlobalHeap, Y, d [Y]) [11] elseif Heap [Y] then /* Y is over-consistent */ <ref> [12] </ref> AdjustHeap ( GlobalHeap, Y, min key (Heap [Y])) [13] else /* Y is consistent */ [14] if Y GlobalHeap then Remove Y from GlobalHeap fi [15] fi begin [16] GlobalHeap := [17] for every production p P do [18] recomputeProductionValue (p) [19] od [20] while GlobalHeap do [21] Select and <p> The procedure essentially performs (a) one function computation (line [2]), (b) O (1) set operations (lines [8] and [9]), (c) O (1) Heap [Y ] operations (lines [4] or [6]), and (d) O (1) GlobalHeap operations (lines [10], <ref> [12] </ref> or [14]). The set operations on SP [Y ] can be done in constant time by associating every production Y fi g (X 1 , . . . , X k ) with a bit that indicates if it is in the set SP [Y ] or not. <p> In other words, no edges are deleted and no edge-length is increased. In this case it can be seen that no under-consistent vertex exists, and that the value of no vertex increases during the update. In particular, the AdjustHeap operations (in lines [4], [10], and <ref> [12] </ref>) either perform an insertion or decrease the key of an item. Lines [6] and [14] are never executed. <p> Previous work on algorithms for the dynamic shortest-path problem include papers by Murchland [27, 28], Loubal [26], Rodionov [34], Halder [21], Pape [29], Hsieh et al. [22], Cheston [9], Dionne <ref> [12] </ref>, Goto et al. [20], Cheston and Corneil [10], Rohnert [35], Even and Gazit [15], Lin and Chang [25], Ausiello et al. [2, 4], and Ramalingam and Reps [30]. The work described in this paper differs from these algorithms in several ways.
Reference: 13. <author> Driscoll, J.R., Gabow, H.N., Shrairman, R., and Tarjan, R.E., </author> <title> Relaxed heaps: An alternative to Fibonacci heaps with applications to parallel computation, </title> <journal> Communications of the ACM 31(11) pp. </journal> <month> 1343-1354 </month> <year> (1988). </year>
Reference-contexts: Heap, u, min (rhs [u ],d [u ])) [6] fi [8] while Heap do [9] u := ExtractAndDeleteMin ( Heap ) [10] if rhs [u ] &lt; d [u ] then /* u is over-consistent */ [11] d [u ] := rhs [u ] [12] for v Succ (u) do <ref> [13] </ref> rhs [v ] := g v (d [x 1 ], . . . , d [x k ]) [14] if rhs [v ] d [v ] then [15] AdjustHeap (Heap, v, min (rhs [v ],d [v ])) [16] else [17] if v Heap then Remove v from Heap fi [18] <p> An Improved Algorithm for the Dynamic SSF Grammar Problem The algorithm presented in the previous section can be improved further in the case of the dynamic grammar problem. The sources of optimization are lines <ref> [13] </ref> and [23] in Figure 3. In the general SWSF fixed point problem, the function on the right-hand side of an equation can be an arbitrary s.w.s.f ., and, consequently, the right-hand side has to computed from scratch (in lines [13] and [23]) when one of the arguments changes in value. <p> The sources of optimization are lines <ref> [13] </ref> and [23] in Figure 3. In the general SWSF fixed point problem, the function on the right-hand side of an equation can be an arbitrary s.w.s.f ., and, consequently, the right-hand side has to computed from scratch (in lines [13] and [23]) when one of the arguments changes in value. The functions that arise in the grammar problem, however, have a special form. <p> SP [Y] := SP [Y] -pelse SP [Y] := SP [Y]-p- fi [9] if (SP [Y] = ) then /* Y is under-consistent */ [10] AdjustHeap ( GlobalHeap, Y, d [Y]) [11] elseif Heap [Y] then /* Y is over-consistent */ [12] AdjustHeap ( GlobalHeap, Y, min key (Heap [Y])) <ref> [13] </ref> else /* Y is consistent */ [14] if Y GlobalHeap then Remove Y from GlobalHeap fi [15] fi begin [16] GlobalHeap := [17] for every production p P do [18] recomputeProductionValue (p) [19] od [20] while GlobalHeap do [21] Select and remove from GlobalHeap a non-terminal X with minimum key <p> In particular, the AdjustHeap operations (in lines [4], [10], and [12]) either perform an insertion or decrease the key of an item. Lines [6] and [14] are never executed. Consequently, procedure recomputeProductionValue takes time O (1) if relaxed heaps <ref> [13] </ref> or Fibonacci heaps [16] are used. (In the latter case, the time complexity is the amortized complexity.) It can also be verified that the number of elements in any of the heaps is O ( | d | ).
Reference: 14. <author> Edmonds, J. and Karp, </author> <title> R.M., Theoretical improvements in algorithmic efficiency for network flow problems, </title> <journal> J. ACM 19 pp. </journal> <month> 248-264 </month> <year> (1972). </year>
Reference-contexts: Heap ) [10] if rhs [u ] &lt; d [u ] then /* u is over-consistent */ [11] d [u ] := rhs [u ] [12] for v Succ (u) do [13] rhs [v ] := g v (d [x 1 ], . . . , d [x k ]) <ref> [14] </ref> if rhs [v ] d [v ] then [15] AdjustHeap (Heap, v, min (rhs [v ],d [v ])) [16] else [17] if v Heap then Remove v from Heap fi [18] fi [20] else /* u is under-consistent */ [21] d [u ] := [22] for v (Succ (u) -u-) <p> [Y] := SP [Y]-p- fi [9] if (SP [Y] = ) then /* Y is under-consistent */ [10] AdjustHeap ( GlobalHeap, Y, d [Y]) [11] elseif Heap [Y] then /* Y is over-consistent */ [12] AdjustHeap ( GlobalHeap, Y, min key (Heap [Y])) [13] else /* Y is consistent */ <ref> [14] </ref> if Y GlobalHeap then Remove Y from GlobalHeap fi [15] fi begin [16] GlobalHeap := [17] for every production p P do [18] recomputeProductionValue (p) [19] od [20] while GlobalHeap do [21] Select and remove from GlobalHeap a non-terminal X with minimum key value [22] if key (X) &lt; d <p> The procedure essentially performs (a) one function computation (line [2]), (b) O (1) set operations (lines [8] and [9]), (c) O (1) Heap [Y ] operations (lines [4] or [6]), and (d) O (1) GlobalHeap operations (lines [10], [12] or <ref> [14] </ref>). The set operations on SP [Y ] can be done in constant time by associating every production Y fi g (X 1 , . . . , X k ) with a bit that indicates if it is in the set SP [Y ] or not. <p> In this case it can be seen that no under-consistent vertex exists, and that the value of no vertex increases during the update. In particular, the AdjustHeap operations (in lines [4], [10], and [12]) either perform an insertion or decrease the key of an item. Lines [6] and <ref> [14] </ref> are never executed. <p> The idea is to adapt the technique of Edmonds and Karp for transforming the length of every edge to a non-negative real without changing the graph's shortest paths <ref> [14, 37] </ref>.
Reference: 15. <author> Even, S. and Gazit, H., </author> <title> Updating distances in dynamic graphs, </title> <note> pp. 271-388 in IX Symposium on Operations Research, </note> <author> (Osnabrueck, W. Ger., </author> <month> Aug. </month> <pages> 27-29, </pages> <year> 1984), </year> <journal> Methods of Operations Research, </journal> <volume> Vol. 49, </volume> <editor> ed. P. Brucker and R. </editor> <booktitle> Pauly,Verlag Anton Hain (1985). </booktitle> - <pages> 31 </pages> - 
Reference-contexts: [u ] then /* u is over-consistent */ [11] d [u ] := rhs [u ] [12] for v Succ (u) do [13] rhs [v ] := g v (d [x 1 ], . . . , d [x k ]) [14] if rhs [v ] d [v ] then <ref> [15] </ref> AdjustHeap (Heap, v, min (rhs [v ],d [v ])) [16] else [17] if v Heap then Remove v from Heap fi [18] fi [20] else /* u is under-consistent */ [21] d [u ] := [22] for v (Succ (u) -u-) do [23] rhs [v ] := g v (d <p> ) then /* Y is under-consistent */ [10] AdjustHeap ( GlobalHeap, Y, d [Y]) [11] elseif Heap [Y] then /* Y is over-consistent */ [12] AdjustHeap ( GlobalHeap, Y, min key (Heap [Y])) [13] else /* Y is consistent */ [14] if Y GlobalHeap then Remove Y from GlobalHeap fi <ref> [15] </ref> fi begin [16] GlobalHeap := [17] for every production p P do [18] recomputeProductionValue (p) [19] od [20] while GlobalHeap do [21] Select and remove from GlobalHeap a non-terminal X with minimum key value [22] if key (X) &lt; d [X ] then /* X is over-consistent */ [23] d <p> Previous work on algorithms for the dynamic shortest-path problem include papers by Murchland [27, 28], Loubal [26], Rodionov [34], Halder [21], Pape [29], Hsieh et al. [22], Cheston [9], Dionne [12], Goto et al. [20], Cheston and Corneil [10], Rohnert [35], Even and Gazit <ref> [15] </ref>, Lin and Chang [25], Ausiello et al. [2, 4], and Ramalingam and Reps [30]. The work described in this paper differs from these algorithms in several ways.
Reference: 16. <author> Fredman, </author> <title> M.L. and Tarjan, R.E., Fibonacci heaps and their uses in improved network optimization algorithms, </title> <journal> J. ACM 34(3) pp. </journal> <month> 596-615 </month> <year> (1987). </year>
Reference-contexts: [u ] := rhs [u ] [12] for v Succ (u) do [13] rhs [v ] := g v (d [x 1 ], . . . , d [x k ]) [14] if rhs [v ] d [v ] then [15] AdjustHeap (Heap, v, min (rhs [v ],d [v ])) <ref> [16] </ref> else [17] if v Heap then Remove v from Heap fi [18] fi [20] else /* u is under-consistent */ [21] d [u ] := [22] for v (Succ (u) -u-) do [23] rhs [v ] := g v (d [x 1 ], . . . , d [x k <p> Y is under-consistent */ [10] AdjustHeap ( GlobalHeap, Y, d [Y]) [11] elseif Heap [Y] then /* Y is over-consistent */ [12] AdjustHeap ( GlobalHeap, Y, min key (Heap [Y])) [13] else /* Y is consistent */ [14] if Y GlobalHeap then Remove Y from GlobalHeap fi [15] fi begin <ref> [16] </ref> GlobalHeap := [17] for every production p P do [18] recomputeProductionValue (p) [19] od [20] while GlobalHeap do [21] Select and remove from GlobalHeap a non-terminal X with minimum key value [22] if key (X) &lt; d [X ] then /* X is over-consistent */ [23] d [X ] := <p> In particular, the AdjustHeap operations (in lines [4], [10], and [12]) either perform an insertion or decrease the key of an item. Lines [6] and [14] are never executed. Consequently, procedure recomputeProductionValue takes time O (1) if relaxed heaps [13] or Fibonacci heaps <ref> [16] </ref> are used. (In the latter case, the time complexity is the amortized complexity.) It can also be verified that the number of elements in any of the heaps is O ( | d | ). <p> In particular, if m edges are inserted into an empty graph with n vertices, the algorithm works exactly like the O (m + n log n) implementation of Dijkstra's algorithm due to Fredman and Tarjan <ref> [16] </ref>. The asymptotic complexity of the algorithm can be further improved by using the recently developed AF-heap data structure [17]. 5. Extensions to the Algorithms In this section, we briefly outline various possible extensions and applications of the incremental algo rithms described in the previous sections. 5.1. <p> The above complexity follows from Fredman and Tarjan's <ref> [16] </ref> improvement to Dijkstra's algorithm. The complexity of the above algorithm can be improved slightly by utilising the recent O (m + nlogn /loglogn) shortest-path algorithm due to Fredman and Willard [17]).
Reference: 17. <author> Fredman, </author> <title> M.L. and Willard, D.E., Trans-dichotomous algorithms for minimum spanning trees and shortest paths, pp. </title> <booktitle> 719-725 in Proceedings of the 31st Annual Symposium on Foundations of Computer Science Volume II (St. </booktitle> <address> Louis, Missouri, </address> <month> October </month> <year> 1990), </year> <booktitle> IEEE Computer Society, </booktitle> <address> Washington, DC (1990). </address>
Reference-contexts: := rhs [u ] [12] for v Succ (u) do [13] rhs [v ] := g v (d [x 1 ], . . . , d [x k ]) [14] if rhs [v ] d [v ] then [15] AdjustHeap (Heap, v, min (rhs [v ],d [v ])) [16] else <ref> [17] </ref> if v Heap then Remove v from Heap fi [18] fi [20] else /* u is under-consistent */ [21] d [u ] := [22] for v (Succ (u) -u-) do [23] rhs [v ] := g v (d [x 1 ], . . . , d [x k ]) [24] <p> */ [10] AdjustHeap ( GlobalHeap, Y, d [Y]) [11] elseif Heap [Y] then /* Y is over-consistent */ [12] AdjustHeap ( GlobalHeap, Y, min key (Heap [Y])) [13] else /* Y is consistent */ [14] if Y GlobalHeap then Remove Y from GlobalHeap fi [15] fi begin [16] GlobalHeap := <ref> [17] </ref> for every production p P do [18] recomputeProductionValue (p) [19] od [20] while GlobalHeap do [21] Select and remove from GlobalHeap a non-terminal X with minimum key value [22] if key (X) &lt; d [X ] then /* X is over-consistent */ [23] d [X ] := key (X) [24] <p> The asymptotic complexity of the algorithm can be further improved by using the recently developed AF-heap data structure <ref> [17] </ref>. 5. Extensions to the Algorithms In this section, we briefly outline various possible extensions and applications of the incremental algo rithms described in the previous sections. 5.1. <p> The above complexity follows from Fredman and Tarjan's [16] improvement to Dijkstra's algorithm. The complexity of the above algorithm can be improved slightly by utilising the recent O (m + nlogn /loglogn) shortest-path algorithm due to Fredman and Willard <ref> [17] </ref>). We now consider how our incremental algorithm for the shortest-path problem can be used to solve this problem more efficiently. Let u 1 , . . . , u k be the set of all vertices in the graph that have an incoming edge of negative length.
Reference: 18. <author> Gallo, G., Longo, G., Pallottino, S., and Nguyen, S., </author> <title> Directed hypergraphs and applications, </title> <note> Discrete Applied Mathematics 42 pp. </note> <month> 177-201 </month> <year> (1993). </year>
Reference-contexts: In addition to the single-source shortest-path problem, Knuth lists a variety of other applications and special cases of the grammar problem, including the generation of optimal code for expression trees and the construction of optimal binary-search trees. The grammar problem also subsumes a number of hypergraph problems <ref> [3, 6, 7, 18, 23] </ref>, in particular, the problem of finding optimal hyperpaths in directed hypergraphs [5]. A directed hypergraph consists of a set of nodes and a set of hyperarcs, where each hyperarc connects a set of source nodes to a single target node. <p> [13] rhs [v ] := g v (d [x 1 ], . . . , d [x k ]) [14] if rhs [v ] d [v ] then [15] AdjustHeap (Heap, v, min (rhs [v ],d [v ])) [16] else [17] if v Heap then Remove v from Heap fi <ref> [18] </ref> fi [20] else /* u is under-consistent */ [21] d [u ] := [22] for v (Succ (u) -u-) do [23] rhs [v ] := g v (d [x 1 ], . . . , d [x k ]) [24] if rhs [v ] d [v ] then [25] AdjustHeap <p> [Y]) [11] elseif Heap [Y] then /* Y is over-consistent */ [12] AdjustHeap ( GlobalHeap, Y, min key (Heap [Y])) [13] else /* Y is consistent */ [14] if Y GlobalHeap then Remove Y from GlobalHeap fi [15] fi begin [16] GlobalHeap := [17] for every production p P do <ref> [18] </ref> recomputeProductionValue (p) [19] od [20] while GlobalHeap do [21] Select and remove from GlobalHeap a non-terminal X with minimum key value [22] if key (X) &lt; d [X ] then /* X is over-consistent */ [23] d [X ] := key (X) [24] SP [X ] := - p | <p> Consequently, the steps executed by the main procedure can be divided into (a) O ( || Changed || B ) invocations of the procedure recomputeProductionValue (lines <ref> [18] </ref>, [27] and [35]), (b) O ( | Affected | ) operations on GlobalHeap (line [21]), and (c) the remaining steps, which take time O ( || Changed || B ). Let us now consider the time taken by a single execution of procedure recomputeProductionValue.
Reference: 19. <author> Gondran, M. and Minoux, M., </author> <title> Graphs and Algorithms, </title> <publisher> John Wiley and Sons, </publisher> <address> New York (1984). </address>
Reference-contexts: 0 if u = source (G) = v Pred (u) min [d (v) + length (v fi u)] otherwise It can be shown that the maximal fixed point of this collection of equations is the solution to the SSSP problem if the input graph contains no negative length cycles. (See <ref> [19] </ref> for instance.) It is necessary to view the unknowns as belonging to the set of reals extended by + so that for every vertex u unreachable from the source vertex, d (u) will be in the maximal fixed point. <p> Heap [Y] then /* Y is over-consistent */ [12] AdjustHeap ( GlobalHeap, Y, min key (Heap [Y])) [13] else /* Y is consistent */ [14] if Y GlobalHeap then Remove Y from GlobalHeap fi [15] fi begin [16] GlobalHeap := [17] for every production p P do [18] recomputeProductionValue (p) <ref> [19] </ref> od [20] while GlobalHeap do [21] Select and remove from GlobalHeap a non-terminal X with minimum key value [22] if key (X) &lt; d [X ] then /* X is over-consistent */ [23] d [X ] := key (X) [24] SP [X ] := - p | p is a
Reference: 20. <author> Goto, S. and Sangiovanni-Vincentelli, A., </author> <title> A new shortest path updating algorithm, Networks 8(4) pp. </title> <month> 341-372 </month> <year> (1978). </year>
Reference-contexts: [v ] := g v (d [x 1 ], . . . , d [x k ]) [14] if rhs [v ] d [v ] then [15] AdjustHeap (Heap, v, min (rhs [v ],d [v ])) [16] else [17] if v Heap then Remove v from Heap fi [18] fi <ref> [20] </ref> else /* u is under-consistent */ [21] d [u ] := [22] for v (Succ (u) -u-) do [23] rhs [v ] := g v (d [x 1 ], . . . , d [x k ]) [24] if rhs [v ] d [v ] then [25] AdjustHeap (Heap, v, <p> then /* Y is over-consistent */ [12] AdjustHeap ( GlobalHeap, Y, min key (Heap [Y])) [13] else /* Y is consistent */ [14] if Y GlobalHeap then Remove Y from GlobalHeap fi [15] fi begin [16] GlobalHeap := [17] for every production p P do [18] recomputeProductionValue (p) [19] od <ref> [20] </ref> while GlobalHeap do [21] Select and remove from GlobalHeap a non-terminal X with minimum key value [22] if key (X) &lt; d [X ] then /* X is over-consistent */ [23] d [X ] := key (X) [24] SP [X ] := - p | p is a production for <p> In other words, p is consistent iff it satisfies the invariant and, in addition, value (p) d [Y ]. The precondition we assume to hold at the beginning of the update is that every unmodified production is consistent. The invariant the algorithm maintains is that whenever execution reaches line <ref> [20] </ref> every production satisfies the invariant, and that the GlobalHeap contains exactly the inconsistent non-terminals. The postcondition established by the algorithm is that every production and non-terminal in the grammar will be consistent. <p> The latter condition is relevant only if no production has X on the left-hand side. - 20 - We now show that whenever execution reaches line <ref> [20] </ref> every production satisfies the invariant, and GlobalHeap contains exactly the inconsistent non-terminals. The lines [16]-[19] initially establish the invariant. Subsequently, in each iteration of the loop in lines [20]-[38], whenever the value of a nonterminal changes (either in line [23] or line [30]) procedure recomputeProductionValue (p) is called for every <p> Previous work on algorithms for the dynamic shortest-path problem include papers by Murchland [27, 28], Loubal [26], Rodionov [34], Halder [21], Pape [29], Hsieh et al. [22], Cheston [9], Dionne [12], Goto et al. <ref> [20] </ref>, Cheston and Corneil [10], Rohnert [35], Even and Gazit [15], Lin and Chang [25], Ausiello et al. [2, 4], and Ramalingam and Reps [30]. The work described in this paper differs from these algorithms in several ways. <p> Second, the version of the dynamic shortest-path problem we address, namely the single-source version, has been previously considered only in <ref> [20] </ref>. The algorithm described in this paper is more efficient and capable of handling more general modifications than the algorithm described in [20]. Finally, we have generalized our algorithm to handle a version of the dynamic fixed point problem. <p> Second, the version of the dynamic shortest-path problem we address, namely the single-source version, has been previously considered only in <ref> [20] </ref>. The algorithm described in this paper is more efficient and capable of handling more general modifications than the algorithm described in [20]. Finally, we have generalized our algorithm to handle a version of the dynamic fixed point problem. A more comprehensive discussion and comparison of the above-mentioned algorithms appears in [31].
Reference: 21. <author> Halder, </author> <title> A.K., The method of competing links, </title> <note> Transportation Science 4 pp. </note> <month> 36-51 </month> <year> (1970). </year>
Reference-contexts: In addition, the algorithm also has to identify the change in consistency status of vertices and changes in the keys of inconsistent vertices as a result of the assignment of a new value to d [u ] in line [11] or line <ref> [21] </ref>. This is done in lines [12]-[19] and lines [22]-[29]. Let us now determine the time complexity of the algorithm. Let M d be a bound on the time required to compute the function associated with any vertex in Changed Succ (Changed). <p> 1 ], . . . , d [x k ]) [14] if rhs [v ] d [v ] then [15] AdjustHeap (Heap, v, min (rhs [v ],d [v ])) [16] else [17] if v Heap then Remove v from Heap fi [18] fi [20] else /* u is under-consistent */ <ref> [21] </ref> d [u ] := [22] for v (Succ (u) -u-) do [23] rhs [v ] := g v (d [x 1 ], . . . , d [x k ]) [24] if rhs [v ] d [v ] then [25] AdjustHeap (Heap, v, min (rhs [v ],d [v ])) [26] <p> over-consistent */ [12] AdjustHeap ( GlobalHeap, Y, min key (Heap [Y])) [13] else /* Y is consistent */ [14] if Y GlobalHeap then Remove Y from GlobalHeap fi [15] fi begin [16] GlobalHeap := [17] for every production p P do [18] recomputeProductionValue (p) [19] od [20] while GlobalHeap do <ref> [21] </ref> Select and remove from GlobalHeap a non-terminal X with minimum key value [22] if key (X) &lt; d [X ] then /* X is over-consistent */ [23] d [X ] := key (X) [24] SP [X ] := - p | p is a production for X such that value <p> Consequently, the steps executed by the main procedure can be divided into (a) O ( || Changed || B ) invocations of the procedure recomputeProductionValue (lines [18], [27] and [35]), (b) O ( | Affected | ) operations on GlobalHeap (line <ref> [21] </ref>), and (c) the remaining steps, which take time O ( || Changed || B ). Let us now consider the time taken by a single execution of procedure recomputeProductionValue. <p> Consequently, in this version of the dynamic SSF grammar problem, for example, if the query asks for the value d [Y ] of some non-terminal Y, then the updating algorithm in Figure 4 may stop when the key of the non-terminal X selected in line <ref> [21] </ref> is greater than d [Y ]. Some other minor modifications to the algorithms are necessary. For example, in Figure 4, Glo-balHeap, the heap of inconsistent vertices, need no longer be empty in between updates or queries. <p> This is, however, not a significant difference. Such hyperpaths can be represented in the grammar by derivations by simply adding epsilon productions for all the relevant non-terminals. Previous work on algorithms for the dynamic shortest-path problem include papers by Murchland [27, 28], Loubal [26], Rodionov [34], Halder <ref> [21] </ref>, Pape [29], Hsieh et al. [22], Cheston [9], Dionne [12], Goto et al. [20], Cheston and Corneil [10], Rohnert [35], Even and Gazit [15], Lin and Chang [25], Ausiello et al. [2, 4], and Ramalingam and Reps [30].
Reference: 22. <author> Hsieh, W., Kershenbaum, A., and Golden, B., </author> <title> Constrained routing in large sparse networks, pp. </title> <booktitle> 38.14-38.18 in Proceedings of IEEE International Conference on Communications, </booktitle> , <address> Philadelphia, PA (1976). </address>
Reference-contexts: , d [x k ]) [14] if rhs [v ] d [v ] then [15] AdjustHeap (Heap, v, min (rhs [v ],d [v ])) [16] else [17] if v Heap then Remove v from Heap fi [18] fi [20] else /* u is under-consistent */ [21] d [u ] := <ref> [22] </ref> for v (Succ (u) -u-) do [23] rhs [v ] := g v (d [x 1 ], . . . , d [x k ]) [24] if rhs [v ] d [v ] then [25] AdjustHeap (Heap, v, min (rhs [v ],d [v ])) [26] else [27] if v Heap <p> /* Y is consistent */ [14] if Y GlobalHeap then Remove Y from GlobalHeap fi [15] fi begin [16] GlobalHeap := [17] for every production p P do [18] recomputeProductionValue (p) [19] od [20] while GlobalHeap do [21] Select and remove from GlobalHeap a non-terminal X with minimum key value <ref> [22] </ref> if key (X) &lt; d [X ] then /* X is over-consistent */ [23] d [X ] := key (X) [24] SP [X ] := - p | p is a production for X such that value (p) = d [X ] - [25] Heap [X ] := [26] for <p> Such hyperpaths can be represented in the grammar by derivations by simply adding epsilon productions for all the relevant non-terminals. Previous work on algorithms for the dynamic shortest-path problem include papers by Murchland [27, 28], Loubal [26], Rodionov [34], Halder [21], Pape [29], Hsieh et al. <ref> [22] </ref>, Cheston [9], Dionne [12], Goto et al. [20], Cheston and Corneil [10], Rohnert [35], Even and Gazit [15], Lin and Chang [25], Ausiello et al. [2, 4], and Ramalingam and Reps [30]. The work described in this paper differs from these algorithms in several ways.
Reference: 23. <author> Italiano, G.F. and Nanni, U., </author> <title> On line maintenance of minimal directed hypergraphs, </title> <note> pp. 335-349 in Proceedings 3rd Convegno Italiano di Informatica Teorica (Mantova), World Science Press (1989). </note>
Reference-contexts: In addition to the single-source shortest-path problem, Knuth lists a variety of other applications and special cases of the grammar problem, including the generation of optimal code for expression trees and the construction of optimal binary-search trees. The grammar problem also subsumes a number of hypergraph problems <ref> [3, 6, 7, 18, 23] </ref>, in particular, the problem of finding optimal hyperpaths in directed hypergraphs [5]. A directed hypergraph consists of a set of nodes and a set of hyperarcs, where each hyperarc connects a set of source nodes to a single target node. <p> rhs [v ] d [v ] then [15] AdjustHeap (Heap, v, min (rhs [v ],d [v ])) [16] else [17] if v Heap then Remove v from Heap fi [18] fi [20] else /* u is under-consistent */ [21] d [u ] := [22] for v (Succ (u) -u-) do <ref> [23] </ref> rhs [v ] := g v (d [x 1 ], . . . , d [x k ]) [24] if rhs [v ] d [v ] then [25] AdjustHeap (Heap, v, min (rhs [v ],d [v ])) [26] else [27] if v Heap then Remove v from Heap fi [28] <p> An Improved Algorithm for the Dynamic SSF Grammar Problem The algorithm presented in the previous section can be improved further in the case of the dynamic grammar problem. The sources of optimization are lines [13] and <ref> [23] </ref> in Figure 3. In the general SWSF fixed point problem, the function on the right-hand side of an equation can be an arbitrary s.w.s.f ., and, consequently, the right-hand side has to computed from scratch (in lines [13] and [23]) when one of the arguments changes in value. <p> The sources of optimization are lines [13] and <ref> [23] </ref> in Figure 3. In the general SWSF fixed point problem, the function on the right-hand side of an equation can be an arbitrary s.w.s.f ., and, consequently, the right-hand side has to computed from scratch (in lines [13] and [23]) when one of the arguments changes in value. The functions that arise in the grammar problem, however, have a special form. <p> fi [15] fi begin [16] GlobalHeap := [17] for every production p P do [18] recomputeProductionValue (p) [19] od [20] while GlobalHeap do [21] Select and remove from GlobalHeap a non-terminal X with minimum key value [22] if key (X) &lt; d [X ] then /* X is over-consistent */ <ref> [23] </ref> d [X ] := key (X) [24] SP [X ] := - p | p is a production for X such that value (p) = d [X ] - [25] Heap [X ] := [26] for every production p with X on the right-hand side do recomputeProductionValue (p) od [27] <p> The lines [16]-[19] initially establish the invariant. Subsequently, in each iteration of the loop in lines [20]-[38], whenever the value of a nonterminal changes (either in line <ref> [23] </ref> or line [30]) procedure recomputeProductionValue (p) is called for every production p that might have become inconsistent. Thus, the invariant is re-established. It follows from the explanation in the previous paragraph that every non-terminal and production in the grammar is consistent when the algorithm halts.
Reference: 24. <author> Knuth, D.E., </author> <title> A generalization of Dijkstra's algorithm, </title> <note> Information Processing Letters 6(1) pp. </note> <month> 1-5 </month> <year> (1977). </year>
Reference-contexts: 1. Introduction Knuth defined the following generalization of the single-source shortest-path problem, called the grammar problem <ref> [24] </ref>: Consider a context-free grammar in which every production is associated with a real-valued function whose arity equals the number of non-terminal occurrences on the right-hand side of the production. <p> We refer to these two problems as the SSSP0 problem and - 4 - SSSP&gt;0 problem, respectively. The grammar problem is a generalization of the shortest path problem due to Knuth <ref> [24] </ref>. <p> However, some simple restrictions on the type of production functions allowed, which we discuss shortly, guarantee that m G (Y) is well defined. Examples. (Knuth <ref> [24] </ref>.) Given a context-free grammar, consider the abstract grammar obtained by replacing each production Y fi q in the given grammar by the production Y fi g q (X 1 , . . . , X k ), where X 1 , . . . , X k are the non-terminal <p> [17] if v Heap then Remove v from Heap fi [18] fi [20] else /* u is under-consistent */ [21] d [u ] := [22] for v (Succ (u) -u-) do [23] rhs [v ] := g v (d [x 1 ], . . . , d [x k ]) <ref> [24] </ref> if rhs [v ] d [v ] then [25] AdjustHeap (Heap, v, min (rhs [v ],d [v ])) [26] else [27] if v Heap then Remove v from Heap fi [28] fi [30] fi end postconditions Every vertex in V (G) is consistent hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh Hence, the lines [11]-[19] take O <p> [17] for every production p P do [18] recomputeProductionValue (p) [19] od [20] while GlobalHeap do [21] Select and remove from GlobalHeap a non-terminal X with minimum key value [22] if key (X) &lt; d [X ] then /* X is over-consistent */ [23] d [X ] := key (X) <ref> [24] </ref> SP [X ] := - p | p is a production for X such that value (p) = d [X ] - [25] Heap [X ] := [26] for every production p with X on the right-hand side do recomputeProductionValue (p) od [27] else /* X is under-consistent */ [28] <p> We have also described how the algorithm can be generalized to handle negative edge lengths under certain conditions, and how the algorithm for the dynamic single-source shortest-path problem can be utilized for the dynamic all-pairs shortest-path problem as well. Knuth <ref> [24] </ref> introduced the grammar problem as a generalization of the shortest-path problem, and generalized Dijkstra's algorithm to solve the batch SF grammar problem.
Reference: 25. <author> Lin, C.-C. and Chang, R.-C., </author> <title> On the dynamic shortest path problem, </title> <journal> Journal of Information Processing 13(4)(1990). </journal>
Reference-contexts: fi [18] fi [20] else /* u is under-consistent */ [21] d [u ] := [22] for v (Succ (u) -u-) do [23] rhs [v ] := g v (d [x 1 ], . . . , d [x k ]) [24] if rhs [v ] d [v ] then <ref> [25] </ref> AdjustHeap (Heap, v, min (rhs [v ],d [v ])) [26] else [27] if v Heap then Remove v from Heap fi [28] fi [30] fi end postconditions Every vertex in V (G) is consistent hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh Hence, the lines [11]-[19] take O ( || -u- || . (M d +log || <p> non-terminal X with minimum key value [22] if key (X) &lt; d [X ] then /* X is over-consistent */ [23] d [X ] := key (X) [24] SP [X ] := - p | p is a production for X such that value (p) = d [X ] - <ref> [25] </ref> Heap [X ] := [26] for every production p with X on the right-hand side do recomputeProductionValue (p) od [27] else /* X is under-consistent */ [28] d [X ] := [29] SP [X ] := - p | p is a production for X - [30] Heap [X ] <p> Previous work on algorithms for the dynamic shortest-path problem include papers by Murchland [27, 28], Loubal [26], Rodionov [34], Halder [21], Pape [29], Hsieh et al. [22], Cheston [9], Dionne [12], Goto et al. [20], Cheston and Corneil [10], Rohnert [35], Even and Gazit [15], Lin and Chang <ref> [25] </ref>, Ausiello et al. [2, 4], and Ramalingam and Reps [30]. The work described in this paper differs from these algorithms in several ways.
Reference: 26. <author> Loubal, P., </author> <title> A network evaluation procedure, </title> <journal> Highway Research Record 205 pp. </journal> <month> 96-109 </month> <year> (1967). </year>
Reference-contexts: [21] d [u ] := [22] for v (Succ (u) -u-) do [23] rhs [v ] := g v (d [x 1 ], . . . , d [x k ]) [24] if rhs [v ] d [v ] then [25] AdjustHeap (Heap, v, min (rhs [v ],d [v ])) <ref> [26] </ref> else [27] if v Heap then Remove v from Heap fi [28] fi [30] fi end postconditions Every vertex in V (G) is consistent hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh Hence, the lines [11]-[19] take O ( || -u- || . (M d +log || d || )) time (in one iteration). <p> value [22] if key (X) &lt; d [X ] then /* X is over-consistent */ [23] d [X ] := key (X) [24] SP [X ] := - p | p is a production for X such that value (p) = d [X ] - [25] Heap [X ] := <ref> [26] </ref> for every production p with X on the right-hand side do recomputeProductionValue (p) od [27] else /* X is under-consistent */ [28] d [X ] := [29] SP [X ] := - p | p is a production for X - [30] Heap [X ] := makeHeap (- p | <p> This is, however, not a significant difference. Such hyperpaths can be represented in the grammar by derivations by simply adding epsilon productions for all the relevant non-terminals. Previous work on algorithms for the dynamic shortest-path problem include papers by Murchland [27, 28], Loubal <ref> [26] </ref>, Rodionov [34], Halder [21], Pape [29], Hsieh et al. [22], Cheston [9], Dionne [12], Goto et al. [20], Cheston and Corneil [10], Rohnert [35], Even and Gazit [15], Lin and Chang [25], Ausiello et al. [2, 4], and Ramalingam and Reps [30].
Reference: 27. <author> Murchland, J.D., </author> <title> The effect of increasing or decreasing the length of a single arc on all shortest distances in a graph, </title> <type> Tech. Rep. </type> <institution> LBS-TNT-26, London Business School, Transport Network Theory Unit, </institution> <address> London, UK (1967). </address>
Reference-contexts: [u ] := [22] for v (Succ (u) -u-) do [23] rhs [v ] := g v (d [x 1 ], . . . , d [x k ]) [24] if rhs [v ] d [v ] then [25] AdjustHeap (Heap, v, min (rhs [v ],d [v ])) [26] else <ref> [27] </ref> if v Heap then Remove v from Heap fi [28] fi [30] fi end postconditions Every vertex in V (G) is consistent hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh Hence, the lines [11]-[19] take O ( || -u- || . (M d +log || d || )) time (in one iteration). <p> [23] d [X ] := key (X) [24] SP [X ] := - p | p is a production for X such that value (p) = d [X ] - [25] Heap [X ] := [26] for every production p with X on the right-hand side do recomputeProductionValue (p) od <ref> [27] </ref> else /* X is under-consistent */ [28] d [X ] := [29] SP [X ] := - p | p is a production for X - [30] Heap [X ] := makeHeap (- p | p is a production for X with value (p) &lt; d [X ] -) [31] <p> Consequently, the steps executed by the main procedure can be divided into (a) O ( || Changed || B ) invocations of the procedure recomputeProductionValue (lines [18], <ref> [27] </ref> and [35]), (b) O ( | Affected | ) operations on GlobalHeap (line [21]), and (c) the remaining steps, which take time O ( || Changed || B ). Let us now consider the time taken by a single execution of procedure recomputeProductionValue. <p> This is, however, not a significant difference. Such hyperpaths can be represented in the grammar by derivations by simply adding epsilon productions for all the relevant non-terminals. Previous work on algorithms for the dynamic shortest-path problem include papers by Murchland <ref> [27, 28] </ref>, Loubal [26], Rodionov [34], Halder [21], Pape [29], Hsieh et al. [22], Cheston [9], Dionne [12], Goto et al. [20], Cheston and Corneil [10], Rohnert [35], Even and Gazit [15], Lin and Chang [25], Ausiello et al. [2, 4], and Ramalingam and Reps [30].
Reference: 28. <author> Murchland, J.D., </author> <title> A fixed matrix method for all shortest distances in a directed graph and for the inverse problem, </title> <type> Doctoral dissertation, </type> <institution> Universita .. t Karlsruhe, Karlsruhe, W. Germany </institution> (). 
Reference-contexts: [23] rhs [v ] := g v (d [x 1 ], . . . , d [x k ]) [24] if rhs [v ] d [v ] then [25] AdjustHeap (Heap, v, min (rhs [v ],d [v ])) [26] else [27] if v Heap then Remove v from Heap fi <ref> [28] </ref> fi [30] fi end postconditions Every vertex in V (G) is consistent hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh Hence, the lines [11]-[19] take O ( || -u- || . (M d +log || d || )) time (in one iteration). Lines [20]-[30] are similarly executed at most once for each affected vertex u. <p> [24] SP [X ] := - p | p is a production for X such that value (p) = d [X ] - [25] Heap [X ] := [26] for every production p with X on the right-hand side do recomputeProductionValue (p) od [27] else /* X is under-consistent */ <ref> [28] </ref> d [X ] := [29] SP [X ] := - p | p is a production for X - [30] Heap [X ] := makeHeap (- p | p is a production for X with value (p) &lt; d [X ] -) [31] if Heap [X ] then AdjustHeap ( <p> This is, however, not a significant difference. Such hyperpaths can be represented in the grammar by derivations by simply adding epsilon productions for all the relevant non-terminals. Previous work on algorithms for the dynamic shortest-path problem include papers by Murchland <ref> [27, 28] </ref>, Loubal [26], Rodionov [34], Halder [21], Pape [29], Hsieh et al. [22], Cheston [9], Dionne [12], Goto et al. [20], Cheston and Corneil [10], Rohnert [35], Even and Gazit [15], Lin and Chang [25], Ausiello et al. [2, 4], and Ramalingam and Reps [30].
Reference: 29. <editor> Pape, U., Netzwerk-veraenderungen und korrektur kuerzester weglaengen von einer wurzelmenge zu allen anderen knoten, </editor> <booktitle> Computing 12 pp. </booktitle> <month> 357-362 </month> <year> (1974). </year>
Reference-contexts: - p | p is a production for X such that value (p) = d [X ] - [25] Heap [X ] := [26] for every production p with X on the right-hand side do recomputeProductionValue (p) od [27] else /* X is under-consistent */ [28] d [X ] := <ref> [29] </ref> SP [X ] := - p | p is a production for X - [30] Heap [X ] := makeHeap (- p | p is a production for X with value (p) &lt; d [X ] -) [31] if Heap [X ] then AdjustHeap ( GlobalHeap, X, min key (Heap <p> This is, however, not a significant difference. Such hyperpaths can be represented in the grammar by derivations by simply adding epsilon productions for all the relevant non-terminals. Previous work on algorithms for the dynamic shortest-path problem include papers by Murchland [27, 28], Loubal [26], Rodionov [34], Halder [21], Pape <ref> [29] </ref>, Hsieh et al. [22], Cheston [9], Dionne [12], Goto et al. [20], Cheston and Corneil [10], Rohnert [35], Even and Gazit [15], Lin and Chang [25], Ausiello et al. [2, 4], and Ramalingam and Reps [30]. The work described in this paper differs from these algorithms in several ways.
Reference: 30. <author> Ramalingam, G. and Reps, T., </author> <title> On the computational complexity of incremental algorithms, </title> <institution> TR-1033, Computer Sciences Department, University of Wisconsin, Madison, </institution> <note> WI (August 1991). </note>
Reference-contexts: [v ] := g v (d [x 1 ], . . . , d [x k ]) [24] if rhs [v ] d [v ] then [25] AdjustHeap (Heap, v, min (rhs [v ],d [v ])) [26] else [27] if v Heap then Remove v from Heap fi [28] fi <ref> [30] </ref> fi end postconditions Every vertex in V (G) is consistent hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh Hence, the lines [11]-[19] take O ( || -u- || . (M d +log || d || )) time (in one iteration). Lines [20]-[30] are similarly executed at most once for each affected vertex u. Consequently, lines [20]-[30] also <p> [X ] - [25] Heap [X ] := [26] for every production p with X on the right-hand side do recomputeProductionValue (p) od [27] else /* X is under-consistent */ [28] d [X ] := [29] SP [X ] := - p | p is a production for X - <ref> [30] </ref> Heap [X ] := makeHeap (- p | p is a production for X with value (p) &lt; d [X ] -) [31] if Heap [X ] then AdjustHeap ( GlobalHeap, X, min key (Heap [X])) fi [32] for every production p with X on the right-hand side do recomputeProductionValue <p> The lines [16]-[19] initially establish the invariant. Subsequently, in each iteration of the loop in lines [20]-[38], whenever the value of a nonterminal changes (either in line [23] or line <ref> [30] </ref>) procedure recomputeProductionValue (p) is called for every production p that might have become inconsistent. Thus, the invariant is re-established. It follows from the explanation in the previous paragraph that every non-terminal and production in the grammar is consistent when the algorithm halts. <p> problem include papers by Murchland [27, 28], Loubal [26], Rodionov [34], Halder [21], Pape [29], Hsieh et al. [22], Cheston [9], Dionne [12], Goto et al. [20], Cheston and Corneil [10], Rohnert [35], Even and Gazit [15], Lin and Chang [25], Ausiello et al. [2, 4], and Ramalingam and Reps <ref> [30] </ref>. The work described in this paper differs from these algorithms in several ways. First, the incremental algorithm we have presented is the first algorithm for any version of the dynamic shortest-path problem that is capable of handling arbitrary modifications to the graph (i.e., multiple heterogeneous changes to the graph).
Reference: 31. <author> Ramalingam, G. and Reps, T., </author> <title> An incremental algorithm for a generalization of the shortest-path problem, </title> <institution> TR-1087, Computer Sciences Department, University of Wisconsin, Madison, </institution> <address> WI (May 1992). </address>
Reference-contexts: [27] else /* X is under-consistent */ [28] d [X ] := [29] SP [X ] := - p | p is a production for X - [30] Heap [X ] := makeHeap (- p | p is a production for X with value (p) &lt; d [X ] -) <ref> [31] </ref> if Heap [X ] then AdjustHeap ( GlobalHeap, X, min key (Heap [X])) fi [32] for every production p with X on the right-hand side do recomputeProductionValue (p) od [33] fi end postconditions: Every non-terminal and production in G is consistent hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh mental fashion. <p> Finally, we have generalized our algorithm to handle a version of the dynamic fixed point problem. A more comprehensive discussion and comparison of the above-mentioned algorithms appears in <ref> [31] </ref>. Appendix In this appendix, we prove the claims made in Section 2 concerning the relationship between the various versions of the grammar problem and the various versions of the fixed point problem.
Reference: 32. <author> Ramalingam, G., </author> <title> Bounded Incremental Computation, </title> <type> Ph.D. dissertation and Tech. Rep. </type> <institution> TR-1172, Computer Sciences Department, University of Wisconsin, Madison, </institution> <note> WI (August 1993). </note>
Reference-contexts: For our purposes, a more useful measure of the size of K is the extended size || K || G of K, which is defined to be the sum of the number of vertices in K and the number of edges which have at least one endpoint in K <ref> [1, 32, 33] </ref>. Thus, the two parameters we will find useful are | Changed G,d | , which we abbreviate to | d | G , and || Changed G,d || G+d , which we abbreviate to || d || G . <p> ] := - p | p is a production for X - [30] Heap [X ] := makeHeap (- p | p is a production for X with value (p) &lt; d [X ] -) [31] if Heap [X ] then AdjustHeap ( GlobalHeap, X, min key (Heap [X])) fi <ref> [32] </ref> for every production p with X on the right-hand side do recomputeProductionValue (p) od [33] fi end postconditions: Every non-terminal and production in G is consistent hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh mental fashion. We now describe the auxiliary data structures that the algorithm uses to do this.
Reference: 33. <author> Reps, T., </author> <title> Generating Language-Based Environments, </title> <publisher> The M.I.T. Press, </publisher> <address> Cambridge, MA (1984). </address>
Reference-contexts: For our purposes, a more useful measure of the size of K is the extended size || K || G of K, which is defined to be the sum of the number of vertices in K and the number of edges which have at least one endpoint in K <ref> [1, 32, 33] </ref>. Thus, the two parameters we will find useful are | Changed G,d | , which we abbreviate to | d | G , and || Changed G,d || G+d , which we abbreviate to || d || G . <p> ] := makeHeap (- p | p is a production for X with value (p) &lt; d [X ] -) [31] if Heap [X ] then AdjustHeap ( GlobalHeap, X, min key (Heap [X])) fi [32] for every production p with X on the right-hand side do recomputeProductionValue (p) od <ref> [33] </ref> fi end postconditions: Every non-terminal and production in G is consistent hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh mental fashion. We now describe the auxiliary data structures that the algorithm uses to do this. These auxiliary data structures are retained across invocations of the procedure.
Reference: 34. <author> Rodionov, V., </author> <title> The parametric problem of shortest distances, </title> <journal> U.S.S.R. Computational Math. and Math. Phys. </journal> <pages> 8(5) pp. </pages> <month> 336-343 </month> <year> (1968). </year>
Reference-contexts: This is, however, not a significant difference. Such hyperpaths can be represented in the grammar by derivations by simply adding epsilon productions for all the relevant non-terminals. Previous work on algorithms for the dynamic shortest-path problem include papers by Murchland [27, 28], Loubal [26], Rodionov <ref> [34] </ref>, Halder [21], Pape [29], Hsieh et al. [22], Cheston [9], Dionne [12], Goto et al. [20], Cheston and Corneil [10], Rohnert [35], Even and Gazit [15], Lin and Chang [25], Ausiello et al. [2, 4], and Ramalingam and Reps [30].
Reference: 35. <author> Rohnert, H., </author> <title> A dynamization of the all pairs least cost path problem, pp. </title> <booktitle> 279-286 in Proceedings of STACS 85: Second Annual Symposium on Theoretical Aspects of Computer Science, </booktitle> <editor> (Saarbruecken, W. Ger., </editor> <month> Jan. </month> <pages> 3-5, </pages> <year> 1985), </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 182, </volume> <editor> ed. K. Mehlhorn,Springer-Verlag, </editor> <address> New York, NY (1985). </address>
Reference-contexts: Consequently, the steps executed by the main procedure can be divided into (a) O ( || Changed || B ) invocations of the procedure recomputeProductionValue (lines [18], [27] and <ref> [35] </ref>), (b) O ( | Affected | ) operations on GlobalHeap (line [21]), and (c) the remaining steps, which take time O ( || Changed || B ). Let us now consider the time taken by a single execution of procedure recomputeProductionValue. <p> Previous work on algorithms for the dynamic shortest-path problem include papers by Murchland [27, 28], Loubal [26], Rodionov [34], Halder [21], Pape [29], Hsieh et al. [22], Cheston [9], Dionne [12], Goto et al. [20], Cheston and Corneil [10], Rohnert <ref> [35] </ref>, Even and Gazit [15], Lin and Chang [25], Ausiello et al. [2, 4], and Ramalingam and Reps [30]. The work described in this paper differs from these algorithms in several ways.
Reference: 36. <author> Spira, P.M. and Pan, A., </author> <title> On finding and updating spanning trees and shortest paths, </title> <note> SIAM J. Computing 4(3) pp. </note> <month> 375-380 (September </month> <year> 1975). </year>
Reference: 37. <author> Tarjan, R.E., </author> <title> Data Structures and Network Algorithms, </title> <institution> Society for Industrial and Applied Mathematics, </institution> <address> Philadelphia, PA (1983). </address>
Reference-contexts: The idea is to adapt the technique of Edmonds and Karp for transforming the length of every edge to a non-negative real without changing the graph's shortest paths <ref> [14, 37] </ref>.
Reference: 38. <author> Yap, C.K., </author> <title> A hybrid algorithm for the shortest path between two nodes in the presence of few negative arcs, </title> <note> Information Processing Letters 16 pp. </note> <month> 181-182 (May </month> <year> 1983). </year>
Reference-contexts: We leave the details to the reader. 5.6. The Batch Shortest-Path Problem in the Presence of Few Negative Edges Yap <ref> [38] </ref> describes an algorithm for finding the shortest path between two vertices in a graph that may include edges with negative length. This algorithm works better than the standard Bellman-Ford algorithm when the number of negative-length edges is small.
References-found: 38

