URL: http://www.eecs.umich.edu/~sjhan/tpds99.ps
Refering-URL: http://www.eecs.umich.edu/~sjhan/
Root-URL: http://www.eecs.umich.edu
Title: Experimental Evaluation of Behavior-Based Failure-Detection Schemes in Real-time Communication Networks  
Author: Seungjae Han and Kang G. Shin, Fellow, IEEE 
Keyword: Index Terms Real-time communication, network failures, failure detection, fault-injection experiments.  
Abstract: Effective detection of failures is essential for reliable communication services. Traditionally, non-real-time computer networks have relied on behavior-based techniques for detecting communication failures. That is, each node uses heartbeats to detect the failure of its neighbors, and the end-to-end transport protocol (e.g., TCP) achieves reliable communication by acknowledgment/retransmission. Recently, there is a growing demand for reliable `real-time' communication, but little research has been done on the failure detection problem. In this paper, we present two behavior-based failure-detection schemes | neighbor detection and end-to-end detection | for reliable real-time communication services, and experimentally evaluate their effectiveness. Specifically, we measure and analyze the coverage and latency of these detection schemes through fault-injection experiments. The experimental results have shown that nearly all failures can be detected very quickly by the neighbor detection scheme, while the end-to-end detection scheme uncovers the remaining failures with larger detection latencies. fl A subset of the materials of this paper was presented at FTCS-27, June 1997, in Seattle, WA. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. Ramanathan and K. G. Shin, </author> <title> "Delivery of time-critical messages using a multiple copy approach," </title> <journal> ACM Trans. Computer Systems, </journal> <volume> vol. 10, no. 2, </volume> <pages> pp. 144-166, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: As a result, loss-free real-time communication is very difficult to achieve without using expensive forward-recovery techniques (e.g., multiple-copy transmission <ref> [1] </ref>, error correction coding [2]). However, fortunately, many real-time applications do not require such strict reliability as `no message loss at all.' For example, infrequent loss of two or three frames in video/voice data streams is acceptable in most multimedia applications.
Reference: [2] <author> A. Banerjea, </author> <title> "Simulation study of the capacity effects of dispersity routing for fault tolerant realtime channels," </title> <booktitle> in Proc. ACM SIGCOMM, </booktitle> <pages> pp. 194-205, </pages> <year> 1996. </year>
Reference-contexts: As a result, loss-free real-time communication is very difficult to achieve without using expensive forward-recovery techniques (e.g., multiple-copy transmission [1], error correction coding <ref> [2] </ref>). However, fortunately, many real-time applications do not require such strict reliability as `no message loss at all.' For example, infrequent loss of two or three frames in video/voice data streams is acceptable in most multimedia applications.
Reference: [3] <author> K. G. Shin and H. Kim, </author> <title> "Derivation and application of hard deadlines for real-time control systems," </title> <journal> IEEE Trans. on System, Man, and Cybernetics, </journal> <volume> vol. 22, no. 6, </volume> <pages> pp. 1403-1413, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: Temporary message losses for a short period of time are also tolerable in real-time control applications because of the `system inertia' characterized by the control system deadline <ref> [3] </ref>. Therefore, the grain of failure detection in real-time communication service is channel failures instead of individual message losses. A real-time channel is said to have `failed,' if the rate of correct 1 message delivery within a certain time interval is below a certain threshold specified by the application.
Reference: [4] <author> W. N. </author> <title> Toy, "Fault-tolerant design of AT&T telephone switching system processors," </title> <booktitle> in Reliable Computer Systems: Design and Evaluation, </booktitle> <pages> pp. 533-574. </pages> <publisher> Digital Press, </publisher> <year> 1992. </year>
Reference-contexts: In telephone networks, an expensive failure-detection technique using hardware duplication/comparison is used to quickly detect switching-node failures <ref> [4] </ref>, and spatial redundancy is applied to the physical layer to mask link failures. However, (hardware) duplication is not a viable solution for large-scale computer networks such as Internet, considering the complexity of designing routers and the innate heterogeneity of sub-networks.
Reference: [5] <author> D. Comer, </author> <title> Internetworking with TCP/IP, </title> <publisher> Prentice-Hall, </publisher> <year> 1995. </year>
Reference-contexts: With the connection-level detection scheme (called `end-to-end detection'), the status of a real-time channel is monitored by its receiver node. The former is similar to the reachability test between gateways in the Internet Protocol (IP) <ref> [5] </ref>, while the latter is, in principle, similar to the negative acknowledgment method. The deployment of our schemes can benefit from these similarities by easing the integration with the existing network protocols. We will not address the integration issue of our schemes with existing network protocols.
Reference: [6] <author> M. Hsueh, T. Tsai, and R. Iyer, </author> <title> "Fault injection techniques and tools," </title> <booktitle> IEEE Computer, </booktitle> <pages> pp. 75-82, </pages> <month> April </month> <year> 1997. </year>
Reference-contexts: The basic design principles are explained first, and the implementation details are then described. 3.1 DOCTOR: An integrateD ftware-implemented fault injeC n enviR onment Fault injection has long been viewed as a useful means of testing/evaluating fault-tolerant systems <ref> [6] </ref>. Numerous hardware-implemented fault injectors (HFIs) [7, 8, 9] have been developed and used for various experiments. However, as the complexity of contemporary computer systems increases as a result of using highly-integrated VLSI chips, it is becoming more difficult, or nearly impossible, to evaluate dependability with HFIs alone. <p> Although SFI techniques such as overwriting memory or register contents are becoming popular, they still face many difficulties, such as limited accessibility to hardware, perturbation to workloads, and poor time-resolution <ref> [6] </ref>. List below are the desirable features of a fault-injection tool for the evaluation of our failure-detection schemes. 1. The fault model should include faults on communication links or communication adaptor circuitry as well as faults inside a processing node such as memory, CPU, or bus. 2.
Reference: [7] <author> J. Arlat, Y. Crouzet, and J.-C. Laprie, </author> <title> "Fault injection for dependability validation of fault-tolerant computing systems.," </title> <booktitle> in Proc. IEEE FTCS, </booktitle> <pages> pp. 348-355, </pages> <year> 1989. </year>
Reference-contexts: The basic design principles are explained first, and the implementation details are then described. 3.1 DOCTOR: An integrateD ftware-implemented fault injeC n enviR onment Fault injection has long been viewed as a useful means of testing/evaluating fault-tolerant systems [6]. Numerous hardware-implemented fault injectors (HFIs) <ref> [7, 8, 9] </ref> have been developed and used for various experiments. However, as the complexity of contemporary computer systems increases as a result of using highly-integrated VLSI chips, it is becoming more difficult, or nearly impossible, to evaluate dependability with HFIs alone. <p> measure the efficiency of the neighbor scheme (i.e., its detection coverage and latency) and to examine if and how much sending node-heartbeats as real-time messages can enhance the detection coverage of the neighbor scheme. 4.3 Experiment Specification We describe the details of the experiment plan using the FARM specification model <ref> [7] </ref>, which formulate a fault-injection experiment with four attributes: a set of faults F, a set of activations A, a set of readouts R, and a set of derived measures M.
Reference: [8] <author> U. Gunneflo, J. Karlsson, and J. Torin, </author> <title> "Evaluation of error detection schemes using fault injection by heavy-ion radiation," </title> <booktitle> in Proc. IEEE FTCS, </booktitle> <pages> pp. 340-347, </pages> <year> 1989. </year>
Reference-contexts: The basic design principles are explained first, and the implementation details are then described. 3.1 DOCTOR: An integrateD ftware-implemented fault injeC n enviR onment Fault injection has long been viewed as a useful means of testing/evaluating fault-tolerant systems [6]. Numerous hardware-implemented fault injectors (HFIs) <ref> [7, 8, 9] </ref> have been developed and used for various experiments. However, as the complexity of contemporary computer systems increases as a result of using highly-integrated VLSI chips, it is becoming more difficult, or nearly impossible, to evaluate dependability with HFIs alone.
Reference: [9] <author> H. Madeira and J. Silva, </author> <title> "Experimental evaluation of the fail-silent behavior in computers without error masking," </title> <booktitle> in Proc. IEEE FTCS, </booktitle> <pages> pp. 350-359, </pages> <year> 1994. </year> <month> 22 </month>
Reference-contexts: The basic design principles are explained first, and the implementation details are then described. 3.1 DOCTOR: An integrateD ftware-implemented fault injeC n enviR onment Fault injection has long been viewed as a useful means of testing/evaluating fault-tolerant systems [6]. Numerous hardware-implemented fault injectors (HFIs) <ref> [7, 8, 9] </ref> have been developed and used for various experiments. However, as the complexity of contemporary computer systems increases as a result of using highly-integrated VLSI chips, it is becoming more difficult, or nearly impossible, to evaluate dependability with HFIs alone. <p> The most important contribution of this paper is that we showed that the `near-failure-silence' behavior of network nodes can be achieved without applying expensive redundancy techniques in real-time communication networks. This result contrasts with the previous experimental results on the failure-silence behavior in various application areas <ref> [9, 27, 28, 23, 29] </ref>. Acknowledgments We would like to thank Harold Rosenberg and Jaehyun Park for their contribution in the implementation of DOCTOR. Atri Indiresan provided the skeleton of the real-time channel protocol used in our experiment.
Reference: [10] <author> Z. Segall et al., </author> <title> "FIAT fault injection based automated testing environment," </title> <booktitle> in Proc. IEEE FTCS, </booktitle> <pages> pp. 102-107, </pages> <year> 1988. </year>
Reference-contexts: However, as the complexity of contemporary computer systems increases as a result of using highly-integrated VLSI chips, it is becoming more difficult, or nearly impossible, to evaluate dependability with HFIs alone. On the other hand, software-implemented fault injectors (SFIs) <ref> [10, 11, 12, 13, 14] </ref> have been proposed as less expensive and more controllable alternatives. Although SFI techniques such as overwriting memory or register contents are becoming popular, they still face many difficulties, such as limited accessibility to hardware, perturbation to workloads, and poor time-resolution [6].
Reference: [11] <author> R. Chillarege and N. S. Bowen, </author> <title> "Understanding large system failures | a fault injection experiment," </title> <booktitle> in Proc. IEEE FTCS, </booktitle> <pages> pp. 356-363, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: However, as the complexity of contemporary computer systems increases as a result of using highly-integrated VLSI chips, it is becoming more difficult, or nearly impossible, to evaluate dependability with HFIs alone. On the other hand, software-implemented fault injectors (SFIs) <ref> [10, 11, 12, 13, 14] </ref> have been proposed as less expensive and more controllable alternatives. Although SFI techniques such as overwriting memory or register contents are becoming popular, they still face many difficulties, such as limited accessibility to hardware, perturbation to workloads, and poor time-resolution [6].
Reference: [12] <author> G. Kanawati, N. Kanawati, and J. Abraham, "FERRARI: </author> <title> A tool for the validation of system dependability properties," </title> <booktitle> in Proc. IEEE FTCS, </booktitle> <pages> pp. 336-344. </pages> <publisher> IEEE, </publisher> <year> 1992. </year>
Reference-contexts: However, as the complexity of contemporary computer systems increases as a result of using highly-integrated VLSI chips, it is becoming more difficult, or nearly impossible, to evaluate dependability with HFIs alone. On the other hand, software-implemented fault injectors (SFIs) <ref> [10, 11, 12, 13, 14] </ref> have been proposed as less expensive and more controllable alternatives. Although SFI techniques such as overwriting memory or register contents are becoming popular, they still face many difficulties, such as limited accessibility to hardware, perturbation to workloads, and poor time-resolution [6].
Reference: [13] <author> K. Echtle and M. Leu, </author> <title> "The EFA fault injector for fault-tolerant distributed system testing," </title> <booktitle> in Workshop on Fault-Tolerant Parallel and Distributed Systems, </booktitle> <pages> pp. 28-35. </pages> <publisher> IEEE, </publisher> <year> 1992. </year>
Reference-contexts: However, as the complexity of contemporary computer systems increases as a result of using highly-integrated VLSI chips, it is becoming more difficult, or nearly impossible, to evaluate dependability with HFIs alone. On the other hand, software-implemented fault injectors (SFIs) <ref> [10, 11, 12, 13, 14] </ref> have been proposed as less expensive and more controllable alternatives. Although SFI techniques such as overwriting memory or register contents are becoming popular, they still face many difficulties, such as limited accessibility to hardware, perturbation to workloads, and poor time-resolution [6].
Reference: [14] <author> W. Kao, R. Iyer, and D. Tang, </author> <title> "FINE: A fault injection and monitoring environment for tracing the UNIX system behavior under faults," </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> vol. 19, no. 11, </volume> <pages> pp. 1105-1118, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: However, as the complexity of contemporary computer systems increases as a result of using highly-integrated VLSI chips, it is becoming more difficult, or nearly impossible, to evaluate dependability with HFIs alone. On the other hand, software-implemented fault injectors (SFIs) <ref> [10, 11, 12, 13, 14] </ref> have been proposed as less expensive and more controllable alternatives. Although SFI techniques such as overwriting memory or register contents are becoming popular, they still face many difficulties, such as limited accessibility to hardware, perturbation to workloads, and poor time-resolution [6].
Reference: [15] <author> S. Han, K. G. Shin, and H. Rosenberg, "DOCTOR: </author> <title> An integrateD sOftware fault injeCTiOn enviRonment for distributed real-time systems," </title> <booktitle> in Proc. IEEE IPDS, </booktitle> <pages> pp. 204-213, </pages> <year> 1995. </year>
Reference-contexts: The fault-injection techniques used by DOCTOR are briefly described below. (Details on the fault-injector implementation can be found in <ref> [15] </ref>.) Memory fault: Contents of the cache or main memory are corrupted. The fault-injection target can be either explicitly specified by the user, or chosen randomly from the address space.
Reference: [16] <author> L. Young, C. Alonso, R. Iyer, and K. Goswami, </author> <title> "A hybrid monitor assisted fault injection environment," Dependable Computing for Critical Applications 3, </title> <journal> vol. </journal> <volume> 3, </volume> <pages> pp. 281-302, </pages> <year> 1993. </year>
Reference-contexts: It is a cheaper and more accurate way to achieve the same effect as if all time-stamps are generated by a centralized clock. Young also used a hardware/software hybrid monitor <ref> [16] </ref>, where a commercial logic analyzer 3 In terms of bus arbitration. 8 Timer Controller Input Ports Bus Memory Output Interface Port Backplane bus was used to probe hardware signals and a software monitor checked the system status to assist the control of the hardware monitor.
Reference: [17] <author> A. Indiresan, </author> <title> Exploring Quality-of-Service Issues in Network Interface Design, </title> <type> PhD thesis, </type> <institution> University of Michigan, </institution> <year> 1997. </year>
Reference-contexts: Nodes are not equipped with disks, and application/system software is downloaded from the host machine. 4 For instance, we used HMON for the performance measurement of real-time channel protocol which is used in our experiment <ref> [17] </ref>. 9 NI NP AP HMON VME Bus NI NP AP HMON VME Bus NI NP AP HMON VME Bus Host Node 1 Node 2 Node 3 Ethernet HMON networkFiber network An extended version of the pSOS +m real-time OS [19] is used for AP's system software.
Reference: [18] <institution> Fibre Channel Physical and Signalling Interface (FC-PH), American National Standards Institute, </institution> <note> rev. 3.0 edition, June 1992. Working draft. </note>
Reference-contexts: In each node, a CPU board (labeled as NP) is dedicated to communication processing, while a separate CPU board (labeled as AP) is used for application processing. As a communication fabric between nodes, a network interface board (NI) featuring the ANSI Fiber Channel 3.0 standard <ref> [18] </ref> is equipped with each node. Nodes 1 and 2 are connected by two simplex links (i.e., optical fibers), one in each direction. The same type of connection exists between Node 2 and Node 3.
Reference: [19] <author> L. M. Thompson, </author> <title> "Using pSOS + for embedded real-time computing," </title> <booktitle> in Proc. COMPCON, </booktitle> <pages> pp. 282-288, </pages> <year> 1990. </year>
Reference-contexts: of real-time channel protocol which is used in our experiment [17]. 9 NI NP AP HMON VME Bus NI NP AP HMON VME Bus NI NP AP HMON VME Bus Host Node 1 Node 2 Node 3 Ethernet HMON networkFiber network An extended version of the pSOS +m real-time OS <ref> [19] </ref> is used for AP's system software. The AP-side software is not important in our experiment, since APs run very simple applications which request message delivery to the associated NP, and retrieve the messages received by the NP.
Reference: [20] <author> L. L. Peterson, N. C. Hutchinson, S. W. O`Malley, and H. C. Rao, </author> <title> "The x-Kernel: A platform for accessing internet resources," </title> <journal> IEEE Computer, </journal> <volume> vol. 23, no. 5, </volume> <pages> pp. 23-33, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: The AP-side software is not important in our experiment, since APs run very simple applications which request message delivery to the associated NP, and retrieve the messages received by the NP. NP employs a derivative of x-kernel 3.1 <ref> [20] </ref> as a system executive and a substrate for building the protocol stack. Since NPs do not run user tasks, we disabled the virtual address management of x-kernel. Thus, all tasks in NP are executed within a single (kernel) address space.
Reference: [21] <author> D. Kandlur, K. G. Shin, and D. Ferrari, </author> <title> "Real-time communication in multi-hop networks," </title> <journal> IEEE Trans. Parallel and Distributed Systems, </journal> <volume> vol. 5, no. 10, </volume> <pages> pp. 1044-1056, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: Thus, all tasks in NP are executed within a single (kernel) address space. Memory protection of x-kernel was also disabled to minimize the overhead. (Note that these restrictions are typical of a real-time OS.) Each NP executes the real-time channel protocol described in <ref> [21] </ref>. Figure 5 gives an overview of the NP protocol stack. The protocol stack includes protocols for application program interface (API), network management (NM), remote procedure call (RPC), 5 transport-level fragmentation (FRAG), 6 network/data-link layer (HNET), and the device driver for network interface boards (DD).
Reference: [22] <author> A. Mehra, A. Indiresan, and K. G. Shin, </author> <title> "Resource management for real-time communication: Making theory meet practice," </title> <booktitle> in Proc. IEEE RTAS, </booktitle> <pages> pp. 130-138, </pages> <year> 1996. </year>
Reference-contexts: For this reason, we implemented the run-time message scheduler as a special thread that is created at system startup and runs at the highest-priority level. Implementation details can be found in <ref> [22] </ref>. At the first stage of an experiment, EGM analyzes the executable images of the fault-injection targets, and extracts their symbol/object-code information, and generates experiment parameters such as fault injection scripts (i.e., fault types and injection timings), the start/quit time of each experiment, and so on.
Reference: [23] <author> D. Stott, G. Ries, M. Hsueh, and R. Iyer, </author> <title> "Dependability analysis of a high-speed network using software-implemented fault injection and simulated fault injection," </title> <journal> IEEE Trans. Computers, </journal> <volume> vol. 47, no. 1, </volume> <pages> pp. 108-119, </pages> <year> 1998. </year>
Reference-contexts: Since the fault manifestations will be greatly affected by the types, targets, and injection timings of faults, a representative subset of the real fault population should be injected in order to obtain the representative values. However, the derivation of a representative fault 9 <ref> [23] </ref> reports the occurrence of multiple symptoms with the injection of same faults. 16 Experiment 1 Experiment 2 HNET DD TM CS HNET DD TM CS runs 392 387 393 387 396 398 398 399 Memory cf 28.1% 9.3% 17.8% 15.8% 31.3% 10.3% 16.8% 18.5% ok 0.8% 0.3% 0.0% 0.3% 2.3% <p> The most important contribution of this paper is that we showed that the `near-failure-silence' behavior of network nodes can be achieved without applying expensive redundancy techniques in real-time communication networks. This result contrasts with the previous experimental results on the failure-silence behavior in various application areas <ref> [9, 27, 28, 23, 29] </ref>. Acknowledgments We would like to thank Harold Rosenberg and Jaehyun Park for their contribution in the implementation of DOCTOR. Atri Indiresan provided the skeleton of the real-time channel protocol used in our experiment.
Reference: [24] <author> H. Kopetz and G. Grunsteidl, </author> <title> "TTP a time-triggered protocol for fault-tolerant real-time systems," </title> <booktitle> in Proc. IEEE FTCS, </booktitle> <pages> pp. 524-533, </pages> <year> 1993. </year>
Reference-contexts: In most previous research on dependable real-time communication, even the definition of failures is not clearly given and failures are assumed to be detected immediately upon their occurrence. In <ref> [24, 25, 26] </ref>, the "I am alive" heartbeat method is implicitly assumed to detect all failures, but this assumption is valid only if the network components have the failure-silent characteristic. In general, the failure-silent semantic is difficult to achieve without relying on redundancy.
Reference: [25] <author> A. Banerjea, C. Parris, and D. Ferrari, </author> <title> "Recovering guaranteed performance service connections from single and multiple faults," </title> <type> Technical Report TR-93-066, </type> <institution> UC Berkeley, </institution> <year> 1993. </year> <month> 23 </month>
Reference-contexts: In most previous research on dependable real-time communication, even the definition of failures is not clearly given and failures are assumed to be detected immediately upon their occurrence. In <ref> [24, 25, 26] </ref>, the "I am alive" heartbeat method is implicitly assumed to detect all failures, but this assumption is valid only if the network components have the failure-silent characteristic. In general, the failure-silent semantic is difficult to achieve without relying on redundancy.
Reference: [26] <author> R. Kawamura, K. Sato, and I. Tokizawa, </author> <title> "Self-healing ATM networks based on virtual path concept," </title> <journal> IEEE Journal on Selected Areas in Communications, </journal> <volume> vol. 12, no. 1, </volume> <pages> pp. 120-127, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: In most previous research on dependable real-time communication, even the definition of failures is not clearly given and failures are assumed to be detected immediately upon their occurrence. In <ref> [24, 25, 26] </ref>, the "I am alive" heartbeat method is implicitly assumed to detect all failures, but this assumption is valid only if the network components have the failure-silent characteristic. In general, the failure-silent semantic is difficult to achieve without relying on redundancy.
Reference: [27] <author> M. Rela, H. Madeira, and J. Silva, </author> <title> "Experimental evaluation of the fail-silent behavior in programs with consistency checks," </title> <booktitle> in Proc. IEEE FTCS, </booktitle> <pages> pp. 394-403, </pages> <year> 1996. </year>
Reference-contexts: The most important contribution of this paper is that we showed that the `near-failure-silence' behavior of network nodes can be achieved without applying expensive redundancy techniques in real-time communication networks. This result contrasts with the previous experimental results on the failure-silence behavior in various application areas <ref> [9, 27, 28, 23, 29] </ref>. Acknowledgments We would like to thank Harold Rosenberg and Jaehyun Park for their contribution in the implementation of DOCTOR. Atri Indiresan provided the skeleton of the real-time channel protocol used in our experiment.
Reference: [28] <author> J. Silva, J. Carreira, H. Madeira, D. Costa, and F. Moreira, </author> <title> "Experimental assessment of parallel systems," </title> <booktitle> in Proc. IEEE FTCS, </booktitle> <pages> pp. 415-424, </pages> <year> 1996. </year>
Reference-contexts: The most important contribution of this paper is that we showed that the `near-failure-silence' behavior of network nodes can be achieved without applying expensive redundancy techniques in real-time communication networks. This result contrasts with the previous experimental results on the failure-silence behavior in various application areas <ref> [9, 27, 28, 23, 29] </ref>. Acknowledgments We would like to thank Harold Rosenberg and Jaehyun Park for their contribution in the implementation of DOCTOR. Atri Indiresan provided the skeleton of the real-time channel protocol used in our experiment.

References-found: 28

