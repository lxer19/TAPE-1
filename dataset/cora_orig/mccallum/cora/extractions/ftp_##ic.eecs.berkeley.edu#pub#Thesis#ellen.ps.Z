URL: ftp://ic.eecs.berkeley.edu/pub/Thesis/ellen.ps.Z
Refering-URL: http://www-cad.eecs.berkeley.edu:80/Respep/Research/Thesis/thesis.html
Root-URL: 
Title: Sequential Circuit Synthesis at the Gate Level  
Author: by Ellen Marie Sentovich 
Degree: M.S. (University of California at Berkeley) 1988 A dissertation submitted in partial satisfaction of the requirements for the degree of Doctor of Philosophy in Engineering-Electrical Engineering and Computer Sciences in the GRADUATE DIVISION of the UNIVERSITY of CALIFORNIA at BERKELEY Committee in charge: Professor Robert K. Brayton, Chair Professor Alberto Sangiovanni-Vincentelli Professor Dorit S. Hochbaum  
Date: 1985  1993  
Address: Berkeley)  
Affiliation: B.S. (University of California at  
Abstract-found: 0
Intro-found: 1
Reference: [ABB + 93] <author> A. Aziz, F. Balarin, R.K. Brayton, S.-T. Cheng, R. Hojati, S.C. Krish-nan, R.K. Ranjan, A.L. Sangiovanni-Vincentelli, T.R. Shiple, V. Singhal, S. Tasiran, and H.-Y. Wang. HSIS: </author> <title> A BDD-Based Environment for Formal Verification. </title> <booktitle> In submission, </booktitle> <year> 1993. </year>
Reference-contexts: Each state is symbolic; the transition table indicates the next symbolic state and output bit-vector given a current state and input bit-vector. External don't care conditions are indicated by a missing transition (i.e., a present-state/input combination that 2 A new program called hsis (hierarchical sis) <ref> [ABB + 93] </ref> is currently under development for synthesis of hierarchical netlists. B.3. DESIGN SPECIFICATION 167 astg stg Logic Implementation Mapped Circuit Design Specification Figure B.2: A design is specified as an astg, stg, or logic implementation 168 APPENDIX B.
Reference: [Ake78] <author> S.B. Akers. </author> <title> Binary Decision Diagrams. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-37:509-516, </volume> <month> June </month> <year> 1978. </year>
Reference-contexts: Furthermore, it is difficult to predict this computational "blow-up". The Binary-Decision Diagram (bdd) has recently emerged <ref> [Ake78, Bry86, Bry92] </ref> as an efficient representation for storing and manipulating Boolean functions. A bdd is a dag with a root node for each output function and leaf nodes representing the value of each function for each input minterm.
Reference: [Arm62] <author> D.B. Armstrong. </author> <title> A Programmed Algorithm for Assigning Internal Codes to Sequential Machines. </title> <journal> IRE Transactions on Electronic Computers, </journal> <volume> EC-11(4):466-472, </volume> <month> August </month> <year> 1962. </year>
Reference-contexts: These codes are used to create a logic-level implementation using a register per bit of the binary code, so the encoding has a direct effect on the quality of the implementation. The state assignment problem has been studied periodically for over 30 years <ref> [Arm62, Har61] </ref>, and is one of the classical unsolved problems in logic synthesis. 4 Recently-developed state assignment algorithms attempt to predict the effect of the encoding on the size of the resulting two-level [DBSV85, VSV90] or multilevel [DHLN91, LN89, DMNSV88] implementation.
Reference: [BBH + 88] <author> K.A. Bartlett, R.K. Brayton, G.D. Hachtel, R.M. Jacoby, C.R. Morrison, R.L. Rudell, A.L. Sangiovanni-Vincentelli, and A.R. Wang. </author> <title> Multi-level Logic Minimization Using Implicit Don't Cares. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> CAD-7(6):723-740, </volume> <month> June </month> <year> 1988. </year>
Reference-contexts: Here, flexibility means choice in the actual function implemented (as opposed to choice in how that function is implemented). Flexibility in various forms has been studied extensively, 122 CHAPTER 6. FLEXIBILITY IN BOOLEAN FUNCTIONS and includes don't care conditions for optimization of combinational <ref> [BHMSV84, BBH + 88, MKLC89, Sav92] </ref> and sequential [DM92a, RHS91] two-level and multilevel circuits as single entities (each output can be optimized independently), Boolean relations [BS89b, BS89a, WB91] which express relationships between outputs and are derived from the surrounding environment, and synchronous recurrence equations [DM92b] for optimization of sequential circuits in
Reference: [BCM90] <author> J.R. Burch, E.M. Clarke, and K. McMillan. </author> <title> Symbolic Model Checking: 10 20 States and Beyond. </title> <booktitle> In The 5th Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 428-439, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: The canonicity property of bdds, efficient bdd package implementation [BRB90, Lon93], and recent improvements in variable ordering strategies [Rud93a] have made bdd-based algorithms successful for verification at various levels of the design process <ref> [MWBSV88, FFK88, CMB90, BCM90, TSL + 90, HTKB92] </ref>. Quite large circuits have been successfully verified (e.g., a 12x12 multiplier has been verified within a 32Mbyte memory limit [Rud93b], despite the inherent difficulty in representing multipliers using bdds [Bry92]). <p> Implicit State Enumeration Efficient methods for implicitly enumerating the states in a finite state machine have recently been reported and can be used to explore the state space of very large designs <ref> [CMB90, BCM90, TSL + 90] </ref>. They proceed by breadth-first traversal of sets of states of a machine. Efficient implementation requires careful computation of the transition relation (present-state/next-state relation) and the current set of states. Each function is efficiently implemented and manipulated using bdds.
Reference: [BCW80] <author> M.W. Blum, A.K. Chandra, </author> <title> and M.N. Wegman. Equivalence of Free Boolean Graphs can be decided Probabilistically in Polynomial Time. </title> <journal> Information Processing Letters, </journal> <volume> 10(2) </volume> <pages> 80-82, </pages> <month> March </month> <year> 1980. </year>
Reference-contexts: Current research efforts include new variable ordering strategies, a multitude of new applications for bdds, extensions of bdds to represent integer functions [CFM + 93, BFG + 93], exploration of free bdds that are not ordered and are more compact <ref> [BCW80, GM94, SDG93] </ref>, and a novel modification called the zero-suppressed bdd for efficient representation of sets [Min93b, Min93a]. 2.1.6 Image Computation and Characteristic Functions Many algorithms for Boolean function manipulation rely on an efficient computation of the set of output minterms produced by a particular set of input minterms.
Reference: [BFG + 93] <author> R.I. Bahar, E.A. Frohm, C.M. Gaona, G.D. Hachtel, E. Macii, A. Pardo, and F. Somenzi. </author> <title> Algebraic Decision Diagrams and their Applications. </title> <booktitle> In 176 BIBLIOGRAPHY Proceedings of the IEEE International Conference on Computer-Aided Design, </booktitle> <pages> pages 188-191, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: Current research efforts include new variable ordering strategies, a multitude of new applications for bdds, extensions of bdds to represent integer functions <ref> [CFM + 93, BFG + 93] </ref>, exploration of free bdds that are not ordered and are more compact [BCW80, GM94, SDG93], and a novel modification called the zero-suppressed bdd for efficient representation of sets [Min93b, Min93a]. 2.1.6 Image Computation and Characteristic Functions Many algorithms for Boolean function manipulation rely on an
Reference: [BHMSV84] <author> R.K. Brayton, G.D. Hachtel, C.T. McMullen, and A.L. Sangiovanni-Vincentelli. </author> <title> Logic Minimization Algorithms for VLSI Synthesis. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1984. </year>
Reference-contexts: Flexibility for two-level optimization takes the form of don't care conditions which are conditions on the input signals under which the outputs are allowed to take either Boolean value. Efficient and effective techniques for both exact [Qui52, McC56, Rud89, MSBSV93] and heuristic <ref> [BHMSV84] </ref> methods for obtaining a minimal-row pla (minimal-product-term function) have been developed. Two-level logic optimization is now considered a standard procedure and is used extensively in logic synthesis systems. Multilevel logic optimization is not as well-developed or well-understood. <p> There are several sources of flexibility which depend on the type of circuit and the structure of the functions used during logic synthesis. Don't care conditions have historically been used to capture the flexibility in implementing combinational functions. Don't cares are exploited in two-level logic optimization programs <ref> [BHMSV84] </ref>. The don't cares at this level are usually user-specified, or external don't cares. They may be derived from the environment surrounding the two-level circuit. A multilevel Boolean network may be optimized by simplifying the two-level function at each node using a two-level logic optimization program. <p> In addition, d z 1 should be re-expressed in terms of the input variables (y 1 , y 2 ) of z 1 . (Standard two-level minimization, e.g., espresso <ref> [BHMSV84] </ref>, requires the ON-set and DC-set to be expressed in terms of the same set of variables.) 28 CHAPTER 3. AUXILIARY FUNCTIONS x 1 y 1 z 1 d y 1 = x 1 x 2 This chapter addresses the problem of manipulating auxiliary functions in combinational and sequential circuits. <p> they are simulated to obtain the next state, this next state may not be in the set of next states reachable from the original initial state function. 61 Chapter 4 An Exact Optimization of Sequential Circuits Exact techniques for optimizing two-level combinational circuits are useful for producing optimum pla implementations <ref> [BHMSV84] </ref>, for solving subproblems in multilevel logic optimization [BRSVW87], and for producing good initial implementations for multilevel optimization. Exact techniques for acyclic sequential circuits can provide a means of local optimization for multilevel sequential circuits, as well as a measure of the quality of a sequential circuit implementation. <p> Since the number of inputs and outputs (columns) is fixed, area is minimized by minimizing the number of implicants (rows, or and gates). As a secondary optimization criterion, the number of transistors in the arrays is minimized. The solutions for both the heuristic algorithm presented in <ref> [BHMSV84] </ref> and the traditional exact algorithm reported in [McC65] are prime (no transistor connection can be removed from the input array) and irredundant (no row of the input array can be removed). <p> No constraints have been placed on the number or location of the registers. The problem of minimizing the number of registers is addressed in Section 4.8.2. 4.3 Synchronous Boolean Functions A synchronous Boolean function is similar to a combinational Boolean function (defined precisely in <ref> [BHMSV84] </ref>), with an extension to the input space to allow expression of the sequential nature of the function. 4.3.1 Definition Definition 4.3.1 Let B = f0; 1g, R = f0; 1; : : :; rg and D = f0; 1; 2g. <p> COMBINATIONAL OPERATIONS ON SYNCHRONOUS CUBES 71 4.4 Combinational Operations on Synchronous Cubes Definitions for combinational operations on synchronous minterms and cubes are given in this section. The synchronous variables are treated as independent variables, so the definitions closely follow those in <ref> [BHMSV84] </ref>. 4.4.1 Multioutput Cube Notation In [BHMSV84], each cube is represented by an integer vector with an input part and an output part. The input part represents an implicant; the output part indicates for which functions the implicant is valid. <p> COMBINATIONAL OPERATIONS ON SYNCHRONOUS CUBES 71 4.4 Combinational Operations on Synchronous Cubes Definitions for combinational operations on synchronous minterms and cubes are given in this section. The synchronous variables are treated as independent variables, so the definitions closely follow those in <ref> [BHMSV84] </ref>. 4.4.1 Multioutput Cube Notation In [BHMSV84], each cube is represented by an integer vector with an input part and an output part. The input part represents an implicant; the output part indicates for which functions the implicant is valid. <p> They are summarized here for reference as some will be used and extended to the synchronous domain in the following section. The full definitions can be found in <ref> [BHMSV84] </ref>. Let c, d, and e be cubes in the Boolean space (B fi R) n , and c j j j literals of cubes c, d, and e respectively. 72 CHAPTER 4. <p> and d otherwise, e = c d in the input part except in the one position i where the conflict occurs: there e i = 2; the output part of e is the union of the output parts of c and d 3 This differs slightly from the definition in <ref> [BHMSV84] </ref>. That definition of consensus, e = c " d when ffi (c; d) = 0, will not produce all primes when iterated. 4.5. SYNCHRONOUS OPERATIONS ON SYNCHRONOUS CUBES 73 Note that cfid c [d as proven in [BHMSV84]. Examples: [12034]fi [01244] = [21034]; [12034] fi [11243] = [11044]. <p> of c and d 3 This differs slightly from the definition in <ref> [BHMSV84] </ref>. That definition of consensus, e = c " d when ffi (c; d) = 0, will not produce all primes when iterated. 4.5. SYNCHRONOUS OPERATIONS ON SYNCHRONOUS CUBES 73 Note that cfid c [d as proven in [BHMSV84]. Examples: [12034]fi [01244] = [21034]; [12034] fi [11243] = [11044]. Consensus is used to generate all primes. <p> Since f is unate, all primes can be found by removing any cube in f that is contained by any other single cube <ref> [BHMSV84] </ref>. All the primes in f will have the form x i : : : x j , indicating that any cube not containing all of x i : : : x j is a compatible. <p> Here, flexibility means choice in the actual function implemented (as opposed to choice in how that function is implemented). Flexibility in various forms has been studied extensively, 122 CHAPTER 6. FLEXIBILITY IN BOOLEAN FUNCTIONS and includes don't care conditions for optimization of combinational <ref> [BHMSV84, BBH + 88, MKLC89, Sav92] </ref> and sequential [DM92a, RHS91] two-level and multilevel circuits as single entities (each output can be optimized independently), Boolean relations [BS89b, BS89a, WB91] which express relationships between outputs and are derived from the surrounding environment, and synchronous recurrence equations [DM92b] for optimization of sequential circuits in <p> A single solution is given by the description itself, and an optimal implementation is obtained by using standard two-level minimization techniques (e.g., <ref> [BHMSV84] </ref>). (While completely specified functions can be represented in multilevel form, this introduces new variables which in turn introduces some don't care conditions inherent in the representation. <p> Thus, it might be better to minimize the synchronous relation directly. [SWB93] have presented a heuristic method to optimize synchronous relations directly. They have represented and manipulated both the synchronous relation and the compatible function implicitly using bdds.Their basic methodology is based on the espresso paradigm <ref> [BHMSV84] </ref> which manipulates one product term at a time, maintaining compatibility with the desired specification and reducing cost greedily. It is instructive to examine the relationship between the multiple Boolean relations and the depth d required to represent them as a synchronous relation. <p> Its development began in the Spring of 1989 as part of a graduate research course in logic synthesis. At that time, state-of-the-art synthesis tools at Berkeley included combinational tools such as espresso <ref> [BHMSV84] </ref> and misii [BRSVW87], and state assignment programs such as mustang [DMNSV88] and kiss [DBSV85]. There was no connection between the combinational and sequential tools: logic gates and state registers had to be treated separately during optimization and technology mapping.
Reference: [BHSV90] <author> R.K. Brayton, G.D. Hachtel, and A.L. Sangiovanni-Vincentelli. </author> <title> Multilevel Logic Synthesis. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 78(2) </volume> <pages> 264-300, </pages> <month> February </month> <year> 1990. </year>
Reference-contexts: The goal is to create a technology-independent representation of a set of Boolean functions in multilevel form based on some optimization criteria. Many techniques have been developed for creating and manipulating multilevel Boolean functions under various optimization criteria. An exposition on state-of-the-art multilevel logic synthesis techniques is contained in <ref> [BHSV90] </ref>. Multilevel logic optimization is inherently more difficult than two-level because of the additional degrees of freedom afforded the implementation.
Reference: [BRB90] <author> K. Brace, R. Rudell, and R. Bryant. </author> <title> Efficient Implementation of a BDD Package. </title> <booktitle> In Proceedings of the 27 th Design Automation Conference, </booktitle> <pages> pages 40-45, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Verification (f g?) requires a graph isomorphism check, and since bdds are rooted dags this is linear in the number of nodes in the bdds. The canonicity property of bdds, efficient bdd package implementation <ref> [BRB90, Lon93] </ref>, and recent improvements in variable ordering strategies [Rud93a] have made bdd-based algorithms successful for verification at various levels of the design process [MWBSV88, FFK88, CMB90, BCM90, TSL + 90, HTKB92].
Reference: [BRSVW87] <author> R.K. Brayton, R. Rudell, A.L. Sangiovanni-Vincentelli, and A.R. Wang. </author> <title> MIS: A Multiple-Level Logic Optimization System. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> CAD-6(6):1062-1081, </volume> <month> November </month> <year> 1987. </year>
Reference-contexts: PRESERVING DON'T CARES DURING RETIMING 55 If the input registers move backward, the old inputs become internal nodes. The node simplification algorithm may allow the don't care functions to be expressed in terms of internal nodes, in which case no modification is necessary. (In misii <ref> [BRSVW87] </ref> and sis [SSM + 92], the SDC is used in tandem with the ODC and external can't happens during node simplification, so there is no need to express the don't cares in terms of inputs to the logic block. <p> this next state may not be in the set of next states reachable from the original initial state function. 61 Chapter 4 An Exact Optimization of Sequential Circuits Exact techniques for optimizing two-level combinational circuits are useful for producing optimum pla implementations [BHMSV84], for solving subproblems in multilevel logic optimization <ref> [BRSVW87] </ref>, and for producing good initial implementations for multilevel optimization. Exact techniques for acyclic sequential circuits can provide a means of local optimization for multilevel sequential circuits, as well as a measure of the quality of a sequential circuit implementation. <p> Its development began in the Spring of 1989 as part of a graduate research course in logic synthesis. At that time, state-of-the-art synthesis tools at Berkeley included combinational tools such as espresso [BHMSV84] and misii <ref> [BRSVW87] </ref>, and state assignment programs such as mustang [DMNSV88] and kiss [DBSV85]. There was no connection between the combinational and sequential tools: logic gates and state registers had to be treated separately during optimization and technology mapping. <p> An overview of the structure of sis is given in this section: its origins, programmatic structure, and sequential circuit model. B.2.1 misii misii is a multilevel combinational logic optimization tool <ref> [BRSVW87] </ref>. sis is built directly on top of misii, so the data structures and program structure are similar. A digital circuit is represented as a Boolean network comprised of primary inputs, primary outputs, and internal nodes that each have an associated logic function.
Reference: [Bry86] <author> R.E. Bryant. </author> <title> Graph-Based Algorithms for Boolean Function Manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-35(8):677-691, </volume> <month> August </month> <year> 1986. </year>
Reference-contexts: Furthermore, it is difficult to predict this computational "blow-up". The Binary-Decision Diagram (bdd) has recently emerged <ref> [Ake78, Bry86, Bry92] </ref> as an efficient representation for storing and manipulating Boolean functions. A bdd is a dag with a root node for each output function and leaf nodes representing the value of each function for each input minterm.
Reference: [Bry92] <author> R.E. Bryant. </author> <title> Symbolic Boolean Manipulation with Ordered Binary-Decision Diagrams. </title> <journal> ACM Computing Surveys, </journal> <volume> 24(3) </volume> <pages> 293-318, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: Furthermore, it is difficult to predict this computational "blow-up". The Binary-Decision Diagram (bdd) has recently emerged <ref> [Ake78, Bry86, Bry92] </ref> as an efficient representation for storing and manipulating Boolean functions. A bdd is a dag with a root node for each output function and leaf nodes representing the value of each function for each input minterm. <p> Quite large circuits have been successfully verified (e.g., a 12x12 multiplier has been verified within a 32Mbyte memory limit [Rud93b], despite the inherent difficulty in representing multipliers using bdds <ref> [Bry92] </ref>).
Reference: [BS89a] <author> R.K. Brayton and F. Somenzi. </author> <title> An Exact Minimizer for Boolean Relations. </title> <booktitle> In Proceedings of the IEEE International Conference on Computer-Aided Design, </booktitle> <pages> pages 316-319, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: A single solution to a Boolean relation is found by selecting a function for one output, and successively choosing functions for the remaining outputs while satisfying the constraints between outputs. Both exact <ref> [BS89a] </ref> and heuristic [WB91] techniques for finding optimum and optimal solutions based on two-level implementations have been published. These techniques are similar to two-level minimization techniques. 2.2.5 Observability Relation The observability relation, or network characteristic function, has been described and used in [Cer77, Sav92]. <p> Flexibility in various forms has been studied extensively, 122 CHAPTER 6. FLEXIBILITY IN BOOLEAN FUNCTIONS and includes don't care conditions for optimization of combinational [BHMSV84, BBH + 88, MKLC89, Sav92] and sequential [DM92a, RHS91] two-level and multilevel circuits as single entities (each output can be optimized independently), Boolean relations <ref> [BS89b, BS89a, WB91] </ref> which express relationships between outputs and are derived from the surrounding environment, and synchronous recurrence equations [DM92b] for optimization of sequential circuits in the context of continuous operation over time. <p> A single solution to a Boolean relation is found by selecting a function for one output, and successively choosing functions for the remaining outputs while satisfying the constraints between outputs. Both exact <ref> [BS89a] </ref> and heuristic [WB91] techniques for finding optimum and optimal solutions based on two-level implementations have been published. These techniques are similar to two-level minimization techniques. 6.3 Multiple Boolean Relations Multiple Boolean relations can arise in several ways as discussed in Section 6.1. <p> Boolean Function of Multivalued Variables As a result of Theorem 6.3.2, prime relations of M are obtained from the primes of f mv . Minimizing f mv using espresso-mv [RSV87] yields a minimum set of prime relations. An exact Boolean relations minimizer such as <ref> [BS89a] </ref> or a heuristic minimizer such as gyocro [WB91] is called on each Boolean relation (each product term in f mv ) to find a minimal function satisfying the Boolean relation, and the minimum of these over all Boolean relations is taken as the best solution. <p> Note that this provides a new way of finding an exact minimum solution to a single Boolean relation: form the binary-valued function representation, find the prime incompletely specified functions, and find the minimum solution to each. For some problems, this method may be faster than <ref> [BS89a] </ref> while providing a better solution than [WB91]; however, the number of prime incompletely specified functions may be prohibitively large. For the MBR in Figure 6.4, the two Boolean relations (which constitute all prime relations) represent 16 functions and 6 prime incompletely specified functions.
Reference: [BS89b] <author> R.K. Brayton and F. Somenzi. </author> <title> Boolean Relations and the Incomplete Specification of Logic Networks. </title> <booktitle> In Proceedings of the International Conference on VLSI'89, </booktitle> <address> Munich, </address> <month> August </month> <year> 1989. </year>
Reference-contexts: Flexibility in various forms has been studied extensively, 122 CHAPTER 6. FLEXIBILITY IN BOOLEAN FUNCTIONS and includes don't care conditions for optimization of combinational [BHMSV84, BBH + 88, MKLC89, Sav92] and sequential [DM92a, RHS91] two-level and multilevel circuits as single entities (each output can be optimized independently), Boolean relations <ref> [BS89b, BS89a, WB91] </ref> which express relationships between outputs and are derived from the surrounding environment, and synchronous recurrence equations [DM92b] for optimization of sequential circuits in the context of continuous operation over time. <p> Recall from <ref> [BS89b] </ref> that a function f : B n ! B m is compatible with a Boolean relation R, f / R, if and only if 8x i 2 B n , (x i ; z i ) 2 R, where z i = f (x i ).
Reference: [CBM89] <author> O. Coudert, C. Berthet, and J.C. Madre. </author> <title> Verification of Sequential Machines Based on Symbolic Execution. In Proceedings of the Workshop on Automatic Verification Methods for Finite State Systems, </title> <address> Grenoble, France, </address> <year> 1989. </year>
Reference-contexts: This information is ambiguous because its origins are unknown. Nevertheless, some synthesis and verification algorithms depend on the fact that the circuit will begin precisely in the given initial state (e.g., <ref> [CBM89, TB93] </ref>). If the circuit is surrounded by reset circuitry that will indeed reset the circuit to the initial state, then this assumption is valid. A more general approach makes no assumptions about a particular initial state and instead allows the circuit to power-up in any state.
Reference: [Cer77] <author> E. Cerny. </author> <title> An Approach to Unified Methodology of Combinational Switching Circuits. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-26(8):745-756, </volume> <month> August </month> <year> 1977. </year> <note> BIBLIOGRAPHY 177 </note>
Reference-contexts: Both exact [BS89a] and heuristic [WB91] techniques for finding optimum and optimal solutions based on two-level implementations have been published. These techniques are similar to two-level minimization techniques. 2.2.5 Observability Relation The observability relation, or network characteristic function, has been described and used in <ref> [Cer77, Sav92] </ref>. It is a characteristic function O : B n+m ! B which specifies all allowed output vectors for each input vector of the circuit. It is capable of expressing all types of don't cares and Boolean relations, but in practice is usually too large to build and manipulate. <p> When network N 2 is connected to N 1, the don't cares in N 1 should be propagated to N 2 to optimize that network. Using the observability relation <ref> [Cer77, Sav92] </ref> to propagate the don't cares: OBS = S y i=1 y i f i + y i f i + d y i i=1 ) d z 1 = @z 1 d z 2 = @z 2 3.2.
Reference: [CFM + 93] <author> E. Clarke, M. Fujita, P. McGeer, K. McMillan, J. Yang, and X. Zhao. </author> <title> Multi-Terminal Binary Decision Diagrams: An Efficient Data Structure for Matrix Representation. </title> <booktitle> In Proceedings of the International Workshop on Logic Synthesis, </booktitle> <address> Tahoe City, California, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: Current research efforts include new variable ordering strategies, a multitude of new applications for bdds, extensions of bdds to represent integer functions <ref> [CFM + 93, BFG + 93] </ref>, exploration of free bdds that are not ordered and are more compact [BCW80, GM94, SDG93], and a novel modification called the zero-suppressed bdd for efficient representation of sets [Min93b, Min93a]. 2.1.6 Image Computation and Characteristic Functions Many algorithms for Boolean function manipulation rely on an
Reference: [Chu87] <author> Tam-Anh Chu. </author> <title> Synthesis of Self-timed VLSI Circuits from Graph-theoretic Specifications. </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <month> June </month> <year> 1987. </year>
Reference-contexts: Other methods of input are by reading from the Oct database, and through a sequential circuit netlist called slif (Stanford Logic Interchange Format) [DeM89]. For asynchronous circuits, the input is a signal transition graph <ref> [Chu87, RY85] </ref>. The logic implementation (or netlist description) is given in extended blif (Berke-ley Logic Interchange Format) which consists of interconnected single-output combinational gates and latches. The blif format used in misii has been augmented to allow the specification of latches and controlling clocks.
Reference: [CMB90] <author> O. Coudert, J.C. Madre, and C. Berthet. </author> <title> Verifying Temporal Properties of Sequential Machines without Building their State Diagrams. </title> <booktitle> In Computer-Aided Verification '90, </booktitle> <pages> pages 75-84, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: The canonicity property of bdds, efficient bdd package implementation [BRB90, Lon93], and recent improvements in variable ordering strategies [Rud93a] have made bdd-based algorithms successful for verification at various levels of the design process <ref> [MWBSV88, FFK88, CMB90, BCM90, TSL + 90, HTKB92] </ref>. Quite large circuits have been successfully verified (e.g., a 12x12 multiplier has been verified within a 32Mbyte memory limit [Rud93b], despite the inherent difficulty in representing multipliers using bdds [Bry92]). <p> Implicit State Enumeration Efficient methods for implicitly enumerating the states in a finite state machine have recently been reported and can be used to explore the state space of very large designs <ref> [CMB90, BCM90, TSL + 90] </ref>. They proceed by breadth-first traversal of sets of states of a machine. Efficient implementation requires careful computation of the transition relation (present-state/next-state relation) and the current set of states. Each function is efficiently implemented and manipulated using bdds.
Reference: [DBSV85] <author> G. DeMicheli, R.K. Brayton, and A. Sangiovanni-Vincentelli. </author> <title> Optimal State Assignment for Finite State Machines. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> 4(3) </volume> <pages> 269-285, </pages> <month> July </month> <year> 1985. </year>
Reference-contexts: The state assignment problem has been studied periodically for over 30 years [Arm62, Har61], and is one of the classical unsolved problems in logic synthesis. 4 Recently-developed state assignment algorithms attempt to predict the effect of the encoding on the size of the resulting two-level <ref> [DBSV85, VSV90] </ref> or multilevel [DHLN91, LN89, DMNSV88] implementation. These techniques are fairly successful for small machines, but break down on large, automatically generated machines. One exact algorithm has been proposed [DN91] but is impractical for all but the smallest circuits. <p> Its development began in the Spring of 1989 as part of a graduate research course in logic synthesis. At that time, state-of-the-art synthesis tools at Berkeley included combinational tools such as espresso [BHMSV84] and misii [BRSVW87], and state assignment programs such as mustang [DMNSV88] and kiss <ref> [DBSV85] </ref>. There was no connection between the combinational and sequential tools: logic gates and state registers had to be treated separately during optimization and technology mapping. Many of the research projects in the course involved exploration of new sequential optimization algorithms that consider logic and state together.
Reference: [DD91] <author> M. Damiani and G. DeMicheli. </author> <title> Derivation of Don't Care Conditions by Perturbation Analysis of Combinational Multiple-Level Logic Circuits. </title> <booktitle> In Proceedings of the International Workshop on Logic Synthesis, </booktitle> <address> North Carolina, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: These ideas were extended in [SB90, SBT91] and applied to general multilevel networks. In <ref> [Sav92, DD91] </ref>, algorithms are given for efficient computation of mspfs and maximal cspfs. Beginning at the outputs with the external don't cares and working towards the inputs, cspfs are computed at each node and can be used in the simplification of that node simultaneously with simplifying other nodes. 2.2.
Reference: [DeM89] <author> G. DeMicheli. </author> <title> Synchronous Logic Synthesis. </title> <booktitle> In Proceedings of the International Workshop on Logic Synthesis, </booktitle> <address> North Carolina, </address> <month> May </month> <year> 1989. </year>
Reference-contexts: The two most common entry points are a netlist of gates and a finite state machine in state-transition-table form. Other methods of input are by reading from the Oct database, and through a sequential circuit netlist called slif (Stanford Logic Interchange Format) <ref> [DeM89] </ref>. For asynchronous circuits, the input is a signal transition graph [Chu87, RY85]. The logic implementation (or netlist description) is given in extended blif (Berke-ley Logic Interchange Format) which consists of interconnected single-output combinational gates and latches.
Reference: [DeM91] <author> G. DeMicheli. </author> <title> Synchronous Logic Synthesis: Algorithms for Cycle-Time Minimization. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> CAD-10(1):63-73, </volume> <month> January </month> <year> 1991. </year>
Reference-contexts: Enhancements to retiming 1.3. OVERVIEW 9 have been proposed, e.g., [DPR92], that perform simple logic restructuring operations to permit additional register movement. Various techniques for combining register movement and logic restructuring have been proposed recently. In <ref> [DeM91] </ref>, combinational techniques for successively extracting and eliminating common factors are extended to "look across" register boundaries. This approach was given a more formal framework in [Lin93], where synchronous kernel generation is used to find synchronous factors. <p> The reason for this is that one open question in the area of gate-level sequential circuit optimization has been the utility of algorithms that exploit sharing of logic across several time frames. Results reported thus far <ref> [MSBSV91, DeM91] </ref> have suggested that logic functions of this form are uncommon in real circuits. <p> This chapter address the problem of implementing optimal, multilevel, acyclic sequential circuits, and hence completes the treatment of gate-level sequential circuit optimization. 5.1 Introduction In <ref> [DeM91] </ref>, standard combinational techniques (factor extraction, resubstitution, elimination) are extended to sequential circuits. Application of these techniques yielded good results for cycle-time optimization, but very few improvements for area optimization. <p> Such an algorithm would automatically break feedback arcs, contain parameters for controlling node duplication, contain a method for determining feasible circuits for duplication as mentioned in Section 5.5, and use the exact two-level algorithm for node minimization. Experimentation with this and other techniques <ref> [MSBSV91, DeM91, Lin93] </ref> would provide valuable insight into the overall sequential circuit optimization process, and only then could effective automatic scripts for optimizing such circuits (such as those that have been so successful in misii) be developed.
Reference: [Dev89] <author> S. Devadas. </author> <title> Approaches to Multi-Level Sequential Logic Synthesis. </title> <booktitle> In Proceedings of the 26 th Design Automation Conference, </booktitle> <pages> pages 270-276, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: In [KN72], input don't care sequences are derived from two cascaded interacting state machines and used to minimize the states in a state transition graph. This approach is also used in <ref> [Dev89] </ref>, where subsets of input don't care sequences are used, and in [RHS91] where bidirectional communicating state machines are considered. More recently, in [WB93a] the complete input don't care sequences are derived for bidirectional interacting machines. No similar work has been done for output don't care sequences.
Reference: [Dev91] <author> S. Devadas. </author> <title> Optimizing Interacting Finite State Machines Using Sequential Don't Cares. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> 10(12) </volume> <pages> 1473-1484, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: This limited controllability and observability respectively can be captured as input and output don't care sequences and used to minimize the number of states in the machine. A subset of input don't care sequences is extracted and used for optimization in <ref> [Ung69, Dev91] </ref>. More recently, algorithms have been published for extracting and exploiting the complete set of input don't care sequences for both cascade [KN72] and bidirectional communicating fsms [RHS91, WB93b]. Full efficient utilization of output don't care sequences is still an unsolved problem.
Reference: [DHLN91] <author> X. Du, G. Hachtel, B. Lin, and A.R. </author> <title> Newton. MUSE: A MUltilevel Symbolic Encoding Algorithm for State Assignment. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> 10(1) </volume> <pages> 28-38, </pages> <month> January </month> <year> 1991. </year> <note> 178 BIBLIOGRAPHY </note>
Reference-contexts: The state assignment problem has been studied periodically for over 30 years [Arm62, Har61], and is one of the classical unsolved problems in logic synthesis. 4 Recently-developed state assignment algorithms attempt to predict the effect of the encoding on the size of the resulting two-level [DBSV85, VSV90] or multilevel <ref> [DHLN91, LN89, DMNSV88] </ref> implementation. These techniques are fairly successful for small machines, but break down on large, automatically generated machines. One exact algorithm has been proposed [DN91] but is impractical for all but the smallest circuits. State machine decomposition is used to split large state machines into several interacting machines.
Reference: [DM92a] <author> M. Damiani and G. De Micheli. </author> <title> Don't Care Set Specifications in Combinational and Synchronous Logic Circuits. </title> <type> Technical Report CSL-TR-92-531, </type> <institution> Stanford University, Computer Systems Laboratory, Stanford, </institution> <address> CA 94305-4055, </address> <month> July </month> <year> 1992. </year>
Reference-contexts: In particular, don't care conditions based on unreachable states and Boolean relations based on equivalent states are extracted and used with existing combinational logic optimization programs in [LTN90]. Sequential don't care conditions based on the structure of a network are described in <ref> [DM92a] </ref>. These include both don't cares that are similar to the various don't cares derived for a combinational Boolean network (these are detailed in Section 2.2) and don't care sequences. <p> Equivalent states are static Boolean relations which can be exploited using a Boolean relations minimizer, or in simple cases using a combinational logic optimizer. Logic-level sequential don't care conditions analogous to the SDC and ODC combinational don't cares are derived and used in <ref> [DM92a] </ref>. In [KN72], input don't care sequences are derived from two cascaded interacting state machines and used to minimize the states in a state transition graph. <p> Flexibility in various forms has been studied extensively, 122 CHAPTER 6. FLEXIBILITY IN BOOLEAN FUNCTIONS and includes don't care conditions for optimization of combinational [BHMSV84, BBH + 88, MKLC89, Sav92] and sequential <ref> [DM92a, RHS91] </ref> two-level and multilevel circuits as single entities (each output can be optimized independently), Boolean relations [BS89b, BS89a, WB91] which express relationships between outputs and are derived from the surrounding environment, and synchronous recurrence equations [DM92b] for optimization of sequential circuits in the context of continuous operation over time.
Reference: [DM92b] <author> M. Damiani and G. De Micheli. </author> <title> Recurrence Equations and the Optimization of Synchronous Logic Circuits. </title> <booktitle> In Proceedings of the 29 th Design Automation Conference, </booktitle> <pages> pages 556-561, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: This can be discovered by a simple topological scan of the network. After removing these latches and other gates that do not effect the outputs, the outputs are trivially determined to be 0. 102 CHAPTER 5. OPTIMIZATION OF MULTILEVEL SYNCHRONOUS CIRCUITS A method is given in <ref> [DM92b] </ref> for extracting and optimizing synchronous recurrence equations. These equations express all the functions that can be implemented at a node in a synchronous network without changing the behavior of the overall network. This is potentially a very powerful technique, but computationally expensive. <p> there may be portions of the network that are independent (i.e., that contain inputs and outputs that are not transitively in the fanin or fanout of any other nodes in the network). 5.3 Maximal Peripheral Retiming A small circuit that is difficult to optimize with standard techniques is given in <ref> [DM92b] </ref> and shown in Figure 5.1 (a). Peripheral retiming cannot be performed since there are two paths from input x to output z with different path lengths, 0 and 1. <p> care conditions for optimization of combinational [BHMSV84, BBH + 88, MKLC89, Sav92] and sequential [DM92a, RHS91] two-level and multilevel circuits as single entities (each output can be optimized independently), Boolean relations [BS89b, BS89a, WB91] which express relationships between outputs and are derived from the surrounding environment, and synchronous recurrence equations <ref> [DM92b] </ref> for optimization of sequential circuits in the context of continuous operation over time. A multiple Boolean relation (MBR) is a set of Boolean relations that encompasses all possible flexibility in choosing the functions to be implemented. It is a way of representing any collection of multioutput functions. <p> Each output function is chosen independent of the others. This can be viewed as choosing an output minterm for a given input minterm with the restriction that the choices over all input minterms are not independent. As Damiani et al. observed in <ref> [DM92b] </ref> in the context of synchronous recurrence equations, the inputs are correlated. <p> The goal is to optimize a subcircuit using information from the surrounding logic. The flexibility in the input/output specification for the subcircuit can be completely specified in terms of finite sequential input/output traces. Damiani and De Micheli <ref> [DM92b] </ref> have demonstrated how one can derive such traces (which they call synchronous recurrence equations). The depth of these traces is no greater than the number of latches in the surrounding logic. <p> The synchronous relation represents a set of functions which cannot be represented using an ordinary Boolean relation. Synchronous relations can be converted to a Boolean function of Boolean variables as done in <ref> [DM92b] </ref>. That method will be described in more detail in Section 6.4. If the number of latches in the surrounding logic is small, or if only a partial optimization is desired (only part of the solution space is considered), the depth of the synchronous relation can be small. <p> In [KF92], the constraints are merged directly into the Boolean relation by variable substitution. For this particular type of constraint, merging is more practical than enumerating constraints and intersecting them with the Boolean relation. 6.4.2 Synchronous Recurrence Equations In <ref> [DM92b] </ref>, the notion of synchronous recurrence equations is used to optimize sequential subnetworks at the gate level. The goal is to reimplement a subnetwork in an 142 CHAPTER 6. FLEXIBILITY IN BOOLEAN FUNCTIONS optimal way, given information about the environment. <p> Solution <ref> [DM92b] </ref>: 1. Form a Boolean relation between the inputs x and the intermediate variables y that represents all valid conditions in which the terminal behavior is unchanged. 2. <p> In particular, the depth d is chosen for both the input and output variables; the larger the depth value, the greater the amount of flexibility in implementation. See <ref> [DM92b] </ref> for a detailed explanation. In the example in Figure 6.7 [DM92b], the goal is to reimplement y n without chang ing the behavior at z. <p> In particular, the depth d is chosen for both the input and output variables; the larger the depth value, the greater the amount of flexibility in implementation. See <ref> [DM92b] </ref> for a detailed explanation. In the example in Figure 6.7 [DM92b], the goal is to reimplement y n without chang ing the behavior at z. The terminal behavior is z = x n2 2 (x n1 2 ) which is expressed in terms of y n as z = x n1 2 + x n1 6.4. <p> that the function used to implement y n , which for this example is chosen to be f (x n 1 ; x n1 2 ), must be the same as that selected for y n1 time-shifted by one: y n1 = f (x n1 1 ; x n2 In <ref> [DM92b] </ref>, the function K is built by assigning a new variable to each input minterm for each output, and generating constraints directly from the Boolean relation. <p> From Example 6.4.1, line 2 of the relation table, if f is chosen to be 1 at x n 2 = 0, x n1 2 = 1, then f must be chosen to be 0 at x n1 2 = 1, x n2 2 = 0. <ref> [DM92b] </ref> uses all such constraints to extract a function representing all valid solutions, and finds a two-level function of minimum cost function that satisfies the function. This formulation has an equivalent single multivalued function f mv that can be used to find an optimum solution. 144 CHAPTER 6.
Reference: [DMNSV88] <author> S. Devadas, H.-K. Ma, A.R. Newton, and A. Sangiovanni-Vincentelli. MUSTANG: </author> <title> State Assignment of Finite State Machines Targeting Multilevel Logic Implementations. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> 7(12) </volume> <pages> 1290-1300, </pages> <month> December </month> <year> 1988. </year>
Reference-contexts: The state assignment problem has been studied periodically for over 30 years [Arm62, Har61], and is one of the classical unsolved problems in logic synthesis. 4 Recently-developed state assignment algorithms attempt to predict the effect of the encoding on the size of the resulting two-level [DBSV85, VSV90] or multilevel <ref> [DHLN91, LN89, DMNSV88] </ref> implementation. These techniques are fairly successful for small machines, but break down on large, automatically generated machines. One exact algorithm has been proposed [DN91] but is impractical for all but the smallest circuits. State machine decomposition is used to split large state machines into several interacting machines. <p> Its development began in the Spring of 1989 as part of a graduate research course in logic synthesis. At that time, state-of-the-art synthesis tools at Berkeley included combinational tools such as espresso [BHMSV84] and misii [BRSVW87], and state assignment programs such as mustang <ref> [DMNSV88] </ref> and kiss [DBSV85]. There was no connection between the combinational and sequential tools: logic gates and state registers had to be treated separately during optimization and technology mapping. Many of the research projects in the course involved exploration of new sequential optimization algorithms that consider logic and state together.
Reference: [DN89] <author> S. Devadas and A.R. </author> <title> Newton. Decomposition and Factorization of Sequential Finite State Machines. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> 8(11) </volume> <pages> 1206-1217, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: State machine decomposition is used to split large state machines into several interacting machines. This often results in a smaller combined area and better performance, similar to the advantages multilevel combinational logic has over two-level implementations. The initial work treated only cascade decompositions [Har60, HS66]; recent publications (e.g., <ref> [DN89, YC92] </ref>) allow multiway decompositions with bidirectional communication. Additional flexibility can be exploited in systems of interacting state machines. An fsm may not receive all possible input sequences, and some of its output sequences may appear equivalent to the following state machines.
Reference: [DN91] <author> S. Devadas and A.R. </author> <title> Newton. Exact Algorithms for Output Encoding, State Assignment, and Four-level Boolean Minimization. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> 10(1) </volume> <pages> 13-27, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: These techniques are fairly successful for small machines, but break down on large, automatically generated machines. One exact algorithm has been proposed <ref> [DN91] </ref> but is impractical for all but the smallest circuits. State machine decomposition is used to split large state machines into several interacting machines. This often results in a smaller combined area and better performance, similar to the advantages multilevel combinational logic has over two-level implementations.
Reference: [DPR92] <author> S. Dey, M. Potkonjak, and S. Rothweiler. </author> <title> Performance Optimization of Sequential Circuits by Eliminating Retiming Bottlenecks. </title> <booktitle> In Proceedings of the IEEE International Conference on Computer-Aided Design, </booktitle> <pages> pages 504-509, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: Registers are moved across logic gates while preserving the I/O behavior. The limitation is that the combinational gates are unaltered, so optimizations involving both register movement and logic restructuring are not considered. Enhancements to retiming 1.3. OVERVIEW 9 have been proposed, e.g., <ref> [DPR92] </ref>, that perform simple logic restructuring operations to permit additional register movement. Various techniques for combining register movement and logic restructuring have been proposed recently. In [DeM91], combinational techniques for successively extracting and eliminating common factors are extended to "look across" register boundaries.
Reference: [FFK88] <author> M. Fujita, H. Fujisawa, and N. Kawato. </author> <title> Evaluation and Improvements of Boolean Comparison Method Based on Binary Decision Diagrams. </title> <booktitle> In Proceedings of the IEEE International Conference on Computer-Aided Design, </booktitle> <pages> pages 2-5, </pages> <month> November </month> <year> 1988. </year>
Reference-contexts: The canonicity property of bdds, efficient bdd package implementation [BRB90, Lon93], and recent improvements in variable ordering strategies [Rud93a] have made bdd-based algorithms successful for verification at various levels of the design process <ref> [MWBSV88, FFK88, CMB90, BCM90, TSL + 90, HTKB92] </ref>. Quite large circuits have been successfully verified (e.g., a 12x12 multiplier has been verified within a 32Mbyte memory limit [Rud93b], despite the inherent difficulty in representing multipliers using bdds [Bry92]).
Reference: [GM94] <author> J. Gergov and C. Meinel. </author> <title> Efficient Boolean Manipulation with obdd's Can be Extended to fbdd's. </title> <journal> IEEE Transactions on Computers, </journal> <note> 1994. To appear. </note>
Reference-contexts: Current research efforts include new variable ordering strategies, a multitude of new applications for bdds, extensions of bdds to represent integer functions [CFM + 93, BFG + 93], exploration of free bdds that are not ordered and are more compact <ref> [BCW80, GM94, SDG93] </ref>, and a novel modification called the zero-suppressed bdd for efficient representation of sets [Min93b, Min93a]. 2.1.6 Image Computation and Characteristic Functions Many algorithms for Boolean function manipulation rely on an efficient computation of the set of output minterms produced by a particular set of input minterms.
Reference: [Har60] <author> J. Hartmanis. </author> <title> Symbolic Analysis of a Decomposition of Information Processing. </title> <journal> Information and Control, </journal> <volume> 3(2) </volume> <pages> 154-178, </pages> <month> June </month> <year> 1960. </year> <note> BIBLIOGRAPHY 179 </note>
Reference-contexts: State machine decomposition is used to split large state machines into several interacting machines. This often results in a smaller combined area and better performance, similar to the advantages multilevel combinational logic has over two-level implementations. The initial work treated only cascade decompositions <ref> [Har60, HS66] </ref>; recent publications (e.g., [DN89, YC92]) allow multiway decompositions with bidirectional communication. Additional flexibility can be exploited in systems of interacting state machines. An fsm may not receive all possible input sequences, and some of its output sequences may appear equivalent to the following state machines.
Reference: [Har61] <author> J. Hartmanis. </author> <title> On the State Assignment Problem for Sequential Machines. </title> <journal> IRE Transactions on Electronic Computers, </journal> <volume> EC-10(2):157-165, </volume> <month> June </month> <year> 1961. </year>
Reference-contexts: These codes are used to create a logic-level implementation using a register per bit of the binary code, so the encoding has a direct effect on the quality of the implementation. The state assignment problem has been studied periodically for over 30 years <ref> [Arm62, Har61] </ref>, and is one of the classical unsolved problems in logic synthesis. 4 Recently-developed state assignment algorithms attempt to predict the effect of the encoding on the size of the resulting two-level [DBSV85, VSV90] or multilevel [DHLN91, LN89, DMNSV88] implementation.
Reference: [HDJ + 88] <author> H.-C. Hsieh, K. Dong, J.Y. Ja, R. Kanazawa, L.T. Ngo, L. G. Tinkey, W.S. carter, and R.H. Freeman. </author> <title> A 9000-Gate User-Programmable Gate Array. </title> <booktitle> In Proceedings of the Custom Integrated Circuits Conference, </booktitle> <year> 1988. </year>
Reference-contexts: However, the registers are fixed so only the interior combinational logic can be optimized. Other existing technologies for implementing sequential circuits are more general and allow multiple levels of logic and feedback. Examples include the stored logic array, or sla [PW79], and various pld and fpga architectures (e.g., <ref> [HDJ + 88] </ref>). Nevertheless, the algorithms developed in this chapter are applicable to these architectures. The more important application for two-level sequential techniques is in multilevel sequential logic optimization programs to perform node minimization and small subnetwork optimization.
Reference: [HS66] <author> J. Hartmanis and R.E. Stearns. </author> <title> Algebraic Structure Theory of Sequential Machines. </title> <booktitle> International Series in Applied Mathematics. </booktitle> <publisher> Prentice-Hall, </publisher> <address> Engle-wood Cliffs, N.J., </address> <year> 1966. </year>
Reference-contexts: State machine decomposition is used to split large state machines into several interacting machines. This often results in a smaller combined area and better performance, similar to the advantages multilevel combinational logic has over two-level implementations. The initial work treated only cascade decompositions <ref> [Har60, HS66] </ref>; recent publications (e.g., [DN89, YC92]) allow multiway decompositions with bidirectional communication. Additional flexibility can be exploited in systems of interacting state machines. An fsm may not receive all possible input sequences, and some of its output sequences may appear equivalent to the following state machines.
Reference: [HTKB92] <author> R. Hojati, H. Touati, R.P. Kurshan, and R.K. Brayton. </author> <title> Efficient !-Regular Language Containment. </title> <booktitle> In Fourth Workshop on Computer-aided Verification, </booktitle> <pages> pages 371-382, </pages> <address> Montreal, Quebec, Canada, </address> <year> 1992. </year>
Reference-contexts: The canonicity property of bdds, efficient bdd package implementation [BRB90, Lon93], and recent improvements in variable ordering strategies [Rud93a] have made bdd-based algorithms successful for verification at various levels of the design process <ref> [MWBSV88, FFK88, CMB90, BCM90, TSL + 90, HTKB92] </ref>. Quite large circuits have been successfully verified (e.g., a 12x12 multiplier has been verified within a 32Mbyte memory limit [Rud93b], despite the inherent difficulty in representing multipliers using bdds [Bry92]).
Reference: [KF92] <author> Y. Kukimoto and M. Fujita. </author> <title> Rectification Method for Lookup-Table Type FPGA's. </title> <booktitle> In Proceedings of the IEEE International Conference on Computer-Aided Design, </booktitle> <pages> pages 54-61, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: Depending on the application, it may be possible to add the set of constraints in a more efficient way (perhaps implicitly, as sets) or to incorporate them directly in the representative function while it is being constructed. This latter technique is used in <ref> [KF92] </ref>. 6.4 Applications Multiple Boolean relations have arisen in a number of synthesis problems. One example was shown in Section 6.1. The multifunction in Example 6.1.1 was derived by analysis of don't care sequences in finite state machines. Several applications are described in this section. <p> However, depending on the origin of the Boolean relations and the additional constraints, more efficient techniques may be applied to specific problems. 6.4.1 FPGA Rectification The goal of FPGA rectification as given in <ref> [KF92] </ref> is to change the output functions of the FPGA by modifying the functions of certain LUT's (look-up tables) within the FPGA, while maintaining the interconnections between LUT's. <p> FLEXIBILITY IN BOOLEAN FUNCTIONS 01 00; 10 00; 11 u 2 u 1 v 2 v 1 10 Solution <ref> [KF92] </ref>: 1. Form a Boolean relation R containing all (u i ; v j ) pairs, where u i 2 B s , v j 2 B t , that satisfy the specification SP EC given that the rest of the network is unchanged. 2. <p> The Boolean relation arises from the encapsulation of the environmental information used to determine functions for implementing the u i 's; the constraints on it arise from the support constraints in reimplementing the LUT functions of the subnetwork. The exact solution in <ref> [KF92] </ref> is similar to the Boolean function formulation from Sections 6.3.2 and 6.3.3, but the support of each v i is limited by the number of inputs to the LUT so the number of new Boolean variables is 2 jSUP P j t (for outputs v 1 ; v 2 ; <p> In <ref> [KF92] </ref>, the constraints are merged directly into the Boolean relation by variable substitution.
Reference: [KN72] <author> J. Kim and M. Newborn. </author> <title> The Simplification of Sequential Machines with Input Restrictions. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-21:1440-1443, </volume> <month> De-cember </month> <year> 1972. </year>
Reference-contexts: A subset of input don't care sequences is extracted and used for optimization in [Ung69, Dev91]. More recently, algorithms have been published for extracting and exploiting the complete set of input don't care sequences for both cascade <ref> [KN72] </ref> and bidirectional communicating fsms [RHS91, WB93b]. Full efficient utilization of output don't care sequences is still an unsolved problem. <p> Equivalent states are static Boolean relations which can be exploited using a Boolean relations minimizer, or in simple cases using a combinational logic optimizer. Logic-level sequential don't care conditions analogous to the SDC and ODC combinational don't cares are derived and used in [DM92a]. In <ref> [KN72] </ref>, input don't care sequences are derived from two cascaded interacting state machines and used to minimize the states in a state transition graph. This approach is also used in [Dev89], where subsets of input don't care sequences are used, and in [RHS91] where bidirectional communicating state machines are considered.
Reference: [KVBSV93] <author> T. Kam, T. Villa, R.K. Brayton, and A. Sangiovanni-Vincentelli. </author> <title> A Fully Implicit Algorithm for Exact State Minimization. </title> <type> Technical Report Memorandum No. </type> <institution> UCB/ERL M93/79, University of California Berkeley, Electronics Research Laboratory, College of Engineering, University of California, </institution> <address> Berke-ley, CA 94720, </address> <month> November </month> <year> 1993. </year>
Reference-contexts: Recent improvements in state machine traversal and Boolean function manipulation have made these algorithms practical for larger machines <ref> [RHSJ94, KVBSV93] </ref>. State assignment algorithms assign binary codes to each symbolic state. These codes are used to create a logic-level implementation using a register per bit of the binary code, so the encoding has a direct effect on the quality of the implementation.
Reference: [Lar89] <author> T. Larrabee. </author> <title> Efficient Generation of Test Patterns Using Boolean Difference. </title> <booktitle> In Proceedings of the International Test Conference, </booktitle> <pages> pages 795-801, </pages> <year> 1989. </year>
Reference-contexts: An efficient automatic test pattern generation algorithm for combinational logic has been implemented. The deterministic part of the search for tests is based on the algorithm reported in <ref> [Lar89] </ref>: a set of equations is written to express the difference between the good and faulty circuits for a particular fault and Boolean satisfiability is used to find a satisfying assignment for these equations. The implementation of the algorithm in sis has been substantially improved for speed.
Reference: [Lin93] <author> B. Lin. </author> <title> Restructuring of Synchronous Logic Circuits. </title> <booktitle> In Proceedings of the European Conference on Design Automation, </booktitle> <pages> pages 205-209, </pages> <address> Paris, France, </address> <month> February </month> <year> 1993. </year> <note> 180 BIBLIOGRAPHY </note>
Reference-contexts: Various techniques for combining register movement and logic restructuring have been proposed recently. In [DeM91], combinational techniques for successively extracting and eliminating common factors are extended to "look across" register boundaries. This approach was given a more formal framework in <ref> [Lin93] </ref>, where synchronous kernel generation is used to find synchronous factors. In [MSBSV91], a circuit is peripherally retimed to move the registers to the boundaries of a logic block and combinational techniques used to optimize the interior combinational logic. <p> Application of these techniques yielded good results for cycle-time optimization, but very few improvements for area optimization. A more formal framework for this basic method is given in <ref> [Lin93] </ref>, where synchronous kernel extraction is used to find synchronous factors. Although this reportedly resulted in significant area optimization, it is unclear for some examples that the savings achieved would not have been achieved by other, simpler techniques. 1 However, the techniques as described are sound. <p> Their implementation does require significant changes to existing logic optimization algorithms. 1 For one circuit in particular, s953, it was reported in <ref> [Lin93] </ref> that the circuit was "reduced to a constant 0 [by using the synchronous factor optimization algorithm] : : : without having to extract the state space." In fact, this circuit is anomalous in that none of the latches transitively fanout to the primary outputs. <p> The maximal peripheral retiming and resynthesis algorithm described in this chapter has a niche in the gate-level sequential optimization process. In particular, it provides a bridge between the work in [MSBSV91] and the work in <ref> [Lin93] </ref>. It is potentially more powerful than retiming and resynthesis since it includes an initial resynthesis step. It is not as powerful as extracting synchronous factors a la [Lin93] since combinational blocks are still considered as one entity and the final retiming is done in one step (rather than iterating with <p> In particular, it provides a bridge between the work in [MSBSV91] and the work in <ref> [Lin93] </ref>. It is potentially more powerful than retiming and resynthesis since it includes an initial resynthesis step. It is not as powerful as extracting synchronous factors a la [Lin93] since combinational blocks are still considered as one entity and the final retiming is done in one step (rather than iterating with resynthesis). <p> Finally, the algorithms should be extended to apply to extraction not only synchronous cubes, but synchronous factors in a multilevel circuit. This would be an approach similar to <ref> [Lin93] </ref>, but would utilize existing combinational techniques. The multilevel optimization algorithm developed in Chapter 5 should be combined with the two-level algorithm of Chapter 4 for a complete sequential synthesis algorithm. <p> Such an algorithm would automatically break feedback arcs, contain parameters for controlling node duplication, contain a method for determining feasible circuits for duplication as mentioned in Section 5.5, and use the exact two-level algorithm for node minimization. Experimentation with this and other techniques <ref> [MSBSV91, DeM91, Lin93] </ref> would provide valuable insight into the overall sequential circuit optimization process, and only then could effective automatic scripts for optimizing such circuits (such as those that have been so successful in misii) be developed.
Reference: [Lis89] <author> R. Lisanke. </author> <title> Logic Synthesis Benchmark Circuits for the International Workshop on Logic Synthesis. </title> <institution> Microelectronics Center of North Carolina, </institution> <month> May </month> <year> 1989. </year>
Reference-contexts: It succeeded in finding the minimal arc feedback set in a reasonable amount of time (typically no more than 1 hour real time on a DECstation 5100) for most of the benchmark circuits used in sequential logic synthesis and distributed with the MCNC benchmark set <ref> [Lis89] </ref>. 5 In theory it is computationally expensive. Its authors deliberately omitted stating theoretical asymptotic run times since the performance in practice was very good for large graphs. 5.5. IMPLEMENTATION AND RESULTS 119 5.5.2 Algorithm and Results The multilevel optimization algorithm as implemented proceeds as follows. <p> Additionally, the blif format accepts user-specified don't care conditions. Designs can be described hierarchically although currently the hierarchy information is not retained in the internal data structure resulting in a flat netlist. 2 A state transition table for a finite state machine can be specified with the kiss <ref> [Lis89] </ref> format, which is used extensively in state assignment and state minimization programs. Each state is symbolic; the transition table indicates the next symbolic state and output bit-vector given a current state and input bit-vector.
Reference: [LN89] <author> B. Lin and A.R. </author> <title> Newton. Synthesis of Multiple Level Logic from Symbolic High-Level Description Languages. </title> <booktitle> In Proceedings of the International Conference on VLSI, </booktitle> <pages> pages 187-196, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: The state assignment problem has been studied periodically for over 30 years [Arm62, Har61], and is one of the classical unsolved problems in logic synthesis. 4 Recently-developed state assignment algorithms attempt to predict the effect of the encoding on the size of the resulting two-level [DBSV85, VSV90] or multilevel <ref> [DHLN91, LN89, DMNSV88] </ref> implementation. These techniques are fairly successful for small machines, but break down on large, automatically generated machines. One exact algorithm has been proposed [DN91] but is impractical for all but the smallest circuits. State machine decomposition is used to split large state machines into several interacting machines. <p> These binary codes are used to create a logic-level implementation by substituting the binary codes for the symbolic states and creating a latch for each bit of the binary code. Two state assignment programs, jedi <ref> [LN89] </ref> and nova [VSV90] are distributed with sis. jedi is a general symbolic encoding program (i.e., for encoding both inputs and outputs) that can be used for the more specific state encoding problem; it is targeted for multilevel implementations. nova is a state assignment program targeted for pla-based finite state machines;
Reference: [Lon93] <author> David Long, </author> <month> November </month> <year> 1993. </year> <type> Personal communication. </type>
Reference-contexts: Verification (f g?) requires a graph isomorphism check, and since bdds are rooted dags this is linear in the number of nodes in the bdds. The canonicity property of bdds, efficient bdd package implementation <ref> [BRB90, Lon93] </ref>, and recent improvements in variable ordering strategies [Rud93a] have made bdd-based algorithms successful for verification at various levels of the design process [MWBSV88, FFK88, CMB90, BCM90, TSL + 90, HTKB92].
Reference: [LRS83] <author> C.E. Leiserson, F.M. Rose, and J.B. Saxe. </author> <title> Optimizing Synchronous Circuitry by Retiming. </title> <booktitle> In Advanced Research in VLSI: Proceedings of the Third Caltech Conference, </booktitle> <pages> pages 86-116. </pages> <publisher> Computer Science Press, </publisher> <year> 1983. </year>
Reference-contexts: Retiming algorithms were first proposed by Leiserson, et al. <ref> [LS83, LRS83, LS88] </ref>, and applied to circuits with a single global clock controlling edge-triggered registers. A single-clock, edge-triggered-register circuit functions properly when clocked at a rate equal to the longest combinational delay between any two registers. Retiming relies on this property for a simple delay calculation and correct circuit functionality.
Reference: [LS83] <author> C.E. Leiserson and J.B. Saxe. </author> <title> Optimizing Synchronous Systems. </title> <journal> Journal of VLSI and Computer Systems, </journal> <volume> 1(1) </volume> <pages> 41-67, </pages> <month> Spring </month> <year> 1983. </year>
Reference-contexts: Retiming algorithms were first proposed by Leiserson, et al. <ref> [LS83, LRS83, LS88] </ref>, and applied to circuits with a single global clock controlling edge-triggered registers. A single-clock, edge-triggered-register circuit functions properly when clocked at a rate equal to the longest combinational delay between any two registers. Retiming relies on this property for a simple delay calculation and correct circuit functionality. <p> A legal retiming has been proven to generate a circuit that is functionally equivalent to the original circuit <ref> [LS83] </ref>. The circuit shown in resulting retimed circuit is shown in Figure 2.2. In [LS88] the external interface to a synchronous circuit is modeled by a single node called the host node (v h ), to which all inputs and outputs are connected. <p> The synchronous, edge-triggered, and single-clock properties together ensure that the retiming algorithm can be applied to the circuit while maintaining the correct input/output behavior <ref> [LS83] </ref>. There are two places in which retiming is required: in expressing a multilevel synchronous circuit as a two-level synchronous circuit, and in optimizing a two-level synchronous circuit. A synchronous circuit is represented and optimized using a single synchronous Boolean function representation (a precise definition follows in Section 4.3.1). <p> Sequential don't cares based on unreachable states can be computed and used during node minimization. Retiming [LS88] has been implemented for cycle-time optimization of synchronous edge-triggered designs. The original algorithm <ref> [LS83] </ref> was based on a mixed-integer linear programming formulation for determining the feasibility of a particular cycle time. Later, more efficient relaxation-based techniques were reported [Sax85]. Both approaches are im B.4. SYNTHESIS AND OPTIMIZATION 171 plemented in the retime command in sis.
Reference: [LS88] <author> C.E. Leiserson and J.B. Saxe. </author> <title> Retiming Synchronous Circuitry. </title> <type> Technical Report TM 372, </type> <institution> MIT/LCS, Massachusetts Institute of Technology, 545 Technology Square, </institution> <address> Cambridge, Massachusetts 02139, </address> <month> October </month> <year> 1988. </year>
Reference-contexts: Retiming is an algorithm for finding the optimum cycle time, minimum number of registers, or minimal number of registers subject to a cycle-time constraint for a synchronous circuit <ref> [LS88] </ref>. Registers are moved across logic gates while preserving the I/O behavior. The limitation is that the combinational gates are unaltered, so optimizations involving both register movement and logic restructuring are not considered. Enhancements to retiming 1.3. <p> Retiming algorithms were first proposed by Leiserson, et al. <ref> [LS83, LRS83, LS88] </ref>, and applied to circuits with a single global clock controlling edge-triggered registers. A single-clock, edge-triggered-register circuit functions properly when clocked at a rate equal to the longest combinational delay between any two registers. Retiming relies on this property for a simple delay calculation and correct circuit functionality. <p> A legal retiming has been proven to generate a circuit that is functionally equivalent to the original circuit [LS83]. The circuit shown in resulting retimed circuit is shown in Figure 2.2. In <ref> [LS88] </ref> the external interface to a synchronous circuit is modeled by a single node called the host node (v h ), to which all inputs and outputs are connected. <p> Here, a retiming is always assumed to be a legal retiming with r (v) = 0 for all vertices v that represent I/O pins. The registers move in a limited fashion during a legal retiming. Lemma 1 in <ref> [LS88] </ref> asserts that w r (p) = w (p) + r (v) r (u), where p is a path from u to v in the circuit, and w (p) is the sum of the edge weights along that path. <p> The resulting circuit contains no redundant register connections: that is, no registers in the current implementation can be removed without changing the functionality. This reduction in redundant register connections can be followed by retiming for minimum registers <ref> [LS88] </ref>, which will determine an absolute minimum number of registers for a given implementation. Minimizing Registers Using Weighted Column Covering The number of registers can be minimized by solving a weighted column covering problem on the minterm-prime covering table. <p> SIS B.2.3 New Packages A number of new packages and capabilities have been added to sis. For sequential circuits in particular, the clock and latch packages model delay elements and their clocking signals, the retime package optimally moves registers throughout the circuit using retiming <ref> [LS88] </ref>, the seqbdd package provides the capability for implicit traversal of the state space of a gate-level finite state machine, the stg package provides a data structure and manipulation routines for symbolic finite state machines, the timing package provides routines for verifying a given clock schedule and computing an optimal clock <p> Sequential Optimization All of the combinational techniques described above can be applied to the combinational blocks between register boundaries in a sequential circuit. Sequential don't cares based on unreachable states can be computed and used during node minimization. Retiming <ref> [LS88] </ref> has been implemented for cycle-time optimization of synchronous edge-triggered designs. The original algorithm [LS83] was based on a mixed-integer linear programming formulation for determining the feasibility of a particular cycle time. Later, more efficient relaxation-based techniques were reported [Sax85]. Both approaches are im B.4.
Reference: [LTN90] <author> B. Lin, H. Touati, and A.R. </author> <title> Newton. Don't Care Minimization of Multilevel Sequential Logic Networks. </title> <booktitle> In Proceedings of the IEEE International Conference on Computer-Aided Design, </booktitle> <pages> pages 414-417, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: In particular, don't care conditions based on unreachable states and Boolean relations based on equivalent states are extracted and used with existing combinational logic optimization programs in <ref> [LTN90] </ref>. Sequential don't care conditions based on the structure of a network are described in [DM92a]. These include both don't cares that are similar to the various don't cares derived for a combinational Boolean network (these are detailed in Section 2.2) and don't care sequences.
Reference: [Mal90] <author> Sharad Malik. </author> <title> Combinational Logic Optimization Techniques in Sequential Logic Synthesis. </title> <type> PhD thesis, </type> <institution> University of California Berkeley, Electronics Research Laboratory, College of Engineering, University of California, </institution> <address> Berke-ley, CA 94720, </address> <month> November </month> <year> 1990. </year> <note> Memorandum No. UCB/ERL M90/115. </note>
Reference-contexts: In addition, it is difficult to decide automatically which nodes to choose to optimize. Finally, an attempt to duplicate the results presented in that work indicated that the area savings achieved could be achieved by well-known combinational techniques [Wat93]. In <ref> [MSBSV91, Mal90] </ref>, a method was given that applies existing techniques for combinational optimization to optimize signals that span over several time periods.
Reference: [McC56] <author> E. McCluskey. </author> <title> Minimization of Boolean Functions. </title> <journal> Bell Systems Technical Journal, </journal> <volume> 35 </volume> <pages> 1417-1444, </pages> <month> April </month> <year> 1956. </year>
Reference-contexts: Flexibility for two-level optimization takes the form of don't care conditions which are conditions on the input signals under which the outputs are allowed to take either Boolean value. Efficient and effective techniques for both exact <ref> [Qui52, McC56, Rud89, MSBSV93] </ref> and heuristic [BHMSV84] methods for obtaining a minimal-row pla (minimal-product-term function) have been developed. Two-level logic optimization is now considered a standard procedure and is used extensively in logic synthesis systems. Multilevel logic optimization is not as well-developed or well-understood.
Reference: [McC65] <author> E.J. McCluskey. </author> <title> Introduction to the Theory of Switching Circuits. </title> <publisher> McGraw-Hill Book Company, </publisher> <year> 1965. </year>
Reference-contexts: As a secondary optimization criterion, the number of transistors in the arrays is minimized. The solutions for both the heuristic algorithm presented in [BHMSV84] and the traditional exact algorithm reported in <ref> [McC65] </ref> are prime (no transistor connection can be removed from the input array) and irredundant (no row of the input array can be removed). <p> As a result, a minimum-row solution can be found by selecting a minimum number of prime implicants. (See [Rud89] for a brief on cost functions for plas.) Exact techniques based on this cost function <ref> [McC65, Rud89] </ref> employ the following algorithm: Two-level Exact Algorithm: 1. Compute all primes. 2. Form the covering table. 3. Solve the minimum-column cover problem. The covering table contains one row for each minterm of the ON-set and one column for each prime.
Reference: [Mea55] <author> G.H. Mealy. </author> <title> A Method for Synthesizing Sequential Circuits. </title> <journal> Bell Systems Technical Journal, </journal> <volume> 34 </volume> <pages> 1045-1079, </pages> <month> September </month> <year> 1955. </year> <note> BIBLIOGRAPHY 181 </note>
Reference-contexts: LOGIC SYNTHESIS 7 Exact and heuristic techniques have been developed for both completely-specified finite state machines (where no don't care conditions are given and each symbolic state has a specified next state for every input vector) <ref> [Mea55] </ref> and incompletely specified state machines [PU59]. Recent improvements in state machine traversal and Boolean function manipulation have made these algorithms practical for larger machines [RHSJ94, KVBSV93]. State assignment algorithms assign binary codes to each symbolic state. <p> If no don't care conditions are present, the state transition graph is completely specified and the exact minimum number of states can be found in time proportional to the number of states <ref> [Mea55] </ref>. For incompletely specified machines, the state minimization problem is NP-hard, but efficient techniques have been successful on quite large state machines [RHSJ94]. Finally, the minimized stg is encoded with a minimum length encoding to produce an implementation with a minimum number of registers. 4.8.
Reference: [Min93a] <author> S. Minato. </author> <title> Fast Weak-Division Method for Implicit Cube Representation. </title> <booktitle> In Proceedings of the SASIMI Workshop, </booktitle> <pages> pages 423-432, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: ordering strategies, a multitude of new applications for bdds, extensions of bdds to represent integer functions [CFM + 93, BFG + 93], exploration of free bdds that are not ordered and are more compact [BCW80, GM94, SDG93], and a novel modification called the zero-suppressed bdd for efficient representation of sets <ref> [Min93b, Min93a] </ref>. 2.1.6 Image Computation and Characteristic Functions Many algorithms for Boolean function manipulation rely on an efficient computation of the set of output minterms produced by a particular set of input minterms.
Reference: [Min93b] <author> S. Minato. </author> <title> Zero-Suppressed BDDs for Set Manipulation in Combinatorial Problems. </title> <booktitle> In Proceedings of the 30 th Design Automation Conference, </booktitle> <pages> pages 272-277, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: ordering strategies, a multitude of new applications for bdds, extensions of bdds to represent integer functions [CFM + 93, BFG + 93], exploration of free bdds that are not ordered and are more compact [BCW80, GM94, SDG93], and a novel modification called the zero-suppressed bdd for efficient representation of sets <ref> [Min93b, Min93a] </ref>. 2.1.6 Image Computation and Characteristic Functions Many algorithms for Boolean function manipulation rely on an efficient computation of the set of output minterms produced by a particular set of input minterms.
Reference: [MKLC89] <author> S. Muroga, Y. Kambayashi, H. C. Lai, and J. N. Culliney. </author> <title> The Transduction Method Design of Logic Networks Based on Permissible Functions. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-38(10):1404-1424, </volume> <month> October </month> <year> 1989. </year>
Reference-contexts: It is derived by looking at the fanout of the variable y i and seeing how specifically y i is used. In <ref> [MKLC89] </ref>, two sets based on observability don't care conditions were defined: mspfs (maximum sets of permissible functions), which include for each node the ON-set of the node function and the largest possible set of observability don't cares for that node, and cspfs (compatible sets of permissible functions), which include the ON-set <p> Here, flexibility means choice in the actual function implemented (as opposed to choice in how that function is implemented). Flexibility in various forms has been studied extensively, 122 CHAPTER 6. FLEXIBILITY IN BOOLEAN FUNCTIONS and includes don't care conditions for optimization of combinational <ref> [BHMSV84, BBH + 88, MKLC89, Sav92] </ref> and sequential [DM92a, RHS91] two-level and multilevel circuits as single entities (each output can be optimized independently), Boolean relations [BS89b, BS89a, WB91] which express relationships between outputs and are derived from the surrounding environment, and synchronous recurrence equations [DM92b] for optimization of sequential circuits in
Reference: [MLSB89] <author> C.W. Moon, B. Lin, H. Savoj, and R.K. Brayton. </author> <title> Technology Mapping for Sequential Logic Synthesis. </title> <booktitle> In Proceedings of the International Workshop on Logic Synthesis, </booktitle> <address> North Carolina, </address> <month> May </month> <year> 1989. </year>
Reference-contexts: Technology Mapping The strategy of representing feedback lines by latches with a PO/PI pair preserves the acyclic nature of the circuit representation and allows the combinational technology mapping algorithms to be easily extended to sequential technology mapping <ref> [MLSB89] </ref>. The same tree-covering algorithm [Rud89] is used but the pattern matching procedure is extended to accommodate sequential elements. The pattern matching relies no longer on just the network topology but also on the type of library element and on the location of latch input and output pins.
Reference: [MSBSV90] <author> S. Malik, K.J. Singh, R.K. Brayton, and A.L. Sangiovanni-Vincentelli. </author> <title> Performance Optimization of Pipelined Circuits. </title> <booktitle> In Proceedings of the IEEE International Conference on Computer-Aided Design, </booktitle> <pages> pages 410-413, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: Peripheral retiming can only be applied to a certain class of acyclic circuits; for all others, it is applied to subcircuits that satisfy its requirements. Application of retiming and resynthesis to acyclic circuits has been successful in improving performance <ref> [MSBSV90] </ref>; however, insignificant improvements were obtained for area optimization and for cyclic circuits. The reason for this is in part that there is a large class of circuits which cannot be peripherally retimed. In this chapter, the idea of a maximal peripheral retiming is developed. <p> Simulation along the cycle is used to determine the new initial state for the retimed circuit. The algorithms for maximally preserving don't care conditions during retiming (see Chapter 3) and retiming and resynthesis <ref> [MSBSV90, MSBSV91] </ref> have been implemented in sis. For retiming and resynthesis, the first step is to identify the largest subcircuits that can be peripherally retimed, and then to perform the retiming and resynthesis operations.
Reference: [MSBSV91] <author> S. Malik, E.M. Sentovich, R.K. Brayton, and A.L. Sangiovanni-Vincentelli. </author> <title> Retiming and Resynthesis: Optimizing Sequential Networks with Combinational Techniques. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> CAD-10(1):74-84, </volume> <month> January </month> <year> 1991. </year>
Reference-contexts: In [DeM91], combinational techniques for successively extracting and eliminating common factors are extended to "look across" register boundaries. This approach was given a more formal framework in [Lin93], where synchronous kernel generation is used to find synchronous factors. In <ref> [MSBSV91] </ref>, a circuit is peripherally retimed to move the registers to the boundaries of a logic block and combinational techniques used to optimize the interior combinational logic. Termed retiming and resynthesis, this technique has the advantage that existing combinational logic optimization programs can be used on the interior logic. <p> The reason for this is that one open question in the area of gate-level sequential circuit optimization has been the utility of algorithms that exploit sharing of logic across several time frames. Results reported thus far <ref> [MSBSV91, DeM91] </ref> have suggested that logic functions of this form are uncommon in real circuits. <p> In addition, it is difficult to decide automatically which nodes to choose to optimize. Finally, an attempt to duplicate the results presented in that work indicated that the area savings achieved could be achieved by well-known combinational techniques [Wat93]. In <ref> [MSBSV91, Mal90] </ref>, a method was given that applies existing techniques for combinational optimization to optimize signals that span over several time periods. <p> The maximal peripheral retiming and resynthesis algorithm described in this chapter has a niche in the gate-level sequential optimization process. In particular, it provides a bridge between the work in <ref> [MSBSV91] </ref> and the work in [Lin93]. It is potentially more powerful than retiming and resynthesis since it includes an initial resynthesis step. <p> Such an algorithm would automatically break feedback arcs, contain parameters for controlling node duplication, contain a method for determining feasible circuits for duplication as mentioned in Section 5.5, and use the exact two-level algorithm for node minimization. Experimentation with this and other techniques <ref> [MSBSV91, DeM91, Lin93] </ref> would provide valuable insight into the overall sequential circuit optimization process, and only then could effective automatic scripts for optimizing such circuits (such as those that have been so successful in misii) be developed. <p> Simulation along the cycle is used to determine the new initial state for the retimed circuit. The algorithms for maximally preserving don't care conditions during retiming (see Chapter 3) and retiming and resynthesis <ref> [MSBSV90, MSBSV91] </ref> have been implemented in sis. For retiming and resynthesis, the first step is to identify the largest subcircuits that can be peripherally retimed, and then to perform the retiming and resynthesis operations.
Reference: [MSBSV93] <author> P. McGeer, J. Sanghavi, R. Brayton, and A. Sangiovanni-Vincentelli. </author> <title> A New Exact Minimizer for Logic Functions. </title> <booktitle> In Proceedings of the International Symposium on Logic Synthesis and Microprocessor Architecture, Iizuka, </booktitle> <month> December </month> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: Flexibility for two-level optimization takes the form of don't care conditions which are conditions on the input signals under which the outputs are allowed to take either Boolean value. Efficient and effective techniques for both exact <ref> [Qui52, McC56, Rud89, MSBSV93] </ref> and heuristic [BHMSV84] methods for obtaining a minimal-row pla (minimal-product-term function) have been developed. Two-level logic optimization is now considered a standard procedure and is used extensively in logic synthesis systems. Multilevel logic optimization is not as well-developed or well-understood.
Reference: [MSS + 91] <author> P.C. McGeer, A. Saldanha, P.R. Stephan, R.K. Brayton, and A.L. Sangiovanni-Vincentelli. </author> <title> Timing Analysis and Delay-Fault Test Generation using Path-Recursive Functions. </title> <booktitle> In Proceedings of the IEEE International Conference on Computer-Aided Design, </booktitle> <pages> pages 180-183, </pages> <month> November </month> <year> 1991. </year>
Reference-contexts: Y j=yg y i 2g f i d y i X OBS z OBS z = gy Y (f i + d y i ) y j 2j f j + d y j Since X 0 Y ff g g2"U 1 Y (ff g + fi g ) (see <ref> [MSS + 91] </ref>), then OBS z OBS z = y i 2y f i + d y i + f i + d y i = y i 2y Thus OBS z OBS z = 0 So d z can be expressed as d z = OBS z OBS z Computing
Reference: [MWBSV88] <author> S. Malik, A.R. Wang, R.K. Brayton, and A. Sangiovanni-Vincentelli. </author> <title> Logic Verification using Binary Decision Diagrams in a Logic Synthesis Environ 182 BIBLIOGRAPHY ment. </title> <booktitle> In Proceedings of the IEEE International Conference on Computer-Aided Design, </booktitle> <pages> pages 6-9, </pages> <month> November </month> <year> 1988. </year>
Reference-contexts: The canonicity property of bdds, efficient bdd package implementation [BRB90, Lon93], and recent improvements in variable ordering strategies [Rud93a] have made bdd-based algorithms successful for verification at various levels of the design process <ref> [MWBSV88, FFK88, CMB90, BCM90, TSL + 90, HTKB92] </ref>. Quite large circuits have been successfully verified (e.g., a 12x12 multiplier has been verified within a 32Mbyte memory limit [Rud93b], despite the inherent difficulty in representing multipliers using bdds [Bry92]).
Reference: [Ng92] <author> Antony Peng-Chew Ng. </author> <title> Partitioning and Scheduling for Circuit Simulation. </title> <type> PhD thesis, </type> <institution> University of California Berkeley, Electronics Research Laboratory, College of Engineering, University of California, Berkeley, </institution> <address> CA 94720, </address> <year> 1992. </year>
Reference-contexts: For a network with e edges, this algorithm exhibits O (e) run time. However, the algorithm is greedy and hence may break many arcs, resulting in a greater loss of signal communication information. This and several other effective heuristic algorithms are investigated in <ref> [Ng92] </ref>. The sw algorithm [SW75] guarantees a minimum feedback arc set. It operates by successively partitioning a strongly connected component of a graph into two subgraphs according to a candidate feedback arc set, and exhaustively testing to see if the candidate set is minimal.
Reference: [PB91a] <author> C. Pixley and G. Beihl. </author> <title> Calculating Resetability and Reset Sequences. </title> <booktitle> In Proceedings of the IEEE International Conference on Computer-Aided Design, </booktitle> <pages> pages 376-379, </pages> <month> November </month> <year> 1991. </year>
Reference-contexts: It is assumed that the environment brings the circuit to a known state using a reset sequence, i.e., the reset circuitry is apparent to the circuit. The behavior of the circuit can be correctly predicted henceforth. This is the approach taken in <ref> [Pix90, PB91a, PB91b] </ref>, where a resetable circuit is defined as one that has a reset sequence, a sequence of input vectors that brings the circuit to a single known state regardless of the initial state.
Reference: [PB91b] <author> C. Pixley and G. Beihl. </author> <title> Quotient and Isomorphism Theorems of a Theory of Sequential Hardware Design. </title> <booktitle> In Proceedings of the 1991 International Workshop on Formal Methods in VLSI Design, </booktitle> <address> Miami, Florida, </address> <month> January </month> <year> 1991. </year>
Reference-contexts: It is assumed that the environment brings the circuit to a known state using a reset sequence, i.e., the reset circuitry is apparent to the circuit. The behavior of the circuit can be correctly predicted henceforth. This is the approach taken in <ref> [Pix90, PB91a, PB91b] </ref>, where a resetable circuit is defined as one that has a reset sequence, a sequence of input vectors that brings the circuit to a single known state regardless of the initial state.
Reference: [Pix90] <author> C. Pixley. </author> <title> A Computational Theory and Implementation of Sequential Hardware Equivalence. In R.P. Kurshan and E.M. </title> <editor> Clarke, editors, </editor> <booktitle> DIMACS Technical Report 90-31, volume 2, Workshop on Computer-Aided Verification, </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: It is assumed that the environment brings the circuit to a known state using a reset sequence, i.e., the reset circuitry is apparent to the circuit. The behavior of the circuit can be correctly predicted henceforth. This is the approach taken in <ref> [Pix90, PB91a, PB91b] </ref>, where a resetable circuit is defined as one that has a reset sequence, a sequence of input vectors that brings the circuit to a single known state regardless of the initial state. <p> An essentially resetable design has the property that its stg has a single strongly connected component that is reachable from all states. 2.4. INITIAL STATES AND RESETABILITY 25 Self-reseting designs are an important subclass of essentially resetable designs <ref> [Pix90] </ref>. The outputs of a self-reseting design depend only on the previous k inputs, for some integer k. Hence the initial state or power-up state has no effect on the machine after k cycles. Pipelined circuits are self-reseting. <p> Intuitively, this means that the two machines can be forced to behave identically after a certain number of cycles regardless of the initial state of either machine. An interesting result from <ref> [Pix90] </ref> is that a circuit is equivalent to itself if and only if it is essentially resetable.
Reference: [PU59] <author> M.C. Paull and S.H. Unger. </author> <title> Minimizing the Number of States in Incompletely Specified Sequential Switching Functions. </title> <journal> IRE Transactions on Electronic Computers, </journal> <volume> EC-8(3):356-367, </volume> <month> September </month> <year> 1959. </year>
Reference-contexts: LOGIC SYNTHESIS 7 Exact and heuristic techniques have been developed for both completely-specified finite state machines (where no don't care conditions are given and each symbolic state has a specified next state for every input vector) [Mea55] and incompletely specified state machines <ref> [PU59] </ref>. Recent improvements in state machine traversal and Boolean function manipulation have made these algorithms practical for larger machines [RHSJ94, KVBSV93]. State assignment algorithms assign binary codes to each symbolic state.
Reference: [PW79] <author> S.S. Patil and T.A. Welch. </author> <title> A Programmable Logic Approach for VLSI. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-28(9):594-601, </volume> <month> September </month> <year> 1979. </year>
Reference-contexts: However, the registers are fixed so only the interior combinational logic can be optimized. Other existing technologies for implementing sequential circuits are more general and allow multiple levels of logic and feedback. Examples include the stored logic array, or sla <ref> [PW79] </ref>, and various pld and fpga architectures (e.g., [HDJ + 88]). Nevertheless, the algorithms developed in this chapter are applicable to these architectures. The more important application for two-level sequential techniques is in multilevel sequential logic optimization programs to perform node minimization and small subnetwork optimization.
Reference: [Qui52] <author> W. Quine. </author> <title> The Problem of Simplifying Truth Functions. </title> <journal> American Mathematical Monthly, </journal> <volume> 59 </volume> <pages> 521-531, </pages> <year> 1952. </year>
Reference-contexts: Flexibility for two-level optimization takes the form of don't care conditions which are conditions on the input signals under which the outputs are allowed to take either Boolean value. Efficient and effective techniques for both exact <ref> [Qui52, McC56, Rud89, MSBSV93] </ref> and heuristic [BHMSV84] methods for obtaining a minimal-row pla (minimal-product-term function) have been developed. Two-level logic optimization is now considered a standard procedure and is used extensively in logic synthesis systems. Multilevel logic optimization is not as well-developed or well-understood.
Reference: [RHS91] <author> J.-K. Rho, G. Hachtel, and F. Somenzi. </author> <title> Don't Care Sequences and the Optimization of Interacting Finite State Machines. </title> <booktitle> In Proceedings of the IEEE International Conference on Computer-Aided Design, </booktitle> <pages> pages 418-421, </pages> <month> Novem-ber </month> <year> 1991. </year>
Reference-contexts: A subset of input don't care sequences is extracted and used for optimization in [Ung69, Dev91]. More recently, algorithms have been published for extracting and exploiting the complete set of input don't care sequences for both cascade [KN72] and bidirectional communicating fsms <ref> [RHS91, WB93b] </ref>. Full efficient utilization of output don't care sequences is still an unsolved problem. <p> In [KN72], input don't care sequences are derived from two cascaded interacting state machines and used to minimize the states in a state transition graph. This approach is also used in [Dev89], where subsets of input don't care sequences are used, and in <ref> [RHS91] </ref> where bidirectional communicating state machines are considered. More recently, in [WB93a] the complete input don't care sequences are derived for bidirectional interacting machines. No similar work has been done for output don't care sequences. <p> Flexibility in various forms has been studied extensively, 122 CHAPTER 6. FLEXIBILITY IN BOOLEAN FUNCTIONS and includes don't care conditions for optimization of combinational [BHMSV84, BBH + 88, MKLC89, Sav92] and sequential <ref> [DM92a, RHS91] </ref> two-level and multilevel circuits as single entities (each output can be optimized independently), Boolean relations [BS89b, BS89a, WB91] which express relationships between outputs and are derived from the surrounding environment, and synchronous recurrence equations [DM92b] for optimization of sequential circuits in the context of continuous operation over time. <p> This formulation has an equivalent single multivalued function f mv that can be used to find an optimum solution. 144 CHAPTER 6. FLEXIBILITY IN BOOLEAN FUNCTIONS 6.4.3 Don't Care Sequences In <ref> [RHS91] </ref>, the problem of optimizing interacting finite state machines in considered. In the presence of a surrounding environment of interacting finite state machines, the observability and the controllability of a finite state machine is reduced. <p> In the presence of a surrounding environment of interacting finite state machines, the observability and the controllability of a finite state machine is reduced. This sequential flexibility is referred to as sequential controllability and observability don't cares, quite similar to the case for combinational circuits [Sav92]. As <ref> [RHS91] </ref> have shown, the sequential don't cares for the interacting finite state machine environment can be represented as finite sequences of input-output pairs. This can be naturally cast into the synchronous recurrence equations that were described in the last section.
Reference: [RHSJ94] <author> J.-K. Rho, G.D. Hachtel, F. Somenzi, and R.M. </author> <title> Jacoby. Exact and Heuristic Algorithms for the Minimization of Incompletely Specified State Ma BIBLIOGRAPHY 183 chines. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> 13(2) </volume> <pages> 167-177, </pages> <month> Febru-ary </month> <year> 1994. </year>
Reference-contexts: Recent improvements in state machine traversal and Boolean function manipulation have made these algorithms practical for larger machines <ref> [RHSJ94, KVBSV93] </ref>. State assignment algorithms assign binary codes to each symbolic state. These codes are used to create a logic-level implementation using a register per bit of the binary code, so the encoding has a direct effect on the quality of the implementation. <p> For incompletely specified machines, the state minimization problem is NP-hard, but efficient techniques have been successful on quite large state machines <ref> [RHSJ94] </ref>. Finally, the minimized stg is encoded with a minimum length encoding to produce an implementation with a minimum number of registers. 4.8. <p> B.4. SYNTHESIS AND OPTIMIZATION 169 B.4 Synthesis and Optimization B.4.1 stg Synthesis State minimization has been implemented in sis to allow the user to choose among various state minimization programs. Currently, two state minimization programs are supported: stamina <ref> [RHSJ94] </ref> and sred a fast, heuristic state minimizer developed at CSELT, Torino, Italy [Vil93]. State assignment provides the mapping from an stg to a netlist. State assignment programs start with a state transition table and compute optimal binary codes for each symbolic state.
Reference: [RK62] <author> J.P. Roth and R.M. Karp. </author> <title> Minimization over Boolean Graphs. </title> <journal> IBM Journal of Research and Development, </journal> <volume> 6(2) </volume> <pages> 227-238, </pages> <month> April </month> <year> 1962. </year>
Reference-contexts: All algorithms published thus far are heuristic, 1 but in practice produce good results compared to manually produced designs. 1 With the exception of the decomposition algorithm described in <ref> [RK62] </ref>, which is impractical for all but trivial circuits. 1.2. LOGIC SYNTHESIS 5 Multilevel logic optimization programs typically operate on a Boolean network representation of a functional block, with a Boolean function associated with each node in the network.
Reference: [Rot80] <author> J.P. Roth. </author> <title> Computer Logic, Testing and Verification. Digital System Design. </title> <publisher> Computer Science Press, </publisher> <year> 1980. </year>
Reference-contexts: The 4.1. INTRODUCTION 63 minimum-column cover represents a minimum set of prime implicants that implement the output functions, which corresponds to a minimum-row pla implementation. (As noted in [Rud89], this does not guarantee a minimum-transistor (minimum-literal) implementation as this cost function does not satisfy the assumption above. See <ref> [Rot80] </ref> for a minimum-transistor optimization algorithm. The number of transistors is heuristically reduced in espresso following exact or heuristic prime selection.) In summary, two-level optimization techniques produce prime and irredundant solutions: removal of any literal or product term invalidates the cover. Exact techniques guarantee a minimum number of product terms.
Reference: [RSV87] <author> R. Rudell and A. Sangiovanni-Vincentelli. </author> <title> Multiple-valued Minimization for PLA Optimization. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> CAD-6(5):727-750, </volume> <month> September </month> <year> 1987. </year>
Reference-contexts: For the MBR in f0; 1; 2; 3g which represent the output minterms 00, 01, 10, and 11 respectively. Borrowing the terminology for multivalued variables and literals from <ref> [RSV87] </ref>, a i is a variable taking a value from M , J i M , and a J i i is a literal of variable a i representing the Boolean function a J i ( 1 if a i 2 J i For MBR1, the literal a f0;3g 0 represents <p> Proof. Suppose p is not a prime implicant. Thus there exists a product term ~p p (~p contains p <ref> [RSV87] </ref>), such that ~p is an implicant of f mv . Consider the set of minterms fm 1 ; m 2 ; : : : ; m q g covered by the product term ~p. <p> Boolean Function of Multivalued Variables As a result of Theorem 6.3.2, prime relations of M are obtained from the primes of f mv . Minimizing f mv using espresso-mv <ref> [RSV87] </ref> yields a minimum set of prime relations.
Reference: [Rud89] <author> Richard L. Rudell. </author> <title> Logic Synthesis for VLSI Design. </title> <type> PhD thesis, </type> <institution> University of California Berkeley, Electronics Research Laboratory, College of Engineering, University of California, Berkeley, </institution> <address> CA 94720, </address> <month> April </month> <year> 1989. </year> <note> Memorandum No. UCB/ERL M89/49. </note>
Reference-contexts: Flexibility for two-level optimization takes the form of don't care conditions which are conditions on the input signals under which the outputs are allowed to take either Boolean value. Efficient and effective techniques for both exact <ref> [Qui52, McC56, Rud89, MSBSV93] </ref> and heuristic [BHMSV84] methods for obtaining a minimal-row pla (minimal-product-term function) have been developed. Two-level logic optimization is now considered a standard procedure and is used extensively in logic synthesis systems. Multilevel logic optimization is not as well-developed or well-understood. <p> As a result, a minimum-row solution can be found by selecting a minimum number of prime implicants. (See <ref> [Rud89] </ref> for a brief on cost functions for plas.) Exact techniques based on this cost function [McC65, Rud89] employ the following algorithm: Two-level Exact Algorithm: 1. Compute all primes. 2. Form the covering table. 3. Solve the minimum-column cover problem. <p> As a result, a minimum-row solution can be found by selecting a minimum number of prime implicants. (See [Rud89] for a brief on cost functions for plas.) Exact techniques based on this cost function <ref> [McC65, Rud89] </ref> employ the following algorithm: Two-level Exact Algorithm: 1. Compute all primes. 2. Form the covering table. 3. Solve the minimum-column cover problem. The covering table contains one row for each minterm of the ON-set and one column for each prime. <p> A '1' entry in the table indicates that the column prime covers the row minterm. The 4.1. INTRODUCTION 63 minimum-column cover represents a minimum set of prime implicants that implement the output functions, which corresponds to a minimum-row pla implementation. (As noted in <ref> [Rud89] </ref>, this does not guarantee a minimum-transistor (minimum-literal) implementation as this cost function does not satisfy the assumption above. See [Rot80] for a minimum-transistor optimization algorithm. <p> The complete table is formed and the covering problem solved. See <ref> [Rud89] </ref> for efficient minimum column-covering algorithms. 4.6.4 Generating an Implementation Once the minimum set of synchronous primes has been selected, an implementation is generated directly by implementing each prime c (I c ) by its implicit structure (c) i c max . <p> x 2 2 (0; 6 1) contained by x 2 (2) Despite the overhead of partitioning the function, converting it to and from a synchronous representation, and generating extra cubes when generating primes, this method for prime generation has a distinct advantage since efficient combinational prime generation techniques already exist <ref> [Rud89] </ref>. One property of optimizing two-level sequential circuits is made apparent by this formulation. <p> Technology Mapping The strategy of representing feedback lines by latches with a PO/PI pair preserves the acyclic nature of the circuit representation and allows the combinational technology mapping algorithms to be easily extended to sequential technology mapping [MLSB89]. The same tree-covering algorithm <ref> [Rud89] </ref> is used but the pattern matching procedure is extended to accommodate sequential elements. The pattern matching relies no longer on just the network topology but also on the type of library element and on the location of latch input and output pins.
Reference: [Rud93a] <author> R. Rudell. </author> <title> Dynamic Variable Ordering for Ordered Binary Decision Diagrams. </title> <booktitle> In Proceedings of the IEEE International Conference on Computer-Aided Design, </booktitle> <pages> pages 42-47, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: Verification (f g?) requires a graph isomorphism check, and since bdds are rooted dags this is linear in the number of nodes in the bdds. The canonicity property of bdds, efficient bdd package implementation [BRB90, Lon93], and recent improvements in variable ordering strategies <ref> [Rud93a] </ref> have made bdd-based algorithms successful for verification at various levels of the design process [MWBSV88, FFK88, CMB90, BCM90, TSL + 90, HTKB92].
Reference: [Rud93b] <author> Richard Rudell, </author> <month> May </month> <year> 1993. </year> <type> Personal communication. </type>
Reference-contexts: Quite large circuits have been successfully verified (e.g., a 12x12 multiplier has been verified within a 32Mbyte memory limit <ref> [Rud93b] </ref>, despite the inherent difficulty in representing multipliers using bdds [Bry92]).
Reference: [RY85] <author> L. Y. Rosenblum and A. V. Yakovlev. </author> <title> Signal Graphs: from Self-timed to Timed Ones. </title> <booktitle> In International Workshop on Timed Petri Nets, </booktitle> <address> Torino, Italy, </address> <year> 1985. </year>
Reference-contexts: Other methods of input are by reading from the Oct database, and through a sequential circuit netlist called slif (Stanford Logic Interchange Format) [DeM89]. For asynchronous circuits, the input is a signal transition graph <ref> [Chu87, RY85] </ref>. The logic implementation (or netlist description) is given in extended blif (Berke-ley Logic Interchange Format) which consists of interconnected single-output combinational gates and latches. The blif format used in misii has been augmented to allow the specification of latches and controlling clocks.
Reference: [Sav92] <author> Hamid Savoj. </author> <title> Don't Cares in Multi-Level Network Optimization. </title> <type> PhD thesis, </type> <institution> University of California Berkeley, Electronics Research Laboratory, College of Engineering, University of California, Berkeley, </institution> <address> CA 94720, </address> <month> May </month> <year> 1992. </year>
Reference-contexts: These ideas were extended in [SB90, SBT91] and applied to general multilevel networks. In <ref> [Sav92, DD91] </ref>, algorithms are given for efficient computation of mspfs and maximal cspfs. Beginning at the outputs with the external don't cares and working towards the inputs, cspfs are computed at each node and can be used in the simplification of that node simultaneously with simplifying other nodes. 2.2. <p> Both exact [BS89a] and heuristic [WB91] techniques for finding optimum and optimal solutions based on two-level implementations have been published. These techniques are similar to two-level minimization techniques. 2.2.5 Observability Relation The observability relation, or network characteristic function, has been described and used in <ref> [Cer77, Sav92] </ref>. It is a characteristic function O : B n+m ! B which specifies all allowed output vectors for each input vector of the circuit. It is capable of expressing all types of don't cares and Boolean relations, but in practice is usually too large to build and manipulate. <p> image (h 1 (s)) image ( h 1 (s)) = image (h 1 (s)) " image ( h 1 (s)) If h fl is defined as h fi + p 4 , the computation is simplified to a single image computation (this is the same computation as that used in <ref> [Sav92] </ref> to map don't cares to the local space of a node): h fl (y) = image (h 1 (s)) " image ( h 1 (s)) [ image (h 1 (s)) [ image ( h 1 (s)) = image ( h 1 (s)) = S s i=1 Since p 0 4 <p> When network N 2 is connected to N 1, the don't cares in N 1 should be propagated to N 2 to optimize that network. Using the observability relation <ref> [Cer77, Sav92] </ref> to propagate the don't cares: OBS = S y i=1 y i f i + y i f i + d y i i=1 ) d z 1 = @z 1 d z 2 = @z 2 3.2. <p> Theorem 3.3.2 Let y i = f i (x) and d y i be the given don't care functions. Let z = h (y) be the (only) output of the node or network. Computing the don't care function d z for z using the observability relation calculation <ref> [Sav92] </ref> d z = @z ( n Y zh + z h ) is equivalent to computing d z using the observable set formulation: d z = g y @ y i 2g 1 Proof. <p> The h fl calculation includes part of the SDC set. If the output registers are moved, the don't care functions for these nodes are propagated to neighboring nodes using the techniques in Section 3.3. Using the techniques described in <ref> [Sav92] </ref> to propagate don't care information backward guarantees that the maximal compatible property is retained, so the don't cares can be used simultaneously during node simplification. 3.4.1 Applications There are a number of places in the synthesis procedure where retiming don't cares is beneficial. <p> Here, flexibility means choice in the actual function implemented (as opposed to choice in how that function is implemented). Flexibility in various forms has been studied extensively, 122 CHAPTER 6. FLEXIBILITY IN BOOLEAN FUNCTIONS and includes don't care conditions for optimization of combinational <ref> [BHMSV84, BBH + 88, MKLC89, Sav92] </ref> and sequential [DM92a, RHS91] two-level and multilevel circuits as single entities (each output can be optimized independently), Boolean relations [BS89b, BS89a, WB91] which express relationships between outputs and are derived from the surrounding environment, and synchronous recurrence equations [DM92b] for optimization of sequential circuits in <p> In the presence of a surrounding environment of interacting finite state machines, the observability and the controllability of a finite state machine is reduced. This sequential flexibility is referred to as sequential controllability and observability don't cares, quite similar to the case for combinational circuits <ref> [Sav92] </ref>. As [RHS91] have shown, the sequential don't cares for the interacting finite state machine environment can be represented as finite sequences of input-output pairs. This can be naturally cast into the synchronous recurrence equations that were described in the last section.
Reference: [Sax85] <author> James B. Saxe. </author> <title> Decomposable Searching Problems and Circuit Optimization by Retiming: Two Studies in General Transformations of Computational Structures. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, Department of Computer Science, </institution> <month> August </month> <year> 1985. </year> <note> CMU-CS-85-162. 184 BIBLIOGRAPHY </note>
Reference-contexts: Retiming [LS88] has been implemented for cycle-time optimization of synchronous edge-triggered designs. The original algorithm [LS83] was based on a mixed-integer linear programming formulation for determining the feasibility of a particular cycle time. Later, more efficient relaxation-based techniques were reported <ref> [Sax85] </ref>. Both approaches are im B.4. SYNTHESIS AND OPTIMIZATION 171 plemented in the retime command in sis. To determine the optimal cycle time, the feasible cycle time algorithm is combined with a binary search procedure through a range of cycle times.
Reference: [SB90] <author> H. Savoj and R.K. Brayton. </author> <title> The Use of Observability and External Don't Cares for the Simplification of Multi-Level Networks. </title> <booktitle> In Proceedings of the 27 th Design Automation Conference, </booktitle> <pages> pages 297-301, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: These ideas were extended in <ref> [SB90, SBT91] </ref> and applied to general multilevel networks. In [Sav92, DD91], algorithms are given for efficient computation of mspfs and maximal cspfs. <p> Re-expressing don't cares is done 3.3. DON'T CARE CONDITIONS 43 x 1 x p y n z 1 y 1 f 2 (x) d y 2 (x) d y n (x) g 2 (y) as described in Section 3.2.2. Propagating don't cares backward is described in <ref> [SB90] </ref> and summarized in Section 2.2.3. Propagating don't cares forward can be done using the observability relation as described in Section 2.2.5, but this relation may be too large to build in practice.
Reference: [SBSV92] <author> A. Saldanha, R.K. Brayton, and A.L. Sangiovanni-Vincentelli. </author> <title> Circuit Structure Relations to Redundancy and Delay: The KMS Algorithm Revisited. </title> <booktitle> In Proceedings of the 29 th Design Automation Conference, </booktitle> <pages> pages 245-248, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: With this extension, any acyclic circuit can be expanded so that a peripheral retim-ing exists. The complete algorithm for generating an equivalent network with a peripheral 3 This is similar to the false path elimination algorithm of <ref> [SBSV92] </ref>, where all paths from the inputs are divided into those of length &gt; t and those of length t. Here, a length is measured in terms of registers along a path, and all input leads are separated into distinct lengths. 4 This was rarely observed experimentally. 108 CHAPTER 5.
Reference: [SBT91] <author> H. Savoj, R.K. Brayton, and H.J. Touati. </author> <title> Extracting Local Don't Cares for Network Optimization. </title> <booktitle> In Proceedings of the IEEE International Conference on Computer-Aided Design, </booktitle> <pages> pages 514-517, </pages> <month> November </month> <year> 1991. </year>
Reference-contexts: These ideas were extended in <ref> [SB90, SBT91] </ref> and applied to general multilevel networks. In [Sav92, DD91], algorithms are given for efficient computation of mspfs and maximal cspfs.
Reference: [SDG93] <author> A. Shen, S. Devadas, and A. Ghosh. </author> <title> Probabilistic Construction and Manipulation of Free Boolean Diagrams. </title> <booktitle> In Proceedings of the IEEE International Conference on Computer-Aided Design, </booktitle> <pages> pages 544-549, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: Current research efforts include new variable ordering strategies, a multitude of new applications for bdds, extensions of bdds to represent integer functions [CFM + 93, BFG + 93], exploration of free bdds that are not ordered and are more compact <ref> [BCW80, GM94, SDG93] </ref>, and a novel modification called the zero-suppressed bdd for efficient representation of sets [Min93b, Min93a]. 2.1.6 Image Computation and Characteristic Functions Many algorithms for Boolean function manipulation rely on an efficient computation of the set of output minterms produced by a particular set of input minterms.
Reference: [She93] <author> Narendra Shenoy. </author> <title> Timing Issues in Sequential Circuits. </title> <type> PhD thesis, </type> <institution> University of California Berkeley, Electronics Research Laboratory, College of Engineering, University of California, Berkeley, </institution> <address> CA 94720, </address> <month> November </month> <year> 1993. </year> <note> In preparation. </note>
Reference-contexts: At each iteration, the reached states are checked for equivalent output functions. The verify fsm command in sis has verified machines with more than 10 68 states [TSL + 90]. Optimal Clocking The new timing package in sis <ref> [She93] </ref> handles clocking strategies for synchronous circuits. Mixed edge-triggered and level-clocked designs can be synthesized. The c check command verifies that the set-up and hold constraints for a proposed clocking scheme are 172 APPENDIX B. SIS met for each delay element.
Reference: [Sin92] <author> Kanwar Jit Singh. </author> <title> Performance Optimization of Digital Circuits. </title> <type> PhD thesis, </type> <institution> University of California Berkeley, Electronics Research Laboratory, College of Engineering, University of California, Berkeley, </institution> <address> CA 94720, </address> <month> November </month> <year> 1992. </year> <note> Memorandum No. UCB/ERL M92/149. </note>
Reference-contexts: A number of new techniques for performance optimization have been implemented. The speed up command reduces the depth of the (2-input nand gate) decomposed network, restructures by collapsing along long paths, and resynthesizes for better performance <ref> [Sin92] </ref>. The reduce depth command uniformly reduces the depth of the circuit by forming clusters of nodes and collapsing the clusters. Both speed up and reduce depth perform technology-independent network restructuring.
Reference: [Sin93] <author> Kanwar Jit Singh, </author> <month> November </month> <year> 1993. </year> <type> Personal communication. </type>
Reference-contexts: Such inefficiencies are typically not found in hand-crafted designs. Second, in extracting a gate-level description from layout, the extraction may create a description that has simple sequential redundancies and easily-detected common factors <ref> [Sin93] </ref>. Any further manipulations of this extracted design (e.g., verifying its description with a specification) will be made more efficient by first optimizing it with these techniques. The maximal peripheral retiming and resynthesis algorithm described in this chapter has a niche in the gate-level sequential optimization process. <p> This may be used, for example, to verify that the layout-level design is equivalent to some higher-level specification or map an old implementation into a newer technology. Such an extraction process can create a suboptimal gate-level description <ref> [Sin93] </ref> that can be improved by the techniques proposed herein. Deriving and exploiting flexibility in implementing a design has become more and more important for all levels of logic synthesis.
Reference: [SSL + 92] <author> E.M. Sentovich, K.J. Singh, L. Lavagno, C. Moon, R. Murgai, A. Saldanha, H. Savoj, P.R. Stephan, R.K. Brayton, and A.L. Sangiovanni-Vincentelli. </author> <note> SIS: </note>
Reference-contexts: These functions are then updated incrementally after retiming, avoiding another complete unreachable state computation for the retimed circuit. 3.4.2 Implementation An outline of the algorithm for preserving don't cares during retiming is given in Figure 3.12. These techniques have been implemented in sis <ref> [SSL + 92, SSM + 92] </ref>, the sequential circuit synthesis program being developed at UC Berkeley. Whenever a retiming is done, the don't cares are updated accordingly. <p> This creates a more compact but not complete covering table. The result is the same for the complete table.) Solution: f = x 1 x 2 x 3 (0; 1). f x 1 x 3 4.7 Algorithm Implementation The ideas in this chapter have been implemented in sis <ref> [SSL + 92, SSM + 92] </ref> using espresso as a starting point. The theory presented in the last few sections treats syn chronous functions in a slightly different way than combinational functions. <p> For more detailed information, including tutorial examples illustrating the design process using sis, details of interchange formats, and an extensive list of references, the reader is referred to <ref> [SSL + 92] </ref>. B.2 Overview sis is one of a large set of cad tools maintained and distributed by the cad research group at UC Berkeley. <p> The final entry point to sis is the signal transition graph which is an event-based specification for asynchronous circuits. A detailed description and examples are given in more detail in <ref> [SSL + 92] </ref>. B.4. SYNTHESIS AND OPTIMIZATION 169 B.4 Synthesis and Optimization B.4.1 stg Synthesis State minimization has been implemented in sis to allow the user to choose among various state minimization programs.
References-found: 91

