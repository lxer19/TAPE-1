URL: http://www.cs.sunysb.edu/~juliana/lpnmr.ps.gz
Refering-URL: http://www.cs.sunysb.edu/~juliana/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: XSB A System for Efficiently Computing Well Founded Semantics a full Prolog system that closely
Author: Prasad Rao, Konstantinos Sagonas, Terrance Swift, David Warren and Juliana Freire 
Note: XSB is  
Address: NY 11794-4400  
Affiliation: Department of Computer Science SUNY at Stony Brook Stony Brook,  
Abstract: The well-founded model provides a natural and robust semantics for logic programs with negative literals in rule bodies. We implemented the well-founded semantics in the SLG-WAM of XSB. Performance results indicate that the overhead of delay and simplification to Prolog | or tabled | evaluations is minimal. To compute the well-founded semantics, the SLG-WAM adds to an efficient tabling engine three operations | negative loop detection, delay and simplification | which serve to detect, to break and to resolve the cycles through negation that arise in evaluating normal programs 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F. Banchilhon, D. Maier, Y. Sagiv, and J. Ullman. </author> <title> Magic sets and other strange ways to implement logic programs. </title> <booktitle> In PODS. ACM, </booktitle> <year> 1986. </year>
Reference-contexts: The inability of Prolog to answer such queries, which arise frequently, comprises one of its major limitations as an implementation of logic. A number of approaches have been developed which solve programs like ancestor by reusing partial answers to the query ancestor (1,Y) <ref> [9, 24, 1, 26, 27] </ref>. Briefly, the ideas behind these algorithms can be described in the following manner. First, the program keeps track of nodes where calls to ancestor (1,Y) have been made.
Reference: [2] <author> F. Banchilhon and R. Ramakrishnan. </author> <title> An amateur's introduction to recursive query processing strategies. </title> <booktitle> In Proc. of SIGMOD 1986 Conference, </booktitle> <pages> pages 16-52. </pages> <publisher> ACM, </publisher> <year> 1986. </year>
Reference-contexts: The same generation program furnishes a case of the usefulness of tabling for optimizing a Prolog program. Example 4.1 The query ?- sg (1,X),fail. was executed against the program sg (X,Y) :- cyl (X,X1), sg (X1,Y1), cyl (Y,Y1). using a 24x24x2 randomly generated cylinder <ref> [2] </ref>, as the base relation cyl/2. A cylinder can be thought of as a rectangular matrix of elements where each element in row N has links to a certain 7 number of elements in row N + 1.
Reference: [3] <author> W. Chen, M. Kifer, and D.S. Warren. HiLog: </author> <title> A foundation for higher-order logic programming. </title> <journal> J. Logic Programming, </journal> <volume> 15(3) </volume> <pages> 187-230, </pages> <year> 1993. </year>
Reference-contexts: Prolog, of course, would enter an infinite loop. XSB's treatment of negation is discussed further in Section 2. The second important extension in XSB is support of HiLog programming. However due to space limitations HiLog is not discussed here, but is disscussed in detail in <ref> [3, 22] </ref>. <p> The research features of XSB tabling, HiLog, and indexing techniques are not discussed in this document. Documents related to them <ref> [3, 22, 6, 17] </ref> can be found via the world-wide web or anonymous ftp from fwww/ftpg.cs.sunysb.edu, the same host from which XSB can be obtained. The rest of this paper is organized as follows: Section 2 describes SLG evaluation and the computation of the Well-Founded semantics in XSB.
Reference: [4] <author> W. Chen and D. S. Warren. </author> <title> Tabled Evaluation with Delaying for General Logic Programs. </title> <journal> Journal of the ACM, </journal> <volume> 43(1) </volume> <pages> 20-74, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: These facilities, while seemingly simple, significantly extend its capabilities beyond those of a typical Prolog system. We feel that these capabilities justify viewing XSB as a new paradigm for Logic Programming. To understand the implications of SLG resolution <ref> [4] </ref>, recall that Prolog is based on a depth-first search strategy (SLD) which uses program clause resolution. As such, Prolog is susceptible to getting lost in an infinite branch of a search tree, where it may loop infinitely. SLG evaluation, available in XSB, can correctly evaluate many such logic programs. <p> In the language of <ref> [4] </ref>, the first call of a (leftmost) goal is called a generator node, and is expanded using program clauses as in SLD resolution (Prolog).
Reference: [5] <author> M. Codish, B. Demoen, and K. Sagonas. </author> <title> Xsb as a general purpose program analyzer. </title> <type> Technical report, </type> <institution> KU Leuven, </institution> <year> 1996. </year>
Reference-contexts: This power to solve recursive queries has proven very useful in a number of areas, including deductive databases, language processing [13, 14], meta-interpreters, and program analysis <ref> [7, 5] </ref>. For efficiency, we have implemented SLG at the abstract machine level so that tabled predicates will be executed with the speed of compiled Prolog.
Reference: [6] <author> S. Dawson, C. R. Ramakrishnan, I. V. Ramakrishnan, K. Sagonas, S. Skiena, T. Swift, and D. S. Warren. </author> <title> Unification factoring for efficient execution of logic programs. </title> <booktitle> In Proc. of the 22nd Symposium on Principles of Programming Languages, </booktitle> <pages> pages 247-258. </pages> <publisher> ACM, </publisher> <year> 1995. </year>
Reference-contexts: The research features of XSB tabling, HiLog, and indexing techniques are not discussed in this document. Documents related to them <ref> [3, 22, 6, 17] </ref> can be found via the world-wide web or anonymous ftp from fwww/ftpg.cs.sunysb.edu, the same host from which XSB can be obtained. The rest of this paper is organized as follows: Section 2 describes SLG evaluation and the computation of the Well-Founded semantics in XSB. <p> Clauses can be indexed on a groups of arguments or on alternative arguments. For a detailed description of this mode of indexing see [21]. Another form of assert that utilizes the full prefix indexing provided by tries is also available. For compiled code, XSB offers unification factoring <ref> [6] </ref>, which extends clause indexing methods found in functional programming into the logic programming framework.
Reference: [7] <author> S. Dawson, C.R. Ramakrishnan, and D.S. Warren. </author> <title> Practical program analysis using general purpose logic programming systems | a case study. </title> <booktitle> In ACM PLDI, </booktitle> <year> 1996. </year> <note> To Appear. </note>
Reference-contexts: This power to solve recursive queries has proven very useful in a number of areas, including deductive databases, language processing [13, 14], meta-interpreters, and program analysis <ref> [7, 5] </ref>. For efficiency, we have implemented SLG at the abstract machine level so that tabled predicates will be executed with the speed of compiled Prolog.
Reference: [8] <author> S. Debray. </author> <title> SB-Prolog System, Version 3.0, A User Manual, </title> <year> 1988. </year>
Reference-contexts: Many of the components of XSB are based on PSB-Prolog [28], which itself is based on version 2.0 of SB-Prolog <ref> [8] </ref>. Though XSB can be used as a Prolog system, we avoid referring to XSB as such, because of the availability of SLG resolution and the handling of HiLog terms. These facilities, while seemingly simple, significantly extend its capabilities beyond those of a typical Prolog system.
Reference: [9] <author> S. Dietrich. </author> <title> Extension Tables for Recursive Query Evaluation. </title> <type> PhD thesis, </type> <institution> SUNY at Stony Brook, </institution> <year> 1987. </year>
Reference-contexts: The inability of Prolog to answer such queries, which arise frequently, comprises one of its major limitations as an implementation of logic. A number of approaches have been developed which solve programs like ancestor by reusing partial answers to the query ancestor (1,Y) <ref> [9, 24, 1, 26, 27] </ref>. Briefly, the ideas behind these algorithms can be described in the following manner. First, the program keeps track of nodes where calls to ancestor (1,Y) have been made.
Reference: [10] <author> J. Freire, T. Swift, and D.S. Warren. </author> <title> Beyond depth-first: Improving tabled logic programs through alternative scheduling strategies. </title> <booktitle> In 8th International PLILP Symposium. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: The scheduling of answer returns is an important issue for efficiency of evaluations. Indeed, the tabling scheduling strategy of XSB was thoroughly revised in version 1.5 to use a strategy that is more efficient in terms of time and space <ref> [10] </ref>. The same paper outlined implementation of a second scheduling strategy, Local Scheduling, which has applications to non-monotonic reasoning and when combined with answer subsumption can improve the performance of some programs by arbitrary amounts. 4 Performance The SLG-WAM overhead for SLD resolution is minimal.
Reference: [11] <author> M. Gelfond and V. Lifshitz. </author> <title> The stable model semantics for logic programming. </title> <booktitle> In Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 1070-1080, </pages> <year> 1988. </year>
Reference-contexts: This semantics is a natural extension from a programmer's perspective. It can be shown that a program is dynamically stratified 5 if and only if it has a two-valued well-founded model. Furthermore, more elaborate forms of non--monotonic reasoning, such as stable models <ref> [11] </ref> can be built using the well-founded model. Indeed, XSB provides a residual program which, as explained below, can be used to evaluate stable models of a program. The intuition behind the Well-Founded semantics can be explained through the operations of tabling.
Reference: [12] <author> D. Kemp and R. Topor. </author> <title> Completeness of a top-down query evaluation procedure for stratified databases. </title> <booktitle> In Logic Programming: Proc. of the Fifth International Conference and Symposium, </booktitle> <pages> pages 178-194, </pages> <year> 1988. </year>
Reference-contexts: Second, because of the way that solutions are stored and returned to active nodes in XSB, answers may be returned to the user in an unaccustomed order. 2.2 Left-to-Right Dynamically Stratified Negation Most of the original definitions for tabling algorithms considered only definite programs, though some (e.g. <ref> [12, 23] </ref>) extended tabling to programs with restricted forms of stratified negation. Broadly, a program uses stratified negation whenever there is no recursion through negation. Refining this intuition can lead to an array of stratification classes.
Reference: [13] <author> R. Larson, D. S. Warren, J. Freire, and K. </author> <title> Sagonas. </title> <publisher> Syntactica. MIT Press, </publisher> <year> 1995. </year>
Reference-contexts: Alternately, an auto table compiler directive can be used to direct the system to invoke a simple static analysis to decide what predicates to table. This power to solve recursive queries has proven very useful in a number of areas, including deductive databases, language processing <ref> [13, 14] </ref>, meta-interpreters, and program analysis [7, 5]. For efficiency, we have implemented SLG at the abstract machine level so that tabled predicates will be executed with the speed of compiled Prolog.
Reference: [14] <author> R. Larson, D. S. Warren, J. Freire, K. Sagonas, and P. Gomez. </author> <title> Semantica. </title> <publisher> MIT Press, </publisher> <year> 1995. </year> <note> In preparation. 9 </note>
Reference-contexts: Alternately, an auto table compiler directive can be used to direct the system to invoke a simple static analysis to decide what predicates to table. This power to solve recursive queries has proven very useful in a number of areas, including deductive databases, language processing <ref> [13, 14] </ref>, meta-interpreters, and program analysis [7, 5]. For efficiency, we have implemented SLG at the abstract machine level so that tabled predicates will be executed with the speed of compiled Prolog.
Reference: [15] <author> T. Lindholm and R.A. O'Keefe. </author> <title> Efficient implementation of a defensible semantics for dynamic PROLOG code. </title> <booktitle> In Proceedings of the International Conference on Logic Programming, </booktitle> <pages> pages 21-39, </pages> <year> 1987. </year>
Reference-contexts: At the same time, because asserted code is compiled into SLG-WAM code, the speed of executing asserted code in XSB is faster than that of other Prologs as well. We note however, that XSB does not follow the semantics of assert specified in <ref> [15] </ref>. XSBdoes not compile programs directly into memory but rather generates SLG-WAM object code (called byte code) into files. The object files can be executed directly by the emulator or, as is more usual, loaded by the interpreter (which itself is a byte code file executed by the emulator).
Reference: [16] <author> T.C. Przymusinski. </author> <title> Every logic program has a natural stratification and an iterated least fixed point model. </title> <booktitle> In PODS, </booktitle> <pages> pages 11-21, </pages> <year> 1989. </year>
Reference-contexts: The adjective "left-to-right" comes from the fixed order in which the evaluation selects literals in the body. The adjective "dynamic" arises from the fact that run-time information is central to whether the derivation path remains suspended or not. LRD-stratified programs and their evaluation method are explained in detail in <ref> [20, 16] </ref>. However, the following simple program is LRD-stratified, but does not fit into other stratification classes (e.g. the more familiar class of (left-to-right) modularly stratified programs [18]. p:- q,: r,: s. r:-p,: q. <p> Consider the program p:- : s,,: r, q. r:-p,: q. which cannot be evaluated by the method sketched above. Such programs, are called dynamically stratified, but may not be stratified for any particular evaluation order <ref> [16] </ref>. Version 1.7 of XSB handles dynamically stratified programs through delaying negative literals when it becomes necessary to look to their right in a clause, and then simplifying away the delayed literals when and if their truth value becomes known.
Reference: [17] <author> I.V. Ramakrishnan, P. Rao, K. Sagonas, T. Swift, and D.S. Warren. </author> <title> Efficient table access mechanisms for logic programs. </title> <editor> In L. Sterling, editor, </editor> <booktitle> International Conference on Logic Programming, </booktitle> <pages> pages 697-711, </pages> <year> 1995. </year>
Reference-contexts: The research features of XSB tabling, HiLog, and indexing techniques are not discussed in this document. Documents related to them <ref> [3, 22, 6, 17] </ref> can be found via the world-wide web or anonymous ftp from fwww/ftpg.cs.sunysb.edu, the same host from which XSB can be obtained. The rest of this paper is organized as follows: Section 2 describes SLG evaluation and the computation of the Well-Founded semantics in XSB. <p> Correct answer substitutions to the solution node are interned in the table entry (call plus returns) for a call. 3 (For details see <ref> [17] </ref>.) Subsequent calls (that is, subsequent variant or subsumed calls) are referred to as active nodes 1 , and are expanded using answers derived for that goal instead of program clauses.
Reference: [18] <author> K.A. Ross. </author> <title> The Semantics of Deductive Databases. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Stanford University, </institution> <year> 1991. </year>
Reference-contexts: LRD-stratified programs and their evaluation method are explained in detail in [20, 16]. However, the following simple program is LRD-stratified, but does not fit into other stratification classes (e.g. the more familiar class of (left-to-right) modularly stratified programs <ref> [18] </ref>. p:- q,: r,: s. r:-p,: q. Before leaving the subject of stratification, we note that the use of completion also forms the basis of evaluation of programs with stratified findall/3 2.3 Dynamic Stratification A simple rearrangement of the program of the previous section causes it not to be LRD-stratified.
Reference: [19] <author> K. Sagonas, T. Swift, and D.S. Warren. </author> <title> XSB as an efficient deductive database engine. </title> <booktitle> In Proc. of SIGMOD 1994 Conference. ACM, </booktitle> <year> 1994. </year>
Reference-contexts: A goal of XSB is to provide in implementation engine for both logic programming and in-memory deductive database queries <ref> [19] </ref>. One prerequisite for this functionality is the ability to load a large amount of data very quickly. We have taken care to code in C a compiler for asserted clauses. <p> While the judicious use of tabling can make some programs faster, its indiscriminate use can make other programs slower. For instance, tabling append/3 3 slows the linear algorithm to a quadratic one. A detailed analysis of the performance of XSB can be found in <ref> [19] </ref>. 4.1 Performance of Well-Founded Negation To our knowledge, the win/1 program is still the only standard scalable benchmark in the well-founded semantics literature. Its SLG and SLDNF versions, using XSB, are shown below. SLDNF resolution is sufficient for acyclic move/2 graphs (like chains and trees). <p> In the case of the complete binary tree, however, tabled negation is much slower. This is because tabled negation has to fully evaluate negative literals before completing them, and consequently, it traverses the entire search space which is exponential in the height of the tree (see <ref> [19] </ref>). 5 Conclusion The goal of the XSB system is to provide a framework and environment that gracefully integrates Logic Programming, inmemory Deductive Database query processing, and Nonmonotonic Reasoning with respect the the Well-Founded Semantics.
Reference: [20] <author> K. Sagonas, T. Swift, and D.S. Warren. </author> <title> The limits of fixed-order computation. </title> <booktitle> In International Workshop on Logic and Databases. </booktitle> <publisher> LNAI: Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Broadly, a program uses stratified negation whenever there is no recursion through negation. Refining this intuition can lead to an array of stratification classes. While XSB evaluates all programs, whether stratified or not, its evaluation is especially efficient for LRD-stratified programs <ref> [20] </ref>, which we now explain. Consider a simple approach to incorporate negation into tabling, and assume, to avoid complications of floundering, that the entire program is ground | that no clause of the program contains any variable. <p> The adjective "left-to-right" comes from the fixed order in which the evaluation selects literals in the body. The adjective "dynamic" arises from the fact that run-time information is central to whether the derivation path remains suspended or not. LRD-stratified programs and their evaluation method are explained in detail in <ref> [20, 16] </ref>. However, the following simple program is LRD-stratified, but does not fit into other stratification classes (e.g. the more familiar class of (left-to-right) modularly stratified programs [18]. p:- q,: r,: s. r:-p,: q.
Reference: [21] <author> K. Sagonas, T. Swift, and D.S. Warren. </author> <title> The XSB Programmer's Manual: </title> <note> version 1.6, </note> <year> 1996. </year>
Reference-contexts: XSB offers a variety of indexing techniques for asserted code. Clauses can be indexed on a groups of arguments or on alternative arguments. For a detailed description of this mode of indexing see <ref> [21] </ref>. Another form of assert that utilizes the full prefix indexing provided by tries is also available. For compiled code, XSB offers unification factoring [6], which extends clause indexing methods found in functional programming into the logic programming framework.
Reference: [22] <author> K. Sagonas and D.S. Warren. </author> <title> Efficient execution of HiLog in WAM-based Prolog implementations. </title> <booktitle> In International Conference on Logic Programming, </booktitle> <year> 1995. </year> <note> To Appear. </note>
Reference-contexts: Prolog, of course, would enter an infinite loop. XSB's treatment of negation is discussed further in Section 2. The second important extension in XSB is support of HiLog programming. However due to space limitations HiLog is not discussed here, but is disscussed in detail in <ref> [3, 22] </ref>. <p> The research features of XSB tabling, HiLog, and indexing techniques are not discussed in this document. Documents related to them <ref> [3, 22, 6, 17] </ref> can be found via the world-wide web or anonymous ftp from fwww/ftpg.cs.sunysb.edu, the same host from which XSB can be obtained. The rest of this paper is organized as follows: Section 2 describes SLG evaluation and the computation of the Well-Founded semantics in XSB.
Reference: [23] <author> H. Seki. </author> <title> On the power of Alexandrer templates. </title> <booktitle> In Proc. of 8th PODS, </booktitle> <pages> pages 150-159. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: Second, because of the way that solutions are stored and returned to active nodes in XSB, answers may be returned to the user in an unaccustomed order. 2.2 Left-to-Right Dynamically Stratified Negation Most of the original definitions for tabling algorithms considered only definite programs, though some (e.g. <ref> [12, 23] </ref>) extended tabling to programs with restricted forms of stratified negation. Broadly, a program uses stratified negation whenever there is no recursion through negation. Refining this intuition can lead to an array of stratification classes.
Reference: [24] <author> H. Tamaki and T. Sato. </author> <title> OLDT resolution with tabulation. </title> <booktitle> In Third International Conference on Logic Programming, </booktitle> <pages> pages 84-98, </pages> <year> 1986. </year>
Reference-contexts: For efficiency, we have implemented SLG at the abstract machine level so that tabled predicates will be executed with the speed of compiled Prolog. We finally note that for definite programs SLG resolution is similar to other tabling methods such as OLDT resolution <ref> [24] </ref> The use of tabling also makes possible the evaluation of programs with negation. When logic programming rules have negation, paradoxes become possible. <p> The inability of Prolog to answer such queries, which arise frequently, comprises one of its major limitations as an implementation of logic. A number of approaches have been developed which solve programs like ancestor by reusing partial answers to the query ancestor (1,Y) <ref> [9, 24, 1, 26, 27] </ref>. Briefly, the ideas behind these algorithms can be described in the following manner. First, the program keeps track of nodes where calls to ancestor (1,Y) have been made.
Reference: [25] <author> A. van Gelder, K.A. Ross, and J.S. Schlipf. </author> <title> Unfounded sets and well-founded semantics for general logic programs. </title> <journal> JACM, </journal> <volume> 38(3) </volume> <pages> 620-650, </pages> <year> 1991. </year>
Reference-contexts: 1 Introduction XSB is a research-oriented Logic Programming system for Unix and Windows/DOS-based systems. In addition to providing all the functionality of Prolog, XSB contains several features not usually found in Logic Programming systems, including * Evaluation according to the Well-Founded Semantics <ref> [25] </ref> through full SLG resolution; * A compiled HiLog implementation; * A variety of indexing techniques for asserted code, along with a novel transformation technique called unification factoring that can improve program speed and indexing for compiled code; * Source code availability for portability and extensibility. <p> The difference in evaluation strategy means that, with appropriate declarations, XSB is complete under the well-founded semantics <ref> [25] </ref> for non-floundering normal programs (those with negation), and terminates when these programs have the bounded term-depth property, as will be explained below. This use of tabling allows a different, more declarative programming style than Prolog that can be of use for a number of problems. <p> That is, the value of a ground atom may be undefined in addition to being true or false. From the perspective of stratification, these programs are not even dynamically stratified. XSB, in fact, handles such programs, evaluating them according to the Well-Founded Semantics <ref> [25] </ref>. This semantics is a natural extension from a programmer's perspective. It can be shown that a program is dynamically stratified 5 if and only if it has a two-valued well-founded model.
Reference: [26] <author> L. Vieille. </author> <title> Recursive query processing: The power of logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 69 </volume> <pages> 1-53, </pages> <year> 1989. </year>
Reference-contexts: The inability of Prolog to answer such queries, which arise frequently, comprises one of its major limitations as an implementation of logic. A number of approaches have been developed which solve programs like ancestor by reusing partial answers to the query ancestor (1,Y) <ref> [9, 24, 1, 26, 27] </ref>. Briefly, the ideas behind these algorithms can be described in the following manner. First, the program keeps track of nodes where calls to ancestor (1,Y) have been made.
Reference: [27] <author> A. Walker. </author> <title> Backchain iteration: Towards a practical inference method that is simple enough to be proved terminating, sound, and complete. </title> <journal> J. Automated Reasoning, </journal> <volume> 11(1) </volume> <pages> 1-23, </pages> <address> 1993. Originally formulated in New York University TR 34, </address> <year> 1981. </year>
Reference-contexts: The inability of Prolog to answer such queries, which arise frequently, comprises one of its major limitations as an implementation of logic. A number of approaches have been developed which solve programs like ancestor by reusing partial answers to the query ancestor (1,Y) <ref> [9, 24, 1, 26, 27] </ref>. Briefly, the ideas behind these algorithms can be described in the following manner. First, the program keeps track of nodes where calls to ancestor (1,Y) have been made.
Reference: [28] <author> J. Xu. </author> <title> The PSB-Prolog User Manual, </title> <booktitle> 1990. </booktitle> <pages> 10 </pages>
Reference-contexts: Many of the components of XSB are based on PSB-Prolog <ref> [28] </ref>, which itself is based on version 2.0 of SB-Prolog [8]. Though XSB can be used as a Prolog system, we avoid referring to XSB as such, because of the availability of SLG resolution and the handling of HiLog terms.
References-found: 28

