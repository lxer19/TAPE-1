URL: http://www.cse.unsw.edu.au/~cs9242/lectures/Hartig_HLSW_97.ps
Refering-URL: http://www.cse.unsw.edu.au/~cs9242/lectures/
Root-URL: http://www.cse.unsw.edu.au
Email: email: l4-linux@os.inf.tu-dresden.de  email: jochen@watson.ibm.com  
Title: The Performance of -Kernel-Based Systems  
Author: Hermann Hartig Michael Hohmuth Jochen Liedtke Sebastian Schonberg Jean Wolter 
Address: D-01062 Dresden, Germany  30 Saw Mill River Road Hawthorne, NY 10532, USA  
Affiliation: Dresden University of Technology Department of Computer Science  IBM T. J. Watson Research Center  
Abstract: First-generation -kernels have a reputation for being too slow and lacking sufficient flexibility. To determine whether L4, a lean second-generation -kernel, has overcome these limitations, we have repeated several earlier experiments and conducted some novel ones. Moreover, we ported the Linux operating system to run on top of the L4 -kernel and compared the resulting system with both Linux running native, and MkLinux, a Linux version that executes on top of a first-generation Mach-derived -kernel. For L 4 Linux, the AIM benchmarks report a maximum throughput which is only 5% lower than that of native Linux. The corresponding penalty is 5 times higher for a co-located in-kernel version of MkLinux, and 7 times higher for a user-level version of MkLinux. These numbers demonstrate both that it is possible to implement a high-performance conventional operating system personality above a -kernel, and that the performance of the -kernel is crucial to achieve this. Further experiments illustrate that the resulting system is highly extensible and that the extensions perform well. Even real-time memory management including second-level cache allocation can be implemented at user-level, coexisting with L 4 Linux. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> V. Abrossimov, A. Demers, and C. Hauser. </author> <title> Generic virtual memory management for operating system kernels. </title> <booktitle> In 12th ACM Symposium on Operating System Principles (SOSP), </booktitle> <pages> pages 123136, </pages> <address> Lichfield Park, AZ, </address> <month> December </month> <year> 1989. </year>
Reference-contexts: Grafts executing in kernel mode can reduce the number of user/kernel mode switches and address-space switches. However, they either have to be completely trusted or need sand-boxing. Various systems have been built on that basis. They range from very pragmatic co-location techniques <ref> [1, 10] </ref> that simply trust co-located code to more sophisticated techniques that confine the potential damage of kernel extensions. However, Section 5 shows that simple co-location is not necessarily a promising technique. Co-located MkLinux performs worse than user-mode L 4 Linux.
Reference: [2] <institution> AIM Technology. AIM Multiuser Benchmark, Suite VII, </institution> <year> 1996. </year>
Reference-contexts: to be lines of C code Linux/x86 L 4 Linux architecture 2,500 6,500 dependent 2,000 j 2,000 part 4,500 8,500 Linux kernel 105,000 drivers 232,700 Table 1: Source-code lines for Linux/x86 and L 4 Linux. stable, and, as we'll show, can run such extreme stress test as the AIM benchmark <ref> [2] </ref> to completion. 5 Compatibility Performance In this section, we discuss the performance of L 4 Linux from the perspective of pure Linux applications. The conservative criterion for accepting a -kernel architecture is that existing applications are not significantly penalized. <p> 35.3 (1%) 34.5 (4%) 32.2 (1%) 32.7 (3%) 30.1 (4%) Mmap reread 64KB 97.5 (1%) 91.4 (1%) 78.8 (1%) 89.4 (1%) 77.7 (3%) Table 3: Selected OS-dependent lmbench and hbench-OS results. (133 MHz Pentium.) Standard deviations are shown in parentheses. test how well multiuser systems perform under different application loads <ref> [2] </ref>. (The AIM benchmark results presented in this paper are not certified by AIM Technology.) AIM uses the shared libc.so so that the trampoline overhead is automatically avoided.
Reference: [3] <author> A. W. Appel and K. Li. </author> <title> Virtual memory primitives for user programs. </title> <booktitle> In 4th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS), </booktitle> <pages> pages 73 80, </pages> <address> Santa Clara, CA, </address> <month> April </month> <year> 1991. </year>
Reference-contexts: The measured time includes the user instruction, page fault, notification of the pager by IPC, mapping a page and completing the original instruction. The next three experiments are taken from Appel and Li <ref> [3] </ref>. We compare the Linux version with an implementation using na L4 Linux Fault 6.2 s n/a Trap 3.4 s 12 s Appel1 12 s 55 s Appel2 10 s 44 s Table 5: Processor time for virtual-memory benchmarks. (133 MHz Pentium) tive L4 mechanisms.
Reference: [4] <author> N. Batlivala, B. Gleeson, J. Hamrick, S Lurndal, D. Price, J. Soddy, and V. Abrossimov. </author> <title> Experience with SVR4 over Chorus. </title> <booktitle> In USENIX Workshop on Micro-Kernels and Other Kernel Architectures, </booktitle> <pages> pages 223241, </pages> <address> Seattle, WA, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: A comparison of IPC performance of the three L4 -kernels can be found in [25]. 4 Linux on Top of L4 Many classical systems emulate Unix on top of a -kernel. For example, monolithic Unix kernels were ported to Mach [13, 15] and Chorus <ref> [4] </ref>. Very recently, a single-server experiment was repeated with Linux and newer, optimized versions of Mach [10]. To add a standard OS personality to L4, we decided to port Linux. Linux is stable, performs well, and is on the way to becoming a de-facto standard in the freeware world.
Reference: [5] <author> B. N. Bershad, S. Savage, P. Pardyak, E. G. Sirer, M. Fiuczynski, D. Becker, S. Eggers, and C. Chambers. </author> <title> Extensibility, safety and performance in the Spin operating system. </title> <booktitle> In 15th ACM Symposium on Operating System Principles (SOSP), </booktitle> <pages> pages 267284, </pages> <address> Copper Mountain Resort, CO, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: The too low faction concentrated on the extensible-kernel idea. Mechanisms were introduced to add functionality to kernels and their address spaces, either pragmatically (co-location in Chorus or Mach) or systematically. Various means were invented to protect kernels from misbehaving extensions, ranging from the use of safe languages <ref> [5] </ref> to expensive transaction-like schemes [34]. The too high faction started building kernels resembling a hardware architecture at their interface This research was supported in part by the Deutsche Forschungsgemein-schaft (DFG) through the Sonderforschungsbereich 358. [12]. Software abstractions have to be built on top of that. <p> Finally, Section 7 discusses alternative basic concepts from a performance point of view. 2 Related Work Most of this paper repeats experiments described by Bershad et al. <ref> [5] </ref>, des Places, Stephen & Reynolds [10], and Engler, Kaashoek & O'Toole [12] to explore the influence of a second-generation - kernel on user-level application performance. Kaashoek et al. describe in [18] how to build a Unix-compatible operating system on top of a small kernel. <p> We concentrate on the problem of porting an existing monolithic operating system to a -kernel. A large bunch of evaluation work exists which addresses how certain application or system functionality, e. g. a protocol implementation, can be accelerated using system specialization [31], extensible kernels <ref> [5, 12, 34] </ref>, layered path organisation [30], etc. Two alternatives to the pure -kernel approach, grafting and the Exoker-nel idea, are discussed in more detail in Section 7. Most of the performance evaluation results published elsewhere deal with parts of the Unix functionality. <p> Therefore, we assume that performance differences are mostly due to the underlying -kernel. First, we compare L 4 Linux (which always runs in user mode) to the MkLinux variant that also runs in user mode. Mach is known for slow user-to-user IPC and expensive user-level page-fault handling <ref> [5, 21] </ref>. So benchmarks should report a distinct difference between L 4 Linux and MkLinux if the -kernel efficiency influences the whole system significantly. A faster version of MkLinux uses a co-located server running in kernel mode and executing inside the -kernel's address space. <p> Co-located MkLinux performs worse than user-mode L 4 Linux. Vino [34] introduces a sophisticated yet expensive transaction mechanism; Exokernel [12, 36] enables application-specific handlers using a variety of mechanisms ranging from interpretable intermediate code to run time checking. SPIN <ref> [5] </ref> is an example of a well-performing, sophisticated grafting technique. Its kernel extensions use compile-time sand-boxing as much as possible and thus avoid additional runtime sand-boxing overhead except for subscript checking. Of the performance results published in [5], the virtual memory benchmarks favor SPIN's approach most. <p> SPIN <ref> [5] </ref> is an example of a well-performing, sophisticated grafting technique. Its kernel extensions use compile-time sand-boxing as much as possible and thus avoid additional runtime sand-boxing overhead except for subscript checking. Of the performance results published in [5], the virtual memory benchmarks favor SPIN's approach most. This makes sense, because for these tiny operations, the system-call and context-switching overhead counts heavily. Table 5 shows equivalent benchmarks on L4, running in user-mode. <p> This makes sense, because for these tiny operations, the system-call and context-switching overhead counts heavily. Table 5 shows equivalent benchmarks on L4, running in user-mode. The L4 times are between 2 and 4.7 times better (geometric mean: 3.1) than the times published for SPIN <ref> [5] </ref>. However, due to the different hardware platforms (SPIN: 133 MHz Alpha 21064, L4: 133 MHz Pentium) this comparison must be interpreted very cautiously.
Reference: [6] <author> A. B. Brown and M. I. Seltzer. </author> <title> Operating system benchmarking in the wake of lmbench: A case study of the performance of NetBSD on the Intel x86 architecture. </title> <booktitle> In ACM SIGMETRICS Conference on Measurement and Modeling of Computer Systems, </booktitle> <pages> pages 214224, </pages> <address> Seattle, WA, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: The lmbench [29] microbenchmark suite measures basic operations like system calls, context switches, memory accesses, pipe operations, network operations, etc. by repeating the respective operation a large number of times. lmbench's measurement methods have recently been criticized by Brown and Seltzer <ref> [6] </ref>. Their improved hbench:OS microbenchmark suite covers a broader spectrum of measurements and measures short operations more precisely.
Reference: [7] <author> M. E. Chastain. </author> <title> Linux kernel change summaries. </title> <address> URL: ftp://ftp.shout.net/pub/users/mec/kcs/. </address>
Reference-contexts: We used version 2 of the L4 -kernel. L 4 Linux is based on Linux version 2.0.21, MkLinux on version 2.0.28. According to the `Linux kernel change summaries' <ref> [7] </ref>, only performance-neutral bug fixes were added to 2.0.28, mostly in device drivers. We consider both versions comparable. Microbenchmarks are used to analyze the detailed behaviour of L 4 Linux mechanisms while macrobenchmarks measure the system's overall performance.
Reference: [8] <author> J. B. Chen and B. N. Bershad. </author> <title> The impact of operating system structure on memory system performance. </title> <booktitle> In 14th ACM Symposium on Operating System Principles (SOSP), </booktitle> <pages> pages 120133, </pages> <address> Asheville, NC, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: Two alternatives to the pure -kernel approach, grafting and the Exoker-nel idea, are discussed in more detail in Section 7. Most of the performance evaluation results published elsewhere deal with parts of the Unix functionality. An analysis of two complete Unix-like OS implementations regarding memory-architecture-based influences, is described in <ref> [8] </ref>. Currently, we do not know of any other full Unix implementation on a second-generation -kernel. And we know of no other recent end-to-end performance evaluation of -kernel-based OS personalities.
Reference: [9] <author> M. Condict, D. Bolinger, E. McManus, D. Mitchell, and S. Lewontin. </author> <title> Microkernel modularity with integrated kernel performance. </title> <type> Technical report, </type> <institution> OSF Research Institute, </institution> <address> Cambridge, MA, </address> <month> April </month> <year> 1994. </year>
Reference-contexts: And we know of no other recent end-to-end performance evaluation of -kernel-based OS personalities. We found no substantiation for the common knowledge that early Mach 3.0-based Unix single-server implementations achieved a performance penalty of only 10% compared to bare Unix on the same hardware. For newer hardware, <ref> [9] </ref> reports penalties of about 50%. 3 L4 Essentials The L4 -kernel [22] is based on two basic concepts, threads and address spaces. A thread is an activity executing inside an address space. Cross-address-space communication, also called inter-process communication (IPC), is one of the most fundamental - kernel mechanisms.
Reference: [10] <author> F. B. des Places, N. Stephen, and F. D. Reynolds. </author> <title> Linux on the OSF Mach3 microkernel. </title> <booktitle> In Conference on Freely Distributable Software, </booktitle> <address> Boston, MA, </address> <month> February </month> <year> 1996. </year> <title> Free Software Foundation, </title> <type> 59 Temple Place, Suite 330, </type> <address> Boston, MA 02111. </address> <note> Available from URL: http://www.gr.osf.org/~stephen/fsf96.ps. </note>
Reference-contexts: The performance of the resulting system is compared to the native Linux implementation and MkLinux, a port of Linux to a Mach 3.0 derived -kernel <ref> [10] </ref>. Furthermore, comparing L 4 Linux and MkLinux gives us some insight in how the -kernel efficiency influences the overall system performance. * The objective of three further experiments was to show the extensibility of the system and to evaluate the achievable performance. <p> Finally, Section 7 discusses alternative basic concepts from a performance point of view. 2 Related Work Most of this paper repeats experiments described by Bershad et al. [5], des Places, Stephen & Reynolds <ref> [10] </ref>, and Engler, Kaashoek & O'Toole [12] to explore the influence of a second-generation - kernel on user-level application performance. Kaashoek et al. describe in [18] how to build a Unix-compatible operating system on top of a small kernel. <p> For example, monolithic Unix kernels were ported to Mach [13, 15] and Chorus [4]. Very recently, a single-server experiment was repeated with Linux and newer, optimized versions of Mach <ref> [10] </ref>. To add a standard OS personality to L4, we decided to port Linux. Linux is stable, performs well, and is on the way to becoming a de-facto standard in the freeware world. <p> Our second question is * Does the performance of the underlying -kernel matter? To answer it, we compare L 4 Linux to MkLinux <ref> [10] </ref>, an OSF-developed port of Linux running on the OSF Mach 3.0 -kernel. Mk-Linux and L 4 Linux differ basically in the architecture-dependent part, except that the authors of MkLinux slightly modified Linux' architecture-independent memory system to get better performance on Mach. <p> Grafts executing in kernel mode can reduce the number of user/kernel mode switches and address-space switches. However, they either have to be completely trusted or need sand-boxing. Various systems have been built on that basis. They range from very pragmatic co-location techniques <ref> [1, 10] </ref> that simply trust co-located code to more sophisticated techniques that confine the potential damage of kernel extensions. However, Section 5 shows that simple co-location is not necessarily a promising technique. Co-located MkLinux performs worse than user-mode L 4 Linux.
Reference: [11] <institution> Digital Equipment Corp., Maynard, Massachusetts. </institution> <note> Alpha 21164 Microprocessor Hardware Reference Manual, July 96. </note>
Reference-contexts: The most relevant user-visible difference probably is that the Pentium -kernel runs in 32-bit mode whereas the other two are 64-bit-mode kernels and therefore support larger address spaces. The L4/Alpha implementation is based on a complete replacement of Digital's original PALcode <ref> [11] </ref>. Short, time-critical operations are hand-tuned and completely performed in PALcode. Longer, interruptible operations enter PALcode, switch to kernel mode and leave PALcode to perform the remainder of the operation using standard machine instructions.
Reference: [12] <author> D. Engler, M. F. Kaashoek, and J O'Toole. Exokernel, </author> <title> an operating system architecture for application-level resource management. </title> <booktitle> In 15th ACM Symposium on Operating System Principles (SOSP), </booktitle> <pages> pages 251266, </pages> <address> Copper Mountain Resort, CO, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: The too high faction started building kernels resembling a hardware architecture at their interface This research was supported in part by the Deutsche Forschungsgemein-schaft (DFG) through the Sonderforschungsbereich 358. <ref> [12] </ref>. Software abstractions have to be built on top of that. It is claimed that -kernels can be fast on a given architecture but cannot be moved to other architectures without losing much of their efficiency [19]. <p> Starting from the IPC implementation in L4/Alpha, we also implemented a lower-level communication primitive, similar to Exokernel's protected control transfer <ref> [12] </ref>, to find out whether and to what extent the L4 IPC abstraction can be out performed by a lower-level primitive. After a short overview of L4 in Section 3, Section 4 explains the design and implementation of our Linux server. <p> Finally, Section 7 discusses alternative basic concepts from a performance point of view. 2 Related Work Most of this paper repeats experiments described by Bershad et al. [5], des Places, Stephen & Reynolds [10], and Engler, Kaashoek & O'Toole <ref> [12] </ref> to explore the influence of a second-generation - kernel on user-level application performance. Kaashoek et al. describe in [18] how to build a Unix-compatible operating system on top of a small kernel. We concentrate on the problem of porting an existing monolithic operating system to a -kernel. <p> We concentrate on the problem of porting an existing monolithic operating system to a -kernel. A large bunch of evaluation work exists which addresses how certain application or system functionality, e. g. a protocol implementation, can be accelerated using system specialization [31], extensible kernels <ref> [5, 12, 34] </ref>, layered path organisation [30], etc. Two alternatives to the pure -kernel approach, grafting and the Exoker-nel idea, are discussed in more detail in Section 7. Most of the performance evaluation results published elsewhere deal with parts of the Unix functionality. <p> Recently, Engler, Kaashoek and O'Toole <ref> [12] </ref> applied a similar principle to -kernels. <p> Instead of implementing abstractions like IPC or address spaces, only hardware mechanisms such as TLBs should be multiplexed and exported securely. From this point of view, IPC might be too high-level an abstraction to be implemented with optimum efficiency. Instead, a protected control transfer (PCT) as proposed in <ref> [12] </ref> might be more faster. PCT is similar to a hardware interrupt: a parameterless cross-address-space procedure call via a callee-defined call gate. Indeed, when we started the design of L4/Alpha, we first had the impression that PCT could be implemented more efficiently than simple IPC. <p> However, Section 5 shows that simple co-location is not necessarily a promising technique. Co-located MkLinux performs worse than user-mode L 4 Linux. Vino [34] introduces a sophisticated yet expensive transaction mechanism; Exokernel <ref> [12, 36] </ref> enables application-specific handlers using a variety of mechanisms ranging from interpretable intermediate code to run time checking. SPIN [5] is an example of a well-performing, sophisticated grafting technique.
Reference: [13] <author> D. Golub, R. Dean, A. Forin, and R. Rashid. </author> <title> Unix as an application program. </title> <booktitle> In USENIX 1990 Summer Conference, </booktitle> <pages> pages 8795, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: In contrast, we investigate the pure -kernel approach by systematically repeating earlier experiments and conducting some novel experiments using L4, a second-generation -kernel. (Most first-generation -kernels like Chorus [32] and Mach <ref> [13] </ref> evolved from earlier monolithic kernel approaches; second-generation -kernels like QNX [16] and L4 more rigorously aim at minimality and are designed from scratch [24].) The goal of this work is to show that -kernel based systems are usable in practice with good performance. <p> A comparison of IPC performance of the three L4 -kernels can be found in [25]. 4 Linux on Top of L4 Many classical systems emulate Unix on top of a -kernel. For example, monolithic Unix kernels were ported to Mach <ref> [13, 15] </ref> and Chorus [4]. Very recently, a single-server experiment was repeated with Linux and newer, optimized versions of Mach [10]. To add a standard OS personality to L4, we decided to port Linux. <p> Porting Linux was therefore also an experiment checking whether performance can be achieved without significant -kernel-directed optimizations in the Linux kernel, and whether the L4 interface is truly general and flexible. Under the constraints mentioned above, the natural solution is the straightforward single-server approach, similar to <ref> [13] </ref>: -kernel tasks are used for Linux user processes and provide Linux services via a single Linux server in a separate -kernel task. This is indeed how we began our port. The Linux Server (Linux Kernel). Native Linux maps physical memory one-to-one to the the kernel's address space.
Reference: [14] <author> G. Heiser, K. Elphinstone, J. Vochteloo, S. Russell, and J. Liedtke. </author> <title> Implementation and performance of the Mungi single-address-space operating system. </title> <type> UNSW-CSE-TR 9704, </type> <institution> University of New South Wales, School of Computer Science, </institution> <address> Sydney 2052, Australia, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: Within a single task, some threads might use the normal large space while others operate on the corresponding small space. Pentium Alpha MIPS Originally developed for the 486 and Pentium architecture, experimental L4 implementations now exist for Digital's Alpha 21164 [33] and MIPS R4600 <ref> [14] </ref>. Both new implementations were designed from scratch. L4/Pentium, L4/Alpha and L4/MIPS are different -kernels with the same logical API. However, the -kernel-internal algorithms and the binary API (use of registers, word and address size, encoding of the kernel call) are processor dependent and optimized for each processor.
Reference: [15] <author> Johannes Helander. </author> <title> Unix under Mach: The Lites server. </title> <type> Master's thesis, </type> <institution> Helsinki University of Technology, </institution> <year> 1994. </year> <note> Available from: http://www.cs.hut.fi/~jvh/lites.MASTERS.ps. </note>
Reference-contexts: A comparison of IPC performance of the three L4 -kernels can be found in [25]. 4 Linux on Top of L4 Many classical systems emulate Unix on top of a -kernel. For example, monolithic Unix kernels were ported to Mach <ref> [13, 15] </ref> and Chorus [4]. Very recently, a single-server experiment was repeated with Linux and newer, optimized versions of Mach [10]. To add a standard OS personality to L4, we decided to port Linux.
Reference: [16] <author> D. Hildebrand. </author> <title> An architectural overview of QNX. </title> <booktitle> In 1st USENIX Workshop on Micro-kernels and Other Kernel Architectures, </booktitle> <pages> pages 113126, </pages> <address> Seattle, WA, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: In contrast, we investigate the pure -kernel approach by systematically repeating earlier experiments and conducting some novel experiments using L4, a second-generation -kernel. (Most first-generation -kernels like Chorus [32] and Mach [13] evolved from earlier monolithic kernel approaches; second-generation -kernels like QNX <ref> [16] </ref> and L4 more rigorously aim at minimality and are designed from scratch [24].) The goal of this work is to show that -kernel based systems are usable in practice with good performance.
Reference: [17] <author> M. Hohmuth. </author> <title> Linux Architecture-Specific Kernel Interfaces. </title> <type> TU Dresden, </type> <month> March </month> <year> 1996. </year> <note> Available from URL: http://www.inf.tu-dresden.de/~mh1/prj/linux-on-l4/. </note>
Reference-contexts: Recent versions contain a relatively well-defined interface between architecture-dependent and independent parts of the kernel <ref> [17] </ref>. All interfaces described in this paper correspond to Linux version 2.0. Linux' architecture-independent part includes process and resource management, file systems, networking subsystems and all device drivers. Altogether, these are about 98% of the Linux/x86 source distribution of kernel and device drivers.
Reference: [18] <author> M. F. Kaashoek, D. R. Engler, G. R. Ganger, H. Briceno, R. Hunt, D. Mazieres, T. Pinckney, R. Grimm, and T. Pinckney. </author> <title> Application performance and flexibility on exokernel systems. </title> <booktitle> In 16th ACM Symposium on Operating System Principles (SOSP), </booktitle> <address> Saint-Malo, France, </address> <month> October </month> <year> 1997. </year>
Reference-contexts: Kaashoek et al. describe in <ref> [18] </ref> how to build a Unix-compatible operating system on top of a small kernel. We concentrate on the problem of porting an existing monolithic operating system to a -kernel.
Reference: [19] <author> A. I. Karshmer and J. N. Thomas. </author> <booktitle> Are operating systems at RISC? Lecture Notes in Computer Science, </booktitle> <address> 563:48, </address> <year> 1991. </year>
Reference-contexts: Software abstractions have to be built on top of that. It is claimed that -kernels can be fast on a given architecture but cannot be moved to other architectures without losing much of their efficiency <ref> [19] </ref>.
Reference: [20] <editor> J. Liedtke. Clans & chiefs. </editor> <booktitle> In 12. GI/ITG-Fachtagung Architektur von Rechensystemen, </booktitle> <pages> pages 294305, </pages> <address> Kiel, March 1992. </address> <publisher> Springer. </publisher>
Reference-contexts: Most server applications need these features and must therefore spend the cycles additionally to the PCT costs. Furthermore, IPC makes 1-to-n messages simple since it includes starting the destination threads. In addition, L4-style IPC provides message diversion (using Clans & Chiefs <ref> [20, 23] </ref>). A message crossing a clan border is redirected to the user-level chief of the clan which can inspect and handle the message. This can be used as a basis for the implementation of mandatory access control policies or isolation of suspicious objects.
Reference: [21] <author> J. Liedtke. </author> <title> Improving IPC by kernel design. </title> <booktitle> In 14th ACM Symposium on Operating System Principles (SOSP), </booktitle> <pages> pages 175188, </pages> <address> Asheville, NC, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: Therefore, we assume that performance differences are mostly due to the underlying -kernel. First, we compare L 4 Linux (which always runs in user mode) to the MkLinux variant that also runs in user mode. Mach is known for slow user-to-user IPC and expensive user-level page-fault handling <ref> [5, 21] </ref>. So benchmarks should report a distinct difference between L 4 Linux and MkLinux if the -kernel efficiency influences the whole system significantly. A faster version of MkLinux uses a co-located server running in kernel mode and executing inside the -kernel's address space. <p> An IPC transfers a message from a sender thread to a destination thread; both threads remain in their respective address spaces but the set of active threads changes. Lazy scheduling techniques <ref> [21] </ref> remove the additional costs of the second model so that in most cases both are equivalent from a performance point of view. However, IPC requires a preallocated system resource, the destination thread.
Reference: [22] <editor> J. Liedtke. </editor> <booktitle> On -kernel construction. In 15th ACM Symposium on Operating System Principles (SOSP), </booktitle> <pages> pages 237250, </pages> <address> Copper Mountain Resort, CO, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: L4 is a lean kernel featuring fast message-based synchronous IPC, a simple-to-use external paging mechanism and a security mechanism based on secure domains. The kernel implements only a minimal set of abstractions upon which operating systems can be built <ref> [22] </ref>. The following experiments were performed: * A monolithic Unix kernel, Linux, was adapted to run as a user-level single server on top of L4. <p> We found no substantiation for the common knowledge that early Mach 3.0-based Unix single-server implementations achieved a performance penalty of only 10% compared to bare Unix on the same hardware. For newer hardware, [9] reports penalties of about 50%. 3 L4 Essentials The L4 -kernel <ref> [22] </ref> is based on two basic concepts, threads and address spaces. A thread is an activity executing inside an address space. Cross-address-space communication, also called inter-process communication (IPC), is one of the most fundamental - kernel mechanisms. <p> A Pentium-specific feature of L4 is the small-address-space optimization. Whenever the currently-used portion of an address space is small, 4 MB up to 512 MB, this logical space can be physically shared through all page tables and protected by Pentium's segment mechanism. As described in <ref> [22] </ref>, this simulates a tagged TLB for context switching to and from small address spaces. Since the virtual address space is limited, the total size of all small spaces is also limited to 512 MB by default.
Reference: [23] <author> J. Liedtke. </author> <title> L4 reference manual (486, Pentium, PPro). Ar-beitspapiere der GMD No. </title> <type> 1021, </type> <institution> GMD German National Research Center for Information Technology, Sankt Augustin, </institution> <note> Septem-ber 1996. Also Research Report RC 20549, </note> <institution> IBM T. J. Watson Research Center, Yorktown Heights, NY, </institution> <note> Sep 1996; available from URL: ftp://borneo.gmd.de/pub/rs/L4/l4refx86.ps. </note>
Reference-contexts: Most server applications need these features and must therefore spend the cycles additionally to the PCT costs. Furthermore, IPC makes 1-to-n messages simple since it includes starting the destination threads. In addition, L4-style IPC provides message diversion (using Clans & Chiefs <ref> [20, 23] </ref>). A message crossing a clan border is redirected to the user-level chief of the clan which can inspect and handle the message. This can be used as a basis for the implementation of mandatory access control policies or isolation of suspicious objects.
Reference: [24] <author> J. Liedtke. </author> <title> Toward real -kernels. </title> <journal> Communications of the ACM, </journal> <volume> 39(9):7077, </volume> <month> September </month> <year> 1996. </year>
Reference-contexts: pure -kernel approach by systematically repeating earlier experiments and conducting some novel experiments using L4, a second-generation -kernel. (Most first-generation -kernels like Chorus [32] and Mach [13] evolved from earlier monolithic kernel approaches; second-generation -kernels like QNX [16] and L4 more rigorously aim at minimality and are designed from scratch <ref> [24] </ref>.) The goal of this work is to show that -kernel based systems are usable in practice with good performance. L4 is a lean kernel featuring fast message-based synchronous IPC, a simple-to-use external paging mechanism and a security mechanism based on secure domains.
Reference: [25] <author> J. Liedtke, K. Elphinstone, S. Schonberg, H. Hartig, G. Heiser, N. Is-lam, and T. Jaeger. </author> <title> Achieved IPC performance (still the foundation for extensibility). </title> <booktitle> In 6th Workshop on Hot Topics in Operating Systems (HotOS), </booktitle> <pages> pages 2831, </pages> <address> Chatham (Cape Cod), MA, </address> <month> May </month> <year> 1997. </year>
Reference-contexts: Short, time-critical operations are hand-tuned and completely performed in PALcode. Longer, interruptible operations enter PALcode, switch to kernel mode and leave PALcode to perform the remainder of the operation using standard machine instructions. A comparison of IPC performance of the three L4 -kernels can be found in <ref> [25] </ref>. 4 Linux on Top of L4 Many classical systems emulate Unix on top of a -kernel. For example, monolithic Unix kernels were ported to Mach [13, 15] and Chorus [4]. Very recently, a single-server experiment was repeated with Linux and newer, optimized versions of Mach [10].
Reference: [26] <author> J. Liedtke, H. Hartig, and M. Hohmuth. </author> <title> Predictable caches in real-time systems. </title> <booktitle> In Third IEEE Real-time Technology and Applications Symposium (RTAS), </booktitle> <pages> pages 213223, </pages> <address> Montreal, Canada, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: If the operating system does not know or cannot control the cache usage of all tasks, the cache-interference costs are unpredictable. In <ref> [26] </ref>, we described how a main-memory manager (a pager) on top of L4 can be used to partition the second-level cache between multiple real-time tasks and to isolate real-time from timesharing applications.
Reference: [27] <author> Linux website. </author> <note> URL: http://www.linux.org. </note>
Reference-contexts: A positive implication of this design decision is that new versions of Linux can be easily adapted to our system. 4.1 Linux Essentials Although originally developed for x86 processors, the Linux kernel has been ported to several other architectures, including Alpha, M68k and SPARC <ref> [27] </ref>. Recent versions contain a relatively well-defined interface between architecture-dependent and independent parts of the kernel [17]. All interfaces described in this paper correspond to Linux version 2.0. Linux' architecture-independent part includes process and resource management, file systems, networking subsystems and all device drivers.
Reference: [28] <author> R. A. Mayer and L. H. Seawright. </author> <title> A virtual machine time sharing system. </title> <journal> IBM Systems Journal, </journal> <volume> 9(3):199218, </volume> <year> 1970. </year>
Reference-contexts: There is some evidence that the -kernel architecture enables to implement high-performance nonclassical systems cooperating with a classical timesharing OS. 7 Alternative Basic Concepts In this section, we address questions whether a mechanism lower-level than IPC or a grafting model could improve the -kernel performance. 7.1 Protected Control Transfers VM/370 <ref> [28] </ref> was built on the paradigm of virtualizing and multiplexing the underlying hardware. Recently, Engler, Kaashoek and O'Toole [12] applied a similar principle to -kernels.
Reference: [29] <author> L. McVoy and C. Staelin. lmbench: </author> <title> Portable tools for performance analysis. </title> <booktitle> In USENIX Annual Technical Conference, </booktitle> <pages> pages 279294, </pages> <year> 1996. </year>
Reference-contexts: When removing the part called LINUX in Figure 5, the L 4 Linux overhead code remains. It uses 45 cache lines, 9% of the first-level cache, including the cache L4 needs for IPC. The lmbench <ref> [29] </ref> microbenchmark suite measures basic operations like system calls, context switches, memory accesses, pipe operations, network operations, etc. by repeating the respective operation a large number of times. lmbench's measurement methods have recently been criticized by Brown and Seltzer [6].
Reference: [30] <author> D. Mosberger and L.L. Peterson. </author> <title> Making paths explicit in the Scout operating system. </title> <booktitle> In 2nd USENIX Symposium on Operating Systems Design and Implementation (OSDI), </booktitle> <pages> pages 153167, </pages> <address> Seattle, WA, </address> <month> Oc-tober </month> <year> 1996. </year>
Reference-contexts: A large bunch of evaluation work exists which addresses how certain application or system functionality, e. g. a protocol implementation, can be accelerated using system specialization [31], extensible kernels [5, 12, 34], layered path organisation <ref> [30] </ref>, etc. Two alternatives to the pure -kernel approach, grafting and the Exoker-nel idea, are discussed in more detail in Section 7. Most of the performance evaluation results published elsewhere deal with parts of the Unix functionality.
Reference: [31] <author> C. Pu, T. Autrey, A. Black, C. Consel, C. Cowan, J. Inouye, L. Kethana, J. Walpole, and K. Zhang. </author> <title> Optimistic incremental specialization: Streamlining a commercial operating system. </title> <booktitle> In 15th ACM Symposium on Operating System Principles (SOSP), </booktitle> <pages> pages 314324, </pages> <address> Copper Mountain Resort, CO, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: We concentrate on the problem of porting an existing monolithic operating system to a -kernel. A large bunch of evaluation work exists which addresses how certain application or system functionality, e. g. a protocol implementation, can be accelerated using system specialization <ref> [31] </ref>, extensible kernels [5, 12, 34], layered path organisation [30], etc. Two alternatives to the pure -kernel approach, grafting and the Exoker-nel idea, are discussed in more detail in Section 7. Most of the performance evaluation results published elsewhere deal with parts of the Unix functionality. <p> So we have to ask for the added value the -kernel gives us. One such is that it enables specialization (improved implementation of special OS functionality <ref> [31] </ref>) and buys us extensibility, i. e., permits the orthogonal implementation of new services and policies that are not covered by and cannot easily be added to a conventional workstation OS. Potential application fields are databases, real-time, multi-media and security.
Reference: [32] <author> M. Rozier, A. Abrossimov, F. Armand, I. Boule, M. Gien, M. Guille-mont, F. Herrmann, C. Kaiser, S. Langlois, P. Leonard, and W. Neuhauser. </author> <title> CHORUS distributed operating system. </title> <booktitle> Computing Systems, </booktitle> <address> 1(4):305370, </address> <year> 1988. </year>
Reference-contexts: In contrast, we investigate the pure -kernel approach by systematically repeating earlier experiments and conducting some novel experiments using L4, a second-generation -kernel. (Most first-generation -kernels like Chorus <ref> [32] </ref> and Mach [13] evolved from earlier monolithic kernel approaches; second-generation -kernels like QNX [16] and L4 more rigorously aim at minimality and are designed from scratch [24].) The goal of this work is to show that -kernel based systems are usable in practice with good performance. <p> So benchmarks should report a distinct difference between L 4 Linux and MkLinux if the -kernel efficiency influences the whole system significantly. A faster version of MkLinux uses a co-located server running in kernel mode and executing inside the -kernel's address space. Similar to Chorus' supervisor tasks <ref> [32] </ref>, co-located (in-kernel) servers communicate much more efficiently with each other and with the -kernel than user-mode servers do. However, in order to improve performance, co-location violates the address-space boundaries of a -kernel system, which weakens security and safety.
Reference: [33] <author> S. Schonberg. </author> <title> L4 on Alpha, design and implementation. </title> <type> Technical Report CS-TR-407, </type> <institution> University of Cambridge, </institution> <year> 1996. </year>
Reference-contexts: Within a single task, some threads might use the normal large space while others operate on the corresponding small space. Pentium Alpha MIPS Originally developed for the 486 and Pentium architecture, experimental L4 implementations now exist for Digital's Alpha 21164 <ref> [33] </ref> and MIPS R4600 [14]. Both new implementations were designed from scratch. L4/Pentium, L4/Alpha and L4/MIPS are different -kernels with the same logical API.
Reference: [34] <author> M.I. Seltzer, Y. Endo, C. Small, and K.A. Smith. </author> <title> Dealing with disaster: Surviving misbehaved kernel extensions. </title> <booktitle> In 2nd USENIX Symposium on Operating Systems Design and Implementation (OSDI), </booktitle> <pages> pages 213227, </pages> <address> Seattle, WA, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: Mechanisms were introduced to add functionality to kernels and their address spaces, either pragmatically (co-location in Chorus or Mach) or systematically. Various means were invented to protect kernels from misbehaving extensions, ranging from the use of safe languages [5] to expensive transaction-like schemes <ref> [34] </ref>. The too high faction started building kernels resembling a hardware architecture at their interface This research was supported in part by the Deutsche Forschungsgemein-schaft (DFG) through the Sonderforschungsbereich 358. [12]. Software abstractions have to be built on top of that. <p> We concentrate on the problem of porting an existing monolithic operating system to a -kernel. A large bunch of evaluation work exists which addresses how certain application or system functionality, e. g. a protocol implementation, can be accelerated using system specialization [31], extensible kernels <ref> [5, 12, 34] </ref>, layered path organisation [30], etc. Two alternatives to the pure -kernel approach, grafting and the Exoker-nel idea, are discussed in more detail in Section 7. Most of the performance evaluation results published elsewhere deal with parts of the Unix functionality. <p> They range from very pragmatic co-location techniques [1, 10] that simply trust co-located code to more sophisticated techniques that confine the potential damage of kernel extensions. However, Section 5 shows that simple co-location is not necessarily a promising technique. Co-located MkLinux performs worse than user-mode L 4 Linux. Vino <ref> [34] </ref> introduces a sophisticated yet expensive transaction mechanism; Exokernel [12, 36] enables application-specific handlers using a variety of mechanisms ranging from interpretable intermediate code to run time checking. SPIN [5] is an example of a well-performing, sophisticated grafting technique.
Reference: [35] <author> J. Shapiro, D. Farber, and J. M. Smith. </author> <title> The measured performance of a fast local ipc. </title> <booktitle> In 5th International Workshop on Object Orientation in Operating Systems (IWOOOS), </booktitle> <pages> pages 8994, </pages> <address> Seattle, WA, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: Since the bandwidth measurement moves 64 KB chunks of data, its performance is basically determined by the memory hardware, in particular by the direct-mapped second-level cache. As proposed by Jonathan Shapiro <ref> [35] </ref>, L4 IPC simulates a write-allocate cache by prereading the destination area when copying longer messages. In the best case, Linux allocates pages such that source and destination do not overlap in the cache; in the worst case, the copy operation flushes every data prior to its next usage.
Reference: [36] <author> D. A. Wallach. </author> <title> High Performance Application-Specific Networking. </title> <type> PhD thesis, </type> <institution> MIT Laboratory, </institution> <month> January </month> <year> 1997. </year>
Reference-contexts: However, Section 5 shows that simple co-location is not necessarily a promising technique. Co-located MkLinux performs worse than user-mode L 4 Linux. Vino [34] introduces a sophisticated yet expensive transaction mechanism; Exokernel <ref> [12, 36] </ref> enables application-specific handlers using a variety of mechanisms ranging from interpretable intermediate code to run time checking. SPIN [5] is an example of a well-performing, sophisticated grafting technique.
References-found: 36

