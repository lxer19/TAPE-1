URL: ftp://ftp.cs.brown.edu/pub/techreports/97/cs97-10.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-97-10.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> K. Arnold and J. Gosling. </author> <title> The Java Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1996. </year>
Reference-contexts: On the other hand, the icon representing the local computer is small to describe that no powerful local computers are needed. 2.4 The Java Model Java <ref> [1] </ref> is an object-oriented language designed to be dynamically redistributable over the Internet, especially in conjunction with the World Wide Web.
Reference: [2] <author> C. L. Bajaj. </author> <title> Collaborative multimedia & scientific toolkits. Course Notes, </title> <institution> Dept. Comp. Sci., Purdue Univ., West Lafayette, Indiana, </institution> <year> 1996. </year>
Reference-contexts: We anticipate quickly adding a large library of existing geometric algorithm filters to Mocha . 5 Extensions Collaborative environments enable members of communities to interact with each other over the Internet with not only traditional tools (email, news, etc.) but also through specialized tools <ref> [2] </ref>. In particular, we envision the development of collaborative environments which provide access to geometric animations and visualizations in the context of web browsers.
Reference: [3] <author> G. Barequet, S. S. Bridgeman, C. A. Duncan, M. T. Goodrich, and R. Tamassia. </author> <title> Classic computational geometry with GeomNet. </title> <booktitle> In Proc. Annu. ACM Sympos. </booktitle> <institution> Comput. Geom., </institution> <year> 1997. </year>
Reference-contexts: The user interface combines fast responsiveness with the powerful authoring capabilities of hypertext narratives. Our vision for Mocha is in fact a part of the even broader vision of GeomNet <ref> [3] </ref>, a system for performing distributed geometric computing over the Internet. GeomNet consists of a family of geometric computing servers that execute a variety of geometric algorithms on behalf of remote clients, which can be either users interacting through a Web browser interface, or application programs connecting directly through sockets.
Reference: [4] <author> J. Bazik, R. Tamassia, S. P. Reiss, and A. van Dam. </author> <title> Software visualization in teaching at Brown University. </title> <editor> In Brown, J. Domingue, B. Price, and J. Stasko, editors, </editor> <title> Software Visualization: Programming as a Multi-Media Experience. </title> <publisher> MIT Press, </publisher> <year> 1996. </year>
Reference-contexts: Algorithm animation is also a powerful tool to demonstrate new algorithms to others in a intuitive, often appealing fashion. Therefore, there is a strong pedagogical interest associated with interactive algorithm visualization, which can be used by students individually or in class demonstrations <ref> [4, 42, 50, 12] </ref>. Visualization can also be used as a debugging tool for large software applications [38]. The visual nature of geometry applications makes it a natural area where visualization can be an effective tool for communicating ideas.
Reference: [5] <author> P. Bose, G. Di Battista, W. Lenhart, and G. Liotta. </author> <title> Proximity constraints and representable trees. </title> <editor> In R. Tamassia and I. G. Tollis, editors, </editor> <booktitle> Graph Drawing (Proc. GD '94), volume 894 of Lecture Notes Comput. Sci., </booktitle> <pages> pages 340-351. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: An advanced interaction technique allows the user to define the value of fi by sliding a cursor along a logarithmic-scale ruler. The following values of fi, which are of special interest in the theory of proximity graphs (e.g. see <ref> [6, 5] </ref>), are explicitly highlighted below the ruler and cause the cursor to "snap" when dragged near them: fi = p 2 , fi = 1 5 ) fi = 1 5 ) 20 public class Voronoi extends GeometryClient - /* Instance data -- set later */ PointSet ptsetInput; Graph graphVoronoi;
Reference: [6] <author> P. Bose, W. Lenhart, and G. Liotta. </author> <title> Characterizing proximity trees. </title> <journal> Algorithmica, </journal> <volume> 16 </volume> <pages> 83-110, </pages> <year> 1996. </year> <title> (special issue on Graph Drawing, </title> <editor> edited by G. Di Battista and R. </editor> <publisher> Tamassia). </publisher>
Reference-contexts: An advanced interaction technique allows the user to define the value of fi by sliding a cursor along a logarithmic-scale ruler. The following values of fi, which are of special interest in the theory of proximity graphs (e.g. see <ref> [6, 5] </ref>), are explicitly highlighted below the ruler and cause the cursor to "snap" when dragged near them: fi = p 2 , fi = 1 5 ) fi = 1 5 ) 20 public class Voronoi extends GeometryClient - /* Instance data -- set later */ PointSet ptsetInput; Graph graphVoronoi;
Reference: [7] <author> M. Brown, J. Domingue, B. Price, and J. Stasko. </author> <title> Software visualization. </title> <booktitle> In Proc. ACM Conf. on Human Factors in Computing Systems, </booktitle> <volume> volume 2, </volume> <pages> page 463, </pages> <year> 1994. </year>
Reference-contexts: The end-user can understand algorithms by following visually their step-by-step execution, otherwise a complex task if relying on the textual program alone. Extensive work has been done on algorithm animation and program visualization. See, e.g., the survey by Myers [34] and <ref> [7, 8, 9, 10, 13, 17, 20, 23, 39, 44, 45] </ref>. Algorithm animation is also a powerful tool to demonstrate new algorithms to others in a intuitive, often appealing fashion.
Reference: [8] <author> M. H. Brown. </author> <title> Algorithm Animation. </title> <publisher> MIT Press, </publisher> <address> Cambridge, </address> <year> 1988. </year>
Reference-contexts: The end-user can understand algorithms by following visually their step-by-step execution, otherwise a complex task if relying on the textual program alone. Extensive work has been done on algorithm animation and program visualization. See, e.g., the survey by Myers [34] and <ref> [7, 8, 9, 10, 13, 17, 20, 23, 39, 44, 45] </ref>. Algorithm animation is also a powerful tool to demonstrate new algorithms to others in a intuitive, often appealing fashion. <p> Mocha are provided in Section 4. 2 2 Models for Algorithm Visualization over the Internet In this section, we examine the currently used mechanisms for providing algorithm visualization over the Internet, and present our new architecture. 2.1 Components of an Algorithm Visualization System Following the event-driven approach advocated by Brown <ref> [8] </ref> and the conceptual framework pioneered by Stasko [45, 43, 44], we view interactive algorithm visualization as an event-driven system of communicating processes: the algorithm augmented with annotations of interesting events, called algorithm operations, and the interactive visualization component that provides the multimedia visualization of the algorithm operations. <p> The three main functional components of the visualization system (GUI, animator, and algorithm) reside on the user's machine and receive their Java code and multimedia objects from a server on the provider's machine. All communication is performed with the HTTP protocol. A sorting visualization (inspired by Balsa <ref> [8] </ref>) that uses the Java model is shown in Figure 5. Thanks to its built-in features, the Java model provides a high level of security for both the user and the provider. <p> By using MVC we can ensure the correspondence of each view to the model without increasing the complexity of the design (at least beyond the design's initial incorporation of MVC). The importance of this for algorithm visualization was introduced by BALSA <ref> [8] </ref>. Mocha extends this conventional use of MVC by partitioning both the model and the controller between the client and the server.
Reference: [9] <author> M. H. Brown. ZEUS: </author> <title> A System for Algorithm Animation and Multi-View Editing. </title> <booktitle> In IEEE Symposium on Visual Languages (VL '91), </booktitle> <pages> pages 4-9, </pages> <year> 1992. </year> <note> Also available from http://gatekeeper.dec.com/pub/DEC/SRC/research-reports/abstracts/src-rr-075.html. </note>
Reference-contexts: The end-user can understand algorithms by following visually their step-by-step execution, otherwise a complex task if relying on the textual program alone. Extensive work has been done on algorithm animation and program visualization. See, e.g., the survey by Myers [34] and <ref> [7, 8, 9, 10, 13, 17, 20, 23, 39, 44, 45] </ref>. Algorithm animation is also a powerful tool to demonstrate new algorithms to others in a intuitive, often appealing fashion.
Reference: [10] <author> M. H. Brown and J. Hershberger. </author> <title> Color and sound in algorithm animation. </title> <journal> IEEE Computer, </journal> <volume> 25(12) </volume> <pages> 52-63, </pages> <year> 1992. </year>
Reference-contexts: The end-user can understand algorithms by following visually their step-by-step execution, otherwise a complex task if relying on the textual program alone. Extensive work has been done on algorithm animation and program visualization. See, e.g., the survey by Myers [34] and <ref> [7, 8, 9, 10, 13, 17, 20, 23, 39, 44, 45] </ref>. Algorithm animation is also a powerful tool to demonstrate new algorithms to others in a intuitive, often appealing fashion.
Reference: [11] <author> M. H. Brown and M. A. Najork. </author> <title> Algorithm animation using 3D interactive graphics. </title> <booktitle> In Proc. ACM Symp. on User Interface Software and Technology, </booktitle> <pages> pages 93-100, </pages> <year> 1993. </year>
Reference-contexts: There are many technical challenges in doing algorithm visualization and animation. For example, the development of a conceptual framework to modularize and simplify the design process (part of the authoring process), for which Stasko proposes the path-transition paradigm [43], 3D visualization <ref> [11, 40, 37] </ref>, and automatic graph layout [15]. Another challenge, which extends beyond algorithm animation, is the visualization of large sets of data [33].
Reference: [12] <author> M. H. Brown and M. A. Najork. </author> <title> Collaborative active textbooks. </title> <booktitle> In IEEE Symp. on Visual Languages, </booktitle> <year> 1996. </year>
Reference-contexts: Algorithm animation is also a powerful tool to demonstrate new algorithms to others in a intuitive, often appealing fashion. Therefore, there is a strong pedagogical interest associated with interactive algorithm visualization, which can be used by students individually or in class demonstrations <ref> [4, 42, 50, 12] </ref>. Visualization can also be used as a debugging tool for large software applications [38]. The visual nature of geometry applications makes it a natural area where visualization can be an effective tool for communicating ideas.
Reference: [13] <author> M. H. Brown and R. Sedgewick. </author> <title> Techniques for algorithm animation. </title> <journal> IEEE Software, </journal> <volume> 2(1) </volume> <pages> 28-39, </pages> <year> 1985. </year>
Reference-contexts: The end-user can understand algorithms by following visually their step-by-step execution, otherwise a complex task if relying on the textual program alone. Extensive work has been done on algorithm animation and program visualization. See, e.g., the survey by Myers [34] and <ref> [7, 8, 9, 10, 13, 17, 20, 23, 39, 44, 45] </ref>. Algorithm animation is also a powerful tool to demonstrate new algorithms to others in a intuitive, often appealing fashion.
Reference: [14] <author> P. J. de Rezende and W. R. Jacometti. </author> <title> Animation of geometric algorithms using GeoLab. </title> <booktitle> In Proc. 9th Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> pages 401-402, </pages> <year> 1993. </year> <month> 32 </month>
Reference-contexts: Given these observations, it is not surprising that there has been noticeable progress during the past few years in the production of visualizations of geometric algorithms and concepts (see, e.g., <ref> [28, 47, 32, 14, 26] </ref> and the collections of videos accompanying the proceedings of the ACM Symposium on Computational Geometry since 1992) [46, 47].
Reference: [15] <author> G. Di Battista, P. Eades, R. Tamassia, and I. G. Tollis. </author> <title> Algorithms for drawing graphs: an annotated bibliography. </title> <journal> Comput. Geom. Theory Appl., </journal> <volume> 4 </volume> <pages> 235-282, </pages> <year> 1994. </year>
Reference-contexts: There are many technical challenges in doing algorithm visualization and animation. For example, the development of a conceptual framework to modularize and simplify the design process (part of the authoring process), for which Stasko proposes the path-transition paradigm [43], 3D visualization [11, 40, 37], and automatic graph layout <ref> [15] </ref>. Another challenge, which extends beyond algorithm animation, is the visualization of large sets of data [33]. <p> The visualized algorithms solve problems of computational geometry and graph drawing. For an overview of these two fields the reader is referred to [36] and to <ref> [15] </ref>. In what follows, we will call our system for interactive visualization of geometric algorithms Geometry Server or GS for brevity. Geometric algorithms have interesting characteristics.
Reference: [16] <author> G. Di Battista, W. Lenhart, and G. Liotta. </author> <title> Proximity drawability: a survey. </title> <editor> In R. Tamassia and I. G. Tollis, editors, </editor> <booktitle> Graph Drawing (Proc. GD '94), volume 894 of Lecture Notes Comput. Sci., </booktitle> <pages> pages 328-339. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: See the examples in Figure 12. For a survey on proximity graphs and on their applications to graph drawing see [24] and <ref> [16] </ref>. The Proximity Server of GS can generate infinitely many proximity graphs on a given set S. The user, through the canvas of the hypertextual interface, specifies both the set S and a nonnegative parameter fi. This parameter unambiguously defines the shape of the proximity region, called the fi-region.
Reference: [17] <author> J. Domingue, B. A. Price, and M. </author> <title> Eisenstadt. A framework for describing and implementing software visualization systems. </title> <booktitle> In Proceedings of Graphics Interface '92, </booktitle> <pages> pages 53-60, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: The end-user can understand algorithms by following visually their step-by-step execution, otherwise a complex task if relying on the textual program alone. Extensive work has been done on algorithm animation and program visualization. See, e.g., the survey by Myers [34] and <ref> [7, 8, 9, 10, 13, 17, 20, 23, 39, 44, 45] </ref>. Algorithm animation is also a powerful tool to demonstrate new algorithms to others in a intuitive, often appealing fashion.
Reference: [18] <author> K. R. Gabriel and R. R. Sokal. </author> <title> A new statistical approach to geographic variation analysis. </title> <journal> Systematic Zoology, </journal> <volume> 18 </volume> <pages> 259-278, </pages> <year> 1969. </year>
Reference-contexts: The points p and q are close if their proximity region is empty, i.e. it does not contain any other point of S. It is the shape of the proximity region that determines the type of graph that results. For example, the Gabriel region <ref> [18] </ref> of p and q is the disk having p and q as antipodal points; the corresponding proximity graph is called Gabriel graph.
Reference: [19] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides. </author> <title> Design Patterns. </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1995. </year>
Reference-contexts: A simple scaling would not produce these numbers; instead the client applet provides for "gravity" near these special points of interest. Other possible input mechanisms would be special grids (hexagonal, octagonal) and coordinate systems (polar) to precisely enter input to observe interesting algorithmic behavior. 4.2 Frameworks Architectural frameworks <ref> [19, 35] </ref> provide for the reusability of the design and implementation of a set of cooperating classes over a given application domain. The advantage that frameworks provide over a monolithic API is that they define the interactions, collaborations, and responsibilities of the components, including the novel parts, in the framework.
Reference: [20] <author> S. C. Glassman. </author> <title> A Turbo Environment for Producing Algorithm Animation. </title> <booktitle> In IEEE Symposium on Visual Languages (VL '93), </booktitle> <pages> pages 32-36, </pages> <year> 1993. </year>
Reference-contexts: The end-user can understand algorithms by following visually their step-by-step execution, otherwise a complex task if relying on the textual program alone. Extensive work has been done on algorithm animation and program visualization. See, e.g., the survey by Myers [34] and <ref> [7, 8, 9, 10, 13, 17, 20, 23, 39, 44, 45] </ref>. Algorithm animation is also a powerful tool to demonstrate new algorithms to others in a intuitive, often appealing fashion.
Reference: [21] <author> J. Gosling and H. McGilton. </author> <title> The Java language environment: </title> <note> a white paper, 1995. http://www.javasoft.com/whitePaper/java-whitepaper-1.html. </note>
Reference-contexts: While this mechanism is simple to implement, there are significant security problems associated with remote X sessions, and the communication load placed on the Internet is quite high. The Java language <ref> [21] </ref> and its environment opens the possibility of embedding interactive applications in HTML documents, which are executed through the WWW browser on the user machine after their code has been transferred. Java has become a de facto standard for distributing interactive platform-independent applications across the WWW.
Reference: [22] <author> A. Hausner and D. Dobkin. </author> <title> Making geometry visible: An introduction to the animation of geometric algorithms. </title> <editor> In J.-R. Sack and J. Urrutia, editors, </editor> <booktitle> Handbook on Computational Geometry, </booktitle> <publisher> pages ??-?? North-Holland, </publisher> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: An extensive survey by Hausner and Dobkin on the visualization of geometric algorithms is also available <ref> [22] </ref> There is every reason to believe that work on the visualizations of geometric algorithms will continue and even accelerate in the future [48]. There are many technical challenges in doing algorithm visualization and animation. <p> Another challenge, which extends beyond algorithm animation, is the visualization of large sets of data [33]. As pointed out in <ref> [22] </ref>, a major issue in the visualization of geometric algorithms is the realization of interactive animations, where the user has direct control over the algorithm's input (e.g., through a geometric editor integrated with the animation system), the visualization (e.g., by selecting a 3D view and/or a 2D projection), and the timeline
Reference: [23] <author> S. E. Hudson and J. T. Stasko. </author> <title> Animation Support in a User Interface Toolkit: Flexible, Robust, and Reusable Abstractions. </title> <booktitle> In Proc. UIST, </booktitle> <pages> pages 57-67, </pages> <year> 1993. </year>
Reference-contexts: The end-user can understand algorithms by following visually their step-by-step execution, otherwise a complex task if relying on the textual program alone. Extensive work has been done on algorithm animation and program visualization. See, e.g., the survey by Myers [34] and <ref> [7, 8, 9, 10, 13, 17, 20, 23, 39, 44, 45] </ref>. Algorithm animation is also a powerful tool to demonstrate new algorithms to others in a intuitive, often appealing fashion.
Reference: [24] <author> J. W. Jaromczyk and G. T. Toussaint. </author> <title> Relative neighborhood graphs and their relatives. </title> <journal> Proc. IEEE, </journal> <volume> 80(9) </volume> <pages> 1502-1517, </pages> <month> Sept. </month> <year> 1992. </year>
Reference-contexts: See the examples in Figure 12. For a survey on proximity graphs and on their applications to graph drawing see <ref> [24] </ref> and [16]. The Proximity Server of GS can generate infinitely many proximity graphs on a given set S. The user, through the canvas of the hypertextual interface, specifies both the set S and a nonnegative parameter fi.
Reference: [25] <author> D. G. Kirkpatrick and J. D. Radke. </author> <title> A framework for computational morphology. </title> <editor> In G. T. Toussaint, editor, </editor> <booktitle> Computational Geometry, </booktitle> <pages> pages 217-248. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, Netherlands, </address> <year> 1985. </year>
Reference-contexts: The user, through the canvas of the hypertextual interface, specifies both the set S and a nonnegative parameter fi. This parameter unambiguously defines the shape of the proximity region, called the fi-region. For a formal definition of fi-regions see <ref> [25] </ref>. We provide here an intuitive description of them. See Figure 12 (d). For fi = 1 the 1-region of p and q is their Gabriel region.
Reference: [26] <author> A. Knight, J. May, M. McAffer, T. Nguyen, and J.-R. Sack. </author> <title> A computational geometry workbench. </title> <booktitle> In Proc. 6th Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> page 370, </pages> <year> 1990. </year>
Reference-contexts: Given these observations, it is not surprising that there has been noticeable progress during the past few years in the production of visualizations of geometric algorithms and concepts (see, e.g., <ref> [28, 47, 32, 14, 26] </ref> and the collections of videos accompanying the proceedings of the ACM Symposium on Computational Geometry since 1992) [46, 47].
Reference: [27] <author> G. E. Krasner and S. T. Pope. </author> <title> A cookbook for using the model-view-controller user interface paradigm in Smalltalk-80. </title> <journal> Journal of Object-Oriented Programming, </journal> <volume> 1(3) </volume> <pages> 26-49, </pages> <month> Aug. </month> <year> 1988. </year>
Reference-contexts: Mocha is thus both a implementation framework | in terms of support for MVC by visualization clients and common mediator code | as well as a design framework for integrating algorithm services. 4.3 The Model-View-Controller Paradigm The Model-View-Controller paradigm <ref> [27] </ref> separates the task of modeling from that of displaying the model (view) and of interacting with the model (controller).
Reference: [28] <author> D. T. Lee. </author> <title> Geometric algorithm visualization revisited. </title> <booktitle> In Workshop on Geometric Computing, </booktitle> <year> 1997. </year> <month> 33 </month>
Reference-contexts: Given these observations, it is not surprising that there has been noticeable progress during the past few years in the production of visualizations of geometric algorithms and concepts (see, e.g., <ref> [28, 47, 32, 14, 26] </ref> and the collections of videos accompanying the proceedings of the ACM Symposium on Computational Geometry since 1992) [46, 47].
Reference: [29] <author> L. D. Lejter. </author> <title> A collaborative environment for algorithm animation on the WWW. http://loki.cs.brown.edu:8080/CollaborativeMocha/paper html/index.html. </title>
Reference-contexts: Introducing collaboration extends the possibilities of use of the Mocha environment, and some preliminary work has been done in the development of a collaborative version of our Mocha project <ref> [29] </ref>. Issues to be considered in collaborative environments is the consistency of views, the synchronization of these views, and the policy for updating the collaborative space.At Brown, we have developed an initial prototype of collaborative Mocha; see http://loki.cs.brown.edu:8080/CollaborativeMocha/pages/CMocha.html.
Reference: [30] <author> T. Lindholm and F. Yellin. </author> <title> The Java Virtual Machine Specification. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1997. </year>
Reference-contexts: The Java virtual machine (JVM) provides a uniform set of services across all platforms, such as graphics display, multithreading, and distributed objects, and it loads classes stored in a portable byte code as needed <ref> [30] </ref>. In the Web environment, these classes are generally transported to the Web browser through the HTTP protocol for execution on the user's machine as an applet contained on a Web page, although other mechanisms exist; see for example http://www.marimba.com. Java is an emerging standard for Internet programming.
Reference: [31] <author> K. Mehlhorn and S. Naher. LEDA: </author> <title> a platform for combinatorial and geometric computing. </title> <journal> Commun. ACM, </journal> <volume> 38 </volume> <pages> 96-102, </pages> <year> 1995. </year>
Reference-contexts: On the other hand, the Java model forces the provider to implement in Java all the components of the visualization system: GUI, animator, and algorithm. The latter can be particularly disadvantageous since the provider may want to use directly existing algorithm libraries (e.g., LEDA <ref> [31] </ref>). The main drawbacks of the Java model are code protection and accessibility. The user has full access to the Java code; hence, the entire algorithm visualization code is given away to the user. <p> Interactivity is obtained by providing real-time responses to operations such as insertion, deletion, or displacement of the geometric objects of interest in the application. The two subsections that follow aim at describing these aspects within two different application contexts. 3.1 The LEDA Visualization Service LEDA <ref> [31] </ref> is a library of data types and computational geometry algorithms written in C and C++.
Reference: [32] <author> T. Munzner, S. Levy, and M. Philips. Geomview: </author> <title> A system for geometric visualization. </title> <booktitle> In Proc. 11th Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> pages C12-C13, </pages> <year> 1995. </year>
Reference-contexts: Given these observations, it is not surprising that there has been noticeable progress during the past few years in the production of visualizations of geometric algorithms and concepts (see, e.g., <ref> [28, 47, 32, 14, 26] </ref> and the collections of videos accompanying the proceedings of the ACM Symposium on Computational Geometry since 1992) [46, 47].
Reference: [33] <author> J. Muthukumarasamy and J. T. Stasko. </author> <title> Visualizing Program Executions on Large Data Sets Using Semantic Zooming. </title> <type> Technical Report GIT-GVU-95-02, </type> <institution> Georgia Institute of Technology, </institution> <year> 1995. </year>
Reference-contexts: Another challenge, which extends beyond algorithm animation, is the visualization of large sets of data <ref> [33] </ref>.
Reference: [34] <author> B. Myers. </author> <title> Taxonomies of visual programming and program visualization. </title> <journal> J. of Visual Languages and Computating, </journal> <volume> 1(1) </volume> <pages> 97-123, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: The end-user can understand algorithms by following visually their step-by-step execution, otherwise a complex task if relying on the textual program alone. Extensive work has been done on algorithm animation and program visualization. See, e.g., the survey by Myers <ref> [34] </ref> and [7, 8, 9, 10, 13, 17, 20, 23, 39, 44, 45]. Algorithm animation is also a powerful tool to demonstrate new algorithms to others in a intuitive, often appealing fashion.
Reference: [35] <author> O. Nierstraz and T. D. Meijler. </author> <title> Research directions in software composition. </title> <journal> ACM Computing Surveys, </journal> <volume> 27(2), </volume> <year> 1995. </year>
Reference-contexts: A simple scaling would not produce these numbers; instead the client applet provides for "gravity" near these special points of interest. Other possible input mechanisms would be special grids (hexagonal, octagonal) and coordinate systems (polar) to precisely enter input to observe interesting algorithmic behavior. 4.2 Frameworks Architectural frameworks <ref> [19, 35] </ref> provide for the reusability of the design and implementation of a set of cooperating classes over a given application domain. The advantage that frameworks provide over a monolithic API is that they define the interactions, collaborations, and responsibilities of the components, including the novel parts, in the framework. <p> The advantage that frameworks provide over a monolithic API is that they define the interactions, collaborations, and responsibilities of the components, including the novel parts, in the framework. Frameworks thus provide for "generic software architectures" <ref> [35] </ref>. Java provides a GUI framework in terms of its java.awt package and especially the applet class. Users of this GUI framework are constrained to how the framework dispatches 27 events, such as mouse events or repaints.
Reference: [36] <author> F. P. Preparata and M. I. Shamos. </author> <title> Computational Geometry: An Introduction. </title> <publisher> Springer-Verlag, </publisher> <address> New York, NY, </address> <year> 1985. </year>
Reference-contexts: The visualized algorithms solve problems of computational geometry and graph drawing. For an overview of these two fields the reader is referred to <ref> [36] </ref> and to [15]. In what follows, we will call our system for interactive visualization of geometric algorithms Geometry Server or GS for brevity. Geometric algorithms have interesting characteristics. <p> Each section is provided with a canvas where the user is supported by standard user-interface facilities, such as zoom-in and zoom-out, addition, deletion and displacement of objects. Suppose the user wants to execute the algorithm of LEDA Server that computes the convex hull <ref> [36] </ref> of a finite set S of distinct points of the plane. The client, using the Visualization Protocol, interacts with the LEDA Server.
Reference: [37] <author> S. P. Reiss. </author> <title> A Framework for Abstract 3D Visualizations. </title> <booktitle> In IEEE Symposium on Visual Languages (VL '93), </booktitle> <pages> pages 100-107, </pages> <year> 1993. </year>
Reference-contexts: There are many technical challenges in doing algorithm visualization and animation. For example, the development of a conceptual framework to modularize and simplify the design process (part of the authoring process), for which Stasko proposes the path-transition paradigm [43], 3D visualization <ref> [11, 40, 37] </ref>, and automatic graph layout [15]. Another challenge, which extends beyond algorithm animation, is the visualization of large sets of data [33].
Reference: [38] <author> S. P. Reiss. </author> <title> An engine for the 3D visualization of program information. </title> <journal> J. Visual Lang. Comput., </journal> <volume> 6(3), </volume> <year> 1995. </year> <title> (special issue on Graph Visualization, edited by I. </title> <editor> F. Cruz and P. </editor> <publisher> Eades). </publisher>
Reference-contexts: Therefore, there is a strong pedagogical interest associated with interactive algorithm visualization, which can be used by students individually or in class demonstrations [4, 42, 50, 12]. Visualization can also be used as a debugging tool for large software applications <ref> [38] </ref>. The visual nature of geometry applications makes it a natural area where visualization can be an effective tool for communicating ideas. This is enhanced by the observation that much research in computational geometry occurs in two and three dimensions, where visualization is highly plausible.
Reference: [39] <author> S. P. Reiss and I. F. Cruz. </author> <title> Practical Software Visualization. </title> <booktitle> In CHI '94 Workshop on Software Visualization, </booktitle> <year> 1994. </year>
Reference-contexts: The end-user can understand algorithms by following visually their step-by-step execution, otherwise a complex task if relying on the textual program alone. Extensive work has been done on algorithm animation and program visualization. See, e.g., the survey by Myers [34] and <ref> [7, 8, 9, 10, 13, 17, 20, 23, 39, 44, 45] </ref>. Algorithm animation is also a powerful tool to demonstrate new algorithms to others in a intuitive, often appealing fashion.
Reference: [40] <author> G. G. Robertson, S. K. Card, and J. D. Mackinlay. </author> <title> Information visualization using 3D interactive visualization. </title> <journal> Comm. ACM, </journal> <volume> 36(4) </volume> <pages> 56-71, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: There are many technical challenges in doing algorithm visualization and animation. For example, the development of a conceptual framework to modularize and simplify the design process (part of the authoring process), for which Stasko proposes the path-transition paradigm [43], 3D visualization <ref> [11, 40, 37] </ref>, and automatic graph layout [15]. Another challenge, which extends beyond algorithm animation, is the visualization of large sets of data [33].
Reference: [41] <author> R. W. Scheifler and J. Gettys. </author> <title> The X window system. </title> <journal> ACM Trans. Graph., </journal> <volume> 5(2) </volume> <pages> 79-109, </pages> <year> 1986. </year>
Reference-contexts: Previous approaches use the X Window system and, more recently, the distributed and platform-independent programming environment associated with the Java language. The X Window system <ref> [41] </ref> provides a basic client-server mechanism for algorithm animation over the Internet, which we shall call X model. <p> Communication Complexity. The communication load on the Internet should be kept as light as possible. Accessibility. Users with limited computing resources should be able to access visualiza tions of computationally expensive algorithms. 2.3 The X Model The X Window system <ref> [41] </ref> provides a basic client-server mechanism for algorithm visualization over the Internet, which we shall call X model.
Reference: [42] <author> J. Stasko, A. Badre, and C. Lewis. </author> <title> Do algorithm animations assist learning? an empirical study and analysis. </title> <booktitle> In Proc. ACM Conf. on Human Factors in Computing Systems, </booktitle> <pages> pages 61-66, </pages> <year> 1993. </year>
Reference-contexts: Algorithm animation is also a powerful tool to demonstrate new algorithms to others in a intuitive, often appealing fashion. Therefore, there is a strong pedagogical interest associated with interactive algorithm visualization, which can be used by students individually or in class demonstrations <ref> [4, 42, 50, 12] </ref>. Visualization can also be used as a debugging tool for large software applications [38]. The visual nature of geometry applications makes it a natural area where visualization can be an effective tool for communicating ideas.
Reference: [43] <author> J. T. Stasko. </author> <title> The path-transition paradigm: a practical methodology for adding animation to program interfaces. </title> <journal> J. Visual Lang. Comput., </journal> <volume> 1(3) </volume> <pages> 213-236, </pages> <year> 1990. </year> <month> 34 </month>
Reference-contexts: There are many technical challenges in doing algorithm visualization and animation. For example, the development of a conceptual framework to modularize and simplify the design process (part of the authoring process), for which Stasko proposes the path-transition paradigm <ref> [43] </ref>, 3D visualization [11, 40, 37], and automatic graph layout [15]. Another challenge, which extends beyond algorithm animation, is the visualization of large sets of data [33]. <p> Models for Algorithm Visualization over the Internet In this section, we examine the currently used mechanisms for providing algorithm visualization over the Internet, and present our new architecture. 2.1 Components of an Algorithm Visualization System Following the event-driven approach advocated by Brown [8] and the conceptual framework pioneered by Stasko <ref> [45, 43, 44] </ref>, we view interactive algorithm visualization as an event-driven system of communicating processes: the algorithm augmented with annotations of interesting events, called algorithm operations, and the interactive visualization component that provides the multimedia visualization of the algorithm operations.
Reference: [44] <author> J. T. Stasko. </author> <title> Simplifying algorithm animation with tango. </title> <booktitle> In Proc. IEEE Workshop on Visual Languages, </booktitle> <pages> pages 1-6, </pages> <year> 1990. </year>
Reference-contexts: The end-user can understand algorithms by following visually their step-by-step execution, otherwise a complex task if relying on the textual program alone. Extensive work has been done on algorithm animation and program visualization. See, e.g., the survey by Myers [34] and <ref> [7, 8, 9, 10, 13, 17, 20, 23, 39, 44, 45] </ref>. Algorithm animation is also a powerful tool to demonstrate new algorithms to others in a intuitive, often appealing fashion. <p> Models for Algorithm Visualization over the Internet In this section, we examine the currently used mechanisms for providing algorithm visualization over the Internet, and present our new architecture. 2.1 Components of an Algorithm Visualization System Following the event-driven approach advocated by Brown [8] and the conceptual framework pioneered by Stasko <ref> [45, 43, 44] </ref>, we view interactive algorithm visualization as an event-driven system of communicating processes: the algorithm augmented with annotations of interesting events, called algorithm operations, and the interactive visualization component that provides the multimedia visualization of the algorithm operations.
Reference: [45] <author> J. T. Stasko. </author> <title> Tango: a framework and system for algorithm animation. </title> <journal> IEEE Computer, </journal> <volume> 23(9) </volume> <pages> 27-39, </pages> <year> 1990. </year>
Reference-contexts: The end-user can understand algorithms by following visually their step-by-step execution, otherwise a complex task if relying on the textual program alone. Extensive work has been done on algorithm animation and program visualization. See, e.g., the survey by Myers [34] and <ref> [7, 8, 9, 10, 13, 17, 20, 23, 39, 44, 45] </ref>. Algorithm animation is also a powerful tool to demonstrate new algorithms to others in a intuitive, often appealing fashion. <p> Models for Algorithm Visualization over the Internet In this section, we examine the currently used mechanisms for providing algorithm visualization over the Internet, and present our new architecture. 2.1 Components of an Algorithm Visualization System Following the event-driven approach advocated by Brown [8] and the conceptual framework pioneered by Stasko <ref> [45, 43, 44] </ref>, we view interactive algorithm visualization as an event-driven system of communicating processes: the algorithm augmented with annotations of interesting events, called algorithm operations, and the interactive visualization component that provides the multimedia visualization of the algorithm operations. <p> For example, this mechanism is used to provide on-line demonstrations of the XTango visualization system <ref> [45] </ref>, see in a Web browsing session. The X model of algorithm visualization is schematically illustrated in Figure 3. The three main functional components of the visualization system (GUI, executor, and algorithm) reside on the remote machine of the provider. All communication is performed with the X System protocol.
Reference: [46] <author> A. Tal and D. Dobkin. </author> <title> Gasp: A system to facilitate animating geometric algorithms. </title> <booktitle> In Proc. 10th Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> pages 388-389, </pages> <year> 1994. </year>
Reference-contexts: observations, it is not surprising that there has been noticeable progress during the past few years in the production of visualizations of geometric algorithms and concepts (see, e.g., [28, 47, 32, 14, 26] and the collections of videos accompanying the proceedings of the ACM Symposium on Computational Geometry since 1992) <ref> [46, 47] </ref>. An extensive survey by Hausner and Dobkin on the visualization of geometric algorithms is also available [22] There is every reason to believe that work on the visualizations of geometric algorithms will continue and even accelerate in the future [48].
Reference: [47] <author> A. Tal and D. P. Dobkin. </author> <title> Visualization of geometric algorithms. </title> <journal> IEEE Trans. Visualization and Computer Graphics, </journal> <volume> 1, </volume> <year> 1995. </year>
Reference-contexts: Given these observations, it is not surprising that there has been noticeable progress during the past few years in the production of visualizations of geometric algorithms and concepts (see, e.g., <ref> [28, 47, 32, 14, 26] </ref> and the collections of videos accompanying the proceedings of the ACM Symposium on Computational Geometry since 1992) [46, 47]. <p> observations, it is not surprising that there has been noticeable progress during the past few years in the production of visualizations of geometric algorithms and concepts (see, e.g., [28, 47, 32, 14, 26] and the collections of videos accompanying the proceedings of the ACM Symposium on Computational Geometry since 1992) <ref> [46, 47] </ref>. An extensive survey by Hausner and Dobkin on the visualization of geometric algorithms is also available [22] There is every reason to believe that work on the visualizations of geometric algorithms will continue and even accelerate in the future [48].
Reference: [48] <author> R. Tamassia et al. </author> <title> Strategic directions in computational geometry. </title> <journal> ACM Comput. Surv., </journal> <volume> 28(4), </volume> <year> 1996. </year> <note> http://www.cs.brown.edu/people/rt/sdcr/report.html. </note>
Reference-contexts: An extensive survey by Hausner and Dobkin on the visualization of geometric algorithms is also available [22] There is every reason to believe that work on the visualizations of geometric algorithms will continue and even accelerate in the future <ref> [48] </ref>. There are many technical challenges in doing algorithm visualization and animation. For example, the development of a conceptual framework to modularize and simplify the design process (part of the authoring process), for which Stasko proposes the path-transition paradigm [43], 3D visualization [11, 40, 37], and automatic graph layout [15].
Reference: [49] <author> G. T. Toussaint. </author> <title> The relative neighbourhood graph of a finite planar set. </title> <journal> Pattern Recogn., </journal> <volume> 12 </volume> <pages> 261-268, </pages> <year> 1980. </year>
Reference-contexts: Another example is the lune of p and q, defined as the intersection of two (open) disks whose radius is the distance from p to q, with one disk centered at p and the other at q; the corresponding graph is called the relative neighborhood graph <ref> [49] </ref>. See the examples in Figure 12. For a survey on proximity graphs and on their applications to graph drawing see [24] and [16]. The Proximity Server of GS can generate infinitely many proximity graphs on a given set S.
Reference: [50] <author> A. van Dam. </author> <title> The electronic classroom: Workstations for teaching. </title> <journal> Int. J. of Man-Machine Studies, </journal> <volume> 21(4) </volume> <pages> 353-363, </pages> <year> 1984. </year>
Reference-contexts: Algorithm animation is also a powerful tool to demonstrate new algorithms to others in a intuitive, often appealing fashion. Therefore, there is a strong pedagogical interest associated with interactive algorithm visualization, which can be used by students individually or in class demonstrations <ref> [4, 42, 50, 12] </ref>. Visualization can also be used as a debugging tool for large software applications [38]. The visual nature of geometry applications makes it a natural area where visualization can be an effective tool for communicating ideas.
Reference: [51] <author> G. Wiederhold. </author> <title> Mediation in information systems. </title> <journal> ACM Computing Surveys, </journal> <volume> 27(2), </volume> <year> 1995. </year>
Reference-contexts: However, naive application partitioning can result in high maintenance costs and even a lack of openness if each client-server pair has its own interface. As the number of clients n and the number of servers m expand, the number of potential relationships is of course n fi m. Mediators <ref> [51] </ref> are a well-known mechanism for reducing this interoperability problem.
References-found: 51

