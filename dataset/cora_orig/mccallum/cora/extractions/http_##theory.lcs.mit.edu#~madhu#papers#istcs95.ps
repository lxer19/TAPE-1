URL: http://theory.lcs.mit.edu/~madhu/papers/istcs95.ps
Refering-URL: http://theory.lcs.mit.edu/~madhu/papers.html
Root-URL: 
Title: Some Improvements to Total Degree Tests  
Author: KATALIN FRIEDL MADHU SUDAN 
Abstract: A low-degree test is a collection of simple, local rules for checking the proximity of an arbitrary function to a low-degree polynomial. Each rule depends on the function's values at a small number of places. If a function satisfies many rules then it is close to a low-degree polynomial. Low-degree tests play an important role in the development of probabilistically checkable proofs. In this paper we present two improvements to the efficiency of low-degree tests. Our first improvement concerns the smallest field size over which a low-degree test can work. We show how to test that a function is a degree d polynomial over prime fields of size only d + 2. Our second improvement shows a better efficiency of the low-degree test of [14] than previously known. We show concrete applications of this improvement via the notion of locally checkable codes. This improvement translates into better tradeoffs on the size versus probe complexity of probabilistically checkable proofs than previously known. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Arora, C. Lund, R. Motwani, M. Sudan, and M. Szegedy. </author> <title> Proof verification and the intractability of approximation problems. </title> <booktitle> In Proceedings of the 33rd IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 14-23, </pages> <year> 1992. </year>
Reference-contexts: The low-degree testing problem has been studied widely due to their relationship with probabilistically checkable (holographic) proofs and program checking. [5, 6, 9, 2, 10, 13] study the case of testing the maximum degree and <ref> [8, 11, 14, 1] </ref> study the case of testing total degree 1 . Our improvements are to the latter family of testers. We start by describing their testers. <p> For our purposes it is not important how P (f;d) is computed by the tester. This will become clear in the context of our applications. 1 Some of the improvements in the former family have also affected the latter. In particular <ref> [1] </ref> obtain their improvement using the improved analysis of [2]. Similarly the work of [13] also affects the latter family of testers. The correctness of the tester is proved by the following kind of a statement. <p> The improvements in [14] and <ref> [1] </ref> yielded ffi O (1=d) and ffi ffi 0 for some ffi 0 &gt; 0 respectively. The constant ffi 0 coming from the latter analysis is not described explicitly but the number appears to be fairly small. Here we show that the theorem works for any ffi &lt; 1=8. <p> Remark: The bound on the field size in the above theorem is also better than that of <ref> [1] </ref> who are only able to show it for jF j d 3 . However, this improvement can already be inferred in the work of [13]. <p> In fact, our analysis inherits this particular improvement from their analysis. 1.3 An Application The second theorem given above turns out to have some implication to the properties of probabilistically checkable proofs. In particular it implies that the proofs constructed in <ref> [1] </ref> have a much smaller probe complexity than shown earlier. It turns out that all the known construction of holographic proof inherits part of their properties from the properties of some underlying error-correcting code. <p> It turns out that all the known construction of holographic proof inherits part of their properties from the properties of some underlying error-correcting code. It is easiest to describe the effect of our analysis in terms of the improvement in the properties of the codes created in <ref> [1, 15] </ref>. The following definitions are from [15]. <p> The work of [2] implicitly describe a related code which achieves both p; 1 ffi = O (1), but requires very large alphabet sizes to get this namely their code requires a i = k * i . The significant improvement in <ref> [1] </ref> is to get good codes which have p = 2, ffi &gt; 0 with a i = polylog (k i ). (By applying a recursive technique introduced by [2] to this code they later manage to reduce a to a constant as well.) The code used by [1] is the <p> improvement in <ref> [1] </ref> is to get good codes which have p = 2, ffi &gt; 0 with a i = polylog (k i ). (By applying a recursive technique introduced by [2] to this code they later manage to reduce a to a constant as well.) The code used by [1] is the following (see also [15]): Definition 10 (Polynomial-Line Codes) Let c 1 &gt; 1 and c 2 1 be parameters. <p> The code achieves k m = m+d =(d + 1) and n m = jF j O (m 2 ) over the alphabet F d+1 . It is clear that for all constants c 1 and c 2 the Polynomial-Line codes are good codes. <ref> [1] </ref> show that for all c 1 &gt; 1 and c 2 3 these codes give (2; ffi &gt; 0)-locally testable codes. [13] improve this to c 2 1, without changing the ffi in any significant way. <p> However, the relationship between p=ffi and the probe complexity of PCP turns out to be not so simple. [7] manage to reduce the probe complexity of a PCP to about 24 bits to get a confidence of 1=2 (from some unknown number estimated to be around 10 4 in <ref> [1] </ref>) without improving the analysis of low-degree tests! How do they obtain this reduction? It turns out that this reduction is obtained by exploding the proof size to the order of n 10 4 (from some smaller polynomial of size about n 12 in [1]). <p> to be around 10 4 in <ref> [1] </ref>) without improving the analysis of low-degree tests! How do they obtain this reduction? It turns out that this reduction is obtained by exploding the proof size to the order of n 10 4 (from some smaller polynomial of size about n 12 in [1]). But by incorporating the analysis from this paper into the analysis of PCP one can obtain better bounds on the probe complexity of proof systems. <p> But by incorporating the analysis from this paper into the analysis of PCP one can obtain better bounds on the probe complexity of proof systems. The verifier we construct probes a proof at most 165 bits (as opposed to the 10 4 of <ref> [1, 13] </ref>) while increasing the proof size to only n 2+* (to be contrasted with the n 10 4 in [7]). (We point out that the improvement relies fairly heavily on the techniques developed in [7] and [13], as well as those of [2] and [1].) 2 Characterizing the Total Degree <p> to the 10 4 of [1, 13]) while increasing the proof size to only n 2+* (to be contrasted with the n 10 4 in [7]). (We point out that the improvement relies fairly heavily on the techniques developed in [7] and [13], as well as those of [2] and <ref> [1] </ref>.) 2 Characterizing the Total Degree of Polynomials Let F = F q be a finite field of order q = p s where p is its characteristic. <p> Notice that E x;h [ffi (l x;h )] = ffi f . The pairwise independence of the lines implies that the collection of real numbers fffi (row i )g i2F is a pairwise independent collection of variables taking values from <ref> [0; 1] </ref> with expectation ffi f . <p> The recursion mechanism of [2] plays a central role in the combination of the various proof systems used here. The final ingredient in the proof system is the randomness-efficient parallelization protocol of <ref> [1] </ref> (which is where the efficiency of the tester of [14] plays a role). Details of the construction will be available in the full paper. Last we would also like to mention two interesting questions that may be raised about locally checkable codes. 1.
Reference: [2] <author> S. Arora and S. Safra. </author> <title> Probabilistic checking of proofs: A new characterization of NP. </title> <booktitle> In Proceedings of the 33rd Annual IEEE Symposium of the Foundations of Computer Science, </booktitle> <pages> pages 2-13, </pages> <year> 1992. </year>
Reference-contexts: The low-degree testing problem has been studied widely due to their relationship with probabilistically checkable (holographic) proofs and program checking. <ref> [5, 6, 9, 2, 10, 13] </ref> study the case of testing the maximum degree and [8, 11, 14, 1] study the case of testing total degree 1 . Our improvements are to the latter family of testers. We start by describing their testers. <p> This will become clear in the context of our applications. 1 Some of the improvements in the former family have also affected the latter. In particular [1] obtain their improvement using the improved analysis of <ref> [2] </ref>. Similarly the work of [13] also affects the latter family of testers. The correctness of the tester is proved by the following kind of a statement. <p> The codes of [6] for instance produce good codes which are (polylog (k i ); (1))-locally testable. The work of <ref> [2] </ref> implicitly describe a related code which achieves both p; 1 ffi = O (1), but requires very large alphabet sizes to get this namely their code requires a i = k * i . <p> The significant improvement in [1] is to get good codes which have p = 2, ffi &gt; 0 with a i = polylog (k i ). (By applying a recursive technique introduced by <ref> [2] </ref> to this code they later manage to reduce a to a constant as well.) The code used by [1] is the following (see also [15]): Definition 10 (Polynomial-Line Codes) Let c 1 &gt; 1 and c 2 1 be parameters. <p> Connection with proof checking Lastly we describe a very informal manner the way in which this affects the construction of probabilistically checkable proofs. We assume that the reader of this subsection is familiar with the notion of probabilistically checkable proofs (PCPs) as defined in <ref> [2] </ref> (see, for instance, [3] for a survey). In particular we discuss the probe complexity of proofs and the sizes of probabilistically checkable proofs. As mentioned earlier every holographic proof ends up inheriting part of its properties on some underlying locally-testable code. <p> (as opposed to the 10 4 of [1, 13]) while increasing the proof size to only n 2+* (to be contrasted with the n 10 4 in [7]). (We point out that the improvement relies fairly heavily on the techniques developed in [7] and [13], as well as those of <ref> [2] </ref> and [1].) 2 Characterizing the Total Degree of Polynomials Let F = F q be a finite field of order q = p s where p is its characteristic. <p> By Lemma 16 we now conclude that Corr f = g implying that d (f; g) 2ffi f . 3.1 Proof of Main Lemma The proof of Lemma 18 relies on a minor strengthening of the following lemma due to [13], which in turn improves upon a similar lemma in <ref> [2] </ref>. <p> In fact our verifier uses theirs as a black box and then builds upon it. In addition to the use of such size-efficient proof systems our construction also use many ingredients from the query-efficient proofs of [7]. The recursion mechanism of <ref> [2] </ref> plays a central role in the combination of the various proof systems used here. The final ingredient in the proof system is the randomness-efficient parallelization protocol of [1] (which is where the efficiency of the tester of [14] plays a role).
Reference: [3] <author> L. Babai. </author> <title> Transparent (holographic) proofs. </title> <booktitle> Springer-Verlag Lecture Notes on Computer Science, 10th Annual Symposium on Theoretical Aspects of Computer Science, </booktitle> <volume> 665 </volume> <pages> 525-533, </pages> <year> 1993. </year>
Reference-contexts: Connection with proof checking Lastly we describe a very informal manner the way in which this affects the construction of probabilistically checkable proofs. We assume that the reader of this subsection is familiar with the notion of probabilistically checkable proofs (PCPs) as defined in [2] (see, for instance, <ref> [3] </ref> for a survey). In particular we discuss the probe complexity of proofs and the sizes of probabilistically checkable proofs. As mentioned earlier every holographic proof ends up inheriting part of its properties on some underlying locally-testable code.
Reference: [4] <author> L. Babai and K. Friedl. </author> <title> On slightly superlinear transparent proofs. </title> <type> Tech. Report CS 93-13, </type> <institution> Department of Computer Science, University of Chicago, </institution> <year> 1993. </year>
Reference: [5] <author> L. Babai, L. Fortnow, and C. Lund. </author> <title> Nondeterministic exponential time has two-prover interactive protocols. Computational Complexity, </title> <booktitle> 1 (1991), </booktitle> <pages> 3-40. </pages>
Reference-contexts: The low-degree testing problem has been studied widely due to their relationship with probabilistically checkable (holographic) proofs and program checking. <ref> [5, 6, 9, 2, 10, 13] </ref> study the case of testing the maximum degree and [8, 11, 14, 1] study the case of testing total degree 1 . Our improvements are to the latter family of testers. We start by describing their testers.
Reference: [6] <author> L. Babai, L. Fortnow, L.A. Levin, and M. Szegedy. </author> <title> Checking computations in polylogarithmic time. </title> <booktitle> In Proceedings of the 23rd STOC, </booktitle> <pages> pages 21-31, </pages> <year> 1991. </year>
Reference-contexts: The low-degree testing problem has been studied widely due to their relationship with probabilistically checkable (holographic) proofs and program checking. <ref> [5, 6, 9, 2, 10, 13] </ref> study the case of testing the maximum degree and [8, 11, 14, 1] study the case of testing total degree 1 . Our improvements are to the latter family of testers. We start by describing their testers. <p> Conversely, if w = C (m) for some m, then V (r; w q 1 (r) ; : : : ; w q p (r) ) = 1 for all r 2 . The codes of <ref> [6] </ref> for instance produce good codes which are (polylog (k i ); (1))-locally testable.
Reference: [7] <author> M. Bellare, S. Goldwasser, C. Lund, and A. Russell. </author> <title> Efficient probabilistically checkable proofs. </title> <booktitle> In Proceedings of the 25th Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 294-304, </pages> <year> 1993. </year>
Reference-contexts: Thus the probe complexity of a PCP seems to be inherently dependent on the ratio of p and ffi. However, the relationship between p=ffi and the probe complexity of PCP turns out to be not so simple. <ref> [7] </ref> manage to reduce the probe complexity of a PCP to about 24 bits to get a confidence of 1=2 (from some unknown number estimated to be around 10 4 in [1]) without improving the analysis of low-degree tests! How do they obtain this reduction? It turns out that this reduction <p> The verifier we construct probes a proof at most 165 bits (as opposed to the 10 4 of [1, 13]) while increasing the proof size to only n 2+* (to be contrasted with the n 10 4 in <ref> [7] </ref>). (We point out that the improvement relies fairly heavily on the techniques developed in [7] and [13], as well as those of [2] and [1].) 2 Characterizing the Total Degree of Polynomials Let F = F q be a finite field of order q = p s where p is <p> construct probes a proof at most 165 bits (as opposed to the 10 4 of [1, 13]) while increasing the proof size to only n 2+* (to be contrasted with the n 10 4 in <ref> [7] </ref>). (We point out that the improvement relies fairly heavily on the techniques developed in [7] and [13], as well as those of [2] and [1].) 2 Characterizing the Total Degree of Polynomials Let F = F q be a finite field of order q = p s where p is its characteristic. <p> The model we use here is the same as that used by [13]. In fact our verifier uses theirs as a black box and then builds upon it. In addition to the use of such size-efficient proof systems our construction also use many ingredients from the query-efficient proofs of <ref> [7] </ref>. The recursion mechanism of [2] plays a central role in the combination of the various proof systems used here. The final ingredient in the proof system is the randomness-efficient parallelization protocol of [1] (which is where the efficiency of the tester of [14] plays a role).
Reference: [8] <author> M. Blum, M. Luby, and R. Rubinfeld. </author> <title> Self-testing/correcting with applications to numerical problems. </title> <booktitle> In Proceedings of the 22nd Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 73-83, </pages> <year> 1990. </year>
Reference-contexts: The low-degree testing problem has been studied widely due to their relationship with probabilistically checkable (holographic) proofs and program checking. [5, 6, 9, 2, 10, 13] study the case of testing the maximum degree and <ref> [8, 11, 14, 1] </ref> study the case of testing total degree 1 . Our improvements are to the latter family of testers. We start by describing their testers.
Reference: [9] <author> U. Feige, S. Goldwasser, L. Lov asz, S. Safra, and M. Szegedy. </author> <title> Approximating clique is almost NP-complete. </title> <booktitle> In Proceedings of the 32nd IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 2-12, </pages> <year> 1991. </year>
Reference-contexts: The low-degree testing problem has been studied widely due to their relationship with probabilistically checkable (holographic) proofs and program checking. <ref> [5, 6, 9, 2, 10, 13] </ref> study the case of testing the maximum degree and [8, 11, 14, 1] study the case of testing total degree 1 . Our improvements are to the latter family of testers. We start by describing their testers.
Reference: [10] <author> K. Friedl, Zs. H ats agi, and A. Shen. </author> <title> Low-degree tests. </title> <booktitle> In Proceedings of the 5th ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <pages> pages 57-64, </pages> <year> 1994. </year>
Reference-contexts: The low-degree testing problem has been studied widely due to their relationship with probabilistically checkable (holographic) proofs and program checking. <ref> [5, 6, 9, 2, 10, 13] </ref> study the case of testing the maximum degree and [8, 11, 14, 1] study the case of testing total degree 1 . Our improvements are to the latter family of testers. We start by describing their testers.
Reference: [11] <author> P. Gemmell, R. Lipton, R. Rubinfeld, M. Sudan, and A. Wigderson. </author> <title> Self-testing/correcting for polynomials and for approximate functions. </title> <booktitle> In Proceedings of the 23rd Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 32-42, </pages> <year> 1991. </year>
Reference-contexts: The low-degree testing problem has been studied widely due to their relationship with probabilistically checkable (holographic) proofs and program checking. [5, 6, 9, 2, 10, 13] study the case of testing the maximum degree and <ref> [8, 11, 14, 1] </ref> study the case of testing total degree 1 . Our improvements are to the latter family of testers. We start by describing their testers. <p> The smallest field size over which polynomials of a given total degree exhibit sufficient redundancy to, say, enable the application of the Schwartz-Zippel like theorems [16, 18], is when the field size is at least d + 2. The low-degree tester of <ref> [11] </ref> uses sets of the same size, i.e., d + 2, as elementary test sets. Their proof manages to show that in a certain sense (see Lemma 5) fields of size d + 2 are sufficient to show some sort of robustness. <p> We use the above statement in combination with the following Lemma from <ref> [11, 15] </ref>, to get Theorem 6. Lemma 5 ([11, 15]) There exists a constant c such that if jF j d + 2 and ffi 1 c (d+1) 2 and P and f satisfy Pr [P x;h (t) 6= f (x + t h)] ffi then there exists a function g <p> 2 F , P x;h (t) = g (x + t h), but 1.2 Improving the efficiency Improving the second of the two parameters in the statement of the Informal Statement is a task of greater significance. (Here an improvement would imply a larger value of ffi.) The result in <ref> [11] </ref> shows that the test works for ffi O (1=d 2 ). The improvements in [14] and [1] yielded ffi O (1=d) and ffi ffi 0 for some ffi 0 &gt; 0 respectively.
Reference: [12] <author> S. Phillips and S. Safra. </author> <title> Efficient Probabilistic Verification. </title> <type> Manuscript, </type> <year> 1992. </year>
Reference-contexts: Does there exist such a family of codes with constant alphabet size? Acknowledgments We would like to thank Laci Babai and Oded Goldreich for their valuable comments. We also thank Steven Phillips for providing us with a copy of the manuscript <ref> [12] </ref>.
Reference: [13] <author> A. Polishchuk and D. Spielman. </author> <title> Nearly-linear size holographic proofs. </title> <booktitle> In Proceedings of the 26th Annual ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 194-203. </pages>
Reference-contexts: The low-degree testing problem has been studied widely due to their relationship with probabilistically checkable (holographic) proofs and program checking. <ref> [5, 6, 9, 2, 10, 13] </ref> study the case of testing the maximum degree and [8, 11, 14, 1] study the case of testing total degree 1 . Our improvements are to the latter family of testers. We start by describing their testers. <p> This will become clear in the context of our applications. 1 Some of the improvements in the former family have also affected the latter. In particular [1] obtain their improvement using the improved analysis of [2]. Similarly the work of <ref> [13] </ref> also affects the latter family of testers. The correctness of the tester is proved by the following kind of a statement. <p> Remark: The bound on the field size in the above theorem is also better than that of [1] who are only able to show it for jF j d 3 . However, this improvement can already be inferred in the work of <ref> [13] </ref>. In fact, our analysis inherits this particular improvement from their analysis. 1.3 An Application The second theorem given above turns out to have some implication to the properties of probabilistically checkable proofs. <p> It is clear that for all constants c 1 and c 2 the Polynomial-Line codes are good codes. [1] show that for all c 1 &gt; 1 and c 2 3 these codes give (2; ffi &gt; 0)-locally testable codes. <ref> [13] </ref> improve this to c 2 1, without changing the ffi in any significant way. Our analysis (Theorem 7) immediately yields that Polynomial-Line Codes are (2; 1=8 *)-locally testable. It can be easily shown that no code can achieve (2; 1=2 + *)-local testability. <p> But by incorporating the analysis from this paper into the analysis of PCP one can obtain better bounds on the probe complexity of proof systems. The verifier we construct probes a proof at most 165 bits (as opposed to the 10 4 of <ref> [1, 13] </ref>) while increasing the proof size to only n 2+* (to be contrasted with the n 10 4 in [7]). (We point out that the improvement relies fairly heavily on the techniques developed in [7] and [13], as well as those of [2] and [1].) 2 Characterizing the Total Degree <p> a proof at most 165 bits (as opposed to the 10 4 of [1, 13]) while increasing the proof size to only n 2+* (to be contrasted with the n 10 4 in [7]). (We point out that the improvement relies fairly heavily on the techniques developed in [7] and <ref> [13] </ref>, as well as those of [2] and [1].) 2 Characterizing the Total Degree of Polynomials Let F = F q be a finite field of order q = p s where p is its characteristic. <p> By Lemma 16 we now conclude that Corr f = g implying that d (f; g) 2ffi f . 3.1 Proof of Main Lemma The proof of Lemma 18 relies on a minor strengthening of the following lemma due to <ref> [13] </ref>, which in turn improves upon a similar lemma in [2]. Lemma 19 ([13]) For any * &gt; 0, if r i and c j are families of degree d polynomials such that Pr [r i (j) 6= c j (i)] 1=4 *; then there exists a bivariate polynomial Q of <p> To be able to lay out precise bounds on the size of the proof, one needs to be careful about the model of computing used to define the size of a proof. The model we use here is the same as that used by <ref> [13] </ref>. In fact our verifier uses theirs as a black box and then builds upon it. In addition to the use of such size-efficient proof systems our construction also use many ingredients from the query-efficient proofs of [7].
Reference: [14] <author> R. Rubinfeld and M. Sudan. </author> <title> Testing polynomial functions efficiently and over rational domains. </title> <booktitle> In Proceedings of the 3rd Annual ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <pages> pages 23-43, </pages> <year> 1992. </year>
Reference-contexts: The low-degree testing problem has been studied widely due to their relationship with probabilistically checkable (holographic) proofs and program checking. [5, 6, 9, 2, 10, 13] study the case of testing the maximum degree and <ref> [8, 11, 14, 1] </ref> study the case of testing total degree 1 . Our improvements are to the latter family of testers. We start by describing their testers. <p> Ties are broken arbitrarily. The tester in <ref> [14] </ref> is effectively the following: Pick x, h randomly and uniformly from F m and t randomly from F and verify that P (f;d) x;h (t) = f (x + t h). For our purposes it is not important how P (f;d) is computed by the tester. <p> The improvements in <ref> [14] </ref> and [1] yielded ffi O (1=d) and ffi ffi 0 for some ffi 0 &gt; 0 respectively. The constant ffi 0 coming from the latter analysis is not described explicitly but the number appears to be fairly small. <p> The recursion mechanism of [2] plays a central role in the combination of the various proof systems used here. The final ingredient in the proof system is the randomness-efficient parallelization protocol of [1] (which is where the efficiency of the tester of <ref> [14] </ref> plays a role). Details of the construction will be available in the full paper. Last we would also like to mention two interesting questions that may be raised about locally checkable codes. 1. Does there exist a family of good (2; 1=2) locally checkable codes? 2.
Reference: [15] <author> R. Rubinfeld and M. Sudan. </author> <title> Robust characterizations of polynomials with applications to program testing. </title> <type> Technical Report RC 19156, </type> <institution> IBM Research Division, T. J. Watson Research Center, </institution> <address> Yorktown Heights, NY 10598, </address> <month> September </month> <year> 1993. </year>
Reference-contexts: However their proof falls short of showing low-degree tests that work over fields of size d + 2 because of the lack of an exact characterization (in the sense of <ref> [15] </ref>). We complement their work by providing an exact characterization of low-degree polynomials, which shows that their tester is good for prime fields of size d + 2, and improves the bound for non-prime fields as well. We give examples to show that our characterizations are essentially the best possible. <p> We use the above statement in combination with the following Lemma from <ref> [11, 15] </ref>, to get Theorem 6. Lemma 5 ([11, 15]) There exists a constant c such that if jF j d + 2 and ffi 1 c (d+1) 2 and P and f satisfy Pr [P x;h (t) 6= f (x + t h)] ffi then there exists a function g <p> It turns out that all the known construction of holographic proof inherits part of their properties from the properties of some underlying error-correcting code. It is easiest to describe the effect of our analysis in terms of the improvement in the properties of the codes created in <ref> [1, 15] </ref>. The following definitions are from [15]. <p> It is easiest to describe the effect of our analysis in terms of the improvement in the properties of the codes created in [1, 15]. The following definitions are from <ref> [15] </ref>. <p> good codes which have p = 2, ffi &gt; 0 with a i = polylog (k i ). (By applying a recursive technique introduced by [2] to this code they later manage to reduce a to a constant as well.) The code used by [1] is the following (see also <ref> [15] </ref>): Definition 10 (Polynomial-Line Codes) Let c 1 &gt; 1 and c 2 1 be parameters. The polynomial-line codes fL m g are chosen by letting d = fi (m c 1 ) and picking a finite field F of size fi (d c 2 ). <p> Our proof is based on the proof in <ref> [15] </ref> and borrows various ingredients from their technique. However our analysis seems to be simplify certain aspects of their proof by introducing an inductive analysis to their proof.
Reference: [16] <author> J.T. Schwartz. </author> <title> Fast probabilistic algorithms for verification of polynomial identities. </title> <journal> Journal of the ACM, v. </journal> <volume> 27, </volume> <pages> 701-717, </pages> <year> 1980. </year>
Reference-contexts: The smallest field size over which polynomials of a given total degree exhibit sufficient redundancy to, say, enable the application of the Schwartz-Zippel like theorems <ref> [16, 18] </ref>, is when the field size is at least d + 2. The low-degree tester of [11] uses sets of the same size, i.e., d + 2, as elementary test sets.
Reference: [17] <author> M. Sudan. </author> <title> Efficient Checking of Polynomials and Proofs and the Hardness of Approximation Problems. </title> <type> PhD thesis, </type> <institution> University of California at Berkeley, Berkeley, </institution> <address> CA 94720, </address> <year> 1992. </year>
Reference: [18] <author> R. Zippel. </author> <title> Probabilistic algorithms for sparse polynomials. </title> <booktitle> EUROSAM '79, Lecture Notes in Computer Science, </booktitle> <volume> 72 </volume> <pages> 216-226, </pages> <year> 1979. </year>
Reference-contexts: The smallest field size over which polynomials of a given total degree exhibit sufficient redundancy to, say, enable the application of the Schwartz-Zippel like theorems <ref> [16, 18] </ref>, is when the field size is at least d + 2. The low-degree tester of [11] uses sets of the same size, i.e., d + 2, as elementary test sets.
References-found: 18

