URL: http://www.cs.iastate.edu/tech-reports/TR92-39.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: http://www.cs.iastate.edu
Title: Hardware-Assisted Garbage Collection for the Icon Programming Language  
Author: TR - Ramakrishna Chinta 
Address: 226 Atanasoff Ames, IA 50011  
Affiliation: Iowa State University of Science and Technology Department of Computer Science  
Date: December, 1992  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> K. Nilsen and W. J. Schmidt, </author> <title> Hardware-Assisted General-Purpose garbage Collection for Hard Real-Time Systems, </title> <institution> Iowa State Univ. </institution> <type> Tech. Rep. </type> <pages> 92-25, </pages> <year> 1992. </year>
Reference-contexts: Thus real-time programmers are unable to utilize the power of very high-level languages like Icon. 1.3 Hardware-Assisted Garbage Collection The above-mentioned problem has been addressed by researchers working on real-time support for high level languages <ref> [1, 5, 6, 11, 12, 10] </ref>. Reference [1] describes a hardware architecture that enables hardware-assisted garbage collection. This architecture offers high average-case allocation rates and memory bandwidths, with a tight bound on worst-case allocations, fetches, and stores. <p> Thus real-time programmers are unable to utilize the power of very high-level languages like Icon. 1.3 Hardware-Assisted Garbage Collection The above-mentioned problem has been addressed by researchers working on real-time support for high level languages [1, 5, 6, 11, 12, 10]. Reference <ref> [1] </ref> describes a hardware architecture that enables hardware-assisted garbage collection. This architecture offers high average-case allocation rates and memory bandwidths, with a tight bound on worst-case allocations, fetches, and stores. <p> It provides real-time response by interleaving incremental garbage collection activities with ongoing execution of application software. 1.4 Objective This work aims at providing an Icon implementation that is more conducive to a real-time environment and investigating the utility of the garbage collection architecture proposed in reference <ref> [1] </ref>. The traditional run-time implementation of Icon is changed to use the special hardware to perform hardware-assisted garbage collection. The work also attempts to characterize the efforts required to port existing garbage-collected languages to the hardware-assisted garbage-collection environment. <p> Performance results on sample test cases are provided to give an estimate of the overhead introduced by the garbage collection protocol on the overall performance. 2 2 Hardware-Assisted Garbage Collection This section gives an overview of the hardware architecture and the garbage-collecting algorithm. More thorough descriptions are provided in <ref> [1, 2, 3] </ref>. 2.1 Architecture The garbage-collected memory module is configured into the traditional bus architecture as shown above. The GC module appears to be an extension to normal memory and occupies part of the real-memory address space. <p> An Icon string descriptor would ideally look like 12 J J H E L L O 5 Icon Descriptor Slice Object Slice Region However, slice region data referenced by an arbitrary descriptor is only treated as live if it is also referenced by a slice object <ref> [1] </ref>. This means that on a flip, a pointer to the slice object has to be tended, rather than a pointer to the slice region, for the string to be treated as live data.
Reference: [2] <author> K. Nilsen, </author> <title> Memory Cycle Accountings for Hardware-Assisted Real-Time Garbage Collection, </title> <institution> Iowa State Univ. </institution> <type> Tech. Rep. 91-21, </type> <institution> Iowa State Univ., </institution> <year> 1991. </year>
Reference-contexts: Performance results on sample test cases are provided to give an estimate of the overhead introduced by the garbage collection protocol on the overall performance. 2 2 Hardware-Assisted Garbage Collection This section gives an overview of the hardware architecture and the garbage-collecting algorithm. More thorough descriptions are provided in <ref> [1, 2, 3] </ref>. 2.1 Architecture The garbage-collected memory module is configured into the traditional bus architecture as shown above. The GC module appears to be an extension to normal memory and occupies part of the real-memory address space. <p> The worst-case fetch time is shown to be 6 traditional memory cycles <ref> [2] </ref>. For both fetch and store operations, the average cost is nearly the same as traditional memory. 6 3 Implementation of Icon The Icon system for version 8.0 of Icon consists mainly of two parts: a translator and a run-time system.
Reference: [3] <author> K. Nilsen and W. J. Schmidt, </author> <title> Preferred embodiment of a Hardware-Assisted Garbage-Collection System, </title> <institution> Iowa State Univ. </institution> <type> Tech. Rep. </type> <pages> 1992-17, </pages> <year> 1992. </year>
Reference-contexts: Performance results on sample test cases are provided to give an estimate of the overhead introduced by the garbage collection protocol on the overall performance. 2 2 Hardware-Assisted Garbage Collection This section gives an overview of the hardware architecture and the garbage-collecting algorithm. More thorough descriptions are provided in <ref> [1, 2, 3] </ref>. 2.1 Architecture The garbage-collected memory module is configured into the traditional bus architecture as shown above. The GC module appears to be an extension to normal memory and occupies part of the real-memory address space.
Reference: [4] <author> W. J. Schmidt, </author> <title> Issues in the Design and Implementation of a Real-Time Garbage Collection Architecture, </title> <institution> Iowa State Univ. </institution> <type> Tech. Rep. </type> <pages> 1992-25, </pages> <year> 1992. </year>
Reference-contexts: However the following overheads are directly proportional to the amount of data stored in the GC area. * overhead to keep track and update the descriptor tags of GC memory cells. Other studies have shown this overhead to be very significant <ref> [4] </ref>. * overhead to copy the live objects from from-space to to-space on a flip. We need to balance the tradeoffs by properly choosing between traditional and garbage-collected memory for all dynamically allocated data. <p> If it were stored in GC memory, any change to it would need an update of the associated descriptor tags, and this could introduce tremendous overhead <ref> [4] </ref>. * co-expression blocks contain internal pointers and hence are difficult to relocate to another place. So, the decision holds good even when GC-Icon is adapted to support co-expressions.
Reference: [5] <author> K. Nilsen, </author> <title> Garbage Collection of Strings and Linked Data Structures in Real-Time, </title> <journal> Software-Practice And Experience, </journal> <volume> Vol. 18(7), </volume> <month> July </month> <year> 1988, </year> <pages> 613-640. </pages>
Reference-contexts: Thus real-time programmers are unable to utilize the power of very high-level languages like Icon. 1.3 Hardware-Assisted Garbage Collection The above-mentioned problem has been addressed by researchers working on real-time support for high level languages <ref> [1, 5, 6, 11, 12, 10] </ref>. Reference [1] describes a hardware architecture that enables hardware-assisted garbage collection. This architecture offers high average-case allocation rates and memory bandwidths, with a tight bound on worst-case allocations, fetches, and stores.
Reference: [6] <author> K. Nilsen, </author> <title> Design and Implementation of High-Level Programming Language Features for Pattern Matching in Real Time, </title> <type> Ph.D. Dissertation, </type> <institution> University of Arizona, Tucson, </institution> <year> 1988. </year>
Reference-contexts: Thus real-time programmers are unable to utilize the power of very high-level languages like Icon. 1.3 Hardware-Assisted Garbage Collection The above-mentioned problem has been addressed by researchers working on real-time support for high level languages <ref> [1, 5, 6, 11, 12, 10] </ref>. Reference [1] describes a hardware architecture that enables hardware-assisted garbage collection. This architecture offers high average-case allocation rates and memory bandwidths, with a tight bound on worst-case allocations, fetches, and stores.
Reference: [7] <author> R. E. Griswold and M. T. Griswold, </author> <title> The Icon Programming Language, </title> <publisher> Prentice Hall Inc., </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1983. </year>
Reference-contexts: Its semantics offer expression-based, goal-directed evaluation. It offers various features that free the programmer from low-level details and help reduce software development time. Some of features offered are listed below. The language is described in detail in reference <ref> [7] </ref>. * No type declarations. Variables can have values of any type. * Several high-level data structures such as lists, sets, tables.
Reference: [8] <author> R. E. Griswold and M. T. Griswold, </author> <title> The Implementation of Icon Programming Language, </title> <publisher> Princeton University Press, </publisher> <year> 1986. </year>
Reference-contexts: The icode is then interpreted by the run-time system during execution. The run-time system consists of an interpreter for icode and a library of support routines to carry out the various operations required by the interpreter. Reference <ref> [8] </ref> describes the implementation of the run-time system in detail. This section introduces implementation issues that are relevant to memory management. 3.1 Icon Descriptors Every Icon value is represented by a descriptor comprised of 2 words.
Reference: [9] <author> M. F. Fernandez and D. Hansen, </author> <note> Research Report CS-TR-324-91, </note> <institution> Dept. of Computer Science, Princeton University, </institution> <year> 1991. </year>
Reference-contexts: Unfortunately, it is observed that garbage collection can have a measurable effect on the overall performance of the language. It can account for up to 76% of total execution time of some Icon programs <ref> [9] </ref>. Of even 1 greater concern are the delays that occur at unpredictable times to garbage collect memory. In a real-time environment, it is critical to have a tightly bounded response time.
Reference: [10] <author> A. W. Appel, J. R. Ellis, and K. Li, </author> <title> Real-time Concurrent Collection on Stock Multiprocessors, </title> <journal> SIGPLAN Notices, </journal> <volume> Vol 23(7), </volume> <month> July </month> <year> 1988, </year> <pages> 11-20. </pages>
Reference-contexts: Thus real-time programmers are unable to utilize the power of very high-level languages like Icon. 1.3 Hardware-Assisted Garbage Collection The above-mentioned problem has been addressed by researchers working on real-time support for high level languages <ref> [1, 5, 6, 11, 12, 10] </ref>. Reference [1] describes a hardware architecture that enables hardware-assisted garbage collection. This architecture offers high average-case allocation rates and memory bandwidths, with a tight bound on worst-case allocations, fetches, and stores.
Reference: [11] <author> H. G. Baker Jr., </author> <title> List Processing in Real Time on a Serial Computer, </title> <journal> Comm. ACM 21, </journal> <month> 4 (April </month> <year> 1978), </year> <pages> 280-293. </pages>
Reference-contexts: Thus real-time programmers are unable to utilize the power of very high-level languages like Icon. 1.3 Hardware-Assisted Garbage Collection The above-mentioned problem has been addressed by researchers working on real-time support for high level languages <ref> [1, 5, 6, 11, 12, 10] </ref>. Reference [1] describes a hardware architecture that enables hardware-assisted garbage collection. This architecture offers high average-case allocation rates and memory bandwidths, with a tight bound on worst-case allocations, fetches, and stores.
Reference: [12] <author> Johnson, </author> <title> Reducing the Latency of a Real-Time Garbage Collector, </title> <journal> ACM Letters on Prog. Lang. and Systems. </journal> <volume> 34 </volume>
Reference-contexts: Thus real-time programmers are unable to utilize the power of very high-level languages like Icon. 1.3 Hardware-Assisted Garbage Collection The above-mentioned problem has been addressed by researchers working on real-time support for high level languages <ref> [1, 5, 6, 11, 12, 10] </ref>. Reference [1] describes a hardware architecture that enables hardware-assisted garbage collection. This architecture offers high average-case allocation rates and memory bandwidths, with a tight bound on worst-case allocations, fetches, and stores.
Reference: [13] <author> D. A. Patterson and J. L. Hennessey, </author> <title> Computer Architecture: A Quan--titative Approach, </title> <publisher> Morgan Kauffmann Publishers Inc., </publisher> <year> 1990. </year> <month> 35 </month>
Reference-contexts: The modified Icon implementation that uses hardware-assisted garbage collection will henceforth be called GC-Icon. 4.1 Background Work The GC module has been simulated on the DLX architecture <ref> [13] </ref>. In order to incorporate hardware-assisted garbage collection we need an Icon implementation for DLX architecture. The implementation of Icon's run-time system is written in C and contains about 50 source code files, containing an average of 600 lines per file.
References-found: 13

