URL: http://www.cs.uoregon.edu/~sabry/papers/purelyFunctional.ps
Refering-URL: http://www.cs.uoregon.edu/~sabry/papers/index.html
Root-URL: http://www.cs.uoregon.edu
Email: sabry@cs.uoregon.edu  
Title: What is a Purely Functional Language?  
Author: Amr Sabry 
Address: Eugene, OR 97403  
Affiliation: Department of Computer Information Science University of Oregon  
Date: 1 (1): 1-000, January 1993  
Note: J. Functional Programming  c 1993 Cambridge University Press 1  
Abstract: Functional programming languages are informally classified into pure and impure languages. The precise meaning of this distinction has been a matter of controversy. We therefore investigate a formal definition of purity. We begin by showing that some proposed definitions that rely on confluence, soundness of the beta axiom, preservation of pure observational equivalences, and independence of the order of evaluation, do not withstand close scrutiny. We propose instead a definition based on parameter-passing independence. Intuitively, the definition implies that functions are pure mappings from arguments to results; the operational decision of how to pass the arguments is irrelevant. In the context of Haskell, our definition is consistent with the fact that the traditional call-by-name denotational semantics coincides with the traditional call-by-need implementation. Furthermore, our definition is compatible with the stream-based, continuation-based, and monad-based integration of computational effects in Haskell. Finally, we ob serve that call-by-name reasoning principles are unsound in compilers for monadic Haskell.
Abstract-found: 1
Intro-found: 1
Reference: <author> Ariola, Zena M., & Felleisen, Matthias. </author> <year> (1996). </year> <title> The call-by-need lambda calculus. </title> <note> To appear in the Journal of Functional Programming. </note>
Reference: <author> Ariola, Zena M., Felleisen, Matthias, Maraist, John, Odersky, Martin, & Wadler, Philip. </author> <year> (1995). </year> <title> A call-by-need lambda calculus. </title> <booktitle> Pages 233-246 of: ACM Symposium on Principles of Programming Languages. </booktitle>
Reference-contexts: Clearly, as we demonstrate above, ghc cannot use arbitrary fi-reductions on the intermediate representation of the program. Fortunately, even before the monadic extensions, ghc was careful not to duplicate work and hence refrained from using fi steps for performance reasons <ref> (Ariola et al., 1995) </ref>. Consequently, the addition of assignments to the back end did not cause any immediate problems.
Reference: <author> Barendregt, H. P. </author> <year> (1984). </year> <title> The lambda calculus: Its syntax and semantics. Revised edn. </title> <booktitle> Studies in Logic and the Foundations of Mathematics, </booktitle> <volume> vol. 103. </volume> <publisher> North-Holland. </publisher>
Reference-contexts: We then divide the reductions into three groups. The first group G 1 includes C and is Church-Rosser because the reduction forms an orthogonal combinatory reduction system (Klop et al., 1993). The second group G 2 includes fi which is Church-Rosser <ref> (Barendregt, 1984) </ref>. The third group G 3 includes the remaining reductions S and A and is Church-Rosser because the reflexive closure of the reductions satisfies the diamond property (Barendregt, 1984, Ch.3). The result follows by the Hindley-Rosen Lemma (Barendregt, 1984) since G 2 commutes with G 3 , and the union <p> The second group G 2 includes fi which is Church-Rosser (Barendregt, 1984). The third group G 3 includes the remaining reductions S and A and is Church-Rosser because the reflexive closure of the reductions satisfies the diamond property <ref> (Barendregt, 1984, Ch.3) </ref>. <p> The second group G 2 includes fi which is Church-Rosser <ref> (Barendregt, 1984) </ref>. The third group G 3 includes the remaining reductions S and A and is Church-Rosser because the reflexive closure of the reductions satisfies the diamond property (Barendregt, 1984, Ch.3). The result follows by the Hindley-Rosen Lemma (Barendregt, 1984) since G 2 commutes with G 3 , and the union of G 2 and G 3 commutes with G 1 . 3 An Imperative Extension fl ! To study the impact of computational effects on the properties of purely functional languages, we extend our language with expressions whose
Reference: <author> Cartwright, R., & Felleisen, Matthias. </author> <year> 1991 </year> <month> (August). </month> <title> Observable sequentiality and full abstraction. </title> <type> Tech. </type> <institution> rept. 91-167. Rice University. </institution> <note> Preliminary version in: </note> <editor> Proc. </editor> <booktitle> 19th ACM Symposium on Principles of Programming Languages (1992), </booktitle> <pages> pp. 328-342. </pages>
Reference: <author> Cartwright, R., Curien, P.-L., & Felleisen, Matthias. </author> <year> 1993 </year> <month> (December). </month> <title> Fully abstract semantics for observably sequential languages. </title> <type> Tech. </type> <institution> rept. 93-219. Rice University. </institution> <note> Also appears in Information and Computation 111 (2), </note> <year> 1994, </year> <pages> 297-401. </pages>
Reference: <author> Felleisen, Matthias. </author> <year> (1991). </year> <title> On the expressive power of programming languages. </title> <booktitle> Pages 35-75 of: Science of Computer Programming, </booktitle> <volume> vol. </volume> <month> 17. </month> <title> Preliminary version in: </title> <booktitle> Proc. Eu-ropean Symposium on Programming, Lecture Notes in Computer Science, </booktitle> <volume> 432. </volume> <publisher> Springer-Verlag (1990), </publisher> <pages> 134-151. </pages>
Reference-contexts: Definition 2.5 (Stuck) A term M where M is an application or an addition is stuck if the term rewriting machine has no transition from that term. In the remainder of this paper, we will be study the language fl and its extensions. Definition 2.6 (Conservative Extension <ref> (Felleisen, 1991) </ref>) A language L 1 conservatively extends a language L 2 if: What is a Purely Functional Language? 5 * the set of L 1 -terms (programs) includes the set of L 2 -terms (programs), * the of L 1 -observables includes the set of L 2 -observables, and * <p> Proposition 3.4 (x:M ) N ~ = ! M [N=x] The proposition motivates the following statement. Fact 3.5 Without further information about a language, the soundness of the fi axiom does not guarantee that the language is purely functional. However, as generally expected from an imperative extension <ref> (Felleisen, 1991) </ref>, the observational equivalence relation of fl ! differs from the one for fl. Proposition 3.6 The observational equivalence relations ~ = and ~ = ! are different. Proof 8 Amr Sabry From proposition 2.8, we have x + y ~ = y + x. <p> However, we show that a nave interpretation of this idea is incorrect. It is possible to break some observational equivalences of a purely functional language by extending it with a pure but non-expressible <ref> (Felleisen, 1991) </ref> construct. The standard illustration of this situation are the two purely functional languages PCF and PPCF (Plotkin, 1977). The language PCF extends the simply typed -calculus with constants for expressing recursion, conditionals, and operations on the natural numbers.
Reference: <author> Felleisen, Matthias, & Hieb, R. </author> <year> (1992). </year> <title> The revised report on the syntactic theories of sequential control and state. Theoretical Computer Science, </title> <type> 102, 235-271. Technical Report 89-100, </type> <institution> Rice University. </institution>
Reference: <author> Filinski, Andrzej. </author> <year> (1994). </year> <title> Representing monads. </title> <booktitle> Pages 446-457 of: ACM Symposium on Principles of Programming Languages. </booktitle>
Reference: <author> Filinski, Andrzej. </author> <year> (1996). </year> <title> Controlling effects. </title> <type> Ph.D. thesis, </type> <institution> Carnegie Mellon University. </institution> <note> Available as Technical Report CS-96-119. </note>
Reference: <editor> Hudak, Paul, Peyton Jones, Simon L., & Wadler, Philip. </editor> <year> (1992). </year> <title> Report on the programming language Haskell, a non-strict purely functional language (version 1.2). </title> <journal> SIGPLAN notices, </journal> <volume> 27(5). </volume>
Reference-contexts: The idea is also reminiscent of the stream I/O model in Haskell <ref> (Hudak et al., 1992) </ref> where for example, instead of having side-effecting expressions like writeFile, we have a datatype of Request that includes a data constructor (i.e., a value) WriteFile. These values that refer to I/O operations are accumulated in a stream and performed at the top level.
Reference: <author> Klop, J. W., van Oostrom, V., & van Raamsdon, F. </author> <year> 1993 </year> <month> (June). </month> <title> Combinatory reduction systems: Introduction and survey. </title> <type> Tech. </type> <institution> rept. IR-327. Vrije Universiteit Amsterdam. </institution>
Reference-contexts: We direct each axiom from left to right to yield a system of reductions. We then divide the reductions into three groups. The first group G 1 includes C and is Church-Rosser because the reduction forms an orthogonal combinatory reduction system <ref> (Klop et al., 1993) </ref>. The second group G 2 includes fi which is Church-Rosser (Barendregt, 1984). The third group G 3 includes the remaining reductions S and A and is Church-Rosser because the reflexive closure of the reductions satisfies the diamond property (Barendregt, 1984, Ch.3).
Reference: <author> Launchbury, John, & Peyton Jones, Simon L. </author> <year> (1995). </year> <title> State in Haskell. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 8, </volume> <pages> 193-341. </pages>
Reference-contexts: Even in published papers we find varying statements regarding the definition of purity that refer to notions like the soundness of the fi-axiom (Odersky et al., 1993), referential transparency <ref> (Launchbury & Peyton Jones, 1995) </ref>, the confluence of a calculus for the language (Swarup et al., 1991), the preservation of pure observational equivalences (O'Hearn, 1995), and the independence of order of evaluation (Launchbury & Peyton Jones, 1995). <p> of purity that refer to notions like the soundness of the fi-axiom (Odersky et al., 1993), referential transparency <ref> (Launchbury & Peyton Jones, 1995) </ref>, the confluence of a calculus for the language (Swarup et al., 1991), the preservation of pure observational equivalences (O'Hearn, 1995), and the independence of order of evaluation (Launchbury & Peyton Jones, 1995). The investigation of a formal definition of purity goes beyond settling some differences in opinion. <p> We have not yet undertaken such a proof <ref> (Launchbury & Peyton Jones, 1995, p.322) </ref>. We have already developed a call-by-name operational semantics for the full State in Haskell (Launchbury & Sabry, 1997) language. <p> To prove that the language is pure according to our definition, it remains to develop call-by-value and call-by-need variants of the semantics and show their weak equivalence. 5.3 Implementation The language fl m can by implemented with the same tradeoffs as the language of State in Haskell <ref> (Launchbury & Peyton Jones, 1995) </ref>. We describe two possible implementations: a functional one and an imperative one. The first phase of both implementations translates the source programs by expressing return, &gt;>=, and run in store-passing style.
Reference: <author> Launchbury, John, & Sabry, Amr. </author> <year> (1997). </year> <title> Monadic state: Axiomatization and type safety. </title> <booktitle> ACM SIGPLAN International Conference on Functional Programming. </booktitle>
Reference-contexts: We have not yet undertaken such a proof (Launchbury & Peyton Jones, 1995, p.322). We have already developed a call-by-name operational semantics for the full State in Haskell <ref> (Launchbury & Sabry, 1997) </ref> language.
Reference: <author> Odersky, Martin, Rabin, Dan, & Hudak, Paul. </author> <year> 1993 </year> <month> (Jan.). </month> <title> Call by name, assignment, and the lambda calculus. </title> <booktitle> Pages 43-56 of: ACM Symposium on Principles of Programming Languages. </booktitle>
Reference-contexts: Even in published papers we find varying statements regarding the definition of purity that refer to notions like the soundness of the fi-axiom <ref> (Odersky et al., 1993) </ref>, referential transparency (Launchbury & Peyton Jones, 1995), the confluence of a calculus for the language (Swarup et al., 1991), the preservation of pure observational equivalences (O'Hearn, 1995), and the independence of order of evaluation (Launchbury & Peyton Jones, 1995).
Reference: <author> O'Hearn, Peter W. </author> <year> (1995). </year> <title> Note on Algol and conservatively extending functional programming. </title> <journal> Journal of Functional Programming. </journal> <note> To appear. 22 Amr Sabry Peterson, </note> <editor> J., et al. </editor> . <year> (1996). </year> <title> Report on the programming language Haskell (version 1.3). </title> <type> Tech. </type> <institution> rept. YALEU/DCS/RR-1106. Yale University. </institution>
Reference: <editor> Peyton Jones, Simon L., & Wadler, Philip. </editor> <year> (1993). </year> <title> Imperative functional programming. </title> <booktitle> Pages 71-84 of: ACM Symposium on Principles of Programming Languages. </booktitle>
Reference: <author> Plotkin, Gordon D. </author> <year> (1975). </year> <title> Call-by-name, call-by-value, and the -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1, </volume> <pages> 125-159. </pages>
Reference-contexts: The other expressions, called syntactic values, have a trivial evaluation, and are allowed to be duplicated and hence re-evaluated several times. Definition 4.1 (Syntactic Value) In fl, the following subset of terms are syntactic values <ref> (Plotkin, 1975) </ref>: V ::= n j x:M Definition 4.2 The call-by-need evaluator is defined (Ariola et al., 1995; Ariola & Felleisen, 1996) as follows: eval z (M ) = B if M 7! fl A and obs (A) = B, where: Answers A ::= V j (x:A) M Evaluation contexts E
Reference: <author> Plotkin, Gordon D. </author> <year> (1977). </year> <title> LCF considered as a programming language. </title> <journal> Theoretical Computer Science, </journal> <volume> 5, </volume> <pages> 223-255. </pages>
Reference-contexts: First, we assume that a language is functional (pure or not) if it includes the simply typed -calculus. Second, we assume that the following three languages are purely functional: the language fl that extends the call-by-name -calculus with numbers and addition, and the languages PCF and PPCF <ref> (Plotkin, 1977) </ref>. These assumptions may be challenged but they appear to be consistent with the informal practice. <p> It is possible to break some observational equivalences of a purely functional language by extending it with a pure but non-expressible (Felleisen, 1991) construct. The standard illustration of this situation are the two purely functional languages PCF and PPCF <ref> (Plotkin, 1977) </ref>. The language PCF extends the simply typed -calculus with constants for expressing recursion, conditionals, and operations on the natural numbers. The language PPCF extends PCF with a parallel (but deterministic) operator por. <p> the PCF terms M (1) and M (2) where is a canonical diverging term: M (u) = f:if (f True ) (if (f True) (if (f False False) u) ) It is a standard result that M (1) and M (2) are observationally equivalent in PCF but not in PPCF <ref> (Plotkin, 1977) </ref>. The way to distinguish the terms in PPCF is to apply them to por. The latter construct bypasses the first two conditional tests as it returns True if either of its arguments is True even if the other argument diverges. This result motivates the following statement.
Reference: <author> Reynolds, John C. </author> <year> (1972). </year> <title> Definitional interpreters for higher-order programming languages. </title> <booktitle> Pages 717-740 of: Proceedings of the ACM annual conference. </booktitle>
Reference: <author> Reynolds, John C. </author> <year> (1981). </year> <title> The essence of Algol. Pages 345-372 of: </title> <editor> de Bakker, & van Vliet (eds), </editor> <booktitle> Algorithmic languages. </booktitle> <address> Amsterdam: </address> <publisher> North-Holland. </publisher>
Reference: <author> Reynolds, John C. </author> <year> (1988). </year> <title> Preliminary design of the programming language Forsythe. </title> <type> Tech. </type> <institution> rept. CMU-CS-88-159. Carnegie Mellon University. </institution>
Reference: <author> Reynolds, John C. </author> <year> (1991). </year> <title> Replacing complexity with generality: The programming language Forsythe. </title> <type> Unpublished manuscript, </type> <institution> Carnegie Mellon University. </institution>
Reference: <author> Sabry, Amr, & Field, John. </author> <year> (1993). </year> <title> Reasoning about explicit and implicit representations of state. </title> <type> Tech. </type> <address> rept. YALEU/DCS/RR-968. Yale University. </address> <booktitle> ACM SIGPLAN Workshop on State in Programming Languages, </booktitle> <pages> pages 17-30. </pages>
Reference: <author> Stndergaard, H., & Sestoft, P. </author> <year> (1990). </year> <title> Referential transparency, definiteness and unfold-ability. </title> <journal> Acta Informatica, </journal> <volume> 27(6), </volume> <pages> 505-517. </pages>
Reference: <author> Swarup, V., Reddy, Uday, & Ireland, E. </author> <year> (1991). </year> <title> Assignments for applicative languages. </title> <booktitle> Pages 192-214 of: Conference on Functional Programming and Computer Architecture. </booktitle>
Reference-contexts: Even in published papers we find varying statements regarding the definition of purity that refer to notions like the soundness of the fi-axiom (Odersky et al., 1993), referential transparency (Launchbury & Peyton Jones, 1995), the confluence of a calculus for the language <ref> (Swarup et al., 1991) </ref>, the preservation of pure observational equivalences (O'Hearn, 1995), and the independence of order of evaluation (Launchbury & Peyton Jones, 1995). The investigation of a formal definition of purity goes beyond settling some differences in opinion.
Reference: <author> Wadler, Philip. </author> <year> (1990). </year> <title> Comprehending monads. </title> <booktitle> Pages 61-78 of: ACM conference on Lisp and Functional Programming. </booktitle>
Reference: <author> Weeks, Stephen, & Felleisen, Matthias. </author> <year> (1993). </year> <title> On the orthogonality of assignments and procedures in Algol. </title> <booktitle> Pages 57-70 of: ACM Symposium on Principles of Programming Languages. </booktitle>
Reference-contexts: The only catch is that the imperative program resulting from an Idealized Algol program may be infinite, so this view is only conceptual <ref> (Weeks & Felleisen, 1993) </ref>. In practice the two evaluators would be implemented as coroutines.
References-found: 27

