URL: http://c.gp.cs.cmu.edu:5103/afs/cs.cmu.edu/Web/People/rwh/papers/ttisml/ttisml.ps
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs.cmu.edu/Web/People/rwh/papers.html
Root-URL: http://www.cs.cmu.edu
Email: frwh,cstoneg@cs.cmu.edu  
Title: A Type-Theoretic Interpretation of Standard ML  
Author: Robert Harper and Christopher Stone 
Address: 5000 Forbes Avenue Pittsburgh, PA 15213-3891  
Affiliation: School of Computer Science Carnegie Mellon University  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Andrew W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: Named form and component renaming ensures that the exact behavior of all (first-order) functors is always expressible in the internal-language signature of the translated functor. Note that the simple renaming mechanism we have outlined here is not "safe for space complexity" <ref> [1] </ref>. In particular, the elaboration given here retains not only the hidden type components that are required for subsequent specifications, but also type components that are not so required, and value components, which are never required.
Reference: [2] <author> Luca Cardelli. </author> <title> Typeful programming. </title> <editor> In E. J. Neuhold and M. Paul, editors, </editor> <booktitle> Formal Description of Programming Concepts. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Consequently, no management of stamps is required at run-time. Much recent research on both the metatheory and implementation of programming languages is based on an explicitly-typed interpretation in which the dynamic semantics is defined on typed, rather than type-erased, programs <ref> [28, 2] </ref>. From a semantic viewpoint programs are seen as intrinsically typed, and hence fundamental relations such as operational equivalence are defined so as to limit the set of observations to those that make type sense. <p> This is used to express the propagation of type sharing properties from the argument to the result, without relying on exposure of the implementation of the functor. The sub-signature relation is extended to functor signatures in the usual way, contravariantly in the domain and covariantly in the codomain <ref> [2] </ref>. Only non-dependent functors may be applied to arguments; the dependency must first be eliminated through the use of the sub-signature and signature equivalence relations.
Reference: [3] <author> Luca Cardelli. </author> <title> Type systems. </title> <editor> In Allen B. Tucker Jr., editor, </editor> <booktitle> Handbook of Computer Science and Engineering, </booktitle> <pages> pages 2208-2236. </pages> <publisher> CRC Press, </publisher> <year> 1997. </year>
Reference-contexts: DAAH04-94-G-0289. The views and conclusions contained in this document are those of the authors and should not be interpreted as representing official policies, either expressed or implied, of the Advanced Research Projects Agency, the U.S. Government or the National Science Foundation. 1 See Cardelli's overview of type systems <ref> [3] </ref> for a comprehensive survey and references to the literature. 1 untyped interpretation is a special case of the typed interpretation in which we consider only one (typically recursive) type. Thus there is no loss of generality in considering the explicitly-typed case.
Reference: [4] <author> Jean-Yves Girard. </author> <title> Une extension de l'interpretation de Godel a l'analyse, et son application a l'elimination des coupures dans l'analyse et la theorie des types. </title> <editor> In Jens Erik Fenstad, editor, </editor> <booktitle> Second Scandinavian Logic Symposium, volume 63 of Studies in Logic and the Foundations of Mathematics, </booktitle> <pages> pages 63-92. </pages> <publisher> North-Holland, </publisher> <year> 1971. </year>
Reference-contexts: However, we do not treat type abstraction and application as a primitive notion (as in the polymorphic -calculus <ref> [4, 24] </ref>). Instead, we represent a polymorphic value as an internal-language functor abstracted on a structure whose components are types, yielding a structure with a single component labeled "it" for the value itself.
Reference: [5] <author> Michael J. Gordon, Robin Milner, and Christo-pher P. Wadsworth. </author> <title> Edinburgh LCF: </title> <journal> a mech-anised logic of computation, </journal> <volume> volume LNCS 78. </volume> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: 1 Introduction It has been nearly twenty years since Robin Milner introduced ML as the metalanguage of the LCF interactive theorem prover <ref> [5] </ref>.
Reference: [6] <editor> Carl A. Gunter, Elsa L. Gunter, and David B. MacQueen. </editor> <title> An abstract interpretation for ML equality kinds. </title> <publisher> LNCS 526, </publisher> <pages> pages 112-130, </pages> <year> 1991. </year>
Reference-contexts: Our approach is related to the compilation of overloading in Haskell [30] and to the treatment of equality proposed by Gunter, Gunter and MacQueen <ref> [6] </ref>. The judgment ` eq con ; exp v expresses that ` exp v : conficon*Bool is the equality function for type con.
Reference: [7] <author> Robert Harper. </author> <title> A simplified account of polymorphic references. </title> <type> Technical Report CMU-CS-93-169, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <year> 1993. </year>
Reference-contexts: If decs ` E [mod ] : con and mod is closed, then decs ` mod : sig for some signature sig . Furthermore, if decs ` mod 0 : sig where mod 0 is closed, then decs ` E [mod 0 ] : con. Following Harper <ref> [7] </ref> and Wright and Felleisen [32], we say that a store is well-formed with respect to a context , written ` , if 8loc 2 BV (); if ` loc : con Ref then ` (x) : con: This formulation of store typing avoids the need for complex maximal fixed point
Reference: [8] <author> Robert Harper and Mark Lillibridge. </author> <title> A type-theoretic approach to higher-order modules with sharing. </title> <booktitle> In 21st ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 123-137, </pages> <year> 1994. </year>
Reference-contexts: The internal language is derived from the XML language of Harper and Mitchell [9], but with a richer collection of primitive types and a more expressive module system based on the translucent sum <ref> [8] </ref>, or manifest type [13], formalism. The internal language is given a type-passing dynamic semantics in the form of a transition system between states of an abstract machine. <p> The two levels are linked by the ability to declare a module within a core-level expression. The internal language is based loosely on Harper and Mitchell's XML language [9], but with a treatment of modules derived from Harper and Lillibridge's <ref> [8, 15] </ref> translucent sum formalism and Leroy's manifest type system [13]. This section consists of a brief overview of the internal language. The language is defined by a set of inference rules for deriving the judgment forms given in Figure 1. <p> This is exploited heavily in the interpretation of Standard ML given in Section 3. 2.3 Modules and Signatures The module language is based on the translucent sum (or manifest type) formalism <ref> [8, 13] </ref>. The syntax for modules and signatures is given in Figure 4. The basic form of module is a structure, which consists of a sequence of constructor, expression, and module bindings. Structure signatures consist of a corresponding sequence of constructor, expression, and module declarations.
Reference: [9] <author> Robert Harper and John C. Mitchell. </author> <title> On the type structure of Standard ML. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(2) </volume> <pages> 211-252, </pages> <year> 1993. </year>
Reference-contexts: The external language considered here is the 1997 dialect of Standard ML, as described in the revised Definition [18]. The internal language is derived from the XML language of Harper and Mitchell <ref> [9] </ref>, but with a richer collection of primitive types and a more expressive module system based on the translucent sum [8], or manifest type [13], formalism. The internal language is given a type-passing dynamic semantics in the form of a transition system between states of an abstract machine. <p> The two levels are linked by the ability to declare a module within a core-level expression. The internal language is based loosely on Harper and Mitchell's XML language <ref> [9] </ref>, but with a treatment of modules derived from Harper and Lillibridge's [8, 15] translucent sum formalism and Leroy's manifest type system [13]. This section consists of a brief overview of the internal language. <p> To account for shadowing, declaration sequencing goes beyond simple concatenation of bindings by renaming fields corresponding to shadowed identifiers. 3.3 Polymorphism Polymorphism is interpreted by explicit type abstraction and type application <ref> [9] </ref>. However, we do not treat type abstraction and application as a primitive notion (as in the polymorphic -calculus [4, 24]).
Reference: [10] <author> Robert Harper and Greg Morrisett. </author> <title> Compiling polymorphism using intensional type analysis. </title> <booktitle> In 22nd ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 130-141, </pages> <year> 1995. </year>
Reference-contexts: Factoring out such substitutions separately simplifies the dynamic semantics, but is not critical to the framework. 8 We have given a high-level operational semantics in that types are propagated, but never normalized or examined at run-time. To describe primitives which do intensional type analysis <ref> [10] </ref> we could refine the semantics to perform normalization computations at the constructor level as well. 2.5 Properties of the Internal Language In order to relate the static and dynamic semantics, we must first state some technical properties of the operational semantics.
Reference: [11] <author> Robert Harper and Christopher Stone. </author> <title> An interpretation of Standard ML in type theory. </title> <type> Technical Report CMU-CS-97-147, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <year> 1997. </year>
Reference-contexts: The language is defined by a set of inference rules for deriving the judgment forms given in Figure 1. A selection of the rules is given in Appendix B; the remainder can be found in a companion technical report <ref> [11] </ref>. For further background and motivation the reader is urged to consult the references cited above. 2.1 Constructors and Kinds The syntax of constructors and kinds is given in Figure 2. Kinds classify constructors. Constructors of kind are called types. <p> A fully detailed account of the interpretation appears in a companion technical report <ref> [11] </ref>. The complete interpretation consists of approximately 270 inference rules, of which approximately 140 form the typing rules and dynamic semantics of the internal language (120 rules and 20 rules, respectively), with the remaining 130 rules being the interpretation itself.
Reference: [12] <author> Xavier Leroy. </author> <title> Polymorphism by name for references and continuations. </title> <booktitle> In 20th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 220-231, </pages> <year> 1993. </year>
Reference-contexts: Valuability of core- and module-level expressions is expressed by a judgment form expressing that the given expression may be evaluated without engendering any computational effect. For decidability reasons, the rules define a conservative approximation of valua-bility. The approximation is strong enough to express the "value restriction" on polymorphism <ref> [31, 12] </ref> in Standard ML, as discussed in Section 3.
Reference: [13] <author> Xavier Leroy. </author> <title> Manifest types, modules, and separate compilation. </title> <booktitle> In 21st ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 109-122, </pages> <year> 1994. </year>
Reference-contexts: The internal language is derived from the XML language of Harper and Mitchell [9], but with a richer collection of primitive types and a more expressive module system based on the translucent sum [8], or manifest type <ref> [13] </ref>, formalism. The internal language is given a type-passing dynamic semantics in the form of a transition system between states of an abstract machine. <p> The internal language is based loosely on Harper and Mitchell's XML language [9], but with a treatment of modules derived from Harper and Lillibridge's [8, 15] translucent sum formalism and Leroy's manifest type system <ref> [13] </ref>. This section consists of a brief overview of the internal language. The language is defined by a set of inference rules for deriving the judgment forms given in Figure 1. <p> This is exploited heavily in the interpretation of Standard ML given in Section 3. 2.3 Modules and Signatures The module language is based on the translucent sum (or manifest type) formalism <ref> [8, 13] </ref>. The syntax for modules and signatures is given in Figure 4. The basic form of module is a structure, which consists of a sequence of constructor, expression, and module bindings. Structure signatures consist of a corresponding sequence of constructor, expression, and module declarations.
Reference: [14] <author> Xavier Leroy. </author> <title> A syntactic theory of type gener-ativity and sharing. </title> <journal> Journal of Functional Programming, </journal> <volume> 6(5) </volume> <pages> 667-698, </pages> <year> 1996. </year>
Reference-contexts: Since we are working with an explicitly-typed internal language, polymorphic instantiation in signature matching is also managed by explicit coercion. 6. Sharing expansion. Uses of type sharing specifications are expanded into uses of type definitions in signatures <ref> [14] </ref>. The where type construct of Standard ML is translated by explicitly "patching" internal-language signatures. 7. Generativity and persistence. In Standard ML type identifiers may persist beyond their apparent scope of definition. <p> Datatype generativity interacts with functor instantiation in such a way that each application of a functor that declares a datatype introduces a "new copy" of that datatype, distinct from all other instances introduced by the same functor (and all types otherwise introduced). Following Leroy <ref> [14] </ref> we capture this behavior by imposing the requirement that module expressions be restricted to "named form". This means that every non-trivial module expression must be bound to a module identifier before it can be used. <p> This restriction is reflected in the grammar by, e.g., the requirement that functor arguments be structure identifiers, rather than arbitrary structure expressions. There is no loss of generality in assuming that programs are written in named form; we can make a prepass introduces bindings for non-trivial module expression <ref> [14] </ref>. The practical effect of the restriction to named form is that the result of every functor application is bound to module variable, which thereafter serves as the "unique name" of that instance of the functor application. Consequently, opaque types (including datatypes) selected from that instance are unique.
Reference: [15] <author> Mark Lillibridge. </author> <title> Translucent Sums: A Foundation for Higher-Order Module Systems. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mel-lon University, </institution> <year> 1997. </year> <month> 19 </month>
Reference-contexts: The two levels are linked by the ability to declare a module within a core-level expression. The internal language is based loosely on Harper and Mitchell's XML language [9], but with a treatment of modules derived from Harper and Lillibridge's <ref> [8, 15] </ref> translucent sum formalism and Leroy's manifest type system [13]. This section consists of a brief overview of the internal language. The language is defined by a set of inference rules for deriving the judgment forms given in Figure 1.
Reference: [16] <author> David MacQueen. </author> <title> Using dependent types to ex-press modular structure. </title> <booktitle> In 13th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 277-286, </pages> <year> 1986. </year>
Reference-contexts: Translucent sums may be seen as a generalized form of existential type [19] that affords fine-grained control over the "degree" of abstractness of a type. They may also be seen as a variant of the "dependent sum" type <ref> [16] </ref>, adopting the flexible "projection" notation for component selection, but avoiding implementation dependencies. Structure signatures consist of a sequence of constructor, value, and module declarations. Constructor declarations may either be opaque (specifying only a kind) or transparent (specifying the identity of the constructor).
Reference: [17] <author> Robin Milner. </author> <title> A proposal for Standard ML. </title> <booktitle> In 1984 ACM Symposium on LISP and Functional Programming, </booktitle> <pages> pages 184-197, </pages> <year> 1984. </year>
Reference-contexts: As an implementation tool type theory provides a framework for structuring compilers and supports the use of efficient data representations even in the presence of polymorphism [28, 27]. Milner's work on ML culminated in his ambitious proposal for Standard ML <ref> [17] </ref> that sought to extend ML to a full-scale programming language supporting functional and imperative programming and an expressive module system. Standard ML presented a serious challenge to rigorous formalization of its static and dynamic semantics.
Reference: [18] <author> Robin Milner, Mads Tofte, Robert Harper, and Dave MacQueen. </author> <title> The Definition of Standard ML (Revised). </title> <publisher> MIT Press, </publisher> <year> 1997. </year>
Reference-contexts: The target of the translation we call the internal language, or IL; the source language is then called the external language, or EL. The external language considered here is the 1997 dialect of Standard ML, as described in the revised Definition <ref> [18] </ref>. The internal language is derived from the XML language of Harper and Mitchell [9], but with a richer collection of primitive types and a more expressive module system based on the translucent sum [8], or manifest type [13], formalism.
Reference: [19] <author> John C. Mitchell and Gordon Plotkin. </author> <title> Abstract types have existential type. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 10(3) </volume> <pages> 470-502, </pages> <year> 1988. </year>
Reference-contexts: Propagation of type sharing information is managed by the selective exposure of type information in a signature through the use of transparent and opaque type specifications. Translucent sums may be seen as a generalized form of existential type <ref> [19] </ref> that affords fine-grained control over the "degree" of abstractness of a type. They may also be seen as a variant of the "dependent sum" type [16], adopting the flexible "projection" notation for component selection, but avoiding implementation dependencies.
Reference: [20] <author> Eugenio Moggi. </author> <title> Notions of computation and monads. </title> <journal> Information and Computation, </journal> <volume> 93(1) </volume> <pages> 55-92, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: There is no subtyping at the core level, which is consistent with the lack of subtyping in the SML core language. Most of the type constructors are relatively standard, except for total function types, tag types, and the type of tagged values. We borrow from the computational -calculus <ref> [20] </ref> an abstract notion of "definedness", called valuability, and the closely-associated notion of "totality" for functions. Valuability of core- and module-level expressions is expressed by a judgment form expressing that the given expression may be evaluated without engendering any computational effect.
Reference: [21] <author> Chris Okasaki. </author> <title> Purely Functional Data Structures. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <year> 1996. </year>
Reference-contexts: More efficient algorithms based on decision tree heuristics are routinely used in Standard ML compilers. We present a "reference" implementation of pattern compilation so as to avoid undue commitments to specific strategies, to admit generalizations of pattern matching that may engender effects (such as forcing memoized suspensions <ref> [21] </ref>), and for the sake of perspicuity of the translation. There is a subtle, but important, interaction between pattern compilation and the value restriction on polymorphism.
Reference: [22] <author> Andrew M. Pitts and Ian D. B. Stark. </author> <title> Observable properties of higher order functions that dynamically create local names, or: </title> <booktitle> What's new? In Mathematical Foundations of Computer Science, 18th International Symposium, volume 711 of LNCS, </booktitle> <pages> pages 122-141. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1993. </year>
Reference-contexts: The internal language type Tagged is a type of dynamically-tagged values, corresponding to the external language type exn. The dynamically-generated tags are similar to the "names" considered by Pitts and Stark <ref> [22] </ref>, except that we associate a type with each name to ensure type safety. Tags of values of type con are themselves values of type con Tag. 2.2 Expressions The syntax of internal language expressions is given in Figure 3.
Reference: [23] <author> Gordon D. Plotkin. </author> <title> A structural approach to operational semantics. </title> <type> Technical Report DAIMI FN-19, </type> <institution> Aarhus University, </institution> <month> September </month> <year> 1981. </year>
Reference-contexts: The presentation is strongly influenced by the work of Plotkin <ref> [23] </ref> and Wright and Felleisen [32], but is departure from the framework of The Definition of Standard ML. The state-machine presentation avoids the need for implicit evaluation rules for handling exceptions, and supports a natural interpretation of type soundness that does not rely on artificial "wrong" transitions.
Reference: [24] <author> John C. Reynolds. </author> <title> Towards a theory of type structure. </title> <editor> In B. Robinet, editor, </editor> <booktitle> Programming Symposium, Proceedings, Colloque sur la Pro-grammation, volume 19 of LNCS, </booktitle> <pages> pages 408-425, </pages> <year> 1974. </year>
Reference-contexts: However, we do not treat type abstraction and application as a primitive notion (as in the polymorphic -calculus <ref> [4, 24] </ref>). Instead, we represent a polymorphic value as an internal-language functor abstracted on a structure whose components are types, yielding a structure with a single component labeled "it" for the value itself.
Reference: [25] <author> Dana S. Scott. </author> <title> Data types as lattices. </title> <journal> SIAM Journal on Computing, </journal> <volume> 5 </volume> <pages> 522-587, </pages> <month> September </month> <year> 1976. </year>
Reference-contexts: From this point of view the internal language plays a role analogous to Scott's LAMBDA language for denotational semantics <ref> [25] </ref>. The meaning of a Standard ML program is defined by interpretation into the internal language, which is given meaning by some other means.
Reference: [26] <author> Zhong Shao. </author> <title> An overview of the FLINT/ML compiler. </title> <booktitle> In 1997 ACM SIGPLAN Workshop on Types in Compilation (TIC'97), </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: The interpretation may also be viewed as a declarative specification of the elaboration rules for type-based compilers for Standard ML such as TIL [28] and SML/NJ <ref> [26] </ref>. The front-end of the TIL compiler is a "determinization" of elaboration rules described below, using standard methods such as unification to defer non-deterministic choices until the context resolves any ambiguity.
Reference: [27] <author> Zhong Shao and Andrew W. Appel. </author> <title> A type-based compiler for Standard ML. </title> <booktitle> In ACM SIG-PLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 116-129, </pages> <year> 1995. </year>
Reference-contexts: As an implementation tool type theory provides a framework for structuring compilers and supports the use of efficient data representations even in the presence of polymorphism <ref> [28, 27] </ref>. Milner's work on ML culminated in his ambitious proposal for Standard ML [17] that sought to extend ML to a full-scale programming language supporting functional and imperative programming and an expressive module system. Standard ML presented a serious challenge to rigorous formalization of its static and dynamic semantics.
Reference: [28] <author> David Tarditi, Greg Morrisett, Perry Cheng, Chris Stone, Robert Harper, and Peter Lee. </author> <title> TIL: A type-directed optimizing compiler for ML. </title> <booktitle> In ACM SIGPLAN '96 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 181-192, </pages> <year> 1996. </year>
Reference-contexts: As an implementation tool type theory provides a framework for structuring compilers and supports the use of efficient data representations even in the presence of polymorphism <ref> [28, 27] </ref>. Milner's work on ML culminated in his ambitious proposal for Standard ML [17] that sought to extend ML to a full-scale programming language supporting functional and imperative programming and an expressive module system. Standard ML presented a serious challenge to rigorous formalization of its static and dynamic semantics. <p> Consequently, no management of stamps is required at run-time. Much recent research on both the metatheory and implementation of programming languages is based on an explicitly-typed interpretation in which the dynamic semantics is defined on typed, rather than type-erased, programs <ref> [28, 2] </ref>. From a semantic viewpoint programs are seen as intrinsically typed, and hence fundamental relations such as operational equivalence are defined so as to limit the set of observations to those that make type sense. <p> The interpretation may also be viewed as a declarative specification of the elaboration rules for type-based compilers for Standard ML such as TIL <ref> [28] </ref> and SML/NJ [26]. The front-end of the TIL compiler is a "determinization" of elaboration rules described below, using standard methods such as unification to defer non-deterministic choices until the context resolves any ambiguity.
Reference: [29] <author> Mads Tofte. </author> <title> Type inference for polymorphic references. </title> <journal> Information and Computation, </journal> <volume> 89(1) </volume> <pages> 1-34, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: Wright and Felleisen [32], we say that a store is well-formed with respect to a context , written ` , if 8loc 2 BV (); if ` loc : con Ref then ` (x) : con: This formulation of store typing avoids the need for complex maximal fixed point constructions <ref> [29] </ref>. Fix a base type ans of answers to which a complete, closed program might evaluate. 2 We say that a machine state is well-formed, written ` (; ; exp); if and only if ` exp : ans, exp has no free (expression, constructor, or module) variables, and ` .
Reference: [30] <author> Philip Wadler and Stephen Blott. </author> <title> How to make ad-hoc polymorphism less ad-hoc. </title> <booktitle> In 16th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 60-76, </pages> <year> 1989. </year>
Reference-contexts: There is no need for separate "equality attributes" in our IL; a type admits equality if and only if the equality compiler is able to generate an equality operation for it. Our approach is related to the compilation of overloading in Haskell <ref> [30] </ref> and to the treatment of equality proposed by Gunter, Gunter and MacQueen [6]. The judgment ` eq con ; exp v expresses that ` exp v : conficon*Bool is the equality function for type con.
Reference: [31] <author> Andrew Wright. </author> <title> Simple imperative polymor-phism. </title> <journal> Journal of Lisp and Symbolic Computation, </journal> <volume> 8(4) </volume> <pages> 343-355, </pages> <month> December </month> <year> 1995. </year>
Reference-contexts: Valuability of core- and module-level expressions is expressed by a judgment form expressing that the given expression may be evaluated without engendering any computational effect. For decidability reasons, the rules define a conservative approximation of valua-bility. The approximation is strong enough to express the "value restriction" on polymorphism <ref> [31, 12] </ref> in Standard ML, as discussed in Section 3.
Reference: [32] <author> Andrew Wright and Matthias Felleisen. </author> <title> A syntactic approach to type soundness. </title> <type> Technical Report TR91-160, </type> <institution> Dept. of Computer Science, Rice University, </institution> <year> 1991. </year> <month> 20 </month>
Reference-contexts: The presentation is strongly influenced by the work of Plotkin [23] and Wright and Felleisen <ref> [32] </ref>, but is departure from the framework of The Definition of Standard ML. The state-machine presentation avoids the need for implicit evaluation rules for handling exceptions, and supports a natural interpretation of type soundness that does not rely on artificial "wrong" transitions. <p> Furthermore, if decs ` mod 0 : sig where mod 0 is closed, then decs ` E [mod 0 ] : con. Following Harper [7] and Wright and Felleisen <ref> [32] </ref>, we say that a store is well-formed with respect to a context , written ` , if 8loc 2 BV (); if ` loc : con Ref then ` (x) : con: This formulation of store typing avoids the need for complex maximal fixed point constructions [29].
References-found: 32

