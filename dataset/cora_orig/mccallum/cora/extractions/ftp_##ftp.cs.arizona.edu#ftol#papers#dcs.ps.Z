URL: ftp://ftp.cs.arizona.edu/ftol/papers/dcs.ps.Z
Refering-URL: http://www.cs.arizona.edu/cactus/public.html
Root-URL: http://www.cs.arizona.edu
Title: Constructing a Configurable Group RPC Service  
Author: Matti A. Hiltunen and Richard D. Schlichting 
Address: Tucson, AZ 85721, USA  
Affiliation: Department of Computer Science University of Arizona  
Abstract: Current Remote Procedure Call (RPC) services implement a variety of semantics, with many of the differences related to how communication and server failures are handled. The list increases even more when considering group RPC, a variant of RPC often used for fault-tolerance where an invocation is sent to a group of servers rather than one. This paper presents an approach to constructing group RPC in which a single configurable system is used to build different variants of the service. The approach is based on implementing each property as a separate software module called a micro-protocol, and then configuring the micro-protocols needed to implement the desired service together using a software framework based on the x-kernel. The properties of point-to-point and group RPC are identified and classified, and the general execution model described. An example consisting of a modular implementation of a group RPC service is given to illustrate the approach. Dependency issues that restrict configurability are also addressed. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Ananda, B. Tay, and E. Koh. </author> <title> ASTRA An asynchronous remote procedure call facility. </title> <booktitle> In Proceedings of the 8th International IEEE Conference on Distributed Computing Systems, </booktitle> <pages> pages 172-179, </pages> <address> Arlington, Texas, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: In the latter case, the RPC system may include another system call that allows the thread to retrieve results later. Although synchronous is most commonly used, a number of systems provide an asynchronous option as well (e.g., <ref> [1] </ref>). * Orphan handling semantics specify how orphans that is, server computations associated with clients that have failed are dealt with. Orphans not only waste computing resources, but may also interfere with new calls issued by a recovered client.
Reference: [2] <author> Apollo Computer Inc. </author> <title> Network computing system (NCS) reference. </title> <type> Technical report, </type> <institution> Apollo Computer Inc., </institution> <year> 1989. </year>
Reference-contexts: Numerous examples of different RPC services and implementations exist, including Firefly RPC [19], Alphorn [3], lightweight RPC [4], and Peregrine [14]. Among the commercial RPC packages released have been Courier from Xerox [24], Sun RPC [22], Netwise RPC from Novell Net-ware, and NCA from Apollo <ref> [2] </ref>. On the surface, the semantics of RPC seem very simple, yet the reality is that there are subtleties and variations. For example, there are many ways to define how an RPC service deals with server and communication failures.
Reference: [3] <author> H.-R. Aschmann, N. Giger, E. Hoepli, P. Janak, and H. Kir-rmann. Alphorn: </author> <title> A remote procedure call environment for fault-tolerant, heterogeneous, </title> <journal> distributed systems. IEEE Micro, </journal> <volume> 11(5) 16-19,60-67, </volume> <month> Oct </month> <year> 1991. </year>
Reference-contexts: With RPC, a request for service from a client to a server process is structured to give synchronization semantics at the client similar to normal procedure call. Numerous examples of different RPC services and implementations exist, including Firefly RPC [19], Alphorn <ref> [3] </ref>, lightweight RPC [4], and Peregrine [14]. Among the commercial RPC packages released have been Courier from Xerox [24], Sun RPC [22], Netwise RPC from Novell Net-ware, and NCA from Apollo [2].
Reference: [4] <author> B. Bershad, T. Anderson, E. Lazokska, and H. Levy. </author> <title> Lightweight remote procedure call. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1) </volume> <pages> 37-55, </pages> <month> Feb </month> <year> 1990. </year>
Reference-contexts: With RPC, a request for service from a client to a server process is structured to give synchronization semantics at the client similar to normal procedure call. Numerous examples of different RPC services and implementations exist, including Firefly RPC [19], Alphorn [3], lightweight RPC <ref> [4] </ref>, and Peregrine [14]. Among the commercial RPC packages released have been Courier from Xerox [24], Sun RPC [22], Netwise RPC from Novell Net-ware, and NCA from Apollo [2]. On the surface, the semantics of RPC seem very simple, yet the reality is that there are subtleties and variations.
Reference: [5] <author> N. T. Bhatti and R. D. Schlichting. </author> <title> A system for constructing configurable high-level protocols. </title> <type> Technical report, </type> <institution> Department of Computer Science, University of Arizona, </institution> <address> Tucson, AZ, </address> <year> 1995. </year>
Reference-contexts: They then select the desired variant of each type. For example, they might select at least once semantics to deal with failures [21] and orphan termination to deal with orphaned computations [20]. Finally, software modules called micro-protocols <ref> [5, 9] </ref>, each of which implements a single selected property, are configured together using a software framework based on the x-kernel [12]. The approach assumes an asynchronous distributed system, where the underlying communication system can experience both omission and performance failures, and where sites can experience crash failures. <p> total ordering, every server must receive the same set of messages, i.e., the reliability property must hold. 3 Micro-protocols and event-driven execu tion A configurable RPC system based on the above properties is realized using a model for composing fine-grained software modules [9] and its associated x-kernel based implementation platform <ref> [5] </ref>. The basic building block of this model is a micro-protocol, a software module that implements a well-defined property of the desired service. A micro-protocol, in turn, is structured as a collection of event handlers, which are procedure-like segments of code that are invoked when an event occurs. <p> A prototype implementation of a runtime framework supporting this style of protocol construction has recently been completed <ref> [5] </ref>. The prototype executes on DecSta-tion 5000/240s running the Mach operating system, and is based on extending the hierarchical model of the x-kernel to support composite protocols.
Reference: [6] <author> A. D. Birrell and B. J. Nelson. </author> <title> Implementing remote procedure calls. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(1) </volume> <pages> 39-59, </pages> <month> Feb </month> <year> 1984. </year>
Reference-contexts: 1 Introduction Remote Procedure Call (RPC) <ref> [6, 17] </ref> is a communication abstraction designed to simplify the writing of distributed programs. With RPC, a request for service from a client to a server process is structured to give synchronization semantics at the client similar to normal procedure call. <p> It is also easy to configure RPC services that realize the same set of properties as existing services. For example, <ref> [6] </ref> corresponds to a service configured with RPC Main, Synchronous Call, Acceptance with acceptance limit one, Collation with an identity function as the cumulative function, Reliable Communication, and Unique Execution. Rajdoot [18] corresponds to the same set, plus Bounded Termination and Terminate Orphans.
Reference: [7] <author> R. Cmelik, N. Gehani, and W. D. Roome. </author> <title> Fault Tolerant Concurrent C: A tool for writing fault tolerant distributed programs. </title> <booktitle> In Proceedings of the Eighteenth International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 55-61, </pages> <address> Tokyo, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: Group RPC has numerous applications. For example, it can be used to implement replicated servers to increase availability of the service in the event of failures, to implement parallel computation, or to improve response time. Examples of group or multicast RPC include <ref> [7, 8, 23, 25] </ref>. For brevity, in this paper we consider only one-to-many group RPC, in which one client uses RPC to invoke a procedure implemented by a server group.
Reference: [8] <author> E. C. Cooper. </author> <title> Replicated distributed programs. </title> <booktitle> In Proceedings of the Tenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 63-78, </pages> <address> Orcas Island, WA, </address> <year> 1985. </year>
Reference-contexts: Group RPC has numerous applications. For example, it can be used to implement replicated servers to increase availability of the service in the event of failures, to implement parallel computation, or to improve response time. Examples of group or multicast RPC include <ref> [7, 8, 23, 25] </ref>. For brevity, in this paper we consider only one-to-many group RPC, in which one client uses RPC to invoke a procedure implemented by a server group. <p> Rajdoot [18] corresponds to the same set, plus Bounded Termination and Terminate Orphans. Among group RPC services, the one-to-many RPC described in <ref> [8] </ref> corresponds to the set RPC Main, Synchronous Call, Acceptance with limit equal to the size of the server group, Collation with cumulative function consisting of identity and comparison to detect inconsistencies at the server processes, Reliable Communication, Unique Execution, and Total Order.
Reference: [9] <author> M. A. Hiltunen and R. D. Schlichting. </author> <title> An approach to constructing modular fault-tolerant protocols. </title> <booktitle> In Proceedingsof the 12th IEEE Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 105-114, </pages> <address> Princeton, NJ, USA, </address> <month> Oct </month> <year> 1993. </year>
Reference-contexts: They then select the desired variant of each type. For example, they might select at least once semantics to deal with failures [21] and orphan termination to deal with orphaned computations [20]. Finally, software modules called micro-protocols <ref> [5, 9] </ref>, each of which implements a single selected property, are configured together using a software framework based on the x-kernel [12]. The approach assumes an asynchronous distributed system, where the underlying communication system can experience both omission and performance failures, and where sites can experience crash failures. <p> For example, to implement FIFO or total ordering, every server must receive the same set of messages, i.e., the reliability property must hold. 3 Micro-protocols and event-driven execu tion A configurable RPC system based on the above properties is realized using a model for composing fine-grained software modules <ref> [9] </ref> and its associated x-kernel based implementation platform [5]. The basic building block of this model is a micro-protocol, a software module that implements a well-defined property of the desired service.
Reference: [10] <author> M. A. Hiltunen and R. D. Schlichting. </author> <title> Constructing a configurable group RPC service. </title> <type> Technical Report 94-28, </type> <institution> Department of Computer Science, University of Arizona, </institution> <address> Tucson, AZ, </address> <month> Oct </month> <year> 1994. </year>
Reference-contexts: All major micro-protocols are described, with pseudo-code for several shorter micro-protocols given to illustrate the programming style. Detailed pseudo-code for all micro-protocols can be found in <ref> [10] </ref>. For brevity, the focus here is on group RPC. Point-to-point RPC can be seen as a special case in this implementation, although in practice it would likely be implemented separately to obtain a more compact and efficient protocol.
Reference: [11] <author> Y.-M. Huang and C. Ravishankar. </author> <title> Designing an agent synthesis system for cross-RPC communication. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 19(3) </volume> <pages> 188-198, </pages> <month> Mar </month> <year> 1994. </year>
Reference-contexts: In contrast with our emphasis on modularizing along the lines of abstract properties, however, that paper describes a more syntactic scheme based on functional components of an RPC service implementing one chosen semantics. The work on an agent-synthesis system for Cross-RPC communication in <ref> [11] </ref> is relatively closely related to our goals. Although the primary goal in [11] is to allow heterogeneous RPC systems to communicate with one another, the system also offers the possibility for designing and pro-totyping new variants of RPC. <p> The work on an agent-synthesis system for Cross-RPC communication in <ref> [11] </ref> is relatively closely related to our goals. Although the primary goal in [11] is to allow heterogeneous RPC systems to communicate with one another, the system also offers the possibility for designing and pro-totyping new variants of RPC.
Reference: [12] <author> N. C. Hutchinson and L. L. Peterson. </author> <title> The x-kernel: An architecture for implementing network protocols. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(1) </volume> <pages> 64-76, </pages> <month> Jan </month> <year> 1991. </year>
Reference-contexts: For example, they might select at least once semantics to deal with failures [21] and orphan termination to deal with orphaned computations [20]. Finally, software modules called micro-protocols [5, 9], each of which implements a single selected property, are configured together using a software framework based on the x-kernel <ref> [12] </ref>. The approach assumes an asynchronous distributed system, where the underlying communication system can experience both omission and performance failures, and where sites can experience crash failures.
Reference: [13] <author> N. C. Hutchinson, L. L. Peterson, S. O'Malley, and M. Ab-bott. </author> <title> RPC in the x-kernel: Evaluating new design techniques. </title> <booktitle> In Proceedings of the Twelfth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 91-101, </pages> <address> Litchfield Park, AZ, </address> <month> Dec </month> <year> 1989. </year>
Reference-contexts: All this derives from our experience with the Consul system, which suggests that current techniques are inadequate for supporting modularity in the type of complex protocols often found in fault-tolerant distributed systems [16]. Other researchers have also proposed modular implementations of RPC. For example, in <ref> [13] </ref> a modularization technique also based on the x-kernel is described. In contrast with our emphasis on modularizing along the lines of abstract properties, however, that paper describes a more syntactic scheme based on functional components of an RPC service implementing one chosen semantics.
Reference: [14] <author> D. Johnson and W. Zwaenepoel. </author> <title> The Peregrine high-performance RPC system. </title> <journal> Software Practice & Experience, </journal> <volume> 23(2) </volume> <pages> 201-222, </pages> <year> 1993. </year>
Reference-contexts: With RPC, a request for service from a client to a server process is structured to give synchronization semantics at the client similar to normal procedure call. Numerous examples of different RPC services and implementations exist, including Firefly RPC [19], Alphorn [3], lightweight RPC [4], and Peregrine <ref> [14] </ref>. Among the commercial RPC packages released have been Courier from Xerox [24], Sun RPC [22], Netwise RPC from Novell Net-ware, and NCA from Apollo [2]. On the surface, the semantics of RPC seem very simple, yet the reality is that there are subtleties and variations.
Reference: [15] <author> B. Liskov and R. W. Scheifler. </author> <title> Guardians and actions: Linguistic support for robust distributed programs. </title> <journal> ACM Transactions on ProgrammingLanguages and Systems, </journal> <volume> 5(3) </volume> <pages> 381-404, </pages> <month> Jul </month> <year> 1983. </year>
Reference-contexts: At most once is the same as exactly once if the invocation terminates normally, while if the invocation terminates abnormally, the execution of the remote procedure is guaranteed to be atomic, i.e., either executed completely or not at all <ref> [15] </ref>. In our classification, each of these semantics can be realized as some combination of the unique and atomic execution properties, as illustrated in Figure 1. Unique exec. Atom. proc. exec.
Reference: [16] <author> S. Mishra, L. L. Peterson, and R. D. Schlichting. </author> <title> Experience with modularity in Consul. </title> <journal> Software Practice & Experience, </journal> <volume> 23(10) </volume> <pages> 1059-1075, </pages> <month> Oct </month> <year> 1993. </year>
Reference-contexts: All this derives from our experience with the Consul system, which suggests that current techniques are inadequate for supporting modularity in the type of complex protocols often found in fault-tolerant distributed systems <ref> [16] </ref>. Other researchers have also proposed modular implementations of RPC. For example, in [13] a modularization technique also based on the x-kernel is described.
Reference: [17] <author> B. Nelson. </author> <title> Remote Procedure Call. </title> <type> PhD thesis, </type> <institution> Dept of Computer Science, Carnegie-Mellon University, </institution> <address> Pittsburgh, PA, </address> <year> 1981. </year>
Reference-contexts: 1 Introduction Remote Procedure Call (RPC) <ref> [6, 17] </ref> is a communication abstraction designed to simplify the writing of distributed programs. With RPC, a request for service from a client to a server process is structured to give synchronization semantics at the client similar to normal procedure call.
Reference: [18] <author> F. Panzieri and S. K. Shrivastava. Rajdoot: </author> <title> A remote procedure call mechanism supporting orphan detection and killing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-14(1):30-37, </volume> <month> Jan </month> <year> 1988. </year>
Reference-contexts: Options for dealing with orphans include interference avoidance, where the orphans finish their computation before the recovered client is allowed to issue new requests, and orphan termination, where orphans are terminated upon detection <ref> [18, 20] </ref>. * Communication semantics specify properties about the communication between the client and server. Here, we concentrate on reliable communication, which can be implemented by message acknowledge-ments and retransmissions. <p> If the server has not responded by the deadline, the call returns with an indication of failure. We point out that our classification of failure semantics subsumes more traditional distinctions, which can be summarized as follows <ref> [18] </ref>. At least once guarantees that if the invocation terminates normally, the remote procedure has been executed one or more times, and if it terminates abnormally, no conclusion is possible [21]. <p> For example, [6] corresponds to a service configured with RPC Main, Synchronous Call, Acceptance with acceptance limit one, Collation with an identity function as the cumulative function, Reliable Communication, and Unique Execution. Rajdoot <ref> [18] </ref> corresponds to the same set, plus Bounded Termination and Terminate Orphans.
Reference: [19] <author> M. Schroeder and M. Burrows. </author> <title> Performance of Firefly RPC. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1) </volume> <pages> 1-17, </pages> <month> Feb </month> <year> 1990. </year>
Reference-contexts: With RPC, a request for service from a client to a server process is structured to give synchronization semantics at the client similar to normal procedure call. Numerous examples of different RPC services and implementations exist, including Firefly RPC <ref> [19] </ref>, Alphorn [3], lightweight RPC [4], and Peregrine [14]. Among the commercial RPC packages released have been Courier from Xerox [24], Sun RPC [22], Netwise RPC from Novell Net-ware, and NCA from Apollo [2].
Reference: [20] <author> S. K. Shrivastava. </author> <title> On the treatment of orphans in a distributed system. </title> <booktitle> In Proceedings of Third Symposium on Reliability in Distributed Software and Database Systems, </booktitle> <pages> pages 155-162, </pages> <address> Florida, </address> <month> Oct </month> <year> 1983. </year>
Reference-contexts: They then select the desired variant of each type. For example, they might select at least once semantics to deal with failures [21] and orphan termination to deal with orphaned computations <ref> [20] </ref>. Finally, software modules called micro-protocols [5, 9], each of which implements a single selected property, are configured together using a software framework based on the x-kernel [12]. <p> Options for dealing with orphans include interference avoidance, where the orphans finish their computation before the recovered client is allowed to issue new requests, and orphan termination, where orphans are terminated upon detection <ref> [18, 20] </ref>. * Communication semantics specify properties about the communication between the client and server. Here, we concentrate on reliable communication, which can be implemented by message acknowledge-ments and retransmissions.
Reference: [21] <author> A. Z. Spector. </author> <title> Performing remote operations efficiently on a local computer network. </title> <journal> Communications of the ACM, </journal> <volume> 25(17) </volume> <pages> 246-260, </pages> <month> Apr </month> <year> 1982. </year>
Reference-contexts: In our approach, users begin by analyzing the requirements of the application with respect to the different types of properties realized by RPC. They then select the desired variant of each type. For example, they might select at least once semantics to deal with failures <ref> [21] </ref> and orphan termination to deal with orphaned computations [20]. Finally, software modules called micro-protocols [5, 9], each of which implements a single selected property, are configured together using a software framework based on the x-kernel [12]. <p> We point out that our classification of failure semantics subsumes more traditional distinctions, which can be summarized as follows [18]. At least once guarantees that if the invocation terminates normally, the remote procedure has been executed one or more times, and if it terminates abnormally, no conclusion is possible <ref> [21] </ref>. Exactly once guarantees that if the invocation terminates normally, the remote procedure has been executed exactly one time, and if it terminates abnormally, no conclusion is possible other than that it has not been executed more than once.
Reference: [22] <author> Sun Microsystems. </author> <title> RPC: Remote procedure call protocol specification. </title> <type> Technical Report RFC-1057, </type> <institution> Sun Microsys-tems, </institution> <month> Jun </month> <year> 1988. </year>
Reference-contexts: Numerous examples of different RPC services and implementations exist, including Firefly RPC [19], Alphorn [3], lightweight RPC [4], and Peregrine [14]. Among the commercial RPC packages released have been Courier from Xerox [24], Sun RPC <ref> [22] </ref>, Netwise RPC from Novell Net-ware, and NCA from Apollo [2]. On the surface, the semantics of RPC seem very simple, yet the reality is that there are subtleties and variations. For example, there are many ways to define how an RPC service deals with server and communication failures.
Reference: [23] <author> X. Wang, H. Zhao, and J. Zhu. GRPC: </author> <title> A communication cooperation mechanism in distributed systems. </title> <journal> Operating Systems Review, </journal> <volume> 27(3) </volume> <pages> 75-86, </pages> <month> Jul </month> <year> 1993. </year>
Reference-contexts: Group RPC has numerous applications. For example, it can be used to implement replicated servers to increase availability of the service in the event of failures, to implement parallel computation, or to improve response time. Examples of group or multicast RPC include <ref> [7, 8, 23, 25] </ref>. For brevity, in this paper we consider only one-to-many group RPC, in which one client uses RPC to invoke a procedure implemented by a server group. <p> As an example of a very simple group RPC, lookup RPC <ref> [23] </ref> corresponds to RPC Main, Synchronous Call, Acceptance with limit one, and Collation with identity. Also, note that the dependency graph given here does not map directly to the dependency graph of the properties given in Figure 2.
Reference: [24] <author> Xerox. Courier: </author> <title> The remote procedure call protocol. </title> <type> Technical Report XSIS 038112, </type> <institution> Xerox System Integration Standard, Stamford, CT, </institution> <month> Dec </month> <year> 1981. </year>
Reference-contexts: Numerous examples of different RPC services and implementations exist, including Firefly RPC [19], Alphorn [3], lightweight RPC [4], and Peregrine [14]. Among the commercial RPC packages released have been Courier from Xerox <ref> [24] </ref>, Sun RPC [22], Netwise RPC from Novell Net-ware, and NCA from Apollo [2]. On the surface, the semantics of RPC seem very simple, yet the reality is that there are subtleties and variations.
Reference: [25] <author> K. Yap, P. Jalote, and S. Tripathi. </author> <title> Fault tolerant remote procedure call. </title> <booktitle> In Proceedings of the 8th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 48-54, </pages> <month> Jun </month> <year> 1988. </year>
Reference-contexts: Group RPC has numerous applications. For example, it can be used to implement replicated servers to increase availability of the service in the event of failures, to implement parallel computation, or to improve response time. Examples of group or multicast RPC include <ref> [7, 8, 23, 25] </ref>. For brevity, in this paper we consider only one-to-many group RPC, in which one client uses RPC to invoke a procedure implemented by a server group.
References-found: 25

