URL: ftp://ftp.eecs.umich.edu/groups/gasm/edl.ps.gz
Refering-URL: http://www.eecs.umich.edu/gasm/papers.html
Root-URL: http://www.eecs.umich.edu
Title: Extending Dynamic Logic for Reasoning about Evolving Algebras  
Author: Arno Schonegge 
Affiliation: Universitat Karlsruhe Fakultat fur Informatik Institut fur Logik, Komplexitat und Deduktionssysteme  
Date: November 1995  
Note: Interner Bericht Nr. 49/95  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> J.A. Bergstra and J.V. Tucker. </author> <title> Algebraic specifications of computable and semicomputable data types. </title> <journal> Theoret. Comput. Sci., </journal> <volume> 50 </volume> <pages> 137-181, </pages> <year> 1987. </year>
Reference-contexts: For instance a let construct is frequently used. Integrating it in EDL will make no serious problems. Sometimes even sequential execution is useful in 19 At least all computable algebras can be uniquely (up to isomorphism) described by a finite set of EDL formulas (cf. <ref> [1, 23] </ref>). 15 evolving algebra rules (e.g. in [6]). EDL already provides such a con-struct for sequential execution of programs (composition). 20 There are a lot of further constructs that may be desirable in certain applications (cf. [14]: choose, duplicate, : : : ).
Reference: [2] <author> E. Borger. </author> <title> A logical operational semantics for full Prolog. </title> <editor> In E. Borger, H. Kleine-Buning, and M.M. Richter, editors, </editor> <booktitle> Proceedings of the CSL'89, volume 440 of Lecture Notes in Computer Science, </booktitle> <pages> pages 36-64. </pages> <publisher> Springer Verlag, </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction Evolving algebras, introduced by Gurevich [13, 14], are abstract machines mainly applied for the specification of several programming languages (e.g. Prolog <ref> [2, 7] </ref>, Occam [16], C [15]) and of real and virtual architectures (e.g. APE [3], PVM [5]). The usefulness of reasoning about evolving algebras is beyond question.
Reference: [3] <author> E. Borger, G. Del Castillo, P. Galvan, and D. Rosenzweig. </author> <title> Towards a mathematical specification of the APE100 architecture: The APESE model. </title> <editor> In B. Pehrson and I. Simon, editors, </editor> <booktitle> Proceedings of the IFIP 13th World Computer Congress, </booktitle> <volume> volume I: Technology/Foundations, </volume> <pages> pages 396-401. </pages> <publisher> Elsevier Science Publishers B. V., </publisher> <year> 1994. </year>
Reference-contexts: 1 Introduction Evolving algebras, introduced by Gurevich [13, 14], are abstract machines mainly applied for the specification of several programming languages (e.g. Prolog [2, 7], Occam [16], C [15]) and of real and virtual architectures (e.g. APE <ref> [3] </ref>, PVM [5]). The usefulness of reasoning about evolving algebras is beyond question. For instance, certain properties of a single evolving algebra can only be guaranteed by formal proof (e.g. determinism, absence of clashes, or so-called integrity constraints [13]).
Reference: [4] <author> E. Borger, I. Durdanovic, and D. Rosenzweig. </author> <title> Occam: Specification and compiler correctness. </title> <editor> In U. Montanari and E.-R. Olderog, editors, </editor> <booktitle> Proceedings of the IFIP Working Conference on Programming Concepts, Methods and Calculi (PROCOMET 94). </booktitle> <publisher> North Holland, </publisher> <year> 1994. </year>
Reference-contexts: Another important thing is to prove relations between evolving algebras (e.g. equivalence). This is the technique of a proof of the WAM-compiler correctness [6], and some similar work (e.g. <ref> [4] </ref>). These are only a few examples in the range of applications of reasoning about evolving algebras. However, to our knowledge, up to now no (powerful) tool supporting the construction of formal proofs about evolving algebras exists. 1 This paper aims to make first steps towards such a tool.
Reference: [5] <author> E. Borger and U. Glasser. </author> <title> A formal specification of the PVM architecture. </title> <editor> In B. Pehrson and I. Simon, editors, </editor> <booktitle> Proceedings of the IFIP 13th World Computer Congress, volume I: </booktitle> <address> Technology/Foundations. </address> <publisher> Elsevier Science Publishers B. V., </publisher> <year> 1994. </year>
Reference-contexts: 1 Introduction Evolving algebras, introduced by Gurevich [13, 14], are abstract machines mainly applied for the specification of several programming languages (e.g. Prolog [2, 7], Occam [16], C [15]) and of real and virtual architectures (e.g. APE [3], PVM <ref> [5] </ref>). The usefulness of reasoning about evolving algebras is beyond question. For instance, certain properties of a single evolving algebra can only be guaranteed by formal proof (e.g. determinism, absence of clashes, or so-called integrity constraints [13]). Another important thing is to prove relations between evolving algebras (e.g. equivalence).
Reference: [6] <author> E. Borger and D. Rosenzweig. </author> <title> The WAM | definition and compiler correctness. </title> <type> Technical Report TR-14/92, </type> <institution> Universita degli Studi di Pisa, Diparti-mento di Informatika, </institution> <year> 1992. </year>
Reference-contexts: For instance, certain properties of a single evolving algebra can only be guaranteed by formal proof (e.g. determinism, absence of clashes, or so-called integrity constraints [13]). Another important thing is to prove relations between evolving algebras (e.g. equivalence). This is the technique of a proof of the WAM-compiler correctness <ref> [6] </ref>, and some similar work (e.g. [4]). These are only a few examples in the range of applications of reasoning about evolving algebras. <p> This approach was taken e.g. by Schellhorn [22] while doing the WAM case-study <ref> [6] </ref> in the KIV system. 2 The KIV system (Karlsruhe Interactive Verifier) is an advanced tool for development of correct software. <p> this class is sufficient to cope with most evolving algebras in practice. 19 While in most definitions an evolving algebra has exactly one initial state, we permit a set of initial states, namely all st 2 STATE (SIG; X) with st j= I. * final states: In some publications (e.g. <ref> [6] </ref>) the set of final (terminal) states is implicitly defined to be the states which are reachable from the initial state (s) by applying rules, but in which no further rule is applicable. In other definitions final states are not defined at all. <p> Integrating it in EDL will make no serious problems. Sometimes even sequential execution is useful in 19 At least all computable algebras can be uniquely (up to isomorphism) described by a finite set of EDL formulas (cf. [1, 23]). 15 evolving algebra rules (e.g. in <ref> [6] </ref>). EDL already provides such a con-struct for sequential execution of programs (composition). 20 There are a lot of further constructs that may be desirable in certain applications (cf. [14]: choose, duplicate, : : : ). <p> until no rule is applicable, we set: ff := ( (if * 1 then ff 1 ) [ (if * 2 then ff 2 ) [ (if * 3 then ff 3 ) ): Otherwise, if the semantics is to indeterministically choose one of the appli cable rules (cf. e.g. <ref> [6] </ref>), then we set: F := : * 1 ^ : * 2 ^ : * 3 ff := if * 1 ^ * 2 ^ * 3 then (ff 1 [ ff 2 [ ff 3 ) else if * 1 ^ * 2 then (ff 1 [ ff 2 <p> Secondly, we define a formula 25 aff ects i j ( false , otherwise 24 However, allowing constructs for sequential execution in evolving algebra rules is some times convenient, as e.g. in <ref> [6] </ref>. 25 We use (t 1 ; : : :; t n ) = (t 0 n ) as an abbreviation for the conjunction of equations t 1 = t 0 n . which is true if the function update (or assignment) f t := t affects the value of the <p> Another work, which has strongly stimulated our interest in the topic, is that of Schellhorn and Ahrendt [22]. Their aim is to reconstruct the WAM 26 compiler correctness proofs outlined in <ref> [6] </ref> in a rigorous way supported by de-duction systems. In doing so, the KIV system has already been successfully applied for reasoning about (a representation of a certain class of) evolving algebras.
Reference: [7] <author> E. Borger and D. Rosenzweig. </author> <title> A mathematical definition of full Prolog. </title> <booktitle> Science of Computer Programming, </booktitle> <year> 1994. </year>
Reference-contexts: 1 Introduction Evolving algebras, introduced by Gurevich [13, 14], are abstract machines mainly applied for the specification of several programming languages (e.g. Prolog <ref> [2, 7] </ref>, Occam [16], C [15]) and of real and virtual architectures (e.g. APE [3], PVM [5]). The usefulness of reasoning about evolving algebras is beyond question.
Reference: [8] <author> H. Ehrig and B. Mahr. </author> <title> Fundamentals of Algebraic Specification 1, Equations and Initial Semantics, </title> <booktitle> volume 6 of EATCS Monographs on Theoretical Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1985. </year>
Reference-contexts: F [ F 0 ) is again a signature, and from A 2 Alg (SIG), B 2 Alg (SIG 0 ) a (SIG [ SIG 0 )-algebra A + B := (A + B) s s2S [S 0 ; f A+B f2F [F 0 can be constructed by (cf. in <ref> [8] </ref>: amalgamated sum of algebras) (A + B) s := A s , if s 2 S f (A+B) := f A , if f 2 F Definition 2.6 (semantics of terms) Let SIG = (S; F ) be a signature, X a system of variables for SIG, A 2 Alg
Reference: [9] <author> L.M.G. Feijs and H.B.M. Jonkers. </author> <title> Formal Specification and Design, </title> <booktitle> volume 35 of Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1994. </year>
Reference-contexts: The work most close to ours, and with the same aim | which is to make first steps towards (a system for) formal reasoning about evolving algebras (and related specification formalisms, e.g. COLD <ref> [9] </ref>) | was done by Groen-boom and Renardel de Lavalette [11, 12]. In [11] Groenboom and Renardel de Lavalette present MLCM (Modal Logic of Creation and Modification), which is (as EDL) a derivation from traditional dynamic logic.
Reference: [10] <author> R. </author> <title> Goldblatt. </title> <booktitle> Axiomatizing the Logic of Computer Programming, volume 130 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1982. </year>
Reference-contexts: The basic idea is to get a deduction system for evolving algebras by appropriately modifying the KIV system [21]. 2 This modification basically means a kind of extension of the logic underlying the KIV system, which is a variant of dynamic logic <ref> [17, 10, 18] </ref>. In this paper we provide syntax, semantics and a sequent calculus for such an extension of dynamic logic. So, our work can be thought of as a theoretical foundation for adapting the KIV system for reasoning about evolving algebras.
Reference: [11] <author> R. Groenboom and G.R. Renardel de Lavalette. </author> <title> Reasoning about dynamic features in specification languages: A modal view on creation and modification. In D.J. Andrews, </title> <editor> J.F. Groote, and C.A. Middelburg, editors, </editor> <booktitle> Proceedings of the Workshop in Semantics of Specification Languages, </booktitle> <address> Utrecht, 1993. </address> <publisher> Springer Verlag, </publisher> <year> 1994. </year> <month> 28 </month>
Reference-contexts: The work most close to ours, and with the same aim | which is to make first steps towards (a system for) formal reasoning about evolving algebras (and related specification formalisms, e.g. COLD [9]) | was done by Groen-boom and Renardel de Lavalette <ref> [11, 12] </ref>. In [11] Groenboom and Renardel de Lavalette present MLCM (Modal Logic of Creation and Modification), which is (as EDL) a derivation from traditional dynamic logic. On the basis of MLCM they developed a Formal Language for Evolving Algebras (FLEA 2 ) [12]. <p> The work most close to ours, and with the same aim | which is to make first steps towards (a system for) formal reasoning about evolving algebras (and related specification formalisms, e.g. COLD [9]) | was done by Groen-boom and Renardel de Lavalette [11, 12]. In <ref> [11] </ref> Groenboom and Renardel de Lavalette present MLCM (Modal Logic of Creation and Modification), which is (as EDL) a derivation from traditional dynamic logic. On the basis of MLCM they developed a Formal Language for Evolving Algebras (FLEA 2 ) [12].
Reference: [12] <author> R. Groenboom and G.R. Renardel de Lavalette. </author> <title> A formalization of evolving algebras. </title> <booktitle> In Proceedings of Accolade 1995, </booktitle> <publisher> forthcoming. </publisher>
Reference-contexts: no clashes, i.e. that * there are no extensions of the same domain by the same value in both state changes, i.e. new elements in st 0 differ from new elements in st 00 , 11 This definition is partly adopted from Rix Groenboom and Gerard Renardel de Lavalette de <ref> [12] </ref>. 9 * there are no conflicting function updates, i.e. if in both state changes a value of a function value is changed, then these updates of the function value are the same, and * there are no conflicting assignments to variables, i.e. if in both state changes a value of <p> The work most close to ours, and with the same aim | which is to make first steps towards (a system for) formal reasoning about evolving algebras (and related specification formalisms, e.g. COLD [9]) | was done by Groen-boom and Renardel de Lavalette <ref> [11, 12] </ref>. In [11] Groenboom and Renardel de Lavalette present MLCM (Modal Logic of Creation and Modification), which is (as EDL) a derivation from traditional dynamic logic. On the basis of MLCM they developed a Formal Language for Evolving Algebras (FLEA 2 ) [12]. <p> In [11] Groenboom and Renardel de Lavalette present MLCM (Modal Logic of Creation and Modification), which is (as EDL) a derivation from traditional dynamic logic. On the basis of MLCM they developed a Formal Language for Evolving Algebras (FLEA 2 ) <ref> [12] </ref>. Though closely related there are substantial differences to our approach. The semantics of FLEA 2 is defined using a so-called super-universum (cf. [14]) and special pre-defined functions (e.g. Reserve). Furthermore a repetition construct is available only in MLCM but not in FLEA 2 .
Reference: [13] <author> Y. Gurevich. </author> <title> Evolving algebras. A tutorial introduction. </title> <journal> In Bulletin of the European Association for Theoretical Computer Science, </journal> <volume> volume 43, </volume> <pages> pages 264-284, </pages> <year> 1991. </year>
Reference-contexts: 1 Introduction Evolving algebras, introduced by Gurevich <ref> [13, 14] </ref>, are abstract machines mainly applied for the specification of several programming languages (e.g. Prolog [2, 7], Occam [16], C [15]) and of real and virtual architectures (e.g. APE [3], PVM [5]). The usefulness of reasoning about evolving algebras is beyond question. <p> APE [3], PVM [5]). The usefulness of reasoning about evolving algebras is beyond question. For instance, certain properties of a single evolving algebra can only be guaranteed by formal proof (e.g. determinism, absence of clashes, or so-called integrity constraints <ref> [13] </ref>). Another important thing is to prove relations between evolving algebras (e.g. equivalence). This is the technique of a proof of the WAM-compiler correctness [6], and some similar work (e.g. [4]). These are only a few examples in the range of applications of reasoning about evolving algebras. <p> Using error elements instead of proper partiality minimizes the modifications of the KIV system (and is even the technique used in basic introductions to evolving algebras <ref> [13, 14] </ref>). 10 Notice that we do not explicitly forbid non-strict functions in algebras. <p> There are several differences to other common definitions of evolving algebras: * many-sorted signature: Instead of modeling sorts by means of predicate symbols (ranging over a so-called super-universe) as e.g. in <ref> [13, 14] </ref>, we prefer to use a many-sorted signature. Thus, we loose a little bit of expressiveness (e.g. allowing objects which are elements of more than one universe), but avoid keeping track of sorting information while constructing proofs. * initial states: Mostly no syntactic representation for initial states is given. <p> In some publications a computation step is defined as firing one, indeterministically chosen rule, in other publications (e.g. <ref> [13] </ref>) a computation step is defined as firing all rules simultaneously. <p> rules in a single one, which an advocate of the first definition would write as ff := (ff 1 [ [ ff n ), and an advocate of the second definition would write as ff := (ff 1 ; : : : ; ff n ). * clash handling: In <ref> [13] </ref> executing conflicting updates is defined to indeterministically choose one of the greatest subsets of non-conflicting updates. Some more recent publications (e.g. [14]) define a clash to behave just like skip. However, it is commonly accepted that a detection of an inconsistency should manifest itself in some way.
Reference: [14] <author> Y. Gurevich. </author> <title> Evolving algebras 1993: Lipari guide. </title> <editor> In E. Borger, editor, </editor> <title> Specification and Validation Methods. </title> <publisher> Oxford University Press, </publisher> <year> 1994. </year>
Reference-contexts: 1 Introduction Evolving algebras, introduced by Gurevich <ref> [13, 14] </ref>, are abstract machines mainly applied for the specification of several programming languages (e.g. Prolog [2, 7], Occam [16], C [15]) and of real and virtual architectures (e.g. APE [3], PVM [5]). The usefulness of reasoning about evolving algebras is beyond question. <p> Using error elements instead of proper partiality minimizes the modifications of the KIV system (and is even the technique used in basic introductions to evolving algebras <ref> [13, 14] </ref>). 10 Notice that we do not explicitly forbid non-strict functions in algebras. <p> There are several differences to other common definitions of evolving algebras: * many-sorted signature: Instead of modeling sorts by means of predicate symbols (ranging over a so-called super-universe) as e.g. in <ref> [13, 14] </ref>, we prefer to use a many-sorted signature. Thus, we loose a little bit of expressiveness (e.g. allowing objects which are elements of more than one universe), but avoid keeping track of sorting information while constructing proofs. * initial states: Mostly no syntactic representation for initial states is given. <p> EDL already provides such a con-struct for sequential execution of programs (composition). 20 There are a lot of further constructs that may be desirable in certain applications (cf. <ref> [14] </ref>: choose, duplicate, : : : ). We do not discuss them here. * one rule only: Usually an evolving algebra is defined to contain a finite set of rules fff 1 ; : : : ; ff n g. <p> Some more recent publications (e.g. <ref> [14] </ref>) define a clash to behave just like skip. However, it is commonly accepted that a detection of an inconsistency should manifest itself in some way. In our opinion it should even not be possible to continue a computation if a clash has occurred. <p> On the basis of MLCM they developed a Formal Language for Evolving Algebras (FLEA 2 ) [12]. Though closely related there are substantial differences to our approach. The semantics of FLEA 2 is defined using a so-called super-universum (cf. <ref> [14] </ref>) and special pre-defined functions (e.g. Reserve). Furthermore a repetition construct is available only in MLCM but not in FLEA 2 . A minor difference is that in the semantics of the extend construct presented here the variable is bound locally and not globally.
Reference: [15] <author> Y. Gurevich and J. Huggins. </author> <title> The semantics of the C programming language. </title> <booktitle> In Proceedings of the CSL, volume 702 of Lecture Notes in Computer Science, </booktitle> <pages> pages 273-309. </pages> <publisher> Springer Verlag, </publisher> <year> 1993. </year>
Reference-contexts: 1 Introduction Evolving algebras, introduced by Gurevich [13, 14], are abstract machines mainly applied for the specification of several programming languages (e.g. Prolog [2, 7], Occam [16], C <ref> [15] </ref>) and of real and virtual architectures (e.g. APE [3], PVM [5]). The usefulness of reasoning about evolving algebras is beyond question. For instance, certain properties of a single evolving algebra can only be guaranteed by formal proof (e.g. determinism, absence of clashes, or so-called integrity constraints [13]).
Reference: [16] <author> Y. Gurevich and L. Moss. </author> <title> Algebraic operational semantics and Occam. </title> <editor> In E. Borger, H. Kleine-Buning, and M.M. Richter, editors, </editor> <booktitle> Proceedings of the CSL'89, volume 440 of Lecture Notes in Computer Science, </booktitle> <pages> pages 176-192. </pages> <publisher> Springer Verlag, </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction Evolving algebras, introduced by Gurevich [13, 14], are abstract machines mainly applied for the specification of several programming languages (e.g. Prolog [2, 7], Occam <ref> [16] </ref>, C [15]) and of real and virtual architectures (e.g. APE [3], PVM [5]). The usefulness of reasoning about evolving algebras is beyond question. For instance, certain properties of a single evolving algebra can only be guaranteed by formal proof (e.g. determinism, absence of clashes, or so-called integrity constraints [13]).
Reference: [17] <author> D. Harel. </author> <title> First Order Dynamic Logic. </title> <booktitle> Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1979. </year>
Reference-contexts: The basic idea is to get a deduction system for evolving algebras by appropriately modifying the KIV system [21]. 2 This modification basically means a kind of extension of the logic underlying the KIV system, which is a variant of dynamic logic <ref> [17, 10, 18] </ref>. In this paper we provide syntax, semantics and a sequent calculus for such an extension of dynamic logic. So, our work can be thought of as a theoretical foundation for adapting the KIV system for reasoning about evolving algebras.
Reference: [18] <author> M. Heisel, W. Reif, and W. Stephan. </author> <title> A dynamic logic for program verification. </title> <booktitle> In Logical Foundations of Computer Science, volume 363 of Lecture Notes in Computer Science, </booktitle> <pages> pages 134-145. </pages> <publisher> Springer Verlag, </publisher> <year> 1989. </year>
Reference-contexts: The basic idea is to get a deduction system for evolving algebras by appropriately modifying the KIV system [21]. 2 This modification basically means a kind of extension of the logic underlying the KIV system, which is a variant of dynamic logic <ref> [17, 10, 18] </ref>. In this paper we provide syntax, semantics and a sequent calculus for such an extension of dynamic logic. So, our work can be thought of as a theoretical foundation for adapting the KIV system for reasoning about evolving algebras. <p> In the following definition so-called counters are introduced. This is a special built-in data structure used for inductive arguments about while loops (see definition 2.10 and appendix A) (cf. <ref> [18] </ref>).
Reference: [19] <author> A. Kappel. </author> <title> Algebraische operationale Semantik und ihre Anwendung auf Prolog. </title> <type> Master's thesis, </type> <institution> Universitat Dortmund, Lehrstuhl Informatik V, </institution> <year> 1990. </year>
Reference-contexts: Another syntax for the extend-construct, which emphasizes the relationship to local variable bindings is used in <ref> [19] </ref> and looks like let x = new (s) in ff endlet. <p> In other definitions final states are not defined at all. As e.g. in <ref> [19] </ref> we prefer to make final states explicit, namely as a boolean expression describing a stopping condition. <p> during a run of the evolving algebra, and so-called static functions, for which no update exists in the rules of the evolving algebra. (The same distinction is possible for variables.) In practice it is reasonable to make this separation explicit in the signature, a technique which is used e.g. in <ref> [19] </ref>. Besides methodological merits one also gains advantages in (interactive) reasoning about evolving algebras: All the information (axioms and derived lemmata) about the static part can be kept globally, so that the current (sub-)goals in a proof have only to keep information concerning the dynamic part.
Reference: [20] <author> A. Poetzsch-Heffter. </author> <title> Deriving partial correctness logics from evolving algebras. </title> <editor> In B. Pehrson and I. Simon, editors, </editor> <booktitle> IFIP 13th World Computer Congress 1994, Volume I: </booktitle> <address> Technology/Foundations. Elsevier Amsterdam, </address> <year> 1994. </year>
Reference-contexts: Another proposal for reasoning about evolving algebras, restricted to in-variance properties of single evolving algebras, can be found in Poetzsch-Heffter's work on deriving partial correctness logics from evolving algebras <ref> [20] </ref>. <p> For this purpose the KIV system was not adapted in any way, but evolving algebras are simulated by formalizing dynamic functions as association lists, i.e. as explicit data. (A similar technique is used in <ref> [20] </ref>). Acknowledgments I am indebted to Thomas Fuch, Gerhard Schellhorn, and Wolfgang Ahrendt for many valuable discussions on the topic of this paper. Thomas Fuch, Martin Giese, Elmar Habermalz and Roland Prei have made helpful comments on an earlier draft. 27
Reference: [21] <author> W. Reif. </author> <title> The KIV-system: Systematic construction of verified software. </title> <booktitle> In Proceedings of the 11th International Conference on Automated Deduction, volume 607 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: The basic idea is to get a deduction system for evolving algebras by appropriately modifying the KIV system <ref> [21] </ref>. 2 This modification basically means a kind of extension of the logic underlying the KIV system, which is a variant of dynamic logic [17, 10, 18]. In this paper we provide syntax, semantics and a sequent calculus for such an extension of dynamic logic.
Reference: [22] <author> G. Schellhorn. </author> <title> &lt;unknown title&gt; (report on a case study with KIV which deals with proving WAM-compiler correctness), </title> <year> 1996 </year> <month> forthcoming. </month>
Reference-contexts: This approach was taken e.g. by Schellhorn <ref> [22] </ref> while doing the WAM case-study [6] in the KIV system. 2 The KIV system (Karlsruhe Interactive Verifier) is an advanced tool for development of correct software. <p> Another work, which has strongly stimulated our interest in the topic, is that of Schellhorn and Ahrendt <ref> [22] </ref>. Their aim is to reconstruct the WAM 26 compiler correctness proofs outlined in [6] in a rigorous way supported by de-duction systems. In doing so, the KIV system has already been successfully applied for reasoning about (a representation of a certain class of) evolving algebras.
Reference: [23] <author> M. Wirsing. </author> <title> Algebraic Specification, </title> <booktitle> volume B of Handbook of Theoretical Computer Science, chapter 13, </booktitle> <pages> pages 675-788. </pages> <publisher> Elsevier Science Publishers B. V., </publisher> <year> 1990. </year>
Reference-contexts: For instance a let construct is frequently used. Integrating it in EDL will make no serious problems. Sometimes even sequential execution is useful in 19 At least all computable algebras can be uniquely (up to isomorphism) described by a finite set of EDL formulas (cf. <ref> [1, 23] </ref>). 15 evolving algebra rules (e.g. in [6]). EDL already provides such a con-struct for sequential execution of programs (composition). 20 There are a lot of further constructs that may be desirable in certain applications (cf. [14]: choose, duplicate, : : : ).
References-found: 23

