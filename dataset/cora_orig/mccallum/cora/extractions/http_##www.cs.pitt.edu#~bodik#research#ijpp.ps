URL: http://www.cs.pitt.edu/~bodik/research/ijpp.ps
Refering-URL: http://www.cs.pitt.edu/~bodik/research/lcpc95.html
Root-URL: 
Title: Array Data Flow Analysis for Load-Store Optimizations in Fine-Grain Architectures  
Author: Rastislav Bodk and Rajiv Gupta 
Keyword: data flow analysis, data dependence analysis, load-store optimizations, partial redundancy elimination, partial dead code elimination.  
Note: Appeared in International Journal of Parallel Programming, 24 (06), page 481-512 (1996). Partially supported by National Science Foundation Presidential Young Investigator Award CCR-9157371 to the University of Pittsburgh and a grant from Hewlett-Packard Laboratories.  
Address: Pittsburgh, Pittsburgh, PA 15260  
Affiliation: Dept. of Computer Science, University of  
Abstract: The performance of scientific programs on modern processors can be significantly degraded by memory references that frequently arise due to load and store operations associated with array references. We have developed techniques for optimally allocating registers to array elements whose values are repeatedly referenced over one or more loop iterations. The resulting placement of loads and stores is optimal in that the number of loads and stores encountered along each path through the loop is minimal for the given program branching structure. To place load, store, and register-to-register shift operations without introducing fully/partially redundant and dead memory operations, a detailed value flow analysis of array references is required. We present an analysis framework to efficiently solve various data flow problems required by array load-store optimizations. The framework determines the collective behavior of recurrent references spread over multiple loop iterations. We also demonstrate how our algorithms can be adapted for various fine-grain architectures. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> M.E. Benitez and J.W. Davidson, </author> <title> "Code Generation for Streaming: an Access/Execute Mechanism," </title> <booktitle> Proceedings of Arch. Support for Programming Languages and Operating Systems-IV, </booktitle> <pages> pages 132-141, </pages> <year> 1991. </year>
Reference-contexts: R2 viii 13 store R2, A [2 fl i] viii 14 endif ix 15 def R1 x 16 store R1, A [i + 4] x 17 endloop xi (a) Unoptimized loop. 1 load R1, A [4] 2 load R2, A [3] 3 load R3, A [2] 4 load R4, A <ref> [1] </ref> 5 for i in 1 : : : N i 7 use R4 iii 8 if (odd (i)) then iv 9 use R1 v 10 shift R3, R4 11 shift R2, R3 12 def R2 vi 13 store R2, A [i + 3] vi 14 else vii 15 store R1, <p> framework introduced in the preceding section. 3 A critical edge is an edge leading from a node with more than one successor to a node with more than one predecessor. 15 1 load R2, A [4] 2 load R3, A [3] 3 load R4, A [2] 4 load R5, A <ref> [1] </ref> 5 for i in 1 : : : N i 7 use R5 iii 8 if (odd (i)) then iv 9 use R2 v 11 store R2, A [i + 3] vi 12 else vii 13 def R2 viii 14 store R2, A [2 fl i] viii 15 load R3, <p> 18 store R1, A [i + 4] x 19 shift R4, R5 20 shift R3, R4 21 shift R2, R3 22 shift R1, R2 23 endloop xi (a) After load optimization. 1 load R2, A [4] 2 load R3, A [3] 3 load R4, A [2] 4 load R5, A <ref> [1] </ref> 5 for i in 1 : : : N i 7 use R5 iii 8 if (odd (i)) then iv 9 use R2 v 11 store R2, A [i + 3] vi 12 else vii 13 store R2, A [i + 3] 14 def R2 viii 15 store R2, A
Reference: 2. <author> R. Bodik and R. Gupta, </author> <title> "Optimal Placement of Load-Store Operations for Array Accesses in Loops," </title> <type> Technical report 95-03, </type> <institution> DCS, Univ. of Pittsburgh, </institution> <year> 1995. </year>
Reference-contexts: 11 else vii 12 def R2 viii 13 store R2, A [2 fl i] viii 14 endif ix 15 def R1 x 16 store R1, A [i + 4] x 17 endloop xi (a) Unoptimized loop. 1 load R1, A [4] 2 load R2, A [3] 3 load R3, A <ref> [2] </ref> 4 load R4, A [1] 5 for i in 1 : : : N i 7 use R4 iii 8 if (odd (i)) then iv 9 use R1 v 10 shift R3, R4 11 shift R2, R3 12 def R2 vi 13 store R2, A [i + 3] vi 14 <p> array references by utilizing the framework introduced in the preceding section. 3 A critical edge is an edge leading from a node with more than one successor to a node with more than one predecessor. 15 1 load R2, A [4] 2 load R3, A [3] 3 load R4, A <ref> [2] </ref> 4 load R5, A [1] 5 for i in 1 : : : N i 7 use R5 iii 8 if (odd (i)) then iv 9 use R2 v 11 store R2, A [i + 3] vi 12 else vii 13 def R2 viii 14 store R2, A [2 fl <p> ix 17 def R1 x 18 store R1, A [i + 4] x 19 shift R4, R5 20 shift R3, R4 21 shift R2, R3 22 shift R1, R2 23 endloop xi (a) After load optimization. 1 load R2, A [4] 2 load R3, A [3] 3 load R4, A <ref> [2] </ref> 4 load R5, A [1] 5 for i in 1 : : : N i 7 use R5 iii 8 if (odd (i)) then iv 9 use R2 v 11 store R2, A [i + 3] vi 12 else vii 13 store R2, A [i + 3] 14 def R2
Reference: 3. <author> D. Callahan, S. Carr, and K. Kennedy, </author> <title> "Improving Register Allocation for Subscripted Variables," </title> <booktitle> Proceedings of the SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <address> White Plains, New York, </address> <pages> pages 53-65, </pages> <month> June </month> <year> 1990. </year> <month> 32 </month>
Reference-contexts: A [i + 3] vi 11 else vii 12 def R2 viii 13 store R2, A [2 fl i] viii 14 endif ix 15 def R1 x 16 store R1, A [i + 4] x 17 endloop xi (a) Unoptimized loop. 1 load R1, A [4] 2 load R2, A <ref> [3] </ref> 3 load R3, A [2] 4 load R4, A [1] 5 for i in 1 : : : N i 7 use R4 iii 8 if (odd (i)) then iv 9 use R1 v 10 shift R3, R4 11 shift R2, R3 12 def R2 vi 13 store R2, A <p> for application to loads for array references by utilizing the framework introduced in the preceding section. 3 A critical edge is an edge leading from a node with more than one successor to a node with more than one predecessor. 15 1 load R2, A [4] 2 load R3, A <ref> [3] </ref> 3 load R4, A [2] 4 load R5, A [1] 5 for i in 1 : : : N i 7 use R5 iii 8 if (odd (i)) then iv 9 use R2 v 11 store R2, A [i + 3] vi 12 else vii 13 def R2 viii 14 <p> [i + 2] 16 endif ix 17 def R1 x 18 store R1, A [i + 4] x 19 shift R4, R5 20 shift R3, R4 21 shift R2, R3 22 shift R1, R2 23 endloop xi (a) After load optimization. 1 load R2, A [4] 2 load R3, A <ref> [3] </ref> 3 load R4, A [2] 4 load R5, A [1] 5 for i in 1 : : : N i 7 use R5 iii 8 if (odd (i)) then iv 9 use R2 v 11 store R2, A [i + 3] vi 12 else vii 13 store R2, A [i
Reference: 4. <author> S. Carr and K. Kennedy, </author> <title> "Scalar Replacement in the Presence of Conditional Control Flow," </title> <journal> Software--Practice and Experience, </journal> <volume> Vol. 24, No. 1, </volume> <pages> pages 51-77, </pages> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: def A [i + 4] use A [i] use A [i + 3] else def A [2 fi i] endif def A [i + 4] use A [i] use A [i + 3] else def A [2 fi i] endif def A [i + 4] 2 1 load R1, A <ref> [4] </ref> 2 for i in 1 : : : N i 3 load R2, A [i + 2] ii 4 use R2 ii 5 load R2, A [i] iii 6 use R2 iii 7 if (odd (i)) then iv 8 use R1 v 10 store R2, A [i + 3] vi <p> R1 v 10 store R2, A [i + 3] vi 11 else vii 12 def R2 viii 13 store R2, A [2 fl i] viii 14 endif ix 15 def R1 x 16 store R1, A [i + 4] x 17 endloop xi (a) Unoptimized loop. 1 load R1, A <ref> [4] </ref> 2 load R2, A [3] 3 load R3, A [2] 4 load R4, A [1] 5 for i in 1 : : : N i 7 use R4 iii 8 if (odd (i)) then iv 9 use R1 v 10 shift R3, R4 11 shift R2, R3 12 def R2 <p> (15) This approach is adapted for application to loads for array references by utilizing the framework introduced in the preceding section. 3 A critical edge is an edge leading from a node with more than one successor to a node with more than one predecessor. 15 1 load R2, A <ref> [4] </ref> 2 load R3, A [3] 3 load R4, A [2] 4 load R5, A [1] 5 for i in 1 : : : N i 7 use R5 iii 8 if (odd (i)) then iv 9 use R2 v 11 store R2, A [i + 3] vi 12 else vii <p> viii 15 load R3, A [i + 2] 16 endif ix 17 def R1 x 18 store R1, A [i + 4] x 19 shift R4, R5 20 shift R3, R4 21 shift R2, R3 22 shift R1, R2 23 endloop xi (a) After load optimization. 1 load R2, A <ref> [4] </ref> 2 load R3, A [3] 3 load R4, A [2] 4 load R5, A [1] 5 for i in 1 : : : N i 7 use R5 iii 8 if (odd (i)) then iv 9 use R2 v 11 store R2, A [i + 3] vi 12 else vii
Reference: 5. <author> G.J. Chaitin, </author> <title> "Register Allocation and Spilling via Graph Coloring," </title> <booktitle> Proceedings of the SIGPLAN Symposium on Compiler Construction, SIGPLAN Notices, </booktitle> <volume> vol. 17, no. 6, </volume> <pages> pages 98-105, </pages> <month> June </month> <year> 1982. </year>
Reference: 6. <author> T.H. Cormen, C.E. Leiserson, and R.L. Rivest, </author> <title> Introduction to Algorithms, </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference: 7. <author> J.C. Dehnert, P.Y.-T. Hsu, and J.P. Bratt, </author> <title> "Overlapped Loop Support in the Cydra 5," </title> <booktitle> Proceedings of ASPLOS-III, </booktitle> <pages> pages 26-39, </pages> <year> 1989. </year>
Reference: 8. <author> D.M. Dhamdhere, </author> <title> "Practical Adaptation of the Global Optimization Algorithm of Morel and Renvoise," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Volume 13, No. 2, </volume> <pages> pages 291-294, </pages> <month> April </month> <year> 1991. </year>
Reference: 9. <author> D.M. Dhamdhere, B.K. Rosen and F.K. Zadeck, </author> <title> "How to Analyze Large Programs Efficiently and informatively," </title> <booktitle> Proc. of the SIGPLAN PLDI, </booktitle> <address> San Francisco, California, </address> <pages> pages 212-223, </pages> <month> June </month> <year> 1992. </year>
Reference: 10. <author> E. Duesterwald, R. Gupta, </author> <title> and M.L. Soffa, "Register Pipelining: An Integrated Approach to Register Allocation for Scalar and Subscripted Variables," </title> <booktitle> Proc. of International Workshop on Compiler Construction, </booktitle> <publisher> LNCS 641 Springer Verlag, </publisher> <pages> pages 192-206, </pages> <address> Paderborn, Germany, </address> <month> October </month> <year> 1992. </year>
Reference: 11. <author> E. Duesterwald, R. Gupta, </author> <title> and M.L. Soffa, "A Practical Data Flow Framework for Array Reference Analysis and its Application in Optimizations," </title> <booktitle> Proc. of ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <address> pp.68-77, Albuquerque, New Mexico, </address> <month> June </month> <year> 1993. </year>
Reference: 12. <author> R. Gupta, </author> <title> "Generalized Dominators and Post-Dominators," </title> <booktitle> The Nineteenth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 246-257, </pages> <address> Albuquerque, New Mexico, </address> <month> January </month> <year> 1992. </year>
Reference: 13. <author> L. Hendren, G.R. Gao, E.R. Altman, and C. Mukerji, </author> <title> "A Register Allocation Framework based upon Hierarchical Cyclic Interval Graphs," </title> <booktitle> International Workshop on Compiler Construction, </booktitle> <publisher> LNCS 641 Springer Verlag, </publisher> <pages> pages 176-191, </pages> <address> Germany, </address> <year> 1992. </year>
Reference: 14. <author> V. Kathail, M. Schlansker, and B. Rau, </author> <title> HPL PlayDoh Architecture Specification: </title> <note> Version 1.0, HPL-93-80, </note> <month> February, </month> <year> 1994. </year>
Reference: 15. <author> J. Knoop, O. Ruthing, and B. Steffen, </author> <title> "Optimal Code Motion: </title> <journal> Theory and Practice," ACM TOPLAS, </journal> <volume> vol. 16, num. 4, </volume> <pages> pages 1117-1155. </pages>
Reference: 16. <author> P. Kolte and M.J. Harrold, </author> <title> "Load/Store Range Analysis for Global Register Allocation," </title> <booktitle> Proc. of the SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <address> Albuquerque, New Mexico, </address> <pages> pages 268-277, </pages> <month> June </month> <year> 1994. </year>
Reference: 17. <author> E. Morel and C. </author> <title> Renvoise, "Global Optimization by Suppression of Partial Redundancies," </title> <journal> Communications of the ACM, </journal> <volume> Volume 22, No. 2, </volume> <pages> pages 96-103, </pages> <year> 1979. </year>
Reference: 18. <author> B. R. Rau. M. Lee, P. P. Tirumalai, M. S. Schlansker, </author> <title> "Register Allocation for Software Pipelined Loops," </title> <booktitle> Proc. of the SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <address> San Francisco, California, </address> <pages> pages 212-223, </pages> <month> June </month> <year> 1992. </year> <month> 33 </month>
Reference: 19. <author> B. R. Rau, </author> <title> "Data Flow and Dependence Analysis for Instruction-Level Parallelism," </title> <booktitle> Fourth Annual Workshop on Languages and Compilers for Parallel Computing, </booktitle> <address> Santa Clara, california, </address> <month> August </month> <year> 1991. </year>
Reference: 20. <author> M. Wolfe and U. Banerjee, </author> <title> "Data Dependence and Its Application to Parallel Processing," </title> <journal> International Journal of Parallel Programming, </journal> <volume> Vol. 16, No. 2, </volume> <month> April </month> <year> 1987. </year> <month> 34 </month>
References-found: 20

