URL: http://www.cs.umd.edu/~rich/courses/cmsc818G-s98/papers/goddard_rtas98.ps
Refering-URL: http://www.cs.umd.edu/~rich/courses/cmsc818G-s98/schedule.html
Root-URL: 
Email: fgoddard, jeffayg@cs.unc.edu  
Title: A Software Synthesis Method for Building Real-Time Systems from Processing Graphs  
Author: Steve Goddard Kevin Jeffay 
Address: Chapel Hill, NC 27599-3175  
Affiliation: Department of Computer Science University of North Carolina  
Date: June 1998.  
Note: To appear in: Proceedings of the IEEE Real-Time Technology and Applications Symposium,  
Abstract: In this paper, we present software synthesis techniques that create a real-time uniprocessor system from processing graphs. To achieve the synthesis, new rate theorems have been developed to derive the execution rate of each processing component in the graph. The processing graph is mapped to the existing Rate Based Execution (RBE) task model, and if the schedulability test for the resulting task set is affirmative, we show that efficient buffer management can be achieved using a simple Earliest Deadline First (EDF) scheduler. We evaluate our results using an International Maritime Satellite (INMARSAT) mobile receiver application. The case study shows that a dynamically scheduled implementation of the INMARSAT mobile satellite receiver uses less memory and introduces less latency than a comparable static implementation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Baruah, S., Goddard, S., Jeffay, K., </author> <title> "Feasibility Concerns in PGM Graphs with Bounded Buffers," </title> <booktitle> Proc. of the Third Intl. Conference on Engineering of Complex Computer Systems, </booktitle> <month> Sept., </month> <year> 1997, </year> <pages> pp 130-139. </pages>
Reference-contexts: Off-line schedulers create a static schedule that is executed periodically (or cyclically) by the processor. The primary goal of our synthesis method and related research has been to manage latency and buffer requirements of processing graphs executed with a work-conserving on-line scheduler <ref> [1, 7, 8, 10] </ref>. In contrast to the off-line schedulers developed for SDF graphs, on-line scheduling of PGM graphs uses input data rates and schedulability conditions from real-time scheduling theory.
Reference: [2] <author> Baruah, S., Howell, R., Rosier, L., </author> <title> "Algorithms and Complexity Concerning the Preemptively Scheduling of Periodic, Real-Time Tasks on One Processor" Real-Time Systems Journal, </title> <journal> Vol. </journal> <volume> 2, </volume> <year> 1990, </year> <pages> pp. 301-324. </pages>
Reference-contexts: where f (a) = ( 0 if a &lt; 0 Note that if the cumulative processor utilization for a graph is strictly less than one (i.e., P n x i e i y i &lt; 1) then condition (4.4) can be evaluated efficiently (in pseudo-polynomial time) using techniques developed in <ref> [2] </ref>. In [7] we established sufficiency of (4.4) by showing that the preemptive EDF scheduling algorithm can schedule releases of the tasks in T without a task missing a deadline if the task set satisfies (4.4).
Reference: [3] <author> Bhattacharyya, S.S., Murthy, P.K., Lee, </author> <title> E.A., Software Synthesis from Dataflow Graphs, </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1996. </year>
Reference-contexts: An important aspect in controlling memory usage is the node execution schedule since this impacts the buffer requirements of the edges in the graph. The state of the art in minimizing the memory requirements of a signal processing graph is to create a node execution schedule off-line <ref> [14, 18, 23, 19, 3] </ref>. In contrast, our approach is to use a dynamic, on-line scheduler for graph execution. <p> Navy's coarse-grain Processing Graph Method (PGM) [16], which is based on computation graphs introduced by Karp and Miller [13]. Another synthesis methodology based on computation graphs is the Synchronous Dataflow (SDF) software synthesis method <ref> [3, 14] </ref>. For our purposes, the differences between SDF graphs and PGM graphs are minor and are presented in x3. However, the differences between the two synthesis methods are dramatic. <p> However, the differences between the two synthesis methods are dramatic. The main goal of the SDF synthesis method and related scheduling research has been to minimize memory usage by creating off-line scheduling algorithms (e.g., <ref> [14, 18, 23, 19, 3] </ref>). Off-line schedulers create a static schedule that is executed periodically (or cyclically) by the processor. <p> a state-of-the-art, static scheduler, which is designed to minimize memory requirements. 6.2 Buffer Requirements In this section we present the buffer requirements of each queue in the mobile satellite receiver application and compare the total memory requirements of our synthesis of the application with the bounds reported in [19] and <ref> [3] </ref>. Due to space limitations, we derive the bounds for one queue as an example and refer the reader to Table 2 for the buffer bounds on the remaining queues. <p> in the mobile satellite receiver graph (calculated with the RBE parameters of Table 1) are shown in Table 2 with the exception of the queues attached to input or output devices since the buffer space for these queues was ignored in the buffer calculations done by [18, 23, 19] and <ref> [3] </ref>. The buffer space required for each of these queues in our model is 1 token. When an off-line scheduler is employed, the buffer space required for each of the queues attached to input devices varies from 44 to 4,224 tokens depending on the scheduler. <p> Assuming a unique buffer for each queue, the minimum buffer requirement for the INMARSAT mobile satellite receiver graph is 1,545 tokens | derived by summing prd (q)cns (q) gcd (prd (q);cns (q)) = max (prd (q); cns (q)) over all queues in the graph <ref> [3] </ref>.
Reference: [4] <author> Berry, G., Cosserat, L., </author> <title> "The ESTEREL Synchronous Programming Language and its Mathematical Semantics", </title> <booktitle> Lecture Notes in Computer Science, Vol. 197 Seminar on Concurrency, </booktitle> <publisher> Springer Verlag, </publisher> <address> Berlin, </address> <year> 1985. </year>
Reference-contexts: An execution paradigm that supports expected rates of the form x executions in y time units is a much more natural and simpler task model for the analysis of schedulability, latency, and buffer requirements for a processing graph application. We assume the strong synchrony hypothesis of <ref> [4] </ref> to introduce the concept of node execution rates. The strong synchrony hypothesis is that the system instantly reacts to external stimuli by updating internal states such that the response to input appears instantaneously.
Reference: [5] <author> Gerber, R., Seongsoo, H., Saksena, M., </author> <title> "Guaranteeing Real-Time Requirements with Resource-Based Calibration of Periodic Processes", </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(7), </volume> <month> July </month> <year> 1995. </year>
Reference-contexts: In contrast to the off-line schedulers developed for SDF graphs, on-line scheduling of PGM graphs uses input data rates and schedulability conditions from real-time scheduling theory. The real-time literature is replete with examples in which some form of a processing graph is used to construct real-time systems <ref> [5, 6, 11, 15, 17, 22, 20, 21] </ref> (to list a few). The processing graphs of [5, 17] and [22] are task graphs in which only precedence constraints are described. An even simpler processing graph, called task chains, is employed by [6, 20] and [21]. <p> The real-time literature is replete with examples in which some form of a processing graph is used to construct real-time systems [5, 6, 11, 15, 17, 22, 20, 21] (to list a few). The processing graphs of <ref> [5, 17] </ref> and [22] are task graphs in which only precedence constraints are described. An even simpler processing graph, called task chains, is employed by [6, 20] and [21]. <p> An even simpler processing graph, called task chains, is employed by [6, 20] and [21]. Both task graphs and task chains can be represented with PGM graphs, but this paper does not address the distributed or end-to-end latency issues of <ref> [5, 6, 17, 22, 20, 21] </ref>. From the real-time literature, the results presented in this paper are most closely related to the dataflow graphs found in the Software Automation for Real-Time Operations (SARTOR) project led by Mok [15] and the Real-Time Producer/Consumer (RTP/C) paradigm of Jeffay [11].
Reference: [6] <author> Kang, D.-I., Gerber, R., Saksena, M., </author> <booktitle> "Performance-Based Design of Distributed Real-Time Systems", Proc. of IEEE Real-Time Technology and Applications Symposium, </booktitle> <month> June </month> <year> 1997, </year> <pages> pp. 2-13. </pages>
Reference-contexts: In contrast to the off-line schedulers developed for SDF graphs, on-line scheduling of PGM graphs uses input data rates and schedulability conditions from real-time scheduling theory. The real-time literature is replete with examples in which some form of a processing graph is used to construct real-time systems <ref> [5, 6, 11, 15, 17, 22, 20, 21] </ref> (to list a few). The processing graphs of [5, 17] and [22] are task graphs in which only precedence constraints are described. An even simpler processing graph, called task chains, is employed by [6, 20] and [21]. <p> The processing graphs of [5, 17] and [22] are task graphs in which only precedence constraints are described. An even simpler processing graph, called task chains, is employed by <ref> [6, 20] </ref> and [21]. Both task graphs and task chains can be represented with PGM graphs, but this paper does not address the distributed or end-to-end latency issues of [5, 6, 17, 22, 20, 21]. <p> An even simpler processing graph, called task chains, is employed by [6, 20] and [21]. Both task graphs and task chains can be represented with PGM graphs, but this paper does not address the distributed or end-to-end latency issues of <ref> [5, 6, 17, 22, 20, 21] </ref>. From the real-time literature, the results presented in this paper are most closely related to the dataflow graphs found in the Software Automation for Real-Time Operations (SARTOR) project led by Mok [15] and the Real-Time Producer/Consumer (RTP/C) paradigm of Jeffay [11].
Reference: [7] <author> Goddard, S., Jeffay, K. </author> <title> "Analyzing the Real-Time Properties of a Dataflow Execution Paradigm using a Synthetic Aperture Radar Application", </title> <institution> TR97-007, Dept. of CS, UNC, </institution> <month> April </month> <year> 1997. </year>
Reference-contexts: Off-line schedulers create a static schedule that is executed periodically (or cyclically) by the processor. The primary goal of our synthesis method and related research has been to manage latency and buffer requirements of processing graphs executed with a work-conserving on-line scheduler <ref> [1, 7, 8, 10] </ref>. In contrast to the off-line schedulers developed for SDF graphs, on-line scheduling of PGM graphs uses input data rates and schedulability conditions from real-time scheduling theory. <p> We proved the following feasibility condition for an RBE task set in <ref> [7] </ref>. Lemma 4.5. Let T = f (x 1 ; y 1 ; d 1 ; e 1 ); : : : (x n ; y n ; d n ; e n )g be a set of tasks. <p> In <ref> [7] </ref> we established sufficiency of (4.4) by showing that the preemptive EDF scheduling algorithm can schedule releases of the tasks in T without a task missing a deadline if the task set satisfies (4.4).
Reference: [8] <author> Goddard, S., Jeffay, K. </author> <title> "Analyzing the Real-Time Properties of Processing Graphs Implemented with the Rate Based Execution Model", </title> <institution> TR98-001, Dept. of CS, UNC, </institution> <month> March </month> <year> 1998. </year>
Reference-contexts: Off-line schedulers create a static schedule that is executed periodically (or cyclically) by the processor. The primary goal of our synthesis method and related research has been to manage latency and buffer requirements of processing graphs executed with a work-conserving on-line scheduler <ref> [1, 7, 8, 10] </ref>. In contrast to the off-line schedulers developed for SDF graphs, on-line scheduling of PGM graphs uses input data rates and schedulability conditions from real-time scheduling theory. <p> In the general case, the buffer bounds that we can derive are much too loose to be useful (though they are valid 1 See <ref> [8] </ref> for a complete discussion on buffer bounds for graphs implemented with the RBE model. 7 upper bounds). Fortunately, many signal processing ap-plications possess dataflow characteristics that we can exploit to get relatively tight buffer bounds. <p> Due to space limitations, we are unable to present these functions (see <ref> [8] </ref>). In the rest of this paper we use s (u) rather than T 1 (u) to denote the time associated with the first release of node u since we are only concerned with this particular release time.
Reference: [9] <author> Goddard, S., Jeffay, K. </author> <title> "A Software Synthesis Method for Building Real-Time Systems from Processing Graphs", </title> <institution> TR98-002, Dept. of CS, UNC, </institution> <month> February </month> <year> 1998. </year>
Reference-contexts: Assuming a valid PGM digraph G = (V; E; ) and each queue in the path (s) from a periodic source to node v is initialized with (thr (q) cns (q)) tokens prior to the beginning of graph execution using the RBE-EDF scheduling algorithm with release time inher 2 See <ref> [9] </ref>, the full Technical Report version of this paper, for the proof of this Theorem. itance, 8q; u such that (q) = (u; v), the buffer require ments for queue q is Buf (q) where Buf (q) max (y (v); s (v) + d (v) s (u)) + (thr (q) cns
Reference: [10] <author> Goddard, S., Jeffay, K. </author> <title> "Analyzing the Real-Time Properties of a Dataflow Execution Paradigm using a Synthetic Aperture Radar Application", </title> <booktitle> Proc. IEEE Real-Time Technology and Applications Symposium, </booktitle> <month> June </month> <year> 1997, </year> <pages> pp. 60-71. </pages>
Reference-contexts: Off-line schedulers create a static schedule that is executed periodically (or cyclically) by the processor. The primary goal of our synthesis method and related research has been to manage latency and buffer requirements of processing graphs executed with a work-conserving on-line scheduler <ref> [1, 7, 8, 10] </ref>. In contrast to the off-line schedulers developed for SDF graphs, on-line scheduling of PGM graphs uses input data rates and schedulability conditions from real-time scheduling theory. <p> Corollary 4.1. If R (v) = (x; y) is a valid rate specification for node v, then m R (v) = (m x; m y) is also a valid rate specification for node v. Proof: The proof follows immediately from the execution rate definition. In <ref> [10] </ref>, we derived execution rates for nodes in a PGM chain. The execution rate theorem of that paper is reproduced here since we will use this result to extend the analysis to include nodes with multiple input queues. Theorem 4.2. <p> Since d (u) affects processor demand, latency and buffer requirements, a good starting point for the selection of d (u) is one such that it is greater than or equal to the deadline of its predecessor node and less than or equal to y (u). As shown in <ref> [10] </ref>, when the deadline for each node is greater than or equal to its predecessor's deadline, release time inheritance can be used to minimize latency.
Reference: [11] <author> Jeffay, K., </author> <title> "The Real-Time Producer/Consumer Paradigm: A paradigm for the construction of efficient, predictable real-time systems", </title> <booktitle> Proc. of ACM/SIGAPP Symp. on Appl. Computing, </booktitle> <month> Feb. </month> <year> 1993, </year> <pages> pp. 796-804. </pages>
Reference-contexts: In contrast to the off-line schedulers developed for SDF graphs, on-line scheduling of PGM graphs uses input data rates and schedulability conditions from real-time scheduling theory. The real-time literature is replete with examples in which some form of a processing graph is used to construct real-time systems <ref> [5, 6, 11, 15, 17, 22, 20, 21] </ref> (to list a few). The processing graphs of [5, 17] and [22] are task graphs in which only precedence constraints are described. An even simpler processing graph, called task chains, is employed by [6, 20] and [21]. <p> From the real-time literature, the results presented in this paper are most closely related to the dataflow graphs found in the Software Automation for Real-Time Operations (SARTOR) project led by Mok [15] and the Real-Time Producer/Consumer (RTP/C) paradigm of Jeffay <ref> [11] </ref>. Unfortunately, neither of these paradigms correctly model the execution of PGM graphs. The dataflow graphs of the SARTOR project have different (and incompatible) node execution rules from PGM. Without creating a non-work-conserving execution of the graph, we cannot use a periodic task model.
Reference: [12] <author> Jeffay, K., Bennett, D. </author> <title> "A Rate-Based Execution Abstraction For Multimedia Computing," </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <editor> T.D.C. Little and R. Gusella eds., </editor> <volume> Vol. 1018, </volume> <publisher> Springer-Verlag, </publisher> <address> Heidelberg, </address> <year> 1995, </year> <pages> pp 65-75. </pages>
Reference-contexts: paper, we present new theorems that characterize the node execution rate of every node in a PGM graph, and demonstrate the synthesis of real-time systems from acyclic processing graphs by mapping nodes in the graph to real-time tasks using the existing Rate Based Execution (RBE) task model developed by Jeffay <ref> [12] </ref>. The accompanying RBE schedulability condition is used to verify processor capacity. An affirmative result from the schedulability condition lets us bound latency and buffer requirements for the application. Once the processing graph has been mapped to real-time tasks, memory requirements can be addressed. <p> However, our execution model is capable of supporting much more sophisticated data flow models than RTP/C. Whereas RTP/C models processes as sporadic tasks, our paradigm uses the Rate-Based Execution (RBE) process 2 model of <ref> [12] </ref> to more accurately predict processor de-mand. 3 An Introduction to Processing Graphs This section introduces some graph theory and notation, which will be used throughout the paper, followed by a summary of the U.S. Navy's Processing Graph Method (PGM). <p> Once a processing graph has been created for the application, we identify the execution rates of graph nodes and map each node to a task in Jeffay's Rate Based Execution (RBE) task model <ref> [12] </ref>. The presentation of our software synthesis method for building real-time uniprocessor systems from PGM graphs is organized as follows. x4.1 introduces the concept of node execution rates and how the execution rate for each node in a PGM graph is derived. <p> Unfortunately we have already seen that nodes are neither periodic nor sporadic, even when the source is periodic, which eliminates most execution models from the literature. The Rate Based Execution (RBE) paradigm <ref> [12] </ref> developed by Jeffay, however, does provide a natural description of node executions in an implementation of processing graphs. This section provides a brief overview of the RBE task model.
Reference: [13] <author> Karp, R.M., Miller, R.E., </author> <title> "Properties of a model for parallel computations: Determinacy, termination, queuing", </title> <journal> SIAM J. Appl. Math, </journal> <volume> 14(6), </volume> <year> 1966, </year> <pages> pp 1390-1411. </pages>
Reference-contexts: Our contributions are summarized in x7. 2 Related Work Our software synthesis technique begins with the U.S. Navy's coarse-grain Processing Graph Method (PGM) [16], which is based on computation graphs introduced by Karp and Miller <ref> [13] </ref>. Another synthesis methodology based on computation graphs is the Synchronous Dataflow (SDF) software synthesis method [3, 14]. For our purposes, the differences between SDF graphs and PGM graphs are minor and are presented in x3. However, the differences between the two synthesis methods are dramatic.
Reference: [14] <author> Lee, E.A., Messerschmitt, D.G., </author> <title> "Static Scheduling of Synchronous Data Flow Programs for Digital Signal Processing", </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-36(1), </volume> <month> Jan. </month> <year> 1987, </year> <pages> pp. 24-35. </pages>
Reference-contexts: An important aspect in controlling memory usage is the node execution schedule since this impacts the buffer requirements of the edges in the graph. The state of the art in minimizing the memory requirements of a signal processing graph is to create a node execution schedule off-line <ref> [14, 18, 23, 19, 3] </ref>. In contrast, our approach is to use a dynamic, on-line scheduler for graph execution. <p> Navy's coarse-grain Processing Graph Method (PGM) [16], which is based on computation graphs introduced by Karp and Miller [13]. Another synthesis methodology based on computation graphs is the Synchronous Dataflow (SDF) software synthesis method <ref> [3, 14] </ref>. For our purposes, the differences between SDF graphs and PGM graphs are minor and are presented in x3. However, the differences between the two synthesis methods are dramatic. <p> However, the differences between the two synthesis methods are dramatic. The main goal of the SDF synthesis method and related scheduling research has been to minimize memory usage by creating off-line scheduling algorithms (e.g., <ref> [14, 18, 23, 19, 3] </ref>). Off-line schedulers create a static schedule that is executed periodically (or cyclically) by the processor.
Reference: [15] <author> Mok, A.K., Sutanthavibul, S., </author> <title> "Modeling and Scheduling of Dataflow Real-Time Systems", </title> <booktitle> Proc. of the IEEE Real-Time Systems Symposium, </booktitle> <month> Dec. </month> <year> 1985, </year> <pages> pp. 178-187. </pages>
Reference-contexts: In contrast to the off-line schedulers developed for SDF graphs, on-line scheduling of PGM graphs uses input data rates and schedulability conditions from real-time scheduling theory. The real-time literature is replete with examples in which some form of a processing graph is used to construct real-time systems <ref> [5, 6, 11, 15, 17, 22, 20, 21] </ref> (to list a few). The processing graphs of [5, 17] and [22] are task graphs in which only precedence constraints are described. An even simpler processing graph, called task chains, is employed by [6, 20] and [21]. <p> From the real-time literature, the results presented in this paper are most closely related to the dataflow graphs found in the Software Automation for Real-Time Operations (SARTOR) project led by Mok <ref> [15] </ref> and the Real-Time Producer/Consumer (RTP/C) paradigm of Jeffay [11]. Unfortunately, neither of these paradigms correctly model the execution of PGM graphs. The dataflow graphs of the SARTOR project have different (and incompatible) node execution rules from PGM.
Reference: [16] <editor> Processing Graph Method Specification, </editor> <title> prepared by NRL for use by the Navy Standard Signal Processing Program Office (PMS-412), </title> <note> Version 1.0, </note> <month> Dec. </month> <year> 1987. </year>
Reference-contexts: We evaluate our results in x6 with a case study of an International Maritime Satellite (INMARSAT) mobile receiver application. Our contributions are summarized in x7. 2 Related Work Our software synthesis technique begins with the U.S. Navy's coarse-grain Processing Graph Method (PGM) <ref> [16] </ref>, which is based on computation graphs introduced by Karp and Miller [13]. Another synthesis methodology based on computation graphs is the Synchronous Dataflow (SDF) software synthesis method [3, 14]. For our purposes, the differences between SDF graphs and PGM graphs are minor and are presented in x3.
Reference: [17] <author> Ramamritham, K., </author> <title> "Allocation and Scheduling of Precedence-Related Periodic Tasks", </title> <journal> IEEE Trans. on Parallel and Dist. Syst., </journal> <volume> 6(4), </volume> <month> April </month> <year> 1995, </year> <pages> pp 412-420. </pages>
Reference-contexts: In contrast to the off-line schedulers developed for SDF graphs, on-line scheduling of PGM graphs uses input data rates and schedulability conditions from real-time scheduling theory. The real-time literature is replete with examples in which some form of a processing graph is used to construct real-time systems <ref> [5, 6, 11, 15, 17, 22, 20, 21] </ref> (to list a few). The processing graphs of [5, 17] and [22] are task graphs in which only precedence constraints are described. An even simpler processing graph, called task chains, is employed by [6, 20] and [21]. <p> The real-time literature is replete with examples in which some form of a processing graph is used to construct real-time systems [5, 6, 11, 15, 17, 22, 20, 21] (to list a few). The processing graphs of <ref> [5, 17] </ref> and [22] are task graphs in which only precedence constraints are described. An even simpler processing graph, called task chains, is employed by [6, 20] and [21]. <p> An even simpler processing graph, called task chains, is employed by [6, 20] and [21]. Both task graphs and task chains can be represented with PGM graphs, but this paper does not address the distributed or end-to-end latency issues of <ref> [5, 6, 17, 22, 20, 21] </ref>. From the real-time literature, the results presented in this paper are most closely related to the dataflow graphs found in the Software Automation for Real-Time Operations (SARTOR) project led by Mok [15] and the Real-Time Producer/Consumer (RTP/C) paradigm of Jeffay [11].
Reference: [18] <author> Ritz, S., Meyer, H., </author> <title> "Exploring the design space of a DSP-based mobile satellite receiver", </title> <booktitle> Proc. </booktitle> <address> of ICSPAT 94 , Dallas, TX, </address> <month> Oct. </month> <year> 1994. </year>
Reference-contexts: An important aspect in controlling memory usage is the node execution schedule since this impacts the buffer requirements of the edges in the graph. The state of the art in minimizing the memory requirements of a signal processing graph is to create a node execution schedule off-line <ref> [14, 18, 23, 19, 3] </ref>. In contrast, our approach is to use a dynamic, on-line scheduler for graph execution. <p> However, the differences between the two synthesis methods are dramatic. The main goal of the SDF synthesis method and related scheduling research has been to minimize memory usage by creating off-line scheduling algorithms (e.g., <ref> [14, 18, 23, 19, 3] </ref>). Off-line schedulers create a static schedule that is executed periodically (or cyclically) by the processor. <p> rest of the queues in the mobile satellite receiver graph (calculated with the RBE parameters of Table 1) are shown in Table 2 with the exception of the queues attached to input or output devices since the buffer space for these queues was ignored in the buffer calculations done by <ref> [18, 23, 19] </ref> and [3]. The buffer space required for each of these queues in our model is 1 token. When an off-line scheduler is employed, the buffer space required for each of the queues attached to input devices varies from 44 to 4,224 tokens depending on the scheduler.
Reference: [19] <author> Ritz, R., Willems, M., Meyer, H., </author> <title> "Scheduling for Optimum Data Memory Compaction in Block Diagram Oriented Software Synthesis", </title> <booktitle> Proc. of ICASSP 95 , De-troit, </booktitle> <address> MI, </address> <month> May </month> <year> 1995, </year> <pages> pp. 133-143. </pages>
Reference-contexts: An important aspect in controlling memory usage is the node execution schedule since this impacts the buffer requirements of the edges in the graph. The state of the art in minimizing the memory requirements of a signal processing graph is to create a node execution schedule off-line <ref> [14, 18, 23, 19, 3] </ref>. In contrast, our approach is to use a dynamic, on-line scheduler for graph execution. <p> However, the differences between the two synthesis methods are dramatic. The main goal of the SDF synthesis method and related scheduling research has been to minimize memory usage by creating off-line scheduling algorithms (e.g., <ref> [14, 18, 23, 19, 3] </ref>). Off-line schedulers create a static schedule that is executed periodically (or cyclically) by the processor. <p> The high speed data option of the INMARSAT-B mobile terminal is also used to provide video teleconferencing and compressed or delayed video transmission services to remote locations on land or at sea. INMARSAT mobile terminal [23]. The corresponding processing graph for this application is shown in Figure 4 <ref> [19] </ref>. The two unlabeled circles with single output queues represent the input devices receiving the satellite signal. The other unlabeled circle represents the terminal accepting the processed signal. <p> scheduled by a state-of-the-art, static scheduler, which is designed to minimize memory requirements. 6.2 Buffer Requirements In this section we present the buffer requirements of each queue in the mobile satellite receiver application and compare the total memory requirements of our synthesis of the application with the bounds reported in <ref> [19] </ref> and [3]. Due to space limitations, we derive the bounds for one queue as an example and refer the reader to Table 2 for the buffer bounds on the remaining queues. <p> rest of the queues in the mobile satellite receiver graph (calculated with the RBE parameters of Table 1) are shown in Table 2 with the exception of the queues attached to input or output devices since the buffer space for these queues was ignored in the buffer calculations done by <ref> [18, 23, 19] </ref> and [3]. The buffer space required for each of these queues in our model is 1 token. When an off-line scheduler is employed, the buffer space required for each of the queues attached to input devices varies from 44 to 4,224 tokens depending on the scheduler. <p> If a shared buffer implementation is used for the RBE task set, as assumed in the statically scheduled implementation of <ref> [19] </ref>, we can reduce the upper bound of 1,599 to 1,101.
Reference: [20] <author> Sun, J., Liu, J., </author> <title> "Synchronization Protocols in Distributed Real-Time Systems", </title> <booktitle> Proc Intl. Conference on Dist. Computing Syst., </booktitle> <month> May, </month> <year> 1996. </year>
Reference-contexts: In contrast to the off-line schedulers developed for SDF graphs, on-line scheduling of PGM graphs uses input data rates and schedulability conditions from real-time scheduling theory. The real-time literature is replete with examples in which some form of a processing graph is used to construct real-time systems <ref> [5, 6, 11, 15, 17, 22, 20, 21] </ref> (to list a few). The processing graphs of [5, 17] and [22] are task graphs in which only precedence constraints are described. An even simpler processing graph, called task chains, is employed by [6, 20] and [21]. <p> The processing graphs of [5, 17] and [22] are task graphs in which only precedence constraints are described. An even simpler processing graph, called task chains, is employed by <ref> [6, 20] </ref> and [21]. Both task graphs and task chains can be represented with PGM graphs, but this paper does not address the distributed or end-to-end latency issues of [5, 6, 17, 22, 20, 21]. <p> An even simpler processing graph, called task chains, is employed by [6, 20] and [21]. Both task graphs and task chains can be represented with PGM graphs, but this paper does not address the distributed or end-to-end latency issues of <ref> [5, 6, 17, 22, 20, 21] </ref>. From the real-time literature, the results presented in this paper are most closely related to the dataflow graphs found in the Software Automation for Real-Time Operations (SARTOR) project led by Mok [15] and the Real-Time Producer/Consumer (RTP/C) paradigm of Jeffay [11].
Reference: [21] <author> Sun, J., Liu, J., </author> <title> "Bounding Completion Times of Jobs with Arbitrary Release Times and Variable Execution Times", </title> <booktitle> Proc. of the IEEE Real-Time Systems Symposium, </booktitle> <month> Dec. </month> <year> 1996, </year> <pages> pp. 2-12. </pages>
Reference-contexts: In contrast to the off-line schedulers developed for SDF graphs, on-line scheduling of PGM graphs uses input data rates and schedulability conditions from real-time scheduling theory. The real-time literature is replete with examples in which some form of a processing graph is used to construct real-time systems <ref> [5, 6, 11, 15, 17, 22, 20, 21] </ref> (to list a few). The processing graphs of [5, 17] and [22] are task graphs in which only precedence constraints are described. An even simpler processing graph, called task chains, is employed by [6, 20] and [21]. <p> The processing graphs of [5, 17] and [22] are task graphs in which only precedence constraints are described. An even simpler processing graph, called task chains, is employed by [6, 20] and <ref> [21] </ref>. Both task graphs and task chains can be represented with PGM graphs, but this paper does not address the distributed or end-to-end latency issues of [5, 6, 17, 22, 20, 21]. <p> An even simpler processing graph, called task chains, is employed by [6, 20] and [21]. Both task graphs and task chains can be represented with PGM graphs, but this paper does not address the distributed or end-to-end latency issues of <ref> [5, 6, 17, 22, 20, 21] </ref>. From the real-time literature, the results presented in this paper are most closely related to the dataflow graphs found in the Software Automation for Real-Time Operations (SARTOR) project led by Mok [15] and the Real-Time Producer/Consumer (RTP/C) paradigm of Jeffay [11]. <p> Clearly neither a single periodic nor sporadic task can model node v. It is less obvious that three sporadic tasks are insufficient to model the execution of node v efficiently. As identified in <ref> [21] </ref>, jitter caused by the execution of other nodes can create an execution pattern that has a much less than expected inter execution time for a particular node.
Reference: [22] <author> Spuri, M., Stankovic, J.A., </author> <title> "How to Integrate Precedence Constraints and Shared Resources in Real-Time Scheduling", </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol. 43, No. 12, </volume> <month> Dec. </month> <year> 1994, </year> <pages> pp. 1407-1412. </pages>
Reference-contexts: In contrast to the off-line schedulers developed for SDF graphs, on-line scheduling of PGM graphs uses input data rates and schedulability conditions from real-time scheduling theory. The real-time literature is replete with examples in which some form of a processing graph is used to construct real-time systems <ref> [5, 6, 11, 15, 17, 22, 20, 21] </ref> (to list a few). The processing graphs of [5, 17] and [22] are task graphs in which only precedence constraints are described. An even simpler processing graph, called task chains, is employed by [6, 20] and [21]. <p> The real-time literature is replete with examples in which some form of a processing graph is used to construct real-time systems [5, 6, 11, 15, 17, 22, 20, 21] (to list a few). The processing graphs of [5, 17] and <ref> [22] </ref> are task graphs in which only precedence constraints are described. An even simpler processing graph, called task chains, is employed by [6, 20] and [21]. <p> An even simpler processing graph, called task chains, is employed by [6, 20] and [21]. Both task graphs and task chains can be represented with PGM graphs, but this paper does not address the distributed or end-to-end latency issues of <ref> [5, 6, 17, 22, 20, 21] </ref>. From the real-time literature, the results presented in this paper are most closely related to the dataflow graphs found in the Software Automation for Real-Time Operations (SARTOR) project led by Mok [15] and the Real-Time Producer/Consumer (RTP/C) paradigm of Jeffay [11].
Reference: [23] <author> Zivojnovic, V., Ritz, S., Meyer, H., </author> <title> "High Performance DSP Software Using Data-Flow Graph Transformations", </title> <booktitle> Proc. of ASILOMAR 94 , Nov. </booktitle> <year> 1994. </year> <month> 12 </month>
Reference-contexts: An important aspect in controlling memory usage is the node execution schedule since this impacts the buffer requirements of the edges in the graph. The state of the art in minimizing the memory requirements of a signal processing graph is to create a node execution schedule off-line <ref> [14, 18, 23, 19, 3] </ref>. In contrast, our approach is to use a dynamic, on-line scheduler for graph execution. <p> However, the differences between the two synthesis methods are dramatic. The main goal of the SDF synthesis method and related scheduling research has been to minimize memory usage by creating off-line scheduling algorithms (e.g., <ref> [14, 18, 23, 19, 3] </ref>). Off-line schedulers create a static schedule that is executed periodically (or cyclically) by the processor. <p> The high speed data option of the INMARSAT-B mobile terminal is also used to provide video teleconferencing and compressed or delayed video transmission services to remote locations on land or at sea. INMARSAT mobile terminal <ref> [23] </ref>. The corresponding processing graph for this application is shown in Figure 4 [19]. The two unlabeled circles with single output queues represent the input devices receiving the satellite signal. The other unlabeled circle represents the terminal accepting the processed signal. <p> rest of the queues in the mobile satellite receiver graph (calculated with the RBE parameters of Table 1) are shown in Table 2 with the exception of the queues attached to input or output devices since the buffer space for these queues was ignored in the buffer calculations done by <ref> [18, 23, 19] </ref> and [3]. The buffer space required for each of these queues in our model is 1 token. When an off-line scheduler is employed, the buffer space required for each of the queues attached to input devices varies from 44 to 4,224 tokens depending on the scheduler.
References-found: 23

