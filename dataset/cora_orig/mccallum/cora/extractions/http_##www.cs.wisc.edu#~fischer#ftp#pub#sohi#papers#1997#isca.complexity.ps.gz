URL: http://www.cs.wisc.edu/~fischer/ftp/pub/sohi/papers/1997/isca.complexity.ps.gz
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/sohi/papers/1997/
Root-URL: http://www.cs.wisc.edu
Email: subbarao@cs.wisc.edu  jouppi@pa.dec.com  jes@ece.wisc.edu  
Title: Complexity-Effective Superscalar Processors  
Author: Subbarao Palacharla Norman P. Jouppi J. E. Smith 
Address: Madison, WI 53706, USA  Palo Alto, CA 94301, USA  Madison, WI 53706, USA  
Affiliation: Computer Sciences Department University of Wisconsin-Madison  Western Research Laboratory Digital Equipment Corporation  Dept. of Electrical and Computer Engg. University of Wisconsin-Madison  
Abstract: The performance tradeoff between hardware complexity and clock speed is studied. First, a generic superscalar pipeline is defined. Then the specific areas of register renaming, instruction window wakeup and selection logic, and operand bypassing are analyzed. Each is modeled and Spice simulated for feature sizes of 0:8m, 0:35m, and 0:18m. Performance results and trends are expressed in terms of issue width and window size. Our analysis indicates that window wakeup and selection logic as well as operand bypass logic are likely to be the most critical in the future. A microarchitecture that simplifies wakeup and selection logic is proposed and discussed. This implementation puts chains of dependent instructions into queues, and issues instructions from multiple queues in parallel. Simulation shows little slowdown as compared with a completely flexible issue window when performance is measured in clock cycles. Furthermore, because only instructions at queue heads need to be awakened and selected, issue logic is simplified and the clock cycle is faster consequently overall performance is improved. By grouping dependent instructions together, the proposed microarchitecture will help minimize performance degradation due to slow bypasses in future wide-issue machines. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. S. Ahuja, D. W. Clark, and A. Rogers. </author> <title> The Performance Impact of Incomplete Bypassing in Processor Pipelines. </title> <booktitle> In Proceedings of the 28th Annual International Symposium on Microarchitecture, </booktitle> <month> Novem-ber </month> <year> 1995. </year>
Reference-contexts: The number of bypass paths required is determined by the depth of the pipeline and the issue width of the microarchitec-ture. As pointed out in <ref> [1] </ref>, if IW is the issue width, and if there are S pipestages after the first result-producing stage, then a fully bypassed design would require (2 fi IW 2 fi S) bypass paths assuming 2-input functional units. In other words, the number of bypass paths grows quadratically with issue width. <p> Results presented in table Table 2 show that this is feasible for a 4-way machine. However, bypass delay can easily become a bottleneck for wider issue-widths. One solution is to include only a proper subset of bypass paths <ref> [1] </ref>, and take a penalty for those that are not present. For an 8-way machine with deep pipelines, this would exclude a large number of bypass paths. Another solution is to generalize the method used in the DEC 21264 [10] and use multiple copies of the register file.
Reference: [2] <author> C. Asato, R. Montoye, J. Gmuender, E. W. Simmons, A. Ike, and J. Za-sio. </author> <title> A 14-port 3.8ns 116-word 64b Read-Renaming Register File. </title> <booktitle> In 1995 IEEE International Sold-State Circuits Conference Digest of Technical Papers, </booktitle> <pages> pages 104-105, </pages> <month> February </month> <year> 1995. </year>
Reference-contexts: The number of entries in the map table is equal to the number of logical registers. * CAM scheme An alternate scheme for register renaming uses a CAM (content-addressable memory) [19] to store the current mappings. Such a scheme is implemented in the HAL SPARC <ref> [2] </ref> and the DEC 21264 [10]. The number of entries in the CAM is equal to the number of physical registers.
Reference: [3] <author> Mark T. Bohr. </author> <title> Interconnect Scaling The Real Limiter to High Performance ULSI. </title> <booktitle> In 1995 International Electron Devices Meeting Technical Digest, </booktitle> <pages> pages 241-244, </pages> <year> 1995. </year>
Reference-contexts: We also study the impact of the technology trend towards smaller feature sizes. The complexity analysis shows that logic associated with the issue window and data bypasses are likely to be key limiters of clock speed since smaller feature sizes cause wire delays to dominate overall delay <ref> [20, 3] </ref>. Taking sources of complexity into account, we propose and evaluate a new microarchitecture. This microarchitecture is called dependence-based because it focuses on grouping dependent instructions rather than independent ones, as is often the case in superscalar implementations.
Reference: [4] <author> Doug Burger, Todd M. Austin, and Steve Bennett. </author> <title> Evaluating Future Microprocessors: The Simplescalar Tool Set. </title> <note> Technical Report CS-TR-96-1308 (Available from http://www.cs.wisc.edu/trs.html), University of Wisconsin-Madison, </note> <month> July </month> <year> 1996. </year>
Reference-contexts: The proposed microarchitecture has 8 FIFOs, with each FIFO having 8-entries. The issue window of the conventional processor has 64 entries. Both microarchitectures can decode, rename, and execute a maximum of 8 instructions per cycle. The timing simulator, a modified version of SimpleScalar <ref> [4] </ref>, is detailed in Table 3.
Reference: [5] <author> M. Butler and Y. N. Patt. </author> <title> An Investigation of the Performance of Various Dynamic Scheduling Techniques. </title> <booktitle> In Proceedings of the 25th Annual International Symposium on Microarchitecture, </booktitle> <pages> pages 1-9, </pages> <month> De-cember </month> <year> 1992. </year>
Reference-contexts: A selection policy is used to decide which of the requesting instructions is granted. An example selection policy is oldest first - the ready instruction that occurs earliest in program order is granted 5 the functional unit. Butler and Patt <ref> [5] </ref> studied various policies for scheduling ready instructions and found that overall performance is largely independent of the selection policy. The HP PA-8000 uses a selection policy that is based on the location of the instruction in the window.
Reference: [6] <author> Keith I. Farkas, Norman P. Jouppi, and Paul Chow. </author> <title> Register File Design Considerations in Dynamically Scheduled Processors. </title> <booktitle> In Proceedings of the Second IEEE Symposium on High-Performance Computer Architecture, </booktitle> <month> February </month> <year> 1996. </year>
Reference-contexts: There are other important pieces of pipeline logic that are not considered in this paper, even though their delay is a function of dispatch/issue width. In most cases, their delay has been considered elsewhere. These include register files and caches. Farkas et. al. <ref> [6] </ref> study how the access time of the register file varies with the number of registers and the number of ports. The access time of a cache is a function of the size of the cache and the associativity of the cache.
Reference: [7] <author> Linley Gwennap. </author> <title> Speed Kills? Not for RISC Processors. </title> <type> Microprocessor Report, </type> <institution> 7(3):3, </institution> <month> March </month> <year> 1993. </year>
Reference-contexts: These two camps are often referred to as brainiacs and speed demons taken from an editorial in Microprocessor Report <ref> [7] </ref>.
Reference: [8] <author> Linley Gwennap. </author> <title> HAL Reveals Multichip SPARC Processor. </title> <type> Microprocessor Report, 9(3), </type> <month> March </month> <year> 1995. </year>
Reference-contexts: The MIPS R10000 [22] and the DEC 21264 [10] are real implementations that directly fit this model. Hence, the structures identified above apply to these two processors. On the other hand, the Intel Pentium Pro [9], the HP PA-8000 [12], the PowerPC 604 [16], and the HAL SPARC64 <ref> [8] </ref> do not completely fit the baseline model. These processors are based on a microarchitecture where the reorder buffer holds non-committed, renamed register values. In contrast, the baseline microarchitec-ture uses the physical register file for both committed and noncommitted values.
Reference: [9] <author> Linley Gwennap. </author> <title> Intel's P6 Uses Decoupled Superscalar Design. </title> <type> Microprocessor Report, 9(2), </type> <month> February </month> <year> 1995. </year>
Reference-contexts: The MIPS R10000 [22] and the DEC 21264 [10] are real implementations that directly fit this model. Hence, the structures identified above apply to these two processors. On the other hand, the Intel Pentium Pro <ref> [9] </ref>, the HP PA-8000 [12], the PowerPC 604 [16], and the HAL SPARC64 [8] do not completely fit the baseline model. These processors are based on a microarchitecture where the reorder buffer holds non-committed, renamed register values.
Reference: [10] <author> Jim Keller. </author> <title> The 21264: A Superscalar Alpha Processor with Out-of-Order Execution, October 1996. </title> <booktitle> 9th Annual Microprocessor Forum, </booktitle> <address> San Jose, California. </address>
Reference-contexts: The MIPS R10000 [22] and the DEC 21264 <ref> [10] </ref> are real implementations that directly fit this model. Hence, the structures identified above apply to these two processors. On the other hand, the Intel Pentium Pro [9], the HP PA-8000 [12], the PowerPC 604 [16], and the HAL SPARC64 [8] do not completely fit the baseline model. <p> Such a scheme is implemented in the HAL SPARC [2] and the DEC 21264 <ref> [10] </ref>. The number of entries in the CAM is equal to the number of physical registers. Each entry contains two fields: the logical register designator that is mapped to the physical register represented by the entry and a valid bit that is set if the current mapping is valid. <p> For an 8-way machine with deep pipelines, this would exclude a large number of bypass paths. Another solution is to generalize the method used in the DEC 21264 <ref> [10] </ref> and use multiple copies of the register file. This is the cluster method referred to in Section 4.4.
Reference: [11] <author> Gregory A. Kemp and Manoj Franklin. PEWs: </author> <title> A Decentralized Dynamic Scheduler for ILP Processing. </title> <booktitle> In Proceedings of the International Conference on Parallel Processing, </booktitle> <volume> volume I, </volume> <pages> pages 239-246, </pages> <year> 1996. </year>
Reference-contexts: In this particular case, we treat each 32-entry window as eight FIFOs with four slots each. Note that these FIFOs are a conceptual device used only by the assignment heuristic in reality, instructions issue from the window with complete flexibility. Kemp and Franklin <ref> [11] </ref> studied an organization called PEWs (Parallel Execution Windows) for simplifying the logic associated with a central window. PEWs simplifies window logic by splitting the central instruction window among multiple windows much like the clustered microarchitecture described above.
Reference: [12] <author> Ashok Kumar. </author> <title> The HP-PA8000 RISC CPU: A High Performance Out-of-Order Processor. </title> <booktitle> In Proceedings of the Hot Chips VIII, </booktitle> <pages> pages 9-20, </pages> <month> August </month> <year> 1996. </year>
Reference-contexts: The MIPS R10000 [22] and the DEC 21264 [10] are real implementations that directly fit this model. Hence, the structures identified above apply to these two processors. On the other hand, the Intel Pentium Pro [9], the HP PA-8000 <ref> [12] </ref>, the PowerPC 604 [16], and the HAL SPARC64 [8] do not completely fit the baseline model. These processors are based on a microarchitecture where the reorder buffer holds non-committed, renamed register values. In contrast, the baseline microarchitec-ture uses the physical register file for both committed and noncommitted values.
Reference: [13] <author> Scott McFarling. </author> <title> Combining Branch Predictors. </title> <note> DEC WRL Technical Note TN-36, </note> <institution> DEC Western Research Laboratory, </institution> <year> 1993. </year>
Reference-contexts: Both microarchitectures can decode, rename, and execute a maximum of 8 instructions per cycle. The timing simulator, a modified version of SimpleScalar [4], is detailed in Table 3. Fetch width any 8 instructions I-cache Perfect instruction cache Branch Predictor McFarling's gshare <ref> [13] </ref> 4K 2-bit counters, 12 bit history unconditional control instructions predicted perfectly Issue window size 64 Max. in-flight 128 instructions Retire width 16 Functional Units 8 symmetrical units Functional Unit Latency 1 cycle Issue Mechanism out-of-order issue of up to 8 ops/cycle loads may execute when all prior store addresses are
Reference: [14] <author> Meta-Software Inc. </author> <note> HSpice User's Manual, </note> <month> June </month> <year> 1987. </year>
Reference-contexts: However, we believe that the relative delays between different structures should be more accurate than the absolute delays. 1 International Solid-State and Circuits Conference. 2 In the second phase we implemented the circuit and optimized the circuit for speed. We used the Hspice circuit simulator <ref> [14] </ref> from Meta-Software to simulate the circuits. Primarily, static logic was used. However, in situations where dynamic logic helped in boosting the performance significantly, we used dynamic logic. For example, in the wakeup logic, a dynamic 7-input NOR gate is used for comparisons instead of a static gate.
Reference: [15] <author> Subbarao Palacharla, Norman P. Jouppi, and James E. Smith. </author> <title> Quantifying the Complexity of Superscalar Processors. </title> <note> Technical Report CS-TR-96-1328 (Available from http://www.cs.wisc.edu/trs.html), University of Wisconsin-Madison, </note> <month> November </month> <year> 1996. </year>
Reference-contexts: Layouts for the 0:35m and 0:18m process were obtained by appropriately shrinking the layouts for the 0:8m process. The Hspice models used for the three technologies are tabulated in <ref> [15] </ref>. 4 Pipeline Complexity In this section, we analyze the critical pipeline structures. The presentation for each structure begins with a description of the logical function being implemented. Then, possible implementation schemes are discussed, and one is chosen. <p> Then, possible implementation schemes are discussed, and one is chosen. Next, we summarize our analysis of the overall delay in terms of the microarchitectural parameters of issue width and issue window size; a much more detailed version of the analysis appears in <ref> [15] </ref>. Finally, Hspice circuit simulation results are presented and trends are identified and compared with the earlier analysis. 4.1 Register Rename Logic Register rename logic translates logical register designators into physical register designators by accessing a map table with the logical register designator as the index. <p> Also, for the design space we are interested in, the performance was found to be comparable. Consequently, we focus on the RAM method below. A more detailed discussion of the trade-offs involved can be found in <ref> [15] </ref>. The dependence check logic proceeds in parallel with the map table access. Every logical register designator being renamed is compared against the logical destination register designators of earlier instructions in the current rename group. <p> All sources of delay are considered in detail in <ref> [15] </ref>. In the rename logic, the window size is not a factor, and the issue width affects delay through its impact on wire lengths. Increasing 3 the issue width increases the number of bitlines and wordlines in each cell thus making each cell bigger. <p> + c 1 fi IW + c 2 fi IW 2 where IW is the issue width and c 0 , c 1 , and c 2 are constants that are fixed for a given technology and instruction set architecture; derivation of the constants for each component is given in <ref> [15] </ref>. In each case, the quadratic component, resulting from the intrinsic RC delay of wires, is relatively small for the design space and technologies we explored. Hence, the decode, wordline, and bitline delays are effectively linear functions of the issue width. <p> Also, increasing issue width increases the number of comparators in each cell. Note that we assume the maximum number of tags produced per cycle is equal to the maximum issue width. In simplified form (see <ref> [15] </ref> for a more detailed analysis), the time taken to drive the tags is: T tagdrive = c 0 + (c 1 + c 2 fi IW ) fi W IN SIZE + (c 3 + c 4 fi IW + c 5 fi IW ) fi W IN SIZE 2 <p> The match OR time is the time taken to OR the match lines, and the number of matchlines is a linear function of issue width. Both of these (refer to <ref> [15] </ref>) have a delay: T tagmatch ; T matchOR = c 0 + c 1 fi IW + c 2 fi IW 2 However, in both cases the quadratic term is very small for the design space we consider, so these delays are linear functions of issue width. 4.2.3 Spice Results <p> We assume the same selection policy in our study. 4.3.1 Structure The basic structure of selection logic is shown in Figure 7. Modifications to this scheme for handling multiple functional units of the same type are discussed in <ref> [15] </ref>. Selection logic consists of a tree of arbiters that works in two phases. In the first phase, request signals are propagated up the tree. Each cell raises the anyreq signal if any of its input request signals is high. <p> Hence, the selection delay depends on the height of the arbitration tree and can be written as (see <ref> [15] </ref> for a more detailed analysis): T selection = c 0 + c 1 fi log 4 (W IN SIZE) where c 0 and c 1 are constants determined by the propagation delays of a single arbiter. <p> Table 1 shows the results. Wire lengths are shown in terms of , where is half the feature size. The delays are the same for the three technologies since wire delays are constant according to the scaling model assumed. See <ref> [15] </ref> for the detailed data and analysis. 4.4.4 Alternative Layouts The results presented above assume a particular layout; the functional units are placed on either side of the register file. However, as mentioned before, the length of the result wires is a function of the layout. <p> All the other structures either will not cause a clock cycle problem, or if they do, they can be pipelined. The pipelining aspects of these structures is discussed in <ref> [15] </ref>. This additional pipelining can cause some performance impact, although it is beyond the scope of this paper to evaluate the exact impact. Wakeup and select together constitute what appears to be an atomic operation.
Reference: [16] <author> S. Peter Song, Marvin Denman, and Joe Chang. </author> <title> The PowerPC 604 RISC Microprocessor. </title> <booktitle> In IEEE Micro, </booktitle> <pages> pages 8-17, </pages> <month> October </month> <year> 1995. </year>
Reference-contexts: The MIPS R10000 [22] and the DEC 21264 [10] are real implementations that directly fit this model. Hence, the structures identified above apply to these two processors. On the other hand, the Intel Pentium Pro [9], the HP PA-8000 [12], the PowerPC 604 <ref> [16] </ref>, and the HAL SPARC64 [8] do not completely fit the baseline model. These processors are based on a microarchitecture where the reorder buffer holds non-committed, renamed register values. In contrast, the baseline microarchitec-ture uses the physical register file for both committed and noncommitted values.
Reference: [17] <author> N. Vasseghi et al. </author> <title> 200 MHz Superscalar RISC Processor Circuit Design Issues. </title> <booktitle> In 1996 IEEE International Sold-State Circuits Conference Digest of Technical Papers, </booktitle> <pages> pages 356-357, </pages> <month> February </month> <year> 1996. </year>
Reference-contexts: We found the optimal number of arbiter inputs to be four in our case, so the logarithm is base 4. The selection logic in the MIPS R10000, described in <ref> [17] </ref>, is also based on four-input arbiter cells. 4.3.3 Spice Results three components. From the graph we can see that for all the three technologies, the delay increases logarithmically with window size.
Reference: [18] <author> Tomohisa Wada, Suresh Rajan, and Steven A. Przybylski. </author> <title> An Analytical Access Time Model for On-Chip Cache Memories. </title> <journal> IEEE Journal of Solid-State Circuits, </journal> <volume> 27(8) </volume> <pages> 1147-1156, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: Farkas et. al. [6] study how the access time of the register file varies with the number of registers and the number of ports. The access time of a cache is a function of the size of the cache and the associativity of the cache. Wada et. al. <ref> [18] </ref> and Wilton and Jouppi [21] have developed detailed models that estimate the access time of a cache given its size and associativity. 2.2 Current Implementations The structures identified above were presented in the context of the baseline superscalar model shown in Figure 1.
Reference: [19] <author> Neil H.E. Weste and Kamran Eshraghian. </author> <title> Principles of CMOS VLSI Design. </title> <publisher> Addison Wesley, </publisher> <address> second edition, </address> <year> 1993. </year>
Reference-contexts: The number of entries in the map table is equal to the number of logical registers. * CAM scheme An alternate scheme for register renaming uses a CAM (content-addressable memory) <ref> [19] </ref> to store the current mappings. Such a scheme is implemented in the HAL SPARC [2] and the DEC 21264 [10]. The number of entries in the CAM is equal to the number of physical registers.
Reference: [20] <author> Neil C. Wilhelm. </author> <title> Why Wire Delays Will No Longer Scale for VLSI Chips. </title> <type> Technical Report SMLI TR-95-44, </type> <institution> Sun Microsystems Laboratories, </institution> <month> August </month> <year> 1995. </year>
Reference-contexts: We also study the impact of the technology trend towards smaller feature sizes. The complexity analysis shows that logic associated with the issue window and data bypasses are likely to be key limiters of clock speed since smaller feature sizes cause wire delays to dominate overall delay <ref> [20, 3] </ref>. Taking sources of complexity into account, we propose and evaluate a new microarchitecture. This microarchitecture is called dependence-based because it focuses on grouping dependent instructions rather than independent ones, as is often the case in superscalar implementations.
Reference: [21] <author> Steven J. E. Wilton and Norman P. Jouppi. </author> <title> An Enhanced Access and Cycle Time Model for On-Chip Caches. </title> <type> Technical Report 93/5, </type> <institution> DEC Western Research Laboratory, </institution> <month> July </month> <year> 1994. </year>
Reference-contexts: The access time of a cache is a function of the size of the cache and the associativity of the cache. Wada et. al. [18] and Wilton and Jouppi <ref> [21] </ref> have developed detailed models that estimate the access time of a cache given its size and associativity. 2.2 Current Implementations The structures identified above were presented in the context of the baseline superscalar model shown in Figure 1.
Reference: [22] <author> K. C. Yeager. </author> <title> MIPS R10000 Superscalar Microprocessor. </title> <booktitle> In IEEE Micro, </booktitle> <month> April </month> <year> 1996. </year> <month> 13 </month>
Reference-contexts: The MIPS R10000 <ref> [22] </ref> and the DEC 21264 [10] are real implementations that directly fit this model. Hence, the structures identified above apply to these two processors. <p> These two schemes, called the RAM scheme and the CAM scheme, are described next. * RAM scheme In the RAM scheme, implemented in the MIPS R10000 <ref> [22] </ref>, the map table is a register file where the logical register designator directly accesses an entry that contains the physical reg ister to which it is mapped.
References-found: 22

