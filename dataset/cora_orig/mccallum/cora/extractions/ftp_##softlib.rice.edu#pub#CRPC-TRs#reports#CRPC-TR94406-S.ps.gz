URL: ftp://softlib.rice.edu/pub/CRPC-TRs/reports/CRPC-TR94406-S.ps.gz
Refering-URL: http://www.crpc.rice.edu/CRPC/softlib/TRs_online.html
Root-URL: 
Title: A Generalized Expression Optimization Hook for C++ on High-Performance Architectures  
Author: David J. Edelsohn 
Address: Syracuse, NY 13244  
Affiliation: Northeast Parallel Architectures Center Syracuse University  
Abstract: C++ has gained broad acceptance as an object-oriented evolutionary extension to the C language, but it severely constrains methods for operating on class objects by forcing all data manipulation through an interface which assumes that all basic operations can be implemented as they are written: as unary or binary operators. C++ allows great flexibility in the creation of complex data structures which can perform the same functionality as built-in types of many other languages, but unfortunately it does not allow an equivalent level of flexibility so that operators acting on those data types can achieve the same level of efficiency as their counterparts in language-level implementations. This limitation becomes even more pronounced on high-performance computers whose advanced features require considerable cooperation between the algorithm, the compiler, and the architecture for maximum performance. This paper describes a language enhancement proposal: a special member function which interacts with overloaded operators as complete expressions. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A.V. Aho, R. Sethi, and J.D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, </address> <year> 1986. </year>
Reference-contexts: The fundamental problem stems from C++'s bottom-up, hierarchical approach to building objects and methods (functions for accessing and modifying objects). Most compilers internally develop a complete parse tree and basic-block structure which is the essential information necessary to implement deferred expression and/or block evaluation producing the expected performance improvement <ref> [1] </ref>. One approach to circumvent the language's limitations creates libraries which contain compilers that generate efficient machine code at runtime (Runtime Code Generation or RTCG)[12]. Unfortunately this requires duplicating much of the work performed during the initial compilation phase without having access to additional knowledge in the original source code.
Reference: [2] <author> I. Angus. </author> <title> Applications Demand Class-Specific Optimizations: The C++ Compiler Can Do More. </title> <booktitle> In The Object Oriented Numerics Conference, </booktitle> <address> Sunriver, Oregon, </address> <month> April 25-27 </month> <year> 1993. </year>
Reference-contexts: Professional, commercial libraries need not be written in C++ and a good case can be made for compiler vendors providing a private or public back-door into the compiler to better handle these cases <ref> [2] </ref>. This, however, clearly creates a two-tiered system preventing the average user from generating highly efficient libraries without learning about language grammars and optimization patterns described by this essentially new language, assuming that the compiler allows public access to this knowledge.
Reference: [3] <author> F. Bodin, P. Beckman, D. Gannon, et al. Sage++: </author> <title> A Class Library for Building Fortran 90 and C++ Restructuring Tools. </title> <type> Technical report, </type> <institution> Indiana University, </institution> <year> 1994. </year>
Reference: [4] <author> P. Brezany, M. Gerndt, V. Sipkova, and H.P. Zima. </author> <title> SUPERB Support for Irregular Scientific Computation. </title> <booktitle> In Proceedings of the Scalable High Performance Computing Conference, </booktitle> <pages> pages 314-321. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> April </month> <year> 1992. </year>
Reference-contexts: has been devoted to addressing some of these problems through better policies on the reuse of temporary variables and special optimizations, such as loop jamming, which try to recognize related, adjacent loops and merge them into a single outer loop to provide more opportunities for the other optimizations listed above <ref> [4, 13] </ref>. C++ makes this very difficult, though, because of the considerable use of pointers and references which hide the effect of many operations and prevent the compiler from making important assumptions allowing code motion and merging.
Reference: [5] <author> K.G. Budge. PHYSLIB: </author> <title> A C++ Tensor Class Library. </title> <type> Technical Report SAND91-1752, </type> <institution> Sandia National Laboratory, Sandia, </institution> <address> New Mexico, </address> <year> 1991. </year>
Reference-contexts: Hierarchies of interrelated objects frequently are constructed, such as the now classic examples of drawing a shape on a graphics output device, or arrays of objects manipulated as single, aggregate objects, such as array and matrix class libraries <ref> [5, 15, 8] </ref>, which can provide the functionality described by Golub [10].
Reference: [6] <author> K.G. Budge, J.S. Peery, and A.C. Robinson. </author> <title> High-Performance Scientific Computing Using C++. </title> <booktitle> In USENIX C++ Technical Conference Proceedings, </booktitle> <pages> pages 131-150, </pages> <address> Portland, Oregon, </address> <month> August </month> <year> 1992. </year> <institution> USENIX Association. </institution>
Reference-contexts: Loop jamming to permit chaining requires C++ to inline loops instead of generating function calls; rearranging the code so that memory allocation and deallocation are segregated from the loops, which itself requires allocation/deallocation with neither side effects nor memory aliases, and then chaining the loops on vector architectures <ref> [6] </ref>. Unless the compiler merges the loops, chaining on scalar architectures still is not accomplished. C++ provides a programmer with great expressive freedom which leads to many different ways to describe identical functionality | not all of which the compiler can recognize and optimize. <p> Another approach creates specialized class operators which internally optimize multiple operations in their implementation. This, of course, simply provides inelegant, manual optimization in the C++ environment, requiring considerable additional effort and attention from the programmer <ref> [6] </ref>. Yet another technique which somewhat combines the previous two pre-computes canonical tables of mixed operators up to an arbitrary depth, intercepts expressions at runtime, and maps appropriate combinations of operators to the optimized table [14]. The arbitrarily large and static table can pose significant constraints on this approach.
Reference: [7] <author> R.B. Davies. </author> <title> Notes for the Library Working Group of WG21/X3J16. Presented at C++ Standards Committee Meeting, </title> <month> March </month> <year> 1991. </year>
Reference-contexts: The arbitrarily large and static table can pose significant constraints on this approach. Deferred expression evaluation implementations of the operators construct a parse tree at runtime instead of directly performing the actual operation <ref> [7] </ref>. The assignment operation implementation then evaluates the parse tree and performs each of the operations with the additional optimization manually coded into the function using full knowledge of the semantics for the objects' operators.
Reference: [8] <author> J.J. Dongarra, R. Pozo, and D. Walker. La--pack++: </author> <title> A Design Overview of Object-Oriented Extensions for High Performance Linear Algebra. </title> <type> Technical report, </type> <institution> Oak Ridge National Laboratory, </institution> <year> 1993. </year>
Reference-contexts: Hierarchies of interrelated objects frequently are constructed, such as the now classic examples of drawing a shape on a graphics output device, or arrays of objects manipulated as single, aggregate objects, such as array and matrix class libraries <ref> [5, 15, 8] </ref>, which can provide the functionality described by Golub [10].
Reference: [9] <author> High Performance Fortran Forum. </author> <title> HPF Language Specification. </title> <type> Technical Report CRPC-TR 92225, </type> <institution> Center for Research on Parallel Computation, Rice University, Houston, Texas, </institution> <month> May </month> <year> 1993. </year>
Reference-contexts: Up to five temporary array variables might be created reflecting each of the intermediate results and architectural features such as special add-multiply or vector-chaining instructions could not be utilized. Languages such as Fortran 90 [11] and High Performance Fortran <ref> [9] </ref>, both with native array types, can recognize an expression or multiple expressions as a single, related entity which only requires one outer loop, scalar temporaries, and the application of special instruction modes. C++ operators act upon objects either singly or pairwise.
Reference: [10] <author> G.H. Golub and C.F. Van Loan. </author> <title> Matrix Computations, 2nd ed. </title> <publisher> Johns Hopkins Press, </publisher> <address> Baltimore, </address> <year> 1989. </year>
Reference-contexts: Hierarchies of interrelated objects frequently are constructed, such as the now classic examples of drawing a shape on a graphics output device, or arrays of objects manipulated as single, aggregate objects, such as array and matrix class libraries [5, 15, 8], which can provide the functionality described by Golub <ref> [10] </ref>. The C++ language provides for the creation of complicated, composite objects automatically by implicitly calling the necessary constructors for the object and all of its constituent pieces in the appropriate order, and a symmetric reverse process available to decommission the object.
Reference: [11] <institution> ISO/IEC 1539:1991(E) and ANSI X3.198-1992. </institution>
Reference-contexts: Up to five temporary array variables might be created reflecting each of the intermediate results and architectural features such as special add-multiply or vector-chaining instructions could not be utilized. Languages such as Fortran 90 <ref> [11] </ref> and High Performance Fortran [9], both with native array types, can recognize an expression or multiple expressions as a single, related entity which only requires one outer loop, scalar temporaries, and the application of special instruction modes. C++ operators act upon objects either singly or pairwise.
Reference: [12] <author> D. Keppel, S.J. Eggers, and R.R. Henry. </author> <title> A Case for Runtime Code Generation. </title> <type> Technical Report 91-11-04, </type> <institution> Department of Computer Science and Engineering, University of Washington, </institution> <address> Seattle, </address> <month> November </month> <year> 1991. </year>
Reference: [13] <author> C. Polychronopoulos, M. Girkar, M. Haghighat, et al. </author> <title> The Structure of Parafrase-2: An Advanced Parallelizing Compiler for C and Fortran. </title> <editor> In D. Gelernter, A. Nicolau, and D. Padua, editors, </editor> <booktitle> Languages and Compilers for Parallel Computing, </booktitle> <pages> pages 423-453. </pages> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: has been devoted to addressing some of these problems through better policies on the reuse of temporary variables and special optimizations, such as loop jamming, which try to recognize related, adjacent loops and merge them into a single outer loop to provide more opportunities for the other optimizations listed above <ref> [4, 13] </ref>. C++ makes this very difficult, though, because of the considerable use of pointers and references which hide the effect of many operations and prevent the compiler from making important assumptions allowing code motion and merging.
Reference: [14] <author> D. Quinlan and R. Parsons. </author> <title> A++/P++ Array Classes for Architecture Independent Finite Difference Computations. </title> <booktitle> In The Object Oriented Numerics Conference, </booktitle> <address> Sunriver, Oregon, </address> <month> April </month> <year> 1994. </year>
Reference-contexts: Yet another technique which somewhat combines the previous two pre-computes canonical tables of mixed operators up to an arbitrary depth, intercepts expressions at runtime, and maps appropriate combinations of operators to the optimized table <ref> [14] </ref>. The arbitrarily large and static table can pose significant constraints on this approach. Deferred expression evaluation implementations of the operators construct a parse tree at runtime instead of directly performing the actual operation [7].
Reference: [15] <author> Dyad Software. </author> <title> M++ Matrix Class Library Reference Manual. </title> <year> 1991. </year>
Reference-contexts: Hierarchies of interrelated objects frequently are constructed, such as the now classic examples of drawing a shape on a graphics output device, or arrays of objects manipulated as single, aggregate objects, such as array and matrix class libraries <ref> [5, 15, 8] </ref>, which can provide the functionality described by Golub [10].
References-found: 15

