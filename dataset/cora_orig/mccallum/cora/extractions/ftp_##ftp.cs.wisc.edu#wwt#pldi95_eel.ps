URL: ftp://ftp.cs.wisc.edu/wwt/pldi95_eel.ps
Refering-URL: http://www.cs.wisc.edu/~schnarr/SADL.html
Root-URL: 
Date: June 1995.  
Note: To appear: SIGPLAN Conference on Programming Language Design and Implementation (PLDI),  
Abstract: EEL (Executable Editing Library) is a library for building tools to analyze and modify an executable (compiled) program. The systems and languages communities have built many tools for error detection, fault isolation, architecture translation, performance measurement, simulation, and optimization using this approach of modifying executables. Currently, however, tools of this sort are difficult and time-consuming to write and are usually closely tied to a particular machine and operating system. EEL supports a machine and system-independent editing model that enables tool builders to modify an executable without being aware of the details of the underlying architecture or operating system or being concerned with the consequences of deleting instructions or adding foreign code. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1985. </year>
Reference-contexts: EEL represents a routines body with two further 1. EEL also supports interprocedural analysis and call graphs, which are not described here. int main (int argc, char* argv []) - executable* exec = new executable (argv <ref> [1] </ref>); exec-&gt;read_contents (); routine* r; FOREACH_ROUTINE (r, exec-&gt;routines ()) - instrument (r); while (!exec-&gt;hidden_routines ()->is_empty ()) - r = exec-&gt;hidden_routines ()->first (); exec-&gt;hidden_routines ()->remove (r); instrument (r); exec-&gt;routines ()->add (r); - addr x = exec-&gt;edited_addr (exec->start_address ()); exec-&gt;write_edited_executable (st_cat (argv [1], .count), x); return (0); - void instrument (routine* r) - <p> char* argv []) - executable* exec = new executable (argv <ref> [1] </ref>); exec-&gt;read_contents (); routine* r; FOREACH_ROUTINE (r, exec-&gt;routines ()) - instrument (r); while (!exec-&gt;hidden_routines ()->is_empty ()) - r = exec-&gt;hidden_routines ()->first (); exec-&gt;hidden_routines ()->remove (r); instrument (r); exec-&gt;routines ()->add (r); - addr x = exec-&gt;edited_addr (exec->start_address ()); exec-&gt;write_edited_executable (st_cat (argv [1], .count), x); return (0); - void instrument (routine* r) - static long num = 0; cfg* g = r-&gt;control_flow_graph (); bb* b; FOREACH_BB (b, g-&gt;blocks ()) - if (1 &lt; b-&gt;succ ()->size ()) - edge* e; FOREACH_EDGE (e, b-&gt;succ ()) - e-&gt;add_code_along (incr_count (num)); num += 1; - r-&gt;produce_edited_routine (); <p> Instrumentation routines for a branch counting tool (see Srivastava and Eustace [23]). abstractions: control-ow graphs (CFGs) and instructions. A CFG is a directed graph whose nodes are basic blocks (single-entry, single-exit straight-line code sequences) and whose edges represent control ow between blocks <ref> [1] </ref>. EEL provides extensive control-ow and data-ow analysis for CFGs. Blocks contain a sequence of instructions, each of which is a machine-independent description of a machine instruction. A tool edits a CFG by deleting instructions or adding code snippets to blocks and edges.
Reference: [2] <author> Kristy Andrews and Duane Sand. </author> <title> Migrating a CISC Computer Family onto RISC via Object Code Translation. </title> <booktitle> In Proceedings of the Fifth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS V), </booktitle> <pages> pages 213222, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: In the limit, editing can replace an entire program with instructions for a different architecture. Translation is used both to migrate legacy code to new architectures (e.g., Tandem <ref> [2] </ref> and VAX [21]) and to run binaries on other systems [12]. Technology trends are increasing opportunities for editing executables. Machines, both sequential and parallel, are built almost exclusively from commodity microprocessors, which offer instructions and memory systems targeted at a 1.
Reference: [3] <author> Mark W. Bailey and Jack W. Davidson. </author> <title> A Formal Model and Specification Language for Procedure Calling Conventions. </title> <booktitle> In Conference Record of POPL 95: 22nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 298 310, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: It is not, however, a way of freeing a register across the entire program for the foreign code. Later releases of EEL will provide a mechanism to free a register. of bytes of accessed memory. Spawn is currently unaware of a systems subroutine and system call conventions <ref> [3] </ref>, so these instructions require additional processing to distin guish overloaded instruction uses. For example, the code in the figure resolves the SPARCs three overload uses of a jump instruction.
Reference: [4] <author> Thomas Ball and James R. Larus. </author> <title> Optimally Profiling and Tracing Programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(4):13191360, </volume> <month> July </month> <year> 1994. </year>
Reference-contexts: Binary translation provides machines with the operations necessary to run the vast amount of software for Intel processors. Another use of executable editing is program observation. Profiling and tracing tools, such as MIPSs pixie [22] or qpt <ref> [4] </ref>, edit executables to record execution frequencies or trace memory references. These tools are widely used to study program or system behavior (e.g., [6,8]) and computer architecture (e.g., [5,11,29]). <p> EEL represents a routine as a CFG, as opposed to a sequence of instructions, for three reasons. First, the initial application of EEL, qpt, required CFGs to implement efficient profiling and tracing by placing instrumentation on CFG edges <ref> [4] </ref>. Moreover, previous experience with simple tools showed that even they could reduce overhead by using control-ow information to place instrumentation intelligently. Second, EEL itself uses CFGs to adjust addresses in branch and jump instructions affected by editing. Most important, CFGs provide an architecture-independent way of representing control ow.
Reference: [5] <author> Anita Borg, R. E. Kessler, and David W. Wall. </author> <title> Generation and Analysis of Very Long Address Traces. </title> <booktitle> In Proceedings of the 17th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 270281, </pages> <month> May </month> <year> 1990. </year>
Reference: [6] <author> Brad Calder, Dirk Grunwald, and Benjamin Zorn. </author> <title> Quantifying Behavioral Differences Between C and C++ Programs. </title> <journal> Journal of Programming Languages, </journal> <note> 1995. To appear. </note>
Reference: [7] <author> Steve Chamberlain. libbfd: </author> <title> The Binary File Descriptor Library. Cygnus Support, </title> <note> bfd version 3.0 edition, </note> <month> April </month> <year> 1991. </year>
Reference-contexts: The first piece is a library to read and write Unix executable files. EEL currently uses the GNU bfd library <ref> [7] </ref>, which is also used by the GNU assembler, linker, and debugger (gdb). The second piece is an EEL-specific library to parse, decode, analyze, and modify binary instructions. Previous experience argued against implementing these routines by hand.
Reference: [8] <author> J. Bradley Chen and Brian N. Bershad. </author> <title> The Impact of Operating System Structure on Memory System Performance. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating System Principles (SOSP), </booktitle> <pages> pages 120133, </pages> <year> 1993. </year>
Reference: [9] <author> Jack W. Davidson and Christopher W. Fraser. </author> <title> Code Selection through Object Code Optimization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 6(4):505526, </volume> <month> October </month> <year> 1984. </year>
Reference-contexts: The syntax description is similar to the one in Ramseys retargetable debugger [18] and NJ Machine Code Toolkit. Spawn extends Ramseys work by expressing instructions semantics with a simple register-transfer description of instruction semantics <ref> [9] </ref>. Spawn descriptions are concise and easily derived from processor architecture manuals. They first describe registers and instruction fields by specifying their width and, for registers, a type for use in semantic expressions.
Reference: [10] <author> Jack W. Davidson and Christopher W. Fraser. </author> <title> Register Allocation and Exhaustive Peephole Optimization. </title> <journal> Software Practice & Experience, </journal> <volume> 14(9):857865, </volume> <month> September </month> <year> 1994. </year>
Reference-contexts: Low-level instrumentation for branch counting on a SPARC processor. 4 level (RTL) instruction description <ref> [10] </ref>. A crucial difference, however, is that a compiler writer can choose RTL operations with clean semantics and translate constructs to a sequence of operations, while each EEL instruction must capture the semantics of a machine instruction.
Reference: [11] <author> Amer Diwan, David Tarditi, and Eliot Moss. </author> <title> Memory Subsystem Performance of Programs Using Copying Garbage Collection. </title> <booktitle> In Conference Record of the Twenty-First Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 114, </pages> <month> January </month> <year> 1994. </year>
Reference: [12] <author> Tom R. Halfhill. </author> <title> Emulation: RISCs Secret Weapon. </title> <journal> Byte, </journal> <pages> pages 119130, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: In the limit, editing can replace an entire program with instructions for a different architecture. Translation is used both to migrate legacy code to new architectures (e.g., Tandem [2] and VAX [21]) and to run binaries on other systems <ref> [12] </ref>. Technology trends are increasing opportunities for editing executables. Machines, both sequential and parallel, are built almost exclusively from commodity microprocessors, which offer instructions and memory systems targeted at a 1. This process can also be performed on components of an executable (object files). <p> For example, good performance on highly-parallel superscalar or VLIW processors requires instruction scheduling tuned for a particular implementation. Rescheduling an executable (by editing) offers an attractive alternative to purchasing, distributing, managing, and updating binaries. Finally, editing offers a solution to the instruction-set compatibility issues <ref> [12] </ref> that have hindered widespread acceptance of RISC processors, despite their cost-effective performance. Binary translation provides machines with the operations necessary to run the vast amount of software for Intel processors. Another use of executable editing is program observation.
Reference: [13] <author> Reed Hastings and Bob Joyce. Purify: </author> <title> Fast Detection of Memory Leaks and Access Errors. </title> <booktitle> In Proceedings of the Winter Usenix Conference, </booktitle> <pages> pages 112, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: More recently, a tool based on EEL, Active Memory [16], dramatically lowered the cost of cache simulationto a 27x slowdownby inserting cache-miss tests before a programs memory references rather than post-processing an address trace. In addition, software development tools, such as Pure Softwares Purify <ref> [13] </ref>, detect programming errors, such as out-of-bounds memory references or memory leaks. Finally, executable editing has also been used for global register allocation and program optimization [24,25].
Reference: [14] <author> James R. Larus. </author> <title> Abstract Execution: A Technique for Efficiently Tracing Programs. </title> <journal> Software Practice & Experience, </journal> <volume> 20(12):1241 1258, </volume> <month> December </month> <year> 1990. </year>
Reference-contexts: EEL provides many inquiries about an instructions effect on a programs state (i.e., which registers it reads and writes, how it changes the program counter, or what its operation is). These inquiries provide enough information to analyze many aspects of a program. For example, address slice for address tracing <ref> [14] </ref>. Because it operates on EEL instructions, this code is similar to the original algo rithm and independent of an underlying machine.
Reference: [15] <author> James R. Larus and Thomas Ball. </author> <title> Rewriting Executable Files to Measure Program Behavior. </title> <journal> Software Practice & Experience, </journal> <volume> 24(2):197218, </volume> <month> February </month> <year> 1994. </year>
Reference-contexts: Unlike most compilers, which operate on a single file, editing can manipulate an entire program, which permits it to perform interprocedural analysis rather than stopping at procedure boundaries. Executable editing is conceptually easy, but complex in practice because of a myriad of architectural and system-specific details <ref> [15] </ref>. This complexity reduces the attractiveness of the technique by increasing the time and effort required to produce a robust tool. Ad-hoc systems are unlikely to employ reliable, general analyses for difficult constructs, such as indirect jumps. <p> However, this analysis also permits EEL to provide common functionality across vastly different systems. Larus and Ball <ref> [15] </ref> described the ad-hoc analysis used by their profiling and tracing tool qpt to instrument executable files. EEL extends the earlier work by providing a general library for manipulating executables that is not tied to a specific application. <p> A few operations modify a programs state by changing a memory location or replacing or adding a routine. Most editing, however, is performed on a routines control-ow graph, as described below. Symbol table information in executable files is typically incomplete or misleading <ref> [15] </ref>, which greatly complicates accurate analysis of a program. For example, compilers hide routines by not producing debugger symbol table information or put data tables in the text segment with a symbol table entry indistinguishable from a routines. <p> EEL uses a distinguished, zero-length basic blockafter the block containing the calls delayed instructionas a placeholder for the control transfer and possible side-effects of the subroutines body. In general, when control ow cannot be completely analyzed, run-time code ensures that control passes to the correct edited instruction <ref> [15] </ref>. EEL can perform several standard CFG analyses: dominators, natural loops, live registers, and slicing [1,28]. EEL uses them to improve the precision of control analysis and to reduce the need for run-time mechanisms. These analyses also provide an analytic basis for building tools. Consider, for example, indirect jumps. <p> Above the line is the snippets body, which contains instructions to increment a profile counter. Labels before each line (e.g., 1*) name instructions that are customized for each counter. Below the line is qpt code that inserts a counters address. 7 technique of register scavenging <ref> [15] </ref> is a way of utilizing unused registers in snippets. 1 The final parameter to a snippet is a call-back procedure, which is invoked after register allocation, but before the instructions are placed in the modified program.
Reference: [16] <author> Alvin R. Lebeck and David A. Wood. </author> <title> Active Memory: A New Abstraction for Memory-System Simulation. </title> <booktitle> In Proceedings of the 1995 ACM Sigmetrics Conference on Measurement and Modeling of Computer Systems, </booktitle> <month> May </month> <year> 1995. </year> <note> To appear. </note>
Reference-contexts: Profiling and tracing tools, such as MIPSs pixie [22] or qpt [4], edit executables to record execution frequencies or trace memory references. These tools are widely used to study program or system behavior (e.g., [6,8]) and computer architecture (e.g., [5,11,29]). More recently, a tool based on EEL, Active Memory <ref> [16] </ref>, dramatically lowered the cost of cache simulationto a 27x slowdownby inserting cache-miss tests before a programs memory references rather than post-processing an address trace. In addition, software development tools, such as Pure Softwares Purify [13], detect programming errors, such as out-of-bounds memory references or memory leaks. <p> In particular, EELs CFGs are larger (26,912 vs. 15,441 blocks 1 ), which disproportionately increases execution time because many CFG algorithms are non-linear. To date, we have used EEL to build four other tools. Alvin Lebeck and David Wood built Active Memory <ref> [16] </ref>, which is a platform for efficiently simulating memory systems. It inserts a quick test before load and store instructions to check the state of the accessed location. Different states invoke handlers to perform tasks such as cache simulation.
Reference: [17] <institution> Pure Software. United States Patent 5,193,180, </institution> <month> March </month> <year> 1993. </year>
Reference-contexts: Machines, both sequential and parallel, are built almost exclusively from commodity microprocessors, which offer instructions and memory systems targeted at a 1. This process can also be performed on components of an executable (object files). However, a patent obtained by Pure Software precludes many uses of object-file modification <ref> [17] </ref>. EEL: Machine-Independent Executable Editing James R. Larus and Eric Schnarr Computer Sciences Department University of WisconsinMadison 1210 West Dayton St. Madison, WI 53706 USA -larus,schnarr-@cs.wisc.edu This work is supported in part by Wright Laboratory Avionics Directorate, Air Force Material Command, USAF, under grant #F33615-94-1-1525 and ARPA order no.
Reference: [18] <author> Norman Ramsey and David Hanson. </author> <title> A Retargetable Debugger. </title> <booktitle> In Proceedings of the SIGPLAN 92 Conference on Programming Language Design and Implementation (PLDI), </booktitle> <pages> pages 2231, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Spawn replace annotations (in bold) in the C++ code with machine-specific code that dispatches on different instruction types and extracts or modifies instruction fields. 8 tax (i.e., encoding) and semantics. The syntax description is similar to the one in Ramseys retargetable debugger <ref> [18] </ref> and NJ Machine Code Toolkit. Spawn extends Ramseys work by expressing instructions semantics with a simple register-transfer description of instruction semantics [9]. Spawn descriptions are concise and easily derived from processor architecture manuals.
Reference: [19] <author> Steven K. Reinhardt, Mark D. Hill, James R. Larus, Alvin R. Leb-eck, James C. Lewis, and David A. Wood. </author> <title> The Wisconsin Wind Tunnel: Virtual Prototyping of Parallel Computers. </title> <booktitle> In Proceedings of the 1993 ACM Sigmetrics Conference on Measurement and Modeling of Computer Systems, </booktitle> <pages> pages 4860, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Executable editing is widely used for three purposes: emulation, observation, and optimization. An edited executable can emulate features that hardware does not provide. For example, the Wisconsin Wind Tunnel architecture simulator <ref> [19] </ref> drives a distributed, discrete-event simulation of a parallel computer from the logical cycle times of processors directly executing a parallel program. The underlying hardware (a SPARC processor in a Thinking Machines CM-5) does not provide a cycle counter or an efficient mechanism for interleaving computation and simulation. <p> Government. 2 mass market that has no need for semantically-rich protection or memory models. Although its performance is lower than hardwares, executable editing enables research by allowing new ideas, such as sandboxing or user-level shared memory <ref> [19] </ref>, to be demonstrated on existing processors and tested on real applications. Editing can also solve practical problems raised by new architectures. For example, good performance on highly-parallel superscalar or VLIW processors requires instruction scheduling tuned for a particular implementation. <p> Steven Reinhardt built a direct-execution architectural simulator called Elsie. Elsie replaces loads, stores, and system calls in a program with simulator calls (using EEL) and then loads the edited executable into the simulator. Sashikanth Chandrasekaran is rewriting the Wisconsin Wind Tunnel architectural simulator <ref> [19] </ref> using EEL. We also used EEL to re-implement Blizzard-Ss fine-grain access control [20]. The old version of Blizzard-S used code from qpt to insert access-control tests. The new version greatly improves performance with several optimizations that would have been difficult to implement in the old system.
Reference: [20] <author> Ioannis Schoinas, Babak Falsafi, Alvin R. Lebeck, Steven K. Re-inhardt, James R. Larus, and David A. Wood. </author> <title> Fine-grain Access Control for Distributed Shared Memory. </title> <booktitle> In Proceedings of the Sixth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS VI), </booktitle> <pages> pages 297307, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: The Wind Tunnel system edits programs so that they update a cycle timer and return control at timer expirations. Similarly, one version of the Blizzard distributed shared-memory system <ref> [20] </ref> edits programs to insert fine-grain access tests before shared loads and stores. These tests permit data sharing at cache-block granularity, which reduces the false sharing incurred by page-granularity distributed shared-memory systems. <p> Elsie replaces loads, stores, and system calls in a program with simulator calls (using EEL) and then loads the edited executable into the simulator. Sashikanth Chandrasekaran is rewriting the Wisconsin Wind Tunnel architectural simulator [19] using EEL. We also used EEL to re-implement Blizzard-Ss fine-grain access control <ref> [20] </ref>. The old version of Blizzard-S used code from qpt to insert access-control tests. The new version greatly improves performance with several optimizations that would have been difficult to implement in the old system.
Reference: [21] <author> Richard L. Sites, Anton Chernoff, Matthew B. Kirk, Maurice P. Marks, and Scott G. Robinson. </author> <title> Binary Translation. </title> <journal> Communications of the ACM, </journal> <volume> 36(2):6981, </volume> <month> February </month> <year> 1993. </year>
Reference-contexts: In the limit, editing can replace an entire program with instructions for a different architecture. Translation is used both to migrate legacy code to new architectures (e.g., Tandem [2] and VAX <ref> [21] </ref>) and to run binaries on other systems [12]. Technology trends are increasing opportunities for editing executables. Machines, both sequential and parallel, are built almost exclusively from commodity microprocessors, which offer instructions and memory systems targeted at a 1.
Reference: [22] <author> Michael D. Smith. </author> <title> Tracing with pixie. Memo from Center for Integrated Systems, </title> <institution> Stanford Univ., </institution> <month> April </month> <year> 1991. </year>
Reference-contexts: Binary translation provides machines with the operations necessary to run the vast amount of software for Intel processors. Another use of executable editing is program observation. Profiling and tracing tools, such as MIPSs pixie <ref> [22] </ref> or qpt [4], edit executables to record execution frequencies or trace memory references. These tools are widely used to study program or system behavior (e.g., [6,8]) and computer architecture (e.g., [5,11,29]).
Reference: [23] <author> Amitabh Srivastava and Alan Eustace. </author> <title> ATOM A System for Building Customized Program Analysis Tools. </title> <booktitle> In Proceedings of the SIGPLAN 94 Conference on Programming Language Design and Implementation (PLDI), </booktitle> <pages> pages 196205, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: EEL extends the earlier work by providing a general library for manipulating executables that is not tied to a specific application. EEL also shows that many problems raised in the earlier paper can be handled with more powerful program analysis. ATOM <ref> [23] </ref> is a system that provides a simple interface to OM for adding instrumentation to programs. ATOMs interface is higher-level and more concise than EELs (or OMs), which simplifies writing tools, but provides less control over the instrumentation process. <p> ATOMs principle advantage is that foreign code can be written entirely in a high-level language. Figure 1 contains the EEL code to implement the same branch-counting application as discussed by Srivastava and Eustace <ref> [23] </ref>. The code for the 1. In the near future, EEL will supplement and verify its analysis with relocation information, when available, and will modify this information, which will permit editing of object files. 2. <p> Instrumentation routines for a branch counting tool (see Srivastava and Eustace <ref> [23] </ref>). abstractions: control-ow graphs (CFGs) and instructions. A CFG is a directed graph whose nodes are basic blocks (single-entry, single-exit straight-line code sequences) and whose edges represent control ow between blocks [1]. EEL provides extensive control-ow and data-ow analysis for CFGs.
Reference: [24] <author> Amitabh Srivastava and David Wall. </author> <title> Link-Time Optimization of Address Calculation on a 64-bit Architecture. </title> <booktitle> In Proceedings of the SIGPLAN 94 Conference on Programming Language Design and Implementation (PLDI), </booktitle> <pages> pages 4960, </pages> <month> June </month> <year> 1994. </year>
Reference: [25] <author> Amitabh Srivastava and David W. Wall. </author> <title> A practical system for in-termodule code optimization at link-time. </title> <journal> Journal of Programming Languages, </journal> <volume> 1(1):118, </volume> <month> March </month> <year> 1993. </year>
Reference-contexts: However, in most tools, the application and executable modification are intertwined and details of the latter have not been published. An exception is Srivastava and Walls OM system <ref> [25] </ref>, which is a library, similar to EEL, for modifying object files. OM internally represents instructions as RTL, which can be manipulated and translated back into machine instructions. OMs RTL and EELs instructions serve the same roles. <p> Combining classes, unfortunately, is unlikely to synthesize the semantics of CISC instructions, such as string edits. These instructions, however, are also difficult to analyze and instrument because of their dynamic behavior and internal control ow. The best representation may be a sequence of simpler instructions <ref> [25] </ref>. EEL provides many inquiries about an instructions effect on a programs state (i.e., which registers it reads and writes, how it changes the program counter, or what its operation is). These inquiries provide enough information to analyze many aspects of a program.
Reference: [26] <author> Richard M. Stallman. </author> <title> Using and Porting GNU CC. Free Software Foundation, </title> <month> October </month> <year> 1993. </year> <note> For GCC Version 2.5. </note>
Reference: [27] <author> Robert Wahbe, Steven Lucco, Thomas E. Anderson, and Susan L. Graham. </author> <title> Efficient Software-Based Fault Isolation. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating System Principles (SOSP), </booktitle> <pages> pages 203216, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: Similarly, one version of the Blizzard distributed shared-memory system [20] edits programs to insert fine-grain access tests before shared loads and stores. These tests permit data sharing at cache-block granularity, which reduces the false sharing incurred by page-granularity distributed shared-memory systems. Another emulation is software fault isolation (sandboxing) <ref> [27] </ref>, which implements protection domains by modifying code to prevent it from referencing or transferring control out of its domain. In the limit, editing can replace an entire program with instructions for a different architecture.
Reference: [28] <author> Mark Weiser. </author> <title> Program Slicing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(4):352357, </volume> <month> July </month> <year> 1984. </year>
Reference: [29] <author> Cheryl A. Wiecek. </author> <title> A Case Study of VAX-11 Instruction Set Usage for Compiler Execution. </title> <booktitle> In Proceedings of Symposium on Architectural Support for Programming Languages and Operations Systems, </booktitle> <pages> pages 177184, </pages> <month> April </month> <year> 1982. </year>
References-found: 29

