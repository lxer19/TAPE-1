URL: ftp://ftp.cs.washington.edu/homes/chambers/hybrid.ps.Z
Refering-URL: http://www.cs.washington.edu/research/projects/cecil/www/Papers/hybrid.html
Root-URL: 
Email: chambers-@cs.washington.edu  
Title: Vortex: An Optimizing Compiler for Object-Oriented Languages  
Author: Jeffrey Dean, Greg DeFouw, David Grove, Vassily Litvinov, and Craig Chambers 
Address: Box 352350, Seattle, Washington 98195-2350 USA -jdean, gdefouw, grove, vass,  
Affiliation: Department of Computer Science and Engineering University of Washington  
Abstract: Previously, techniques such as class hierarchy analysis and profile-guided receiver class prediction have been demonstrated to greatly improve the performance of applications written in pure object-oriented languages, but the degree to which these results are transferable to applications written in hybrid languages has been unclear. In part to answer this question, we have developed the Vortex compiler infrastructure, a language-independent optimizing compiler for object-oriented languages, with front-ends for Cecil, C++, Java, and Modula-3. In this paper, we describe the Vortex compilers intermediate language, internal structure, and optimization suite, and then we report the results of experiments assessing the effectiveness of different combinations of optimizations on sizable applications across these four languages. We characterize the benchmark programs in terms of a collection of static and dynamic metrics, intended to quantify aspects of the object-oriented-ness of a program. 
Abstract-found: 1
Intro-found: 1
Reference: [Agesen & Hlzle 95] <author> Ole Agesen and Urs Hlzle. </author> <title> Type Feedback vs. Concrete Type Analysis: A Comparison of Optimization Techniques for Object-Oriented Languages. </title> <booktitle> In OOPSLA95 Conference Proceedings, </booktitle> <pages> pages 91107, </pages> <address> Austin, Tx, </address> <month> October </month> <year> 1995. </year>
Reference-contexts: Diwans system also does not support selective recompilation after programming changes. Agesen and Hlzle compared the effectiveness of the Cartesian Product interprocedural class analysis algorithm [Agesen 95] with profile-guided receiver class prediction [Hlzle & Ungar 94] for Self programs <ref> [Agesen & Hlzle 95, Agesen & Hlzle 96] </ref>.
Reference: [Agesen & Hlzle 96] <author> Ole Agesen and Urs Hlzle. </author> <title> Dynamic vs. Static Optimization Techniques for Object-Oriented Languages. </title> <journal> Theory and Practice of Object Systems, </journal> <volume> 1(3), </volume> <year> 1996. </year>
Reference-contexts: Diwans system also does not support selective recompilation after programming changes. Agesen and Hlzle compared the effectiveness of the Cartesian Product interprocedural class analysis algorithm [Agesen 95] with profile-guided receiver class prediction [Hlzle & Ungar 94] for Self programs <ref> [Agesen & Hlzle 95, Agesen & Hlzle 96] </ref>.
Reference: [Agesen 95] <author> Ole Agesen. </author> <title> The Cartesian Product Algorithm: Simple and Precise Type Inference of Parametric Polymorphism. </title> <booktitle> In Proceedings ECOOP 95, </booktitle> <address> Aarhus, Denmark, </address> <month> August </month> <year> 1995. </year> <note> Springer-Verlag. </note>
Reference-contexts: Diwans system also does not support selective recompilation after programming changes. Agesen and Hlzle compared the effectiveness of the Cartesian Product interprocedural class analysis algorithm <ref> [Agesen 95] </ref> with profile-guided receiver class prediction [Hlzle & Ungar 94] for Self programs [Agesen & Hlzle 95, Agesen & Hlzle 96].
Reference: [Aho et al. 86] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <address> Addison-Wes-ley, Reading, MA, </address> <year> 1986. </year>
Reference-contexts: Also, giving each method a unique name separate from the generic functions allows direct non-dispatched calls to methods to be represented easily. 3.1.4 IL Statements Executable code in the Vortex IL is represented as a series of three-address statements <ref> [Aho et al. 86] </ref>, including the usual complement of arithmetic, logical, pointer, branching (conditional, unconditional, and indexed), and direct and indirect procedure call-related statements. In addition, a number of higher-level object-oriented notions are reified in the Vortex IL, allowing the optimizer to more easily reason about them: Message sends. <p> Loop identification: A dominator-based algorithm identifies the loops and the loop nesting structure of the procedure being compiled. (Vortex alternatively allows front-ends to provide this information directly, avoiding recomputing it in the back-end.) Vortexs IDFA framework currently requires that control ow graphs be reducible (roughly, have a single entry node) <ref> [Aho et al. 86] </ref>; the loop identification pass detects irreducible ow graphs and reports them as errors.
Reference: [Aigner & Hlzle 96] <author> Gerald Aigner and Urs Hlzle. </author> <title> Eliminating Virtual Function Calls in C++ Programs. </title> <booktitle> In Proceedings ECOOP 96, </booktitle> <address> Linz, Austria, </address> <month> August </month> <year> 1996. </year> <note> Springer-Verlag. </note>
Reference-contexts: Aigner and Hlzle implemented a prototype system to compare class hierarchy analysis and profile-guided receiver-class prediction for C++ programs <ref> [Aigner & Hlzle 96] </ref>. Their system works by first combining a C++ program composed of multiple source files to produce a single, monolithic C++ file.
Reference: [AK et al. 89] <author> Hassan At-Kaci, Robert Boyer, Patrick Lincoln, and Roger Nasr. </author> <title> Efficient Implementation of Lattice Operations. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(1):115146, </volume> <month> January </month> <year> 1989. </year>
Reference-contexts: Alternative encodings of the subclassing relationship are possible, representing different time-space tradeoffs; At-Kaci et al. provide a useful overview of efficient lattice operations that discusses many of these alternatives <ref> [AK et al. 89] </ref>. 3.1.7 Exceptions Many languages support some form of exceptional control ow: Modula-3 supports traditional exceptions, C++ and Java support object-based exceptions, and Cecil, like Smalltalk and Self, has non-local returns that allow a nested closure to return directly from its lexically-enclosing method.
Reference: [Bacon & Sweeney 96] <author> David F. Bacon and Peter F. Sweeney. </author> <title> Fast Static Analysis of C++ Virtual Function Calls. </title> <booktitle> In OOPS-LA96 Conference Proceedings, </booktitle> <address> San Jose, CA, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: in C++, one used when there was only one method with a particular name (and argument type signature) in the program, class hierarchy analysis, and rapid type analysis (an extension of class hierarchy analysis that prunes unreachable classes and methods in parallel with computing the possible targets of call sites) <ref> [Bacon & Sweeney 96] </ref>. For two of their five non-trivial benchmarks, ranging in size from 5,000 to 17,500 lines, rapid type analysis statically-bound more calls than class hierarchy analysis.
Reference: [Bieman & Zhao 95] <author> James M. Bieman and Josephine Xia Zhao. </author> <title> Reuse Through Inheritance: A Quantitative Study of C++ Software. </title> <booktitle> In Proceedings of the Symposium on Software Reusability. ACM SIGSOFT, </booktitle> <month> August </month> <year> 1995. </year> <note> Software Engineering Notes. </note>
Reference-contexts: As this value increases, we expect the overall performance impact of the optimizations to decrease. Bieman and Zhao also used the first three of these metrics (and some additional ones) in their study of inheritance in C++ applications <ref> [Bieman & Zhao 95] </ref>. They utilized the metrics to assess the amount of code reuse through inheritance in large C++ programs; in contrast, we are interested in characterizing how the structure of the inheritance hierarchy affects the need for optimization.
Reference: [Bobrow et al. 88] <author> D. G. Bobrow, L. G. DeMichiel, R. P. Gabriel, S. E. Keene, G. Kiczales, and D. A. Moon. </author> <title> Common Lisp Object System Specification X3J13. </title> <journal> SIGPLAN Notices, 28(Special Issue), </journal> <month> September </month> <year> 1988. </year>
Reference-contexts: However, some languages use other rules for method lookup (such as CLOS, which uses a left-to-right ordering of parents for resolving ambiguities <ref> [Bobrow et al. 88] </ref>), and compiling such languages would require adding back-end support for more generally computing the required partial order from the inheritance graph. C++ and Modula-3 support parameterized classes and/or methods (templates in C++ and generic modules in Modula-3). <p> The Vortex IL supports global variable declarations. A declaration specifies a representation and optionally the initial value for the variable (even if the variable is an aggregate data type). 3.1.3 Methods and Procedures The Vortex IL uses a notion of a generic function <ref> [Bobrow et al. 88] </ref> to unify the concepts of procedures, methods, and multi-methods. Each call or message maps to a single generic function. A generic function contains a set of dynamically-overloaded methods, with each method indicating where in the programs class hierarchy it is attached.
Reference: [Calder & Grunwald 94] <author> Brad Calder and Dirk Grunwald. </author> <title> Reducing Indirect Function Call Overhead in C++ Programs. </title> <booktitle> In Conference Record of POPL 94: 21st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 397408, </pages> <address> Portland, Oregon, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: Calder and Grunwald consider several ways of optimizing dynamically-dispatched calls in C++ <ref> [Calder & Grunwald 94] </ref>. They examined some characteristics of the class distributions of several C++ programs and found that although the potential polymorphism was high, the distributions seen at individual call sites were strongly peaked, suggesting that profile-guided receiver class prediction would pay off.
Reference: [Chambers & Ungar 89] <author> Craig Chambers and David Ungar. </author> <title> Customization: Optimizing Compiler Technology for Self, A Dynamically-Typed Object-Oriented Programming Language. </title> <journal> SIGPLAN Notices, </journal> <volume> 24(7):146160, </volume> <month> July </month> <year> 1989. </year> <booktitle> In Proceedings of the ACM SIGPLAN 89 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: Receiver class prediction can be driven either by information hard-wired into the compiler, as in early Smalltalk and Self implementations <ref> [Deutsch & Schiffman 84, Chambers & Ungar 89] </ref>, or by profile-derived class distributions [Hlzle & Ungar 94, Grove et al. 95], or by static examination of the programs class hierarchy [Chambers et al. 96]. <p> Splitting can eliminate these redundant tests by duplicating paths through the control ow graph starting at merges after one test and ending with the redundant test to be eliminated [Chambers & Ungar 90]. 2.4 Customization and Specialization Customization and method specialization <ref> [Chambers & Ungar 89, Lea 90, Dean et al. 95a] </ref> are techniques that also can be used to statically bind messages sent to self, by creating multiple compiled copies of a single source method, each specialized to particular receiver classes. <p> However, it places some limitations on the optimizations that the back-end can perform. In particular, because dispatch tables are not exposed at a high enough level, the back-end cannot perform optimizations that would require generating different dispatch tables. Examples of such optimizations include customization and specialization <ref> [Chambers & Ungar 89, Lea 90, Dean et al. 95a] </ref> and converting a C++-style method from virtual to non-virtual to reduce the size of dispatch tables, when the back-end is able to detect that the method is not overridden anywhere in the program.
Reference: [Chambers & Ungar 90] <author> Craig Chambers and David Ungar. </author> <title> Iterative Type Analysis and Extended Message Splitting: Optimizing Dynamically-Typed Object-Oriented Programs. </title> <journal> SIGPLAN Notices, </journal> <volume> 25(6):150164, </volume> <month> June </month> <year> 1990. </year> <booktitle> In Proceedings of the ACM SIGPLAN 90 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: application development to coexist. 2.1 Intraprocedural Class Analysis Intraprocedural class analysis uses a standard iterative dataow approach to compute for each program expression a set of classes such that any runtime value of the expression is guaranteed to be an instance of one of the classes in the computed set <ref> [Johnson 88, Chambers & Ungar 90] </ref>. The analysis maintains a mapping from variables to sets of classes, and propagates this mapping through the procedures control ow graph. <p> If receiver class prediction is applied to each of these message sends, redundant class tests will be introduced. Splitting can eliminate these redundant tests by duplicating paths through the control ow graph starting at merges after one test and ending with the redundant test to be eliminated <ref> [Chambers & Ungar 90] </ref>. 2.4 Customization and Specialization Customization and method specialization [Chambers & Ungar 89, Lea 90, Dean et al. 95a] are techniques that also can be used to statically bind messages sent to self, by creating multiple compiled copies of a single source method, each specialized to particular receiver <p> This allows the callee to be fully optimized in the context of its caller and for the downstream code of the caller to benefit from any information gained by inlining the callee <ref> [Chambers & Ungar 90] </ref>. Closure optimizations: Partial dead code elimination delays closure object creations until absolutely necessary (hopefully removing them entirely from the common case paths) and environments are marked to be either heap-allocated or stack-allocated. This phase has no effect in languages lacking closures or nested procedures.
Reference: [Chambers 92] <author> Craig Chambers. </author> <title> Object-Oriented Multi-Methods in Cecil. </title> <editor> In O. Lehrmann Madsen, editor, </editor> <booktitle> Proceedings ECOOP 92, </booktitle> <volume> LNCS 615, </volume> <pages> pages 3356, </pages> <address> Utrecht, The Netherlands, June 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: and interprocedural static class analysis [Chambers & Ungar 90, Plevyak & Chien 94, Agesen & Hlzle 95], class hierarchy analysis [Dean et al. 95b], and profile-guided receiver class prediction [Hlzle & Ungar 94, Grove et al. 95] can greatly improve the performance of dynamically-typed, purely object-oriented languages such as Cecil <ref> [Chambers 92, Chambers 93] </ref>, Self [Ungar & Smith 87], and Concurrent Aggregates [Chien 93]. These techniques have been highly effective in this context, since message sends are ubiquitous and expensive; even the most primitive operations in these languages are implemented via user defined methods and dynamic dispatching.
Reference: [Chambers 93] <author> Craig Chambers. </author> <title> The Cecil Language: Specification and Rationale. </title> <type> Technical Report TR-93-03-05, </type> <institution> Department of Computer Science and Engineering. University of Washington, </institution> <month> March </month> <year> 1993. </year>
Reference-contexts: and interprocedural static class analysis [Chambers & Ungar 90, Plevyak & Chien 94, Agesen & Hlzle 95], class hierarchy analysis [Dean et al. 95b], and profile-guided receiver class prediction [Hlzle & Ungar 94, Grove et al. 95] can greatly improve the performance of dynamically-typed, purely object-oriented languages such as Cecil <ref> [Chambers 92, Chambers 93] </ref>, Self [Ungar & Smith 87], and Concurrent Aggregates [Chien 93]. These techniques have been highly effective in this context, since message sends are ubiquitous and expensive; even the most primitive operations in these languages are implemented via user defined methods and dynamic dispatching. <p> This partial ordering implements the simple rule that children override parents, which was derived from the Cecil language semantics <ref> [Chambers 93] </ref>. This can accommodate a wide range of languages whose semantics either match these or that have static typechecking rules that are more restrictive.
Reference: [Chambers et al. 95] <author> Craig Chambers, Jeffrey Dean, and David Grove. </author> <title> A Framework for Selective Recompilation in the Presence of Complex Intermodule Dependencies. </title> <booktitle> In 17th International Conference on Software Engineering, </booktitle> <address> Seattle, WA, </address> <month> April </month> <year> 1995. </year>
Reference-contexts: Our experience with Vortex has been that incremental compilation is quite practical, and that most programming changes result in very few additional files being recompiled that were not directly modified <ref> [Chambers et al. 95] </ref>. 3 Vortex Compiler Infrastructure The basic structure of the compiler is shown in Figure 1.
Reference: [Chambers et al. 96] <author> Craig Chambers, Jeffrey Dean, and David Grove. </author> <title> Whole-Program Optimization of Object-Oriented Languages. </title> <type> Technical Report TR-96-06-02, </type> <institution> Department of Computer Science and Engineering. University of Washington, </institution> <month> June </month> <year> 1996. </year>
Reference-contexts: Receiver class prediction can be driven either by information hard-wired into the compiler, as in early Smalltalk and Self implementations [Deutsch & Schiffman 84, Chambers & Ungar 89], or by profile-derived class distributions [Hlzle & Ungar 94, Grove et al. 95], or by static examination of the programs class hierarchy <ref> [Chambers et al. 96] </ref>. We use the term exhaustive class testing to refer to class-hierarchy-guided class testing, and profile-guided class prediction to refer to class testing based on dynamic profile information.
Reference: [Chien 93] <author> Andrew A. Chien. </author> <title> Concurrent Aggregates (CA): Supporting Modularity in Massively-Parallel Programs. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1993. </year>
Reference-contexts: 94, Agesen & Hlzle 95], class hierarchy analysis [Dean et al. 95b], and profile-guided receiver class prediction [Hlzle & Ungar 94, Grove et al. 95] can greatly improve the performance of dynamically-typed, purely object-oriented languages such as Cecil [Chambers 92, Chambers 93], Self [Ungar & Smith 87], and Concurrent Aggregates <ref> [Chien 93] </ref>. These techniques have been highly effective in this context, since message sends are ubiquitous and expensive; even the most primitive operations in these languages are implemented via user defined methods and dynamic dispatching.
Reference: [Click & Cooper 95] <author> Cliff Click and Keith D. Cooper. </author> <title> Combining Analyses, Combining Optimizations. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(2):181196, </volume> <month> March </month> <year> 1995. </year>
Reference-contexts: & Hennessy 92].) Analyses written separately using Vortexs framework can also be composed so that they run together simultaneously, thus alleviating potential phase-ordering problems. (Click and Cooper describe the theoretical conditions under which the resulting combination of optimizations will produce better results than repeated applications of the original separate optimizations <ref> [Click & Cooper 95] </ref>.) The major phases in Vortexs compilation of a control ow graph are: Loop identification: A dominator-based algorithm identifies the loops and the loop nesting structure of the procedure being compiled. (Vortex alternatively allows front-ends to provide this information directly, avoiding recomputing it in the back-end.) Vortexs IDFA
Reference: [Dean et al. 95a] <author> Jeffrey Dean, Craig Chambers, and David Grove. </author> <title> Selective Specialization for Object-Oriented Languages. </title> <journal> SIGPLAN Notices, </journal> <pages> pages 93102, </pages> <month> June </month> <year> 1995. </year> <booktitle> In Proceedings of the ACM SIGPLAN 95 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: Splitting can eliminate these redundant tests by duplicating paths through the control ow graph starting at merges after one test and ending with the redundant test to be eliminated [Chambers & Ungar 90]. 2.4 Customization and Specialization Customization and method specialization <ref> [Chambers & Ungar 89, Lea 90, Dean et al. 95a] </ref> are techniques that also can be used to statically bind messages sent to self, by creating multiple compiled copies of a single source method, each specialized to particular receiver classes. <p> However, it places some limitations on the optimizations that the back-end can perform. In particular, because dispatch tables are not exposed at a high enough level, the back-end cannot perform optimizations that would require generating different dispatch tables. Examples of such optimizations include customization and specialization <ref> [Chambers & Ungar 89, Lea 90, Dean et al. 95a] </ref> and converting a C++-style method from virtual to non-virtual to reduce the size of dispatch tables, when the back-end is able to detect that the method is not overridden anywhere in the program.
Reference: [Dean et al. 95b] <author> Jeffrey Dean, David Grove, and Craig Chambers. </author> <title> Optimization of Object-Oriented Programs Using Static Class Hierarchy Analysis. </title> <booktitle> In Proceedings ECOOP 95, </booktitle> <address> Aar-hus, Denmark, </address> <month> August </month> <year> 1995. </year> <note> Springer-Verlag. </note>
Reference-contexts: 1 Introduction In recent years, it has been demonstrated that intra- and interprocedural static class analysis [Chambers & Ungar 90, Plevyak & Chien 94, Agesen & Hlzle 95], class hierarchy analysis <ref> [Dean et al. 95b] </ref>, and profile-guided receiver class prediction [Hlzle & Ungar 94, Grove et al. 95] can greatly improve the performance of dynamically-typed, purely object-oriented languages such as Cecil [Chambers 92, Chambers 93], Self [Ungar & Smith 87], and Concurrent Aggregates [Chien 93]. <p> as is the case in statically-typed languages like C++, Modula-3, and Java, is insufficient on its own to enable intraprocedural class analysis to statically bind the message send, since the possibility of an overriding method defined on a subclass cannot be ruled out. 2.2 Class Hierarchy Analysis Class hierarchy analysis <ref> [Dean et al. 95b] </ref> broadens the scope of the information available to the compiler by giving it access to all of the class and method declarations in the program.
Reference: [Deutsch & Schiffman 84] <author> L. Peter Deutsch and Allan M. Schiff-man. </author> <title> Efficient Implementation of the Smalltalk-80 System. </title> <booktitle> In Conference Record of the Eleventh Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 297302, </pages> <address> Salt Lake City, Utah, </address> <month> January </month> <year> 1984. </year>
Reference-contexts: Receiver class prediction can be driven either by information hard-wired into the compiler, as in early Smalltalk and Self implementations <ref> [Deutsch & Schiffman 84, Chambers & Ungar 89] </ref>, or by profile-derived class distributions [Hlzle & Ungar 94, Grove et al. 95], or by static examination of the programs class hierarchy [Chambers et al. 96].
Reference: [Diwan et al. 96] <author> Amer Diwan, Eliot Moss, and Kathryn McKin-ley. </author> <title> Simple and Effective Analysis of Statically-typed Object-Oriented Programs. </title> <booktitle> In OOPSLA96 Conference Proceedings, </booktitle> <address> San Jose, CA, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: Diwan, Moss, and McKinley developed a whole-program optimizer for Modula-3 incorporating class hierarchy analysis (which they call type hierarchy analysis), intraprocedural and interprocedural class analysis, and a simple, monovariant heap analysis to compute class sets for instance variables <ref> [Diwan et al. 96] </ref>.
Reference: [EDG] <author> C++ Front End 2.28. </author> <title> Provided by Edison Design Group, </title> <publisher> Inc. </publisher> <address> http://www.edg.com. </address>
Reference-contexts: The usual way of adding a new source language to the Vortex back-end is to reuse an existing public-domain or commercial front-end, and modify it to output the Vortex IL. For C++, we started with the Edison Design Groups C++ Front End <ref> [EDG] </ref>, a commercial product used as the front-end for many industrial C++ compilers. For Modula-3, we modified the front-end from the freely-available DEC SRC Modula-3 implementation [SRC].
Reference: [Fernandez 95] <author> Mary Fernandez. </author> <title> Simple and Effective Link-time Optimization of Modula-3 Programs. </title> <journal> SIGPLAN Notices, </journal> <pages> pages 103115, </pages> <month> June </month> <year> 1995. </year> <booktitle> In Proceedings of the ACM SIGPLAN 95 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: is the approach we have chosen for the Cecil and Java front-ends, supports higher-level analysis of object structures (such as better alias analysis) and opens the opportunity for optimizations that rearrange data representations. (Recent work has shown that these can have substantial performance impact in the context of both Modula-3 <ref> [Fernandez 95] </ref> and ML [Shao & Appel 95, Tarditi et al. 96].) If the front-end makes representation decisions, objects are described as a generic array of bytes of a particular size. <p> Also, they do not report the bottom-line run-time performance impact of their optimizations. Fernandez developed an optimizing Modula-3 system that performs class hierarchy analysis, inlining, and procedure specialization at link-time <ref> [Fernandez 95] </ref>. Her system delays all code generation until link time: the compiler does a simple translation of each source file to an intermediate representation, and the linker combines these IR files and generates code for the entire program.
Reference: [Goldberg & Robson 83] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Lanaguge and its Implementation. </title> <address> Addis-ion-Wesley, Reading, MA, </address> <year> 1983. </year>
Reference-contexts: For example, C++ has a stricter treatment of ambiguities, but C++s static typechecker ensures that no programs with ambiguities according to C++s rules produce IL code. Vortexs semantics are sufficient to handle the inheritance rules for single-inheritance languages such as Java, Modula-3, and Smalltalk <ref> [Goldberg & Robson 83] </ref>, and to handle multiple-inheritance languages such as Cecil, C++, and Trellis [Schaffert et al. 85].
Reference: [Gosling et al. 96] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1996. </year>
Reference-contexts: Thus, is it unclear how much overhead due to use of object-oriented features exists in programs written in these languages, and it is unclear how much benefit can be gained by applying advanced optimizations of the object-oriented features to programs in these languages. Java <ref> [Gosling et al. 96] </ref>, a language somewhere between C++ and Cecil in terms of its purity and dependence on object-oriented features, offers another interesting point in the language design space, and therefore its need for advanced optimization techniques may be different than both Cecil and C++.
Reference: [Grove et al. 95] <author> David Grove, Jeffrey Dean, Charles Garrett, and Craig Chambers. </author> <title> Profile-Guided Receiver Class Prediction. </title> <booktitle> In OOPSLA95 Conference Proceedings, </booktitle> <pages> pages 108123, </pages> <address> Austin, TX, </address> <month> October </month> <year> 1995. </year>
Reference-contexts: 1 Introduction In recent years, it has been demonstrated that intra- and interprocedural static class analysis [Chambers & Ungar 90, Plevyak & Chien 94, Agesen & Hlzle 95], class hierarchy analysis [Dean et al. 95b], and profile-guided receiver class prediction <ref> [Hlzle & Ungar 94, Grove et al. 95] </ref> can greatly improve the performance of dynamically-typed, purely object-oriented languages such as Cecil [Chambers 92, Chambers 93], Self [Ungar & Smith 87], and Concurrent Aggregates [Chien 93]. <p> Receiver class prediction can be driven either by information hard-wired into the compiler, as in early Smalltalk and Self implementations [Deutsch & Schiffman 84, Chambers & Ungar 89], or by profile-derived class distributions <ref> [Hlzle & Ungar 94, Grove et al. 95] </ref>, or by static examination of the programs class hierarchy [Chambers et al. 96]. We use the term exhaustive class testing to refer to class-hierarchy-guided class testing, and profile-guided class prediction to refer to class testing based on dynamic profile information. <p> In previous work, we applied several metrics to measure the peakedness and stability of the profile data used to drive profile-guided receiver class prediction <ref> [Grove et al. 95] </ref>. Due to space constraints, we only use the first class same metric here. 4.2 Applying the Metrics We applied the metrics defined in the previous section to a number of medium-to-large applications written in Cecil, Java, Modula-3, and C++. Table 1 summarizes several distinguishing language features.
Reference: [Hlzle & Ungar 94] <author> Urs Hlzle and David Ungar. </author> <title> Optimizing Dynamically-Dispatched Calls with Run-Time Type Feedback. </title> <journal> SIGPLAN Notices, </journal> <volume> 29(6):326336, </volume> <month> June </month> <year> 1994. </year> <booktitle> In Proceedings of the ACM SIGPLAN 94 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: 1 Introduction In recent years, it has been demonstrated that intra- and interprocedural static class analysis [Chambers & Ungar 90, Plevyak & Chien 94, Agesen & Hlzle 95], class hierarchy analysis [Dean et al. 95b], and profile-guided receiver class prediction <ref> [Hlzle & Ungar 94, Grove et al. 95] </ref> can greatly improve the performance of dynamically-typed, purely object-oriented languages such as Cecil [Chambers 92, Chambers 93], Self [Ungar & Smith 87], and Concurrent Aggregates [Chien 93]. <p> Receiver class prediction can be driven either by information hard-wired into the compiler, as in early Smalltalk and Self implementations [Deutsch & Schiffman 84, Chambers & Ungar 89], or by profile-derived class distributions <ref> [Hlzle & Ungar 94, Grove et al. 95] </ref>, or by static examination of the programs class hierarchy [Chambers et al. 96]. We use the term exhaustive class testing to refer to class-hierarchy-guided class testing, and profile-guided class prediction to refer to class testing based on dynamic profile information. <p> Diwans system also does not support selective recompilation after programming changes. Agesen and Hlzle compared the effectiveness of the Cartesian Product interprocedural class analysis algorithm [Agesen 95] with profile-guided receiver class prediction <ref> [Hlzle & Ungar 94] </ref> for Self programs [Agesen & Hlzle 95, Agesen & Hlzle 96].
Reference: [Hlzle et al. 91] <author> Urs Hlzle, Craig Chambers, and David Ungar. </author> <title> Optimizing Dynamically-Typed Object-Oriented Languages With Polymorphic Inline Caches. </title> <editor> In P. America, editor, </editor> <booktitle> Proceedings ECOOP 91, </booktitle> <volume> LNCS 512, </volume> <pages> pages 2138, </pages> <address> Geneva, Swit-zerland, July 15-19 1991. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: be useful to the back-end optimizer (e.g., the static type of the arguments of a method or the result of an instance variable access). 3.1.5 Implementing Message Sends Vortex currently supports two implementation strategies for message sends, one based on dispatch tables and one based on polymorphic inline caches (PICs) <ref> [Hlzle et al. 91] </ref>. For Cecil and Java, we select the PIC-based implementation strategy: dynamically generate a piece of executable code per call site that linearly tests for the N most common receiver classes, falling back to a hash table lookup if the cache overows.
Reference: [JDK] <institution> Java Development Kit. Sun Microsystems Inc. </institution> <note> http://ja-va.sun.com/. </note>
Reference-contexts: For C++, we started with the Edison Design Groups C++ Front End [EDG], a commercial product used as the front-end for many industrial C++ compilers. For Modula-3, we modified the front-end from the freely-available DEC SRC Modula-3 implementation [SRC]. For Java, we first use Suns javac Java compiler program <ref> [JDK] </ref> (invoked with the -O ag to perform as much optimization as possible in the existing front-end, to avoid overstating the benefits of Vortexs optimizations) to translate Java source programs into Java bytecodes, and then we modified the javap bytecode disassembler to convert to Vortex IL.
Reference: [Johnson 88] <author> Ralph Johnson. </author> <title> TS: AN Optimizing Compiler for Smalltalk. </title> <booktitle> In Proceedings OOPSLA 88, </booktitle> <pages> pages 1826, </pages> <month> Novem-ber </month> <year> 1988. </year> <journal> Published as ACM SIGPLAN Notices, </journal> <volume> volume 23, number 11. </volume>
Reference-contexts: application development to coexist. 2.1 Intraprocedural Class Analysis Intraprocedural class analysis uses a standard iterative dataow approach to compute for each program expression a set of classes such that any runtime value of the expression is guaranteed to be an instance of one of the classes in the computed set <ref> [Johnson 88, Chambers & Ungar 90] </ref>. The analysis maintains a mapping from variables to sets of classes, and propagates this mapping through the procedures control ow graph.
Reference: [Lea 90] <editor> Doug Lea. Customization in C++. </editor> <booktitle> In Proceedings of the 1990 Usenix C++ Conference, </booktitle> <address> San Francisco, CA, </address> <month> April </month> <year> 1990. </year>
Reference-contexts: Splitting can eliminate these redundant tests by duplicating paths through the control ow graph starting at merges after one test and ending with the redundant test to be eliminated [Chambers & Ungar 90]. 2.4 Customization and Specialization Customization and method specialization <ref> [Chambers & Ungar 89, Lea 90, Dean et al. 95a] </ref> are techniques that also can be used to statically bind messages sent to self, by creating multiple compiled copies of a single source method, each specialized to particular receiver classes. <p> However, it places some limitations on the optimizations that the back-end can perform. In particular, because dispatch tables are not exposed at a high enough level, the back-end cannot perform optimizations that would require generating different dispatch tables. Examples of such optimizations include customization and specialization <ref> [Chambers & Ungar 89, Lea 90, Dean et al. 95a] </ref> and converting a C++-style method from virtual to non-virtual to reduce the size of dispatch tables, when the back-end is able to detect that the method is not overridden anywhere in the program.
Reference: [Nelson 91] <author> Greg Nelson. </author> <title> Systems Programming with Modula-3. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: These techniques have been highly effective in this context, since message sends are ubiquitous and expensive; even the most primitive operations in these languages are implemented via user defined methods and dynamic dispatching. However, in statically-typed, hybrid object-oriented languages such as C++ [Stroustrup 91] and Modula-3 <ref> [Nelson 91] </ref>, much of the normal execution of programs involves non-object-oriented constructs, and consequently the incidence of dynamically-dispatched calls is much lower than in pure languages.
Reference: [Pande & Ryder 94] <author> Hemant D. Pande and Barbara G. Ryder. </author> <title> Static Type Determination for C++. </title> <booktitle> In Proceedings of Sixth USENIX C++ Technical Conference, </booktitle> <year> 1994. </year>
Reference-contexts: They do report that rapid type analysis shrinks the size of the generated programs substantially. Pande and Ryder apply aggressive interprocedural context-sensitive pointer analysis to statically-bind virtual function call sites in C++ <ref> [Pande & Ryder 94] </ref>.
Reference: [Plevyak & Chien 94] <author> John Plevyak and Andrew A. Chien. </author> <title> Precise Concrete Type Inference for Object-Oriented Languages. </title> <booktitle> In Proceedings OOPSLA 94, </booktitle> <pages> pages 324340, </pages> <address> Portland, OR, </address> <month> October </month> <year> 1994. </year>
Reference: [Schaffert et al. 85] <author> Craig Schaffert, Topher Cooper, and Carrie Wilpolt. </author> <title> Trellis Object-Based Environment, Language Reference Manual. </title> <type> Technical Report DEC-TR-372, </type> <institution> Digital Equipment Corporation, </institution> <month> November </month> <year> 1985. </year>
Reference-contexts: Vortexs semantics are sufficient to handle the inheritance rules for single-inheritance languages such as Java, Modula-3, and Smalltalk [Goldberg & Robson 83], and to handle multiple-inheritance languages such as Cecil, C++, and Trellis <ref> [Schaffert et al. 85] </ref>.
Reference: [Shao & Appel 95] <author> Zhong Shao and Andrew Appel. </author> <title> A type-based compiler foor Standard ML. </title> <journal> SIGPLAN Notices, </journal> <pages> pages 116 129, </pages> <month> June </month> <year> 1995. </year> <booktitle> In Proceedings of the ACM SIGPLAN 95 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: have chosen for the Cecil and Java front-ends, supports higher-level analysis of object structures (such as better alias analysis) and opens the opportunity for optimizations that rearrange data representations. (Recent work has shown that these can have substantial performance impact in the context of both Modula-3 [Fernandez 95] and ML <ref> [Shao & Appel 95, Tarditi et al. 96] </ref>.) If the front-end makes representation decisions, objects are described as a generic array of bytes of a particular size. Low-level pointer operations are used to implement instance variable accesses, and object allocation is implemented in terms of malloc-type byte allocators.
Reference: [SRC] <institution> DEC SRC Modula-3 Implementation. Digital Equipment Corporation Systems Research Center. </institution> <note> http://www.research.digital.com/SRC/modula-3/html/home.html. </note>
Reference-contexts: For C++, we started with the Edison Design Groups C++ Front End [EDG], a commercial product used as the front-end for many industrial C++ compilers. For Modula-3, we modified the front-end from the freely-available DEC SRC Modula-3 implementation <ref> [SRC] </ref>.
Reference: [Stroustrup 87] <author> Bjarne Stroustrup. </author> <title> Multiple Inheritance for C++. </title> <booktitle> In In Proceedings of the European Unix Users Group Conference 87, </booktitle> <pages> pages 189207, </pages> <address> Helsinki, Finland, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: This low-level form works even if the memory location is only invariant in some contexts. For example, in C++, vtbl words of objects are unchanged outside of their constructor methods <ref> [Stroustrup 87] </ref>. The Vortex IL supports global variable declarations. <p> However, in C++ this test is complicated by the fact that, in the presence of multiple inheritance, an object can have multiple different vtbl addresses, each for different statically-typed views of the object <ref> [Stroustrup 87] </ref>. To support C++-style class identifiers effectively, the front-end annotates each class with a mapping from static type views to the name of the vtbl constant stored at that offset.
Reference: [Stroustrup 91] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language (second edition). </title> <address> Addision-Wesley, Reading, MA, </address> <year> 1991. </year>
Reference-contexts: These techniques have been highly effective in this context, since message sends are ubiquitous and expensive; even the most primitive operations in these languages are implemented via user defined methods and dynamic dispatching. However, in statically-typed, hybrid object-oriented languages such as C++ <ref> [Stroustrup 91] </ref> and Modula-3 [Nelson 91], much of the normal execution of programs involves non-object-oriented constructs, and consequently the incidence of dynamically-dispatched calls is much lower than in pure languages.
Reference: [Tarditi et al. 96] <author> David Tarditi, Greg Morrisett, Perry Cheng, Chris Stone, Bob Harper, and Peter Lee. </author> <title> TIL: A Type-Directed Compiler for ML. </title> <journal> SIGPLAN Notices, </journal> <pages> pages 181192, </pages> <month> May </month> <year> 1996. </year> <booktitle> In Proceedings of the ACM SIGPLAN 96 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: have chosen for the Cecil and Java front-ends, supports higher-level analysis of object structures (such as better alias analysis) and opens the opportunity for optimizations that rearrange data representations. (Recent work has shown that these can have substantial performance impact in the context of both Modula-3 [Fernandez 95] and ML <ref> [Shao & Appel 95, Tarditi et al. 96] </ref>.) If the front-end makes representation decisions, objects are described as a generic array of bytes of a particular size. Low-level pointer operations are used to implement instance variable accesses, and object allocation is implemented in terms of malloc-type byte allocators.
Reference: [Tjiang & Hennessy 92] <author> Steven W. K. Tjiang and John L. Hen-nessy. </author> <title> Sharlit A Tool for Building Optimizers. </title> <journal> SIGPLAN Notices, </journal> <volume> 27(7):8293, </volume> <month> July </month> <year> 1992. </year> <booktitle> In Proceedings of the ACM SIGPLAN 92 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: Clients of the framework simply provide an analysis closure that encapsulates the appropriate ow functions and an analysis-specific domain class that implements the copy, meet, and reached_convergence methods. (Vortexs IDFA framework is similar in spirit to the Sharlit system developed by Tjiang and Hennessy <ref> [Tjiang & Hennessy 92] </ref>.) Analyses written separately using Vortexs framework can also be composed so that they run together simultaneously, thus alleviating potential phase-ordering problems. (Click and Cooper describe the theoretical conditions under which the resulting combination of optimizations will produce better results than repeated applications of the original separate optimizations
Reference: [Ungar & Smith 87] <author> David Ungar and Randall B. Smith. </author> <title> Self: The Power of Simplicity. </title> <booktitle> In Proceedings OOPSLA 87, </booktitle> <pages> pages 227 242, </pages> <month> December </month> <year> 1987. </year>
Reference-contexts: [Chambers & Ungar 90, Plevyak & Chien 94, Agesen & Hlzle 95], class hierarchy analysis [Dean et al. 95b], and profile-guided receiver class prediction [Hlzle & Ungar 94, Grove et al. 95] can greatly improve the performance of dynamically-typed, purely object-oriented languages such as Cecil [Chambers 92, Chambers 93], Self <ref> [Ungar & Smith 87] </ref>, and Concurrent Aggregates [Chien 93]. These techniques have been highly effective in this context, since message sends are ubiquitous and expensive; even the most primitive operations in these languages are implemented via user defined methods and dynamic dispatching.
References-found: 43

