URL: http://www.isi.edu/isd/rickel/atp-analogy.ps
Refering-URL: http://www.isi.edu/isd/rickel/publications.html
Root-URL: http://www.isi.edu
Title: Use of Analogy in Automated Theorem Proving  
Author: Jeff Rickel 
Date: May 15, 1989  
Address: Austin  
Affiliation: Department of Computer Science The University of Texas at  
Note: The  "Those who forget history may be condemned to repeat it, but those who record history are allowed to replay it." Jack Mostow [18]  
Abstract: Technical Report ATP-90, Artificial Intelligence Laboratory, University of Texas at Austin. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Bareiss, E.R., "Protos: </author> <title> A Unified Approach to Concept Representation, Classification, and Learning," </title> <type> Ph.D. Thesis, </type> <institution> University of Texas at Austin, Austin, TX, </institution> <month> August </month> <year> 1988. </year>
Reference-contexts: Protos <ref> [1] </ref>, a case-based reasoning system developed by Bareiss, uses an interesting variant of failure indexing called difference links.
Reference: [2] <author> Bledsoe, W.W., and L.M. Hines, </author> <title> "Variable Elimination and Chaining in a Resolution-Based Prover for Inequalities," </title> <editor> in CADE-5 (eds. W. Bibel and R. Kowalski). Les Arcs, </editor> <address> France: </address> <publisher> Springer-Verlag, </publisher> <pages> pp. 70-87, </pages> <year> 1980. </year>
Reference-contexts: They have tried both resolution and natural deduction versions of BOX. Both versions use chaining and variable elimination <ref> [2] </ref>, and both are capable of fetching lemmas as needed. An analogous step in the proof is "the application of the same rule to the analogous terms as determined by the analogy mapping" [3]. BOX handles updates and extensions of the mapping at two levels. <p> Brock et. al. [3] present three types of patching required in their analogy prover in the domain of Real Analysis. If an inference step fails because two terms fail to unify, they search for an equality substitution in the lemma base. In the special case of chaining <ref> [2] </ref>, "the two terms which failed to unify are used to find a lemma which will chain with both terms," a method they call "double-entry fetching" [3]. The second problem, when variable elimination is prevented by a shielding term [2], is dealt with by trying to eliminate the shielding term. <p> In the special case of chaining <ref> [2] </ref>, "the two terms which failed to unify are used to find a lemma which will chain with both terms," a method they call "double-entry fetching" [3]. The second problem, when variable elimination is prevented by a shielding term [2], is dealt with by trying to eliminate the shielding term. This is the normal strategy of their standard prover, but in the analogy case the prover is focused on a particular shielding term, the one that is preventing the analogous step from the old proof.
Reference: [3] <author> Brock, B., S. Cooper, and W. Pierce, </author> <title> "Analogical Reasoning and Proof Discovery," </title> <address> CADE-88, </address> <year> 1988, </year> <pages> pp. 455-468. </pages>
Reference-contexts: Other work on hierarchical proof techniques, such as Hines' axiom rules [12], would also enable the use of Derivational Analogy. 4.5 BOX The BOX system of Brock et. al. <ref> [3] </ref> requires an analogous old theorem and proof as well as a mapping (pairing of subterms) between the old theorem and new theorem (the mapping scheme described in the last section has not been integrated with their prover). They have tried both resolution and natural deduction versions of BOX. <p> Both versions use chaining and variable elimination [2], and both are capable of fetching lemmas as needed. An analogous step in the proof is "the application of the same rule to the analogous terms as determined by the analogy mapping" <ref> [3] </ref>. BOX handles updates and extensions of the mapping at two levels. First, each term in BOX has a label. Analogous terms have the same label. At each inference in the proof, a term in the new step "inherits the tags from all the terms from which it was derived" [3]. <p> <ref> [3] </ref>. BOX handles updates and extensions of the mapping at two levels. First, each term in BOX has a label. Analogous terms have the same label. At each inference in the proof, a term in the new step "inherits the tags from all the terms from which it was derived" [3]. Also, any term substituted for a variable inherits any analogies of that variable as well as retaining its own analogical mappings. <p> The user tells the system which such analogies are appropriate to the mapping between new and old theorem, and the system then uses the analogous lemma when its corresponding lemma is used in the old proof. Brock et. al. <ref> [3] </ref> discuss their problems with the flat proof structure of their resolution prover and their change to a natural deduction format with a hierarchical dependency structure for proofs. <p> Carbonell [6] suggests that each step in the subgoal hierarchy be evaluated for relevance to the new problem. In this way, whole subproofs can be skipped where they are inapplicable. Brock et. al. <ref> [3] </ref> have even suggested that the prover try to solve subgoals directly before resorting to the details of the old proof. When a subgoal is relevant yet the derivational trace fails Carbonell suggests that we first reassess the alternatives recorded but not chosen in the old solution. <p> In standard logics, application of an inference rule does not invalidate previously proven facts. The types of patching required sometimes depend on the particular domain or prover. Brock et. al. <ref> [3] </ref> present three types of patching required in their analogy prover in the domain of Real Analysis. If an inference step fails because two terms fail to unify, they search for an equality substitution in the lemma base. <p> In the special case of chaining [2], "the two terms which failed to unify are used to find a lemma which will chain with both terms," a method they call "double-entry fetching" <ref> [3] </ref>. The second problem, when variable elimination is prevented by a shielding term [2], is dealt with by trying to eliminate the shielding term. <p> Derivational Analogy permits a great deal of necessary flexibility in following and patching an old proof, and its utility has been demonstrated by the experiments of Brock et. al. <ref> [3] </ref>. Patching also requires the ability to call on the standard prover and possibly use some domain-dependent techniques. <p> Not only would this help the patching problem, but it would also allow subproofs of old theorems to guide subproofs of new theorems and the use of several analogies to guide a new proof <ref> [3] </ref>. 6.2 Carbonell's Approach While Carbonell's papers on Transformational and Derivational Analogy give good insights on the following and patching problems, they make fewer suggestions for the retrieval problem.
Reference: [4] <author> Brock, B., S. Cooper, and W. Pierce, </author> <title> "Some Experiments with Analogy in Proof Discovery: A Natural Deduction Approach," </title> <type> Tech. Report ACA-AI-274-87, </type> <institution> MCC, Austin, TX, </institution> <month> August </month> <year> 1987. </year>
Reference-contexts: Also, the preference for a one-to-one mapping and the emphasis on mapping higher-order structure are both sound principles. 3.3 BOX Brock et. al. <ref> [4] </ref> describe a top-down mapping scheme for their BOX analogical theorem prover in which domain-dependent mapping rules recursively map terms (their use of the word "term" is looser than the predicate calculus sense of the word). <p> Their use of these hierarchical dependencies is motivated by the inadequacy of their early representation of a proof as simply a sequence of inference steps. In an earlier paper, Brock et. al. <ref> [4] </ref> discuss in more detail their method for annotating proofs with motivations. Their BOX system was modified to allow a "motive" (in their 11 domain, this could be either variable elimination or chaining) to be attached to a group of proof steps. <p> Thus, the standard prover is often called on to fill gaps in the new proof or finish the proof after the analogy has been "used up." Even in such cases, the analogy is helpful in focusing the standard prover on small tasks. However, as Brock et. al. <ref> [4] </ref> note, "updating the analogy when steps are added to or deleted from the new proof can be very complicated." The prover of Brock et. al. puts off any subgoals without an analog in the old proof until the end (the old proof has been used up), at which time they
Reference: [5] <author> Carbonell, J.G., </author> <title> "Learning by Analogy: Formulating and Generalizing Plans from Past Experience," </title> <booktitle> in Machine Learning: An Artificial Intelligence Approach, </booktitle> <volume> Vol. </volume> <editor> I (eds. Michalski, Carbonell, and Mitchell). </editor> <address> Palo Alto, CA: </address> <publisher> Tioga Press, </publisher> <year> 1983, </year> <pages> pp. 137-161. </pages>
Reference-contexts: main problems with ZORBA with regard to proof reuse are that it assumes that syntactically similar theorems will have syntactically similar proofs, and there are no facilities for abstraction or generalization of the old proof. 4.3 Transformational Analogy In order to allow problem solving by analogy with previous solutions, Carbonell <ref> [5] </ref> suggested a method he called Transformational Analogy. The key idea in Transformational Analogy is that transforming a recalled solution sequence is just a process of means-end analysis in the space of solution sequences, and hence uses the same problem-solving methods as looking for a solution anew. <p> In Transformational Analogy, Carbonell <ref> [5] </ref> suggests the use of a similarity metric which measures the similarity of an old case with a new case along a number of dimensions.
Reference: [6] <author> Carbonell, J.G., </author> <title> "Derivational Analogy: A Theory of Reconstructive Problem Solving and Expertise Acquisition," </title> <booktitle> in Machine Learning: An Artificial Intelligence Approach, </booktitle> <volume> Vol. </volume> <editor> II (eds. Michalski, Carbonell, and Mitchell). </editor> <address> Los Altos, CA: </address> <publisher> Morgan Kaufmann, </publisher> <year> 1986, </year> <pages> pp. 371-392. </pages>
Reference-contexts: The attraction of this approach is apparent: it relies on the 9 same weak method as problem solving from scratch, and thus adds no new machinery to our problem solver. However, as we will see in the next section, this approach is limited. 4.4 Derivational Analogy Carbonell's Derivational Analogy <ref> [6] </ref> is a reconstructive rather than transformational method. ARIES, the implementation of Transformational Analogy, turned out to be very complex due to the difficulty of pattern matching over problem descriptions and searching in the space of solution tranformations. <p> If one has designed a quicksort algorithm in LISP, the design of the Pascal version should follow the same steps with only a change in low-level (language-dependent) details. Derivational Analogy is designed to deal with such problems <ref> [6] </ref>. In proof discovery, Transformational Analogy is appropriate when the proof of the old theorem is very similar to a proof of the new conjecture. However, it is often possible that the abstract structure of the proofs is similar but the low-level details differ significantly. <p> In Derivational Analogy, the whole reasoning process leading to the old proof is recorded. When using this old proof to prove a new conjecture, we attempt to "replay" the old proof by following the same reasoning steps wherever possible. When solving a problem, we record the following information <ref> [6] </ref>: * The subgoal structure of the problem * Each decision, including the alternatives, reasons for decisions, the beginning of false paths along with the reasons they appeared promising and yet failed, and dependencies among decisions. * Pointers to knowledge that was used productively. * The resulting solution, including reasons for <p> For reasons already discussed, this approach relies on a good deal of similarity between the old proof and the new one at a detailed level. 12 Derivational Analogy suggests an alternative. Carbonell <ref> [6] </ref> suggests that each step in the subgoal hierarchy be evaluated for relevance to the new problem. In this way, whole subproofs can be skipped where they are inapplicable. <p> Finally, as a last resort, we abandon the analogy. If deviation from the old solution is required, the dependency links can be used to see which parts of the old solution must be modified and which can still be reused directly <ref> [6] </ref>. Patching often falls back on the standard prover. Failed preconditions can often be established independent of the old proof, as can residual subgoals (those not addressed in the old proof). <p> However, he provides no such similarity metric in any detail, and it is not clear how this approach would scale up to deal with large knowledge bases unless tremendous parallelism is assumed. In Derivational Analogy <ref> [6] </ref>, when solving a new problem, we retrieve old solutions which are similar in the initial stages of their reasoning process to the new problem. We then try to follow the derivational trace of the old solution. <p> First, it can only help to use EBL generalization techniques [7] to generalize the proof as far as possible while still maintaining the validity of each proof step. Second, we must decide whether the proof should be stored by itself, as an annotation or deviation from a similar proof <ref> [19, 6] </ref>, or just forgotten. After all, if we stored everything, our knowledge base would grow unwieldy.
Reference: [7] <author> DeJong, </author> <title> G.F., and R.J. Mooney, "Explanation-Based Learning: An Alternative View," </title> <journal> Machine Learning 1, </journal> <volume> 2, </volume> <year> 1986, </year> <pages> pp. 145-176. 19 </pages>
Reference-contexts: The question is whether such an approach would be flexible enough to permit a significant number of old proofs to be reused. Another approach, currently being investigated under the label "Explanation-Based Learning" (EBL) <ref> [7] </ref>, involves a generalization process prior to storage of each proof. The proof is generalized as far as possible while still maintaining the requisite connections between proof steps. <p> It makes sense to avoid the learning problem until research in the other areas has shown what later processing steps need to reuse an old proof. However, some observations can be made about storing proofs for reuse. First, it can only help to use EBL generalization techniques <ref> [7] </ref> to generalize the proof as far as possible while still maintaining the validity of each proof step. Second, we must decide whether the proof should be stored by itself, as an annotation or deviation from a similar proof [19, 6], or just forgotten.
Reference: [8] <author> Falkenhainer, B., K.D. Forbus, and D. Gentner, </author> <title> "The Structure Mapping Engine," </title> <booktitle> Proc. of the Fifth National Conference on Artificial Intelligence, </booktitle> <address> Los Altos, CA: </address> <publisher> Morgan Kaufmann, </publisher> <month> August </month> <year> 1986. </year>
Reference-contexts: The Structure-Mapping Engine (SME) <ref> [8] </ref> is a toolkit for analogical mapping based on Structure Mapping theory. Its representation is a typed predicate calculus. While 4 SME includes rules for other types of similarity matching, I will concentrate on its imple-mentation of Structure Mapping.
Reference: [9] <author> Falkenhainer, B., K.D. Forbus, and D. Gentner, </author> <title> "The Structure Mapping Engine: Algorithm and Examples," </title> <type> Report UIUCDCS-R-87-1361, </type> <institution> Department of Computer Science, University of Illinois at Urbana-Champaign, Urbana, IL, </institution> <month> July </month> <year> 1987. </year>
Reference: [10] <author> Gentner, D., </author> <title> "Structure Mapping: A Theoretical Framework for Analogy," </title> <booktitle> Cognitive Science 7 (2), </booktitle> <pages> pp. 155-170, </pages> <year> 1983. </year>
Reference-contexts: How do we focus this search in order to find only those mappings which will allow transfer of the old proof? 3.2 Structure-Mapping Engine One of the most successful theories of analogical mapping is Structure Mapping, due to Gentner <ref> [10] </ref>. Structure Mapping is a domain-independent theory of human analogical mapping which has been supported by many psychological experiments. The key idea is that networks of higher-order relations should guide the mapping, not the similarity of predicates or terms. In general, higher-order relations convey the causal structure of the situation.
Reference: [11] <author> Gentner, D., </author> <title> "Mechanisms of Analogical Learning," in Similarity and Analogical Reasoning (Eds. </title> <editor> S. Vosniadou and A. Ortony), </editor> <publisher> London: Cambridge University Press, </publisher> <year> 1987. </year>
Reference-contexts: In theorem proving, higher-order relations (logical implication and equivalence) convey the proof structure. Structure Mapping is based on the principle of "Systematicity," which states that "people prefer to map connected systems of relations governed by higher-order relations with inferential import, rather than isolated predicates" <ref> [11] </ref>. <p> Finally, SME rates each Gmap according to "local evidence rules," the number of candidate inferences they support, and the size of their deepest (most systematic) mappable system of relations <ref> [11] </ref>. SME fails as a foundation for analogical mapping in proof discovery, although it does provide a starting point. The main problem is that SME only considers structural abstraction. While SME has rules for other types of similarity matching, all these rules require identical predicates for any match. <p> How can we look at shared abstractions efficiently? It should be noted that psychological evidence shows that, while people do use abstractions for retrieval, the retrieval process is largely dominated by surface commonalities <ref> [11] </ref>. <p> Since research has shown that experts seem to index into their knowledge based on more abstract features than novices, I will close this section with a quote from Gentner <ref> [11] </ref>: "To the extent that experts differ from novices in their access patterns, I suspect this results chiefly from experts having different knowledge representations (e.g., possessing relational abstractions), rather than different access processes." 7 Learning I have saved learning for last because its design is largely determined by the design of
Reference: [12] <author> Hines, L.M., </author> <title> "Hyper-chaining and Knowledge-Based Theorem Proving," </title> <booktitle> Proceedings of CADE-9, </booktitle> <month> May </month> <year> 1988. </year>
Reference-contexts: Standard resolution theorem proving is thus unsuitable for Derivational Analogy. Natural deduction, on the other hand, provides the necessary subgoal structure for proofs, 10 and also makes the intention of proof steps more apparent. Other work on hierarchical proof techniques, such as Hines' axiom rules <ref> [12] </ref>, would also enable the use of Derivational Analogy. 4.5 BOX The BOX system of Brock et. al. [3] requires an analogous old theorem and proof as well as a mapping (pairing of subterms) between the old theorem and new theorem (the mapping scheme described in the last section has not
Reference: [13] <author> Hofstadter, </author> <title> D.R., "The Copycat Project: An Experiment in Nondeterminism and Creative Analogies," AI Memo 755, </title> <publisher> MIT, </publisher> <address> Cambridge, MA, </address> <month> January </month> <year> 1984. </year>
Reference-contexts: Finally, the authors do not state whether mapping decisions made in one branch of the recursion are propagated to other branches, which seems to be required for consistency if backtracking isn't allowed. 3.4 ACME Analogical mapping can be seen as a number of competing pressures, a perspective suggested by Hofstadter <ref> [13] </ref>. Structural pressures prefer one-to-one mappings and structural consistency; structural consistency means that a proposition is analogous iff its constituent predicate and arguments are analogous. Semantic pressures prefer mappings between elements with similar meanings, such as predicates or operators with a shared abstraction.
Reference: [14] <author> Holyoak, Keith J., and Paul Thagard, </author> <title> "Analogical Mapping by Constraint Satisfaction," </title> <journal> Cognitive Science, </journal> <note> to appear. </note>
Reference-contexts: By handling these pressures sequentially, we give an a priori importance to certain types of pressures without considering the magnitude of evidence the other pressures offer. Holyoak and Thagard <ref> [14] </ref> make the following observation: A cooperative algorithm for parallel constraint satisfaction is preferable to any serial decision process when: (a) a global decision is composed of a number of constituent decisions, (b) each constituent decision should be based on multiple constraints, (c) the outcome of the global decision could vary
Reference: [15] <author> Kedar-Cabelli, S.T., </author> <title> "Analogy from a Unified Perspective," </title> <type> Report No. </type> <institution> ML-TR-3, Rutgers University, </institution> <address> New Brunswick, NJ, </address> <month> December </month> <year> 1985. </year>
Reference-contexts: At what level of abstraction do we retrieve? Kedar-Cabelli <ref> [15] </ref> has noted that we cannot retrieve based on surface features alone, but must consider shared abstractions.
Reference: [16] <author> Kling, R.E., </author> <title> "A Paradigm for Reasoning by Analogy," </title> <journal> Artificial Intelligence, </journal> <volume> 2 (2), </volume> <pages> pp. 147-178, </pages> <month> Fall </month> <year> 1971. </year>
Reference-contexts: The task is therefore to explore the applicability of the old proof (along with the mapping) to the new proof, transfering subproofs and planning islands wherever possible. This may require that we extend and/or update the mapping along the way. 8 4.2 ZORBA Kling <ref> [16] </ref> was the first to try the use of old proofs in guiding the discovery of new proofs in resolution theorem proving. His system, ZORBA, required an analogous theorem and its proof as input.
Reference: [17] <author> Minsky, M., </author> <title> "Steps Toward Artificial Intelligence," </title> <editor> in Computers and Thought (eds. Feigenbaum and Feldman). </editor> <address> New York: </address> <publisher> McGraw-Hill, </publisher> <year> 1961. </year>
Reference-contexts: 1 Introduction The search space for the discovery of proofs of nontrivial theorems is combinatorially explosive. One of the limiting factors in current automated provers is their inability to focus this search sufficiently to avoid exceeding resource limitations (memory, time). An observation by Minsky <ref> [17] </ref> suggests one general approach to this problem: In a graph with 10 branches descending from each node, a 20-step search might involve 10 20 trials, which is out of the question, while the insertion of just four ... sequential subgoals might reduce the search to only 5 fi 10 4
Reference: [18] <author> Mostow, J., </author> <title> "Design by Derivational Analogy: Issues in the Automated Replay of Design Plans," </title> <journal> Artificial Intelligence, </journal> <note> to appear. </note>
Reference: [19] <author> Schank, </author> <title> R.C., Dynamic Memory. </title> <address> Cambridge, MA: </address> <publisher> Cambridge University Press, </publisher> <year> 1982. </year>
Reference-contexts: Most research in this area has its roots in Schank's work on "dynamic memory" <ref> [19] </ref>. In fact, Carbonell's idea of retrieving old plans based on a similar initial reasoning process as the current problem can be traced back to Schank. Schank proposes a number of different indices into past cases based on different levels of abstraction. <p> Schank proposes a number of different indices into past cases based on different levels of abstraction. In this section I will only discuss a few of these which seem most relevant to theorem proving. Schank <ref> [19] </ref> suggests that the reminding process is very goal oriented. It certainly makes sense that we index into old proofs based more on what we are trying to prove than what antecedents we are given. This suggests that we index into old proofs based on our goals and their abstractions. <p> First, it can only help to use EBL generalization techniques [7] to generalize the proof as far as possible while still maintaining the validity of each proof step. Second, we must decide whether the proof should be stored by itself, as an annotation or deviation from a similar proof <ref> [19, 6] </ref>, or just forgotten. After all, if we stored everything, our knowledge base would grow unwieldy. <p> After all, if we stored everything, our knowledge base would grow unwieldy. The issues of selective retention are crucial, and are discussed at length by Schank <ref> [19] </ref>, yet remain among the most important unsolved problems in artificial intelligence. 8 Conclusions This paper has provided an overview of the issues and important ideas in problem solving by analogy. If some sections seem incomplete, that largely reflects the state of the field.
Reference: [20] <author> Thagard, P, K. Holyoak, G. Nelson, and D. Gochfeld, </author> <title> "Analog Retrieval by Constraint Satisfaction" unpublished manuscript, </title> <institution> Cognitive Science Laboratory, Prince-ton University, Princeton, NJ, </institution> <month> February </month> <year> 1989. </year> <month> 20 </month>
Reference-contexts: Finally, Carbonell provides few details on his retrieval ideas. 15 6.3 ARCS The ACME analogical mapping system is accompanied by a retrieval system called ARCS <ref> [20] </ref>. The basic ideas in ARCS are the same as those in ACME with only a few differences. Like ACME, ARCS is based on semantic, structural, and pragmatic constraints, and it uses a parallel, competitive relaxation of these constraints. <p> Like ACME, ARCS is based on semantic, structural, and pragmatic constraints, and it uses a parallel, competitive relaxation of these constraints. However, unlike ACME, semantic similarity is the dominant pressure in ARCS, due mostly to the psychological evidence for such an approach in humans <ref> [20] </ref>. ARCS uses three knowledge representations: Predicate Calculus for the source and target analogs, frames attached to predicates for semantic information, and a constraint network for analogical correspondences. Each semantic frame includes a set of synonyms, antonyms, tenses, plurals, superordinate and subordinate relations, and part-whole relations [20]. <p> an approach in humans <ref> [20] </ref>. ARCS uses three knowledge representations: Predicate Calculus for the source and target analogs, frames attached to predicates for semantic information, and a constraint network for analogical correspondences. Each semantic frame includes a set of synonyms, antonyms, tenses, plurals, superordinate and subordinate relations, and part-whole relations [20]. ARCS operates like ACME with the addition of an initial stage of postulating potential analogs using semantic similarities. Once these hypotheses are formed, the pragmatic and structural constraints are added and the network is relaxed in the usual way.
References-found: 20

