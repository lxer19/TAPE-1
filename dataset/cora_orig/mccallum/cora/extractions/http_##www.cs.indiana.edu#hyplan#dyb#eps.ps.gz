URL: http://www.cs.indiana.edu/hyplan/dyb/eps.ps.gz
Refering-URL: http://www.cs.indiana.edu/hyplan/dyb/synbib.html
Root-URL: http://www.cs.indiana.edu
Title: Expansion-Passing Style: A General Macro Mechanism*  
Author: R. Kent Dybvig, Daniel P. Friedman, Christopher T. Haynes 
Abstract: The traditional Lisp macro expansion facility inhibits several important forms of expansion control. These include selective expansion of subexpressions, expansion of subexpressions using modified expansion functions, and expansion of application and variable expressions. Furthermore, the expansion algorithm must treat every special form as a separate case. The result is limited expressive power and poor modularity. We propose an alternative facility that avoids these problems, using a technique called expansion-passing style (EPS). The critical difference between the facility proposed here and the traditional macro mechanism is that expansion functions are passed not only an expression to be expanded but also another expansion function. This function may or may not be used to perform further expansion. The power of this technique is illustrated with several examples. Most Lisp systems may be adapted to employ this technique. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Charniak, E., Riesbeck, C. K., and McDermott, D. V., </author> <booktitle> Artificial Intelligence Programming, </booktitle> <publisher> Lawrence Erlbaum Associates, </publisher> <year> 1980. </year>
Reference-contexts: This function may or may not be used to perform further expansion. This is analogous to passing an explicit continuation to a function, which is well known to be a powerful programming technique (for example, see <ref> [1, 12] </ref>). In this paper we have demonstrated that the related technique of passing expanders explicitly provides a powerful tool for defining syntactic extensions.
Reference: [2] <author> Dybvig, R. K., </author> <title> The Scheme Programming Language, </title> <publisher> Prentice-Hall, </publisher> <year> 1987. </year>
Reference-contexts: Some familiarity with Lisp and its traditional macro expansion mechanism is assumed. For a survey of macro expansion techniques, see [6]. 2. Coding Conventions The code that follows is expressed in Scheme, a lexically scoped dialect of Lisp <ref> [2, 10] </ref>. The only core syntactic forms|those that are not implemented as syntactic extensions|are given in Figure 1. Superscript "*" and * A preliminary version of this paper was presented at the 1986 ACM Symposium on Lisp and Functional Programming. <p> The gensym function returns a symbol that is guaranteed to be distinct from all other symbols. Finally, printf provides formatted output a la Common Lisp's format . These features are described fully in <ref> [2] </ref>. 3. The Traditional Approach to Syntactic Extension Syntactic transformation of Lisp programs may be performed by manipulating source expressions prior to evaluation. Provision for this is easily made by adding a preprocessor to eval , which we call expand .
Reference: [3] <author> Liongosari, Edy S., </author> <title> "Scheme Debugger User's Manual" Undergraduate Honors Thesis, </title> <institution> Indiana University (July, </institution> <year> 1987). </year>
Reference-contexts: When an error (or other form of break) occurs, it is then possible to inspect the contents of the buffer to follow the recent history of the computation. Such a history mechanism has proven useful for debugging student assignments <ref> [3] </ref>. This technique of implementing a debugger is comparable in run time efficiency to other debuggers, and provides all the advantages mentioned at the beginning of this section. But it does have one drawback: it results in the generation of voluminous code.
Reference: [4] <author> Dybvig, R. K., Friedman, D. P., and Haynes, C. T., </author> <title> "Expansion-passing style: beyond conventional macros," </title> <booktitle> Proceedings of the 1986 ACM Conference on Lisp and Functional Programming, </booktitle> <address> Cambridge, Massachusetts, </address> <pages> pp. 143-150, </pages> <year> 1986. </year>
Reference-contexts: Call-by-need semantics may be achieved with a more complex application expansion <ref> [4] </ref>. To perform these transformations, we require a nontraditional expansion algorithm that expands vari ables and applications. It is also sometimes essential that further expansion be performed only on selected subexpressions of transformed expressions.
Reference: [5] <author> Fischer, M.J., </author> <title> Lambda calculus schemata, </title> <booktitle> Proceedings ACM Conference on Proving Assertions about Programs, </booktitle> <address> Las Cruces, New Mexico, </address> <pages> pp. 104-109, </pages> <year> 1972. </year>
Reference-contexts: This is analogous to a function having control over how the value that it returns is used to continue the computation. Continuation-passing style (CPS) may be used to give the function this control <ref> [5, 9, 12] </ref>. In the macro? line of old-style-expand (see Figure 2), the recursive call occurs in a tail recursive position.
Reference: [6] <author> Kohlbecker, E., </author> <title> Syntactic Extensions in the Programming Language Lisp, </title> <type> PhD dissertation, </type> <institution> Indiana University, </institution> <month> August, </month> <year> 1986. </year>
Reference-contexts: Finally, a few difficulties with the facility are noted and alternative approaches are discussed. Some familiarity with Lisp and its traditional macro expansion mechanism is assumed. For a survey of macro expansion techniques, see <ref> [6] </ref>. 2. Coding Conventions The code that follows is expressed in Scheme, a lexically scoped dialect of Lisp [2, 10]. The only core syntactic forms|those that are not implemented as syntactic extensions|are given in Figure 1. <p> This is reflected by the non-tail-recursive position of the other calls of old-style-expand in Figure 2. Also, continuations are not passed another continuation as a second parameter. 4 It should also be possible for EPS to coexist with the macro-by-example mechanism of Kohlbecker and Wand <ref> [6, 8] </ref>. <p> This avoids the possibility that identical variables in the body of the new expander be captured by the parameters of the expander. (A more sophisticated solution to the capturing problem is provided by hygienic macro expansion <ref> [6, 7] </ref>.
Reference: [7] <author> Kohlbecker, E., Friedman, D., Felleisen, M., and Duba, B., </author> <title> "Hygienic macro expansion," </title> <booktitle> Proceedings of the 1986 ACM Conference on Lisp and Functional Programming, </booktitle> <address> Cambridge, Massachusetts, </address> <pages> pp. 151-161, </pages> <year> 1986. </year>
Reference-contexts: This avoids the possibility that identical variables in the body of the new expander be captured by the parameters of the expander. (A more sophisticated solution to the capturing problem is provided by hygienic macro expansion <ref> [6, 7] </ref>.
Reference: [8] <author> Kohlbecker, E., and Wand, M., "Macro-by-example: </author> <title> deriving syntactic transformations from their specifications," </title> <booktitle> Conference Record of the Fourteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> Munich, Germany, </address> <pages> pp. 77-84, </pages> <year> 1987. </year>
Reference-contexts: This is reflected by the non-tail-recursive position of the other calls of old-style-expand in Figure 2. Also, continuations are not passed another continuation as a second parameter. 4 It should also be possible for EPS to coexist with the macro-by-example mechanism of Kohlbecker and Wand <ref> [6, 8] </ref>.
Reference: [9] <author> Plotkin, G., </author> <title> Call-by-name, call-by-value, and the -calculus, </title> <journal> Theoretical Computer Science, </journal> <volume> 1, </volume> <pages> pp. 125-159, </pages> <year> 1975. </year>
Reference-contexts: This is analogous to a function having control over how the value that it returns is used to continue the computation. Continuation-passing style (CPS) may be used to give the function this control <ref> [5, 9, 12] </ref>. In the macro? line of old-style-expand (see Figure 2), the recursive call occurs in a tail recursive position.
Reference: [10] <editor> Rees, J., and Clinger, W. (Eds.), </editor> <title> Revised 3 Report on the Algorithmic Language Scheme, </title> <journal> SIGPLAN Notices, </journal> <volume> 21, 12, </volume> <pages> pp. 37-79, </pages> <year> 1986. </year>
Reference-contexts: Some familiarity with Lisp and its traditional macro expansion mechanism is assumed. For a survey of macro expansion techniques, see [6]. 2. Coding Conventions The code that follows is expressed in Scheme, a lexically scoped dialect of Lisp <ref> [2, 10] </ref>. The only core syntactic forms|those that are not implemented as syntactic extensions|are given in Figure 1. Superscript "*" and * A preliminary version of this paper was presented at the 1986 ACM Symposium on Lisp and Functional Programming.
Reference: [11] <author> Steele, G. L., </author> <title> Common LISP: The Language, </title> <publisher> Digital Press, </publisher> <year> 1984. </year>
Reference-contexts: Because forms returned by expansion functions are themselves expanded, expansion functions can return forms involving other syntactic extensions. See Figure 2 for an expand function using this protocol that might be used with our core language. Each special form (there are 24 in Common Lisp <ref> [11] </ref>) must be treated as a special case. <p> For example, in the call-by-name expansion, it is not appropriate to perform the expansion on the application introduced by expanding a variable reference. Another case in which subexpressions require different expansion treatment is the definition of lexical syntactic extensions, in the manner of macrolet <ref> [11] </ref>. Lexical syntactic extensions require that the body of the form that introduces them be expanded in such a way that an additional keyword is recognized and associated with a new syntactic extension, which may override an existing syntactic extension.
Reference: [12] <author> Steele, G. L., </author> <title> LAMBDA: the ultimate declarative, </title> <journal> Artificial Intelligence Memo No. </journal> <volume> 379, </volume> <publisher> MIT, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1976. </year>
Reference-contexts: This is analogous to a function having control over how the value that it returns is used to continue the computation. Continuation-passing style (CPS) may be used to give the function this control <ref> [5, 9, 12] </ref>. In the macro? line of old-style-expand (see Figure 2), the recursive call occurs in a tail recursive position. <p> This function may or may not be used to perform further expansion. This is analogous to passing an explicit continuation to a function, which is well known to be a powerful programming technique (for example, see <ref> [1, 12] </ref>). In this paper we have demonstrated that the related technique of passing expanders explicitly provides a powerful tool for defining syntactic extensions.
Reference: [13] <author> Stoy, J., </author> <title> Denotational Semantics: The Scott-Strachey Approach to Programming Language Theory, </title> <publisher> MIT Press, </publisher> <year> 1977. </year> <month> 17 </month>
Reference-contexts: If x is not a variable or application, then it is passed to expander e along with expander e1 , which is used to expand subexpressions of x . The factorial function may be defined, in a way that dramatizes the normal order evaluation semantics, using the Y combinator <ref> [13] </ref>: 8 (install-expander 'call-by-name (lambda (x e ) (let ( (e1 (lambda (x e2 ) (cond ( (variable? x ) `(,x ) ) ( (application? x ) (call-by-name-application x e2 ) ) (else (e x e2 ) ) ) ) ) ) (e1 (cadr x ) e1 ) ) ) )
References-found: 13

