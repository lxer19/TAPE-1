URL: http://www.cs.ucsd.edu/~calder/papers/ICCA97.ps.Z
Refering-URL: http://www.cs.ucsd.edu/~calder/papers.html
Root-URL: http://www.cs.ucsd.edu
Email: fahashemi,kaelig@ece.neu.edu calder@cs.ucsd.edu  
Title: Procedure Mapping Using Static Call Graph Estimation  
Author: Amir H. Hashemi David R. Kaeli Brad Calder 
Address: Boston, MA La Jolla, CA  
Affiliation: Dept. of Electrical and Computer Engineering Dept. of Computer Science and Engineering Northeastern University University of California, San Diego  
Date: Feb. 1997  
Note: Appeared in the Workshop on Interaction between Compilers and Computer Architectures, San Antonio, Texas,  
Abstract: A number of software approaches to code reordering have been proposed. Their goal is to reduce the number of cache line conflicts. Most of these schemes use profile data in order to reposition the code in the address space. In this paper we present a link-time procedure mapping algorithm which uses a call graph constructed without the use of profile data. We will refer to this scheme as static call graph estimation. In this approach we use program-based heuristics to statically estimate the behavior of the call graph. Then once the estimated weighted call graph is formed, we can employ various procedure remapping algorithms. Our results show that we were able to reduce instruction cache miss rates by 20% on average when using our estimated static call graph with modern procedure reordering algorithms. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> T. Ball and J.R. Larus. </author> <title> Branch prediction for free. </title> <booktitle> In Proceedings of the SIGPLAN'93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 300-313, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Some of these techniques use heuristics based on local knowledge that can be encoded in the branch architecture [10, 14]. Other techniques rely on applying heuristics based on more detailed control flow analysis <ref> [1, 16, 17] </ref>. Still others have examined using machine learning techniques to statically predict the control flow at compile-time [2]. <p> While simple, BTFNT is also quite successful, since many programs spend a lot of time executing inside of loops and the backwards branch in a loop is correctly predicted as taken when using the BTFNT heuristic. In recent work, Ball and Larus <ref> [1] </ref> showed that applying a number of simple program-based heuristics can significantly improve the static branch prediction miss rate over BTFNT on tests based on the conditional branch operation. <p> Ball and Larus describe seven heuristics that they considered successful, but also noted that "We tried many heuristics that were unsuccessful. <ref> [1] </ref>" The prioritization problem has existed in the artificial intelligence community for many years and is commonly known as the "evidence combination" problem. <p> The sources of evidence used by Wu and Larus were the heuristic's branch prediction success from the paper of Ball and Larus <ref> [1] </ref>. Their algorithm propagated these branch probabilities throughout each procedure's basic block graph. After the intra-procedural estimated edge weights were calculated, the algorithm then propagated the call frequencies along the call graph edges to compute the inter-procedural estimated call edge weights. <p> We see many future directions for this work. We are currently modifying our algorithm to include more detailed branch heuristics and to use normalized probabilities for the estimated edge weights as in previous research <ref> [1, 16, 17] </ref>. We plan to extend the heuristics of Ball and Larus to more accurately predict which call paths will be frequently executed, and to examine other evidence combination techniques to propagate the estimated edge weights in the call graph.
Reference: [2] <author> B. Calder, D. Grunwald, M. Jones, D. Lindsay, J. Martin, M. Mozer, and B. Zorn. </author> <title> Evidence-based static branch prediction using machine learning. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 19(1), </volume> <year> 1997. </year>
Reference-contexts: Other techniques rely on applying heuristics based on more detailed control flow analysis [1, 16, 17]. Still others have examined using machine learning techniques to statically predict the control flow at compile-time <ref> [2] </ref>. In [5], Hank et al. showed that these program-based heuristics can be used to accurately guide profile-based optimizations, employing techniques such as superblock formation, achieving performance improvements close to those realized by using profile data.
Reference: [3] <author> P. P. Chang, S. A. Mahlke, and W. W. Hwu. </author> <title> Using profile information to assist classic compiler code optimizations. </title> <journal> Software Practice and Experience, </journal> <volume> 21(12) </volume> <pages> 1301-1321, </pages> <year> 1991. </year>
Reference-contexts: 1 Introduction Profile-based feedback optimizations have been used extensively to tune the performance of programs <ref> [3, 8] </ref>. Profile-based methods use a set of sample inputs to profile an application. These profiles are then fed back into an optimizer and are used to train the application to the data.
Reference: [4] <author> A. P. Dempster. </author> <title> A generalization of bayesian inference. </title> <journal> Journal of the Royal Statistical Society, </journal> <volume> 30 </volume> <pages> 205-247, </pages> <year> 1968. </year>
Reference-contexts: In that paper, their goal was to determine branch probabilities instead of simple branch prediction in order to provide program-based profile estimation. Wu and Larus abandoned the simplistic evidence combination function of using a best fixed order in favor of an evidence combination function borrowed from Dempster-Shafer theory <ref> [4, 13] </ref>. By making some fairly strong assumptions concerning the independence of different attributes, the Dempster-Shafer evidence combination function can produce an estimate of the branch probability from any number of sources of evidence.
Reference: [5] <author> R. Hank, S. Mahlke, R. Bringmann, J. Gyllen-haal, and W. Hwu. </author> <title> Superblock formation using static program analysis. </title> <booktitle> In 26th International Symposium on Microarchitecture, </booktitle> <pages> pages 247-256. </pages> <publisher> IEEE, </publisher> <year> 1993. </year>
Reference-contexts: Other techniques rely on applying heuristics based on more detailed control flow analysis [1, 16, 17]. Still others have examined using machine learning techniques to statically predict the control flow at compile-time [2]. In <ref> [5] </ref>, Hank et al. showed that these program-based heuristics can be used to accurately guide profile-based optimizations, employing techniques such as superblock formation, achieving performance improvements close to those realized by using profile data.
Reference: [6] <author> A.H. Hashemi, D.R. Kaeli, and B. Calder. </author> <title> Efficient procedure mapping using cache line coloring. </title> <note> WRL Research Report 96/3, </note> <month> October </month> <year> 1996. </year>
Reference-contexts: While many of these techniques have been shown to be effective in predicting program flow, none of these previous studies have attempted to apply their heuristics to procedure reordering. Prior work in procedure reordering used profiles to guide the program layout in order to reduce instruction cache conflicts <ref> [7, 6, 11] </ref>. In this paper we examine how to perform procedure reordering using heuristics to estimate the behavior of a program's call graph. By inspecting the high-level language branch constructs (e.g., loops, switches, conditional branches), we statically predict how often each edge in the call graph is 1 traversed. <p> To examine the performance of our statically estimated call graphs we apply these estimated edge weights to an existing procedure reordering algorithm. The procedure reordering algorithm we chose is our color mapping algorithm described in <ref> [6] </ref>. The algorithm processes the edges from the heaviest weighted to the lightest weighted. When processing an edge, the procedure's associated with the edge are mapped to the address space, and each procedure is assigned the cache lines (colors) used by that procedure in the address space. <p> These colors are then used to avoid cache conflicts with other procedures as they are mapped into the address space (see <ref> [6] </ref> for a complete description of the algorithm). Other algorithms have been proposed for procedure reordering such as the depth-first algorithm of Hwu and Chang [7], and the greedy edge weight algorithm of Pettis and Hansen [11]. In [6], we showed that our color mapping algorithm consistently outperformed the Pettis and <p> with other procedures as they are mapped into the address space (see <ref> [6] </ref> for a complete description of the algorithm). Other algorithms have been proposed for procedure reordering such as the depth-first algorithm of Hwu and Chang [7], and the greedy edge weight algorithm of Pettis and Hansen [11]. In [6], we showed that our color mapping algorithm consistently outperformed the Pettis and Hansen greedy algorithm. Therefore, in this paper we only provide results for our cache line color mapping algorithm. To study the effectiveness of procedure reordering we used the ATOM trace-driven simulation tool [15]. <p> Our procedure mapping algorithm uses a threshold value on the call graph edge weights in order to split a graph into 2 sets <ref> [6] </ref>. The edges and procedures with weights above the threshold value are included into the popular set of procedures and edges, and the remaining edges and procedures are labeled as unpopular. <p> We estimated the edge weights in the static call graph using simple heuristics which take into consideration the control flow structure of the program (e.g., loops, conditional branches, switch statements). We then used these estimated call graph edge weights to guide our color-based procedure reordering algorithm <ref> [6] </ref>. Our results show that the static call graph estimation was able to reduce the cache miss rate of the original program on average by 20%.
Reference: [7] <author> W.W. Hwu and P.P. Chang. </author> <title> Achieving high instruction cache performance with an optimizing compiler. </title> <booktitle> In 16th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 242-251. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: While many of these techniques have been shown to be effective in predicting program flow, none of these previous studies have attempted to apply their heuristics to procedure reordering. Prior work in procedure reordering used profiles to guide the program layout in order to reduce instruction cache conflicts <ref> [7, 6, 11] </ref>. In this paper we examine how to perform procedure reordering using heuristics to estimate the behavior of a program's call graph. By inspecting the high-level language branch constructs (e.g., loops, switches, conditional branches), we statically predict how often each edge in the call graph is 1 traversed. <p> These colors are then used to avoid cache conflicts with other procedures as they are mapped into the address space (see [6] for a complete description of the algorithm). Other algorithms have been proposed for procedure reordering such as the depth-first algorithm of Hwu and Chang <ref> [7] </ref>, and the greedy edge weight algorithm of Pettis and Hansen [11]. In [6], we showed that our color mapping algorithm consistently outperformed the Pettis and Hansen greedy algorithm. Therefore, in this paper we only provide results for our cache line color mapping algorithm.
Reference: [8] <author> G.P. Lowney, S.M. Freudenberger, T.J. Karzes, W.D. Lichtenstein, R.P. Nix, J.S. O'Donnell, and J.C. Ruttenberg. </author> <title> The multiflow trace scheduling compiler. </title> <journal> Journal of Supercomputing, </journal> <volume> 7 </volume> <pages> 51-142, </pages> <year> 1993. </year>
Reference-contexts: 1 Introduction Profile-based feedback optimizations have been used extensively to tune the performance of programs <ref> [3, 8] </ref>. Profile-based methods use a set of sample inputs to profile an application. These profiles are then fed back into an optimizer and are used to train the application to the data.
Reference: [9] <author> S. McFarling. </author> <title> Program optimization for instruction caches. </title> <booktitle> In Proceedings of the Third International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS III), </booktitle> <pages> pages 183-191, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: The result for bison is also of special interest. Here we are actually outperforming the profile-driven color-based repositioning. This highlights the fact that profile data does not capture the temporal locality exhibited by a single procedure, and that finding an optimal mapping to minimize conflicts is NP-complete <ref> [9] </ref>. To further improve on these results, we plan to investigate the following issues: 1. Incorporate static branch prediction techniques to improve upon the one-half heuristic currently used for conditional branches. 2. Identify commonly called, but infrequently vis ited, procedures (e.g., exit (), error ()). 3.
Reference: [10] <author> S. McFarling and J. Hennessy. </author> <title> Reducing the cost of branches. </title> <booktitle> In 13th Annual International Symposium of Computer Architecture, </booktitle> <pages> pages 396-403. </pages> <institution> Association for Computing Machinery, </institution> <year> 1986. </year>
Reference-contexts: Program-based estimation methods attempt to predict branches and estimate the control flow of a program based on a program's structure. Some of these techniques use heuristics based on local knowledge that can be encoded in the branch architecture <ref> [10, 14] </ref>. Other techniques rely on applying heuristics based on more detailed control flow analysis [1, 16, 17]. Still others have examined using machine learning techniques to statically predict the control flow at compile-time [2].
Reference: [11] <author> K. Pettis and R.C. Hansen. </author> <title> Profile guided code positioning. </title> <booktitle> In Proceedings of the ACM SIG-PLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 16-27. </pages> <publisher> ACM, ACM, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: While many of these techniques have been shown to be effective in predicting program flow, none of these previous studies have attempted to apply their heuristics to procedure reordering. Prior work in procedure reordering used profiles to guide the program layout in order to reduce instruction cache conflicts <ref> [7, 6, 11] </ref>. In this paper we examine how to perform procedure reordering using heuristics to estimate the behavior of a program's call graph. By inspecting the high-level language branch constructs (e.g., loops, switches, conditional branches), we statically predict how often each edge in the call graph is 1 traversed. <p> Other algorithms have been proposed for procedure reordering such as the depth-first algorithm of Hwu and Chang [7], and the greedy edge weight algorithm of Pettis and Hansen <ref> [11] </ref>. In [6], we showed that our color mapping algorithm consistently outperformed the Pettis and Hansen greedy algorithm. Therefore, in this paper we only provide results for our cache line color mapping algorithm. To study the effectiveness of procedure reordering we used the ATOM trace-driven simulation tool [15].
Reference: [12] <author> C.V. Ramamoorthy. </author> <title> Discrete markov analysis of computer programs. </title> <booktitle> In 20th National Conference, </booktitle> <pages> pages 386-391. </pages> <publisher> ACM, </publisher> <year> 1965. </year>
Reference-contexts: They also applied the heuristics in a fixed order. They used the heuristic probabilities as did Wu and Larus, but instead used Markov Modeling to propagate the probabilities through the control flow graph <ref> [12] </ref>. This creates basic block graphs and call graphs with estimated edge weights. Both the Wu and Larus and the Wagner et al. study examined statically estimating the program's behavior.
Reference: [13] <author> G. Shafer. </author> <title> A Mathematical Theory of Evidence. </title> <publisher> Princeton University Press, </publisher> <address> Princeton, NJ, </address> <year> 1976. </year>
Reference-contexts: In that paper, their goal was to determine branch probabilities instead of simple branch prediction in order to provide program-based profile estimation. Wu and Larus abandoned the simplistic evidence combination function of using a best fixed order in favor of an evidence combination function borrowed from Dempster-Shafer theory <ref> [4, 13] </ref>. By making some fairly strong assumptions concerning the independence of different attributes, the Dempster-Shafer evidence combination function can produce an estimate of the branch probability from any number of sources of evidence.
Reference: [14] <author> J. E. Smith. </author> <title> A study of branch prediction strategies. </title> <booktitle> In 8th Annual International Symposium of Computer Architecture, </booktitle> <pages> pages 135-148. </pages> <publisher> ACM, </publisher> <year> 1981. </year>
Reference-contexts: Program-based estimation methods attempt to predict branches and estimate the control flow of a program based on a program's structure. Some of these techniques use heuristics based on local knowledge that can be encoded in the branch architecture <ref> [10, 14] </ref>. Other techniques rely on applying heuristics based on more detailed control flow analysis [1, 16, 17]. Still others have examined using machine learning techniques to statically predict the control flow at compile-time [2].
Reference: [15] <author> A. Srivastava and A. Eustace. </author> <title> ATOM: A system for building customized program analysis tools. </title> <booktitle> In Proceedings of the Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 196-205. </pages> <publisher> ACM, </publisher> <year> 1994. </year>
Reference-contexts: In [6], we showed that our color mapping algorithm consistently outperformed the Pettis and Hansen greedy algorithm. Therefore, in this paper we only provide results for our cache line color mapping algorithm. To study the effectiveness of procedure reordering we used the ATOM trace-driven simulation tool <ref> [15] </ref>. ATOM is an execution-driven simulation tool for the DEC Alpha processor.
Reference: [16] <author> T.A. Wagner, V. Maverick, S. Graham, and M. Harrison. </author> <title> Accurate static estimators for program optimization. </title> <booktitle> In Proceedings of the Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 85-96, </pages> <address> Orlando, Florida, </address> <month> June </month> <year> 1994. </year> <note> ACM. </note>
Reference-contexts: Some of these techniques use heuristics based on local knowledge that can be encoded in the branch architecture [10, 14]. Other techniques rely on applying heuristics based on more detailed control flow analysis <ref> [1, 16, 17] </ref>. Still others have examined using machine learning techniques to statically predict the control flow at compile-time [2]. <p> Their algorithm propagated these branch probabilities throughout each procedure's basic block graph. After the intra-procedural estimated edge weights were calculated, the algorithm then propagated the call frequencies along the call graph edges to compute the inter-procedural estimated call edge weights. Wagner et al. <ref> [16] </ref> also used heuristics similar to those of Ball and Larus to perform program-based profile estimation. They also applied the heuristics in a fixed order. They used the heuristic probabilities as did Wu and Larus, but instead used Markov Modeling to propagate the probabilities through the control flow graph [12]. <p> We see many future directions for this work. We are currently modifying our algorithm to include more detailed branch heuristics and to use normalized probabilities for the estimated edge weights as in previous research <ref> [1, 16, 17] </ref>. We plan to extend the heuristics of Ball and Larus to more accurately predict which call paths will be frequently executed, and to examine other evidence combination techniques to propagate the estimated edge weights in the call graph.
Reference: [17] <author> Y. Wu and J.R. Larus. </author> <title> Static branch frequency and program profile analysis. </title> <booktitle> In 27th International Symposium on Microarchitecture, </booktitle> <pages> pages 1-11, </pages> <address> San Jose, Ca, </address> <month> November </month> <year> 1994. </year> <journal> IEEE. </journal> <volume> 7 </volume>
Reference-contexts: Some of these techniques use heuristics based on local knowledge that can be encoded in the branch architecture [10, 14]. Other techniques rely on applying heuristics based on more detailed control flow analysis <ref> [1, 16, 17] </ref>. Still others have examined using machine learning techniques to statically predict the control flow at compile-time [2]. <p> They determined the "best" fixed order by conducting an experiment in which all possible orders were considered. In a related paper, Wu and Larus extended the heuristic-based methods of Ball and Larus <ref> [17] </ref> to statically estimate the edge weights of the program's control flow graph. In that paper, their goal was to determine branch probabilities instead of simple branch prediction in order to provide program-based profile estimation. <p> We see many future directions for this work. We are currently modifying our algorithm to include more detailed branch heuristics and to use normalized probabilities for the estimated edge weights as in previous research <ref> [1, 16, 17] </ref>. We plan to extend the heuristics of Ball and Larus to more accurately predict which call paths will be frequently executed, and to examine other evidence combination techniques to propagate the estimated edge weights in the call graph.
References-found: 17

