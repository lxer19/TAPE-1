URL: ftp://ftp.cs.kun.nl/pub/CSI/SoftwEng.FunctLang/papers/achp95-ConcurrIO.ps.gz
Refering-URL: http://www.cs.kun.nl/~clean/Clean.Papers.html
Root-URL: 
Email: peter88@cs.kun.nl, rinus@cs.kun.nl  
Title: Concurrent Interactive Processes in a Pure Functional Language  
Author: Peter Achten and Rinus Plasmeijer 
Address: Nijmegen, Toernooiveld 1, 6525ED, Nijmegen, The Netherlands  
Affiliation: Computing Science Institute, University of  
Abstract: In this paper we present an operational semantics for concurrent interactive pro cess es in the purely functional programming language Clean. An in teractive process is in essence a state transi - tion system which apart from its logical state can also access the state of the file system, do high - level Graphical User I/O, and do inter-process communication via synchronous and asynchronous message passing and data sharing. Inter-process commu nication is typesafe and polymorphic . The semantics of the sys tem is based on earlier work on the Interleaved Event I/O system. In this paper we identi fy limitations of the inter leaved model in the context of concurrent processes and propose a new process semantics that does allow a concurrent implementation. The method basi cally intro duces a Remote Procedure Call communication scheme and demonstrates how to ap ply this scheme to obtain a concurrent process semantics. The resulting system is the Concur rent Event I/O system . The operational semantics is given in Clean itself. As a re sult the concur rency system is completely func tional because the construction is done within the pure func tional framework.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Achten, P.M., Groningen J.H.G. van, and Plasmeijer, M.J. </author> <year> 1993. </year> <title> High Level Spec ifica tion of I/O in Func - tional Languages. </title> <editor> In Launchbury, J., Sansom, P. eds. </editor> <booktitle> Proc. Glasgow Workshop on Functional Pro gram-ming , Ayr, </booktitle> <address> Scotland, </address> <month> 6-8 July </month> <year> 1992, </year> <title> Workshops in Com puting, </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1993, </year> <pages> pp. 1-17. </pages>
Reference: [2] <author> Achten, P.M. and Plasmeijer, M.J. </author> <year> 1994. </year> <title> A Framework for Deterministically Interleaved Interac tive Pro - grams in the Functional Programming Language Clean. </title> <editor> In Bakker. E. ed. </editor> <booktitle> Proc. Com puting Science in the Netherlands, </booktitle> <address> CSN94 , Jaarbeurs Utrecht, The Netherlands, </address> <month> November 21-22, </month> <institution> Stichting Mathe matisch Centrum, </institution> <address> Amsterdam, </address> <year> 1994, </year> <pages> pp. 30-41. </pages>
Reference-contexts: This yields a new state value. This is repeated until termina tion of the program. The Interleaved Event I/O system is the extension of the Event I/O system with interactive processes <ref> [2] </ref>. Interactive processes are the conceptual units by which Clean programmers can construct more complex in teractive programs from simpler interactive programs. The main difference with the Event I/O system is that these processes coexist in an interleaved fashion, hence the name of the sys tem. <p> This expo - sition is basically an ex tended abstract of <ref> [2] </ref>. Clean [6,9,10] is a lazy func tional program ming language based on Term Graph Rewriting [4]. The pro grams in this paper are writ ten in Clean 1.0 [11]. Most of the language con structs used in Clean 1.0 are customary in other func tional lan guages. <p> The main functions of the definition of SendRPC is given in appendix 2. The full definition can be found in the appendices 2-6. For reasons of space we do not repeat the process management data types and operations (these can be found in <ref> [2] </ref>) and introduce them informally instead: the data type GState (g lobal state ) con tains the complete process structure of an interactive program. Given the process identification of some in teractive process contextSwitchIn transforms a given global state into the re quired process state. <p> In comparison with the Interleaved Event I/O system which applies a deterministic, round - robin interleaving order of interactive processes <ref> [2] </ref> the system described here is essentially non-de - terministic. This has a number of consequences when reasoning about the evaluation of interactive pro cesses. Let A be the interactive process that ap plies SendRPC and B the RPC process.
Reference: [3] <author> Achten, P.M. and Plasmeijer, M.J. </author> <year> 1995. </year> <title> The ins and outs of Clean I/O. In Journal of Functional Pro - gramming 5(1) - January 1995, </title> <publisher> Cambridge University Press, </publisher> <pages> pp. 81-110. </pages>
Reference-contexts: However, the semantics 1 The set of functions is structured by means of algebraic data types which are abstract definitions of Graphical User Interface elements. For more details see <ref> [3] </ref>. cannot without modi fication be used to explain the semantics of true parallel evaluation of interactive processes. We are in terested in such a concurrency model because we intend to program real distributed interactive applications using the Graphi cal User Interface tools from the Event I/O system.
Reference: [4] <author> Barendregt, H.P., Eekelen, M.C.J.D. van, Glauert, J.R.W., Kennaway, J.R., Plasmeijer, M.J., and Sleep, </author> <title> M.R. 1987. Term Graph Rewriting. </title> <editor> In Bakker, J.W. de, Nijman, A.J., Treleaven, P.C. eds. </editor> <booktitle> Proc. </booktitle> <editor> Par al lel Ar chitectures and Lan guages Europe , Eind hoven, </editor> <address> The Netherlands, </address> <publisher> LNCS 259, Vol.II, Springer-Verlag, Berlin, </publisher> <pages> pp. 141-158. </pages>
Reference-contexts: This expo - sition is basically an ex tended abstract of [2]. Clean [6,9,10] is a lazy func tional program ming language based on Term Graph Rewriting <ref> [4] </ref>. The pro grams in this paper are writ ten in Clean 1.0 [11]. Most of the language con structs used in Clean 1.0 are customary in other func tional lan guages. Where appropriate, the text in cludes remarks on particu - lar aspects of Clean 1.0.
Reference: [5] <author> Barendsen, E. and Smetsers, J.E.W. </author> <year> 1993. </year> <title> Con ventional and Uniqueness Typing in Graph Rewrite Sys - tems. In Shyamasundar, R.K. </title> <editor> ed. Pro c. </editor> <booktitle> 13th Con ference on the Foundations of Software Tech nology and The oretical Com puter Science , 1517 December 1993, </booktitle> <address> Bombay, India, </address> <publisher> LNCS 761, Springer-Verlag, Berlin, </publisher> <pages> pp. 41-51. </pages>
Reference: [6] <author> Brus, T., Eekelen, M.C.J.D. van, Leer, M.O. van, Plasmeijer, M.J., and Barendregt, </author> <title> H.P. 1987. Clean: A Lan guage for Functional Graph Rewriting. </title> <editor> In Kahn. G. ed. </editor> <booktitle> Proc. 3rd International Conference on Func tional Program ming Languages and Computer Ar chitec ture, </booktitle> <address> Portland, Ore gon, USA, </address> <publisher> LNCS 274, Springer-Verlag, </publisher> <pages> pp. 364-384. </pages>
Reference: [7] <author> Milner, R. </author> <year> 1989. </year> <title> Communication and Concurrency. </title> <publisher> Prentice-Hall, </publisher> <year> 1989. </year>
Reference-contexts: Essentially, the sorting office implements a nondeterministic merge of all messages outside the language. A different direction is taken in the Facile language [15]. Facile is based on the SML/NJ version [13] of Standard ML [8] and extends it with higher-order concurrent processes based on CCS <ref> [7] </ref>. It should be noted that Facile is not a pure functional language as it is based on Standard ML. Facile al - lows the creation of processes defined by arbitrary functions.
Reference: [8] <author> Milner, R., Tofte, M., and Harper, R. </author> <year> 1993. </year> <title> Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: Essentially, the sorting office implements a nondeterministic merge of all messages outside the language. A different direction is taken in the Facile language [15]. Facile is based on the SML/NJ version [13] of Standard ML <ref> [8] </ref> and extends it with higher-order concurrent processes based on CCS [7]. It should be noted that Facile is not a pure functional language as it is based on Standard ML. Facile al - lows the creation of processes defined by arbitrary functions.
Reference: [9] <author> Ncker, E.G.J.M.H., Smetsers, J.E.W., Eekelen, M.C.J.D. van, and Plasmeijer, M.J. </author> <year> 1991. </year> <title> Con current Clean. </title> <editor> In Aarts, E.H.L., Leeuwen, J. van, Rem, M., eds, Pro c. Paral lel Ar chitectures and Lan guages Eu-rope, </editor> <address> June, Eind hoven, The Netherlands, </address> <publisher> LNCS 506, Springer-Ver lag,pp. </publisher> <pages> 202-219. </pages>
Reference-contexts: So we have an imple mentation that sequentially simulates concurrent processes. In this section we consider how to obtain an implementation of the Con current Event I/O system that allows for concurrent processes using the concur rency primitives of Clean <ref> [9] </ref>. With the concurrency primitives of Clean a programmer can create new reduction processes that either are evaluated on the cur rent processor (using the I annota tion), or on another processor (using the P annotation). These reduction processes evaluate the annotated functional expression to root-normal-form.
Reference: [10] <author> Plasmeijer, M.J. and Eekelen, M.C.J.D. </author> <title> van 1993. Functional Program ming and Paral lel Graph Rewriting . Addi son-Wes ley Publishing Company 1993. </title>
Reference: [11] <author> Plasmeijer, M.J. and Eekelen, M.C.J.D. </author> <title> van 1994. Concur rent Clean 1.0 Language Report. </title> <institution> Tech nical Re - port , in prepara tion, Univer sity of Nijmegen, The Nether lands. </institution>
Reference-contexts: This expo - sition is basically an ex tended abstract of [2]. Clean [6,9,10] is a lazy func tional program ming language based on Term Graph Rewriting [4]. The pro grams in this paper are writ ten in Clean 1.0 <ref> [11] </ref>. Most of the language con structs used in Clean 1.0 are customary in other func tional lan guages. Where appropriate, the text in cludes remarks on particu - lar aspects of Clean 1.0. Clean programs are functions of type *World fi *World .
Reference: [12] <author> Smetsers, J.E.W., Barendsen, E., Eekelen, M.C.J.D. van, and Plasmeijer, M.J. </author> <year> 1993. </year> <title> Guarantee ing Safe De structive Updates through a Type Sys tem with Uniqueness Information for Graphs. </title> <editor> In Schneider, H.J., Ehrig, H. eds. </editor> <booktitle> Proc. Workshop Graph Transforma tions in Computer Sci ence, </booktitle> <address> Dagstuhl Cas tle, Germany, </address> <month> January 4-8, </month> <title> 1993. </title> <publisher> LNCS 776, Springer-Verlag, Berlin, </publisher> <pages> pp. 358-379. </pages>
Reference: [13] <institution> Standard ML of New Jersey Base Environment (version 0.93), </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: Essentially, the sorting office implements a nondeterministic merge of all messages outside the language. A different direction is taken in the Facile language [15]. Facile is based on the SML/NJ version <ref> [13] </ref> of Standard ML [8] and extends it with higher-order concurrent processes based on CCS [7]. It should be noted that Facile is not a pure functional language as it is based on Standard ML. Facile al - lows the creation of processes defined by arbitrary functions.
Reference: [14] <author> Stoye, W.R. </author> <year> 1984. </year> <title> A new scheme for writing func tional operat ing systems. </title> <type> Technical Report 56, </type> <institution> Computer Laboratory, Cambridge University, </institution> <year> 1984. </year>
Reference-contexts: One particular system is the Kent Ap plicative Operat ing System project [16]. The system is based on earlier work by Stoye <ref> [14] </ref>. Both sys tems allow dynamic creation of func tional processes. Processes are in essence stream processors , functions that transform an ingoing stream to an outgoing stream. Process scheduling is based on evaluation on demand of the outgoing stream and withholding further in put.
Reference: [15] <author> Thomsen, B., Leth, L., Prasad, S., Kuo, T-M., Kramer, A., Knabe, F., and Giacalone, A. </author> <year> 1993. </year> <title> Facile an - tigua release programming guide. </title> <institution> Technical Report , European Computer-Industry Research Centre (ECRC), </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: Inter-process communi ca tion by message passing is based on the sorting office con cept intro duced by Stoye. Essentially, the sorting office implements a nondeterministic merge of all messages outside the language. A different direction is taken in the Facile language <ref> [15] </ref>. Facile is based on the SML/NJ version [13] of Standard ML [8] and extends it with higher-order concurrent processes based on CCS [7]. It should be noted that Facile is not a pure functional language as it is based on Standard ML.
Reference: [16] <author> Turner, D.A. </author> <year> 1990. </year> <title> An Approach to Functional Operating Sys tems. In Turner, D.A. ed. Re search top ics in Func tional Programming, </title> <publisher> Addison-Wesley Pub lishing Com pany, </publisher> <pages> pp. 199-217. </pages>
Reference-contexts: One particular system is the Kent Ap plicative Operat ing System project <ref> [16] </ref>. The system is based on earlier work by Stoye [14]. Both sys tems allow dynamic creation of func tional processes. Processes are in essence stream processors , functions that transform an ingoing stream to an outgoing stream.
References-found: 16

