URL: ftp://ftp.ics.hawaii.edu/pub/tr/ics-tr-93-10.ps.Z
Refering-URL: ftp://ftp.ics.hawaii.edu/pub/tr/INDEX.html
Root-URL: 
Title: Identical Tasks and Counter Variables in an Integer Programming-Based Approach to Verification  
Author: James C. Corbett 
Affiliation: Information and Computer Science Department University of Hawaii at Manoa  
Abstract: Analysis of concurrent systems is plagued by the state explosion problem. The constrained expression analysis technique uses necessary conditions, in the form of linear inequalities, to verify certain properties of concurrent systems without enumerating the system's states. While effective against the state explosion due to interleaving, the technique fails to yield a tractable analysis if the size of the components themselves grow exponentially due to the use of variables in the components. As a partial solution to this problem, we present a technique for representing certain program variables as integer programming variables. We also present a synergistic technique for efficiently representing many identical components in the context of an integer programming analysis. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. S. Avrunin, U. A. Buy, and J. C. Corbett. </author> <title> Integer programming in the analysis of concurrent systems. </title> <booktitle> In Larsen and Skou [12], </booktitle> <pages> pages 92-102. </pages>
Reference-contexts: Many techniques have been proposed to cope with this state explosion problem, including symbolic model checking (e.g., [3]), abstraction (e.g., [6]), partial order techniques (e.g., [11,15]), compositional techniques (e.g., [4, 16]), and integer linear programming (ILP) techniques (e.g., [2, 14]). One integer programming approach, constrained expressions <ref> [1] </ref>, is capable of verifying general safety and liveness properties (such as deadlock and starvation) [8] and has been successfully applied to a range of concurrent systems [2]. It has the additional advantage of being applicable to concurrent system specifications and designs expressed in a broad range of notations [9]. <p> Experiments with both techniques are presented in Section 5 and Section 6 concludes. 2 Model and Basic Technique As in <ref> [1] </ref>, we model a concurrent system as a collection of communicating finite state automata (FSAs) with additional restrictions expressed as a set of recursive languages on the alphabets of the FSAs. The acceptance of a symbol by an automaton represents the occurrence of an event in the concurrent system.
Reference: [2] <author> G. S. Avrunin, U. A. Buy, J. C. Corbett, L. K. Dillon, and J. C. Wileden. </author> <title> Automated analysis of concurrent systems with the constrained expression toolset. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 17(11) </volume> <pages> 1204-1222, </pages> <month> Nov. </month> <year> 1991. </year>
Reference-contexts: Many techniques have been proposed to cope with this state explosion problem, including symbolic model checking (e.g., [3]), abstraction (e.g., [6]), partial order techniques (e.g., [11,15]), compositional techniques (e.g., [4, 16]), and integer linear programming (ILP) techniques (e.g., <ref> [2, 14] </ref>). One integer programming approach, constrained expressions [1], is capable of verifying general safety and liveness properties (such as deadlock and starvation) [8] and has been successfully applied to a range of concurrent systems [2]. <p> One integer programming approach, constrained expressions [1], is capable of verifying general safety and liveness properties (such as deadlock and starvation) [8] and has been successfully applied to a range of concurrent systems <ref> [2] </ref>. It has the additional advantage of being applicable to concurrent system specifications and designs expressed in a broad range of notations [9]. This approach uses necessary conditions, in the form of linear inequalities, to verify properties of a system without enumerating the system's states. <p> For now, we do not model the value of c nor enforce the guards. In Section 4, we will show how to create K identical copies of the customer. For now, we use only one customer. Using this example, we review the basic technique for inequality generation described in <ref> [2] </ref>. We take the set of event symbols appearing in an FSA or restriction language as its alphabet. The basic technique uses necessary conditions, in the form of linear inequalities, to either help find a trace with certain properties or prove that no such trace could exist. <p> If such a solution arises, the analysis is inconclusive since the presence of that solution implies nothing about the existence of another solution that does correspond to a trace. In our experience <ref> [2] </ref>, however, such spurious solutions are uncommon. We verify a property P by constructing necessary conditions for the existence of a trace violating P . If these necessary conditions are unsatisfiable, then there cannot exist a trace violating P , thus P must hold. <p> These techniques have been automated as part of the constrained expression toolset <ref> [2] </ref> and applied to a handful of standard problems from the literature. Each problem is scaled up to get an idea of how quickly the analysis times grow with the problem size.
Reference: [3] <author> J. Burch, E. Clarke, K. McMillan, D. Dill, and L. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <booktitle> In Proceedings of the Fifth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 428-439, </pages> <year> 1990. </year>
Reference-contexts: Many techniques have been proposed to cope with this state explosion problem, including symbolic model checking (e.g., <ref> [3] </ref>), abstraction (e.g., [6]), partial order techniques (e.g., [11,15]), compositional techniques (e.g., [4, 16]), and integer linear programming (ILP) techniques (e.g., [2, 14]). <p> Both of these problems have been studied before. Certain uses of variables (e.g., register values transformed by an ALU) have been represented very efficiently using BDDs <ref> [3] </ref> and a different technique for analyzing systems with counters is given in [13]. Systems with an arbitrary number of identical tasks have been verified using analyst-specified closures [5] or more recently by a fully automatic technique described in [10].
Reference: [4] <author> E. Clarke, D. Long, and K. McMillan. </author> <title> Compositional model checking. </title> <booktitle> In Proceedings of the Fourth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <year> 1989. </year>
Reference-contexts: Many techniques have been proposed to cope with this state explosion problem, including symbolic model checking (e.g., [3]), abstraction (e.g., [6]), partial order techniques (e.g., [11,15]), compositional techniques (e.g., <ref> [4, 16] </ref>), and integer linear programming (ILP) techniques (e.g., [2, 14]). One integer programming approach, constrained expressions [1], is capable of verifying general safety and liveness properties (such as deadlock and starvation) [8] and has been successfully applied to a range of concurrent systems [2].
Reference: [5] <author> E. M. Clarke and O. Grumberg. </author> <title> Avoiding the state explosion problem in temporal logic model checking algorithms. </title> <booktitle> In Proceedings of the Sixth Anual ACM Symposium on the Principles of Distributed Computing, </booktitle> <pages> pages 294-303, </pages> <year> 1987. </year>
Reference-contexts: Certain uses of variables (e.g., register values transformed by an ALU) have been represented very efficiently using BDDs [3] and a different technique for analyzing systems with counters is given in [13]. Systems with an arbitrary number of identical tasks have been verified using analyst-specified closures <ref> [5] </ref> or more recently by a fully automatic technique described in [10]. Both of these techniques use a form of induction to prove properties of systems with an arbitrary number of identical tasks.
Reference: [6] <author> E. M. Clarke, O. Grumberg, and D. E. </author> <title> Long. Model checking and abstraction. </title> <booktitle> In Proceedings of the 19th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 343-354, </pages> <month> Jan. </month> <year> 1992. </year>
Reference-contexts: Many techniques have been proposed to cope with this state explosion problem, including symbolic model checking (e.g., [3]), abstraction (e.g., <ref> [6] </ref>), partial order techniques (e.g., [11,15]), compositional techniques (e.g., [4, 16]), and integer linear programming (ILP) techniques (e.g., [2, 14]).
Reference: [7] <author> J. C. Corbett. </author> <title> Automated Formal Analysis Methods for Concurrent and Real-Time Software. </title> <type> PhD thesis, </type> <institution> University of Massachusetts at Amherst, </institution> <year> 1992. </year> <note> Available as COINS Technical Report 92-48. </note>
Reference-contexts: Assuming this, we may write the restriction inequality for channel e as jh c (e)j + K jh a (e)j K where K is the number of times the caller of channel e is replicated. The communication equations do not change. The correctness of these conditions is proved in <ref> [7] </ref>. We now apply the technique to the example of Figure 1 to create K identical customer tasks. We need only change three inequalities, the modified versions of which are shown in Figure 5.
Reference: [8] <author> J. C. Corbett. </author> <title> Verifying general safety and live-ness properties with integer programming. </title> <editor> In G. von Bochmann, editor, </editor> <booktitle> Computer Aided Verification, 4th International Workshop Proceedings, </booktitle> <pages> pages 337-348, </pages> <address> Montreal, Canada, </address> <year> 1992. </year>
Reference-contexts: One integer programming approach, constrained expressions [1], is capable of verifying general safety and liveness properties (such as deadlock and starvation) <ref> [8] </ref> and has been successfully applied to a range of concurrent systems [2]. It has the additional advantage of being applicable to concurrent system specifications and designs expressed in a broad range of notations [9]. <p> Here, we sought to verify that a writer cannot starve waiting for access to the data once it has made a request to the controller. To verify this property, we combined the techniques in this paper with those for verifying general safety and live-ness properties described in <ref> [8] </ref>. The performance of the automated tools on several sizes of this problem is shown in Table 3. In each case, the inequality system was found to have no integral solution, proving a writer cannot starve. The 1000 reader/writer system has over 10 300 reachable states.
Reference: [9] <author> L. K. Dillon, G. S. Avrunin, and J. C. Wileden. </author> <title> Constrained expressions: Toward broad applicability of analysis methods for distributed software systems. </title> <journal> ACM Trans. Prog. Lang. Syst., </journal> <volume> 10(3) </volume> <pages> 374-402, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: It has the additional advantage of being applicable to concurrent system specifications and designs expressed in a broad range of notations <ref> [9] </ref>. This approach uses necessary conditions, in the form of linear inequalities, to verify properties of a system without enumerating the system's states.
Reference: [10] <author> S. M. German and A. P. Sistla. </author> <title> Reasoning about systems with many processes. </title> <journal> J. ACM, </journal> <volume> 39(3) </volume> <pages> 675-735, </pages> <year> 1992. </year>
Reference-contexts: Systems with an arbitrary number of identical tasks have been verified using analyst-specified closures [5] or more recently by a fully automatic technique described in <ref> [10] </ref>. Both of these techniques use a form of induction to prove properties of systems with an arbitrary number of identical tasks. <p> While our technique can only prove properties of a system with a specific number of copies (i.e., K must be a constant), calculating a safe upper bound for a real system should be possible. Since the automatic technique in <ref> [10] </ref> is doubly-exponential in the size of the tasks, it may not be tractable if the non-replicated part of the system is nontrivial. The paper is organized as follows. Section 2 reviews the model and basic technique.
Reference: [11] <author> P. Godefroid and P. Wolper. </author> <title> Using partial orders for the efficient verification of deadlock freedom and safety properties. </title> <booktitle> In Larsen and Skou [12], </booktitle> <pages> pages 332-242. </pages>
Reference: [12] <editor> K. G. Larsen and A. Skou, editors. </editor> <booktitle> Computer Aided Verification, 3rd International Workshop Proceedings, volume 575 of Lecture Notes in Computer Science, </booktitle> <address> Aalborg, Denmark, July 1991. </address> <publisher> Springer-Verlag. </publisher>
Reference: [13] <author> E. Macii, B. Plessier, and F. Somenzi. </author> <title> Verification of systems containing counters. </title> <booktitle> In Proceedings of IEEE International Conference on Computer-Aided Design, </booktitle> <year> 1992. </year>
Reference-contexts: Both of these problems have been studied before. Certain uses of variables (e.g., register values transformed by an ALU) have been represented very efficiently using BDDs [3] and a different technique for analyzing systems with counters is given in <ref> [13] </ref>. Systems with an arbitrary number of identical tasks have been verified using analyst-specified closures [5] or more recently by a fully automatic technique described in [10]. Both of these techniques use a form of induction to prove properties of systems with an arbitrary number of identical tasks.
Reference: [14] <author> T. Murata, B. Shenker, and S. M. Shatz. </author> <title> Detection of Ada static deadlocks using Petri net invariants. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 15(3) </volume> <pages> 314-326, </pages> <year> 1989. </year>
Reference-contexts: Many techniques have been proposed to cope with this state explosion problem, including symbolic model checking (e.g., [3]), abstraction (e.g., [6]), partial order techniques (e.g., [11,15]), compositional techniques (e.g., [4, 16]), and integer linear programming (ILP) techniques (e.g., <ref> [2, 14] </ref>). One integer programming approach, constrained expressions [1], is capable of verifying general safety and liveness properties (such as deadlock and starvation) [8] and has been successfully applied to a range of concurrent systems [2].
Reference: [15] <author> A. Valmari. </author> <title> A stubborn attack on state explosion. </title> <editor> In E. M. Clarke and R. P. Kurshan, editors, </editor> <booktitle> Computer-Aided Verification '90, number 3 in DI-MACS Series in Discrete Mathematics and Theoretical Computer Science, </booktitle> <pages> pages 25-41, </pages> <address> Providence, RI, 1991. </address> <publisher> American Mathematical Society. </publisher>
Reference: [16] <author> W. J. Yeh and M. Young. </author> <title> Compositional reacha-bility analysis using process algebra. </title> <booktitle> In Proceedings of the Symposium on Testing, Analysis, and Verification (TAV4), </booktitle> <pages> pages 178-187, </pages> <address> New York, </address> <month> Oct. </month> <year> 1991. </year> <institution> ACM SIGSOFT, Association for Computing Machinery. </institution>
Reference-contexts: Many techniques have been proposed to cope with this state explosion problem, including symbolic model checking (e.g., [3]), abstraction (e.g., [6]), partial order techniques (e.g., [11,15]), compositional techniques (e.g., <ref> [4, 16] </ref>), and integer linear programming (ILP) techniques (e.g., [2, 14]). One integer programming approach, constrained expressions [1], is capable of verifying general safety and liveness properties (such as deadlock and starvation) [8] and has been successfully applied to a range of concurrent systems [2].
References-found: 16

