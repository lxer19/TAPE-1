URL: http://www.cs.unc.edu/~anderson/papers/disc98b.ps.Z
Refering-URL: http://www.cs.unc.edu/~anderson/papers.html
Root-URL: http://www.cs.unc.edu
Title: Wait-Free Synchronization in Quantum-Based Multiprogrammed Systems (Extended Abstract)  
Author: James H. Anderson, Rohit Jain, and David Ott 
Keyword: Consensus, multiprogrammed systems, scheduling quantum, synchronization, wait-free.  
Note: Work supported by NSF grant CCR 9510156, and by a Young Investigator Award from the U.S. Army Research Office, grant number DAAH04-95-1-0323. The first author was also supported by an Alfred P. Sloan Research Fellowship.  
Address: Chapel Hill  
Affiliation: Department of Computer Science University of North Carolina at  
Abstract: We consider wait-free synchronization in multiprogrammed uniprocessor and multiprocessor systems in which the processes bound to each processor are scheduled for execution using a scheduling quantum. We show that, in such systems, any object with consensus number P in Herlihy's wait-free hierarchy is universal for any number of processes executing on P processors, provided the scheduling quantum is of a certain size. We give an asymptotically tight characterization of how large the scheduling quantum must be for this result to hold. The algorithms presented to establish these results are of polynomial space and time complexity, so if an object is universal, it can be used as the basis for a universal construction that is polynomial in space and time. It follows from our results that the ability to achieve wait-free synchronization in quantum-based systems is a function of three things: (i) the number of processors in the system (not the number of processes), (ii) the "power" of available synchronization primitives in terms of their consensus numbers, and (iii) the size of the scheduling quantum. Intuitively, synchronization primitives allow processes on different processors to coordinate, and the scheduling quantum allows processes on the same processor to coordinate. An important special case of our main result is that, with a sufficient quantum, reads and writes are universal in quantum-based uniprocessor systems. In this case, the scheduling quantum must be large enough to encompass the execution of eight high-level language instructions. In any practical system, the scheduling quantum would be much larger than this. Thus, in practice, Herlihy's wait-free hierarchy collapses in multithreaded uniprocessor applications in which quantum-based scheduling is used. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Fischer, N. Lynch, and M. Patterson. </author> <title> Impossibility of distributed consensus with one faulty process. </title> <journal> Journal of the ACM, </journal> <volume> 32(2) </volume> <pages> 374-382, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: In our implementation, the Seen flags provide the needed mechanism. There are two pairs of such flags for each process p, Seen1 [p; 0]/Seen2 [p; 0] and Seen1 <ref> [p; 1] </ref>/Seen2 [p; 1]. p alternates between these pairs from one C&S to the next. The current pair is given by p's alt variable. <p> In our implementation, the Seen flags provide the needed mechanism. There are two pairs of such flags for each process p, Seen1 [p; 0]/Seen2 [p; 0] and Seen1 <ref> [p; 1] </ref>/Seen2 [p; 1]. p alternates between these pairs from one C&S to the next. The current pair is given by p's alt variable. If p detects that Seen2 [p; alt] holds, then it knows that a value it has assigned to X1 or X2 has been seen by another process. <p> However, Moir and Ramamurthy's algorithm requires fewer references to shared memory, and thus would probably require a smaller quantum than ours in practice. Moir and Ramamurthy's algorithm employs three shared variables, P <ref> [1] </ref>, P [2], and P [3]. The idea is to attempt to copy a value from P [1] to P [2], and then from P [2] to P [3]. <p> However, Moir and Ramamurthy's algorithm requires fewer references to shared memory, and thus would probably require a smaller quantum than ours in practice. Moir and Ramamurthy's algorithm employs three shared variables, P <ref> [1] </ref>, P [2], and P [3]. The idea is to attempt to copy a value from P [1] to P [2], and then from P [2] to P [3]. We found the mechanism of detecting preemptions used in our algorithm to be much easier to extend and employ when implementing other objects.
Reference: [2] <author> M. Herlihy. </author> <title> Wait-free synchronization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(1) </volume> <pages> 124-149, </pages> <year> 1991. </year>
Reference-contexts: On each processor, the highest-priority task that is eligible to run executes until it either terminates or is preempted by an even higher-priority task. For this model of multiprogrammed execution, Ramamurthy et al. showed that any object with consensus number P in Herlihy's wait-free hierarchy <ref> [2] </ref> is universal for any number of processes executing on P processors, i.e., universality is a function of the number of processors in the system, not the number of processes. <p> Obviously, if C &lt; P , then universal algorithms are impossible <ref> [2] </ref>. If C lies in the range P C 2P , then the smallest value of Q that suffices is a value proportional to (2P + 1 C)T max . <p> If 2P C &lt; 1, then the smallest value of Q that suffices is a value proportional to 2T max . If C = 1, then Q (obviously) can be any value <ref> [2] </ref>. An important special case of our main result is that reads and writes are universal in quantum-based uniprocessor systems (P = 1). In this case, the scheduling quantum must be large enough to encompass the execution of eight high-level language instructions (see Theorem 1). <p> Then, in Section 3, we present our results for quantum-based uniprocessor systems. To prove that an object is universal, it suffices to show that it can be used to implement consensus in a wait-free manner for any number of processes <ref> [2] </ref>. In Section 3, we show that reads and writes are universal in quantum-based uniprocessor systems by presenting a wait-free, constant-time implementation of a consensus object that uses only reads and writes. This implementation requires a quantum of constant size. <p> This implementation requires a quantum of constant size. Although consensus objects can be used directly to implement other wait-free and lock-free objects <ref> [2] </ref>, implementations of practical interest are usually based on stronger synchronization primitives such as compare-and-swap (C&S). We show that, given a quantum of constant size and using only reads and writes, C&S can be implemented in a quantum-based uniprocessor system in constant time. <p> However, Moir and Ramamurthy's algorithm requires fewer references to shared memory, and thus would probably require a smaller quantum than ours in practice. Moir and Ramamurthy's algorithm employs three shared variables, P [1], P <ref> [2] </ref>, and P [3]. The idea is to attempt to copy a value from P [1] to P [2], and then from P [2] to P [3]. We found the mechanism of detecting preemptions used in our algorithm to be much easier to extend and employ when implementing other objects. <p> Moir and Ramamurthy's algorithm employs three shared variables, P [1], P <ref> [2] </ref>, and P [3]. The idea is to attempt to copy a value from P [1] to P [2], and then from P [2] to P [3]. We found the mechanism of detecting preemptions used in our algorithm to be much easier to extend and employ when implementing other objects. <p> Moir and Ramamurthy's algorithm employs three shared variables, P [1], P <ref> [2] </ref>, and P [3]. The idea is to attempt to copy a value from P [1] to P [2], and then from P [2] to P [3]. We found the mechanism of detecting preemptions used in our algorithm to be much easier to extend and employ when implementing other objects.
Reference: [3] <author> M. Moir and S. </author> <title> Ramamurthy. </title> <type> Private communication. </type> <year> 1998. </year>
Reference-contexts: : array [1::3] of valtype [ ? initially ? procedure decide (val: valtype) returns valtype private variable v; w: valtype 1: v := val ; 3: w := P [i]; 4: if w 6= ? then 5: v := w else 6: P [i] := v od; 7: return P <ref> [3] </ref> Theorem 5: In a P -processor, quantum-based system, consensus cannot be implemented in a wait-free manner for any number of processes using read/write registers and C-consensus objects if C P and Q max (1; 2P C). 2 If we were to incorporate time within our model, then we could easily <p> An important special case of our main result is that, with a sufficient quantum, reads and writes are universal in quantum-based uniprocessors. Our work was partially inspired by a read/write consensus algorithm for quantum-based uniprocessor systems due to Moir and Ramamurthy <ref> [3] </ref>. Actually, their goal was to design wait-free algorithms for systems with the property that once a process initiates an operation that requires a memory access, the processor-to-memory bus is secured by that process for some specified length of time. <p> However, Moir and Ramamurthy's algorithm requires fewer references to shared memory, and thus would probably require a smaller quantum than ours in practice. Moir and Ramamurthy's algorithm employs three shared variables, P [1], P [2], and P <ref> [3] </ref>. The idea is to attempt to copy a value from P [1] to P [2], and then from P [2] to P [3]. We found the mechanism of detecting preemptions used in our algorithm to be much easier to extend and employ when implementing other objects. <p> Moir and Ramamurthy's algorithm employs three shared variables, P [1], P [2], and P <ref> [3] </ref>. The idea is to attempt to copy a value from P [1] to P [2], and then from P [2] to P [3]. We found the mechanism of detecting preemptions used in our algorithm to be much easier to extend and employ when implementing other objects.
Reference: [4] <author> S. Ramamurthy, M. Moir, and J. Anderson. </author> <title> Real-time object sharing with minimal support. </title> <booktitle> Proceedings of the 15th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pp. 233-242. </pages> <year> 1996. </year> <month> 12 </month>
Reference-contexts: 1 Introduction This paper is concerned with wait-free synchronization in multiprogrammed systems. In such systems, several processes may be bound to the same processor. In related previous work, Ramamurthy, Moir, and Anderson considered wait-free synchronization in multiprogrammed systems in which processes on the same processor are scheduled by priority <ref> [4] </ref>. In priority-based systems, each process executes as a sequence of terminating tasks. When a task of a process terminates, some time may elapse before the next task of that process executes. Each object invocation by a process must be entirely contained within a single task of that process.
References-found: 4

