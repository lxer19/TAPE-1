URL: http://graphics.lcs.mit.edu/~seth/pubs/realtime-i3d97.ps.Z
Refering-URL: http://graphics.lcs.mit.edu/~seth/pubs/pubs.html
Root-URL: 
Title: Real-Time Occlusion Culling for Models with Large Occluders  
Author: Satyan Coorg Seth Teller 
Keyword: CR Categories and Subject Descriptors: I.3.3 [Computer Graphics]: Three-Dimensional Graphics and Realism visible line/surface algorithms; I.3.7 [Computer Graphics]: Computational Geometry and Object Modeling object hierarchies. Additional Keywords: Conservative visibility, temporal coherence, spatial coherence, kD-trees.  
Affiliation: Computer Graphics Group MIT Laboratory for Computer Science  
Note: In Proc. 1997 ACM Symposium on Interactive 3D Graphics, pp. 83-90 and 189.  
Abstract: One way to avoid needlessly processing invisible portions of the scene is to use an occlusion culling algorithm to discard invisible polygons early in the graphics pipeline. In this paper, we exploit the presence of large occluders in urban and architectural models to design a real-time occlusion culling algorithm. Our algorithm has the following features: it is conservative, i.e., it overestimates the set of visible polygons; it exploits spatial coherence by using a hierarchical data structure; and it exploits temporal coherence by reusing visibility information computed for previous viewpoints. The new algorithm significantly accelerates rendering of several complex test models. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Airey, J. M., Rohlf, J. H., and Brooks, Jr., F. P. </author> <title> Towards Image Realism with Interactive Update Rates in Complex Virtual Building Environments. </title> <booktitle> ACM Siggraph Special Issue on 1990 Symposium on Interactive 3D Graphics 24, 2 (1990), </booktitle> <pages> 41-50. </pages>
Reference-contexts: Given the availability of hardware z-buffers, it seems promising to overestimate the set of visible polygons, then use a z-buffer to render the final image. This idea of overestimated or conservative visibility has been exploited to design fast architectural walkthrough systems <ref> [1, 6, 10, 15] </ref>. The idea in [15] is to subdivide the input model into cells, roughly corresponding to rooms in a building, and use cell-to-cell/eye-to-cell visibility to bound exact visibility from above.
Reference: [2] <author> Akeley, K. </author> <title> RealityEngine Graphics. </title> <booktitle> SIG-GRAPH '93 Conference Proceedings (1993), </booktitle> <pages> 109-116. </pages>
Reference-contexts: Once such a description is available, further processing can be restricted to involve only the visible portions of the scene. However, these techniques tend to be complex and hence difficult to use in interactive applications. Instead, the z-buffer algorithm [4], typically implemented in hardware <ref> [2] </ref>, is widely used. Given the availability of hardware z-buffers, it seems promising to overestimate the set of visible polygons, then use a z-buffer to render the final image. This idea of overestimated or conservative visibility has been exploited to design fast architectural walkthrough systems [1, 6, 10, 15].
Reference: [3] <author> Bentley, J. </author> <title> Multidimensional binary search trees used for associative searching. </title> <booktitle> Communications of the ACM 18 (1975), </booktitle> <pages> 509-517. </pages>
Reference-contexts: Instead, we use two techniques to reduce the number of visibility tests performed. First, the algorithm operates on a hierarchical data-structure: a kD-tree <ref> [3] </ref> organizing all model polygons. Second, only a small, dynamically maintained set of occluders near the viewpoint is used to determine occlusion (Section 3.1). Given a kD-tree, the visibility algorithm (Figure 9) reports those polygons in the kD-tree that are not occluded by the specified occluders.
Reference: [4] <author> Catmull, E. E. </author> <title> A Subdivision Algorithm for Computer Display of Curved Surfaces. </title> <type> PhD thesis, </type> <institution> University of Utah, </institution> <month> Dec. </month> <year> 1974. </year>
Reference-contexts: Once such a description is available, further processing can be restricted to involve only the visible portions of the scene. However, these techniques tend to be complex and hence difficult to use in interactive applications. Instead, the z-buffer algorithm <ref> [4] </ref>, typically implemented in hardware [2], is widely used. Given the availability of hardware z-buffers, it seems promising to overestimate the set of visible polygons, then use a z-buffer to render the final image.
Reference: [5] <author> Coorg, S., and Teller, S. </author> <title> Temporally Coher ent Conservative Visibility. </title> <booktitle> In Proc. 12 th Annual ACM Symposium on Computational Geometry (1996), </booktitle> <pages> pp. 78-87. </pages>
Reference-contexts: Because of its reliance on image space queries, this algorithm is also susceptible to aliasing artifacts (although, with an accompanying increase in complexity, it is possible to avoid aliasing [8]). A dynamic temporally coherent conservative visibility algorithm, described in <ref> [5] </ref>, identifies relevant visibility events, i.e., changes in visibility that will occur in the near future. One drawback of this algorithm is that it must reconstruct visibility information for the continuous sequence of points between each discrete pair of subsequent viewpoints assumed by the moving observer.
Reference: [6] <author> Funkhouser, T., S equin, C., and Teller, S. </author> <title> Management of Large Amounts of Data in Interactive Building Walkthroughs. </title> <booktitle> In Proc. 1992 Workshop on Interactive 3D Graphics (1992), </booktitle> <pages> pp. 11-20. </pages>
Reference-contexts: Given the availability of hardware z-buffers, it seems promising to overestimate the set of visible polygons, then use a z-buffer to render the final image. This idea of overestimated or conservative visibility has been exploited to design fast architectural walkthrough systems <ref> [1, 6, 10, 15] </ref>. The idea in [15] is to subdivide the input model into cells, roughly corresponding to rooms in a building, and use cell-to-cell/eye-to-cell visibility to bound exact visibility from above.
Reference: [7] <author> Garlick, B., Baum, D. R., and Winget, J. M. </author> <title> Interactive Viewing of Large Geometric Databases Using Multiprocessor Graphics Workstations. Siggraph '90 Course Notes (Parallel Algorithms and Architectures for 3D Image Generation) (1990). </title>
Reference-contexts: Though this method eliminates most invisible polygons in architectural models, its generalization to models with less apparent cell structure (e.g., city models) appears difficult. An approach using octree-based spatial subdivi-sion is used in <ref> [7] </ref> to render only those polygons that lie within the viewing frustum. However, this algorithm does not exploit any occlusion properties of the model. The hierarchical z-buffer algorithm [9] culls nodes of an octree hierarchy by using a z-pyramid to resolve visibility queries.
Reference: [8] <author> Greene, N., and Kass, M. </author> <title> Error-Bounded Antialiased Rendering of Complex Environments. </title> <booktitle> In SIGGRAPH '94 Conference Proceedings (1994), </booktitle> <pages> pp. 59-66. </pages>
Reference-contexts: Because of its reliance on image space queries, this algorithm is also susceptible to aliasing artifacts (although, with an accompanying increase in complexity, it is possible to avoid aliasing <ref> [8] </ref>). A dynamic temporally coherent conservative visibility algorithm, described in [5], identifies relevant visibility events, i.e., changes in visibility that will occur in the near future.
Reference: [9] <author> Greene, N., Kass, M., and Miller, G. </author> <title> Hierarchical Z-Buffer Visibility. </title> <booktitle> In SIGGRAPH '93 Conference Proceedings (1993), </booktitle> <pages> pp. 231-240. </pages>
Reference-contexts: An approach using octree-based spatial subdivi-sion is used in [7] to render only those polygons that lie within the viewing frustum. However, this algorithm does not exploit any occlusion properties of the model. The hierarchical z-buffer algorithm <ref> [9] </ref> culls nodes of an octree hierarchy by using a z-pyramid to resolve visibility queries.
Reference: [10] <author> Luebke, D., and Georges, C. </author> <title> Portals and Mirrors: Simple, Fast Evaluation of Potentially Visible Sets. </title> <booktitle> In Proc. 1995 Symposium on Interactive 3D Graphics (1995), </booktitle> <pages> pp. 105-106. </pages>
Reference-contexts: Given the availability of hardware z-buffers, it seems promising to overestimate the set of visible polygons, then use a z-buffer to render the final image. This idea of overestimated or conservative visibility has been exploited to design fast architectural walkthrough systems <ref> [1, 6, 10, 15] </ref>. The idea in [15] is to subdivide the input model into cells, roughly corresponding to rooms in a building, and use cell-to-cell/eye-to-cell visibility to bound exact visibility from above.
Reference: [11] <author> Maciel, P. W. C., and Shirley, P. </author> <title> Visual Navigation of Large Environments Using Textured Clusters. </title> <booktitle> In Proc. 1995 Symposium on Interactive 3D Graphics (1995), </booktitle> <pages> pp. 95-102. </pages>
Reference-contexts: One drawback of this algorithm is that it must reconstruct visibility information for the continuous sequence of points between each discrete pair of subsequent viewpoints assumed by the moving observer. Finally, recent algorithms proposed in <ref> [11, 13, 16] </ref> accelerate rendering by approximating sets of polygons with texture maps. Visibility is resolved only when computing the texture approximation corresponding to a set of polygons. These textures are used to render many frames, thereby reducing further visibility processing. <p> Also, we are investigating strategies for adaptively choosing k, the size of the occluder set dynamically maintained by the visibility algorithm. Another interesting area of future research is integration of occlusion culling techniques with texture based approximation <ref> [11, 13, 16] </ref>. Finally, occlusion culling techniques presented here (especially those based on table lookup) may be amenable to hardware implementation, yielding further speedups.
Reference: [12] <author> Naylor, B. F. </author> <title> Partitioning Tree Image Representation and Generation from 3D geometric models. </title> <booktitle> In Proc. Graphics Interface '92 (1992), </booktitle> <pages> pp. 201-211. </pages>
Reference-contexts: Second, we describe a cheap preprocessing step that identifies nearby large occluders for all viewpoints. Finally, a hierarchical visibility algorithm repeatedly applies the visibility test to determine the status of tree nodes in a spatial hierarchy. 1.1 Related Work Given a 3D model and a viewpoint, exact visibility algorithms <ref> [12, 14] </ref> compute a description of the image in terms of visible polygon fragments. Once such a description is available, further processing can be restricted to involve only the visible portions of the scene. However, these techniques tend to be complex and hence difficult to use in interactive applications.
Reference: [13] <author> Shade, J., Lischinski, D., Salesin, D., DeRose, T., and Snyder, J. </author> <title> Hierarchical Image Caching for Accelerated Walkthroughs of Complex Environments. </title> <booktitle> In SIGGRAPH '96 Conference Proceedings (1996), </booktitle> <pages> pp. 75-82. </pages>
Reference-contexts: One drawback of this algorithm is that it must reconstruct visibility information for the continuous sequence of points between each discrete pair of subsequent viewpoints assumed by the moving observer. Finally, recent algorithms proposed in <ref> [11, 13, 16] </ref> accelerate rendering by approximating sets of polygons with texture maps. Visibility is resolved only when computing the texture approximation corresponding to a set of polygons. These textures are used to render many frames, thereby reducing further visibility processing. <p> Also, we are investigating strategies for adaptively choosing k, the size of the occluder set dynamically maintained by the visibility algorithm. Another interesting area of future research is integration of occlusion culling techniques with texture based approximation <ref> [11, 13, 16] </ref>. Finally, occlusion culling techniques presented here (especially those based on table lookup) may be amenable to hardware implementation, yielding further speedups.
Reference: [14] <author> Sutherland, I. E., Sproull, R. F., and Schumacker, R. A. </author> <title> A Characterization of Ten Hidden-Surface Algorithms. </title> <journal> Computing Surveys 6, </journal> <volume> 1 (1974), </volume> <pages> 1-55. </pages>
Reference-contexts: Second, we describe a cheap preprocessing step that identifies nearby large occluders for all viewpoints. Finally, a hierarchical visibility algorithm repeatedly applies the visibility test to determine the status of tree nodes in a spatial hierarchy. 1.1 Related Work Given a 3D model and a viewpoint, exact visibility algorithms <ref> [12, 14] </ref> compute a description of the image in terms of visible polygon fragments. Once such a description is available, further processing can be restricted to involve only the visible portions of the scene. However, these techniques tend to be complex and hence difficult to use in interactive applications.
Reference: [15] <author> Teller, S., and S equin, C. H. </author> <title> Visibility Preprocessing for Interactive Walkthroughs. </title> <booktitle> SIG-GRAPH '91 Conference Proceedings (1991), </booktitle> <pages> 61-69. </pages>
Reference-contexts: Given the availability of hardware z-buffers, it seems promising to overestimate the set of visible polygons, then use a z-buffer to render the final image. This idea of overestimated or conservative visibility has been exploited to design fast architectural walkthrough systems <ref> [1, 6, 10, 15] </ref>. The idea in [15] is to subdivide the input model into cells, roughly corresponding to rooms in a building, and use cell-to-cell/eye-to-cell visibility to bound exact visibility from above. <p> Given the availability of hardware z-buffers, it seems promising to overestimate the set of visible polygons, then use a z-buffer to render the final image. This idea of overestimated or conservative visibility has been exploited to design fast architectural walkthrough systems [1, 6, 10, 15]. The idea in <ref> [15] </ref> is to subdivide the input model into cells, roughly corresponding to rooms in a building, and use cell-to-cell/eye-to-cell visibility to bound exact visibility from above. Though this method eliminates most invisible polygons in architectural models, its generalization to models with less apparent cell structure (e.g., city models) appears difficult.
Reference: [16] <author> Xiong, R. </author> <title> A Stratified Rendering Algorithm for Virtual Walkthroughs of Large Environments. </title> <type> Masters Thesis, </type> <institution> EECS Department, MIT, </institution> <month> May </month> <year> 1996. </year> <title> White: Node borders Yellow: Current leaf Black: Occluders Dark Blue: Outside frustum Green: Culled Light Blue: </title> <address> Drawn 9 </address>
Reference-contexts: One drawback of this algorithm is that it must reconstruct visibility information for the continuous sequence of points between each discrete pair of subsequent viewpoints assumed by the moving observer. Finally, recent algorithms proposed in <ref> [11, 13, 16] </ref> accelerate rendering by approximating sets of polygons with texture maps. Visibility is resolved only when computing the texture approximation corresponding to a set of polygons. These textures are used to render many frames, thereby reducing further visibility processing. <p> Also, we are investigating strategies for adaptively choosing k, the size of the occluder set dynamically maintained by the visibility algorithm. Another interesting area of future research is integration of occlusion culling techniques with texture based approximation <ref> [11, 13, 16] </ref>. Finally, occlusion culling techniques presented here (especially those based on table lookup) may be amenable to hardware implementation, yielding further speedups.
References-found: 16

