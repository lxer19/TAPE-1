URL: http://www.cs.ucsb.edu/oocsb/self/papers/chambers-thesis/thesis.ps.Z
Refering-URL: http://www.cs.ucsb.edu/oocsb/self/papers/chambers-thesis/
Root-URL: http://www.cs.ucsb.edu
Title: The Design and Implementation of the SELF Compiler, an Optimizing Compiler for Object-Oriented Programming Languages  
Author: Craig Chambers 
Degree: A Dissertation Submitted to the Department of Computer Science and the Committee on Graduate Studies of Stanford University in Partial Fulfillment of the Requirements for the Degree of Doctor of Philosophy  
Date: March 13, 1992  
Abstract-found: 0
Intro-found: 0
Reference: [AS85] <author> Harold Abelson and Gerald Jay Sussman. </author> <title> Structure and Interpretation of Computer Programs. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1985. </year>
Reference-contexts: In this situation, the closure would act like an exception handler. Closures typically provide a way to prematurely exit computations, either using first-class continuations as in Scheme <ref> [AS85, RC86, HDB90] </ref> or using non-local returns as in Smalltalk-80 or SELF. When returning non-locally, the closure returns not to its caller (e.g., the popHandlingEmpty operation) but from its lexically-enclosing operation (e.g., the caller of popHandlingEmpty). Thus non-local returns have an effect similar to return statements in C. <p> are not directly applicable to a dynamically-typed language such as SELF; adding in extra run-time checking to detect illegal messages would sacrifice any performance advantage held by the virtual function table implementation over a system like in-line caching. 3.3 Scheme Systems Scheme is a dynamically-typed function-oriented language descended from Lisp <ref> [AS85, RC86] </ref>. Scheme supports several language features described in Chapter 2 as desirable, including closures and generic arithmetic. Consequently, insights into the construction of efficient Scheme implementations may help in building efficient implementations of object-oriented languages, particularly ones with user-defined control structures and generic arithmetic.
Reference: [Ado85] <author> Adobe Systems Inc. </author> <title> PostScript Language Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1985. </year>
Reference-contexts: Most object-oriented languages, including C++, Eiffel, Trellis/Owl, Smalltalk, T, and CLOS, would benefit (to varying degrees) from the techniques we have 44 developed. Also, languages with object-oriented subsystems would benefit, including languages supporting some form of generic arithmetic such as Lisp, APL [Ive62, GR84], PostScript <ref> [Ado85] </ref>, and Icon [GG83], languages with logic variables such as Prolog, and languages with futures such as Multilisp [Hal85] and Mul-T [KHM89]. 5.2 Overall Approach This section describes the overall approach to achieving an efficient implementation of SELF and similar languages. 5.2.1 Representation-Level Type Information Is Key Dynamically-typed object-oriented programming languages
Reference: [ASU86] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1986. </year>
Reference-contexts: In this section we discuss several conventional techniques that relate to techniques used for SELF. 3.4.1 Data Flow Analysis Much work has been done on developing techniques to optimize traditional statically-typed non-object-oriented imperative programming languages such as Fortran [BBB+57], C, and Pascal <ref> [ASU86, PW86, Gup90] </ref>. Many of these techniques revolve around data ow analysis, a framework in which information is computed about a procedure by propagating information through the procedures control ow graph. <p> The standard approach to common subexpression elimination uses data ow analysis to propagate sets of available expressions, which are computations that have been performed earlier in the control ow graph <ref> [ASU86] </ref>. After computing the expressions available at a control ow graph node such as an arithmetic instruction node, the compiler can eliminate the node if the result computed by the node is already available.
Reference: [AJ88] <author> Randy Allen and Steve Johnson. </author> <title> Compiling C for Vectorization, Parallelization, and Inline Expansion. </title> <booktitle> In Proceedings of the SIGPLAN 88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 241-249, </pages> <address> Atlanta, GA, </address> <month> June, </month> <year> 1988. </year> <note> Published as SIGPLAN Notices 23(7), </note> <month> July, </month> <year> 1988. </year>
Reference-contexts: Some languages, including C++, provide mechanisms through which the programmer can tell the compiler to inline calls to particular routines. More sophisticated systems attempt to determine automatically which routines should be inlined <ref> [Sch77, AJ88, HC89, RG89, McF91] </ref>. Inlining itself is not a particularly difficult transformation, but it is harder to devise a set of good heuristics to control automatic inlining, balancing compiled code space and compilation time increases against projected run-time performance improvements and operating correctly in the presence of recursive routines.
Reference: [AWZ88] <author> Bowen Alpern, Mark N. Wegman, and F. Kenneth Zadeck. </author> <title> Detecting Equality of Variables in Programs. </title> <booktitle> In Conference Record of the Fifteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 1-11, </pages> <address> San Diego, CA, </address> <month> January, </month> <year> 1988. </year>
Reference-contexts: Several researchers have developed techniques to improve the effectiveness of determining when two expressions are equal. Perhaps the best current approaches are based on static single assignment (SSA) form <ref> [AWZ88] </ref>. The invariant maintained by a program in SSA form is that each variable is assigned at most once, and exactly one definition of a variable reaches any use of that variable.
Reference: [Atk86] <author> Robert G. Atkinson. </author> <title> Hurricane: An Optimizing Compiler for Smalltalk. </title> <booktitle> In OOPSLA 86 Conference Proceedings, </booktitle> <pages> pp. 151-158, </pages> <address> Portland, OR, </address> <month> September, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year>
Reference-contexts: however, we are skeptical that an optimizing compiler written in Typed Smalltalk could ever run as fast as a simple compiler written in C, as is the Deutsch-Schiffman compiler. 3.1.4 Atkinsons Hurricane Compiler Robert Atkinson pursued an approach similar to the Typed Smalltalk project in attempting to speed Smalltalk-80 programs <ref> [Atk86] </ref>. He devised a type system very similar to Typed Smalltalks set-of-classes types and allowed Smalltalk programmers to annotate their programs with type declarations.
Reference: [BBB+57] <author> J. W. Backus, R. J. Beeber, S. Best, R. Goldberg, L. M. Haibt, H. L. Herrick, R. A. Nelson, D. Sayre, P. B. Sheridan, H. Stern, I. Ziller, R. A. Hughes, and R. Nutt. </author> <title> The Fortran Automatic Coding System. </title> <booktitle> In Western Joint Computer Conference, </booktitle> <pages> pp. 188-198, </pages> <year> 1957. </year>
Reference-contexts: In this section we discuss several conventional techniques that relate to techniques used for SELF. 3.4.1 Data Flow Analysis Much work has been done on developing techniques to optimize traditional statically-typed non-object-oriented imperative programming languages such as Fortran <ref> [BBB+57] </ref>, C, and Pascal [ASU86, PW86, Gup90]. Many of these techniques revolve around data ow analysis, a framework in which information is computed about a procedure by propagating information through the procedures control ow graph.
Reference: [BHJL86] <author> Andrew Black, Norman Hutchinson, Eric Jul, and Henry Levy. </author> <title> Object Structure in the Emerald System. </title> <booktitle> In OOPSLA 86 Conference Proceedings, </booktitle> <pages> pp. 78-86, </pages> <address> Portland, OR, </address> <month> September, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year>
Reference-contexts: The implementors openly admit that Trellis/Owls performance is not near that of traditional languages, but report that performance is good enough for their users. 3.2.4 Emerald Emerald is a statically-typed pure object-oriented language for distributed programming <ref> [BHJL86, Hut87, HRB+87, JLHB88, Jul88] </ref>. Emerald is unusual in lacking both classes and implementation inheritance: Emerald objects are completely self-sufficient. Emerald does include a separate subtyping hierarchy, however, and recent versions include a powerful mechanism for statically-type-checked polymorphism [BH90].
Reference: [BH90] <author> Andrew P. Black and Norman C. Hutchinson. </author> <title> Typechecking Polymorphism in Emerald. </title> <type> Technical report TR 90-34, </type> <institution> Department of Computer Science, University of Arizona, </institution> <month> December, </month> <year> 1990. </year>
Reference-contexts: Emerald is unusual in lacking both classes and implementation inheritance: Emerald objects are completely self-sufficient. Emerald does include a separate subtyping hierarchy, however, and recent versions include a powerful mechanism for statically-type-checked polymorphism <ref> [BH90] </ref>. All Emerald data structures are objects, and the only way to manipulate or access an object is to send it a message. Thus, Emerald is just as pure as Trellis/Owl.
Reference: [BDG+88] <author> D. G. Bobrow, L. G. DeMichiel, R. P. Gabriel, S. E. Keene, G. Kiczales, D. A. Moon. </author> <title> Common Lisp Object System Specification X3J13. </title> <booktitle> In SIGPLAN Notices 23, </booktitle> <month> September, </month> <year> 1988. </year>
Reference-contexts: Several object-oriented languages have been designed and implemented, including Smalltalk-80 * [GR83], C++ [Str86, ES90], Trellis/Owl [SCW85, SCB+86], Eiffel [Mey86, Mey88, Mey92], Modula-3 [Nel91, Har92], CLOS <ref> [BDG+88] </ref>, and T [RA82, Sla87, RAM90]. Unfortunately, traditional implementations of object-oriented language features, particularly message passing, have been much slower than traditional implementations of their non-object-oriented counterparts, and this gap in run-time performance has limited the widespread use of object-oriented language features and hindered the acceptance of purely object-oriented languages.
Reference: [BCKT89] <author> Preston Briggs, Keith D. Cooper, Ken Kennedy, and Linda Torczon. </author> <title> Coloring Heuristics for Register Allocation. </title> <booktitle> In Proceedings of the SIGPLAN 89 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 275-284, </pages> <address> Portland, OR, </address> <month> June, </month> <year> 1989. </year> <note> Published as SIGPLAN Notices 24(7), </note> <month> July, </month> <year> 1989. </year>
Reference-contexts: an NP-complete problem, so much of the work in implementing graph-coloring-based register allocators in real compilers involves developing heuristics that can usually find a coloring of the interference graph in a reasonable amount of time, and in handling spilling of variables to memory if no coloring can be quickly found <ref> [CAC+81, Cha82, CH84, LH86, BCKT89, CH90] </ref>.
Reference: [CAC+81] <author> Gregory J. Chaitin, Marc A. Auslander, Ashok K. Chandra, John Cocke, Martin E. Hopkins, and Peter W. Markstein. </author> <title> Register Allocation via Coloring. </title> <booktitle> In Computer Languages 6, </booktitle> <pages> pp. 47-57, </pages> <year> 1981. </year>
Reference-contexts: an NP-complete problem, so much of the work in implementing graph-coloring-based register allocators in real compilers involves developing heuristics that can usually find a coloring of the interference graph in a reasonable amount of time, and in handling spilling of variables to memory if no coloring can be quickly found <ref> [CAC+81, Cha82, CH84, LH86, BCKT89, CH90] </ref>.
Reference: [Cha82] <author> G. J. Chaitin. </author> <title> Register Allocation & Spilling via Graph Coloring. </title> <booktitle> In Proceedings of the SIGPLAN 82 Symposium on Compiler Construction, </booktitle> <pages> pp. 98-105, </pages> <address> Boston, MA, </address> <month> June, </month> <year> 1982. </year> <note> Published as SIGPLAN Notices 17(6), </note> <month> June, </month> <year> 1982. </year>
Reference-contexts: an NP-complete problem, so much of the work in implementing graph-coloring-based register allocators in real compilers involves developing heuristics that can usually find a coloring of the interference graph in a reasonable amount of time, and in handling spilling of variables to memory if no coloring can be quickly found <ref> [CAC+81, Cha82, CH84, LH86, BCKT89, CH90] </ref>.
Reference: [CU89] <author> Craig Chambers and David Ungar. </author> <title> Customization: Optimizing Compiler Technology for SELF, a Dynamically-Typed Object-Oriented Programming Language. </title> <booktitle> In Proceedings of the SIGPLAN 89 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 146-160, </pages> <address> Portland, OR, </address> <month> June, </month> <year> 1989. </year> <note> Published as SIGPLAN Notices 24(7), </note> <month> July, </month> <year> 1989. </year>
Reference-contexts: These techniques include customization, type analysis, type prediction, and splitting. Earlier designs and implementations of these techniques have been described in other papers <ref> [CU89, CUL89, CU90, CU91] </ref>. Chapter 13 describes compiler support for the SELF programming environment, in particular techniques that mask the effects of optimizations such as inlining and splitting from the SELF programmer when debugging; some of these techniques have been described in other papers [CUL89, HCU92].
Reference: [CUL89] <author> Craig Chambers, David Ungar, and Elgin Lee. </author> <title> An Efficient Implementation of SELF, a Dynamically-Typed Object-Oriented Language Based on Prototypes. </title> <booktitle> In OOPSLA 89 Conference Proceedings, </booktitle> <pages> pp. 49-70, </pages> <address> New Orleans, LA, </address> <month> October, </month> <year> 1989. </year> <note> Published as SIGPLAN Notices 24(10), </note> <month> October, </month> <year> 1989. </year> <title> Also published in Lisp and Symbolic Computation 4(3), </title> <publisher> Kluwer Academic Publishers, </publisher> <month> June, </month> <year> 1991. </year>
Reference-contexts: These techniques include customization, type analysis, type prediction, and splitting. Earlier designs and implementations of these techniques have been described in other papers <ref> [CU89, CUL89, CU90, CU91] </ref>. Chapter 13 describes compiler support for the SELF programming environment, in particular techniques that mask the effects of optimizations such as inlining and splitting from the SELF programmer when debugging; some of these techniques have been described in other papers [CUL89, HCU92]. <p> Chapter 13 describes compiler support for the SELF programming environment, in particular techniques that mask the effects of optimizations such as inlining and splitting from the SELF programmer when debugging; some of these techniques have been described in other papers <ref> [CUL89, HCU92] </ref>. Section 5.3 contains a more detailed outline of this part of the dissertation. The performance of our SELF implementation is analyzed in Chapter 14. This analysis measures various configurations of our implementation and identifies the individual contributions to performance of particular techniques. <p> An early version of the SELF memory system was documented by Elgin Lee [Lee88]; a more recent version was described in <ref> [CUL89] </ref>. The following two subsections describe techniques for efficient object storage systems pioneered by the SELF implementation. Subsection 6.1.3 describes constraints placed on the compiler by SELFs garbage collection algorithm. <p> In particular, the SELF compiler does not produce derived pointers to the interior of an object. This restriction allows the garbage collector to assume that all data tagged as an object reference really points to the * This design is slightly different from segregation as described in [Lee88] and <ref> [CUL89] </ref>, in which byte arrays were stored completely in the bytes area. The design was changed so that a byte array could have user-defined references to other objects in addition to its array of bytes.
Reference: [CU90] <author> Craig Chambers and David Ungar. </author> <title> Iterative Type Analysis and Extended Message Splitting: Optimizing Dynamically-Typed Object-Oriented Programs. </title> <booktitle> In Proceedings of the SIGPLAN 90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 150-164, </pages> <address> White Plains, NY, </address> <month> June, </month> <year> 1990. </year> <note> Published as SIGPLAN Notices 25(6), </note> <month> June, </month> <year> 1990. </year> <title> Also published in Lisp and Symbolic Computation 4(3), </title> <publisher> Kluwer Academic Publishers, </publisher> <month> June, </month> <year> 1991. </year> <month> 228 </month>
Reference-contexts: These techniques include customization, type analysis, type prediction, and splitting. Earlier designs and implementations of these techniques have been described in other papers <ref> [CU89, CUL89, CU90, CU91] </ref>. Chapter 13 describes compiler support for the SELF programming environment, in particular techniques that mask the effects of optimizations such as inlining and splitting from the SELF programmer when debugging; some of these techniques have been described in other papers [CUL89, HCU92]. <p> As detailed in section 14.3, without any form of splitting SELF programs would run only half as fast. * These two cases were termed local message splitting and extended message splitting in <ref> [CU90] </ref>. x: t 2 Before Splitting After Splitting r message (x) x: t 2 x: t 1 arbitrary subgraph x: -t 1 ,t 2 - r message (x) x: t 1 arbitrary subgraph x: t 1 r message (x) x: t 2 arbitrary subgraph x: t 2 x: -t 1 ,t
Reference: [CUCH91] <author> Craig Chambers, David Ungar, Bay-Wei Chang, and Urs Hlzle. </author> <title> Parents are Shared Parts: Inheritance and Encapsulation in SELF. Published in Lisp and Symbolic Computation 4(3), </title> <publisher> Kluwer Academic Publishers, </publisher> <month> June, </month> <year> 1991. </year>
Reference-contexts: Unfortunately, most languages and implementations do not support all these desirable features, again because they historically have had a high cost in run-time performance. 1.2 The SELF Language To maximize the potential benefits of object-oriented programming, David Ungar and Randy Smith designed the SELF programming language <ref> [US87, HCC+91, UCCH91, CUCH91] </ref> as a refinement and simplification of the Smalltalk-80 language. <p> Consequently, the performance of existing object-oriented languages lags far behind the performance of conventional languages. 34 35 Chapter 4 The SELF Language SELF is a dynamically-typed prototype-based object-oriented language with multiple, dynamic inheritance, originally designed by David Ungar and Randy Smith at Xerox PARC in 1986 <ref> [US87, HCC+91, UCCH91, CUCH91] </ref> as a successor to the Smalltalk-80 programming language. Like Smalltalk, SELF is intended for exploratory programming environments in which rapid program development and modification are primary goals. <p> For example, when sending the x message to the cartesian point, the system locates the x slot in the point, extracts its contents (the * The current version of SELF supports prioritized parents with differing numbers of asterisks for different parent priorities. Further details may be found in <ref> [CUCH91] </ref>. 37 3 integer object), evaluates it (in this case just returning 3 again, since the 3 object contains no code and hence evaluates to itself), and returns the result (3) as the result of the original x message. <p> The byte code object contains a byte array for the byte codes themselves, and a separate object array for the constants and message names used in the source code. * Resends and directed resends are described in detail in <ref> [CUCH91] </ref> and [HCC+91]. (code) literals codes . . . method object byte code object (prototype activation record) IMPLICIT-SELF SEND # 0 (x) SEND # 1 (print) LITERAL # 2 (, ) SEND # 1 (print) IMPLICIT-SELF SEND # 3 (y) SEND # 1 (print) byte code array literal array self* x
Reference: [CU91] <author> Craig Chambers and David Ungar. </author> <title> Making Pure Object-Oriented Languages Practical. </title> <booktitle> In OOPSLA 91 Conference Proceedings, </booktitle> <pages> pp. 1-15, </pages> <address> Phoenix, AZ, </address> <month> October, </month> <year> 1991. </year> <note> Published as SIGPLAN Notices 26(10), </note> <month> October, </month> <year> 1991. </year>
Reference-contexts: These techniques include customization, type analysis, type prediction, and splitting. Earlier designs and implementations of these techniques have been described in other papers <ref> [CU89, CUL89, CU90, CU91] </ref>. Chapter 13 describes compiler support for the SELF programming environment, in particular techniques that mask the effects of optimizations such as inlining and splitting from the SELF programmer when debugging; some of these techniques have been described in other papers [CUL89, HCU92].
Reference: [CH84] <author> Frederick Chow and John Hennessy. </author> <title> Register Allocation by Priority-Based Coloring. </title> <booktitle> In Proceedings of the SIGPLAN 84 Symposium on Compiler Construction, </booktitle> <pages> pp. 222-232, </pages> <address> Montreal, Canada, </address> <month> June, </month> <year> 1984. </year> <note> Published as SIGPLAN Notices 19(6), </note> <month> June, </month> <year> 1984. </year>
Reference-contexts: an NP-complete problem, so much of the work in implementing graph-coloring-based register allocators in real compilers involves developing heuristics that can usually find a coloring of the interference graph in a reasonable amount of time, and in handling spilling of variables to memory if no coloring can be quickly found <ref> [CAC+81, Cha82, CH84, LH86, BCKT89, CH90] </ref>. <p> Register allocators for other compilers frequently allocate disjoint subregions of a variables lifetime to different registers, and sometimes can even split a variables lifetime into separately-allocatable regions <ref> [CH84, CH90] </ref>, but these systems do not simultaneously support complete source-level debugging.
Reference: [CH90] <author> Fred C. Chow and John L. Hennessy. </author> <title> The Priority-Based Coloring Approach to Register Allocation. </title> <booktitle> In ACM Transactions on Programming Languages and Systems 12(4), </booktitle> <pages> pp. 501-536, </pages> <month> October, </month> <year> 1990. </year>
Reference-contexts: an NP-complete problem, so much of the work in implementing graph-coloring-based register allocators in real compilers involves developing heuristics that can usually find a coloring of the interference graph in a reasonable amount of time, and in handling spilling of variables to memory if no coloring can be quickly found <ref> [CAC+81, Cha82, CH84, LH86, BCKT89, CH90] </ref>. <p> Register allocators for other compilers frequently allocate disjoint subregions of a variables lifetime to different registers, and sometimes can even split a variables lifetime into separately-allocatable regions <ref> [CH84, CH90] </ref>, but these systems do not simultaneously support complete source-level debugging.
Reference: [CC77] <author> P. Cousot and R. Cousot. </author> <title> Abstract Interpretation: a Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints. </title> <booktitle> In Conference Record of the Fourth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 238-252, </pages> <month> January, </month> <year> 1977. </year>
Reference-contexts: Unfortunately, the control ow graphs manipulated by the SELF compiler are not always reducible, especially after splitting loops as described in Chapter 11. 30 3.4.2 Abstract Interpretation Abstract interpretation is a more semantics-based approach to the data ow analysis problem <ref> [CC77] </ref>. In this framework, the semantics of the original programming language is abstracted to capture only relevant information; this new abstract semantics is called a non-standard semantics. The program can then be analyzed by interpreting the program using the non-standard semantics.
Reference: [CMR88] <author> Deborah S. Coutant, Sue Meloy, and Michelle Ruscetta. </author> <title> DOC: A Practical Approach to Source-Level Debugging of Globally Optimized Code. </title> <booktitle> In Proceedings of the SIGPLAN 88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 125-134, </pages> <address> Atlanta, GA, </address> <month> June, </month> <year> 1988. </year> <note> Published as SIGPLAN Notices 23(7), </note> <month> July, </month> <year> 1988. </year>
Reference-contexts: These features are fairly easy to support in an interpretive environment but are much more difficult to achieve in a high-performance optimizing compiler environment, particularly one based on aggressive inlining. Other researchers have investigated the problem of enabling compilation and optimization to coexist gracefully with the programming environment <ref> [Hen82, Zel84, CMR88, ZJ91] </ref>. This chapter describes the techniques used in the SELF implementation to support the programming environment, focusing on the support provided by the compiler. A compiled method contains more than just instructions.
Reference: [DB76] <author> L. Peter Deutsch and Daniel G. Bobrow. </author> <title> An Efficient, Incremental, Real-Time Garbage Collector. </title> <booktitle> In Communications of the ACM 19(10), </booktitle> <month> October, </month> <year> 1976. </year>
Reference-contexts: Depending on the memory system organization, this technique requires two or three memory references and four or five extra instructions to verify an in-line cache hit. These techniques, along with a faster garbage collection strategy called deferred reference counting <ref> [DB76] </ref>, made significant improvements in the performance of Smalltalk-80 systems on stock hardware. The run-time performance of the Deutsch-Schiffman implementation is close to twice the speed of the interpreted version of Smalltalk.
Reference: [Deu83] <author> L. Peter Deutsch. </author> <title> The Dorado Smalltalk-80 Implementation: Hardware Architectures Impact on Software Architecture. </title> <editor> In Glenn Krasner, editor, </editor> <title> Smalltalk-80: Bits of History, Words of Advice. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1983. </year>
Reference-contexts: Originally, Smalltalk-80 ran on Xerox Dorados implementing this instruction set in microcode <ref> [Deu83] </ref>. Subsequent software implementations of Smalltalk-80 on stock hardware supplied a virtual machine that interpreted these byte codes in software.
Reference: [DS84] <author> L. Peter Deutsch and Allan M. Schiffman. </author> <title> Efficient Implementation of the Smalltalk-80 System. </title> <booktitle> In Conference Record of the Eleventh Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 297-302, </pages> <address> Salt Lake City, UT, </address> <month> January, </month> <year> 1984. </year>
Reference-contexts: This design further slowed the implementation of method call and return with the cost to allocate and eventually deallocate these activation record objects. Peter Deutsch and Allan Schiffman developed several techniques for implementing Smalltalk-80 programs better than these interpreters without specialized hardware support <ref> [DS84] </ref>. They overcame the interpretation overhead by introducing an extra invisible translation step from virtual machine byte codes into native machine code, with the system directly executing the native machine code instead of interpreting the original byte codes.
Reference: [Deu88] <author> L. Peter Deutsch. </author> <title> Richards benchmark source code. </title> <type> Personal communication, </type> <month> October, </month> <year> 1988. </year>
Reference-contexts: These benchmarks include several micro-benchmarks gathered from various sources, the Stanford integer benchmark suite [Hen88], the Richards benchmark <ref> [Deu88] </ref>, and several SELF programs originally written without benchmarking in mind. Source code for all these benchmarks is available from the author upon request.
Reference: [Deu89] <author> L. Peter Deutsch. atAllPut: </author> <title> benchmark suggestion. </title> <type> Personal communication, </type> <month> September, </month> <year> 1989. </year>
Reference-contexts: It was originally suggested to us by Peter Deutsch as an interesting micro benchmark <ref> [Deu89] </ref>. sumAll adds up all the elements of a 100,000-element-long vector.
Reference: [DMSV89] <author> R. Dixon, T. McKee, P. Schweitzer, and M. Vaughan. </author> <title> A Fast Method Dispatcher for Compiled Languages with Multiple Inheritance. </title> <booktitle> In OOPSLA 89 Conference Proceedings, </booktitle> <pages> pp. 211-214, </pages> <address> New Orleans, LA, </address> <month> October, </month> <year> 1989. </year> <note> Published as SIGPLAN Notices 24(10), </note> <month> October, </month> <year> 1989. </year>
Reference-contexts: Dixon et al use a graph coloring technique to determine message names which must be given distinct indices <ref> [DMSV89] </ref>; they report that only a small amount of space is wasted in empty _vtbl array entries. Pugh and Weddell propose a novel extension that allows negative indices [PW90]. The extra degree of freedom in assigning indices without wasting space saves a significant amount of space.
Reference: [Gab85] <author> Richard P. Gabriel. </author> <title> Performance and Evaluation of Lisp Systems. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1985. </year>
Reference-contexts: This benchmark is another TS Typed Smalltalk benchmark. sieve finds all the primes between 1 and 8190 using Eratosthenes sieve algorithm and stresses integer calculations, integer comparisons, and accessing arrays of booleans. tak executes the recursive Tak benchmark from the Gabriel Lisp benchmarks <ref> [Gab85] </ref>, which stresses method calling and integer arithmetic. takl performs the same algorithm, but uses lists of cons-cells to represent integers, and so additionally stresses list traversals and memory allocation.
Reference: [GR84] <author> Leonard Gilman and Allen J. Rose. </author> <title> APL: An Interactive Approach. </title> <publisher> Wiley, </publisher> <address> New York, </address> <year> 1984. </year>
Reference-contexts: Most object-oriented languages, including C++, Eiffel, Trellis/Owl, Smalltalk, T, and CLOS, would benefit (to varying degrees) from the techniques we have 44 developed. Also, languages with object-oriented subsystems would benefit, including languages supporting some form of generic arithmetic such as Lisp, APL <ref> [Ive62, GR84] </ref>, PostScript [Ado85], and Icon [GG83], languages with logic variables such as Prolog, and languages with futures such as Multilisp [Hal85] and Mul-T [KHM89]. 5.2 Overall Approach This section describes the overall approach to achieving an efficient implementation of SELF and similar languages. 5.2.1 Representation-Level Type Information Is Key Dynamically-typed
Reference: [GR83] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and Its Implementation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1983. </year>
Reference-contexts: Several object-oriented languages have been designed and implemented, including Smalltalk-80 * <ref> [GR83] </ref>, C++ [Str86, ES90], Trellis/Owl [SCW85, SCB+86], Eiffel [Mey86, Mey88, Mey92], Modula-3 [Nel91, Har92], CLOS [BDG+88], and T [RA82, Sla87, RAM90]. <p> the most relevant to achieving good performance for SELF. 3.1.1 The Smalltalk-80 Language Smalltalk-80 incorporates most of the language features we identified in the previous chapter as contributing to expressive power and implementation inefficiency: abstract data types, message passing, inheritance, dynamic typing, user-defined control structures, error-checking primitives, and generic arithmetic <ref> [GR83] </ref>. However, the designers of Smalltalk-80 included several compromises in the definition of the language and the implementation to make Smalltalk easier to implement efficiently. Smalltalk (and most object-oriented languages) treats variables differently from other methods. Variables are accessed directly using a special mechanism that avoids a costly message send. <p> each store into memory to support generation scavenging; we are not aware of any other store checking designs that impose less overhead. 6.2 The Parser To minimize parsing overhead, textual SELF programs are parsed once when entered into the system, generating SELF-level byte code objects, much like Smalltalk-80 CompiledMethod instances <ref> [GR83] </ref>. Each method object represents its source code by storing a reference to the pre-parsed byte code object in the methods map; all cloned invocations of the method thus share the same byte code object since they share the same map.
Reference: [Gra89] <author> Justin Owen Graver. </author> <title> Type-Checking and Type-Inference for Object-Oriented Programming Languages. </title> <type> Ph.D. thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <year> 1989. </year>
Reference-contexts: In an effort to improve the speed of Smalltalk programs, Ralph Johnson and his group at the University of Illinois at Urbana-Champaign have designed an extension to Smalltalk called Typed Smalltalk <ref> [Joh86, JGZ88, McC89, Hei90, Gra89, GJ90] </ref>. They added explicit type declarations to Smalltalk and built an optimizing compiler, called TS, that uses these type declarations to improve run-time performance. A type in Typed Smalltalk is either a (possibly singleton) set of classes * or a signature.
Reference: [GJ90] <author> Justin O. Graver and Ralph E. Johnson. </author> <title> A Type System for Smalltalk. </title> <booktitle> In Conference Record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 136-150, </pages> <address> San Francisco, CA, </address> <month> January, </month> <year> 1990. </year>
Reference-contexts: In an effort to improve the speed of Smalltalk programs, Ralph Johnson and his group at the University of Illinois at Urbana-Champaign have designed an extension to Smalltalk called Typed Smalltalk <ref> [Joh86, JGZ88, McC89, Hei90, Gra89, GJ90] </ref>. They added explicit type declarations to Smalltalk and built an optimizing compiler, called TS, that uses these type declarations to improve run-time performance. A type in Typed Smalltalk is either a (possibly singleton) set of classes * or a signature.
Reference: [GG83] <author> Ralph E. Griswold and Madge T. Griswold. </author> <title> The Icon Programming Language. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1983. </year>
Reference-contexts: Most object-oriented languages, including C++, Eiffel, Trellis/Owl, Smalltalk, T, and CLOS, would benefit (to varying degrees) from the techniques we have 44 developed. Also, languages with object-oriented subsystems would benefit, including languages supporting some form of generic arithmetic such as Lisp, APL [Ive62, GR84], PostScript [Ado85], and Icon <ref> [GG83] </ref>, languages with logic variables such as Prolog, and languages with futures such as Multilisp [Hal85] and Mul-T [KHM89]. 5.2 Overall Approach This section describes the overall approach to achieving an efficient implementation of SELF and similar languages. 5.2.1 Representation-Level Type Information Is Key Dynamically-typed object-oriented programming languages historically have run
Reference: [Gup90] <author> Rajiv Gupta. </author> <title> A Fresh Look at Optimizing Array Bounds Checking. </title> <booktitle> In Proceedings of the SIGPLAN 90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 272-282, </pages> <address> White Plains, NY, </address> <month> June, </month> <year> 1990. </year> <note> Published as SIGPLAN Notices 25(6), </note> <month> June, </month> <year> 1990. </year>
Reference-contexts: In this section we discuss several conventional techniques that relate to techniques used for SELF. 3.4.1 Data Flow Analysis Much work has been done on developing techniques to optimize traditional statically-typed non-object-oriented imperative programming languages such as Fortran [BBB+57], C, and Pascal <ref> [ASU86, PW86, Gup90] </ref>. Many of these techniques revolve around data ow analysis, a framework in which information is computed about a procedure by propagating information through the procedures control ow graph.
Reference: [Hal85] <author> Robert Halstead. </author> <title> Multilisp: A Language for Concurrent Symbolic Computation. </title> <booktitle> In ACM Transactions on Programming Languages and Systems 7(4), </booktitle> <pages> pp. 501-538, </pages> <month> October, </month> <year> 1985. </year> <month> 229 </month>
Reference-contexts: Also, languages with object-oriented subsystems would benefit, including languages supporting some form of generic arithmetic such as Lisp, APL [Ive62, GR84], PostScript [Ado85], and Icon [GG83], languages with logic variables such as Prolog, and languages with futures such as Multilisp <ref> [Hal85] </ref> and Mul-T [KHM89]. 5.2 Overall Approach This section describes the overall approach to achieving an efficient implementation of SELF and similar languages. 5.2.1 Representation-Level Type Information Is Key Dynamically-typed object-oriented programming languages historically have run much slower than traditional statically-typed non-object-oriented programming languages. <p> Implementations of logic programming languages such as Prolog might benefit from knowing that along certain branches some logic variable is guaranteed to be instantiated; this knowledge could come from techniques related to type analysis and splitting. Similarly, implementations of programming languages supporting futures such as Multilisp <ref> [Hal85] </ref> and Mul-T [KHM89] could distinguish between known and unknown futures, compiling specialized code for each case (or perhaps just for the common case of known futures).
Reference: [Har92] <author> Samuel P. Harbison. </author> <title> Modula-3. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1992. </year>
Reference-contexts: Several object-oriented languages have been designed and implemented, including Smalltalk-80 * [GR83], C++ [Str86, ES90], Trellis/Owl [SCW85, SCB+86], Eiffel [Mey86, Mey88, Mey92], Modula-3 <ref> [Nel91, Har92] </ref>, CLOS [BDG+88], and T [RA82, Sla87, RAM90].
Reference: [HDB90] <author> Robert Heib, R. Kent Dybvig, and Carl Bruggeman. </author> <title> Representing Control in the Presence of First-Class Continuations. </title> <booktitle> In Proceedings of the SIGPLAN 90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 66-77, </pages> <address> White Plains, NY, </address> <month> June, </month> <year> 1990. </year> <note> Published as SIGPLAN Notices 25(6), </note> <month> June, </month> <year> 1990. </year>
Reference-contexts: In this situation, the closure would act like an exception handler. Closures typically provide a way to prematurely exit computations, either using first-class continuations as in Scheme <ref> [AS85, RC86, HDB90] </ref> or using non-local returns as in Smalltalk-80 or SELF. When returning non-locally, the closure returns not to its caller (e.g., the popHandlingEmpty operation) but from its lexically-enclosing operation (e.g., the caller of popHandlingEmpty). Thus non-local returns have an effect similar to return statements in C.
Reference: [Hei90] <author> Richard Louis Heintz, Jr. </author> <title> Low Level Optimizations for an Object-Oriented Programming Language. </title> <type> Masters thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <year> 1990. </year>
Reference-contexts: In an effort to improve the speed of Smalltalk programs, Ralph Johnson and his group at the University of Illinois at Urbana-Champaign have designed an extension to Smalltalk called Typed Smalltalk <ref> [Joh86, JGZ88, McC89, Hei90, Gra89, GJ90] </ref>. They added explicit type declarations to Smalltalk and built an optimizing compiler, called TS, that uses these type declarations to improve run-time performance. A type in Typed Smalltalk is either a (possibly singleton) set of classes * or a signature.
Reference: [Hen82] <author> John L. Hennessy. </author> <title> Symbolic Debugging of Optimized Code. </title> <journal> ACM Transactions of Programming Languages and Systems 4(3), </journal> <month> July, </month> <year> 1982. </year>
Reference-contexts: These features are fairly easy to support in an interpretive environment but are much more difficult to achieve in a high-performance optimizing compiler environment, particularly one based on aggressive inlining. Other researchers have investigated the problem of enabling compilation and optimization to coexist gracefully with the programming environment <ref> [Hen82, Zel84, CMR88, ZJ91] </ref>. This chapter describes the techniques used in the SELF implementation to support the programming environment, focusing on the support provided by the compiler. A compiled method contains more than just instructions.
Reference: [Hen88] <author> John Hennessy. </author> <title> Stanford benchmark suite source code. </title> <type> Personal communication, </type> <month> June, </month> <year> 1988. </year>
Reference-contexts: The next section prefaces these results with a description of our measurement methodology. 14.1 Methodology 14.1.1 The Benchmarks We analyzed the performance of the SELF implementation using a selection of benchmark programs. These benchmarks include several micro-benchmarks gathered from various sources, the Stanford integer benchmark suite <ref> [Hen88] </ref>, the Richards benchmark [Deu88], and several SELF programs originally written without benchmarking in mind. Source code for all these benchmarks is available from the author upon request.
Reference: [HP90] <author> John L. Hennessy and David A. Patterson. </author> <title> Computer Architecture: A Quantitative Approach. </title> <address> Morgan-Kaufman, San Mateo, </address> <year> 1990. </year>
Reference-contexts: Appendix C contains the raw data for all the measurements. 14.1.2 The Hardware We did all our measurements on a Sun-4/260 workstation configured with 48MB of main memory. The Sun-4/260 workstation is based on the SPARC, a RISC-style microprocessor with hardware register windows and delayed branches and calls <ref> [HP90] </ref>. The implementation of the SPARC on the Sun-4/260 has a 62ns cycle time, 8 register windows, two-cycle loads (if the target register is not used in the following instruction, three cycles otherwise), and three-cycle stores, assuming cache hits.
Reference: [HCC+91] <author> Urs Hlzle, Bay-Wei Chang, Craig Chambers, Ole Agesen, and David Ungar. </author> <title> The SELF Manual, </title> <note> Version 1.1. Unpublished manual, </note> <month> February, </month> <year> 1991. </year>
Reference-contexts: Unfortunately, most languages and implementations do not support all these desirable features, again because they historically have had a high cost in run-time performance. 1.2 The SELF Language To maximize the potential benefits of object-oriented programming, David Ungar and Randy Smith designed the SELF programming language <ref> [US87, HCC+91, UCCH91, CUCH91] </ref> as a refinement and simplification of the Smalltalk-80 language. <p> Consequently, the performance of existing object-oriented languages lags far behind the performance of conventional languages. 34 35 Chapter 4 The SELF Language SELF is a dynamically-typed prototype-based object-oriented language with multiple, dynamic inheritance, originally designed by David Ungar and Randy Smith at Xerox PARC in 1986 <ref> [US87, HCC+91, UCCH91, CUCH91] </ref> as a successor to the Smalltalk-80 programming language. Like Smalltalk, SELF is intended for exploratory programming environments in which rapid program development and modification are primary goals. <p> The byte code object contains a byte array for the byte codes themselves, and a separate object array for the constants and message names used in the source code. * Resends and directed resends are described in detail in [CUCH91] and <ref> [HCC+91] </ref>. (code) literals codes . . . method object byte code object (prototype activation record) IMPLICIT-SELF SEND # 0 (x) SEND # 1 (print) LITERAL # 2 (, ) SEND # 1 (print) IMPLICIT-SELF SEND # 3 (y) SEND # 1 (print) byte code array literal array self* x print @
Reference: [HCU91] <author> Urs Hlzle, Craig Chambers, and David Ungar. </author> <title> Optimizing Dynamically-Typed Object-Oriented Programming Languages with Polymorphic Inline Caches. </title> <booktitle> In ECOOP 91 Conference Proceedings, </booktitle> <pages> pp. 21-38, </pages> <address> Geneva, Switzerland, </address> <month> July, </month> <year> 1991. </year>
Reference-contexts: executions of the same message send will test the most recently invoked method first. * * After the bulk of the research reported in this dissertation was completed, Urs Hlzle and other members of the SELF group designed and implemented an extension to normal in-line caching called polymorphic inline caching <ref> [HCU91] </ref>. Polymorphic inline caches roughly act like dynamically-growing chains of normal monomorphic in-line caches, eventually increasing the hit rate for a polymorphic inline cache to 100%. <p> For example, dynamic profile data could be used to augment or replace the static table built into the compiler. We are actively investigating techniques that would make type prediction more adapting to changing usage patterns <ref> [HCU91] </ref>. expr: -true, false, unknown result ifTrue:(expr, block) expr = true? result ifTrue:(expr, block) expr: true expr: false expr: -false, not true expr = false? result ifTrue:(expr, block) expr: not true or false 82 9.5 Block Analysis Blocks are very common in SELF code, primarily because of their central role in <p> This characteristic may not be true in the future with the introduction of adaptive recompilation using polymorphic in-line caches <ref> [HCU91] </ref>, and so this type compatibility rule may need to be revised to keep down the number of iterations needed to reach the fixed point. 2 1- 2 132 uncommon-case loop tail compatible with an uncommon-case loop head if the types at the loop head merely contain the types at the <p> This goal is not yet met by the current SELF implementation, which for the richards benchmark runs about a third the speed of the optimized C version. Some initial work has already begun in this direction <ref> [HCU91] </ref>. A final direction would address more of the programming environment issues. <p> The current SELF implementation might meet the second level of performance but unfortunately is still not at the level of fraction-of-a-second compile pauses. To maintain a high-productivity environment, more research is needed to reconcile unnoticeable compiler pauses with good run-time performance. Fortunately, this problem also is being actively pursued <ref> [HCU91] </ref> and early results are quite promising. 15.4 Conclusion We believe that this work has demonstrated the feasibility of the new techniques and consequently the practicality of pure object-oriented languages for a wide range of applications. <p> Even though global reluctant splitting does not seem useful in todays system with local reluctant splitting and lazy compilation, in the future multiple common-case paths may be more frequent as other implementation techniques are incorporated <ref> [HCU91] </ref>, and global reluctant splitting may then begin to show significant improvement over local reluctant splitting. 192 smallstanfordoo-stanfordpuzzlerichardsparserprimMakerpathCache 193 B.4.2 Lazy Compilation of Uncommon Branches The charts on the following page report the performance of various reluctant splitting strategies both with and without lazy compilation of uncommon branches. <p> However, in environments or applications where vector receivers were more common, vector type prediction could significantly improve performance. Developing a system in which some parts type-predict for vectors while others do not is an active area of current research <ref> [HCU91] </ref>. Type predicting for vectors uniformly slows down compilation. Usually this slow-down is less than 20%, but when mispredictions force the compiler to generate uncommon branch extension methods (when non-vector cases are considered uncommon), compile times can be twice as long as with the normal configuration.
Reference: [Hl91] <author> Urs Hlzle. </author> <title> In-line cache improvements. </title> <type> Personal communication, </type> <month> August, </month> <year> 1991. </year>
Reference-contexts: Since these measurements were made and the problem discovered, the implementation of in-line caches with many receiver types has been improved, and now in-line cached sends reportedly are almost always faster than uncached sends <ref> [Hl91] </ref>. B.3.5 Type Analysis The SELF compiler relies on type analysis to propagate type information through the control ow graph and thus inline away more messages and avoid unnecessary type tests. Type analysis was the subject of Chapter 9 and much of Chapter 11.
Reference: [HCU92] <author> Urs Hlzle, Craig Chambers, and David Ungar. </author> <title> Debugging Optimized Code with Dynamic De-Optimization. </title> <booktitle> To appear in Proceedings of the SIGPLAN 92 Conference on Programming Language Design and Implementation, </booktitle> <address> San Francisco, CA, </address> <month> June, </month> <year> 1992. </year>
Reference-contexts: Chapter 13 describes compiler support for the SELF programming environment, in particular techniques that mask the effects of optimizations such as inlining and splitting from the SELF programmer when debugging; some of these techniques have been described in other papers <ref> [CUL89, HCU92] </ref>. Section 5.3 contains a more detailed outline of this part of the dissertation. The performance of our SELF implementation is analyzed in Chapter 14. This analysis measures various configurations of our implementation and identifies the individual contributions to performance of particular techniques. <p> The approach taken in the SELF system is to recompile the out-of-date compiled method and rebuild its stack frame based on the data stored in the old stack frame. * The SELF system performs this conversion lazily to make this recompilation easier and less intrusive <ref> [HCU92] </ref>.
Reference: [Hut87] <author> Norman C. Hutchinson. </author> <title> Emerald: An Object-Based Language for Distributed Programming. </title> <type> Ph.D. thesis, </type> <institution> University of Washington, </institution> <year> 1987. </year>
Reference-contexts: The implementors openly admit that Trellis/Owls performance is not near that of traditional languages, but report that performance is good enough for their users. 3.2.4 Emerald Emerald is a statically-typed pure object-oriented language for distributed programming <ref> [BHJL86, Hut87, HRB+87, JLHB88, Jul88] </ref>. Emerald is unusual in lacking both classes and implementation inheritance: Emerald objects are completely self-sufficient. Emerald does include a separate subtyping hierarchy, however, and recent versions include a powerful mechanism for statically-type-checked polymorphism [BH90].
Reference: [HRB+87] <author> Norman C. Hutchinson, Rajendra K. Raj, Andrew P. Black, Henry M. Levy, and Eric Jul. </author> <title> The Emerald Programming Language Report. </title> <type> Technical Report 87-10-07, </type> <institution> Department of Computer Science, University of Washington, </institution> <month> October, </month> <year> 1987. </year>
Reference-contexts: The implementors openly admit that Trellis/Owls performance is not near that of traditional languages, but report that performance is good enough for their users. 3.2.4 Emerald Emerald is a statically-typed pure object-oriented language for distributed programming <ref> [BHJL86, Hut87, HRB+87, JLHB88, Jul88] </ref>. Emerald is unusual in lacking both classes and implementation inheritance: Emerald objects are completely self-sufficient. Emerald does include a separate subtyping hierarchy, however, and recent versions include a powerful mechanism for statically-type-checked polymorphism [BH90].
Reference: [HC89] <author> Wen-mei W. Hwu and Pohua P. Chang. </author> <title> Inline Function Expansion for Compiling C Programs. </title> <booktitle> In Proceedings of the SIGPLAN 89 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 246-257, </pages> <address> Portland, OR, </address> <month> June, </month> <year> 1989. </year> <note> Published as SIGPLAN Notices 24(7), </note> <month> July, </month> <year> 1989. </year>
Reference-contexts: Some languages, including C++, provide mechanisms through which the programmer can tell the compiler to inline calls to particular routines. More sophisticated systems attempt to determine automatically which routines should be inlined <ref> [Sch77, AJ88, HC89, RG89, McF91] </ref>. Inlining itself is not a particularly difficult transformation, but it is harder to devise a set of good heuristics to control automatic inlining, balancing compiled code space and compilation time increases against projected run-time performance improvements and operating correctly in the presence of recursive routines.
Reference: [Ing78] <author> Daniel H. H. Ingalls. </author> <title> The Smalltalk-76 Programming System Design and Implementation. </title> <booktitle> In Conference Record of the Fifth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 9-16, </pages> <address> Tucson, AZ, </address> <year> 1978. </year>
Reference: [Ive62] <author> Kenneth Iverson. </author> <title> A Programming Language. </title> <publisher> Wiley, </publisher> <address> New York, </address> <year> 1962. </year>
Reference-contexts: Most object-oriented languages, including C++, Eiffel, Trellis/Owl, Smalltalk, T, and CLOS, would benefit (to varying degrees) from the techniques we have 44 developed. Also, languages with object-oriented subsystems would benefit, including languages supporting some form of generic arithmetic such as Lisp, APL <ref> [Ive62, GR84] </ref>, PostScript [Ado85], and Icon [GG83], languages with logic variables such as Prolog, and languages with futures such as Multilisp [Hal85] and Mul-T [KHM89]. 5.2 Overall Approach This section describes the overall approach to achieving an efficient implementation of SELF and similar languages. 5.2.1 Representation-Level Type Information Is Key Dynamically-typed
Reference: [JW85] <author> Kathleen Jensen and Niklaus Wirth. </author> <title> Pascal User Manual and Report. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1985. </year>
Reference-contexts: Traditional programming languages such as C [KR78] and Pascal <ref> [JW85] </ref> include record and array data type declarations; Lisp [WH81, Ste84], Prolog [SS86], and many functional programming languages [MTH90, Wik87, Pey87] include cons cells. These type declarations build concrete data types.
Reference: [Joh86] <author> Ralph E. Johnson. </author> <title> Type-Checking Smalltalk. </title> <booktitle> In OOPSLA 86 Conference Proceedings, </booktitle> <pages> pp. 315-321, </pages> <address> Portland, OR, </address> <month> September, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year>
Reference-contexts: In an effort to improve the speed of Smalltalk programs, Ralph Johnson and his group at the University of Illinois at Urbana-Champaign have designed an extension to Smalltalk called Typed Smalltalk <ref> [Joh86, JGZ88, McC89, Hei90, Gra89, GJ90] </ref>. They added explicit type declarations to Smalltalk and built an optimizing compiler, called TS, that uses these type declarations to improve run-time performance. A type in Typed Smalltalk is either a (possibly singleton) set of classes * or a signature.
Reference: [Joh87] <author> Ralph Johnson. </author> <title> Workshop on Compiling and Optimizing Object-Oriented Programming Languages. </title> <booktitle> In Addendum to the OOPSLA 87 Conference Proceedings, </booktitle> <pages> pp. 59-65, </pages> <address> Orlando, FL, </address> <month> October, </month> <year> 1987. </year> <note> Published as SIGPLAN Notices 23(5), </note> <month> May, </month> <year> 1988. </year>
Reference-contexts: Future systems should attempt to achieve this level of unobtrusiveness. 3.1.3 Typed Smalltalk and TS Optimizing Compiler Many researchers have noted that the chief obstacle to improving the performance of Smalltalk programs is the lack of representation-level type information upon which to base optimizations like procedure inlining <ref> [Joh87] </ref>. In an effort to improve the speed of Smalltalk programs, Ralph Johnson and his group at the University of Illinois at Urbana-Champaign have designed an extension to Smalltalk called Typed Smalltalk [Joh86, JGZ88, McC89, Hei90, Gra89, GJ90].
Reference: [JGZ88] <author> Ralph E. Johnson, Justin O. Graver, and Lawrence W. Zurawski. </author> <title> TS: An Optimizing Compiler for Smalltalk. </title> <booktitle> In OOPSLA 88 Conference Proceedings, </booktitle> <pages> pp. 18-26, </pages> <address> San Diego, CA, </address> <month> October, </month> <year> 1988. </year> <note> Published as SIGPLAN Notices 23(11), </note> <month> November, </month> <year> 1988. </year>
Reference-contexts: In an effort to improve the speed of Smalltalk programs, Ralph Johnson and his group at the University of Illinois at Urbana-Champaign have designed an extension to Smalltalk called Typed Smalltalk <ref> [Joh86, JGZ88, McC89, Hei90, Gra89, GJ90] </ref>. They added explicit type declarations to Smalltalk and built an optimizing compiler, called TS, that uses these type declarations to improve run-time performance. A type in Typed Smalltalk is either a (possibly singleton) set of classes * or a signature.
Reference: [JLHB88] <author> Eric Jul, Henry Levy, Normal Hutchinson, and Andrew Black. </author> <title> Fine-Grained Mobility in the Emerald System. </title> <booktitle> In ACM Transactions on Computer Systems 6(1), </booktitle> <pages> pp. 109-133, </pages> <month> February, </month> <year> 1988. </year>
Reference-contexts: The implementors openly admit that Trellis/Owls performance is not near that of traditional languages, but report that performance is good enough for their users. 3.2.4 Emerald Emerald is a statically-typed pure object-oriented language for distributed programming <ref> [BHJL86, Hut87, HRB+87, JLHB88, Jul88] </ref>. Emerald is unusual in lacking both classes and implementation inheritance: Emerald objects are completely self-sufficient. Emerald does include a separate subtyping hierarchy, however, and recent versions include a powerful mechanism for statically-type-checked polymorphism [BH90].
Reference: [Jul88] <author> Eric Jul. </author> <title> Object Mobility in a Distributed Object-Oriented System. </title> <type> Ph.D. thesis, </type> <institution> University of Washington, </institution> <month> December, </month> <year> 1988. </year> <month> 230 </month>
Reference-contexts: The implementors openly admit that Trellis/Owls performance is not near that of traditional languages, but report that performance is good enough for their users. 3.2.4 Emerald Emerald is a statically-typed pure object-oriented language for distributed programming <ref> [BHJL86, Hut87, HRB+87, JLHB88, Jul88] </ref>. Emerald is unusual in lacking both classes and implementation inheritance: Emerald objects are completely self-sufficient. Emerald does include a separate subtyping hierarchy, however, and recent versions include a powerful mechanism for statically-type-checked polymorphism [BH90].
Reference: [KR78] <author> Brian W. Kernighan and Dennis M. Ritchie. </author> <title> The C Programming Language. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1978. </year>
Reference-contexts: Those readers familiar with these language features and implementation challenges may choose to skim this chapter. 2.1 Abstract Data Types 2.1.1 Benefits to Programmers The ability to describe and manipulate data structures is central to the expressive power of a language. Traditional programming languages such as C <ref> [KR78] </ref> and Pascal [JW85] include record and array data type declarations; Lisp [WH81, Ste84], Prolog [SS86], and many functional programming languages [MTH90, Wik87, Pey87] include cons cells. These type declarations build concrete data types.
Reference: [Kil88] <author> Michael F. Kilian. </author> <title> Why Trellis/Owl Runs Fast. </title> <type> Unpublished manuscript, </type> <month> March, </month> <year> 1988. </year>
Reference-contexts: It is a pure object-oriented language, in that all operations on objects are performed using message sends, with no statically-bound procedure calls in the language, ** and even variables are accessed solely via messages. The Trellis/Owl implementation has been concerned primarily with eliminating the overhead for these messages <ref> [Kil88] </ref>. As its principle implementation technique, Trellis/Owl automatically compiles a separate version of each source method for each inheriting subclass. Each version is used only for receivers whose class is exactly the same as the one assumed by the copy.
Reference: [KKR+] <author> David Kranz, Richard Kelsey, Jonathan Rees, Paul Hudak, James Philbin, and Norman Adams. </author> <title> ORBIT: An Optimizing Compiler for Scheme. </title> <booktitle> In Proceedings of the SIGPLAN 86 Symposium on Compiler Construction, </booktitle> <pages> pp. 219-233, </pages> <address> Palo Alto, CA, </address> <month> June, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(7), </note> <month> July, </month> <year> 1986. </year>
Reference: [Kra88] <author> David Andrew Kranz. </author> <title> Orbit: An Optimizing Compiler for Scheme. </title> <type> Ph.D. thesis, </type> <institution> Yale University, </institution> <year> 1988. </year>
Reference-contexts: The ORBIT T compiler by Kranz et al is a well-respected Scheme compiler <ref> [KKR+86, Kra88] </ref>. The ORBIT compiler analyzes the use of closures and continuations and attempts to avoid heap allocation of closures whenever possible. Early measurements indicate that ORBITs performance is comparable both to other Lisps without closures and even to traditional languages such as Pascal.
Reference: [KHM89] <author> David A. Kranz, Robert H. Halstead, Jr., and Eric Mohr. Mul-T: </author> <title> A High-Performance Parallel Lisp. </title> <booktitle> In Proceedings of the SIGPLAN 89 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 81-90, </pages> <address> Portland, OR, </address> <month> June, </month> <year> 1989. </year> <note> Published as SIGPLAN Notices 24(7), </note> <month> July, </month> <year> 1989. </year>
Reference-contexts: Also, languages with object-oriented subsystems would benefit, including languages supporting some form of generic arithmetic such as Lisp, APL [Ive62, GR84], PostScript [Ado85], and Icon [GG83], languages with logic variables such as Prolog, and languages with futures such as Multilisp [Hal85] and Mul-T <ref> [KHM89] </ref>. 5.2 Overall Approach This section describes the overall approach to achieving an efficient implementation of SELF and similar languages. 5.2.1 Representation-Level Type Information Is Key Dynamically-typed object-oriented programming languages historically have run much slower than traditional statically-typed non-object-oriented programming languages. <p> Implementations of logic programming languages such as Prolog might benefit from knowing that along certain branches some logic variable is guaranteed to be instantiated; this knowledge could come from techniques related to type analysis and splitting. Similarly, implementations of programming languages supporting futures such as Multilisp [Hal85] and Mul-T <ref> [KHM89] </ref> could distinguish between known and unknown futures, compiling specialized code for each case (or perhaps just for the common case of known futures).
Reference: [Kra89] <author> David Kranz. </author> <title> Optimization of object-oriented features in the ORBIT compiler. </title> <type> Personal communication, </type> <month> June, </month> <year> 1989. </year>
Reference-contexts: Additionally, no user-defined control structures are used in the benchmarks measured, only the built-in control structures. Finally, ORBIT does not optimize the object-oriented features of T <ref> [Kra89] </ref>. 3.3.3 Shivers Control Flow Analysis and Type Recovery Olin Shivers has developed a set of algorithms for constructing relatively large control ow graphs from Scheme programs using interprocedural analysis, even in the presence of higher-order functions and closures [Shi88].
Reference: [Kra90] <author> David Kranz. </author> <title> Optimization of generic arithmetic in the ORBIT compiler. </title> <type> Personal communication, </type> <month> June, </month> <year> 1990. </year>
Reference-contexts: However, as seems to be the rule with Lisp benchmarks, the unsafe type-specific versions of arithmetic operators are used to achieve fast performance; the compiler does not optimize the performance of true generic arithmetic <ref> [Kra90] </ref>. Additionally, no user-defined control structures are used in the benchmarks measured, only the built-in control structures.
Reference: [Kra83] <author> Glenn Krasner, </author> <title> editor. Smalltalk-80: Bits of History, Words of Advice. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1983. </year>
Reference-contexts: Originally, Smalltalk-80 ran on Xerox Dorados implementing this instruction set in microcode [Deu83]. Subsequent software implementations of Smalltalk-80 on stock hardware supplied a virtual machine that interpreted these byte codes in software. Needless to say this interpretation was quite slow <ref> [Kra83] </ref>. 14 Additionally, Smalltalk-80 activation records are defined and implemented as first-class objects, allocated in the heap and garbage collected when no longer referenced. This design further slowed the implementation of method call and return with the cost to allocate and eventually deallocate these activation record objects. <p> B.1 Detailed Description of the Benchmarks We measured the following micro-benchmarks: recur is a tiny recursive benchmark that stresses method call and integer comparison and subtraction, adapted from the testActivationReturn Smalltalk-80 micro-benchmark <ref> [Kra83] </ref>. sumTo adds up all the numbers from its receiver (1) to its argument (10000), 100 times over. fastSumTo is the same as sumTo, except that the body of sumTo is inlined into the outer loop (manually in the C, Smalltalk, and T versions, automatically in the SELF version). sumFromTo is
Reference: [LH86] <author> James R. Larus and Paul N. Hilfinger. </author> <title> Register Allocation in the SPUR Lisp Compiler. </title> <booktitle> In Proceedings of the SIGPLAN 86 Symposium on Compiler Construction, </booktitle> <pages> pp. 255-263, </pages> <address> Palo Alto, CA, </address> <month> June, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(7), </note> <month> July, </month> <year> 1986. </year>
Reference-contexts: an NP-complete problem, so much of the work in implementing graph-coloring-based register allocators in real compilers involves developing heuristics that can usually find a coloring of the interference graph in a reasonable amount of time, and in handling spilling of variables to memory if no coloring can be quickly found <ref> [CAC+81, Cha82, CH84, LH86, BCKT89, CH90] </ref>.
Reference: [Lea90] <editor> Douglas Lea. Customization in C++. </editor> <booktitle> In Proceedings of the 1990 Usenix C++ Conference, </booktitle> <pages> pp. 301-314, </pages> <address> San Francisco, CA, </address> <month> April, </month> <year> 1990. </year>
Reference-contexts: However, our techniques would still be useful to the extent that implementations wish to support and encourage the use of the object-oriented features of their languages. One researcher already has proposed extending C++ to support a form of customization <ref> [Lea90] </ref>. Our techniques also could improve the performance of many languages that do not claim to be object-oriented. These languages include powerful features in which several different representations of objects can be used interchangeably within programs.
Reference: [Lee88] <author> Elgin Lee. </author> <title> Object Storage and Inheritance for SELF, a Prototype-Based Object-Oriented Programming Language. </title> <type> Engineers thesis, </type> <institution> Stanford University, </institution> <year> 1988. </year>
Reference-contexts: Chapter 5 presents the goals of this work and outlines the organization of the compiler. Chapter 6 describes the framework in which the compiler functions, including the memory system architecture and the run-time system. (An early design and implementation of the memory system was described in Elgin Lees thesis <ref> [Lee88] </ref>.) Chapters 7 through 12 present the bulk of the new techniques developed to improve run-time performance. These techniques include customization, type analysis, type prediction, and splitting. Earlier designs and implementations of these techniques have been described in other papers [CU89, CUL89, CU90, CU91]. <p> For minimal overhead in the common case, the SELF system represents object references using direct tagged pointers, rather than indirectly through an object table as do some Smalltalk systems. An early version of the SELF memory system was documented by Elgin Lee <ref> [Lee88] </ref>; a more recent version was described in [CUL89]. The following two subsections describe techniques for efficient object storage systems pioneered by the SELF implementation. Subsection 6.1.3 describes constraints placed on the compiler by SELFs garbage collection algorithm. <p> In particular, the SELF compiler does not produce derived pointers to the interior of an object. This restriction allows the garbage collector to assume that all data tagged as an object reference really points to the * This design is slightly different from segregation as described in <ref> [Lee88] </ref> and [CUL89], in which byte arrays were stored completely in the bytes area. The design was changed so that a byte array could have user-defined references to other objects in addition to its array of bytes. <p> the source and an object array holding the message names and object literals used in the source; the byte code object also records the original unparsed source and the file name and line number where the method was defined for user-interface purposes. * Earlier SELF implementations including that described in <ref> [Lee88] </ref> used a more traditional remembered set to record old objects containing pointers to new objects. 51 Each byte code in the byte array represents a single byte-sized virtual machine instruction and is divided into two parts: a 3-bit opcode and a 5-bit object array index.
Reference: [LZ74] <author> Barbara H. Liskov and Stephen N. Zilles. </author> <title> Programming with Abstract Data Types. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Very High Level Languages, </booktitle> <pages> pp. 50-59, </pages> <month> April, </month> <year> 1974. </year> <note> Published as SIGPLAN Notices 9(4), </note> <year> 1974. </year>
Reference-contexts: These type declarations build concrete data types. Manipulating concrete data structures is simply a matter of extracting fields from records or cons cells and indexing into arrays. Abstract data types <ref> [LZ74, LSAS77, LAB+81, LG86] </ref> provide a more expressive mechanism for describing and manipulating data structures. An abstract data type abstracts away from a concrete data type by providing a set of operations (the interface) through which clients are to manipulate objects of the type.
Reference: [LSAS77] <author> Barbara Liskov, Alan Snyder, Russell Atkinson, and J. Craig Schaffert. </author> <title> Abstraction Mechanisms in CLU. </title> <booktitle> In Communications of the ACM 20(8), </booktitle> <pages> pp. 564-576, </pages> <month> August, </month> <year> 1977. </year>
Reference-contexts: These type declarations build concrete data types. Manipulating concrete data structures is simply a matter of extracting fields from records or cons cells and indexing into arrays. Abstract data types <ref> [LZ74, LSAS77, LAB+81, LG86] </ref> provide a more expressive mechanism for describing and manipulating data structures. An abstract data type abstracts away from a concrete data type by providing a set of operations (the interface) through which clients are to manipulate objects of the type.
Reference: [LAB+81] <author> Barbara Liskov, Russell Atkinson, Toby Bloom, Eliot Moss, J. Craig Schaffert, Robert Scheier, and Alan Snyder. </author> <title> CLU Reference Manual. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1981. </year>
Reference-contexts: These type declarations build concrete data types. Manipulating concrete data structures is simply a matter of extracting fields from records or cons cells and indexing into arrays. Abstract data types <ref> [LZ74, LSAS77, LAB+81, LG86] </ref> provide a more expressive mechanism for describing and manipulating data structures. An abstract data type abstracts away from a concrete data type by providing a set of operations (the interface) through which clients are to manipulate objects of the type. <p> This static binding is not possible with only a single shared version of the source method, since each subclass is free to provide new implementations for all methods defined on the receiver. Additionally, to save compiled * These control structures were pioneered in the CLU language <ref> [LAB+81] </ref>, of which Trellis/Owl is a descendant. ** Operations on classes may only be invoked on class constants (variables cannot contain classes), and so are effectively statically bound.
Reference: [LG86] <author> Barbara Liskov and John Guttag. </author> <title> Abstraction and Specification in Program Development. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1986. </year>
Reference-contexts: These type declarations build concrete data types. Manipulating concrete data structures is simply a matter of extracting fields from records or cons cells and indexing into arrays. Abstract data types <ref> [LZ74, LSAS77, LAB+81, LG86] </ref> provide a more expressive mechanism for describing and manipulating data structures. An abstract data type abstracts away from a concrete data type by providing a set of operations (the interface) through which clients are to manipulate objects of the type.
Reference: [McC89] <author> Carl D. McConnell. </author> <title> The Design of the RTL System. </title> <type> Masters thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <year> 1989. </year>
Reference-contexts: In an effort to improve the speed of Smalltalk programs, Ralph Johnson and his group at the University of Illinois at Urbana-Champaign have designed an extension to Smalltalk called Typed Smalltalk <ref> [Joh86, JGZ88, McC89, Hei90, Gra89, GJ90] </ref>. They added explicit type declarations to Smalltalk and built an optimizing compiler, called TS, that uses these type declarations to improve run-time performance. A type in Typed Smalltalk is either a (possibly singleton) set of classes * or a signature.
Reference: [McF91] <author> Scott McFarling. </author> <title> Procedure Merging with Instruction Caches. </title> <booktitle> In Proceedings of the SIGPLAN 91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 71-79, </pages> <address> Toronto, Ontario, Canada, </address> <month> June, </month> <year> 1991. </year> <note> Published as SIGPLAN Notices 26(6), </note> <month> June, </month> <year> 1991. </year>
Reference-contexts: Some languages, including C++, provide mechanisms through which the programmer can tell the compiler to inline calls to particular routines. More sophisticated systems attempt to determine automatically which routines should be inlined <ref> [Sch77, AJ88, HC89, RG89, McF91] </ref>. Inlining itself is not a particularly difficult transformation, but it is harder to devise a set of good heuristics to control automatic inlining, balancing compiled code space and compilation time increases against projected run-time performance improvements and operating correctly in the presence of recursive routines.
Reference: [Mey86] <author> Bertrand Meyer. </author> <title> Genericity versus Inheritance. </title> <booktitle> In OOPSLA 86 Conference Proceedings, </booktitle> <pages> pp. 391-405, </pages> <address> Portland, OR, </address> <month> September, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year>
Reference-contexts: Several object-oriented languages have been designed and implemented, including Smalltalk-80 * [GR83], C++ [Str86, ES90], Trellis/Owl [SCW85, SCB+86], Eiffel <ref> [Mey86, Mey88, Mey92] </ref>, Modula-3 [Nel91, Har92], CLOS [BDG+88], and T [RA82, Sla87, RAM90]. <p> The Emerald compiler performs no inlining of user-defined methods, however, even when statically-bound. 27 3.2.5 Eiffel Eiffel is a statically-typed class-based object-oriented language supporting multiple inheritance <ref> [Mey86, Mey88, Mey92] </ref>. Like C++ and Trellis/Owl, Eiffel equates classes with types, and treats subclassing as subtyping. However, Eiffel does not verify that subclasses are legal subtypes of their superclasses, and in fact provides many commonly-used features that violate the standard subtype compatibility rules assumed by other statically-typed object-oriented languages.
Reference: [Mey88] <author> Bertrand Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: Several object-oriented languages have been designed and implemented, including Smalltalk-80 * [GR83], C++ [Str86, ES90], Trellis/Owl [SCW85, SCB+86], Eiffel <ref> [Mey86, Mey88, Mey92] </ref>, Modula-3 [Nel91, Har92], CLOS [BDG+88], and T [RA82, Sla87, RAM90]. <p> The Emerald compiler performs no inlining of user-defined methods, however, even when statically-bound. 27 3.2.5 Eiffel Eiffel is a statically-typed class-based object-oriented language supporting multiple inheritance <ref> [Mey86, Mey88, Mey92] </ref>. Like C++ and Trellis/Owl, Eiffel equates classes with types, and treats subclassing as subtyping. However, Eiffel does not verify that subclasses are legal subtypes of their superclasses, and in fact provides many commonly-used features that violate the standard subtype compatibility rules assumed by other statically-typed object-oriented languages.
Reference: [Mey92] <author> Bertrand Meyer. </author> <title> Eiffel: The Language. </title> <publisher> Prentice Hall, </publisher> <address> New York, </address> <year> 1992. </year>
Reference-contexts: Several object-oriented languages have been designed and implemented, including Smalltalk-80 * [GR83], C++ [Str86, ES90], Trellis/Owl [SCW85, SCB+86], Eiffel <ref> [Mey86, Mey88, Mey92] </ref>, Modula-3 [Nel91, Har92], CLOS [BDG+88], and T [RA82, Sla87, RAM90]. <p> The Emerald compiler performs no inlining of user-defined methods, however, even when statically-bound. 27 3.2.5 Eiffel Eiffel is a statically-typed class-based object-oriented language supporting multiple inheritance <ref> [Mey86, Mey88, Mey92] </ref>. Like C++ and Trellis/Owl, Eiffel equates classes with types, and treats subclassing as subtyping. However, Eiffel does not verify that subclasses are legal subtypes of their superclasses, and in fact provides many commonly-used features that violate the standard subtype compatibility rules assumed by other statically-typed object-oriented languages.
Reference: [MTH90] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1990. </year>
Reference-contexts: Traditional programming languages such as C [KR78] and Pascal [JW85] include record and array data type declarations; Lisp [WH81, Ste84], Prolog [SS86], and many functional programming languages <ref> [MTH90, Wik87, Pey87] </ref> include cons cells. These type declarations build concrete data types. Manipulating concrete data structures is simply a matter of extracting fields from records or cons cells and indexing into arrays.
Reference: [Mot85] <author> Motorola. </author> <title> MC68020 32-Bit Microprocessor Users Manual, Second Edition. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1985. </year>
Reference-contexts: The machine hardware provides support for efficiently managing stack frames. For example, the Motorola 680x0 architectures provide special instructions such as link, jsr, and movem for managing linked stacks of activation records and stack pointers <ref> [Mot85] </ref>, and the Sun SPARC architecture provides hardware register windows to support fast procedure calls and returns with little register saving and restoring overhead [Sun91]. Garbage collection places some requirements on the design and implementation of the run-time system and the compiler.
Reference: [Nel91] <author> Greg Nelson, </author> <title> editor. Systems Programming with Modula-3. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year> <month> 231 </month>
Reference-contexts: Several object-oriented languages have been designed and implemented, including Smalltalk-80 * [GR83], C++ [Str86, ES90], Trellis/Owl [SCW85, SCB+86], Eiffel [Mey86, Mey88, Mey92], Modula-3 <ref> [Nel91, Har92] </ref>, CLOS [BDG+88], and T [RA82, Sla87, RAM90].
Reference: [PW86] <author> David A. Padua and Michael J. Wolfe. </author> <title> Advanced Compiler Optimizations for Supercomputers. </title> <booktitle> In Communications of the ACM 29(12), </booktitle> <pages> pp. 1184-1201, </pages> <month> December, </month> <year> 1986. </year>
Reference-contexts: In this section we discuss several conventional techniques that relate to techniques used for SELF. 3.4.1 Data Flow Analysis Much work has been done on developing techniques to optimize traditional statically-typed non-object-oriented imperative programming languages such as Fortran [BBB+57], C, and Pascal <ref> [ASU86, PW86, Gup90] </ref>. Many of these techniques revolve around data ow analysis, a framework in which information is computed about a procedure by propagating information through the procedures control ow graph.
Reference: [Pey87] <editor> Simon L. Peyton Jones. </editor> <booktitle> The Implementation of Functional Programming Languages. </booktitle> <publisher> Prentice-Hall, </publisher> <address> New York, </address> <year> 1987. </year>
Reference-contexts: Traditional programming languages such as C [KR78] and Pascal [JW85] include record and array data type declarations; Lisp [WH81, Ste84], Prolog [SS86], and many functional programming languages <ref> [MTH90, Wik87, Pey87] </ref> include cons cells. These type declarations build concrete data types. Manipulating concrete data structures is simply a matter of extracting fields from records or cons cells and indexing into arrays.
Reference: [PW90] <author> William Pugh and Grant Weddell. </author> <title> Two-Directional Record Layout for Multiple Inheritance. </title> <booktitle> In Proceedings of the SIGPLAN 90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 85-91, </pages> <address> White Plains, NY, </address> <month> June, </month> <year> 1990. </year> <note> Published as SIGPLAN Notices 25(6), </note> <month> June, </month> <year> 1990. </year>
Reference-contexts: Dixon et al use a graph coloring technique to determine message names which must be given distinct indices [DMSV89]; they report that only a small amount of space is wasted in empty _vtbl array entries. Pugh and Weddell propose a novel extension that allows negative indices <ref> [PW90] </ref>. The extra degree of freedom in assigning indices without wasting space saves a significant amount of space. They report only 6% wasted space for a Flavors system with 564 classes and 2245 fields using their technique, versus 47% wasted space for a more conventional index assignment algorithm.
Reference: [RA82] <author> Jonathan Rees and Norman Adams. </author> <title> T: a Dialect of Lisp or, Lambda: the Ultimate Software Tool. </title> <booktitle> In Proceedings of the 1982 ACM Symposium on Lisp and Functional Programming, </booktitle> <pages> pp. 114-122, </pages> <month> August, </month> <year> 1982. </year>
Reference-contexts: Several object-oriented languages have been designed and implemented, including Smalltalk-80 * [GR83], C++ [Str86, ES90], Trellis/Owl [SCW85, SCB+86], Eiffel [Mey86, Mey88, Mey92], Modula-3 [Nel91, Har92], CLOS [BDG+88], and T <ref> [RA82, Sla87, RAM90] </ref>. Unfortunately, traditional implementations of object-oriented language features, particularly message passing, have been much slower than traditional implementations of their non-object-oriented counterparts, and this gap in run-time performance has limited the widespread use of object-oriented language features and hindered the acceptance of purely object-oriented languages. <p> Also, type-specific unchecked versions of arithmetic functions exist for programmers who are willing to sacrifice both safety and reusability in the quest for speed. 3.3.2 The T Language and the ORBIT Compiler T is an object-oriented extension to Scheme <ref> [RA82, Sla87, RAM90] </ref>. It includes all the features of Scheme, including first-class closures and continuations, and adds the ability to declare dynamically-bound generic operations and object structure types.
Reference: [RC86] <editor> Jonathan Rees and William Clinger, editors. </editor> <title> Revised 3 Report on the Algorithmic Language Scheme. </title> <booktitle> In SIGPLAN Notices 21(12), </booktitle> <month> December, </month> <year> 1986. </year>
Reference-contexts: In this situation, the closure would act like an exception handler. Closures typically provide a way to prematurely exit computations, either using first-class continuations as in Scheme <ref> [AS85, RC86, HDB90] </ref> or using non-local returns as in Smalltalk-80 or SELF. When returning non-locally, the closure returns not to its caller (e.g., the popHandlingEmpty operation) but from its lexically-enclosing operation (e.g., the caller of popHandlingEmpty). Thus non-local returns have an effect similar to return statements in C. <p> are not directly applicable to a dynamically-typed language such as SELF; adding in extra run-time checking to detect illegal messages would sacrifice any performance advantage held by the virtual function table implementation over a system like in-line caching. 3.3 Scheme Systems Scheme is a dynamically-typed function-oriented language descended from Lisp <ref> [AS85, RC86] </ref>. Scheme supports several language features described in Chapter 2 as desirable, including closures and generic arithmetic. Consequently, insights into the construction of efficient Scheme implementations may help in building efficient implementations of object-oriented languages, particularly ones with user-defined control structures and generic arithmetic.
Reference: [RAM90] <author> Jonathan Rees, Norman Adams, and James Meehan. </author> <title> The T Manual, Fifth Edition, </title> <institution> Yale University, </institution> <month> October, </month> <year> 1990. </year>
Reference-contexts: Several object-oriented languages have been designed and implemented, including Smalltalk-80 * [GR83], C++ [Str86, ES90], Trellis/Owl [SCW85, SCB+86], Eiffel [Mey86, Mey88, Mey92], Modula-3 [Nel91, Har92], CLOS [BDG+88], and T <ref> [RA82, Sla87, RAM90] </ref>. Unfortunately, traditional implementations of object-oriented language features, particularly message passing, have been much slower than traditional implementations of their non-object-oriented counterparts, and this gap in run-time performance has limited the widespread use of object-oriented language features and hindered the acceptance of purely object-oriented languages. <p> Also, type-specific unchecked versions of arithmetic functions exist for programmers who are willing to sacrifice both safety and reusability in the quest for speed. 3.3.2 The T Language and the ORBIT Compiler T is an object-oriented extension to Scheme <ref> [RA82, Sla87, RAM90] </ref>. It includes all the features of Scheme, including first-class closures and continuations, and adds the ability to declare dynamically-bound generic operations and object structure types.
Reference: [RG89] <author> Steve Richardson and Mahadevan Ganapathi. </author> <title> Interprocedural Analysis vs. Procedure Integration. </title> <booktitle> In Information Processing Letters 32(3), </booktitle> <pages> pp. 137-142, </pages> <month> August, </month> <year> 1989. </year>
Reference-contexts: Some languages, including C++, provide mechanisms through which the programmer can tell the compiler to inline calls to particular routines. More sophisticated systems attempt to determine automatically which routines should be inlined <ref> [Sch77, AJ88, HC89, RG89, McF91] </ref>. Inlining itself is not a particularly difficult transformation, but it is harder to devise a set of good heuristics to control automatic inlining, balancing compiled code space and compilation time increases against projected run-time performance improvements and operating correctly in the presence of recursive routines.
Reference: [Ros88] <author> John R. Rose. </author> <title> Fast Dispatch Mechanisms for Stock Hardware. </title> <booktitle> In OOPSLA 88 Conference Proceedings, </booktitle> <pages> pp. 27-35, </pages> <address> San Diego, CA, </address> <month> October, </month> <year> 1988. </year> <note> Published as SIGPLAN Notices 23(11), </note> <month> November, </month> <year> 1988. </year>
Reference-contexts: collector could offset some (or perhaps all) of the extra performance advantage of this implementation approach over a simpler scheme such as in-line caching that never produces pointers into the middle of an object. 3.2.2 Other Fast Dispatch Mechanisms John Rose describes a framework for analyzing _vtbl-array-style message send implementations <ref> [Ros88] </ref>. His framework can describe several variations on the array-lookup implementation, and Rose carefully analyzes their relative performance. Not all variations are practical for all object-oriented languages; techniques such as that implemented in single-inheritance C++ are probably the fastest available short of statically binding and optionally inlining the message send.
Reference: [SCW85] <author> Craig Schaffert, Topher Cooper, and Carrie Wilpolt. </author> <title> Trellis Object-Based Environment, Language Reference Manual. </title> <type> Technical report DEC-TR-372, </type> <month> November, </month> <year> 1985. </year>
Reference-contexts: Several object-oriented languages have been designed and implemented, including Smalltalk-80 * [GR83], C++ [Str86, ES90], Trellis/Owl <ref> [SCW85, SCB+86] </ref>, Eiffel [Mey86, Mey88, Mey92], Modula-3 [Nel91, Har92], CLOS [BDG+88], and T [RA82, Sla87, RAM90]. <p> The extra cost for these run-time checks may be significant, and when combined with the original cost of the two to four additional memory indirections may be much more than the expected average cost of in-line caching. 3.2.3 Trellis/Owl Trellis/Owl is a statically-typed class-based object-oriented language supporting multiple inheritance <ref> [SCW85, SCB+86] </ref>. Trellis/Owl equates types with classes, and a subclass is required to be a legal subtype of its superclasses. Trellis/Owl includes the conventional kinds of built-in control structures, plus a type_case control structure that tests the run-time type of an expression.
Reference: [SCB+86] <author> Craig Schaffert, Topher Cooper, Bruce Bullis, Mike Kilian, and Carrie Wilpolt. </author> <title> An Introduction to Trellis/Owl. </title> <booktitle> In OOPSLA 86 Conference Proceedings, </booktitle> <pages> pp. 9-16, </pages> <address> Portland, OR, </address> <month> September, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year>
Reference-contexts: Several object-oriented languages have been designed and implemented, including Smalltalk-80 * [GR83], C++ [Str86, ES90], Trellis/Owl <ref> [SCW85, SCB+86] </ref>, Eiffel [Mey86, Mey88, Mey92], Modula-3 [Nel91, Har92], CLOS [BDG+88], and T [RA82, Sla87, RAM90]. <p> The extra cost for these run-time checks may be significant, and when combined with the original cost of the two to four additional memory indirections may be much more than the expected average cost of in-line caching. 3.2.3 Trellis/Owl Trellis/Owl is a statically-typed class-based object-oriented language supporting multiple inheritance <ref> [SCW85, SCB+86] </ref>. Trellis/Owl equates types with classes, and a subclass is required to be a legal subtype of its superclasses. Trellis/Owl includes the conventional kinds of built-in control structures, plus a type_case control structure that tests the run-time type of an expression.
Reference: [Sch77] <author> Robert W. Scheier. </author> <title> An Analysis of Inline Substitution for a Structured Programming Language. </title> <booktitle> In Communications of the ACM 20(9), </booktitle> <pages> pp. 647-654, </pages> <month> September, </month> <year> 1977. </year>
Reference-contexts: Some languages, including C++, provide mechanisms through which the programmer can tell the compiler to inline calls to particular routines. More sophisticated systems attempt to determine automatically which routines should be inlined <ref> [Sch77, AJ88, HC89, RG89, McF91] </ref>. Inlining itself is not a particularly difficult transformation, but it is harder to devise a set of good heuristics to control automatic inlining, balancing compiled code space and compilation time increases against projected run-time performance improvements and operating correctly in the presence of recursive routines.
Reference: [SS88] <author> Peter Sestoft and Harald Sndergaard. </author> <title> A Bibliography on Partial Evaluation. </title> <booktitle> In SIGPLAN Notices 23(2), </booktitle> <pages> pp. 19-27, </pages> <month> February, </month> <year> 1988. </year>
Reference-contexts: Abstract interpretation and data ow analysis are both techniques for statically analyzing programs, but a particular analysis problem can sometimes be described more elegantly using abstract interpretation. 3.4.3 Partial Evaluation Partial evaluation is a technique for optimizing a program based on a partial description of its input <ref> [SS88] </ref>.
Reference: [Shi88] <author> Olin Shivers. </author> <title> Control Flow Analysis in Scheme. </title> <booktitle> In Proceedings of the SIGPLAN 88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 164-174, </pages> <address> Atlanta, GA, </address> <month> June, </month> <year> 1988. </year> <note> Published as SIGPLAN Notices 23(7), </note> <month> July, </month> <year> 1988. </year>
Reference-contexts: Finally, ORBIT does not optimize the object-oriented features of T [Kra89]. 3.3.3 Shivers Control Flow Analysis and Type Recovery Olin Shivers has developed a set of algorithms for constructing relatively large control ow graphs from Scheme programs using interprocedural analysis, even in the presence of higher-order functions and closures <ref> [Shi88] </ref>. The resulting large control ow graph is more amenable to traditional optimizations than the original small control ow graphs, thus potentially boosting the performance of Scheme programs to that achieved by optimizing compilers for traditional languages.
Reference: [Shi90] <author> Olin Shivers. </author> <title> Data-Flow Analysis and Type Recovery in Scheme. </title> <type> Technical report CMU-CS-90-115, </type> <month> March, </month> <year> 1990. </year> <title> To appear in Topics in Advanced Language Implementation, </title> <editor> Peter Lee (ed.), </editor> <publisher> MIT Press. </publisher>
Reference-contexts: Shivers also developed a technique for type recovery in Scheme that attempts to infer the types of variables in programs <ref> [Shi90] </ref>. His algorithm begins with assignments from constants (which have a known type) and propagates this information though his extended interprocedural control ow graph along subsequent variable bindings, much like traditional data ow analysis (described in section 3.4.1).
Reference: [Sla87] <author> Stephen Slade. </author> <title> The T Programming Language. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1987. </year>
Reference-contexts: Several object-oriented languages have been designed and implemented, including Smalltalk-80 * [GR83], C++ [Str86, ES90], Trellis/Owl [SCW85, SCB+86], Eiffel [Mey86, Mey88, Mey92], Modula-3 [Nel91, Har92], CLOS [BDG+88], and T <ref> [RA82, Sla87, RAM90] </ref>. Unfortunately, traditional implementations of object-oriented language features, particularly message passing, have been much slower than traditional implementations of their non-object-oriented counterparts, and this gap in run-time performance has limited the widespread use of object-oriented language features and hindered the acceptance of purely object-oriented languages. <p> Also, type-specific unchecked versions of arithmetic functions exist for programmers who are willing to sacrifice both safety and reusability in the quest for speed. 3.3.2 The T Language and the ORBIT Compiler T is an object-oriented extension to Scheme <ref> [RA82, Sla87, RAM90] </ref>. It includes all the features of Scheme, including first-class closures and continuations, and adds the ability to declare dynamically-bound generic operations and object structure types.
Reference: [Ste76] <author> Guy Lewis Steele Jr. </author> <title> LAMBDA: The Ultimate Declarative. </title> <type> AI Memo 379, </type> <institution> MIT Artificial Intelligence Laboratory, </institution> <month> November, </month> <year> 1976. </year>
Reference-contexts: These chunks of code are called closures or blocks <ref> [SS76, Ste76] </ref> and enable programmers to implement their own iterators, exception handlers, and other sorts of control structures. For example, the stack data type could provide an operation called iterate that would take a closure as its argument.
Reference: [SS76] <author> Guy Lewis Steele Jr. and Gerald Jay Sussman. </author> <title> LAMBDA: The Ultimate Imperative. </title> <type> AI Memo 353, </type> <institution> MIT Artificial Intelligence Laboratory, </institution> <month> March, </month> <year> 1976. </year>
Reference-contexts: These chunks of code are called closures or blocks <ref> [SS76, Ste76] </ref> and enable programmers to implement their own iterators, exception handlers, and other sorts of control structures. For example, the stack data type could provide an operation called iterate that would take a closure as its argument.
Reference: [Ste84] <author> Guy L. Steele Jr. </author> <title> Common LISP. </title> <publisher> Digital Press, </publisher> <year> 1984. </year>
Reference-contexts: Traditional programming languages such as C [KR78] and Pascal [JW85] include record and array data type declarations; Lisp <ref> [WH81, Ste84] </ref>, Prolog [SS86], and many functional programming languages [MTH90, Wik87, Pey87] include cons cells. These type declarations build concrete data types. Manipulating concrete data structures is simply a matter of extracting fields from records or cons cells and indexing into arrays.
Reference: [SS86] <author> Leon Sterling and Ehud Shapiro. </author> <title> The Art of Prolog. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1986. </year>
Reference-contexts: Traditional programming languages such as C [KR78] and Pascal [JW85] include record and array data type declarations; Lisp [WH81, Ste84], Prolog <ref> [SS86] </ref>, and many functional programming languages [MTH90, Wik87, Pey87] include cons cells. These type declarations build concrete data types. Manipulating concrete data structures is simply a matter of extracting fields from records or cons cells and indexing into arrays.
Reference: [Str86] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1986. </year>
Reference-contexts: Several object-oriented languages have been designed and implemented, including Smalltalk-80 * [GR83], C++ <ref> [Str86, ES90] </ref>, Trellis/Owl [SCW85, SCB+86], Eiffel [Mey86, Mey88, Mey92], Modula-3 [Nel91, Har92], CLOS [BDG+88], and T [RA82, Sla87, RAM90]. <p> much of the ease of programming, exibility, and reusability of the original untyped code. 3.2 Statically-Typed Object-Oriented Languages Several statically-typed object-oriented languages have been implemented, and in this section we describe techniques used in these languages to achieve relatively good performance. 3.2.1 C++ C++ is a statically-typed class-based object-oriented language <ref> [Str86, ES90] </ref>. The original version of C++ included only single inheritance; recent versions (C++ 2.0 and later) have extended C++ to support multiple inheritance. C++ contains C as an embedded sublanguage and so incorporates all of Cs built-in control structures and data types.
Reference: [Str87] <author> Bjarne Stroustrup. </author> <title> Multiple Inheritance for C++. </title> <booktitle> In Proceedings of the European Unix Users Group Conference, </booktitle> <pages> pp. 189-207, </pages> <address> Helsinki, </address> <month> May, </month> <year> 1987. </year>
Reference: [Sun91] <author> Sun Microsystems. </author> <title> The SPARC Architecture Manual, </title> <type> Version 8. </type> <month> January, </month> <year> 1991. </year>
Reference-contexts: For example, the Motorola 680x0 architectures provide special instructions such as link, jsr, and movem for managing linked stacks of activation records and stack pointers [Mot85], and the Sun SPARC architecture provides hardware register windows to support fast procedure calls and returns with little register saving and restoring overhead <ref> [Sun91] </ref>. Garbage collection places some requirements on the design and implementation of the run-time system and the compiler. The garbage collector must be able to locate all object references stored in registers or on the stack.
Reference: [Ung84] <author> David Ungar. </author> <title> Generation Scavenging: A Non-Disruptive High Performance Storage Reclamation Algorithm. </title> <booktitle> In Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pp. 157-167, </pages> <address> Pittsburgh, PA, </address> <month> April, </month> <year> 1984, </year> <month> 232 </month>
Reference-contexts: scanner locates the object containing the reference by scanning backwards to the objects mark word and then converting the mark words address into an object reference by adding the right tag bits to the address. 6.1.3 Garbage Collection The SELF implementation reclaims inaccessible objects using a version of Generation Scavenging <ref> [Ung84, Ung87] </ref> with demographic feedback-mediated tenuring [UJ88], augmented with a traditional mark/sweep collector to reclaim tenured garbage.
Reference: [Ung87] <author> David Michael Ungar. </author> <title> The Design and Evaluation of a High-Performance Smalltalk System. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1987. </year>
Reference-contexts: scanner locates the object containing the reference by scanning backwards to the objects mark word and then converting the mark words address into an object reference by adding the right tag bits to the address. 6.1.3 Garbage Collection The SELF implementation reclaims inaccessible objects using a version of Generation Scavenging <ref> [Ung84, Ung87] </ref> with demographic feedback-mediated tenuring [UJ88], augmented with a traditional mark/sweep collector to reclaim tenured garbage. <p> However, even in large Smalltalk systems, the receiver of a message like + is an integer 90% to 95% of the time <ref> [Ung87] </ref>, so type prediction is useful even for programs written in a heavily object-oriented style. As reported in section 14.3, type prediction speeds SELF programs by a factor of 3 on average, with object-oriented SELF programs benefitting almost as much as more traditional, numeric benchmarks.
Reference: [US87] <author> David Ungar and Randall B. Smith. </author> <title> SELF: The Power of Simplicity. </title> <booktitle> In OOPSLA 87 Conference Proceedings, </booktitle> <pages> pp. 227-241, </pages> <address> Orlando, FL, </address> <month> October, </month> <year> 1987. </year> <note> Published as SIGPLAN Notices 22(12), </note> <month> December, </month> <year> 1987. </year> <title> Also published in Lisp and Symbolic Computation 4(3), </title> <publisher> Kluwer Academic Publishers, </publisher> <month> June, </month> <year> 1991. </year>
Reference-contexts: Unfortunately, most languages and implementations do not support all these desirable features, again because they historically have had a high cost in run-time performance. 1.2 The SELF Language To maximize the potential benefits of object-oriented programming, David Ungar and Randy Smith designed the SELF programming language <ref> [US87, HCC+91, UCCH91, CUCH91] </ref> as a refinement and simplification of the Smalltalk-80 language. <p> Consequently, the performance of existing object-oriented languages lags far behind the performance of conventional languages. 34 35 Chapter 4 The SELF Language SELF is a dynamically-typed prototype-based object-oriented language with multiple, dynamic inheritance, originally designed by David Ungar and Randy Smith at Xerox PARC in 1986 <ref> [US87, HCC+91, UCCH91, CUCH91] </ref> as a successor to the Smalltalk-80 programming language. Like Smalltalk, SELF is intended for exploratory programming environments in which rapid program development and modification are primary goals.
Reference: [UCCH91] <author> David Ungar, Craig Chambers, Bay-Wei Chang, and Urs Hlzle. </author> <title> Organizing Programs without Classes. Published in Lisp and Symbolic Computation 4(3), </title> <publisher> Kluwer Academic Publishers, </publisher> <month> June, </month> <year> 1991. </year>
Reference-contexts: Unfortunately, most languages and implementations do not support all these desirable features, again because they historically have had a high cost in run-time performance. 1.2 The SELF Language To maximize the potential benefits of object-oriented programming, David Ungar and Randy Smith designed the SELF programming language <ref> [US87, HCC+91, UCCH91, CUCH91] </ref> as a refinement and simplification of the Smalltalk-80 language. <p> Consequently, the performance of existing object-oriented languages lags far behind the performance of conventional languages. 34 35 Chapter 4 The SELF Language SELF is a dynamically-typed prototype-based object-oriented language with multiple, dynamic inheritance, originally designed by David Ungar and Randy Smith at Xerox PARC in 1986 <ref> [US87, HCC+91, UCCH91, CUCH91] </ref> as a successor to the Smalltalk-80 programming language. Like Smalltalk, SELF is intended for exploratory programming environments in which rapid program development and modification are primary goals. <p> We call such run-time changes in an objects inheritance dynamic inheritance, and we have found this facility to be of practical value in our SELF programming. Further information on the uses of dynamic inheritance may be found in <ref> [UCCH91] </ref>. 4.2.1 Message Syntax SELF message syntax is much like Smalltalk-80 message syntax. Both languages define three classes of message, distinguished syntactically: Unary messages. A unary message takes no arguments other than the receiver.
Reference: [Weg81] <author> Mark N. Wegman. </author> <title> General and Efficient Methods for Global Code Improvement. </title> <type> Ph.D. thesis, </type> <institution> University of California at Berkeley, </institution> <year> 1981. </year>
Reference-contexts: While the SELF compiler does not use precisely SSA form, its values, described in section 9.1.3, are quite similar. 3.4.5 Wegmans Node Distinction Mark Wegman describes a generalization of several standard code duplication and code motion optimizations called node distinction <ref> [Weg81] </ref>. Given some differentiating criterion computable through data ow analysis, Wegmans technique splits nodes downstream of a potential merge point if the merging paths have different values of the differentiating criterion.
Reference: [Weg87] <author> Peter Wegner. </author> <title> Dimensions of Object-Based Language Design. </title> <booktitle> In OOPSLA 87 Conference Proceedings, </booktitle> <pages> pp. 227-241, </pages> <address> Orlando, FL, </address> <month> October, </month> <year> 1987. </year> <note> Published as SIGPLAN Notices 22(12), </note> <month> December, </month> <year> 1987. </year> <title> [Wik87] ke Wikstrm. Functional Programming Using Standard ML. </title> <publisher> Prentice-Hall, </publisher> <address> London, </address> <year> 1987. </year>
Reference-contexts: Abstraction boundaries are great for people to help organize their programs, but serve little purpose for the implementation. 2.2 Object-Oriented Programming 2.2.1 Benefits to Programmers Object-oriented programming languages improve abstract data types by provide objects or classes instead <ref> [Weg87] </ref>.
Reference: [WM89] <author> Paul R. Wilson and Thomas G. Moher. </author> <title> Design of the Opportunistic Garbage Collector. </title> <booktitle> In OOPSLA 89 Conference Proceedings, </booktitle> <pages> pp. 23-35, </pages> <address> New Orleans, LA, </address> <month> October, </month> <year> 1989. </year> <note> Published as SIGPLAN Notices 24(10), </note> <month> October, </month> <year> 1989. </year>
Reference-contexts: The current SELF implementation uses a card marking scheme similar to that used by some other systems <ref> [WM89] </ref>. * Each card corresponds to a region of a SELF memory space (currently 128 bytes long), and records whether any of the words in the corresponding region contain pointers to new space.
Reference: [WH81] <author> Patrick Henry Winston and Berthold Klaus Paul Horn. </author> <title> LISP. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1981. </year>
Reference-contexts: Traditional programming languages such as C [KR78] and Pascal [JW85] include record and array data type declarations; Lisp <ref> [WH81, Ste84] </ref>, Prolog [SS86], and many functional programming languages [MTH90, Wik87, Pey87] include cons cells. These type declarations build concrete data types. Manipulating concrete data structures is simply a matter of extracting fields from records or cons cells and indexing into arrays.
Reference: [Wir71] <author> Niklaus Wirth. </author> <title> Program Development by Stepwise Refinement. </title> <booktitle> In Communications of the ACM 14(4), </booktitle> <pages> pp. 221-227, </pages> <month> April, </month> <year> 1971. </year>
Reference-contexts: When using abstract data types, the task of programming an application tends to revolve around identifying, designing, and implementing abstract data types. For many applications, this orientation is better than the more traditional orientation of top-down refinement of procedures and functions <ref> [Wir71] </ref>. In addition, libraries of common abstract data types are developed that may be reused in future applications, reducing development and maintenance costs. 2.1.2 Implementation Effects Widespread use of abstract data types greatly increases the frequency of procedure calls over traditional programming styles using concrete data types.
Reference: [Zel84] <author> Polle T. Zellweger. </author> <title> Interactive Source-Level Debugging of Optimized Programs. </title> <type> Ph.D. dissertation, </type> <institution> Computer Science Department, University of California, Berkeley, </institution> <year> 1984. </year> <note> Also published as Xerox PARC Technical Report CSL-84-5, </note> <month> May, </month> <year> 1984. </year>
Reference-contexts: These features are fairly easy to support in an interpretive environment but are much more difficult to achieve in a high-performance optimizing compiler environment, particularly one based on aggressive inlining. Other researchers have investigated the problem of enabling compilation and optimization to coexist gracefully with the programming environment <ref> [Hen82, Zel84, CMR88, ZJ91] </ref>. This chapter describes the techniques used in the SELF implementation to support the programming environment, focusing on the support provided by the compiler. A compiled method contains more than just instructions.
Reference: [ZJ91] <author> Lawrence W. Zurawski and Ralph E. Johnson. </author> <title> Debugging Optimized Code with Expected Behavior. </title> <type> Unpublished manuscript, </type> <year> 1991. </year>
Reference-contexts: These features are fairly easy to support in an interpretive environment but are much more difficult to achieve in a high-performance optimizing compiler environment, particularly one based on aggressive inlining. Other researchers have investigated the problem of enabling compilation and optimization to coexist gracefully with the programming environment <ref> [Hen82, Zel84, CMR88, ZJ91] </ref>. This chapter describes the techniques used in the SELF implementation to support the programming environment, focusing on the support provided by the compiler. A compiled method contains more than just instructions.
References-found: 113

