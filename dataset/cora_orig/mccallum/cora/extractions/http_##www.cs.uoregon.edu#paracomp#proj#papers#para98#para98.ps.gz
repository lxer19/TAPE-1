URL: http://www.cs.uoregon.edu/paracomp/proj/papers/para98/para98.ps.gz
Refering-URL: http://www.cs.uoregon.edu/paracomp/proj/tau/papers.html
Root-URL: http://www.cs.uoregon.edu
Email: hacksg@cs.uoregon.edu  
Title: Dynamic Performance Callstack Sampling: Merging TAU and DAQV  
Author: Sameer Shende, Allen D. Malony, and Steven T. Hackstadt fsameer, malony, 
Address: OR 97403  
Affiliation: Computational Science Institute, Department of Computer and Information Science, University of Oregon, Eugene  
Abstract: Observing the performance of an application at runtime requires economy in what performance data is measured and accessed, and flexibility in changing the focus of performance interest. This paper describes the performance callstack as an efficient performance view of a running program which can be retrieved and controlled by external analysis tools. The performance measurement support is provided by the TAU profiling library whereas tool-program interaction support is available through the DAQV framework. How these systems are merged to provide dynamic performance callstack sampling is discussed.
Abstract-found: 1
Intro-found: 1
Reference: 1. <institution> Advanced Computing Laboratory (LANL): TAU Portable Profiling URL:http://www.acl.lanl.gov/tau. </institution> <year> (1998) </year>
Reference-contexts: In this paper, we describe the dynamic performance callstack tool that we are developing as part of the TAU profiling package <ref> [1] </ref> for parallel, multi-threaded C++ programs. We also discuss how the performance callstack information is made available to analysis and visualization tools running in the program's computational environment.
Reference: 2. <author> Foster, I., Kesselman, C., Tuecke, S.: </author> <title> The Nexus Approach to Integrating Multi-threading and Communication. </title> <journal> Jour. of Parallel and Distributed Computing. </journal> <volume> Vol. 37 (1). </volume> <month> Aug </month> <year> (1996) </year> <month> 70-82 </month>
Reference-contexts: The reason for embodying this functionality in the form of a thread is so that querying the information and accessing the data can be done concurrently with the execution of the application processes, if desired. DAQV-II uses the threading system provided by the Nexus multithreaded communication library <ref> [2] </ref> to create and manage these slave threads. The individual slave threads are coordinated by a separate process called the DAQV master.
Reference: 3. <author> Gannon, D., Beckman, P., Johnson, E., Green, T., Levine, M.: </author> <title> HPC++ and the HPC++LIB Toolkit. </title> <institution> Technical Report Department of Computer Science, Indiana University (1998) </institution>
Reference-contexts: Other data includes the number of times each function was called, the number of profiled functions each function invoked, and the mean inclusive time per call. Time information can also be displayed relative to nodes, contexts, and threads <ref> [3] </ref>. All of this analysis is also available to the user of the performance callstack view. 4 Runtime Access to Performance Callstack View The performance callstack information provides a snapshot on a program's performance during execution.
Reference: 4. <author> High Performance Debugging Forum: </author> <title> HPD Version 1 Standard: Command Interface for Parallel Debuggers. High Performance Debugging Forum and Oregon State University (1997) </title>
Reference-contexts: This is done using the DAQV-II tool interaction framework [5]. 2 Performance Callstacks A callstack at a point in execution shows the current execution location (s) and the sequence of procedure calls that led to it <ref> [4] </ref>. A performance callstack is a view on a program's performance execution profile at runtime. The execution profile shows where time is being spent in a program's code (mainly with respect to routines) for each thread of execution.
Reference: 5. <author> Hackstadt, S., Harrop, C., Malony, A.: </author> <title> A Framework for Interacting with Distributed Programs and Data. </title> <booktitle> In: Proc. of the Seventh Int'l Symp. on High Performance Distributed Computing 1998 (HPDC-7). IEEE, </booktitle> <month> July </month> <year> (1998) </year>
Reference-contexts: We also discuss how the performance callstack information is made available to analysis and visualization tools running in the program's computational environment. This is done using the DAQV-II tool interaction framework <ref> [5] </ref>. 2 Performance Callstacks A callstack at a point in execution shows the current execution location (s) and the sequence of procedure calls that led to it [4]. A performance callstack is a view on a program's performance execution profile at runtime. <p> We decided to use the DAQV framework to implement the interfaces and glue for runtime access to performance callstack views. The DAQV system is described below followed by its integration with TAU and use for callstack access. 5 The DAQV Program Interaction Framework The DAQV-II <ref> [5] </ref> framework for program interoperability provides external tools with a view of distributed data as a logical global array that can be accessed selectively via a high-level array reference; see Figure 1. Fig. 1.
Reference: 6. <author> Hackstadt, S., Malony, A.: DAQV: </author> <title> Distributed Array Query and Visualization Framework. </title> <journal> Journal of Theoretical Computer Science, special issue on Parallel Computing Vol. </journal> <volume> 196, No. </volume> <pages> 1-2, </pages> <month> April </month> <year> (1998) </year> <month> 289-317 </month>
Reference-contexts: Excessive synchronization is likely to deteriotate application performance. In addition, monitoring performance data in an application with multiple threads/processes forces clients to manage interaction with, and data from, multiple servers. This makes client implementation unnecessarily complex. Another option exists in our first implementation of the DAQV system <ref> [6] </ref>. Our primary objective was to simplify tool interaction with parallel applications by removing the need to interact with each process individually.
Reference: 7. <author> Malony, A. D., Hackstadt, S.: </author> <title> Performance of a System for Interacting with Parallel Applications. </title> <booktitle> International Jornal of Parallel and Distributed Systems and Networks. </booktitle> <year> (1998) </year>
Reference-contexts: The client interface runs as a separate thread in the tool process and is responsible for communicating requests to and receiving events from the master, and participating in data communication. A detailed description of the operation of array access can be found in <ref> [7] </ref>. DAQV-II was originally designed to allow external tools to access distributed application data. For example, a visualization tool could use DAQV-II to access arbitrary subsections of the global array created by each of the declared program array instances in the multiple processes of a parallel program.
Reference: 8. <author> Miller, B., Callaghan, M., Cargille, J., Hollingsworth, J., Irvin, R., Karavanic, K., Kunchithapadam K., Newhall T.: </author> <title> The Paradyne Parallel Performance Measurement Tools. </title> <journal> IEEE Computer Vol. </journal> <volume> 28, No. 11, </volume> <month> November </month> <year> (1995) </year>
Reference-contexts: 1 Introduction The are several motivations for wanting to observe the performance of a parallel application during its execution <ref> [8] </ref> (e.g., to terminate a long running job or to steer performance variables). The downside in doing so is the deleterious effect on performance that may result.
Reference: 9. <author> Mohr, B., Malony, A., Cuny, J.: </author> <title> TAU. </title> <editor> In: Wilson, G., Lu, P. (Eds.): </editor> <title> Parallel Programming using C++. </title> <publisher> M.I.T. Press (1996) </publisher>
Reference-contexts: One common approach to making performance data available to tools is to save it in a trace file for post-execution analysis <ref> [9, 11] </ref>. Because multiple nodes of an application produce callstack data, multiple trace files are needed and must be merged to give a complete, time-consistent view of the application's performance.
Reference: 10. <editor> Reynders, J. et. al.: Pooma: </editor> <title> A Framework for Scientific Simulation on Parallel Architectures. </title> <editor> In: Wilson, G., Lu, P. (Eds.): </editor> <title> Parallel Programming using C++. </title> <publisher> M.I.T. </publisher> <month> Press </month> <year> (1996) </year> <month> 553-594 </month>
Reference-contexts: Fig. 4. Callstack on node 0 of a POOMA 2D Diffusion equation simulation which tracks the progression of the diffusion of a heat source on a mesh with respect to time. It was implemented using the POOMA <ref> [10] </ref> object oriented scientific computing framework. 7 Conclusions The merging of the TAU and DAQV-II systems described above has been implemented for performance callstack sampling. Callstack analysis and visualization tools have also been constructed.
Reference: 11. <author> Shende, S., Cuny, J., Hansen, L., Kundu, J., McLaughry, S., Wolf, O.: </author> <title> Event and State-based Debugging in TAU: A Prototype. </title> <booktitle> Proc. SIGMETRICS Symp. on Parallel and Distributed Tools. ACM May (1996) </booktitle>
Reference-contexts: One common approach to making performance data available to tools is to save it in a trace file for post-execution analysis <ref> [9, 11] </ref>. Because multiple nodes of an application produce callstack data, multiple trace files are needed and must be merged to give a complete, time-consistent view of the application's performance.
Reference: 12. <author> Shende, S., Malony, A. D., Cuny, J., Lindlan, K., Beckman, P., Karmesin, S.: </author> <title> Portable Profiling and Tracing for Parallel, Scientific Applications using C++. </title> <booktitle> Proc. 2nd SIGMETRICS Symp. on Parallel and Distributed Tools. ACM Aug (1998) </booktitle>
Reference-contexts: Table 1. Callstack statistics for the example Routine on Calls Subrs Excl Incl Instance Excl Instance Incl Callstack (usec) (usec) (usec) (usec) main () 1 2 5 25 5 25 bar () 1 1 5 10 5 10 3 TAU Portable Profiling Library The TAU portable profiling library <ref> [12] </ref> is used to build the performance call-stack view. The library features the ability to capture performance data for C++ function, method, basic block, and statement execution, as well as template in-stantiation. It also supports the definition of profiling groups for organizing and controlling instrumentation.
References-found: 12

