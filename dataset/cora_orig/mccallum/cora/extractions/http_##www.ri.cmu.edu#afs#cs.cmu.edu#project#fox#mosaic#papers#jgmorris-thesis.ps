URL: http://www.ri.cmu.edu/afs/cs.cmu.edu/project/fox/mosaic/papers/jgmorris-thesis.ps
Refering-URL: http://www.ri.cmu.edu/afs/cs.cmu.edu/project/fox/mosaic/papers.html
Root-URL: 
Title: Compiling with Types  
Author: Greg Morrisett Jeannette Wing, Co-Chair Peter Lee Andrew Appel, 
Degree: Submitted in partial fulfillment of the requirements for the degree of Doctor of Philosophy. Thesis Committee: Robert Harper, Co-Chair  
Note: Princeton University Copyright c fl1995 Greg Morrisett  
Address: Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Date: December, 1995  
Pubnum: CMU-CS-95-226  
Abstract: This research was sponsored in part by the Defense Advanced Research Projects Agency, CSTO, under the title "The Fox Project: Advanced Development of Systems Software", ARPA Order No. 8313, issued by ESD/AVS under Contract No. F19628-91-C-0168. Support also was sponsored by the Wright Laboratory, Aeronautical Systems Center, Air Force Materiel Command, USAF, and the Advanced Research Projects Agency ([ARPA]) under grant F33615-93-1-1330. The US Government is authorized to reproduce and distribute reprints for Government purposes, notwithstanding any copyright notation thereon. Views and conclusions contained in this document are those of the author and should not be interpreted as representing the official policies, either expressed or implied, of Wright Laboratory or the United States Government. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi, L. Cardelli, P.-L. Curien, and J.-J.Levy. </author> <title> Explicit substitutions. </title> <booktitle> In Sixteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 31-46, </pages> <address> San Francisco, </address> <month> Jan. </month> <year> 1990. </year>
Reference-contexts: CHAPTER 2. A SOURCE LANGUAGE: MINI-ML 30 E [eq (i 1 ; i 2 )] 7! E <ref> [1] </ref> (i 1 = int i 2 ) E [eq (f 1 ; f 2 )] 7! E [1] (f 1 = float f 2 ) E [eq (f 1 ; f 2 )] 7! E [0] (f 1 6= float f 2 ) E [eq (hv 1 ; v 2 <p> CHAPTER 2. A SOURCE LANGUAGE: MINI-ML 30 E [eq (i 1 ; i 2 )] 7! E <ref> [1] </ref> (i 1 = int i 2 ) E [eq (f 1 ; f 2 )] 7! E [1] (f 1 = float f 2 ) E [eq (f 1 ; f 2 )] 7! E [0] (f 1 6= float f 2 ) E [eq (hv 1 ; v 2 i; hv 0 2 i)] 7! E [if0 eq (v 1 ; v 0 1 ) then 0 <p> Furthermore, the following lemma shows that onearg is a left-inverse of vararg. This gives an optimizer the opportunity to replace onearg <ref> [ 1 ] </ref>[ 2 ] (vararg [ 1 ][ 2 ] v) with simply v even when the argument type of the function v is unknown. Henglein and Jorgensen suggest a similar approach to eliminate excessive Leroy-style coercions [65]. CHAPTER 5. <p> Furthermore, the following lemma shows that onearg is a left-inverse of vararg. This gives an optimizer the opportunity to replace onearg <ref> [ 1 ] </ref>[ 2 ] (vararg [ 1 ][ 2 ] v) with simply v even when the argument type of the function v is unknown. Henglein and Jorgensen suggest a similar approach to eliminate excessive Leroy-style coercions [65]. CHAPTER 5. <p> [jt 0 j][jt j] v 0 ) (v 0 1 ) 8t 1 ; 1 ; ; t n ; n :t 1 1 ; ; t n n implies v [t 1 ; ; t n ] ~ ft 1 =t 1 ;;t n =t n gt v 0 <ref> [ 1 ] </ref> [ n ] i -Rep and ffi 0 maps type variables to closed, ML i -Rep constructors as follows: Dom (ffi) = Dom (ffi 0 ) = Dom () ffi ffi 0 The term relation is extended to pairs of substitutions, ffi; fl and ffi 0 ; fl <p> Substitution is expensive because it requires traversing and copying a term in order to find and replace all occurrences of the given variable. A well-known technique for mitigating these costs is to delay substitution until the binding of the variable is required during evaluation <ref> [80, 2, 1] </ref>. This is accomplished by pairing an open term with an environment that provides values for the free variables in the term. The open term may be thought of as immutable code that acts on the environment. <p> ] fl 1 :: 1 ; l 2 :: 2 g; Q t ), T 1 = (Q f ] fl 2 =q 2 g; s ]fl 2 :: 2 g [ 1 ; Q t ]fl 2 =q 2 g) where 1 = fl 0 :: 0 2 KL <ref> [ 1 ] </ref>(q 1 ) j l 0 62 Dom (Q t )] fl 1 gg, and T 2 = (Q f ] fl 1 =q 1 g; s ] fl 1 :: 1 g [ 2 ; Q t ] fl 2 =q 2 g) where 2 = fl 0
Reference: [2] <author> M. Abadi, L. Cardelli, P.-L. Curien, and J.-J.Levy. </author> <title> Explicit substitutions. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(4) </volume> <pages> 375-416, </pages> <month> Oct. </month> <year> 1991. </year>
Reference-contexts: 2 ; arrow ) j Typerec C 1 of ( int ; C 2 ) j Typerec of (C 1 ; C 2 ) j C [D] where I use C [D] to denote the two-holed constructor formed by replacing the hole in C with D and I use D <ref> [ 1 ; 2 ] </ref> to denote the constructor obtained by replacing the left-most hole in D with 1 and the right-most hole in D with 2 . <p> ; t 2 )][t] = x:T (Struct (Append [Cons (t 1 ; t 2 )][t])): proj2 [t 2 ][t](tail x) The crucial step in showing that the term translations of projections respect the type translation, is showing that Append [Cons ( 1 ; 2 )][] Cons ( 1 ; Append <ref> [ 2 ] </ref>[]); which follows directly from the definition of Append. This allows us to argue that the inductive cases are well-formed. One advantage of explicitly flattening structs in the target language is that we can export a type-safe form of casting to the source level. <p> For example, we can modify Append to insert padding (a pointer to an empty struct) between non-Float components: Append 0 [Nil ][] = Append 0 [Cons (Float; 2 )][] = Cons (Float; Append 0 <ref> [ 2 ] </ref>[]) Append 0 [Cons (t 1 ; t 2 )][] = Cons (t 1 ; Cons (Struct (Nil ); Append 0 [ 2 ][])) Alternatively, we might split the float and non-float components of a struct to avoid padding altogether. <p> insert padding (a pointer to an empty struct) between non-Float components: Append 0 [Nil ][] = Append 0 [Cons (Float; 2 )][] = Cons (Float; Append 0 <ref> [ 2 ] </ref>[]) Append 0 [Cons (t 1 ; t 2 )][] = Cons (t 1 ; Cons (Struct (Nil ); Append 0 [ 2 ][])) Alternatively, we might split the float and non-float components of a struct to avoid padding altogether. <p> Substitution is expensive because it requires traversing and copying a term in order to find and replace all occurrences of the given variable. A well-known technique for mitigating these costs is to delay substitution until the binding of the variable is required during evaluation <ref> [80, 2, 1] </ref>. This is accomplished by pairing an open term with an environment that provides values for the free variables in the term. The open term may be thought of as immutable code that acts on the environment. <p> j l 0 62 Dom (Q t )] fl 1 gg, and T 2 = (Q f ] fl 1 =q 1 g; s ] fl 1 :: 1 g [ 2 ; Q t ] fl 2 =q 2 g) where 2 = fl 0 :: 0 2 KL <ref> [ 2 ] </ref>(q 2 ) j l 0 62 Dom (Q t ) ] fl 2 gg.
Reference: [3] <author> M. Abadi, L. Cardelli, B. Pierce, and G. Plotkin. </author> <title> Dynamic typing in a statically-typed language. </title> <booktitle> In Sixteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 213-227, </pages> <address> San Francisco, </address> <month> Jan. </month> <year> 1990. </year>
Reference: [4] <author> M. Abadi, L. Cardelli, B. Pierce, and G. Plotkin. </author> <title> Dynamic typing in a statically-typed language. </title> <journal> ACM Transactions on Progamming Languages and Systems, </journal> <volume> 13(2) </volume> <pages> 237-268, </pages> <month> Apr. </month> <year> 1991. </year> <note> Revised version of [3]. </note>
Reference-contexts: However, type checking for the language is in general undecidable and type errors can occur at run time. Furthermore, like the approaches to type classes, there is no facility for transforming types. Marshalling in languages with abstract or polymorphic types has been the subject of much research <ref> [85, 86, 84, 66, 27, 4, 100, 77] </ref>. The solution I propose does not easily extend to user-defined abstract types (as with Herlihy and Liskov [66]).
Reference: [5] <author> S. Aditya and A. Caro. </author> <title> Compiler-directed type reconstruction for polymorphic languages. </title> <booktitle> In ACM Conference on Functional Programming and Computer Architecture, </booktitle> <pages> pages 74-82, </pages> <address> Copenhagen, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Type passing was also used by Aditya and Caro in an implementation of Id, so that instantiations of polymorphic types could be reconstructed for debugging purposes <ref> [5] </ref>. Jones [72, 71] has proposed a general framework for passing data derived from types to "qualified" polymorphic operations, called evidence passing. He shows how evidence passing can be used to implement Haskell-style type classes, generalizing the earlier work of Wadler and Blott [122]. <p> Tolmach [119] built a type-recovery collector for a variant of SML that passes type information to polymorphic routines during execution. Aditya and Caro gave a type-recovery algorithm for an implementation of Id that is equivalent to type passing <ref> [5] </ref> and Aditya, Flood, and Hicks extended this work to garbage collection for Id [6]. In both collectors, bindings for type variables are accumulated in type environments as I propose here. However, the type systems of these languages are considerably simpler that ML i .
Reference: [6] <author> S. Aditya, C. Flood, and J. Hicks. </author> <title> Garbage collection for strongly-typed languages using run-time type reconstruction. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 12-23, </pages> <address> Orlando, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: When allocating a register for a variable of type double, a C compiler will use a floating point register instead of a general purpose register. Some implementations take advantage of types to support tag-free garbage collection <ref> [23, 119, 6] </ref> and so-called "conservative" garbage collection [21]. Types are also used to support debugging, printing and parsing, marshaling, and other means of traversing a data structure. In addition to directing implementation, types are useful for proving formal properties of programs. <p> Hence, tag-free garbage collection is another mechanism that can use dynamic type dispatch to account for variable types. As for monomorphic languages, this approach to tag-free garbage collection for polymorphic languages is not new <ref> [119, 6, 96, 95] </ref>, but my formulation is sufficiently abstract that we can easily prove its correctness. Tag-free garbage collection is important for two very practical reasons: first, a clever tag-free implementation can avoid manipulating any type information in monomorphic code at run time, except during garbage collection. <p> Aditya and Caro gave a type-recovery algorithm for an implementation of Id that is equivalent to type passing [5] and Aditya, Flood, and Hicks extended this work to garbage collection for Id <ref> [6] </ref>. In both collectors, bindings for type variables are accumulated in type environments as I propose here. However, the type systems of these languages are considerably simpler that ML i . In particular, they only support instantiation of polytypes and not general forms of computation (e.g., function call and Typerec).
Reference: [7] <author> A. Aiken, E. L. Wimmers, and T. Lakshman. </author> <title> Soft typing with conditional types. </title> <booktitle> In Twenty-First ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 163-173, </pages> <address> Portland, </address> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: None of these approaches supports unboxed mutable data, or generally unboxed datatypes. Furthermore, they do not address type classes, marshaling, or garbage collection. Of a broadly similar nature is the work on "soft" type systems <ref> [64, 7, 29, 132] </ref>. Here, ML-style type inference or set constraints are used to eliminate type-tag checks in dynamically typed languages such as Scheme. Morrison, et al. [97] described an implementation of Napier that passed types at run time to determine the behavior of polymorphic operations. <p> For example, the conventional argument flattener of TIL fails to flatten many functions that the type-directed flattener does flatten. Even without programmer-supplied type information, the advances in soft typing <ref> [64, 7, 29, 132] </ref> provide a means for compiler writers to take advantage of types. In general, compilers and other kinds of system software have real issues and problems that can serve as the clients and driving force behind the development of advanced type systems.
Reference: [8] <author> A. W. Appel. </author> <title> Runtime tags aren't necessary. </title> <journal> LISP and Symbolic Computation, </journal> <volume> 2 </volume> <pages> 153-162, </pages> <year> 1989. </year>
Reference-contexts: TIL also performs various optimizations to share as many type computations as is possible. These and other "real-world" implementation issues are discussed in Chapter 8. Over the past few years, a number of papers on inference-based collection in monomor-phic [22, 129, 23] and polymorphic <ref> [8, 49, 50, 43] </ref> languages appeared in the literature. <p> These and other "real-world" implementation issues are discussed in Chapter 8. Over the past few years, a number of papers on inference-based collection in monomor-phic [22, 129, 23] and polymorphic [8, 49, 50, 43] languages appeared in the literature. Appel <ref> [8] </ref> argued informally that "tag-free" collection is possible for polymorphic languages such as SML by a combination of recording information statically and performing what amounts to type inference during the collection process, though the connections between inference and collection were not made clear. <p> Otherwise, we simply forward the representation information to the next stack frame, and so on. This approach to reconstructing type information is similar to the approach suggested by Appel <ref> [8] </ref> and Goldberg and Gloger [49, 50]. Once we determine which registers and which stack slots must be traced, we perform a standard copying garbage collection on the resulting roots.
Reference: [9] <author> A. W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: of unknown type to some routine, then the value must be boxed (i.e., represented as a pointer.) Because it is impossible to tell whether or not a value will be passed to a polymorphic function, most ML compilers, including Poly/ML [88], Bigloo [107], Caml [126], and older versions of SML/NJ <ref> [9] </ref>, box all objects. Boxing supports separate compilation and dynamic linking, but unfortunately, it consumes space and time because of the extra indirection that is introduced. <p> The open term may be thought of as immutable code that acts on the environment. Since the code is immutable, it can be generated once and shared among all instances of a function. Closure conversion <ref> [105, 111, 33, 78, 76, 9, 124, 54] </ref> is a program transformation that achieves such a separation between code and data. Functions with free variables are replaced by code abstracting an extra environment parameter. Free variables in the body of the function are replaced by references to the environment. <p> TYPED CLOSURE CONVERSION 121 6.5 Related Work Closure conversion is discussed in descriptions of various functional language compilers <ref> [111, 78, 11, 9, 109] </ref>. It is closely related to -lifting [69] in that it eliminates free variables in the bodies of -abstractions. However, closure conversion differs by making the representation of the environment explicit as a data structure. <p> In particular, the language forbids nested expressions and requires that all values and computations be bound to variables. These restrictions simplify the presentation of the semantics, but they provide many of the practical benefits of CPS <ref> [9] </ref>. The syntax of Mono-GC is defined in Figure 7.1. Types are monomorphic and include base types, products, code, and arrow types. To simplify the language, I only consider functions of one argument. <p> The entire optimization process is then iterated for some adjustable number of times (currently three). 8.7 Closure Conversion The closure conversion phase of TIL is based on the formal treatment of closure conversion given in Chapter 6, but following Kranz [78] and Appel <ref> [9] </ref>, I extended the translation to avoid creating closures and environments unless functions "escape". A function escapes if it is placed in a data structure, passed as an argument to another function, or is returned as the result of a function. <p> Table 8.1 describes these programs. The benchmarks cover a range of application areas including scientific computing, list processing, systems programming, and compilers. Some of these programs have been used previously for measuring ML performance <ref> [9, 36] </ref>. Others were adapted from the Caml-Light distribution [24]. For this set of comparisons, I compiled all of the programs as single closed modules. For lexgen and simple, which are standard benchmarks [9], I eliminated functors by hand, since TIL does not yet support functors. <p> Some of these programs have been used previously for measuring ML performance [9, 36]. Others were adapted from the Caml-Light distribution [24]. For this set of comparisons, I compiled all of the programs as single closed modules. For lexgen and simple, which are standard benchmarks <ref> [9] </ref>, I eliminated functors by hand, since TIL does not yet support functors. For TIL, I compiled programs with all optimizations enabled. For SML/NJ, I compiled programs using the default optimization settings.
Reference: [10] <author> A. W. Appel. </author> <title> A critique of Standard ML. </title> <journal> Journal of Functional Programming, </journal> <volume> 3(4) </volume> <pages> 391-429, </pages> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: In SML/NJ, cons cells are flattened but SOME cells are not, precisely because the compiler cannot determine at compile time whether it can safely flatten option datatypes. Even to support flattened cons cells, SML/NJ restricts the programmer from writing certain legal SML programs <ref> [10] </ref>.
Reference: [11] <author> A. W. Appel and T. Jim. </author> <title> Continuation-passing, closure-passing style. </title> <booktitle> In Sixteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 293-302, </pages> <address> Austin, </address> <month> Jan. </month> <year> 1989. </year> <note> 217 BIBLIOGRAPHY 218 </note>
Reference-contexts: TYPED CLOSURE CONVERSION 121 6.5 Related Work Closure conversion is discussed in descriptions of various functional language compilers <ref> [111, 78, 11, 9, 109] </ref>. It is closely related to -lifting [69] in that it eliminates free variables in the bodies of -abstractions. However, closure conversion differs by making the representation of the environment explicit as a data structure.
Reference: [12] <author> A. W. Appel and D. B. MacQueen. </author> <title> Standard ML of New Jersey. </title> <editor> In M. Wirsing, editor, </editor> <booktitle> Third International Symposium on Programming Language Implementation and Logic Programming, </booktitle> <pages> pages 1-13, </pages> <address> New York, </address> <month> Aug. </month> <year> 1991. </year> <title> Springer-Verlag. </title> <booktitle> Volume 528 of Lecture Notes in Computer Science. </booktitle>
Reference-contexts: These optimizations account for much of the good performance of TIL, in spite of the fact that they operate on statically-typed intermediate languages. Indeed, TIL produces code that is roughly twice as fast as code produced by the SML/NJ compiler <ref> [12] </ref>, which is one of the best existing compilers for Standard ML. The rest of this chapter serves as an overview of the thesis. In Section 1.1, I give an overview of type-directed translation. <p> Currently, we use a simple two-generation collector. 8.10 Performance Analysis of TIL In this section, I compare the performance of code produced by TIL against code produced by the SML/NJ compiler <ref> [12] </ref>. I also examine other aspects, including heap allocation, physical memory requirements, executable size, and compile time.
Reference: [13] <author> A. W. Appel, J. S. Mattson, and D. Tarditi. </author> <title> A lexical analyzer generator for Standard ML. Distributed with Standard ML of New Jersey, </title> <year> 1989. </year>
Reference-contexts: The balanced binary trees are taken from the SML/NJ library. fft 246 Fast-Fourier transform. fmult 63 Matrix multiply of two 100x100 floating point matrices. imult 63 Matrix multiply of two 200x200 integer matrices. kb 618 The Knuth-Bendix completion algorithm. lexgen 1123 A lexical-analyzer generator <ref> [13] </ref>, processing the lexical descrip tion of SML/NJ. life 146 A simulation of cells implemented using lists [103]. logic 459 A simple Prolog-like interpreter, with unification and backtrack ing. msort 45 List merge sort of 5,120 integers, 40 times. pia 2065 A Perspective Inversion Algorithm [125] deciding the location of an
Reference: [14] <author> H. Baker. </author> <title> Unify and conquer (garbage, updating, aliasing ...) in functional languages. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 218-226, </pages> <address> Nice, </address> <year> 1990. </year>
Reference-contexts: Appel [8] argued informally that "tag-free" collection is possible for polymorphic languages such as SML by a combination of recording information statically and performing what amounts to type inference during the collection process, though the connections between inference and collection were not made clear. Baker <ref> [14] </ref> recognized that Milner-style type inference can be used to prove that reachable objects can be safely collected, but did not give a formal account of this result.
Reference: [15] <author> H. P. Barendregt. </author> <title> The Lambda Calculus: Its Syntax and Semantics, </title> <booktitle> volume 103 of Studies in Logic and the Foundations of Mathematics. </booktitle> <publisher> North-Holland, </publisher> <address> revised edition, </address> <year> 1984. </year>
Reference-contexts: I use def instead of let because I reserve let as an abbreviation. In particular, I use let x:t = e 1 in e 2 as an abbreviation for (x:t: e 2 ) e 1 . Following conventional formulations of -calculus based languages <ref> [15] </ref>, I consider the variable x in x:t: e to be bound within the body of the function e.
Reference: [16] <author> E. Barendsen and S. Smetsers. </author> <title> Conventional and uniqueness typing in graph rewrite systems. </title> <booktitle> In Proceedings of the 13th Conference on the Foundations of Software Technology and Theoretical Computer Science 1993, </booktitle> <address> Bombay, New York, </address> <year> 1993. </year> <note> Springer-Verlag. Extended abstract. </note>
Reference-contexts: Both Hudak and Chirimar et al. assume a weak approximation of garbage (reference counts). Barendsen and Smetsers give a Curry-like type system for CHAPTER 7. TYPES AND GARBAGE COLLECTION 159 functional languages extended with uniqueness information that guarantees an object is only "locally accessible" <ref> [16] </ref>. This provides a compiler enough information to determine when certain objects may be garbage collected or over-written. Tolmach [119] built a type-recovery collector for a variant of SML that passes type information to polymorphic routines during execution.
Reference: [17] <author> E. Biagioni. </author> <title> Sequence types for functional languages. </title> <type> Technical Report CMU-CS-95-180, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> Aug. </month> <year> 1995. </year> <note> Also published as Fox Memorandum CMU-CS-FOX-95-06. </note>
Reference-contexts: THE TIL/ML COMPILER 192 Program lines Description cksum 241 Checksum fragment from the Foxnet [18], doing 5000 checksums on a 4096-byte array, using a stream interface <ref> [17] </ref>. dict 166 Insert 10,000 strings, indexed by integers into a balanced binary tree, lookup each string and replace it with another.
Reference: [18] <author> E. Biagioni, R. Harper, P. Lee, and B. Milnes. </author> <title> Signatures for a network protocol stack: A systems application of Standard ML. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 55-64, </pages> <address> Orlando, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: THE TIL/ML COMPILER 192 Program lines Description cksum 241 Checksum fragment from the Foxnet <ref> [18] </ref>, doing 5000 checksums on a 4096-byte array, using a stream interface [17]. dict 166 Insert 10,000 strings, indexed by integers into a balanced binary tree, lookup each string and replace it with another.
Reference: [19] <author> L. Birkedal, N. Rothwell, M. Tofte, and D. N. Turner. </author> <title> The ML Kit, </title> <type> Version 1. Technical Report 93/14, </type> <institution> Department of Computer Science (DIKU), University of Copenhagen, </institution> <year> 1993. </year>
Reference-contexts: We were careful to use standard Unix tools, such as ld so that we could take advantage of profilers, debuggers, and other widely used tools. Also, to avoid constructing a parser, type-checker, and pattern match compiler, we decided to use the front end of the ML Kit Compiler <ref> [19] </ref>. Finally, we wanted TIL to be as interoperable with other languages (notably C, C++, and Fortran) as possible, without compromising the efficiency of conventional SML code. <p> The first phase of TIL uses the front end of the ML Kit compiler <ref> [19] </ref> to parse, type check, and elaborate SML source code. The Kit produces annotated abstract syntax for the full SML language and then compiles a subset of this abstract syntax to an explicitly-typed core language called Lambda. The compilation to Lambda eliminates pattern matching and various derived forms. <p> In principle, TIL supports the rest of the Standard ML Definition, though of course there may be bugs in the implementation. CHAPTER 8. THE TIL/ML COMPILER 167 We use the ML Kit Compiler <ref> [19] </ref> to parse, type-check, and elaborate SML expressions. The Kit translates SML to annotated abstract syntax. The annotations include position information for error reporting as well as type information. Next, the annotated abstract syntax is translated to the Lambda intermediate form. <p> The Kit translates SML to annotated abstract syntax. The annotations include position information for error reporting as well as type information. Next, the annotated abstract syntax is translated to the Lambda intermediate form. This intermediate form is quite similar to the language described by Birkedal et. al. <ref> [19] </ref>, but I added support for type abbreviations, structures, and signatures. Also, we added various primitive operations to the language to support, for instance, unsigned integer operations, logical operations, and so forth. The Kit compiler translates core SML, annotated abstract syntax to Lambda declarations.
Reference: [20] <author> G. E. Blelloch. NESL: </author> <title> A nested data-parallel language (version 2.6). </title> <type> Technical Report CMU-CS-93-129, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> Apr. </month> <year> 1993. </year>
Reference-contexts: This allows us to use a standard, monomorphic compiler. The "elimination" approach has been used in various guises by implementations of C++ [114], Ada [121], NESL <ref> [20] </ref>, and Gofer [74] to support ADTs and polymorphism. * When defining a new class in C++, the definition is placed in a ".h" file. The definition is #included by any client code that wishes to use the abstraction. <p> Again, the type system of the language enforces the abstraction, but the first stage of compilation replaces the abstract type variable with the implementation representation. * NESL is a programming language for parallel computations that allows programmers to define polymorphic functions <ref> [20] </ref>. However, the NESL implementation delays compiling any polymorphic definitions. Instead, whenever a polymorphic function is instantiated with a particular type, the type is substituted for the occurrences of the type variable within the polymorphic code. The resulting monomor phic code is compiled.
Reference: [21] <author> H.-J. Boehm. </author> <title> Space-efficient conservative garbage collection. </title> <booktitle> In ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 197-206, </pages> <address> Albu-querque, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: When allocating a register for a variable of type double, a C compiler will use a floating point register instead of a general purpose register. Some implementations take advantage of types to support tag-free garbage collection [23, 119, 6] and so-called "conservative" garbage collection <ref> [21] </ref>. Types are also used to support debugging, printing and parsing, marshaling, and other means of traversing a data structure. In addition to directing implementation, types are useful for proving formal properties of programs. For instance, it is possible to prove that every term in the simply-typed -calculus terminates.
Reference: [22] <author> P. Branquart and J. Lewi. </author> <title> A scheme for storage allocation and garbage collection for Algol-68. In Algol-68 Implementation. </title> <publisher> North-Holland Publishing Company, </publisher> <address> Amsterdam, </address> <year> 1970. </year>
Reference-contexts: TIL also performs various optimizations to share as many type computations as is possible. These and other "real-world" implementation issues are discussed in Chapter 8. Over the past few years, a number of papers on inference-based collection in monomor-phic <ref> [22, 129, 23] </ref> and polymorphic [8, 49, 50, 43] languages appeared in the literature.
Reference: [23] <author> D. E. Britton. </author> <title> Heap storage management for the programming language Pascal. </title> <type> Master's thesis, </type> <institution> University of Arizona, </institution> <year> 1975. </year>
Reference-contexts: When allocating a register for a variable of type double, a C compiler will use a floating point register instead of a general purpose register. Some implementations take advantage of types to support tag-free garbage collection <ref> [23, 119, 6] </ref> and so-called "conservative" garbage collection [21]. Types are also used to support debugging, printing and parsing, marshaling, and other means of traversing a data structure. In addition to directing implementation, types are useful for proving formal properties of programs. <p> Consequently, no tags are required on the values in the heap to support garbage collection. This approach to tag-free garbage collection is not new <ref> [23] </ref>, but my formulation is at a sufficiently high level that it is easy to prove its correctness. I then show how to extend the tag-free collection algorithm to accommodate generational garbage collection. <p> TIL also performs various optimizations to share as many type computations as is possible. These and other "real-world" implementation issues are discussed in Chapter 8. Over the past few years, a number of papers on inference-based collection in monomor-phic <ref> [22, 129, 23] </ref> and polymorphic [8, 49, 50, 43] languages appeared in the literature. <p> We use the return address of call sites as an index to find the information and ensure that the return address is always saved in the first slot of a stack frame. In these respects, our collector closely resembles Britton's collector for Pascal <ref> [23] </ref> and the formal development of Chapter 7. However, our collector is complicated by two details: the first complication is that some values have unknown representation at compile time.
Reference: [24] <author> Caml light. </author> <note> http://pauillac.inria.fr:80/caml/. </note>
Reference-contexts: Table 8.1 describes these programs. The benchmarks cover a range of application areas including scientific computing, list processing, systems programming, and compilers. Some of these programs have been used previously for measuring ML performance [9, 36]. Others were adapted from the Caml-Light distribution <ref> [24] </ref>. For this set of comparisons, I compiled all of the programs as single closed modules. For lexgen and simple, which are standard benchmarks [9], I eliminated functors by hand, since TIL does not yet support functors. For TIL, I compiled programs with all optimizations enabled.
Reference: [25] <author> L. Cardelli. </author> <title> Phase distinctions in type theory. </title> <type> Unpublished manuscript. BIBLIOGRAPHY 219 </type>
Reference-contexts: The Typerec and typerec forms may be thought of as eliminatory forms for the kind at the constructor and term level respectively. The introductory forms are the constructors of kind ; there are no introductory forms at the term level in order to preserve the phase distinction <ref> [25, 60] </ref>. In effect, Typerec and typerec let us fold some computation over a monotype. Limiting the computation to a fold, instead of some general recursion, ensures that the computation terminates | a crucial property at the constructor level.
Reference: [26] <author> L. Cardelli. </author> <title> The functional abstract machine. </title> <journal> Polymorphism, </journal> <volume> 1(1), </volume> <year> 1983. </year>
Reference-contexts: Since the body of f could contain an occurrence of z, it is also sensible to include z in the environment, resulting in the following code: let val x = 1 val z = 3 in end In the above example I chose a "flat" (FAM-like <ref> [26] </ref>) representation of the environment as a record with one field for each variable. Alternatively, I could choose a "linked" (CAM-like [33]) representation where, for example, each binding is a separate "frame" attached to the front of the remaining bindings.
Reference: [27] <author> L. Cardelli. </author> <title> A language with distributed scope. </title> <journal> Computing Systems, </journal> <volume> 8(1) </volume> <pages> 27-59, </pages> <month> Jan. </month> <year> 1995. </year>
Reference-contexts: Often, it is impossible to get the source code for such libraries and it is prohibitively time-consuming to recompile them for each application, especially during development. We now have languages such as Java [51] and Obliq <ref> [27, 28] </ref> where objects and code are dynamically transmitted from one machine to another via a network, compiled to a native representation, and then dynamically linked into a running program. <p> However, type checking for the language is in general undecidable and type errors can occur at run time. Furthermore, like the approaches to type classes, there is no facility for transforming types. Marshalling in languages with abstract or polymorphic types has been the subject of much research <ref> [85, 86, 84, 66, 27, 4, 100, 77] </ref>. The solution I propose does not easily extend to user-defined abstract types (as with Herlihy and Liskov [66]).
Reference: [28] <author> L. Cardelli. </author> <title> A language with distributed scope. </title> <booktitle> In Twenty-Second ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 286-297, </pages> <address> San Francisco, </address> <month> Jan. </month> <year> 1995. </year>
Reference-contexts: Often, it is impossible to get the source code for such libraries and it is prohibitively time-consuming to recompile them for each application, especially during development. We now have languages such as Java [51] and Obliq <ref> [27, 28] </ref> where objects and code are dynamically transmitted from one machine to another via a network, compiled to a native representation, and then dynamically linked into a running program.
Reference: [29] <author> R. Cartwright and M. Fagan. </author> <title> Soft typing. </title> <booktitle> In ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 278-292, </pages> <address> Toronto, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: None of these approaches supports unboxed mutable data, or generally unboxed datatypes. Furthermore, they do not address type classes, marshaling, or garbage collection. Of a broadly similar nature is the work on "soft" type systems <ref> [64, 7, 29, 132] </ref>. Here, ML-style type inference or set constraints are used to eliminate type-tag checks in dynamically typed languages such as Scheme. Morrison, et al. [97] described an implementation of Napier that passed types at run time to determine the behavior of polymorphic operations. <p> For example, the conventional argument flattener of TIL fails to flatten many functions that the type-directed flattener does flatten. Even without programmer-supplied type information, the advances in soft typing <ref> [64, 7, 29, 132] </ref> provide a means for compiler writers to take advantage of types. In general, compilers and other kinds of system software have real issues and problems that can serve as the clients and driving force behind the development of advanced type systems.
Reference: [30] <author> J. Chirimar, C. A. Gunter, and J. G. Riecke. </author> <title> Proving memory management invariants for a language based on linear logic. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 139-150, </pages> <address> San Francisco, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: He presents an abstraction of the model and gives an algorithm for computing approximations of reference counts statically. Chirimar, Gunter, and Riecke give a framework for proving invariants regarding memory management for a language with a linear type system <ref> [30] </ref>. Their low-level semantics specifies explicit memory management based on reference counting. Both Hudak and Chirimar et al. assume a weak approximation of garbage (reference counts). Barendsen and Smetsers give a Curry-like type system for CHAPTER 7.
Reference: [31] <author> D. Clement, J. Despeyroux, T. Despeyroux, and G. Kahn. </author> <title> A simple applicative language: </title> <booktitle> Mini-ML. In ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 13-27, </pages> <year> 1986. </year>
Reference-contexts: Finally, in Chapter 9, I present a summary of the thesis, and discuss future directions. Chapter 2 A Source Language: Mini-ML In this chapter, I specify a starting source language, called Mini-ML, that is based on the core language of Standard ML <ref> [90, 31] </ref>. Although Mini-ML is a fairly limited language, it has many of the constructs that one might find in a conventional functional programming language, including integers and floating point values; first-class, lexically-scoped functions; tuples (records); and polymorphism.
Reference: [32] <author> R. L. Constable, et. al. </author> <title> Implementing Mathematics with the NuPRL Proof Development System. </title> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference-contexts: However, the notion of constructor equivalence in ML i corresponds to what Lambek and Scott term a "weak" natural number object. The idea of adding an inductively generated universe, with a term-level elimination rule such as typerec, was derived from the universe elimination rules found in NuPrl <ref> [32] </ref>, though the idea was only described in unpublished work of Robert Constable. Harper and I devised the original formulation of ML i [62, 61].
Reference: [33] <editor> C. Cousineau, P.-L. Curien, and M. Mauny. </editor> <booktitle> The categorical abstract machine. In ACM Conference on Functional Programming and Computer Architecture, volume 201 of Lecture Notes in Computer Science, </booktitle> <pages> pages 50-64, </pages> <address> Nancy, Sept. 1985. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The open term may be thought of as immutable code that acts on the environment. Since the code is immutable, it can be generated once and shared among all instances of a function. Closure conversion <ref> [105, 111, 33, 78, 76, 9, 124, 54] </ref> is a program transformation that achieves such a separation between code and data. Functions with free variables are replaced by code abstracting an extra environment parameter. Free variables in the body of the function are replaced by references to the environment. <p> Alternatively, I could choose a "linked" (CAM-like <ref> [33] </ref>) representation where, for example, each binding is a separate "frame" attached to the front of the remaining bindings.
Reference: [34] <author> A. Demers, M. Weiser, B. Hayes, H. Boehm, D. Bobrow, and S. Shenker. </author> <title> Combining generational and conservative garbage collection: Framework and implementations. </title> <booktitle> In Seventeenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 261-269, </pages> <address> San Francisco, </address> <month> Jan. </month> <year> 1990. </year>
Reference-contexts: Demers et al. <ref> [34] </ref> give a model of memory parameterized by an abstract notion of a "points-to" relation. As a result, they can characterize reachability-based algorithms including mark-sweep, copying, generational, "conservative," and other sophisticated forms of garbage collection.
Reference: [35] <author> A. Diwan, E. Moss, and R. Hudson. </author> <title> Compiler support for garbage collection in a statically typed language. </title> <booktitle> In ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 273-282, </pages> <address> San Francisco, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Fully tag-free collectors cannot use the standard breadth-first scan, because there is not always space for a forwarding pointer in a tag-free object 1 . Furthermore, we were worried that the sizes of tables that contain full type information might be excessively large <ref> [35] </ref>. Taking all of these factors into account, we felt that leaving integers and pointers untagged, but tagging heap-allocated objects, had the most virtues. We decided not to unbox double-precision floating point values except within functions and within arrays.
Reference: [36] <author> A. Diwan, D. Tarditi, and E. Moss. </author> <title> Memory-system performance of programs with intensive heap allocation. </title> <journal> Transactions on Computer Systems, </journal> <month> Aug. </month> <year> 1995. </year>
Reference-contexts: Table 8.1 describes these programs. The benchmarks cover a range of application areas including scientific computing, list processing, systems programming, and compilers. Some of these programs have been used previously for measuring ML performance <ref> [9, 36] </ref>. Others were adapted from the Caml-Light distribution [24]. For this set of comparisons, I compiled all of the programs as single closed modules. For lexgen and simple, which are standard benchmarks [9], I eliminated functors by hand, since TIL does not yet support functors.
Reference: [37] <author> C. Dubois, F. Rouaix, and P. Weis. </author> <title> Extensional polymorphism. </title> <booktitle> In Twenty-Second ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 118-129, </pages> <address> San Francisco, </address> <month> Jan. </month> <year> 1995. </year>
Reference-contexts: In one sense, these proposals do a better job of enforcing type classes, since they restrict the kinds of type variables. However, like Jones's qualified types, neither of these approaches can express transformations on types. Dubois, Rouaix, and Weis formulated an approach to polymorphism dubbed "extensional polymorphism" <ref> [37] </ref> 5 . The goal was to provide a framework to type check ad hoc operators like polymorphic equality. As with ML i , their formulation requires that some types be passed at runtime and be examined using what amounts to a structural induction elimination form.
Reference: [38] <author> D. Duggan and J. Ophel. </author> <title> Kinded parametric overloading. </title> <type> Technical Report CS-94-35, </type> <institution> University of Waterloo, Department of Computer Science, </institution> <month> September </month> <year> 1994. </year> <note> Supersedes CS-94-15 and CS-94-16, </note> <month> March </month> <year> 1994, </year> <note> and CS-93-32, August 1993. BIBLIOGRAPHY 220 </note>
Reference-contexts: Haskell generalizes this sort of restriction by qualifying bound type variables with a user-defined predicate or predicates (e.g., is eqty (ff)) 3 . Another approach, suggested by Duggan <ref> [38] </ref>, is to refine the kind of the bound type variable, much as Freeman and Pfenning suggest refinements of SML datatypes [44]. 3 See Jones [72, 71] for a general formulation of qualified types. CHAPTER 5. <p> However, qualified types represent predicates on types, whereas the type system of ML i supports computations that transform types. For example, it is not possible to express the transmissible representation or a flattened representation of a type in Jones's framework. Recently, Duggan and Ophel <ref> [38] </ref> and Thatte [116] have independently suggested semantics for type classes that are similar in spirit to my proposal. In one sense, these proposals do a better job of enforcing type classes, since they restrict the kinds of type variables. <p> From a compiler perspective, the whole purpose of dynamic type dispatch is to violate the very abstraction that a programmer establishes. There are a variety of approaches that could be taken to solve this problem. The work of Duggan and Ophel <ref> [38] </ref> and Thatte [116] on kind-based definitions of type-classes seems promising to me.
Reference: [39] <author> K. Ekanadham and Arvind. </author> <title> SIMPLE: An exercise in future scientific programming. Technical Report Computation Structures Group Memo 273, </title> <publisher> MIT, </publisher> <address> Cambridge, MA, </address> <month> July </month> <year> 1987. </year> <note> Simultaneously published as IBM/T. J. </note> <institution> Watson Research Center Research Report 12686, Yorktown Heights, NY. </institution>
Reference-contexts: of 5,120 integers, 40 times. pia 2065 A Perspective Inversion Algorithm [125] deciding the location of an object in a perspective video image. qsort 141 Integer array quicksort of 50,000 pseudo-random integers, 2 times. sieve 27 Sieve of Eratosthenes, filtering primes up to 30000. simple 870 A spherical fluid-dynamics program <ref> [39] </ref>, run for 4 iterations with grid size of 100. soli 131 A solver for a peg-board game. Table 8.1: Benchmark Programs CHAPTER 8. THE TIL/ML COMPILER 193 25% 75% 125% cksum dict fft fmult imult kb lexgen life logic msort pia qsort sieve simple soli compilation time.
Reference: [40] <author> M. Felleisen and D. P. Friedman. </author> <title> Control operators, the SECD-machine, and the lambda-calculus. </title> <booktitle> In Third Working Conference on the Formal Description of Programming Concepts, </booktitle> <pages> pages 193-219, </pages> <month> Aug. </month> <year> 1986. </year>
Reference-contexts: In particular, I use closures and environments to implement substitution. In this respect, the semantics CHAPTER 7. TYPES AND GARBAGE COLLECTION 160 is quite similar to the SECD [80] and CEK machines <ref> [40] </ref>. The primary difference between my approach and these machines is that I make the heap explicit, which enables me to define a suitable notion of garbage and garbage collection.
Reference: [41] <author> M. Felleisen and R. Hieb. </author> <title> The revised report on the syntactic theories of sequential control and state. </title> <journal> Theoretical Computer Science, </journal> <volume> 103 </volume> <pages> 235-271, </pages> <year> 1992. </year>
Reference-contexts: Likewise, I write ft =tg to denote capture-avoiding substitution of the monotype t for t within the polytype . 2.1 Dynamic Semantics of Mini-ML I describe evaluation of Mini-ML programs using a contextual rewriting semantics in the style of Felleisen and Hieb <ref> [41] </ref>. This kind of semantics describes evaluation as an abstract machine whose states are expressions and whose steps are functions, or more generally, relations between expressions. The final state of this abstract machine is a closed value.
Reference: [42] <author> C. Flanagan, A. Sabry, B. F. Duba, and M. Felleisen. </author> <title> The essence of compiling with continuations. </title> <booktitle> In ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 237-247, </pages> <address> Albuquerque, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: A much better approach is to compare types directly and normalize CHAPTER 8. THE TIL/ML COMPILER 164 CHAPTER 8. THE TIL/ML COMPILER 165 components only if they do not match. Lmli-Bform (or simply Bform) is a subset of Lmli similar to A-normal form <ref> [42] </ref>. It provides a more regular intermediate language than Lmli to facilitate optimization. Because Bform is a subset of Lmli, we can use all of the Lmli tools, including the type checker and pretty printer on the Bform representation 2 .
Reference: [43] <author> P. Fradet. </author> <title> Collecting more garbage. </title> <booktitle> In ACM Conference on Functional Programming and Computer Architecture, </booktitle> <pages> pages 24-33, </pages> <address> Orlando, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: TIL also performs various optimizations to share as many type computations as is possible. These and other "real-world" implementation issues are discussed in Chapter 8. Over the past few years, a number of papers on inference-based collection in monomor-phic [22, 129, 23] and polymorphic <ref> [8, 49, 50, 43] </ref> languages appeared in the literature. <p> They gave an informal argument based on traversal of stack frames to show that such values are semantically garbage. Fradet <ref> [43] </ref> gave another argument based on Reynolds's abstraction/parametricity theorem [104]. The style of semantics I use here is closely related to the allocation semantics used in my previous work on garbage collection [96, 95], but is slightly lower-level. In particular, I use closures and environments to implement substitution.
Reference: [44] <author> T. Freeman and F. Pfenning. </author> <title> Refinement types for ML. </title> <booktitle> In ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 268-277, </pages> <address> Toronto, </address> <month> June </month> <year> 1991. </year> <note> ACM. </note>
Reference-contexts: Haskell generalizes this sort of restriction by qualifying bound type variables with a user-defined predicate or predicates (e.g., is eqty (ff)) 3 . Another approach, suggested by Duggan [38], is to refine the kind of the bound type variable, much as Freeman and Pfenning suggest refinements of SML datatypes <ref> [44] </ref>. 3 See Jones [72, 71] for a general formulation of qualified types. CHAPTER 5. COMPILING WITH DYNAMIC TYPE DISPATCH 96 However, it is possible to encode type classes to a limited degree using Typerec. <p> The next phase of TIL maps Ubform programs to the Rtl intermediate form. Rtl, 2 The actual ML datatypes used for Lmli and Bform differ, but we provide a simple map from Bform to Lmli. If SML provided refinement types <ref> [44] </ref>, then we could have defined Bform as a refinement of Lmli and avoided this extra piece of code. CHAPTER 8. THE TIL/ML COMPILER 166 which stands for register transfer language, provides an idealized RISC instruction set, with a few heavy-weight instructions and an infinite number of registers.
Reference: [45] <author> L. George and A. W. Appel. </author> <title> Iterated register coalescing. </title> <booktitle> In Twenty-Third ACM Symposium on Principles of Programming Languages, </booktitle> <month> Jan. </month> <year> 1996. </year> <note> To appear. </note>
Reference-contexts: Most of the compile time is spent in the optimizer and the register allocator. We assume that much of the time in the register allocator can be eliminated by using an intelligent form of coalescing as suggested by George and Appel <ref> [45] </ref>. We assume that much of the time spent in the optimizer can be eliminated by simply tuning and inlining key routines.
Reference: [46] <author> J.-Y. Girard. </author> <title> Une extension de l'interpretation de Godel a l'analyse, et son application a l'elimination des coupures dans l'analyse et la theorie des types. </title> <booktitle> In Proceedings of the Second Scandinavian Logic Symposium, edited by J.E. Fenstad. </booktitle> <publisher> North-Holland, Amsterdam, </publisher> <pages> pages 63-92, </pages> <year> 1971. </year>
Reference-contexts: derive intermediate languages based on this formal calculus and show how to compile Mini-ML to these lower-level languages, taking advantage of dynamic type dispatch to implement various language features. 3.1 Syntax of ML ML i is based on ML [94], a predicative variant of the Girard-Reynolds polymorphic calculus, F ! <ref> [47, 46, 106] </ref>. The essential departure from the impredicative systems of Girard and Reynolds is that, as in Mini-ML, there is a distinction made between monotypes (types without a quantifier) and polytypes, and type variables are only allowed to range over monotypes. <p> Furthermore, e arrow must abstract the components of the Arrow constructor as well as the result of unwinding the typerec on these components. 3.4 Related Work There are two traditional interpretations of polymorphism, the explicit style (due to Gi-rard <ref> [47, 46] </ref> and Reynolds [106]), in which types are passed to polymorphic operations, and the implicit style (due to Milner [89]), in which types are erased prior to execution. CHAPTER 3.
Reference: [47] <author> J.-Y. Girard. </author> <title> Interpretation Fonctionnelle et Elimination des Coupures dans l'Arithmetique d'Ordre Superieur. </title> <type> PhD thesis, </type> <institution> Universite Paris VII, </institution> <year> 1972. </year>
Reference-contexts: derive intermediate languages based on this formal calculus and show how to compile Mini-ML to these lower-level languages, taking advantage of dynamic type dispatch to implement various language features. 3.1 Syntax of ML ML i is based on ML [94], a predicative variant of the Girard-Reynolds polymorphic calculus, F ! <ref> [47, 46, 106] </ref>. The essential departure from the impredicative systems of Girard and Reynolds is that, as in Mini-ML, there is a distinction made between monotypes (types without a quantifier) and polytypes, and type variables are only allowed to range over monotypes. <p> Furthermore, e arrow must abstract the components of the Arrow constructor as well as the result of unwinding the typerec on these components. 3.4 Related Work There are two traditional interpretations of polymorphism, the explicit style (due to Gi-rard <ref> [47, 46] </ref> and Reynolds [106]), in which types are passed to polymorphic operations, and the implicit style (due to Milner [89]), in which types are erased prior to execution. CHAPTER 3. <p> Of a related nature, the restriction to predicative polymorphism is suitable for interpreting ML-like languages. However, this restriction prevents us from compiling languages based on the original Girard-Reynolds impredicative calculus. Girard has shown that adding Typerec-like operators to such calculi breaks strong normalization <ref> [47] </ref>, so it is unlikely that there is a simple calculus that provides both decidable type checking and CHAPTER 9. SUMMARY, FUTURE WORK, AND CONCLUSIONS 214 impredicative polymorphism.
Reference: [48] <author> K. </author> <title> Godel. Uber eine bisher noch nicht benutzte Erweiterung des finiten Standpunktes. </title> <journal> Dialectica, </journal> <volume> 12 </volume> <pages> 280-287, </pages> <year> 1958. </year>
Reference: [49] <author> B. Goldberg. </author> <title> Tag-free garbage collection for strongly typed programming languages. </title> <booktitle> In ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 165-176, </pages> <address> Toronto, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: TIL also performs various optimizations to share as many type computations as is possible. These and other "real-world" implementation issues are discussed in Chapter 8. Over the past few years, a number of papers on inference-based collection in monomor-phic [22, 129, 23] and polymorphic <ref> [8, 49, 50, 43] </ref> languages appeared in the literature. <p> Otherwise, we simply forward the representation information to the next stack frame, and so on. This approach to reconstructing type information is similar to the approach suggested by Appel [8] and Goldberg and Gloger <ref> [49, 50] </ref>. Once we determine which registers and which stack slots must be traced, we perform a standard copying garbage collection on the resulting roots.
Reference: [50] <author> B. Goldberg and M. Gloger. </author> <title> Polymorphic type reconstruction for garbage collection without tags. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 53-65, </pages> <address> San Francisco, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: TIL also performs various optimizations to share as many type computations as is possible. These and other "real-world" implementation issues are discussed in Chapter 8. Over the past few years, a number of papers on inference-based collection in monomor-phic [22, 129, 23] and polymorphic <ref> [8, 49, 50, 43] </ref> languages appeared in the literature. <p> Baker [14] recognized that Milner-style type inference can be used to prove that reachable objects can be safely collected, but did not give a formal account of this result. Goldberg and Gloger <ref> [50] </ref> recognized that it is not possible to reconstruct the concrete types of all reachable values in an implementation of an ML-style language that does not pass types to polymorphic routines. They gave an informal argument based on traversal of stack frames to show that such values are semantically garbage. <p> Otherwise, we simply forward the representation information to the next stack frame, and so on. This approach to reconstructing type information is similar to the approach suggested by Appel [8] and Goldberg and Gloger <ref> [49, 50] </ref>. Once we determine which registers and which stack slots must be traced, we perform a standard copying garbage collection on the resulting roots.
Reference: [51] <author> J. Gosling. </author> <title> Java intermediate bytecodes. </title> <booktitle> In ACM SIGPLAN Workshop on Intermediate Representations (IR'95), </booktitle> <month> Jan. </month> <year> 1995. </year> <note> BIBLIOGRAPHY 221 </note>
Reference-contexts: For example, vendor-supplied, dynamically-linked libraries (e.g., Xlib, Tk) are now the norm instead of the exception. Often, it is impossible to get the source code for such libraries and it is prohibitively time-consuming to recompile them for each application, especially during development. We now have languages such as Java <ref> [51] </ref> and Obliq [27, 28] where objects and code are dynamically transmitted from one machine to another via a network, compiled to a native representation, and then dynamically linked into a running program.
Reference: [52] <author> C. A. Gunter, E. L. Gunter, and D. B. MacQueen. </author> <title> Computing ML equality kinds using abstract interpretation. </title> <journal> Information and Computation, </journal> <volume> 107(2) </volume> <pages> 303-323, </pages> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: Such a calculus is more than sufficient for the interpretation of ML-style polymorphism 1 and makes arguments based on logical relations easier than an impred-icative calculus. The language ML i extends ML with intensional (or structural <ref> [52] </ref>) polymorphism, which allows non-parametric functions to be defined via intensional analysis of types. The four syntactic classes of ML i are given in Figure 3.1. The expressions of the language are described by types. Types include int, function types, explicitly injected constructors (T ()) and polymorphic types (8t:::).
Reference: [53] <author> C. Hall, K. Hammond, S. Peyton-Jones, and P. Wadler. </author> <title> Type classes in Haskell. </title> <booktitle> In Fifth European Symposium on Programming, volume 788 of Lecture Notes in Computer Science, </booktitle> <pages> pages 241-256. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: In this section, I show how the dynamic type dispatch facilities of ML i can be used to support flattened data structures (such as C-style structs and arrays), Haskell-style type classes <ref> [53] </ref>, and polymorphic communication primitives. 5.4.1 C-style Structs Languages like C provide flattened data structures by default. Programmers explicitly specify when they want to use pointers. This gives programmers control over both sharing and data layout.
Reference: [54] <author> J. Hannan. </author> <title> A type system for closure conversion. In The Workshop on Types for Program Analysis, </title> <institution> Aarhus University, </institution> <month> May </month> <year> 1995. </year>
Reference-contexts: The open term may be thought of as immutable code that acts on the environment. Since the code is immutable, it can be generated once and shared among all instances of a function. Closure conversion <ref> [105, 111, 33, 78, 76, 9, 124, 54] </ref> is a program transformation that achieves such a separation between code and data. Functions with free variables are replaced by code abstracting an extra environment parameter. Free variables in the body of the function are replaced by references to the environment. <p> Wand and Steckler [124] have considered two optimizations of the basic closure conversion strategy | selective and lightweight closure conversion | and provide a correctness proof for each of these in an untyped setting. Hannan <ref> [54] </ref> recasts Wand's work into a typed setting, and provides correctness proofs for Wand's optimizations. As with my translation, Hannan's translation is formulated as a deductive system.
Reference: [55] <author> R. Harper. </author> <title> Strong normalization and confluence for predicative, higher-order intensional polymorphism. </title> <note> Unpublished note. </note>
Reference-contexts: The ideas follow closely those of Harper <ref> [55] </ref> and Lambek and Scott [79].
Reference: [56] <author> R. Harper and P. Lee. </author> <title> Advanced languages for systems software: The Fox project in 1994. </title> <type> Technical Report CMU-CS-94-104, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: The goal was to support efficient access to library routines, system calls, and hardware, which is needed for "systems" programming in SML as proposed by the Fox project <ref> [56] </ref>. To this end, we decided to use tag-free garbage collection to support untagged, unboxed integers and pointers, since most arguments to libraries or system calls involve these two representations.
Reference: [57] <author> R. Harper and M. Lillibridge. </author> <title> Explicit polymorphism and CPS conversion. </title> <booktitle> In Twentieth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 206-219, </pages> <address> Charleston, </address> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: This so-called "value restriction" is necessary to support a type-passing interpretation of SML, since polymorphic computations are represented as functions. The value restriction has been proposed by others <ref> [63, 57, 82] </ref> as a way to avoid the well-known problems of polymorphism and refs, exceptions, continuations, and other constructs that have computational effects. Furthermore, according to a study performed by Wright [131], most SML code naturally obeys the value restriction.
Reference: [58] <author> R. Harper and M. Lillibridge. </author> <title> A type-theoretic approach to higher-order modules with sharing. </title> <booktitle> In Twenty-First ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 123-137, </pages> <address> Portland, </address> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: Each source module is compiled to a Lambda module with an explicit list of imported modules and their signatures. Imported signatures may include transparent definitions of types defined in other modules. Hence, TIL supports a limited form of translucent <ref> [58] </ref> or manifest types [83]. I extended the mapping from SML abstract syntax to Lambda so that SML structures are mapped to Lambda structures with transparent imported types. Currently, the mapping to Lambda does not handle source-level signatures, nested structures, or functors. <p> Each exported constructor can optionally include the definition of the constructor in the signature. In this respect, Lmli signatures resemble the translucent sums of the Harper and Lillibridge module calculus <ref> [58] </ref>. The types of the values can contain references to the constructors exported by the module | using the Dot c notation | relative to the module strid M.
Reference: [59] <author> R. Harper and J. C. Mitchell. </author> <title> On the type structure of Standard ML. </title> <journal> ACM Transactions on Progamming Languages and Systems, </journal> <volume> 15(2) </volume> <pages> 211-252, </pages> <month> April </month> <year> 1993. </year> <note> (See also [93].). </note>
Reference-contexts: 8t 1 :::8t 2 :::ft 1 =tg ! ft 2 =tg ! fArrow (t 1 ; t 2 )=tg ; ` typerec of [t:](e int ; e arrow ) : f=tg (equiv) ; ` e : 0 ` 0 :: In their study of the type theory of Standard ML <ref> [93, 59] </ref>, Harper and Mitchell argued that an explicitly-typed interpretation of ML polymorphism has better semantic properties and scales more easily to cover a full programming language. <p> The resulting constructor has kind Mono k ! Mono k. The translation of a datatype applied to some type argument is straightforward: I simply apply the constructor function corresponding to the datatype to the translation of the type arguments. This approach to datatypes was originally suggested by Harper <ref> [59] </ref>, though he also suggests the use of an existential to hide the representation of the datatype. Hiding the representation of the datatype is important at the source level, since this distinguishes user types that happen to have the same representation.
Reference: [60] <author> R. Harper, J. C. Mitchell, and E. Moggi. </author> <title> Higher-order modules and the phase distinction. </title> <booktitle> In Seventeenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 341-354, </pages> <address> San Francisco, </address> <month> Jan. </month> <year> 1990. </year>
Reference-contexts: The Typerec and typerec forms may be thought of as eliminatory forms for the kind at the constructor and term level respectively. The introductory forms are the constructors of kind ; there are no introductory forms at the term level in order to preserve the phase distinction <ref> [25, 60] </ref>. In effect, Typerec and typerec let us fold some computation over a monotype. Limiting the computation to a fold, instead of some general recursion, ensures that the computation terminates | a crucial property at the constructor level. <p> Harper and Mitchell formulated a predicative type theory, XML, a theory of dependent types augmented with a universe of small types, adequate for capturing many aspects of SML. This type theory was later refined by Harper, Mitchell, and Moggi <ref> [60] </ref>, and provides the fundamental basis for the type theory of ML i . The idea of adding an inductively generated ground type (the natural numbers) with an elimination rule like Typerec, to the typed -calculus is implicit in Godel's original "functionals of finite type"[48].
Reference: [61] <author> R. Harper and G. Morrisett. </author> <title> Compiling with non-parametric polymorphism (preliminary report). </title> <type> Technical Report CMU-CS-94-122, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> Mar. </month> <year> 1994. </year> <note> Also published as Fox Memorandum CMU-CS-FOX-94-03. </note>
Reference-contexts: The idea of adding an inductively generated universe, with a term-level elimination rule such as typerec, was derived from the universe elimination rules found in NuPrl [32], though the idea was only described in unpublished work of Robert Constable. Harper and I devised the original formulation of ML i <ref> [62, 61] </ref>. Chapter 4 Typing Properties of ML In this chapter, I present proofs of two important properties of ML i : Type checking ML i terms is decidable, and the type system is sound with respect to the operational semantics.
Reference: [62] <author> R. Harper and G. Morrisett. </author> <title> Compiling polymorphism using intensional type analysis. </title> <booktitle> In Twenty-Second ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 130-141, </pages> <address> San Francisco, </address> <month> Jan. </month> <year> 1995. </year>
Reference-contexts: The idea of adding an inductively generated universe, with a term-level elimination rule such as typerec, was derived from the universe elimination rules found in NuPrl [32], though the idea was only described in unpublished work of Robert Constable. Harper and I devised the original formulation of ML i <ref> [62, 61] </ref>. Chapter 4 Typing Properties of ML In this chapter, I present proofs of two important properties of ML i : Type checking ML i terms is decidable, and the type system is sound with respect to the operational semantics.
Reference: [63] <author> R. W. Harper and M. Lillibridge. </author> <title> Polymorphic type assignment and CPS conversion. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 6 </volume> <pages> 361-379, </pages> <year> 1993. </year>
Reference-contexts: This so-called "value restriction" is necessary to support a type-passing interpretation of SML, since polymorphic computations are represented as functions. The value restriction has been proposed by others <ref> [63, 57, 82] </ref> as a way to avoid the well-known problems of polymorphism and refs, exceptions, continuations, and other constructs that have computational effects. Furthermore, according to a study performed by Wright [131], most SML code naturally obeys the value restriction.
Reference: [64] <author> F. Henglein. </author> <title> Global tagging optimization by type inference. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 205-215, </pages> <address> San Francisco, </address> <month> June </month> <year> 1992. </year> <note> BIBLIOGRAPHY 222 </note>
Reference-contexts: of the code emitted by most SML compilers, even when these features are not used, is far below the quality of compilers for languages like C or Fortran. 1.2.3 Previous Approach: Coercions Because boxing and tagging are so expensive, a great deal of research has gone into minimizing these costs <ref> [75, 81, 64, 65, 102, 110] </ref>. A particularly clever approach was suggested by Xavier Leroy for call-by-value languages based on the ML type system [81]. <p> None of these approaches supports unboxed mutable data, or generally unboxed datatypes. Furthermore, they do not address type classes, marshaling, or garbage collection. Of a broadly similar nature is the work on "soft" type systems <ref> [64, 7, 29, 132] </ref>. Here, ML-style type inference or set constraints are used to eliminate type-tag checks in dynamically typed languages such as Scheme. Morrison, et al. [97] described an implementation of Napier that passed types at run time to determine the behavior of polymorphic operations. <p> For example, the conventional argument flattener of TIL fails to flatten many functions that the type-directed flattener does flatten. Even without programmer-supplied type information, the advances in soft typing <ref> [64, 7, 29, 132] </ref> provide a means for compiler writers to take advantage of types. In general, compilers and other kinds of system software have real issues and problems that can serve as the clients and driving force behind the development of advanced type systems.
Reference: [65] <author> F. Henglein and J. Jtrgensen. </author> <title> Formally optimal boxing. </title> <booktitle> In Twenty-First ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 213-226, </pages> <address> Portland, </address> <month> Jan. </month> <year> 1994. </year> <note> ACM. </note>
Reference-contexts: of the code emitted by most SML compilers, even when these features are not used, is far below the quality of compilers for languages like C or Fortran. 1.2.3 Previous Approach: Coercions Because boxing and tagging are so expensive, a great deal of research has gone into minimizing these costs <ref> [75, 81, 64, 65, 102, 110] </ref>. A particularly clever approach was suggested by Xavier Leroy for call-by-value languages based on the ML type system [81]. <p> This gives an optimizer the opportunity to replace onearg [ 1 ][ 2 ] (vararg [ 1 ][ 2 ] v) with simply v even when the argument type of the function v is unknown. Henglein and Jorgensen suggest a similar approach to eliminate excessive Leroy-style coercions <ref> [65] </ref>. CHAPTER 5.
Reference: [66] <author> M. Herlihy and B. Liskov. </author> <title> A value transmission method for abstract data types. </title> <journal> ACM Transactions on Progamming Languages and Systems, </journal> <volume> 4(4) </volume> <pages> 527-551, </pages> <month> Oct. </month> <year> 1982. </year>
Reference-contexts: However, type checking for the language is in general undecidable and type errors can occur at run time. Furthermore, like the approaches to type classes, there is no facility for transforming types. Marshalling in languages with abstract or polymorphic types has been the subject of much research <ref> [85, 86, 84, 66, 27, 4, 100, 77] </ref>. The solution I propose does not easily extend to user-defined abstract types (as with Herlihy and Liskov [66]). <p> Marshalling in languages with abstract or polymorphic types has been the subject of much research [85, 86, 84, 66, 27, 4, 100, 77]. The solution I propose does not easily extend to user-defined abstract types (as with Herlihy and Liskov <ref> [66] </ref>). However, none of these previous approaches are able to express the relationship between a value's type and its transmissible representation, whereas I am able to express this relationship as a constructor function (i.e., Tran). 5 Originally, Harper and I termed the type analysis of ML i "intensional polymorphism".
Reference: [67] <author> P. Hudak. </author> <title> A semantic model of reference counting and its abstraction. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 351-363, </pages> <month> Aug. </month> <year> 1986. </year>
Reference-contexts: Nettles [98] provides a concrete specification of a copying garbage collection algorithm using the Larch specification language. My specification of the free-variable tracing algorithm is essentially a high-level, one-line description of his specification. Hudak gives a denotational model that tracks reference counts for a first-order language <ref> [67] </ref>. He presents an abstraction of the model and gives an algorithm for computing approximations of reference counts statically. Chirimar, Gunter, and Riecke give a framework for proving invariants regarding memory management for a language with a linear type system [30].
Reference: [68] <author> P. Hudak, S. L. P. Jones, and P. Wadler. </author> <title> Report on the programming language Haskell, version 1.2. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 27(5), </volume> <month> May </month> <year> 1992. </year>
Reference-contexts: Nevertheless, the range of transformations that ML i -like languages can support seems to cover a wide variety of the interesting cases. 5.4.2 Type Classes The programming language Haskell <ref> [68] </ref> gives the programmer the ability to define a class of types with associated operations called methods. The canonical example is the class of types that admit equality (also known as equality types in SML [90]).
Reference: [69] <author> T. Johnsson. </author> <title> Lambda lifting: Transforming programs to recursive equations. </title> <booktitle> In ACM Conference on Functional Programming and Computer Architecture, volume 201 of Lecture Notes in Computer Science, </booktitle> <pages> pages 190-203, </pages> <address> Nancy, Sept. 1985. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: TYPED CLOSURE CONVERSION 121 6.5 Related Work Closure conversion is discussed in descriptions of various functional language compilers [111, 78, 11, 9, 109]. It is closely related to -lifting <ref> [69] </ref> in that it eliminates free variables in the bodies of -abstractions. However, closure conversion differs by making the representation of the environment explicit as a data structure. Making the environment explicit is important because it exposes environment construction and variable lookup to an optimizer.
Reference: [70] <author> M. B. Jones, R. F. Rashid, and M. R. Thompson. Matchmaker: </author> <title> An interface specification language for distributed processing. </title> <booktitle> In Twelfth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 225-235, </pages> <address> New Orleans, </address> <month> Jan. </month> <year> 1985. </year>
Reference-contexts: With marshal and unmarshal, I can dynamically convert a value to and from its transmissible representation. In effect, these terms reify the stub compilers of traditional RPC systems (e.g., the Mach Interface Generator for Mach RPC <ref> [70, 123] </ref>).
Reference: [71] <author> M. P. Jones. </author> <title> Qualified Types: Theory and Practice. </title> <type> PhD thesis, </type> <institution> Programming Research Group, Oxford University Computing Laboratory, </institution> <month> July </month> <year> 1992. </year> <note> Currently available as Technical Monograph PRG-106, </note> <institution> Oxford University Computing Laboratory, Programming Research Group, </institution> <address> 11 Keble Road, Oxford OX1 3QD, U.K. email: library@comlab.ox.ac.uk. </address>
Reference-contexts: Another approach, suggested by Duggan [38], is to refine the kind of the bound type variable, much as Freeman and Pfenning suggest refinements of SML datatypes [44]. 3 See Jones <ref> [72, 71] </ref> for a general formulation of qualified types. CHAPTER 5. COMPILING WITH DYNAMIC TYPE DISPATCH 96 However, it is possible to encode type classes to a limited degree using Typerec. <p> Type passing was also used by Aditya and Caro in an implementation of Id, so that instantiations of polymorphic types could be reconstructed for debugging purposes [5]. Jones <ref> [72, 71] </ref> has proposed a general framework for passing data derived from types to "qualified" polymorphic operations, called evidence passing. He shows how evidence passing can be used to implement Haskell-style type classes, generalizing the earlier work of Wadler and Blott [122].
Reference: [72] <author> M. P. Jones. </author> <title> A theory of qualified types. </title> <booktitle> In ESOP '92: European Symposium on Programming, Rennes, </booktitle> <address> France, New York, </address> <month> February </month> <year> 1992. </year> <note> Springer-Verlag. Lecture Notes in Computer Science, 582. </note>
Reference-contexts: Another approach, suggested by Duggan [38], is to refine the kind of the bound type variable, much as Freeman and Pfenning suggest refinements of SML datatypes [44]. 3 See Jones <ref> [72, 71] </ref> for a general formulation of qualified types. CHAPTER 5. COMPILING WITH DYNAMIC TYPE DISPATCH 96 However, it is possible to encode type classes to a limited degree using Typerec. <p> Type passing was also used by Aditya and Caro in an implementation of Id, so that instantiations of polymorphic types could be reconstructed for debugging purposes [5]. Jones <ref> [72, 71] </ref> has proposed a general framework for passing data derived from types to "qualified" polymorphic operations, called evidence passing. He shows how evidence passing can be used to implement Haskell-style type classes, generalizing the earlier work of Wadler and Blott [122].
Reference: [73] <author> M. P. Jones. </author> <title> Partial evaluation for dictionary-free overloading. </title> <institution> Research Report YALEU/DCS/RR-959, Yale University, </institution> <address> New Haven, </address> <month> April </month> <year> 1993. </year>
Reference-contexts: The resulting monomor phic code is compiled. A caching scheme is used to minimize code duplication. * Gofer, a dialect of Haskell, provides both polymorphism and type classes. Mark Jones constructed an implementation that, like the NESL implementation, performs all polymorphic instantiation at compile time <ref> [73] </ref>. Unfortunately, the "eliminate variable types" approach has many drawbacks. One drawback is that polymorphic code is never shared. Instead, each polymorphic definition is copied at least once for each unique instantiation. This can have a serious effect on both compile times and instruction cache locality. <p> For languages like Gofer, Haskell, and SML, which provide nested polymorphic definitions, it is possible that the number of copies of a polymorphic definition could grow exponentially with the number of type variables in the definition. (However, Jones reports that this does not occur in practice <ref> [73] </ref>.) Even if code size, compile times, and instruction cache locality were not an issue, the "eliminate" approach sacrifices separate compilation of an ADT or polymorphic definition from its uses.
Reference: [74] <author> M. P. Jones. </author> <title> The implementation of the Gofer functional programming system. </title> <institution> Research Report YALEU/DCS/RR-1030, Yale University, </institution> <address> New Haven, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: This allows us to use a standard, monomorphic compiler. The "elimination" approach has been used in various guises by implementations of C++ [114], Ada [121], NESL [20], and Gofer <ref> [74] </ref> to support ADTs and polymorphism. * When defining a new class in C++, the definition is placed in a ".h" file. The definition is #included by any client code that wishes to use the abstraction. Hence, the compiler can always determine the representation of an abstract data type.
Reference: [75] <author> S. P. Jones and J. Launchbury. </author> <title> Unboxed values as first-class citizens. </title> <booktitle> In ACM Conference on Functional Programming and Computer Architecture, volume 523 of Lecture Notes in Computer Science, </booktitle> <pages> pages 636-666, </pages> <address> Cambridge, Sept. 1991. </address> <publisher> ACM, Springer-Verlag. </publisher>
Reference-contexts: of the code emitted by most SML compilers, even when these features are not used, is far below the quality of compilers for languages like C or Fortran. 1.2.3 Previous Approach: Coercions Because boxing and tagging are so expensive, a great deal of research has gone into minimizing these costs <ref> [75, 81, 64, 65, 102, 110] </ref>. A particularly clever approach was suggested by Xavier Leroy for call-by-value languages based on the ML type system [81]. <p> Similarly, we can code general-purpose print and read routines within ML i , in order to achieve the easy input/output of languages like Lisp and Scheme. 5.5 Related Work Peyton Jones and Launchbury suggested an approach to unboxed integers and reals in the context of a lazy language <ref> [75] </ref>. However, they restricted unboxed types from instantiating type variables. A similar idea was recently proposed by Ohori [101] to compile polymorphic languages such as SML.
Reference: [76] <author> R. Kelsey and P. Hudak. </author> <booktitle> Realistic compilation by program translation detailed summary -. In Sixteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 281-292, </pages> <address> Austin, </address> <month> Jan. </month> <year> 1989. </year>
Reference-contexts: The open term may be thought of as immutable code that acts on the environment. Since the code is immutable, it can be generated once and shared among all instances of a function. Closure conversion <ref> [105, 111, 33, 78, 76, 9, 124, 54] </ref> is a program transformation that achieves such a separation between code and data. Functions with free variables are replaced by code abstracting an extra environment parameter. Free variables in the body of the function are replaced by references to the environment.
Reference: [77] <author> F. Knabe. </author> <title> Language Support for Mobile Agents. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <year> 1995. </year> <note> BIBLIOGRAPHY 223 </note>
Reference-contexts: However, type checking for the language is in general undecidable and type errors can occur at run time. Furthermore, like the approaches to type classes, there is no facility for transforming types. Marshalling in languages with abstract or polymorphic types has been the subject of much research <ref> [85, 86, 84, 66, 27, 4, 100, 77] </ref>. The solution I propose does not easily extend to user-defined abstract types (as with Herlihy and Liskov [66]).
Reference: [78] <author> D. Kranz et al. </author> <title> Orbit: An optimizing compiler for Scheme. </title> <booktitle> In Proceedings of the ACM SIGPLAN '86 Symposium on Compiler Construction, </booktitle> <year> 1986. </year>
Reference-contexts: The open term may be thought of as immutable code that acts on the environment. Since the code is immutable, it can be generated once and shared among all instances of a function. Closure conversion <ref> [105, 111, 33, 78, 76, 9, 124, 54] </ref> is a program transformation that achieves such a separation between code and data. Functions with free variables are replaced by code abstracting an extra environment parameter. Free variables in the body of the function are replaced by references to the environment. <p> TYPED CLOSURE CONVERSION 121 6.5 Related Work Closure conversion is discussed in descriptions of various functional language compilers <ref> [111, 78, 11, 9, 109] </ref>. It is closely related to -lifting [69] in that it eliminates free variables in the bodies of -abstractions. However, closure conversion differs by making the representation of the environment explicit as a data structure. <p> Hence, Lmli-Close is a refinement of Lmli-Bform, much the same as Lmli-Bform is a refinement of Lmli. The conversion is based on the type-directed closure translation described in Chapter 6. However, following Kranz <ref> [78] </ref>, we calculate the set of functions that do not "escape" and avoid constructing closures for such functions. Because Lmli-Close is a subset of Bform, we can use both the optimizer and the type checker on the closure converted code. <p> The entire optimization process is then iterated for some adjustable number of times (currently three). 8.7 Closure Conversion The closure conversion phase of TIL is based on the formal treatment of closure conversion given in Chapter 6, but following Kranz <ref> [78] </ref> and Appel [9], I extended the translation to avoid creating closures and environments unless functions "escape". A function escapes if it is placed in a data structure, passed as an argument to another function, or is returned as the result of a function.
Reference: [79] <author> J. Lambek and P. Scott. </author> <title> Introduction to Higher Order Categorical Logic. </title> <publisher> Cambridge University Press, </publisher> <year> 1986. </year>
Reference-contexts: The idea of adding an inductively generated ground type (the natural numbers) with an elimination rule like Typerec, to the typed -calculus is implicit in Godel's original "functionals of finite type"[48]. Thus, the constructor language of ML i is fundamentally based on this work. According to Lambek and Scott <ref> [79] </ref>, Marie-France Thibault [117] studied the correspondence between such calculi and cartesian closed categories equipped with "strong" natural number objects. However, the notion of constructor equivalence in ML i corresponds to what Lambek and Scott term a "weak" natural number object. <p> The ideas follow closely those of Harper [55] and Lambek and Scott <ref> [79] </ref>.
Reference: [80] <author> P. J. Landin. </author> <title> The mechanical evaluation of expressions. </title> <journal> The Computer Journal, </journal> <volume> 6 </volume> <pages> 308-320, </pages> <year> 1966. </year>
Reference-contexts: Substitution is expensive because it requires traversing and copying a term in order to find and replace all occurrences of the given variable. A well-known technique for mitigating these costs is to delay substitution until the binding of the variable is required during evaluation <ref> [80, 2, 1] </ref>. This is accomplished by pairing an open term with an environment that provides values for the free variables in the term. The open term may be thought of as immutable code that acts on the environment. <p> In particular, I use closures and environments to implement substitution. In this respect, the semantics CHAPTER 7. TYPES AND GARBAGE COLLECTION 160 is quite similar to the SECD <ref> [80] </ref> and CEK machines [40]. The primary difference between my approach and these machines is that I make the heap explicit, which enables me to define a suitable notion of garbage and garbage collection.
Reference: [81] <author> X. Leroy. </author> <title> Unboxed objects and polymorphic typing. </title> <booktitle> In Nineteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 177-188, </pages> <address> Albuquerque, </address> <month> Jan. </month> <year> 1992. </year>
Reference-contexts: of the code emitted by most SML compilers, even when these features are not used, is far below the quality of compilers for languages like C or Fortran. 1.2.3 Previous Approach: Coercions Because boxing and tagging are so expensive, a great deal of research has gone into minimizing these costs <ref> [75, 81, 64, 65, 102, 110] </ref>. A particularly clever approach was suggested by Xavier Leroy for call-by-value languages based on the ML type system [81]. <p> A particularly clever approach was suggested by Xavier Leroy for call-by-value languages based on the ML type system <ref> [81] </ref>. The fundamental idea is to compile monomorphic code in exactly the same way that it is compiled in the absence of variable types, and to compile polymorphic code assuming that variables of unknown type are boxed and tagged. <p> However, for at least one contrived program with a great deal of polymorphism, the coercion approach slowed the program by more than a factor of two <ref> [81] </ref>. Nevertheless, his coercion approach has an attractive property: You pay only for the polymorphism you use. Other researchers have also found that eliminating boxing and tagging through coercions can cut execution times and allocation considerably. <p> Second, in the presence of recursive types (ML data types), refs, or arrays, not only must the components corresponding to type variables be boxed, but their components must be recursively boxed <ref> [81] </ref>. Third, and perhaps most troublesome, it is difficult if not impossible to make a copy of a mutable data structure such as an array. The problem is that updates to the copy must be reflected in the original data structure and vice versa. <p> However, they restricted unboxed types from instantiating type variables. A similar idea was recently proposed by Ohori [101] to compile polymorphic languages such as SML. Leroy suggested the coercion based approach to allow unrestricted instantiation of type variables <ref> [81] </ref>, and later, Poulsen extended his work to accommodate unboxed datatypes that do not "escape" [102]. Henglein and Jtrgensen examined techniques for eliminating coercions at compile-time. Shao and Appel [110, 108] took the ideas of Leroy and extended them to the full Standard ML language. <p> For example, all functions in SML take one argument; multiple arguments are simulated by using a tuple as the argument. From previous studies <ref> [81, 110] </ref>, we determined that most functions do not use the tuple argument except to extract the components of the tuple. Consequently, we wanted TIL to translate functions so that they take tuple components in registers as multiple arguments, thereby avoiding constructing the argument tuple.
Reference: [82] <author> X. Leroy. </author> <title> Polymorphism by name. </title> <booktitle> In Twentieth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 220-231, </pages> <address> Charleston, </address> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: This so-called "value restriction" is necessary to support a type-passing interpretation of SML, since polymorphic computations are represented as functions. The value restriction has been proposed by others <ref> [63, 57, 82] </ref> as a way to avoid the well-known problems of polymorphism and refs, exceptions, continuations, and other constructs that have computational effects. Furthermore, according to a study performed by Wright [131], most SML code naturally obeys the value restriction.
Reference: [83] <author> X. Leroy. </author> <title> Manifest types, modules, and separate compilation. </title> <booktitle> In Twenty-First ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 109-122, </pages> <address> Portland, </address> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: Each source module is compiled to a Lambda module with an explicit list of imported modules and their signatures. Imported signatures may include transparent definitions of types defined in other modules. Hence, TIL supports a limited form of translucent [58] or manifest types <ref> [83] </ref>. I extended the mapping from SML abstract syntax to Lambda so that SML structures are mapped to Lambda structures with transparent imported types. Currently, the mapping to Lambda does not handle source-level signatures, nested structures, or functors.
Reference: [84] <author> B. Liskov. </author> <title> Overview of the Argus language and system. Programming Methodology Group Memo 40, </title> <institution> MIT Laboratory for Computer Science, </institution> <month> Feb. </month> <year> 1984. </year>
Reference-contexts: However, type checking for the language is in general undecidable and type errors can occur at run time. Furthermore, like the approaches to type classes, there is no facility for transforming types. Marshalling in languages with abstract or polymorphic types has been the subject of much research <ref> [85, 86, 84, 66, 27, 4, 100, 77] </ref>. The solution I propose does not easily extend to user-defined abstract types (as with Herlihy and Liskov [66]).
Reference: [85] <author> B. Liskov. </author> <title> Distributed Programming in Argus. </title> <journal> Communications of the ACM, </journal> <volume> 31(3) </volume> <pages> 300-312, </pages> <month> Mar. </month> <year> 1988. </year>
Reference-contexts: However, type checking for the language is in general undecidable and type errors can occur at run time. Furthermore, like the approaches to type classes, there is no facility for transforming types. Marshalling in languages with abstract or polymorphic types has been the subject of much research <ref> [85, 86, 84, 66, 27, 4, 100, 77] </ref>. The solution I propose does not easily extend to user-defined abstract types (as with Herlihy and Liskov [66]).
Reference: [86] <author> B. Liskov, D. Curtis, P. Johnson, and R. Scheifler. </author> <title> Implementation of Argus. </title> <booktitle> In Proceedings of the 11th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 111-122, </pages> <address> Austin, </address> <month> Nov. </month> <year> 1987. </year> <note> ACM. </note>
Reference-contexts: However, type checking for the language is in general undecidable and type errors can occur at run time. Furthermore, like the approaches to type classes, there is no facility for transforming types. Marshalling in languages with abstract or polymorphic types has been the subject of much research <ref> [85, 86, 84, 66, 27, 4, 100, 77] </ref>. The solution I propose does not easily extend to user-defined abstract types (as with Herlihy and Liskov [66]).
Reference: [87] <author> P. Martin-Lof. </author> <title> About models for intuitionistic type theories and the notion of definitional equality. </title> <editor> In S. Kanger, editor, </editor> <booktitle> Proceedings of the Third Scandinavian Logic Symposium, Studies in Logic and the Foundations of Mathematics, </booktitle> <pages> pages 81-109. </pages> <publisher> North-Holland, </publisher> <year> 1975. </year>
Reference-contexts: To type check an expression, we need to be able to tell when two types are equivalent. Since constructors can be injected into types, we need an appropriate notion of constructor equivalence. Therefore, I define definitional equivalence <ref> [113, 87] </ref> via the judgment ` 1 2 :: . Figure 3.7 gives the axioms and inference rules that allows us to derive CHAPTER 3. A CALCULUS OF DYNAMIC TYPE DISPATCH 42 definitional equivalence.
Reference: [88] <author> D. Matthews. </author> <title> Poly manual. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 20(9) </volume> <pages> 42-76, </pages> <year> 1985. </year>
Reference-contexts: If a value is passed as an argument of unknown type to some routine, then the value must be boxed (i.e., represented as a pointer.) Because it is impossible to tell whether or not a value will be passed to a polymorphic function, most ML compilers, including Poly/ML <ref> [88] </ref>, Bigloo [107], Caml [126], and older versions of SML/NJ [9], box all objects. Boxing supports separate compilation and dynamic linking, but unfortunately, it consumes space and time because of the extra indirection that is introduced.
Reference: [89] <author> R. Milner. </author> <title> A theory of type polymorphism in programming languages. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: Arrow constructor as well as the result of unwinding the typerec on these components. 3.4 Related Work There are two traditional interpretations of polymorphism, the explicit style (due to Gi-rard [47, 46] and Reynolds [106]), in which types are passed to polymorphic operations, and the implicit style (due to Milner <ref> [89] </ref>), in which types are erased prior to execution. CHAPTER 3.
Reference: [90] <author> R. Milner, M. Tofte, and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Introduction The goal of my thesis is to show that types can and should be used throughout implementations of modern programming languages. More specifically, I claim that, through the use of type-directed translation and dynamic type dispatch (explained below), we can compile polymorphic, garbage-collected languages, such as Standard ML <ref> [90] </ref>, without sacrificing natural data representations, efficient calling conventions, or separate compilation. Furthermore, I claim that a principled language implementation based on types lends itself to proofs of correctness, as well as tools that automatically verify the integrity of the implementation. <p> Finally, in Chapter 9, I present a summary of the thesis, and discuss future directions. Chapter 2 A Source Language: Mini-ML In this chapter, I specify a starting source language, called Mini-ML, that is based on the core language of Standard ML <ref> [90, 31] </ref>. Although Mini-ML is a fairly limited language, it has many of the constructs that one might find in a conventional functional programming language, including integers and floating point values; first-class, lexically-scoped functions; tuples (records); and polymorphism. <p> The canonical example is the class of types that admit equality (also known as equality types in SML <ref> [90] </ref>). The class of equality types includes primitive types, such as int and float, that have a primitive notion of equality. Equality types also include data structures, such as tuples, when the component types are equality types. <p> A cursory study showed that no datatypes of this form existed in either the Edinburgh or the SML/NJ library. In many respects, the ability to define such datatypes violates the type-theoretic "essence of SML" [94], and thus I view them more as a bug in the Definition <ref> [90] </ref> than a feature. In principle, TIL supports the rest of the Standard ML Definition, though of course there may be bugs in the implementation. CHAPTER 8. THE TIL/ML COMPILER 167 We use the ML Kit Compiler [19] to parse, type-check, and elaborate SML expressions.
Reference: [91] <author> Y. Minamide, G. Morrisett, and R. Harper. </author> <title> Typed closure conversion. </title> <type> Technical Report CMU-CS-95-171, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> July </month> <year> 1995. </year> <note> Also published as Fox Memorandum CMU-CS-FOX-95-05. </note>
Reference-contexts: In this chapter, I present a particularly important stage of compilation for functional programming languages known as closure conversion. To my knowledge, no one (besides Yasuhiko Minamide, Robert Harper and myself <ref> [92, 91] </ref>) has presented a type-preserving closure conversion phase, especially for type-passing polymorphic languages. Therefore, it is important to show that such a translation exists if I am to claim that my type-based implementation approach is viable. <p> In this chapter, I show how to closure convert ML i - Rep using abstract closures. Minamide, Harper, and Morrisett provide further details on environment representations and how to represent closures <ref> [92, 91] </ref>. I begin by giving an overview of closure conversion and why it is an important part of functional language implementation. I then define a target language called ML i -Close, which is a variant of ML i -Rep that provides explicit facilities for constructing closures and their environments. <p> However, Han-nan does not consider the important issue of environment representation (preferring an abstract account), nor does he consider the typing properties of the closure-converted code. Minamide, Morrisett, and Harper give a comprehensive treatment of type-directed closure conversion for the simply-typed -calculus and a predicative, type-passing polymorphic -calculus <ref> [92, 91] </ref>. This chapter extends the initial treatment by showing how to closure convert a language like ML i with higher-kinds (i.e., functions at both the constructor and term levels).
Reference: [92] <author> Y. Minamide, G. Morrisett, and R. Harper. </author> <title> Typed closure conversion. </title> <booktitle> In Twenty-Third ACM Symposium on Principles of Programming Languages. ACM, </booktitle> <month> Jan. </month> <year> 1996. </year> <note> To appear. </note>
Reference-contexts: In this chapter, I present a particularly important stage of compilation for functional programming languages known as closure conversion. To my knowledge, no one (besides Yasuhiko Minamide, Robert Harper and myself <ref> [92, 91] </ref>) has presented a type-preserving closure conversion phase, especially for type-passing polymorphic languages. Therefore, it is important to show that such a translation exists if I am to claim that my type-based implementation approach is viable. <p> In this chapter, I show how to closure convert ML i - Rep using abstract closures. Minamide, Harper, and Morrisett provide further details on environment representations and how to represent closures <ref> [92, 91] </ref>. I begin by giving an overview of closure conversion and why it is an important part of functional language implementation. I then define a target language called ML i -Close, which is a variant of ML i -Rep that provides explicit facilities for constructing closures and their environments. <p> However, Han-nan does not consider the important issue of environment representation (preferring an abstract account), nor does he consider the typing properties of the closure-converted code. Minamide, Morrisett, and Harper give a comprehensive treatment of type-directed closure conversion for the simply-typed -calculus and a predicative, type-passing polymorphic -calculus <ref> [92, 91] </ref>. This chapter extends the initial treatment by showing how to closure convert a language like ML i with higher-kinds (i.e., functions at both the constructor and term levels). <p> In our previous work on closure conversion <ref> [92] </ref>, we showed how closures could be represented using a combination of translucent types and existentials. Using this representation in TIL would allow us to hoist code and environment projections out of loops, but would greatly complicate the type system.
Reference: [93] <author> J. Mitchell and R. Harper. </author> <title> The essence of ML. </title> <booktitle> In Fifteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 28-46, </pages> <address> San Diego, </address> <month> Jan. </month> <year> 1988. </year> <note> BIBLIOGRAPHY 224 </note>
Reference-contexts: 8t 1 :::8t 2 :::ft 1 =tg ! ft 2 =tg ! fArrow (t 1 ; t 2 )=tg ; ` typerec of [t:](e int ; e arrow ) : f=tg (equiv) ; ` e : 0 ` 0 :: In their study of the type theory of Standard ML <ref> [93, 59] </ref>, Harper and Mitchell argued that an explicitly-typed interpretation of ML polymorphism has better semantic properties and scales more easily to cover a full programming language.
Reference: [94] <author> J. C. Mitchell and R. Harper. </author> <title> The essence of ML. </title> <booktitle> In Conference Record of the 15th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 28-46, </pages> <month> Jan. </month> <year> 1988. </year>
Reference-contexts: In subsequent chapters, I derive intermediate languages based on this formal calculus and show how to compile Mini-ML to these lower-level languages, taking advantage of dynamic type dispatch to implement various language features. 3.1 Syntax of ML ML i is based on ML <ref> [94] </ref>, a predicative variant of the Girard-Reynolds polymorphic calculus, F ! [47, 46, 106]. <p> The expressions of the language are described by types. Types include int, function types, explicitly injected constructors (T ()) and polymorphic types (8t:::). Types that do not include a quantifier are called monotypes, whereas types that do include a quantifier are called polytypes. 1 See Harper and Mitchell <ref> [94] </ref> for further discussion of this point. 36 CHAPTER 3. A CALCULUS OF DYNAMIC TYPE DISPATCH 37 The language easily extends to float, products, and inductively generated types like lists; I omit these here to simplify the formal treatment of the calculus. <p> Such datatypes are very rare. A cursory study showed that no datatypes of this form existed in either the Edinburgh or the SML/NJ library. In many respects, the ability to define such datatypes violates the type-theoretic "essence of SML" <ref> [94] </ref>, and thus I view them more as a bug in the Definition [90] than a feature. In principle, TIL supports the rest of the Standard ML Definition, though of course there may be bugs in the implementation. CHAPTER 8.
Reference: [95] <author> G. Morrisett, M. Felleisen, and R. Harper. </author> <title> Abstract models of memory management. </title> <type> Technical Report CMU-CS-95-110, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> Jan. </month> <year> 1994. </year> <note> Also published as Fox Memorandum CMU-CS-FOX-95-01. </note>
Reference-contexts: Hence, tag-free garbage collection is another mechanism that can use dynamic type dispatch to account for variable types. As for monomorphic languages, this approach to tag-free garbage collection for polymorphic languages is not new <ref> [119, 6, 96, 95] </ref>, but my formulation is sufficiently abstract that we can easily prove its correctness. Tag-free garbage collection is important for two very practical reasons: first, a clever tag-free implementation can avoid manipulating any type information in monomorphic code at run time, except during garbage collection. <p> arrows denote relations that are assumed to exist and dashed arrows denote relations that can be derived from the assumed relations. 1 In an untyped setting where collections are not required to be closed programs, it is undecidable whether or not a given binding in an arbitrary program is garbage <ref> [96, 95] </ref>. This more general notion of garbage can be recovered in the typed setting by allowing locations to be rebound in the heap. CHAPTER 7. <p> Fradet [43] gave another argument based on Reynolds's abstraction/parametricity theorem [104]. The style of semantics I use here is closely related to the allocation semantics used in my previous work on garbage collection <ref> [96, 95] </ref>, but is slightly lower-level. In particular, I use closures and environments to implement substitution. In this respect, the semantics CHAPTER 7. TYPES AND GARBAGE COLLECTION 160 is quite similar to the SECD [80] and CEK machines [40].
Reference: [96] <author> G. Morrisett, M. Felleisen, and R. Harper. </author> <title> Abstract models of memory management. </title> <booktitle> In ACM Conference on Functional Programming and Computer Architecture, </booktitle> <pages> pages 66-77, </pages> <address> La Jolla, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: Hence, tag-free garbage collection is another mechanism that can use dynamic type dispatch to account for variable types. As for monomorphic languages, this approach to tag-free garbage collection for polymorphic languages is not new <ref> [119, 6, 96, 95] </ref>, but my formulation is sufficiently abstract that we can easily prove its correctness. Tag-free garbage collection is important for two very practical reasons: first, a clever tag-free implementation can avoid manipulating any type information in monomorphic code at run time, except during garbage collection. <p> arrows denote relations that are assumed to exist and dashed arrows denote relations that can be derived from the assumed relations. 1 In an untyped setting where collections are not required to be closed programs, it is undecidable whether or not a given binding in an arbitrary program is garbage <ref> [96, 95] </ref>. This more general notion of garbage can be recovered in the typed setting by allowing locations to be rebound in the heap. CHAPTER 7. <p> Fradet [43] gave another argument based on Reynolds's abstraction/parametricity theorem [104]. The style of semantics I use here is closely related to the allocation semantics used in my previous work on garbage collection <ref> [96, 95] </ref>, but is slightly lower-level. In particular, I use closures and environments to implement substitution. In this respect, the semantics CHAPTER 7. TYPES AND GARBAGE COLLECTION 160 is quite similar to the SECD [80] and CEK machines [40].
Reference: [97] <author> R. Morrison, A. Dearle, R. C. H. Connor, and A. L. Brown. </author> <title> An ad hoc approach to the implementation of polymorphism. </title> <journal> ACM Transactions on Progamming Languages and Systems, </journal> <volume> 13(3) </volume> <pages> 342-371, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: This approach breaks down when we move to a language with first-class polymorphism. 1.3 Dynamic Type Dispatch There is an approach for compiling in the presence of variable types, first suggested by the Napier '88 implementation <ref> [97] </ref>, which avoids the drawbacks of boxing or coercions without sacrificing separate compilation. The idea is to delay deciding what code to select until types are known. This is accomplished by passing types that are unknown at compile-time to primitive operations. <p> Of a broadly similar nature is the work on "soft" type systems [64, 7, 29, 132]. Here, ML-style type inference or set constraints are used to eliminate type-tag checks in dynamically typed languages such as Scheme. Morrison, et al. <ref> [97] </ref> described an implementation of Napier that passed types at run time to determine the behavior of polymorphic operations. However, the actual transformations performed were not described and there was little or no analysis of the typing properties or performance of the resulting code.
Reference: [98] <author> S. Nettles. </author> <title> A Larch specification of copying garbage collection. </title> <type> Technical Report CMU-CS-92-219, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> Dec. </month> <year> 1992. </year>
Reference-contexts: However, their model is intentionally divorced from the programming language and cannot take advantage of any semantic properties of evaluation, such as type preservation. Consequently, their framework cannot model the type-based collectors I describe here. Nettles <ref> [98] </ref> provides a concrete specification of a copying garbage collection algorithm using the Larch specification language. My specification of the free-variable tracing algorithm is essentially a high-level, one-line description of his specification. Hudak gives a denotational model that tracks reference counts for a first-order language [67].
Reference: [99] <author> A. Ohori. </author> <title> A compilation method for ML-style polymorphic record calculi. </title> <booktitle> In Nineteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 154-165, </pages> <address> Albuquerque, </address> <month> Jan. </month> <year> 1992. </year>
Reference-contexts: However, the actual transformations performed were not described and there was little or no analysis of the typing properties or performance of the resulting code. The work of Ohori on compiling record operations <ref> [99] </ref> is similarly based on a type-passing interpretation and provided much of the inspiration of this work. Type passing was also used by Aditya and Caro in an implementation of Id, so that instantiations of polymorphic types could be reconstructed for debugging purposes [5].
Reference: [100] <author> A. Ohori and K. Kato. </author> <title> Semantics for communication primitives in a polymorphic language. </title> <booktitle> In Twentieth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 99-112, </pages> <address> Charleston, </address> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: The information encoded in the type class can be used by a compiler to eliminate unneeded cases within methods. CHAPTER 5. COMPILING WITH DYNAMIC TYPE DISPATCH 98 5.4.3 Communication Primitives Ohori and Kato give an extension of ML with primitives for communication in a distributed, heterogeneous environment <ref> [100] </ref>. Their extension has two essential features: one is a mechanism for generating globally unique names ("handles" or "capabilities") that are used as proxies for functions provided by servers. The other is a method for representing arbitrary values in a form suitable for transmission through a network. <p> However, type checking for the language is in general undecidable and type errors can occur at run time. Furthermore, like the approaches to type classes, there is no facility for transforming types. Marshalling in languages with abstract or polymorphic types has been the subject of much research <ref> [85, 86, 84, 66, 27, 4, 100, 77] </ref>. The solution I propose does not easily extend to user-defined abstract types (as with Herlihy and Liskov [66]).
Reference: [101] <author> A. Ohori and T. Takamizawa. </author> <title> A polymorphic unboxed calculus as an abstract machine for polymorphic languages. </title> <type> Technical Report RIMS-1032, </type> <institution> RIMS, Kyoto University, </institution> <month> May </month> <year> 1995. </year>
Reference-contexts: However, they restricted unboxed types from instantiating type variables. A similar idea was recently proposed by Ohori <ref> [101] </ref> to compile polymorphic languages such as SML. Leroy suggested the coercion based approach to allow unrestricted instantiation of type variables [81], and later, Poulsen extended his work to accommodate unboxed datatypes that do not "escape" [102]. Henglein and Jtrgensen examined techniques for eliminating coercions at compile-time.
Reference: [102] <author> E. R. Poulsen. </author> <title> Representation analysis for efficient implementation of polymorphism. </title> <type> Technical report, </type> <institution> Department of Computer Science (DIKU), University of Copenhagen, </institution> <month> Apr. </month> <year> 1993. </year> <note> Master Dissertation. </note>
Reference-contexts: of the code emitted by most SML compilers, even when these features are not used, is far below the quality of compilers for languages like C or Fortran. 1.2.3 Previous Approach: Coercions Because boxing and tagging are so expensive, a great deal of research has gone into minimizing these costs <ref> [75, 81, 64, 65, 102, 110] </ref>. A particularly clever approach was suggested by Xavier Leroy for call-by-value languages based on the ML type system [81]. <p> A similar idea was recently proposed by Ohori [101] to compile polymorphic languages such as SML. Leroy suggested the coercion based approach to allow unrestricted instantiation of type variables [81], and later, Poulsen extended his work to accommodate unboxed datatypes that do not "escape" <ref> [102] </ref>. Henglein and Jtrgensen examined techniques for eliminating coercions at compile-time. Shao and Appel [110, 108] took the ideas of Leroy and extended them to the full Standard ML language. Thiemann extended the work of Leroy to keep some values unboxed even within polymorphic functions [118].
Reference: [103] <author> C. Reade. </author> <title> Elements of Functional Programming. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, </address> <year> 1989. </year>
Reference-contexts: 246 Fast-Fourier transform. fmult 63 Matrix multiply of two 100x100 floating point matrices. imult 63 Matrix multiply of two 200x200 integer matrices. kb 618 The Knuth-Bendix completion algorithm. lexgen 1123 A lexical-analyzer generator [13], processing the lexical descrip tion of SML/NJ. life 146 A simulation of cells implemented using lists <ref> [103] </ref>. logic 459 A simple Prolog-like interpreter, with unification and backtrack ing. msort 45 List merge sort of 5,120 integers, 40 times. pia 2065 A Perspective Inversion Algorithm [125] deciding the location of an object in a perspective video image. qsort 141 Integer array quicksort of 50,000 pseudo-random integers, 2 times.
Reference: [104] <author> J. Reynolds. </author> <title> Types, abstraction, and parametric polymorphism. </title> <booktitle> In Proceedings of Information Processing '83, </booktitle> <pages> pages 513-523, </pages> <year> 1983. </year>
Reference-contexts: They gave an informal argument based on traversal of stack frames to show that such values are semantically garbage. Fradet [43] gave another argument based on Reynolds's abstraction/parametricity theorem <ref> [104] </ref>. The style of semantics I use here is closely related to the allocation semantics used in my previous work on garbage collection [96, 95], but is slightly lower-level. In particular, I use closures and environments to implement substitution. In this respect, the semantics CHAPTER 7.
Reference: [105] <author> J. C. Reynolds. </author> <title> Definitional interpreters for higher-order programming languages. </title> <booktitle> In Proceedings of the Annual ACM Conference, </booktitle> <pages> pages 717-740, </pages> <year> 1972. </year>
Reference-contexts: The open term may be thought of as immutable code that acts on the environment. Since the code is immutable, it can be generated once and shared among all instances of a function. Closure conversion <ref> [105, 111, 33, 78, 76, 9, 124, 54] </ref> is a program transformation that achieves such a separation between code and data. Functions with free variables are replaced by code abstracting an extra environment parameter. Free variables in the body of the function are replaced by references to the environment.
Reference: [106] <author> J. C. Reynolds. </author> <title> Towards a theory of type structure. </title> <booktitle> In Proceedings, Colloque sur la Programmation. Lecture Notes in Computer Science, </booktitle> <volume> volume 19, </volume> <pages> pages 408-425. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1974. </year> <note> BIBLIOGRAPHY 225 </note>
Reference-contexts: derive intermediate languages based on this formal calculus and show how to compile Mini-ML to these lower-level languages, taking advantage of dynamic type dispatch to implement various language features. 3.1 Syntax of ML ML i is based on ML [94], a predicative variant of the Girard-Reynolds polymorphic calculus, F ! <ref> [47, 46, 106] </ref>. The essential departure from the impredicative systems of Girard and Reynolds is that, as in Mini-ML, there is a distinction made between monotypes (types without a quantifier) and polytypes, and type variables are only allowed to range over monotypes. <p> Furthermore, e arrow must abstract the components of the Arrow constructor as well as the result of unwinding the typerec on these components. 3.4 Related Work There are two traditional interpretations of polymorphism, the explicit style (due to Gi-rard [47, 46] and Reynolds <ref> [106] </ref>), in which types are passed to polymorphic operations, and the implicit style (due to Milner [89]), in which types are erased prior to execution. CHAPTER 3.
Reference: [107] <author> M. Serrano and P. Weis. </author> <title> 1+1 = 1: an optimizing Caml compiler. </title> <booktitle> In Record of the 1994 ACM SIGPLAN Workshop on ML and its Applications, </booktitle> <pages> pages 101-111, </pages> <address> Orlando, </address> <month> June </month> <year> 1994. </year> <note> INRIA RR 2265. </note>
Reference-contexts: If a value is passed as an argument of unknown type to some routine, then the value must be boxed (i.e., represented as a pointer.) Because it is impossible to tell whether or not a value will be passed to a polymorphic function, most ML compilers, including Poly/ML [88], Bigloo <ref> [107] </ref>, Caml [126], and older versions of SML/NJ [9], box all objects. Boxing supports separate compilation and dynamic linking, but unfortunately, it consumes space and time because of the extra indirection that is introduced.
Reference: [108] <author> Z. Shao. </author> <title> Compiling Standard ML for Efficient Execution on Modern Machines. </title> <type> PhD thesis, </type> <institution> Princeton University, </institution> <year> 1994. </year>
Reference-contexts: Leroy suggested the coercion based approach to allow unrestricted instantiation of type variables [81], and later, Poulsen extended his work to accommodate unboxed datatypes that do not "escape" [102]. Henglein and Jtrgensen examined techniques for eliminating coercions at compile-time. Shao and Appel <ref> [110, 108] </ref> took the ideas of Leroy and extended them to the full Standard ML language. Thiemann extended the work of Leroy to keep some values unboxed even within polymorphic functions [118]. None of these approaches supports unboxed mutable data, or generally unboxed datatypes.
Reference: [109] <author> Z. Shao and A. W. Appel. </author> <title> Space-efficient closure representations. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 150-161, </pages> <address> Orlando, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: The linked representation can also support constant-time closure creation, but this requires reusing the current environment and can result in bindings in the environment for CHAPTER 6. TYPED CLOSURE CONVERSION 105 variables that do not occur free in the function (such as z above), leading to space leaks <ref> [109] </ref>. Closure conversion for a language like ML i where constructors are passed at run time is complicated by the fact that we must account for free type variables as well as free value variables within code. <p> TYPED CLOSURE CONVERSION 121 6.5 Related Work Closure conversion is discussed in descriptions of various functional language compilers <ref> [111, 78, 11, 9, 109] </ref>. It is closely related to -lifting [69] in that it eliminates free variables in the bodies of -abstractions. However, closure conversion differs by making the representation of the environment explicit as a data structure. <p> However, closure conversion differs by making the representation of the environment explicit as a data structure. Making the environment explicit is important because it exposes environment construction and variable lookup to an optimizer. Furthermore, Shao and Appel show that not all environment representations are "safe for space" <ref> [109] </ref>, and thus choosing a good environment representation is an important part of compilation. Wand and Steckler [124] have considered two optimizations of the basic closure conversion strategy | selective and lightweight closure conversion | and provide a correctness proof for each of these in an untyped setting.
Reference: [110] <author> Z. Shao and A. W. Appel. </author> <title> A type-based compiler for Standard ML. </title> <booktitle> In ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 116-129, </pages> <address> La Jolla, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: of the code emitted by most SML compilers, even when these features are not used, is far below the quality of compilers for languages like C or Fortran. 1.2.3 Previous Approach: Coercions Because boxing and tagging are so expensive, a great deal of research has gone into minimizing these costs <ref> [75, 81, 64, 65, 102, 110] </ref>. A particularly clever approach was suggested by Xavier Leroy for call-by-value languages based on the ML type system [81]. <p> Other researchers have also found that eliminating boxing and tagging through coercions can cut execution times and allocation considerably. For instance, Shao and Appel were able to improve execution time by about 19% and decrease heap allocation by 36% via Leroy-style coercions for their SML/NJ compiler <ref> [110] </ref>. However, much of their improvement (11% execution time, 30% of allocation) comes by performing a type-directed flattening of function arguments as part of the coercion process. CHAPTER 1. <p> In practice, flattening function arguments yields a substantial speedup for SML code and significantly reduces allocation. Much of the improvement claimed by Shao and Appel for their implementation of Leroy-style representation analysis is due to argument flattening <ref> [110] </ref>. In particular, they reduced total execution time by 11% on average and allocation by 30% on average. I found similar performance advantages with argument flattening in the context of the TIL compiler (see Chapter 8). <p> Leroy suggested the coercion based approach to allow unrestricted instantiation of type variables [81], and later, Poulsen extended his work to accommodate unboxed datatypes that do not "escape" [102]. Henglein and Jtrgensen examined techniques for eliminating coercions at compile-time. Shao and Appel <ref> [110, 108] </ref> took the ideas of Leroy and extended them to the full Standard ML language. Thiemann extended the work of Leroy to keep some values unboxed even within polymorphic functions [118]. None of these approaches supports unboxed mutable data, or generally unboxed datatypes. <p> For example, all functions in SML take one argument; multiple arguments are simulated by using a tuple as the argument. From previous studies <ref> [81, 110] </ref>, we determined that most functions do not use the tuple argument except to extract the components of the tuple. Consequently, we wanted TIL to translate functions so that they take tuple components in registers as multiple arguments, thereby avoiding constructing the argument tuple. <p> The Ubform representation is quite similar to a direct-style version of the CPS intermediate form used by Shao and Appel in the SML/NJ compiler <ref> [110] </ref>. While Shao and Appel claim that their compiler is type-based, they only use representation-based, untyped intermediate forms. Hence, it is not possible, in general, to verify automatically that any of their intermediate representations are type-safe. <p> For TIL, I compiled programs with all optimizations enabled. For SML/NJ, I compiled programs using the default optimization settings. I used a recent internal release of SML/NJ (a variant of version 108.3), since it produces code that is about 35% faster than the standard 0.93 release of SML/NJ <ref> [110] </ref>. For both compilers, we extended the built-in types with safe 2-dimensional arrays. The 2-d array operations perform bounds checking on each dimension and then use unsafe 1-d array operations. Arrays are stored in column-major order. TIL automatically prefixes a set of operations onto each module that it compiles. <p> Regardless, since flattening real arrays has a negligible negative effect on the other benchmarks, it is a worthwhile optimization. All of these results are consistent with results seen by Shao and Appel <ref> [110] </ref>. The advantages of my approach are that (a) we can flatten data constructors without making restrictions at the source level, (b) we can flatten arrays, (c) we need not tag values for garbage collection or polymorphic equality. CHAPTER 8.
Reference: [111] <author> G. L. Steele Jr. Rabbit: </author> <title> A compiler for Scheme. </title> <type> Master's thesis, </type> <institution> MIT, </institution> <year> 1978. </year>
Reference-contexts: The open term may be thought of as immutable code that acts on the environment. Since the code is immutable, it can be generated once and shared among all instances of a function. Closure conversion <ref> [105, 111, 33, 78, 76, 9, 124, 54] </ref> is a program transformation that achieves such a separation between code and data. Functions with free variables are replaced by code abstracting an extra environment parameter. Free variables in the body of the function are replaced by references to the environment. <p> TYPED CLOSURE CONVERSION 121 6.5 Related Work Closure conversion is discussed in descriptions of various functional language compilers <ref> [111, 78, 11, 9, 109] </ref>. It is closely related to -lifting [69] in that it eliminates free variables in the bodies of -abstractions. However, closure conversion differs by making the representation of the environment explicit as a data structure.
Reference: [112] <author> P. Steenkiste and J. Hennessey. </author> <title> Tags and type checking in LISP: Hardware and software approaches. </title> <booktitle> In Proceedings of the Second International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-II), </booktitle> <pages> pages 50-59, </pages> <month> Oct. </month> <year> 1987. </year>
Reference-contexts: In contrast, a tagging implementation must tag values as they are created and possibly untag the values when they are examined. The overheads of manipulating these tags during the computation can be considerable <ref> [112] </ref> and implementors go to great lengths and use many clever encodings to minimize these overheads [128]. Second, tag-free garbage collection supports language and system interoperability. In particular, many ubiquitous languages, such as Fortran, C, and C++, do not provide automatic memory management and, thus, do not tag values.
Reference: [113] <author> S. Stenlund. </author> <title> Combinators, -terms and Proof Theory. </title> <address> D. </address> <publisher> Reidel, </publisher> <year> 1972. </year>
Reference-contexts: To type check an expression, we need to be able to tell when two types are equivalent. Since constructors can be injected into types, we need an appropriate notion of constructor equivalence. Therefore, I define definitional equivalence <ref> [113, 87] </ref> via the judgment ` 1 2 :: . Figure 3.7 gives the axioms and inference rules that allows us to derive CHAPTER 3. A CALCULUS OF DYNAMIC TYPE DISPATCH 42 definitional equivalence. <p> Furthermore, I show that this reduction relation is confluent, from which it follows that constructor equivalence is decidable <ref> [113] </ref>. The type formation and equivalence rules can be found in Figures 3.8 and 3.9 respectively. The rules of type equivalence define the interpretation T () of the constructor as a type.
Reference: [114] <author> B. Stroustrup. </author> <title> The C++ Programming Language, Second Edition. </title> <publisher> Addison-Wesley, </publisher> <year> 1991. </year>
Reference-contexts: This allows us to use a standard, monomorphic compiler. The "elimination" approach has been used in various guises by implementations of C++ <ref> [114] </ref>, Ada [121], NESL [20], and Gofer [74] to support ADTs and polymorphism. * When defining a new class in C++, the definition is placed in a ".h" file. The definition is #included by any client code that wishes to use the abstraction.
Reference: [115] <author> D. R. Tarditi. </author> <title> Optimizing ML. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <year> 1996. </year> <month> Forthcoming. </month>
Reference-contexts: Because the optimization phases use Bform for both the source and target language, the output of each phase can be checked for type correctness. Most of the design and implementation of the optimizer is not my work, and is described fully by Tarditi's thesis <ref> [115] </ref>. It is interesting to note that working with a typed intermediate form did not constrain the set of optimizations that Tarditi wished to perform, and that types could be used to perform some optimizations that were not possible in an untyped setting. <p> These constraints also have the effect of linearizing nested computations and naming intermediate results. All of these constraints simplify standard optimization. Numerous transformations and optimizations are applied in the Bform phase to programs. (See Tarditi <ref> [115] </ref> for a more complete description of these optimizations.) The optimizations include the following conventional transformations: * alpha-conversion: We assign unique names to all bound variables. * minimizing fix: We break functions into minimal sets of mutually recursive func tions. <p> Since SML/NJ flattens arguments using Leroy-style coercions, and also flattens some constructors (see Section 8.5.3), the primary difference in performance for most benchmarks is not due to my type-directed translations. Most likely, the primary difference in performance is due to the conventional optimizations that TIL employs <ref> [115] </ref>. What is remarkable is that, even though TIL employs more optimizations than SML/NJ, the use of types and dynamic type dispatch does not interfere with optimization.
Reference: [116] <author> S. R. Thatte. </author> <title> Semantics of type classes revisited. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 208-219, </pages> <address> Orlando, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: However, qualified types represent predicates on types, whereas the type system of ML i supports computations that transform types. For example, it is not possible to express the transmissible representation or a flattened representation of a type in Jones's framework. Recently, Duggan and Ophel [38] and Thatte <ref> [116] </ref> have independently suggested semantics for type classes that are similar in spirit to my proposal. In one sense, these proposals do a better job of enforcing type classes, since they restrict the kinds of type variables. <p> From a compiler perspective, the whole purpose of dynamic type dispatch is to violate the very abstraction that a programmer establishes. There are a variety of approaches that could be taken to solve this problem. The work of Duggan and Ophel [38] and Thatte <ref> [116] </ref> on kind-based definitions of type-classes seems promising to me.
Reference: [117] <author> M.-F. Thibault. </author> <title> Representations des Fonctions Recursives Dans les Categories. </title> <type> PhD thesis, </type> <institution> McGill University, Montreal, </institution> <year> 1977. </year>
Reference-contexts: Thus, the constructor language of ML i is fundamentally based on this work. According to Lambek and Scott [79], Marie-France Thibault <ref> [117] </ref> studied the correspondence between such calculi and cartesian closed categories equipped with "strong" natural number objects. However, the notion of constructor equivalence in ML i corresponds to what Lambek and Scott term a "weak" natural number object.
Reference: [118] <author> P. J. Thiemann. </author> <title> Unboxed values and polymorphic typing revisited. </title> <booktitle> In ACM Conference on Functional Programming and Computer Architecture, </booktitle> <pages> pages 24-35, </pages> <address> La Jolla, </address> <year> 1995. </year>
Reference-contexts: Henglein and Jtrgensen examined techniques for eliminating coercions at compile-time. Shao and Appel [110, 108] took the ideas of Leroy and extended them to the full Standard ML language. Thiemann extended the work of Leroy to keep some values unboxed even within polymorphic functions <ref> [118] </ref>. None of these approaches supports unboxed mutable data, or generally unboxed datatypes. Furthermore, they do not address type classes, marshaling, or garbage collection. Of a broadly similar nature is the work on "soft" type systems [64, 7, 29, 132].
Reference: [119] <author> A. Tolmach. </author> <title> Tag-free garbage collection using explicit type parameters. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 1-11, </pages> <address> Orlando, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: When allocating a register for a variable of type double, a C compiler will use a floating point register instead of a general purpose register. Some implementations take advantage of types to support tag-free garbage collection <ref> [23, 119, 6] </ref> and so-called "conservative" garbage collection [21]. Types are also used to support debugging, printing and parsing, marshaling, and other means of traversing a data structure. In addition to directing implementation, types are useful for proving formal properties of programs. <p> Hence, tag-free garbage collection is another mechanism that can use dynamic type dispatch to account for variable types. As for monomorphic languages, this approach to tag-free garbage collection for polymorphic languages is not new <ref> [119, 6, 96, 95] </ref>, but my formulation is sufficiently abstract that we can easily prove its correctness. Tag-free garbage collection is important for two very practical reasons: first, a clever tag-free implementation can avoid manipulating any type information in monomorphic code at run time, except during garbage collection. <p> Barendsen and Smetsers give a Curry-like type system for CHAPTER 7. TYPES AND GARBAGE COLLECTION 159 functional languages extended with uniqueness information that guarantees an object is only "locally accessible" [16]. This provides a compiler enough information to determine when certain objects may be garbage collected or over-written. Tolmach <ref> [119] </ref> built a type-recovery collector for a variant of SML that passes type information to polymorphic routines during execution. <p> We were unsure whether the run 1 Yasuhiko Minamide pointed this out to me and showed that Tolmach failed to properly correct for this in his tag-free collector <ref> [119] </ref>. CHAPTER 8. THE TIL/ML COMPILER 163 time costs of the more complicated mechanisms would outweigh the benefits of unboxed doubles, especially for conventional SML code which typically manipulates many records and few doubles. <p> Hence, for values of unknown represen CHAPTER 8. THE TIL/ML COMPILER 190 tation, we must record where this other variable can be found so that the collector can determine whether or not to trace the original value. In this respect, our collector resembles Tolmach's tag-free collector for SML <ref> [119] </ref>. However, Tolmach calculates unknown representations lazily during garbage collection, because he does not have a general programming language at the type level. In particular, he only supports substitution at the constructor level and not, for instance, Typerec.
Reference: [120] <author> D. Ungar. </author> <title> Generational scavenging: A non-disruptive high performance storage management reclamation algorithm. </title> <booktitle> In ACM SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pages 15-167, </pages> <address> Pittsburgh, </address> <month> Apr. </month> <year> 1984. </year>
Reference-contexts: The third reason generational collection is important is that empirical evidence shows that "objects tend to die young" <ref> [120] </ref>. That is, recently allocated bindings are more likely to become garbage in a small number of evaluation steps.
Reference: [121] <institution> United States Department of Defense. </institution> <note> Reference Manual for the Ada Programming Language, </note> <month> Feb. </month> <year> 1983. </year> <title> U.S. Government Printing Office, ANSI/MIL-STD-1815A-1983. BIBLIOGRAPHY 226 </title>
Reference-contexts: This allows us to use a standard, monomorphic compiler. The "elimination" approach has been used in various guises by implementations of C++ [114], Ada <ref> [121] </ref>, NESL [20], and Gofer [74] to support ADTs and polymorphism. * When defining a new class in C++, the definition is placed in a ".h" file. The definition is #included by any client code that wishes to use the abstraction.
Reference: [122] <author> P. Wadler and S. Blott. </author> <title> How to make ad hoc polymorphism less ad hoc. </title> <booktitle> In Sixteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 60-76, </pages> <address> Austin, </address> <year> 1989. </year>
Reference-contexts: Jones [72, 71] has proposed a general framework for passing data derived from types to "qualified" polymorphic operations, called evidence passing. He shows how evidence passing can be used to implement Haskell-style type classes, generalizing the earlier work of Wadler and Blott <ref> [122] </ref>. He also shows how Ohori-style record calculi can be imple CHAPTER 5. COMPILING WITH DYNAMIC TYPE DISPATCH 101 mented with evidence passing. Jones's approach subsumes type passing in that functions or types or any evidence derived from qualified types could, in principle, be passed to polymorphic operations.
Reference: [123] <author> L. R. Walmer and M. R. Thompson. </author> <title> A programmer's guide to the Mach user environment. </title> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> Feb. </month> <year> 1988. </year>
Reference-contexts: With marshal and unmarshal, I can dynamically convert a value to and from its transmissible representation. In effect, these terms reify the stub compilers of traditional RPC systems (e.g., the Mach Interface Generator for Mach RPC <ref> [70, 123] </ref>).
Reference: [124] <author> M. Wand and P. Steckler. </author> <title> Selective and lightweight closure conversion. </title> <booktitle> In Twenty-First ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 435-445, </pages> <address> Portland, </address> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: The open term may be thought of as immutable code that acts on the environment. Since the code is immutable, it can be generated once and shared among all instances of a function. Closure conversion <ref> [105, 111, 33, 78, 76, 9, 124, 54] </ref> is a program transformation that achieves such a separation between code and data. Functions with free variables are replaced by code abstracting an extra environment parameter. Free variables in the body of the function are replaced by references to the environment. <p> Making the environment explicit is important because it exposes environment construction and variable lookup to an optimizer. Furthermore, Shao and Appel show that not all environment representations are "safe for space" [109], and thus choosing a good environment representation is an important part of compilation. Wand and Steckler <ref> [124] </ref> have considered two optimizations of the basic closure conversion strategy | selective and lightweight closure conversion | and provide a correctness proof for each of these in an untyped setting. Hannan [54] recasts Wand's work into a typed setting, and provides correctness proofs for Wand's optimizations.
Reference: [125] <author> K. G. Waugh, P. McAndrew, and G. Michaelson. </author> <title> Parallel implementations from function prototypes: a case study. </title> <institution> Technical Report Computer Science 90/4, Heriot-Watt University, Edinburgh, </institution> <month> Aug. </month> <year> 1990. </year>
Reference-contexts: lexgen 1123 A lexical-analyzer generator [13], processing the lexical descrip tion of SML/NJ. life 146 A simulation of cells implemented using lists [103]. logic 459 A simple Prolog-like interpreter, with unification and backtrack ing. msort 45 List merge sort of 5,120 integers, 40 times. pia 2065 A Perspective Inversion Algorithm <ref> [125] </ref> deciding the location of an object in a perspective video image. qsort 141 Integer array quicksort of 50,000 pseudo-random integers, 2 times. sieve 27 Sieve of Eratosthenes, filtering primes up to 30000. simple 870 A spherical fluid-dynamics program [39], run for 4 iterations with grid size of 100. soli 131
Reference: [126] <author> P. Weis, M.-V. Aponte, A. Laville, M. Mauny, and A. </author> <title> Suarez. The CAML reference manual, Version 2.6. </title> <type> Technical report, </type> <institution> Projet Formel, INRIA-ENS, </institution> <year> 1989. </year>
Reference-contexts: value is passed as an argument of unknown type to some routine, then the value must be boxed (i.e., represented as a pointer.) Because it is impossible to tell whether or not a value will be passed to a polymorphic function, most ML compilers, including Poly/ML [88], Bigloo [107], Caml <ref> [126] </ref>, and older versions of SML/NJ [9], box all objects. Boxing supports separate compilation and dynamic linking, but unfortunately, it consumes space and time because of the extra indirection that is introduced.
Reference: [127] <author> P. R. Wilson. </author> <title> Uniprocessor garbage collection techniques. </title> <editor> In Y. Bekkers and J. Cohen, editors, </editor> <booktitle> International Workshop on Memory Management, number 637 in Lecture Notes in Computer Science, </booktitle> <pages> pages 1-42, </pages> <address> St. Malo, Sept. 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference: [128] <author> P. R. Wilson. </author> <title> Garbage collection. </title> <journal> Computing Surveys, </journal> <note> 1995. Expanded version of [127]. Draft available via anonymous internet FTP from cs.utexas.edu as pub/garbage/bigsurv.ps. In revision, to appear. </note>
Reference-contexts: In contrast, a tagging implementation must tag values as they are created and possibly untag the values when they are examined. The overheads of manipulating these tags during the computation can be considerable [112] and implementors go to great lengths and use many clever encodings to minimize these overheads <ref> [128] </ref>. Second, tag-free garbage collection supports language and system interoperability. In particular, many ubiquitous languages, such as Fortran, C, and C++, do not provide automatic memory management and, thus, do not tag values. <p> The mechanism that tracks updates to older generations is called a write barrier. Wilson's overview provides many examples of techniques used to implement write barriers <ref> [128] </ref>. The second reason generational collection is important is that, given a generational partition, we can directly use the tracing collection algorithm to generate a generational collection of a program.
Reference: [129] <author> P. Wodon. </author> <title> Methods of garbage collection for Algol-68. In Algol-68 Implementation. </title> <publisher> North-Holland Publishing Company, </publisher> <address> Amsterdam, </address> <year> 1970. </year>
Reference-contexts: TIL also performs various optimizations to share as many type computations as is possible. These and other "real-world" implementation issues are discussed in Chapter 8. Over the past few years, a number of papers on inference-based collection in monomor-phic <ref> [22, 129, 23] </ref> and polymorphic [8, 49, 50, 43] languages appeared in the literature.
Reference: [130] <author> A. Wright and M. Felleisen. </author> <title> A syntactic approach to type soundness. </title> <type> Technical Report TR91-160, </type> <institution> Department of Computer Science, Rice University, </institution> <month> Apr. </month> <year> 1991. </year>
Reference-contexts: My proof is a syntactic one in the style of Wright and Felleisen <ref> [130] </ref>. The basic idea is to show that every well-formed program e of type is a value of type , or else there exists a unique e 0 (modulo ff-conversion), such that e steps to e 0 and e 0 has type .
Reference: [131] <author> A. K. Wright. </author> <title> Polymorphism for imperative languages without imperative types. </title> <type> Technical Report TR93-200, </type> <institution> Department of Computer Science, Rice University, </institution> <month> Feb. </month> <year> 1993. </year>
Reference-contexts: The value restriction has been proposed by others [63, 57, 82] as a way to avoid the well-known problems of polymorphism and refs, exceptions, continuations, and other constructs that have computational effects. Furthermore, according to a study performed by Wright <ref> [131] </ref>, most SML code naturally obeys the value restriction. The few cases he found that do not, are easily transformed so that they do meet this restriction. The other restriction on core SML code involves datatypes.
Reference: [132] <author> A. K. Wright and R. Cartwright. </author> <title> A practical soft type system for Scheme. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 250-262, </pages> <address> Orlando, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: None of these approaches supports unboxed mutable data, or generally unboxed datatypes. Furthermore, they do not address type classes, marshaling, or garbage collection. Of a broadly similar nature is the work on "soft" type systems <ref> [64, 7, 29, 132] </ref>. Here, ML-style type inference or set constraints are used to eliminate type-tag checks in dynamically typed languages such as Scheme. Morrison, et al. [97] described an implementation of Napier that passed types at run time to determine the behavior of polymorphic operations. <p> For example, the conventional argument flattener of TIL fails to flatten many functions that the type-directed flattener does flatten. Even without programmer-supplied type information, the advances in soft typing <ref> [64, 7, 29, 132] </ref> provide a means for compiler writers to take advantage of types. In general, compilers and other kinds of system software have real issues and problems that can serve as the clients and driving force behind the development of advanced type systems.
References-found: 132

