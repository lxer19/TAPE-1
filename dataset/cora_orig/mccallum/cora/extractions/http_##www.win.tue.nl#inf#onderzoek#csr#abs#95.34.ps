URL: http://www.win.tue.nl/inf/onderzoek/csr/abs/95.34.ps
Refering-URL: http://www.win.tue.nl/inf/onderzoek/publicaties.html
Root-URL: http://www.win.tue.nl
Email: e-mail janz@win.tue.nl  
Title: Record concatenation with intersection types  
Author: Jan Zwanenburg 
Date: December 20, 1995  
Address: P.O.Box 513, 5600 MB Eindhoven, The Netherlands  
Affiliation: Department of Mathematics and Computing Science Eindhoven University of Technology  
Abstract: We define an extension of a second-order type system with records and operations on them, including record concatenation. Our aim is to model the most important concepts in object-oriented languages in a type system with subtyping. Such a model needs a form of record concatenation. The novelty in our approach is that intersection types are used for record concatenation. We give examples of how object-oriented concepts can be modelled and show how the system can be translated to a type system without subtyping. 
Abstract-found: 1
Intro-found: 1
Reference: [BCGS 91] <author> Val Breazu-Tannen, Thierry Coquand, Carl A. Gunter & Andre Scedrov. </author> <title> Inheritance as Implicit Coercion. </title> <note> Information and Computation 93. Also in [GM 94]. </note>
Reference-contexts: This leads to a translation of F # , where the coercions are implicit, to F fi , with explicit coercions. F fi is the second-order lambda calculus with cartesian products and labelled types. This translation was given first for F by Breazu-Tannen, Coquand, Gunter, Scedrov <ref> [BCGS 91] </ref>, and for F ^ by Pierce [Pie 91b]. Our translation is an extension of the latter. Such a translation is sometimes called a semantics because any semantics for the target system can be composed with this translation to yield a translation for the source system.
Reference: [BL 90] <author> Kim B. Bruce & Giuseppe Longo. </author> <title> A modest model of records. </title> <note> Information and Computation 87. Also in [GM 94]. </note>
Reference-contexts: Limitations: We would like to make a polymorphic record update, a polymorphic function that changes one field of a record, and leaves all other fields untouched. Examples 5 and 6 try to do this, but don't succeed. In <ref> [BL 90] </ref> is a semantic argument that such a function cannot be made in calculi like this one, and, more generally, a function of type 8XT : X!X must be an identity function. 7 2.4 Top type for The type Top is introduced to recover an F polymorphic function as a
Reference: [Car 88] <author> Luca Cardelli. </author> <title> A Semantics of Multiple Inheritance. </title> <booktitle> Information and Computation 76. </booktitle>
Reference-contexts: E.g. we cannot apply the function of example 2 to fx=3; y=4; z=5g or to fy=4; x=3g. 2.3 Subtyping The standard way to alleviate the rigid typing is to introduce subtyping, see e.g. <ref> [Car 88] </ref> for subtyping on records. Subtyping is a relation between types, denoted by . <p> To implement this, we need to pack the state and methods together and apply a mechanism that hides the state. In the literature two mechanisms for encapsulation have appeared: procedural abstraction (using recursive records, see e.g. <ref> [Car 88] </ref>) and type abstraction. Following [PT 93], we choose for type abstraction, which is formalized in the context of lambda-calculi by existential types [MP 88].
Reference: [Car 92] <author> Luca Cardelli. </author> <title> Extensible Records in a Pure Calculus of Subtyping. </title> <type> Technical Report Number 81, </type> <institution> Systems Research, Digital Equipment Corporation. </institution> <note> Also in [GM 94]. </note>
Reference-contexts: Most introduced a form of disjoint concatenation (only new fields may be added), and a way of restricting records (removing a field). Together these operations can provide a polymorphic update. But the ones that include subtyping <ref> [CM 91, Car 92] </ref> have no full record concatenation, just extension. Alternatives that do have record concatenation [HP 90], do not have subtyping, which is necessary for a natural model of inheritance. Most problems are caused by type variables that represent records. <p> As even for F ^ coherence is not yet proved, the proofs of these conjectures are outside the scope of this article. 5 Conclusions 5.1 Related work Record concatenation First we will compare F # with other explicitly typed second-order record calculi, viz. Cardelli <ref> [Car 92] </ref>, Cardelli and Mitchell [CM 91] and Harper and Pierce [HP 90]. All of these calculi have a restriction operator, denoted by n, that removes a field from a record, and a way of extending a record with one new field. <p> In F # this function is: Rfjx:Intjg; R # fjx:Intjg: r:R: r R with fjx:Intjg fx=r:x + 1g :8Rfjx:Intjg; R # fjx:Intjg: R!R The examples that we will give are largely adapted to our syntax. * In <ref> [Car 92] </ref> Cardelli gives a record calculus based on row-variables. Just as in our system, Cardelli provides a translation of the system with records to a system with only cartesian products. There are two differences. First, his target system includes subtyping whereas ours does not.
Reference: [CD 78] <author> M. Coppo & M. Dezani-Ciancaglini. </author> <title> A new type-assignment for -terms. Archive for Mathematical Logic 19. </title>
Reference-contexts: Alternatives that do have record concatenation [HP 90], do not have subtyping, which is necessary for a natural model of inheritance. Most problems are caused by type variables that represent records. In this paper, we model concatenation by intersection types, developed by Coppo and Dezani-Ciancaglini <ref> [CD 78] </ref>. This choice is based on the fact that, given two record types R and S, the concatenation of R and S should be a subtype of R and a subtype of S. This is one of the defining property of the intersection of R and S.
Reference: [CM 91] <author> Luca Cardelli & John C. Mitchell. </author> <note> Operations on Records. Mathematical Structures in Computer Science 1. Also in [GM 94]. </note>
Reference-contexts: Most introduced a form of disjoint concatenation (only new fields may be added), and a way of restricting records (removing a field). Together these operations can provide a polymorphic update. But the ones that include subtyping <ref> [CM 91, Car 92] </ref> have no full record concatenation, just extension. Alternatives that do have record concatenation [HP 90], do not have subtyping, which is necessary for a natural model of inheritance. Most problems are caused by type variables that represent records. <p> This example is adopted from <ref> [CM 91] </ref>. 7. ` ex6 fjl:fjm:Int; n:Charjg; p:Realjg fl=fm=4; n= 0 a 0 g; p=3:14g : fjl:fjm:Int; n:Charjg; p:Realjg 8. ex7:l:m = 5 9. ` 7 Int with Int 5 : Int^Int this is an unintended, but harmless, consequence of the new compatibility rules: records, however deep, can be updated. <p> As even for F ^ coherence is not yet proved, the proofs of these conjectures are outside the scope of this article. 5 Conclusions 5.1 Related work Record concatenation First we will compare F # with other explicitly typed second-order record calculi, viz. Cardelli [Car 92], Cardelli and Mitchell <ref> [CM 91] </ref> and Harper and Pierce [HP 90]. All of these calculi have a restriction operator, denoted by n, that removes a field from a record, and a way of extending a record with one new field. <p> Each extensible record has a row variable representing the unknown fields of the record. In this example of a polymorphic update: X"x: r:fjx:Int; Xjg: fx=r:x + 1; rnxg :8X"x: fjx:Int; Xjg!fjx:Int; Xjg X is the row-variable representing all fields other than x. * In <ref> [CM 91] </ref> Cardelli and Mitchell give a record calculus where both positive (a record has a field) and negative information (a record doesn't have a field) is determined by the record type. All record values that comply with this information belong to this record type.
Reference: [Com 95] <author> Adriana B. Compagnoni. </author> <title> Higher-Order Subtyping with Intersection Types. </title> <type> Ph.D. thesis, </type> <institution> Catholic University Nijmegen. </institution>
Reference-contexts: These operators are used here to indicate which methods a class has, i.e. to give the interface of a class. So we assume we have a higher order type system instead of second-order. The resulting system is very close to Compagnoni's F ! ^ <ref> [Com 95] </ref>, to which compatibility is added. <p> Typing algorithm For implementation, a typing algorithm is very important. Such a typing algorithm relies on a subtyping and a compatibility algorithm. For the subtyping and typing of similar systems algorithms have been proposed <ref> [Pie 91b, Com 95] </ref>, and adaption seems straightforward, but for compatibility a new algorithm has to be constructed. Just as with subtyping, the rule for transitivity poses the most problems.
Reference: [CP 93] <author> Adriana B. Compagnoni & Benjamin C. Pierce. </author> <title> Multiple Inheritance via Intersection Types. </title> <type> Technical report ECS-LFCS-93-275, </type> <institution> LFCS, University of Edinburgh. </institution> <note> Also available as technical report 93-18, </note> <institution> computer science, Catholic University Nijmegen. </institution>
Reference-contexts: This can also be modelled in our calculus, but falls outside the scope of this article. See [PT 93]. 3.5 Self-reference In this section we will add self-reference to our model of OOP, so it will be fairly complete. This model is based on <ref> [PT 93, CP 93] </ref>, but it is simpler because of the extended underlying calculus. Self-reference is the idea that a method can use the own methods of an object. In particular, a method can use itself, i.e. be recursive. <p> A comparison of both methods can be found in [FM 94], a more theoretic treatment of the similarities and differences in [HP 95]. Our model is the same as the model of Pierce and Turner [PT 93] and Compagnoni and Pierce <ref> [CP 93] </ref>, who chose for the second way, since the combination of subtyping with recursive types is still problematic for modelling inheritance. Because our type system is more powerful, the encoding is simpler. The differences are: 1.
Reference: [CW 85] <author> Luca Cardelli & Peter Wegner. </author> <title> On understanding types, data abstraction and polymorphism. </title> <journal> Computing Surveys 17(4). </journal>
Reference-contexts: Wand [Wan 87] gave a system of extensible records in an implicitly typed language. This was later extended to include concatenation and the type-inference problem was solved [Wan 89]. Cardelli and Wegner <ref> [CW 85] </ref> defined a full second-order, explicitly typed language with records, subtyping and bounded quantification, i.e. an abstraction over a type variable that has to be a subtype of some type. To solve the polymorphic record update problem, more powerful explicitly typed calculi were defined.
Reference: [FM 94] <author> Kathleen Fisher & John C. Mitchell. </author> <booktitle> Notes on typed object-oriented programming. Lecture Notes in Computer Science 789. </booktitle>
Reference-contexts: The first is procedural abstraction, objects are encoded as elements of recursive record types. The second is type abstraction, which hides the type of the state, but permits the invocation of methods that can work on the state. A comparison of both methods can be found in <ref> [FM 94] </ref>, a more theoretic treatment of the similarities and differences in [HP 95].
Reference: [Gir 72] <author> J. Y. Girard. </author> <title> Interpretation fonctionelle et elimination des coupures de l'arith-methique d'ordre superieur. </title> <type> Ph.D. thesis, </type> <institution> Universite Paris VII. </institution> <note> [GM 94] eds. </note> <editor> Carl A. Gunter & John C. Mitchell. </editor> <booktitle> Theoretical Aspects of Object-Oriented Programming. Foundations of Computing Series. </booktitle>
Reference-contexts: In each subsection we will only give the new rules, and designate which old rules are redundant. In appendix A the total system is given. 2.1 Second-order lambda calculus The starting point is F , the second-order lambda calculus <ref> [Gir 72] </ref>. In this calculus it is possible to make polymorphic functions, i.e. functions that work on several types. <p> Extension of language To implement this aspect of inheritance, type operators are very convenient, if not necessary. Type operators are functions from types to types, and are admitted in higher order type systems <ref> [Gir 72] </ref>. These operators are used here to indicate which methods a class has, i.e. to give the interface of a class. So we assume we have a higher order type system instead of second-order.
Reference: [GR 83] <author> A. Goldberg & D. Robson. </author> <title> Smalltalk-80: The Language and Its Implementation. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley. </publisher>
Reference-contexts: For a model of this more symmetrical notion of method invocation, run-time type information is needed. We concentrate on the single-dispatch variants, such as SmallTalk <ref> [GR 83] </ref> and C++. There appeared two ways to model the concept of encapsulation of single-dispatch OO languages in a type-theoretic setting. The first is procedural abstraction, objects are encoded as elements of recursive record types.
Reference: [HP 90] <author> Robert W. Harper & Benjamin C. Pierce. </author> <title> A record calculus based on symmetric Concatenation. </title> <type> Technical report CMU-CS-90-157, </type> <institution> Carnegie Mellon University. </institution>
Reference-contexts: Together these operations can provide a polymorphic update. But the ones that include subtyping [CM 91, Car 92] have no full record concatenation, just extension. Alternatives that do have record concatenation <ref> [HP 90] </ref>, do not have subtyping, which is necessary for a natural model of inheritance. Most problems are caused by type variables that represent records. In this paper, we model concatenation by intersection types, developed by Coppo and Dezani-Ciancaglini [CD 78]. <p> Cardelli [Car 92], Cardelli and Mitchell [CM 91] and Harper and Pierce <ref> [HP 90] </ref>. All of these calculi have a restriction operator, denoted by n, that removes a field from a record, and a way of extending a record with one new field. <p> The very different philosophy makes it impossible to define a disjoint record concatenation, because two records, of whatever type, can always have a field in common. Furthermore this view complicates the semantics of the system. * Harper and Pierce give in <ref> [HP 90] </ref> a calculus with only negative information and with a full concatenation operator on disjoint records. For negative information the same symbol as in F # for compatibility is used, viz. #. This relation expresses that two records are disjoint, so may be concatenated with k.
Reference: [HP 94] <author> Martin Hofmann & Benjamin Pierce. </author> <title> Positive Subtyping. </title> <type> Technical report ECS-LFCS-94-303, </type> <institution> LFCS, University of Edinburgh. </institution>
Reference-contexts: IntReal or contravariant arrow subtyping, but reflexivity, transitivity and record subtyping do transfer. Such a system can be very interesting if only polymorphic updates are needed (but no record concatenation), since the syntax is almost as simple as the standard subtyping syntax. This approach has been taken in <ref> [HP 94] </ref>. Acknowledgments Thanks to Kees Hemerik, Benjamin Pierce and Erik Poll for reading drafts of this article.
Reference: [HP 95] <author> Martin Hofmann & Benjamin Pierce. </author> <title> A Unifying Type-Theoretic Framework for Objects. </title> <journal> Journal of Functional Programming, </journal> <year> 1995. </year>
Reference-contexts: The second is type abstraction, which hides the type of the state, but permits the invocation of methods that can work on the state. A comparison of both methods can be found in [FM 94], a more theoretic treatment of the similarities and differences in <ref> [HP 95] </ref>. Our model is the same as the model of Pierce and Turner [PT 93] and Compagnoni and Pierce [CP 93], who chose for the second way, since the combination of subtyping with recursive types is still problematic for modelling inheritance.
Reference: [MP 88] <author> John C. Mitchell & Gordon D. Plotkin. </author> <title> Abstract Types Have Existential Type. </title> <journal> ACM Transactions on Programming Languages and Systems 10(3). </journal>
Reference-contexts: In the literature two mechanisms for encapsulation have appeared: procedural abstraction (using recursive records, see e.g. [Car 88]) and type abstraction. Following [PT 93], we choose for type abstraction, which is formalized in the context of lambda-calculi by existential types <ref> [MP 88] </ref>.
Reference: [Pie 91a] <author> Benjamin C. Pierce. </author> <title> Programming with Intersection Types, Union Types and Poly-morphism. </title> <type> Technical report CMU-CS-91-205, </type> <institution> Carnegie Mellon University. </institution>
Reference-contexts: It turns out that with (the higher order version of) this system, we can define template classes relatively simple. Variant types A record is seen as an intersection of labeled fields. The dual notion of intersection types are union types <ref> [Pie 91a] </ref>. So it is tempting to see a variant type as the union of labeled fields. We will see however, that this cannot be done in a coherent way. Consider the judgment ` fjl:Intjg^fjm:Charjg fjl:Intjg _ fjm:Charjg.
Reference: [Pie 91b] <author> Benjamin C. Pierce. </author> <title> Programming with Intersection Types and Bounded Polymor-phism. </title> <type> Ph.D. thesis, </type> <institution> Carnegie Mellon University. </institution> <note> Also available as technical report CMU-CS-91-205. </note>
Reference-contexts: F fi is the second-order lambda calculus with cartesian products and labelled types. This translation was given first for F by Breazu-Tannen, Coquand, Gunter, Scedrov [BCGS 91], and for F ^ by Pierce <ref> [Pie 91b] </ref>. Our translation is an extension of the latter. Such a translation is sometimes called a semantics because any semantics for the target system can be composed with this translation to yield a translation for the source system. <p> Clearly, the cartesian product S fi T satisfies this requirement: The coercions are just the projections (here we follow <ref> [Pie 91b] </ref>). So the type fjl:Int; m:Charjg, which is an abbreviation for fjl:Intjg^fjm:Charjg, will be translated as fjl:Intjg fi fjm:Charjg. Suppose e is an F # -term of this type. To type e:l, e has to be coerced to fjl:Intjg (remember the (T-Sel) rule). <p> Typing algorithm For implementation, a typing algorithm is very important. Such a typing algorithm relies on a subtyping and a compatibility algorithm. For the subtyping and typing of similar systems algorithms have been proposed <ref> [Pie 91b, Com 95] </ref>, and adaption seems straightforward, but for compatibility a new algorithm has to be constructed. Just as with subtyping, the rule for transitivity poses the most problems.
Reference: [Pie 94] <author> Benjamin C. Pierce. </author> <title> Bounded Quantification is Undecidable. </title> <note> Information & Computation 112. Also in [Pie 91b] and [GM 94]. </note>
Reference-contexts: There has been a long debate about the (S-All) rule (for a summary, see [SP 94]). The following is considered the most natural rule: ` V U ; XV ` S T (S-All') Unfortunately, the subtyping problem of the system with this rule is undecidable <ref> [Pie 94] </ref>, so we stick to the (S-All) rule. Rule (T-Sel) is a short rule for the selection of a field of a record in a calculus of subtyping and makes the old (T-Sel) rule redundant.
Reference: [PT 93] <author> Benjamin C. Pierce & David N. Turner. </author> <title> Simple Type-Theoretic Foundations For Object-Oriented Programming. </title> <journal> Journal of Functional Programming 4(2). </journal>
Reference-contexts: This encourages separation of tasks. There are different possibilities to determine which method is actually invoked, as we will see later on. We have in figure 1 a small object oriented program in a functional OO language, derived from <ref> [PT 93] </ref>. Normally object-oriented languages are imperative, but a functional variant suits our purposes better. <p> To implement this, we need to pack the state and methods together and apply a mechanism that hides the state. In the literature two mechanisms for encapsulation have appeared: procedural abstraction (using recursive records, see e.g. [Car 88]) and type abstraction. Following <ref> [PT 93] </ref>, we choose for type abstraction, which is formalized in the context of lambda-calculi by existential types [MP 88]. <p> In some OO languages, there is an even stricter sense of encapsulation. Methods of subclasses may not touch the instance variables of superclasses. This can also be modelled in our calculus, but falls outside the scope of this article. See <ref> [PT 93] </ref>. 3.5 Self-reference In this section we will add self-reference to our model of OOP, so it will be fairly complete. This model is based on [PT 93, CP 93], but it is simpler because of the extended underlying calculus. <p> This can also be modelled in our calculus, but falls outside the scope of this article. See [PT 93]. 3.5 Self-reference In this section we will add self-reference to our model of OOP, so it will be fairly complete. This model is based on <ref> [PT 93, CP 93] </ref>, but it is simpler because of the extended underlying calculus. Self-reference is the idea that a method can use the own methods of an object. In particular, a method can use itself, i.e. be recursive. <p> The late binding mechanism means the new setX is used, so a bump on a coloured pointed changes the colour to blue. 3.6 Conclusion The final model is based on Pierce & Turner <ref> [PT 93] </ref>. A class is just an object with enough of the packaging left off, and enough decisions about representation and recursive self-reference postponed, that it can still be extended. <p> A comparison of both methods can be found in [FM 94], a more theoretic treatment of the similarities and differences in [HP 95]. Our model is the same as the model of Pierce and Turner <ref> [PT 93] </ref> and Compagnoni and Pierce [CP 93], who chose for the second way, since the combination of subtyping with recursive types is still problematic for modelling inheritance. Because our type system is more powerful, the encoding is simpler. The differences are: 1.
Reference: [Rey 88] <author> John C. Reynolds. </author> <title> Preliminary design of the programming language Forsythe. </title> <type> Technical report CMU-CS-88-159, </type> <institution> Carnegie Mellon University. </institution>
Reference-contexts: The idea of using intersection types for record concatenation already appeared in Reynolds imperative language Forsythe <ref> [Rey 88] </ref>. In Forsythe there is also a construction to make a value of an intersection type, called merge. Because Reynolds permits only merging with one field, there is no need for a compatibility relation. The restrictions for merge can be expressed directly by the derivation rules.
Reference: [SP 94] <author> Martin Steffen & Benjamin Pierce. </author> <title> Higher-Order Subtyping. </title> <type> Technical Report ECS-LFCS-94-280, </type> <institution> University of Edinburgh. </institution>
Reference-contexts: This relation is called equivalence. Discussion: All rules except (S-All) and the ones for records, viz. (S-Width), (S-Depth), (S-Order) and (T-Sel) are standard. There has been a long debate about the (S-All) rule (for a summary, see <ref> [SP 94] </ref>). The following is considered the most natural rule: ` V U ; XV ` S T (S-All') Unfortunately, the subtyping problem of the system with this rule is undecidable [Pie 94], so we stick to the (S-All) rule.
Reference: [Ste 84] <author> G.L. Steele. </author> <title> Common Lisp: The language. </title> <publisher> Digital Press. </publisher>
Reference-contexts: In delegation based languages an object can be extended to form a new object. We will only study class based languages in this paper. The class based languages have two categories: single-dispatch and multiple dispatch. In multiple-dispatch languages, such as Common Lisp <ref> [Ste 84] </ref>, the method is determined by any number of arguments instead of just one for single-dispatch languages. For a model of this more symmetrical notion of method invocation, run-time type information is needed. We concentrate on the single-dispatch variants, such as SmallTalk [GR 83] and C++.
Reference: [Wan 87] <author> Mitchell Wand. </author> <title> Complete Type inference for Simple Objects Proc. </title> <booktitle> Second IEEE Symp. on Logic in Computer Science. </booktitle>
Reference-contexts: The record concatenation of two records is a new record, that has all the fields that any of the constituents have. This is more flexible than record extension, and is necessary for multiple inheritance (where a class may have more than one superclass). Wand <ref> [Wan 87] </ref> gave a system of extensible records in an implicitly typed language. This was later extended to include concatenation and the type-inference problem was solved [Wan 89]. <p> This approach comes in different flavours. We choose for a concatenation that is permitted only if the types of the common fields are the same, because this gives simple subtyping rules (e.g. S-Inter-LB). The standard flavour in implicitly typed systems is the concatenation that is always permitted <ref> [Wan 87] </ref>. In an explicitly typed system, this would lead to more complex rules. 2.8 Specialized record updating For certain uses, it is desirable to update not only with the same type, but also with a subtype.
Reference: [Wan 89] <author> Mitchell Wand. </author> <title> Type Inference for Record Concatenation and Multiple Inheritance Proc. </title> <booktitle> Fourth IEEE Symp. on Logic in Computer Science. </booktitle>
Reference-contexts: This is more flexible than record extension, and is necessary for multiple inheritance (where a class may have more than one superclass). Wand [Wan 87] gave a system of extensible records in an implicitly typed language. This was later extended to include concatenation and the type-inference problem was solved <ref> [Wan 89] </ref>. Cardelli and Wegner [CW 85] defined a full second-order, explicitly typed language with records, subtyping and bounded quantification, i.e. an abstraction over a type variable that has to be a subtype of some type. To solve the polymorphic record update problem, more powerful explicitly typed calculi were defined.
Reference: [WB 89] <author> Philip Wadler & Stephen Blott. </author> <title> How to make ad-hoc polymorphism less ad-hoc. </title> <booktitle> Sixteenth Annual ACM Conference on Principles of Programming Languages. </booktitle> <pages> 41 </pages>
Reference-contexts: The equality on type A, can be invoked by is A, provided that Eq A is valid. Polymorphic functions can demand that a type variable has an equality, this is comparible to bounded quantification. Eq is an example of a so-called type class, as described by Wadler and Blott <ref> [WB 89] </ref> (the word type class has nothing to do with an object-oriented class). The derivation rules for type classes may be extended, but a few restrictions apply, that prevent the loss of coherence and make type checking for the type classes feasible. Even new type classes can be introduced.
References-found: 26

