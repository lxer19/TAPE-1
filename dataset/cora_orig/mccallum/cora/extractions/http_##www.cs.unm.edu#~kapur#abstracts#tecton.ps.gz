URL: http://www.cs.unm.edu/~kapur/abstracts/tecton.ps.gz
Refering-URL: http://www.cs.unm.edu/~kapur/abstracts/tecton.html
Root-URL: http://www.cs.unm.edu
Phone: 2  
Title: An Overview of the Tecton Proof System  
Author: Deepak Kapur David R. Musser and Xumin Nie 
Note: Partially supported by National Science Foundation Grants CCR-8906678, CDA-8805910, CCR-9308016, and CCR-9303394, and subcontract CB0204 of SRI Contract MDA904-92-C 5186 with The Maryland Procurement Office.  
Address: New York Albany, New York 12222  Troy, New York 12180  
Affiliation: 1 Institute for Programming and Logics Computer Science Department State University of  Computer Science Department Rensselaer Polytechnic Institute  
Abstract:  
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R.M. Akscyn, </author> <title> D.L. McCracken, E.A. Yoder. "KMS: A Distributed Hyperme-dia System for Managing Knowledge in Organizations," </title> <journal> Comm. ACM 31(7): </journal> <pages> pp. </pages> <month> 820-835 (July </month> <year> 1988). </year>
Reference-contexts: The first example is a proof, found automatically by Tecton, of a lemma about the integer remainder function. The proof found by Tecton is shown in Figures 6 and 7, which are pages produced by a prototype user interface implemented using KMS (Knowledge Management System) <ref> [1] </ref>, a commercial hypertext system. The proof contains instances of the following inference mechanisms: cover set induction, reduction, generalization, and splitting. The linear arithmetic procedure was also used as part of the reduction mechanism.
Reference: [2] <author> Avron Barr and Edward A. Feigenbaum, </author> <booktitle> The Handbook of artificial intelligence, </booktitle> <publisher> W. Kaufman, </publisher> <year> 1981. </year>
Reference-contexts: The chosen representation, called a general proof forest|basically a set of "and/or trees" <ref> [2, pp. 39-42] </ref> such as are used in general problem solving strategies|is illustrated in Figure 2 through 4 and is defined precisely below. (An alternative of using a directed acyclic graph was also considered and rejected for reasons that are discussed later.) 2.2.1 Basic proof trees and general proof trees Before
Reference: [3] <author> B-Toolkit: </author> <title> Specification and Design Assistant, User's Manual, </title> <publisher> BP International Ltd., </publisher> <year> 1992. </year>
Reference-contexts: Tecton proofs also typically involve hundreds of primitive inferences, but inference nodes in Tecton proof forests organize large groups of primitive inferences into meaningful macro inference steps. 29 6.1.3 Automatic versus interactive proof The B-toolkit <ref> [3] </ref>, a collection of software tools designed to support development of software systems using the B-method, includes two theorem provers, called the auto prover and inter prover. The auto prover uses built-in tactics and a standard library of definitions, theorems and lemmas about well-known mathematical structures to discharge proof obligations.
Reference: [4] <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic Handbook. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1988. </year> <month> 34 </month>
Reference-contexts: The third is the power of its mechanisms for automating many steps of proofs, which are based principally on earlier work on rewriting and mathematical induction methods from two previous systems, our own Rewrite Rule Laboratory (RRL) [27] and the Boyer-Moore prover <ref> [4] </ref>. In this paper we describe these proof structuring, displaying and automation features, including our motivations for some of the main design decisions. <p> For these reasons, we have not tried to integrate higher-order constructs in Tecton. Tecton's inference engine is similar in its objectives and style to Boyer and Moore's theorem prover <ref> [4] </ref>, in that both theorem provers provide rewriting, heuristics for proofs by induction, and a decision procedure for linear arithmetic.
Reference: [5] <author> R.S. Boyer and J S. Moore, </author> <title> "Integrating Decision Procedures into Heuristic Theorem Provers: A Case Study of Linear Arithmetic," </title> <booktitle> Machine Intelligence 11 (1988) 83-157. </booktitle>
Reference-contexts: The subclass decided consists of Presburger formulas that, when placed in prenex form, contain only universal quantifiers. Boyer and Moore incorporated a similar rational-based procedure into their heuristic theorem prover <ref> [5] </ref>. Our implementation is heavily influenced by the work of Boyer and Moore. The core of the decision procedure is Fourier's algorithm for deciding linear inequalities over the rationals. The extension attempts to generate implicit equalities that are transformed into rewrite rules for simplification and elimination.
Reference: [6] <author> J. Conklin, </author> <title> "Hypertext: An Introduction and Survey," </title> <booktitle> IEEE Computer 2(9): </booktitle> <pages> pp. </pages> <month> 17-41 </month> <year> (1987). </year>
Reference: [7] <author> R. Constable, et al., </author> <title> Implementing Mathematics with the Nuprl Proof Development System, </title> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference-contexts: LCF [14, 36] and several LCF-influenced systems, including Nuprl <ref> [7] </ref>, HOL [15], Isabelle [38], and Lego [29], use tactics, which are programs for reducing a goal to a list of subgoals.
Reference: [8] <author> N. Dershowitz, </author> <title> "Termination of rewriting", </title> <journal> J. </journal> <note> Symbolic Computation 3: pp 69-116 (1987). </note>
Reference-contexts: Rewrite rules are formed by Tecton using a term ordering to determine which side of an equation to take as the left hand side of a rule so that the rewriting sequences generated by such rules are always finite. The ordering used is called lexicographic recursive path ordering (lrpo) <ref> [8] </ref>. (For equations not orientable by lrpo, it is possible for a user to manually orient equations into rewrite rules; but, then there is a danger of rewriting not terminating.
Reference: [9] <author> R.W. Erickson and D.R. Musser, </author> <title> "The AFFIRM theorem prover: proof forests and management of large proofs," </title> <booktitle> 5th Conference on Automated Deduction, Lecture Notes in Computer Science, </booktitle> <volume> Vol. 87, </volume> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1980. </year>
Reference-contexts: In its present form it is noteworthy mainly for three features. One is the way it represents and manages proofs internally in flexible structures called proof forests, allowing records of multiple complete or incomplete proof attempts to be retained (an extension of the proof forest notion of <ref> [9] </ref>). The second is the structured external display format the system uses to present proofs to the user, using tables, graphics, and hypertext links. <p> When we need to make the distinction, we speak of "unproved lemmas" (conjectures without complete proofs) or "proved lemmas" (conjectures that have been proved and are therefore valid) <ref> [9] </ref>. 7 Definition 5 Define on a proof forest F a directed graph G, called the induced dependency graph of F , by including a directed arc from each node of F to each of its children and, additionally, from each inference node to any node used as a lemma. <p> An interested reader may consult [19]. 6.1 Proof construction and representation 6.1.1 Basic proof management issues The approach to proof structure and management used in Tecton is based in part on the notion of proof forests supported in the Affirm system <ref> [9] </ref>. Other systems that are similar in their proof support to Affirm include the proof assistants of the Mural [30], EVES [10], and PVS [35]. Mural allows users to introduce their own inference rules that can be used in a proof even if the inference rule is not yet proved.
Reference: [10] <author> D. Craigen, et al, </author> <title> "Eves system description," </title> <booktitle> Proc. Automated Deduction - CADE-11, </booktitle> <publisher> LNAI 607, Springer Verlag, </publisher> <year> 1992, </year> <pages> 766-775. </pages>
Reference-contexts: Other systems that are similar in their proof support to Affirm include the proof assistants of the Mural [30], EVES <ref> [10] </ref>, and PVS [35]. Mural allows users to introduce their own inference rules that can be used in a proof even if the inference rule is not yet proved. As in Affirm and Tecton, proofs can be attempted top-down, bottom-up or in a mixed strategy.
Reference: [11] <author> C. George, </author> <title> "The RAISE specification language: a tutorial," </title> <booktitle> Proc. of VDM'91, Formal Software Development Methods, </booktitle> <publisher> LNCS 552, Springer Verlag, Vol. </publisher> <address> 2, </address> <year> 1991, </year> <pages> 239-319. </pages>
Reference-contexts: The RAISE language is a wide spectrum language for "very abstract, initial specifications and also for concrete development of initial specifications that can be easily (or even automatically) translated into a programming language" <ref> [11] </ref>. The RAISE Toolset [12] includes a justification editor for simplifying expressions and expanding goals into subgoals, to be used for interactively developing justifications for correctness of a specification.
Reference: [12] <author> The CRI Raise Tools Group, </author> <title> "The Raise Toolset," </title> <booktitle> Proc. of VDM '91, Formal Software Development Methods, </booktitle> <publisher> LNCS 551, Springer Verlag, Vol. </publisher> <address> 1, </address> <year> 1991, </year> <pages> 689-690. </pages>
Reference-contexts: The RAISE language is a wide spectrum language for "very abstract, initial specifications and also for concrete development of initial specifications that can be easily (or even automatically) translated into a programming language" [11]. The RAISE Toolset <ref> [12] </ref> includes a justification editor for simplifying expressions and expanding goals into subgoals, to be used for interactively developing justifications for correctness of a specification.
Reference: [13] <author> J. A. Goguen, T. Winker, J. Meseguer, K. Futatsugi, and J.-P. Jouannaud, </author> <note> "Introducing OBJ," to appear in J.A. Goguen, </note> <editor> D. Coleman, and R. Gallimore (editors). </editor> <title> Applications of Algebraic Specification using OBJ, </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: However, we have designed a new language, also named Tecton [19], in which we attempt to unify and simplify previous research with similar goals, mainly drawing from research on abstract data types and from previous formal specification languages that emphasized behavioral abstraction, including mainly OBJ <ref> [13] </ref>, Larch [16], and an earlier Tecton language design attempt [23, 24]. We have recently begun developing a Tecton Specification Processor that together with the Tecton Proof System should provide strong support for using formal methods on generic software and hardware design components.
Reference: [14] <author> M. J. Gordon, R. Milner, and C. P. </author> <title> Wadsworth, </title> <publisher> Edinburgh LCF, LNCS 78, Springer Verlag, </publisher> <year> 1979. </year>
Reference-contexts: The PVS and EVES also maintain a tree of goals and subgoals, but without provision for alternative inferences. 6.1.2 Goals, subgoals, and tactics in LCF-style systems Some form of top-down transformation of goals into subgoals is provided by several other natural deduction style provers. LCF <ref> [14, 36] </ref> and several LCF-influenced systems, including Nuprl [7], HOL [15], Isabelle [38], and Lego [29], use tactics, which are programs for reducing a goal to a list of subgoals.
Reference: [15] <author> M. J. Gordon, </author> <title> "A Proof Generating System for Higher Order Logic," VLSI Specification, Verification and Synthesis, </title> <editor> G. Birtwistle and P.A. Subra-manhanyam, eds., Kluwer, G. Birtwistle and P.A. Subramanhanyam, eds., </editor> <publisher> Kluwer, </publisher> <year> 1987. </year>
Reference-contexts: LCF [14, 36] and several LCF-influenced systems, including Nuprl [7], HOL <ref> [15] </ref>, Isabelle [38], and Lego [29], use tactics, which are programs for reducing a goal to a list of subgoals. <p> The latter is a function that, when 28 applied to a list of theorems, produces a theorem that "achieves" the original goal g (see <ref> [15, Section 7.1] </ref> for the precise sense in which a theorem achieves a goal). The theorems to which the justification is applied are those theorems that achieve the subgoals g 1 ; : : : ; g n .
Reference: [16] <author> J. V. Guttag and J. J. Horning, </author> <title> "Report on the Larch Shared Language," </title> <journal> Sci. Comput. Program., </journal> <volume> vol. 6, no. 2, </volume> <pages> pp. 103-134, </pages> <month> Mar. </month> <year> 1986. </year>
Reference-contexts: However, we have designed a new language, also named Tecton [19], in which we attempt to unify and simplify previous research with similar goals, mainly drawing from research on abstract data types and from previous formal specification languages that emphasized behavioral abstraction, including mainly OBJ [13], Larch <ref> [16] </ref>, and an earlier Tecton language design attempt [23, 24]. We have recently begun developing a Tecton Specification Processor that together with the Tecton Proof System should provide strong support for using formal methods on generic software and hardware design components.
Reference: [17] <author> J. Guttag, et. al., </author> <title> Larch: Languages and Tools for Formal Specification. Texts and Monographs in Computer Science, </title> <publisher> Springer Verlag, </publisher> <year> 1993. </year> <month> 35 </month>
Reference-contexts: The inference engine of the Tecton system is also related to the Larch prover <ref> [17] </ref> in that both theorem provers accept function definitions as terminating rewrite rules. The Larch prover provides a user access to a variety of inference methods, but many appear to require more interaction than Tecton.
Reference: [18] <author> C.A.R. Hoare, </author> <title> "An Axiomatic Basis for Computer Programming," </title> <journal> Comm. </journal> <note> ACM 12 (10) (1969) 576-583. </note>
Reference-contexts: Within this framework, the Tecton Proof System is an experimental tool for constructing proofs of first order logic formulas and of program specifications expressed using formulas in Hoare's axiomatic proof formalism <ref> [18] </ref>. In its present form it is noteworthy mainly for three features. One is the way it represents and manages proofs internally in flexible structures called proof forests, allowing records of multiple complete or incomplete proof attempts to be retained (an extension of the proof forest notion of [9]). <p> rule, a derived inference rule, or a basic inference mechanism, as described in the following subsections. 13 4.1 Primitive and derived inference rules for Hoare for- mulas In the current Tecton Proof System, the only explicit use of primitive and derived rules on inference nodes are applications of Hoare rules <ref> [18] </ref> for eliminating program structure from Hoare formulas. Hoare formulas are used to express properties of programs, by relating program statements to assertions expressed in first order logic.
Reference: [19] <author> D. Kapur and D.R. Musser, Tecton: </author> <title> a framework for specifying and verifying generic system components, </title> <institution> Rensselaer Polytechnic Institute Computer Science Technical Report 92-20, </institution> <month> July, </month> <year> 1992. </year> <title> Invited talk at TPCD Conf. 1992 (Theorem Provers in Circuit Design), </title> <institution> University of Nijmegen, The Nether-lands, </institution> <month> June 22-24, </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Tecton (Greek for "builder") is a methodology and tool set for formal specification and verification of computational systems (both hardware designs and software) <ref> [19, 20, 23, 24, 21] </ref>. In formulating the goals of Tecton and designing its tools, we are seeking to combine many of the key advances in specification and proof technology, from both the authors' and many others' work on earlier specification language and proof systems. <p> The major weakness of the system is its specification language, which is essentially just traditional first order logic and Hoare 1 formulas. However, we have designed a new language, also named Tecton <ref> [19] </ref>, in which we attempt to unify and simplify previous research with similar goals, mainly drawing from research on abstract data types and from previous formal specification languages that emphasized behavioral abstraction, including mainly OBJ [13], Larch [16], and an earlier Tecton language design attempt [23, 24]. <p> For this reason it is somewhat difficult to discuss their reasoning tools in isolation. However, we will refrain from comparing the Tecton specification language with other specification languages and systems, as such a comparison is outside the scope of this paper. An interested reader may consult <ref> [19] </ref>. 6.1 Proof construction and representation 6.1.1 Basic proof management issues The approach to proof structure and management used in Tecton is based in part on the notion of proof forests supported in the Affirm system [9]. <p> The Tecton Proof System is an experimental system and is only one component of the broader Tecton framework we envision. The following are the other components we are working to design, develop, and integrate: * The Tecton specification language <ref> [19] </ref>, a high level language for describing and using abstract concepts in formal software development and hardware design. * A proof command language for interactively guiding the construction of large, complex proofs, allowing the user to keep control of proof development while making effective use of the automated deduction capabilities of <p> The syntax and semantics are such that a corresponding proof theory requires only first order and inductive proof methods, rather than general higher order techniques as required in some frameworks. The current design of the language and some of the main proof issues are described in <ref> [19] </ref>, which also contains a substantial example of its use in hardware design|a behavioral and structural description of a carry-lookahead adder circuit, with the circuit realization given in terms of a generic parallel-prefix circuit.
Reference: [20] <author> D. Kapur and D.R. Musser, </author> <title> Examples of Tecton concept descriptions, </title> <note> in preparation. </note>
Reference-contexts: 1 Introduction Tecton (Greek for "builder") is a methodology and tool set for formal specification and verification of computational systems (both hardware designs and software) <ref> [19, 20, 23, 24, 21] </ref>. In formulating the goals of Tecton and designing its tools, we are seeking to combine many of the key advances in specification and proof technology, from both the authors' and many others' work on earlier specification language and proof systems. <p> Hierarchies of concepts useful for symbolic algebra systems as well as for linear data structures are discussed in <ref> [20] </ref>. An example of specification and verification of a generic software component|an efficient partitioning algorithm|may be found in [25]. We have also implemented and are currently experimenting with a simple proof command language.
Reference: [21] <author> D. Kapur, D.R. Musser and X. Nie, </author> <title> "The Tecton Proof System," chapter in Formal Methods in Databases and Software Engineering, </title> <editor> Alagar, Laksh-manan, Sadri, eds., </editor> <booktitle> Workshop in Computing Series, </booktitle> <publisher> Springer Verlag (1993) 54-79. </publisher>
Reference-contexts: 1 Introduction Tecton (Greek for "builder") is a methodology and tool set for formal specification and verification of computational systems (both hardware designs and software) <ref> [19, 20, 23, 24, 21] </ref>. In formulating the goals of Tecton and designing its tools, we are seeking to combine many of the key advances in specification and proof technology, from both the authors' and many others' work on earlier specification language and proof systems. <p> I Internal Proof Structure Layout Used on Tecton Screens motivation for the format are sketched only briefly here; further detail may be found in <ref> [21, 22] </ref>. 3.2.1 First order logic formulas Formulas of first order logic are displayed in two column tables, with each row of a formula table representing an implication A oe C, where A (assumptions) and C (conclusions) are the conjunctions of the atomic formulas in the left and right columns of
Reference: [22] <author> D. Kapur, D.R. Musser and X. Nie, </author> <title> The Tecton Proof System: Introduction and User's Guide, Institute for Programming and Logic, </title> <institution> State University of New York (1991). </institution>
Reference-contexts: I Internal Proof Structure Layout Used on Tecton Screens motivation for the format are sketched only briefly here; further detail may be found in <ref> [21, 22] </ref>. 3.2.1 First order logic formulas Formulas of first order logic are displayed in two column tables, with each row of a formula table representing an implication A oe C, where A (assumptions) and C (conclusions) are the conjunctions of the atomic formulas in the left and right columns of <p> The Hoare rules used in Tecton are mostly conventional and their soundness is easily justified in terms of a formalization of the usual conditional correctness semantics. The current Tecton Proof System has inference rules for the following statement types <ref> [22] </ref>: assignment, composition, conditional, while, declare, release, abort, null, choose (nondeterministic choice), and exchange. Some of these are illustrated in the sample proof in Section 5.
Reference: [23] <author> D. Kapur, D.R. Musser, and A.A. Stepanov, </author> <title> "Operators and algebraic structures," </title> <booktitle> Proc. of Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> Portsmouth, New Hampshire (1981). </address>
Reference-contexts: 1 Introduction Tecton (Greek for "builder") is a methodology and tool set for formal specification and verification of computational systems (both hardware designs and software) <ref> [19, 20, 23, 24, 21] </ref>. In formulating the goals of Tecton and designing its tools, we are seeking to combine many of the key advances in specification and proof technology, from both the authors' and many others' work on earlier specification language and proof systems. <p> new language, also named Tecton [19], in which we attempt to unify and simplify previous research with similar goals, mainly drawing from research on abstract data types and from previous formal specification languages that emphasized behavioral abstraction, including mainly OBJ [13], Larch [16], and an earlier Tecton language design attempt <ref> [23, 24] </ref>. We have recently begun developing a Tecton Specification Processor that together with the Tecton Proof System should provide strong support for using formal methods on generic software and hardware design components.
Reference: [24] <author> D. Kapur, D.R. Musser, and A. A. Stepanov, "Tecton: </author> <title> a language for manipulating generic objects," </title> <booktitle> Proc. of Program Specification Workshop, </booktitle> <institution> University of Aarhus, Denmark, </institution> <month> August </month> <year> 1981, </year> <note> Lecture Notes in Computer Science, Springer-Verlag, Vol. 134 (1982). </note>
Reference-contexts: 1 Introduction Tecton (Greek for "builder") is a methodology and tool set for formal specification and verification of computational systems (both hardware designs and software) <ref> [19, 20, 23, 24, 21] </ref>. In formulating the goals of Tecton and designing its tools, we are seeking to combine many of the key advances in specification and proof technology, from both the authors' and many others' work on earlier specification language and proof systems. <p> new language, also named Tecton [19], in which we attempt to unify and simplify previous research with similar goals, mainly drawing from research on abstract data types and from previous formal specification languages that emphasized behavioral abstraction, including mainly OBJ [13], Larch [16], and an earlier Tecton language design attempt <ref> [23, 24] </ref>. We have recently begun developing a Tecton Specification Processor that together with the Tecton Proof System should provide strong support for using formal methods on generic software and hardware design components.
Reference: [25] <author> D. Kapur, D.R. Musser, and C. Wang, </author> <title> Specification and verification of a generic partitioning algorithm, </title> <note> in preparation. </note>
Reference-contexts: Hierarchies of concepts useful for symbolic algebra systems as well as for linear data structures are discussed in [20]. An example of specification and verification of a generic software component|an efficient partitioning algorithm|may be found in <ref> [25] </ref>. We have also implemented and are currently experimenting with a simple proof command language.
Reference: [26] <author> D. Kapur and X. Nie, </author> <title> Reasoning about numbers in Tecton, </title> <institution> Department of Computer Science, State University of New York, Albany, </institution> <address> NY 12222, </address> <month> March </month> <year> 1994. </year>
Reference-contexts: mainly from RRL, including the use of inference rules for Hoare proof rules involving programs, inference mechanisms used to prove first-order formulas arising in specification analysis and in building theories, and the integration into the theorem prover of a decision procedure for universally quantified Presburger arithmetic with uninterpreted function symbols <ref> [26] </ref>. Section 5 contains brief examples from Tecton proofs, and Section 6 compares the main features of Tecton with other proof approaches. <p> For completeness, it is also essential to superpose subterms in a goal with the defining rewrite rules of interpreted function symbols, but that is also not implemented. A detailed 20 description of the decision procedure and related issues is given in <ref> [26] </ref>. 4.5 Overall inference mechanism We can now describe the overall general inference mechanism Tecton uses to attempt to prove a formula.
Reference: [27] <author> D. Kapur and H. Zhang, </author> <title> "An overview of Rewrite Rule Laboratory (RRL)," </title> <note> to appear in a special issue of Computers in Math. with Applications, 1994. Earlier descriptions appeared in CADE-88 and RTA-89. </note>
Reference-contexts: The third is the power of its mechanisms for automating many steps of proofs, which are based principally on earlier work on rewriting and mathematical induction methods from two previous systems, our own Rewrite Rule Laboratory (RRL) <ref> [27] </ref> and the Boyer-Moore prover [4]. In this paper we describe these proof structuring, displaying and automation features, including our motivations for some of the main design decisions.
Reference: [28] <author> R.A. Kemmerer, </author> <title> "Verification Assessment Study Final Report", </title> <type> Vols. 1-5, </type> <institution> National Computer Security Center, Fort George G. Meade, Maryland. </institution>
Reference-contexts: Most of the time, proof attempts exist in a partially completed state, and the user spends most of his or her effort trying to comprehend the current state of the attempt in order to guide the system towards a complete proof <ref> [28] </ref>. Multiple goals with incomplete proofs typically coexist, and it may sometimes be useful to maintain several distinct attempts to prove the same goal. Much like software, successful proof attempts can be reused. Related theorems have related proofs.
Reference: [29] <author> Z. Luo, and R. Pollack, </author> <title> Lego Proof Development System: User's Manual, </title> <institution> Department of Computer Science, Univ. of Edinburgh, </institution> <month> May </month> <year> 1992. </year> <month> 36 </month>
Reference-contexts: LCF [14, 36] and several LCF-influenced systems, including Nuprl [7], HOL [15], Isabelle [38], and Lego <ref> [29] </ref>, use tactics, which are programs for reducing a goal to a list of subgoals. From a goal g, which is a formula, and a list of formulas regarded as assumptions, a tactic produces a list of subgoals g 1 ; : : : ; g n and a justification. <p> Proofs in Isabelle are performed by a generalization of resolution using higher-order unification, which is undecidable. Lego <ref> [29] </ref> is another interactive proof checker based on type theory in the natural deduction style, but Lego does not seem to support tactics. An interesting aspect of Lego is that it has been used to encode, among other formal systems, specification languages Z and VDM.
Reference: [30] <author> R. Moore, </author> <title> "Machine support for formal methods: an overview of Mural," </title> <type> Un--published Manuscript, </type> <institution> Dept. of Computer Science, University of Manchester, Manchester, UK, </institution> <year> 1992. </year>
Reference-contexts: Other systems that are similar in their proof support to Affirm include the proof assistants of the Mural <ref> [30] </ref>, EVES [10], and PVS [35]. Mural allows users to introduce their own inference rules that can be used in a proof even if the inference rule is not yet proved. As in Affirm and Tecton, proofs can be attempted top-down, bottom-up or in a mixed strategy.
Reference: [31] <author> D.R. Musser, </author> <title> Elements of a Pragmatic Approach to Program Verification, </title> <institution> Rensselaer Polytechnic Institute Computer Science Department TR 89-24 (1989). </institution>
Reference-contexts: using abstract concepts in formal software development and hardware design. * A proof command language for interactively guiding the construction of large, complex proofs, allowing the user to keep control of proof development while making effective use of the automated deduction capabilities of the system. * A program modeling language <ref> [31] </ref> capable of modeling crucial features in production programming languages, such as Ada and C++, for building libraries of generic software components: encapsulation, templates/generics, and class inheritance.
Reference: [32] <author> D.R. Musser and A.A. Stepanov, </author> <title> The Ada Generic Library: Linear List Processing Packages, </title> <publisher> Springer-Verlag Compass Series (1989). </publisher>
Reference-contexts: By abstracting behavior and carefully engineering interfaces, we can produce software or hardware design building blocks, or generic components <ref> [32] </ref>, that are much more easily composable and widely usable than the specialized components usually constructed in current practice.
Reference: [33] <author> G. Nelson and D.C. Oppen, </author> <title> "Simplification by Cooperating Decision Procedures," </title> <note> ACM Transactions on Programming Languages and Systems 1 (2) (1979) 245-257. </note>
Reference-contexts: This close interaction makes our procedure different from and more useful than stand-alone procedures such as discussed in [39]. This interaction by equality sharing is a powerful method to combine different decision procedures <ref> [33] </ref> and has made the linear procedure more useful. Tecton does not implement a complete decision procedure for linear arithmetic. No attempt is made to check whether any derived equality on integer terms is satisfiable.
Reference: [34] <editor> T. Nipkow and L.C. Paulson, "Isabelle-91," </editor> <booktitle> Proc. Automated Deduction - CADE-11, </booktitle> <publisher> LNAI 607, Springer Verlag, </publisher> <year> 1992, </year> <pages> 673-677. </pages>
Reference: [35] <author> S. Owre,, J.M. Rushby, and N. Shankar, "PVS: </author> <title> A Prototype Verification System," </title> <booktitle> Proc. Automated Deduction - CADE-11, </booktitle> <address> Saratoga Springs, </address> <publisher> LNAI 607, Springer Verlag, </publisher> <year> 1992, </year> <pages> 748-752. </pages>
Reference-contexts: Details and 2 We are also developing alternative visual representations as part of a project to provide a graphical/hypertext interface to SRI's PVS proof-checker <ref> [35] </ref>. 11 G 1 G 2 G n G 2 G ... <p> Other systems that are similar in their proof support to Affirm include the proof assistants of the Mural [30], EVES [10], and PVS <ref> [35] </ref>. Mural allows users to introduce their own inference rules that can be used in a proof even if the inference rule is not yet proved. As in Affirm and Tecton, proofs can be attempted top-down, bottom-up or in a mixed strategy. <p> As a consequence, the user must often carry out proofs in excruciating detail. The inference engine of PVS does contain a collection of decision procedures for ground theories <ref> [35] </ref>, but rewriting is not fully automated. The rewriting capability in HOL is adapted from the LCF implementation of rewriting [37].
Reference: [36] <author> L.C. Paulson, </author> <title> Interactive theorem proving with Cambridge LCF: a user's manual, </title> <type> Technical Report 80, </type> <institution> Computer Laboratory, University of Cam-bridge, </institution> <address> Cambridge, England, </address> <year> 1985. </year>
Reference-contexts: The PVS and EVES also maintain a tree of goals and subgoals, but without provision for alternative inferences. 6.1.2 Goals, subgoals, and tactics in LCF-style systems Some form of top-down transformation of goals into subgoals is provided by several other natural deduction style provers. LCF <ref> [14, 36] </ref> and several LCF-influenced systems, including Nuprl [7], HOL [15], Isabelle [38], and Lego [29], use tactics, which are programs for reducing a goal to a list of subgoals.
Reference: [37] <author> L.C. Paulson, </author> <title> "A Higher-Order Implementation of Rewriting," </title> <booktitle> Science of Computer Programming, </booktitle> <year> 1983. </year>
Reference-contexts: As a consequence, the user must often carry out proofs in excruciating detail. The inference engine of PVS does contain a collection of decision procedures for ground theories [35], but rewriting is not fully automated. The rewriting capability in HOL is adapted from the LCF implementation of rewriting <ref> [37] </ref>.
Reference: [38] <author> L.C. Paulson, </author> <title> Introduction to Isabelle, </title> <institution> Computer Laboratory, University of Cambridge, </institution> <address> England, </address> <year> 1993. </year>
Reference-contexts: LCF [14, 36] and several LCF-influenced systems, including Nuprl [7], HOL [15], Isabelle <ref> [38] </ref>, and Lego [29], use tactics, which are programs for reducing a goal to a list of subgoals. <p> The rationale sometimes given for not keeping a record of inference steps is that it would grow too large; e.g., "an Isabelle proof typically involves hundreds of primitive inferences and would be unintelligible if displayed" <ref> [38] </ref>.
Reference: [39] <author> R.E. Shostak, </author> <title> "A Practical Decision Procedure for Arithmetic with Function Symbols," </title> <note> Journal of ACM 26(2) (1979) 351-360. </note>
Reference-contexts: This close interaction makes our procedure different from and more useful than stand-alone procedures such as discussed in <ref> [39] </ref>. This interaction by equality sharing is a powerful method to combine different decision procedures [33] and has made the linear procedure more useful. Tecton does not implement a complete decision procedure for linear arithmetic. No attempt is made to check whether any derived equality on integer terms is satisfiable.
Reference: [40] <author> L. Thery, Y. Bertot, and G. Kahn, </author> <title> "Real theorem provers deserve real user-interfaces," </title> <institution> University of Cambridge report, </institution> <month> May, </month> <year> 1992. </year>
Reference-contexts: The theorems and lemmas used in proofs are not readily available with the proofs and have to be looked up in an often large list of mostly irrelevant theorems and lemmas. Most systems still use a teletype or text-editor-buffer style interface. (See also <ref> [40] </ref> for a general discussion of improving interfaces to theorem provers.) In Tecton our approach for escaping such limitations combines a structured internal representation of proofs and proof attempts with proof visualization methods using graphics, hypertext links, and tabular formats. <p> As previously noted, however, such large tactics are not by themselves adequate for human understanding; to show the details of the proof, tactics have to be broken back down into a sequence of smaller tactics or tactics that are then replayed to see the subgoals they produce. Thery <ref> [40] </ref> discusses principles for providing graphical interfaces to proof checkers in general, and in particular to the HOL system.
Reference: [41] <author> H. Zhang, D. Kapur, </author> <title> and M.S. Krishnamoorthy, "A Mechanizable Induction Principle for Equational Specifications," </title> <booktitle> Proc. of Ninth International Conference on Automated Deduction (CADE-9), </booktitle> <address> Argonne, IL (1988). </address>
Reference-contexts: For example, given a goal A oe C 1 ^ C 2 ^ ^ C n , the split mechanism produces subgoals A oe C i , for i = 1; : : : ; n. 4.2.4 Induction Tecton uses the cover set induction mechanism <ref> [41] </ref>. Many heuristics are used to choose an induction variable. In fact, the choice of an induction variable is determined by selecting a subterm whose definition is used to generate an induction scheme for the data structure (s) appearing in the domain of the subterm.
Reference: [42] <author> H. Zhang, </author> <title> "Implementing contextual rewriting," </title> <booktitle> in: Proc. Third International Workshop on Conditional Term Rewriting Systems, </booktitle> <editor> J. L. Remy and M. Rusinowitch (eds.), </editor> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 656, </volume> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992, </year> <pages> pp. 363-377. 37 </pages>
Reference-contexts: Also built into reduce are transformations and simplifications based on the logical axioms used by Tecton. Use of these transformations is not indicated on the inference node. For conditional rewrite rules, Tecton uses contextual rewriting; examples illustrating contextual rewriting and its power are discussed in detail in <ref> [42] </ref>.
References-found: 42

