URL: http://www.daimi.aau.dk/~andrzej/papers/DCaCD.ps.Z
Refering-URL: http://www.daimi.aau.dk/~andrzej/papers/
Root-URL: http://www.daimi.aau.dk
Email: email: andrzej@diku.dk  
Title: Declarative Continuations and Categorical Duality  
Author: Andrzej Filinski 
Date: August 10, 1989  
Address: Universitetsparken 1, DK-2100 Copenhagen O, Denmark  
Affiliation: DIKU Computer Science Department, University of Copenhagen  
Abstract: DIKU Report 89/11 Abstract This thesis presents a formalism for reasoning about continuations in a categorical setting. It points out how values and continuations can be seen as categorically dual concepts, and that this symmetry extends to not only data types, but also control structures, evaluation strategies and higher-order constructs. The central idea is a view of continuations as a declarative concept, rather than an imperative one, and the implications of this make up the spine of the presentation. A symmetrical extension of the typed -calculus is introduced, where values and continuations are treated as opposites, permitting a mirror-image syntax for dual categorical concepts like products and coproducts. An implementable semantic description and a static type system for this calculus are given. A purely categorical description of the language is also obtained, through a correspondence with a system of combinatory logic, similar to a cartesian closed category, but with a completely symmetrical set of axioms. Finally, a number of possible practical applications and directions for further research are suggested. 
Abstract-found: 1
Intro-found: 1
Reference: [ANSI 78] <author> American National Standard: </author> <title> Programming Language FORTRAN. </title> <institution> American National Standards Institute (1978). ANSI Std. X3.9-1978. </institution>
Reference: [ANSI 83] <institution> The Programming Language ADA Reference Manual. American National Standards Institute (1983). ANSI/MIL-STD-1815A-1983, </institution> <note> LNCS 155. </note>
Reference: [Appel & Jim 89] <author> Andrew W. Appel and Trevor Jim: </author> <title> Continuation-Passing, Closure-Passing Style. </title> <booktitle> In Proceedings of the Sixteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 293-302, </pages> <note> Austin, Texas (January 1989). </note>
Reference-contexts: This is somewhat closer to the SLC approach, precisely because the primitives are conceptually simpler. An example is of this organization is the callcc facility found in newer versions of Standard ML of New Jersey (NJML) <ref> [Appel & Jim 89] </ref>. However, this still insists on treating continuations as values, which actually makes the SLC definitions of the primitives slightly more complicated than Scheme's call/cc.
Reference: [Arbib & Manes 75] <author> Michael A. Arbib and Ernest G. Manes: </author> <title> Arrows, Structures and Functors: The Categorical Imperative. </title> <publisher> Academic Press, </publisher> <address> London (1975). </address>
Reference: [Backus 78] <author> John Backus: </author> <title> Can Programming be Liberated from the von Neumann Style? Communications of the ACM, </title> <type> 21 </type> <month> 613-641 </month> <year> (1978). </year>
Reference: [Baker 79] <author> Henry G. Baker, Jr.: </author> <title> Shallow Binding in LISP 1.5. </title> <booktitle> In Artificial Intelligence: An MIT Perspective, </booktitle> <volume> Vol. 2, </volume> <pages> pp. 375-387, </pages> <publisher> MIT Press (1979). </publisher>
Reference: [Blikle & Tarlecki 83] <author> Andrzej Blikle and Andrzej Tarlecki: </author> <title> Naive Denotational Semantics. In Information Processing 83, </title> <editor> R. E. A. Mason (ed.), </editor> <booktitle> pp. </booktitle> <pages> 345-355, </pages> <publisher> IFIP (1983). </publisher>
Reference: [Cardelli 84] <author> Luca Cardelli: </author> <title> A Semantics of Multiple Inheritance. </title> <booktitle> In Proceedings of International Symposium on the Semantics of Data Types, </booktitle> <pages> pp. </pages> <month> 51-67 </month> <year> (1984). </year> <note> LNCS 173. </note>
Reference-contexts: In other languages, specifications form the basis of class definitions. As examples of this kind we note Trellis/Owl [Schaffert et al. 86] and the language presented in <ref> [Cardelli 84] </ref>. Here, it is the behavior of a class, not its set of instance variables or methods that determines its place in the type hierarchy. The specification subclassing relation may be explicit or implicit. In the former case, a class specification explicitly names its superclass. <p> For example, it only has eager coproducts (), unlike the classical LL, which also has objects ("inverted &") which seem to correspond to the lazy coproducts of pure CBN. Furthermore, unlike the CAM, the LAM does not deal with general recursion. * <ref> [Cardelli 84] </ref> investigates the symmetry between products and coproducts as related to inheritance, and a number of his ideas about types and subtyping have influenced section 4.1.2. The type system and the subtyping relation he presents is in fact completely symmetrical in products and coproducts.
Reference: [Curien 86] <author> P-L. Curien: </author> <title> Categorical Combinators, Sequential Algorithms and Functional Programming. </title> <booktitle> Research Notes in Theoretical Computer Science, </booktitle> <volume> Vol. 1, </volume> <publisher> Pitman (1986). </publisher>
Reference-contexts: the language need not impede parallelization, precisely because flow of control becomes explicit, so that independent pieces of the computation may be easier to detect. * SCL as an abstract machine: With some refinements, the SCL might be used as the basis of an abstract machine, similar to the CAM <ref> [Curien 86] </ref>, but with a firm categorical foundation for handling "imperative" aspects of control flow, s.a. run-time errors, escapes, etc. In fact, a CBV version of SLC might be more natural for traditional architectures than the CAM, whose theoretical background seems to imply availability of proper products and exponentials. <p> However, because it concentrates exclusively on values, the symmetry is not perfect. For example, the construct `merge', suggested as the dual to `case' is not really its mirror image, neither syntactically nor semantically. * <ref> [Curien 86] </ref> builds on the equivalence between -calculusand CCCs (or more precisely, C-monoids). One result is a set of categorical combinators leading to an efficient implementation (the Categorical Abstract Machine, CAM).
Reference: [Dahl et al. 70] <author> Ole-Johan Dahl, Bjorn Myhrhaug, and Kristen Nygaard: </author> <title> Simula: Common Base Language. </title> <note> Norwegian Computing Center (October 1970). </note>
Reference-contexts: This suggests that it may sometimes be advantageous to think of a problem in SLC terms, and then translate it into Scheme or NJML. We shall see one such situation in section 4.3.3. Finally, let us note that facilities like coroutines in Simula 67 <ref> [Dahl et al. 70] </ref> or tasking in Ada are also closely related to persistent continuations, because the activation records are heap-allocated. <p> The perhaps best-known object-oriented language Smalltalk [Goldberg & Robson 83] has a purely implementation-based class organization. The specification class of an object is determined implicitly by the set of messages it accepts (without error). Classes in languages like Simula <ref> [Dahl et al. 70] </ref> and C++ [Stroustrup 86] are also based on common implementation but use (often pro forma) implementation subclassing to express specification conformance as well: the possibility of different instance types with the same properties is expressed through virtual member functions, i.e., methods in the implementation superclass that are
Reference: [Damas & Milner 82] <author> L. Damas and Robin Milner: </author> <title> Principal Type-schemes for Functional Languages. </title> <booktitle> In Proceedings of the Ninth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. </pages> <month> 207-212 (January </month> <year> 1982). </year>
Reference: [Danvy & Filinski 89] <author> Olivier Danvy and Andrzej Filinski: </author> <title> A Functional Abstraction of Typed Contexts. </title> <institution> DIKU Rapport 89/12, Computer Science Department, University of Copenhagen, Copenhagen, </institution> <address> Denmark (July 1989). </address>
Reference: [Dijkstra 68] <author> Edger W. Dijkstra: </author> <title> Goto Statement Considered Harmful. </title> <journal> Communications of the ACM, </journal> <month> 11(3) (March </month> <year> 1968). </year> <month> 98 </month>
Reference: [Felleisen 88] <author> Matthias Felleisen: </author> <title> The Theory and Practice of First-Class Prompts. </title> <booktitle> In Proceedings of the Fifteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 180-190, </pages> <address> San Diego, California (January 1988). </address>
Reference: [Filinski 89] <author> Andrzej Filinski: </author> <title> Declarative Continuations: An Investigation of Duality in Programming Language Semantics. </title> <booktitle> In Proceedings of Summer Conference on Category Theory and Computer Science, </booktitle> <address> Manchester, U.K. </address> <month> (September </month> <year> 1989). </year> <note> To appear in LNCS. </note>
Reference: [Friedman & Wise 76] <author> Daniel P. Friedman and David S. Wise: </author> <title> CONS Should Not Evaluate its Arguments. In Automata, Languages, and Programming, </title> <editor> S. Michaelson and R. </editor> <booktitle> Milner (eds.), </booktitle> <pages> pp. 257-284, </pages> <publisher> Edinburgh University Press, Edinburgh, </publisher> <address> Scotland (1976). </address>
Reference: [Girard 87] <author> Jean-Yves Girard: </author> <title> Linear Logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 50 </volume> <month> 1-102 </month> <year> (1987). </year>
Reference-contexts: Furthermore, the work does not seem to consider at all the "other side" of category theory, e.g., coproducts, which are equally important in a practical language. 93 * <ref> [Girard 87] </ref> presents a formalism called Linear Logic, which exhibits many similarities with SCL. It has a form of negation as a fundamental primitive, and this induces a question/answer symmetry similar to SCL's. However, this work (on classical linear logic) appears to involve only proof theory, not general computation.
Reference: [Goldberg & Robson 83] <author> Adele Goldberg and David Robson: </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley (1983). </publisher>
Reference-contexts: As we have mentioned, the concepts of specification and implementation inheritance are often tightly interwoven, and different languages group them in various ways. We will try, however, to separate them as much as possible. The perhaps best-known object-oriented language Smalltalk <ref> [Goldberg & Robson 83] </ref> has a purely implementation-based class organization. The specification class of an object is determined implicitly by the set of messages it accepts (without error).
Reference: [Gries 81] <editor> David Gries: </editor> <booktitle> The Science of Programming. Texts and Monographs in Computer Science, </booktitle> <publisher> Springer-Verlag (1981). </publisher>
Reference-contexts: This also seems strongly connected with the view of statements in an imperative language as either state or predicate transformers <ref> [Gries 81] </ref>. Typically, dual analyses will concern dual evaluation strategies. For example, strictness analysis [Hughes 87] in CBV would be meaningless, as all functions are strict.
Reference: [Hagino 87a] <author> Tatsuya Hagino: </author> <title> A Categorical Programming Language. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, Edinburgh, </institution> <address> Scotland (1987). ECS-LFCS-87-38. </address>
Reference-contexts: It would be very interesting to see if the framework presented in <ref> [Hagino 87a] </ref>, where virtually all of the structure is defined through adjunctions, could be extended to encompass continuations. From the other side, maybe the value/continuation duality could present categorical concepts s.a. pushouts and pullbacks in a new light. <p> Yet no-one seems to have combined all three ideas. In this section, we will point out some of this work, and compare it to the present approach. * <ref> [Hagino 87a] </ref> uses category theory to obtain a symmetrical language. He starts with very few primitive concepts, and builds virtually all of the type structure and programming constructs as categorical adjoints. The dialgebra approach gives a nice formulation of recursive types and primitive recursion.
Reference: [Hagino 87b] <author> Tatsuya Hagino: </author> <title> A Typed Lambda Calculus with Categorical Type Constructors. </title> <booktitle> In Proc. Summer Conference on Category Theory and Computer Science, </booktitle> <pages> pp. 141-156, </pages> <note> Edinburgh (1987). LNCS 283. </note>
Reference-contexts: Although the left adjoint to the coproduct functor (i.e., coexpo-nentials) can be easily expressed in the general notation, it is not a valid construct in the "computable" subset of the language. Also, the restriction to primitive recursion, although seldom a problem, excludes a number of applications, s.a. interpreters. <ref> [Hagino 87b] </ref> also proposes a symmetric extension to ML, similar to the one discussed in section 4.1. However, because it concentrates exclusively on values, the symmetry is not perfect.
Reference: [Harper et al. 88] <author> Robert Harper, Robin Milner, and Mads Tofte: </author> <title> The Definition of Standard ML, </title> <type> Version 2. Report ECS-LFCS-88-62, </type> <institution> University of Edinburgh, Edinburgh, </institution> <note> Scotland (August 1988). </note>
Reference: [Hewitt 79] <author> Carl Hewitt: </author> <title> Control Structure as Patterns of Passing Messages. </title> <booktitle> In Artificial Intelligence: An MIT Perspective, </booktitle> <volume> Vol. 2, </volume> <pages> pp. 434-465, </pages> <publisher> MIT Press (1979). </publisher>
Reference-contexts: Again, the summands of a co-object can be context-typed, so that messages sent to it can contain "return addresses" as well as input data. In fact, the actors in <ref> [Hewitt 79] </ref> are more like co-objects than objects, because they are associated with properties rather than instances as in other object-oriented languages. 4.4.2 Specification inheritance The other main characteristic of OOP is the concept of inheritance.
Reference: [Hewitt et al. 74] <editor> Carl Hewitt et al.: </editor> <title> Behavioral Semantics of Nonrecursive Control Structures. </title> <booktitle> In Proceedings of Programming Symposium, </booktitle> <publisher> B. Robinet (ed.), </publisher> <pages> pp. 385-407, </pages> <address> Paris, France (April 1974). </address> <publisher> LNCS 19. </publisher>
Reference-contexts: In this section, we will consider a more complicated problem, involving higher-order SLC concepts. The example can still be considered in Scheme or NJML, or a language with similar capabilities for heap-allocating activation records, e.g., Simula coroutines or Ada tasking. The same-fringe problem <ref> [Hewitt et al. 74] </ref> is a well-known example of the use of coroutines. The problem is to decide whether two binary trees (e.g., as defined in the previous example) have the same sequence of values at the leaves in a left-to-right traversal.
Reference: [Hughes 87] <author> John Hughes: </author> <title> Analysing Strictness by Abstract Interpretation of Continuations. In Abstract Interpretation of Declarative Languages, </title> <editor> Samson Abramsky and Chris Hankin (eds.), </editor> <booktitle> chapter 4, </booktitle> <publisher> Ellis Horwood (1987). </publisher>
Reference-contexts: This also seems strongly connected with the view of statements in an imperative language as either state or predicate transformers [Gries 81]. Typically, dual analyses will concern dual evaluation strategies. For example, strictness analysis <ref> [Hughes 87] </ref> in CBV would be meaningless, as all functions are strict. It would rather be replaced by totality analysis, which could be used to ensure that transformations involving the conditional axioms did not change the meaning of the program.
Reference: [Hughes 88] <author> John Hughes: </author> <title> Backwards Analysis of Functional Programs. In Partial Evaluation and Mixed Computation, </title> <editor> D. Bjorner, A. P. Ershov, and N. D. Jones (eds.), </editor> <booktitle> pp. </booktitle> <pages> 187-208, </pages> <publisher> North-Holland (1988). </publisher>
Reference-contexts: However, it seems that more advanced analyses than the ones sketched here are also possible. In particular, higher-order programs would be treated by considering abstract closures and contexts. A number of the other analyses suggested in <ref> [Hughes 88] </ref> also seem to fit well into the SLC/SCL framework. 4.6 Other directions for further research As mentioned before, this investigation is not yet very deep.
Reference: [Huwig & Poigne 86] <author> Hagen Huwig and Axel Poigne: </author> <title> A Note on Inconsistencies Caused by Fix-points in a Cartesian Closed Category (1986). </title> <type> Unpublished manuscript. </type>
Reference: [Iverson 62] <author> K. E. Iverson: </author> <title> A Programming Language. </title> <publisher> John Wiley and Sons (1962). </publisher>
Reference: [Jensen & Wirth 74] <author> Kathleen Jensen and Niklaus Wirth: </author> <title> PASCAL: User Manual and Report. </title> <publisher> Springer-Verlag (1974). LNCS 18. </publisher> <pages> 99 </pages>
Reference: [Lafont 88] <author> Yves Lafont: </author> <title> The Linear Abstract Machine. </title> <journal> Theoretical Computer Science, </journal> <volume> 59 </volume> <month> 157-180 </month> <year> (1988). </year>
Reference-contexts: Another important difference with SCL is that the latter does not consider a type and its negation as two different objects in the same category, but expresses the duality through the morphism structure instead. On the other hand, the Linear Abstract Machine <ref> [Lafont 88] </ref> builds on intuitionistic linear logic, in an essentially bicartesian closed category (i.e., CCC with coproducts). Also it gives a traditional computational model in terms of values.
Reference: [Lambek & Scott 86] <author> Joachim Lambek and P.J. Scott: </author> <title> Introduction to Higher Order Categorical Logic. </title> <booktitle> Cambridge studies in advanced mathematics, </booktitle> <volume> Vol. 7, </volume> <publisher> Cambridge University Press (1986). </publisher>
Reference: [MacLane 71] <author> Saunders MacLane: </author> <title> Categories for the Working Mathematician. Graduate Texts in Mathematics, </title> <journal> Vol. </journal> <volume> 5, </volume> <publisher> Springer-Verlag (1971). </publisher>
Reference: [Manes & Arbib 86] <author> Ernest G. Manes and Michael A. Arbib: </author> <title> Algebraic Approaches to Program Semantics. Texts and Monographs in Computer Science, </title> <publisher> Springer-Verlag (1986). </publisher>
Reference-contexts: In particular, the implicit equality between a type and its recursive definition will probably have to be replaced by a named isomorphism. Moreover, the existence of recursive values and continuations of a given type seems closely connected with the existence of initial and final fixpoints of the type-defining functor <ref> [Manes & Arbib 86, chapt. 10,11] </ref>, and this will have to be investigated.
Reference: [McCarthy et al. 62] <editor> John McCarthy et al.: </editor> <title> LISP 1.5 Programmer's Manual. </title> <publisher> MIT Press, </publisher> <address> Cam-bridge, Massachusetts (1962). </address>
Reference: [Moggi 89] <author> Eugenio Moggi: </author> <title> Computational Lambda-calculus and Monads. </title> <booktitle> In Proceedings of 4th Conference on Logic in Computer Science, </booktitle> <pages> pp. 14-23, </pages> <note> IEEE (1989). </note>
Reference: [Naur 62] <author> Peter Naur (ed.): </author> <title> Revised Report on the Algorithmic Language Algol 60. </title> <journal> Communications of the ACM, </journal> <volume> 6(1) </volume> <month> 1-17 </month> <year> (1962). </year>
Reference: [Peyton Jones 87] <editor> Simon L. Peyton Jones: </editor> <booktitle> The Implementation of Functional Programming Languages. Prentice-Hall (1987). </booktitle>
Reference: [Plotkin 75] <author> Gordon D. Plotkin: </author> <title> Call-by-name, Call-by-value and the -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <month> 125-159 </month> <year> (1975). </year>
Reference: [Poigne 83] <author> Axel Poigne: </author> <title> On Semantic Algebras: Higher Order Structures (1983). </title> <type> Unpublished manuscript. </type>
Reference: [Rees & Clinger 86] <editor> Jonathan Rees and William Clinger (eds.): </editor> <title> Revised 3 Report on the Algorithmic Language Scheme. </title> <journal> SIGPLAN Notices, </journal> <volume> 21(12) </volume> <month> 37-79 (December </month> <year> 1986). </year>
Reference: [Reynolds 72] <author> John C. Reynolds: </author> <title> Definitional Interpreters for Higher-Order Programming Languages. </title> <booktitle> In Proceedings 25th ACM National Conference, </booktitle> <pages> pp. 717-740, </pages> <address> New York (1972). </address>
Reference-contexts: be no meaningful continuation, by making q return a null-typed result: call=cc 0 j k ( k # (f ) f " (fg ( k)) : [[A ! 0] ! A] ! A A slight syntactic variation on call/cc consists of performing the binding with a special form, e.g., escape <ref> [Reynolds 72] </ref>, T's catch (not to be confused with MacLisp catch), etc.
Reference: [Rydeheard & Burstall 88] <author> David E. Rydeheard and Rod M. Burstall: </author> <title> Computational Category Theory. </title> <publisher> Prentice Hall International Series in Computer Science, Prentice Hall (1988). </publisher>
Reference: [Sato & Tamaki 89] <author> Taisuke Sato and Hisao Tamaki: </author> <title> Existential Continuation. </title> <journal> New Generation Computing, </journal> <volume> 6 </volume> <month> 421-438 </month> <year> (1989). </year>
Reference-contexts: For reasoning about the control aspects of logic programming, e.g., backtracking, continuations could be a natural tool. In fact, the SLC/SCL already contains elements of backtracking, as witnessed by functions like pa. Some work on continuations in a logic programming framework has already been undertaken by <ref> [Sato & Tamaki 89] </ref>. The bidirectional data flow in Prolog predicates may also be strongly connected with the view of functions as either value or request transformers in SLC. 92 * Parallelism: The SLC/SCL has been presented in an inherently sequential way.
Reference: [Schaffert et al. 86] <author> Craig Schaffert, Topher Cooper, Bruce Bullis, Mike Kilian, and Carrie Wilpolt: </author> <title> An Introduction to Trellis/Owl. </title> <booktitle> In Proceedings of OOPSLA'86, </booktitle> <pages> pp. </pages> <month> 9-16 </month> <year> (1986). </year>
Reference-contexts: In other languages, specifications form the basis of class definitions. As examples of this kind we note Trellis/Owl <ref> [Schaffert et al. 86] </ref> and the language presented in [Cardelli 84]. Here, it is the behavior of a class, not its set of instance variables or methods that determines its place in the type hierarchy. The specification subclassing relation may be explicit or implicit.
Reference: [Schmidt 86] <author> David A. Schmidt: </author> <title> Denotational Semantics: A Methodology for Language Development. </title> <publisher> Allyn and Bacon, Inc. </publisher> <year> (1986). </year>
Reference: [Sethi & Tang 80] <author> Ravi Sethi and Adrian Tang: </author> <title> Constructing Call-by-Value Continuation Semantics. </title> <journal> Journal of the ACM, </journal> <volume> 27(3) </volume> <month> 580-597 (July </month> <year> 1980). </year>
Reference: [Stoy 77] <author> Joseph E. Stoy: </author> <title> Denotational Semantics: The Scott-Strachey Approach to Programming Language Theory. </title> <publisher> MIT Press (1977). </publisher> <pages> 100 </pages>
Reference: [Strachey & Wadsworth 74] <author> Christopher Strachey and Christopher P. Wadsworth: </author> <title> Continuations: </title>
References-found: 48

