URL: http://www.csc.ncsu.edu/faculty/riely/papers/98TR-partial.ps.gz
Refering-URL: http://www.csc.ncsu.edu/faculty/riely/
Root-URL: http://www.csc.ncsu.edu
Title: Trust and Partial Typing in Open Systems of Mobile Agents  
Author: James Riely and Matthew Hennessy 
Address: Brighton BN1 9QH ISSN 13503170  
Date: 4/98 6 July 1998  
Affiliation: UNIVERSITY OF SUSSEX COMPUTER SCIENCE  Computer Science School of Cognitive and Computing Sciences University of Sussex  
Pubnum: Report  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> M. Abadi and A. D. Gordon. </author> <title> A calculus for cryptographic protocols: The spi calculus. </title> <type> Technical Report 414, </type> <institution> University of Cambridge Computer Laboratory, </institution> <month> January </month> <year> 1997. </year>
Reference-contexts: Any treatment of open systems must assume some underlying security mechanisms for communication between sites, or locations. One approach would be to add security features directly in the language, as in Abadi and Gordon's Spi calculus <ref> [1] </ref>. In such languages code signatures and nonces are directly manipulable as program objects. Here we take a more abstract approach, presenting a secure semantics for a language without explicit security features. <p> It is straightforward to design a static type system to enforce this constraint. 4 However such an approach is very restrictive without some addition to the language. One possibility would be to introduce the notion of signed values (possibly based on <ref> [1] </ref>) which would allow certain values in an agent to be received (and typed) under a different authority than that of the agent itself. Even without full progress, signatures could be useful.
Reference: [2] <author> Martjn Abadi. </author> <title> Secrecy by typing in security protocols. </title> <type> Draft, </type> <year> 1997. </year> <note> Available from http://www.research.digital.com/SRC/personal/Martin_ Abadi/home.html. </note>
Reference-contexts: Another area of related work has to do with static methods for analyzing the security of information flow <ref> [9, 2, 8, 24, 11] </ref>. Although this area of research shares our general aims there is very little technical overlap with our approach to resource protection in open systems. Acknowledgments.
Reference: [3] <author> R. Amadio and S. Prasad. </author> <title> Localities and failures. </title> <booktitle> In Proc. 14th Foundations of Software Technology and Theoretical Computer Science, volume 880 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Several other distributed variants of the p-calculus have been defined, and it is informative to see how partial typing might be added to these languages. Syntactically, Dp is most similar to the language of Amadio and Prasad <ref> [3, 4] </ref>, which also uses a goto operator for thread movement, written spawn (`; P). However, in Amadio and Prasad's language, the set of resources available to a thread does not vary as the thread moves about the network.
Reference: [4] <author> Roberto Amadio. </author> <title> An asynchronous model of locality, failure, and process mobility. In COORDINATION '97, </title> <booktitle> volume 1282 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: For example locfputi:reshinti; geti:reshinti; putl:reshloci; getl:reshlocig is the type of a location with four resources, two for manipulating integers and two for manipulating location names. A feature which distinguishes Dp from related languages <ref> [10, 4, 23] </ref> is that resource names have only local significance, i.e. resource names are unique locally, but not globally across the network. This property reflects the open-ended nature of open systems such as the internet. <p> The fact that resource names are not assigned unique locations is crucial to the success of our strategy for dynamic typechecking. It would be difficult to see how to formulate our approach while maintaining the assumption that each name had a unique location (as, for example, in <ref> [4] </ref>). For example, suppose that the resource a was uniquely located at k. Then the agent mJgoto `: b!hm [a]iK at the bad site m could hijack a using (thread-self 2 ), convincing ` that a was uniquely located at m, rather than some good location k. <p> Several other distributed variants of the p-calculus have been defined, and it is informative to see how partial typing might be added to these languages. Syntactically, Dp is most similar to the language of Amadio and Prasad <ref> [3, 4] </ref>, which also uses a goto operator for thread movement, written spawn (`; P). However, in Amadio and Prasad's language, the set of resources available to a thread does not vary as the thread moves about the network. <p> To add partial typing to such a language, one would need to typecheck messages dynamically, rather than threads, violating the third principle given in the introduction. In addition, the fact that names are assigned unique locations in <ref> [4] </ref> appears to be incompatible with partial typing, as outlined at the end of Section 4.1. Trust and Partial Typing in Open Systems of Mobile Agents 30 The join calculus of Fournet, Gonthier, Levy, Marganget and Remy [10] shares many of these properties.
Reference: [5] <author> L. Cardelli and A. D. Gordon. </author> <title> Mobile ambients. </title> <editor> In Maurice Nivat, editor, </editor> <booktitle> Proc. FOS-SACS'98, International Conference on Foundations of Software Science and Computation Structures, volume 1378 of Lecture Notes in Computer Science, </booktitle> <pages> pages 140 155. </pages> <publisher> Springer-Verlag, </publisher> <year> 1998. </year>
Reference-contexts: In Dp, the type system ensures that the extent of resource names in subject position is local, i.e. resources may be referenced at remote sites, but may only be used locally. Cardelli and Gordon's ambient calculus <ref> [5] </ref>, on the other hand, appears to be amenable to partial typing since ambient movement is a local operation; thus the problem of universal extent does not arise.
Reference: [6] <author> Luca Cardelli. </author> <title> A language with distributed scope. </title> <booktitle> Computing Systems, </booktitle> <address> 8(1):2759, </address> <month> January </month> <year> 1995. </year> <note> A preliminary version appeared in Proceedings of the 22nd ACM Symposium on Principles of Programming. </note>
Reference-contexts: The former would be similar to our locations, the later, our resources. This discipline would open the possibility of typing code during in and out operations, rather than open. Several studies have addressed the issue of static typing for languages with remote resources; some recent papers are <ref> [20, 6, 22] </ref>. Perhaps the work closest to ours is that of Knabe [14], who has implemented an extension of Facile which supports mobile agents. The main extensions are remote signatures and proxy structures, which recall our location types. None of these works address open systems, however.
Reference: [7] <author> Luca Cardelli and Andrew Gordon. Ambient decor. </author> <type> Draft, </type> <year> 1998. </year>
Reference-contexts: The typing system of Dp is based on the original sorting system of the p-calculus [16], and this sorting system has recently been extended to the ambient calculus <ref> [7] </ref>. Whereas locations in Dp have a straightforward analog in implementations they correspond to address spaces the notion of ambient is more general, adding expressiveness while blurring the distinction between agent movement and agent interaction.
Reference: [8] <author> Mads Dam. </author> <title> Proving trust in systems of second-order processes. </title> <booktitle> In Hawaii International Conference on Systems Science. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <year> 1998. </year>
Reference-contexts: Another area of related work has to do with static methods for analyzing the security of information flow <ref> [9, 2, 8, 24, 11] </ref>. Although this area of research shares our general aims there is very little technical overlap with our approach to resource protection in open systems. Acknowledgments.
Reference: [9] <author> D. Denning. </author> <title> Certification of programs for secure information flow. </title> <journal> Communications of the ACM, </journal> <volume> 20:504513, </volume> <year> 1977. </year>
Reference-contexts: Another area of related work has to do with static methods for analyzing the security of information flow <ref> [9, 2, 8, 24, 11] </ref>. Although this area of research shares our general aims there is very little technical overlap with our approach to resource protection in open systems. Acknowledgments.
Reference: [10] <author> C. Fournet, G. Gonthier, J.J. Levy, L. Marganget, and D. Remy. </author> <title> A calculus of mobile agents. </title> <editor> In U. Montanari and V. Sassone, editors, </editor> <booktitle> CONCUR: Proceedings of the International Conference on Concurrency Theory, volume 1119 of Lecture Notes in Computer Science, </booktitle> <pages> pages 406421, </pages> <address> Pisa, </address> <month> August </month> <year> 1996. </year> <note> Springer-Verlag. </note>
Reference-contexts: For example locfputi:reshinti; geti:reshinti; putl:reshloci; getl:reshlocig is the type of a location with four resources, two for manipulating integers and two for manipulating location names. A feature which distinguishes Dp from related languages <ref> [10, 4, 23] </ref> is that resource names have only local significance, i.e. resource names are unique locally, but not globally across the network. This property reflects the open-ended nature of open systems such as the internet. <p> In addition, the fact that names are assigned unique locations in [4] appears to be incompatible with partial typing, as outlined at the end of Section 4.1. Trust and Partial Typing in Open Systems of Mobile Agents 30 The join calculus of Fournet, Gonthier, Levy, Marganget and Remy <ref> [10] </ref> shares many of these properties. Whereas Amadio's language adds thread movement to message movement, however, the join calculus adds location movement. Unfortunately this does not help combat the problems outlined above, which result from the universal extent of resource names in both subject and object position.
Reference: [11] <author> Nevin Heintz and Jon G. Riecke. </author> <title> The SLam calculus: Programming with secrecy and integrity. </title> <booktitle> In Conference Record of the ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Diego, </address> <month> January </month> <year> 1998. </year> <title> ACM Press. Trust and Partial Typing in Open Systems of Mobile Agents 35 </title>
Reference-contexts: Another area of related work has to do with static methods for analyzing the security of information flow <ref> [9, 2, 8, 24, 11] </ref>. Although this area of research shares our general aims there is very little technical overlap with our approach to resource protection in open systems. Acknowledgments.
Reference: [12] <author> Matthew Hennessy and James Riely. </author> <title> Resource access control in systems of mobile agents. </title> <institution> Computer Science Technical Report 2/98, University of Sussex, </institution> <year> 1998. </year> <note> Available from http://www.cogs.susx.ac.uk/. </note>
Reference-contexts: 1 Introduction In <ref> [12] </ref> we presented a type system for controlling the use of resources in a distributed system, or network. <p> Such type violations may lead to core dumps, information leakage or the spread of viruses and other virtual pestilence. We study these issues in the formal setting of Dp <ref> [12] </ref>, a distributed variant of the p-calculus [17]. In Dp resources reside at locations and mobile agents may move from site to site, interacting via local resources to affect computations. The typing system of Dp is based on location types which describe the resources available at a site. <p> The paper ends with a brief survey of related work. 2 The Language and Standard Typing In this section we review the syntax and standard semantics of Dp. For a full treatment of the language, including many examples, see <ref> [12] </ref>. Our formalization of the language differs slightly from that of [12], as discussed in the conclusion. 2.1 Syntax The syntax is given in Table 1, although discussion of types, T, is postponed to Section 2.3. <p> For a full treatment of the language, including many examples, see <ref> [12] </ref>. Our formalization of the language differs slightly from that of [12], as discussed in the conclusion. 2.1 Syntax The syntax is given in Table 1, although discussion of types, T, is postponed to Section 2.3. <p> The first two agents are running at location `, the third at location k. Moreover Q and R share knowledge of a private resource a of type T, allocated at ` and unknown to P. NOTATION. We adopt several notational conventions, as in <ref> [12] </ref>. * In the concrete syntax, goto u has greater binding power than composition. Thus `goto k: P j Q' should be read `(goto k: P) j Q'. We adopt several standard abbreviations. For example, we routinely drop type annotations when they are not of interest. <p> In this paper we use the simple type language from <ref> [12, x5] </ref>, extended with base types. However all of the results in this paper extend smoothly to the more powerful type system of [12, x6], which includes resource capabilities and non-trivial subtyping on resource types. <p> In this paper we use the simple type language from [12, x5], extended with base types. However all of the results in this paper extend smoothly to the more powerful type system of <ref> [12, x6] </ref>, which includes resource capabilities and non-trivial subtyping on resource types. <p> Location types are essentially the same as standard record types, and we identify location types up to reordering of their fields. Thus locfa:A; b:Bg = locfb:B; a:Ag. We write `loc' for `locf g'. The subtyping preorder (T &lt; : S) is discussed at length in <ref> [12] </ref>. On base types and channel types there is no nontrivial subtyping; for example, reshTi &lt; : reshT 0 i if and only if T = T 0 . <p> The more general case is straightforward, but requires a more complex treatment of location types, as in <ref> [12] </ref>. <p> So for G as defined above, G (z) = locfa:A 0 g whereas G (u) is undefined. The standard typing system is defined in Table 3. This is the type system from <ref> [12, x5] </ref>, with a few notational changes and the addition of base types. We implicitly assume in all rules that the environment G is well-formed and that each type on the right-hand-side of the turnstile is closed; i.e. we do not allow variables to appear in location types in terms. <p> Further examples are given in <ref> [12] </ref> where we argue that the more general rule is crucial for typing many practical applications. The typing system satisfies several standard properties such as type specialization, weakening and a substitution lemma, as described in [12]. <p> Further examples are given in <ref> [12] </ref> where we argue that the more general rule is crucial for typing many practical applications. The typing system satisfies several standard properties such as type specialization, weakening and a substitution lemma, as described in [12]. The following result establishes that well-typed terms are free of runtime errors throughout their execution. THEOREM 2.4 (SUBJECT REDUCTION FOR THE STANDARD SEMANTICS). If G ` N and N ! N 0 then G ` N 0 . Proof. <p> The following result establishes that well-typed terms are free of runtime errors throughout their execution. THEOREM 2.4 (SUBJECT REDUCTION FOR THE STANDARD SEMANTICS). If G ` N and N ! N 0 then G ` N 0 . Proof. See <ref> [12, Theorem 5.1] </ref>. fl Trust and Partial Typing in Open Systems of Mobile Agents 12 3 Partial Typing The purpose of this paper is to study systems in which only a subset of agents are known to be well typed. <p> Here we describe the runtime errors captured by our system, which can be informally described as misuse of resources at good sites. Often the formulation of runtime errors is quite cumbersome as it involves the invention of a tagged version of the language, see <ref> [12, 21] </ref>. However in this case the presence of filters makes it straightforward. In Table 6 we define, for each location ` a unary predicate err ` ! over networks. <p> Finally, we added webs of trust to the language, reducing the need for dynamic typechecking while retaining type safety at good sites. The presentation of Dp given here differs somewhat from that of <ref> [12] </ref>; for example, we have added base types and moved some of the semantic rules from the structural equivalence to the reduction relation. Most of the changes are stylistic rather than substantive. Two of the changes, however, are essential for the treatment of partial typing. <p> The proofs of both results, and the accompanying lemmas, can easily be derived from those found in <ref> [12] </ref>; in particular see Lemmas 4.7 and A.2, Proposition 4.5 and Theorem 5.1 of that paper. The only substantial differences are in the rules (r f -comm) and (r f move), which we discuss below. For the most part, the proof for (r f -comm) follows that given in [12]. <p> in <ref> [12] </ref>; in particular see Lemmas 4.7 and A.2, Proposition 4.5 and Theorem 5.1 of that paper. The only substantial differences are in the rules (r f -comm) and (r f move), which we discuss below. For the most part, the proof for (r f -comm) follows that given in [12]. The only additional complication is presence of filter updating. Suppose that G (k) 6= lbad, G ` k v:T and G &lt; : D.
Reference: [13] <author> Matthew Hennessy and James Riely. </author> <title> Type-safe execution of mobile agents in anonymous networks. </title> <institution> Computer Science Technical Report 3/98, University of Sussex, </institution> <year> 1998. </year> <note> Available from http://www.cogs.susx.ac.uk/. </note>
Reference-contexts: The full development is given in Section 4, where we prove Subject Reduction and Type Safety theorems for this semantics, ensuring that resource access at good locations is always type-safe. This approach should be contrasted with that of <ref> [13] </ref> (outlined in Appendix B), which gives an adequate semantics for networks in which the authority of incoming agents cannot reliably be determined. One drawback of this framework is that every agent must be dynamically typechecked when moving from one site to another. <p> In each of these sections, the main results are Subject Reduction (for the partial typing relation) and Type Safety. Trust and Partial Typing in Open Systems of Mobile Agents 16 It is worth contrasting this approach with the purely local approach adopted for anonymous networks in <ref> [13] </ref> (and outlined in Appendix B). In anonymous networks, the authority of incoming threads is not known. The semantics of [13] uses a weaker typing system requiring consistency only of local resource types. <p> Trust and Partial Typing in Open Systems of Mobile Agents 16 It is worth contrasting this approach with the purely local approach adopted for anonymous networks in <ref> [13] </ref> (and outlined in Appendix B). In anonymous networks, the authority of incoming threads is not known. The semantics of [13] uses a weaker typing system requiring consistency only of local resource types. Thus, in that work, (6) is taken to be well-typed, with subject reduction failing only in the move from (7) to (8). <p> In the example sketched above, after m's agent is refused entry to `, m might itself resend the agent, rather than forwarding it to k, this time carrying a signed value to prove that k [a] is of the appropriate type. 6.4 Anonymous Networks In <ref> [13] </ref> we presented a semantics for open system in which the authority of incoming agents is not known. We call such systems anonymous networks. In Appendix B we recast the semantics of [13] using filters and lbad. <p> carrying a signed value to prove that k [a] is of the appropriate type. 6.4 Anonymous Networks In <ref> [13] </ref> we presented a semantics for open system in which the authority of incoming agents is not known. We call such systems anonymous networks. In Appendix B we recast the semantics of [13] using filters and lbad. An attractive property of the semantics is that filter updating is purely local, i.e. no non-local data need be stored in filters. <p> we have from (net-new g ) that K 6= lbad, thus we can apply induction to conclude that N err k X!, a contradiction. fl B Anonymous Networks In this section we describe how the techniques developed in this paper could be brought to bear on the anonymous networks of <ref> [13] </ref>. As a starting place, we take the standard semantics of Section 2 under the partial typing relation of Section 3. As in Section 4, we extend the syntax of networks to include filters, although here they are of the form khhKii, rather than khhDii. <p> For example the network (6) of Section 3.2 is well-typed, although (8) is not. Using these definitions, one can establish Subject Reduction and a weaker notion of Type Safety (given in <ref> [13] </ref>). This formulation has certain advantages over that of [13], such as the stronger language of partial types. Moreover it allows self moves to go untyped; i.e. reductions of the form `Jgoto `: PK 7! `JPK are always allowed. <p> For example the network (6) of Section 3.2 is well-typed, although (8) is not. Using these definitions, one can establish Subject Reduction and a weaker notion of Type Safety (given in <ref> [13] </ref>). This formulation has certain advantages over that of [13], such as the stronger language of partial types. Moreover it allows self moves to go untyped; i.e. reductions of the form `Jgoto `: PK 7! `JPK are always allowed.
Reference: [14] <author> Frederick Coleville Knabe. </author> <title> Language Support for Mobile Agents. </title> <type> PhD thesis, </type> <institution> Carnegie-Mellon University, </institution> <year> 1995. </year>
Reference-contexts: This discipline would open the possibility of typing code during in and out operations, rather than open. Several studies have addressed the issue of static typing for languages with remote resources; some recent papers are [20, 6, 22]. Perhaps the work closest to ours is that of Knabe <ref> [14] </ref>, who has implemented an extension of Facile which supports mobile agents. The main extensions are remote signatures and proxy structures, which recall our location types. None of these works address open systems, however.
Reference: [15] <author> Dexter Kozen. </author> <title> Efficient code certification. </title> <type> Technical Report 98-1661, </type> <institution> Cornell University, Department of Computer Science, </institution> <year> 1988. </year> <note> Available from http://www.cs. cornell.edu/kozen/secure. </note>
Reference-contexts: The object of this paper is the formalization of a protection policy for good sites against such malicious attacks. As in <ref> [25, 19, 15, 18] </ref>, the basic idea is to require that code be verified before it is loaded locally. <p> The main extensions are remote signatures and proxy structures, which recall our location types. None of these works address open systems, however. On the other hand, Necula's proof carrying code [19] and related techniques <ref> [25, 15, 18] </ref> address the problem of dynamic typechecking in open systems, but do not consider the subject of remote resources. Another area of related work has to do with static methods for analyzing the security of information flow [9, 2, 8, 24, 11].
Reference: [16] <author> Robin Milner. </author> <title> The polyadic p-calculus: a tutorial. </title> <type> Technical Report ECS-LFCS-91-180, </type> <institution> Laboratory for Foundations of Computer Science, Department of Computer Science, University of Edinburgh, UK, </institution> <month> October </month> <year> 1991. </year> <title> Also in Logic and Algebra of Specification, </title> <editor> ed. F. L. Bauer, W. Brauer and H. Schwichtenberg, </editor> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Patterns, XY, include variables and tuples of patterns; we require that patterns be linear, i.e. that each variable appear at most once. The main syntactic categories of the language are as follows: * Threads, PR, are terms of the ordinary polyadic p-calculus <ref> [16] </ref> with addi tional constructs for movement and restriction of locations. * Agents, kJPK, are located threads. * Networks, MN, are collections of agents combined using the static combi nators of composition and restriction. <p> Cardelli and Gordon's ambient calculus [5], on the other hand, appears to be amenable to partial typing since ambient movement is a local operation; thus the problem of universal extent does not arise. The typing system of Dp is based on the original sorting system of the p-calculus <ref> [16] </ref>, and this sorting system has recently been extended to the ambient calculus [7]. Whereas locations in Dp have a straightforward analog in implementations they correspond to address spaces the notion of ambient is more general, adding expressiveness while blurring the distinction between agent movement and agent interaction.
Reference: [17] <author> Robin Milner, Joachim Parrow, and David Walker. </author> <title> A calculus of mobile processes, Parts I and II. Information and Computation, </title> <address> 100:177, </address> <month> September </month> <year> 1992. </year>
Reference-contexts: Such type violations may lead to core dumps, information leakage or the spread of viruses and other virtual pestilence. We study these issues in the formal setting of Dp [12], a distributed variant of the p-calculus <ref> [17] </ref>. In Dp resources reside at locations and mobile agents may move from site to site, interacting via local resources to affect computations. The typing system of Dp is based on location types which describe the resources available at a site.
Reference: [18] <author> Greg Morrisett, David Walker, Karl Crary, and Neal Glew. </author> <title> From System F to typed assembly language. </title> <booktitle> In Conference Record of the ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 8597, </pages> <address> San Diego, </address> <month> January </month> <year> 1998. </year> <note> ACM Press. </note>
Reference-contexts: The object of this paper is the formalization of a protection policy for good sites against such malicious attacks. As in <ref> [25, 19, 15, 18] </ref>, the basic idea is to require that code be verified before it is loaded locally. <p> The main extensions are remote signatures and proxy structures, which recall our location types. None of these works address open systems, however. On the other hand, Necula's proof carrying code [19] and related techniques <ref> [25, 15, 18] </ref> address the problem of dynamic typechecking in open systems, but do not consider the subject of remote resources. Another area of related work has to do with static methods for analyzing the security of information flow [9, 2, 8, 24, 11].
Reference: [19] <author> George Necula. </author> <title> Proof-carrying code. </title> <booktitle> In Conference Record of the ACM Symposium on Principles of Programming Languages. </booktitle> <publisher> ACM Press, </publisher> <month> January </month> <year> 1996. </year>
Reference-contexts: The object of this paper is the formalization of a protection policy for good sites against such malicious attacks. As in <ref> [25, 19, 15, 18] </ref>, the basic idea is to require that code be verified before it is loaded locally. <p> The main extensions are remote signatures and proxy structures, which recall our location types. None of these works address open systems, however. On the other hand, Necula's proof carrying code <ref> [19] </ref> and related techniques [25, 15, 18] address the problem of dynamic typechecking in open systems, but do not consider the subject of remote resources. Another area of related work has to do with static methods for analyzing the security of information flow [9, 2, 8, 24, 11].
Reference: [20] <author> Atsuhi Ohori and Kazuhiko Kato. </author> <title> Semantics for communication primitives in a polymorphic language. </title> <booktitle> In Conference Record of the ACM Symposium on Principles of Programming Languages, </booktitle> <address> Charleston, </address> <month> January </month> <year> 1993. </year> <note> ACM Press. </note>
Reference-contexts: The former would be similar to our locations, the later, our resources. This discipline would open the possibility of typing code during in and out operations, rather than open. Several studies have addressed the issue of static typing for languages with remote resources; some recent papers are <ref> [20, 6, 22] </ref>. Perhaps the work closest to ours is that of Knabe [14], who has implemented an extension of Facile which supports mobile agents. The main extensions are remote signatures and proxy structures, which recall our location types. None of these works address open systems, however.
Reference: [21] <author> Benjamin Pierce and Davide Sangiorgi. </author> <title> Typing and subtyping for mobile processes. </title> <note> Mathematical Structures in Computer Science, 6(5):409454, 1996. Extended abstract in LICS '93. </note>
Reference-contexts: Here we describe the runtime errors captured by our system, which can be informally described as misuse of resources at good sites. Often the formulation of runtime errors is quite cumbersome as it involves the invention of a tagged version of the language, see <ref> [12, 21] </ref>. However in this case the presence of filters makes it straightforward. In Table 6 we define, for each location ` a unary predicate err ` ! over networks.
Reference: [22] <author> Tatsurou Sekiguchi and Akinori Yonezawa. </author> <title> A calculus with code mobility. </title> <booktitle> In FMOODS '97, </booktitle> <address> Canterbury, July 1997. </address> <publisher> Chapman and Hall. </publisher>
Reference-contexts: The former would be similar to our locations, the later, our resources. This discipline would open the possibility of typing code during in and out operations, rather than open. Several studies have addressed the issue of static typing for languages with remote resources; some recent papers are <ref> [20, 6, 22] </ref>. Perhaps the work closest to ours is that of Knabe [14], who has implemented an extension of Facile which supports mobile agents. The main extensions are remote signatures and proxy structures, which recall our location types. None of these works address open systems, however.
Reference: [23] <author> Peter Sewell. </author> <title> Global/local subtyping for a distributed p-calculus. </title> <type> Technical Report 435, </type> <institution> Computer Laboratory, University of Cambridge, </institution> <month> August </month> <year> 1997. </year>
Reference-contexts: For example locfputi:reshinti; geti:reshinti; putl:reshloci; getl:reshlocig is the type of a location with four resources, two for manipulating integers and two for manipulating location names. A feature which distinguishes Dp from related languages <ref> [10, 4, 23] </ref> is that resource names have only local significance, i.e. resource names are unique locally, but not globally across the network. This property reflects the open-ended nature of open systems such as the internet.
Reference: [24] <author> Geoffrey Smith and Dennis Volpano. </author> <title> Secure information flow in a multi-threaded imperative language. </title> <booktitle> In Conference Record of the ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Diego, </address> <month> January </month> <year> 1998. </year> <note> ACM Press. </note>
Reference-contexts: Another area of related work has to do with static methods for analyzing the security of information flow <ref> [9, 2, 8, 24, 11] </ref>. Although this area of research shares our general aims there is very little technical overlap with our approach to resource protection in open systems. Acknowledgments.
Reference: [25] <author> Frank Yellin. </author> <title> Low-level security in Java. </title> <note> In WWW4 Conference, 1995. Available from http://www.javasoft.com/sfaq/verifier.html. </note>
Reference-contexts: The object of this paper is the formalization of a protection policy for good sites against such malicious attacks. As in <ref> [25, 19, 15, 18] </ref>, the basic idea is to require that code be verified before it is loaded locally. <p> The main extensions are remote signatures and proxy structures, which recall our location types. None of these works address open systems, however. On the other hand, Necula's proof carrying code [19] and related techniques <ref> [25, 15, 18] </ref> address the problem of dynamic typechecking in open systems, but do not consider the subject of remote resources. Another area of related work has to do with static methods for analyzing the security of information flow [9, 2, 8, 24, 11].
References-found: 25

