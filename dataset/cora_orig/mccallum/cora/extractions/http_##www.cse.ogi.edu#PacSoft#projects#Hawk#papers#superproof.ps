URL: http://www.cse.ogi.edu/PacSoft/projects/Hawk/papers/superproof.ps
Refering-URL: http://www.cse.ogi.edu/~byron/papers/
Root-URL: http://www.cse.ogi.edu
Email: fkrstic,byron,jl,johnmg@cse.ogi.edu  
Title: A correctness proof of a speculative, superscalar, out-of-order, renaming microarchitecture  
Author: Sava Krstic, Byron Cook, John Launchbury, and John Matthews 
Affiliation: Oregon Graduate Institute  
Abstract: In this paper we provide high-level mathematical specifications for a basic machine and for a speculative, superscalar, out-of-order, renaming machine based on the Intel P6 microarchitecture. We then prove that the visible outputs of the two machines are equivalent.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Aagaard, M., and Leeser, M. </author> <title> Reasoning about pipelines with structural hazards. </title> <booktitle> In Second International Conference on Theorem Provers in Circuit Design (Bad Herrenalb, </booktitle> <address> Germany, </address> <month> Sept. </month> <year> 1994). </year>
Reference-contexts: To formalize those entities, we use the concept of transactions <ref> [1, 8] </ref>. A transaction is a package of information which (directly or indirectly) contains the identity of the unique instruction it is associated with plus various data contained in the current machine state that are relevant for the execution of that instruction. <p> Theorem. hpc; resi (retired 1 retired 2 ) = standard. Here retired 1 retired 2 is the concatenation of finite sequences retired 1 , retired 2 , etc. 5 I 1 I 2 I 3 I 4 I 5 I 6 I 7 I 8 1 1 <ref> [1] </ref> 1 [2] 1 [3] 1 [4] 3 3 [1] 3 [2] 3 [3] 3 [4] 5 5 [1] 5 [2] 5 [3] 5 [4] 5 [5] 5 [6] 5 [7] 5 [8] . . . . . . . . . . . . . . . 3.2.1 Computational state <p> Here retired 1 retired 2 is the concatenation of finite sequences retired 1 , retired 2 , etc. 5 I 1 I 2 I 3 I 4 I 5 I 6 I 7 I 8 1 1 <ref> [1] </ref> 1 [2] 1 [3] 1 [4] 3 3 [1] 3 [2] 3 [3] 3 [4] 5 5 [1] 5 [2] 5 [3] 5 [4] 5 [5] 5 [6] 5 [7] 5 [8] . . . . . . . . . . . . . . . 3.2.1 Computational state Our approach to proving top-level specifications of complex machines <p> is the concatenation of finite sequences retired 1 , retired 2 , etc. 5 I 1 I 2 I 3 I 4 I 5 I 6 I 7 I 8 1 1 <ref> [1] </ref> 1 [2] 1 [3] 1 [4] 3 3 [1] 3 [2] 3 [3] 3 [4] 5 5 [1] 5 [2] 5 [3] 5 [4] 5 [5] 5 [6] 5 [7] 5 [8] . . . . . . . . . . . . . . . 3.2.1 Computational state Our approach to proving top-level specifications of complex machines is based on the idea of using transactions to <p> If n is regular, then 1 n is a prefix of 1 n1 . If n is singular, then 1 n = 1 n and ffi n contains n . 4.4 Checking the axioms of the standard machine Proof of SM-1. We want to prove pc ( 1 <ref> [1] </ref>) = startIdx. Let n be the smallest integer such that fetched n 6= ;. By IFU-1, pc (t) = startIdx, where t is the first transaction in fetched n .
Reference: [2] <author> Birch, J., and Dill, D. </author> <title> Automatic verification of pipelined microprocessor control. </title> <booktitle> In 6th International Conference of Computer Aided Verification (Stan-ford, </booktitle> <address> California, </address> <month> June </month> <year> 1994). </year>
Reference-contexts: Theorem. hpc; resi (retired 1 retired 2 ) = standard. Here retired 1 retired 2 is the concatenation of finite sequences retired 1 , retired 2 , etc. 5 I 1 I 2 I 3 I 4 I 5 I 6 I 7 I 8 1 1 [1] 1 <ref> [2] </ref> 1 [3] 1 [4] 3 3 [1] 3 [2] 3 [3] 3 [4] 5 5 [1] 5 [2] 5 [3] 5 [4] 5 [5] 5 [6] 5 [7] 5 [8] . . . . . . . . . . . . . . . 3.2.1 Computational state Our approach <p> Here retired 1 retired 2 is the concatenation of finite sequences retired 1 , retired 2 , etc. 5 I 1 I 2 I 3 I 4 I 5 I 6 I 7 I 8 1 1 [1] 1 <ref> [2] </ref> 1 [3] 1 [4] 3 3 [1] 3 [2] 3 [3] 3 [4] 5 5 [1] 5 [2] 5 [3] 5 [4] 5 [5] 5 [6] 5 [7] 5 [8] . . . . . . . . . . . . . . . 3.2.1 Computational state Our approach to proving top-level specifications of complex machines is based <p> concatenation of finite sequences retired 1 , retired 2 , etc. 5 I 1 I 2 I 3 I 4 I 5 I 6 I 7 I 8 1 1 [1] 1 <ref> [2] </ref> 1 [3] 1 [4] 3 3 [1] 3 [2] 3 [3] 3 [4] 5 5 [1] 5 [2] 5 [3] 5 [4] 5 [5] 5 [6] 5 [7] 5 [8] . . . . . . . . . . . . . . . 3.2.1 Computational state Our approach to proving top-level specifications of complex machines is based on the idea of using transactions to explicitly describe <p> Since res (contents n hpi) is in Value, it must be equal to res (contents m hpi), and again the desired result follows. 15 5 Related work Burch and Dill's seminal paper <ref> [2] </ref> developed the concept of a pipeline flushing abstraction function to prove an equivalence between an ISA and a pipelined implementation. Any instructions in flight are made to complete by an appropriate insertion of null operations.
Reference: [3] <author> Burch, J. </author> <title> Techniques for verifying superscalar microprocessors. </title> <booktitle> In 33rd annual Design Automation Conference (Las Vegas, </booktitle> <address> Nevada, </address> <month> June </month> <year> 1996). </year>
Reference-contexts: Here retired 1 retired 2 is the concatenation of finite sequences retired 1 , retired 2 , etc. 5 I 1 I 2 I 3 I 4 I 5 I 6 I 7 I 8 1 1 [1] 1 [2] 1 <ref> [3] </ref> 1 [4] 3 3 [1] 3 [2] 3 [3] 3 [4] 5 5 [1] 5 [2] 5 [3] 5 [4] 5 [5] 5 [6] 5 [7] 5 [8] . . . . . . . . . . . . . . . 3.2.1 Computational state Our approach to proving <p> Here retired 1 retired 2 is the concatenation of finite sequences retired 1 , retired 2 , etc. 5 I 1 I 2 I 3 I 4 I 5 I 6 I 7 I 8 1 1 [1] 1 [2] 1 <ref> [3] </ref> 1 [4] 3 3 [1] 3 [2] 3 [3] 3 [4] 5 5 [1] 5 [2] 5 [3] 5 [4] 5 [5] 5 [6] 5 [7] 5 [8] . . . . . . . . . . . . . . . 3.2.1 Computational state Our approach to proving top-level specifications of complex machines is based on the <p> finite sequences retired 1 , retired 2 , etc. 5 I 1 I 2 I 3 I 4 I 5 I 6 I 7 I 8 1 1 [1] 1 [2] 1 <ref> [3] </ref> 1 [4] 3 3 [1] 3 [2] 3 [3] 3 [4] 5 5 [1] 5 [2] 5 [3] 5 [4] 5 [5] 5 [6] 5 [7] 5 [8] . . . . . . . . . . . . . . . 3.2.1 Computational state Our approach to proving top-level specifications of complex machines is based on the idea of using transactions to explicitly describe the current <p> Any instructions in flight are made to complete by an appropriate insertion of null operations. Since then, Burch <ref> [3] </ref>, Windley and Burch [13], and Skakkebk, Jones and Dill [12] have extended the approach to superscalar pipelined microprocessors. Using a non-deterministic intermediate machine, Damm and Pnueli [5] constructed a refinement relation between a sequential and Tomasulo-style implementation of an out-of-order processor core.
Reference: [4] <author> Cook, B., Launchbury, J., and Matthews, J. </author> <title> Specifying superscalar microprocessors with Hawk. </title> <booktitle> In Workshop on Formal Techniques for Hardware (Maarstrand, </booktitle> <address> Sweden, </address> <month> June </month> <year> 1998). </year>
Reference-contexts: Industry is working hard to find formal verification methods that scale to the problem sizes they face. Our paper attempts to address some aspects of this issue Our research is based on a fairly detailed model of a P6-like microarchitecture <ref> [4, 6] </ref> expressed using Hawk [8]. To prove its correctness, we have constructed a more abstract specification in which each major component is axiomatically specified. <p> Here retired 1 retired 2 is the concatenation of finite sequences retired 1 , retired 2 , etc. 5 I 1 I 2 I 3 I 4 I 5 I 6 I 7 I 8 1 1 [1] 1 [2] 1 [3] 1 <ref> [4] </ref> 3 3 [1] 3 [2] 3 [3] 3 [4] 5 5 [1] 5 [2] 5 [3] 5 [4] 5 [5] 5 [6] 5 [7] 5 [8] . . . . . . . . . . . . . . . 3.2.1 Computational state Our approach to proving top-level specifications <p> 1 retired 2 is the concatenation of finite sequences retired 1 , retired 2 , etc. 5 I 1 I 2 I 3 I 4 I 5 I 6 I 7 I 8 1 1 [1] 1 [2] 1 [3] 1 <ref> [4] </ref> 3 3 [1] 3 [2] 3 [3] 3 [4] 5 5 [1] 5 [2] 5 [3] 5 [4] 5 [5] 5 [6] 5 [7] 5 [8] . . . . . . . . . . . . . . . 3.2.1 Computational state Our approach to proving top-level specifications of complex machines is based on the idea of <p> retired 1 , retired 2 , etc. 5 I 1 I 2 I 3 I 4 I 5 I 6 I 7 I 8 1 1 [1] 1 [2] 1 [3] 1 <ref> [4] </ref> 3 3 [1] 3 [2] 3 [3] 3 [4] 5 5 [1] 5 [2] 5 [3] 5 [4] 5 [5] 5 [6] 5 [7] 5 [8] . . . . . . . . . . . . . . . 3.2.1 Computational state Our approach to proving top-level specifications of complex machines is based on the idea of using transactions to explicitly describe the current state of
Reference: [5] <author> Damm, W., and Pnueli, A. </author> <title> Verifying out-of-order executions. In Conference on Correct Hardware Design and Verification Methods (Montreal, </title> <address> Canada, </address> <year> 1997). </year>
Reference-contexts: , retired 2 , etc. 5 I 1 I 2 I 3 I 4 I 5 I 6 I 7 I 8 1 1 [1] 1 [2] 1 [3] 1 [4] 3 3 [1] 3 [2] 3 [3] 3 [4] 5 5 [1] 5 [2] 5 [3] 5 [4] 5 <ref> [5] </ref> 5 [6] 5 [7] 5 [8] . . . . . . . . . . . . . . . 3.2.1 Computational state Our approach to proving top-level specifications of complex machines is based on the idea of using transactions to explicitly describe the current state of computation at <p> Any instructions in flight are made to complete by an appropriate insertion of null operations. Since then, Burch [3], Windley and Burch [13], and Skakkebk, Jones and Dill [12] have extended the approach to superscalar pipelined microprocessors. Using a non-deterministic intermediate machine, Damm and Pnueli <ref> [5] </ref> constructed a refinement relation between a sequential and Tomasulo-style implementation of an out-of-order processor core. McMillan [9] verifies the same processor using compositional model-checking techniques. The machine transitions are defined by next-state operations on the full states of the ISA and the Tomasulo machines.
Reference: [6] <author> Gwennap, L. </author> <title> Intel's P6 uses decoupled superscalar design. </title> <type> Microprocessor Report 9, </type> <month> 2 </month> <year> (1995). </year>
Reference-contexts: Industry is working hard to find formal verification methods that scale to the problem sizes they face. Our paper attempts to address some aspects of this issue Our research is based on a fairly detailed model of a P6-like microarchitecture <ref> [4, 6] </ref> expressed using Hawk [8]. To prove its correctness, we have constructed a more abstract specification in which each major component is axiomatically specified. <p> 2 , etc. 5 I 1 I 2 I 3 I 4 I 5 I 6 I 7 I 8 1 1 [1] 1 [2] 1 [3] 1 [4] 3 3 [1] 3 [2] 3 [3] 3 [4] 5 5 [1] 5 [2] 5 [3] 5 [4] 5 [5] 5 <ref> [6] </ref> 5 [7] 5 [8] . . . . . . . . . . . . . . . 3.2.1 Computational state Our approach to proving top-level specifications of complex machines is based on the idea of using transactions to explicitly describe the current state of computation at any cycle.
Reference: [7] <author> Krsti c, S., Cook, B., Launchbury, J., and Matthews, J. </author> <title> A correctness proof of a speculative superscalar, </title> <journal> out-of-order, </journal> <note> renaming microarchitecture | extended technical report. Available at www.cse.ogi.edu/PacSoft/projects/Hawk/, Apr. </note> <year> 1998. </year>
Reference-contexts: etc. 5 I 1 I 2 I 3 I 4 I 5 I 6 I 7 I 8 1 1 [1] 1 [2] 1 [3] 1 [4] 3 3 [1] 3 [2] 3 [3] 3 [4] 5 5 [1] 5 [2] 5 [3] 5 [4] 5 [5] 5 [6] 5 <ref> [7] </ref> 5 [8] . . . . . . . . . . . . . . . 3.2.1 Computational state Our approach to proving top-level specifications of complex machines is based on the idea of using transactions to explicitly describe the current state of computation at any cycle. <p> Now we demonstrate that the axiomatization is sufficient to obtain a global correctness property. The arguments will be rather sketchy and some omitted. For a complete proof, see our technical report <ref> [7] </ref>. In addition to shorthands n ; t n , we will also use n for retired n .
Reference: [8] <author> Matthews, J., Launchbury, J., and Cook, B. </author> <title> Specifying microprocessors in Hawk. </title> <booktitle> In IEEE International Conference on Computer Languages (Aug. </booktitle> <year> 1998). </year>
Reference-contexts: Industry is working hard to find formal verification methods that scale to the problem sizes they face. Our paper attempts to address some aspects of this issue Our research is based on a fairly detailed model of a P6-like microarchitecture [4, 6] expressed using Hawk <ref> [8] </ref>. To prove its correctness, we have constructed a more abstract specification in which each major component is axiomatically specified. We are then able to prove that, for any given program, the visible output computed by the microarchitecture is identical to that of the simple reference machine. <p> To formalize those entities, we use the concept of transactions <ref> [1, 8] </ref>. A transaction is a package of information which (directly or indirectly) contains the identity of the unique instruction it is associated with plus various data contained in the current machine state that are relevant for the execution of that instruction. <p> I 1 I 2 I 3 I 4 I 5 I 6 I 7 I 8 1 1 [1] 1 [2] 1 [3] 1 [4] 3 3 [1] 3 [2] 3 [3] 3 [4] 5 5 [1] 5 [2] 5 [3] 5 [4] 5 [5] 5 [6] 5 [7] 5 <ref> [8] </ref> . . . . . . . . . . . . . . . 3.2.1 Computational state Our approach to proving top-level specifications of complex machines is based on the idea of using transactions to explicitly describe the current state of computation at any cycle.
Reference: [9] <author> McMillan, K. </author> <title> Verification of an implementation of tomasulo's algorithm by compositional model checking. </title> <booktitle> In International Conference on Computer-Aided Verification (Vancouver, </booktitle> <address> Canada, </address> <month> July </month> <year> 1998). </year>
Reference-contexts: Since then, Burch [3], Windley and Burch [13], and Skakkebk, Jones and Dill [12] have extended the approach to superscalar pipelined microprocessors. Using a non-deterministic intermediate machine, Damm and Pnueli [5] constructed a refinement relation between a sequential and Tomasulo-style implementation of an out-of-order processor core. McMillan <ref> [9] </ref> verifies the same processor using compositional model-checking techniques. The machine transitions are defined by next-state operations on the full states of the ISA and the Tomasulo machines. This results in a large conjunctive formula, each conjunct of which is checked independently.
Reference: [10] <author> Sawada, J., and Hunt, W. </author> <title> Processor verification with precise exceptions and speculative execution. </title> <booktitle> In International Conference on Computer-Aided Verification (Vancouver, </booktitle> <address> Canada, </address> <month> July </month> <year> 1998). </year>
Reference-contexts: As their models rely on being able to apply rewrite rules in any order, it is not clear how their correctness result would translate to a lower-level implementation that did not have this flexibility. In a very recent paper, Sawada and Hunt <ref> [10] </ref> describe a microprocessor verification that has many similarities to our work. They also construct a sequence of transaction-like records, called a Micro-Architecture Execution Trace Table (MAETT). Like our state, the MAETT is permanently enlarged with every completed instruction.
Reference: [11] <author> Shen, X., and Arvind. </author> <title> Design and verification of speculative processors. </title> <booktitle> In Workshop on Formal Techniques for Hardware (Maarstrand, </booktitle> <address> Sweden, </address> <month> June </month> <year> 1998). </year>
Reference-contexts: This encapsulation may provide an additional level of abstraction and modularity to the verification effort, and allow separate teams to develop each component, while ensuring that global processor invariants are maintained. Shen and Arvind <ref> [11] </ref> describe a term-rewriting methodology for verifying superscalar, speculative, out-of-order multiprocessors. Their approach can be considered to be at an even higher level of abstraction than our Hawk designs which provided the basis for our axiomatization. As a result, their specifications are simpler than ours.
Reference: [12] <author> Skakkebaek, J., Jones, R., and Dill, D. </author> <title> Formal verification of out-of-order execution using incremental flushing. </title> <booktitle> In International Conference on Computer-Aided Verification (Vancouver, </booktitle> <address> Canada, </address> <month> July </month> <year> 1998). </year>
Reference-contexts: Any instructions in flight are made to complete by an appropriate insertion of null operations. Since then, Burch [3], Windley and Burch [13], and Skakkebk, Jones and Dill <ref> [12] </ref> have extended the approach to superscalar pipelined microprocessors. Using a non-deterministic intermediate machine, Damm and Pnueli [5] constructed a refinement relation between a sequential and Tomasulo-style implementation of an out-of-order processor core. McMillan [9] verifies the same processor using compositional model-checking techniques.
Reference: [13] <author> Windley, P., and Burch, J. </author> <title> Mechanically checking a lemma used in an automatic verification tool. </title> <booktitle> In Formal Methods in Computer-Aided Design (Palo Alto, </booktitle> <address> California, </address> <year> 1996). </year> <month> 18 </month>
Reference-contexts: Any instructions in flight are made to complete by an appropriate insertion of null operations. Since then, Burch [3], Windley and Burch <ref> [13] </ref>, and Skakkebk, Jones and Dill [12] have extended the approach to superscalar pipelined microprocessors. Using a non-deterministic intermediate machine, Damm and Pnueli [5] constructed a refinement relation between a sequential and Tomasulo-style implementation of an out-of-order processor core. McMillan [9] verifies the same processor using compositional model-checking techniques.
References-found: 13

