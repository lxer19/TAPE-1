URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/reports/97/tr1366.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/reports/97/
Root-URL: http://www.cs.wisc.edu
Title: Compressing Relations and Indexes  
Author: Jonathan Goldstein Raghu Ramakrishnan Uri Shaft 
Date: 1366, December 1997  
Affiliation: Computer Sciences Department University of Wisconsin-Madison  
Pubnum: Technical Report No.  
Abstract: We propose a new compression algorithm that is tailored to database applications. It can be applied to a collection of records, and is especially effective for records with many low to medium cardinality fields and numeric fields. In addition, this new technique supports very fast decompression. Promising application domains include decision support systems (DSS), since "fact tables", which are by far the largest tables in these applications, contain many low and medium cardinality fields and typically no text fields. Further, our decompression rates are faster than typical disk throughputs for sequential scans; in contrast, gzip is slower. This is important in DSS applications, which often scan large ranges of records. An important distinguishing characteristic of our algorithm, in contrast to compression algorithms proposed earlier, is that we can decompress individual tuples (even individual fields), rather than a full page (or an entire relation) at a time. Also, all the information needed for tuple decompression resides on the same page with the tuple. This means that a page can be stored in the buffer pool and used in compressed form, simplifying the job of the buffer manager. Our compression algorithm also improves index structures such as B-trees and R-trees significantly by reducing the number of leaf pages and compressing index entries, which greatly increases the fan-out. We can also use lossy compression on the internal nodes of an index. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. A. Bassiouni, </author> <title> "Data Compression in Scientific and Statistical Databases", </title> <journal> in IEEE Transactions on Software Engineering, </journal> <volume> Vol. SE-11, No. 10, </volume> <pages> pp. 1047-1058, </pages> <year> 1985. </year>
Reference-contexts: Additionally, we demonstrated the application of multidimensional bulk loading to compression, and presented a range of performance results that strongly argue for the use of compression in a database context. <ref> [5, 18, 1] </ref> discuss several compression techniques such as run length encoding, header compression, encoding category values, order preserving compression, Huffman encoding, Lempel-Ziv, differencing, prefix and postfix compression, none of which support random access to tuples within a page.
Reference: [2] <author> R. Bayer and E. McCreight, </author> <title> "Organization and maintenance of large ordered indexes", </title> <journal> in Acta Informat., </journal> <volume> Vol. 1, </volume> <pages> pp. 173-189, </pages> <year> 1972. </year>
Reference-contexts: Note that given the restriction of using our page level compression and the order of tuples, this greedy algorithm achieves optimal compression. 3 Compressing an indexing struc ture Many indexing structures, including R-tree variants [6, 3, 19], B-trees <ref> [2] </ref> , grid files [16], buddy trees [10, 9, 8], TV-trees [14] (using L 1 metric), and X-trees [4], all consist of collections of (rectangle,pointer) pairs (for the internal nodes) and (point,data) pairs (for the leaf nodes).
Reference: [3] <author> N. Beckmann, H.-P. Kriegel, R. Schneider and B. Seeger, </author> <title> "The R fl -Tree: An Efficient and Robust Access Method for Points and Rectangles", </title> <booktitle> in Proc. ACM SIGMOD Int. Conf. on Management of Data pp. </booktitle> <pages> 322-331, </pages> <year> 1992. </year>
Reference-contexts: We continue in this way until all tuples are stored in pages. Note that given the restriction of using our page level compression and the order of tuples, this greedy algorithm achieves optimal compression. 3 Compressing an indexing struc ture Many indexing structures, including R-tree variants <ref> [6, 3, 19] </ref>, B-trees [2] , grid files [16], buddy trees [10, 9, 8], TV-trees [14] (using L 1 metric), and X-trees [4], all consist of collections of (rectangle,pointer) pairs (for the internal nodes) and (point,data) pairs (for the leaf nodes).
Reference: [4] <author> S. Berchtold, D. A. Keim and H.-P. Kriegel, </author> <title> "The X-Tree: An Index Structure for High Dimensional Data", </title> <booktitle> in Proc. 22th Inf. Conf. on VLDB, </booktitle> <pages> pp. 28-39, </pages> <year> 1996. </year>
Reference-contexts: using our page level compression and the order of tuples, this greedy algorithm achieves optimal compression. 3 Compressing an indexing struc ture Many indexing structures, including R-tree variants [6, 3, 19], B-trees [2] , grid files [16], buddy trees [10, 9, 8], TV-trees [14] (using L 1 metric), and X-trees <ref> [4] </ref>, all consist of collections of (rectangle,pointer) pairs (for the internal nodes) and (point,data) pairs (for the leaf nodes). Our main observation is: All these indexing structures try to group similar objects (n-dimensional points) on the same page. <p> We compress this list using the same file level compression algorithm. The resulting sorted list of pages is another level of the B-tree. 3.2 Compressing a rectangle based in dexing structure Most multidimensional indexing structures are rectangle based (e.g., R-trees [6], X-trees <ref> [4] </ref>, TV-tree [14] etc.). They all share these qualities: * These are height-balanced hierarchical structures. * The objects stored in the indexing structure are ei ther points or hyper-rectangles in some n-dimensional space. * The internal nodes consist of (rectangle, pointer) pairs.
Reference: [5] <author> S. J. Eggers, F. Olken and A. Shoshani, </author> <title> "A Compression Technique for Large Statistical Databases", </title> <booktitle> in Proc. 7th Inf. Conf. on VLDB, </booktitle> <pages> pp. 424-434, </pages> <year> 1981. </year>
Reference-contexts: Additionally, we demonstrated the application of multidimensional bulk loading to compression, and presented a range of performance results that strongly argue for the use of compression in a database context. <ref> [5, 18, 1] </ref> discuss several compression techniques such as run length encoding, header compression, encoding category values, order preserving compression, Huffman encoding, Lempel-Ziv, differencing, prefix and postfix compression, none of which support random access to tuples within a page.
Reference: [6] <author> Antonin Guttman, "R-Trees: </author> <title> A Dynamic Index Structure for Spatial Searching", </title> <booktitle> n Proc. ACM SIGMOD Int. Conf. on Management of Data, </booktitle> <pages> pp. 47-57, </pages> <year> 1984. </year>
Reference-contexts: We continue in this way until all tuples are stored in pages. Note that given the restriction of using our page level compression and the order of tuples, this greedy algorithm achieves optimal compression. 3 Compressing an indexing struc ture Many indexing structures, including R-tree variants <ref> [6, 3, 19] </ref>, B-trees [2] , grid files [16], buddy trees [10, 9, 8], TV-trees [14] (using L 1 metric), and X-trees [4], all consist of collections of (rectangle,pointer) pairs (for the internal nodes) and (point,data) pairs (for the leaf nodes). <p> We compress this list using the same file level compression algorithm. The resulting sorted list of pages is another level of the B-tree. 3.2 Compressing a rectangle based in dexing structure Most multidimensional indexing structures are rectangle based (e.g., R-trees <ref> [6] </ref>, X-trees [4], TV-tree [14] etc.). They all share these qualities: * These are height-balanced hierarchical structures. * The objects stored in the indexing structure are ei ther points or hyper-rectangles in some n-dimensional space. * The internal nodes consist of (rectangle, pointer) pairs.
Reference: [7] <author> R. Kimball, </author> <title> The Data Warehouse Toolkit, </title> <publisher> John Wiley and Sons, </publisher> <year> 1996. </year>
Reference-contexts: However, in some situations we can compress non-numeric attributes. It is common practice in decision support systems (DSS) to identify attributes that have low car-dinality for special treatment (see <ref> [7] </ref>). Low cardinality attributes are attributes that have a very limited range of valid values. For example, gender, marital-status, and state/country have very limited ranges although valid values to these attributes are not numeric.
Reference: [8] <author> H.-P. Kriegel, H. Horn and M. Schiwietz, </author> <title> "The Performance of Object Decomposition Techniques for Spatial Query Processing", </title> <booktitle> in Proc. 2nd Symposium on Large Spatial Databases, Lecture Notes in Computer Science, </booktitle> <volume> Vol. 525, </volume> <pages> pp. 257-276, </pages> <year> 1991. </year>
Reference-contexts: Note that given the restriction of using our page level compression and the order of tuples, this greedy algorithm achieves optimal compression. 3 Compressing an indexing struc ture Many indexing structures, including R-tree variants [6, 3, 19], B-trees [2] , grid files [16], buddy trees <ref> [10, 9, 8] </ref>, TV-trees [14] (using L 1 metric), and X-trees [4], all consist of collections of (rectangle,pointer) pairs (for the internal nodes) and (point,data) pairs (for the leaf nodes). Our main observation is: All these indexing structures try to group similar objects (n-dimensional points) on the same page.
Reference: [9] <author> H.-P. Kriegel et al, </author> <title> "Performance Comparison of Point and Spatial Access Methods", </title> <booktitle> in SSD, </booktitle> <pages> pp. 89-113, </pages> <year> 1989. </year>
Reference-contexts: Note that given the restriction of using our page level compression and the order of tuples, this greedy algorithm achieves optimal compression. 3 Compressing an indexing struc ture Many indexing structures, including R-tree variants [6, 3, 19], B-trees [2] , grid files [16], buddy trees <ref> [10, 9, 8] </ref>, TV-trees [14] (using L 1 metric), and X-trees [4], all consist of collections of (rectangle,pointer) pairs (for the internal nodes) and (point,data) pairs (for the leaf nodes). Our main observation is: All these indexing structures try to group similar objects (n-dimensional points) on the same page.
Reference: [10] <author> H.-P. Kriegel et al, </author> <title> "The Buddy-Tree: An Efficient and Robust Method for Spatial Data Base Systems", </title> <booktitle> in Proc. 16th VLDB Conf., </booktitle> <pages> pp. 590-601, </pages> <year> 1990. </year>
Reference-contexts: Note that given the restriction of using our page level compression and the order of tuples, this greedy algorithm achieves optimal compression. 3 Compressing an indexing struc ture Many indexing structures, including R-tree variants [6, 3, 19], B-trees [2] , grid files [16], buddy trees <ref> [10, 9, 8] </ref>, TV-trees [14] (using L 1 metric), and X-trees [4], all consist of collections of (rectangle,pointer) pairs (for the internal nodes) and (point,data) pairs (for the leaf nodes). Our main observation is: All these indexing structures try to group similar objects (n-dimensional points) on the same page.
Reference: [11] <author> A. Lempel and J. Ziv, </author> <title> "On the Complexity of Finite Sequences", </title> <journal> in IEEE Transactions on Information Theory, </journal> <volume> Vol. 22, No. 1, </volume> <pages> pp. 75-81, </pages> <year> 1976. </year>
Reference-contexts: 1 Introduction Traditional compression algorithms such as Lempel-Ziv <ref> [20, 11, 12] </ref>, which is the basis of the standard gzip compression package, require uncompressing a large portion of the file even if only a small part of that file is required.
Reference: [12] <author> A. Lempel and J. Ziv, </author> <title> "A Universal Algorithm for Sequential Data Compression", </title> <journal> in IEEE Transactions on Information Theory, </journal> <volume> Vol. 31, No. 3, </volume> <pages> pp. 337-343, </pages> <year> 1977. </year>
Reference-contexts: 1 Introduction Traditional compression algorithms such as Lempel-Ziv <ref> [20, 11, 12] </ref>, which is the basis of the standard gzip compression package, require uncompressing a large portion of the file even if only a small part of that file is required.
Reference: [13] <author> S. T. Leutenegger et al, "STR: </author> <title> A Simple and Efficient Algorithm for R-Tree Packing", </title> <type> Tech. Report, </type> <institution> Mathematics and Computer Science Dept., University of Denver, No. </institution> <month> 96-02, </month> <year> 1996. </year>
Reference: [14] <author> K.-I. Lin, H. V. Jagadish and C. Faloutsos, </author> <title> "The TV-Tree: An Index Structure for High-Dimensional Data", </title> <journal> in VLDB journal, </journal> <volume> Vol. 3, No. 4, </volume> <pages> pp. 517-542, </pages> <year> 1994. </year>
Reference-contexts: Note that given the restriction of using our page level compression and the order of tuples, this greedy algorithm achieves optimal compression. 3 Compressing an indexing struc ture Many indexing structures, including R-tree variants [6, 3, 19], B-trees [2] , grid files [16], buddy trees [10, 9, 8], TV-trees <ref> [14] </ref> (using L 1 metric), and X-trees [4], all consist of collections of (rectangle,pointer) pairs (for the internal nodes) and (point,data) pairs (for the leaf nodes). Our main observation is: All these indexing structures try to group similar objects (n-dimensional points) on the same page. <p> We compress this list using the same file level compression algorithm. The resulting sorted list of pages is another level of the B-tree. 3.2 Compressing a rectangle based in dexing structure Most multidimensional indexing structures are rectangle based (e.g., R-trees [6], X-trees [4], TV-tree <ref> [14] </ref> etc.). They all share these qualities: * These are height-balanced hierarchical structures. * The objects stored in the indexing structure are ei ther points or hyper-rectangles in some n-dimensional space. * The internal nodes consist of (rectangle, pointer) pairs.
Reference: [15] <author> W. K. Ng, C. V. Ravishankar, </author> <title> "Relational Database Compression Using Augmented Vector Quantization", </title> <booktitle> in IEEE 11'th International Conference on Data Engineering, </booktitle> <pages> pp. 540-549, </pages> <year> 1995. </year>
Reference-contexts: Thus, the effectiveness of the compression can be increased, often dramatically, by partitioning the tuples in a file across pages in an intelligent way. For instance, if a database contains 500,000 tuples, there are many ways to group these tuples, and different groupings may yield drastically different compression ratios. <ref> [15] </ref> demonstrates the effectiveness of using a B-tree sort order to assign tuples to pages. In Section 3 we further develop the connection between index sort orders, including multidimensional indexes like R-trees, and improved compression. In this section we present an algorithm for grouping tuples into compressed pages. <p> Again we used five dimensions and 82600 tuples. In this case we got even better gains than in the Sales dataset case. Here we have two dimensions and 150000 tuples. We see the same good results as in the other datasets. 5 Related work Ng and Ravishankar <ref> [15] </ref> discussed a compression scheme that is similar in some respects to our work.
Reference: [16] <author> J. Nievergelt, H. Hinterberger and S. C. Sevcik, </author> <title> "The Grid File: An Adaptable, Symmetric Multikey File Structure", </title> <booktitle> Readings in Database Systems, </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1988. </year>
Reference-contexts: Note that given the restriction of using our page level compression and the order of tuples, this greedy algorithm achieves optimal compression. 3 Compressing an indexing struc ture Many indexing structures, including R-tree variants [6, 3, 19], B-trees [2] , grid files <ref> [16] </ref>, buddy trees [10, 9, 8], TV-trees [14] (using L 1 metric), and X-trees [4], all consist of collections of (rectangle,pointer) pairs (for the internal nodes) and (point,data) pairs (for the leaf nodes).
Reference: [17] <author> P. O'Neil and D. Quass, </author> <title> "Improved Query Performance with Variant Indexes", </title> <booktitle> in Proc. ACM SIGMOD Int. Conf. on Management of Data, </booktitle> <pages> pp. 38-49, </pages> <year> 1997. </year>
Reference-contexts: Like the compression described in Section 4.3, the above techniques, unlike ours, handle any kind of data, but introduce buffer and storage management problems. <ref> [17] </ref> discusses several query evaluation algorithms based on the use of compression.
Reference: [18] <author> M. A. Roth and S. J. Van Horn, </author> <title> "Database Compression", </title> <booktitle> in SIGMOD Record, </booktitle> <volume> Vol. 22, No. 3, </volume> <pages> pp. 31-39, </pages> <year> 1993. </year>
Reference-contexts: Additionally, we demonstrated the application of multidimensional bulk loading to compression, and presented a range of performance results that strongly argue for the use of compression in a database context. <ref> [5, 18, 1] </ref> discuss several compression techniques such as run length encoding, header compression, encoding category values, order preserving compression, Huffman encoding, Lempel-Ziv, differencing, prefix and postfix compression, none of which support random access to tuples within a page.
Reference: [19] <author> T. Sellis, N. Roussopoulos and C. Faloutsos, </author> <title> "The R + - Tree: A Dynamic Index for Multi-Dimensional Objects", </title> <booktitle> in Proc. 13th Inf. Conf. on VLDB, </booktitle> <pages> pp. 507-518, </pages> <year> 1987. </year>
Reference-contexts: We continue in this way until all tuples are stored in pages. Note that given the restriction of using our page level compression and the order of tuples, this greedy algorithm achieves optimal compression. 3 Compressing an indexing struc ture Many indexing structures, including R-tree variants <ref> [6, 3, 19] </ref>, B-trees [2] , grid files [16], buddy trees [10, 9, 8], TV-trees [14] (using L 1 metric), and X-trees [4], all consist of collections of (rectangle,pointer) pairs (for the internal nodes) and (point,data) pairs (for the leaf nodes).
Reference: [20] <author> J. A. Storer, </author> <title> Data Compression: Methods and Theory, </title> <publisher> Computer Science Press, </publisher> <address> 1803 Research Blvd. Rockville, Maryland, </address> <year> 1988. </year>
Reference-contexts: 1 Introduction Traditional compression algorithms such as Lempel-Ziv <ref> [20, 11, 12] </ref>, which is the basis of the standard gzip compression package, require uncompressing a large portion of the file even if only a small part of that file is required.
References-found: 20

