URL: http://www.cs.yale.edu/HTML/YALE/CS/HyPlans/reid-alastair/reid-padl98.ps.gz
Refering-URL: http://www.cs.yale.edu/HTML/YALE/CS/HyPlans/reid-alastair/
Root-URL: http://www.cs.yale.edu
Email: Email: reid-alastair@cs.yale.edu  
Title: Title: Handling Exceptions in Haskell  
Author: Author: Alastair Reid 
Keyword: Exceptions, Lazy Functional Programming, Non-deterministism.  
Date: Abstract:  
Affiliation: Affiliation: Yale University  
Abstract: Using a language without exception handling is like driving a car with no brakes and no seatbelt | things work fine until something goes wrong. You also learn to drive rather carefully. This paper describes an exception handling extension to the Haskell lazy functional language. The implementation turned out to be very easy but we had problems finding a viable semantics for our system. The resulting semantics is a compromise between theoretical beauty and practical utility. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> C. Dornan and K. Hammond. </author> <title> Exception handling in lazy functional languages. </title> <institution> Research Report CSC 90/R5, Glasgow University, Department of Computing Science, </institution> <month> January </month> <year> 1990. </year>
Reference-contexts: Section 2 recalls a standard exception handling mechanism (the exception monad and the call-by-name monad translation) and Section 3 describes an efficient implementation of this mechanism. This is the easy part of adding exception handling and is essentially a reprise and update of Dornan and Hammond's work <ref> [1] </ref>. Section 4 points out a significant flaw in this approach: even though this mechanism preserves laziness, type safety and referential transparency, it renders many common transformations invalid and apparently makes reasoning about Haskell programs difficult. <p> Wadler's exception monad and call by name translation [13] is semantically sound (indeed, it is the basis for our semantics!) and requires no language extensions but, as we discussed in Section 2, it is tedious to apply and renders programs almost unreadable. Dornan and Hammond <ref> [1, 2] </ref> proposed the same semantics that we describe in Section 2, implemented their proposal and proved that the semantics is sound (confluent and consistent). The primary difference between their work and ours is our observation that soundness is not sufficient: adding exception handling breaks a large number of transformations.
Reference: [2] <author> K. Hammond. </author> <title> Exception handling in a parallel functional language. </title> <institution> Research Report CSC 89/R17, Glasgow University, Department of Computing Science, </institution> <month> August </month> <year> 1989. </year>
Reference-contexts: Wadler's exception monad and call by name translation [13] is semantically sound (indeed, it is the basis for our semantics!) and requires no language extensions but, as we discussed in Section 2, it is tedious to apply and renders programs almost unreadable. Dornan and Hammond <ref> [1, 2] </ref> proposed the same semantics that we describe in Section 2, implemented their proposal and proved that the semantics is sound (confluent and consistent). The primary difference between their work and ours is our observation that soundness is not sufficient: adding exception handling breaks a large number of transformations.
Reference: [3] <author> K. Hammond and A. Gordon. </author> <title> Monadic I/O in Haskell 1.3. </title> <booktitle> In Proceedings of the 1995 Haskell Workshop, </booktitle> <pages> pages 50-68, </pages> <address> La Jolla, California, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: Recent work on Haskell has dealt with the problem of interacting with the real world: Haskell's IO monad <ref> [6, 3] </ref> provided an extensible framework for interacting with the real world; GHC's ccall extension [6] made it possible to use libraries written in C; GHC's foreign pointers [11] made it possible to deallocate C objects without compromising laziness; Hugs-GHC's GreenCard [9] made it easy to use standard C libraries; the <p> Given that any interesting program can go wrong, the only solution is to provide mechanisms for dealing with failure when it happens and to educate programmers to use them. Haskell's IO monad <ref> [3] </ref> recognises the importance of exception handling | providing a simple mechanism for raising and catching exceptions within the IO monad.
Reference: [4] <author> F. Henderson. </author> <title> electronic mail to the Haskell mailing list. </title> <month> June </month> <year> 1998. </year>
Reference-contexts: Our solution is to limit exception catching to the IO monad (where less transformations are valid) and to use non-determinism to describe the semantics of programs that use exception handling. Finally, Henderson <ref> [4] </ref> independently proposed using Hughes and O'Donnell's non-deterministic sets when catching exceptions.
Reference: [5] <author> R. Hughes and J. O'Donnell. </author> <title> Expressing and reasoning about non-deterministic functional programs. </title> <editor> In K. Davis and R. Hughes, editors, </editor> <booktitle> Glasgow Functional Programming Workshop, Workshops in Computing, </booktitle> <pages> pages 308-328. </pages> <publisher> Springer Verlag, </publisher> <year> 1989. </year>
Reference-contexts: To resolve this problem, we borrow an idea from Hughes and O'Donnell's seminal paper <ref> [5] </ref> on reasoning about non-deterministic functional programs. Their main idea was to separate deterministic parts of their programs from non-deterministic parts of their programs and to restrict non-determinism to the top-level of their programs. <p> The next two sections describe how we use non-determinism when reasoning about exception handling. 4.1 Non-deterministic exceptions: a first attempt For a long time, we thought the way to make exception handling non-deterministic was to take a second idea from Hughes and O'Donnell <ref> [5] </ref>: 1. They introduce a new abstract data type fffg whose elements are sets of values of type ff but whose intended implementation is a single representative element chosen non-deterministically from the set it represents. 2.
Reference: [6] <author> S. P. Jones and P. Wadler. </author> <title> Imperative functional programming. </title> <booktitle> In 20th POPL, </booktitle> <pages> pages 71-84, </pages> <address> Charleston, </address> <month> Jan </month> <year> 1993. </year> <note> ACM. </note>
Reference-contexts: Recent work on Haskell has dealt with the problem of interacting with the real world: Haskell's IO monad <ref> [6, 3] </ref> provided an extensible framework for interacting with the real world; GHC's ccall extension [6] made it possible to use libraries written in C; GHC's foreign pointers [11] made it possible to deallocate C objects without compromising laziness; Hugs-GHC's GreenCard [9] made it easy to use standard C libraries; the <p> Recent work on Haskell has dealt with the problem of interacting with the real world: Haskell's IO monad [6, 3] provided an extensible framework for interacting with the real world; GHC's ccall extension <ref> [6] </ref> made it possible to use libraries written in C; GHC's foreign pointers [11] made it possible to deallocate C objects without compromising laziness; Hugs-GHC's GreenCard [9] made it easy to use standard C libraries; the Hugs-GHC standard libraries [7] added support for fixed size integers facilitating access to C libraries
Reference: [7] <author> S. Marlow and A. Reid. </author> <title> The Hugs-GHC libraries. Hugs compiler documentation, </title> <month> June </month> <year> 1998. </year>
Reference-contexts: extensible framework for interacting with the real world; GHC's ccall extension [6] made it possible to use libraries written in C; GHC's foreign pointers [11] made it possible to deallocate C objects without compromising laziness; Hugs-GHC's GreenCard [9] made it easy to use standard C libraries; the Hugs-GHC standard libraries <ref> [7] </ref> added support for fixed size integers facilitating access to C libraries that use them. 1 This increased ability to interact with the real world is a double-edged sword: our programs may achieve wondrous things when they work correctly; but they can wreak untold havoc when they fail.
Reference: [8] <author> J. Peterson and K. Hammond (editors). </author> <title> Report on the Programming Language Haskell 1.4, A Non-strict Purely Functional Language. </title> <institution> Research Report YALEU/DCS/RR-1106, Yale University, Department of Computer Science, </institution> <month> April </month> <year> 1997. </year>
Reference-contexts: The Haskell report <ref> [8] </ref> gives the necessary rules for transforming Haskell programs into Core Haskell. Figure 3 shows the monad translation in action on a user-defined function average and a primitive operation divide. <p> This section describes these features and suggests a unified design which combines all three. Only the first has been implemented so far. Haskell 1.4 <ref> [8] </ref> introduced a restricted form of exception handling which was labelled "error catching". This was a very conservative design which restricted both raising and catching of exceptions to the IO monad.
Reference: [9] <author> S. Peyton Jones, T. Nordin, and A. Reid. Greencard: </author> <title> a foreign-language interface for Haskell. </title> <booktitle> In Proc Haskell Workshop, </booktitle> <address> Amsterdam, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: of interacting with the real world: Haskell's IO monad [6, 3] provided an extensible framework for interacting with the real world; GHC's ccall extension [6] made it possible to use libraries written in C; GHC's foreign pointers [11] made it possible to deallocate C objects without compromising laziness; Hugs-GHC's GreenCard <ref> [9] </ref> made it easy to use standard C libraries; the Hugs-GHC standard libraries [7] added support for fixed size integers facilitating access to C libraries that use them. 1 This increased ability to interact with the real world is a double-edged sword: our programs may achieve wondrous things when they work
Reference: [10] <author> A. Reeves, D. Harrison, A. Sinclair, and P. Williamson. Gerald: </author> <title> An exceptional lazy functional programming language. </title> <editor> In K. Davis and R. Hughes, editors, </editor> <booktitle> Glasgow Functional Programming Workshop, Workshops in Computing, </booktitle> <pages> pages 371-390. </pages> <publisher> Springer Ver-lag, </publisher> <year> 1989. </year>
Reference-contexts: Gerald <ref> [10] </ref> was an early attempt to add exception handling to a lazy language | but it has no clear semantics and seems to be limited to untyped languages.
Reference: [11] <author> A. Reid. </author> <title> Malloc pointers and stable pointers: Improving Haskell's foreign language interface. </title> <booktitle> draft proceedings of Glasgow Functional Programming Workshop, </booktitle> <month> July </month> <year> 1994. </year>
Reference-contexts: Recent work on Haskell has dealt with the problem of interacting with the real world: Haskell's IO monad [6, 3] provided an extensible framework for interacting with the real world; GHC's ccall extension [6] made it possible to use libraries written in C; GHC's foreign pointers <ref> [11] </ref> made it possible to deallocate C objects without compromising laziness; Hugs-GHC's GreenCard [9] made it easy to use standard C libraries; the Hugs-GHC standard libraries [7] added support for fixed size integers facilitating access to C libraries that use them. 1 This increased ability to interact with the real world
Reference: [12] <author> A. Reid. </author> <title> Putting the Spine back in the Spineless Tagless G-machine: an implementation of revertible blackholes. </title> <note> Submitted to IFL'98, </note> <month> August </month> <year> 1998. </year>
Reference-contexts: This paper describes an extension which lets programs catch "internal exceptions" (e.g. calls to the error function, pattern match failure and division by zero); the essential but different task of catching "external exceptions" (e.g. interrupts and timeouts) is discussed in a companion paper <ref> [12] </ref> and outlined in Section 5. The main difficulty in extending Haskell's exception handling capabilities is to avoid compromising Haskell's main strengths: lazy evaluation, type safety, support for equational reasoning and its amenability to both manual and automatic transformation. <p> We recently extended the STG machine with an interrupt catching mechanism <ref> [12] </ref>. <p> There is just one subtlety: when propagating exceptions, we overwrite pending updatees with error values; when interrupting programs, we overwrite pending updates with reverted blackholes (this is the main subject of our other paper <ref> [12] </ref>).
Reference: [13] <author> P. Wadler. </author> <title> Comprehending monads. </title> <booktitle> In Proc ACM Conference on Lisp and Functional Programming, </booktitle> <address> Nice, </address> <month> June </month> <year> 1990. </year> <journal> ACM. </journal> <volume> 15 </volume>
Reference-contexts: The development in the previous sections ignores the interaction between exception handling and two other exception-like features of Haskell: Section 5 describes these features and suggests a unified design. 2 The Exception Monad Wadler <ref> [13] </ref> describes how ordinary programmers can add exception handling to a lazy program using the exception monad and the call by name monad translation. The exception monad and the call by name monad translation are shown in figures 1 and 2. <p> Gerald [10] was an early attempt to add exception handling to a lazy language | but it has no clear semantics and seems to be limited to untyped languages. Wadler's exception monad and call by name translation <ref> [13] </ref> is semantically sound (indeed, it is the basis for our semantics!) and requires no language extensions but, as we discussed in Section 2, it is tedious to apply and renders programs almost unreadable.
References-found: 13

