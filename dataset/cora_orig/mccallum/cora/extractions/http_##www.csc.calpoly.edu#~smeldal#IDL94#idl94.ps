URL: http://www.csc.calpoly.edu/~smeldal/IDL94/idl94.ps
Refering-URL: http://www.csc.calpoly.edu/~smeldal/tidbits.html
Root-URL: http://www.csc.calpoly.edu
Email: fkatiyar, luckham, mitchellg@cs.stanford.edu  sigurd@ii.uib.no  
Title: Polymorphism and subtyping in interfaces  
Author: Dinesh Katiyar David Luckham John Mitchell Sigurd Meldal 
Address: USA  Norway  
Affiliation: Department of Computer Science Stanford University,  Department of Informatics University of Bergen,  
Abstract: Rapide is a programming language framework designed for the development of large, concurrent, real-time systems by prototyping. The framework consists of a type language and default executable, specification and architecture languages, along with associated programming tools. Interfaces are the central construct of the type system. This document describes Rapide interfaces, their expressiveness and their use as a typing construct. 
Abstract-found: 1
Intro-found: 1
Reference: [App92] <author> Apple Computer Inc. </author> <title> Dylan, an object-oriented dynamic language, </title> <month> Nov </month> <year> 1992. </year>
Reference-contexts: However, since the subtype designation gives some information about the operations on the type, these types are only "partially" hidden. These types are analogous to the "sealed classes" of Dylan <ref> [App92] </ref>. Example: Partially hidden clock type type Clock Spec is interface type Clock &lt;: interface tick : function (); read : function () return integer; end interface; new clock : function () return Clock; end interface; This example shows how to specify some constituents, without giving an explicit type definition.
Reference: [BL90] <author> F. </author> <title> Belz and D.C. Luckham. A new approach to prototyping Ada-based hardware/software sys-tems. </title> <booktitle> In Proc. ACM Tri-Ada'90 Conference, </booktitle> <month> December </month> <year> 1990. </year>
Reference-contexts: A preliminary design of the Rapide type system was described in [MMM91]. Some additional technical points are discussed in [KLM + 92]. An early overview of the Rapide approach to prototyping appears in <ref> [BL90] </ref>. Details of the architecture language can be found in [RAr]. 2 Interface types An interface is defined by a list of declarations. These may be declarations of object names (where an object is either a module or function) or types.
Reference: [Coo92] <author> W.R. Cook. </author> <title> Interfaces and specifications for the Smalltalk-80 collection classes. </title> <booktitle> In ACM Conf. Object-oriented Programming: Systems, Languages and Applications, </booktitle> <pages> pages 1-15, </pages> <year> 1992. </year>
Reference-contexts: For instance, one would want to define the interface for double-ended queues by extending that for simple queues, whereas the latter can be easily implemented from the former [Sny86]. Similarly, the Smalltalk library shows several cases of conflict between the implementation hierarchy and a reasonable interface hierarchy <ref> [Coo92] </ref>. In Rapide, interface derivation declarations are essentially used to copy declarations from one interface into another. The simplest form of derivation declaration is include type expression Essentially, A declaration "include A" inside an interface type B has the effect of inserting all the declarations of A into B.
Reference: [DMN70] <author> O-J. Dahl, B. Myrhaug, and K. Nygaard. </author> <title> SIMULA Common Base Language. </title> <institution> Norwegian Computing Center S-22, Oslo, Norway, </institution> <year> 1970. </year>
Reference-contexts: This is in contrast to subtyping (or subclass) mechanisms relying on explicitly stating the type relations between named types (such as in Ada [US 80], Simula67 <ref> [DMN70] </ref> and C++ [Str86]).
Reference: [ES90] <author> M. Ellis and B. Stroustrop. </author> <title> The Annotated C ++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: In the default executable language, for example, modules serve as both compile-time groupings of related types and operations, resembling Ada packages [US 80], for example, and as run-time objects of the form found in C ++ <ref> [ES90] </ref> and other object-oriented languages. A central, unifying idea is that all types in Rapide are expressible using interface types and function types. The Rapide type system supports several forms of parameterization, which coupled with the notion of subtyping, result in very expressive forms of polymorphism. <p> When a subtype designation is used, the result is a form of "partially hidden" type. Overall, an interface is similar in spirit to an Ada package specification (except that packages are not types in Ada) [US 80], the signature part of a C ++ class <ref> [ES90] </ref>, or a Standard ML signature [MTH90] (except that Standard ML modules are only compile-time entities).
Reference: [GR83] <author> A. Goldberg and D. Robson. </author> <title> Smalltalk-80: The language and its implementation. </title> <publisher> Addison Wesley, </publisher> <year> 1983. </year>
Reference-contexts: It also simplifies program modification and maintenance by reducing the amount of redundant or repeated code in a program. In contrast with Smalltalk <ref> [GR83] </ref>, C ++ and other object-oriented languages, Rapide has distinct but parallel inheritance mechanisms for interfaces and implementations. This has proven very useful, for the general reason that interface and implementation inheritance are often used independently and/or in opposite ways.
Reference: [HL94] <author> Robert Harper and Mark Lillibridge. </author> <title> A type-theoretic approach to higher-order modules with sharing. </title> <booktitle> In Proc. 21-st ACM Symp. on Principles of Programming Languages, </booktitle> <year> 1994. </year>
Reference-contexts: any Int Stack Package module. 2 Full type declarations permit the type-checking of incremental definitions of related types, as in the style developed for Standard ML [Mac86, Tof89]. (The relationship between Standard ML type constituents, which are considered "public" by default, and full type declarations in interfaces is discussed in <ref> [HL94, Ler94] </ref>.) Example: Extending the functionality of abstract types type T Package is interface type T; f : function (x:T) return T; end interface; type Ext T Package (t:T Package) is interface type T = t.T; g : function (x:T) return T; end interface; The type T Package defines an abstract
Reference: [Kee89] <author> S.E. Keene. </author> <title> Object-oriented programming in Common Lisp. </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: By applying a type constructor to the interface that is being defined, one may specialize the types of included constituents. This, in fact, gives Rapide the power to program so-called mixins (in the terminology of CLOS <ref> [Kee89] </ref>) without requiring a separate concept. This is illustrate in the following example, which adds equality to points.
Reference: [KLM + 92] <author> D. Katiyar, D.C. Luckham, N. Madhav, S. Meldal, J.C. Mitchell, and S. Sankar. </author> <title> Subtyping, assignment, and cloning in a concurrent object-oriented language. </title> <booktitle> In Proceedings of the DARPA Software Technology Conference, </booktitle> <address> Los Angeles, California., </address> <pages> pages 458-470, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: A more detailed description of the design and rationale of the type system can be found in [KLM94]. A preliminary design of the Rapide type system was described in [MMM91]. Some additional technical points are discussed in <ref> [KLM + 92] </ref>. An early overview of the Rapide approach to prototyping appears in [BL90]. Details of the architecture language can be found in [RAr]. 2 Interface types An interface is defined by a list of declarations.
Reference: [KLM94] <author> Dinesh Katiyar, David Luckham, and John Mitchell. </author> <title> A type system for prototyping languages. </title> <booktitle> In Proc. 21-st ACM Symp. on Principles of Programming Languages, </booktitle> <year> 1994. </year>
Reference-contexts: This paper talks selectively about ideas from the Rapide type system that apply to interface languages, and attempts to motivate them in the setting of an architecture definition language. A more detailed description of the design and rationale of the type system can be found in <ref> [KLM94] </ref>. A preliminary design of the Rapide type system was described in [MMM91]. Some additional technical points are discussed in [KLM + 92]. An early overview of the Rapide approach to prototyping appears in [BL90]. <p> The interface types of the Rapide type system have been used to write the interfaces for all the predefined types supported by the executable language of the framework. These include several types with interesting semantics such as action and reference types (for details, see <ref> [KLM94] </ref>). The exercise of specifying these predefined types as interfaces has illustrated the expressiveness and flexibility of the type system. The detailed interfaces for the predefined types and type constructors are outlined in [RPr].
Reference: [Ler94] <author> Xavier Leroy. </author> <title> Manifest types, modules and separate compilation. </title> <booktitle> In Proc. 21-st ACM Symp. on Principles of Programming Languages, </booktitle> <year> 1994. </year>
Reference-contexts: any Int Stack Package module. 2 Full type declarations permit the type-checking of incremental definitions of related types, as in the style developed for Standard ML [Mac86, Tof89]. (The relationship between Standard ML type constituents, which are considered "public" by default, and full type declarations in interfaces is discussed in <ref> [HL94, Ler94] </ref>.) Example: Extending the functionality of abstract types type T Package is interface type T; f : function (x:T) return T; end interface; type Ext T Package (t:T Package) is interface type T = t.T; g : function (x:T) return T; end interface; The type T Package defines an abstract
Reference: [LST91] <author> D. C. Luckham, S. Sankar, and S. Takahashi. </author> <title> Two dimensional pinpointing: An application of formal specification to debugging packages. </title> <journal> IEEE Software, </journal> <volume> 8(1) </volume> <pages> 74-84, </pages> <month> January </month> <year> 1991. </year> <note> (Also Stanford University Technical Report No. CSL-TR-89-379.). </note>
Reference-contexts: By selectively turning on or off the checking of particular specification elements one may combine decent execution speed with efficient, specification-based high-level error detection and error cause determination <ref> [LST91] </ref>. 3 Parameterized interfaces It is useful to define functions that work uniformly over many types of objects for instance, a quicksort routine that works for all types whose objects can be compared with each other.
Reference: [Mac86] <author> D.B. MacQueen. </author> <title> Using dependent types to express modular structure. </title> <booktitle> In Proc. 13-th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 277-286, </pages> <year> 1986. </year>
Reference-contexts: Using Ada terminology, the type Stack will be a private type of any Int Stack Package module. 2 Full type declarations permit the type-checking of incremental definitions of related types, as in the style developed for Standard ML <ref> [Mac86, Tof89] </ref>. (The relationship between Standard ML type constituents, which are considered "public" by default, and full type declarations in interfaces is discussed in [HL94, Ler94].) Example: Extending the functionality of abstract types type T Package is interface type T; f : function (x:T) return T; end interface; type Ext T
Reference: [MMM91] <author> J.C. Mitchell, S. Meldal, and N. Madhav. </author> <title> An extension of Standard ML modules with subtyping and inheritance. </title> <booktitle> In Proc. 18th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 270-278, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: A more detailed description of the design and rationale of the type system can be found in [KLM94]. A preliminary design of the Rapide type system was described in <ref> [MMM91] </ref>. Some additional technical points are discussed in [KLM + 92]. An early overview of the Rapide approach to prototyping appears in [BL90]. Details of the architecture language can be found in [RAr]. 2 Interface types An interface is defined by a list of declarations.
Reference: [MTH90] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Overall, an interface is similar in spirit to an Ada package specification (except that packages are not types in Ada) [US 80], the signature part of a C ++ class [ES90], or a Standard ML signature <ref> [MTH90] </ref> (except that Standard ML modules are only compile-time entities).
Reference: [RAr] <institution> The PAVG group, Stanford University. </institution> <note> The Rapide Architecture Language Reference Manual. </note>
Reference-contexts: A preliminary design of the Rapide type system was described in [MMM91]. Some additional technical points are discussed in [KLM + 92]. An early overview of the Rapide approach to prototyping appears in [BL90]. Details of the architecture language can be found in <ref> [RAr] </ref>. 2 Interface types An interface is defined by a list of declarations. These may be declarations of object names (where an object is either a module or function) or types. A declaration of an object name associates a type with the identifier, but does not give an implementation. <p> This may be specified by using the external declarations to require that every instance of the type Timer may freely refer to Clk, expecting it to denote some instance of the Clock type. In the Rapide architecture language <ref> [RAr] </ref> the denotation of Clk for a particular Timer instance may change as the execution progresses, in contrast to the effect of making Clk a formal parameter of a function returning new Timers (where the denotation would become fixed at function invocation time).
Reference: [RPr] <institution> The PAVG group, Stanford University. </institution> <note> The Rapide Predefined Types Reference Manual. </note>
Reference-contexts: These include several types with interesting semantics such as action and reference types (for details, see [KLM94]). The exercise of specifying these predefined types as interfaces has illustrated the expressiveness and flexibility of the type system. The detailed interfaces for the predefined types and type constructors are outlined in <ref> [RPr] </ref>. Acknowledgements: We are thankful to the other members of the Rapide project for continuing insightful comments and criticisms.
Reference: [Sny86] <author> A. Snyder. </author> <title> Encapsulation and inheritance in object-oriented programming languages. </title> <booktitle> In Proc. 1-st ACM Symp. on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 38-46, </pages> <month> October </month> <year> 1986. </year>
Reference-contexts: For instance, one would want to define the interface for double-ended queues by extending that for simple queues, whereas the latter can be easily implemented from the former <ref> [Sny86] </ref>. Similarly, the Smalltalk library shows several cases of conflict between the implementation hierarchy and a reasonable interface hierarchy [Coo92]. In Rapide, interface derivation declarations are essentially used to copy declarations from one interface into another.
Reference: [Str86] <author> B. Stroustrop. </author> <title> The C ++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: This is in contrast to subtyping (or subclass) mechanisms relying on explicitly stating the type relations between named types (such as in Ada [US 80], Simula67 [DMN70] and C++ <ref> [Str86] </ref>).
Reference: [Tof89] <author> M. Tofte. </author> <title> Four lectures on Standard ML. </title> <type> Technical Report ECS-LFCS-89-73, </type> <institution> Lab. for Foundations of C.S., University of Edinburgh, </institution> <year> 1989. </year>
Reference-contexts: Using Ada terminology, the type Stack will be a private type of any Int Stack Package module. 2 Full type declarations permit the type-checking of incremental definitions of related types, as in the style developed for Standard ML <ref> [Mac86, Tof89] </ref>. (The relationship between Standard ML type constituents, which are considered "public" by default, and full type declarations in interfaces is discussed in [HL94, Ler94].) Example: Extending the functionality of abstract types type T Package is interface type T; f : function (x:T) return T; end interface; type Ext T
Reference: [US 80] <author> US Dept. </author> <title> of Defense. Reference Manual for the Ada Programming Language. </title> <publisher> GPO 008-000-00354-8, </publisher> <year> 1980. </year>
Reference-contexts: In the default executable language, for example, modules serve as both compile-time groupings of related types and operations, resembling Ada packages <ref> [US 80] </ref>, for example, and as run-time objects of the form found in C ++ [ES90] and other object-oriented languages. A central, unifying idea is that all types in Rapide are expressible using interface types and function types. <p> When a subtype designation is used, the result is a form of "partially hidden" type. Overall, an interface is similar in spirit to an Ada package specification (except that packages are not types in Ada) <ref> [US 80] </ref>, the signature part of a C ++ class [ES90], or a Standard ML signature [MTH90] (except that Standard ML modules are only compile-time entities). <p> This is in contrast to subtyping (or subclass) mechanisms relying on explicitly stating the type relations between named types (such as in Ada <ref> [US 80] </ref>, Simula67 [DMN70] and C++ [Str86]).
References-found: 21

