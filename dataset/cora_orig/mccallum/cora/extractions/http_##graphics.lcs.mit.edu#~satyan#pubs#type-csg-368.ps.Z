URL: http://graphics.lcs.mit.edu/~satyan/pubs/type-csg-368.ps.Z
Refering-URL: http://graphics.lcs.mit.edu/~satyan/pubs.html
Root-URL: 
Email: fshail,satyang@lcs.mit.edu  
Title: A Type System for Functional Imperative Programming (Technical Summary) Computation Structures Group  
Author: Shail Aditya Satyan Coorg 
Affiliation: MIT Laboratory for Computer Science  
Date: July 25, 1994  
Pubnum: Memo 368  
Abstract: The research described in this paper was funded in part by the Advanced Research Projects Agency of the Department of Defense under Office of Naval Research con tract N00014-92-J-1310. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Arvind, Rishiyur S. Nikhil, and Keshav K. Pingali. I-Structures: </author> <title> Data Structures for Parallel Computing. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(4) </volume> <pages> 598-632, </pages> <year> 1989. </year>
Reference-contexts: In general, the close operator can be used to convert arbitrary nonfunctional data-structures like I-structures <ref> [1] </ref> and M-structures [2] into functional ones, retaining all the advantages of using these data-structures inside the close'd expression.
Reference: [2] <author> Paul S. Barth. </author> <title> Atomic Data Structures for Parallel Computing. </title> <type> Technical Report MIT/LCS/TR-532, </type> <institution> Laboratory for Computer Science, Massachusetts Institute of Technology, 545 Technology Square, </institution> <address> Cambridge, MA 02139, </address> <month> March </month> <year> 1992. </year>
Reference-contexts: In general, the close operator can be used to convert arbitrary nonfunctional data-structures like I-structures [1] and M-structures <ref> [2] </ref> into functional ones, retaining all the advantages of using these data-structures inside the close'd expression.
Reference: [3] <author> A. Bloss. </author> <title> Update analysis and the efficient implementation of functional aggregates. </title> <booktitle> In Proceedings of the ACM Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> London, UK. </address> <publisher> ACM Press, </publisher> <month> September </month> <year> 1989. </year>
Reference-contexts: We have chosen to work with the closure typing system because it provides a direct relationship between types and actual structure of objects and a simpler theoretical framework to deal with. A different approach to integrate imperative and (lazy) functional programming has been the focus of many recent papers <ref> [5, 20, 23, 17, 3, 18, 7, 9] </ref>. These papers attempt to introduce assignments 4 into a functional language without destroying its strong functional properties (e.g., confluence and referential transparency). <p> These papers attempt to introduce assignments 4 into a functional language without destroying its strong functional properties (e.g., confluence and referential transparency). To preserve these properties, they ensure that assignments in a program are single-threaded [19] by means of type systems [5, 20, 23], reduction rules [17], dataflow analysis <ref> [3, 18] </ref>, or data abstraction and monadic function composition [7, 9]. Side-effect analysis using regions, such as ours, is orthogonal to the techniques given in these papers and such analysis could be used to make these languages or type systems more permissive.
Reference: [4] <author> Shail Aditya Gupta. </author> <title> A Typed Approach to Layered Programming Language Design. </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <month> December </month> <year> 1994. </year> <note> (In Preparation). </note>
Reference-contexts: The former is a property of the dynamic rules and the latter is ensured by the side condition on the static close rule and Proposition 2. A proof sketch for this case is provided in the appendix. The details appear in <ref> [4] </ref>. The soundness theorem immediately leads us to the following corollary that guarantees that objects with a closed functional type can not be mutated at run-time. <p> Arvind, Xavier Leroy and Yuli Zhou for their helpful comments and suggestions. A Proof Sketch for the Soundness Theorem First, we state some useful properties of the evaluation rules (Figure 1), static rules (Figure 2) and the semantic model (Definition 1). The details of all these proofs appear in <ref> [4] </ref>. A.1 Properties of the Evaluation Rules The following propositions are shown by induction on the length of the evaluation derivation for the expression a, doing a case analysis on the last evaluation rule used in the derivation.
Reference: [5] <author> J. Guzman and P. Hudak. </author> <title> Single-threaded polymorphic lambda calculus. </title> <booktitle> In Proceedings of Fifth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 333-343. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: We have chosen to work with the closure typing system because it provides a direct relationship between types and actual structure of objects and a simpler theoretical framework to deal with. A different approach to integrate imperative and (lazy) functional programming has been the focus of many recent papers <ref> [5, 20, 23, 17, 3, 18, 7, 9] </ref>. These papers attempt to introduce assignments 4 into a functional language without destroying its strong functional properties (e.g., confluence and referential transparency). <p> These papers attempt to introduce assignments 4 into a functional language without destroying its strong functional properties (e.g., confluence and referential transparency). To preserve these properties, they ensure that assignments in a program are single-threaded [19] by means of type systems <ref> [5, 20, 23] </ref>, reduction rules [17], dataflow analysis [3, 18], or data abstraction and monadic function composition [7, 9]. Side-effect analysis using regions, such as ours, is orthogonal to the techniques given in these papers and such analysis could be used to make these languages or type systems more permissive.
Reference: [6] <author> My Hoang, John Mitchell, and Ramesh Viswanathan. </author> <title> Standard ML weak polymorphism and imperative constructs. </title> <booktitle> In Proceedings of the Eighth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 15-25. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1993. </year>
Reference-contexts: to encapsulate such imperative programs that guarantees that the returned array a is non-mutable and is given a polymorphic functional type. 1.2 A Proposal for "Close" There are many existing type systems in the literature that already deal with the problem of extending the Hindley/Milner type system to imperative objects <ref> [6, 10, 11, 14, 21, 22, 24] </ref>. Any one of these may be used to support an imperative kernel language in a type-safe manner.
Reference: [7] <author> P. Hudak and D. Rabin. </author> <title> Mutable abstract datatypes or- how to have your state and munge it too. </title> <type> Technical Report YALEU/DCS/RR-914, </type> <institution> Yale University, Department of Computer Science, </institution> <month> July </month> <year> 1992. </year>
Reference-contexts: We have chosen to work with the closure typing system because it provides a direct relationship between types and actual structure of objects and a simpler theoretical framework to deal with. A different approach to integrate imperative and (lazy) functional programming has been the focus of many recent papers <ref> [5, 20, 23, 17, 3, 18, 7, 9] </ref>. These papers attempt to introduce assignments 4 into a functional language without destroying its strong functional properties (e.g., confluence and referential transparency). <p> To preserve these properties, they ensure that assignments in a program are single-threaded [19] by means of type systems [5, 20, 23], reduction rules [17], dataflow analysis [3, 18], or data abstraction and monadic function composition <ref> [7, 9] </ref>. Side-effect analysis using regions, such as ours, is orthogonal to the techniques given in these papers and such analysis could be used to make these languages or type systems more permissive.
Reference: [8] <editor> P. Hudak and P. Wadler (editors). </editor> <title> Report on the programming language Haskell, a non-strict purely functional language (Version 1.0). </title> <type> Technical Report YALEU/DCS/RR777, </type> <institution> Yale University, Department of Computer Science, </institution> <month> April </month> <year> 1990. </year>
Reference-contexts: In this paper, we propose a type system which provides a reasonable solution to this problem in the context of the implicitly parallel and mostly functional programming languages Id [15] and pH [16] (a parallel version of Haskell <ref> [8] </ref>). 1.1 The Problem Consider the problem of implementing functional arrays that are homogeneous, non-mutable, polymorphic arrays. The function make vector creates a one dimensional functional array that memo-izes a computation for a given index range.
Reference: [9] <author> John Launchbury and Simon L. Peyton Jones. </author> <title> Lazy Functional State Threads. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <address> Orlando, Florida, USA. </address> <publisher> ACM Press, </publisher> <month> June </month> <year> 1994. </year> <month> 15 </month>
Reference-contexts: We have chosen to work with the closure typing system because it provides a direct relationship between types and actual structure of objects and a simpler theoretical framework to deal with. A different approach to integrate imperative and (lazy) functional programming has been the focus of many recent papers <ref> [5, 20, 23, 17, 3, 18, 7, 9] </ref>. These papers attempt to introduce assignments 4 into a functional language without destroying its strong functional properties (e.g., confluence and referential transparency). <p> To preserve these properties, they ensure that assignments in a program are single-threaded [19] by means of type systems [5, 20, 23], reduction rules [17], dataflow analysis [3, 18], or data abstraction and monadic function composition <ref> [7, 9] </ref>. Side-effect analysis using regions, such as ours, is orthogonal to the techniques given in these papers and such analysis could be used to make these languages or type systems more permissive.
Reference: [10] <author> Xavier Leroy. </author> <title> Polymorphic Typing of an Algorithmic Language. </title> <institution> Rapports de Recherche 1778, INRIA, Rocquencourt, France, </institution> <month> October </month> <year> 1992. </year> <title> English translation of the author's Ph.D. </title> <note> thesis originally in French. </note>
Reference-contexts: to encapsulate such imperative programs that guarantees that the returned array a is non-mutable and is given a polymorphic functional type. 1.2 A Proposal for "Close" There are many existing type systems in the literature that already deal with the problem of extending the Hindley/Milner type system to imperative objects <ref> [6, 10, 11, 14, 21, 22, 24] </ref>. Any one of these may be used to support an imperative kernel language in a type-safe manner. <p> This directly implies that in a type-correct program, it is not possible to mutate an object once it is converted into a functional type. 1.5 Related Work The Closure Typing system proposed by Leroy <ref> [10] </ref> is the basis of our work. This powerful type system was designed to determine when type-generalization was safe in the presence of side-effects. <p> Although Talpin and Jouvelot [21] use regions to mask side-effects that are not visible from outside, they do not convert imperative data-structures into functional ones. However, as it seems that their system is at least as powerful as the closure typing system <ref> [10] </ref>, we conjecture that our system can be adapted to work in their framework. We have chosen to work with the closure typing system because it provides a direct relationship between types and actual structure of objects and a simpler theoretical framework to deal with. <p> from the fact that even if we make the language non-deterministic by adding an additional app rule which interchanges the order in which the function and the argument are evaluated, our results on close still hold. 3 3 Static Semantics Now we will briefly describe Xavier Leroy's closure typing system <ref> [10] </ref> and our extensions to it. A type t in our system is defined by: types: t ::= t j j t 1 hi! t 2 j t ref (r) j t ref (*) where t corresponds to an ordinary type variable and corresponds to a base type. <p> Thus, no write handle to the location l is escaping and it can be safely closed. A compile-time close-error is flagged if this check fails. As an aside, we note that a type inference algorithm can be designed for this type system along the lines of <ref> [10] </ref>. We do not discuss that here, the reader is referred to [10] for details. 4 Type Soundness 4.1 Semantic Consistency In order to show the soundness of the typing judgments generated by the above type system with respect to its evaluation rules, we must precisely characterize a "consistent" semantic relationship <p> A compile-time close-error is flagged if this check fails. As an aside, we note that a type inference algorithm can be designed for this type system along the lines of <ref> [10] </ref>. We do not discuss that here, the reader is referred to [10] for details. 4 Type Soundness 4.1 Semantic Consistency In order to show the soundness of the typing judgments generated by the above type system with respect to its evaluation rules, we must precisely characterize a "consistent" semantic relationship between value-domain entities and their corresponding type-domain entities.
Reference: [11] <author> Xavier Leroy and Pierre Weis. </author> <title> Polymorphic type inference and assignment. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 291-302. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1991. </year>
Reference-contexts: to encapsulate such imperative programs that guarantees that the returned array a is non-mutable and is given a polymorphic functional type. 1.2 A Proposal for "Close" There are many existing type systems in the literature that already deal with the problem of extending the Hindley/Milner type system to imperative objects <ref> [6, 10, 11, 14, 21, 22, 24] </ref>. Any one of these may be used to support an imperative kernel language in a type-safe manner.
Reference: [12] <author> John M. Lucassen and David K. Gifford. </author> <title> Polymorphic Effect Systems. </title> <booktitle> In Proceedings of the Fifteenth Annual ACM SIGACT-SIGPLAN Symposium on Principles of Programming languages, </booktitle> <address> San Diego, California, </address> <pages> pages 47-57, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: This powerful type system was designed to determine when type-generalization was safe in the presence of side-effects. Our contribution is adding regions to this type system and recognizing that such a system has all the information needed to express and verify type-coercions between imperative and functional data-structures. Effect systems <ref> [12, 21, 24] </ref> are closely related to our work. Effects and regions in this type system describe the side effects that expression can have. Effect systems are able to determine when it is safe to evaluate expressions in parallel [12], and when to permit type-generalization [21, 24]. <p> Effect systems [12, 21, 24] are closely related to our work. Effects and regions in this type system describe the side effects that expression can have. Effect systems are able to determine when it is safe to evaluate expressions in parallel <ref> [12] </ref>, and when to permit type-generalization [21, 24]. Although Talpin and Jouvelot [21] use regions to mask side-effects that are not visible from outside, they do not convert imperative data-structures into functional ones.
Reference: [13] <author> Robin Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: (r) typeof (! mutable ) = 8t; u; r: t ref (r) hui! t typeof (! non-mutable ) = 8t; u: t ref (*) hui! t typeof (:=) = 8t; u; r: (t ref (r); t) hui! unit The const, ident, app, and let rules are standard Hindley/Milner typing rules <ref> [13] </ref>.
Reference: [14] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: to encapsulate such imperative programs that guarantees that the returned array a is non-mutable and is given a polymorphic functional type. 1.2 A Proposal for "Close" There are many existing type systems in the literature that already deal with the problem of extending the Hindley/Milner type system to imperative objects <ref> [6, 10, 11, 14, 21, 22, 24] </ref>. Any one of these may be used to support an imperative kernel language in a type-safe manner. <p> Section 5 describes a few extensions to the basic type system and Section 6 concludes. 2 Dynamic Semantics of a Mini-Language with "Close" 2.1 Syntax The expression syntax of our mini-language is given below. For simplicity, the language provides ML-like references <ref> [14] </ref> as the only means of creating mutable data structures.
Reference: [15] <author> Rishiyur S. Nikhil. </author> <title> Id Language Reference Manual Version 90.1. </title> <type> Technical Report CSG Memo 284-2, </type> <institution> MIT Laboratory for Computer Science, 545 Technology Square, </institution> <address> Cambridge, MA 02139, </address> <month> July 15 </month> <year> 1991. </year>
Reference-contexts: In this paper, we propose a type system which provides a reasonable solution to this problem in the context of the implicitly parallel and mostly functional programming languages Id <ref> [15] </ref> and pH [16] (a parallel version of Haskell [8]). 1.1 The Problem Consider the problem of implementing functional arrays that are homogeneous, non-mutable, polymorphic arrays. The function make vector creates a one dimensional functional array that memo-izes a computation for a given index range.
Reference: [16] <author> Rishiyur S. Nikhil, Arvind, and James Hicks. </author> <title> pH Language Proposal (Preliminary). Circulated on the pH mailing list, </title> <month> September </month> <year> 1993. </year>
Reference-contexts: In this paper, we propose a type system which provides a reasonable solution to this problem in the context of the implicitly parallel and mostly functional programming languages Id [15] and pH <ref> [16] </ref> (a parallel version of Haskell [8]). 1.1 The Problem Consider the problem of implementing functional arrays that are homogeneous, non-mutable, polymorphic arrays. The function make vector creates a one dimensional functional array that memo-izes a computation for a given index range.
Reference: [17] <author> M. Odersky, D. Rabin, and P. Hudak. </author> <title> Call by Name, Assignment, and the Lambda Calculus. </title> <booktitle> In Proceedings of the 1993 ACM Conference on Principles of Programming Languages, </booktitle> <pages> pages 43-56. </pages> <publisher> ACM Press, </publisher> <year> 1993. </year>
Reference-contexts: We have chosen to work with the closure typing system because it provides a direct relationship between types and actual structure of objects and a simpler theoretical framework to deal with. A different approach to integrate imperative and (lazy) functional programming has been the focus of many recent papers <ref> [5, 20, 23, 17, 3, 18, 7, 9] </ref>. These papers attempt to introduce assignments 4 into a functional language without destroying its strong functional properties (e.g., confluence and referential transparency). <p> These papers attempt to introduce assignments 4 into a functional language without destroying its strong functional properties (e.g., confluence and referential transparency). To preserve these properties, they ensure that assignments in a program are single-threaded [19] by means of type systems [5, 20, 23], reduction rules <ref> [17] </ref>, dataflow analysis [3, 18], or data abstraction and monadic function composition [7, 9]. Side-effect analysis using regions, such as ours, is orthogonal to the techniques given in these papers and such analysis could be used to make these languages or type systems more permissive.
Reference: [18] <author> A. V. S. Sastry, William Clinger, and Zena Ariola. </author> <title> Order-of-evaluation Analysis for Destructive Updates in Strict Functional Languages with Flat Aggregates. </title> <booktitle> In Proceedings of the Conference on Functional Programming Languages and Computer Architecture, Copenhagen, Denmark, </booktitle> <pages> pages 266-275. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1993. </year>
Reference-contexts: We have chosen to work with the closure typing system because it provides a direct relationship between types and actual structure of objects and a simpler theoretical framework to deal with. A different approach to integrate imperative and (lazy) functional programming has been the focus of many recent papers <ref> [5, 20, 23, 17, 3, 18, 7, 9] </ref>. These papers attempt to introduce assignments 4 into a functional language without destroying its strong functional properties (e.g., confluence and referential transparency). <p> These papers attempt to introduce assignments 4 into a functional language without destroying its strong functional properties (e.g., confluence and referential transparency). To preserve these properties, they ensure that assignments in a program are single-threaded [19] by means of type systems [5, 20, 23], reduction rules [17], dataflow analysis <ref> [3, 18] </ref>, or data abstraction and monadic function composition [7, 9]. Side-effect analysis using regions, such as ours, is orthogonal to the techniques given in these papers and such analysis could be used to make these languages or type systems more permissive.
Reference: [19] <author> D. Schmidt. </author> <title> Detecting global variables in denotational specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(2) </volume> <pages> 299-310, </pages> <year> 1985. </year>
Reference-contexts: These papers attempt to introduce assignments 4 into a functional language without destroying its strong functional properties (e.g., confluence and referential transparency). To preserve these properties, they ensure that assignments in a program are single-threaded <ref> [19] </ref> by means of type systems [5, 20, 23], reduction rules [17], dataflow analysis [3, 18], or data abstraction and monadic function composition [7, 9].
Reference: [20] <author> V. Swarup, U. S. Reddy, and E. Ireland. </author> <title> Assignments for applicative languages. </title> <booktitle> In Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 192-214. </pages> <publisher> Springer-Verlag, </publisher> <month> February </month> <year> 1991. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> volume 523. </volume>
Reference-contexts: We have chosen to work with the closure typing system because it provides a direct relationship between types and actual structure of objects and a simpler theoretical framework to deal with. A different approach to integrate imperative and (lazy) functional programming has been the focus of many recent papers <ref> [5, 20, 23, 17, 3, 18, 7, 9] </ref>. These papers attempt to introduce assignments 4 into a functional language without destroying its strong functional properties (e.g., confluence and referential transparency). <p> These papers attempt to introduce assignments 4 into a functional language without destroying its strong functional properties (e.g., confluence and referential transparency). To preserve these properties, they ensure that assignments in a program are single-threaded [19] by means of type systems <ref> [5, 20, 23] </ref>, reduction rules [17], dataflow analysis [3, 18], or data abstraction and monadic function composition [7, 9]. Side-effect analysis using regions, such as ours, is orthogonal to the techniques given in these papers and such analysis could be used to make these languages or type systems more permissive.
Reference: [21] <author> Jean-Pierre Talpin and Pierre Jouvelot. </author> <title> The Type and Effect Discipline. </title> <booktitle> In Proceedings of the ACM Symposium on Logic in Computer Science, </booktitle> <pages> pages 162-173. </pages> <publisher> ACM Press, </publisher> <year> 1992. </year>
Reference-contexts: to encapsulate such imperative programs that guarantees that the returned array a is non-mutable and is given a polymorphic functional type. 1.2 A Proposal for "Close" There are many existing type systems in the literature that already deal with the problem of extending the Hindley/Milner type system to imperative objects <ref> [6, 10, 11, 14, 21, 22, 24] </ref>. Any one of these may be used to support an imperative kernel language in a type-safe manner. <p> This powerful type system was designed to determine when type-generalization was safe in the presence of side-effects. Our contribution is adding regions to this type system and recognizing that such a system has all the information needed to express and verify type-coercions between imperative and functional data-structures. Effect systems <ref> [12, 21, 24] </ref> are closely related to our work. Effects and regions in this type system describe the side effects that expression can have. Effect systems are able to determine when it is safe to evaluate expressions in parallel [12], and when to permit type-generalization [21, 24]. <p> Effect systems [12, 21, 24] are closely related to our work. Effects and regions in this type system describe the side effects that expression can have. Effect systems are able to determine when it is safe to evaluate expressions in parallel [12], and when to permit type-generalization <ref> [21, 24] </ref>. Although Talpin and Jouvelot [21] use regions to mask side-effects that are not visible from outside, they do not convert imperative data-structures into functional ones. <p> Effects and regions in this type system describe the side effects that expression can have. Effect systems are able to determine when it is safe to evaluate expressions in parallel [12], and when to permit type-generalization [21, 24]. Although Talpin and Jouvelot <ref> [21] </ref> use regions to mask side-effects that are not visible from outside, they do not convert imperative data-structures into functional ones.
Reference: [22] <author> Mads Tofte. </author> <title> Type Inference for Polymorphic References. </title> <journal> Information and Computation, </journal> <volume> 89 </volume> <pages> 1-34, </pages> <year> 1990. </year>
Reference-contexts: There is no guarantee that the user will not tamper with the contents of the array once it is returned. Furthermore, in order to be sound, mutable objects must be restricted in polymorphism <ref> [22] </ref> which is not what we want for fully polymorphic functional arrays. In order to express the above code in a standard library, the language must support an imperative kernel in which low-level imperative operations such as memory allocation and assignment are permitted. <p> to encapsulate such imperative programs that guarantees that the returned array a is non-mutable and is given a polymorphic functional type. 1.2 A Proposal for "Close" There are many existing type systems in the literature that already deal with the problem of extending the Hindley/Milner type system to imperative objects <ref> [6, 10, 11, 14, 21, 22, 24] </ref>. Any one of these may be used to support an imperative kernel language in a type-safe manner.
Reference: [23] <editor> Philip Wadler. </editor> <booktitle> Linear types can change the world! In Proceedings of the Working Conference on Programming Concepts and Methods, Israel, </booktitle> <pages> pages 385-407. </pages> <publisher> North-Holland, </publisher> <year> 1990. </year>
Reference-contexts: We have chosen to work with the closure typing system because it provides a direct relationship between types and actual structure of objects and a simpler theoretical framework to deal with. A different approach to integrate imperative and (lazy) functional programming has been the focus of many recent papers <ref> [5, 20, 23, 17, 3, 18, 7, 9] </ref>. These papers attempt to introduce assignments 4 into a functional language without destroying its strong functional properties (e.g., confluence and referential transparency). <p> These papers attempt to introduce assignments 4 into a functional language without destroying its strong functional properties (e.g., confluence and referential transparency). To preserve these properties, they ensure that assignments in a program are single-threaded [19] by means of type systems <ref> [5, 20, 23] </ref>, reduction rules [17], dataflow analysis [3, 18], or data abstraction and monadic function composition [7, 9]. Side-effect analysis using regions, such as ours, is orthogonal to the techniques given in these papers and such analysis could be used to make these languages or type systems more permissive.
Reference: [24] <author> Andrew K. Wright. </author> <title> Typing References by Effect Inference. </title> <booktitle> In Proceedings of the 4th European Symposium on Programming, Rennes, France, </booktitle> <pages> pages 473-491. </pages> <publisher> Springer-Verlag, </publisher> <month> February </month> <year> 1992. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> volume 582. </volume> <pages> 16 </pages>
Reference-contexts: to encapsulate such imperative programs that guarantees that the returned array a is non-mutable and is given a polymorphic functional type. 1.2 A Proposal for "Close" There are many existing type systems in the literature that already deal with the problem of extending the Hindley/Milner type system to imperative objects <ref> [6, 10, 11, 14, 21, 22, 24] </ref>. Any one of these may be used to support an imperative kernel language in a type-safe manner. <p> This powerful type system was designed to determine when type-generalization was safe in the presence of side-effects. Our contribution is adding regions to this type system and recognizing that such a system has all the information needed to express and verify type-coercions between imperative and functional data-structures. Effect systems <ref> [12, 21, 24] </ref> are closely related to our work. Effects and regions in this type system describe the side effects that expression can have. Effect systems are able to determine when it is safe to evaluate expressions in parallel [12], and when to permit type-generalization [21, 24]. <p> Effect systems [12, 21, 24] are closely related to our work. Effects and regions in this type system describe the side effects that expression can have. Effect systems are able to determine when it is safe to evaluate expressions in parallel [12], and when to permit type-generalization <ref> [21, 24] </ref>. Although Talpin and Jouvelot [21] use regions to mask side-effects that are not visible from outside, they do not convert imperative data-structures into functional ones.
References-found: 24

