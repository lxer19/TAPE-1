URL: ftp://ftp.cse.ucsc.edu/pub/tr/ucsc-crl-92-28.ps.Z
Refering-URL: ftp://ftp.cse.ucsc.edu/pub/tr/README.html
Root-URL: http://www.cse.ucsc.edu
Title: Precompiling C++ for Garbage Collection  
Author: Daniel R. Edelson 
Address: Santa Cruz, CA 95064 USA  
Affiliation: Baskin Center for Computer Engineering Information Sciences University of California, Santa Cruz  
Date: 23 June 1992  
Pubnum: UCSC-CRL-92-28  
Abstract: fl Part of this research was performed while the author was a visiting researcher at INRIA Project SOR, BP 105 Rocquencourt, 78153 Le Chesnay CEDEX, FRANCE. This research was supported in part by Esprit project 5279 Harness. This paper first appeared in Proc. 1992 International Workshop on Memory Management, Springer-Verlag, 1992. 
Abstract-found: 1
Intro-found: 1
Reference: <institution> References </institution>
Reference: [1] <editor> ACM. </editor> <booktitle> Proc. PLDI '91 (June 1991). SIGPLAN Not. </booktitle> <pages> 26(6). </pages>
Reference: [2] <author> Appel, A. W. </author> <title> Runtime tags aren't necessary. </title> <booktitle> In Lisp and Symbolic Computation (1989), </booktitle> <volume> vol. 2, </volume> <pages> pp. 153-162. </pages>
Reference-contexts: While not overly verbose, the programming style that this utilizes is quite different from the standard C ++ style and such long macros can make debugging difficult. 2.3. Type-Accurate Techniques 5 Goldberg describes tag-free garbage collection for polymorphic statically-typed languages using compile-time information [23], building on work by Appel <ref> [2] </ref>, who in turn builds on techniques that were invented for Algol-68 and Pascal. Goldberg's compiler emits functions that know how to locate the pointers in all necessary activation records of the program.
Reference: [3] <author> Appel, A. W., and Li, K. </author> <title> Virtual memory primitives for user programs. </title> <booktitle> In ASPLOS Inter. Conf. Architectural Support for Programming Languages and Operating Systems (Santa Clara, </booktitle> <address> CA (USA), </address> <month> Apr. </month> <year> 1991), </year> <pages> pp. 96-107. </pages> <booktitle> SIGPLAN Not. </booktitle> <pages> 26(4). </pages>
Reference-contexts: In this implementation, however, when a cell is removed from the free list, its value is immediately fetched. That fetch is used to avoid the test and branch. The last page of the last cell array is read-protected <ref> [3] </ref>. Attempting to load the link stored in the first cell on the read-protected page causes the program to receive a signal. The signal handler unprotects the page, links in and initializes a new cell array, and read-protects the last page of the new array.
Reference: [4] <author> Bartlett, J. F. </author> <title> Compacting garbage collection with ambiguous roots. </title> <type> Tech. Rep. 88/2, </type> <institution> Digital Equipment Corporation, Western Research Laboratory, Palo Alto, California, </institution> <month> Feb. </month> <year> 1988. </year>
Reference-contexts: Since it has its bad cases, it is worthwhile to investigate type-accurate techniques for C ++ . 2.2 Partially Conservative Bartlett's Mostly Copying Collector is a generational garbage collector for Scheme [14] and C ++ [39] that uses both conservative and copying techniques <ref> [4, 5] </ref>. This collector divides the heap into logical pages, each of which has a space-identifier. During a collection 4 2.
Reference: [5] <author> Bartlett, J. F. </author> <title> Mostly copying garbage collection picks up generations and C++. </title> <type> Tech. Rep. </type> <institution> TN-12, DEC WRL, </institution> <month> Oct. </month> <year> 1989. </year>
Reference-contexts: The proposals span the entire spectrum of techniques including: * compiler-based concurrent atomic mostly-copying garbage collection [12], * library-based reference counting and mark-and-sweep GC [27], * library-based mostly copying generational garbage collection <ref> [5] </ref>, * library-based reference counting through smart pointers [28, 29] (Smart pointers are discussed momentarily), * library-based mark-and-sweep GC using smart pointers [16], * compiler-based GC using smart pointers [22], * library-based mark-and-sweep and generational copying collection using macros [21], and, * library-based conservative generational mark-and-sweep GC [8, 11]. <p> Since it has its bad cases, it is worthwhile to investigate type-accurate techniques for C ++ . 2.2 Partially Conservative Bartlett's Mostly Copying Collector is a generational garbage collector for Scheme [14] and C ++ [39] that uses both conservative and copying techniques <ref> [4, 5] </ref>. This collector divides the heap into logical pages, each of which has a space-identifier. During a collection 4 2.
Reference: [6] <author> Boehm, H.-J. </author> <title> Simple gc-safe compilation. </title> <booktitle> Workshop on GC in Object Oriented Systems at OOPSLA '91, </booktitle> <year> 1991. </year>
Reference-contexts: Since they are fully conservative, during a collection these collectors must examine every word of the stack, of global data, and of every marked object. Boehm discusses compiler changes to preclude optimizations that would cause a conservative garbage collector to reclaim data that is actually accessible <ref> [6] </ref>. Zorn has measured the cost of conservative garbage collection and found that it compares favorably not just with manual allocation, but even with optimized manual allocation [44]. Conservative collectors sometimes retain more garbage than type-accurate collectors because conservative collectors interpret non-pointer data as pointers.
Reference: [7] <author> Boehm, H.-J., Demers, A. J., and Shenker, S. </author> <title> Mostly parallel garbage collection. </title> <booktitle> In Proc. PLDI '91 [1], </booktitle> <pages> pp. 157-164. </pages> <booktitle> SIGPLAN Not. </booktitle> <pages> 26(6). </pages>
Reference-contexts: field of GC, in C ++ software tools, and specifically in collectors for C ++ . 2.1 Conservative GC Conservative garbage collection is a technique in which the collector does not have access to type information so it assumes that anything that might be a pointer actually is a pointer <ref> [7, 8] </ref>. For example, upon examining a quantity that the program interprets as an integer, but whose value is such that it also could be a pointer, the collector assumes the value to be a pointer. <p> This is a useful technique for accomplishing compiler-independent garbage collection in programming languages that do not use tagged pointers. Boehm, Demers, et al. describe conservative, generational, parallel mark-and-sweep garbage collection <ref> [7, 8, 11] </ref> for languages such as C. Russo has adapted these techniques for use in an object-oriented operating system written in C ++ [32, 34].
Reference: [8] <author> Boehm, H.-J., and Weiser, M. </author> <title> Garbage collection in an uncooperative environment. </title> <journal> Softw. - Pract. Exp. </journal> <volume> 18, </volume> <month> 9 (Sept. </month> <year> 1988), </year> <pages> 807-820. </pages>
Reference-contexts: generational garbage collection [5], * library-based reference counting through smart pointers [28, 29] (Smart pointers are discussed momentarily), * library-based mark-and-sweep GC using smart pointers [16], * compiler-based GC using smart pointers [22], * library-based mark-and-sweep and generational copying collection using macros [21], and, * library-based conservative generational mark-and-sweep GC <ref> [8, 11] </ref>. The vast number of proposals, without the widespread acceptance of any one, reflects how hard the problem is. In the past, we have proposed implementing GC strictly in application-code: GC implemented in a library. <p> field of GC, in C ++ software tools, and specifically in collectors for C ++ . 2.1 Conservative GC Conservative garbage collection is a technique in which the collector does not have access to type information so it assumes that anything that might be a pointer actually is a pointer <ref> [7, 8] </ref>. For example, upon examining a quantity that the program interprets as an integer, but whose value is such that it also could be a pointer, the collector assumes the value to be a pointer. <p> This is a useful technique for accomplishing compiler-independent garbage collection in programming languages that do not use tagged pointers. Boehm, Demers, et al. describe conservative, generational, parallel mark-and-sweep garbage collection <ref> [7, 8, 11] </ref> for languages such as C. Russo has adapted these techniques for use in an object-oriented operating system written in C ++ [32, 34].
Reference: [9] <author> Christopher, T. W. </author> <title> Reference count garbage collection. </title> <journal> Softw. - Pract. Exp. </journal> <volume> 14, 6 (1984), </volume> <pages> 503-508. </pages>
Reference-contexts: In OATH, objects are accessed exclusively through application-level references called accessors, that are very similar to stubs because they duplicate the interfaces of their target objects. Accessors implement reference counting on the objects that they reference. The reference counts are used to implement a three-phase mark-and-sweep garbage collection algorithm <ref> [9] </ref> that proceeds as follows. First, OATH scans the objects to eliminate from the reference counts all references between objects. After that, all objects with non-zero reference counts are root-referenced. The root-referenced objects serve as the roots for a standard mark-and-sweep collection, during which the reference counts are restored.
Reference: [10] <author> Coplien, J. </author> <title> Advanced C++ Programming Styles and Idioms. </title> <publisher> Addison-Wesley, </publisher> <year> 1992. </year>
Reference-contexts: Smart pointers can be used for a variety for purposes. For example: 2 1. Introduction * reference counting <ref> [10, 27, 28, 29, 39] </ref>, * convenient access to both transient and persistent objects [36, 39], * uniform access to local or distributed objects [24, 35, 37], * synchronizing operations on objects [39, p. 464], * tracing garbage collection [16, 18, 27], * instrumenting the code, * or others.
Reference: [11] <author> Demers, A., Weiser, M., Hayes, B., Boehm, H., Bobrow, D., and Shenker, S. </author> <title> Combining generational and conservative garbage collection: Framework and implementations. </title> <booktitle> In Proc. POPL '90 (Jan. 1990), ACM, ACM, </booktitle> <pages> pp. 261-269. </pages>
Reference-contexts: generational garbage collection [5], * library-based reference counting through smart pointers [28, 29] (Smart pointers are discussed momentarily), * library-based mark-and-sweep GC using smart pointers [16], * compiler-based GC using smart pointers [22], * library-based mark-and-sweep and generational copying collection using macros [21], and, * library-based conservative generational mark-and-sweep GC <ref> [8, 11] </ref>. The vast number of proposals, without the widespread acceptance of any one, reflects how hard the problem is. In the past, we have proposed implementing GC strictly in application-code: GC implemented in a library. <p> This is a useful technique for accomplishing compiler-independent garbage collection in programming languages that do not use tagged pointers. Boehm, Demers, et al. describe conservative, generational, parallel mark-and-sweep garbage collection <ref> [7, 8, 11] </ref> for languages such as C. Russo has adapted these techniques for use in an object-oriented operating system written in C ++ [32, 34].
Reference: [12] <author> Detlefs, D. </author> <title> Concurrent garbage collection for C++. </title> <type> Tech. Rep. CMU-CS-90-119, </type> <institution> Carnegie Mellon, </institution> <year> 1990. </year>
Reference-contexts: In spite of the difficulty, an enormous amount of work has been and continues to be done in attempting to provide garbage collection in C ++ . The proposals span the entire spectrum of techniques including: * compiler-based concurrent atomic mostly-copying garbage collection <ref> [12] </ref>, * library-based reference counting and mark-and-sweep GC [27], * library-based mostly copying generational garbage collection [5], * library-based reference counting through smart pointers [28, 29] (Smart pointers are discussed momentarily), * library-based mark-and-sweep GC using smart pointers [16], * compiler-based GC using smart pointers [22], * library-based mark-and-sweep and generational
Reference: [13] <author> Dickman, P. </author> <title> Trading space for time in the garbage collection of actors. In unpublished form, </title> <year> 1992. </year>
Reference-contexts: Yasugi and Yonezawa discuss user-level garbage collection for the concurrent object-oriented programming language ABCL/1 [43]. Their programming language is based on active objects, thus, the garbage collection requirements for this language are basically the same as for garbage collection of Actors <ref> [13, 25] </ref>. Ferreira discusses a C ++ library that provides garbage collection for C ++ programs [21]. The library supplies both incremental mark-and-sweep and generational copy collection, and supports pointers to the interiors of objects.
Reference: [14] <author> Dybvig, K. R. </author> <title> The SCHEME Programming Language. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1987. </year>
Reference-contexts: As these examples illustrate, conservative collection is a very useful technique, but it is not a panacea. Since it has its bad cases, it is worthwhile to investigate type-accurate techniques for C ++ . 2.2 Partially Conservative Bartlett's Mostly Copying Collector is a generational garbage collector for Scheme <ref> [14] </ref> and C ++ [39] that uses both conservative and copying techniques [4, 5]. This collector divides the heap into logical pages, each of which has a space-identifier. During a collection 4 2.
Reference: [15] <author> Dykstra, D. </author> <title> Conventions on the use of ObjectStars, 1992. </title> <type> Private communication. </type>
Reference-contexts: This was observed to be true of the ObjectStars, and therefore the following convention was adopted: Whenever an ObjectStar is returned from a function, it must first be assigned to a variable; it cannot be immediately dereferenced <ref> [15] </ref>. This prevents that particular error. 6 3. Garbage Collecting C++ Code 3. Garbage Collecting C++ Code The program's dynamically allocated garbage collected objects are collectively referred to as the data structure.
Reference: [16] <author> Edelson, D. R. </author> <title> Comparing two garbage collectors for C++. In unpublished form, </title> <year> 1992. </year>
Reference-contexts: entire spectrum of techniques including: * compiler-based concurrent atomic mostly-copying garbage collection [12], * library-based reference counting and mark-and-sweep GC [27], * library-based mostly copying generational garbage collection [5], * library-based reference counting through smart pointers [28, 29] (Smart pointers are discussed momentarily), * library-based mark-and-sweep GC using smart pointers <ref> [16] </ref>, * compiler-based GC using smart pointers [22], * library-based mark-and-sweep and generational copying collection using macros [21], and, * library-based conservative generational mark-and-sweep GC [8, 11]. The vast number of proposals, without the widespread acceptance of any one, reflects how hard the problem is. <p> For example: 2 1. Introduction * reference counting [10, 27, 28, 29, 39], * convenient access to both transient and persistent objects [36, 39], * uniform access to local or distributed objects [24, 35, 37], * synchronizing operations on objects [39, p. 464], * tracing garbage collection <ref> [16, 18, 27] </ref>, * instrumenting the code, * or others. Section 2 discusses how existing systems use smart pointers for memory management. A discussion of various issues concerning smart pointers can be found in [17]. Our imple mentation of smart pointers is presented in x3.1. 3 2. <p> To aid the programming task, he is investigating augmenting the conservative garbage collector with weak pointers [30], i.e. references that do not cause objects to be retained. Finally, we have tested conservative garbage collection with a CAD software tool called ITEM <ref> [16, 26] </ref>. This application creates large data structures that are strongly connected when they become garbage. A single false pointer into the data structure keeps the entire mass of data from being reclaimed. Thus, our brief efforts with conservative collection in this application proved unsuccessful. <p> The actual space overhead is greater than that because the root table grows in increments of 8 kilobytes. Measurements of the efficiency of these smart pointers show them to be more expensive than raw pointers but less expensive than reference counted pointers <ref> [16] </ref>. If a global register 3.2. Locating Internal Pointers 9 can be dedicated to the Root Table, then initializing a new smart pointer requires two memory references and destroying one requires one memory reference.
Reference: [17] <author> Edelson, D. R. </author> <title> Smart pointers: They're smart but they're not pointers. </title> <booktitle> In Proc. Usenix C++ Technical Conference (Aug. 1992), Usenix Association, </booktitle> <pages> pp. 1-19. </pages>
Reference-contexts: Section 2 discusses how existing systems use smart pointers for memory management. A discussion of various issues concerning smart pointers can be found in <ref> [17] </ref>. Our imple mentation of smart pointers is presented in x3.1. 3 2. <p> The term root is used to refer to the smart pointer objects. In contrast, the built-in pointers, i.e. the pointers that are directly supported by the compiler and the hardware, are called raw pointers. A problem with smart pointers is that they can be nontrivial to code <ref> [17] </ref>. The problem arises from emulating the implicit type conversions of raw pointers. For example, a raw pointer of type Tfl can be implicitly converted to type const Tfl, based on the safety of converting an unrestricted pointer to a pointer that permits only read accesses. <p> When the application classes are related through inheritance, the precompiler gives the derived class smart pointers user-defined type conversions to the base class smart pointer types. A detailed description of this organization can be found in <ref> [17] </ref>. The precompiler parses the program to determine what smart pointer classes are needed and writes the classes to a file. Then, the preprocessed and otherwise transformed application code is appended. A typical smart pointer class is shown in Fig. 3.3. This shows the smart pointer class for const objects.
Reference: [18] <author> Edelson, D. R., and Pohl, I. </author> <title> A copying collector for C++. </title> <booktitle> In Proc. Usenix C++ Conference [40], </booktitle> <pages> pp. 85-102. </pages>
Reference-contexts: For example: 2 1. Introduction * reference counting [10, 27, 28, 29, 39], * convenient access to both transient and persistent objects [36, 39], * uniform access to local or distributed objects [24, 35, 37], * synchronizing operations on objects [39, p. 464], * tracing garbage collection <ref> [16, 18, 27] </ref>, * instrumenting the code, * or others. Section 2 discusses how existing systems use smart pointers for memory management. A discussion of various issues concerning smart pointers can be found in [17]. Our imple mentation of smart pointers is presented in x3.1. 3 2.
Reference: [19] <author> Ellis, J. </author> <title> Confirmation of unreachability after finalization, 1992. </title> <type> Private communication. </type>
Reference-contexts: Therefore, in order not to create dangling references, an object is never reclaimed in a turn when it is finalized; it is only reclaimed after another collection confirms that it is unreachable and that finalization is disabled for it <ref> [19, 31] </ref>. A finalize function must be static, therefore, it may not be virtual (i.e. dynamically bound).
Reference: [20] <author> Ellis, M. A., and Stroustrup, B. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <month> Feb. </month> <year> 1990. </year>
Reference-contexts: The user must then add a #pragma to the class telling the precompiler what file should contain the definition of the class's gc () function. This technique is used in some C ++ compilers to determine when to emit the vtbl for a class <ref> [20, x10.8.1c] </ref>. 3.8 Status The design and development of this system are both underway. The smart pointers and the garbage collector are operational. The precompiler has been prototyped using an existing C ++ compiler as the starting point.
Reference: [21] <author> Ferreira, P. </author> <title> Garbage collection in C++. </title> <booktitle> Workshop on GC in Object Oriented Systems at OOPSLA '91, </booktitle> <month> July </month> <year> 1991. </year> <note> References 17 </note>
Reference-contexts: and mark-and-sweep GC [27], * library-based mostly copying generational garbage collection [5], * library-based reference counting through smart pointers [28, 29] (Smart pointers are discussed momentarily), * library-based mark-and-sweep GC using smart pointers [16], * compiler-based GC using smart pointers [22], * library-based mark-and-sweep and generational copying collection using macros <ref> [21] </ref>, and, * library-based conservative generational mark-and-sweep GC [8, 11]. The vast number of proposals, without the widespread acceptance of any one, reflects how hard the problem is. In the past, we have proposed implementing GC strictly in application-code: GC implemented in a library. <p> Their programming language is based on active objects, thus, the garbage collection requirements for this language are basically the same as for garbage collection of Actors [13, 25]. Ferreira discusses a C ++ library that provides garbage collection for C ++ programs <ref> [21] </ref>. The library supplies both incremental mark-and-sweep and generational copy collection, and supports pointers to the interiors of objects. The programmer renders the program suitable for garbage collection by placing macro definitions at various places in the program.
Reference: [22] <author> Ginter, A. </author> <title> Cooperative garbage collectors using smart pointers in the C++ programming language. </title> <type> Master's thesis, </type> <institution> Dept. of Computer Science, University of Calgary, </institution> <month> Dec. </month> <year> 1991. </year> <note> Tech. Rpt. 91/451/45. </note>
Reference-contexts: concurrent atomic mostly-copying garbage collection [12], * library-based reference counting and mark-and-sweep GC [27], * library-based mostly copying generational garbage collection [5], * library-based reference counting through smart pointers [28, 29] (Smart pointers are discussed momentarily), * library-based mark-and-sweep GC using smart pointers [16], * compiler-based GC using smart pointers <ref> [22] </ref>, * library-based mark-and-sweep and generational copying collection using macros [21], and, * library-based conservative generational mark-and-sweep GC [8, 11]. The vast number of proposals, without the widespread acceptance of any one, reflects how hard the problem is.
Reference: [23] <author> Goldberg, B. </author> <title> Tag-free garbage collection for strongly typed programming languages. </title> <booktitle> In Proc. PLDI '91 [1], </booktitle> <pages> pp. 165-176. </pages> <booktitle> SIGPLAN Not. </booktitle> <pages> 26(6). </pages>
Reference-contexts: While not overly verbose, the programming style that this utilizes is quite different from the standard C ++ style and such long macros can make debugging difficult. 2.3. Type-Accurate Techniques 5 Goldberg describes tag-free garbage collection for polymorphic statically-typed languages using compile-time information <ref> [23] </ref>, building on work by Appel [2], who in turn builds on techniques that were invented for Algol-68 and Pascal. Goldberg's compiler emits functions that know how to locate the pointers in all necessary activation records of the program.
Reference: [24] <author> Grossman, E. </author> <title> Using smart pointers for transparent access to objects on disk or across a network, 1992. </title> <type> Private communication. </type>
Reference-contexts: Smart pointers can be used for a variety for purposes. For example: 2 1. Introduction * reference counting [10, 27, 28, 29, 39], * convenient access to both transient and persistent objects [36, 39], * uniform access to local or distributed objects <ref> [24, 35, 37] </ref>, * synchronizing operations on objects [39, p. 464], * tracing garbage collection [16, 18, 27], * instrumenting the code, * or others. Section 2 discusses how existing systems use smart pointers for memory management. A discussion of various issues concerning smart pointers can be found in [17].
Reference: [25] <author> Kafura, D., Washabaugh, D., and Nelson, J. </author> <title> Garbage collection of actors. </title> <booktitle> In Proc. </booktitle> <address> OOPSLA/ECOOP (Oct. </address> <year> 1990), </year> <pages> pp. 126-134. </pages> <booktitle> SIGPLAN Not. </booktitle> <pages> 25(10). </pages>
Reference-contexts: Yasugi and Yonezawa discuss user-level garbage collection for the concurrent object-oriented programming language ABCL/1 [43]. Their programming language is based on active objects, thus, the garbage collection requirements for this language are basically the same as for garbage collection of Actors <ref> [13, 25] </ref>. Ferreira discusses a C ++ library that provides garbage collection for C ++ programs [21]. The library supplies both incremental mark-and-sweep and generational copy collection, and supports pointers to the interiors of objects.
Reference: [26] <author> Karplus, K. </author> <title> Using if-then-else DAGs for multi-level logic minimization. </title> <booktitle> In Advanced Research in VLSI: Proceedings of the Decennial Caltech Conference on VLSI (Pasadena, </booktitle> <address> CA, </address> <month> 20-22 March </month> <year> 1989), </year> <editor> C. L. Seitz, Ed., </editor> <publisher> MIT Press, </publisher> <pages> pp. 101-118. </pages>
Reference-contexts: To aid the programming task, he is investigating augmenting the conservative garbage collector with weak pointers [30], i.e. references that do not cause objects to be retained. Finally, we have tested conservative garbage collection with a CAD software tool called ITEM <ref> [16, 26] </ref>. This application creates large data structures that are strongly connected when they become garbage. A single false pointer into the data structure keeps the entire mass of data from being reclaimed. Thus, our brief efforts with conservative collection in this application proved unsuccessful.
Reference: [27] <author> Kennedy, B. </author> <title> The features of the object-oriented abstract type hierarchy (OATH). </title> <booktitle> In Proc. Usenix C++ Conference [40], </booktitle> <pages> pp. 41-50. </pages>
Reference-contexts: The proposals span the entire spectrum of techniques including: * compiler-based concurrent atomic mostly-copying garbage collection [12], * library-based reference counting and mark-and-sweep GC <ref> [27] </ref>, * library-based mostly copying generational garbage collection [5], * library-based reference counting through smart pointers [28, 29] (Smart pointers are discussed momentarily), * library-based mark-and-sweep GC using smart pointers [16], * compiler-based GC using smart pointers [22], * library-based mark-and-sweep and generational copying collection using macros [21], and, * library-based <p> Smart pointers can be used for a variety for purposes. For example: 2 1. Introduction * reference counting <ref> [10, 27, 28, 29, 39] </ref>, * convenient access to both transient and persistent objects [36, 39], * uniform access to local or distributed objects [24, 35, 37], * synchronizing operations on objects [39, p. 464], * tracing garbage collection [16, 18, 27], * instrumenting the code, * or others. <p> For example: 2 1. Introduction * reference counting [10, 27, 28, 29, 39], * convenient access to both transient and persistent objects [36, 39], * uniform access to local or distributed objects [24, 35, 37], * synchronizing operations on objects [39, p. 464], * tracing garbage collection <ref> [16, 18, 27] </ref>, * instrumenting the code, * or others. Section 2 discusses how existing systems use smart pointers for memory management. A discussion of various issues concerning smart pointers can be found in [17]. Our imple mentation of smart pointers is presented in x3.1. 3 2. <p> The collector treats sure pointers accurately and unsure pointers conservatively. Detlefs' collector is concurrent and is implemented in the cfront C ++ compiler. 2.3 Type-Accurate Techniques Kennedy describes a C ++ type hierarchy called OATH that uses both reference counting and mark-and-sweep garbage collection <ref> [27] </ref>. In OATH, objects are accessed exclusively through application-level references called accessors, that are very similar to stubs because they duplicate the interfaces of their target objects. Accessors implement reference counting on the objects that they reference. <p> The hierarchy of operating system classes is shadowed by parallel smart pointer classes, called ObjectStars. By programmer convention, the system classes are accessed exclusively through ObjectStars, which implement reference counting on their referents. As identified by Kennedy in <ref> [27] </ref>, returning reference counting smart pointers from functions can sometimes result in dangling references.
Reference: [28] <author> Madany, P. W., Islam, N., Kougiouris, P., and Campbell, R. H. </author> <title> Reification and reflection in C++: An operating systems perspective. </title> <type> Tech. Rep. </type> <institution> UIUCDCS-R-92-1736, Dept. of Computer Science, University of Illinois at Urbana-Champaign, </institution> <month> Mar. </month> <year> 1992. </year>
Reference-contexts: The proposals span the entire spectrum of techniques including: * compiler-based concurrent atomic mostly-copying garbage collection [12], * library-based reference counting and mark-and-sweep GC [27], * library-based mostly copying generational garbage collection [5], * library-based reference counting through smart pointers <ref> [28, 29] </ref> (Smart pointers are discussed momentarily), * library-based mark-and-sweep GC using smart pointers [16], * compiler-based GC using smart pointers [22], * library-based mark-and-sweep and generational copying collection using macros [21], and, * library-based conservative generational mark-and-sweep GC [8, 11]. <p> Smart pointers can be used for a variety for purposes. For example: 2 1. Introduction * reference counting <ref> [10, 27, 28, 29, 39] </ref>, * convenient access to both transient and persistent objects [36, 39], * uniform access to local or distributed objects [24, 35, 37], * synchronizing operations on objects [39, p. 464], * tracing garbage collection [16, 18, 27], * instrumenting the code, * or others. <p> Other functionality allows the programmer to detect memory leaks by reporting objects that are still alive when the program terminates. Madany et al. discuss the use of reference counting in the Choices object-oriented operating system <ref> [28] </ref>. The hierarchy of operating system classes is shadowed by parallel smart pointer classes, called ObjectStars. By programmer convention, the system classes are accessed exclusively through ObjectStars, which implement reference counting on their referents.
Reference: [29] <author> Maeder, R. E. </author> <title> A provably correct reference count scheme for a symbolic computation system. In unpublished form, </title> <year> 1992. </year>
Reference-contexts: The proposals span the entire spectrum of techniques including: * compiler-based concurrent atomic mostly-copying garbage collection [12], * library-based reference counting and mark-and-sweep GC [27], * library-based mostly copying generational garbage collection [5], * library-based reference counting through smart pointers <ref> [28, 29] </ref> (Smart pointers are discussed momentarily), * library-based mark-and-sweep GC using smart pointers [16], * compiler-based GC using smart pointers [22], * library-based mark-and-sweep and generational copying collection using macros [21], and, * library-based conservative generational mark-and-sweep GC [8, 11]. <p> Smart pointers can be used for a variety for purposes. For example: 2 1. Introduction * reference counting <ref> [10, 27, 28, 29, 39] </ref>, * convenient access to both transient and persistent objects [36, 39], * uniform access to local or distributed objects [24, 35, 37], * synchronizing operations on objects [39, p. 464], * tracing garbage collection [16, 18, 27], * instrumenting the code, * or others. <p> Ferreira's collector requires that the programmer supply functions to locate internal pointers. It can also scan objects conservatively to work without these functions. Maeder describes a C ++ library for symbolic computation systems whose implementation uses smart pointers and reference counting <ref> [29] </ref>. The library contains class hierarchies for expressions, strings, symbols, and other objects that are called normal, and reference-counting smart pointers are used exclusively to access the objects.
Reference: [30] <author> Miller, J. S. Multischeme: </author> <title> A Parallel Processing System Based on MIT Scheme. </title> <type> PhD thesis, </type> <institution> MIT, </institution> <year> 1987. </year> <note> MIT/LCS/Tech. Rep.-402. </note>
Reference-contexts: For example, he has found it necessary to disguise pointers and manually break garbage cycles [33]. To aid the programming task, he is investigating augmenting the conservative garbage collector with weak pointers <ref> [30] </ref>, i.e. references that do not cause objects to be retained. Finally, we have tested conservative garbage collection with a CAD software tool called ITEM [16, 26]. This application creates large data structures that are strongly connected when they become garbage.
Reference: [31] <author> Rovner, P. </author> <title> On adding garbage collection and runtime types to a strongly-typed, statically checked, concurrent language. </title> <type> Tech. Rep. CSL-84-7, </type> <note> Xerox PARC, </note> <year> 1984. </year>
Reference-contexts: A call to malloc (), which circumvents new, also allocates a foreign object. internal pointers are shown in Fig. 3.5. 3.3 Finalization If the programmer specifies a static member function named T:: gc finalize (T*), then that becomes the finalization function <ref> [31] </ref> for objects of type T. As in Cedar, finalization can be enabled or disabled for individual objects; the collector maintains a bit with every 10 3. <p> Therefore, in order not to create dangling references, an object is never reclaimed in a turn when it is finalized; it is only reclaimed after another collection confirms that it is unreachable and that finalization is disabled for it <ref> [19, 31] </ref>. A finalize function must be static, therefore, it may not be virtual (i.e. dynamically bound).
Reference: [32] <author> Russo, V. </author> <title> Garbage collecting an object-oriented operating system kernel. </title> <booktitle> Workshop on GC in Object Oriented Systems at OOPSLA '91, </booktitle> <year> 1991. </year>
Reference-contexts: Boehm, Demers, et al. describe conservative, generational, parallel mark-and-sweep garbage collection [7, 8, 11] for languages such as C. Russo has adapted these techniques for use in an object-oriented operating system written in C ++ <ref> [32, 34] </ref>. Since they are fully conservative, during a collection these collectors must examine every word of the stack, of global data, and of every marked object. Boehm discusses compiler changes to preclude optimizations that would cause a conservative garbage collector to reclaim data that is actually accessible [6].
Reference: [33] <author> Russo, V. </author> <title> There's no free lunch in conservative garbage collection of an operating system, 1991. </title> <type> Private communication. </type>
Reference-contexts: For example, Wentworth has found that conservative garbage collection performs poorly in densely populated address spaces [41, 42]. Russo has found that the programming style must take into account the conservative garbage collector: naive programming leads to inconveniently large amounts of garbage escaping collection <ref> [33, 34] </ref>. For example, he has found it necessary to disguise pointers and manually break garbage cycles [33]. To aid the programming task, he is investigating augmenting the conservative garbage collector with weak pointers [30], i.e. references that do not cause objects to be retained. <p> Russo has found that the programming style must take into account the conservative garbage collector: naive programming leads to inconveniently large amounts of garbage escaping collection [33, 34]. For example, he has found it necessary to disguise pointers and manually break garbage cycles <ref> [33] </ref>. To aid the programming task, he is investigating augmenting the conservative garbage collector with weak pointers [30], i.e. references that do not cause objects to be retained. Finally, we have tested conservative garbage collection with a CAD software tool called ITEM [16, 26].
Reference: [34] <author> Russo, V. </author> <title> Using the parallel Boehm/Weiser/Demers collector in an operating system, 1991. </title> <type> Private communication. </type>
Reference-contexts: Boehm, Demers, et al. describe conservative, generational, parallel mark-and-sweep garbage collection [7, 8, 11] for languages such as C. Russo has adapted these techniques for use in an object-oriented operating system written in C ++ <ref> [32, 34] </ref>. Since they are fully conservative, during a collection these collectors must examine every word of the stack, of global data, and of every marked object. Boehm discusses compiler changes to preclude optimizations that would cause a conservative garbage collector to reclaim data that is actually accessible [6]. <p> For example, Wentworth has found that conservative garbage collection performs poorly in densely populated address spaces [41, 42]. Russo has found that the programming style must take into account the conservative garbage collector: naive programming leads to inconveniently large amounts of garbage escaping collection <ref> [33, 34] </ref>. For example, he has found it necessary to disguise pointers and manually break garbage cycles [33]. To aid the programming task, he is investigating augmenting the conservative garbage collector with weak pointers [30], i.e. references that do not cause objects to be retained.
Reference: [35] <author> Shapiro, M., Dickman, P., and Plainfoss e, D. </author> <title> Robust, distributed references and acyclic garbage collection. </title> <booktitle> In Symp. on Principles of Distributed Computing (Vancouver, </booktitle> <address> Canada, </address> <month> Aug. </month> <year> 1992), </year> <note> ACM. </note>
Reference-contexts: Smart pointers can be used for a variety for purposes. For example: 2 1. Introduction * reference counting [10, 27, 28, 29, 39], * convenient access to both transient and persistent objects [36, 39], * uniform access to local or distributed objects <ref> [24, 35, 37] </ref>, * synchronizing operations on objects [39, p. 464], * tracing garbage collection [16, 18, 27], * instrumenting the code, * or others. Section 2 discusses how existing systems use smart pointers for memory management. A discussion of various issues concerning smart pointers can be found in [17]. <p> The precompiler does not yet reintegrate the emitted code back into the original source program. A complete reimplementation of the precompiler is in progress. The SOR group at INRIA Rocquencourt has designed and is developing a distributed garbage collection algorithm <ref> [35] </ref>. The distributed garbage collector requires local garbage collectors with support for finalization. This garbage collector serves as the foundation for the distributed garbage collector. 3.9 Future Work This collector will be used as a platform for research on the interaction between the collector and the virtual memory system.
Reference: [36] <author> Shapiro, M., Gourhant, Y., Habert, S., Mosseri, L., Ruffin, M., and Valot, C. </author> <title> SOS: An object-oriented operating system|assessment and perspectives. </title> <journal> Comput. Syst. </journal> <volume> 2, </volume> <month> 4 (Dec. </month> <year> 1989), </year> <pages> 287-338. </pages>
Reference-contexts: Smart pointers can be used for a variety for purposes. For example: 2 1. Introduction * reference counting [10, 27, 28, 29, 39], * convenient access to both transient and persistent objects <ref> [36, 39] </ref>, * uniform access to local or distributed objects [24, 35, 37], * synchronizing operations on objects [39, p. 464], * tracing garbage collection [16, 18, 27], * instrumenting the code, * or others. Section 2 discusses how existing systems use smart pointers for memory management.
Reference: [37] <author> Shapiro, M., Maisonneuve, J., and Collet, P. </author> <title> Implementing references as chains of links. In Workshop on Object Orientation in Operating Systems (1992). </title> <note> To appear. </note>
Reference-contexts: Smart pointers can be used for a variety for purposes. For example: 2 1. Introduction * reference counting [10, 27, 28, 29, 39], * convenient access to both transient and persistent objects [36, 39], * uniform access to local or distributed objects <ref> [24, 35, 37] </ref>, * synchronizing operations on objects [39, p. 464], * tracing garbage collection [16, 18, 27], * instrumenting the code, * or others. Section 2 discusses how existing systems use smart pointers for memory management. A discussion of various issues concerning smart pointers can be found in [17].
Reference: [38] <author> Stroustrup, B. </author> <title> The evolution of C++ 1985 to 1987. </title> <booktitle> In Proc. Usenix C++ Workshop (Nov. 1987), Usenix Association, </booktitle> <pages> pp. 1-22. </pages>
Reference-contexts: Therefore, this paper begins with an introduction to the term. C ++ provides the ability to use class objects like pointers; these objects are often called smart pointers <ref> [38] </ref>. Smart pointers allow the programmer to benefit from additional pointer semantics, while keeping the syntax of the program largely unchanged. Smart pointers use operator overloading to be usable in expressions with the same syntax as normal pointers.
Reference: [39] <author> Stroustrup, B. </author> <title> The C++ Programming Language, 2 nd ed. </title> <publisher> Addison-Wesley, </publisher> <year> 1991. </year>
Reference-contexts: Smart pointers can be used for a variety for purposes. For example: 2 1. Introduction * reference counting <ref> [10, 27, 28, 29, 39] </ref>, * convenient access to both transient and persistent objects [36, 39], * uniform access to local or distributed objects [24, 35, 37], * synchronizing operations on objects [39, p. 464], * tracing garbage collection [16, 18, 27], * instrumenting the code, * or others. <p> Smart pointers can be used for a variety for purposes. For example: 2 1. Introduction * reference counting [10, 27, 28, 29, 39], * convenient access to both transient and persistent objects <ref> [36, 39] </ref>, * uniform access to local or distributed objects [24, 35, 37], * synchronizing operations on objects [39, p. 464], * tracing garbage collection [16, 18, 27], * instrumenting the code, * or others. Section 2 discusses how existing systems use smart pointers for memory management. <p> For example: 2 1. Introduction * reference counting [10, 27, 28, 29, 39], * convenient access to both transient and persistent objects [36, 39], * uniform access to local or distributed objects [24, 35, 37], * synchronizing operations on objects <ref> [39, p. 464] </ref>, * tracing garbage collection [16, 18, 27], * instrumenting the code, * or others. Section 2 discusses how existing systems use smart pointers for memory management. A discussion of various issues concerning smart pointers can be found in [17]. <p> Since it has its bad cases, it is worthwhile to investigate type-accurate techniques for C ++ . 2.2 Partially Conservative Bartlett's Mostly Copying Collector is a generational garbage collector for Scheme [14] and C ++ <ref> [39] </ref> that uses both conservative and copying techniques [4, 5]. This collector divides the heap into logical pages, each of which has a space-identifier. During a collection 4 2.
Reference: [40] <editor> Usenix Association. </editor> <booktitle> Proc. Usenix C++ Conference (Apr. </booktitle> <year> 1991). </year>
Reference: [41] <author> Wentworth, E. P. </author> <title> An environment for investigating functional languages and implementations. </title> <type> PhD thesis, </type> <institution> University of Port Elizabeth, </institution> <year> 1988. </year> <note> 18 References </note>
Reference-contexts: Often, the amount of retained garbage is small, and conservative collection succeeds quite well. Other times, conservative techniques are not satisfactory. For example, Wentworth has found that conservative garbage collection performs poorly in densely populated address spaces <ref> [41, 42] </ref>. Russo has found that the programming style must take into account the conservative garbage collector: naive programming leads to inconveniently large amounts of garbage escaping collection [33, 34]. For example, he has found it necessary to disguise pointers and manually break garbage cycles [33].
Reference: [42] <author> Wentworth, E. P. </author> <title> Pitfalls of conservative garbage collection. </title> <journal> Softw. - Pract. Exp. </journal> <month> (July </month> <year> 1990), </year> <pages> 719-727. </pages>
Reference-contexts: Often, the amount of retained garbage is small, and conservative collection succeeds quite well. Other times, conservative techniques are not satisfactory. For example, Wentworth has found that conservative garbage collection performs poorly in densely populated address spaces <ref> [41, 42] </ref>. Russo has found that the programming style must take into account the conservative garbage collector: naive programming leads to inconveniently large amounts of garbage escaping collection [33, 34]. For example, he has found it necessary to disguise pointers and manually break garbage cycles [33].
Reference: [43] <author> Yasugi, M., and Yonezawa, A. </author> <title> Towards user (application) language-level garbage collection in object-oriented concurrent languages. </title> <booktitle> Workshop on GC in Object Oriented Systems at OOPSLA '91, </booktitle> <year> 1991. </year>
Reference-contexts: A function may have more than one garbage collection routine because different variables are live at different points in the function. Clearly, this collector is very tightly coupled to the compiler. Yasugi and Yonezawa discuss user-level garbage collection for the concurrent object-oriented programming language ABCL/1 <ref> [43] </ref>. Their programming language is based on active objects, thus, the garbage collection requirements for this language are basically the same as for garbage collection of Actors [13, 25]. Ferreira discusses a C ++ library that provides garbage collection for C ++ programs [21].
Reference: [44] <author> Zorn, B. </author> <title> The measured cost of conservative garbage collection. </title> <type> Tech. Rep. </type> <institution> CU-CS-573-92, University of Colorado at Boulder, </institution> <year> 1992. </year>
Reference-contexts: Boehm discusses compiler changes to preclude optimizations that would cause a conservative garbage collector to reclaim data that is actually accessible [6]. Zorn has measured the cost of conservative garbage collection and found that it compares favorably not just with manual allocation, but even with optimized manual allocation <ref> [44] </ref>. Conservative collectors sometimes retain more garbage than type-accurate collectors because conservative collectors interpret non-pointer data as pointers. Often, the amount of retained garbage is small, and conservative collection succeeds quite well. Other times, conservative techniques are not satisfactory.
References-found: 45

