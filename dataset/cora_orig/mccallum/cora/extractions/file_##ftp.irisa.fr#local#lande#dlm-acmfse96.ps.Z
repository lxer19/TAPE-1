URL: file://ftp.irisa.fr/local/lande/dlm-acmfse96.ps.Z
Refering-URL: http://www.irisa.fr/lande/LeMetayer.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: email: lemetayer@irisa.fr  
Title: Software architecture styles as graph grammars  
Author: Daniel Le Metayer Irisa/Inria 
Keyword: coordination, graph rewriting, software architecture, static verification.  
Address: 35042 Rennes, France  
Affiliation: Campus de Beaulieu,  
Abstract: We present a formalism for the definition of software architectures in terms of graphs. Nodes represent the individual agents and edges define their interconnection. Individual agents can communicate only along the links specified by the architecture. The dynamic evolution of the overall architecture is defined independently by a `coordinator'. An architecture style is a class of architectures characterised by a graph grammar. The rules of the coordinator are statically checked to ensure that they preserve the constraints imposed by the architecture style. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. Abowd, R. Allen and D. Garlan, </author> <title> Using style to understand descriptions of software architecture, </title> <booktitle> Proc. Sigsoft'93: Foundations of Software Engineering, Software Engineering Notes, </booktitle> <volume> 18, 5, </volume> <month> December </month> <year> 1993. </year>
Reference-contexts: Despite some differences of emphasis, these works share a common point of view: the definition of a software application should make a clear distinction between individual components and their interaction in the overall software organisation. Several authors <ref> [1, 2, 16, 27] </ref> have emphasized the importance of a framework for the formal definition of software architectures. Not only is it a prerequisite for a rigorous analysis of architectures, but it also increases their usefulness and reusability by removing the sources of ambiguity which are unavoidable in informal descriptions. <p> previous work in this area, let us focus on two complementary issues: the formal model used to describe software architectures and the features provided by specific software architecture or coordination languages. * Formal models: Among the formal frameworks used to specify software architectures, let us mention the specification language Z <ref> [1] </ref>, CSP [2], the chemical abstract machine [16], the -calculus [21], partial ordered sets of events [20] and first-order logical theories [24]. <p> These formalisms have been extensively studied and their respective advantages have been identified: Z is a widely used state-based specification language which allows for a clean decomposition of applications into collections of schemas (in the context of software architectures, schemas can be components, connectors, configurations <ref> [1] </ref>); CSP [13] and the -calculus [23] are process algebra which highlight the concurrency and communication issues; the -calculus includes powerful features for manipulating channels as first-class values which increases its potential for describing dynamic architectures; the chemical abstract machine [5] is based on the chemical reaction metaphor [4] which allows
Reference: [2] <author> R. Allen and D. Garlan, </author> <title> Formalizing architectural connection, </title> <booktitle> Proc. 16th Int. Conf. Software Engineering, IEEE Computer Society, </booktitle> <pages> pp. 71-80, </pages> <year> 1994. </year>
Reference-contexts: Despite some differences of emphasis, these works share a common point of view: the definition of a software application should make a clear distinction between individual components and their interaction in the overall software organisation. Several authors <ref> [1, 2, 16, 27] </ref> have emphasized the importance of a framework for the formal definition of software architectures. Not only is it a prerequisite for a rigorous analysis of architectures, but it also increases their usefulness and reusability by removing the sources of ambiguity which are unavoidable in informal descriptions. <p> The common practice of software engineers is to represent architectures informally as `box and line' drawings <ref> [2, 17] </ref>. Starting from this observation, we propose to define software architectures formally in terms of graphs, which constitute the mathematical model closest to the intuition conveyed by `box and line' drawings. The nodes of the graph represent the individual entities which can themselves be described in conventional programming languages. <p> in this area, let us focus on two complementary issues: the formal model used to describe software architectures and the features provided by specific software architecture or coordination languages. * Formal models: Among the formal frameworks used to specify software architectures, let us mention the specification language Z [1], CSP <ref> [2] </ref>, the chemical abstract machine [16], the -calculus [21], partial ordered sets of events [20] and first-order logical theories [24]. <p> As far as formalisation is concerned, our approach to software architectures is in the spirit of previous proposals based on process calculi like CSP <ref> [2] </ref> or the -calculus [23]. On the other hand, our computational model based on a clean separation between individual entities and a coordinator is inspired by [14] (but no formal model is provided for Concoord [14] and a number of technical choices differ from our own approach).
Reference: [3] <author> J.-P. Ban^atre and D. Le Metayer, </author> <title> Programming by multiset transformation, </title> <journal> Communications of the ACM, </journal> <volume> Vol. </volume> <pages> 36-1, pp. 98-111, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: A second example is presented in the appendix (a distributed hospital ward monitoring system inspired by [18] and [15]). 2 Architecture styles Our notion of graphs is inspired by previous work on the chemical reaction model <ref> [3, 4, 10] </ref> and set-theoretic graph rewriting [28]. Formally, a graph is a multiset of relation tuples noted R (e 1 ; : : : ; e n ) where R is a n-ary relation name and e i are entity names (we assume appropriate countable sets of names). <p> In our framework, the evolution of the architecture is defined by a coordinator. The task of the coordinator is expressed by conditional graph rewrite rules in the style of <ref> [3, 4] </ref>. The semantics of the rules is similar to the definition used above for the rewrite system associated with graph grammars, except that we may have additional side conditions in coordination rules.
Reference: [4] <author> J.-P. Ban^atre and D. Le Metayer, </author> <title> Gamma and the chemical reaction model: ten years after, Coordination programming: mechanisms, models and semantics, </title> <publisher> Imperial College Press, </publisher> <year> 1996, </year> <note> to appear. </note>
Reference-contexts: A second example is presented in the appendix (a distributed hospital ward monitoring system inspired by [18] and [15]). 2 Architecture styles Our notion of graphs is inspired by previous work on the chemical reaction model <ref> [3, 4, 10] </ref> and set-theoretic graph rewriting [28]. Formally, a graph is a multiset of relation tuples noted R (e 1 ; : : : ; e n ) where R is a n-ary relation name and e i are entity names (we assume appropriate countable sets of names). <p> In our framework, the evolution of the architecture is defined by a coordinator. The task of the coordinator is expressed by conditional graph rewrite rules in the style of <ref> [3, 4] </ref>. The semantics of the rules is similar to the definition used above for the rewrite system associated with graph grammars, except that we may have additional side conditions in coordination rules. <p> connectors, configurations [1]); CSP [13] and the -calculus [23] are process algebra which highlight the concurrency and communication issues; the -calculus includes powerful features for manipulating channels as first-class values which increases its potential for describing dynamic architectures; the chemical abstract machine [5] is based on the chemical reaction metaphor <ref> [4] </ref> which allows for a higher level of abstraction promoting parallelism as a basic computational model; the event-based structures of [20] are well suited to the explicit representation of timing properties; the logical theories used in [24] form the basis of a definition of a notion of architecture refinement. * Software
Reference: [5] <author> G. Berry and G. Boudol, </author> <title> The chemical abstract machine, </title> <journal> Theoretical Computer Science, </journal> <volume> Vol. 96, </volume> <pages> pp. 217-248, </pages> <year> 1992. </year>
Reference-contexts: context of software architectures, schemas can be components, connectors, configurations [1]); CSP [13] and the -calculus [23] are process algebra which highlight the concurrency and communication issues; the -calculus includes powerful features for manipulating channels as first-class values which increases its potential for describing dynamic architectures; the chemical abstract machine <ref> [5] </ref> is based on the chemical reaction metaphor [4] which allows for a higher level of abstraction promoting parallelism as a basic computational model; the event-based structures of [20] are well suited to the explicit representation of timing properties; the logical theories used in [24] form the basis of a definition
Reference: [6] <author> N. Carriero and D. Gelernter, </author> <title> Linda in context, </title> <journal> Communications of the ACM, </journal> <volume> Vol. </volume> <pages> 32-4, pp. 444-458, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: Several languages or systems have been proposed recently to tackle these problems: they are called software architecture languages [12], configuration languages [18] or coordination languages <ref> [6, 14] </ref>. Despite some differences of emphasis, these works share a common point of view: the definition of a software application should make a clear distinction between individual components and their interaction in the overall software organisation. <p> Other proposals put more emphasis on the dynamic aspects of the system, introducing a separation between the sequential computation of individual agents and their coordination expressed in a specific languages <ref> [6, 14, 18] </ref>. In Linda [6], activities cooperate through a global tuple space using specific associative access primitives. <p> Other proposals put more emphasis on the dynamic aspects of the system, introducing a separation between the sequential computation of individual agents and their coordination expressed in a specific languages [6, 14, 18]. In Linda <ref> [6] </ref>, activities cooperate through a global tuple space using specific associative access primitives. The Conic environment provides a neat separation between individual tasks with explicit interfaces and a configuration level describing the overall application (which involves specifying the task components and establishing links between their ports).
Reference: [7] <author> B. Courcelle, </author> <title> Graph rewriting: an algebraic and logic approach, </title> <booktitle> Handbook of Theoretical Computer Science, Chapter 5, </booktitle> <editor> J. van Leeuwen (ed.), </editor> <publisher> Elsevier Science Publishers, </publisher> <year> 1990. </year>
Reference-contexts: We propose to specify such a class as a context-free graph grammar. Different notions of context-free graph grammars have been studied in the literature. They are defined either in terms of node replacement [9] or in terms of hyper-edge replacement <ref> [7] </ref>. Graph rewriting is also used in [8] as a model for distributed systems, but a dual approach is taken, with hyper-edges representing processes and nodes representing ports (also the process rewrite rules are essentially used to model synchronisation requirements).
Reference: [8] <author> P. Degano and U. Montanari, </author> <title> A model for distributed systems based on graph rewritings, </title> <journal> Journal of the ACM, </journal> <volume> Vol. </volume> <pages> 34-2, pp. 411-449, </pages> <month> April </month> <year> 1987. </year>
Reference-contexts: We propose to specify such a class as a context-free graph grammar. Different notions of context-free graph grammars have been studied in the literature. They are defined either in terms of node replacement [9] or in terms of hyper-edge replacement [7]. Graph rewriting is also used in <ref> [8] </ref> as a model for distributed systems, but a dual approach is taken, with hyper-edges representing processes and nodes representing ports (also the process rewrite rules are essentially used to model synchronisation requirements). Our definition of graphs as multisets allows us to express hyper-edge replacement in a very natural way.
Reference: [9] <author> P. Della Vigna and C. Ghezzi, </author> <title> Context-free graph grammars, </title> <journal> Information and Control, </journal> <volume> Vol. 37, </volume> <pages> pp. 207-233, </pages> <year> 1978. </year>
Reference-contexts: Furthermore, they must follow the communication link pattern exhibited by . We propose to specify such a class as a context-free graph grammar. Different notions of context-free graph grammars have been studied in the literature. They are defined either in terms of node replacement <ref> [9] </ref> or in terms of hyper-edge replacement [7]. Graph rewriting is also used in [8] as a model for distributed systems, but a dual approach is taken, with hyper-edges representing processes and nodes representing ports (also the process rewrite rules are essentially used to model synchronisation requirements).
Reference: [10] <author> P. Fradet and D. Le Metayer, </author> <title> Structured Gamma, </title> <institution> Irisa Research Report PI-989, </institution> <month> March </month> <year> 1996. </year>
Reference-contexts: The coordinator is in charge of managing the architec ture itself (creating and removing entities and links). The coordinator is expressed in terms of conditional graph rewriting in the spirit of <ref> [10, 28] </ref>. The conditions bear on the public variables of the entities and represent the only possible interactions between a coordinator and the individual components (apart from the creation and destruction of links and entities). <p> A second example is presented in the appendix (a distributed hospital ward monitoring system inspired by [18] and [15]). 2 Architecture styles Our notion of graphs is inspired by previous work on the chemical reaction model <ref> [3, 4, 10] </ref> and set-theoretic graph rewriting [28]. Formally, a graph is a multiset of relation tuples noted R (e 1 ; : : : ; e n ) where R is a n-ary relation name and e i are entity names (we assume appropriate countable sets of names). <p> If the above property holds, then Coo is correct with respect to the style H. The correctness of the algorithm is proven in <ref> [10] </ref>. As an illustration, let us apply it to the coordinator Coo CS presented above. <p> Another important issue is the possibility of defining formally a notion of refinement between software architectures. We proposed in <ref> [10] </ref> a refinement relation which corresponds to class containment and which can be checked statically on the rules of the graph grammar. <p> Further experience is necessary to assess the useful ness of this extension. Acknowledgements This work was partly supported by Esprit Basic Research project 9102 Coordination. Some of the inspiration for this paper emerged from previous work on Structured Gamma in collaboration with Pascal Fradet <ref> [10] </ref>. Jean-Pierre Ban^atre, Alexandra Holzbacher and Valerie Issarny provided valuable feedback on an earlier version of this paper.
Reference: [11] <author> D. Garlan, R. Allen and J. Ockerbloom, </author> <title> Exploiting style in architectural design anvironment, </title> <booktitle> Proc. Sig-soft'94, Foundations of Software Engineering, </booktitle> <pages> pp. 175-188, </pages> <year> 1994. </year>
Reference-contexts: Aesop <ref> [11] </ref> provides facilities for the design and graphical visual-isation of architectures following the rules prescribed by specific styles. Architecture styles are defined in a generic object model and include the specification of a vocabulary and constraints on the connections between elements.
Reference: [12] <author> D. Garlan and D. Perry, </author> <title> Editor's Introduction, </title> <journal> IEEE Transactions on Software Engineering, Special Issue on Software Architectures, </journal> <year> 1995. </year>
Reference-contexts: Several languages or systems have been proposed recently to tackle these problems: they are called software architecture languages <ref> [12] </ref>, configuration languages [18] or coordination languages [6, 14]. Despite some differences of emphasis, these works share a common point of view: the definition of a software application should make a clear distinction between individual components and their interaction in the overall software organisation. <p> Up-to-date surveys of formalisms and current trends can be found in <ref> [12, 29] </ref>.
Reference: [13] <author> C. A. R. Hoare, </author> <title> Communicating sequential processes, </title> <journal> Communications of the ACM, </journal> <volume> Vol. </volume> <pages> 21-8, pp. 666-677, </pages> <month> August </month> <year> 1978. </year>
Reference-contexts: The standard way to describe distributed systems is to resort to traditional sequential programming languages enhanced with facilities for process creation and communication (possibly through operating system procedure calls). On the other hand, specification languages like CSP <ref> [13] </ref>, and the -calculus [23] are inherently parallel languages providing powerful and integrated constructions for process creation and synchronisation. None of these approaches makes it easy to extract the underlying communication topology from the application. <p> A repetitive command terminates when each guard includes a false boolean condition. Note that we do not follow the original CSP convention indicating the termination of the repetitive command when all processes addressed in the input/output guards have terminated <ref> [13] </ref>. This option would not make sense in our setting since, as explained above, a communication command may avoid to name the partner process explicitly and new processes and links can be added by the coordinator. <p> These formalisms have been extensively studied and their respective advantages have been identified: Z is a widely used state-based specification language which allows for a clean decomposition of applications into collections of schemas (in the context of software architectures, schemas can be components, connectors, configurations [1]); CSP <ref> [13] </ref> and the -calculus [23] are process algebra which highlight the concurrency and communication issues; the -calculus includes powerful features for manipulating channels as first-class values which increases its potential for describing dynamic architectures; the chemical abstract machine [5] is based on the chemical reaction metaphor [4] which allows for a
Reference: [14] <author> A. A. Holzbacher, </author> <title> A software environment for concurrent coordinated programming, </title> <booktitle> Proc. First int. Conf. on Coordination Models, Languages and Applications, </booktitle> <publisher> Springer Verlag, LNCS 1061, </publisher> <pages> pp. 249-266, </pages> <month> April </month> <year> 1996. </year>
Reference-contexts: Several languages or systems have been proposed recently to tackle these problems: they are called software architecture languages [12], configuration languages [18] or coordination languages <ref> [6, 14] </ref>. Despite some differences of emphasis, these works share a common point of view: the definition of a software application should make a clear distinction between individual components and their interaction in the overall software organisation. <p> Other proposals put more emphasis on the dynamic aspects of the system, introducing a separation between the sequential computation of individual agents and their coordination expressed in a specific languages <ref> [6, 14, 18] </ref>. In Linda [6], activities cooperate through a global tuple space using specific associative access primitives. <p> The Conic environment provides a neat separation between individual tasks with explicit interfaces and a configuration level describing the overall application (which involves specifying the task components and establishing links between their ports). The Conic environment supports graphic tools for configuration programming and monitoring. Con-coord <ref> [14] </ref> introduces a notion of coordinator which is in charge of a collection of processes. A coordinator has access to the state variables of its processes and can test them to trigger the creation (or deletion) of processes and the binding (and unbinding) of ports. <p> On the other hand, our computational model based on a clean separation between individual entities and a coordinator is inspired by <ref> [14] </ref> (but no formal model is provided for Concoord [14] and a number of technical choices differ from our own approach). <p> On the other hand, our computational model based on a clean separation between individual entities and a coordinator is inspired by <ref> [14] </ref> (but no formal model is provided for Concoord [14] and a number of technical choices differ from our own approach). The main departure of our contribution with respect to the above process calculi based proposals is the emphasis put on the geometry of the architecture (following the `box and line' drawing analogy), promoting it as an independent object.
Reference: [15] <author> A. A. Holzbacher, </author> <title> Coordination of distributed and parallel programs in Concoord, Coordination programming: mechanisms, models and semantics, </title> <publisher> Imperial College Press, </publisher> <year> 1996, </year> <note> to appear. </note>
Reference-contexts: A second example is presented in the appendix (a distributed hospital ward monitoring system inspired by [18] and <ref> [15] </ref>). 2 Architecture styles Our notion of graphs is inspired by previous work on the chemical reaction model [3, 4, 10] and set-theoretic graph rewriting [28].
Reference: [16] <author> P. Inverardi and A. Wolf, </author> <title> Formal specification and analysis of software architectures using the chemical abstract machine model, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. 21, No. 4, </volume> <pages> pp. 373-386, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: Despite some differences of emphasis, these works share a common point of view: the definition of a software application should make a clear distinction between individual components and their interaction in the overall software organisation. Several authors <ref> [1, 2, 16, 27] </ref> have emphasized the importance of a framework for the formal definition of software architectures. Not only is it a prerequisite for a rigorous analysis of architectures, but it also increases their usefulness and reusability by removing the sources of ambiguity which are unavoidable in informal descriptions. <p> focus on two complementary issues: the formal model used to describe software architectures and the features provided by specific software architecture or coordination languages. * Formal models: Among the formal frameworks used to specify software architectures, let us mention the specification language Z [1], CSP [2], the chemical abstract machine <ref> [16] </ref>, the -calculus [21], partial ordered sets of events [20] and first-order logical theories [24].
Reference: [17] <author> R. Kazman, L. Bass, G. Abowd and M. Webb, SAAM: </author> <title> A method for analysing the properties of software architectures, </title> <booktitle> Proc. 16th Int. Conf. Software Engineering, IEEE Computer Society, </booktitle> <pages> pp. 81-90, </pages> <year> 1994. </year>
Reference-contexts: The common practice of software engineers is to represent architectures informally as `box and line' drawings <ref> [2, 17] </ref>. Starting from this observation, we propose to define software architectures formally in terms of graphs, which constitute the mathematical model closest to the intuition conveyed by `box and line' drawings. The nodes of the graph represent the individual entities which can themselves be described in conventional programming languages.
Reference: [18] <author> J. Kramer, </author> <title> Configuration programming. A framework for the development of distributable systems, </title> <booktitle> Proc. COMPEURO'90, IEEE, </booktitle> <pages> pp. 374-384, </pages> <year> 1990. </year>
Reference-contexts: Several languages or systems have been proposed recently to tackle these problems: they are called software architecture languages [12], configuration languages <ref> [18] </ref> or coordination languages [6, 14]. Despite some differences of emphasis, these works share a common point of view: the definition of a software application should make a clear distinction between individual components and their interaction in the overall software organisation. <p> A second example is presented in the appendix (a distributed hospital ward monitoring system inspired by <ref> [18] </ref> and [15]). 2 Architecture styles Our notion of graphs is inspired by previous work on the chemical reaction model [3, 4, 10] and set-theoretic graph rewriting [28]. <p> Other proposals put more emphasis on the dynamic aspects of the system, introducing a separation between the sequential computation of individual agents and their coordination expressed in a specific languages <ref> [6, 14, 18] </ref>. In Linda [6], activities cooperate through a global tuple space using specific associative access primitives. <p> One promising research direction is the notion of regular processes used in [26] to specify protocols for object behaviours. Another issue deserving further work is the design of a user friendly interface supporting externally initiated changes to the architecture <ref> [18] </ref>. In our framework, these changes could be expressed, and formally controlled, through the `external agents' as exemplified by the client-server case study. Considering graph grammars themselves, a potentially interesting generalisation would be to consider context sensitive grammars.
Reference: [19] <author> C. E. Landwehr, </author> <title> Formal models of computer security, </title> <journal> Computing Surveys, </journal> <volume> Vol. 13, No. 3, </volume> <pages> pp. 247-277, </pages> <month> September </month> <year> 1981. </year>
Reference-contexts: As an illustration of the relevance of our approach for the analysis of non-functional properties, let us consider a simplified version of the well-known `Bell and LaPadula' security model <ref> [19] </ref>.
Reference: [20] <author> D. C. Luckham, J. J. Kenney, L. M. Augustin, J. Vera, D. Bryan and W. Mann, </author> <title> Specification and analysis of system architecture using Rapide, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. 21, No. 4, </volume> <pages> pp. 336-355, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: to describe software architectures and the features provided by specific software architecture or coordination languages. * Formal models: Among the formal frameworks used to specify software architectures, let us mention the specification language Z [1], CSP [2], the chemical abstract machine [16], the -calculus [21], partial ordered sets of events <ref> [20] </ref> and first-order logical theories [24]. <p> -calculus includes powerful features for manipulating channels as first-class values which increases its potential for describing dynamic architectures; the chemical abstract machine [5] is based on the chemical reaction metaphor [4] which allows for a higher level of abstraction promoting parallelism as a basic computational model; the event-based structures of <ref> [20] </ref> are well suited to the explicit representation of timing properties; the logical theories used in [24] form the basis of a definition of a notion of architecture refinement. * Software architecture languages: there is a great variety of needs for software architectures [29] and this fact is reflected in the
Reference: [21] <author> J. Magee and J. Kramer, </author> <title> Modelling distributed software architectures, Proc. First int. workshop on Architectures for Software Systems, </title> <type> CMU Technical Report, </type> <institution> CMU-CS-95-151, </institution> <month> April </month> <year> 1995. </year>
Reference-contexts: complementary issues: the formal model used to describe software architectures and the features provided by specific software architecture or coordination languages. * Formal models: Among the formal frameworks used to specify software architectures, let us mention the specification language Z [1], CSP [2], the chemical abstract machine [16], the -calculus <ref> [21] </ref>, partial ordered sets of events [20] and first-order logical theories [24].
Reference: [22] <author> N. Mercouroff, </author> <title> An algorithm for analysing communicating processes, </title> <booktitle> 7th int. Conf. on Mathematical Foundations of Programming Semantics, </booktitle> <pages> pp. 312-325, </pages> <month> March </month> <year> 1991. </year>
Reference-contexts: On the other hand, specification languages like CSP [13], and the -calculus [23] are inherently parallel languages providing powerful and integrated constructions for process creation and synchronisation. None of these approaches makes it easy to extract the underlying communication topology from the application. As an illustration, <ref> [22, 25] </ref> propose sophisticated analyses to derive information about the topology of CSP and CML programs. We believe that a better basis for understanding the structure of a system is to consider its topology as an explicit feature rather than trying to dig it up from the program a posteriori. <p> We observe, for example, that any powerful proof technique for parallel languages must include some form of analysis to obtain information about the communication topology of the program. The difficulty of this task is illustrated in various papers <ref> [22, 25] </ref>. Such analyses become much simpler in our framework because the topology is directly available from the specification of the architecture. A significant benefit of our approach is that the direct information flows of a system are made explicit.
Reference: [23] <author> R. Milner, J. Parrow and D. Walker, </author> <title> A calculus of mobile processes, </title> <journal> Journal of Information and Computation, </journal> <volume> Vol. 100, </volume> <pages> pp. 1-77, </pages> <year> 1992. </year>
Reference-contexts: The standard way to describe distributed systems is to resort to traditional sequential programming languages enhanced with facilities for process creation and communication (possibly through operating system procedure calls). On the other hand, specification languages like CSP [13], and the -calculus <ref> [23] </ref> are inherently parallel languages providing powerful and integrated constructions for process creation and synchronisation. None of these approaches makes it easy to extract the underlying communication topology from the application. As an illustration, [22, 25] propose sophisticated analyses to derive information about the topology of CSP and CML programs. <p> formalisms have been extensively studied and their respective advantages have been identified: Z is a widely used state-based specification language which allows for a clean decomposition of applications into collections of schemas (in the context of software architectures, schemas can be components, connectors, configurations [1]); CSP [13] and the -calculus <ref> [23] </ref> are process algebra which highlight the concurrency and communication issues; the -calculus includes powerful features for manipulating channels as first-class values which increases its potential for describing dynamic architectures; the chemical abstract machine [5] is based on the chemical reaction metaphor [4] which allows for a higher level of abstraction <p> As far as formalisation is concerned, our approach to software architectures is in the spirit of previous proposals based on process calculi like CSP [2] or the -calculus <ref> [23] </ref>. On the other hand, our computational model based on a clean separation between individual entities and a coordinator is inspired by [14] (but no formal model is provided for Concoord [14] and a number of technical choices differ from our own approach).
Reference: [24] <author> M. Moriconi, X. Qian and R. A. Riemenschneider, </author> <title> Correct architecture refinement, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. 21, No 4, </volume> <pages> pp. 356-372, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: the features provided by specific software architecture or coordination languages. * Formal models: Among the formal frameworks used to specify software architectures, let us mention the specification language Z [1], CSP [2], the chemical abstract machine [16], the -calculus [21], partial ordered sets of events [20] and first-order logical theories <ref> [24] </ref>. <p> dynamic architectures; the chemical abstract machine [5] is based on the chemical reaction metaphor [4] which allows for a higher level of abstraction promoting parallelism as a basic computational model; the event-based structures of [20] are well suited to the explicit representation of timing properties; the logical theories used in <ref> [24] </ref> form the basis of a definition of a notion of architecture refinement. * Software architecture languages: there is a great variety of needs for software architectures [29] and this fact is reflected in the variety of papers published in this active area during the last few years.
Reference: [25] <author> H. R. Nielson and F. Nielson, </author> <title> Higher-order concurrent programs with finite communication topology, </title> <booktitle> Proc. 21st ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pp. 84-97, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: On the other hand, specification languages like CSP [13], and the -calculus [23] are inherently parallel languages providing powerful and integrated constructions for process creation and synchronisation. None of these approaches makes it easy to extract the underlying communication topology from the application. As an illustration, <ref> [22, 25] </ref> propose sophisticated analyses to derive information about the topology of CSP and CML programs. We believe that a better basis for understanding the structure of a system is to consider its topology as an explicit feature rather than trying to dig it up from the program a posteriori. <p> We observe, for example, that any powerful proof technique for parallel languages must include some form of analysis to obtain information about the communication topology of the program. The difficulty of this task is illustrated in various papers <ref> [22, 25] </ref>. Such analyses become much simpler in our framework because the topology is directly available from the specification of the architecture. A significant benefit of our approach is that the direct information flows of a system are made explicit.
Reference: [26] <author> O. Nierstrasz, </author> <title> Regular types for active objects, </title> <journal> Proc. OOPSLA'93, ACM Sigplan Notices, </journal> <volume> Vol. 28, No 10, </volume> <pages> pp. 1-15, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: Also the types associated with the links in the architecture do not include a communication protocol dimension. We have assumed a rendez-vous mechanism here but a useful extension would be to associate links with user-defined communication protocols. One promising research direction is the notion of regular processes used in <ref> [26] </ref> to specify protocols for object behaviours. Another issue deserving further work is the design of a user friendly interface supporting externally initiated changes to the architecture [18]. In our framework, these changes could be expressed, and formally controlled, through the `external agents' as exemplified by the client-server case study.
Reference: [27] <author> D. E. Perry and A. Wolf, </author> <title> Foundations for the study of software architecture, </title> <booktitle> ACM Sigsoft, Software Engineering Notes, </booktitle> <volume> Vol. 17, No. 4, </volume> <pages> pp. 40-52, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: Despite some differences of emphasis, these works share a common point of view: the definition of a software application should make a clear distinction between individual components and their interaction in the overall software organisation. Several authors <ref> [1, 2, 16, 27] </ref> have emphasized the importance of a framework for the formal definition of software architectures. Not only is it a prerequisite for a rigorous analysis of architectures, but it also increases their usefulness and reusability by removing the sources of ambiguity which are unavoidable in informal descriptions.
Reference: [28] <author> J.-C. Raoult and F. Voisin. </author> <title> Set-theoretic graph rewriting, </title> <booktitle> Proc. int. Workshop on Graph Transformations in Computer Science, </booktitle> <publisher> Springer Verlag, LNCS 776, </publisher> <pages> pp. 312-325, </pages> <year> 1993. </year>
Reference-contexts: The coordinator is in charge of managing the architec ture itself (creating and removing entities and links). The coordinator is expressed in terms of conditional graph rewriting in the spirit of <ref> [10, 28] </ref>. The conditions bear on the public variables of the entities and represent the only possible interactions between a coordinator and the individual components (apart from the creation and destruction of links and entities). <p> A second example is presented in the appendix (a distributed hospital ward monitoring system inspired by [18] and [15]). 2 Architecture styles Our notion of graphs is inspired by previous work on the chemical reaction model [3, 4, 10] and set-theoretic graph rewriting <ref> [28] </ref>. Formally, a graph is a multiset of relation tuples noted R (e 1 ; : : : ; e n ) where R is a n-ary relation name and e i are entity names (we assume appropriate countable sets of names). We consider only binary and unary relations here. <p> The second condition ensures that new variables occurring on the right-hand side of a rule are instantiated with entity names which are distinct from all other existing names. This constraint, which is usual in graph rewriting <ref> [28] </ref>, is necessary to avoid unexpected variable sharing. It is crucial in our context to be able to state precisely the actual connections between entities.
Reference: [29] <author> M. Shaw and D. Garlan, </author> <booktitle> Formulations and formalisms in software architecture, Computer Science Today, Recent Trends and Developments, </booktitle> <publisher> Springer Verlag, LNCS 1000, </publisher> <pages> pp. 307-323, </pages> <year> 1995. </year>
Reference-contexts: Up-to-date surveys of formalisms and current trends can be found in <ref> [12, 29] </ref>. <p> basic computational model; the event-based structures of [20] are well suited to the explicit representation of timing properties; the logical theories used in [24] form the basis of a definition of a notion of architecture refinement. * Software architecture languages: there is a great variety of needs for software architectures <ref> [29] </ref> and this fact is reflected in the variety of papers published in this active area during the last few years. Aesop [11] provides facilities for the design and graphical visual-isation of architectures following the rules prescribed by specific styles.
Reference: [30] <author> M. Shaw, R. DeLine, D. V. Klein, T. L. Ross, D. M. Young and G. Zelesnik, </author> <title> Abstractions for software architecture and tools to support them, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. 21, No. 4, </volume> <pages> pp. 314-335, </pages> <month> April </month> <year> 1995. </year> <month> 8 </month>
Reference-contexts: Aesop [11] provides facilities for the design and graphical visual-isation of architectures following the rules prescribed by specific styles. Architecture styles are defined in a generic object model and include the specification of a vocabulary and constraints on the connections between elements. Unicon <ref> [30] </ref> supports a variety of components (such as `shared data', `filter', `sequential file') and connectors (such as `pipes', `remote procedure calls') which have been implemented and used as a testbed for experimenting system construction mechanisms.
References-found: 30

