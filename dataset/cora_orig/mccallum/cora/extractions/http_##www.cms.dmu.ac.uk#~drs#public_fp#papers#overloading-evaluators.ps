URL: http://www.cms.dmu.ac.uk/~drs/public_fp/papers/overloading-evaluators.ps
Refering-URL: http://www.cms.dmu.ac.uk/~drs/public_fp/papers/
Root-URL: 
Email: cvh@dcs.gla.ac.uk  
Title: Using Overloading to Express Distinctions Between Evaluators 1  
Author: Cordelia V. Hall 
Keyword: Key words: evaluator, overloading, functional programming, abstract interpretation  
Address: G12 8QQ, U.K.  
Affiliation: Department of Computing Science, University of Glasgow,  
Abstract: Evaluators, also called "interpreters", play a variety of roles in the study of programming languages. Given this, it's surprising that we don't have a better framework for developing evaluators and specifying their relationship to each other. This paper shows that type classes in HASKELL provide an excellent framework for exploring relationships between evaluators, using ab stract interpretation as a motivating example.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Abelson, H., G. J. Sussman, and J. Sussman, </author> <title> Structure and Interpretation of Computer Programs, </title> <publisher> MIT Press, </publisher> <year> 1985. </year>
Reference-contexts: Given this, it's surprising that we don't have a better framework for developing evaluators and specifying their relationship to each other. For example, at least two new innovations in the implementation of functional languages were expressed as subtle variations on the familiar metacircular Lisp evaluator <ref> [1] </ref>. The original Lisp evaluator developed by McCarthy implemented dynamic instead of static scoping and didn't support higher order functions. A few small changes yielded an evaluator for a statically scoped higher order language.
Reference: 2. <author> Abramsky, S. and Hankin, C., </author> <title> An introduction to abstract interpretation,Abstract Interpretation of Declarative Languages,Samson Abramsky and Chris Hankin, </title> <editor> eds., </editor> <publisher> Ellis Horwood Limited, </publisher> <address> Chichester, England, </address> <year> 1987, </year> <pages> pp. 266-275. </pages>
Reference-contexts: 1. Introduction Evaluators, also called "interpreters", play a variety of roles in the study of programming languages. They define the meaning of programs [7], support the development of new language paradigms [3], relate abstract semantics of programs to the corresponding concrete semantics <ref> [2] </ref>, provide debugging information [5], and yet are simple enough to teach students about the implementation of programming languages. Given this, it's surprising that we don't have a better framework for developing evaluators and specifying their relationship to each other. <p> Both of these results were more accessible because the original evaluator was so simple and well known. Other pairs of evaluators apparently have little in common, yet we need to have a complete understanding of their relationship. For example, abstract interpretation <ref> [2] </ref> derives its power from the relationship between abstract and concrete interpretations of the same program. Each evaluator is quite different from the other, so much so that they cannot really share code. <p> Testing safety conditions It would be nice to support prototyping of abstract interpretations by checking safety. In order to do this, we have to define two functions, abs and conc <ref> [2] </ref>, so that the following conditions can be established: abs (f x) v f# (abs x) f x 2 conc (f# (abs x)) Unfortunately, it isn't always possible to perform these checks automatically. First of all, the abs function cannot be implemented as defined. <p> For these reasons, it is not practical to check safety conditions for the abstract interpretation given in the previous section. However, if the concrete domain is flat, then these problems do not arise. In this section, we'll define Mycroft's strictness analysis over flat domains <ref> [2] </ref> and give an implementation of the safety conditions for that abstract interpretation. 3.1.
Reference: 3. <author> Friedman, D. P. and D. S. Wise, </author> <title> CONS should not evaluate its arguments, </title> <editor> in : S. Michaelson and R. Milner, Eds., </editor> <title> Automata, </title> <note> Languages and Programming (Edinburgh University Press, </note> <year> 1976) </year> <month> 257-284. </month>
Reference-contexts: 1. Introduction Evaluators, also called "interpreters", play a variety of roles in the study of programming languages. They define the meaning of programs [7], support the development of new language paradigms <ref> [3] </ref>, relate abstract semantics of programs to the corresponding concrete semantics [2], provide debugging information [5], and yet are simple enough to teach students about the implementation of programming languages. <p> The original Lisp evaluator developed by McCarthy implemented dynamic instead of static scoping and didn't support higher order functions. A few small changes yielded an evaluator for a statically scoped higher order language. Friedman and Wise 1 To appear in Information Processing Letters 2 <ref> [3] </ref> altered this new evaluator by redefining the semantics of cons, and implemented call by need. Both of these results were more accessible because the original evaluator was so simple and well known.
Reference: 4. <institution> Report on the Programming Language Haskell, </institution> <note> Version 1.0, 1 April 1990, </note> <editor> Paul Hudak, Philip Wadler, eds., </editor> <publisher> University of Glasgow and Yale University. </publisher>
Reference-contexts: The purpose of this paper is to show that type classes in HASKELL <ref> [4] </ref> provide an excellent framework for exploring relationships between evaluators. For example, suppose we wish to write two evaluators that are identical, except that one uses an alternate semantics for some primitive function. In this case, we want to be fully aware of the two contrasting meanings of this primitive. <p> This is the approach that will be adopted in the rest of the paper, using the implementation of abstract interpretations applied to strictness analysis and the verification of safety conditions as a motivating example. We'll assume familiarity with the HASKELL type system, which is described in detail elsewhere (see <ref> [4] </ref> for the language definition). The next 3 sections implement two abstract interpretations, automatically checking safety conditions for the interpretation on flat domains. Finally, we discuss the results and conclude. 2. Abstract interpretation using overloading In this section, we implement an abstract interpretation over first order list domains [8].
Reference: 5. <author> O'Donnell, J.T. and C.V. Hall, </author> <title> Debugging in applicative languages, </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 1, </volume> <month> 113-145 </month> <year> (1988). </year> <month> 13 </month>
Reference-contexts: 1. Introduction Evaluators, also called "interpreters", play a variety of roles in the study of programming languages. They define the meaning of programs [7], support the development of new language paradigms [3], relate abstract semantics of programs to the corresponding concrete semantics [2], provide debugging information <ref> [5] </ref>, and yet are simple enough to teach students about the implementation of programming languages. Given this, it's surprising that we don't have a better framework for developing evaluators and specifying their relationship to each other.
Reference: 6. <author> O'Donnell, J.T., </author> <title> Generating netlists from executable circuit specifications in a pure functional language, </title> <booktitle> Functional Programming, </booktitle> <address> Glasgow 1992, </address> <publisher> Springer Workshops in Computing. </publisher>
Reference-contexts: It is possible to use the framework given in section 2 and create one evaluator, overloading cons, head and tail. Other possible applications of this use of type classes include implementing debuggers and extracting a netlist from a functional hardware specification <ref> [6] </ref>. 5. Acknowledgements I would like to thank John T. O'Donnell and Mark P. Jones for useful comments on an earlier draft. This work was supported by the GRASP project.
Reference: 7. <author> Schmidt, D. A., </author> <title> Denotational Semantics, </title> <publisher> Allyn and Bacon, Inc., </publisher> <address> Mas-sachusetts, </address> <year> 1986. </year>
Reference-contexts: 1. Introduction Evaluators, also called "interpreters", play a variety of roles in the study of programming languages. They define the meaning of programs <ref> [7] </ref>, support the development of new language paradigms [3], relate abstract semantics of programs to the corresponding concrete semantics [2], provide debugging information [5], and yet are simple enough to teach students about the implementation of programming languages.
Reference: 8. <author> Wadler, P., </author> <title> Strictness analysis on non-flat domains (by Abstract interpretation over finite domains),Abstract Interpretation of Declarative Languages,Samson Abramsky and Chris Hankin, </title> <editor> eds., </editor> <publisher> Ellis Horwood Limited, </publisher> <address> Chichester, England, </address> <year> 1987, </year> <pages> pp. 266-275. </pages>
Reference-contexts: The next 3 sections implement two abstract interpretations, automatically checking safety conditions for the interpretation on flat domains. Finally, we discuss the results and conclude. 2. Abstract interpretation using overloading In this section, we implement an abstract interpretation over first order list domains <ref> [8] </ref>. <p> Bot TopE = BotE &gt; cons Top BotE = BotE &gt; cons Bot BotE = BotE &gt; cons Top Inf = Inf &gt; cons Bot Inf = Inf &gt; cons Top Bot = Inf &gt; cons Bot Bot = Inf The definition of casefun implements the definition of h in <ref> [8] </ref>, which is a straightforward implementation of case plus some simplification. &gt; casefun TopE b1 b2 = (b1 []) `lub` (b2 [Top,TopE]) &gt; casefun BotE b1 b2 = (b2 [Bot,TopE]) `lub` (b2 [Top,BotE]) &gt; casefun Inf b1 b2 = (b2 [Top,Inf]) &gt; casefun Bot b1 b2 = Bot Fixpoints are calculated
References-found: 8

