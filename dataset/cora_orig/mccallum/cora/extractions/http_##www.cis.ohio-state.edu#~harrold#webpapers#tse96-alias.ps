URL: http://www.cis.ohio-state.edu/~harrold/webpapers/tse96-alias.ps
Refering-URL: http://www.cis.ohio-state.edu/~harrold/788.12p/readings.html
Root-URL: 
Email: fharrold, grotherg@cis.ohio-state.edu  
Title: Separate Computation of Alias Information for Reuse  
Author: Mary Jean Harrold and Gregg Rothermel 
Address: 2015 Neil Avenue Columbus, OH 43210-1277  
Affiliation: Department of Computer and Information Science Ohio State University 395 Dreese Lab  
Abstract: Interprocedural data flow information is useful for many software testing and analysis techniques, including data flow testing, regression testing, program slicing, and impact analysis. For programs with aliases, these testing and analysis techniques can yield invalid results, unless the data flow information accounts for aliasing effects. Recent research provides algorithms for performing interprocedural data flow analysis in the presence of aliases; however, these algorithms are expensive, and achieve precise results only on complete programs. This paper presents an algorithm for performing alias analysis on incomplete programs that lets individual software components such as library routines, subroutines, or subsystems be independently analyzed. The paper also presents an algorithm for reusing the results of this separate analysis when the individual software components are linked with calling modules. Our algorithms let us analyze frequently used software components, such as library routines or classes, independently, and reuse the results of that analysis when analyzing calling programs, without incurring the expense of completely reanalyzing each calling program. Our algorithms also provide a way to analyze large systems incrementally.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers, Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, MA, </address> <year> 1986. </year>
Reference-contexts: entry node E and exit node X W orklist : list of [(N; AA) IC ; P A], initially empty CondMayAlias-Module : set of [(N; (AA)) IC ; (P A)] MayAlias-Module : set of [N IC ; (P A)] P ASet : set of names potentially aliased in M begin <ref> [1] </ref> construct G, an ICFG for M /* construct the ICFG for M */ [2] compute P ASet for M /* compute the PASet for M */ [3] foreach P A in P ASet do /* compute conditional may alias introductions for M */ [4] add [(E; P A) P A <p> aliased after N declare G : an interprocedural control flow graph (ICFG) for P W orklist : list of [(N; AA); P A]; initially empty CondMayAlias : set of [(N; (AA)); (P A)] for P CondMayAlias-LinkInf o: conditional may aliases for modules MayAlias-LinkInf o: alias link information for modules begin <ref> [1] </ref> construct G, an ICFG for P [2] foreach N in G do /* compute conditional may alias introductions for P */ [3] if N is an assignment to a pointer or a call node then [4] add conditional may aliases introduced by N to W orklist and CondMayAlias [5] if <p> The first set of modules is a set of routines from the Aristotle program analysis system that implement computation of reverse control flow graphs, dominator trees <ref> [1] </ref>, control dependencies, and control dependence graphs [5]. These program analysis modules were designed to be reusable; they do not use global variables, and they have few parameters. The maximum size of a P ASet for these modules is six. The modules are good candidates for separate analysis.
Reference: [2] <author> D. R. Chase, M. Wegman, and F. K. Zadeck. </author> <title> Analysis of pointers and structures. </title> <booktitle> In Proceedings of the ACM SIGPLAN'90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 296-310, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: IC ; P A], initially empty CondMayAlias-Module : set of [(N; (AA)) IC ; (P A)] MayAlias-Module : set of [N IC ; (P A)] P ASet : set of names potentially aliased in M begin [1] construct G, an ICFG for M /* construct the ICFG for M */ <ref> [2] </ref> compute P ASet for M /* compute the PASet for M */ [3] foreach P A in P ASet do /* compute conditional may alias introductions for M */ [4] add [(E; P A) P A ; P A] to W orklist and to CondMayAlias-Module [5] foreach N in G <p> interprocedural control flow graph (ICFG) for P W orklist : list of [(N; AA); P A]; initially empty CondMayAlias : set of [(N; (AA)); (P A)] for P CondMayAlias-LinkInf o: conditional may aliases for modules MayAlias-LinkInf o: alias link information for modules begin [1] construct G, an ICFG for P <ref> [2] </ref> foreach N in G do /* compute conditional may alias introductions for P */ [3] if N is an assignment to a pointer or a call node then [4] add conditional may aliases introduced by N to W orklist and CondMayAlias [5] if N is an exit node of a
Reference: [3] <author> J-D. Choi, M. Burke, and P. Carini. </author> <title> Efficient flow-sensitive interprocedural computation of pointer-induced aliases and side effects. </title> <booktitle> In Proceedings of the 20th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 232-245, </pages> <month> January </month> <year> 1993. </year> <month> 27 </month>
Reference-contexts: ; (P A)] MayAlias-Module : set of [N IC ; (P A)] P ASet : set of names potentially aliased in M begin [1] construct G, an ICFG for M /* construct the ICFG for M */ [2] compute P ASet for M /* compute the PASet for M */ <ref> [3] </ref> foreach P A in P ASet do /* compute conditional may alias introductions for M */ [4] add [(E; P A) P A ; P A] to W orklist and to CondMayAlias-Module [5] foreach N in G do [6] if N is an assignment to a pointer or a call <p> A]; initially empty CondMayAlias : set of [(N; (AA)); (P A)] for P CondMayAlias-LinkInf o: conditional may aliases for modules MayAlias-LinkInf o: alias link information for modules begin [1] construct G, an ICFG for P [2] foreach N in G do /* compute conditional may alias introductions for P */ <ref> [3] </ref> if N is an assignment to a pointer or a call node then [4] add conditional may aliases introduced by N to W orklist and CondMayAlias [5] if N is an exit node of a separately analyzed module M then [6] foreach [(N; ) ; P A] in CondM ayAlias-LinkInf
Reference: [4] <author> M. Emami, R. Ghiya, and L. J. Hendren. </author> <title> Context-sensitive interprocedural points-to analysis in the presence of function pointers. </title> <booktitle> In Proceedings of the ACM SIGPLAN'94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 242-256, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: names potentially aliased in M begin [1] construct G, an ICFG for M /* construct the ICFG for M */ [2] compute P ASet for M /* compute the PASet for M */ [3] foreach P A in P ASet do /* compute conditional may alias introductions for M */ <ref> [4] </ref> add [(E; P A) P A ; P A] to W orklist and to CondMayAlias-Module [5] foreach N in G do [6] if N is an assignment to a pointer or a call statement then [7] add conditional may aliases introduced by N to W orklist and to CondM ayAlias-Module <p> o: conditional may aliases for modules MayAlias-LinkInf o: alias link information for modules begin [1] construct G, an ICFG for P [2] foreach N in G do /* compute conditional may alias introductions for P */ [3] if N is an assignment to a pointer or a call node then <ref> [4] </ref> add conditional may aliases introduced by N to W orklist and CondMayAlias [5] if N is an exit node of a separately analyzed module M then [6] foreach [(N; ) ; P A] in CondM ayAlias-LinkInf o for M do [7] add [(N; ); P A] to W orklist and
Reference: [5] <author> J. Ferrante, K. J. Ottenstein, and J. D. Warren. </author> <title> The program dependence graph and its use in optimization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(3) </volume> <pages> 319-349, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: ICFG for M */ [2] compute P ASet for M /* compute the PASet for M */ [3] foreach P A in P ASet do /* compute conditional may alias introductions for M */ [4] add [(E; P A) P A ; P A] to W orklist and to CondMayAlias-Module <ref> [5] </ref> foreach N in G do [6] if N is an assignment to a pointer or a call statement then [7] add conditional may aliases introduced by N to W orklist and to CondM ayAlias-Module [8] while W orklist is not empty do /* compute conditional may alias information for M <p> begin [1] construct G, an ICFG for P [2] foreach N in G do /* compute conditional may alias introductions for P */ [3] if N is an assignment to a pointer or a call node then [4] add conditional may aliases introduced by N to W orklist and CondMayAlias <ref> [5] </ref> if N is an exit node of a separately analyzed module M then [6] foreach [(N; ) ; P A] in CondM ayAlias-LinkInf o for M do [7] add [(N; ); P A] to W orklist and CondMayAlias [8] while W orklist is not empty do /* compute conditional may <p> The first set of modules is a set of routines from the Aristotle program analysis system that implement computation of reverse control flow graphs, dominator trees [1], control dependencies, and control dependence graphs <ref> [5] </ref>. These program analysis modules were designed to be reusable; they do not use global variables, and they have few parameters. The maximum size of a P ASet for these modules is six. The modules are good candidates for separate analysis.
Reference: [6] <author> M. J. Harrold, L. Larsen, J. Lloyd, D. Nedved, M. Page, G. Rothermel, M. Singh, and M. Smith. Aristotle: </author> <title> a system for the development of program-analysis-based tools. </title> <booktitle> In Proceedings of the 33rd Annual Southeast Conference, </booktitle> <pages> pages 110-119. </pages> <publisher> ACM Press, </publisher> <month> March </month> <year> 1995. </year>
Reference-contexts: P ASet for M /* compute the PASet for M */ [3] foreach P A in P ASet do /* compute conditional may alias introductions for M */ [4] add [(E; P A) P A ; P A] to W orklist and to CondMayAlias-Module [5] foreach N in G do <ref> [6] </ref> if N is an assignment to a pointer or a call statement then [7] add conditional may aliases introduced by N to W orklist and to CondM ayAlias-Module [8] while W orklist is not empty do /* compute conditional may alias information for M */ [9] remove [(N; AA) IC <p> /* compute conditional may alias introductions for P */ [3] if N is an assignment to a pointer or a call node then [4] add conditional may aliases introduced by N to W orklist and CondMayAlias [5] if N is an exit node of a separately analyzed module M then <ref> [6] </ref> foreach [(N; ) ; P A] in CondM ayAlias-LinkInf o for M do [7] add [(N; ); P A] to W orklist and CondMayAlias [8] while W orklist is not empty do /* compute conditional may alias for P */ [9] remove [(N; AA); P A] from W orklist [10] <p> The results of our analyses are shown in Tables 14, 15, and 16. Table 14 shows the results of our analysis of four ADT modules. The STACK, SET, and QUEUE modules are ADTs written in C, provided with the Aristotle program analysis system <ref> [6] </ref>. The STRING CLASS is an ADT written in C++, provided with a commercial compiler. Most of the modules in the ADTs make no use of global variables; those that use globals use at most two. No module uses more than three parameters.
Reference: [7] <author> M. J. Harrold and G. Rothermel. </author> <title> Separate computation of alias information for reuse. </title> <booktitle> In Proceedings of the ACM International Symposium on Software Testing and Analysis, </booktitle> <pages> pages 107-120, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: A in P ASet do /* compute conditional may alias introductions for M */ [4] add [(E; P A) P A ; P A] to W orklist and to CondMayAlias-Module [5] foreach N in G do [6] if N is an assignment to a pointer or a call statement then <ref> [7] </ref> add conditional may aliases introduced by N to W orklist and to CondM ayAlias-Module [8] while W orklist is not empty do /* compute conditional may alias information for M */ [9] remove [(N; AA) IC ; P A] from W orklist [10] propagate at N and update W orklist <p> assignment to a pointer or a call node then [4] add conditional may aliases introduced by N to W orklist and CondMayAlias [5] if N is an exit node of a separately analyzed module M then [6] foreach [(N; ) ; P A] in CondM ayAlias-LinkInf o for M do <ref> [7] </ref> add [(N; ); P A] to W orklist and CondMayAlias [8] while W orklist is not empty do /* compute conditional may alias for P */ [9] remove [(N; AA); P A] from W orklist [10] if N is a call node then [11] propagate at N ; add to
Reference: [8] <author> W. Landi. </author> <title> Interprocedural Aliasing in the Presence of Pointers. </title> <type> PhD thesis, </type> <institution> Rutgers University, </institution> <year> 1992. </year>
Reference-contexts: add [(E; P A) P A ; P A] to W orklist and to CondMayAlias-Module [5] foreach N in G do [6] if N is an assignment to a pointer or a call statement then [7] add conditional may aliases introduced by N to W orklist and to CondM ayAlias-Module <ref> [8] </ref> while W orklist is not empty do /* compute conditional may alias information for M */ [9] remove [(N; AA) IC ; P A] from W orklist [10] propagate at N and update W orklist and CondMayAlias-Module [11] foreach [(N; AA) IC ; P A] in CondM ayAlias-Module do /* <p> conditional may aliases introduced by N to W orklist and CondMayAlias [5] if N is an exit node of a separately analyzed module M then [6] foreach [(N; ) ; P A] in CondM ayAlias-LinkInf o for M do [7] add [(N; ); P A] to W orklist and CondMayAlias <ref> [8] </ref> while W orklist is not empty do /* compute conditional may alias for P */ [9] remove [(N; AA); P A] from W orklist [10] if N is a call node then [11] propagate at N ; add to W orklist and CondMayAlias [12] elseif N is an entry node <p> link information output by ComputeMayAlias-Hybrid may be used by AnalyzeApplication, or again by ComputeMayAlias-Hybrid, to analyze a program or module that calls R. 3.5 Complexity Landi and Ryder's ComputeMayAlias algorithm runs in time O (n 3 ) for ICFGs of size n; thus, the algorithm is polynomial in program size <ref> [8] </ref>. Preliminary experimentation with ComputeMayAlias suggests, however, that in practice the algorithm runs in time linear in the size of the may alias solution [8]. ComputeMayAlias propagates only aliases that actually occur in a program. ComputeMayAlias-Module, in contrast, propagates all aliases in P ASet. <p> Complexity Landi and Ryder's ComputeMayAlias algorithm runs in time O (n 3 ) for ICFGs of size n; thus, the algorithm is polynomial in program size <ref> [8] </ref>. Preliminary experimentation with ComputeMayAlias suggests, however, that in practice the algorithm runs in time linear in the size of the may alias solution [8]. ComputeMayAlias propagates only aliases that actually occur in a program. ComputeMayAlias-Module, in contrast, propagates all aliases in P ASet.
Reference: [9] <author> W. Landi and B. G. Ryder. </author> <title> Pointer-induced aliasing: A problem classification. </title> <booktitle> In Proceedings of the 17th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 93-103, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: N in G do [6] if N is an assignment to a pointer or a call statement then [7] add conditional may aliases introduced by N to W orklist and to CondM ayAlias-Module [8] while W orklist is not empty do /* compute conditional may alias information for M */ <ref> [9] </ref> remove [(N; AA) IC ; P A] from W orklist [10] propagate at N and update W orklist and CondMayAlias-Module [11] foreach [(N; AA) IC ; P A] in CondM ayAlias-Module do /* compute may alias information for M */ [12] add [N IC ; P A] to MayAlias-Module [13] <p> exit node of a separately analyzed module M then [6] foreach [(N; ) ; P A] in CondM ayAlias-LinkInf o for M do [7] add [(N; ); P A] to W orklist and CondMayAlias [8] while W orklist is not empty do /* compute conditional may alias for P */ <ref> [9] </ref> remove [(N; AA); P A] from W orklist [10] if N is a call node then [11] propagate at N ; add to W orklist and CondMayAlias [12] elseif N is an entry node of a separately analyzed module M (with exit node X) then [13] foreach [(X; AA 0 <p> Marlowe and Ryder [13] extend their hybrid approach to handle aliases for Fortran programs. In this work, they introduce the idea of using one representative global variable to stand for any global variable aliased to a formal parameter at the entry node. Landi and Ryder <ref> [9] </ref> present an algorithm to compute may alias information in the presence of pointer variables that uses alias assumptions at the entry to a function to compute this may alias information.
Reference: [10] <author> W. Landi and B. G. Ryder. </author> <title> A safe approximate algorithm for interprocedural pointer aliasing. </title> <booktitle> In Proceedings of the ACM SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 235-248, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: a pointer or a call statement then [7] add conditional may aliases introduced by N to W orklist and to CondM ayAlias-Module [8] while W orklist is not empty do /* compute conditional may alias information for M */ [9] remove [(N; AA) IC ; P A] from W orklist <ref> [10] </ref> propagate at N and update W orklist and CondMayAlias-Module [11] foreach [(N; AA) IC ; P A] in CondM ayAlias-Module do /* compute may alias information for M */ [12] add [N IC ; P A] to MayAlias-Module [13] ICF G-Module = node set fE; Xg and edge set f <p> [6] foreach [(N; ) ; P A] in CondM ayAlias-LinkInf o for M do [7] add [(N; ); P A] to W orklist and CondMayAlias [8] while W orklist is not empty do /* compute conditional may alias for P */ [9] remove [(N; AA); P A] from W orklist <ref> [10] </ref> if N is a call node then [11] propagate at N ; add to W orklist and CondMayAlias [12] elseif N is an entry node of a separately analyzed module M (with exit node X) then [13] foreach [(X; AA 0 ) IC ; P A 0 ] in CondM <p> Landi and Ryder [9] present an algorithm to compute may alias information in the presence of pointer variables that uses alias assumptions at the entry to a function to compute this may alias information. A subsequent algorithm <ref> [10] </ref> uses a worklist approach that, instead of considering all alias assumptions at the entry to a function, computes the solution to the may alias problem for only the alias pairs that actually reach the function. Our separate analysis algorithms are similar to the above work.
Reference: [11] <author> J. R. Larus and P. N. Hilfinger. </author> <title> Detecting conflicts between structure accesses. </title> <booktitle> In Proceedings of the ACM SIGPLAN'88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 21-34, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: may aliases introduced by N to W orklist and to CondM ayAlias-Module [8] while W orklist is not empty do /* compute conditional may alias information for M */ [9] remove [(N; AA) IC ; P A] from W orklist [10] propagate at N and update W orklist and CondMayAlias-Module <ref> [11] </ref> foreach [(N; AA) IC ; P A] in CondM ayAlias-Module do /* compute may alias information for M */ [12] add [N IC ; P A] to MayAlias-Module [13] ICF G-Module = node set fE; Xg and edge set f (E; X)g [14] foreach [(X; AA) IC ; P A] <p> CondM ayAlias-LinkInf o for M do [7] add [(N; ); P A] to W orklist and CondMayAlias [8] while W orklist is not empty do /* compute conditional may alias for P */ [9] remove [(N; AA); P A] from W orklist [10] if N is a call node then <ref> [11] </ref> propagate at N ; add to W orklist and CondMayAlias [12] elseif N is an entry node of a separately analyzed module M (with exit node X) then [13] foreach [(X; AA 0 ) IC ; P A 0 ] in CondM ayAlias-LinkInf o such that IC = P A
Reference: [12] <author> T. J. Marlowe and B. G. Ryder. </author> <title> An efficient hybrid algorithm for incremental data flow analysis. </title> <booktitle> In Conference Record of the 17th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 184-196, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: /* compute conditional may alias information for M */ [9] remove [(N; AA) IC ; P A] from W orklist [10] propagate at N and update W orklist and CondMayAlias-Module [11] foreach [(N; AA) IC ; P A] in CondM ayAlias-Module do /* compute may alias information for M */ <ref> [12] </ref> add [N IC ; P A] to MayAlias-Module [13] ICF G-Module = node set fE; Xg and edge set f (E; X)g [14] foreach [(X; AA) IC ; P A] in CondM ayAlias-Module do /* output may alias link information for M */ [15] add [(X; AA); P A] to <p> A] to W orklist and CondMayAlias [8] while W orklist is not empty do /* compute conditional may alias for P */ [9] remove [(N; AA); P A] from W orklist [10] if N is a call node then [11] propagate at N ; add to W orklist and CondMayAlias <ref> [12] </ref> elseif N is an entry node of a separately analyzed module M (with exit node X) then [13] foreach [(X; AA 0 ) IC ; P A 0 ] in CondM ayAlias-LinkInf o such that IC = P A do [14] add [(X; AA 0 ); P A 0 ] <p> An efficient implementation, in which CondM ayAlias entries are organized in terms of inducement conditions, may yield a lower run time in practice. 3.6 Relation to previous work Marlowe and Ryder <ref> [12] </ref> present a hybrid algorithm for data flow analysis that decomposes the control flow graph of a program into regions. Their algorithm first solves data flow problems within regions separately.
Reference: [13] <author> T. J. Marlowe and B. G. Ryder. </author> <title> Hybrid incremental alias analysis. </title> <booktitle> In Proceedings of the 24th Hawaii International Conference on System Sciences, </booktitle> <pages> pages 428-437, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: [9] remove [(N; AA) IC ; P A] from W orklist [10] propagate at N and update W orklist and CondMayAlias-Module [11] foreach [(N; AA) IC ; P A] in CondM ayAlias-Module do /* compute may alias information for M */ [12] add [N IC ; P A] to MayAlias-Module <ref> [13] </ref> ICF G-Module = node set fE; Xg and edge set f (E; X)g [14] foreach [(X; AA) IC ; P A] in CondM ayAlias-Module do /* output may alias link information for M */ [15] add [(X; AA); P A] to CondM ayAlias-LinkInf o [16] foreach may alias [N IC <p> alias for P */ [9] remove [(N; AA); P A] from W orklist [10] if N is a call node then [11] propagate at N ; add to W orklist and CondMayAlias [12] elseif N is an entry node of a separately analyzed module M (with exit node X) then <ref> [13] </ref> foreach [(X; AA 0 ) IC ; P A 0 ] in CondM ayAlias-LinkInf o such that IC = P A do [14] add [(X; AA 0 ); P A 0 ] to CondM ayAlias and W orklist [15] else propagate at N and add to W orklist and CondMayAlias <p> Then, during propagation of data flow information throughout the condensed graph, no further propagation is required within regions only the virtual data flow information must be updated. Marlowe and Ryder <ref> [13] </ref> extend their hybrid approach to handle aliases for Fortran programs. In this work, they introduce the idea of using one representative global variable to stand for any global variable aliased to a formal parameter at the entry node.


References-found: 13

