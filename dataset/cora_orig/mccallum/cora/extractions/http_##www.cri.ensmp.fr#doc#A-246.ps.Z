URL: http://www.cri.ensmp.fr/doc/A-246.ps.Z
Refering-URL: http://www.cri.ensmp.fr/rapports.html
Root-URL: 
Email: E-mail: ftang,jouvelotg@cri.ensmp.fr  
Title: Effect Systems with Subtyping  
Author: Yan Mei Tang Pierre Jouvelot 
Address: Paris  
Affiliation: Centre de Recherche en Informatique Ecole Des Mines de  
Abstract: Effect systems extend classical type systems with effect information. Just as types describe the possible values of expressions, effects describe their possible evaluation behaviors. Effects, which appear in function types, introduce new constraints on the typability of expressions. To increase the flexibility and accuracy of effect systems, we present a new effect system based on subtyping. The subtype relation is induced by a subsumption relation on effects. This subtyp-ing effect system avoids merging effect information together, thus collecting more precise effect information. We introduce a reconstruction algorithm which for any expression already typed with classical types, reconstructs its type and effect based on the subtype relation. The reconstruction algorithm is sound and complete w.r.t. the static semantics. 
Abstract-found: 1
Intro-found: 1
Reference: [Cardelli88] <author> Cardelli, L. </author> <title> Structural Subtyping and the Notion of Power Type. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 70-79, </pages> <year> 1988. </year>
Reference-contexts: 1 E ` e : t 1 ; c 1 then S (E; e) = ht; c; i and there exists an effect model of , such that: 1 E = E and t t 1 and c 1 c Proof See the appendix. 4 Related Work Subtyping (see e.g. <ref> [Cardelli88] </ref>) adds flexibility to type systems by allowing type coercions to be performed if necessary in the presence of type mismatches. It is often used to captures aspects of object-oriented programming [Wand87, Stansifer88]. Subtyping in effect systems has been previously introduced in explicitly typed languages [Gifford87, Consel94].
Reference: [Consel93] <author> Consel, C., and Jouvelot, P. </author> <title> Separate Polyvari-ant Binding-Time Analysis. </title> <type> OGI Tech. Rep. CS/E 93-006, </type> <month> March </month> <year> 1993. </year>
Reference: [Consel94] <author> Consel, C., Jouvelot, P., and Orbaek, P. </author> <title> Separate Polyvariant Binding-Time Reconstruction. </title> <type> Technical Report A-261, </type> <institution> Ecole des Mines de Paris, </institution> <month> July </month> <year> 1994. </year>
Reference-contexts: It is often used to captures aspects of object-oriented programming [Wand87, Stansifer88]. Subtyping in effect systems has been previously introduced in explicitly typed languages <ref> [Gifford87, Consel94] </ref>. There, a subsumption rule similar to the one presented above was used, but since only type checking was performed, its treatment was simpler than ours. This paper shows that type and effect reconstruction may be performed in an implicitly typed language.
Reference: [Dornic91] <author> Dornic, V. and Jouvelot, P. </author> <title> Polymorphic Time Systems for Estimating Program Complexity. </title> <booktitle> In JTASPEFL'91, </booktitle> <address> Bordeaux, France, </address> <year> 1991. </year>
Reference-contexts: There, a subsumption rule similar to the one presented above was used, but since only type checking was performed, its treatment was simpler than ours. This paper shows that type and effect reconstruction may be performed in an implicitly typed language. Previous implicit effect systems <ref> [Dornic91, Talpin92, Tang92] </ref> have introduced subeffecting, via the subeffecting rule (see Section 2), to increase the flexibility of the static semantics. Subeffecting allows expressions of same classical types to also have the same effect-including types by allowing such effects to be replaced by larger ones if need be.
Reference: [Gifford87] <author> Gifford, D. K., Jouvelot, P., Lucassen, J. M., and Sheldon, M. A. </author> <title> FX-87 Reference Manual. </title> <institution> MIT/LCS/TR-407, MIT Laboratory for Computer Science, </institution> <month> September </month> <year> 1987. </year>
Reference-contexts: However, effects, which appear in function types, introduce new constraints on the typability of expressions, i.e., effect checking may force the rejection of programs which would have type-checked if no effects were present. To increase the flexibility of previous effect systems, subef-fecting has been introduced <ref> [Gifford87, Talpin92, Tang92] </ref>. Subeffecting allows expressions to admit larger effects, thus enabling type misatches due to the introduction of effect information to be eliminated. <p> It is often used to captures aspects of object-oriented programming [Wand87, Stansifer88]. Subtyping in effect systems has been previously introduced in explicitly typed languages <ref> [Gifford87, Consel94] </ref>. There, a subsumption rule similar to the one presented above was used, but since only type checking was performed, its treatment was simpler than ours. This paper shows that type and effect reconstruction may be performed in an implicitly typed language.
Reference: [Milner78] <author> Milner, R. </author> <title> A Theory for type polymorphism in programming. </title> <journal> In Journal of Computer and Systems Sciences, </journal> <volume> Vol. 17, </volume> <pages> pages 348-375, </pages> <year> 1978. </year>
Reference-contexts: For every expression that has a type and a control-flow effect in the static semantics, its effect constraint set must have at least one solution, which satisfies the set of type inequalities. The classical types of expressions are reconstructed by a simple type reconstruction algorithm <ref> [Milner78, Tofte87] </ref>. 3.2 Algorithm S Given a type environment E and an expression e assumed priorly decorated with its classical type (we use a straightforward expression annotation mechanism to express this information in the algorithm), the reconstruction algorithm S computes a type t, an effect c and an effect constraint set
Reference: [Plotkin81] <author> Plotkin, G. </author> <title> A structural approach to operational semantics. </title> <type> Technical report DAIMI-FN-19. </type> <institution> Aarhus University, </institution> <year> 1981. </year>
Reference-contexts: Eff (int int) = ; 0 ! t 0 t 0 c 1 1 t 0 [Eff (t 0 t 1 ) 2.4 Semantics The static semantics defines the type and control-flow effect of expressions. It is specified by a set of inference rules <ref> [Plotkin81] </ref>. Given a type environment E, the inference rules associate an expression e with its type t and control-flow information c. We write : E ` e : t; c The crucial rules are the (abs) and (app) rules for lambda abstraction and application.
Reference: [Stansifer88] <author> Stansifer, R. </author> <title> Type Inference with Subtypes. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1988. </year>
Reference-contexts: It is often used to captures aspects of object-oriented programming <ref> [Wand87, Stansifer88] </ref>. Subtyping in effect systems has been previously introduced in explicitly typed languages [Gifford87, Consel94]. There, a subsumption rule similar to the one presented above was used, but since only type checking was performed, its treatment was simpler than ours.
Reference: [Talpin92] <author> Talpin, J. P., and Jouvelot, P. </author> <title> Polymorphic Type, Region and Effect Inference. </title> <journal> In the Journal of Functional Programming, </journal> <volume> volume 2, number 3. </volume> <publisher> Cam-bridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: However, effects, which appear in function types, introduce new constraints on the typability of expressions, i.e., effect checking may force the rejection of programs which would have type-checked if no effects were present. To increase the flexibility of previous effect systems, subef-fecting has been introduced <ref> [Gifford87, Talpin92, Tang92] </ref>. Subeffecting allows expressions to admit larger effects, thus enabling type misatches due to the introduction of effect information to be eliminated. <p> There, a subsumption rule similar to the one presented above was used, but since only type checking was performed, its treatment was simpler than ours. This paper shows that type and effect reconstruction may be performed in an implicitly typed language. Previous implicit effect systems <ref> [Dornic91, Talpin92, Tang92] </ref> have introduced subeffecting, via the subeffecting rule (see Section 2), to increase the flexibility of the static semantics. Subeffecting allows expressions of same classical types to also have the same effect-including types by allowing such effects to be replaced by larger ones if need be.
Reference: [Tang92] <author> Tang, Y. M., and Jouvelot, P. </author> <title> Control-Flow Ef--fects for Closure Analysis. </title> <booktitle> In Proceedings of the 2nd Workshop on Semantics Analysis, </booktitle> <pages> Bigre numbers 81-82, pages 313-321. </pages> <address> Bordeaux, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: However, effects, which appear in function types, introduce new constraints on the typability of expressions, i.e., effect checking may force the rejection of programs which would have type-checked if no effects were present. To increase the flexibility of previous effect systems, subef-fecting has been introduced <ref> [Gifford87, Talpin92, Tang92] </ref>. Subeffecting allows expressions to admit larger effects, thus enabling type misatches due to the introduction of effect information to be eliminated. <p> To motivate this new notion, we show how to use effect-based subtyping within the effect system for control-flow analysis presented in <ref> [Tang92] </ref>, thus improving the accuracy of this control-flow analysis technique. <p> This increases the flexibility of the static semantics by relaxing the constraint on latent effects imposed by the context of an expression. We show that this new approach performs a bet ter analysis than the one previously introduced in <ref> [Tang92] </ref> (see an example in Section 4) which used the less precise subeffecting rule: (subeffecting) : E ` e : t; c 0 E ` e : t; c 3 Reconstruction with Subtyping We present a new reconstruction algorithm that reconstructs types and effects of expressions based on the subtype relation. <p> There, a subsumption rule similar to the one presented above was used, but since only type checking was performed, its treatment was simpler than ours. This paper shows that type and effect reconstruction may be performed in an implicitly typed language. Previous implicit effect systems <ref> [Dornic91, Talpin92, Tang92] </ref> have introduced subeffecting, via the subeffecting rule (see Section 2), to increase the flexibility of the static semantics. Subeffecting allows expressions of same classical types to also have the same effect-including types by allowing such effects to be replaced by larger ones if need be.
Reference: [Tang94-1] <author> Tang, Y. </author> <title> M. </title> <institution> Systemes d'Effet et Interpretation Abstraite pour l'Analyse de Flot de Controle. Doctoral Dissertation. Ecole des Mines de Paris et Universite Paris VI, </institution> <month> March </month> <year> 1994. </year>
Reference-contexts: The proofs are given in appendix. 2 Static Semantics with Subtyping 2.1 Language A simple functional language is enough to present our ideas, although our analysis can be extended to additional language constructs, such as constants, imperative operations, separate compilation (in the vein of <ref> [Tang94-1, Tang94-2] </ref>). In particular, our analysis can also deal with polymorphism as presented in [Tang94-1]. <p> In particular, our analysis can also deal with polymorphism as presented in <ref> [Tang94-1] </ref>. <p> 0 S (E ; (e e 0 )) ) ! t; c; i = S (E; e) in ht; c [ c 0 [ c 00 ; [ 0 [ Eff (t 0 t 00 )i Subeffecting can be easily related to subtyping by noticing that its related reconstruction algorithm <ref> [Tang94-1] </ref> is similar to S, except that is replaced by the more restric tive =, implemented by unification. 3.3 Properties of S The reconstruction algorithm S has the following properties, easily proved by induction : Lemma 1 (Properties of S) For any E , e, if S (E; e) = ht;
Reference: [Tang94-2] <author> Tang, Y. M., and Jouvelot, P. </author> <title> Separate Abstract Interpretation for Control-Flow Analysis. </title> <booktitle> International Symposium on Theoretical Aspects of Computer Software, </booktitle> <publisher> Springer Verlag, LNCS 789. </publisher> <address> Japan, </address> <month> April </month> <year> 1994. </year>
Reference-contexts: The proofs are given in appendix. 2 Static Semantics with Subtyping 2.1 Language A simple functional language is enough to present our ideas, although our analysis can be extended to additional language constructs, such as constants, imperative operations, separate compilation (in the vein of <ref> [Tang94-1, Tang94-2] </ref>). In particular, our analysis can also deal with polymorphism as presented in [Tang94-1].
Reference: [Tofte87] <author> Tofte, M. </author> <title> Operational semantics and polymorphic type inference. </title> <type> PhD Thesis, </type> <institution> University of Edinburgh, </institution> <year> 1987. </year>
Reference-contexts: For every expression that has a type and a control-flow effect in the static semantics, its effect constraint set must have at least one solution, which satisfies the set of type inequalities. The classical types of expressions are reconstructed by a simple type reconstruction algorithm <ref> [Milner78, Tofte87] </ref>. 3.2 Algorithm S Given a type environment E and an expression e assumed priorly decorated with its classical type (we use a straightforward expression annotation mechanism to express this information in the algorithm), the reconstruction algorithm S computes a type t, an effect c and an effect constraint set
Reference: [Wand87] <author> Wand, M. </author> <title> Complete type inference for simple objects. </title> <booktitle> In Proceedings of the 2nd IEEE Symposium on Logic in Computer Science, </booktitle> <year> 1987, </year> <pages> pages 37-44. </pages>
Reference-contexts: It is often used to captures aspects of object-oriented programming <ref> [Wand87, Stansifer88] </ref>. Subtyping in effect systems has been previously introduced in explicitly typed languages [Gifford87, Consel94]. There, a subsumption rule similar to the one presented above was used, but since only type checking was performed, its treatment was simpler than ours.
References-found: 14

