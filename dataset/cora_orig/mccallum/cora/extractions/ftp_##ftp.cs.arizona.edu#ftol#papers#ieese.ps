URL: ftp://ftp.cs.arizona.edu/ftol/papers/ieese.ps
Refering-URL: http://www.cs.arizona.edu/people/hiltunen/
Root-URL: http://www.cs.arizona.edu
Email: hiltunen@cs.arizona.edu  
Title: Configuration Management for Highly-Customizable Software  
Author: Matti A. Hiltunen 
Date: September 30, 1998  
Address: Tucson, AZ 85721, USA  
Affiliation: Department of Computer Science University of Arizona  
Abstract: Customizable operating systems, database systems, and communication subsystems have demonstrated many advantages of customization, including considerable performance improvements. One common approach for constructing customizable software is to implement it as a collection of modules that can be configured in different combinations to provide customized variants of the software. Typically, ad hoc methods are used to determine which modules may be combined. Such methods require intimate knowledge of the modules and their interactions or the configuration will not behave as expected. In this paper, we present a methodology that simplifies the difficult task of constructing correct custom variants of highly-customizable software. The methodology is based on identifying relations between software modules that dictate which combinations are correct. We also introduce a configuration support tool that, based on these relations, allows only correct configurations to be created.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> C. Pu, H. Massalin, and J. Ioannidis. </author> <title> The Synthesis kernel. </title> <journal> Computing Systems, </journal> <volume> 1(1) </volume> <pages> 11-32, </pages> <year> 1988. </year>
Reference-contexts: 1 Introduction The recent research on customizable software components such as operating systems <ref> [1, 2, 3, 4] </ref>, file systems [5, 6, 7], database systems [8, 9, 10], and communication subsystems [11, 12, 13, 14, 15] has demonstrated many advantages of customization.
Reference: [2] <author> B. Bershad, S. Savage, P. Pardyak, E. Sirer, M. Fiuczynski, D. Becker, C. Chambers, and S. Eggers. </author> <title> Extensibility, safety, and performance in the SPIN operating system. </title> <booktitle> In Proceedings of the 15th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 267-284, </pages> <address> Copper Mountain Resort, CO, </address> <month> Dec </month> <year> 1995. </year>
Reference-contexts: 1 Introduction The recent research on customizable software components such as operating systems <ref> [1, 2, 3, 4] </ref>, file systems [5, 6, 7], database systems [8, 9, 10], and communication subsystems [11, 12, 13, 14, 15] has demonstrated many advantages of customization.
Reference: [3] <author> D. Engler, M. Kaashoek, and J. O'Toole. Exokernel: </author> <title> An operating system architecture for application-level resource management. </title> <booktitle> In Proceedings of the 15th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 251-266, </pages> <address> Copper Mountain Resort, CO, </address> <month> Dec </month> <year> 1995. </year>
Reference-contexts: 1 Introduction The recent research on customizable software components such as operating systems <ref> [1, 2, 3, 4] </ref>, file systems [5, 6, 7], database systems [8, 9, 10], and communication subsystems [11, 12, 13, 14, 15] has demonstrated many advantages of customization.
Reference: [4] <author> A. Veitch and N Hutchinson. </author> <title> Dynamic service reconfiguration and migration in the Kea kernel. </title> <booktitle> In Proceedings of the 4rd International Conference on Configurable Distributed Systems, </booktitle> <pages> pages 156-163, </pages> <address> Annapolis, MD, </address> <month> May </month> <year> 1998. </year>
Reference-contexts: 1 Introduction The recent research on customizable software components such as operating systems <ref> [1, 2, 3, 4] </ref>, file systems [5, 6, 7], database systems [8, 9, 10], and communication subsystems [11, 12, 13, 14, 15] has demonstrated many advantages of customization.
Reference: [5] <author> J. Heidemann and G. Popek. </author> <title> Performance of cache coherence in stackable filing. </title> <booktitle> In Proceedings of the 15th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 127-142, </pages> <address> Copper Mountain Resort, CO, </address> <month> Dec </month> <year> 1995. </year>
Reference-contexts: 1 Introduction The recent research on customizable software components such as operating systems [1, 2, 3, 4], file systems <ref> [5, 6, 7] </ref>, database systems [8, 9, 10], and communication subsystems [11, 12, 13, 14, 15] has demonstrated many advantages of customization. <p> Each module typically interacts only with modules immediately above and below it in the hierarchy. Recent examples of this approach are the x-kernel [11], Horus [14], the Genesis database system [8], and stackable file systems <ref> [5] </ref>. Some of the approaches require that all modules export an identical interface, e.g., x-kernel, while others allow layer-specific interfaces, e.g., Genesis. In the systems where all modules export the same interface, any stack of modules would be syntactically valid.
Reference: [6] <author> Y. Khalidi and M. Nelson. </author> <title> Extensible file systems in Spring. </title> <booktitle> In Proceedings of the 14th Symposium on Operating Systems Principles, </booktitle> <address> Asheville, NC, </address> <month> Dec </month> <year> 1993. </year>
Reference-contexts: 1 Introduction The recent research on customizable software components such as operating systems [1, 2, 3, 4], file systems <ref> [5, 6, 7] </ref>, database systems [8, 9, 10], and communication subsystems [11, 12, 13, 14, 15] has demonstrated many advantages of customization.
Reference: [7] <author> O. Krieger and M. Stumm. </author> <title> HFS: A performance-oriented flexible file system based on building block composition. </title> <journal> ACM Transactions on Computer System, </journal> <volume> 15(3) </volume> <pages> 286-321, </pages> <month> Aug </month> <year> 1997. </year>
Reference-contexts: 1 Introduction The recent research on customizable software components such as operating systems [1, 2, 3, 4], file systems <ref> [5, 6, 7] </ref>, database systems [8, 9, 10], and communication subsystems [11, 12, 13, 14, 15] has demonstrated many advantages of customization.
Reference: [8] <author> D. Batory, J. Barnett, J. Garza, K. Smith, K. Tsukuda, B. Twichell, and T. Wise. </author> <title> GENESIS: An extensible database management system. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-14(11):1711-1729, </volume> <month> Nov </month> <year> 1988. </year>
Reference-contexts: 1 Introduction The recent research on customizable software components such as operating systems [1, 2, 3, 4], file systems [5, 6, 7], database systems <ref> [8, 9, 10] </ref>, and communication subsystems [11, 12, 13, 14, 15] has demonstrated many advantages of customization. For example, it allows the implementation of a software component to be optimized for the requirements of its users as well as for the characteristics of the execution environment. <p> Each module typically interacts only with modules immediately above and below it in the hierarchy. Recent examples of this approach are the x-kernel [11], Horus [14], the Genesis database system <ref> [8] </ref>, and stackable file systems [5]. Some of the approaches require that all modules export an identical interface, e.g., x-kernel, while others allow layer-specific interfaces, e.g., Genesis. In the systems where all modules export the same interface, any stack of modules would be syntactically valid.
Reference: [9] <author> M. Stonebraker and L. Rowe. </author> <title> The design of Postgres. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 340-355, </pages> <year> 1986. </year>
Reference-contexts: 1 Introduction The recent research on customizable software components such as operating systems [1, 2, 3, 4], file systems [5, 6, 7], database systems <ref> [8, 9, 10] </ref>, and communication subsystems [11, 12, 13, 14, 15] has demonstrated many advantages of customization. For example, it allows the implementation of a software component to be optimized for the requirements of its users as well as for the characteristics of the execution environment.
Reference: [10] <author> P. Schwarz, W. Chang, J. Freytag, G. Lohman, J. McPherson, C. Mohan, and H. Pirahesh. </author> <title> Extensibility in the Starburst database system. </title> <booktitle> In Proceedings of the International Workshop on Object-Oriented Database Systems, </booktitle> <pages> pages 85-93, </pages> <address> Asilomar, CA, </address> <month> Sep </month> <year> 1986. </year>
Reference-contexts: 1 Introduction The recent research on customizable software components such as operating systems [1, 2, 3, 4], file systems [5, 6, 7], database systems <ref> [8, 9, 10] </ref>, and communication subsystems [11, 12, 13, 14, 15] has demonstrated many advantages of customization. For example, it allows the implementation of a software component to be optimized for the requirements of its users as well as for the characteristics of the execution environment.
Reference: [11] <author> N. Hutchinson and L. Peterson. </author> <title> The x-kernel: An architecture for implementing network protocols. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(1) </volume> <pages> 64-76, </pages> <month> Jan </month> <year> 1991. </year>
Reference-contexts: 1 Introduction The recent research on customizable software components such as operating systems [1, 2, 3, 4], file systems [5, 6, 7], database systems [8, 9, 10], and communication subsystems <ref> [11, 12, 13, 14, 15] </ref> has demonstrated many advantages of customization. For example, it allows the implementation of a software component to be optimized for the requirements of its users as well as for the characteristics of the execution environment. <p> Services can typically be combined using traditional hierarchical methods, such as supported by the x-kernel <ref> [11] </ref>, but the traditional methods are often inadequate for the more closely interrelated modules that implement service properties. A detailed comparison of the micro-protocol approach to other approaches is beyond the scope of this paper but details can be found in [15]. <p> Each module typically interacts only with modules immediately above and below it in the hierarchy. Recent examples of this approach are the x-kernel <ref> [11] </ref>, Horus [14], the Genesis database system [8], and stackable file systems [5]. Some of the approaches require that all modules export an identical interface, e.g., x-kernel, while others allow layer-specific interfaces, e.g., Genesis.
Reference: [12] <author> D. Schmidt, D. Box, and T. Suda. </author> <title> ADAPTIVE: A dynamically assembled protocol transformation, integration, and evaluation environment. </title> <journal> Concurrency: Practice and Experience, </journal> <volume> 5(4) </volume> <pages> 269-286, </pages> <month> Jun </month> <year> 1993. </year>
Reference-contexts: 1 Introduction The recent research on customizable software components such as operating systems [1, 2, 3, 4], file systems [5, 6, 7], database systems [8, 9, 10], and communication subsystems <ref> [11, 12, 13, 14, 15] </ref> has demonstrated many advantages of customization. For example, it allows the implementation of a software component to be optimized for the requirements of its users as well as for the characteristics of the execution environment. <p> Examples of this approach are Adaptive <ref> [12] </ref> and a framework for group communication systems presented in [22]. In contrast with the hierarchical approach, modules in this approach are typically typed and thus can only be used in one specific slot. However, there may be other relations between modules that typing of modules does not capture.
Reference: [13] <author> S. Mishra, L. Peterson, and R. Schlichting. </author> <title> Consul: A communication substrate for fault-tolerant distributed programs. </title> <journal> Distributed System Engineering, </journal> <volume> 1 </volume> <pages> 87-103, </pages> <month> Dec </month> <year> 1993. </year>
Reference-contexts: 1 Introduction The recent research on customizable software components such as operating systems [1, 2, 3, 4], file systems [5, 6, 7], database systems [8, 9, 10], and communication subsystems <ref> [11, 12, 13, 14, 15] </ref> has demonstrated many advantages of customization. For example, it allows the implementation of a software component to be optimized for the requirements of its users as well as for the characteristics of the execution environment.
Reference: [14] <author> R. van Renesse, K. Birman, and S Maffeis. Horus, </author> <title> a flexible group communication system. </title> <journal> Communications of the ACM, </journal> <volume> 39(4) </volume> <pages> 76-83, </pages> <month> Apr </month> <year> 1996. </year>
Reference-contexts: 1 Introduction The recent research on customizable software components such as operating systems [1, 2, 3, 4], file systems [5, 6, 7], database systems [8, 9, 10], and communication subsystems <ref> [11, 12, 13, 14, 15] </ref> has demonstrated many advantages of customization. For example, it allows the implementation of a software component to be optimized for the requirements of its users as well as for the characteristics of the execution environment. <p> Each module typically interacts only with modules immediately above and below it in the hierarchy. Recent examples of this approach are the x-kernel [11], Horus <ref> [14] </ref>, the Genesis database system [8], and stackable file systems [5]. Some of the approaches require that all modules export an identical interface, e.g., x-kernel, while others allow layer-specific interfaces, e.g., Genesis. In the systems where all modules export the same interface, any stack of modules would be syntactically valid.
Reference: [15] <author> N. Bhatti, M. Hiltunen, R. Schlichting, and W. Chiu. Coyote: </author> <title> A system for constructing fine-grain configurable communication services. </title> <booktitle> ACM Transaction on Computer Systems, </booktitle> <month> Nov </month> <year> 1998. </year>
Reference-contexts: 1 Introduction The recent research on customizable software components such as operating systems [1, 2, 3, 4], file systems [5, 6, 7], database systems [8, 9, 10], and communication subsystems <ref> [11, 12, 13, 14, 15] </ref> has demonstrated many advantages of customization. For example, it allows the implementation of a software component to be optimized for the requirements of its users as well as for the characteristics of the execution environment. <p> A detailed comparison of the micro-protocol approach to other approaches is beyond the scope of this paper but details can be found in <ref> [15] </ref>. In our approach, each service is implemented as a composite protocol that is constructed of software modules referred to as micro-protocols. Micro-protocols in a composite protocol interact using flexible event mechanisms as well as shared data. <p> Despite the increased number of dependencies and conflicts, this design still allows 132 semantically different correct configurations even without considering all the potential different collation and acceptance policies. Performance results of a number of the different configurations are presented in <ref> [15] </ref>. Given this set of micro-protocols, we can configure RPC service variants that realize the same set of properties as existing RPC services.
Reference: [16] <author> M. Hiltunen. </author> <title> Configurable Distributed Fault-Tolerant Services. </title> <type> PhD thesis, </type> <institution> Dept of Computer Science, University of Arizona, </institution> <address> Tucson, AZ, </address> <month> Jul </month> <year> 1996. </year>
Reference-contexts: The possibilities include returning any one reply, all replies, or the result of a function that maps all replies into one result. Further details on the properties of group RPC service, as well as of other services, can be found in <ref> [16] </ref>. 2.2 Relations between properties It turns out that any combination of abstract service properties is not feasible because all properties are not independentfor example, there may be two properties p i and p j such that there is no way to implement the service so that p i is guaranteed <p> Execution of event handlers is atomic with respect to concurrency, i.e., each handler is executed to completion without interruption. Further details on the model, event-handling operations, and other aspects of the approach can be found in <ref> [16, 17] </ref>. 3.2 Design goals The implementation of a configurable service has two major goals: minimizing execution overhead and maximizing degree of configurability. The execution overhead is the performance difference between a monolithic implementation of a service and a configurable implementation that provides equivalent guarantees. <p> Only one micro-protocol from each choice node may be chosen and no micro-protocol m 1 such that micro-protocol m 2 is in the configuration and m 2 includes m 1 may be chosen. A configuration graph of a highly-configurable group RPC service described in <ref> [16] </ref> is presented in figure 3. The goal of the group RPC implementation was to be highly configurable but not necessarily reach the theoretical maximum degree of configurability, and thus, the configuration graph has some additional configuration constraints compared to the corresponding dependency graph in figure 1.
Reference: [17] <author> N. Bhatti. </author> <title> A System for Constructing Configurable High-Level Protocols. </title> <type> PhD thesis, </type> <institution> Dept of Computer Science, University of Arizona, </institution> <address> Tucson, AZ, </address> <month> Nov </month> <year> 1996. </year>
Reference-contexts: Execution of event handlers is atomic with respect to concurrency, i.e., each handler is executed to completion without interruption. Further details on the model, event-handling operations, and other aspects of the approach can be found in <ref> [16, 17] </ref>. 3.2 Design goals The implementation of a configurable service has two major goals: minimizing execution overhead and maximizing degree of configurability. The execution overhead is the performance difference between a monolithic implementation of a service and a configurable implementation that provides equivalent guarantees.
Reference: [18] <author> A. Birrell and B. Nelson. </author> <title> Implementing remote procedure calls. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(1) </volume> <pages> 39-59, </pages> <month> Feb </month> <year> 1984. </year>
Reference-contexts: Performance results of a number of the different configurations are presented in [15]. Given this set of micro-protocols, we can configure RPC service variants that realize the same set of properties as existing RPC services. For example, the basic RPC service described in <ref> [18] </ref> corresponds to a service configured with RPCMain, Blocking, Acceptance (1), Collation with a function that returns the first response, ReliableCom-munication, and UniqueExecution. Rajdoot [19] corresponds to the same set, plus BoundedTermination and TerminateOrphans.
Reference: [19] <author> F. Panzieri and S. Shrivastava. Rajdoot: </author> <title> A remote procedure call mechanism supporting orphan detection and killing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-14(1):30-37, </volume> <month> Jan </month> <year> 1988. </year>
Reference-contexts: For example, the basic RPC service described in [18] corresponds to a service configured with RPCMain, Blocking, Acceptance (1), Collation with a function that returns the first response, ReliableCom-munication, and UniqueExecution. Rajdoot <ref> [19] </ref> corresponds to the same set, plus BoundedTermination and TerminateOrphans.
Reference: [20] <author> E. Cooper. </author> <title> Replicated distributed programs. </title> <booktitle> In Proceedings of the 10th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 63-78, </pages> <address> Orcas Island, WA, </address> <year> 1985. </year>
Reference-contexts: Rajdoot [19] corresponds to the same set, plus BoundedTermination and TerminateOrphans. Among group RPC services, the one-to-many RPC described in <ref> [20] </ref> corresponds to the set RPCMain, Blocking, Acceptance (N), Collation with a function consisting of identity and comparison to detect inconsistencies at the server processes, ReliableCommunication, UniqueExecution, and TotalOrder. 4 Configuration support tool A configuration graph could be used manually to create correct configurations, but the configuration task can be simplified
Reference: [21] <author> R. van Renesse, K. Birman, R. Friedman, M. Hayden, and D. Karr. </author> <title> A framework for protocol composition in Horus. </title> <booktitle> In Proceedings of the 14th ACM Principles of Distributed Computing Conference, </booktitle> <pages> pages 80-89, </pages> <month> Aug </month> <year> 1995. </year>
Reference-contexts: In the systems where all modules export the same interface, any stack of modules would be syntactically valid. However, in practice, semantic constraints between modules dictate that only certain combinations are correct. In particular, some modules require certain other modules underneath them, i.e., depend on the other modules <ref> [21] </ref>. Furthermore, often there is a choice of protocols, or modules in general, for a certain layer of the hierarchy. This translates naturally to conflict since only one of these protocols can typically be chosen in any configuration. Thus, both dependency and conflict relations typically appear in such systems.
Reference: [22] <author> R. Golding. </author> <title> Weak-Consistency Group Communication and Membership. </title> <type> PhD thesis, </type> <institution> Dept of Computer Science, University of California, </institution> <address> Santa Cruz, Santa Cruz, CA, </address> <month> Dec </month> <year> 1992. </year>
Reference-contexts: Examples of this approach are Adaptive [12] and a framework for group communication systems presented in <ref> [22] </ref>. In contrast with the hierarchical approach, modules in this approach are typically typed and thus can only be used in one specific slot. However, there may be other relations between modules that typing of modules does not capture.
Reference: [23] <author> S. Shrivastava, G. Dixon, and G. Parrington. </author> <title> An overview of the Arjuna distributed programming system. </title> <journal> IEEE Software, </journal> <volume> 8(1) </volume> <pages> 66-73, </pages> <month> Jan </month> <year> 1991. </year>
Reference-contexts: A predefined class hierarchy specifies the available components, which can be manipulated by invoking the object methods. New classes can be defined as derived classes of existing ones. Examples of this approach are Arjuna <ref> [23] </ref> and a configurable mixed-media file system [24]. The subclass relation between modules is well-defined in the class hierarchy based approach. This relation maps naturally to inclusion: a subclass augments its base class and by definition includes the base class.
Reference: [24] <author> S. Maffeis. </author> <title> Design and implementation of a configurable mixed-media file system. </title> <journal> Operating Systems Review, </journal> <volume> 28(4) </volume> <pages> 4-10, </pages> <month> Oct </month> <year> 1994. </year>
Reference-contexts: A predefined class hierarchy specifies the available components, which can be manipulated by invoking the object methods. New classes can be defined as derived classes of existing ones. Examples of this approach are Arjuna [23] and a configurable mixed-media file system <ref> [24] </ref>. The subclass relation between modules is well-defined in the class hierarchy based approach. This relation maps naturally to inclusion: a subclass augments its base class and by definition includes the base class.
Reference: [25] <author> G. Agha. </author> <title> Concurrent object-oriented programming. </title> <journal> Communications of the ACM, </journal> <volume> 33(9) </volume> <pages> 125-141, </pages> <month> Sep </month> <year> 1990. </year>
Reference-contexts: Examples of this approach are the Actor model <ref> [25] </ref>, where a computation is constructed of actor objects that communicate using point-to-point messages, and the model for parallel execution of communication protocols presented in [26]. All the four relations between modules may be present in systems designed using this approach.
Reference: [26] <author> K. Schwan, T. Bihari, and B. Blake. </author> <title> Adaptive, reliable software for distributed and parallel real-time systems. </title> <booktitle> In Proceedings of the 6th IEEE Symposium on Reliability in Distributed Software and Database Systems, </booktitle> <pages> pages 32-42, </pages> <month> Mar </month> <year> 1987. </year>
Reference-contexts: Examples of this approach are the Actor model [25], where a computation is constructed of actor objects that communicate using point-to-point messages, and the model for parallel execution of communication protocols presented in <ref> [26] </ref>. All the four relations between modules may be present in systems designed using this approach. If object A sends a message to object B, there may be a dependency between them.
Reference: [27] <author> E. Bersoff, V. Henderson, and S. Siegel. </author> <title> Software Configuration Management. </title> <publisher> Prentice-Hall, </publisher> <year> 1980. </year>
Reference-contexts: SCM involves managing the development of the components from which a complex system is built and integrating these components to form that system. SCM has been extensively studied <ref> [27] </ref>, standards have been published (IEEE Std 828-1990, NASA D-GL-11, DoD MIL-STD-973), and a number of commercial tools have been developed. The main thrust of SCM is managing the different versions of the software modules in a complex system.
Reference: [28] <author> W. Gentleman, S. MacKay, D. Stewart, and M. Wein. </author> <title> Commercial realtime software needs different configuration management. </title> <booktitle> In Proceedings of the Second International Workshop on Software Configuration Management, </booktitle> <pages> pages 152-161, </pages> <address> Princeton, NJ, </address> <month> Oct </month> <year> 1989. </year>
Reference-contexts: There has been some work on extending SCM to provide customized features for different customers. For example, the Harmony project <ref> [28] </ref> supports configuration-specific inclusion files that list the source files to be included in a given configuration and thus allows different configurations to be created. However, even this tool does not identify or support semantic relations between modules.
Reference: [29] <author> J. Bishop and R. Faria. </author> <title> Connectors in configuration programming languages: Are they necessary. </title> <booktitle> In Proceedings of the 3rd International Conference on Configurable Distributed Systems, </booktitle> <pages> pages 11-18, </pages> <address> Annapolis, MD, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: However, even this tool does not identify or support semantic relations between modules. Another area of configuration management is configuration programming, defined as the process whereby components written in any conventional programming language can be bound together to form a dynamic system <ref> [29] </ref>. Examples of this work are Darwin [30], Polylith [31], and UNICON [32].
Reference: [30] <author> J. Magee, N. Dulay, and J Kramer. Regis: </author> <title> A constructive development environment for distributed programs. </title> <journal> Distributed Systems Engineering Journal, </journal> <volume> 1(5) </volume> <pages> 304-312, </pages> <month> Sep </month> <year> 1994. </year>
Reference-contexts: However, even this tool does not identify or support semantic relations between modules. Another area of configuration management is configuration programming, defined as the process whereby components written in any conventional programming language can be bound together to form a dynamic system [29]. Examples of this work are Darwin <ref> [30] </ref>, Polylith [31], and UNICON [32]. In contrast to our work, the primary goal of these systems is to make it possible to combine existing software components into a larger system primarily by linking the inputs and outputs of the components using pipes, RPC, or shared data structures.
Reference: [31] <author> J. Purtilo. </author> <title> The Polylith software bus. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(4) </volume> <pages> 151-174, </pages> <month> Jan </month> <year> 1994. </year>
Reference-contexts: Another area of configuration management is configuration programming, defined as the process whereby components written in any conventional programming language can be bound together to form a dynamic system [29]. Examples of this work are Darwin [30], Polylith <ref> [31] </ref>, and UNICON [32]. In contrast to our work, the primary goal of these systems is to make it possible to combine existing software components into a larger system primarily by linking the inputs and outputs of the components using pipes, RPC, or shared data structures.
Reference: [32] <author> M. Shaw, R. DeLine, D. Klein, T. Ross, D. Young, and G. Zelesnik. </author> <title> Abstractions for software architecture and tools to support them. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(4) </volume> <pages> 314-335, </pages> <month> Apr </month> <year> 1995. </year>
Reference-contexts: Another area of configuration management is configuration programming, defined as the process whereby components written in any conventional programming language can be bound together to form a dynamic system [29]. Examples of this work are Darwin [30], Polylith [31], and UNICON <ref> [32] </ref>. In contrast to our work, the primary goal of these systems is to make it possible to combine existing software components into a larger system primarily by linking the inputs and outputs of the components using pipes, RPC, or shared data structures.
Reference: [33] <author> D. Perry. </author> <title> Software interconnection models. </title> <booktitle> In Proceedings of the 9th International Conference on Software Engineering, </booktitle> <pages> pages 61-69, </pages> <year> 1987. </year>
Reference-contexts: Furthermore, our approach could be used in conjunction with the configuration programming languages to capture the semantic relations between the components. Finally, there is work on configuration management aiming at determining if a configuration is consistent based on syntactic and semantic compatibility of interacting modules. For example, <ref> [33] </ref> uses predicates to describe the acceptable inputs to a module (preconditions) as well as its outputs (postconditions). A configuration is consistent if for every communicating pair of modules, the postconditions of the output satisfy the preconditions of the input.
Reference: [34] <author> P. Feiler and J. Li. </author> <title> Consistency in dynamic reconfiguration. </title> <booktitle> In Proceedings of the 4th International Conference on Configurable Distributed Systems, </booktitle> <pages> pages 189-196, </pages> <address> Annapolis, MD, </address> <month> May </month> <year> 1998. </year>
Reference-contexts: A configuration is consistent if for every communicating pair of modules, the postconditions of the output satisfy the preconditions of the input. The approach has been extended to handle dynamic system configuration changes as a result of new modules being introduced <ref> [34] </ref>. This is somewhat orthogonal to our work since we assume the modules of a configurable software component are designed and implemented so that they operate correctly together (independence or dependency) or they must not be used together (conflict or inclusion).
Reference: [35] <author> M. Hiltunen. </author> <title> Configuration management for highly-customizable services. </title> <booktitle> In Proceedings of the 4th International Conference on Configurable Distributed Systems, </booktitle> <pages> pages 197-205, </pages> <address> Annapolis, MD, </address> <month> May </month> <year> 1998. </year>
Reference-contexts: Acknowledgments This work is based on the author's dissertation work done under the supervision of Prof. Richard Schlichting whose guidance has been invaluable. Sameer Verkhedkar designed and implemented the configuration support tool. An earlier version of this paper appeared in <ref> [35] </ref>.
References-found: 35

