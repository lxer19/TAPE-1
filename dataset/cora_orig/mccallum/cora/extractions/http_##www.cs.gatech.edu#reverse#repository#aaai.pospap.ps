URL: http://www.cs.gatech.edu/reverse/repository/aaai.pospap.ps
Refering-URL: http://www.cs.gatech.edu/reverse/repos.html
Root-URL: 
Email: spencer@cc.gatech.edu  
Title: PROGRAM COMPREHENSION FOR REVERSE ENGINEERING must bridge different worlds. Of particular importance are bridges over
Author: Spencer Rugaber 
Keyword: Definition Difficulties  
Note: INTRODUCTION: REVERSE ENGINEERING  Reverse engineering is difficult. It is difficult because it  
Address: Atlanta, Georgia 30332-0280  
Affiliation: College of Computing Georgia Institute of Technology  
Abstract: This paper motivates and describes a research program in the area of reverse engineering being conducted at the Georgia Institute of Technology. Reverse engineering is an emerging interest area within the software engineering field. Software engineering itself is concerned with improving the productivity of the software development process and the quality of the systems it produces. However, as currently practiced, the majority of the software development effort is spent on maintaining existing systems rather than developing new ones. Estimates of the proportion of resources and time devoted to maintenance range from 50% to 80%. [ Boehm, 1981 ] The greatest part of the software maintenance process is devoted to understanding the system being maintained. Fjeldstad and Hamlen report that 47% and 62% of time spent on actual enhancement and correction tasks, respectively, are devoted to comprehension activities. These involve reading the documentation, scanning the source code, and understanding the changes to be made. [ Fjeldstad and Hamlen, 1979 ] The implications are that if we want to improve software development, we should look at maintenance, and if we want to improve maintenance, we should facilitate the process of comprehending existing programs. Reverse engineering provides a direct attack on the program comprehension problem. The process of understanding a program involves reverse engineering the source code. Chikofsky and Cross [ Chikofsky and Cross II, 1990 ] give the following definition. "Reverse enginering is the process of analyzing a subject system to identify the system's components and their interrelationships and create representations of the system in another form or at a higher level of abstraction." The purpose of reverse engineering is to understand a software system in order to facilitate enhancement, correction, documentation, redesign, or reprogramming in a different programming language. There are two approaches to understanding a program: bottom-up, starting with the source code and generating a description; and top-down, formulating hypotheses and confirming them by examining the program. An example of the former is the approach taken by Soloway and Ehrlich. They propose a bottom-up model of analysis based on the recognition of plans in the source code. [ Soloway and Ehrlich, 1984 ] The plans are organized into subgoals and then goals. Experiments have been conducted that support this approach, and Letovsky has built an analysis tool that implements part of the analysis process. [ Letovsky, 1988 ] Other examples of the bottom-up approach are 
Abstract-found: 1
Intro-found: 1
Reference: <author> Basili, V. R. and Mills, H. D. </author> <year> 1982. </year> <title> Understanding and documenting programs. </title> <journal> IEEE Transactions on Software Engineering SE-8(3):270-283. </journal>
Reference: <author> Boehm, Barry W. </author> <year> 1981. </year> <title> Software Engineering Economics. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ. Brooks, </address> <month> Ruven </month> <year> 1983. </year> <title> Towards a theory of the comprehension of computer programs. </title> <journal> International Journal of Man-Machine Studies 18 </journal> <pages> 543-554. </pages>
Reference: <author> Chikofsky, Elliot J. and Cross II, James H. </author> <year> 1990. </year> <title> Reverse engineering and design recovery: A taxonomy. </title> <booktitle> IEEE Software 7(1) </booktitle> <pages> 13-17. </pages>
Reference: <author> Conklin, J. </author> <year> 1987. </year> <title> Hypertext: An introduction and survey. </title> <booktitle> IEEE Computer 20(9) </booktitle> <pages> 17-41. </pages>
Reference: <author> Feather, Martin S. </author> <year> 1987. </year> <title> A survey and classification of some program transformation approaches and techniques. </title> <editor> In Meertens, L. G. L. T., editor 1987, </editor> <title> Program Specification and Transformation. </title> <publisher> Elsevier North Hol-land. </publisher> <pages> 165-195. </pages>
Reference: <author> Fjeldstad, R. K. and Hamlen, W. T. </author> <year> 1979. </year> <title> Application program maintenance study: Report to our respondents. </title> <booktitle> In Proceedings GUIDE 48, Philadelphia, PA. Also in Tutorial on Software Maintenance, </booktitle> <publisher> G. </publisher>
Reference: <editor> Parikh and N. Zvegintozov, editors, </editor> <publisher> IEEE Computer Society, IEEE Order No. EM453. </publisher>
Reference: <author> Kamper, Kit and Rugaber, </author> <title> Spencer 1990. A reverse engineering methodology for data processing applications. </title> <type> Technical Report GIT-SERC-90/02, </type> <institution> Software Engineering Research Center, Georgia Institute of Technology. </institution>
Reference: <author> Letovsky, </author> <title> Stanley 1988. Plan Analysis of Programs. </title> <type> Ph.D. Dissertation, </type> <institution> Yale University. </institution>
Reference: <author> Partsch, H. and Steinbruggen, R. </author> <year> 1983. </year> <title> Program transformation systems. </title> <journal> ACM Computing Surveys 15(3) </journal> <pages> 189-226. </pages>
Reference: <author> Rich, Charles and Wills, Linda M. </author> <year> 1990. </year> <title> Recognizing a program's design: A graph-parsing approach. </title> <booktitle> IEEE Software 7(1) </booktitle> <pages> 82-89. </pages>
Reference: <author> Rugaber, Spencer; Ornburn, Stephen B.; and Jr., Richard J. </author> <title> LeBlanc 1990. Recognizing design decisions in programs. </title> <booktitle> IEEE Software 7(1) </booktitle> <pages> 46-54. </pages>
Reference: <author> Soloway, E. and Ehrlich, K. </author> <year> 1984. </year> <title> Empirical studies of programming knowledge. </title> <journal> IEEE Transactions on Software Engineering SE-10(5):595-609. </journal>
References-found: 13

