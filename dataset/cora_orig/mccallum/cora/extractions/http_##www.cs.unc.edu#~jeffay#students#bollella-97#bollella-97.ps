URL: http://www.cs.unc.edu/~jeffay/students/bollella-97/bollella-97.ps
Refering-URL: http://www.cs.unc.edu/~jeffay/dissertations.html
Root-URL: http://www.cs.unc.edu
Title: Slotted Priorities: Supporting Real-Time Computing Within General-Purpose Operating Systems  
Author: by Gregory Bollella Kevin Jeffay F. Donelson Smith Peter Calingaert James P. Gray 
Degree: A dissertation submitted to the faculty of the  in partial fulfillment of the requirements for the degree of Doctor of Philosophy in the  Approved by:  
Date: 1997  
Address: Chapel Hill  
Affiliation: University of North Carolina at Chapel Hill  Department of Computer Science.  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Anonymous. </author> <title> Atlas, a new concept in large computer design. </title> <journal> Commun. </journal> <note> ACM 3 (June 1960), 367-368. </note>
Reference-contexts: This principle simply states that it is highly likely that the next logical instruction to be executed in a task will be close, in memory location, to the previously executed instruction. The principle of locality allows the efficient implementation of paging. Paging was first implemented on the ATLAS <ref> [1] </ref>. In a paged system memory pages no longer actively in use are moved from memory to backing store, providing physical memory free for other tasks. From paging came the idea of virtual memory, analyzed by Denning [7].
Reference: [2] <author> Baker, T. P., and Shaw, A. </author> <title> The cyclic executive model and ada. </title> <booktitle> The Journal of Real-Time Systems 1, </booktitle> <month> 1 (June </month> <year> 1989), </year> <pages> 7-25. </pages>
Reference-contexts: The schedule is so organized that all tasks meet their deadlines. For a set of n tasks the constraints on the length m of a minor cycle are <ref> [2] </ref>: * m &lt; d i for i = 1 to n. * m must be greater than the the longest task or subtask. * m must divide the major cycle M . * m + (m gcd (m; p i )) d i for i = 1 to n.
Reference: [3] <author> Brooks, F. P. </author> <title> Personal communication. Advanced Architecture Class, </title> <year> 1990. </year>
Reference-contexts: Early computer system designs used the processor to interact directly with attached devices, resulting in an interaction paradigm known as programmed I/O. Then, and now, attached devices were three orders of magnitude slower than the processor <ref> [3] </ref>. Interrupts, first developed in the IBM Stretch [3], relieved the processor from continuous interaction with attached devices. <p> Early computer system designs used the processor to interact directly with attached devices, resulting in an interaction paradigm known as programmed I/O. Then, and now, attached devices were three orders of magnitude slower than the processor <ref> [3] </ref>. Interrupts, first developed in the IBM Stretch [3], relieved the processor from continuous interaction with attached devices. An interrupt is a signal from an attached device that causes the processor to switch from its current task to a sequence of instructions (the interrupt handler or device driver) that interacts with the signalling device.
Reference: [4] <author> Carpenter, B., Roman, M., Vasilatos, N., and Zimmerman, M. </author> <title> The rtx real-time subsystem for windows nt. </title> <booktitle> In The USENIX Windows NO Workshop Proceedings (Aug. </booktitle> <year> 1997), </year> <pages> pp. 33-38. </pages>
Reference-contexts: The device drivers interact with a set of virtual device drivers associated with the MVDM, which are shared among the instances of DOS. VentuCom currently advertises a commercial product, RTX 4.1 <ref> [4] </ref>, that adds support for a particular type of real-time computation to a general-purpose operating system. The product is described as a real-time extension to Windows NT. Windows NT provides a hardware abstraction layer (HAL) which virtualizes hardware resources.
Reference: [5] <author> Deitel, H., and Kogan, M. </author> <title> The Design of OS/2. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1991. </year>
Reference-contexts: Almost all programs written DOS or Windows can run in the simulated environment without modification. OS/2 provides this environment by creating a virtual DOS environment (VDM) for each DOS program that is executed, using the mul 46 tiple virtual DOS machine (MVDM) technology <ref> [5] </ref>. The MVDM is called a kernel and is scheduled by OS/2 as a single OS/2 task; hence, it is subject to all of the unpredictability of an OS/2 task.
Reference: [6] <author> Denning, P. J. </author> <title> The working set model for program behavior. </title> <journal> Commun. ACM 11, </journal> <month> 5 (May </month> <year> 1968), </year> <pages> 323-333. </pages>
Reference-contexts: However, not being able to predict the completion time of a task means that a system cannot guarantee completion times as required by periodic real-time tasks. Another design milestone in the development of operating system theory was the principle of locality first proposed by Denning <ref> [6] </ref>. This principle simply states that it is highly likely that the next logical instruction to be executed in a task will be close, in memory location, to the previously executed instruction. The principle of locality allows the efficient implementation of paging. Paging was first implemented on the ATLAS [1].
Reference: [7] <author> Denning, P. J. </author> <title> Virtual memory. </title> <journal> ACM Comput. Surv. </journal> <volume> 2, </volume> <month> 3 (Sept. </month> <year> 1970), </year> <pages> 153-189. </pages>
Reference-contexts: Paging was first implemented on the ATLAS [1]. In a paged system memory pages no longer actively in use are moved from memory to backing store, providing physical memory free for other tasks. From paging came the idea of virtual memory, analyzed by Denning <ref> [7] </ref>. Virtual memory extends the logical address space available to tasks by multiplexing the use of physical memory.
Reference: [8] <author> Engler, D. R., Kaashoek, M. F., and Jr., J. O. Exokernel: </author> <title> An operating system architecture for application-level resource management. </title> <booktitle> In Proceedings of the Fifteenth Symposium on Operating Systems Principles (Dec. </booktitle> <year> 1995). </year>
Reference-contexts: enable or disable interrupts should already be function or procedure calls, which would allow the dynamic binding of new handlers. 2.4.2 ExoKernel The ExoKernel proposes an operating system architecture that exports the capabilities of the physical hardware and provides only protection; the goal here is to separate protection from management <ref> [8] </ref>. For example, the ExoKernel protects (prevents access by unauthorized processes to) a component such as a frame buffer, but does not attempt to manage it, i.e., it does not maintain a free list, etc. <p> Results of experiments show that the particular implementation of the ExoKernel is significantly faster than a typical GPOS for operations such as an exception dispatch (a source of overhead in traditional operating systems) <ref> [8] </ref>. Applications can also perform scheduling for themselves as well as for other applications. Since the ExoKernel architecture exports an interface just above the physical hardware, it seems likely that an implementation of the SP architecture could easily be constructed within the ExoKernel.
Reference: [9] <author> Ford, B., Hibler, M., Lepreau, J., Tullmann, P., Back, G., and Clawson, S. </author> <title> Microkernels meet recursive virtual machines. </title> <booktitle> In Proceedings of the Second USENIX Symposium on Operating Systems Design and Implementation (OSDI) (Oct. </booktitle> <year> 1996), </year> <pages> pp. 137-151. </pages>
Reference-contexts: An application would define the minor cycles and dispatch real-time tasks appropriately. 2.4.3 Microkernels and Virtual Machines Another approach to dynamically adding function to an active kernel is the creation of virtual machines. One example is the Fluke (Flux -kernel Environment) operating system architecture <ref> [9] </ref> which enhances OS modularity, flexibility, and extensibility. The Fluke architecture allows deep hierarchies of virtual machines to 41 operate efficiently. It is a nested process architecture, similar to a virtual machine architecture. However, it does not incur the performance degradation of virtual machines when they occur in layers.
Reference: [10] <author> Garey, M., and Johnson, D. </author> <title> Computers and Intractability. </title> <publisher> Freeman, </publisher> <address> San Francisco, California, </address> <year> 1979. </year>
Reference-contexts: In these regions aperiodic tasks, such as non-real-time, may execute. The schedule is prepared off-line and cannot be changed while the system is executing. It has been shown that finding a schedule is NP-hard for one processor <ref> [10] </ref>. Although the cyclic executive does allow the execution of aperiodic and periodic tasks, it fits poorly into a general-purpose operating system because it is static. The SP architecture borrows notation and concepts from the work on cyclic executives.
Reference: [11] <author> Govindan, R., and Anderson, D. P. </author> <title> Scheduling and IPC mechanisms for continuous media. </title> <booktitle> In Proceedings of the Thirteenth ACM Symposium on Operating Systems Principles (Oct. </booktitle> <year> 1991). </year> <month> 238 </month>
Reference-contexts: SP largely avoids this question, because it separates real-time computation from non-real-time computation via the CPU executive. Even in SP, however, resource executives must ensure that their managed resource is available when a real-time task attempts to access 32 it. Anderson et al. consider OS support for continuous media <ref> [11] </ref>. They address the issue of which OS function should be modified to accommodate real-time access by noting that resource conflict occurs during user/kernel domain switches and mapping (context) switches. <p> They note that in the UNIX asynchronous I/O mechanism, ten domain switches and two mapping switches are required to read a block of data. The authors make a case for reducing the amount of overhead incurred when processes cross domain boundaries in typical UNIX implementations <ref> [11] </ref>. They have designed two mechanisms that help reduce the latencies that arise from switching: split-level scheduling with synchronization and memory-mapped streams.
Reference: [12] <author> Heath, C., and Rosch, W. L. </author> <title> The MicroChannel Architecture Handbook. </title> <publisher> Simon and Schuster, Inc., </publisher> <address> New York, NY, 10023, </address> <year> 1990. </year>
Reference-contexts: This particular machine has 32 megabytes of 80 ns main memory and an IBM MicroChannel Bus. During a burst, an adapter can continue to hold access to the bus for up to 7.8 microseconds after an adapter with a higher arbitration level has raised the bus request line <ref> [12] </ref>. The microprocessor has a high priority arbitration level and may thus have to wait only 7.8 microseconds for access to the bus while another adapter finishes a burst request.
Reference: [13] <author> IBM. </author> <title> The IBM Personal System/2 Hardware Interface Technical Reference, </title> <type> 1 ed., </type> <year> 1988. </year>
Reference-contexts: The microprocessor has a high priority arbitration level and may thus have to wait only 7.8 microseconds for access to the bus while another adapter finishes a burst request. The motherboard contains two programmable interrupt controller (PIC) circuits <ref> [13, 18] </ref>, one programmable system timer circuit, and a Real-Time Clock Plus Battery Backed CMOS Ram (RTClock) with a periodic interval timer [13, 26]. The system timer, the RTClock, and the PICs are sources of hardware interrupts to the i486 CPU. <p> The motherboard contains two programmable interrupt controller (PIC) circuits [13, 18], one programmable system timer circuit, and a Real-Time Clock Plus Battery Backed CMOS Ram (RTClock) with a periodic interval timer <ref> [13, 26] </ref>. The system timer, the RTClock, and the PICs are sources of hardware interrupts to the i486 CPU. The system timer provides a number of different modes that determine when and if an interrupt will be generated.
Reference: [14] <author> IBM. </author> <title> The IBM Personal System/2 Model 95 XP 486 Technical Reference, </title> <type> 4 ed., </type> <year> 1992. </year>
Reference-contexts: The DMA controller operates at 25MHz and can transfer a single byte in approximately 740-900 nanoseconds, depending on whether the operation is a read or a write to memory and whether the memory page is present <ref> [14] </ref>. In burst mode, the DMA controller can transfer data between 300 + (320 + 160) fi n and 300 + (320 + 280) fi n bytes/ns, where n = the number of bytes in the burst. <p> This model has no level-2 cache, and its first level cache is a 8KB, 4-way, write-through, internal cache <ref> [14] </ref>. This particular machine has 32 megabytes of 80 ns main memory and an IBM MicroChannel Bus. During a burst, an adapter can continue to hold access to the bus for up to 7.8 microseconds after an adapter with a higher arbitration level has raised the bus request line [12].
Reference: [15] <author> IBM Corporation. </author> <title> IBM Virtual Machine Facility /370 Planning Guide (GC20-1801-0), </title> <year> 1972. </year>
Reference-contexts: Another use of virtual machines might be to provide each user with the illusion of a complete single user machine while actually executing many identical virtual machines, each with its own user, on a single hardware system. This is the use provided by IBM's Virtual Machine (VM/370) <ref> [15, 16] </ref>. VM/370 is a micro-kernel architecture, a small kernel interacting directly with the physical hardware and exporting the 360 architecture. The VM/370 micro-kernel is called the control program (CP).
Reference: [16] <author> IBM Corporation. </author> <title> IBM Virtual Machine Facility /370 Release 2 Planning Guide (GC20-1814-0), </title> <year> 1973. </year>
Reference-contexts: Another use of virtual machines might be to provide each user with the illusion of a complete single user machine while actually executing many identical virtual machines, each with its own user, on a single hardware system. This is the use provided by IBM's Virtual Machine (VM/370) <ref> [15, 16] </ref>. VM/370 is a micro-kernel architecture, a small kernel interacting directly with the physical hardware and exporting the 360 architecture. The VM/370 micro-kernel is called the control program (CP).
Reference: [17] <author> Intel Corporation. </author> <title> Intel486 TM Microprocessor Family Programmer's Reference Manual. Mt. Prospect, </title> <address> IL, </address> <year> 1993. </year>
Reference-contexts: A potential problem is that if the processor architecture does not allow interrupts between the actions of a repeat instruction, long, unpredictable, and irrevocable delays may occur before an interrupt may be handled. The i486 architecture allows interrupts between the actions of repeat instructions <ref> [17] </ref>. 141 the IBM MicroKernel, the timer generates an interrupt when the value of a two--byte countdown register reaches zero. The countdown resumes when either a new value is written into the countdown register or a control word is written to the circuits control register.
Reference: [18] <author> Intel Corporation. </author> <title> Peripheral Components. Mt. Prospect, </title> <address> IL, </address> <year> 1993. </year>
Reference-contexts: The microprocessor has a high priority arbitration level and may thus have to wait only 7.8 microseconds for access to the bus while another adapter finishes a burst request. The motherboard contains two programmable interrupt controller (PIC) circuits <ref> [13, 18] </ref>, one programmable system timer circuit, and a Real-Time Clock Plus Battery Backed CMOS Ram (RTClock) with a periodic interval timer [13, 26]. The system timer, the RTClock, and the PICs are sources of hardware interrupts to the i486 CPU.
Reference: [19] <author> Jeffay, K., and Bennett, D. </author> <title> A rate-based execution abstraction for multimedia computing. </title> <booktitle> In Proceedings of the 5th International Workshop on Network and Operating System Support for Digital Audio and Video (Apr. </booktitle> <year> 1995). </year>
Reference-contexts: in each interval of 30 36 milliseconds, the real-time task would receive two (30 fi 0:066) milliseconds (*) of processor cycles. 2.3.3 Rate-Based Execution Jeffay and Bennett propose a model, rate based execution (RBE), in which processes state their timeliness requirements via a rate expressed in activities per time unit <ref> [19] </ref>. For example, a process may require enough resources to process one video frame every 33 ms. The model is general enough to encompass most traditional periodic and sporadic task models, as well as some proposed multimedia computation models. It also allows the integration of non-real-time activities with real-time computation.
Reference: [20] <author> Jeffay, K., and Stone, D. L. </author> <title> Accounting for interrupt handling costs in dynamic priority task systems. </title> <note> Not Published. </note>
Reference-contexts: Jeffay and Stone solve the feasibility conditions exactly for the alternate model given by Liu and Layland. In the work by Jeffay and Stone the effect of execution of interrupt handlers is taken into account when deciding the feasibility of a set of periodic real-time tasks <ref> [20] </ref>. The difficulty is determining the amount of CPU time the interrupt handlers consume because their interarrival times and costs are known only stochastically. The Jeffay and Stone model considers two types of tasks, interrupt handlers and application tasks (periodic real-time tasks). <p> This proves Theorem 3. 4.4 Summary The analysis of the SP CPU executive presented in this section is derived from the seminal work of Liu and Layland [24] and the work by Jeffay and Stone <ref> [20] </ref>. Liu and Layland defined the fundamental characteristics of real-time tasks and proved 137 for their model that the feasibility of a task set is a function of processor utilization when scheduled by an EDF scheduler.
Reference: [21] <author> Jones, M. B. </author> <title> Adaptive real-time resource management supporting modular composition of digital multimedia services. </title> <booktitle> In Proceedings of the 4th International Workshop on Network and Operating System Support for Digital Audio and Video (Nov. </booktitle> <year> 1993). </year>
Reference-contexts: modifying the complete operating system to support real-time tasks. 2.2.4 Rialto The Rialto system being developed at Microsoft Research attempts to incorporate into their operating system high-level reasoning and dynamic inheritance of scheduling attributes, across boundaries (such as modules and RPC) traditionally closed to such inheritance, to support real-time computation <ref> [22, 21] </ref>. Rialto defines and uses programming and system abstractions that make it easier to manage computer system resources. Each resource providing a service can define how much resource it needs to accomplish that service.
Reference: [22] <author> Jones, M. B., Leach, P. J., Draves, R. P., and Barrera, J. S. </author> <title> Support for user-centric modular real-time resource management in the ri-alto operating system. </title> <booktitle> In Proceedings of the 5th International Workshop on Network and Operating System Support for Digital Audio and Video (Apr. </booktitle> <year> 1995). </year>
Reference-contexts: modifying the complete operating system to support real-time tasks. 2.2.4 Rialto The Rialto system being developed at Microsoft Research attempts to incorporate into their operating system high-level reasoning and dynamic inheritance of scheduling attributes, across boundaries (such as modules and RPC) traditionally closed to such inheritance, to support real-time computation <ref> [22, 21] </ref>. Rialto defines and uses programming and system abstractions that make it easier to manage computer system resources. Each resource providing a service can define how much resource it needs to accomplish that service.
Reference: [23] <author> Little, J. D. </author> <title> A proof of the formula l = w. </title> <booktitle> Operations Research 9, 3 (May-June 1961), </booktitle> <pages> 383-387. </pages>
Reference-contexts: These stochastic methods estimate the average time a task waits in the queue <ref> [23] </ref>. For GPOSs this is the best that can be done, since the actual interarrival times and service requirements of its tasks cannot be predicted.
Reference: [24] <author> Liu, C. L., and Layland, J. W. </author> <title> Scheduling algorithms for multiprogramming in a hard real-time environment. </title> <journal> J. ACM 20, </journal> <month> 1 (Jan. </month> <year> 1973), </year> <pages> 46-61. </pages>
Reference-contexts: For example, incoming compressed video frames must be decompressed and displayed approximately every 33 milliseconds, or the quality of the displayed video will degrade. In 1973 Liu and Layland published their seminal work in the scheduling of tasks with real-time execution constraints <ref> [24] </ref>. Their model is called the periodic real-time task model. <p> The three variables are related by the following expression: = C T where C is the computation time, and T is the interval in which the computation must occur. This analysis allows straightforward application of the results presented by Liu and Layland <ref> [24] </ref>, for 29 the purpose of determining the feasibility of the real-time task set and is what they use for admission control. <p> When x = 1 and d = y, the RBE model is identical to the Liu and Layland periodic task model <ref> [24] </ref>. RBE has been implemented on YARTOS (Yet Another Real-Time Operating System) and Real-Time Mach. Although RBE supports non-real-time and real-time activities, its focus is different from the SP architecture. <p> The seminal work on defining real-time tasks, along with two algorithms for assigning priorities, is by Liu and Layland <ref> [24] </ref>. The SP system uses this model for the tasks which it specifically supports. <p> The analysis first imposes rather strict assumptions and considers a case in which feasibility is a function of processor utilization, similar to the analysis given 122 by Liu and Layland <ref> [24] </ref>. The assumptions are then relaxed in the analysis of Section 4.3.1: feasibility then requires a test for all intervals, but covers the general case where the costs and periods of the real-time tasks are unrelated to the lengths of the minor cycles. <p> Thus t will be feasible if and only if g (L) 0 for all L 2 P . This proves Theorem 3. 4.4 Summary The analysis of the SP CPU executive presented in this section is derived from the seminal work of Liu and Layland <ref> [24] </ref> and the work by Jeffay and Stone [20]. Liu and Layland defined the fundamental characteristics of real-time tasks and proved 137 for their model that the feasibility of a task set is a function of processor utilization when scheduled by an EDF scheduler. <p> This section addresses which set of values the admission control function should choose and how that decision is made. Consider a set, T , of n periodic real-time threads, as described by Liu and Layland, such that thread t i has cost c i and period p i <ref> [24] </ref>. We know that P n c i is the CPU utilization of the real-time threads. Thus, we know that the following must hold (it is necessary but not sufficient) before the feasibility analysis will succeed: mc rt i=1 p i But this is not the whole story. <p> implemented in this manner to save task switch time, when the RTK switches to a real-time task, since their periods should be about as long as the interval between invocations of the RTK. 6.3.3 Real-Time Threads This application contains three real-time threads modelled after the Liu and Lay-land task model <ref> [24] </ref>. (An alternate model for these real-time threads is described 3 An obvious optimization here would be to modify the low-level interrupt handler to determine if the RTK device driver removed the packet and, in that case, simply issue an end-of-interrupt to the device and return, rather than call the GPOS
Reference: [25] <author> Mercer, C. W., Savage, S., and Tokuda, H. </author> <title> Processor Capacity Reserves for Multimedia Operating Systems. </title> <booktitle> In Proceedings of the IEEE International Conference on Multimedia Computing and Systems (May 1994). </booktitle> <pages> 239 </pages>
Reference-contexts: merging them and to develop a generic approach that can be used with any GPOS. 2.2.3 Processor Capacity Reserves Processor capacity reservation (PCR) is an abstraction and mechanism, added to Real-Time Mach, to allow the user to control allocation of processor cycles among a number of tasks reserving processor cycles <ref> [25] </ref>. A new kernel abstraction, the reserve, is also introduced. The reserve tracks the reservation and measures the processor cycles used by tasks with reservations. <p> A measurement mechanism accurately measures the processor time accumulated by each activity. Activities that have not yet consumed their reserve have a higher priority than activities that have. The measurement mechanism is driven by an auxiliary timer board. The system described by Mercer et al. <ref> [25] </ref> does recognize that interrupt handlers artificially increase the amount of processor time a scheduler attributes to a particular task, because their measurement mechanism specifically excludes the execution time of interrupt handlers.
Reference: [26] <institution> Motorola. Motorola Semiconductor Technical Data. Motorola Design-Net 602-244-6591. </institution>
Reference-contexts: The motherboard contains two programmable interrupt controller (PIC) circuits [13, 18], one programmable system timer circuit, and a Real-Time Clock Plus Battery Backed CMOS Ram (RTClock) with a periodic interval timer <ref> [13, 26] </ref>. The system timer, the RTClock, and the PICs are sources of hardware interrupts to the i486 CPU. The system timer provides a number of different modes that determine when and if an interrupt will be generated.
Reference: [27] <author> Nieh, J., Hanko, J. G., Northcutt, J. D., and Wall, G. A. </author> <title> Svr4unix scheduler unacceptable for multimedia applications. </title> <booktitle> In Proceedings of the 4th International Workshop on Network and Operating System Support for Digital Audio and Video (Nov. </booktitle> <year> 1993). </year>
Reference-contexts: SP architecture. 2.2.1 Integrated Processor Scheduling Nieh et al. developed the concept of integrated processor scheduling because the real-time scheduler supplied with System V Release 4 UNIX could not effectively schedule a set of tasks which included both traditional timesharing tasks and tasks for managing multimedia (which required real-time support) <ref> [27] </ref>. Integrated processor scheduling is so named because it integrates the scheduling of conventional and real-time tasks within a single system. <p> Measurements completed on the System V Release 4 (SVR4) UNIX scheduler showed conclusively that the SVR4 priority based scheduling algorithm could not schedule both applications with deadlines and typical GPOS applications <ref> [27, 28] </ref>. The SVR4 real-time scheduler allows real-time tasks to be scheduled at the highest priority class in the system to allow them to receive processor cycles as needed. <p> Small differences in the tuning values, the application mix, or the input data could have caused radically different latencies and response times <ref> [27] </ref>. Integrated processor can fairly schedule a mix of tasks with deadlines and traditional priority-scheduled tasks because it does not confuse urgency and importance. <p> about 10 percent of the mean (average completion time is 112 ms and standard deviation is 9.75 ms); on a busy system, the standard deviation of the completion times of the real-time tasks is about 30 percent of the mean (mean completion time 177 ms and standard deviation 48.3 ms) <ref> [27] </ref>. This is undesirable, because the largest possible completion time would have to be used to determine the share given to the real-time tasks, thus reducing the amount of processor cycles available for real-time tasks.
Reference: [28] <author> Nieh, J., and Lam, M. S. </author> <title> Integrated processor scheduling for multimedia. </title> <booktitle> In Proceedings of the 5th International Workshop on Network and Operating System Support for Digital Audio and Video (Apr. </booktitle> <year> 1995). </year>
Reference-contexts: Measurements completed on the System V Release 4 (SVR4) UNIX scheduler showed conclusively that the SVR4 priority based scheduling algorithm could not schedule both applications with deadlines and typical GPOS applications <ref> [27, 28] </ref>. The SVR4 real-time scheduler allows real-time tasks to be scheduled at the highest priority class in the system to allow them to receive processor cycles as needed.
Reference: [29] <author> Pardyak, P., and Bershad, B. N. </author> <title> Dynamic binding for an extensible system. </title> <booktitle> In Proceedings of the Second USENIX Symposium on Operating Systems Design and Implementation (OSDI) (Oct. </booktitle> <year> 1996), </year> <pages> pp. 201-212. </pages>
Reference-contexts: architectures that represent possible approaches to dynamically extending an operating system kernel to support periodic real-time tasks. 2.4.1 SPIN The SPIN project attempts to facilitate the addition of services in an operating system by viewing function and procedure calls as events that can be dynamically 39 bound to various handlers <ref> [29] </ref>. The basic SPIN kernel consists only of device access, dynamic linking, and event handling. All other typical GPOS services, such as threads and virtual memory, are provided by applications as needed.
Reference: [30] <author> Peterson, J. L., and Silberschatz, A. </author> <title> Operating System Concepts. </title> <publisher> Addison Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1983. </year>
Reference-contexts: Scheduling real-time tasks with completion time deadlines is fundamentally different from scheduling non-real-time tasks. Typically, GPOSs use schedulers, such as first in first out (FIFO), shortest job first (SJF), or least remaining time first, (LRTF) <ref> [30] </ref>. The quantitative measures of system performance (such as task completion times) for these schedulers are computed using assumed stochastic distributions for the service requirement of each task and for the interarrival times of tasks at the ready queue.
Reference: [31] <author> Ramamurthy, S., Moir, M., and Anderson, J. H. </author> <title> Real-time object sharing with minimal system support. </title> <booktitle> In Proceedings of the 15th Annual ACM Symposium on Principles of Distributed Computing (May 1996), ACM, </booktitle> <pages> pp. 233-242. </pages>
Reference-contexts: The log information may be moved to disk at any point, but the real-time and non-real-time threads must communicate easily. Although many mechanisms for this intra-thread communication are possible, their essential component, viewed from the real-time thread, is an abstract wait-free queue <ref> [31] </ref>. Thus, the real-time thread would queue a work request to the queue and that queue operation would have a bounded completion time.
Reference: [32] <author> Sha, L., Rajkumar, R., and Lehoczky, J. P. </author> <title> Priority inheritance protocols: An approach to real-time synchronization. </title> <journal> IEEE Trans. Softw. Eng. </journal> <volume> 39, </volume> <month> 9 (Sept. </month> <year> 1990), </year> <pages> 1175-1185. </pages>
Reference-contexts: Real-time thread creation requires parameters to define the thread's timing characteristics, such as the period (both periodic and aperiodic threads are supported), maximum cost, and deadline, and whether the deadline is hard or soft. Real-Time Mach adds real-time synchronization to solve the priority inversion problem by using priority inheritance <ref> [32] </ref>. Real-time synchronization thus establishes an upper limit to the amount of time a high priority process may be blocked by a lower priority process that has locked a resource the higher priority process needs.
Reference: [33] <author> Shaw, A. C. </author> <title> Reasoning about time in higher-level language software. </title> <journal> IEEE Trans. Softw. Eng. </journal> <volume> 15, </volume> <month> 7 (July </month> <year> 1989), </year> <pages> 875-889. </pages>
Reference-contexts: Another approach, proposed by Shaw <ref> [33] </ref>, would be to determine the "dilation" effect that interrupt handlers have on task execution time.
Reference: [34] <author> Stoica, I., Abdel-Wahab, H., Jeffay, K., Baruah, S. K., Gehrke, J. E., and Plaxton, C. G. </author> <title> A proportional share resource allocation algorithm for real-time, time-shared systems. </title> <booktitle> In Proceedings of the 17th IEEE Real-Time Systems Symposium (Dec. </booktitle> <year> 1996), </year> <pages> pp. 288-299. </pages>
Reference-contexts: Other relevant work in this area includes an algorithm that successfully mixes real-time and non-real-time scheduling so that all processes in the system progress at precise, well-defined, uniform rates <ref> [34] </ref>. The algorithm is earliest deadline first, but it supports services of both the GPOS and real-time tasks. It is essentially a cross between processor sharing and typical periodic real-time scheduling. Every process is assigned a weight from which a share of the processor is calculated.
Reference: [35] <author> Tanenbaum, A. S. </author> <title> Computer Networks. </title> <publisher> Prentice Hall, Inc., </publisher> <address> Englewood Cliffs, NJ 07632, </address> <year> 1981. </year>
Reference-contexts: One may view this alternate execution as dividing the CPU's capacity in time. Paradigms to facilitate the efficient use of a communications link, such as a telephone network's trunk lines, have long included the notion 43 of time division multiplexing <ref> [35] </ref>. Consider a physical communications link with bandwidth fi and a number of distinct logical channels each of which carries a conversation on behalf of a link user. Time division multiplexing allows all of the logical channels to share the physical link.
Reference: [36] <author> Tokuda, H., Nakajima, T., and Rao, P. </author> <title> Real-Time Mach: Toward a Predictable Real-Time System. </title> <booktitle> In Proceedings of USENIX Mach Workshop (Oct. </booktitle> <year> 1990), </year> <pages> pp. 73-82. </pages>
Reference-contexts: These issues are discussed further in Section 3.3. 2.2.2 Real-Time Mach The work on Real-Time Mach attempts to develop a real-time version of the Mach Kernel <ref> [36] </ref>. Real-Time Mach addresses the same issues as the SP architecture 26 but uses a different approach. All of the subsystems of the Mach kernel are mod-ified to create reasonable upper bounds on the cost of using the services of these subsystems.
Reference: [37] <author> Waldspurger, C. A., and Weihl, W. E. </author> <title> Lottery scheduling: Flexible proportional-share resource management. </title> <booktitle> In Proceedings of the First USENIX Symposium on Operating Systems Design and Implementation (OSDI) (Nov. </booktitle> <year> 1994). </year>
Reference-contexts: context of a GPOS, but none accounts for latencies at scheduling boundaries due to the disabling of interrupts or for the effect of interrupt handlers executing below the visibility of the scheduler. 2.3.1 Lottery Scheduling In lottery scheduling, the CPU is scheduled by randomly selecting a process through a lottery <ref> [37] </ref>. Processes obtain a number of `tickets'. The share of a resource that a process eventually receives is proportional to the number of tickets a process holds.
References-found: 37

