URL: http://www.cs.wisc.edu/ZOO/PAPERS/moosefox.ps
Refering-URL: http://www.cs.wisc.edu/ZOO/papers.html
Root-URL: 
Email: fwiener,yannisg@cs.wisc.edu  
Title: A Moose and a Fox Can Aid Scientists with Data Management Problems  
Author: Janet L. Wiener Yannis E. Ioannidis 
Address: 1210 W. Dayton St., Madison, WI 53706 U.S.A.  
Affiliation: Dept. of Computer Sciences, University of Wisconsin-Madison  
Abstract: Fox (Finding Objects of eXperiments) is the declarative query language for Moose (Modeling Objects Of Scientific Experiments), an object-oriented data model at the core of a scientific experiment management system (EMS) being developed at Wisconsin. The goal of the EMS is to support scientists in managing their experimental studies and the data that are generated from them. Moose is unique among object-oriented data models in permitting sets to have relationships to classes other than their elements' class, in providing a construct for indexing collections by other collections, such as time series, and in distinguishing structural relationships from non-structural ones. Fox contains several new features necessary to manage experiments, such as support for associative element retrieval from (indexed) sets and highly expressive path expressions. Fox path expressions can traverse any relationship in the schema graph, including inheritance relationships, and in either direction of the relationship, which makes many queries more concise. Fox also supports a new form of deep equality based on structural information and a new, concise, description of periodic data, e.g., time series. Finally, Fox offers the only object-oriented bulk-loading facility of which we are aware, for loading data from a file.
Abstract-found: 1
Intro-found: 1
Reference: [ABD + 89] <author> M. Atkinson, F. Bancilhon, D. DeWitt, K. Dittrich, D. Maier, and S. Zdonik. </author> <title> The Object-Oriented Database System Manifesto. </title> <booktitle> In Proceedings of the International Conference on Deductive and Object-Oriented Databases, </booktitle> <pages> pages 223-240, </pages> <address> Kyoto, Japan, </address> <month> December </month> <year> 1989. </year>
Reference-contexts: This flexibility permits the scientist to retain a core schema, although the specific details for each study may vary. 2.2.5 Derived subclasses Moose supports derived subclasses, which are defined using constraint inheritance <ref> [ABD + 89] </ref>. The class extent of a subclass is computed intensionally from the extent of the superclass using a rule. The extents of derived subclasses are automatically maintained by the system. Derived subclasses are particularly useful when the scientist discovers that certain experiments with interesting characteristics have special behaviors.
Reference: [AK89] <author> S. Abiteboul and P. Kanellakis. </author> <title> Object Identity as a Query Language Primitive. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 159-173, </pages> <address> Portland, OR, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: There are several other declarative query languages that have been proposed for OO data models, namely O2query [BCD89], Extra/Excess [CDV88], CQL++ [DGJ92], COQL [NO92], OQL [ASL89], IQL <ref> [AK89] </ref>, XSQL [KKS92], Ontos's OSQL [Ont92], and the Orion query language [Kim89], as well as the Equal query algebra [SZ89]. Fox differs from them in several aspects.
Reference: [ASL89] <author> A. M. Alashqur, S. Y. W. Su, and H. Lam. OQL: </author> <title> A Query Language for Manipulating Object-0riented Databases. </title> <booktitle> In Proceedings of the International Conference on Very Large Data Bases, </booktitle> <pages> pages 433-442, </pages> <address> Amsterdam, The Netherlands, </address> <month> August </month> <year> 1989. </year>
Reference-contexts: In addition to the novel features mentioned in the introduction, Fox has the following useful characteristics. It allows arbitrary object construction; it provides closure <ref> [ASL89] </ref>, so that query results can be used in later queries; it provides optional persistence of query results, so that query results can be stored when needed later, but need not clutter the database; and it supports queries based on both named objects and class extents. <p> There are several other declarative query languages that have been proposed for OO data models, namely O2query [BCD89], Extra/Excess [CDV88], CQL++ [DGJ92], COQL [NO92], OQL <ref> [ASL89] </ref>, IQL [AK89], XSQL [KKS92], Ontos's OSQL [Ont92], and the Orion query language [Kim89], as well as the Equal query algebra [SZ89]. Fox differs from them in several aspects. <p> A path expression starts with the name of an object or an object variable, called the path expression root, and continues by traversing relationships. Fox path expressions are more expressive than those of other languages because they can traverse both connection and inheritance relationships in both directions. OQL "contexts" <ref> [ASL89] </ref> are similar to Fox path expressions and can indicate paths through any relationships. However, OQL contexts are only used to restrict the results (which are sub-databases) and do not directly evaluate to objects.
Reference: [BCD89] <author> F. Bancilhon, S. Cluet, and C. Delobel. </author> <title> A Query Language for the O2 Object-Oriented Database System. </title> <editor> In R. Hull, R. Morrison, and D. Stemple, editors, </editor> <booktitle> Proceedings of the International Workshop on Database Programming Languages, </booktitle> <pages> pages 122-138. </pages> <address> Morgan-Kaufman, </address> <publisher> Inc., </publisher> <address> San Mateo, CA, </address> <year> 1989. </year>
Reference-contexts: There are several other declarative query languages that have been proposed for OO data models, namely O2query <ref> [BCD89] </ref>, Extra/Excess [CDV88], CQL++ [DGJ92], COQL [NO92], OQL [ASL89], IQL [AK89], XSQL [KKS92], Ontos's OSQL [Ont92], and the Orion query language [Kim89], as well as the Equal query algebra [SZ89]. Fox differs from them in several aspects. <p> However, their names cannot be persistently stored in the database, which means they cannot be used to identify frequently used objects. Although O2query uses named objects, it does not allow names to be attached to query results <ref> [BCD89] </ref>. The only way to persistently attach a name to an object is to embed the query in a programming language, and assign the query result to a persistent program variable. Fox allows the names to be created in the query language, as well as to be accessible from it. <p> their declarative query languages, not the creation of new ones. (In order to create new objects in these systems, the programming language must be invoked.) For example, Orion's query language only returns the OIDs of existing objects [BKK88], Ontos's OSQL returns relations [Ont92], and O2query results are values (not objects) <ref> [BCD89] </ref>. Fox allows the user to explicitly specify the structure of the result of a query. The select clause specifies not only what to retrieve, but also exactly what the resulting objects should look like. For each binding specified in the for clause, an object is produced. <p> We expect the to be used most often when the for clause indicates iteration, and hence a multiset result, but the where clause qualification restricts the multiset to a single element. Similar constructs include the in Daplex [Shi81] (from which we adopted the keyword), the element function in O2query <ref> [BCD89] </ref>, and the member message in COQL [NO92]. Fox introduces any. We expect any to be used frequently when more than one object may satisfy the where clause qualification, but any such object is acceptable. <p> Sequenced-set element retrieval looks just like list element retrieval in O2query <ref> [BCD89] </ref>, and like array element retrieval in many programming languages, e.g., C and Pascal. If Plant community in for e in Experiment select e.system [1]; The query syntax to retrieve indexed-set elements is a natural extension: instead of identifying the position of the indexed-set elements, its indexing element is specified. <p> In this section, we give examples of Fox queries with their corresponding (more complicated) equivalents in O2query <ref> [BCD89] </ref>. We also show queries that cannot be expressed in O2query, or any other declarative query language besides Fox. We chose O2query because it is one of the most expressive declarative query languages, and also the language most similar to Fox.
Reference: [BCG + 87] <author> J. Banerjee, H. T. Chou, J. Garza, W. Kim, D. Woelk, N. Ballou, and H. J. Kim. </author> <title> Data model issues for object-oriented applications. </title> <journal> ACM Transactions on Office Information Systems, </journal> <volume> 5(1) </volume> <pages> 3-26, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: These needs include the following: * Scientists need to access experimental data in ad-hoc ways. Most current OO query languages impose restrictions on how object relationships may be traversed in query path expressions, for instance, only allowing traversal in one direction <ref> [BCG + 87, CDV88, DGJ92, FBC + 90, NO92] </ref>. This restriction is too strict for queries in an EMS environment, because it forces scientists to start most queries with the root of the schema graph. Fox allows arbitrary path expressions that may traverse all types of relationships in both directions. <p> indexed-set class.) Each element in the keyset uniquely identifies an element in the indexed-set. 1 In Figure 1, Plant community is a set class, and serves as the keyset for Vegetation temperatures, which is an indexed-set class. 2.2 Object relationships in Moose Like many other semantic and OO data models <ref> [HK87, BCG + 87, CDV88, Deu90, ISK + 93, NO92, SKL88] </ref>, Moose provides two major categories of relationships between classes: connection relationships and inheritance relationships. 2 A connection relationship between two classes implies a logical or physical relationship between their object instances. <p> In Moose, an existence dependency can occur in either direction of any connection relationship. This is in contrast to other models that support such constraints, e.g., Orion <ref> [BCG + 87] </ref>, Extra/Excess [CDV88], and Jasmine [ISK + 93], where existence dependency semantics are only attached to (specified) structural relationships, and only in the dominant direction. Existence dependencies among objects are not expressed as separate properties in Moose; they are determined by the properties of mutability and null permissions. <p> For example, when a new relationship is added to an existing source object, what target object should be associated with it? We currently plan to adopt the schema evolution semantics outlined for Orion <ref> [BCG + 87] </ref> and possibly adapt it to an specialized needs that may arise in scientific applications. 4 Fox: the query language for Moose Fox (Finding Objects of eXperiments) is the declarative query and data modification language for Moose.
Reference: [Bee88] <author> D. Beech. </author> <title> A foundation for evolution from relational to object databases. </title> <booktitle> In Proceedings of the International Conference on Extending Database Technology, </booktitle> <pages> pages 251-170, </pages> <address> Venice, Italy, </address> <month> March </month> <year> 1988. </year>
Reference-contexts: Iris also allows both forms of relationship 3 We expect many scientific schemas to contain hundreds of classes. It is quite easy to forget what names have already been used for relationships. 8 creation <ref> [Bee88] </ref>. Each class create statement must specify the kind of the class. Each relationship create statement may specify the properties of the relationship in each direction. If left unspecified, the properites obtain default values of association, N-1, mutable, and with null objects permitted. <p> The keyword required, borrowed from Iris <ref> [Bee88] </ref>, indicates that null values are not allowed.
Reference: [BKK88] <author> J. Banerjee, W. Kim, and K. C. Kim. </author> <title> Queries in Object-Oriented Databases. </title> <booktitle> In IEEE Conference on Data Engineering, </booktitle> <pages> pages 31-38, </pages> <address> Los Angeles, CA, </address> <month> February </month> <year> 1988. </year>
Reference-contexts: Inclusion inheritance means that all objects in the subclass are also instances of the superclass. In Figure 3, the instances of Staff member, Student, and PA are all instances of Scientist, and will be retrieved when iterating through the instances of Scientist. Several languages <ref> [BKK88, BNPS92] </ref> provide optional iteration over the entire class hierarchy, with the default being iteration over objects that are not instances of a subclass. <p> The scope of the object variable bindings includes all subqueries that do not rebind the variable, as well the select and where clauses. Fox's object variables are similar to tuple variables in SQL [DW89], iteration variables in Orion <ref> [BKK88] </ref>, reference variables in Daplex [Shi81], and range variables in CQL++ [DGJ92]. The names of all named objects used in the query must also appear in the for clause. <p> OO systems have chosen to allow only the retrieval of existing objects from their declarative query languages, not the creation of new ones. (In order to create new objects in these systems, the programming language must be invoked.) For example, Orion's query language only returns the OIDs of existing objects <ref> [BKK88] </ref>, Ontos's OSQL returns relations [Ont92], and O2query results are values (not objects) [BCD89]. Fox allows the user to explicitly specify the structure of the result of a query. The select clause specifies not only what to retrieve, but also exactly what the resulting objects should look like.
Reference: [BNPS92] <author> E. Bertino, M. Negri, G. Pelagatti, and L. Sbattella. </author> <title> Object-Oriented Query Languages: The Notion and the Issues. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 4(3) </volume> <pages> 223-237, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Inclusion inheritance means that all objects in the subclass are also instances of the superclass. In Figure 3, the instances of Staff member, Student, and PA are all instances of Scientist, and will be retrieved when iterating through the instances of Scientist. Several languages <ref> [BKK88, BNPS92] </ref> provide optional iteration over the entire class hierarchy, with the default being iteration over objects that are not instances of a subclass. <p> If the path expression traverses multiple set-of 11 relationships, then the effect is that of unioning the innermost collection elements <ref> [BNPS92, KKS92, HM81] </ref>. If two path expressions begin with the same prefix, then they are implicitly joined by their common prefix when they are evaluated. A complete path expression to an inherited relationship (such as the name relationship of the Student class) always traverses the inheritance relationships involved. <p> Fox supports object comparisons by identity, shallow equality, and deep equality, using the operators is, =, and ==, respectively. We extend earlier definitions of shallow and deep equality <ref> [BNPS92, SZ89] </ref> to differentiate a complex object from its associations: only the has-part, set-of, and keyset relationships of the objects are compared, directly for shallow equality and recursively for deep equality. Fox also provides comparison operators for comparing scalars to collections and collections to collections by membership. <p> Fox also provides comparison operators for comparing scalars to collections and collections to collections by membership. All membership tests are by object identity. In addition to the operators provided by other languages <ref> [KKS92, BNPS92] </ref>, Fox adds the disjoint and overlaps operators for comparing two collections (although they may be simulated using set intersection and an (in)equality comparison with the empty set). Collection objects may also be combined with set-theoretic union, intersection, and difference, and additive union [VD91].
Reference: [CDG + 90] <author> M. J. Carey, D. J. DeWitt, G. Graefe, D. M. Haight, J. E. Richardson, D. T. Schuh, E. J. Shekita, and S. L. Vandenberg. </author> <title> The EXODUS Extensible DBMS Project: An Overview. </title> <editor> In Stanley B. Zdonik and David Maier, editors, </editor> <booktitle> Readings in Object-Oriented Database Systems, </booktitle> <pages> pages 474-499. </pages> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> San Mateo, CA, </address> <year> 1990. </year>
Reference-contexts: We have completed a preliminary implemention of Moose and Fox on top of the Exodus storage manager <ref> [CDG + 90] </ref>. The implementation is limited in that it only processes the select clause. However, it is the foundation for our current efforts to add more processing capabilities.
Reference: [CDV88] <author> M. Carey, D. DeWitt, and S. Vandenberg. </author> <title> A Data Model and Query Language for Exodus. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 413-423, </pages> <address> Chicago, IL, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: These needs include the following: * Scientists need to access experimental data in ad-hoc ways. Most current OO query languages impose restrictions on how object relationships may be traversed in query path expressions, for instance, only allowing traversal in one direction <ref> [BCG + 87, CDV88, DGJ92, FBC + 90, NO92] </ref>. This restriction is too strict for queries in an EMS environment, because it forces scientists to start most queries with the root of the schema graph. Fox allows arbitrary path expressions that may traverse all types of relationships in both directions. <p> indexed-set class.) Each element in the keyset uniquely identifies an element in the indexed-set. 1 In Figure 1, Plant community is a set class, and serves as the keyset for Vegetation temperatures, which is an indexed-set class. 2.2 Object relationships in Moose Like many other semantic and OO data models <ref> [HK87, BCG + 87, CDV88, Deu90, ISK + 93, NO92, SKL88] </ref>, Moose provides two major categories of relationships between classes: connection relationships and inheritance relationships. 2 A connection relationship between two classes implies a logical or physical relationship between their object instances. <p> In Moose, an existence dependency can occur in either direction of any connection relationship. This is in contrast to other models that support such constraints, e.g., Orion [BCG + 87], Extra/Excess <ref> [CDV88] </ref>, and Jasmine [ISK + 93], where existence dependency semantics are only attached to (specified) structural relationships, and only in the dominant direction. Existence dependencies among objects are not expressed as separate properties in Moose; they are determined by the properties of mutability and null permissions. <p> There are several other declarative query languages that have been proposed for OO data models, namely O2query [BCD89], Extra/Excess <ref> [CDV88] </ref>, CQL++ [DGJ92], COQL [NO92], OQL [ASL89], IQL [AK89], XSQL [KKS92], Ontos's OSQL [Ont92], and the Orion query language [Kim89], as well as the Equal query algebra [SZ89]. Fox differs from them in several aspects.
Reference: [Che76] <author> P. P. Chen. </author> <title> The Entity-Relationship Model | Towards a Unified View of Data. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 1(1) </volume> <pages> 9-36, </pages> <month> March </month> <year> 1976. </year>
Reference-contexts: Abstractly, an instantiation of such a relationship always connects an object to itself, representing the fact that the object may play the roles of both the general and the specialized class. 2.2.1 Connection relationships Many data models only provide one form of connection relationship <ref> [Che76, Deu90, FBC + 90] </ref>. A major contribution of Moose is to provide different kinds of connection relationships, to reflect the different ways that objects may be related and capture additional semantics implied by these ways. <p> Removing or replacing a plant may imply changing a community, but growing a plant does not imply creating a new plant. Cardinality ratios In Moose, connection relationships have cardinality ratios, as in the Entity-Relationship model <ref> [Che76] </ref>. The ratios are separated into a cardinality for each direction of the relationship. Set-of relationships are multi-valued and indexed-by relationships are single-valued, while all other directions of relationships may be single-valued or multi-valued.
Reference: [Deu90] <author> O. </author> <title> Deux. The Story of O2. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(1) </volume> <pages> 91-108, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: indexed-set class.) Each element in the keyset uniquely identifies an element in the indexed-set. 1 In Figure 1, Plant community is a set class, and serves as the keyset for Vegetation temperatures, which is an indexed-set class. 2.2 Object relationships in Moose Like many other semantic and OO data models <ref> [HK87, BCG + 87, CDV88, Deu90, ISK + 93, NO92, SKL88] </ref>, Moose provides two major categories of relationships between classes: connection relationships and inheritance relationships. 2 A connection relationship between two classes implies a logical or physical relationship between their object instances. <p> Abstractly, an instantiation of such a relationship always connects an object to itself, representing the fact that the object may play the roles of both the general and the specialized class. 2.2.1 Connection relationships Many data models only provide one form of connection relationship <ref> [Che76, Deu90, FBC + 90] </ref>. A major contribution of Moose is to provide different kinds of connection relationships, to reflect the different ways that objects may be related and capture additional semantics implied by these ways.
Reference: [DGJ92] <author> S. Dar, N. H. Gehani, and H. V. Jagadish. CQL++: </author> <title> A SQL for a C++ Based Object-Oriented DBMS. </title> <booktitle> In Proceedings of the International Conference on Extending Database Technology, </booktitle> <pages> pages 201-216, </pages> <address> Vienna, Austria, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: These needs include the following: * Scientists need to access experimental data in ad-hoc ways. Most current OO query languages impose restrictions on how object relationships may be traversed in query path expressions, for instance, only allowing traversal in one direction <ref> [BCG + 87, CDV88, DGJ92, FBC + 90, NO92] </ref>. This restriction is too strict for queries in an EMS environment, because it forces scientists to start most queries with the root of the schema graph. Fox allows arbitrary path expressions that may traverse all types of relationships in both directions. <p> There are several other declarative query languages that have been proposed for OO data models, namely O2query [BCD89], Extra/Excess [CDV88], CQL++ <ref> [DGJ92] </ref>, COQL [NO92], OQL [ASL89], IQL [AK89], XSQL [KKS92], Ontos's OSQL [Ont92], and the Orion query language [Kim89], as well as the Equal query algebra [SZ89]. Fox differs from them in several aspects. <p> Both Iris [FBC + 90] and CQL++ <ref> [DGJ92] </ref> provide names called instance variables and object variables, respectively. However, their names cannot be persistently stored in the database, which means they cannot be used to identify frequently used objects. Although O2query uses named objects, it does not allow names to be attached to query results [BCD89]. <p> The scope of the object variable bindings includes all subqueries that do not rebind the variable, as well the select and where clauses. Fox's object variables are similar to tuple variables in SQL [DW89], iteration variables in Orion [BKK88], reference variables in Daplex [Shi81], and range variables in CQL++ <ref> [DGJ92] </ref>. The names of all named objects used in the query must also appear in the for clause. <p> Making the graphs temporary would allow the scientist to make a final selection before entering the most useful ones into the database for future use. CQL++ also supports temporary results <ref> [DGJ92] </ref>, although in CQL++ the result objects need to be explicitly inserted into a special, temporary class, while Fox infers the class definitions for temporary objects from the query. 4.3 Comparison with other query languages The major differences between Fox and other query languages lie in the expressiveness of Fox's path <p> This example grows all the corn plants by both 1 leaf and 3 cm in height, which would require two update statements in other languages <ref> [DW89, DGJ92] </ref>. (We have not seen declarative update statements for most systems, e.g., O2, Extra/Excess, Iris, and Orion.) for p in plant update p.num leaves to p.num leaves + 1, p.height to p.height + 3.0 where p.type = "corn"; 5.3 Delete The delete statement removes objects from a given class from
Reference: [DW89] <author> C. J. Date and C. J. White. </author> <title> A Guide to DB2. </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <note> 3rd edition, </note> <year> 1989. </year>
Reference-contexts: The scope of the object variable bindings includes all subqueries that do not rebind the variable, as well the select and where clauses. Fox's object variables are similar to tuple variables in SQL <ref> [DW89] </ref>, iteration variables in Orion [BKK88], reference variables in Daplex [Shi81], and range variables in CQL++ [DGJ92]. The names of all named objects used in the query must also appear in the for clause. <p> The effects of grouping can be accomplished with subqueries that include a join on the grouping attributes <ref> [DW89] </ref>. Aggregate functions, which are expressed in an unintuitive manner in SQL, operate on a subquery in Fox. This more intuitive syntax was first proposed for SQL/NF [RKB87]. Group qualifications are expressed in the where clause for the query, instead of in a having clause. <p> This example grows all the corn plants by both 1 leaf and 3 cm in height, which would require two update statements in other languages <ref> [DW89, DGJ92] </ref>. (We have not seen declarative update statements for most systems, e.g., O2, Extra/Excess, Iris, and Orion.) for p in plant update p.num leaves to p.num leaves + 1, p.height to p.height + 3.0 where p.type = "corn"; 5.3 Delete The delete statement removes objects from a given class from
Reference: [FBC + 90] <author> D.H. Fishman, D. Beech, H.P. Cate, E. C. Chow, T. Connors, J. W. Davis, N. Derrett, C. G. Hoch, W. Kent, P. Lyngbaek, B. Mahbod, M. A. Neimat, T.A. Ryan, and M. C. Shan. </author> <title> Iris: An Object-Oriented Database Management System. </title> <editor> In S. B. Zdonik and D. Maier, editors, </editor> <booktitle> Readings in Object-Oriented Database Systems, </booktitle> <pages> pages 216-226. </pages> <address> Morgan-Kaufman, </address> <publisher> Inc., </publisher> <address> San Mateo, CA, </address> <year> 1990. </year>
Reference-contexts: These needs include the following: * Scientists need to access experimental data in ad-hoc ways. Most current OO query languages impose restrictions on how object relationships may be traversed in query path expressions, for instance, only allowing traversal in one direction <ref> [BCG + 87, CDV88, DGJ92, FBC + 90, NO92] </ref>. This restriction is too strict for queries in an EMS environment, because it forces scientists to start most queries with the root of the schema graph. Fox allows arbitrary path expressions that may traverse all types of relationships in both directions. <p> Abstractly, an instantiation of such a relationship always connects an object to itself, representing the fact that the object may play the roles of both the general and the specialized class. 2.2.1 Connection relationships Many data models only provide one form of connection relationship <ref> [Che76, Deu90, FBC + 90] </ref>. A major contribution of Moose is to provide different kinds of connection relationships, to reflect the different ways that objects may be related and capture additional semantics implied by these ways. <p> Both Iris <ref> [FBC + 90] </ref> and CQL++ [DGJ92] provide names called instance variables and object variables, respectively. However, their names cannot be persistently stored in the database, which means they cannot be used to identify frequently used objects. <p> For explicit specification, insert uses the keyword instance, followed by the list of related objects in parentheses. Like Iris <ref> [FBC + 90] </ref>, we have extended insert to allow multiple object insertions in one statement and we allow the objects to be named when they are created. Each instance is followed by an optional naming clause.
Reference: [HK87] <author> R. Hull and R. King. </author> <title> Semantic Database Modeling: Survey, Applications, and Research Issues. </title> <journal> ACM Computing Surveys, </journal> <volume> 19(3) </volume> <pages> 201-260, </pages> <month> September </month> <year> 1987. </year>
Reference-contexts: indexed-set class.) Each element in the keyset uniquely identifies an element in the indexed-set. 1 In Figure 1, Plant community is a set class, and serves as the keyset for Vegetation temperatures, which is an indexed-set class. 2.2 Object relationships in Moose Like many other semantic and OO data models <ref> [HK87, BCG + 87, CDV88, Deu90, ISK + 93, NO92, SKL88] </ref>, Moose provides two major categories of relationships between classes: connection relationships and inheritance relationships. 2 A connection relationship between two classes implies a logical or physical relationship between their object instances.
Reference: [HM81] <author> M. Hammer and D. McLeod. </author> <title> Database Description with SDM: A Semantic Database Model. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 6(3) </volume> <pages> 351-386, </pages> <month> September </month> <year> 1981. </year>
Reference-contexts: Finally, if changing the target object is only permitted until the scientist explicitly freezes it, the relationship is step-immutable in that direction. When an object is frozen, immutability propagates recursively to all its step-immutable structural relationships. Mutability was introduced by SDM <ref> [HM81] </ref> and exists in Jasmine [ISK + 93]; Moose is the first model to introduce step-immutability as an option. Immutable relationships are important because they can prevent the accidental deletion of data. <p> If the path expression traverses multiple set-of 11 relationships, then the effect is that of unioning the innermost collection elements <ref> [BNPS92, KKS92, HM81] </ref>. If two path expressions begin with the same prefix, then they are implicitly joined by their common prefix when they are evaluated. A complete path expression to an inherited relationship (such as the name relationship of the Student class) always traverses the inheritance relationships involved.
Reference: [IL89] <author> Y. Ioannidis and M. Livny. Moose: </author> <title> Modeling Objects in a Simulation Environment. </title> <booktitle> In Proc. IFIP 1989, 11th World Computer Congress, </booktitle> <pages> pages 821-826, </pages> <address> San Francisco, CA, </address> <month> August </month> <year> 1989. </year>
Reference-contexts: In this paper, we briefly describe the salient features of Moose and then focus on the most interesting aspects of Fox. More details on Moose and Fox are available elsewhere [WI93], as are descriptions of earlier versions of Moose <ref> [IL89, IL92] </ref>. Several characteristics of the data expected to be found in scientific experiments and of the ways scientists are expected to interact with an EMS led us to develop Moose and Fox.
Reference: [IL92] <author> Y. Ioannidis and M. Livny. </author> <title> Conceptual Schemas: Multi-Faceted Tools for Desktop Scientific Experiment Management. </title> <journal> International Journal of Intelligent and Cooperative Information Systems, </journal> <volume> 1(3) </volume> <pages> 451-474, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: We are currently involved in the development of a desktop Experiment Management System (EMS), whose primary goal is to support individual (or small teams of) scientists in managing their experimental studies and the data that are generated from them <ref> [IL92, ILH + 93] </ref>. As one of its components, the EMS under development includes an Object-Oriented Database Management System (OO-DBMS). <p> In this paper, we briefly describe the salient features of Moose and then focus on the most interesting aspects of Fox. More details on Moose and Fox are available elsewhere [WI93], as are descriptions of earlier versions of Moose <ref> [IL89, IL92] </ref>. Several characteristics of the data expected to be found in scientific experiments and of the ways scientists are expected to interact with an EMS led us to develop Moose and Fox.
Reference: [ILH + 93] <author> Y. Ioannidis, M. Livny, E. Haber, R. Miller, O. Tsatalos, and J. Wiener. </author> <title> Desktop Experiment Management. </title> <journal> IEEE Data Engineering Bulletin, </journal> <volume> 16(1) </volume> <pages> 19-23, </pages> <month> March </month> <year> 1993. </year>
Reference-contexts: We are currently involved in the development of a desktop Experiment Management System (EMS), whose primary goal is to support individual (or small teams of) scientists in managing their experimental studies and the data that are generated from them <ref> [IL92, ILH + 93] </ref>. As one of its components, the EMS under development includes an Object-Oriented Database Management System (OO-DBMS).
Reference: [ISK + 93] <author> H. Ishikawa, F. Suzuki, F. Kozakura, A. Makinouchi, M. Miyagishima, Y. Izumida, M. Aoshima, and Y. Yamane. </author> <title> The Model, Language, and Implementation of an Object-Oriented Multimedia Knowledge Base Management System. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 18(1) </volume> <pages> 1-50, </pages> <month> March </month> <year> 1993. </year>
Reference-contexts: indexed-set class.) Each element in the keyset uniquely identifies an element in the indexed-set. 1 In Figure 1, Plant community is a set class, and serves as the keyset for Vegetation temperatures, which is an indexed-set class. 2.2 Object relationships in Moose Like many other semantic and OO data models <ref> [HK87, BCG + 87, CDV88, Deu90, ISK + 93, NO92, SKL88] </ref>, Moose provides two major categories of relationships between classes: connection relationships and inheritance relationships. 2 A connection relationship between two classes implies a logical or physical relationship between their object instances. <p> Finally, if changing the target object is only permitted until the scientist explicitly freezes it, the relationship is step-immutable in that direction. When an object is frozen, immutability propagates recursively to all its step-immutable structural relationships. Mutability was introduced by SDM [HM81] and exists in Jasmine <ref> [ISK + 93] </ref>; Moose is the first model to introduce step-immutability as an option. Immutable relationships are important because they can prevent the accidental deletion of data. <p> In Moose, an existence dependency can occur in either direction of any connection relationship. This is in contrast to other models that support such constraints, e.g., Orion [BCG + 87], Extra/Excess [CDV88], and Jasmine <ref> [ISK + 93] </ref>, where existence dependency semantics are only attached to (specified) structural relationships, and only in the dominant direction. Existence dependencies among objects are not expressed as separate properties in Moose; they are determined by the properties of mutability and null permissions.
Reference: [KC86] <author> S. Khoshafian and G. Copeland. </author> <title> Object Identity. </title> <booktitle> In Proceedings the International Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 406-416, </pages> <year> 1986. </year>
Reference-contexts: We conclude in Section 6. 2 The Moose Data Model Moose is an OO data model that supports complex objects, object identity, classes, and (multiple) inheritance. In Moose, real world entities are modeled by objects with unique object identifiers (OIDs) <ref> [KC86] </ref>. Objects are grouped together by uniquely named classes, which capture the objects' common properties. Every class maintains a class extent, stored in the database, to allow subobjects to exist independently of top level objects.
Reference: [Kim89] <author> W. Kim. </author> <title> A Model of Queries for Object-Oriented Databases. </title> <booktitle> In Proceedings of the International Conference on Very Large Data Bases, </booktitle> <pages> pages 423-432, </pages> <address> Amsterdam, The Netherlands, </address> <year> 1989. </year>
Reference-contexts: There are several other declarative query languages that have been proposed for OO data models, namely O2query [BCD89], Extra/Excess [CDV88], CQL++ [DGJ92], COQL [NO92], OQL [ASL89], IQL [AK89], XSQL [KKS92], Ontos's OSQL [Ont92], and the Orion query language <ref> [Kim89] </ref>, as well as the Equal query algebra [SZ89]. Fox differs from them in several aspects.
Reference: [KKS92] <author> M. Kifer, W. Kim, and Y. Sagiv. </author> <title> Querying Object-Oriented Databases. </title> <editor> In M. Stonebreaker, editor, </editor> <booktitle> Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 393-402, </pages> <address> San Diego, CA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: There are several other declarative query languages that have been proposed for OO data models, namely O2query [BCD89], Extra/Excess [CDV88], CQL++ [DGJ92], COQL [NO92], OQL [ASL89], IQL [AK89], XSQL <ref> [KKS92] </ref>, Ontos's OSQL [Ont92], and the Orion query language [Kim89], as well as the Equal query algebra [SZ89]. Fox differs from them in several aspects. <p> If the path expression traverses multiple set-of 11 relationships, then the effect is that of unioning the innermost collection elements <ref> [BNPS92, KKS92, HM81] </ref>. If two path expressions begin with the same prefix, then they are implicitly joined by their common prefix when they are evaluated. A complete path expression to an inherited relationship (such as the name relationship of the Student class) always traverses the inheritance relationships involved. <p> Fox also provides comparison operators for comparing scalars to collections and collections to collections by membership. All membership tests are by object identity. In addition to the operators provided by other languages <ref> [KKS92, BNPS92] </ref>, Fox adds the disjoint and overlaps operators for comparing two collections (although they may be simulated using set intersection and an (in)equality comparison with the empty set). Collection objects may also be combined with set-theoretic union, intersection, and difference, and additive union [VD91]. <p> written specifically for Experiment, a different function would be necessary for each class, since the other models do not distinguish structural relationships. (Even if a model did distinguish structural relationships, we know of no way to test whether a relationship is structural or not, inside a user-defined function.) 5 XSQL <ref> [KKS92] </ref> provides a simple syntax for expressing the join in the path expression, although it still requires the extra object variable. 16 5 Data Modification Fox's data modification statements are closely integrated with its query language.
Reference: [Las93] <author> Y. Lashkari. </author> <title> Domain Independent Disambiguation of Vague Query Specifications. </title> <type> Technical Report 1181, </type> <institution> Department of Computer Sciences, University of Wisconsin-Madison, </institution> <month> October </month> <year> 1993. </year> <type> Master's Thesis. </type>
Reference-contexts: Second, incompletely specified path expressions in the query language may be disambiguated based on the differences in the two types of relationships <ref> [Las93] </ref>. * Scientists often need to represent collections that are indexed by other, arbitrary, collections, e.g., indexed by time series. Arrays (indexed by the set of consecutive integers f1; : : :; ng, for some n) are the only special case of indexed collections supported by existing OO data models. <p> Path compression techniques may be used to permit the specification of incomplete paths. That is, PA.salary may be expanded by the system to PA@Staff member.salary. We are investigating ways of efficiently determining the correct complete path, since there may be more than one possible completion <ref> [Las93] </ref>. 4.1.3 Object retrieval (select clause) Fox supports query results that include arbitrary projections on objects and arbitrary joins between objects, which frequently lead to new objects being created by the query.
Reference: [LLOW91] <author> C. Lamb, G. Landis, J. Orenstein, and D. Weinreb. </author> <title> The ObjectStore Database System. </title> <journal> Communications of the ACM, </journal> <volume> 34(10) </volume> <pages> 50-63, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: OQL "contexts" [ASL89] are similar to Fox path expressions and can indicate paths through any relationships. However, OQL contexts are only used to restrict the results (which are sub-databases) and do not directly evaluate to objects. In some OO models, such as ObjectStore <ref> [LLOW91] </ref>, Versant [Ver91], and Objectivity [Obj91], it is possible to define an inverse relationship, which can then be used to traverse the relationship "in reverse." However, these inverse relationships must be explicitly declared.
Reference: [MF91] <author> G. Miller and C. Fellbaum. </author> <title> Semantic Networks of English. </title> <journal> Cognition, </journal> <volume> 41(1-3):197-229, </volume> <year> 1991. </year>
Reference-contexts: Such distinction captures the semantics of experiments, or any other type of information, more naturally <ref> [MF91, WCH87] </ref>. The additional semantics expressed by this distinction can be used in several ways. First, the structural components of a complex object may be seen as defining its scope, which determines certain properties of the object.
Reference: [NO92] <author> M. Nabil and S. L. Osborn. COQL: </author> <title> A Query Language for an Object-Oriented Database System. </title> <type> Unpublished manuscript, </type> <month> May </month> <year> 1992. </year>
Reference-contexts: These needs include the following: * Scientists need to access experimental data in ad-hoc ways. Most current OO query languages impose restrictions on how object relationships may be traversed in query path expressions, for instance, only allowing traversal in one direction <ref> [BCG + 87, CDV88, DGJ92, FBC + 90, NO92] </ref>. This restriction is too strict for queries in an EMS environment, because it forces scientists to start most queries with the root of the schema graph. Fox allows arbitrary path expressions that may traverse all types of relationships in both directions. <p> indexed-set class.) Each element in the keyset uniquely identifies an element in the indexed-set. 1 In Figure 1, Plant community is a set class, and serves as the keyset for Vegetation temperatures, which is an indexed-set class. 2.2 Object relationships in Moose Like many other semantic and OO data models <ref> [HK87, BCG + 87, CDV88, Deu90, ISK + 93, NO92, SKL88] </ref>, Moose provides two major categories of relationships between classes: connection relationships and inheritance relationships. 2 A connection relationship between two classes implies a logical or physical relationship between their object instances. <p> There are several other declarative query languages that have been proposed for OO data models, namely O2query [BCD89], Extra/Excess [CDV88], CQL++ [DGJ92], COQL <ref> [NO92] </ref>, OQL [ASL89], IQL [AK89], XSQL [KKS92], Ontos's OSQL [Ont92], and the Orion query language [Kim89], as well as the Equal query algebra [SZ89]. Fox differs from them in several aspects. <p> Fox allows the names to be created in the query language, as well as to be accessible from it. COQL <ref> [NO92] </ref> provides a similar feature. 4.1.2 Object variables and path expressions In the for clause of Fox, object variables may be bound to the members of class extents or collection objects described by path expressions. <p> Similar constructs include the in Daplex [Shi81] (from which we adopted the keyword), the element function in O2query [BCD89], and the member message in COQL <ref> [NO92] </ref>. Fox introduces any. We expect any to be used frequently when more than one object may satisfy the where clause qualification, but any such object is acceptable.
Reference: [Obj91] <institution> Objectivity, Inc. </institution> <note> Objectivity/DB Documentation Vol. 1, </note> <year> 1991. </year>
Reference-contexts: OQL "contexts" [ASL89] are similar to Fox path expressions and can indicate paths through any relationships. However, OQL contexts are only used to restrict the results (which are sub-databases) and do not directly evaluate to objects. In some OO models, such as ObjectStore [LLOW91], Versant [Ver91], and Objectivity <ref> [Obj91] </ref>, it is possible to define an inverse relationship, which can then be used to traverse the relationship "in reverse." However, these inverse relationships must be explicitly declared.
Reference: [Ont92] <author> Ontos. </author> <title> Ontos Object SQL Guide, </title> <address> 2.2 edition, </address> <month> February </month> <year> 1992. </year>
Reference-contexts: There are several other declarative query languages that have been proposed for OO data models, namely O2query [BCD89], Extra/Excess [CDV88], CQL++ [DGJ92], COQL [NO92], OQL [ASL89], IQL [AK89], XSQL [KKS92], Ontos's OSQL <ref> [Ont92] </ref>, and the Orion query language [Kim89], as well as the Equal query algebra [SZ89]. Fox differs from them in several aspects. <p> allow only the retrieval of existing objects from their declarative query languages, not the creation of new ones. (In order to create new objects in these systems, the programming language must be invoked.) For example, Orion's query language only returns the OIDs of existing objects [BKK88], Ontos's OSQL returns relations <ref> [Ont92] </ref>, and O2query results are values (not objects) [BCD89]. Fox allows the user to explicitly specify the structure of the result of a query. The select clause specifies not only what to retrieve, but also exactly what the resulting objects should look like.
Reference: [PG88] <author> N. W. Paton and P. M. D. Gray. </author> <title> Identification of Database Objects by Key. </title> <editor> In K. R. Dittrich, editor, </editor> <booktitle> Advances in Object-Oriented Database Systems: 2nd International Workshop on Object-Oriented Database Systems, </booktitle> <pages> pages 280-285, </pages> <address> Berlin, Germany, </address> <month> September </month> <year> 1988. </year> <note> Springer-Verlag. </note>
Reference-contexts: We address the problem in Moose by allowing the user to generate surrogate OIDs for the objects. One of the relationships of the objects may be used as a surrogate OID if it uniquely identifies objects <ref> [PG88] </ref>; otherwise an arbitrary identifier may be used, e.g., meaningful strings or integers automatically generated by a counter in the program generating the data.
Reference: [RKB87] <author> M. A. Roth, H. F. Korth, and D. S. Batory. SQL/NF: </author> <title> A Query Language for :1NF Relational Databases. </title> <journal> Information Systems, </journal> <volume> 12(1) </volume> <pages> 99-114, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: The effects of grouping can be accomplished with subqueries that include a join on the grouping attributes [DW89]. Aggregate functions, which are expressed in an unintuitive manner in SQL, operate on a subquery in Fox. This more intuitive syntax was first proposed for SQL/NF <ref> [RKB87] </ref>. Group qualifications are expressed in the where clause for the query, instead of in a having clause.
Reference: [Shi81] <author> D. W. Shipman. </author> <title> The Functional Data Model and the Data Language DAPLEX. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 6(1) </volume> <pages> 140-173, </pages> <month> March </month> <year> 1981. </year>
Reference-contexts: The scope of the object variable bindings includes all subqueries that do not rebind the variable, as well the select and where clauses. Fox's object variables are similar to tuple variables in SQL [DW89], iteration variables in Orion [BKK88], reference variables in Daplex <ref> [Shi81] </ref>, and range variables in CQL++ [DGJ92]. The names of all named objects used in the query must also appear in the for clause. <p> The any keyword chooses an element at random. We expect the to be used most often when the for clause indicates iteration, and hence a multiset result, but the where clause qualification restricts the multiset to a single element. Similar constructs include the in Daplex <ref> [Shi81] </ref> (from which we adopted the keyword), the element function in O2query [BCD89], and the member message in COQL [NO92]. Fox introduces any. We expect any to be used frequently when more than one object may satisfy the where clause qualification, but any such object is acceptable.
Reference: [SKL88] <author> S. Su, V. Krishnamurthy, and H. Lam. </author> <title> An Object-oriented Semantic Association Model (OSAM). </title> <editor> In S. Kumara, A. L. Soyster, and R. L. Kashyap, editors, </editor> <booktitle> A.I. in Industrial Engineering and Manufacturing: Theoretical Issues and Applications, chapter 17, </booktitle> <pages> pages 463-494. </pages> <institution> American Institute of Industrial Engineering, </institution> <year> 1988. </year> <month> 21 </month>
Reference-contexts: indexed-set class.) Each element in the keyset uniquely identifies an element in the indexed-set. 1 In Figure 1, Plant community is a set class, and serves as the keyset for Vegetation temperatures, which is an indexed-set class. 2.2 Object relationships in Moose Like many other semantic and OO data models <ref> [HK87, BCG + 87, CDV88, Deu90, ISK + 93, NO92, SKL88] </ref>, Moose provides two major categories of relationships between classes: connection relationships and inheritance relationships. 2 A connection relationship between two classes implies a logical or physical relationship between their object instances. <p> A keyset element is used in the same way to retrieve an indexed-set element, e.g., my iset [my key elt]. 2 Connection relationships are related to aggregation relationships proposed in other semantic and OO data models <ref> [SS77, SKL88] </ref>. Not all connection relationships, however, represent aggregations of simpler to more complex objects, hence the different term. 4 interpretations and any constraints on the kinds of the corresponding source and target classes.
Reference: [SS77] <author> J. M. Smith and D. C. P. Smith. </author> <title> Database abstractions: Aggregation and generalization. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 2(2) </volume> <pages> 105-133, </pages> <month> June </month> <year> 1977. </year>
Reference-contexts: A keyset element is used in the same way to retrieve an indexed-set element, e.g., my iset [my key elt]. 2 Connection relationships are related to aggregation relationships proposed in other semantic and OO data models <ref> [SS77, SKL88] </ref>. Not all connection relationships, however, represent aggregations of simpler to more complex objects, hence the different term. 4 interpretations and any constraints on the kinds of the corresponding source and target classes.
Reference: [SZ89] <author> G. M. Shaw and S. B. Zdonik. </author> <title> An Object-Oriented Query Algebra. </title> <editor> In R. Hull, R. Morrison, and D. Stemple, editors, </editor> <booktitle> Proceedings of the International Workshop on Database Programming Languages, </booktitle> <pages> pages 103-112, </pages> <address> San Mateo, CA, 1989. Morgan-Kaufman, </address> <publisher> Inc. </publisher>
Reference-contexts: The user could then create a derived subclass of Plant community, Homogeneous community (also shown in Figure 1), to keep closer track of those communities and the experiments that use them. Encore <ref> [SZ89] </ref> supports derived subclasses whose rule is a predicate. 3 The Data Definition Language of Moose A Moose schema is composed of classes and relationships between classes. The data definition language provides statements to create and destroy both classes and relationships, and to relabel existing relationships between classes. <p> There are several other declarative query languages that have been proposed for OO data models, namely O2query [BCD89], Extra/Excess [CDV88], CQL++ [DGJ92], COQL [NO92], OQL [ASL89], IQL [AK89], XSQL [KKS92], Ontos's OSQL [Ont92], and the Orion query language [Kim89], as well as the Equal query algebra <ref> [SZ89] </ref>. Fox differs from them in several aspects. <p> Fox supports object comparisons by identity, shallow equality, and deep equality, using the operators is, =, and ==, respectively. We extend earlier definitions of shallow and deep equality <ref> [BNPS92, SZ89] </ref> to differentiate a complex object from its associations: only the has-part, set-of, and keyset relationships of the objects are compared, directly for shallow equality and recursively for deep equality. Fox also provides comparison operators for comparing scalars to collections and collections to collections by membership.
Reference: [VD91] <author> S.L. Vandenberg and D.J. DeWitt. </author> <title> Algebraic Support for Complex Objects with Arrays, Identity and Inheritance. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 158-167, </pages> <address> Denver, CO, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: Collection objects may also be combined with set-theoretic union, intersection, and difference, and additive union <ref> [VD91] </ref>. Note that shallow equality for collection objects is the same as a membership test for equality.
Reference: [Ver91] <institution> Versant Object Technology. </institution> <note> VERSANT System Reference Manual, Release 1.6, </note> <year> 1991. </year>
Reference-contexts: OQL "contexts" [ASL89] are similar to Fox path expressions and can indicate paths through any relationships. However, OQL contexts are only used to restrict the results (which are sub-databases) and do not directly evaluate to objects. In some OO models, such as ObjectStore [LLOW91], Versant <ref> [Ver91] </ref>, and Objectivity [Obj91], it is possible to define an inverse relationship, which can then be used to traverse the relationship "in reverse." However, these inverse relationships must be explicitly declared.
Reference: [WCH87] <author> M. Winston, R. Chaffin, and D. Herrmann. </author> <title> A Taxonomy of Part-Whole Relations. </title> <journal> Cognitive Science, </journal> <volume> 11 </volume> <pages> 417-444, </pages> <year> 1987. </year>
Reference-contexts: Such distinction captures the semantics of experiments, or any other type of information, more naturally <ref> [MF91, WCH87] </ref>. The additional semantics expressed by this distinction can be used in several ways. First, the structural components of a complex object may be seen as defining its scope, which determines certain properties of the object.
Reference: [WI93] <author> J. L. Wiener and Y. Ioannidis. </author> <title> A Moose and a Fox Can Aid Scientists with Data Management Problems. </title> <type> Technical Report 1182, </type> <institution> Department of Computer Sciences, University of Wisconsin-Madison, </institution> <month> October </month> <year> 1993. </year>
Reference-contexts: In this paper, we briefly describe the salient features of Moose and then focus on the most interesting aspects of Fox. More details on Moose and Fox are available elsewhere <ref> [WI93] </ref>, as are descriptions of earlier versions of Moose [IL89, IL92]. Several characteristics of the data expected to be found in scientific experiments and of the ways scientists are expected to interact with an EMS led us to develop Moose and Fox.
Reference: [Zan83] <author> C. Zaniolo. </author> <title> The Database Language GEM. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 207-218, </pages> <address> San Jose, CA, </address> <month> May </month> <year> 1983. </year> <month> 22 </month>
Reference-contexts: Otherwise, a null target object is allowed. This is a generic object that is potentially a member of all classes. Such an object in Moose corresponds to the "does not exist" null defined in GEM <ref> [Zan83] </ref>, meaning that for a given source object the relationship currently has no target object in that direction. Null target objects may support the creation of subobjects before their parent objects by allowing the subobject to have a null parent.
References-found: 41

