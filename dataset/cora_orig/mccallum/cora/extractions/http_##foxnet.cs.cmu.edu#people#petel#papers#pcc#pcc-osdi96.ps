URL: http://foxnet.cs.cmu.edu/people/petel/papers/pcc/pcc-osdi96.ps
Refering-URL: http://foxnet.cs.cmu.edu/people/petel/papers/pcc/pcc.html
Root-URL: 
Email: fnecula,petelg@cs.cmu.edu  
Title: Safe Kernel Extensions Without Run-Time Checking  
Author: George C. Necula Peter Lee 
Date: October 28-31, 1996.  
Note: This research was sponsored in part by the Advanced Research Projects Agency CSTO under the title "The Fox Project: Advanced Languages for Systems Software," ARPA Order No. C533, issued by ESC/ENS under Contract No. F19628-95-C-0050. The views and conclusions contained in this document are those of the authors and should not be interpreted as representing the official policies, either expressed or implied, of the Advanced Research Projects Agency or the U.S. Government. To appear at the Second Symposium on Operating Systems Design and Implementation (OSDI '96), Seattle, Washington,  
Address: Pittsburgh, Pennsylvania 15213-3891  
Affiliation: School of Computer Science Carnegie Mellon University  
Abstract: This paper describes a mechanism by which an operating system kernel can determine with certainty that it is safe to execute a binary supplied by an untrusted source. The kernel first defines a safety policy and makes it public. Then, using this policy, an application can provide binaries in a special form called proof-carrying code, or simply PCC. Each PCC binary contains, in addition to the native code, a formal proof that the code obeys the safety policy. The kernel can easily validate the proof without using cryptography and without consulting any external trusted entities. If the validation succeeds, the code is guaranteed to respect the safety policy without relying on run-time checks. The main practical difficulty of PCC is in generating the safety proofs. In order to gain some preliminary experience with this, we have written several network packet filters in hand-tuned DEC Alpha assembly language, and then generated PCC binaries for them using a special prototype assembler. The PCC binaries can be executed with no run-time overhead, beyond a one-time cost of 1 to 3 milliseconds for validating the enclosed proofs. The net result is that our packet filters are formally guaranteed to be safe and are faster than packet filters created using Berkeley Packet Filters, Software Fault Isolation, or safe languages such as Modula-3. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Bershad, B., Savage, S., Pardyak, P., Sirer, E. G., Becker, D., Fiuczynski, M., Chambers, C., and Eggers, S. </author> <title> Extensibility, safety and performance in the SPIN operating system. </title> <booktitle> In Symposium on Operating System Principles (Dec. </booktitle> <year> 1995), </year> <pages> pp. 267-284. </pages>
Reference-contexts: In particular, we show that PCC leads to faster and safer packet filters than previous approaches to code safety in systems software, including Berkeley Packet Filters [12], Software Fault Isolation [23], and programming in the safe subset of Modula-3 <ref> [1, 9, 17] </ref>. Finally, we conclude with a discussion of the remaining difficulties and speculate on what might be necessary to make the approach work on a practical scale. 2 Proof-Carrying Code a PCC binary. The process begins with the code consumer defining and publicizing a safety policy. <p> Proof sizes and validation times are very similar to those for plain PCC packets. Another approach to safe code is to use a type-safe programming language. This approach is taken by the SPIN extensible operating system <ref> [1] </ref>, and the language used is Modula-3 [17] extended with pointer-safe casting (VIEW). SPIN allows applications to install extensions in the kernel but only if they are written in the safe subset of Modula-3.
Reference: [2] <author> Boyer, R. S., and Yu, Y. </author> <title> Automated proofs of object code for a widely used microprocessor. </title> <journal> J. ACM 43, </journal> <month> 1 (Jan. </month> <year> 1996), </year> <pages> 166-192. </pages>
Reference-contexts: Standard techniques exist for building such proofs. Our technique is based on Floyd's verification conditions [6], because they are powerful enough to deal with unstructured assembly-language programs and a broad range of safety invariants. Similar techniques have been used before to verify assembly-language programs <ref> [2, 3] </ref>. Certification of programs involves two steps: 1. Compute the safety predicate for the program. This essentially encodes the semantic meaning of the program in logical form and constitutes a formal statement that the program, when executed, will not violate any safety checks. 2.
Reference: [3] <author> Clutterbuck, D., and Carr e, B. </author> <title> The ver ification of low-level code. </title> <journal> IEEE Software Engineering Journal 3, </journal> <month> 3 (May </month> <year> 1988), </year> <pages> 97-111. </pages>
Reference-contexts: Standard techniques exist for building such proofs. Our technique is based on Floyd's verification conditions [6], because they are powerful enough to deal with unstructured assembly-language programs and a broad range of safety invariants. Similar techniques have been used before to verify assembly-language programs <ref> [2, 3] </ref>. Certification of programs involves two steps: 1. Compute the safety predicate for the program. This essentially encodes the semantic meaning of the program in logical form and constitutes a formal statement that the program, when executed, will not violate any safety checks. 2.
Reference: [4] <author> Constable, R. L., Allen, S. F., Bromley, H. M., Cleaveland, W. R., Cremer, J. F., Harper, R. W., Howe, D. J., Knoblock, T. B., Mendler, N. P., Panangaden, P., Sasaki, J. T., and Smith, S. F. </author> <title> Implementing Mathematics with the Nuprl Proof Development System. </title> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference-contexts: Although we have worked out many of the theoretical underpinnings for PCC (and indeed, most of the theory is based on old and well-known principles from logic, type theory <ref> [4, 11] </ref>, and formal verification [5, 6, 8]), there are many difficult problems that remain to be solved. In particular we do not know at this point the most practical way to generate the proofs.
Reference: [5] <author> Dijkstra, E. W. </author> <title> Guarded commands, nonde terminancy and formal derivation of programs. </title> <booktitle> Communications of the ACM 18 (1975), </booktitle> <pages> 453-457. </pages>
Reference-contexts: Although we have worked out many of the theoretical underpinnings for PCC (and indeed, most of the theory is based on old and well-known principles from logic, type theory [4, 11], and formal verification <ref> [5, 6, 8] </ref>), there are many difficult problems that remain to be solved. In particular we do not know at this point the most practical way to generate the proofs. <p> One of the simplifications in the packet filters is to restrict programs so that they do not contain loops. Although the general framework presented in this paper is easily extended to accommodate loops <ref> [5] </ref>, this introduces a number of complications. One experiment we conducted involves an IP-header checksum routine, which is hand-coded in 39 DEC Alpha instructions. The core loop contains 8 instructions, and is optimized by computing the 16-bit IP checksum using 64-bit additions followed by a folding operation.
Reference: [6] <author> Floyd, R. W. </author> <title> Assigning meanings to pro grams. </title> <booktitle> In Mathematical Aspects of Computer Science, </booktitle> <editor> J. T. Schwartz, Ed. </editor> <publisher> American Mathematical Society, </publisher> <year> 1967, </year> <pages> pp. 19-32. </pages>
Reference-contexts: Although we have worked out many of the theoretical underpinnings for PCC (and indeed, most of the theory is based on old and well-known principles from logic, type theory [4, 11], and formal verification <ref> [5, 6, 8] </ref>), there are many difficult problems that remain to be solved. In particular we do not know at this point the most practical way to generate the proofs. <p> We do this by specifying a safety policy in three parts: 1. A Floyd-style verification-condition generator (also referred to as the VC generator) <ref> [6] </ref>, which is a procedure that computes a predicate in first-order logic based on the code to be certified. We will refer to this predicate as the safety predicate. 2. A set of axioms that can be used to validate the safety predicate. 3. <p> Standard techniques exist for building such proofs. Our technique is based on Floyd's verification conditions <ref> [6] </ref>, because they are powerful enough to deal with unstructured assembly-language programs and a broad range of safety invariants. Similar techniques have been used before to verify assembly-language programs [2, 3]. Certification of programs involves two steps: 1. Compute the safety predicate for the program.
Reference: [7] <author> Harper, R., Honsell, F., and Plotkin, G. </author> <title> A framework for defining logics. </title> <journal> Journal of the Association for Computing Machinery 40, </journal> <month> 1 (Jan. </month> <year> 1993), </year> <pages> 143-184. </pages>
Reference-contexts: To automate the validation process, we must first choose a concrete representation language for predicates and their proofs. From the many available choices, we have selected the Edinburgh Logical Framework <ref> [7] </ref> (also called LF) as the representation framework for predicates and proofs. LF is an extension of the simply typed lambda calculus and was designed as a meta language for high-level specification of languages in logic and computer science.
Reference: [8] <author> Hoare, C. A. R. </author> <title> An axiomatic basis for com puter programming. </title> <booktitle> Communications of the ACM 12 (1969), </booktitle> <pages> 567-580. </pages>
Reference-contexts: Although we have worked out many of the theoretical underpinnings for PCC (and indeed, most of the theory is based on old and well-known principles from logic, type theory [4, 11], and formal verification <ref> [5, 6, 8] </ref>), there are many difficult problems that remain to be solved. In particular we do not know at this point the most practical way to generate the proofs.
Reference: [9] <author> Hsieh, W. C., Fiuczynski, M. E., Gar rett, C., Savage, S., Becker, D., and Bershad, B. N. </author> <title> Language support for extensible operating systems. </title> <booktitle> In The Inaugural Workshop on Compiler Support for Systems Software (Feb. </booktitle> <year> 1996), </year> <pages> pp. 127-133. </pages>
Reference-contexts: In particular, we show that PCC leads to faster and safer packet filters than previous approaches to code safety in systems software, including Berkeley Packet Filters [12], Software Fault Isolation [23], and programming in the safe subset of Modula-3 <ref> [1, 9, 17] </ref>. Finally, we conclude with a discussion of the remaining difficulties and speculate on what might be necessary to make the approach work on a practical scale. 2 Proof-Carrying Code a PCC binary. The process begins with the code consumer defining and publicizing a safety policy. <p> In our experiments with Modula-3 packet filters we use the VIEW extension <ref> [9] </ref> for pointer-safe casting. The result of the measurements are shown in Figure 8. From a per-packet latency point of view, the PCC packet filters outperform filters developed using any other considered approach. However, the PCC method has a startup cost significantly larger than the other approaches.
Reference: [10] <author> Lee, P., and Leone, M. </author> <title> Optimizing ML with run-time code generation. </title> <booktitle> In PLDI'96 Conference on Programming Language Design and Implementation (May 1996), </booktitle> <pages> pp. 137-148. </pages>
Reference-contexts: It is possible, of course, to eliminate the need for interpretation. For example, we could replace the packet-filter interpreter with a compiler. This approach is taken by several researchers <ref> [10, 24] </ref>. The problem here is the startup cost and complexity of compilation, especially if serious optimizations are performed. Another approach to safe code execution is Software Fault Isolation (SFI) [23]. SFI is an inexpensive method for parsing binaries and inserting run-time checks on memory operations.
Reference: [11] <author> Martin-L of, P. </author> <title> A theory of types. </title> <type> Techni cal Report 71-3, </type> <institution> Department of Mathematics, University of Stockholm, </institution> <year> 1971. </year>
Reference-contexts: Although we have worked out many of the theoretical underpinnings for PCC (and indeed, most of the theory is based on old and well-known principles from logic, type theory <ref> [4, 11] </ref>, and formal verification [5, 6, 8]), there are many difficult problems that remain to be solved. In particular we do not know at this point the most practical way to generate the proofs.
Reference: [12] <author> McCanne, S. </author> <title> The Berkeley Packet Fil ter man page. </title> <note> BPF distribution available at ftp://ftp.ee.lbl.gov, </note> <month> May </month> <year> 1991. </year>
Reference-contexts: Still, automation of proof generation remains as one of the most serious obstacles to widespread practical application of PCC. In our main experiment, we implemented several network packet filters <ref> [12, 15] </ref> in DEC Alpha assembly language [19] and then used a special prototype assembler to create PCC binaries for them. <p> In particular, we show that PCC leads to faster and safer packet filters than previous approaches to code safety in systems software, including Berkeley Packet Filters <ref> [12] </ref>, Software Fault Isolation [23], and programming in the safe subset of Modula-3 [1, 9, 17]. Finally, we conclude with a discussion of the remaining difficulties and speculate on what might be necessary to make the approach work on a practical scale. 2 Proof-Carrying Code a PCC binary.
Reference: [13] <author> McCanne, S., and Jacobson, V. </author> <title> The BSD packet filter: A new architecture for user-level packet capture. </title> <booktitle> In The Winter 1993 USENIX Conference (Jan. 1993), USENIX Association, </booktitle> <pages> pp. 259-269. </pages>
Reference-contexts: The standard way to ensure safe execution of packet filters is to interpret the filter and perform extensive run-time checks. This approach is best exemplified by the BSD Packet Filter architecture <ref> [13] </ref>, commonly referred to as BPF. In the BPF approach the filter is encoded in a restricted accumulator-based language. According to the BPF semantics, a filter that attempts to read outside the packet or the scratch memory, or to write outside the scratch memory, is terminated and the packet rejected.
Reference: [14] <author> Milner, R., Tofte, M., and Harper, R. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: a few optimizations that we incorporated in our packet filters: * The number of memory operations is mini mized by using the DEC Alpha 64-bit load followed by byte extraction. * The TCP port number can be found at packet offset (<ref> [14] </ref> 8 & 15) fl 4 + 16, where [14] 8 denotes the byte at offset 14. If loading 64 bits at a time on a little-endian machine, the formula becomes ((([8] 64 48) & 255) & 15) fl 4 + 16. <p> In the formal definition of SML <ref> [14] </ref>, a formal theorem guarantees the safety of any type-correct SML program, for a rigorously defined notion of safety.
Reference: [15] <author> Mogul, J. C., Rashid, R. F., and Accetta, M. J. </author> <title> The packet filter: An efficient mechanism for user-level network code. </title> <booktitle> In ACM Symposium on Operating Systems Principles (Nov. 1987), </booktitle> <publisher> ACM Press, </publisher> <pages> pp. 39-51. </pages> <note> An updated version is available as DEC WRL Research Report 87/2. </note>
Reference-contexts: Still, automation of proof generation remains as one of the most serious obstacles to widespread practical application of PCC. In our main experiment, we implemented several network packet filters <ref> [12, 15] </ref> in DEC Alpha assembly language [19] and then used a special prototype assembler to create PCC binaries for them. <p> A packet filter is an application-provided subroutine that scans each incoming network packet and decides whether the user application is interested in receiving it or not. Packet filters are supported by most of today's workstation operating systems. Since their first introduction in <ref> [15] </ref>, packet filters have been used successfully in network monitoring and diagnosis. In the PCC approach the packet filter is a PCC binary whose native code component is invoked by the kernel on each incoming network packet. Kernel safety is ensured by validating the safety proof.
Reference: [16] <author> Necula, G. C., and Lee, P. </author> <title> Proof-carrying code. </title> <type> Technical Report CMU-CS-96-165, </type> <institution> Computer Science Department, Carnegie Mellon University, </institution> <month> Sept. </month> <year> 1996. </year> <note> Also appeared as FOX memorandum CMU-CS-FOX-96-03. </note>
Reference-contexts: We will thus attempt to explain only the basic technicalities and key intuitions here. Those readers who would like more details on the underlying theory can find them in a separate technical report <ref> [16] </ref>. <p> The proof of the Safety Theorem is beyond the scope of this paper, but can be found in a separate technical report <ref> [16] </ref>. 2.3 Validating the Safety Proofs A PCC binary consists of the assembled native code together with an encoding of the proof of its safety predicate. To validate the binary, the code consumer first extracts the native code and then computes its safety predicate using the VC rules.
Reference: [17] <author> Nelson, G. </author> <title> Systems Programming with MODULA-3. </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: In particular, we show that PCC leads to faster and safer packet filters than previous approaches to code safety in systems software, including Berkeley Packet Filters [12], Software Fault Isolation [23], and programming in the safe subset of Modula-3 <ref> [1, 9, 17] </ref>. Finally, we conclude with a discussion of the remaining difficulties and speculate on what might be necessary to make the approach work on a practical scale. 2 Proof-Carrying Code a PCC binary. The process begins with the code consumer defining and publicizing a safety policy. <p> Proof sizes and validation times are very similar to those for plain PCC packets. Another approach to safe code is to use a type-safe programming language. This approach is taken by the SPIN extensible operating system [1], and the language used is Modula-3 <ref> [17] </ref> extended with pointer-safe casting (VIEW). SPIN allows applications to install extensions in the kernel but only if they are written in the safe subset of Modula-3. <p> In the formal definition of SML [14], a formal theorem guarantees the safety of any type-correct SML program, for a rigorously defined notion of safety. There are, of course, many other type-safe programming languages, for example Modula-3 <ref> [17] </ref> and Java [20], but the use of mathematical formalism sets SML apart from the these languages, and as a practical matter this rigor provides the basic conceptual and technical foundations that we need to create checkable proofs.
Reference: [18] <author> Sirer, E. G., Savage, S., Pardyak, P., De Fouw, G. P., and Bershad, B. N. </author> <title> Writing an operating system with Modula-3. </title> <booktitle> In The Inaugural Workshop on Compiler Support for Systems Software (Feb. </booktitle> <year> 1996), </year> <pages> pp. 134-140. </pages>
Reference-contexts: We measured a 20% improvement in the Modula-3 packet filter performance when using VIEW. Similar performance improvements over the DEC SRC Modula-3 compiler have been reported <ref> [18] </ref> for the more recent Vortex compiler. However, since we have not conducted any experiments with the Vortex compiler on our packet filters, it is not clear what kind of improvements we would realize in practice.
Reference: [19] <author> Sites, R. L. </author> <title> Alpha Architecture Reference Manual. </title> <publisher> Digital Press, </publisher> <year> 1992. </year>
Reference-contexts: Still, automation of proof generation remains as one of the most serious obstacles to widespread practical application of PCC. In our main experiment, we implemented several network packet filters [12, 15] in DEC Alpha assembly language <ref> [19] </ref> and then used a special prototype assembler to create PCC binaries for them. We were motivated to use an unsafe assembly language in order to place equal emphasis on both performance and safety, as well as to demonstrate the generality of the PCC approach. <p> The VC generator and axioms will then be given in the next subsection. An abstract machine for memory-safe DEC Alpha machine code Because the experiments in this paper use the DEC Alpha assembly language, our abstract machine is essentially a high-level formal description of the Alpha architecture <ref> [19] </ref>.
Reference: [20] <author> Sun Microsystems. </author> <title> The Java language spec ification. </title> <note> Available as ftp://ftp.javasoft.com/docs/javaspec.ps.zip, </note> <year> 1995. </year>
Reference-contexts: In the formal definition of SML [14], a formal theorem guarantees the safety of any type-correct SML program, for a rigorously defined notion of safety. There are, of course, many other type-safe programming languages, for example Modula-3 [17] and Java <ref> [20] </ref>, but the use of mathematical formalism sets SML apart from the these languages, and as a practical matter this rigor provides the basic conceptual and technical foundations that we need to create checkable proofs.
Reference: [21] <author> Sun Microsystems. </author> <title> The Java Virtual Ma chine specification. </title> <note> Available as ftp://ftp.javasoft.com/docs/vmspec.ps.zip, </note> <year> 1995. </year>
Reference-contexts: Also, the cost of managing and transmitting encryption keys is not incurred by PCC. We should mention here one more approach to safe code execution, although we do not have an actual quantitative comparison. The Java Virtual Machine <ref> [21] </ref> is a proposed solution to safe interaction of distributed, untrusted agents. Mobile code is encoded in the Java Virtual Machine Language (also referred to as Java Bytecode), which is basically a safe low-level imperative language. Safety is achieved through a combination of static typecheck-ing and run-time checking.
Reference: [22] <author> Tarditi, D., Morrisett, J. G., Cheng, P., Stone, C., Harper, R., and Lee, P. </author> <title> TIL: A type-directed optimizing compiler for ML. </title> <booktitle> In PLDI'96 Conference on Programming Language Design and Implementation (May 1996), </booktitle> <pages> pp. 181-192. </pages>
Reference-contexts: In fact, this approach to compiling is taken by the SML/TIL compiler <ref> [22] </ref>. 14
Reference: [23] <author> Wahbe, R., Lucco, S., Anderson, T. E., and Graham, S. L. </author> <title> Efficient software-based 15 fault isolation. </title> <booktitle> In 14th ACM Symposium on Operating Systems Principles (Dec. 1993), ACM, </booktitle> <pages> pp. 203-216. </pages>
Reference-contexts: In particular, we show that PCC leads to faster and safer packet filters than previous approaches to code safety in systems software, including Berkeley Packet Filters [12], Software Fault Isolation <ref> [23] </ref>, and programming in the safe subset of Modula-3 [1, 9, 17]. Finally, we conclude with a discussion of the remaining difficulties and speculate on what might be necessary to make the approach work on a practical scale. 2 Proof-Carrying Code a PCC binary. <p> For example, we could replace the packet-filter interpreter with a compiler. This approach is taken by several researchers [10, 24]. The problem here is the startup cost and complexity of compilation, especially if serious optimizations are performed. Another approach to safe code execution is Software Fault Isolation (SFI) <ref> [23] </ref>. SFI is an inexpensive method for parsing binaries and inserting run-time checks on memory operations. There are many flavors of SFI depending on the desired level of memory safety. <p> If, on the other hand, the untrusted code interacts frequently with the code consumer or other untrusted components residing in different protection domains and the read operations must be checked also, the overhead of the run-time checks can amount to 20% <ref> [23] </ref>. A more serious disadvantage of SFI is that it can only ensure memory safety. <p> In this case, the code consumer performs a load-time checking that SFI was done correctly. The load-time SFI validator is reportedly simple if it must deal only with binaries for which run-time checks have been inserted on every potentially dangerous memory operation <ref> [23] </ref>. On the other hand, in the case where the validator must accept binaries for which the number of run-time checks has been optimized through program analysis, the validator itself has to redo the analysis that led to the optimization.
Reference: [24] <author> Wallach, D. A., Engler, D., and Kaashoek, M. F. </author> <title> ASHs : Application-specific handlers for high-performance messaging. </title> <booktitle> In ACM SIGCOMM'96 (Oct. 1996), </booktitle> <volume> vol. 26, </volume> <booktitle> ACM. </booktitle> <pages> 16 </pages>
Reference-contexts: It is possible, of course, to eliminate the need for interpretation. For example, we could replace the packet-filter interpreter with a compiler. This approach is taken by several researchers <ref> [10, 24] </ref>. The problem here is the startup cost and complexity of compilation, especially if serious optimizations are performed. Another approach to safe code execution is Software Fault Isolation (SFI) [23]. SFI is an inexpensive method for parsing binaries and inserting run-time checks on memory operations. <p> We wrote the four packet filters in the safe subset of Modula-3 and compiled them with the version 3.5 of the DEC SRC compiler extended with the VIEW operation <ref> [24] </ref>. VIEW is used to safely cast the packet filter to an array of aligned 64-bit words allowing fewer memory operation for accessing packet fields.
References-found: 24

