URL: http://http.cs.berkeley.edu/~asah/papers/other/to-read/CU-CS-665-93.ps.gz
Refering-URL: http://http.cs.berkeley.edu/~asah/papers/other/to-read/
Root-URL: http://www.cs.berkeley.edu
Title: Memory Allocation Costs in Large C and C++ Programs  
Author: David Detlefs and Al Dosser Benjamin Zorn 
Date: August 1993  
Address: 130 Lytton Avenue Palo Alto, CA 94301  Campus Box #430  Boulder 80309-0430  Boulder  
Affiliation: Systems Research Center Digital Equipment Corporation  Department of Computer Science  University of Colorado,  ffi University of Colorado at  
Pubnum: CU-CS-665-93  
Abstract: Technical Report CU-CS-665-93 Department of Computer Science Campus Box 430 University of Colorado Boulder, Colorado 80309 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Thomas Ball and James R. Larus. </author> <title> Optimally profiling and tracing programs. </title> <booktitle> In Conference Record of the 9 Nineteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 59-70, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: Recently, Zorn and Grunwald have shown that the use of synthetic behavior patterns may not lead to an accurate estimation of the performance of a particular algorithm [16]. The existence of instruction-level profiling tools <ref> [1, 6] </ref> has made it possible to count the number of instructions required by various allocation algorithms in large, allocation-intensive programs directly. <p> Instruction counts were all gathered by instrumenting the programs with Larus' QPT tool <ref> [1, 12] </ref>, which presents per-procedure instuction counts with an output format similar to that of gprof [7]. Program execution time was measured using the Unix C-shell built-in time command.
Reference: [2] <author> H. Boehm and M. Weiser. </author> <title> Garbage collection in an uncooperative environment. </title> <journal> Software|Practice and Experience, </journal> <pages> pages 807-820, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: CCR-9121269 and by a Digital Equipment Corporation External Research Grant. 1 One of the DSA implementations measured is a publicly-available conservative garbage collector for C and C++ (BW 2.6+ms,ip) <ref> [2] </ref>. Our measurements show that this collector is competitive in both CPU time and memory usage with existing commercial-quality malloc/free allocators. <p> Specifically, G++, Gnu 0 , and Qf all described in more detail by Grunwald et al [9]. The Berkeley Unix 4.2 BSD allocator, of which Ultrix is a derivative, is also described in that paper. The BW 2.6+ms,ip allocator is described in detail by Boehm and Weiser <ref> [2] </ref> and summarized by Zorn [15]. Black-listing, an enhancement present in Version 2.6 of the collector, is also described by Boehm [3]. 4 Results The results presented were gathered using a variety of measurement tools on a DECstation 5000/240 with 112 megabytes of memory. <p> It is not publicly-available, but comes with the DEC Ultrix operating system. BW 2.6+ms,ip This is version 2.6 of the Boehm-Demers-Weiser conservative garbage collector. Boehm et al decribed a number of related versions of this collector <ref> [2, 4, 3] </ref>. For the measurements collected, the definitions of MERGE SIZES (Ms) and ALL INTERIOR POINTERS (Ip) were enabled. The most recent version of the collector is version 3.2.
Reference: [3] <author> Han-Juergen Boehm. </author> <title> Space efficient conservative garbage collection. </title> <booktitle> In SIGPLAN'93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 197-206, </pages> <address> Albuquerque, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: The BW 2.6+ms,ip allocator is described in detail by Boehm and Weiser [2] and summarized by Zorn [15]. Black-listing, an enhancement present in Version 2.6 of the collector, is also described by Boehm <ref> [3] </ref>. 4 Results The results presented were gathered using a variety of measurement tools on a DECstation 5000/240 with 112 megabytes of memory. <p> It is not publicly-available, but comes with the DEC Ultrix operating system. BW 2.6+ms,ip This is version 2.6 of the Boehm-Demers-Weiser conservative garbage collector. Boehm et al decribed a number of related versions of this collector <ref> [2, 4, 3] </ref>. For the measurements collected, the definitions of MERGE SIZES (Ms) and ALL INTERIOR POINTERS (Ip) were enabled. The most recent version of the collector is version 3.2.
Reference: [4] <author> Hans Boehm, Alan Demers, and Scott Shenker. </author> <title> Mostly parallel garbage collection. </title> <booktitle> In Proceedings of the SIGPLAN'92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 157-164, </pages> <address> Toronto, Canada, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: It is not publicly-available, but comes with the DEC Ultrix operating system. BW 2.6+ms,ip This is version 2.6 of the Boehm-Demers-Weiser conservative garbage collector. Boehm et al decribed a number of related versions of this collector <ref> [2, 4, 3] </ref>. For the measurements collected, the definitions of MERGE SIZES (Ms) and ALL INTERIOR POINTERS (Ip) were enabled. The most recent version of the collector is version 3.2.
Reference: [5] <author> G. Bozman, W. Buco, T. P. Daly, and W. H. </author> <title> Tetzlaff. </title> <journal> Analysis of free-storage algorithms|revisited. IBM Systems Journal, </journal> <volume> 23(1) </volume> <pages> 44-64, </pages> <year> 1984. </year>
Reference: [6] <institution> Digital Equipment Corporation. </institution> <note> Unix Manual Page for pixie, ULTRIX V4.2 (rev 96) edition, </note> <month> September </month> <year> 1991. </year>
Reference-contexts: Recently, Zorn and Grunwald have shown that the use of synthetic behavior patterns may not lead to an accurate estimation of the performance of a particular algorithm [16]. The existence of instruction-level profiling tools <ref> [1, 6] </ref> has made it possible to count the number of instructions required by various allocation algorithms in large, allocation-intensive programs directly.
Reference: [7] <author> Susan L. Graham, Peter B. Kessler, and Marshall K. McKusick. </author> <title> An execution profiler for modular programs. </title> <journal> Software|Practice and Experience, </journal> <volume> 13 </volume> <pages> 671-685, </pages> <year> 1983. </year>
Reference-contexts: Instruction counts were all gathered by instrumenting the programs with Larus' QPT tool [1, 12], which presents per-procedure instuction counts with an output format similar to that of gprof <ref> [7] </ref>. Program execution time was measured using the Unix C-shell built-in time command. The measurement of each program's live data was gathered using a modified version of malloc/free, and allocator maximum heap sizes were measured using a modified version of the Unix sbrk system call.
Reference: [8] <author> Dirk Grunwald and Benjamin Zorn. </author> <title> CustoMalloc: Efficient synthesized memory allocators. </title> <journal> Software| Practice and Experience, </journal> <note> To appear. </note>
Reference: [9] <author> Dirk Grunwald, Benjamin Zorn, and Robert Henderson. </author> <title> Improving the cache locality of memory allocation. </title> <booktitle> In SIGPLAN'93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 177-186, </pages> <address> Albuquerque, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Other recent papers comparing the performance of various aspects of dynamic storage allocation also describe these algorithms, and we refer the interested reader to these papers. Specifically, G++, Gnu 0 , and Qf all described in more detail by Grunwald et al <ref> [9] </ref>. The Berkeley Unix 4.2 BSD allocator, of which Ultrix is a derivative, is also described in that paper. The BW 2.6+ms,ip allocator is described in detail by Boehm and Weiser [2] and summarized by Zorn [15]. <p> Large objects are handled by a general algorithm (in this case, G++). Contact Person: Dirk Grunwald (grunwald@cs.colorado.edu) FTP Site: anonymous@ftp.cs.colorado.edu:pub/cs/misc/qf.c Table 3: General information about the allocators. All the allocators except BW 2.6+ms,ip are described in more detail in <ref> [9] </ref>. 5 Ultrix BW 2.6+ms,ip Gnu 0 G++ Qf Program (instr/malloc) (instr/malloc) (instr/malloc) (instr/malloc) (instr/malloc) Absol Relat Absol Relat Absol Relat Absol Relat Absol Relat Sis 60 1.00 489 8.15 101 1.68 84 1.40 192 3.20 Geodesy 46 1.00 179 3.89 81 1.76 53 1.15 29 0.63 Ild 57 1.00 3544
Reference: [10] <author> Donald E. Knuth. </author> <title> Fundamental Algorithms, </title> <booktitle> volume 1 of The Art of Computer Programming, chapter 2, </booktitle> <pages> pages 435-451. </pages> <publisher> Addison Wesley, </publisher> <address> Reading, MA, 2nd edition, </address> <year> 1973. </year>
Reference: [11] <author> David G. Korn and Kiem-Phong Vo. </author> <title> In search of a better malloc. </title> <booktitle> In Proceedings of the Summer 1985 USENIX Conference, </booktitle> <pages> pages 489-506, </pages> <year> 1985. </year>
Reference: [12] <author> James R. Larus and Thomas Ball. </author> <title> Rewriting executable files to measure program behavior. </title> <type> Technical Report 1083, </type> <institution> Computer Sciences Department, University of Wisconsin-Madison, Madison, WI, </institution> <month> March </month> <year> 1992. </year>
Reference-contexts: Instruction counts were all gathered by instrumenting the programs with Larus' QPT tool <ref> [1, 12] </ref>, which presents per-procedure instuction counts with an output format similar to that of gprof [7]. Program execution time was measured using the Unix C-shell built-in time command.
Reference: [13] <author> Thomas Standish. </author> <title> Data Structures Techniques. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1980. </year>
Reference-contexts: It is distributed with the GNU C++ library, libg++ (through version 2.4.5) and also available separately. Contact Person : Doug Lea (dl@oswego.edu) FTP Site: anonymous@g.oswego.edu:/pub/misc/malloc.c Qf Qf is an implementation of Weinstock and Wulf's fast segregated-storage algorithm based on an array of freelists <ref> [14, 13] </ref>. Like the Gnu 0 algorithm, Qf is a hybrid algorithm that allocates small and large objects in different ways. Large objects are handled by a general algorithm (in this case, G++). Contact Person: Dirk Grunwald (grunwald@cs.colorado.edu) FTP Site: anonymous@ftp.cs.colorado.edu:pub/cs/misc/qf.c Table 3: General information about the allocators.
Reference: [14] <author> Charles B. Weinstock and William A. Wulf. Quickfit: </author> <title> An efficient algorithm for heap storage allocation. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 23(10) </volume> <pages> 141-144, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: It is distributed with the GNU C++ library, libg++ (through version 2.4.5) and also available separately. Contact Person : Doug Lea (dl@oswego.edu) FTP Site: anonymous@g.oswego.edu:/pub/misc/malloc.c Qf Qf is an implementation of Weinstock and Wulf's fast segregated-storage algorithm based on an array of freelists <ref> [14, 13] </ref>. Like the Gnu 0 algorithm, Qf is a hybrid algorithm that allocates small and large objects in different ways. Large objects are handled by a general algorithm (in this case, G++). Contact Person: Dirk Grunwald (grunwald@cs.colorado.edu) FTP Site: anonymous@ftp.cs.colorado.edu:pub/cs/misc/qf.c Table 3: General information about the allocators.
Reference: [15] <author> Benjamin Zorn. </author> <title> The measured cost of conservative garbage collection. </title> <journal> Software|Practice and Experience, </journal> <volume> 23(7) </volume> <pages> 733-756, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: In this paper, we present a large number of detailed measurements of the performance of five very different dynamic storage allocation implementations in 11 large, allocation-intensive C and C++ programs. The results of this paper extend and complement the C-program measurements of Zorn <ref> [15] </ref>. The purpose of this paper is to make additional detailed measurements available to a broad audience. <p> The Berkeley Unix 4.2 BSD allocator, of which Ultrix is a derivative, is also described in that paper. The BW 2.6+ms,ip allocator is described in detail by Boehm and Weiser [2] and summarized by Zorn <ref> [15] </ref>. Black-listing, an enhancement present in Version 2.6 of the collector, is also described by Boehm [3]. 4 Results The results presented were gathered using a variety of measurement tools on a DECstation 5000/240 with 112 megabytes of memory.
Reference: [16] <author> Benjamin Zorn and Dirk Grunwald. </author> <title> Evaluating models of memory allocation. </title> <type> Technical Report CU-CS-603-92, </type> <institution> Department of Computer Science, University of Colorado, Boulder, Boulder, CO, </institution> <month> July </month> <year> 1992. </year> <month> 10 </month>
Reference-contexts: Recently, Zorn and Grunwald have shown that the use of synthetic behavior patterns may not lead to an accurate estimation of the performance of a particular algorithm <ref> [16] </ref>. The existence of instruction-level profiling tools [1, 6] has made it possible to count the number of instructions required by various allocation algorithms in large, allocation-intensive programs directly.
References-found: 16

