URL: http://www.cs.ucsd.edu/users/mihir/papers/cct.ps.gz
Refering-URL: http://www.cs.ucsd.edu/users/mihir/papers/cct.html
Root-URL: http://www.cs.ucsd.edu
Email: e-mail: mihir@cs.ucsd.edu  e-mail: moti@watson.ibm.com  
Title: Certifying Permutations: Non-Interactive Zero-Knowledge Based on any Trapdoor Permutation  
Author: Mihir Bellare Moti Yung 
Address: San Diego, 9500 Gilman Drive, La Jolla, California 92093.  PO Box 704, Yorktown Heights, NY 10598.  
Affiliation: Department of Computer Science Engineering, Mail Code 0114, University of California at  Research Division, IBM T.J. Watson Research Center,  
Note: Appears in Journal of Cryptology, Vol. 9, No. 1, Winter 1996, pp. 149-166. Preliminary version in Advances in Cryptology Crypto 92 Proceedings, Lecture Notes in Computer Science Vol. 740, E. Brickell ed., Springer-Verlag, 1992.  
Abstract: In cryptographic protocols it is often necessary to verify/certify the "tools" in use. This work demonstrates certain subtleties in treating a family of trapdoor permutations in this context, noting the necessity to "check" certain properties of these functions. The particular case we illustrate is that of non-interactive zero-knowledge. We point out that the elegant recent protocol of Feige, Lapidot and Shamir for proving NP statements in non-interactive zero-knowledge requires an additional certification of the underlying trapdoor permutation, and suggest a method for certifying permutations which fills this gap. 
Abstract-found: 1
Intro-found: 1
Reference: [BeGo] <author> M. Bellare and S. Goldwasser. </author> <title> New Paradigms for Digital Signatures and Message Authentication Based on Non-Interactive Zero-Knowledge Proofs. </title> <booktitle> Advances in Cryptology - Crypto 89 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 435, </volume> <editor> G. Brassard ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: There are numerous applications. In particular, Naor and Yung show how to use NIZK proofs to implement public-key cryptosystems secure against chosen-ciphertext attack [NaYu], and Bellare and Goldwasser present a novel paradigm for digital signatures based on NIZK proofs <ref> [BeGo] </ref>. The model is as follows. The prover and verifier have a common input w and also share a random string (of length polynomial in the length of w). We call this string the reference string, and usually denote it by . <p> Hence, we will stick to the simple definition. We note we are considering what have been called "single-theorem" or "bounded" NIZK proof systems. That is, the given reference string can be used to prove only a single theorem. The primitive of importance in applications (cf. <ref> [BeGo, NaYu] </ref>) is the "many-theorem" proof system. <p> In particular, NIZK proof systems are constructible based on RSA. Combining Theorem 4.4 with the result of [NaYu] yields the following. Corollary 4.5 Suppose there exists a trapdoor permutation generator. Then there exists an en cryption scheme secure against chosen-ciphertext attack. Similarly, combining Theorem 4.4 with the result of <ref> [BeGo] </ref> yields the following. Corollary 4.6 Suppose there exists a trapdoor permutation generator. Then there exists an implementation of the signature scheme of [BeGo]. 15 Acknowledgments We thank an anonymous referee for comments that improved the presentation. This work was done while the first author was at the IBM T. <p> Then there exists an en cryption scheme secure against chosen-ciphertext attack. Similarly, combining Theorem 4.4 with the result of <ref> [BeGo] </ref> yields the following. Corollary 4.6 Suppose there exists a trapdoor permutation generator. Then there exists an implementation of the signature scheme of [BeGo]. 15 Acknowledgments We thank an anonymous referee for comments that improved the presentation. This work was done while the first author was at the IBM T. J. Watson Research Center, Yorktown Heights, New York.
Reference: [BeMi] <author> M. Bellare and S. Micali. </author> <title> How to Sign Given any Trapdoor Permutation. </title> <journal> JACM, </journal> <volume> Vol. 39, No. 1, </volume> <month> January </month> <year> 1992, </year> <pages> pp. 214-233. </pages>
Reference-contexts: We then, briefly, discuss our solution. Later sections specify the definitions and our solution in more detail. 1.1 Trapdoor Permutations Let us begin by recalling, in some detail, the definition of a trapdoor permutation generator (we follow <ref> [BeMi] </ref>), and seeing what it means for such a generator to be certified. 1 Such a problem is not present in public-key applications. <p> 1g n to f0; 1g n given by x 7! E (f fl ; x). 6 2.2 Trapdoor Permutations and Certified Ones Let us present a precise definition of trapdoor permutations and see what it means for them to be "certified." The definition that follows is from Bellare and Micali <ref> [BeMi] </ref>. Definition 2.2 (Trapdoor Permutation Generator) Let G be a probabilistic, polynomial time algorithm, and let E; I be polynomial time algorithms. <p> [RSA] and the factoring based ones of Blum, Blum and Shub [BBS], do fit this definition, after some minor transformations (the need for these transformations arises from the fact that these number theoretic functions have domain Z fl N rather than f0; 1g n ; we refer the reader to <ref> [BeMi] </ref> for details). If a trapdoor permutation generator (G; E; I) is fixed and (f fl ; f fl ) 2 [G (1 n )] for some n &gt; 0, then, in informal discussion, we call f fl a trapdoor permutation.
Reference: [BMO] <author> M. Bellare, S. Micali and R. Ostrovsky. </author> <title> The True Complexity of Statistical Zero-Knowledge. </title> <booktitle> Proceedings of the 22nd Annual Symposium on Theory of Computing, ACM, </booktitle> <year> 1990. </year>
Reference-contexts: But not always. One reason is that that these protocols yield only computational zero-knowledge, and we may be interested in stronger forms such as statistical. (One such example occurs in <ref> [BMO] </ref> where the use of the certified discrete log assumption is crucial.) Or, as for the problem we are interested in here, we may want a non-interactive solution, so that again the above mentioned general techniques are precluded.
Reference: [BBS] <author> L. Blum, M. Blum, and M. Shub. </author> <title> A Simple Unpredictable Pseudo-Random Number Generator. </title> <journal> SIAM Journal on Computing, </journal> <volume> Vol. 15, No. 2, </volume> <month> May </month> <year> 1986, </year> <pages> pp. 364-383. </pages>
Reference-contexts: We point out that the elegant recent NIZK protocol of Feige, Lapidot and Shamir [FLS] makes the (implicit) assumption that the trapdoor permutation is "certified." We note that this assumption is not valid for standard (conjectured) trapdoor permutations like RSA or those of <ref> [BBS] </ref>, and so their protocol cannot be instantiated with any known (conjectured) trapdoor permutation. We suggest a certification method to fill this gap, so that any trapdoor permutation truly suffices, and RSA or the construction of [BBS] may be used. <p> assumption is not valid for standard (conjectured) trapdoor permutations like RSA or those of <ref> [BBS] </ref>, and so their protocol cannot be instantiated with any known (conjectured) trapdoor permutation. We suggest a certification method to fill this gap, so that any trapdoor permutation truly suffices, and RSA or the construction of [BBS] may be used. Our certification method involves a NIZK proof that a function is "almost" a permutation, and might be of independent interest. Below we begin by recalling the notions of trapdoor permutations and NIZK proofs. We then discuss the FLS protocol and indicate the source of the problem. <p> If it is recognizable in polynomial time, we say the generator is certified. We note that efficent recognizability is a lot to ask for. Consider our two main (conjectured) examples of trapdoor permutation generators: RSA [RSA], and the factoring based generator of Blum, Blum and Shub <ref> [BBS] </ref>. Neither is likely to be certifiable. This is because, in both cases, certification would need the ability to recognize in polynomial time the class of integers which are a product of (exactly) two (distinct) primes. <p> We note that the gap is not an academic one. Considering concrete cases, such as the use of RSA or the trapdoor permutations based on quadratic residuosity that are suggested by <ref> [BBS] </ref>, we see that the prover may indeed cheat. The solution that first suggests itself is that the prover prove (in NIZK) that he really got f by running the generator G (this is an NP statement). <p> The standard (conjectured) "trapdoor permutations," such as RSA [RSA] and the factoring based ones of Blum, Blum and Shub <ref> [BBS] </ref>, do fit this definition, after some minor transformations (the need for these transformations arises from the fact that these number theoretic functions have domain Z fl N rather than f0; 1g n ; we refer the reader to [BeMi] for details). <p> We note that standard (conjectured) trapdoor permutation generators are (probably) not certified. In particular, RSA is (probably) not certified, and nor is the trapdoor permutation generator of Blum, Blum and Shub <ref> [BBS] </ref>. This is because, in both these cases, the (description of) the trapdoor permutation f fl includes a number which is a product of two primes, and there is (probably) no polynomial time procedure to test whether or not a number is a product of two primes. <p> In particular, the (implicit) assumption in [FLS] is that the trapdoor permutation generator being used is certified. As the above indicates, this means that their scheme cannot be instantiated with RSA or the trapdoor permutations of <ref> [BBS] </ref>. In later sections we will show how to extend their scheme so that any (not necessarily certified) trapdoor permutation generator suffices (so that RSA or the generator of [BBS] may in fact be used). <p> As the above indicates, this means that their scheme cannot be instantiated with RSA or the trapdoor permutations of <ref> [BBS] </ref>. In later sections we will show how to extend their scheme so that any (not necessarily certified) trapdoor permutation generator suffices (so that RSA or the generator of [BBS] may in fact be used). We note that if (G; E; I) is a trapdoor permutation generator, f fl 2 f0; 1g n , and x 2 f0; 1g n then we may assume, without loss of generality, that E (f fl ; x) is an n-bit string.
Reference: [BDMP] <author> M. Blum, A. De Santis, S. Micali, and G. Persiano, </author> <title> Non-Interactive Zero-Knowledge Proof Systems, </title> <journal> SIAM Journal on Computing, </journal> <volume> Vol. 20, No. 6, </volume> <month> December </month> <year> 1991,pp. </year> <pages> 1084-1118. </pages>
Reference-contexts: NIZK is an important notion for cryptographic systems and protocols which was introduced by Blum, Feldman, and Micali [BFM] and Blum, De Santis, Micali and Persiano <ref> [BDMP] </ref>. There are numerous applications. In particular, Naor and Yung show how to use NIZK proofs to implement public-key cryptosystems secure against chosen-ciphertext attack [NaYu], and Bellare and Goldwasser present a novel paradigm for digital signatures based on NIZK proofs [BeGo]. The model is as follows. <p> We note that we are considering what are called "single-theorem" or "bounded" NIZK proof systems. The primitive of importance in applications is the "many-theorem" proof system (cf. <ref> [BFM, BDMP] </ref>). However, the former is known to imply the latter, given the existence of one-way functions [DeYu, FLS]. <p> The definition that follows is based on that of Blum, De Santis, Micali and Persiano <ref> [BDMP] </ref>. However, we state the zero-knowledge condition differently; specifically, we use the notion of a witness selector to state the zero-knowledge condition in terms of the standard notion of computational indistinguishability, whereas in [BDMP] the zero-knowledge condition makes explicit reference to "distinguishing" algorithms. <p> The definition that follows is based on that of Blum, De Santis, Micali and Persiano <ref> [BDMP] </ref>. However, we state the zero-knowledge condition differently; specifically, we use the notion of a witness selector to state the zero-knowledge condition in terms of the standard notion of computational indistinguishability, whereas in [BDMP] the zero-knowledge condition makes explicit reference to "distinguishing" algorithms. The two formulations are, of course, equivalent (but we feel this one is a little simpler because of its "modularity.") Definition 2.6 Let be an NP-relation and let L = L . <p> Given any polynomial k (), the error-probability can be reduced to 2 k (n) by running k (n) independent copies of the original proof system in parallel and accepting iff all sub-proofs are accepting. A stronger definition (cf. <ref> [BDMP] </ref>) asks that in the soundness condition the adversary b P be allowed to select a w 62 L as a function of the reference string. This definition is, however, implied by the one above. <p> For w 62 L, we may use the following "trick" (a standard probabilistic one, used, for the same purpose, in <ref> [BDMP] </ref> and [FLS]). For each fixed f fl 2 f0; 1g n , we reduce the probability that the verifier accepts the interaction on inputs (w; f fl ) to 2 (n+1) , by parallel repetition.
Reference: [BFM] <author> M. Blum, P. Feldman, and S. Micali, </author> <title> Non-Interactive Zero-Knowledge Proof Systems and Applications, </title> <booktitle> Proceedings of the 20th Annual Symposium on Theory of Computing, ACM, </booktitle> <year> 1988. </year>
Reference-contexts: NIZK is an important notion for cryptographic systems and protocols which was introduced by Blum, Feldman, and Micali <ref> [BFM] </ref> and Blum, De Santis, Micali and Persiano [BDMP]. There are numerous applications. In particular, Naor and Yung show how to use NIZK proofs to implement public-key cryptosystems secure against chosen-ciphertext attack [NaYu], and Bellare and Goldwasser present a novel paradigm for digital signatures based on NIZK proofs [BeGo]. <p> We note that we are considering what are called "single-theorem" or "bounded" NIZK proof systems. The primitive of importance in applications is the "many-theorem" proof system (cf. <ref> [BFM, BDMP] </ref>). However, the former is known to imply the latter, given the existence of one-way functions [DeYu, FLS].
Reference: [BC] <author> G. Brassard and C. Crepeau. </author> <title> Non-transitive Transfer of Confidence: A perfect Zero-knowledge Interactive protocol for SAT and Beyond. </title> <booktitle> Proceedings of the 27th Symposium on Foundations of Computer Science, IEEE, </booktitle> <year> 1986. </year>
Reference-contexts: Since the "correctness" of the tool can usually be formulated as an NP assertion, such sub-protocols can in some cases be realized, by using, say, the general interactive protocols of <ref> [GMW, BC] </ref> which enable any NP statement to be proven in zero-knowledge. But not always.
Reference: [DeYu] <author> A. De Santis and M. Yung. </author> <title> Cryptographic Applications of the Metaproof and Many-prover Systems. </title> <booktitle> Advances in Cryptology - Crypto 90 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 537, </volume> <editor> A. J. Menezes and S. Vanstone ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: We note that we are considering what are called "single-theorem" or "bounded" NIZK proof systems. The primitive of importance in applications is the "many-theorem" proof system (cf. [BFM, BDMP]). However, the former is known to imply the latter, given the existence of one-way functions <ref> [DeYu, FLS] </ref>. So we may, wlog, stick to the former. 1.3 The Need for Certification in the FLS Protocol Feige, Lapidot and Shamir [FLS] recently presented an elegant NIZK proof system based on the existence of trapdoor permutations. <p> We note we are considering what have been called "single-theorem" or "bounded" NIZK proof systems. That is, the given reference string can be used to prove only a single theorem. The primitive of importance in applications (cf. [BeGo, NaYu]) is the "many-theorem" proof system. However, De Santis and Yung <ref> [DeYu] </ref>, and Feige, Lapidot and Shamir [FLS], have shown that the existence (for some NP-complete relation) of a bounded NIZK proof system with an efficient prover implies the existence (for any NP-relation) of a many-theorem NIZK proof system (with an efficient prover), as long as one-way functions exist.
Reference: [FLS] <author> U. Feige, D. Lapidot, and A. Shamir. </author> <title> Multiple Non-Interactive Zero-Knowledge based on a Single Random String. </title> <booktitle> Proceedings of the 31st Symposium on Foundations of Computer Science, IEEE, </booktitle> <year> 1990. </year>
Reference-contexts: The particular instance of this issue that we focus on in this paper is the use of trapdoor permutations in non-interactive zero-knowledge (NIZK) proofs. We point out that the elegant recent NIZK protocol of Feige, Lapidot and Shamir <ref> [FLS] </ref> makes the (implicit) assumption that the trapdoor permutation is "certified." We note that this assumption is not valid for standard (conjectured) trapdoor permutations like RSA or those of [BBS], and so their protocol cannot be instantiated with any known (conjectured) trapdoor permutation. <p> We note that we are considering what are called "single-theorem" or "bounded" NIZK proof systems. The primitive of importance in applications is the "many-theorem" proof system (cf. [BFM, BDMP]). However, the former is known to imply the latter, given the existence of one-way functions <ref> [DeYu, FLS] </ref>. So we may, wlog, stick to the former. 1.3 The Need for Certification in the FLS Protocol Feige, Lapidot and Shamir [FLS] recently presented an elegant NIZK proof system based on the existence of trapdoor permutations. <p> However, the former is known to imply the latter, given the existence of one-way functions [DeYu, FLS]. So we may, wlog, stick to the former. 1.3 The Need for Certification in the FLS Protocol Feige, Lapidot and Shamir <ref> [FLS] </ref> recently presented an elegant NIZK proof system based on the existence of trapdoor permutations. The assumption, implicit in their analysis, is that the underlying trapdoor permutation generator is certified. Here we indicate whence arises the need for this certification. <p> P is then instructed to send f fl to V (while keeping f fl to himself). And the problem is right here, in this first step. The analysis of <ref> [FLS] </ref> assumes that the prover performs this step correctly. This may be justified under the assumption that the trapdoor permutation generator is certified. <p> Note that in the above NIZK proof, a (cheating) prover may choose f fl as a function of the random string. But, as pointed out in <ref> [FLS] </ref>, this causes no difficulties. We may assume, in the analysis, that the reference string is chosen after f fl is fixed; later we apply a simple transformation which results in the proof system being secure even if f fl was chosen as a function of . <p> We will deal with this issue explicitly when it arises. Feige et. al <ref> [FLS] </ref> also consider the case of a computationally unbounded prover, where they use a one-way, rather than trapdoor, permutation. <p> We note that this proof is in fact quite independent of the details of the FLS protocol and can be understood without a deep knowledge of the techniques of that paper. 5 Our solution also applies for the usage of one-way (rather than trapdoor) permutations in the <ref> [FLS] </ref> protocol with an unbounded prover. 2 Preliminaries We begin by summarizing some basic notation and conventions which are used throughout the paper. <p> For security reasons he may not wish to reveal (as proof that it is indeed one) the string f fl , but may nonetheless need to convince the verifier that f fl 7 is indeed a trapdoor permutation. In particular, the (implicit) assumption in <ref> [FLS] </ref> is that the trapdoor permutation generator being used is certified. As the above indicates, this means that their scheme cannot be instantiated with RSA or the trapdoor permutations of [BBS]. <p> That is, the given reference string can be used to prove only a single theorem. The primitive of importance in applications (cf. [BeGo, NaYu]) is the "many-theorem" proof system. However, De Santis and Yung [DeYu], and Feige, Lapidot and Shamir <ref> [FLS] </ref>, have shown that the existence (for some NP-complete relation) of a bounded NIZK proof system with an efficient prover implies the existence (for any NP-relation) of a many-theorem NIZK proof system (with an efficient prover), as long as one-way functions exist. <p> We note that although this problem is motivated by the need to fill the gap in the FLS protocol (cf. x1.3), the results of this section might be of interest in their own right. Thus, we prefer to view them independently, and will make the link to <ref> [FLS] </ref> in the next section. In addressing the task of providing a NIZK proof that the function specified by f fl under E is "almost" a permutation, we must begin by clarifying two things. <p> We note also that no cryptographic assumptions were needed for the above proof, and the zero-knowledge is "perfect." 4 Using the Certification Procedure In this section we show how the certification procedure of Theorem 3.2 can be combined with the results of <ref> [FLS] </ref> to yield a NIZK proof system for any NP-relation. We stress that the argument we present here depends little on the specifics of the protocol of [FLS], and our proof does not presume familiarity with that paper. <p> Using the Certification Procedure In this section we show how the certification procedure of Theorem 3.2 can be combined with the results of <ref> [FLS] </ref> to yield a NIZK proof system for any NP-relation. We stress that the argument we present here depends little on the specifics of the protocol of [FLS], and our proof does not presume familiarity with that paper. We begin by extending Definition 3.1 with the following terminology. 11 Definition 4.1 Let n &gt; 0 and f : f0; 1g n ! f0; 1g n . <p> We denote by C l (f ) the set of all ln-bit strings which are f -bad. We now state, without proof, a lemma which can be derived from <ref> [FLS] </ref>. The formal statement follows, but, since it is rather long, let us first try to give an informal explanation of what it says. Briefly, we show how to "measure" the "additional" error incurred by the [FLS] protocol in the case that the function being used is not a permutation. <p> We now state, without proof, a lemma which can be derived from <ref> [FLS] </ref>. The formal statement follows, but, since it is rather long, let us first try to give an informal explanation of what it says. Briefly, we show how to "measure" the "additional" error incurred by the [FLS] protocol in the case that the function being used is not a permutation. More precisely, we fix a trapdoor permutation generator (G; E; I) and an NP-relation . <p> Namely, <ref> [FLS] </ref> show that error probability less than any * (in particular * = 1=4) can be achieved, assuming only that the reference string is not f -bad (i.e. they do not use anywhere that f is permutation). <p> Hence 12 the prover can cheat with probability at most 1=4 plus the probability that the reference string is f -bad. For the full proof, we refer the reader to <ref> [FLS] </ref>. We now show how to remove this extra f fl dependent term in the soundness condition by having the prover certify (using the proof system of Theorem 3.2) that f is almost a permutation. <p> For w 62 L, we may use the following "trick" (a standard probabilistic one, used, for the same purpose, in [BDMP] and <ref> [FLS] </ref>). For each fixed f fl 2 f0; 1g n , we reduce the probability that the verifier accepts the interaction on inputs (w; f fl ) to 2 (n+1) , by parallel repetition.
Reference: [GMW] <author> O. Goldreich, S. Micali, and A. Wigderson. </author> <title> Proofs that Yield Nothing but their Validity and a Methodology of Cryptographic Design. </title> <journal> JACM, </journal> <volume> Vol. 38, No. 1, </volume> <month> July </month> <year> 1991, </year> <pages> pp. 691-729. </pages>
Reference-contexts: Since the "correctness" of the tool can usually be formulated as an NP assertion, such sub-protocols can in some cases be realized, by using, say, the general interactive protocols of <ref> [GMW, BC] </ref> which enable any NP statement to be proven in zero-knowledge. But not always.
Reference: [GoLe] <author> O. Goldreich and L. Levin. </author> <title> A Hard-Core Predicate for all One-Way Functions. </title> <booktitle> Proceedings of the 21st Annual Symposium on Theory of Computing, ACM, </booktitle> <year> 1989. </year>
Reference-contexts: If x and r are n-bit strings then H (x; r) denotes the dot product, over GF (2), of x and r (more precisely, H (x; r) = L n i=1 x i r i ). The theorem of Goldreich and Levin <ref> [GoLe] </ref> says that H is a "hard-core" predicate for (G; E; I). Very informally, this means the following.
Reference: [GMR] <author> S. Goldwasser, S. Micali, and R. Rivest. </author> <title> A Digital Signature Scheme Secure Against Adaptive Chosen-Message Attacks. </title> <journal> SIAM Journal on Computing, </journal> <volume> Vol. 17, No. 2, </volume> <month> April </month> <year> 1988, </year> <pages> pp. 281-308. </pages>
Reference-contexts: We then discuss trapdoor permutations and say what it means for them to be "certified." Finally, we recall the definition, and some basic properties, of non-interactive zero-knowledge proof systems. 2.1 Notation and Conventions We use the notation and conventions for probabilistic algorithms that originated in <ref> [GMR] </ref>. We emphasize the number of inputs received by an algorithm as follows. If algorithm A receives only one input we write "A ()"; if it receives two we write "A (; )", and so on.
Reference: [NaYu] <author> M. Naor and M. Yung. </author> <title> Public Key Cryptosystems secure against chosen-ciphertext attacks. </title> <booktitle> Proceedings of the 22nd Annual Symposium on Theory of Computing, ACM, </booktitle> <year> 1990. </year>
Reference-contexts: There are numerous applications. In particular, Naor and Yung show how to use NIZK proofs to implement public-key cryptosystems secure against chosen-ciphertext attack <ref> [NaYu] </ref>, and Bellare and Goldwasser present a novel paradigm for digital signatures based on NIZK proofs [BeGo]. The model is as follows. The prover and verifier have a common input w and also share a random string (of length polynomial in the length of w). <p> Hence, we will stick to the simple definition. We note we are considering what have been called "single-theorem" or "bounded" NIZK proof systems. That is, the given reference string can be used to prove only a single theorem. The primitive of importance in applications (cf. <ref> [BeGo, NaYu] </ref>) is the "many-theorem" proof system. <p> The zero-knowledge (as required by Definition 2.6) can be argued based on the zero-knowledge condition of Lemma 4.3. We omit the details. In particular, NIZK proof systems are constructible based on RSA. Combining Theorem 4.4 with the result of <ref> [NaYu] </ref> yields the following. Corollary 4.5 Suppose there exists a trapdoor permutation generator. Then there exists an en cryption scheme secure against chosen-ciphertext attack. Similarly, combining Theorem 4.4 with the result of [BeGo] yields the following. Corollary 4.6 Suppose there exists a trapdoor permutation generator.
Reference: [RSA] <author> R. Rivest, A. Shamir, and L. Adleman. </author> <title> A Method for Obtaining Digital Signatures and Public-Key Cryptosystems. </title> <journal> Communications of the ACM, </journal> <volume> Vol. 21, No. 2, </volume> <month> February </month> <year> 1978, </year> <pages> pp. 120-26. </pages>
Reference-contexts: If it is recognizable in polynomial time, we say the generator is certified. We note that efficent recognizability is a lot to ask for. Consider our two main (conjectured) examples of trapdoor permutation generators: RSA <ref> [RSA] </ref>, and the factoring based generator of Blum, Blum and Shub [BBS]. Neither is likely to be certifiable. This is because, in both cases, certification would need the ability to recognize in polynomial time the class of integers which are a product of (exactly) two (distinct) primes. <p> The standard (conjectured) "trapdoor permutations," such as RSA <ref> [RSA] </ref> and the factoring based ones of Blum, Blum and Shub [BBS], do fit this definition, after some minor transformations (the need for these transformations arises from the fact that these number theoretic functions have domain Z fl N rather than f0; 1g n ; we refer the reader to [BeMi]
References-found: 14

