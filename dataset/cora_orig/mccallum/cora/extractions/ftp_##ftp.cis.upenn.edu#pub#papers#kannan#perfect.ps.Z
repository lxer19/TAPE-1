URL: ftp://ftp.cis.upenn.edu/pub/papers/kannan/perfect.ps.Z
Refering-URL: http://www.cis.upenn.edu/~kannan/home.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: A Fast Algorithm for the Computation and Enumeration of Perfect Phylogenies  
Author: Sampath Kannan Tandy Warnow 
Date: August 23, 1995  
Address: Philadelphia, PA 19104  
Affiliation: Department of Computer and Information Science University of Pennsylvania  
Abstract: The Perfect Phylogeny Problem is a classical problem in computational evolutionary biology, in which a set of species/taxa is described by a set of qualitative characters. In recent years, the problem has been shown to be NP-Complete in general, while the different fixed parameter versions can each be solved in polynomial time. In particular, Agarwala and Fernandez-Baca have developed an O(2 3r (nk 3 +k 4 )) algorithm for the perfect phylogeny problem for n species defined by k r-state characters. Since commonly the character data is drawn from alignments of molecular sequences, k is the length of the sequences and can thus be very large (in the hundreds or thousands). Thus, it is imperative to develop algorithms which run efficiently for large values of k. In this paper we make additional observations about the structure of the problem and produce an algorithm for the problem that runs in time O(2 2r k 2 n). We also show how it is possible to efficiently build a structure that implicitly represents the set of all perfect phylogenies, and to randomly sample from that set.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Agarwala and D. Fern andez-Baca, </author> <title> A Polynomial-time Algorithm for the Perfect Phylogeny Problem when the Number of Character States is Fixed, </title> <journal> SIAM J. on Computing, </journal> <volume> Vol. 23, No. 6, </volume> <pages> pp. 1216-1224. </pages>
Reference-contexts: Gusfield [11] gave an O (nk) algorithm for r = 2, the binary character case. Dress and Steel [7] devised a O (nk 2 ) algorithm for r 3. Kannan and Warnow [13] gave a O (n 2 k) algorithm for r 4 (quaternary characters). Agarwala and Fernandez-Baca <ref> [1] </ref> give an O (2 3r (nk 3 + k 4 )) algorithm for the perfect phylogeny problem when the characters are restricted to have at most r states. We present an O (2 2r nk 2 ) time algorithm for this problem. <p> We present an O (2 2r nk 2 ) time algorithm for this problem. The algorithm we present uses some of the same structure as that of <ref> [1] </ref>, but uses additional lemmas about the problem structure and different data structures to achieve the faster running time. <p> Several of these definitions appear in <ref> [1] </ref> and equivalent definitions to some of these definitions can also be found in [13]. In the remainder of this section, we will let ff denote an arbitrary character in C, and we will refer to the states of ff by ff-states. <p> Clearly, a set S has a perfect phylogeny if and only if it has a minimal perfect phylogeny. The relevance of proper clusters to the perfect phylogeny problem and to the algorithm of <ref> [1] </ref> is the following: Lemma 1 ([1], Lemma 1) Let T be a minimal perfect phylogeny for S and let T 0 be an arbitrary subtree of T obtained as a component by the removal of an edge e = (u; v) of T . <p> Using this idea, the algorithm of <ref> [1] </ref> works to determine which proper clusters are good, in a bottom-up dynamic programming fashion. In [1] it is shown that if G 1 is a good proper cluster, G another proper cluster containing G 1 and compatible with G 1 , then we can determine (in polynomial time) if (G; <p> Using this idea, the algorithm of <ref> [1] </ref> works to determine which proper clusters are good, in a bottom-up dynamic programming fashion. In [1] it is shown that if G 1 is a good proper cluster, G another proper cluster containing G 1 and compatible with G 1 , then we can determine (in polynomial time) if (G; G 1 ) is good. 3 The Algorithm of Agarwala & Fernandez Baca Before applying any <p> The more difficult case is where no species in S can be an internal node in any perfect phylogeny for S. The algorithm in <ref> [1] </ref> determines for all proper clusters G 0 of smaller car-dinality than G whether G 0 is good. Now, in considering the pair of proper clusters (G; G 1 ), there are two cases. <p> The determination of whether a proper cluster G is good requires finding a proper cluster G 1 which is contained in and compatible with G, such that (G; G 1 ) is good. In <ref> [1] </ref>, this determination is accomplished by checking all potential proper clusters G 1 . <p> Thus the overall running time of the algorithm in <ref> [1] </ref> is O (2 3r k 3 (k + n)). 4 Our Improvements to the Algorithm While most of the innovation in our algorithm occurs by exploiting structural properties of the solution so as to reduce the number of loops as well as to speed up the inner loop, in order <p> Overall cost: Perfect Phylogeny 8 Thus, the total cost of the preprocessing is O (2 r nk 2 ). 4.2 Reducing to Two Nested Loops The algorithm of <ref> [1] </ref> has three nested loops each of which steps through all possible proper clusters in the worst-case. Thus the number of executions of the innermost loop becomes O (2 3r k 3 ). <p> Since the cost of the innermost loop is bounded by O (n + k), the overall cost of the <ref> [1] </ref> algorithm is therefore O (2 3r (nk 3 + k 4 )). <p> The canonical labeling for the root of T G is x. Since G G 1 is not a proper cluster, x is fully defined (by a lemma proved in <ref> [1] </ref>) (i.e. none of its states are dummy states). By Lemma Perfect Phylogeny 9 3, each equivalence class Q of S/x is a proper cluster. It is easy to verify that each Q 2 S/x is also good and that G 2 /x S/x. <p> Else return NO. 4.3 Speeding up the Inner Loop: In the process of going from three nested loops to two, we have increased the time of execution of the inner loop from O (n + k) in the algorithm of <ref> [1] </ref> to O (nk). We can avoid this blow-up using the information computed during preprocessing. In fact, we will reduce the time for the inner loop to O (n). Since k can be of O (n r1 ), this is significant. <p> If so, we perform a table look-up to see if G 2 is good. Thus, Condition 2 takes only O (n) time to check. Condition 3, surprisingly, also takes only O (n) time (instead of the O (2 r k (n + k)) time used in <ref> [1] </ref> ). Lemma 5 We can determine whether Condition 3 holds in O (n) time. <p> O (n) product nodes in any minimal perfect phylogeny, this depth-first search version of the algorithm is an O (2 2r k 2 n)-delay algorithm for enumerating minimal perfect phylogenies. 6 Comments The algorithm we have presented here is a significant theoretical improvement on the algorithm of Agarwala and Fernandez-Baca <ref> [1] </ref>.
Reference: [2] <author> R. Agarwala and D. Fern andez-Baca, </author> <title> Fast and Simple Algorithms for Perfect Phylogeny and Triangulating Colored Graphs, </title> <type> DIMACS Tech Report 94-51. </type>
Reference-contexts: Proof: Let T be a minimal perfect phylogeny for S where s occurs as the label of an internal node v. By a result in <ref> [2] </ref>, Q is entirely contained in one of the subtrees of T fvg. Let T Q be this subtree.
Reference: [3] <author> H. Bodlaender, M. Fellows, and T. Warnow, </author> <title> Two strikes against perfect phylogeny, </title> <booktitle> In Proceedings of the 19th International Colloquium on Automata, Languages, and Programming, Springer Verlag, Lecture Notes in Computer Science (1992), </booktitle> <pages> pp. 273-283. </pages>
Reference-contexts: In the biology literature, the perfect phylogeny problem is more commonly known as the character compatibility problem [8, 9, 14, 15], where it was introduced in the 1950's. The perfect phylogeny problem was shown to be NP-complete by Bodlaender et al. <ref> [3] </ref> and, independently, by Steel [18]. This fact suggests at least two lines of attack: one is to restrict k, the number of characters; the other is to restrict r. The perfect phylogeny problem was shown to reduce to a graph-theoretic problem in [5] called the triangulating colored graphs problem.
Reference: [4] <author> H. Bodlaender and T. Kloks, </author> <title> A simple linear time algorithm for triangulating three-colored graphs, </title> <booktitle> In Proceedings of the 9th Annual Symposium on Theoretical Aspects of Computer Science (1992), </booktitle> <pages> pp. 415-423. </pages> <note> To appear, Journal of Algorithms. </note>
Reference-contexts: The number of characters in an instance I equals the number of colors in the corresponding graph G I . Algorithms for the perfect phylogeny problem based upon the graph-theoretic formulation were given in <ref> [4, 12, 16] </ref>. These algorithms are thus useful when the number of characters in the input can be bounded. In this paper, we pursue the second approach, in which the number of states is bounded (as is the case for molecular data).
Reference: [5] <author> P. Buneman, </author> <title> A characterization of rigid circuit graphs, </title> <booktitle> Discrete Math 9 (1974), </booktitle> <pages> pp. 205-212. </pages>
Reference-contexts: This fact suggests at least two lines of attack: one is to restrict k, the number of characters; the other is to restrict r. The perfect phylogeny problem was shown to reduce to a graph-theoretic problem in <ref> [5] </ref> called the triangulating colored graphs problem. The number of characters in an instance I equals the number of colors in the corresponding graph G I . Algorithms for the perfect phylogeny problem based upon the graph-theoretic formulation were given in [4, 12, 16].
Reference: [6] <author> W. H. E. Day and D. Sankoff, </author> <title> Computational complexity of inferring phylogenies by compatibility, </title> <journal> Syst. Zool., </journal> <volume> Vol. 35, No. 2 (1986), </volume> <pages> pp. 224-229. </pages> <note> Perfect Phylogeny 20 </note>
Reference-contexts: Furthermore, even though perfect phylogenies are rare in molecular phylogenies, Perfect Phylogeny 19 biologists still seek maximal sets of compatible characters. The problem of finding a maximum cardinality compatible subset of characters is, unfortunately, NP-hard, even for the case of binary characters <ref> [6] </ref>. Finding maximal sets, on the other hand, can be done in a greedy fashion, given an algorithm to determine compatibility of characters.
Reference: [7] <author> A. Dress and M. Steel, </author> <title> Convex tree realizations of partitions, </title> <journal> Appl. Math. Letters, </journal> <volume> Vol. 5, No. 3 (1992), </volume> <pages> pp. 3-6. </pages>
Reference-contexts: In this paper, we pursue the second approach, in which the number of states is bounded (as is the case for molecular data). Gusfield [11] gave an O (nk) algorithm for r = 2, the binary character case. Dress and Steel <ref> [7] </ref> devised a O (nk 2 ) algorithm for r 3. Kannan and Warnow [13] gave a O (n 2 k) algorithm for r 4 (quaternary characters). <p> (O (f (r)nk 2 )) is close to the running time of the algorithms for r = 3; 4, for which O (n 2 k) algorithms were found [13], and matches the O (nk 2 ) running time of the algorithm for r = 3 given by Dress and Steel <ref> [7] </ref>. Although the enumeration algorithms have bad worst-case running times, the actual running time when the number of minimal perfect phylogenies is small is likely to be much more reasonable.
Reference: [8] <author> G.F. Estabrook, </author> <title> Cladistic methodology: a discussion of the theoretical basis for the induction of evolutionary history, Annu. </title> <journal> Rev. Ecol. Syst., </journal> <volume> 3 (1972), </volume> <pages> pp. 427-456. </pages>
Reference-contexts: The tree T , if it exists, is called a perfect phylogeny for S and the set of characters C is said to be compatible. In the biology literature, the perfect phylogeny problem is more commonly known as the character compatibility problem <ref> [8, 9, 14, 15] </ref>, where it was introduced in the 1950's. The perfect phylogeny problem was shown to be NP-complete by Bodlaender et al. [3] and, independently, by Steel [18].
Reference: [9] <author> G. F. Estabrook, C. S. Johnson Jr., and F. R. McMorris, </author> <title> An idealized concept of the true cladistic character, </title> <journal> Mathematical Biosciences, </journal> <volume> 23 (1975), </volume> <pages> pp. 263-272. </pages>
Reference-contexts: The tree T , if it exists, is called a perfect phylogeny for S and the set of characters C is said to be compatible. In the biology literature, the perfect phylogeny problem is more commonly known as the character compatibility problem <ref> [8, 9, 14, 15] </ref>, where it was introduced in the 1950's. The perfect phylogeny problem was shown to be NP-complete by Bodlaender et al. [3] and, independently, by Steel [18].
Reference: [10] <author> L. A. Goldberg, </author> <title> Efficient Algorithms for Enumerating Combinatorial Structures, Distinguished Dissertation Series, </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, </address> <year> 1993. </year>
Reference-contexts: Such an algorithm is a polynomial delay algorithm <ref> [10] </ref> since it takes Perfect Phylogeny 18 only polynomial time to produce the next member of the list being enumerated. In our case, v is at most 2 r k and hence e is at most 2 2r k 2 .
Reference: [11] <author> D. Gusfield, </author> <title> Efficient algorithms for inferring evolutionary trees, Networks, </title> <booktitle> 21 (1991), </booktitle> <pages> pp. 19-28. </pages>
Reference-contexts: These algorithms are thus useful when the number of characters in the input can be bounded. In this paper, we pursue the second approach, in which the number of states is bounded (as is the case for molecular data). Gusfield <ref> [11] </ref> gave an O (nk) algorithm for r = 2, the binary character case. Dress and Steel [7] devised a O (nk 2 ) algorithm for r 3. Kannan and Warnow [13] gave a O (n 2 k) algorithm for r 4 (quaternary characters).
Reference: [12] <author> S. Kannan and T. Warnow, </author> <title> Triangulating three-colored graphs, </title> <journal> SIAM J. on Disc. Math., </journal> <volume> 5 (1992), </volume> <pages> pp. 249-258. </pages>
Reference-contexts: The number of characters in an instance I equals the number of colors in the corresponding graph G I . Algorithms for the perfect phylogeny problem based upon the graph-theoretic formulation were given in <ref> [4, 12, 16] </ref>. These algorithms are thus useful when the number of characters in the input can be bounded. In this paper, we pursue the second approach, in which the number of states is bounded (as is the case for molecular data).
Reference: [13] <author> S. Kannan and T. Warnow, </author> <title> Inferring evolutionary history from DNA sequences, </title> <journal> SIAM J. on Computing, </journal> <volume> Volume 23, No. 3, </volume> <pages> (1994) pp. 713-737. </pages>
Reference-contexts: Gusfield [11] gave an O (nk) algorithm for r = 2, the binary character case. Dress and Steel [7] devised a O (nk 2 ) algorithm for r 3. Kannan and Warnow <ref> [13] </ref> gave a O (n 2 k) algorithm for r 4 (quaternary characters). Agarwala and Fernandez-Baca [1] give an O (2 3r (nk 3 + k 4 )) algorithm for the perfect phylogeny problem when the characters are restricted to have at most r states. <p> Several of these definitions appear in [1] and equivalent definitions to some of these definitions can also be found in <ref> [13] </ref>. In the remainder of this section, we will let ff denote an arbitrary character in C, and we will refer to the states of ff by ff-states. We will use fl to a dummy state for a character. <p> The running time of this algorithm (O (f (r)nk 2 )) is close to the running time of the algorithms for r = 3; 4, for which O (n 2 k) algorithms were found <ref> [13] </ref>, and matches the O (nk 2 ) running time of the algorithm for r = 3 given by Dress and Steel [7].
Reference: [14] <author> W. J. Le Quesne, </author> <title> A method of selection of characters in numerical taxonomy, </title> <journal> Syst. Zool., </journal> <volume> 18 (1969), </volume> <pages> pp. 201-205. </pages>
Reference-contexts: The tree T , if it exists, is called a perfect phylogeny for S and the set of characters C is said to be compatible. In the biology literature, the perfect phylogeny problem is more commonly known as the character compatibility problem <ref> [8, 9, 14, 15] </ref>, where it was introduced in the 1950's. The perfect phylogeny problem was shown to be NP-complete by Bodlaender et al. [3] and, independently, by Steel [18].
Reference: [15] <author> W. J. Le Quesne, </author> <title> Further studies based on the uniquely derived character concept, </title> <journal> Syst. Zool., </journal> <volume> 21 (1972), </volume> <pages> pp. 281-288. </pages>
Reference-contexts: The tree T , if it exists, is called a perfect phylogeny for S and the set of characters C is said to be compatible. In the biology literature, the perfect phylogeny problem is more commonly known as the character compatibility problem <ref> [8, 9, 14, 15] </ref>, where it was introduced in the 1950's. The perfect phylogeny problem was shown to be NP-complete by Bodlaender et al. [3] and, independently, by Steel [18].
Reference: [16] <author> F. R. McMorris, T. Warnow, and T. Wimer, </author> <title> Triangulating vertex colored graphs, </title> <journal> SIAM J. on Discrete Mathematics, </journal> <volume> Vol. 7. No. 2, </volume> <year> (1994), </year> <pages> pp. 296-306. </pages>
Reference-contexts: The number of characters in an instance I equals the number of colors in the corresponding graph G I . Algorithms for the perfect phylogeny problem based upon the graph-theoretic formulation were given in <ref> [4, 12, 16] </ref>. These algorithms are thus useful when the number of characters in the input can be bounded. In this paper, we pursue the second approach, in which the number of states is bounded (as is the case for molecular data).
Reference: [17] <author> D. Ringe, T. Warnow, and A. Taylor, </author> <title> Character-based construction of evolutionary trees for natural languages, </title> <type> IRCS Technical Report, </type> <year> 1995. </year>
Reference-contexts: This greedy heuristic has already been shown to produce extremely reasonable phylogenetic trees [19] for biological data and for trees on natural languages <ref> [17] </ref>. The greedy heuristic for constructing maximal subsets of compatible characters is thus useful for any domain where it is possible to construct perfect phylogenies using almost all of the characters in the data set (i.e. using k O (1) characters).
Reference: [18] <author> M. A. Steel, </author> <title> The complexity of reconstructing trees from qualitative characters and subtrees, </title> <journal> Journal of Classification, </journal> <volume> 9 (1992), </volume> <pages> pp. 91-116. </pages>
Reference-contexts: In the biology literature, the perfect phylogeny problem is more commonly known as the character compatibility problem [8, 9, 14, 15], where it was introduced in the 1950's. The perfect phylogeny problem was shown to be NP-complete by Bodlaender et al. [3] and, independently, by Steel <ref> [18] </ref>. This fact suggests at least two lines of attack: one is to restrict k, the number of characters; the other is to restrict r. The perfect phylogeny problem was shown to reduce to a graph-theoretic problem in [5] called the triangulating colored graphs problem.
Reference: [19] <author> T. Warnow, </author> <title> Constructing phylogenetic trees efficiently using compatibility criteria, </title> <journal> New Zealand Journal of Botany, 1993, </journal> <volume> Vol. 31: </volume> <pages> 239-248. </pages>
Reference-contexts: The algorithm that we have presented provides a tool which could be used by biologists to efficiently construct maximal subsets of compatible characters in a greedy manner. This greedy heuristic has already been shown to produce extremely reasonable phylogenetic trees <ref> [19] </ref> for biological data and for trees on natural languages [17].
References-found: 19

