URL: ftp://dimacs.rutgers.edu/pub/dimacs/TechnicalReports/TechReports/1997/97-81.ps.gz
Refering-URL: http://dimacs.rutgers.edu/TechnicalReports/1997.html
Root-URL: http://www.cs.rutgers.edu
Email: Email: beimel@deas.harvard.edu.  Email: panni@cs.utexas.edu.  
Title: On Arithmetic Branching Programs  
Author: by Amos Beimel Anna Gal 
Affiliation: Dept. of Computer Sciences, The University of Texas at  Dept. of Computer Science of Princeton University.  
Address: MA 02138.  Austin,  
Date: 1997  
Note: December  Supported by grants ONR-M00014-96-1-0550 and ARO-DAAL03-92-G0115. Part of this work was done while the author was a postdoctoral fellow at DIMACS. 2  Part of this work was done while the author was a postdoctoral fellow at DIMACS and the  DIMACS is a partnership of Rutgers University, Princeton University, AT&T Labs-Research, Bell Labs and Bellcore. DIMACS is an NSF Science and Technology Center, funded under contract STC-91-19999; and also receives support from the New Jersey Commission on Science and Technology.  
Abstract: DIMACS Technical Report 97-81 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> E. Allender. </author> <title> Making computation count: Arithmetic circuits in the nineties. SIGACT NEWS, Complexity Theory Column, </title> <note> 1997. To appear. </note>
Reference-contexts: 1 Introduction Algebraic models of computation have received much attention (e.g. <ref> [18, 1] </ref>). One fundamental question is the power of basic algebraic operations. For example, if we can compute the rank of a matrix then we can check if the rows of the matrix are dependent.
Reference: [2] <author> E. Allender, R. Beals, and M. Ogihara. </author> <title> The complexity of matrix rank and feasible systems of linear equations. </title> <booktitle> In Proc. of the 28th Annu. ACM Symp. on the Theory of Computing, </booktitle> <pages> pages 161-167, </pages> <year> 1996. </year>
Reference-contexts: That is, a function has a small mod-p branching program if and only if the function has a small span program over GF (p). Span programs were considered also in <ref> [5, 3, 4, 2] </ref>. Pudlak and Sgall [14] defined a similar model called dependency programs. They proved that span programs are at least as strong as dependency programs. It is not known whether span programs are actually stronger. We give precise definitions of the above models in the next section. <p> Thus, the three open problems are equivalent. We note that the uniform version of these problems over the rationals is equivalent to an open problem in <ref> [2] </ref>. We should mention that span programs and arithmetic programs are equivalent over fixed finite fields up to polynomial factors. The size of the arithmetic program simulating the span program depends on the number of elements in the field.
Reference: [3] <author> L. Babai, A. Gal, J. Kollar, L. Ronyai, T. Szabo, and A. Wigderson. </author> <title> Extremal bipartite graphs and superpolynomial lower bounds for monotone span programs. </title> <booktitle> In Proc. of the 28th Annu. ACM Symp. on the Theory of Computing, </booktitle> <pages> pages 603-611, </pages> <year> 1996. </year>
Reference-contexts: That is, a function has a small mod-p branching program if and only if the function has a small span program over GF (p). Span programs were considered also in <ref> [5, 3, 4, 2] </ref>. Pudlak and Sgall [14] defined a similar model called dependency programs. They proved that span programs are at least as strong as dependency programs. It is not known whether span programs are actually stronger. We give precise definitions of the above models in the next section.
Reference: [4] <author> L. Babai, A. Gal, and A. Wigderson. </author> <title> Superpolynomial lower bounds for monotone span programs. </title> <note> Submitted for publication, </note> <year> 1996. </year>
Reference-contexts: That is, a function has a small mod-p branching program if and only if the function has a small span program over GF (p). Span programs were considered also in <ref> [5, 3, 4, 2] </ref>. Pudlak and Sgall [14] defined a similar model called dependency programs. They proved that span programs are at least as strong as dependency programs. It is not known whether span programs are actually stronger. We give precise definitions of the above models in the next section. <p> We next claim that arithmetic programs over GF (q d ) can be simulated by arithmetic programs over GF (q). The proof is similar to the simulation in Lemma 4.1. A similar result for span programs was proved in [10] (see also <ref> [4] </ref>). Lemma 6.3 Let d be a positive integer and q be a prime-power. Then, AP GF (q) (f) 2d 4 AP GF (q d ) (f).
Reference: [5] <author> A. Beimel, A. Gal, and M. Paterson. </author> <title> Lower bounds for monotone span programs. </title> <journal> Computational Complexity, </journal> <volume> 6(1) </volume> <pages> 29-45, </pages> <year> 1997. </year> <note> Conference version: FOCS '95. </note>
Reference-contexts: That is, a function has a small mod-p branching program if and only if the function has a small span program over GF (p). Span programs were considered also in <ref> [5, 3, 4, 2] </ref>. Pudlak and Sgall [14] defined a similar model called dependency programs. They proved that span programs are at least as strong as dependency programs. It is not known whether span programs are actually stronger. We give precise definitions of the above models in the next section.
Reference: [6] <author> S. J. Berkowitz. </author> <title> On computing the determinant in small parallel time using a small number of processors. </title> <journal> Inform. Process. Lett., </journal> <volume> 18 </volume> <pages> 147-150, </pages> <year> 1984. </year>
Reference-contexts: That is, a function f has a small arithmetic program if and only if its complement f has a small dependency program. Our proof combines results on the computation of the rank <ref> [12, 6] </ref> and the closure of arithmetic programs under disjunction. Our results also imply that dependency programs are closed under conjunction, solving an open problem in [14]. Furthermore, we show that span programs can simulate arithmetic programs very efficiently. <p> We begin with an arithmetic program that checks if the rank of a given matrix is at least r. This arithmetic program is used to construct an arithmetic program which simulates the complement of the dependency program. The construction is based on the results of <ref> [6, 12] </ref> that show that the computation of the rank of a matrix can be done in N C 2 . We start with some notation. <p> Proof: The proof is composed of two parts. We first use a result of Mulmuley [12] which reduces the problem of computing the rank to the problem of computing the characteristic polynomial. Then we use an arithmetic program simulating the construction of Berkowitz <ref> [6] </ref> that computes the coefficients of the characteristic polynomial. There are some technical details left since the result of [12] uses some extension field of K, and we need to simulate the arithmetic over this field by an arithmetic program over K. This simulation uses Corollary 3.5. <p> Thus, each coefficient of the characteristic polynomial det (I B (u)) is a polynomial of ff of degree less than 4s 2 . The result of Berkowitz <ref> [6] </ref> implies that there is an arithmetic program that checks if a given coefficient of the characteristic polynomial is non-zero (for an alternative construction see Mahajan and Vinay [11]).
Reference: [7] <author> G. Buntrock, C. Damm, H. Hertrampf, and C. Meinel. </author> <title> Structure and importance of the logspace-mod class. </title> <journal> Math. Systems Theory, </journal> <volume> 25 </volume> <pages> 223-237, </pages> <year> 1992. </year>
Reference-contexts: This model corresponds to nondeterministic logspace Turing machines that count the number of accepting paths. Modular branching programs have been defined and studied in <ref> [7, 10] </ref>, and were used to construct private simultaneous protocols in [9]. Modular branching programs are also referred to in the literature as counting branching programs. <p> We investigate the relations between arithmetic branching programs and two other algebraic models: span programs [10] and dependency programs [14]. Karchmer and Wigder-son [10] defined span programs and showed, using results of <ref> [7] </ref>, that over fixed finite fields they are equivalent to modular branching programs. That is, a function has a small mod-p branching program if and only if the function has a small span program over GF (p). Span programs were considered also in [5, 3, 4, 2]. <p> Furthermore, we show that span programs can simulate arithmetic programs very efficiently. For every function f it holds that SP K (f ) 2 AP K (f ). This generalizes the result of [10] for programs over GF (2). For other fields only a polynomial relation was known <ref> [7, 14] </ref>. Our last result shows that, over any field, arithmetic programs can efficiently simulate nondeterministic branching programs. This generalizes a result of Wigderson [19] that modular branching programs over GF (2) (and any fixed finite field) can simulate nondeterministic branching programs (e.g., N L/poly L/poly). <p> Furthermore, constant edges can be eliminated if we replace every edge labeled by 1 by two parallel edges, one labeled by x 1 and the other by x 1 . A mod-p branching program <ref> [7, 10] </ref> is an arithmetic program over GF (p) where the weight of every edge is 1.
Reference: [8] <author> J. F. Buss, G. S. Frandsen, and J. O. Shallit. </author> <title> The computational complexity of some problems of linear algebra. </title> <editor> In R. Reischuk and M. Morvan, editors, </editor> <booktitle> STACS '97, volume 1200 of Lecture Notes in Computer Science, </booktitle> <pages> pages 451-462. </pages> <publisher> Springer, </publisher> <year> 1997. </year> <note> See also: ECCC report TR97-009, http://www.eccc.uni-trier.de/eccc/. - 16 </note> - 
Reference-contexts: The arithmetic program is illustrated in Fig. 1. C 1 C 2 s t The arithmetic program for f 1 _f 2 is more complicated. The first construction works only over fields which are not algebraically closed. We use the following lemma of <ref> [8] </ref>. We include its proof for completeness. Lemma 3.2 Let d 2.
Reference: [9] <author> Y. Ishai and E. Kushilevitz. </author> <title> Private simultaneous messages protocols with applications. </title> <booktitle> In 5th Israel Symp. on Theory of Computing and Systems, </booktitle> <pages> pages 174-183, </pages> <year> 1997. </year>
Reference-contexts: This model corresponds to nondeterministic logspace Turing machines that count the number of accepting paths. Modular branching programs have been defined and studied in [7, 10], and were used to construct private simultaneous protocols in <ref> [9] </ref>. Modular branching programs are also referred to in the literature as counting branching programs. An arithmetic branching program (over a field K) is a branching program where every edge in the graph has a weight which is a number taken from the field K.
Reference: [10] <author> M. Karchmer and A. Wigderson. </author> <title> On span programs. </title> <booktitle> In Proc. of the 8th Annu. IEEE Structure in Complexity Theory, </booktitle> <pages> pages 102-111, </pages> <year> 1993. </year>
Reference-contexts: This model corresponds to nondeterministic logspace Turing machines that count the number of accepting paths. Modular branching programs have been defined and studied in <ref> [7, 10] </ref>, and were used to construct private simultaneous protocols in [9]. Modular branching programs are also referred to in the literature as counting branching programs. <p> The size of an arithmetic program is the number of edges in the graph. Clearly, a mod-p branching program is an arithmetic program over GF (p) where the weight of every edge is 1. We investigate the relations between arithmetic branching programs and two other algebraic models: span programs <ref> [10] </ref> and dependency programs [14]. Karchmer and Wigder-son [10] defined span programs and showed, using results of [7], that over fixed finite fields they are equivalent to modular branching programs. <p> Clearly, a mod-p branching program is an arithmetic program over GF (p) where the weight of every edge is 1. We investigate the relations between arithmetic branching programs and two other algebraic models: span programs <ref> [10] </ref> and dependency programs [14]. Karchmer and Wigder-son [10] defined span programs and showed, using results of [7], that over fixed finite fields they are equivalent to modular branching programs. That is, a function has a small mod-p branching program if and only if the function has a small span program over GF (p). <p> Furthermore, we show that span programs can simulate arithmetic programs very efficiently. For every function f it holds that SP K (f ) 2 AP K (f ). This generalizes the result of <ref> [10] </ref> for programs over GF (2). For other fields only a polynomial relation was known [7, 14]. Our last result shows that, over any field, arithmetic programs can efficiently simulate nondeterministic branching programs. <p> The size of the smallest arithmetic program over K that computes f is denoted by AP K (f ). In the definition of the size of an arithmetic branching program we ignore edges labeled by 1. This is the common assumption in the definition of any branching program (e.g. <ref> [15, 10] </ref>). We can assume, w.l.o.g., that there are no parallel edges labeled by 1 and every vertex touches an edge labeled by a literal, hence the number of edges labeled by 1 is at most the square of the number of edges labeled by a literal. <p> Furthermore, constant edges can be eliminated if we replace every edge labeled by 1 by two parallel edges, one labeled by x 1 and the other by x 1 . A mod-p branching program <ref> [7, 10] </ref> is an arithmetic program over GF (p) where the weight of every edge is 1. <p> A mod-p branching program [7, 10] is an arithmetic program over GF (p) where the weight of every edge is 1. The program accepts an assignment if the number of consistent paths is not equal to 0 mod-p. 1 1 In <ref> [10] </ref> the accepting criterion is different; the program accepts if the number of consistent paths is equal to 1 mod-p. - 4 - Definition 2.2 (Span Programs [10]) A span program over K is a triplet c M = hM; ; vi, where M is a matrix over K, v is <p> The program accepts an assignment if the number of consistent paths is not equal to 0 mod-p. 1 1 In <ref> [10] </ref> the accepting criterion is different; the program accepts if the number of consistent paths is equal to 1 mod-p. - 4 - Definition 2.2 (Span Programs [10]) A span program over K is a triplet c M = hM; ; vi, where M is a matrix over K, v is a non-zero row vector called the target vector (it has the same number of coordinates as the number of columns in M ), and is a labeling <p> So, f b f b (u)1 is also in span (M u ). This completes proving both claims. We have proved that the span program c M accepts exactly those inputs that satisfy f , as desired. Theorem 5.1 is a generalization of a result of Karchmer and Wigderson <ref> [10] </ref>, who proved the theorem over GF (2). The construction of the span program in our proof is a generalization of their construction with a somewhat simpler proof. The constant 2 in Theorem 5.1 cannot be replaced by any smaller constant. <p> We next claim that arithmetic programs over GF (q d ) can be simulated by arithmetic programs over GF (q). The proof is similar to the simulation in Lemma 4.1. A similar result for span programs was proved in <ref> [10] </ref> (see also [4]). Lemma 6.3 Let d be a positive integer and q be a prime-power. Then, AP GF (q) (f) 2d 4 AP GF (q d ) (f). <p> That is, SP K (f ) = O (n NBP (f)). We simulate the arith metic program of Lemma 6.2 over an extension field with at least 2 2n elements by a span program using Theorem 5.1. The span program over smaller fields is obtained by the result of <ref> [10] </ref> stating that SP GF (q) (f ) d SP GF (q d ) (f ) : 7 Open Problems We mention three open problems that arise from our work.
Reference: [11] <author> M. Mahajan and V Vinay. </author> <title> A combinatorial algorithm for the determinant. </title> <booktitle> In Proc. of the 8th Annu. ACM-SIAM Symp. on Discrete Algorithms, </booktitle> <pages> pages 730-738, </pages> <year> 1997. </year>
Reference-contexts: The result of Berkowitz [6] implies that there is an arithmetic program that checks if a given coefficient of the characteristic polynomial is non-zero (for an alternative construction see Mahajan and Vinay <ref> [11] </ref>). That is, given a matrix B (x) over the field K (ff) and an integer ` there is an arithmetic program, denoted C ` , which accepts all the assignments u such that the coefficient of ` in the characteristic polynomial of B (u) is non-zero.
Reference: [12] <author> K. Mulmuley. </author> <title> A fast parallel algorithm to compute the rank of a matrix over an arbitrary field. </title> <journal> Combinatorica, </journal> <volume> 7 </volume> <pages> 101-104, </pages> <year> 1987. </year>
Reference-contexts: That is, a function f has a small arithmetic program if and only if its complement f has a small dependency program. Our proof combines results on the computation of the rank <ref> [12, 6] </ref> and the closure of arithmetic programs under disjunction. Our results also imply that dependency programs are closed under conjunction, solving an open problem in [14]. Furthermore, we show that span programs can simulate arithmetic programs very efficiently. <p> We begin with an arithmetic program that checks if the rank of a given matrix is at least r. This arithmetic program is used to construct an arithmetic program which simulates the complement of the dependency program. The construction is based on the results of <ref> [6, 12] </ref> that show that the computation of the rank of a matrix can be done in N C 2 . We start with some notation. <p> Furthermore, let A (x) be an s fi s matrix. There exists an arithmetic program of size s O (1) which accepts an input u if and only if rank (A (u)) r. Proof: The proof is composed of two parts. We first use a result of Mulmuley <ref> [12] </ref> which reduces the problem of computing the rank to the problem of computing the characteristic polynomial. Then we use an arithmetic program simulating the construction of Berkowitz [6] that computes the coefficients of the characteristic polynomial. There are some technical details left since the result of [12] uses some extension <p> result of Mulmuley <ref> [12] </ref> which reduces the problem of computing the rank to the problem of computing the characteristic polynomial. Then we use an arithmetic program simulating the construction of Berkowitz [6] that computes the coefficients of the characteristic polynomial. There are some technical details left since the result of [12] uses some extension field of K, and we need to simulate the arithmetic over this field by an arithmetic program over K. This simulation uses Corollary 3.5. <p> That is, the elements of the field K (ff) are of the form p (ff)=q (ff) where p (ff) and q (ff) are polynomials in ff over the field K (there is no bound on their degrees); addition and multiplication are of polynomials. Following Mulmuley <ref> [12] </ref>, we - 8 - transform the s fi s matrix A (x) over K to an 2s fi 2s matrix B (x) over the field K (ff). Let X be a 2s fi 2s diagonal matrix where X i;i = ff i1 and the other entries are 0. <p> Let X be a 2s fi 2s diagonal matrix where X i;i = ff i1 and the other entries are 0. Let B (x) 4 = X O A (x) ! Mulmuley <ref> [12] </ref> proved that for every u 2 f0; 1g n it holds that rank (B (u)) = 2 rank (A (u)); and the rank of the matrix B (u) is 2s i, where i is the smallest index such that the coefficient of i in the characteristic polynomial of B, i.e.
Reference: [13] <author> N. Nisan. </author> <title> Lower bounds for non-commutative computation. </title> <booktitle> In Proc. of the 23th Annu. ACM Symp. on the Theory of Computing, </booktitle> <pages> pages 410-418, </pages> <year> 1991. </year>
Reference-contexts: However, we give an alternative construction which is more efficient, i.e., the resulting arithmetic program is smaller. Remark: Nisan <ref> [13] </ref> considered a similar complexity model called algebraic branching programs. These programs compute a function from R n to R (where R is a ring), while arithmetic branching programs compute functions from f0; 1g n to f0; 1g. The motivation of [13] was to prove lower bounds on non-commutative computations. <p> Remark: Nisan <ref> [13] </ref> considered a similar complexity model called algebraic branching programs. These programs compute a function from R n to R (where R is a ring), while arithmetic branching programs compute functions from f0; 1g n to f0; 1g. The motivation of [13] was to prove lower bounds on non-commutative computations. Organization: In Section 2 we define the computational models we consider. In Section 3 we prove that arithmetic programs are closed under conjunction and disjunction.
Reference: [14] <author> P. Pudlak and J. Sgall. </author> <title> Algebraic models of computation and interpolation for algebraic proof systems. </title> <editor> In S. Buss, editor, </editor> <title> Feasible Arithmetic and Lengths of Proofs, </title> <booktitle> Lecture Notes in Computer Science. </booktitle> <publisher> Springer, </publisher> <year> 1996. </year> <note> To appear. </note>
Reference-contexts: Clearly, a mod-p branching program is an arithmetic program over GF (p) where the weight of every edge is 1. We investigate the relations between arithmetic branching programs and two other algebraic models: span programs [10] and dependency programs <ref> [14] </ref>. Karchmer and Wigder-son [10] defined span programs and showed, using results of [7], that over fixed finite fields they are equivalent to modular branching programs. That is, a function has a small mod-p branching program if and only if the function has a small span program over GF (p). <p> That is, a function has a small mod-p branching program if and only if the function has a small span program over GF (p). Span programs were considered also in [5, 3, 4, 2]. Pudlak and Sgall <ref> [14] </ref> defined a similar model called dependency programs. They proved that span programs are at least as strong as dependency programs. It is not known whether span programs are actually stronger. We give precise definitions of the above models in the next section. <p> We give precise definitions of the above models in the next section. We denote the size of the smallest span program, dependency program and arithmetic program for f by SP K (f), DP K (f ) and AP K (f ) respectively. Pudlak and Sgall <ref> [14] </ref> proved that (SP K (f)) 1 (only modular branching programs were considered in [14], however their proof holds for arithmetic programs over arbitrary fields). An easy modification of the arguments in [14] - 2 - gives DP K f 2 AP K (f) : (1) It is simple to show <p> We denote the size of the smallest span program, dependency program and arithmetic program for f by SP K (f), DP K (f ) and AP K (f ) respectively. Pudlak and Sgall <ref> [14] </ref> proved that (SP K (f)) 1 (only modular branching programs were considered in [14], however their proof holds for arithmetic programs over arbitrary fields). An easy modification of the arguments in [14] - 2 - gives DP K f 2 AP K (f) : (1) It is simple to show that arithmetic programs are closed under conjunction. <p> Pudlak and Sgall <ref> [14] </ref> proved that (SP K (f)) 1 (only modular branching programs were considered in [14], however their proof holds for arithmetic programs over arbitrary fields). An easy modification of the arguments in [14] - 2 - gives DP K f 2 AP K (f) : (1) It is simple to show that arithmetic programs are closed under conjunction. Our first technical result is showing that arithmetic programs are closed under disjunction. We present two constructions. <p> Since finite fields are not algebraically closed, we prove the closure under disjunction of arithmetic programs over any field. Our second technical result is that AP K (f ) O (1) over any field K. This result, together with results of <ref> [14] </ref>, implies that arithmetic programs are equivalent to complements of dependency programs (up to a polynomial factor in size). That is, a function f has a small arithmetic program if and only if its complement f has a small dependency program. <p> Our proof combines results on the computation of the rank [12, 6] and the closure of arithmetic programs under disjunction. Our results also imply that dependency programs are closed under conjunction, solving an open problem in <ref> [14] </ref>. Furthermore, we show that span programs can simulate arithmetic programs very efficiently. For every function f it holds that SP K (f ) 2 AP K (f ). This generalizes the result of [10] for programs over GF (2). <p> Furthermore, we show that span programs can simulate arithmetic programs very efficiently. For every function f it holds that SP K (f ) 2 AP K (f ). This generalizes the result of [10] for programs over GF (2). For other fields only a polynomial relation was known <ref> [7, 14] </ref>. Our last result shows that, over any field, arithmetic programs can efficiently simulate nondeterministic branching programs. This generalizes a result of Wigderson [19] that modular branching programs over GF (2) (and any fixed finite field) can simulate nondeterministic branching programs (e.g., N L/poly L/poly). <p> The choice of the fixed vector v does not effect the size of the span program. It is always possible to replace v with any non-zero vector by changing the basis of the matrix M . The default value for the target vector is 1. Definition 2.3 (Dependency Programs <ref> [14] </ref>) A dependency program over K is a pair c M = hM; i, where M is a matrix over K, and is a labeling of the rows of M by literals from fx 1 ; : : : ; x n ; x 1 ; : : : ; x <p> The size of c M is the number of rows in M . The size of the smallest dependency program over K that computes f is denoted by DP K (f ). In <ref> [14] </ref>, the size of both dependency programs and span programs is defined as the number of columns in the matrix. <p> AP K @ i=k=2+1 1 1 k X AP K (f i ) : - 7 - If k is not a power of two then AP K W k P k i=1 AP K (f i ) holds. 4 Arithmetic Programs are Equivalent to Complements of Dependency Programs In <ref> [14] </ref> it was proved that if a function f has a small arithmetic program then its complement f has a small dependency program. In this section we prove the converse; if f has a small dependency program then the function f has a small arithmetic program. <p> In this section we prove the converse; if f has a small dependency program then the function f has a small arithmetic program. In particular this implies that dependency programs are closed under conjunction in every field, solving an open problem in <ref> [14] </ref>. We begin with an arithmetic program that checks if the rank of a given matrix is at least r. This arithmetic program is used to construct an arithmetic program which simulates the complement of the dependency program. <p> As we have mentioned already in the introduction, the simulation in the other direction, namely DP K (f ) 2 AP K follows from the arguments of <ref> [14] </ref>. The results of [14] are stated only for modular branching programs, however they easily generalize to arithmetic branching programs and imply DP K (f ) O 2 . An easy modification of the proof in [14] gives DP K (f ) 2 AP K . <p> As we have mentioned already in the introduction, the simulation in the other direction, namely DP K (f ) 2 AP K follows from the arguments of <ref> [14] </ref>. The results of [14] are stated only for modular branching programs, however they easily generalize to arithmetic branching programs and imply DP K (f ) O 2 . An easy modification of the proof in [14] gives DP K (f ) 2 AP K . <p> direction, namely DP K (f ) 2 AP K follows from the arguments of <ref> [14] </ref>. The results of [14] are stated only for modular branching programs, however they easily generalize to arithmetic branching programs and imply DP K (f ) O 2 . An easy modification of the proof in [14] gives DP K (f ) 2 AP K . For completeness we prove this statement in Appendix B. The next corollary is an immediate consequence of (1), Theorem 4.2 and Corollary 3.5. Corollary 4.3 Let k be a power of 2. <p> The reason is that the conversion from an arithmetic program to a dependency program results in a non-monotone program. In <ref> [14] </ref> it is proved that every monotone dependency program for the function (x 1 _x 2 )^(x 3 _x 4 )^ : : : ^(x n1 _x n ) has size at least 2 n =n.
Reference: [15] <author> A. A. Razborov. </author> <title> Lower bounds for deterministic and nondeterministic branching programs. </title> <editor> In L. Budach, editor, </editor> <booktitle> Proceedings of Fundamentals of Computation Theory (FCT '91), volume 529 of Lecture Notes in Computer Science, </booktitle> <pages> pages 47-60. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: The size of the smallest arithmetic program over K that computes f is denoted by AP K (f ). In the definition of the size of an arithmetic branching program we ignore edges labeled by 1. This is the common assumption in the definition of any branching program (e.g. <ref> [15, 10] </ref>). We can assume, w.l.o.g., that there are no parallel edges labeled by 1 and every vertex touches an edge labeled by a literal, hence the number of edges labeled by 1 is at most the square of the number of edges labeled by a literal. <p> We give an alternative construction which is more efficient, i.e., the resulting arithmetic program is smaller (see Theorem 6.4). We note that there are different definitions for nondeterministic branching programs in different papers. For more information on nondeterministic branching programs the reader can refer for example to <ref> [15] </ref>. In this paper a nondeterministic branching program is a quadruple hG; ; s; ti where G is a directed acyclic graph, is a labeling of the edges by literals and s and t are vertices.
Reference: [16] <author> K. Reinhardt and E. Allender. </author> <title> Making nondeterminism unambiguous. </title> <booktitle> In Proc. of the 38th Annu. IEEE Symp. on Foundations of Computer Science, </booktitle> <pages> pages 244-253, </pages> <year> 1977. </year>
Reference-contexts: The construction of Wigderson [19] directly generalizes to arithmetic programs over arbitrary fields. The efficient simulation of nondeterministic branching programs by arithmetic programs over any field also follows from a recent result of Reinhardt and Allender <ref> [16] </ref> who proved, using the construction of [19], that N L/poly = U L/poly. However, we give an alternative construction which is more efficient, i.e., the resulting arithmetic program is smaller. Remark: Nisan [13] considered a similar complexity model called algebraic branching programs.
Reference: [17] <author> C. </author> <title> Small. Arithmetic of finite fields. </title> <editor> M. Dekker, </editor> <year> 1991. </year>
Reference: [18] <author> V. Strassen. </author> <title> Algebraic complexity theory. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume A, chapter 11, </booktitle> <pages> pages 635-672. </pages> <publisher> Elsevier and The MIT press, </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction Algebraic models of computation have received much attention (e.g. <ref> [18, 1] </ref>). One fundamental question is the power of basic algebraic operations. For example, if we can compute the rank of a matrix then we can check if the rows of the matrix are dependent.
Reference: [19] <author> A. Wigderson. N L=poly L=poly. </author> <booktitle> In Proc. of the 9th Annu. IEEE Structure in Complexity Theory, </booktitle> <pages> pages 59-62, </pages> <year> 1994. </year> <note> Journal version: </note> <author> A. Gal and A. Wigderson, </author> <title> Boolean Complexity Classes vs. Their Arithmetic Analogs, Random Structures and Algorithms, </title> <booktitle> 9 </booktitle> <pages> 99-111, </pages> <year> 1996. </year>
Reference-contexts: This generalizes the result of [10] for programs over GF (2). For other fields only a polynomial relation was known [7, 14]. Our last result shows that, over any field, arithmetic programs can efficiently simulate nondeterministic branching programs. This generalizes a result of Wigderson <ref> [19] </ref> that modular branching programs over GF (2) (and any fixed finite field) can simulate nondeterministic branching programs (e.g., N L/poly L/poly). The construction of Wigderson [19] directly generalizes to arithmetic programs over arbitrary fields. <p> Our last result shows that, over any field, arithmetic programs can efficiently simulate nondeterministic branching programs. This generalizes a result of Wigderson <ref> [19] </ref> that modular branching programs over GF (2) (and any fixed finite field) can simulate nondeterministic branching programs (e.g., N L/poly L/poly). The construction of Wigderson [19] directly generalizes to arithmetic programs over arbitrary fields. The efficient simulation of nondeterministic branching programs by arithmetic programs over any field also follows from a recent result of Reinhardt and Allender [16] who proved, using the construction of [19], that N L/poly = U L/poly. <p> The construction of Wigderson <ref> [19] </ref> directly generalizes to arithmetic programs over arbitrary fields. The efficient simulation of nondeterministic branching programs by arithmetic programs over any field also follows from a recent result of Reinhardt and Allender [16] who proved, using the construction of [19], that N L/poly = U L/poly. However, we give an alternative construction which is more efficient, i.e., the resulting arithmetic program is smaller. Remark: Nisan [13] considered a similar complexity model called algebraic branching programs. <p> Wigderson <ref> [19] </ref> proved that modular branching programs over GF (2) (and any fixed finite field) can simulate nondeterministic branching programs (e.g., N L/poly L/poly). The construction of Wigderson [19] directly gener alizes to arithmetic programs over arbitrary fields, and yields arithmetic programs of size O njV j 2 (NBP (f )) , <p> Wigderson <ref> [19] </ref> proved that modular branching programs over GF (2) (and any fixed finite field) can simulate nondeterministic branching programs (e.g., N L/poly L/poly). The construction of Wigderson [19] directly gener alizes to arithmetic programs over arbitrary fields, and yields arithmetic programs of size O njV j 2 (NBP (f )) , where n is the number of variables, jV j is the number of vertices and NBP (f ) is the size of the smallest the nondeterministic branching
References-found: 19

