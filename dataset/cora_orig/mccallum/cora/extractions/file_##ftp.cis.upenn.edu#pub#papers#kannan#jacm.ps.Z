URL: file://ftp.cis.upenn.edu/pub/papers/kannan/jacm.ps.Z
Refering-URL: http://www.cis.upenn.edu/~kannan/home.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Designing programs that check their work checked. The other theorem establishes equivalence classes of problems
Author: Manuel Blum Sampath Kannan 
Web: D.2.4 F.2.0 F.3.1 G.3  
Note: Subject Classification  Two strucural theorems are proven here. One is a characterization of problems that can be  Supported by NSF Grant #CCR88-13632 currently  
Address: Berkeley, CA 94720  Berkeley, CA 94720  Tucson, Arizona 85721  
Affiliation: Comp. Sci. Division U. of California  Comp. Sci. Division U. of California  at Department of Computer Science, University of Arizona,  
Abstract: A program correctness checker is an algorithm for checking the output of a computation. That is, given a program and an instance on which the program is run, the checker certifies whether the output of the program on that instance is correct. This paper defines the concept of a program checker. It designs program checkers for a few specific and carefully chosen problems in the class F P of functions computable in polynomial time. Problems in F P for which checkers are presented in this paper include Sorting, Matrix Rank and GCD. It also applies methods of modern cryptography, especially the idea of a probabilistic interactive proof, to the design of program checkers for group theoretic computations. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> L. Adleman, M. Huang, and K. Kompella. </author> <title> Efficient Checkers for Number-Theoretic Problems. </title> <note> Submitted to Information and Computation. </note>
Reference-contexts: No probabilistic polynomial-time algorithm is known for solving the group intersection problem. This is not surprising since graph isomorphism is polynomial-time reducible to group intersection. The following interactive proof protocol works for group intersection: 5.2.1 IP Protocol 1. The prover sends the verifier a set of permutations of <ref> [1; 2 : : :; n] </ref> which supposedly generate G " H. 2. The verifier checks that the elements sent by the prover actually lie in G " H. This involves testing membership in G and H which the verifier can do by the methods of [17]. <p> Adleman, Huang and Kompella <ref> [1] </ref> have recently given a probabilistic checker for the problem. An extension of the problem makes it easy to check. The idea of extending a problem (without incurring additional running time to solve the extended problem) is an important one in the area of program checking. Extended GCD . <p> Sorting is trivially checked in the comparison tree model. In this model, the inputs are the variables x 1 ; x 2 ; : : : ; x n while the output is given by an ordering of the input variables: For some permutation of <ref> [1, : : : , n] </ref>, the output is x (1) x (2) x (n) . The checker for sorting has only to confirm that the output inequalities are all valid. <p> Here is a different hash function that does work. Recall that n = jXj = jY j. Let m = n+1. Select a random prime p from the interval <ref> [1, 3alog m] </ref>. Set h (x) = m x mod p. Observe that X = Y if and only if P P m y i . Indeed if X = Y , then P P for all primes p. <p> Indeed if X = Y , then P P for all primes p. If X 6= Y then P P m y i and as pointed out by Karp and Rabin [25] P P m y i mod p for at least half of all primes in the interval <ref> [1, 3a log m] </ref>. The choice of the interval size arises from an estimate of how large P m x i can get. Since the sum is over n terms and each term is bounded by m a , the sum is no bigger than n m a . <p> Since m = n + 1, a bound for the sum is m a+1 . The interval has then to be chosen to be a suitable constant times log m a+1 . Thus [25] shows that for primes randomly chosen in the interval <ref> [1, 3 a log m] </ref> the hash function has a probability of at least 1/2 of catching an error. Method 2: This idea was first suggested by Lipton [29] and more recently by Ravi Kannan [23]. <p> In the computation of the product f (z) each term is bounded in absolute value by a + 2n and hence the product is bounded by (a + 2n) n . Thus according to [25] the primes have to be chosen approximately in the range <ref> [1; n log (a + 2n)] </ref>.
Reference: [2] <author> L. Babai and S. Moran. </author> <title> Arthur-Merlin Games: A Randomized Proof System, and a Hierarchy of Complexity Classes. </title> <journal> J. Comput. System Sci. </journal> <volume> 36 (1988), </volume> <pages> 254-276. </pages>
Reference-contexts: We first design an interactive proof system and then show that this interactive proof system can be converted into a checker. Babai and Moran <ref> [2] </ref> have independently (and earlier) provided an interactive proof system for group intersection. We use the checker for group intersection and Beigel's trick to obtain checkers for several problems that are known to be polynomially equivalent to group intersection.
Reference: [3] <author> J. Barwise. </author> <title> Mathematical Proofs of Computer System Correctness. </title> <journal> Notices of the AMS, </journal> <volume> vol. 36, number 7 (1989). </volume>
Reference: [4] <author> D. Beaver and J. Feigenbaum. </author> <title> Hiding Instances in Multioracle Queries. </title> <booktitle> In Proceedings of the 7th Symposium on Theoretical Aspects of Computer Science. Lecture Notes in Computer Science, </booktitle> <volume> vol. 415, </volume> <publisher> Springer, </publisher> <address> Berlin (1990), </address> <pages> 37-48. </pages>
Reference: [5] <author> R. Beigel and J. Feigenbaum. </author> <title> On Being Incoherent Without Being Very Hard. </title> <booktitle> Computational Complexity 2 (1992), </booktitle> <pages> 1-17. </pages>
Reference: [6] <author> M. Blum and S. Kannan. </author> <title> Designing Programs That Check Their Work. </title> <booktitle> In Proceedings of the 21st ACM Symposium on Theory of Computing (Seattle, </booktitle> <address> Wash. May 15-17). </address> <publisher> ACM, </publisher> <address> New York, </address> <year> (1989), </year> <pages> 86-97. </pages>
Reference: [7] <author> M. Blum, M. Luby, and R. Rubinfeld. </author> <title> Self-Testing and Self-Correcting Programs with Applications to Numerical Problems. </title> <booktitle> In Proceedings of the 22nd Symposium on Theory of Computing (Baltimore, </booktitle> <address> MD. May 14-16). ACM New York (1990), 73-83. </address> <note> Final version to appear in J. </note> <institution> Comput Syst. Sci. </institution> <month> 39 </month>
Reference-contexts: Our checker for rank is mainly of theoretical interest. It satisfies the little oh property as required. However it makes O (n 2 ) calls to the program being checked and hence would be highly inefficient to implement in practice. Blum, Luby, and Rubinfeld <ref> [7] </ref> have subsequently discovered a very practical checker for matrix rank. However, their 28 checker does not conform to the original definition of checking.
Reference: [8] <author> M. Blum, W. Evans, P. Gemmell, S. Kannan, and M. Naor. </author> <title> Checking the Correctness of Memories. </title> <booktitle> Proceedings of the 32nd Symposium on Foundations of Computing (San Juan, PR Oct. </booktitle> <pages> 1-4). </pages> <publisher> IEEE Computer Society, Los Alamitos (1991), </publisher> <pages> 90-99. </pages> <note> Final version to appear in Algorithmica. </note>
Reference: [9] <author> R.S. Boyer and J.S. Moore. </author> <title> The Correctness Problem in Computer Science. </title> <publisher> Academic Press, </publisher> <address> London (1981). </address>
Reference: [10] <author> T.A. Budd and D. Angluin. </author> <title> Two notions of Correctness and Their Relation to Testing. </title> <journal> Acta Informatica, </journal> <month> 18 </month> <year> (1982) </year> <month> 31-45. </month>
Reference: [11] <author> S.A. Cook. </author> <title> A Taxonomy of Problems with Fast Parallel Algorithms. </title> <journal> Information and Control, </journal> <volume> 64 (1985), </volume> <pages> 2-22. </pages>
Reference: [12] <author> R.A. DeMillo, W.M. McCracken, R.J. Martin, and J.F. Passafiume. </author> <title> Software Testing and Evaluation. </title> <publisher> The Benjamin Cummings Publishing Company, </publisher> <address> Redwood City (1987). </address>
Reference: [13] <author> R.A. De Millo, R.J. Lipton, and A.J. Perlis. </author> <title> Social Processes and Proofs of Theorems and Programs. </title> <journal> Comm. ACM, </journal> <volume> 22 No. </volume> <month> 5 </month> <year> (1979). </year>
Reference: [14] <author> J. Feigenbaum. </author> <title> Locally Random Reductions in Interactive Complexity Theory. </title> <booktitle> In Advances in Computational Complexity, DIMACS Series in Discrete Mathematics and Theoretical Computer Science, </booktitle> <volume> vol. 13, </volume> <publisher> AMS, </publisher> <address> Providence (1993), </address> <pages> 73-98. </pages>
Reference: [15] <author> J. Feigenbaum and L. Fortnow. </author> <title> Random-Self-Reducibility of Complete Sets. </title> <journal> SIAM J. Comput., </journal> <volume> 22 (1993), </volume> <pages> 994-1005. </pages>
Reference: [16] <author> R. Freivalds. </author> <title> Fast Probabilistic Algorithms. </title> <booktitle> In Springer Verlag Lecture Notes in CS #74, Mathematical Foundations of CS (1979), </booktitle> <pages> 57-69. 40 </pages>
Reference: [17] <author> M. Furst, J.E. Hopcroft, E. Luks. </author> <title> Polynomial-Time Algorithms for Permutation Groups. </title> <booktitle> In Proceedings 21st IEEE Symposium on Foundations of Computer Science. </booktitle> <publisher> IEEE Computer Society, Los Alamitos (1980), </publisher> <pages> 36-41. </pages>
Reference-contexts: The verifier checks that the elements sent by the prover actually lie in G " H. This involves testing membership in G and H which the verifier can do by the methods of <ref> [17] </ref>. As a 19 consequence the verifier is convinced that the elements sent by the prover either generate G " H or a proper subgroup of it. 3. <p> Lemma 5.2 FDP is equivalent to FSP. 21 Proof: It is obvious that FDP reduces to FSP. All that remains to be shown is that FSP reduces to FDP. The proof relies on the notion of `strong generators' introduced by <ref> [17] </ref>. Assume that we have strong generators for G and H as defined in Furst, Hopcroft, and Luks [17]. This can be assumed without loss of generality because any set of generators can be converted to a set of strong generators in polynomial time. <p> All that remains to be shown is that FSP reduces to FDP. The proof relies on the notion of `strong generators' introduced by <ref> [17] </ref>. Assume that we have strong generators for G and H as defined in Furst, Hopcroft, and Luks [17]. This can be assumed without loss of generality because any set of generators can be converted to a set of strong generators in polynomial time. Here is a brief description of the notion of strong generators, M G , for the group G.
Reference: [18] <author> O. Goldreich, S. Micali and A. Wigderson. </author> <title> Proofs that Yield Nothing But Their Validity or All Languages in NP Have Zero-Knowldege Proof Systems. </title> <journal> J. ACM, </journal> <volume> 38 (1991), </volume> <pages> 691-729. </pages>
Reference: [19] <author> S. Goldwasser, S. Micali, and C. Rackoff. </author> <title> The Knowledge Complexity of Interactive Proof Systems. </title> <journal> SIAM J. Comput., </journal> <volume> 18 (1989), </volume> <pages> 186-208. </pages>
Reference-contexts: For the purposes of this section a checker running in polynomial time will be called efficient. We take as our definition of IP (Interactive Proof-System) the definition appearing in Gold-wasser, Micali, and Rackoff <ref> [19] </ref>, except that we replace `for all sufficiently large x' in that definition by `for all x'. This modification of [19] conforms with the commonly accepted definition of IP as it appears, for example, in Goldwasser and Sipser [20], and Tompa and Woll [37]. <p> We take as our definition of IP (Interactive Proof-System) the definition appearing in Gold-wasser, Micali, and Rackoff <ref> [19] </ref>, except that we replace `for all sufficiently large x' in that definition by `for all x'. This modification of [19] conforms with the commonly accepted definition of IP as it appears, for example, in Goldwasser and Sipser [20], and Tompa and Woll [37].
Reference: [20] <author> S. Goldwasser and M. Sipser. </author> <title> Public Coins vs. Private Coins in Interactive Proof Systems. </title> <booktitle> In Advances in Computing Research | vol. 5: Randomness and Computation, </booktitle> <publisher> JAI Press, </publisher> <address> Greenwich (1989), </address> <pages> 73-90. </pages>
Reference-contexts: This modification of [19] conforms with the commonly accepted definition of IP as it appears, for example, in Goldwasser and Sipser <ref> [20] </ref>, and Tompa and Woll [37].
Reference: [21] <author> D. Gorenstein. </author> <title> Finite Simple Groups | An Introduction to Their Classification, </title> <publisher> Plenum Press, </publisher> <address> New York (1982). </address>
Reference-contexts: If G is not isomorphic to H, then G is not isomorphic to a random permutation H 0 of H. Computation has been used extensively as a tool in group theory. In fact the classification of finite simple groups <ref> [21] </ref> has both motivated and been aided by computer calculations. The classification has shown that there are just 26 groups that do not belong to any infinite family of groups. These 26 groups are referred to as the sporadic groups.
Reference: [22] <author> C.M. Hoffmann. </author> <title> Group-Theoretic Algorithms and Graph Isomorphism, </title> <booktitle> Vol. 136 of the series, Lecture Notes in Computer Science, </booktitle> <editor> ed. G. Goos and J. Hartmanis, </editor> <publisher> Springer-Verlag, </publisher> <address> Berlin (1982). </address>
Reference-contexts: Output: No, if is not in GH. a 2 G; b 2 H such that ab = otherwise. The associated Factorization Decision Problem (FDP) is known to be equivalent to group intersection <ref> [22, pages 236-241] </ref>. The following Lemma shows the equivalence of FSP and FDP. Lemma 5.2 FDP is equivalent to FSP. 21 Proof: It is obvious that FDP reduces to FSP. All that remains to be shown is that FSP reduces to FDP.
Reference: [23] <author> R. Kannan. </author> <type> personal communication through S. Rudich. </type>
Reference-contexts: Thus [25] shows that for primes randomly chosen in the interval [1, 3 a log m] the hash function has a probability of at least 1/2 of catching an error. Method 2: This idea was first suggested by Lipton [29] and more recently by Ravi Kannan <ref> [23] </ref>. Let f (z) = (z x 1 )(z x 2 ) (z x n ) and g (z) = (z y 1 )(z y 2 ) (z y n ). Then X = Y as multisets iff f = g.
Reference: [24] <author> S. Kannan and A.C. Yao. </author> <title> Program Checkers for Probability Generation. </title> <booktitle> Proceedings International Colloquium on Automata, Languages and Programming, </booktitle> <address> (Madrid, Spain, </address> <month> Jul. </month> <pages> 8-12), </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin (1991), </address> <pages> 163-173. </pages>
Reference: [25] <author> R.M. Karp and M.O. Rabin. </author> <title> Efficient Randomized Pattern Matching Algorithms. </title> <journal> IBM Journal of Research and Development, </journal> <volume> 31(2) (1987), </volume> <pages> 249-260. 41 </pages>
Reference-contexts: Observe that X = Y if and only if P P m y i . Indeed if X = Y , then P P for all primes p. If X 6= Y then P P m y i and as pointed out by Karp and Rabin <ref> [25] </ref> P P m y i mod p for at least half of all primes in the interval [1, 3a log m]. The choice of the interval size arises from an estimate of how large P m x i can get. <p> Since m = n + 1, a bound for the sum is m a+1 . The interval has then to be chosen to be a suitable constant times log m a+1 . Thus <ref> [25] </ref> shows that for primes randomly chosen in the interval [1, 3 a log m] the hash function has a probability of at least 1/2 of catching an error. Method 2: This idea was first suggested by Lipton [29] and more recently by Ravi Kannan [23]. <p> In the computation of the product f (z) each term is bounded in absolute value by a + 2n and hence the product is bounded by (a + 2n) n . Thus according to <ref> [25] </ref> the primes have to be chosen approximately in the range [1; n log (a + 2n)].
Reference: [26] <author> R.M. Karp and V. Ramachandran. </author> <title> Parallel Algorithms for Shared-Memory Machines. </title> <booktitle> In Hand--book of Theoretical Computer Science, vol. A: Algorithms and Complexity, </booktitle> <publisher> Elsevier, </publisher> <month> Amster-dam </month> <year> (1990), </year> <pages> 869-941. </pages>
Reference: [27] <author> Ker-I Ko. </author> <title> On Helping by Robust Oracle Machines. </title> <journal> TCS, </journal> <volume> 52 (1987), </volume> <pages> 15-36. </pages>
Reference: [28] <author> J.S. Leon. </author> <title> Computing Automorphism Groups of Combinatorial Objects. In Computational Group Theory ed. </title> <address> M.D. </address> <publisher> Atkinson, Academic Press, </publisher> <address> London (1984), </address> <pages> 321-335. </pages>
Reference-contexts: Other examples arise in knot theory, block designs, codes, matrices over GF (q), Latin Squares <ref> [28, page 32] </ref> and in applications of the Burnside and Polya theorems [32].
Reference: [29] <author> R. Lipton. </author> <title> New Directions in Testing. </title> <booktitle> In Distributed Computing and Cryptography, DIMACS series in Discrete Mathematics and Theoretical Computer Science, </booktitle> <volume> vol. 2, </volume> <publisher> AMS, </publisher> <address> Providence (1991), </address> <pages> 191-202. </pages>
Reference-contexts: Thus [25] shows that for primes randomly chosen in the interval [1, 3 a log m] the hash function has a probability of at least 1/2 of catching an error. Method 2: This idea was first suggested by Lipton <ref> [29] </ref> and more recently by Ravi Kannan [23]. Let f (z) = (z x 1 )(z x 2 ) (z x n ) and g (z) = (z y 1 )(z y 2 ) (z y n ). Then X = Y as multisets iff f = g.
Reference: [30] <author> C. Lund, L. Fortnow, H. Karloff, and N. Nisan. </author> <title> Algebraic Methods for Interactive Proof Systems. </title> <journal> J. ACM, </journal> <volume> 39 (1992), </volume> <pages> 859-868. </pages>
Reference-contexts: The main purpose of the above corollary is to point out that if N P 6 CO-function-restricted IP, as seems likely, then there can be no efficient program checker C (in the above sense) for N P -complete problems! Note that the results of Lund et al. <ref> [30] </ref> and Shamir [36] do not give function-restricted IP proofs for NP-complete languages. 37 8 Overview and Conclusions The thrust of this paper is to show that in many cases, it is possible to check a program's output on a given input, thereby giving quantitative mathematical evidence that the program works
Reference: [31] <author> R.A. Mathon. </author> <title> A Note on the Graph Isomorphism Counting Problem. </title> <note> IPL 8 (1979) 131-132. </note>
Reference-contexts: introduction can be viewed as a group theoretic checker since the problem of graph isomorphism is polynomial-time equivalent to the problem of determining the automorphism group of a graph <ref> [31] </ref>. For graph isomorphism we essentially check the consistency of the program in the case that the program says that the input graphs G and H are not isomorphic. The structure of the problem implies that 1. G and a random permutation of G are isomorphic and 15 2.
Reference: [32] <author> G. </author> <title> Polya and R.C. Read. Combinatorial Enumeration of Groups, Graphs, and Chemical Compounds, </title> <publisher> Springer-Verlag, </publisher> <address> Berlin (1987). </address>
Reference-contexts: Other examples arise in knot theory, block designs, codes, matrices over GF (q), Latin Squares [28, page 32] and in applications of the Burnside and Polya theorems <ref> [32] </ref>.
Reference: [33] <author> M.O. Rabin. </author> <title> Probabilistic Algorithms. In Algorithms and Complexity, Recent Results and New Directions, </title> <editor> ed. J.F. Traub, </editor> <publisher> Academic Press (1976), </publisher> <pages> 21-40. </pages>
Reference: [34] <author> R. Rubinfeld. </author> <title> Designing Checkers for Programs that Run in Parallel. </title> <type> Tech. Report TR-090-040, </type> <institution> International Computer Science Institute, Berkeley, </institution> <month> August, </month> <year> 1990. </year>
Reference: [35] <author> U. Schoning. </author> <title> Robust Algorithms: A Different Approach to Oracles. </title> <journal> TCS, </journal> <volume> 40 (1985), </volume> <pages> 57-66. </pages>
Reference: [36] <author> A. Shamir. </author> <title> IP = PSPACE. </title> <journal> J. ACM, </journal> <volume> 39 (1992) 869-877. </volume> <pages> 42 </pages>
Reference-contexts: The main purpose of the above corollary is to point out that if N P 6 CO-function-restricted IP, as seems likely, then there can be no efficient program checker C (in the above sense) for N P -complete problems! Note that the results of Lund et al. [30] and Shamir <ref> [36] </ref> do not give function-restricted IP proofs for NP-complete languages. 37 8 Overview and Conclusions The thrust of this paper is to show that in many cases, it is possible to check a program's output on a given input, thereby giving quantitative mathematical evidence that the program works correctly on that
Reference: [37] <author> M. Tompa and H. Woll. </author> <title> Random Self-Reducibility and Zero Knowledge Interactive Proofs of Possession of Information. </title> <booktitle> In Proceedings 28th IEEE Symposium on Foundations of Computer Science, </booktitle> <publisher> IEEE Computer Society, Los Alamitos, </publisher> <year> 1987, </year> <pages> 472-482. </pages>
Reference-contexts: This modification of [19] conforms with the commonly accepted definition of IP as it appears, for example, in Goldwasser and Sipser [20], and Tompa and Woll <ref> [37] </ref>.
Reference: [38] <author> W.J. Weyuker, </author> <title> The Evaluation of Program-Based Software Test Data Adequacy Criteria, </title> <journal> Communications of the ACM, </journal> <volume> 31 6, </volume> <month> 668-675 </month> <year> (1988). </year>
Reference: [39] <author> M.N. Wegman and J.L. Carter, </author> <title> New Hash Functions and Their Use in Authentication and Set Equality, </title> <journal> J. of Computer and System Science, </journal> <volume> 22 3, </volume> <month> 265-279 </month> <year> (1981). </year> <month> 43 </month>
Reference-contexts: The situation when n &lt; 2 a is more interesting. For this case we present the following two methods for checking multiset equality. Method 1: This method (but not the specific and important choice of hash function) was first suggested by Wegman and Carter <ref> [39] </ref>: Compute n = jXj and check that jY j = n. If so, select a hash function h : Z ! f0; 1g and compare h (x 1 ) + + h (x n ) to h (y 1 ) + + h (y n ).
References-found: 39

