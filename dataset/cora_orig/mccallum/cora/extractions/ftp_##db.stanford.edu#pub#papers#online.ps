URL: ftp://db.stanford.edu/pub/papers/online.ps
Refering-URL: http://www.cs.toronto.edu/~mendel/dwbib.html
Root-URL: 
Email: quass@cs.stanford.edu  widom@cs.stanford.edu  
Title: On-Line Warehouse View Maintenance  
Author: Dallan Quass Jennifer Widom 
Address: Stanford University  Stanford University  
Affiliation: Computer Science Department  Computer Science Department  
Abstract: Data warehouses store materialized views over base data from external sources. Clients typically perform complex read-only queries on the views. The views are refreshed periodically by maintenance transactions, which propagate large batch updates from the base tables. In current warehousing systems, maintenance transactions usually are isolated from client read activity, limiting availability and/or size of the warehouse. We describe an algorithm called 2VNL that allows warehouse maintenance transactions to run concurrently with readers. By logically maintaining two versions of the database, no locking is required and serializability is guaranteed. We present our algorithm, explain its relationship to other multi-version concurrency control algorithms, and describe how it can be implemented on top of a conventional relational DBMS using a query rewrite approach. 
Abstract-found: 1
Intro-found: 1
Reference: [AS89] <author> D. Agrawal and S. Sengupta. </author> <title> Modular synchronization in multiversion databases: Version control and currency control. </title> <booktitle> In Proceedings of ACM SIGMOD 1989 International Conference on Management of Data, </booktitle> <pages> pages 408-417, </pages> <year> 1989. </year>
Reference: [BBG + 95] <author> H. Berenson, P. Bernstein, J. Gray, J. Melton, E. O'Neil, and P. O'Neil. </author> <title> A critique of ANSI SQL isolation levels. </title> <booktitle> In Proceedings of ACM SIGMOD 1995 International Conference on Management of Data, </booktitle> <pages> pages 1-10, </pages> <year> 1995. </year>
Reference: [BC92a] <author> P. Bober and M. Carey. </author> <title> Multiversion query locking. </title> <booktitle> In Proceedings of the Eighteenth International Conference on Very Large Databases (VLDB), </booktitle> <pages> pages 497-510, </pages> <year> 1992. </year>
Reference: [BC92b] <author> P. Bober and M. Carey. </author> <title> On mixing queries and transactions via multiversion locking. </title> <booktitle> In Proceedings of the Eighth International Conference on Data Engineering, </booktitle> <pages> pages 535-545, </pages> <year> 1992. </year>
Reference-contexts: This means that readers might have to perform several I/O's to access the correct version of a tuple. Also, tuple writes involve an additional I/O for copying the existing current version to the version pool. The approach in <ref> [BC92b] </ref> improves on this design by reserving a portion of each data page for a version pool cache so that recent tuple versions are stored on the same page.
Reference: [BHG87] <author> P. Bernstein, V. Hadzilacos, and N. Goodman. </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison-Wesley, </publisher> <year> 1987. </year>
Reference-contexts: Section 5 explains how to extend the 2VNL algorithm to the general case of nVNL (n 2). In Section 6 we compare the 2VNL algorithm to two-version two-phase locking (2V2PL) and multi-version two-phase locking (MV2PL) algorithms <ref> [BHG87] </ref> and discuss the advantages of 2VNL for data warehousing environments. Conclusions and areas for future research are presented in Section 7. 2 Example and Motivation EXAMPLE 2.1 Consider a warehouse of sales data for a chain of sporting goods stores.
Reference: [BHR80] <author> R. Bayer, H. Heller, and A. Reiser. </author> <title> Parallelism and recovery in database systems. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 5(2) </volume> <pages> 139-156, </pages> <month> June </month> <year> 1980. </year>
Reference: [CFL + 82] <author> A. Chan, S. Fox, W. Lin, A. Nori, and D. Ries. </author> <title> The implementation of an integrated concur-rency control and recovery scheme. </title> <booktitle> In Proceedings of ACM SIGMOD 1982 International Conference on Management of Data, </booktitle> <pages> pages 184-191, </pages> <year> 1982. </year>
Reference-contexts: Previous versions may be garbage collected when it is guaranteed that they are no longer needed by any reader. With some MV2PL algorithms, readers read the latest version of the tuple that is less than the reader's begin-timestamp <ref> [CFL + 82] </ref>. These algorithms require maintaining possibly many previous versions of each tuple. By carefully choosing the previous tuple versions that are made available to readers, other MV2PL algorithms [MPL92,WYC93] guarantee that readers and writers never block each other with a maximum of three or four tuple versions. <p> This reduction in the number of versions required is due to the fact that in data warehousing environments, maintenance transactions are known to run one at a time. All MV2PL algorithms require overhead to access and maintain previous tuple versions. For example, the approach in <ref> [CFL + 82] </ref> stores previous versions in a special "version pool" on disk, where they are chained together and to the current version. This means that readers might have to perform several I/O's to access the correct version of a tuple.
Reference: [GL95] <author> T. Griffin and L. Libkin. </author> <title> Incremental maintenance of views with duplicates. </title> <editor> In M. Carey and D. Schneider, editors, </editor> <booktitle> Proceedings of ACM SIG-MOD 1995 International Conference on Management of Data, </booktitle> <pages> pages 328-339, </pages> <address> San Jose, CA, </address> <month> May 23-25 </month> <year> 1995. </year>
Reference-contexts: As changes are made to the data at the sources, the views at the warehouse become out of date. In order to make the views consistent again with the source data, the views can be incrementally maintained <ref> [GL95] </ref> by propagating changes from the source data to the warehouse views. In current commercial warehousing systems, usually changes to the source data are queued and propagated periodically (e.g., once a day) to the warehouse views in a large batch update transaction, called a maintenance transaction.
Reference: [HRU96] <author> V. Harinarayan, A. Rajaraman, and J.D. Ull-man. </author> <title> Implementing data cubes efficiently. </title> <booktitle> In Proceedings of ACM SIGMOD 1996 International Conference on Management of Data, </booktitle> <pages> pages 205-216, </pages> <year> 1996. </year>
Reference-contexts: Because data warehouses often are used primarily for decision support, queries at the warehouse tend to be long and complex. Thus, a warehouse may contain many materialized views in order to speed up query processing <ref> [HRU96] </ref>. As changes are made to the data at the sources, the views at the warehouse become out of date. In order to make the views consistent again with the source data, the views can be incrementally maintained [GL95] by propagating changes from the source data to the warehouse views. <p> DailySales (tt city, state, product line, date, total sales) The DailySales relation is an example of a summary table, because it summarizes (aggregates) the base sales data. Summary tables are used commonly in data warehouses to speed up the evaluation of aggregate queries <ref> [HRU96] </ref>. Suppose that an analyst wanted to find the total sales made by stores in each city.
Reference: [LW95] <author> D. Lomet and J. Widom, </author> <title> editors. Special Issue on Materialized Views and Data Warehousing, </title> <journal> IEEE Data Engineering Bulletin 18(2), </journal> <month> June </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Data warehouses collect information from one or more data sources and integrate it into a single database where it can be queried by clients (readers) of the warehouse. The relations stored at the warehouse represent materialized views over the data at the sources <ref> [LW95] </ref>. Because data warehouses often are used primarily for decision support, queries at the warehouse tend to be long and complex. Thus, a warehouse may contain many materialized views in order to speed up query processing [HRU96].
Reference: [MPL92] <author> C. Mohan, H. Pirahesh, and R. Lorie. </author> <title> Efficient and flexible methods for transient versioning of records to avoid locking by read-only transactions. </title> <booktitle> In Proceedings of ACM SIGMOD 1992 International Conference on Management of Data, </booktitle> <pages> pages 124-133, </pages> <year> 1992. </year>
Reference-contexts: Furthermore, in 2VNL additional I/O's for reading and modifying tuples are never required, although there could be more I/O's altogether in a scan, say, since fewer tuples fit on a page. <ref> [MPL92] </ref> considers incremental versioning, storing only the values of changed attributes in previous tuple versions. They mention that in order to access the correct tuple version multiple incremental versions must be read and combined, but the algorithms for creating and combining the incremental versions are not given. <p> They mention that in order to access the correct tuple version multiple incremental versions must be read and combined, but the algorithms for creating and combining the incremental versions are not given. More importantly, implementing the algorithm of <ref> [MPL92] </ref>, as with all multi-version algorithms of which we are aware, requires significant changes to the DBMS's underlying storage and transaction management systems. We believe 2VNL is the first algorithm that can be implemented on top of current DBMS's using a query rewrite approach.
Reference: [MS93] <author> J. Melton and A. Simon. </author> <title> Understanding the New SQL: A Complete Guide. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1993. </year>
Reference-contexts: We assume that an external protocol limits maintenance transactions to execute one at a time. We also assume that readers and the maintenance transaction do not place any locks, or that if the maintenance transaction does place locks, readers ignore the locks. In SQL92 <ref> [MS93] </ref>, readers can be instructed to ignore write locks by setting the transaction isolation level to "read uncommitted," and several commercial DBMS's, such as Informix, support this capability. The additional concurrency in Figure 2 is achieved by making two versions of the database logically available simultaneously. <p> In the rewriting, the SQL-92 CASE expression <ref> [MS93] </ref> is used to access the current or pre-update attributes as appropriate. Any time an updatable attribute is referenced in a query it is replaced with a CASE expression that returns the current or pre-update attribute value depending upon the tuple's tupleVN and the reader's ses-sionVN.
Reference: [SJGP90] <author> M. Stonebraker, A. Jhingran, J. Goh, and S. Potamianos. </author> <title> On rules, procedures, caching and views in data base systems. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 281-290, </pages> <year> 1990. </year>
Reference: [SP89] <author> A. Segev and J. Park. </author> <title> Updating distributed materialized views. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 1(2) </volume> <pages> 173-184, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Once logically-deleted tuples are no longer needed by readers, they can be garbage collected by periodically running a process to physically delete them. We plan to examine garbage collection in more detail in future work. In addition, the operation recorded in operation needs to represent the net effect <ref> [SP89] </ref> of all operations performed by the maintenance transaction on the tuple. operation Insert Update Delete Current Version read current read current ignore attribute values attribute values tuple Pre-Update Version ignore read pre-update read pre-update tuple attribute values attribute values Table 1: Decision table for extracting the current or pre-update tuple
Reference: [SR81] <author> R. Stearns and D. Rosenkrantz. </author> <title> Distributed database concurrency controls using before-values. </title> <booktitle> In Proceedings of ACM SIGMOD 1981 International Conference on Management of Data, </booktitle> <pages> pages 74-83, </pages> <year> 1981. </year>
Reference: [Sto75] <author> M. Stonebraker. </author> <title> Implementation of integrity constraints and views by query modification. </title> <booktitle> In Proceedings of ACM SIGMOD 1975 International Conference on Management of Data, </booktitle> <pages> pages 65-78, </pages> <year> 1975. </year>
Reference: [Wei87] <author> W. Weihl. </author> <title> Distributed version management for read-only actions. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-13(1):55-64, </volume> <month> January </month> <year> 1987. </year>
Reference: [WYC93] <author> K. Wu, P. Yu, and M. Chen. </author> <title> Dynamic finite versioning: An effective versioning approach to concurrent transaction and query processing. </title> <booktitle> In Proceedings of the Ninth International Conference on Data Engineering, </booktitle> <pages> pages 557-586, </pages> <year> 1993. </year>
References-found: 18

