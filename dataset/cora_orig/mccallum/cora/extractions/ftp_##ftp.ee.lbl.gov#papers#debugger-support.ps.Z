URL: ftp://ftp.ee.lbl.gov/papers/debugger-support.ps.Z
Refering-URL: http://www.cs.washington.edu/research/compiler/papers.d/data-break.html
Root-URL: 
Title: A Survey of Support For Implementing Debuggers  
Author: Vern Paxson Prof. Anderson 
Date: October 30, 1990  
Pubnum: CS 262  
Abstract: The degree to which hardware and operating systems support debugging strongly influences the caliber of service that a debugger can provide. We survey the different forms in which such support is available. We limit our survey to lower-level debugger design issues such as accessing the debugged program's state and controlling its execution. The study concentrates on those types of support that make overall debugger performance efficient and that support debugger features for ferreting out hard-to-find bugs. We conclude with an overview of state-of-the-art debuggers and a proposal for a new debugger design. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Bernd Bruegge. </author> <title> Adaptability and Portability of Symbolic Debuggers. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Carnegie-Mellon University, </institution> <month> September </month> <year> 1985. </year> <month> CMU-CS-85-174. </month>
Reference-contexts: Introduction Debugging is one of the fundamental aspects of software development. Once software has been specified and designed, it enters a well-known edit-compile-test-debug-repeat implementation cycle. During this cycle there is clearly a need for tools that aid debugging: one study of experienced programmers <ref> [1] </ref> found that 78% had bugs that took longer than one day to find, and 34% had bugs that took more than a month to find. Breakpoint debuggers are now widely available. <p> In this fashion, very high performance conditional breakpoints could be supported. One other area of debugger support where interesting work is on-going is that of "debugger languages" <ref> [1, 46] </ref>. These are languages used by a programmer to describe debugging commands and events-of-interest to a debugger. The most recent of these, Dalek [31], is event-oriented. Debugger- and user-defined events are held in event queues, from which the most recent or any previous event can be inspected.
Reference: [2] <author> Mark A. Linton. </author> <title> The evolution of dbx. </title> <booktitle> In Proceedings of the 1990 Usenix Summer Conference, </booktitle> <address> Anaheim, CA, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: Conditional breakpoints have historically often been extremely inefficient, leading perhaps to an underappreciation of their value <ref> [2] </ref>. In our survey we will pay especially close attention to support for efficient conditional break-points. A particularly difficult-to-find type of bug is a sporadic one: one that is not readily reproducible. <p> Linton, the author of dbx , and Olsson et. al. also stress the need to reduce the number of system calls and context switches in order to achieve good debugger response <ref> [2, 31] </ref>. Context switches can be greatly reduced by making the debuggee's state directly available via system calls. For example, the /proc mechanism supported in System V Release 4 Unix systems [32] provides a virtual file system directory in which there is a file for each process. <p> The main benefit of Parasight is that it provides very cheap yet protected debugging agents (the parasites) and a completely extensible (but not protected) mechanism for attaching arbitrary procedure calls to a running program. This latter facility can be used to provide extremely cheap conditional breakpoints. Linton <ref> [2] </ref> briefly discusses the Ndb debugger, presently being designed by Pan. Ndb is a local agent-style debugger with a protocol similar to that used by TTD.
Reference: [3] <author> W.C. Gramlich. </author> <title> Debugging methodology (session summary). </title> <booktitle> In Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on High-Level Debugging [50], </booktitle> <pages> pages 1-3. 23 </pages>
Reference-contexts: A very nasty form of sporadic bug is a Heisenbug <ref> [3] </ref>. This is the (somewhat whimsical) name given to a bug whose manifestation disappears when a debugger is used to find it. Timing-related bugs and those involving illegal memory references are examples. The principle tools for finding sporadic bugs are checkpointing and reverse execution.
Reference: [4] <author> Thomas A. Cargill. </author> <title> The Blit debugger (preliminary draft). </title> <booktitle> In Pro--ceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on High-Level Debugging [50], </booktitle> <pages> pages 190-200. </pages>
Reference-contexts: An Overview of Debugger Features There are many different services that a debugger can provide, more than can be adequately treated in a short paper. Some that we will not be discussing further are: graphical interfaces (some examples are the Joff debugger <ref> [4] </ref>, Bugbane [5], Dbxtool [6], Pi [7], and pdb [8]); debugging optimized code ([9] is the classic reference); issues in source-level debugging [10] and symbol table management [6, 11, 12]; interpretive debuggers, such as Saber-C [13]; transfer tracing, where each discontinuity in the program counter is recorded [14]; debugging real-time software
Reference: [5] <author> Warren Teitelman. </author> <title> The Cedar programming environment: A midterm report and examination. </title> <type> Technical report, </type> <institution> Xerox Corporation, Palo Alto Research Center, </institution> <month> June </month> <year> 1984. </year> <month> CSL-83-11. </month>
Reference-contexts: An Overview of Debugger Features There are many different services that a debugger can provide, more than can be adequately treated in a short paper. Some that we will not be discussing further are: graphical interfaces (some examples are the Joff debugger [4], Bugbane <ref> [5] </ref>, Dbxtool [6], Pi [7], and pdb [8]); debugging optimized code ([9] is the classic reference); issues in source-level debugging [10] and symbol table management [6, 11, 12]; interpretive debuggers, such as Saber-C [13]; transfer tracing, where each discontinuity in the program counter is recorded [14]; debugging real-time software [15]; and
Reference: [6] <author> Evan Adams and Steven S. Muchnick. Dbxtool: </author> <title> A window-based symbolic debugger for Sun workstations. </title> <journal> Software-Practice and Experience, </journal> <volume> 16(7) </volume> <pages> 653-669, </pages> <month> July </month> <year> 1986. </year>
Reference-contexts: An Overview of Debugger Features There are many different services that a debugger can provide, more than can be adequately treated in a short paper. Some that we will not be discussing further are: graphical interfaces (some examples are the Joff debugger [4], Bugbane [5], Dbxtool <ref> [6] </ref>, Pi [7], and pdb [8]); debugging optimized code ([9] is the classic reference); issues in source-level debugging [10] and symbol table management [6, 11, 12]; interpretive debuggers, such as Saber-C [13]; transfer tracing, where each discontinuity in the program counter is recorded [14]; debugging real-time software [15]; and multi-lingual debuggers <p> Some that we will not be discussing further are: graphical interfaces (some examples are the Joff debugger [4], Bugbane [5], Dbxtool [6], Pi [7], and pdb [8]); debugging optimized code ([9] is the classic reference); issues in source-level debugging [10] and symbol table management <ref> [6, 11, 12] </ref>; interpretive debuggers, such as Saber-C [13]; transfer tracing, where each discontinuity in the program counter is recorded [14]; debugging real-time software [15]; and multi-lingual debuggers [11, 16]. <p> A major flaw in the ptrace design is that all access and modification of debuggee state occurs one word or register at a time, and is done in the debuggee's context, so one system call plus two context switches are required for each word accessed. Adams and Muchnick <ref> [6] </ref> found that ptrace system call overhead was a serious bottleneck in the performance of dbx; by extending ptrace to provide more bulk services (reading and writing of multiple data words and registers) they were able to reduce the number of ptrace calls by 2=3.
Reference: [7] <author> Thomas A. Cargill. </author> <title> Pi: A case study in object-oriented programming. </title> <booktitle> In Proceedings of the Usenix C++ Workshop, </booktitle> <address> Santa Fe, NM, </address> <pages> pages 282-303, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: An Overview of Debugger Features There are many different services that a debugger can provide, more than can be adequately treated in a short paper. Some that we will not be discussing further are: graphical interfaces (some examples are the Joff debugger [4], Bugbane [5], Dbxtool [6], Pi <ref> [7] </ref>, and pdb [8]); debugging optimized code ([9] is the classic reference); issues in source-level debugging [10] and symbol table management [6, 11, 12]; interpretive debuggers, such as Saber-C [13]; transfer tracing, where each discontinuity in the program counter is recorded [14]; debugging real-time software [15]; and multi-lingual debuggers [11, 16].
Reference: [8] <author> Paul Maybee. </author> <title> pdb: A network oriented symbolic debugger. </title> <booktitle> In Proceedings of the 1990 Usenix Winter Conference, </booktitle> <address> Washington, D.C., </address> <month> January </month> <year> 1990. </year>
Reference-contexts: Some that we will not be discussing further are: graphical interfaces (some examples are the Joff debugger [4], Bugbane [5], Dbxtool [6], Pi [7], and pdb <ref> [8] </ref>); debugging optimized code ([9] is the classic reference); issues in source-level debugging [10] and symbol table management [6, 11, 12]; interpretive debuggers, such as Saber-C [13]; transfer tracing, where each discontinuity in the program counter is recorded [14]; debugging real-time software [15]; and multi-lingual debuggers [11, 16].
Reference: [9] <author> John Hennessy. </author> <title> Symbolic debugging of optimized programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(3) </volume> <pages> 323-344, </pages> <year> 1982. </year>
Reference: [10] <author> John D. Johnson and Gary W. Kenney. </author> <title> Implementation issues for a source level symbolic debugger (extended abstract). </title> <booktitle> In Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on High-Level Debugging [50], </booktitle> <pages> pages 149-151. </pages>
Reference-contexts: Some that we will not be discussing further are: graphical interfaces (some examples are the Joff debugger [4], Bugbane [5], Dbxtool [6], Pi [7], and pdb [8]); debugging optimized code ([9] is the classic reference); issues in source-level debugging <ref> [10] </ref> and symbol table management [6, 11, 12]; interpretive debuggers, such as Saber-C [13]; transfer tracing, where each discontinuity in the program counter is recorded [14]; debugging real-time software [15]; and multi-lingual debuggers [11, 16].
Reference: [11] <author> Bert Beander. </author> <title> Vax debug: An interactive, symbolic, multilingual debugger. </title> <booktitle> In Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on High-Level Debugging [50], </booktitle> <pages> pages 173-179. </pages>
Reference-contexts: Some that we will not be discussing further are: graphical interfaces (some examples are the Joff debugger [4], Bugbane [5], Dbxtool [6], Pi [7], and pdb [8]); debugging optimized code ([9] is the classic reference); issues in source-level debugging [10] and symbol table management <ref> [6, 11, 12] </ref>; interpretive debuggers, such as Saber-C [13]; transfer tracing, where each discontinuity in the program counter is recorded [14]; debugging real-time software [15]; and multi-lingual debuggers [11, 16]. <p> Pi [7], and pdb [8]); debugging optimized code ([9] is the classic reference); issues in source-level debugging [10] and symbol table management [6, 11, 12]; interpretive debuggers, such as Saber-C [13]; transfer tracing, where each discontinuity in the program counter is recorded [14]; debugging real-time software [15]; and multi-lingual debuggers <ref> [11, 16] </ref>. We also will not be discussing debugging of multi-threaded, parallel, or distributed programs (of which there is a substantial body of literature; [17] is a good starting place) except where those techniques also pertain to debugging single-threaded uniprocessor programs. <p> Hardware page protection can be used to implement watchpoints by making pages read-only (to catch modifications) or inaccessible (to catch any form of access) <ref> [11, 21] </ref>. The author's experience using this feature with VAX DEBUG is that it works well. It is not clear from the literature why this approach is not used more commonly. <p> Workstation and minicomputer debuggers tend to be separate-process, no doubt because operating system support is available for separate-process debugging. One well-known same-process debugger that runs on minicomputers, however, is VAX DEBUG <ref> [11] </ref>, which provides a large number of features, including multilingual debugging, source-level debugging, and watchpoints. As is common with same-process debuggers, VAX DEBUG is implemented as a collection of exception handlers.
Reference: [12] <author> Thomas A. Cargill. </author> <title> Implementation of the Blit debugger. </title> <journal> Software-Practice and Experience, </journal> <volume> 15(2) </volume> <pages> 153-168, </pages> <month> February </month> <year> 1985. </year>
Reference-contexts: Some that we will not be discussing further are: graphical interfaces (some examples are the Joff debugger [4], Bugbane [5], Dbxtool [6], Pi [7], and pdb [8]); debugging optimized code ([9] is the classic reference); issues in source-level debugging [10] and symbol table management <ref> [6, 11, 12] </ref>; interpretive debuggers, such as Saber-C [13]; transfer tracing, where each discontinuity in the program counter is recorded [14]; debugging real-time software [15]; and multi-lingual debuggers [11, 16]. <p> An early example of this type of debugger is Joff <ref> [12] </ref>, a debugger for programs running on the Blit programmable bitmap terminal [37] 9 . The bulk of the debugger runs on the remote host to which the Blit is connected.
Reference: [13] <author> Stephen Kaufer, Russell Lopez, and Sesha Pratap. Saber-C: </author> <title> An interpreter-based programming environment for the C language. </title> <booktitle> In Proceedings of the 1988 Usenix Summer Conference, </booktitle> <address> San Francisco, CA, </address> <month> June </month> <year> 1988. </year> <month> 24 </month>
Reference-contexts: we will not be discussing further are: graphical interfaces (some examples are the Joff debugger [4], Bugbane [5], Dbxtool [6], Pi [7], and pdb [8]); debugging optimized code ([9] is the classic reference); issues in source-level debugging [10] and symbol table management [6, 11, 12]; interpretive debuggers, such as Saber-C <ref> [13] </ref>; transfer tracing, where each discontinuity in the program counter is recorded [14]; debugging real-time software [15]; and multi-lingual debuggers [11, 16].
Reference: [14] <author> D. E. McLear, D. M. Scheibelhut, and E. Tammaru. </author> <title> Guidelines for creating a debuggable processor. </title> <booktitle> In Symposium on Architectural Support for Programming Languages and Operating Systems [49]. </booktitle>
Reference-contexts: the Joff debugger [4], Bugbane [5], Dbxtool [6], Pi [7], and pdb [8]); debugging optimized code ([9] is the classic reference); issues in source-level debugging [10] and symbol table management [6, 11, 12]; interpretive debuggers, such as Saber-C [13]; transfer tracing, where each discontinuity in the program counter is recorded <ref> [14] </ref>; debugging real-time software [15]; and multi-lingual debuggers [11, 16]. We also will not be discussing debugging of multi-threaded, parallel, or distributed programs (of which there is a substantial body of literature; [17] is a good starting place) except where those techniques also pertain to debugging single-threaded uniprocessor programs.
Reference: [15] <author> Jeffrey Tsai et. al. </author> <title> A noninterference monitoring and replay mechanism for real-time software testing and debugging. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(8), </volume> <month> August </month> <year> 1990. </year>
Reference-contexts: Bugbane [5], Dbxtool [6], Pi [7], and pdb [8]); debugging optimized code ([9] is the classic reference); issues in source-level debugging [10] and symbol table management [6, 11, 12]; interpretive debuggers, such as Saber-C [13]; transfer tracing, where each discontinuity in the program counter is recorded [14]; debugging real-time software <ref> [15] </ref>; and multi-lingual debuggers [11, 16]. We also will not be discussing debugging of multi-threaded, parallel, or distributed programs (of which there is a substantial body of literature; [17] is a good starting place) except where those techniques also pertain to debugging single-threaded uniprocessor programs. <p> Their implementation suffered, though, from the availability of only two simultaneous breakpoints, and from the interrupt delay of the external analyzer causing the debuggee to actually be stopped several instructions later than the breakpoint address itself. Tsai <ref> [15] </ref> describes a system that makes sophisticated use of a logic analyzer for detecting high-level events such as process creation, system calls, interrupts, shared memory access, synchronization between multiple processes, interprocess communication, I/O completion, and process termination.
Reference: [16] <author> James R. Cardell. </author> <title> Multilingual debugging with the SWAT high-level debugger. </title> <booktitle> In Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on High-Level Debugging [50]. </booktitle>
Reference-contexts: Pi [7], and pdb [8]); debugging optimized code ([9] is the classic reference); issues in source-level debugging [10] and symbol table management [6, 11, 12]; interpretive debuggers, such as Saber-C [13]; transfer tracing, where each discontinuity in the program counter is recorded [14]; debugging real-time software [15]; and multi-lingual debuggers <ref> [11, 16] </ref>. We also will not be discussing debugging of multi-threaded, parallel, or distributed programs (of which there is a substantial body of literature; [17] is a good starting place) except where those techniques also pertain to debugging single-threaded uniprocessor programs.
Reference: [17] <institution> Proceedings of the ACM SIGPLAN/SIGOPS Workshop on Parallel and Distributed Debugging. SIGPLAN Notices 24(1), </institution> <month> January </month> <year> 1989. </year>
Reference-contexts: We also will not be discussing debugging of multi-threaded, parallel, or distributed programs (of which there is a substantial body of literature; <ref> [17] </ref> is a good starting place) except where those techniques also pertain to debugging single-threaded uniprocessor programs.
Reference: [18] <author> Mark Scott Johnson. </author> <title> Some requirements for architectural support of software debugging. </title> <booktitle> In Symposium on Architectural Support for Programming Languages and Operating Systems [49], </booktitle> <pages> pages 140-148. </pages>
Reference-contexts: The operating system them informs the debugger (either via a message, by completing a system call that the debugger is executing, or by a straight transfer of program control) that a fault has occurred. 3 Johnson <ref> [18] </ref> and Gondzio [19] give thorough discussions of different types and implementations of breakpointing and single-stepping. 5 The debugger inspects the type of fault and reports it to the programmer. At this point the programmer may wish to inspect or modify the debuggee's state. <p> The forms of hardware support for debugging considered so far are relatively cheap to implement. A much more expensive but powerful form of debugging support can be attained by using a tagged architecture, where each memory location has some type information associated with it. Johnson's SPAM architecture <ref> [18] </ref> uses tagging to implement watchpoints, run-time type checking, and catching access to uninitialized data, as well as many types of breakpoints (trap before instruction execution, after instruction execution, before successful branch, and on procedure entry and exit). Another expensive form of debugging support is sheaved memory [28].
Reference: [19] <author> Marek Gondzio. </author> <title> Microprocessor debugging techniques and their application in debugger design. </title> <journal> Software-Practice and Experience, </journal> <volume> 17(3) </volume> <pages> 215-226, </pages> <month> March </month> <year> 1987. </year>
Reference-contexts: The operating system them informs the debugger (either via a message, by completing a system call that the debugger is executing, or by a straight transfer of program control) that a fault has occurred. 3 Johnson [18] and Gondzio <ref> [19] </ref> give thorough discussions of different types and implementations of breakpointing and single-stepping. 5 The debugger inspects the type of fault and reports it to the programmer. At this point the programmer may wish to inspect or modify the debuggee's state. <p> The modern examples of same-process debuggers tend to be those that run on microprocessors, such as Farley and Thompson's cdb debugger [29], designed to run on the DEC Rainbow 100, and Gondzio's MD-86 <ref> [19] </ref>, designed for the Intel 8086. Workstation and minicomputer debuggers tend to be separate-process, no doubt because operating system support is available for separate-process debugging.
Reference: [20] <author> Sun Microsystems. Ptrace(2), </author> <title> SunOS Reference Manual, </title> <booktitle> Vol. II, </booktitle> <month> Jan-uary </month> <year> 1990. </year>
Reference-contexts: On processors without such support, such as the SPARC and R2000 architectures, the debugger must be able to decode the instruction to be single-stepped, compute its successor (or possible successors), breakpoint the successor, continue the program, trap the resulting breakpoint, and remove the successor breakpoint <ref> [20] </ref>. Hardware page protection can be used to implement watchpoints by making pages read-only (to catch modifications) or inaccessible (to catch any form of access) [11, 21]. The author's experience using this feature with VAX DEBUG is that it works well. <p> The philosophy behind the design is that exception handling falls into two major classes: error handlers and debuggers 8 . Error handlers 7 ptrace has been extended to provide for attachment, single-stepping, setting watch-points, and accessing a process' symbol table: see, for example, <ref> [20, 21] </ref>. 8 A third class is that of emulators for instructions that are not present in the hardware 12 deal with low-level, correctable exceptions that may be unusual but are not necessarily due to bugs (for example, arithmetic conditions such as under-flow).
Reference: [21] <institution> Digital Equipment Corporation. Ptrace(2), Ultrix documentation, </institution> <month> March </month> <year> 1990. </year>
Reference-contexts: Hardware page protection can be used to implement watchpoints by making pages read-only (to catch modifications) or inaccessible (to catch any form of access) <ref> [11, 21] </ref>. The author's experience using this feature with VAX DEBUG is that it works well. It is not clear from the literature why this approach is not used more commonly. <p> The philosophy behind the design is that exception handling falls into two major classes: error handlers and debuggers 8 . Error handlers 7 ptrace has been extended to provide for attachment, single-stepping, setting watch-points, and accessing a process' symbol table: see, for example, <ref> [20, 21] </ref>. 8 A third class is that of emulators for instructions that are not present in the hardware 12 deal with low-level, correctable exceptions that may be unusual but are not necessarily due to bugs (for example, arithmetic conditions such as under-flow).
Reference: [22] <author> W. Morven Gentleman and Henry Hoeksma. </author> <title> Hardware assisted high level debugging (preliminary draft). </title> <booktitle> In Proceedings of the ACM SIG-SOFT/SIGPLAN Software Engineering Symposium on High-Level Debugging [50]. </booktitle>
Reference-contexts: On machines with larger page sizes the overhead may become too high. One powerful form of hardware debugging support is the availability of comparators that trigger upon specific execution or memory access patterns and then record the present execution state <ref> [22] </ref>. Snow [23] describes using an external logic analyzer for capturing such software states. The general mechanism was in turn used to implement a debugger [24]. Breakpoints were implemented by using hardware comparators to trap when a particular address was about to be loaded into the program counter.
Reference: [23] <author> C.R. Snow. </author> <title> Integrated tools for hardware/software debugging, </title> <type> final report. Technical report, </type> <institution> University of Newcastle upon Tyne, </institution> <month> Novem-ber </month> <year> 1987. </year> <type> Technical Report Series No. 247, </type> <institution> S.E.R.C. Research Project GR/C/35974. </institution>
Reference-contexts: On machines with larger page sizes the overhead may become too high. One powerful form of hardware debugging support is the availability of comparators that trigger upon specific execution or memory access patterns and then record the present execution state [22]. Snow <ref> [23] </ref> describes using an external logic analyzer for capturing such software states. The general mechanism was in turn used to implement a debugger [24]. Breakpoints were implemented by using hardware comparators to trap when a particular address was about to be loaded into the program counter.
Reference: [24] <author> W.Y.P. Wong and C.R. Snow. </author> <title> Implementation of an interactive remote source-level debugger for C programs. </title> <type> Technical report, </type> <institution> University of Newcastle upon Tyne, </institution> <month> January </month> <year> 1987. </year> <note> Technical Report Series No. 229. </note>
Reference-contexts: Snow [23] describes using an external logic analyzer for capturing such software states. The general mechanism was in turn used to implement a debugger <ref> [24] </ref>. Breakpoints were implemented by using hardware comparators to trap when a particular address was about to be loaded into the program counter. Similarly, watchpoints were implemented to trap reading, writing, or the writing of a particular value to a given address.
Reference: [25] <author> T.A. Cargill and B.N. Locanthi. </author> <title> Cheap hardware support for software debugging and profiling. </title> <booktitle> In Proceedings of the 2nd International Conference on Architectural Support for Programming Languages and Operating Systems [48]. </booktitle>
Reference-contexts: The events are detected by triggering upon access or execution of addresses related the events. Tsai's system records precise timing information for each event, to allow debugging of real-time programs. Another form of hardware debugging support is an instruction counter <ref> [25] </ref>. Cargill and Locanthi describe such a counter as being loaded with a value that is decremented upon the execution of each instruction. When the counter reaches zero, an interrupt is generated. Instruction counters provide a simple way to profile code by determining the number of instructions exe 7 cuted.
Reference: [26] <author> David R. Ditzel, Huber R. McLellan, and Alan Berenbaum. </author> <title> Design tradeoffs to support the C programming language in the CRISP microprocessor. </title> <booktitle> In Proceedings of the 2nd International Conference on Architectural Support for Programming Languages and Operating Systems [48]. </booktitle>
Reference-contexts: By keeping the software instruction counter in a general register, the overhead of the counter is minimized. Their measured overhead on a Motorola MC68020 machine ranges from negligible (&lt; 0:1%) for an execution of the 4 Ditzel, McLellan, and Berenbaum <ref> [26] </ref> report that the CRISP microprocessor has a built-in timer/instruction counter, but also do not elaborate on the uses to which it has been put. 8 lex program up to 12% for an execution of grep with a particular pattern.
Reference: [27] <author> J. M. Mellor-Crummey and T. LeBlanc. </author> <title> A software instruction counter. </title> <booktitle> In Proceedings of the Third International Conference on Architectural Support for Programming Languages and Operating Systems [47]. </booktitle>
Reference-contexts: While Cargill and Locanthi make a compelling argument that an instruction counter gives a considerable benefit for a low hardware cost, Mellor-Crummey and LeBlanc describe how an instruction counter can be implemented wholly in software <ref> [27] </ref>. Their key observation is that for implementing watchpoints and reverse execution an instruction count is not needed; instead, what is needed is simply a unique identification of each state the program has entered, along with a way to recover the state corresponding to the identification.
Reference: [28] <author> Mark E. Staknis. </author> <title> Sheaved memory: Architectural support for state saving and restoration in paged systems. </title> <booktitle> In Proceedings of the Third International Conference on Architectural Support for Programming Languages and Operating Systems [47]. </booktitle>
Reference-contexts: Another expensive form of debugging support is sheaved memory <ref> [28] </ref>. This is a method of grouping together a number of physical pages into one logical page. Writes to the logical page result in each member of the group being modified; reads come from the primary member of the group. Sheaved memory supports checkpointing and reverse execution.
Reference: [29] <author> Michael Farley and Trevor Thompson. </author> <title> A C source language debugger. </title> <booktitle> In Proceedings of the 1983 Usenix Summer Conference, </booktitle> <address> Toronto, Ontario, Canada, </address> <month> July </month> <year> 1983. </year>
Reference-contexts: The modern examples of same-process debuggers tend to be those that run on microprocessors, such as Farley and Thompson's cdb debugger <ref> [29] </ref>, designed to run on the DEC Rainbow 100, and Gondzio's MD-86 [19], designed for the Intel 8086. Workstation and minicomputer debuggers tend to be separate-process, no doubt because operating system support is available for separate-process debugging.
Reference: [30] <author> R.E. Sweet. </author> <title> The Mesa programming environment. </title> <booktitle> In Proceedings of the ACM Symposium on Language Issues in Programming Environments, </booktitle> <pages> pages 216-229. </pages> <booktitle> SIGPLAN Notices 20(7), </booktitle> <month> July </month> <year> 1985. </year>
Reference-contexts: This grab-bag system call provides mechanisms for processes to declare themselves as candidates for debugging as well as allowing a debugger to read and modify the debuggee's memory and access 6 A wholly different approach is to use the file system instead. The Mesa "world-swap" debugger <ref> [30] </ref> works by utilizing a low-level system service that creates a file containing a (restartable) image of the debuggee's complete state. The debugger can then inspect and modify the debuggee's state by simply using file system operations.
Reference: [31] <author> Ronald A. Olsson, Richard H. Crawford, and W. Wilson Ho. </author> <note> Dalek: </note>
Reference-contexts: Linton, the author of dbx , and Olsson et. al. also stress the need to reduce the number of system calls and context switches in order to achieve good debugger response <ref> [2, 31] </ref>. Context switches can be greatly reduced by making the debuggee's state directly available via system calls. For example, the /proc mechanism supported in System V Release 4 Unix systems [32] provides a virtual file system directory in which there is a file for each process. <p> One other area of debugger support where interesting work is on-going is that of "debugger languages" [1, 46]. These are languages used by a programmer to describe debugging commands and events-of-interest to a debugger. The most recent of these, Dalek <ref> [31] </ref>, is event-oriented. Debugger- and user-defined events are held in event queues, from which the most recent or any previous event can be inspected. Debugging "programs" are written in 19 a combination dataflow (for events) and procedural (for actions) language; these programs then generate further events.
References-found: 31

