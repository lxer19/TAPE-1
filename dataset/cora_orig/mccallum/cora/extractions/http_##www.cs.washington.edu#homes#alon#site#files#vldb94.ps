URL: http://www.cs.washington.edu/homes/alon/site/files/vldb94.ps
Refering-URL: http://www.cs.washington.edu/homes/alon/site/PaperAbstractPresentation_bib5.html
Root-URL: 
Email: levy@research.att.com  mumick@research.att.com  sagiv@cs.huji.ac.il  
Title: Query Optimization by Predicate Move-Around  
Author: Alon Y. Levy Inderpal Singh Mumick Yehoshua Sagiv 
Address: Murray Hill, NJ.  Murray Hill, NJ.  Jerusalem, Israel.  
Affiliation: AT&T Bell Laboratories  AT&T Bell Laboratories  Hebrew University  
Abstract: A new type of optimization, called predicate move-around, is introduced. It is shown how this optimization considerably improves the efficiency of evaluating SQL queries that have query graphs with a large number of query blocks (which is a typical situation when queries are defined in terms of multiple views and subqueries). Predicate move-around works by moving predicates across query blocks (in the query graph) that cannot be merged into one block. Predicate move-around is a generalization of and has many advantages over the traditional predicate pushdown. One key advantage arises from the fact that predicate move-around precedes pushdown by pulling predicates up the query graph. As a result, predicates that appear in the query in one part of the graph can be moved around the graph and applied also in other parts of graph. Moreover, predicate move- around optimization can move a wider class of predicates in a wider class of queries as compared to the standard predicate- pushdown techniques. In addition to the usual comparison and arithmetic predicates, other predicates that can be moved around are the EXISTS and NOT EXISTS clauses, the EXCEPT clause, and functional dependencies. The proposed optimization can also move predicates through aggregation. Moreover, the method can also infer new predicates when existing predicates are moved through aggregation or when certain functional dependencies are known to hold. Finally, the predicate move-around algorithm is easy to implement on top of existing query optimizers. 
Abstract-found: 1
Intro-found: 1
Reference: [BMSU86] <author> F. Bancilhon, D. Maier, Y. Sagiv, and J. Ullman. </author> <title> Magic sets and other strange ways to implement logic programs. </title> <booktitle> In PODS 1986, </booktitle> <pages> pages 1-15. </pages>
Reference-contexts: Pirahesh et al. [PHH92] discuss the problem of merging query blocks. Doing so eliminates the need for predicate pushdown. However, that can not always be done (e.g., in the presence of aggregation). Our method can be used in conjunction with the techniques of [PHH92]. Our method complements magic sets <ref> [BMSU86, BR87] </ref> and GMST [MFPR90b, MFPR90a]. The key differences from the magic-set approach are as follows. First, the magic-set transformation depends upon the join order; it can move predicates up from a relation and then down into another relation that appears later in the join order.
Reference: [BR87] <author> C. Beeri and R. Ramakrishnan. </author> <title> On the power of magic. </title> <booktitle> In PODS 1987, </booktitle> <pages> pages 269-283. </pages>
Reference-contexts: Pirahesh et al. [PHH92] discuss the problem of merging query blocks. Doing so eliminates the need for predicate pushdown. However, that can not always be done (e.g., in the presence of aggregation). Our method can be used in conjunction with the techniques of [PHH92]. Our method complements magic sets <ref> [BMSU86, BR87] </ref> and GMST [MFPR90b, MFPR90a]. The key differences from the magic-set approach are as follows. First, the magic-set transformation depends upon the join order; it can move predicates up from a relation and then down into another relation that appears later in the join order.
Reference: [Day87] <author> U. Dayal. </author> <title> Of nests and trees: A unified approach to processing queries that contain nested subqueries, aggregates, and quantifiers. </title> <booktitle> In VLDB 1987, </booktitle> <pages> pages 197-208. </pages>
Reference-contexts: Furthermore, doing predicate move-around improves the ability to determine the optimal join order. The magic-set transformation can be applied after predicate move-around in order to move join predicates in the direction of the join order. There has been a lot of work on optimizing subqueries and eliminating correlations <ref> [Kim82, GW87, Day87, Mur92] </ref>. Our technique complements well with that work by providing a new powerful means of pushing predicates after correlations are removed. A predicate is said to be expensive if the cost of applying the predicate is high. Placement of expensive predicates has been studied by [HS93, Hel94].
Reference: [GW87] <author> R. Ganski and H. Wong. </author> <title> Optimizationof nested SQL queries revisited. </title> <booktitle> In SIGMOD 1987, </booktitle> <pages> pages 23-33. </pages>
Reference-contexts: Furthermore, doing predicate move-around improves the ability to determine the optimal join order. The magic-set transformation can be applied after predicate move-around in order to move join predicates in the direction of the join order. There has been a lot of work on optimizing subqueries and eliminating correlations <ref> [Kim82, GW87, Day87, Mur92] </ref>. Our technique complements well with that work by providing a new powerful means of pushing predicates after correlations are removed. A predicate is said to be expensive if the cost of applying the predicate is high. Placement of expensive predicates has been studied by [HS93, Hel94].
Reference: [Hel94] <author> J. Hellerstein. </author> <title> Practical predicate placement. </title> <booktitle> In SIGMOD 1994. </booktitle>
Reference-contexts: Our technique complements well with that work by providing a new powerful means of pushing predicates after correlations are removed. A predicate is said to be expensive if the cost of applying the predicate is high. Placement of expensive predicates has been studied by <ref> [HS93, Hel94] </ref>. The move-around algorithm, as presented above, assumes that predicates are inexpensive.
Reference: [HS93] <author> J. Hellerstein and M. Stonebraker. </author> <title> Predicate migra-tion: Optimizing queries with expensive predicates. </title> <booktitle> In SIGMOD 1993. </booktitle>
Reference-contexts: Our technique complements well with that work by providing a new powerful means of pushing predicates after correlations are removed. A predicate is said to be expensive if the cost of applying the predicate is high. Placement of expensive predicates has been studied by <ref> [HS93, Hel94] </ref>. The move-around algorithm, as presented above, assumes that predicates are inexpensive.
Reference: [ISO93] <author> ISO ANSI. </author> <title> ISO-ANSI working draft: Database language SQL3, </title> <year> 1993. </year>
Reference-contexts: Our move- around algorithm applies to nonrecursive SQL queries, including SQL queries with correlations. It can also be generalized to recursive SQL queries (as defined in the new proposed SQL3 standard <ref> [ISO93] </ref>), but doing so is beyond the scope of this paper. <p> Our method can handle hierarchical and dag queries. The predicates moved around include arithmetic comparisons, negative predicates (NOT EXISTS and EXCEPT), functional dependencies and aggregation constraints. Furthermore, we can also handle the LIKE predicate of SQL <ref> [ISO93] </ref> (in a fashion similar to equality) and arithmetic constraints (e.g., X = Y + Z). When moving predicates, we can also consider the constraints that hold in database relations.
Reference: [Kim82] <author> W. Kim. </author> <title> On optimizing an SQL-like nested query. </title> <journal> ACM TODS, </journal> <volume> 7(3), </volume> <month> September </month> <year> 1982. </year>
Reference-contexts: Furthermore, doing predicate move-around improves the ability to determine the optimal join order. The magic-set transformation can be applied after predicate move-around in order to move join predicates in the direction of the join order. There has been a lot of work on optimizing subqueries and eliminating correlations <ref> [Kim82, GW87, Day87, Mur92] </ref>. Our technique complements well with that work by providing a new powerful means of pushing predicates after correlations are removed. A predicate is said to be expensive if the cost of applying the predicate is high. Placement of expensive predicates has been studied by [HS93, Hel94].
Reference: [LMSS93] <author> A. Levy, I. Mumick, Y. Sagiv, and O. Shmueli. </author> <title> Equivalence, query-reachability, and satisfiability in Datalog. </title> <booktitle> In PODS 1993, </booktitle> <pages> pages 109-122. </pages>
Reference-contexts: A similar technique for propagating predicates in a query tree was first developed by [LS92] in order to detect and delete redundant Datalog rules. In <ref> [LMSS93] </ref>, this technique was extended to detect satisfiability of Datalog queries in the presence of negated base relations and order predicates. <p> In [LMSS93], this technique was extended to detect satisfiability of Datalog queries in the presence of negated base relations and order predicates. In this paper, we generalize the constraint-propagation techniques of <ref> [LS92, LMSS93] </ref> to SQL with aggregation operators and other types of constraints (e.g., functional dependencies); in the full paper, we also deal with other SQL constructs (e.g., sub- queries).
Reference: [LS92] <author> A. Levy and Y. Sagiv. </author> <title> Constraints and redundancy in datalog. </title> <booktitle> In PODS 1992, </booktitle> <pages> pages 67-80. </pages>
Reference-contexts: In addition, we move predicates both up and down the query tree, thereby enabling predicates from one side of the tree to be moved to applicable places on the other side. A similar technique for propagating predicates in a query tree was first developed by <ref> [LS92] </ref> in order to detect and delete redundant Datalog rules. In [LMSS93], this technique was extended to detect satisfiability of Datalog queries in the presence of negated base relations and order predicates. <p> In [LMSS93], this technique was extended to detect satisfiability of Datalog queries in the presence of negated base relations and order predicates. In this paper, we generalize the constraint-propagation techniques of <ref> [LS92, LMSS93] </ref> to SQL with aggregation operators and other types of constraints (e.g., functional dependencies); in the full paper, we also deal with other SQL constructs (e.g., sub- queries). <p> Our optimization algorithm is essentially a rewriting of the query in an optimized form and, hence, is easily implemented on top of existing query opti- mizers. Finally, by using the termination condition from <ref> [LS92] </ref> (for terminating the construction of the query-tree), we can extend predicate move-around to recursive SQL queries. Srivastava and Ramakrishnan [SR92] describe a related technique for pushing predicates in Datalog programs using fold/unfold transformations.
Reference: [MFPR90a] <author> I. Mumick, S. Finkelstein, H. Pirahesh, and R. Ramakrishnan. </author> <title> Magic is relevant. </title> <booktitle> In SIGMOD 1990, </booktitle> <pages> pages 247-258. </pages>
Reference-contexts: However, it works only on hierarchical queries, which are nonrecursive queries without common subex- pressions. Another approach is the adaptation of the magic-set transformation for an early evaluation of selection and join predicates in nonrecursive SQL queries with common subexpressions <ref> [MFPR90a] </ref>. The magic- set transformation (see [Ull89] for details) pushes predicates according to the order of doing joins and introduces auxiliary magic views. <p> Doing so eliminates the need for predicate pushdown. However, that can not always be done (e.g., in the presence of aggregation). Our method can be used in conjunction with the techniques of [PHH92]. Our method complements magic sets [BMSU86, BR87] and GMST <ref> [MFPR90b, MFPR90a] </ref>. The key differences from the magic-set approach are as follows. First, the magic-set transformation depends upon the join order; it can move predicates up from a relation and then down into another relation that appears later in the join order.
Reference: [MFPR90b] <author> I. Mumick, S. Finkelstein, H. Pirahesh, and R. Ramakrishnan. </author> <title> Magic conditions. </title> <booktitle> In PODS 1990, </booktitle> <pages> pages 314-330. </pages>
Reference-contexts: Doing so eliminates the need for predicate pushdown. However, that can not always be done (e.g., in the presence of aggregation). Our method can be used in conjunction with the techniques of [PHH92]. Our method complements magic sets [BMSU86, BR87] and GMST <ref> [MFPR90b, MFPR90a] </ref>. The key differences from the magic-set approach are as follows. First, the magic-set transformation depends upon the join order; it can move predicates up from a relation and then down into another relation that appears later in the join order.
Reference: [Mur92] <author> M. Muralikrishna. </author> <title> Improved unnesting algorithms for join aggregate SQL queries. </title> <booktitle> In VLDB 1992, </booktitle> <pages> pages 91-102. </pages>
Reference-contexts: Furthermore, doing predicate move-around improves the ability to determine the optimal join order. The magic-set transformation can be applied after predicate move-around in order to move join predicates in the direction of the join order. There has been a lot of work on optimizing subqueries and eliminating correlations <ref> [Kim82, GW87, Day87, Mur92] </ref>. Our technique complements well with that work by providing a new powerful means of pushing predicates after correlations are removed. A predicate is said to be expensive if the cost of applying the predicate is high. Placement of expensive predicates has been studied by [HS93, Hel94].
Reference: [PHH92] <author> H. Pirahesh, J. Hellerstein, and W. Hasan. </author> <title> Extensible/rule based query rewrite optimization in starburst. </title> <booktitle> In SIGMOD 1992, </booktitle> <pages> pages 39-48. </pages>
Reference-contexts: Therefore, it is valuable to merge subqueries and views into one query block. Unfortunately, this is a complicated and sometimes impossible task due to aggregates, the SQL semantics of duplicates, correlations, EXISTS, NOT EXISTS, EXCEPT, UNION, and INTERSECTION. The work of <ref> [PHH92] </ref> has investigated this issue and provided some solutions for merging blocks of queries when the duplicate semantics can either be ignored or when all duplicates are eliminated. <p> More- over, redundant predicates represent wasted compu <p>- tation. Our algorithm can be incorporated easily on top of existing query optimizers, since it consists of rewriting the original queries and views. For example, our algorithm would fit well in the Starburst optimizer <ref> [PHH92] </ref>. The paper is organized as follows. Section 2 illustrates the savings achieved by predicate move-around via a detailed example. Section 3 describes the SQL syntax and the query-tree representation on which the algorithm operates. <p> Section 2 illustrates the savings achieved by predicate move-around via a detailed example. Section 3 describes the SQL syntax and the query-tree representation on which the algorithm operates. The query tree is a straightforward parse-tree representation of a query, close to what is used in several systems (e.g., <ref> [PHH92] </ref>). The predicate move-around algorithm is detailed in Section 4. We describe the general algorithm, and illustrate each step of the algorithm on the example of Section 2. <p> In addition, their approach does not combine pushing of other types of predicates with aggregate selectors. Pirahesh et al. <ref> [PHH92] </ref> discuss the problem of merging query blocks. Doing so eliminates the need for predicate pushdown. However, that can not always be done (e.g., in the presence of aggregation). Our method can be used in conjunction with the techniques of [PHH92]. <p> Pirahesh et al. <ref> [PHH92] </ref> discuss the problem of merging query blocks. Doing so eliminates the need for predicate pushdown. However, that can not always be done (e.g., in the presence of aggregation). Our method can be used in conjunction with the techniques of [PHH92]. Our method complements magic sets [BMSU86, BR87] and GMST [MFPR90b, MFPR90a]. The key differences from the magic-set approach are as follows.
Reference: [SR92] <author> D. Srivastava and R. Ramakrishnan. </author> <title> Pushing Constraint Selections. </title> <booktitle> In PODS 1992. </booktitle>
Reference-contexts: Finally, by using the termination condition from [LS92] (for terminating the construction of the query-tree), we can extend predicate move-around to recursive SQL queries. Srivastava and Ramakrishnan <ref> [SR92] </ref> describe a related technique for pushing predicates in Datalog programs using fold/unfold transformations. Their technique, however, is applicable only when views can be merged and, therefore, cannot be extended to deal with aggregation and relations containing duplicates.
Reference: [SRSS94] <author> D. Srivastava, K. Ross, P. Stuckey and S. Sudarshan. </author> <title> Foundations of Aggregation Constraints. </title> <booktitle> In PPCP 1994. </booktitle>
Reference-contexts: In particular, optimality is guaranteed for queries without aggregation. Achieving an optimal result for queries involving aggregation requires a better understanding of techniques for reasoning about aggregation constraints, which is a subject of current research. The work of <ref> [SRSS94] </ref> is a first step in that direction. The query-tree technique is a general algorithm and is easily extensible to new kinds of predicates and operators, including recursive SQL queries. Predicate move-around is a generalization of predicate pushdown techniques.
Reference: [SR91] <author> S. Sudarshan and R. Ramakrishnan. </author> <title> Aggregation and Relevance in Deductive Databases. </title> <booktitle> In VLDB 1991. </booktitle>
Reference-contexts: Srivastava and Ramakrishnan [SR92] describe a related technique for pushing predicates in Datalog programs using fold/unfold transformations. Their technique, however, is applicable only when views can be merged and, therefore, cannot be extended to deal with aggregation and relations containing duplicates. Sudar- shan & Ramakrishnan <ref> [SR91] </ref> describe a method for pushing down, through Datalog rules, predicates stemming from aggregate operations. Their method uses a set of rewrite rules and introduces aggregate selectors that should be processed directly by the query evaluator; hence, the query evaluator needs to be extended. in order to use their method.
Reference: [Ull89] <author> J. Ullman. </author> <title> Principles of Database and KnowledgeBase Systems, Volumes 1 and 2. </title> <publisher> Computer Science Press, </publisher> <year> 1989. </year>
Reference-contexts: When query blocks cannot be merged, it is important to rewrite the query so that predicates can be applied as early as possible. Predicate pushdown <ref> [Ull89] </ref> is a common and important optimization technique for pushing selection predicates down a query graph, in order to apply those selections as early as possible during evaluation. However, it works only on hierarchical queries, which are nonrecursive queries without common subex- pressions. <p> However, it works only on hierarchical queries, which are nonrecursive queries without common subex- pressions. Another approach is the adaptation of the magic-set transformation for an early evaluation of selection and join predicates in nonrecursive SQL queries with common subexpressions [MFPR90a]. The magic- set transformation (see <ref> [Ull89] </ref> for details) pushes predicates according to the order of doing joins and introduces auxiliary magic views. <p> fgAccounts.AC = "011" on the exported attributes is inferred from the predicate c.AC = "011" on the local attributes. 2 Note that when predicates are conjunctions of comparisons (using &lt;, and =) among constants and ordinary attributes (i.e., no aggregate terms), then the closure can be computed in polynomial time <ref> [Ull89] </ref>. * If ff is an exported predicate of L (n), then add (ff) to the label of the parent of n, where is the external renaming from the exported attributes of n to local attributes of its parent. 4.3.2 Predicate pullup through GROUPBY nodes In principle, it is enough to <p> Consequently, predicates are applied as early as possible in the evaluation in the resulting query. 5 Related Work Our work generalizes predicate-pushdown techniques (e.g., <ref> [Ull89] </ref>). The main contribution, compared to earlier work, is that we can handle aggregation and other constructs such as NOT EXISTS ; our methods can also be extended to recursive queries.
References-found: 18

