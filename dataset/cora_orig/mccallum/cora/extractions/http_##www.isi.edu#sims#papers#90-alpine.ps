URL: http://www.isi.edu/sims/papers/90-alpine.ps
Refering-URL: http://www.isi.edu/~knoblock/
Root-URL: 
Email: cak@cs.cmu.edu  
Title: Learning Abstraction Hierarchies for Problem Solving  
Author: Craig A. Knoblock 
Date: 1990  
Note: Appeared in the Proceedings of the Eighth National Conference on Artificial Intelligence, Boston, MA,  
Address: Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Abstract: The use of abstraction in problem solving is an effective approach to reducing search, but finding good abstractions is a difficult problem, even for people. This paper identifies a criterion for selecting useful abstractions, describes a tractable algorithm for generating them, and empirically demonstrates that the abstractions reduce search. The abstraction learner, called alpine, is integrated with the prodigy problem solver [ Minton et al., 1989b, Carbonell et al., 1991 ] and has been tested on large problem sets in multiple domains. 
Abstract-found: 1
Intro-found: 1
Reference: [ Aho et al., 1974 ] <author> Alfred V. Aho, John E. Hopcroft, and Jeffrey D. Ullman. </author> <title> The Design and Analysis of Computer Algorithms. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1974. </year>
Reference-contexts: The third step in the procedure performs a topological sort of the strongly connected components to find a total ordering of the literal classes, which forms an abstraction hierar-chy. Efficient algorithms for determining the strongly connected components and performing a topological sort can be found in <ref> [ Aho et al., 1974 ] </ref> . Input: Domain operators and a problem to be solved. Output: An ordered hierarchy for the given problem. procedure Create Hierarchy (goal,operators): 1. Find Constraints (goal,operators); 2. Combine Strongly Connected Components (GRAPH); 3.
Reference: [ Carbonell et al., 1991 ] <author> Jaime G. Carbonell, Craig A. Knoblock, and Steven Minton. </author> <title> PRODIGY: An integrated architecture for planning and learning. </title> <editor> In Kurt VanLehn, editor, </editor> <booktitle> Architectures for Intelligence, </booktitle> <pages> pages 241-278. </pages> <publisher> Lawrence Erlbaum, </publisher> <address> Hillsdale, NJ, </address> <year> 1991. </year>
Reference-contexts: If an abstract plan cannot be refined (e.g., conditions introduced at the current abstraction level cannot be satisfied), then the problem solver backtracks to reformulate the plan at a higher level of abstraction. The hierarchical problem solving is implemented in the prodigy architecture <ref> [ Carbonell et al., 1991 ] </ref> . prodigy is a means-ends analysis problem solver, which has been extended to perform the necessary hierarchical control and bookkeeping. The system can backtrack efficiently both across abstractions levels and within an abstraction level by maintaining the relevant problem-solving traces.
Reference: [ Christensen, 1990 ] <author> Jens Christensen. </author> <title> A hierarchical planner that creates its own hierarchies. </title> <booktitle> In Proceedings of the Eighth National Conference on Artificial Intelligence, </booktitle> <pages> pages 1004-1009, </pages> <address> Boston, MA, </address> <year> 1990. </year>
Reference-contexts: This approach forms abstrac tions based on which conditions hold during problem solving, while alpine forms abstractions based on the structure of the domain, pablo <ref> [ Christensen, 1990 ] </ref> is a hierarchical planner that also forms its own abstraction hierarchies, but the system uses a completely different approach from the one described in this paper. The operators are partially evaluated before problem solving to determine the number of steps required to achieve any given goal.
Reference: [ Eavarone, 1969 ] <author> Daniel S. Eavarone. </author> <title> A program that generates difference orderings for GPS. </title> <type> Technical Report SRC-69-6, </type> <institution> Systems Research Center, Case Western Reserve University, </institution> <year> 1969. </year>
Reference-contexts: The system then solves a problem in successive abstraction levels by first working on the parts of the problem that require the greatest number of steps. gps did not create abstractions, but did automatically generate difference orderings <ref> [ Eavarone, 1969, Ernst and Goldstein, 1982 ] </ref> , which specify the order in which to work on the various goal conditions.
Reference: [ Ernst and Goldstein, 1982 ] <author> George W. Ernst and Michael M. Goldstein. </author> <title> Mechanical discovery of classes of problem-solving strategies. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 29(1) </volume> <pages> 1-23, </pages> <year> 1982. </year>
Reference-contexts: The system then solves a problem in successive abstraction levels by first working on the parts of the problem that require the greatest number of steps. gps did not create abstractions, but did automatically generate difference orderings <ref> [ Eavarone, 1969, Ernst and Goldstein, 1982 ] </ref> , which specify the order in which to work on the various goal conditions.
Reference: [ Fikes and Nilsson, 1971 ] <author> Richard E. Fikes and Nils J. Nilsson. </author> <title> STRIPS: A new approach to the application of theorem proving to problem solving. </title> <journal> Artificial Intelligence, </journal> 2(3/4):189-208, 1971. 
Reference-contexts: These domains were originally used to evaluate explanation-based learning (ebl) in prodigy. A problem in the machine-shop scheduling domain involves finding a valid sequence of machining operations and scheduling the operations to produce various parts. The robot planning domain is an extended version of the strips domain <ref> [ Fikes and Nilsson, 1971 ] </ref> , which includes locks, keys, and a robot that can both push and carry objects. alpine produces useful abstraction hierarchies in both problem domains.
Reference: [ Knoblock, 1989 ] <author> Craig A. Knoblock. </author> <title> Learning hierarchies of abstraction spaces. </title> <booktitle> In Proceedings of the Sixth International Workshop on Machine Learning, </booktitle> <pages> pages 241-245, </pages> <address> Ithaca, NY, </address> <year> 1989. </year>
Reference-contexts: Any further refinement of the levels came from the user-defined abstraction hierarchy. In the abstrips's domain, alpine completely automates the formation of the abstraction hierarchies and produces abstractions that are considerably more effective at reducing search <ref> [ Knoblock, 1989 ] </ref> . Unruh and Rosenbloom [ 1989 ] describe a weak method implemented in soar that dynamically forms abstractions for look-ahead search by ignoring unmatched preconditions.
Reference: [ Knoblock, 1990 ] <author> Craig A. Knoblock. </author> <title> A theory of abstraction for hierarchical planning. </title> <editor> In D. Paul Ben-jamin, editor, </editor> <booktitle> Change of Representation and Inductive Bias, </booktitle> <pages> pages 81-104. </pages> <publisher> Kluwer, </publisher> <address> Boston, MA, </address> <year> 1990. </year>
Reference-contexts: Introduction Hierarchical problem solving uses abstraction to reduce the complexity of search by dividing up a problem into smaller subproblems <ref> [ Korf, 1987, Knoblock, 1990 ] </ref> . Given a problem space and a hierarchy of abstractions, called abstraction spaces, a hierarchical problem solver first solves a problem in an abstract space, and then uses the abstract solution to guide the search for a solution in successively more detailed spaces. <p> If shape were dealt with first, the problem solver would produce an abstract plan that made the part cylindrical and then insert the steps to make the hole and paint the object. 1 An ordered monotonic refinement is more restrictive than a monotonic refinement <ref> [ Knoblock, 1990 ] </ref> because it requires that every literal in the abstract space is left unchanged instead of just the specific literals that comprise the abstract plan. The distinction between an ordered monotonic hierarchy and a monotonic one is analogous. <p> The proof that the basic algorithm produces ordered abstraction hierarchies is given in <ref> [ Knoblock, 1990 ] </ref> .
Reference: [ Knoblock, 1991 ] <author> Craig A. Knoblock. </author> <title> Automatically Generating Abstractions for Problem Solving. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mel-lon University, </institution> <year> 1991. </year> <note> Available as Technical Report CMU-CS-91-120. </note>
Reference-contexts: The property constrains this refinement process. The ordered monotonicity property of an abstraction hierarchy is defined as follows. (A more formal definition of this property can be found in <ref> [ Knoblock, 1991 ] </ref> .) Ordered Monotonic Refinement: A refinement of an abstract plan that leaves the truth value of every literal in an abstract space unchanged. 1 Ordered Monotonic Hierarchy An abstraction hierarchy with the property that for every solvable problem there exists an abstract solution that has a sequence <p> This analysis is performed in a preprocessing step that only needs to be done once for a domain. When an hierarchy is created the algorithm simply looks up the potential subgoals in a table. This step is completely described in <ref> [ Knoblock, 1991 ] </ref> . When there are no abstractions for a problem the directed graph will collapse into a single node. An important advantage of the problem-specific abstractions is that the algorithm will produce fewer constraints, which reduces the likelihood that the hierarchy will collapse.
Reference: [ Korf, 1987 ] <author> Richard E. Korf. </author> <title> Planning as search: A quantitative approach. </title> <journal> Artificial Intelligence, </journal> <volume> 33(1) </volume> <pages> 65-88, </pages> <year> 1987. </year>
Reference-contexts: Introduction Hierarchical problem solving uses abstraction to reduce the complexity of search by dividing up a problem into smaller subproblems <ref> [ Korf, 1987, Knoblock, 1990 ] </ref> . Given a problem space and a hierarchy of abstractions, called abstraction spaces, a hierarchical problem solver first solves a problem in an abstract space, and then uses the abstract solution to guide the search for a solution in successively more detailed spaces.
Reference: [ Minton et al., 1989a ] <author> Steven Minton, Jaime G. Car-bonell, Craig A. Knoblock, Daniel R. Kuokka, Oren Etzioni, and Yolanda Gil. </author> <title> Explanation-based learning: A problem solving perspective. </title> <journal> Artificial Intelligence, </journal> <volume> 40(1-3):63-118, </volume> <year> 1989. </year>
Reference-contexts: Results alpine produces useful abstraction hierarchies in a number of problem domains. This section demonstrates the effectiveness of alpine's abstractions in a machine-shop scheduling domain and a robot planning domain <ref> [ Minton, 1988, Minton et al., 1989a ] </ref> . These domains were originally used to evaluate explanation-based learning (ebl) in prodigy. A problem in the machine-shop scheduling domain involves finding a valid sequence of machining operations and scheduling the operations to produce various parts.
Reference: [ Minton et al., 1989b ] <author> Steven Minton, Craig A. Knoblock, Daniel R. Kuokka, Yolanda Gil, Robert L. Joseph, and Jaime G. Carbonell. </author> <title> PRODIGY 2.0: The manual and tutorial. </title> <type> Technical Report CMU-CS-89-146, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <year> 1989. </year>
Reference: [ Minton, 1988 ] <author> Steven Minton. </author> <title> Learning Effective Search Control Knowledge: An Explanation-Based Approach. </title> <type> PhD thesis, </type> <institution> Computer Science Department, Carnegie Mellon University, </institution> <year> 1988. </year>
Reference-contexts: Results alpine produces useful abstraction hierarchies in a number of problem domains. This section demonstrates the effectiveness of alpine's abstractions in a machine-shop scheduling domain and a robot planning domain <ref> [ Minton, 1988, Minton et al., 1989a ] </ref> . These domains were originally used to evaluate explanation-based learning (ebl) in prodigy. A problem in the machine-shop scheduling domain involves finding a valid sequence of machining operations and scheduling the operations to produce various parts. <p> To evaluate the abstraction hierarchies produced by alpine, this section compares problem solving with alpine's abstractions to problem solving in prodigy. In the scheduling domain, the use of alpine's abstractions is also compared to the use of search control rules generated using explanation-based learning <ref> [ Minton, 1988 ] </ref> . The systems were tested on 100-200 randomly generated problems in each domain and were allowed to run on each problem until it was solved or the 300 second CPU time limit was exceeded.
Reference: [ Mostow and Prieditis, 1989 ] <author> Jack Mostow and Ar-mand E. </author> <title> Prieditis. Discovering admissible heuristics by abstracting and optimizing: A transformational approach. </title> <booktitle> In Proceedings of the Eleventh International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 701-707, </pages> <address> Detroit, MI, </address> <year> 1989. </year>
Reference: [ Newell and Simon, 1972 ] <author> Allen Newell and Herbert A. Simon. </author> <title> Human Problem Solving. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1972. </year>
Reference-contexts: Given a problem space and a hierarchy of abstractions, called abstraction spaces, a hierarchical problem solver first solves a problem in an abstract space, and then uses the abstract solution to guide the search for a solution in successively more detailed spaces. The technique was first used in gps <ref> [ Newell and Simon, 1972 ] </ref> and has since been used in a number of problem solvers. abstrips [ Sacerdoti, 1974 ] was the first system that attempted to automate the formation of abstraction spaces, but only partially automated the process.
Reference: [ Sacerdoti, 1974 ] <author> Earl D. Sacerdoti. </author> <title> Planning in a hierarchy of abstraction spaces. </title> <journal> Artificial Intelligence, </journal> <volume> 5(2) </volume> <pages> 115-135, </pages> <year> 1974. </year>
Reference-contexts: The technique was first used in gps [ Newell and Simon, 1972 ] and has since been used in a number of problem solvers. abstrips <ref> [ Sacerdoti, 1974 ] </ref> was the first system that attempted to automate the formation of abstraction spaces, but only partially automated the process. Most hierarchical problem solvers are simply provided with abstractions that are hand-tailored to a specific domain [ Sacerdoti, 1977, Tate, 1977, Wilkins, 1984 ] . <p> As the graph shows, alpine performed significantly better than prodigy on the solvable problems, and alpine was able solve 99% of the problems within the time limit, while prodigy only solved 90%. Related Work abstrips <ref> [ Sacerdoti, 1974 ] </ref> was one of the earliest attempts at automating the formation of abstraction hierarchies.
Reference: [ Sacerdoti, 1977 ] <author> Earl D. Sacerdoti. </author> <title> A Structure for Plans and Behavior. </title> <publisher> American Elsevier, </publisher> <address> New York, NY, </address> <year> 1977. </year>
Reference-contexts: Most hierarchical problem solvers are simply provided with abstractions that are hand-tailored to a specific domain <ref> [ Sacerdoti, 1977, Tate, 1977, Wilkins, 1984 ] </ref> . This paper describes an abstraction learner, called alpine, that completely automates the formation of abstraction hierarchies.
Reference: [ Tate, 1977 ] <author> Austin Tate. </author> <title> Generating project networks. </title> <booktitle> In Proceedings of the Fifth International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 888-900, </pages> <address> Cambridge, MA, </address> <year> 1977. </year>
Reference-contexts: Most hierarchical problem solvers are simply provided with abstractions that are hand-tailored to a specific domain <ref> [ Sacerdoti, 1977, Tate, 1977, Wilkins, 1984 ] </ref> . This paper describes an abstraction learner, called alpine, that completely automates the formation of abstraction hierarchies.
Reference: [ Unruh and Rosenbloom, 1989 ] <author> Amy Unruh and Paul S. Rosenbloom. </author> <title> Abstraction in problem solving and learning. </title> <booktitle> In Proceedings of the Eleventh International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 681-687, </pages> <address> Detroit, MI, </address> <year> 1989. </year>
Reference: [ Veloso and Carbonell, 1989 ] <author> M. M. Veloso and J. G. Carbonell. </author> <title> Learning analogies by analogy the closed loop of memory organization and problem solving. </title> <booktitle> In Proceedings of the Second Workshop on Case-Based Reasoning, </booktitle> <pages> pages 153-159, </pages> <year> 1989. </year>
Reference-contexts: Future work will include developing techniques to efficiently generate these finer-grained hierarchies. Another promising direction for future work is the integration of alpine with other types of learning, such as explanation-based learning and learning by analogy <ref> [ Veloso and Carbonell, 1989 ] </ref> . Since alpine forms abstract models of the original problem space, these other types of learning can be applied within the abstract spaces. Thus, ebl could produce control knowledge within an abstract space, and analogy could store and reuse abstract problem-solving episodes.
Reference: [ Wilkins, 1984 ] <author> David E. Wilkins. </author> <title> Domain-independent planning: Representation and plan generation. </title> <journal> Artificial Intelligence, </journal> <volume> 22(3) </volume> <pages> 269-301, </pages> <year> 1984. </year>
Reference-contexts: Most hierarchical problem solvers are simply provided with abstractions that are hand-tailored to a specific domain <ref> [ Sacerdoti, 1977, Tate, 1977, Wilkins, 1984 ] </ref> . This paper describes an abstraction learner, called alpine, that completely automates the formation of abstraction hierarchies.
References-found: 21

