URL: ftp://ic.eecs.berkeley.edu/pub/Thesis/kam.ps.Z
Refering-URL: http://www-cad.eecs.berkeley.edu/Respep/Research/Thesis/thesis.html
Root-URL: http://www.cs.berkeley.edu
Title: State Minimization of Finite State Machines using Implicit Techniques  
Author: by Timothy Yee-Kwong Kam 
Degree: M.S. (University of California at Berkeley) 1990 A dissertation submitted in partial satisfaction of the requirements for the degree of Doctor of Philosophy in Electrical Engineering and Computer Sciences in the GRADUATE DIVISION of the UNIVERSITY of CALIFORNIA at BERKELEY Committee in charge: Professor Robert K. Brayton, Chair Professor Alberto L. Sangiovanni-Vincentelli Professor Dorit Hochbaum  
Date: 1986  1995  
Address: London)  
Affiliation: B.Sc.(Eng.) (University College, University of  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> S. B. Akers. </author> <title> Binary decision diagrams. </title> <journal> IEEE Transactions on Computers, </journal> <volume> vol. 27 </volume> <pages> 509-516, </pages> <year> 1978. </year>
Reference-contexts: Cofactors with respect to literals are similar to the ones in the previous section, and are formally defined in Section 3.3.1. Binary decision diagrams were first proposed by Akers in <ref> [1] </ref> and popularized by Bryant in [11]. Definition 3.11 A binary decision diagram (BDD) is a rooted, directed acyclic graph. Each nonterminal vertex v is labeled by a Boolean variable var (v). Vertex v has two outgoing arcs, child 0 (v) and child 1 (v).
Reference: [2] <author> A. Aziz, F. Balarin, R. K. Brayton, M. D. Di Benedetto, A. Saldanha, and A. L. Sangiovanni-Vincentelli. </author> <title> Supervisory control of finite state machines. </title> <booktitle> In Proceedings of International Conference on Computer-Aided Verification, </booktitle> <year> 1995. </year>
Reference-contexts: A theoretical solution is presented for the problem of exact state minimization of general non-deterministic FSM's, based on the proposal of generalized compatibles. This gives an algorithmic foundation for exploring behaviors contained in an NDFSM. Recent research <ref> [83, 4, 2] </ref> in sequential synthesis, verification and supervisory control relies, as a final step, on the selection of an optimum behavior to be implemented at a component FSM within a network of FSM's. <p> 2 S p and an x 2 X , there exists u and v such that p ((s 1 ; s 2 ); x) def 2 (s 2 ; xv) and def 2 There is an analogy here with the implicit function theorem in real analysis. 3 As observed in <ref> [2] </ref>, we only need M 2 to be Moore in v, but it can be Mealy in x. 4 A detailed constructive definition of S p will be given in Theorem 7.3. 7.1. <p> This more complex notion of compatibles leads to simpler binate covering. In the next section, we shall show that the compatible can be defined without associating an output minterm with it. 7.3.1 Implicit Compatible Generation Balarin et al. in <ref> [2] </ref> observed the following fact that improves the efficiency of compatible generation a state that cannot produce a same output for all inputs is not involved in any compatible in any reduced Moore machine. <p> On the k-th iteration, according to Definition 7.7, we consider a set c to be an M-compatible if and only if there is an output v such that for every input u, c can transit to a C k M-compatible under u and v. Note that Balarin's method <ref> [2] </ref> of trimming the state space to Moore states can also be applied here, but it will generate more compatibles than our set of M-compatibles. 7.4.2 Selecting a Moore Contained Behavior In this subsection, we consider the problem of finding a Moore behavior that is contained in the E-machine while we
Reference: [3] <author> A. Aziz, F. Balarin, S. Cheng, R. Hojati, T. Kam, S. Krishnan, R. Ranjan, T. Shiple, V. Singhal, S. Tasiran, H. Wang, R. Brayton, and A. Sangiovanni-Vincentelli. HSIS: </author> <title> A BDD-based environment for formal verification. </title> <booktitle> In Proceedings of the Design Automation Conference, </booktitle> <pages> pages 454-459, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: This allows us to construct a function by recursive decomposition. 3.2. MULTI-VALUED DECISION DIAGRAMS 35 3.2 Multi-valued Decision Diagrams This section describes a new data structure the multi-valued decision diagram [78, 36] that is used to solve discrete variable problems <ref> [36, 45, 84, 44, 3] </ref>. Our definition of multi-valued decision diagrams closely follows that of Bryant, [11], with two exceptions: we do not restrict ourselves to the Boolean domain, and the range of our functions is multi-valued.
Reference: [4] <author> M. Di Benedetto, A. Saldanha, and A. Sangiovanni-Vincentelli. </author> <title> Model matching for finite state machines. </title> <booktitle> In Proceedings of the IEEE Conference on Decision and Control, </booktitle> <month> December </month> <year> 1994. </year>
Reference-contexts: A theoretical solution is presented for the problem of exact state minimization of general non-deterministic FSM's, based on the proposal of generalized compatibles. This gives an algorithmic foundation for exploring behaviors contained in an NDFSM. Recent research <ref> [83, 4, 2] </ref> in sequential synthesis, verification and supervisory control relies, as a final step, on the selection of an optimum behavior to be implemented at a component FSM within a network of FSM's. <p> Different minimization problems will be described in Section 7.2. Implicit algorithms will be proposed for these problems in Sections 7.3, 7.4 and 7.5. Similar formulations of this problem have been called model matching of FSM's in the context of the supervisory control problem for discrete event processes <ref> [62, 4, 5] </ref>. <p> Functions p and ffi p might not exist because of the dependence on u and v. The above definition was conceived independently from a similar notion of well-defined composition presented earlier in <ref> [4, 5] </ref>, when characterizing by means of a pre-post dynamic state compensator all solutions to the model matching problem in a closed plant-compensator configuration. Analysis of combinational cycles in circuits has been reported in [51, 12, 75]. Example Consider p ((s 1 ; s 2 ); x) = z.
Reference: [5] <author> M. Di Benedetto, A. Saldanha, and A. Sangiovanni-Vincentelli. </author> <title> Strong model matching for finite state machines. </title> <note> Submitted for publication, </note> <month> September </month> <year> 1995. </year>
Reference-contexts: Different minimization problems will be described in Section 7.2. Implicit algorithms will be proposed for these problems in Sections 7.3, 7.4 and 7.5. Similar formulations of this problem have been called model matching of FSM's in the context of the supervisory control problem for discrete event processes <ref> [62, 4, 5] </ref>. <p> Functions p and ffi p might not exist because of the dependence on u and v. The above definition was conceived independently from a similar notion of well-defined composition presented earlier in <ref> [4, 5] </ref>, when characterizing by means of a pre-post dynamic state compensator all solutions to the model matching problem in a closed plant-compensator configuration. Analysis of combinational cycles in circuits has been reported in [51, 12, 75]. Example Consider p ((s 1 ; s 2 ); x) = z.
Reference: [6] <author> K. Brace, R. Rudell, and R. Bryant. </author> <title> Efficient implementation of a BDD package. </title> <booktitle> In Proceedings of the Design Automation Conference, </booktitle> <pages> pages 40-45, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: BINARY DECISION DIAGRAMS 41 3.3.1 BDD Operators A rich set of BDD operators has been developed and published in the literature <ref> [11, 6] </ref>. The following is the subset of operators useful in our work. The ITE operator forms the basis for the construction and manipulation of BDD's. The use of the ITE operator also guarantees that the resulting BDD is in strong canonical form [6]. <p> The following is the subset of operators useful in our work. The ITE operator forms the basis for the construction and manipulation of BDD's. The use of the ITE operator also guarantees that the resulting BDD is in strong canonical form <ref> [6] </ref>. The CASE operator is the multi-valued analog of the ITE operator. <p> The total number of nonterminal vertices in the BDD of T uple n;k is (n k + 1) (k + 1) 1 = nk k 2 + n = O (nk). With the use of the computed table <ref> [6] </ref>, the time complexity of the above algorithm is also O (nk) as the BDD is built from bottom up and each vertex is built once and then re-used. <p> Conflict will occur only when they become operands to a BDD operation. Actually as a result of overlapping in variable supports, such unrelated functions can be constructed and manipulated more efficiently due to sharing of BDD subgraphs, i.e., possible hits in the unique and computed hash tables <ref> [6] </ref> in a BDD package. 4.6.2 BDD Variable Ordering The issue of BDD variable ordering has been introduced in Section 3.9. 88 CHAPTER 4. <p> Since now on, by BDD of a set we will denote the BDD of the characteristic function of the set over an appropriate Boolean space. As defined in Section 3.3, a BDD <ref> [11, 6] </ref> is a canonical directed acyclic graph data structure that represents logic functions. The items that a BDD can represent are determined by the number of paths of the BDD, while the size of the BDD is determined by the number of nodes of the DAG.
Reference: [7] <author> R. Brayton, G. Hachtel, C. McMullen, and A. Sangiovanni-Vincentelli. </author> <title> Logic Minimization Algorithms for VLSI Synthesis. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1984. </year>
Reference-contexts: More recent work at Bull [19, 48] has shown how implicants, primes and essential primes of a two-valued or multi-valued function can also be computed implicitly. Reported experiments show a suite of examples where all primes could be computed, whereas explicit techniques implemented in ESPRESSO <ref> [7] </ref> failed to do so. Therefore it is important to investigate how far these techniques based on implicit com 8 CHAPTER 1. INTRODUCTION putations can be pushed to solve the core problems of logic synthesis and verification. <p> Results on a variety of benchmarks are reported and discussed in Section 4.7. 4.2 Classical Definitions and Algorithm Most of the terminology used in this chapter is common parlance of the logic synthesis community <ref> [40, 7, 8] </ref>. In this section we will revise briefly the basic definitions and procedures for exact state minimization of ISFSM's, as presented in the original papers and standard textbooks [60, 28, 40]. First we restate the definition of incompletely specified FSM's. <p> Later work at Bull [19, 48] has shown how implicants, primes and essential primes of a two-valued or multi-valued function can also be computed implicitly. Reported experiments show a suite of examples where all primes could be computed, whereas explicit techniques implemented in ESPRESSO <ref> [7] </ref> failed to do so. Finally, the fixed-point dominance computation in the covering step of the Quine-McCluskey procedure has been made implicit in current work [18, 79]. The experiments reported show that the cyclic core of all logic functions of the ESPRESSO benchmark can be successfully computed.
Reference: [8] <author> R. Brayton, A. Sangiovanni-Vincentelli, and G. Hachtel. </author> <title> Multi-level logic synthesis. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> vol. 78(no. 2):264-300, February 1990. 204 </volume> BIBLIOGRAPHY 
Reference-contexts: Combinational Logic Synthesis After synthesis at the sequential level, the next step is to perform an optimization on the combinational portion of a circuit. The goal of combinational logic synthesis <ref> [8] </ref> is to find an optimal interconnection of primitive logic gates that realizes the same functionality as the original circuit. This process involves two steps: technology independent optimization and technology mapping. Technology independent optimization derives an optimal structure of the circuit independent of the gates available in a particular technology. <p> Results on a variety of benchmarks are reported and discussed in Section 4.7. 4.2 Classical Definitions and Algorithm Most of the terminology used in this chapter is common parlance of the logic synthesis community <ref> [40, 7, 8] </ref>. In this section we will revise briefly the basic definitions and procedures for exact state minimization of ISFSM's, as presented in the original papers and standard textbooks [60, 28, 40]. First we restate the definition of incompletely specified FSM's.
Reference: [9] <author> R. Brayton, A. Sangiovanni-Vincentelli, G. Hachtel, and R. Rudell. </author> <title> Multi-level logic synthesis. unpublished book, </title> <year> 1992. </year>
Reference-contexts: This technique has been described in <ref> [29, 28, 9, 10] </ref>, and implemented in successful computer programs [67, 64, 76]. The branch-and-bound solution of minimum binate covering is based on a recursive procedure. A run of the algorithm can be described by its computation tree. <p> Even though more complex criteria of dominance have been investigated (for instance, Section 5.5.12), the previous ones are basic in any table covering solver. Reduction rules have previously been stated for the binate covering case <ref> [28, 29, 10, 9] </ref>, and also for the unate covering case [54, 68, 9]. The former set of reductions are needed for state minimization. Here we will present the known reduction rules directly for binate covering and indicate how they simplify for unate covering, when applicable. <p> Even though more complex criteria of dominance have been investigated (for instance, Section 5.5.12), the previous ones are basic in any table covering solver. Reduction rules have previously been stated for the binate covering case [28, 29, 10, 9], and also for the unate covering case <ref> [54, 68, 9] </ref>. The former set of reductions are needed for state minimization. Here we will present the known reduction rules directly for binate covering and indicate how they simplify for unate covering, when applicable. <p> For each of them, we will first define the reduction rule, and then a theorem showing how that rule is applied. Proofs for the correctness of these reduction rules have been given in <ref> [28, 29, 10, 9] </ref>, and they will not be repeated here, except for a few less common ones. We will provide a survey comparing different related reduction rules used in the literature. The effect of reductions depends on the order of their application. <p> dominance), * similar to column dominance (Rule 3) in [29], except that the labels of dominator row, R i , and dominated row, R j , are reversed (i.e., reverse definition of dominance), * equivalent to row dominance (Definition 10) in [10], * identical to row dominance (Definition 2.11) in <ref> [9] </ref>. <p> first half of Rule 4 in [29]: (a) C j has all the 1's of C k and (b1) C k has all the 0's of C j , * identical to column dominance (Definition 11, Theorem 3) in [10], * identical to column dominance (Definition 2.12, Theorem 2.4.1) in <ref> [9] </ref>. 5.5. <p> 0, such that disregarding entries in row C i and C j , R p dominates R q (with reverse definition of row dominance), noticing that by mistake the condition that C i does not have a 0 in row R q was omitted, * not mentioned in [10] and <ref> [9] </ref>. 5.5.5 Column Dominance Definition 5.6 A column C i dominates another column C j if either C i ff-dominates C j or C i fi-dominates C j . Theorem 5.7 Let M be satisfiable. <p> definition of essential column is * identical to essential row (Rule 2) in [28], * identical to Rule 1 in [29], * included in Definition 9 in [10]: the row R i in the above definition corresponds to a singleton-1 essential row in [10], * included in Definition 2.10 in <ref> [9] </ref>: the row R i in the above definition corresponds to a singleton-1 essential row in [9]. <p> to Rule 1 in [29], * included in Definition 9 in [10]: the row R i in the above definition corresponds to a singleton-1 essential row in [10], * included in Definition 2.10 in <ref> [9] </ref>: the row R i in the above definition corresponds to a singleton-1 essential row in [9]. <p> BINATE COVERING * included in Definition 9 in [10]: the row R i in the above definition corresponds to a singleton-0 essential row in [10], * included in Definition 2.10 in <ref> [9] </ref>: the row R i in the above definition corresponds to a singleton-0 essential row in [9]. 5.5.9 Unnecessary Column Definition 5.11 A column of only 0's and 2's is an unnecessary column. Notice that there is no symmetric rule for columns of 1's and 2's. <p> BINATE COVERING * included in Definition 9 in [10]: the row R i in the above definition corresponds to a singleton-0 essential row in [10], * included in Definition 2.10 in <ref> [9] </ref>: the row R i in the above definition corresponds to a singleton-0 essential row in [9]. 5.5.9 Unnecessary Column Definition 5.11 A column of only 0's and 2's is an unnecessary column. Notice that there is no symmetric rule for columns of 1's and 2's. <p> This definition of unnecessary column is * identical to Rule 4 in [28], * identical to Rule 5 in [29], * not mentioned in [10] and <ref> [9] </ref>. 5.5.10 Trial Rule Theorem 5.12 If there exists in a covering table M a row R i having a 0 in column C j , a 1 in column C k and 2's in the rest, then apply the following test: * eliminate C k together with the rows in <p> This definition of infeasibility is * not mentioned in [28] and [29], * briefly mentioned in [10], * identical to the unfeasible problem in <ref> [9] </ref>. 5.5.12 Gimpel's Reduction Step Another heuristic for solving the minimum cover problem has been suggested by Gim-pel [27]. Gimpel proposed a reduction step which simplifies the covering matrix when it has a special form.
Reference: [10] <author> R. Brayton and F. Somenzi. </author> <title> An exact minimizer for Boolean relations. </title> <booktitle> In Digest of Technical Papers of the IEEE International Conference on Computer-Aided Design, </booktitle> <pages> pages 316-319, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: Various techniques have been proposed to solve binate covering problems. A class of them <ref> [10, 42] </ref> are branch-and-bound techniques that build explicitly the table of the constraints expressed as product-of-sum expressions and explore in the worst-case all possible solutions, but avoid the generation of some of the suboptimal solutions by a clever use of reduction steps and bounding of search space for solutions. <p> This technique has been described in <ref> [29, 28, 9, 10] </ref>, and implemented in successful computer programs [67, 64, 76]. The branch-and-bound solution of minimum binate covering is based on a recursive procedure. A run of the algorithm can be described by its computation tree. <p> Even though more complex criteria of dominance have been investigated (for instance, Section 5.5.12), the previous ones are basic in any table covering solver. Reduction rules have previously been stated for the binate covering case <ref> [28, 29, 10, 9] </ref>, and also for the unate covering case [54, 68, 9]. The former set of reductions are needed for state minimization. Here we will present the known reduction rules directly for binate covering and indicate how they simplify for unate covering, when applicable. <p> For each of them, we will first define the reduction rule, and then a theorem showing how that rule is applied. Proofs for the correctness of these reduction rules have been given in <ref> [28, 29, 10, 9] </ref>, and they will not be repeated here, except for a few less common ones. We will provide a survey comparing different related reduction rules used in the literature. The effect of reductions depends on the order of their application. <p> R j , are reversed (i.e., reverse definition of dominance), * similar to column dominance (Rule 3) in [29], except that the labels of dominator row, R i , and dominated row, R j , are reversed (i.e., reverse definition of dominance), * equivalent to row dominance (Definition 10) in <ref> [10] </ref>, * identical to row dominance (Definition 2.11) in [9]. <p> i;j = 0 and M i;k = 0, * equivalent to first half of Rule 4 in [29]: (a) C j has all the 1's of C k and (b1) C k has all the 0's of C j , * identical to column dominance (Definition 11, Theorem 3) in <ref> [10] </ref>, * identical to column dominance (Definition 2.12, Theorem 2.4.1) in [9]. 5.5. <p> has a 0, such that disregarding entries in row C i and C j , R p dominates R q (with reverse definition of row dominance), noticing that by mistake the condition that C i does not have a 0 in row R q was omitted, * not mentioned in <ref> [10] </ref> and [9]. 5.5.5 Column Dominance Definition 5.6 A column C i dominates another column C j if either C i ff-dominates C j or C i fi-dominates C j . Theorem 5.7 Let M be satisfiable. <p> Column C j must then be deleted together with all the rows in which it has 1's. This definition of essential column is * identical to essential row (Rule 2) in [28], * identical to Rule 1 in [29], * included in Definition 9 in <ref> [10] </ref>: the row R i in the above definition corresponds to a singleton-1 essential row in [10], * included in Definition 2.10 in [9]: the row R i in the above definition corresponds to a singleton-1 essential row in [9]. <p> This definition of essential column is * identical to essential row (Rule 2) in [28], * identical to Rule 1 in [29], * included in Definition 9 in <ref> [10] </ref>: the row R i in the above definition corresponds to a singleton-1 essential row in [10], * included in Definition 2.10 in [9]: the row R i in the above definition corresponds to a singleton-1 essential row in [9]. <p> This definition of unacceptable column is * identical to that of nonselectionable row in [28], * identical to Rule 2 in [29], 122 CHAPTER 5. BINATE COVERING * included in Definition 9 in <ref> [10] </ref>: the row R i in the above definition corresponds to a singleton-0 essential row in [10], * included in Definition 2.10 in [9]: the row R i in the above definition corresponds to a singleton-0 essential row in [9]. 5.5.9 Unnecessary Column Definition 5.11 A column of only 0's and <p> This definition of unacceptable column is * identical to that of nonselectionable row in [28], * identical to Rule 2 in [29], 122 CHAPTER 5. BINATE COVERING * included in Definition 9 in <ref> [10] </ref>: the row R i in the above definition corresponds to a singleton-0 essential row in [10], * included in Definition 2.10 in [9]: the row R i in the above definition corresponds to a singleton-0 essential row in [9]. 5.5.9 Unnecessary Column Definition 5.11 A column of only 0's and 2's is an unnecessary column. <p> This definition of unnecessary column is * identical to Rule 4 in [28], * identical to Rule 5 in [29], * not mentioned in <ref> [10] </ref> and [9]. 5.5.10 Trial Rule Theorem 5.12 If there exists in a covering table M a row R i having a 0 in column C j , a 1 in column C k and 2's in the rest, then apply the following test: * eliminate C k together with the <p> Theorem 5.13 A covering problem M is infeasible if there exists a column C j which is both essential and unacceptable (implying x j = 1 and x j = 0). This definition of infeasibility is * not mentioned in [28] and [29], * briefly mentioned in <ref> [10] </ref>, * identical to the unfeasible problem in [9]. 5.5.12 Gimpel's Reduction Step Another heuristic for solving the minimum cover problem has been suggested by Gim-pel [27]. Gimpel proposed a reduction step which simplifies the covering matrix when it has a special form.
Reference: [11] <author> R. Bryant. </author> <title> Graph based algorithm for Boolean function manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> vol. 35(no. </volume> 8):667-691, 1986. 
Reference-contexts: Berkeley [80] produced powerful techniques for implicit enumeration of subsets of states of an FSM. These techniques are based on the idea of operating on large sets of states by their characteristic functions [13] represented by binary decision diagrams (BDD's) <ref> [11] </ref>. In many cases of practical interest, these sets have a regular structure that translates into small-sized BDD's. <p> The objects we need to represent include functions, relations, sets, and sets of sets. In Section 3.2, we introduce a new data structure called the multi-valued decision diagram (MDD) which can represent multi-valued input multi-valued output functions. MDD is an generalization of binary decision diagram (BDD) <ref> [11] </ref> which will be reviewed in Section 3.3, and the latter represents binary input binary output functions. Relations and sets can be expressed in terms of characteristic functions [13] as shown in Section 3.3. We also describe a variant of BDD called the zero-suppressed BDD (ZBDD) in Section 3.4. <p> MULTI-VALUED DECISION DIAGRAMS 35 3.2 Multi-valued Decision Diagrams This section describes a new data structure the multi-valued decision diagram [78, 36] that is used to solve discrete variable problems [36, 45, 84, 44, 3]. Our definition of multi-valued decision diagrams closely follows that of Bryant, <ref> [11] </ref>, with two exceptions: we do not restrict ourselves to the Boolean domain, and the range of our functions is multi-valued. From Section 3.3 onwards, we use only binary-valued output functions, however the theory is valid for the more general multi-valued functions. <p> Cofactors with respect to literals are similar to the ones in the previous section, and are formally defined in Section 3.3.1. Binary decision diagrams were first proposed by Akers in [1] and popularized by Bryant in <ref> [11] </ref>. Definition 3.11 A binary decision diagram (BDD) is a rooted, directed acyclic graph. Each nonterminal vertex v is labeled by a Boolean variable var (v). Vertex v has two outgoing arcs, child 0 (v) and child 1 (v). Each terminal vertex u is labeled 0 or 1. <p> BINARY DECISION DIAGRAMS 41 3.3.1 BDD Operators A rich set of BDD operators has been developed and published in the literature <ref> [11, 6] </ref>. The following is the subset of operators useful in our work. The ITE operator forms the basis for the construction and manipulation of BDD's. The use of the ITE operator also guarantees that the resulting BDD is in strong canonical form [6]. <p> Since now on, by BDD of a set we will denote the BDD of the characteristic function of the set over an appropriate Boolean space. As defined in Section 3.3, a BDD <ref> [11, 6] </ref> is a canonical directed acyclic graph data structure that represents logic functions. The items that a BDD can represent are determined by the number of paths of the BDD, while the size of the BDD is determined by the number of nodes of the DAG.
Reference: [12] <author> J. R. Burch, D. Dill, E. Wolf, and G. DeMicheli. </author> <title> Modelling hierarchical combinational circuits. </title> <booktitle> In Digest of Technical Papers of the IEEE International Conference on Computer-Aided Design, </booktitle> <pages> pages 612-617, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: Analysis of combinational cycles in circuits has been reported in <ref> [51, 12, 75] </ref>. Example Consider p ((s 1 ; s 2 ); x) = z.
Reference: [13] <author> E. Cerny. </author> <title> Characteristic functions in multivalued logic systems. </title> <booktitle> Digital Processes, </booktitle> <volume> vol. 6 </volume> <pages> 167-174, </pages> <month> June </month> <year> 1980. </year>
Reference-contexts: Seminal work by researchers at Bull [16] and improvements at U.C. Berkeley [80] produced powerful techniques for implicit enumeration of subsets of states of an FSM. These techniques are based on the idea of operating on large sets of states by their characteristic functions <ref> [13] </ref> represented by binary decision diagrams (BDD's) [11]. In many cases of practical interest, these sets have a regular structure that translates into small-sized BDD's. <p> These concepts introduced are central to exact algorithms for state minimization for FSM's. At the end, the correctness of our state minimization algorithms will be proved for a class of FSM's called the pseudo non-deterministic FSM's. 2.1 Taxonomy of Finite State Machines We use characteristic functions proposed by Cerny <ref> [13] </ref> to represent sets and relations, both in theory and in practice. In the sequel, B = f0; 1g. Definition 2.1 Given a subset S U where U is some finite domain, the characteristic function of S, S : U ! B, is defined as follows. <p> MDD is an generalization of binary decision diagram (BDD) [11] which will be reviewed in Section 3.3, and the latter represents binary input binary output functions. Relations and sets can be expressed in terms of characteristic functions <ref> [13] </ref> as shown in Section 3.3. We also describe a variant of BDD called the zero-suppressed BDD (ZBDD) in Section 3.4. The remaining of the chapter concerns with efficient representation of multi-valued input binary output functions. <p> Definition 3.14 A reduced ordered binary decision diagram (ROBDD) is a BDD which is both reduced and ordered. Any subset S in a Boolean space B n can be represented by a unique Boolean function S : B n ! B, which is called its characteristic function <ref> [13] </ref>, such that: S (x) = 1 if and only if x in S In the sequel, we'll not distinguish the subset S from its characteristic function S , and will use S to denote both.
Reference: [14] <author> E. Cerny. </author> <title> Verification of I/O trace set inclusion for a class of non-deterministic finite state machines. </title> <booktitle> In Proceedings of the International Conference on Computer Design, </booktitle> <pages> pages 526-530, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: R S represents the set of reset states. By definition, a PNDFSM is an 1-PNDFSM. Cerny in <ref> [14] </ref> has given a polynomial algorithm to convert a k-PNDFSM to a PNDFSM. A k-PNDFSM has a representation smaller or equal to that of an equivalent PNDFSM. <p> M det is pseudo non-deterministic. Theorem 2.10 (k-PNDFSM ! 1-PNDFSM) Construction given by Cerny in <ref> [14] </ref>. 2.4 Trace Sets and Behaviors In the remaining sections of this chapter, we shall introduce different concepts that lead up to an exact algorithm for state minimization.
Reference: [15] <author> R. P. Colwell and R. L. Steck. </author> <title> A 0.6um BiCMOS processor with dynamic execution. </title> <booktitle> In Proceedings of IEEE International Solid-State Circuits Conference, </booktitle> <month> February </month> <year> 1995. </year>
Reference-contexts: This dissertation is concerned with the problem of automatically synthesizing a class of digital circuits. Manual Design Vs. Automatic Synthesis To best motivate the need for automatic synthesis, let us consider, as an example of the state-of-the-art VLSI design, the Intel's P6 microprocessor <ref> [15] </ref>. To stay ahead in the race for the next generation microprocessors, the most crucial factor in such a VLSI circuit design is probably the design time, which has a big effect on its time-to-market and ultimately to product success in the market.
Reference: [16] <author> O. Coudert, C. Berthet, and J. C. Madre. </author> <title> Verification of sequential machines using functional Boolean vectors. </title> <booktitle> IFIP Conference, </booktitle> <month> November </month> <year> 1989. </year>
Reference-contexts: Implicit representation means a shared representation of the objects, such that the size of the representation is not proportional to the number of objects in it. By implicit manipulation, we mean that in one step, many objects are processed simultaneously. Seminal work by researchers at Bull <ref> [16] </ref> and improvements at U.C. Berkeley [80] produced powerful techniques for implicit enumeration of subsets of states of an FSM. These techniques are based on the idea of operating on large sets of states by their characteristic functions [13] represented by binary decision diagrams (BDD's) [11]. <p> Special care must be exercised with quantifications, that bring more danger of BDD blowups. All of this goes often under the name of implicit representations and computations. The previous insight has already been tested in a series of applications. Research at Bull <ref> [16] </ref> and U.C. Berkeley [80] produced powerful techniques for implicit enumeration of subsets of states of a Finite State Machine (FSM). Later work at Bull [19, 48] has shown how implicants, primes and essential primes of a two-valued or multi-valued function can also be computed implicitly.
Reference: [17] <author> O. Coudert, C. Berthet, and J. C. Madre. </author> <title> Verification of synchronous sequential machines based on symbolic execution. Proceedings of the Workshop on Automatic Verification Methods for Finite State Systems, </title> <month> June </month> <year> 1989. </year>
Reference-contexts: In fact, an unused point is assigned to the same path as the used point whose encoding is closest to the unused code point. This mapping is related to the generalized cofactor operator in [80] which was initially proposed in <ref> [17] </ref> as the constraint operator. Given a function f and a care set c, the generalized cofactor of f with respect to c is the projection of f that maps a don't care point x to the care point y 2 c which has the closest distance to x.
Reference: [18] <author> O. Coudert, H. Fraisse, and J. C. Madre. </author> <title> A new viewpoint on two-level logic minimization. </title> <booktitle> In Proceedings of the Design Automation Conference, </booktitle> <pages> pages 625-630, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Reported experiments show a suite of examples where all primes could be computed, whereas explicit techniques implemented in ESPRESSO [7] failed to do so. Finally, the fixed-point dominance computation in the covering step of the Quine-McCluskey procedure has been made implicit in current work <ref> [18, 79] </ref>. The experiments reported show that the cyclic core of all logic functions of the ESPRESSO benchmark can be successfully computed. For some of them ESPRESSO failed the task.
Reference: [19] <author> O. Coudert and J. C. Madre. </author> <title> Implicit and incremental computation of prime and essential prime implicants of Boolean functions. </title> <booktitle> In Proceedings of the Design Automation Conference, </booktitle> <pages> pages 36-39, </pages> <month> June </month> <year> 1992. </year> <note> BIBLIOGRAPHY 205 </note>
Reference-contexts: Of course, it may be the case that the BDD cannot be constructed, because of the intrinsic structure of the function to represent or because a good ordering of the variables is not found. More recent work at Bull <ref> [19, 48] </ref> has shown how implicants, primes and essential primes of a two-valued or multi-valued function can also be computed implicitly. Reported experiments show a suite of examples where all primes could be computed, whereas explicit techniques implemented in ESPRESSO [7] failed to do so. <p> A 1-hot encoded MDD can be represented as a BDD where each Boolean variable corresponds to a BDD variable. From now on, we use BDD to refer to 1-hot encoded MDD where there is no ambiguity. 1 The representation of primes proposed by Coudert et al. <ref> [19] </ref> needs 3 values per variable to distinguish if the present literal is in positive or negative phase or in both phases. 52 CHAPTER 3. <p> The previous insight has already been tested in a series of applications. Research at Bull [16] and U.C. Berkeley [80] produced powerful techniques for implicit enumeration of subsets of states of a Finite State Machine (FSM). Later work at Bull <ref> [19, 48] </ref> has shown how implicants, primes and essential primes of a two-valued or multi-valued function can also be computed implicitly. Reported experiments show a suite of examples where all primes could be computed, whereas explicit techniques implemented in ESPRESSO [7] failed to do so.
Reference: [20] <author> M. Damiani. </author> <title> Nondeterministic finite-state machines and sequential don't cares. </title> <booktitle> In European Conference on Design Automation, </booktitle> <pages> pages 192-198, </pages> <year> 1994. </year>
Reference-contexts: R S represents the set of reset states. Explicit algorithms for exact state minimization for PNDFSM's have been proposed by Watanabe et al. in [86] and by Damiani in <ref> [20] </ref>. In this section, we contribute the first fully implicit algorithms for exact state minimization of PNDFSM's. The theory for PNDFSM state minimization has already been given in Chapter 2. <p> Of all such sequential functions, those that satisfy given criteria of correctness are valid candidates for implementation (design verification stage). Of all valid candidates, one maximizing a given optimization criterion is implemented (synthesis stage). Recent papers <ref> [86, 85, 20] </ref> have proposed specific applications of NDFSM's, especially PNDFSM's, to sequential synthesis. Some examples are presented in [20]. NDFSM's arise in sequential synthesis when capturing all the flexibility that is in a node of a network of FSM's. <p> Of all valid candidates, one maximizing a given optimization criterion is implemented (synthesis stage). Recent papers [86, 85, 20] have proposed specific applications of NDFSM's, especially PNDFSM's, to sequential synthesis. Some examples are presented in <ref> [20] </ref>. NDFSM's arise in sequential synthesis when capturing all the flexibility that is in a node of a network of FSM's. We will summarize the related theory, which was first proposed by Watanabe et al. in [86, 85].
Reference: [21] <author> M. Davio, J.-P. Deschamps, and A. Thayse. </author> <title> Discrete and Switching Functions. </title> <publisher> Georgi Publishing Co. and McGraw-Hill International Book Company, </publisher> <year> 1978. </year>
Reference-contexts: R S represents the set of reset states. 1 Note that in this and subsequent definitions, the state space S, the input space I and the output space O can be generic discrete spaces and so S, I and O can assume symbolic values <ref> [21, 70] </ref>. A special case is when S, I and O are the Cartesian product of copies of the space B = f0; 1g, i.e., they are binary variables.
Reference: [22] <author> S. Devadas and R. </author> <title> Newton. Exact algorithms for output encoding, state assignment and four-level Boolean minimization. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> vol. 10(no. </volume> 1):13-27, January 1991. 
Reference-contexts: An implicit binate table solver would also be required to solve implicitly other problems in sequential synthesis that we care about. One is the selection of a set of encodeable generalized prime implicants (GPI's), as defined in <ref> [22, 50] </ref>. It is not feasible to generate GPI's and to set up a related binate covering table by explicit techniques on non-trivial examples. Using techniques as in [48], GPI's can be generated implicitly. An implicit binate table solver is therefore needed there too.
Reference: [23] <author> S. Edwards and A. Oliveira. </author> <title> Synthesis of minimal state machines from examples of behavior. EE290LS Class Project Report, </title> <institution> U.C. Berkeley, </institution> <month> May </month> <year> 1993. </year>
Reference-contexts: We ran ISM on different suites of FSM's. We report results on the following suites of FSM's. They are: 1. the MCNC benchmark and other examples, 4.7. EXPERIMENTAL RESULTS 89 2. FSM's generated by a synthesis procedure for asynchronous logic [46], 3. FSM's from learning I/O sequences <ref> [23] </ref>, 4. FSM's from synthesis of interacting FSM's [82], 5. FSM's with exponentially many prime compatibles, 6. FSM's with many maximal compatibles, and 7. randomly generated FSM's. Each suite has different features with respect to state minimization. We discuss features of the experiments and results in different subsections. <p> COMPATIBLE GENERATION 4.7.3 FSM's from Learning I/O Sequences Table 4.3 and Figure 4.4 show the results of running a parametrized set of FSM's constructed to be compatible with a given collection of examples of input/output traces <ref> [23] </ref>. These machines exhibit very large number of compatibles. Here ISM shows all its power compared to STAMINA, both in terms of number of computed prime compatibles and running time. <p> We have shown, when discussing the experiments, that ISFSM's with a very large number of compatibles may be produced as intermediate steps of logic synthesis algorithms, for instance in the cases of asynchronous synthesis [46], of learning I/O sequences <ref> [23] </ref>, and of synthesis of interacting FSM's [65]. This shows that the proposed approach has not only a theoretical interest, but also practical relevance for current logic synthesis applications. A fully implicit exact algorithm for solving the binate covering problem [68] was presented in Chapter 5.
Reference: [24] <author> S. J. Friedman and K. J. Supowit. </author> <title> Finding the optimal variable ordering for binary decision diagrams. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> vol. 39(no. </volume> 5):710-713, May 1990. 
Reference-contexts: Luckily in real life, most discrete functions have reasonable representations provided that a good variable ordering is chosen. Friedman et al. in <ref> [24] </ref> found an O (n 2 3 n ) algorithm for finding the optimal variable ordering where n is the number of Boolean variables. Faster variable ordering heuristics for BDD's have been provided by Malik et al. in [52] and Fujita et al. in [25].
Reference: [25] <author> M. Fujita, H. Fujisawa, and N. Kawato. </author> <title> Evaluation and improvements of Boolean comparison method based on binary decision diagrams. </title> <booktitle> In Digest of Technical Papers of the IEEE International Conference on Computer-Aided Design, </booktitle> <pages> pages 2-5, </pages> <month> November </month> <year> 1988. </year>
Reference-contexts: Friedman et al. in [24] found an O (n 2 3 n ) algorithm for finding the optimal variable ordering where n is the number of Boolean variables. Faster variable ordering heuristics for BDD's have been provided by Malik et al. in [52] and Fujita et al. in <ref> [25] </ref>. Rudell [69] recently proposed an effective dynamic variable reordering heuristic which offers a tradeoff of runtime for compactness of BDD representation. The goal in this section is to find a good variable ordering so as to minimize the total number of vertices used. <p> With a mapped-BDD representation of an MDD, the ordering process consists of two steps: order the BDD variables within each MDD variable, and then merge these orderings into a single BDD variable ordering. Two well-known rule-of-thumbs suggested in [52] and <ref> [25] </ref> can be used for the ordering of BDD variables within each individual MDD variable: 1. Variables that are closely related should be ordered close to each other. 2. Variables that dominate control of the function should be ordered at the top.
Reference: [26] <author> M. R. Garey and D. S. Johnson. </author> <title> Computers and Intractability: A Guide to the Theory of NP-completeness. </title> <editor> W. H. </editor> <publisher> Freeman and Company, </publisher> <year> 1979. </year>
Reference-contexts: If A is given in product-of-sums form, finding a satisfying assignment is exactly the problem SAT, the prototypical N P -complete problem <ref> [26] </ref>. In this case it also possible to write A 102 CHAPTER 5. BINATE COVERING as an array of cubes (that form a matrix with coefficients from the set f0; 1; 2g).
Reference: [27] <author> J. Gimpel. </author> <title> A reduction technique for prime implicant tables. </title> <journal> IRE Transactions on Electronic Computers, </journal> <volume> vol. 14 </volume> <pages> 535-541, </pages> <month> August </month> <year> 1965. </year>
Reference-contexts: This definition of infeasibility is * not mentioned in [28] and [29], * briefly mentioned in [10], * identical to the unfeasible problem in [9]. 5.5.12 Gimpel's Reduction Step Another heuristic for solving the minimum cover problem has been suggested by Gim-pel <ref> [27] </ref>. Gimpel proposed a reduction step which simplifies the covering matrix when it has a special form. This simplification is possible without further branching, and hence is useful at each step of the branch and bound algorithm. <p> Robinson and House [34] showed that the reduction remains valid even for weighted covering problems if the cost of the column c 1 equals the cost of the column c 2 , as it has been presented here. Gimpel's rule has been first proposed in <ref> [27] </ref> and then implemented in [67]. In [64, 76] Gimpel's rule has been extended to handle the binate case.
Reference: [28] <author> A. Grasselli and F. Luccio. </author> <title> A method for minimizing the number of internal states in incompletely specified sequential networks. </title> <journal> IRE Transactions on Electronic Computers, </journal> <volume> vol. 14(no. </volume> 3):350-359, June 1965. 
Reference-contexts: This dissertation addresses state minimization problems of various classes of finite state machines (FSM's). An exact algorithm <ref> [60, 28] </ref> usually consists of the generation of compatibles and the solution of a binate covering problem [68]. The state-of-the-art explicit minimizer [65] fails on FSM's requiring an exponential number of compatibles, or huge binate tables. We indicate also where such examples arise in practice. <p> Our discussion will be based on the state minimization of PNDFSM's because we believe it is the largest subclass of NDFSM's that our state minimization procedure can handle correctly. Miller has given a proof in [56] for the classical exact algorithm for ISFSM minimization <ref> [28] </ref>. We contribute a concise proof for our exact state minimization algorithm for PNDFSM's, by presenting a number of theorems in the following sections. In this section, we first show that a DFSM realizes a behavior while an NDFSM realizes a set of behaviors. <p> In this section we will revise briefly the basic definitions and procedures for exact state minimization of ISFSM's, as presented in the original papers and standard textbooks <ref> [60, 28, 40] </ref>. First we restate the definition of incompletely specified FSM's. Some definitions will be restated in Section 4.3 where they will be explained in more detail. Definition 4.1 An incompletely specified FSM (ISFSM) can be defined as a 6-tuple M = hS; I; O; D; L; Ri. <p> Definition 4.10 A compatible set of states is a prime compatible if it is not dominated by any other compatible. The following procedure (which will be used in Section 4.5.3) generates all prime compatibles from the set of maximal compatibles <ref> [28] </ref>. 1. Initially the set of prime compatibles is empty. 2. Order the maximal compatibles by decreasing size, say n is the size of the largest. 3. Add to the set of prime compatibles the maximal compatibles of size n. 4. <p> Definition 4.11 A prime compatible is an essential prime compatible if it contains a state not contained in any other prime compatibles. The following theorem is proved in <ref> [28] </ref>, and its generalization to PNDFSM has been given in Theorem 2.24. Theorem 4.6 For any ISFSM M , there is a reduced ISFSM M red whose states all correspond to prime compatibles of M . <p> Theorem 4.6 For any ISFSM M , there is a reduced ISFSM M red whose states all correspond to prime compatibles of M . A minimum closed cover can then be found by setting up a table covering problem <ref> [28] </ref> whose columns are the prime compatibles and rows corresponds to the covering and closure conditions. <p> As proved in <ref> [28] </ref>, at least one minimum closed cover consists entirely of prime compatibles. Definition 4.18 . <p> After computing the dominance relation Dominate (c 0 ; c), the prime compatibles can be generated using Lemma 4.15. 4.5.3 Prime Compatible Generation using Maximals The prime compatible generation algorithm given in Section 4.3 does not rely on the computation of maximal compatibles, whereas the classical method in <ref> [28] </ref> does. We are going to present alternative implicit generation algorithm that does make use of maximal compatibles. The motivation is to expedite the prime generation step, as it is usually the most time consuming step. <p> A binate covering problem can be set up as described in Section 5.7, where each column of the table is a prime compatible and each row is one of the covering or closure clauses of the problem <ref> [28] </ref>. There are as many covering clauses as states of the original machine and each of them requires that a state is covered by selecting any of the prime compatibles in which it is contained. <p> This technique has been described in <ref> [29, 28, 9, 10] </ref>, and implemented in successful computer programs [67, 64, 76]. The branch-and-bound solution of minimum binate covering is based on a recursive procedure. A run of the algorithm can be described by its computation tree. <p> Even though more complex criteria of dominance have been investigated (for instance, Section 5.5.12), the previous ones are basic in any table covering solver. Reduction rules have previously been stated for the binate covering case <ref> [28, 29, 10, 9] </ref>, and also for the unate covering case [54, 68, 9]. The former set of reductions are needed for state minimization. Here we will present the known reduction rules directly for binate covering and indicate how they simplify for unate covering, when applicable. <p> For each of them, we will first define the reduction rule, and then a theorem showing how that rule is applied. Proofs for the correctness of these reduction rules have been given in <ref> [28, 29, 10, 9] </ref>, and they will not be repeated here, except for a few less common ones. We will provide a survey comparing different related reduction rules used in the literature. The effect of reductions depends on the order of their application. <p> REDUCTION TECHNIQUES 117 * similar to column dominance (Rule 3) in <ref> [28] </ref>, except that the labels of dominator row, R i , and dominated row, R j , are reversed (i.e., reverse definition of dominance), * similar to column dominance (Rule 3) in [29], except that the labels of dominator row, R i , and dominated row, R j , are reversed <p> This definition of column ff-dominance is * an extension to row ff-dominance (Rule 1) in <ref> [28] </ref>, because the latter doesn't include the case M i;j = 0 and M i;k = 0, * equivalent to first half of Rule 4 in [29]: (a) C j has all the 1's of C k and (b1) C k has all the 0's of C j , * identical <p> This definition of column fi-dominance is * strictly stronger than column ff-dominance given in 5.5.3, * more general than row fi-dominance (Rule 5) in <ref> [28] </ref>, because the latter assumes that the covering table contains only rows with no or one 0, * equivalent to second half of Rule 4 in [29]: (a) C i has all the 1's of C j and (b2) for every row R p in which C i has a 0, <p> Column C j must then be deleted together with all the rows in which it has 1's. This definition of essential column is * identical to essential row (Rule 2) in <ref> [28] </ref>, * identical to Rule 1 in [29], * included in Definition 9 in [10]: the row R i in the above definition corresponds to a singleton-1 essential row in [10], * included in Definition 2.10 in [9]: the row R i in the above definition corresponds to a singleton-1 essential <p> Theorem 5.10 If C j is an unacceptable column, it must be eliminated (x j = 0) in every solution, together with all the rows in which it has 0's. This definition of unacceptable column is * identical to that of nonselectionable row in <ref> [28] </ref>, * identical to Rule 2 in [29], 122 CHAPTER 5. <p> Theorem 5.11 If C j is an unnecessary column, it may be eliminated (x j = 0), together with all the rows in which it has 0's. This definition of unnecessary column is * identical to Rule 4 in <ref> [28] </ref>, * identical to Rule 5 in [29], * not mentioned in [10] and [9]. 5.5.10 Trial Rule Theorem 5.12 If there exists in a covering table M a row R i having a 0 in column C j , a 1 in column C k and 2's in the rest, <p> Therefore, C k can be deleted together with all the columns in which it has 1's. 2 It is possible that a row is left with only 2's by a sequence of reduction steps. 5.5. REDUCTION TECHNIQUES 123 This reduction rule is * identical to Rule 6 in <ref> [28] </ref>, * not mentioned in other papers. 5.5.11 Infeasible Subproblem Unlike the unate covering problem, the binate covering problem may be infeasible. In particular, an intermediate covering matrix M may found to be unsatisfiable by the following theorem. <p> Theorem 5.13 A covering problem M is infeasible if there exists a column C j which is both essential and unacceptable (implying x j = 1 and x j = 0). This definition of infeasibility is * not mentioned in <ref> [28] </ref> and [29], * briefly mentioned in [10], * identical to the unfeasible problem in [9]. 5.5.12 Gimpel's Reduction Step Another heuristic for solving the minimum cover problem has been suggested by Gim-pel [27]. Gimpel proposed a reduction step which simplifies the covering matrix when it has a special form. <p> Gimpel's rule has been first proposed in [27] and then implemented in [67]. In [64, 76] Gimpel's rule has been extended to handle the binate case. This extension has been described in [77]. 5.6 Implicit Binate Covering The classical branch-and-bound algorithm <ref> [28, 29] </ref> for minimum-cost binate covering has been described in previous sections, and implemented by means of efficient computer programs (ESPRESSO and STAMINA). These state-of-the-art binate table solvers represent binate tables efficiently using sparse matrix packages.
Reference: [29] <author> A. Grasselli and F. Luccio. </author> <title> Some covering problems in switching theory. </title> <booktitle> In Networks and Switching Theory, </booktitle> <pages> pages 536-557. </pages> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1968. </year>
Reference-contexts: This technique has been described in <ref> [29, 28, 9, 10] </ref>, and implemented in successful computer programs [67, 64, 76]. The branch-and-bound solution of minimum binate covering is based on a recursive procedure. A run of the algorithm can be described by its computation tree. <p> Even though more complex criteria of dominance have been investigated (for instance, Section 5.5.12), the previous ones are basic in any table covering solver. Reduction rules have previously been stated for the binate covering case <ref> [28, 29, 10, 9] </ref>, and also for the unate covering case [54, 68, 9]. The former set of reductions are needed for state minimization. Here we will present the known reduction rules directly for binate covering and indicate how they simplify for unate covering, when applicable. <p> For each of them, we will first define the reduction rule, and then a theorem showing how that rule is applied. Proofs for the correctness of these reduction rules have been given in <ref> [28, 29, 10, 9] </ref>, and they will not be repeated here, except for a few less common ones. We will provide a survey comparing different related reduction rules used in the literature. The effect of reductions depends on the order of their application. <p> REDUCTION TECHNIQUES 117 * similar to column dominance (Rule 3) in [28], except that the labels of dominator row, R i , and dominated row, R j , are reversed (i.e., reverse definition of dominance), * similar to column dominance (Rule 3) in <ref> [29] </ref>, except that the labels of dominator row, R i , and dominated row, R j , are reversed (i.e., reverse definition of dominance), * equivalent to row dominance (Definition 10) in [10], * identical to row dominance (Definition 2.11) in [9]. <p> This definition of column ff-dominance is * an extension to row ff-dominance (Rule 1) in [28], because the latter doesn't include the case M i;j = 0 and M i;k = 0, * equivalent to first half of Rule 4 in <ref> [29] </ref>: (a) C j has all the 1's of C k and (b1) C k has all the 0's of C j , * identical to column dominance (Definition 11, Theorem 3) in [10], * identical to column dominance (Definition 2.12, Theorem 2.4.1) in [9]. 5.5. <p> This definition of column fi-dominance is * strictly stronger than column ff-dominance given in 5.5.3, * more general than row fi-dominance (Rule 5) in [28], because the latter assumes that the covering table contains only rows with no or one 0, * equivalent to second half of Rule 4 in <ref> [29] </ref>: (a) C i has all the 1's of C j and (b2) for every row R p in which C i has a 0, there exists a row R q in which C j has a 0, such that disregarding entries in row C i and C j , R <p> Column C j must then be deleted together with all the rows in which it has 1's. This definition of essential column is * identical to essential row (Rule 2) in [28], * identical to Rule 1 in <ref> [29] </ref>, * included in Definition 9 in [10]: the row R i in the above definition corresponds to a singleton-1 essential row in [10], * included in Definition 2.10 in [9]: the row R i in the above definition corresponds to a singleton-1 essential row in [9]. <p> This definition of unacceptable column is * identical to that of nonselectionable row in [28], * identical to Rule 2 in <ref> [29] </ref>, 122 CHAPTER 5. <p> Theorem 5.11 If C j is an unnecessary column, it may be eliminated (x j = 0), together with all the rows in which it has 0's. This definition of unnecessary column is * identical to Rule 4 in [28], * identical to Rule 5 in <ref> [29] </ref>, * not mentioned in [10] and [9]. 5.5.10 Trial Rule Theorem 5.12 If there exists in a covering table M a row R i having a 0 in column C j , a 1 in column C k and 2's in the rest, then apply the following test: * eliminate <p> Theorem 5.13 A covering problem M is infeasible if there exists a column C j which is both essential and unacceptable (implying x j = 1 and x j = 0). This definition of infeasibility is * not mentioned in [28] and <ref> [29] </ref>, * briefly mentioned in [10], * identical to the unfeasible problem in [9]. 5.5.12 Gimpel's Reduction Step Another heuristic for solving the minimum cover problem has been suggested by Gim-pel [27]. Gimpel proposed a reduction step which simplifies the covering matrix when it has a special form. <p> Gimpel's rule has been first proposed in [27] and then implemented in [67]. In [64, 76] Gimpel's rule has been extended to handle the binate case. This extension has been described in [77]. 5.6 Implicit Binate Covering The classical branch-and-bound algorithm <ref> [28, 29] </ref> for minimum-cost binate covering has been described in previous sections, and implemented by means of efficient computer programs (ESPRESSO and STAMINA). These state-of-the-art binate table solvers represent binate tables efficiently using sparse matrix packages.
Reference: [30] <author> J. Hartmanis and R. E. Stearns. </author> <title> Some dangers in the state reduction of sequential machines. </title> <journal> Information and Control, </journal> <volume> vol. 5 </volume> <pages> 252-260, </pages> <month> September </month> <year> 1962. </year>
Reference-contexts: There is no theoretical guarantee that a state minimized FSM is always a better starting point for state assignment than an FSM that has not been state minimized <ref> [30] </ref>, yet in practice this leads to excellent solutions, because it couples a step of behavioral optimization on the state transition graph (STG) with an encoding step on a reduced STG, so that the complexity of the latter's task is reduced. 1.3 Implicit Techniques Efficient representation and exploration of design space
Reference: [31] <author> J. E. Hopcroft. </author> <title> n log n algorithm for minimizing states in finite automata. </title> <type> Tech. </type> <institution> Report Stanford Univ. </institution> <note> CS 71/190, 1971. 206 BIBLIOGRAPHY </note>
Reference-contexts: IMPLICIT TECHNIQUES 65 Part II State Minimization of Incompletely Specified FSM's 67 Chapter 4 Compatible Generation 4.1 Introduction State minimization of FSM's is a well-known problem [40]. State minimization of completely specified FSM's (CSFSM's) has a complexity subquadratic in the number of states <ref> [31] </ref>. This makes it an easy problem when the starting point is a two-level description of an FSM, because the number of states is usually less than a few hundred.
Reference: [32] <author> J. E. Hopcroft and J. D. Ullman. </author> <title> Introduction to Automata Theory, Languages, and Computation. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1979. </year>
Reference-contexts: An FSM is a discrete dynamic system that translates sequences of input vectors into sequences of output vectors. FSM's are a formalism growing from the theory of finite automata in computer science <ref> [32] </ref>. An FSM has a set of states and a set of transitions between states; the transitions are triggered by input vectors and produce output vectors. <p> In other words, the common output associated to a given state, goes on all transitions that leave that state. This is a reasonable assumption when modeling an hardware system. However, it is common to find in textbooks <ref> [40, 32] </ref> a dual definition where the output is associated with the next state. In other words, the common output associated to a given state, is on all edges that go into that state, while edges leaving a given state may carry different outputs. <p> The language accepted by A, designated L (A), is the set of stringsfxjD (x; r) " F 6= ;g. Theorem 2.4 Let L be the language accepted by a non-deterministic finite automaton. Then there exists a deterministic finite automaton that accepts L. Proof: By subset construction <ref> [32] </ref>. Corollary 2.5 DFA's and NDFA's (and NDFA's with *-transitions and regular expressions) accept the same set of languages. Proof: The class of languages accepted by NDFA's includes the set of languages accepted by DFA's (regular sets). <p> Theorem 2.9 (NDFSM ! PNDFSM) Given an NDFSM M = hS; I ; O; T; Ri, an NDFA A = hS; I fi O; D; R; Si can be constructed according to the above Theorem 2.7. The NDFA can then be 20 CHAPTER 2. TAXONOMY determinized via subset construction <ref> [32] </ref> to obtain a DFA A det = h2 S ; I fi O; D det ; R det ; 2 S i. <p> STATE MINIMIZATION OF NON-DETERMINISTIC FSM'S 6.2 Algorithms for State Minimization of NDFSM's 6.2.1 Determinized Transition Relation and Implicit Subset Construction Explicit algorithm for subset construction is well-known <ref> [32] </ref>. Here we outline how subset construction can be performed implicitly.
Reference: [33] <author> R. W. House and D. W. Stevens. </author> <title> A new rule for reducing CC tables. </title> <journal> IEEE Transactions on Computers, </journal> <volume> vol. 19 </volume> <pages> 1108-1111, </pages> <month> November </month> <year> 1970. </year>
Reference-contexts: In that case the last application of row consensus is potentially faulty and should not be done. Row consensus is applied in [64]. This criterion generalizes the one given in <ref> [33] </ref>. 118 CHAPTER 5.
Reference: [34] <author> S. Robinson III and R. House. </author> <title> Gimpel's reduction technique extended to the covering problem with costs. </title> <journal> IRE Transactions on Electronic Computers, </journal> <volume> vol. 16 </volume> <pages> 509-514, </pages> <month> August </month> <year> 1967. </year>
Reference-contexts: The resulting cover is a minimum cover for p. A proof can be found in [68], where a more extended discussion is presented. Gimpel's reduction step was originally stated for covering problems where each column had cost 1. Robinson and House <ref> [34] </ref> showed that the reduction remains valid even for weighted covering problems if the cost of the column c 1 equals the cost of the column c 2 , as it has been presented here. Gimpel's rule has been first proposed in [27] and then implemented in [67].
Reference: [35] <author> S.-W. Jeong and F. Somenzi. </author> <title> A new algorithm for 0-1 programming based on binary decision diagrams. </title> <booktitle> In Proceedings of ISKIT-92, Inter. symp. on logic synthesis and microproc. arch., Iizuka, Japan, </booktitle> <pages> pages 177-184, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: In that case the number of variables of the BDD is the number of columns of the binate table. 5.1. INTRODUCTION 103 Recently, a mixed technique has been proposed in <ref> [35] </ref>. It is a branch-and-bound algorithm, where the clauses are represented as a conjunction of BDD's. The usage of BDD's leads to an effective method to compute a lower bound on the cost of the solution. Notice that unate covering is a special case of binate covering. <p> It is an interesting question to characterize the class of problems that can be better formulated and solved with one technique or the other. As an example of reduction from ILP to BCP, a procedure (taken from <ref> [35] </ref>) that derives the Boolean expression corresponding to P n j=1 w j :x j T is shown in Figure 5.1. The idea of the recursion relies on the observation that: 106 CHAPTER 5.
Reference: [36] <author> T. Kam and R. K. Brayton. </author> <title> Multi-valued decision diagrams. </title> <type> Tech. Report No. </type> <institution> UCB/ERL M90/125, </institution> <month> December </month> <year> 1990. </year>
Reference-contexts: This allows us to construct a function by recursive decomposition. 3.2. MULTI-VALUED DECISION DIAGRAMS 35 3.2 Multi-valued Decision Diagrams This section describes a new data structure the multi-valued decision diagram <ref> [78, 36] </ref> that is used to solve discrete variable problems [36, 45, 84, 44, 3]. Our definition of multi-valued decision diagrams closely follows that of Bryant, [11], with two exceptions: we do not restrict ourselves to the Boolean domain, and the range of our functions is multi-valued. <p> This allows us to construct a function by recursive decomposition. 3.2. MULTI-VALUED DECISION DIAGRAMS 35 3.2 Multi-valued Decision Diagrams This section describes a new data structure the multi-valued decision diagram [78, 36] that is used to solve discrete variable problems <ref> [36, 45, 84, 44, 3] </ref>. Our definition of multi-valued decision diagrams closely follows that of Bryant, [11], with two exceptions: we do not restrict ourselves to the Boolean domain, and the range of our functions is multi-valued. <p> Because an ISFSM is also a PNDFSM, our corresponding minimization algorithm in Chapters 4 and 5 is therefore proved as well. The multi-valued decision diagram (MDD) was introduced in Chapter 3. MDD is an extension of BDD for representing multi-valued functions, and has many useful applications (see <ref> [36] </ref>). To explore sequential behaviors in a non-deterministic specification, 1-hot encoded MDD's were used as a compact representation of sets of sets (e.g., to represent subsets of compatibles). A suite of implicit techniques was developed for manipulating these set-theoretic objects.
Reference: [37] <author> T. Kam, T. Villa, R. Brayton, and A. Sangiovanni-Vincentelli. </author> <title> Implicit generation of compatibles for exact state minimization. </title> <type> Tech. Report No. </type> <institution> UCB/ERL M93/60, </institution> <month> August </month> <year> 1993. </year>
Reference-contexts: Therefore the computational methods described here contribute to build a body of implicit techniques whose scope goes much beyond a specific application. In this chapter, we address the problem of computing sets of compatibles for the exact state minimization of ISFSM's <ref> [37] </ref>.
Reference: [38] <author> T. Kam, T. Villa, R. Brayton, and A. Sangiovanni-Vincentelli. </author> <title> A fully implicit algorithm for exact state minimization. </title> <booktitle> In Proceedings of the Design Automation Conference, </booktitle> <pages> pages 684-690, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: STATE MINIMIZATION OF PNDFSM'S 157 problem of finding a minimum closed cover. As a result, the algorithm for state minimization of PNDFSM's consists of two steps: compatible generation and binate covering. It is more complicated than the one for ISFSM minimization <ref> [38] </ref> because the definition of compatibles and the conditions for a closed cover are more complex. Example The PNDFSM M p shown in Figure 6.3 will be used in this section to illustrate various concepts.
Reference: [39] <author> T. Kam, T. Villa, R. Brayton, and A. Sangiovanni-Vincentelli. </author> <title> Implicit state minimization of non-deterministic FSM's. </title> <booktitle> In Proceedings of the International Conference on Computer Design, </booktitle> <month> October </month> <year> 1995. </year>
Reference-contexts: In Section 6.3, we will describe an implicit algorithm for state minimization of PNDFSM's, a subclass of NDFSM's. This research will appear in <ref> [39] </ref>.
Reference: [40] <author> Z. Kohavi. </author> <title> Switching and Finite Automata Theory. </title> <publisher> McGraw-Hill Book Company, </publisher> <address> New York, New York, </address> <note> second edition, </note> <year> 1978. </year>
Reference-contexts: In other words, the common output associated to a given state, goes on all transitions that leave that state. This is a reasonable assumption when modeling an hardware system. However, it is common to find in textbooks <ref> [40, 32] </ref> a dual definition where the output is associated with the next state. In other words, the common output associated to a given state, is on all edges that go into that state, while edges leaving a given state may carry different outputs. <p> IMPLICIT TECHNIQUES 65 Part II State Minimization of Incompletely Specified FSM's 67 Chapter 4 Compatible Generation 4.1 Introduction State minimization of FSM's is a well-known problem <ref> [40] </ref>. State minimization of completely specified FSM's (CSFSM's) has a complexity subquadratic in the number of states [31]. This makes it an easy problem when the starting point is a two-level description of an FSM, because the number of states is usually less than a few hundred. <p> Results on a variety of benchmarks are reported and discussed in Section 4.7. 4.2 Classical Definitions and Algorithm Most of the terminology used in this chapter is common parlance of the logic synthesis community <ref> [40, 7, 8] </ref>. In this section we will revise briefly the basic definitions and procedures for exact state minimization of ISFSM's, as presented in the original papers and standard textbooks [60, 28, 40]. First we restate the definition of incompletely specified FSM's. <p> In this section we will revise briefly the basic definitions and procedures for exact state minimization of ISFSM's, as presented in the original papers and standard textbooks <ref> [60, 28, 40] </ref>. First we restate the definition of incompletely specified FSM's. Some definitions will be restated in Section 4.3 where they will be explained in more detail. Definition 4.1 An incompletely specified FSM (ISFSM) can be defined as a 6-tuple M = hS; I; O; D; L; Ri.
Reference: [41] <author> E. Kuh and T. Ohtsuki. </author> <title> Recent advances in VLSI layout. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> vol. 78(no. </volume> 2):237-263, February 1990. 
Reference-contexts: Technology mapping is the optimization step to select the particular gates from a pre-designed library, to implement an optimized logic network. The optimization criteria are again: area, delay, power and testability. Layout Synthesis The final step in the synthesis flow is physical layout synthesis <ref> [41] </ref>. From a gate level description, it generates mask geometries of transistors and wires to be fabricated on silicon. Different layout tools are used for different design methodologies, such as full-custom, standard cell and gate array (including FPGA and sea-of-gates).
Reference: [42] <author> L. Lavagno. </author> <title> Heuristic and exact methods for binate covering. </title> <type> EE290ls Report, </type> <month> May </month> <year> 1989. </year>
Reference-contexts: Various techniques have been proposed to solve binate covering problems. A class of them <ref> [10, 42] </ref> are branch-and-bound techniques that build explicitly the table of the constraints expressed as product-of-sum expressions and explore in the worst-case all possible solutions, but avoid the generation of some of the suboptimal solutions by a clever use of reduction steps and bounding of search space for solutions.
Reference: [43] <author> L. Lavagno. </author> <type> Personal communication. </type> <institution> UC Berkeley, </institution> <month> December </month> <year> 1991. </year>
Reference-contexts: State minimization of incompletely specified FSM's (ISFSM's) instead has been shown to be an NP-hard problem [61]. Therefore even for problems represented with two-level descriptions involving a hundred states, an exact algorithm may consume too much memory and time. Moreover, it has been recently reported <ref> [43] </ref> that even examples with very few states generated during the synthesis of asynchronous circuits may fail to complete (or require days of CPU time) when run with a state-of-art exact state minimizer as STAMINA [63]. Therefore it is of practical importance 68 CHAPTER 4.
Reference: [44] <author> L. Lavagno. </author> <title> Synthesis and Testing of Bounded Wire Delay Asynchronous Circuits from State Transition Graphs. </title> <type> PhD thesis, </type> <institution> University of California, Berkeley, </institution> <month> December </month> <year> 1992. </year> <note> BIBLIOGRAPHY 207 </note>
Reference-contexts: This allows us to construct a function by recursive decomposition. 3.2. MULTI-VALUED DECISION DIAGRAMS 35 3.2 Multi-valued Decision Diagrams This section describes a new data structure the multi-valued decision diagram [78, 36] that is used to solve discrete variable problems <ref> [36, 45, 84, 44, 3] </ref>. Our definition of multi-valued decision diagrams closely follows that of Bryant, [11], with two exceptions: we do not restrict ourselves to the Boolean domain, and the range of our functions is multi-valued.
Reference: [45] <author> L. Lavagno, S. Malik, R. K. Brayton, and A. Sangiovanni-Vincentelli. MIS-MV: </author> <title> Optimization of multi-level logic with multiple-valued inputs. </title> <booktitle> In Digest of Technical Papers of the IEEE International Conference on Computer-Aided Design, </booktitle> <pages> pages 560-563, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: This allows us to construct a function by recursive decomposition. 3.2. MULTI-VALUED DECISION DIAGRAMS 35 3.2 Multi-valued Decision Diagrams This section describes a new data structure the multi-valued decision diagram [78, 36] that is used to solve discrete variable problems <ref> [36, 45, 84, 44, 3] </ref>. Our definition of multi-valued decision diagrams closely follows that of Bryant, [11], with two exceptions: we do not restrict ourselves to the Boolean domain, and the range of our functions is multi-valued.
Reference: [46] <author> L. Lavagno, C. W. Moon, R. K. Brayton, and A. Sangiovanni-Vincentelli. </author> <title> Solving the state assignment problem for signal transition graphs. </title> <booktitle> In Proceedings of the Design Automation Conference, </booktitle> <pages> pages 568-572, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: We ran ISM on different suites of FSM's. We report results on the following suites of FSM's. They are: 1. the MCNC benchmark and other examples, 4.7. EXPERIMENTAL RESULTS 89 2. FSM's generated by a synthesis procedure for asynchronous logic <ref> [46] </ref>, 3. FSM's from learning I/O sequences [23], 4. FSM's from synthesis of interacting FSM's [82], 5. FSM's with exponentially many prime compatibles, 6. FSM's with many maximal compatibles, and 7. randomly generated FSM's. Each suite has different features with respect to state minimization. <p> 48 3 1 train11 11 5 85 17 15 0 0 viterbi 68 5 329 57 3 6 0 Table 4.1: The MCNC benchmark and others. 4.7.2 FSM's from Asynchronous Synthesis Table 4.2 reports the results of a benchmark of FSM's generated as intermediate steps of an asynchronous synthesis procedure <ref> [46] </ref>. STAMINA ran out of memory on the examples vmebus.master.m, isend, pe-rcv-ifc.fc, pe-send-ifc.fc, while ISM was able to complete them. These examples (with the exception of vbe4a) have a number of primes below a thousand. To explain 4.7. <p> For asynchronous synthesis, a more appropriate formulation of exact state minimization requires the computation of all compatibles or at least of prime compatibles and a different set-up of the covering problem <ref> [46] </ref>. # max # prime CPU time (sec) machine # states compat. # compat. compat. #N EPC ISM STAMINA alex1 42 787 55928 787 787 24 16 future 36 49 7.929e8 49 49 3 0 future.m 28 16 2.621e7 16 16 2 0 intel edge.dummy 28 120 9432 396 396 37 <p> We have shown, when discussing the experiments, that ISFSM's with a very large number of compatibles may be produced as intermediate steps of logic synthesis algorithms, for instance in the cases of asynchronous synthesis <ref> [46] </ref>, of learning I/O sequences [23], and of synthesis of interacting FSM's [65]. This shows that the proposed approach has not only a theoretical interest, but also practical relevance for current logic synthesis applications.
Reference: [47] <author> B. Lin. </author> <title> Synthesis of VLSI designs with symbolic techniques. </title> <type> PhD thesis, </type> <institution> University of California, Berkeley, </institution> <month> November </month> <year> 1991. </year>
Reference-contexts: But when latches are more than a dozen, the number of reachable states may be so huge to make state extraction and/or state minimization unfeasible. Recently it has been shown <ref> [49, 47] </ref> how to bypass the extraction step and compute equivalence classes of states implicitly. Equivalence classes are basically all that is needed to minimize a completely specified state machine.
Reference: [48] <author> B. Lin, O. Coudert, and J. C. Madre. </author> <title> Symbolic prime generation for multiple-valued functions. </title> <booktitle> In Proceedings of the Design Automation Conference, </booktitle> <pages> pages 40-44, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Of course, it may be the case that the BDD cannot be constructed, because of the intrinsic structure of the function to represent or because a good ordering of the variables is not found. More recent work at Bull <ref> [19, 48] </ref> has shown how implicants, primes and essential primes of a two-valued or multi-valued function can also be computed implicitly. Reported experiments show a suite of examples where all primes could be computed, whereas explicit techniques implemented in ESPRESSO [7] failed to do so. <p> IMPLICIT TECHNIQUES 3.7.2 Operations on Positional-sets With our previous definitions of relations and positional-set notation for representing set of objects, useful relational operators on sets can be derived. We propose a unified notational framework for set manipulation which extends the notation used in <ref> [48] </ref>. <p> The previous insight has already been tested in a series of applications. Research at Bull [16] and U.C. Berkeley [80] produced powerful techniques for implicit enumeration of subsets of states of a Finite State Machine (FSM). Later work at Bull <ref> [19, 48] </ref> has shown how implicants, primes and essential primes of a two-valued or multi-valued function can also be computed implicitly. Reported experiments show a suite of examples where all primes could be computed, whereas explicit techniques implemented in ESPRESSO [7] failed to do so. <p> One is the selection of a set of encodeable generalized prime implicants (GPI's), as defined in [22, 50]. It is not feasible to generate GPI's and to set up a related binate covering table by explicit techniques on non-trivial examples. Using techniques as in <ref> [48] </ref>, GPI's can be generated implicitly. An implicit binate table solver is therefore needed there too. Notice that potential applications include unate covering problems, such as selecting the minimum number of encoding-dichotomies that satisfy a set of encoding constraints [71].
Reference: [49] <author> B. Lin and A. R. </author> <title> Newton. Implicit manipulation of equivalence classes using binary decision diagrams. </title> <booktitle> In Proceedings of the International Conference on Computer Design, </booktitle> <pages> pages 81-85, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: But when latches are more than a dozen, the number of reachable states may be so huge to make state extraction and/or state minimization unfeasible. Recently it has been shown <ref> [49, 47] </ref> how to bypass the extraction step and compute equivalence classes of states implicitly. Equivalence classes are basically all that is needed to minimize a completely specified state machine. <p> From now on, sometimes we will blur the distinction between a column (row) label and the column (row) itself, but the context should say clearly which one it is meant. 3 Alternatively, one could have used the cproject BDD operator introduced in <ref> [49] </ref> to pick a representative column out of each set of duplicated columns. 5.8. IMPLICIT REDUCTION TECHNIQUES 133 5.8.3 Column Dominance Some columns need not be considered in a binate table, if they are dominated by others. Classically, there are two notions of column dominance: ff-dominance and fi-dominance.
Reference: [50] <author> B. Lin and F. Somenzi. </author> <title> Minimization of symbolic relations. </title> <booktitle> In Digest of Technical Papers of the IEEE International Conference on Computer-Aided Design, </booktitle> <pages> pages 88-91, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: We will refer to these methods as explicit. A second approach <ref> [50] </ref> formulates the problem with Binary Decision Diagrams (BDD's) and reduces finding a minimum cost assignment to a shortest path computation. In that case the number of variables of the BDD is the number of columns of the binate table. 5.1. <p> An implicit binate table solver would also be required to solve implicitly other problems in sequential synthesis that we care about. One is the selection of a set of encodeable generalized prime implicants (GPI's), as defined in <ref> [22, 50] </ref>. It is not feasible to generate GPI's and to set up a related binate covering table by explicit techniques on non-trivial examples. Using techniques as in [48], GPI's can be generated implicitly. An implicit binate table solver is therefore needed there too.
Reference: [51] <author> S. Malik. </author> <title> Analysis of cyclic combinational circuits. </title> <booktitle> In Digest of Technical Papers of the IEEE International Conference on Computer-Aided Design, </booktitle> <pages> pages 618-625, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: Analysis of combinational cycles in circuits has been reported in <ref> [51, 12, 75] </ref>. Example Consider p ((s 1 ; s 2 ); x) = z.
Reference: [52] <author> S. Malik, A. Wang, R. Brayton, and A. Sangiovanni-Vincentelli. </author> <title> Logic verification using binary decision diagrams in a logic synthesis environment. </title> <booktitle> In Digest of Technical Papers of the IEEE International Conference on Computer-Aided Design, </booktitle> <pages> pages 6-9, </pages> <month> November </month> <year> 1988. </year>
Reference-contexts: Friedman et al. in [24] found an O (n 2 3 n ) algorithm for finding the optimal variable ordering where n is the number of Boolean variables. Faster variable ordering heuristics for BDD's have been provided by Malik et al. in <ref> [52] </ref> and Fujita et al. in [25]. Rudell [69] recently proposed an effective dynamic variable reordering heuristic which offers a tradeoff of runtime for compactness of BDD representation. The goal in this section is to find a good variable ordering so as to minimize the total number of vertices used. <p> With a mapped-BDD representation of an MDD, the ordering process consists of two steps: order the BDD variables within each MDD variable, and then merge these orderings into a single BDD variable ordering. Two well-known rule-of-thumbs suggested in <ref> [52] </ref> and [25] can be used for the ordering of BDD variables within each individual MDD variable: 1. Variables that are closely related should be ordered close to each other. 2. Variables that dominate control of the function should be ordered at the top.
Reference: [53] <author> M. P. Marcus. </author> <title> Derivation of maximal compatibles using Boolean algebra. </title> <journal> IBM Journal of Research and Development, </journal> <pages> pages 537-538, </pages> <month> November </month> <year> 1964. </year>
Reference-contexts: A set of states is a maximal incompatible if it is not a maximal compatible. We give as example an elegant procedure to find all maximal compatibles that can be found in <ref> [53] </ref>. 1. Write down the pairs of incompatibles as a product of sums 2. Multiply them out to obtain a sum of products, and minimize it with respect to single-cube containment. 3. For each resultant product, write down missing states to get maximal compatibles.
Reference: [54] <author> E. McCluskey. </author> <title> Minimization of Boolean functions. </title> <journal> Bell System Technical Journal, </journal> <volume> vol. 35 </volume> <pages> 1417-1444, </pages> <month> November </month> <year> 1956. </year>
Reference-contexts: Even though more complex criteria of dominance have been investigated (for instance, Section 5.5.12), the previous ones are basic in any table covering solver. Reduction rules have previously been stated for the binate covering case [28, 29, 10, 9], and also for the unate covering case <ref> [54, 68, 9] </ref>. The former set of reductions are needed for state minimization. Here we will present the known reduction rules directly for binate covering and indicate how they simplify for unate covering, when applicable.
Reference: [55] <author> M. McFarland, A. Parker, and R. Camposano. </author> <title> The high level synthesis of digital systems. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> vol. 78(no. 2):301-318, February 1990. 208 </volume> BIBLIOGRAPHY 
Reference-contexts: Each individual step can also be seen as a mapping, from a more abstract design representation to a less abstract one. Usually higher levels of abstraction are used to describe behaviors while the lower levels are more structural in nature. High Level Synthesis High level synthesis <ref> [55] </ref> translates a behavioral specification originated from the user into a register transfer level (RTL) description of the design. High level synthesis usually involves two tasks: scheduling and allocation.
Reference: [56] <author> R. E. Miller. </author> <title> Switching theory. Volume II: sequential circuits and machines. </title> <editor> J. </editor> <publisher> Wiley & Sons, Inc., </publisher> <address> N.Y., </address> <year> 1965. </year>
Reference-contexts: Our discussion will be based on the state minimization of PNDFSM's because we believe it is the largest subclass of NDFSM's that our state minimization procedure can handle correctly. Miller has given a proof in <ref> [56] </ref> for the classical exact algorithm for ISFSM minimization [28]. We contribute a concise proof for our exact state minimization algorithm for PNDFSM's, by presenting a number of theorems in the following sections.
Reference: [57] <author> S. Minato. </author> <title> Zero-suppressed BDD's for set manipulation in combinatorial problems. </title> <booktitle> In Proceedings of the Design Automation Conference, </booktitle> <pages> pages 272-277, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: A characteristic of our representations is that the positional-sets (e.g., compatibles) are usually sparse sets. Minato in <ref> [57] </ref> showed that Zero-suppressed BDD is a good 6 Parameters: number of states, number of inputs, number of outputs, don't care output percentage, don't care target state percentage. 4.7.
Reference: [58] <author> E. Moore. </author> <title> Gedanken-experiments on sequential machines. </title> <editor> In C. Shannon and J. McCarthy, editors, </editor> <title> Automata Studies. </title> <publisher> Princeton University Press, </publisher> <year> 1956. </year>
Reference-contexts: R S represents the set of reset states. As a special case of Mealy machine, Moore machines have its output depends on its present state only (but not input). The definition of Moore machine presented here is the same as the one given by Moore in <ref> [58] </ref> and followed by authors in the field (e.g., [86]). The key fact to notice is that the output is associated with the present state. In other words, the common output associated to a given state, goes on all transitions that leave that state.
Reference: [59] <author> C. H. Papadimitriou and K. Steiglitz. </author> <title> Combinatorial Optimization: Algorithms and Complexity. </title> <publisher> Prentice Hall, </publisher> <year> 1982. </year>
Reference: [60] <author> M. Paull and S. Unger. </author> <title> Minimizing the number of states in incompletely specified state machines. </title> <journal> IRE Transactions on Electronic Computers, </journal> <volume> vol. 8 </volume> <pages> 356-367, </pages> <month> September </month> <year> 1959. </year>
Reference-contexts: This dissertation addresses state minimization problems of various classes of finite state machines (FSM's). An exact algorithm <ref> [60, 28] </ref> usually consists of the generation of compatibles and the solution of a binate covering problem [68]. The state-of-the-art explicit minimizer [65] fails on FSM's requiring an exponential number of compatibles, or huge binate tables. We indicate also where such examples arise in practice. <p> In this section we will revise briefly the basic definitions and procedures for exact state minimization of ISFSM's, as presented in the original papers and standard textbooks <ref> [60, 28, 40] </ref>. First we restate the definition of incompletely specified FSM's. Some definitions will be restated in Section 4.3 where they will be explained in more detail. Definition 4.1 An incompletely specified FSM (ISFSM) can be defined as a 6-tuple M = hS; I; O; D; L; Ri.
Reference: [61] <author> C. P. Pfleeger. </author> <title> State reduction in incompletely specified finite state machines. </title> <journal> IEEE Transactions on Computers, </journal> <pages> pages 1099-1102, </pages> <month> October </month> <year> 1973. </year>
Reference-contexts: This implicit technique allows state minimization of sequential networks outside the domain of traditional techniques. State minimization of incompletely specified FSM's (ISFSM's) instead has been shown to be an NP-hard problem <ref> [61] </ref>. Therefore even for problems represented with two-level descriptions involving a hundred states, an exact algorithm may consume too much memory and time.
Reference: [62] <author> P. Ramadge and W. Wonham. </author> <title> Supervisory control of a class of discrete event processes. </title> <journal> SIAM Journal of Control and Optimization, </journal> <volume> vol. 25(no. </volume> 1):206-230, January 1987. 
Reference-contexts: Different minimization problems will be described in Section 7.2. Implicit algorithms will be proposed for these problems in Sections 7.3, 7.4 and 7.5. Similar formulations of this problem have been called model matching of FSM's in the context of the supervisory control problem for discrete event processes <ref> [62, 4, 5] </ref>.
Reference: [63] <author> J.-K. Rho, G. Hachtel, F. Somenzi, and R. </author> <title> Jacoby. Exact and heuristic algorithms for the minimization of incompletely specified state machines. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> vol. 13(no. </volume> 2):167-177, February 1994. 
Reference-contexts: Moreover, it has been recently reported [43] that even examples with very few states generated during the synthesis of asynchronous circuits may fail to complete (or require days of CPU time) when run with a state-of-art exact state minimizer as STAMINA <ref> [63] </ref>. Therefore it is of practical importance 68 CHAPTER 4. COMPATIBLE GENERATION to revisit exact state minimization of ISFSM's and address the issue of representing implicitly the solution space. <p> We show how to compute sets of maximal compatibles, compatibles and prime compatibles with implicit techniques and demonstrate that in this way, it is possible to handle examples exhibiting a number of compatibles up to 2 1500 , an achievement outside the scope of programs based on explicit enumeration <ref> [63] </ref>. We indicate also where such examples arise in practice. The final step of an implicit exact state minimization procedure, i.e., solving a binate table covering problem [68], will be presented in the next chapter, Chapter 5. The remainder of this chapter is organized as follows. <p> We have demonstrated with experiments from a variety of benchmarks that implicit techniques allow us to handle examples exhibiting a number of compatibles up to 2 1500 , an achievement outside the scope of minimization programs based on explicit enumeration <ref> [63] </ref>. We have shown, when discussing the experiments, that ISFSM's with a very large number of compatibles may be produced as intermediate steps of logic synthesis algorithms, for instance in the cases of asynchronous synthesis [46], of learning I/O sequences [23], and of synthesis of interacting FSM's [65].
Reference: [64] <editor> J.-K. Rho and F. Somenzi. STAMINA. </editor> <booktitle> Computer Program, </booktitle> <year> 1991. </year>
Reference-contexts: FSM's with exponentially many prime compatibles, 6. FSM's with many maximal compatibles, and 7. randomly generated FSM's. Each suite has different features with respect to state minimization. We discuss features of the experiments and results in different subsections. Comparisons are made with STAMINA <ref> [64] </ref>, a program that represents the state-of-art for state minimization based on explicit techniques. The program STAMINA was run with the option -P to compute all prime compatibles. <p> This technique has been described in [29, 28, 9, 10], and implemented in successful computer programs <ref> [67, 64, 76] </ref>. The branch-and-bound solution of minimum binate covering is based on a recursive procedure. A run of the algorithm can be described by its computation tree. <p> Bi-partitioning is implemented in <ref> [64, 76] </ref> as follows. When checking for a partition of the problem (line 7), the routine sm mincov is called recursively on two independents subproblems (lines 8 and 10), if they exist. <p> Since finding a maximum independent set is an NP-complete problem, in practice an heuristic is used that provides a weaker lower bound. Notice that even the lower bound provided by solving exactly maximum independent set is not sharp. 114 CHAPTER 5. BINATE COVERING In <ref> [67, 64, 76] </ref>, the adjacency matrix B of a graph whose nodes correspond to rows in the cover matrix M is created. In the binate case, only rows are taken into consideration which do not contain any 0 element. <p> Since the time taken by the selection is a significant part of the total, a trade-off must be made between quality and efficiency. In <ref> [67, 64, 76] </ref>, the selection of the branching variable is restricted to columns intersecting the rows of the independent set, because a unique column must eventually be selected from each row of the maximal independent set. <p> The effect of reductions depends on the order of their application. Reductions are usually attempted in a given order, until nothing changes any more (i.e., the covering matrix has been reduced to a cyclic core). Figure 5.5 shows how reductions are applied in <ref> [67, 64, 76] </ref> 1 . 5.5.1 Row Dominance Definition 5.1 A row R i dominates another row R j if R j has all the 1's and 0's of R i ; i.e., for each column C k of M , one of the following occurs: * M i;k = 1 <p> Theorem 5.3 If a row R j is dominated by another row R i , R j can be eliminated without affecting the solutions to the covering problem. This definition of row dominance is 1 The reductions fi-dominance and row consensus are only in <ref> [64] </ref> and the reduction by implication is only in [76]. 116 CHAPTER 5. <p> In that case the last application of row consensus is potentially faulty and should not be done. Row consensus is applied in <ref> [64] </ref>. This criterion generalizes the one given in [33]. 118 CHAPTER 5. <p> Gimpel's rule has been first proposed in [27] and then implemented in [67]. In <ref> [64, 76] </ref> Gimpel's rule has been extended to handle the binate case. This extension has been described in [77]. 5.6 Implicit Binate Covering The classical branch-and-bound algorithm [28, 29] for minimum-cost binate covering has been described in previous sections, and implemented by means of efficient computer programs (ESPRESSO and STAMINA).
Reference: [65] <author> J.-K. Rho and F. Somenzi. </author> <title> The role of prime compatibles in the minimization of finite state machines. </title> <booktitle> In Proceedings of the European Design Automation Conference, </booktitle> <year> 1992. </year>
Reference-contexts: This dissertation addresses state minimization problems of various classes of finite state machines (FSM's). An exact algorithm [60, 28] usually consists of the generation of compatibles and the solution of a binate covering problem [68]. The state-of-the-art explicit minimizer <ref> [65] </ref> fails on FSM's requiring an exponential number of compatibles, or huge binate tables. We indicate also where such examples arise in practice. This dissertation first contributes a fully implicit algorithm for exact state minimization of incompletely specified FSM's, and a software implementation called ISM. <p> 542608 20 spaceout fourr.40 41 5.266e9 2.388e9 105 spaceout fourr.50 51 3.643e7 1.696e7 198 spaceout fourr.60 61 1.052e10 5.021e9 *18181 spaceout fourr.70 71 9.621e10 4.524e10 *22940 spaceout Table 4.3: FSM's from learning I/O sequences. 4.7.4 FSM's from Synthesis of Interacting FSM's It has been reported by Rho and Somenzi in <ref> [65] </ref> that the exact state minimization of the driven machine of a pair of cascaded FSM's is equivalent to the state minimization of an ISFSM that requires the computation of prime compatibles. <p> We have shown, when discussing the experiments, that ISFSM's with a very large number of compatibles may be produced as intermediate steps of logic synthesis algorithms, for instance in the cases of asynchronous synthesis [46], of learning I/O sequences [23], and of synthesis of interacting FSM's <ref> [65] </ref>. This shows that the proposed approach has not only a theoretical interest, but also practical relevance for current logic synthesis applications. A fully implicit exact algorithm for solving the binate covering problem [68] was presented in Chapter 5.
Reference: [66] <author> F. Rubin. </author> <title> Worst case bounds for maximal compatible subsets. </title> <journal> IEEE Transactions on Computers, </journal> <pages> pages 830-831, </pages> <month> August </month> <year> 1975. </year>
Reference-contexts: Unlike the case of CSFSM's, where state equivalence partitions the states, compatibles for incompletely specified FSM may overlap. As a result, the number of compatibles can be exponential in the number of states <ref> [66] </ref>, and the generation of the whole set of compatibles can be a challenging task. The covering step (which will be described in Sections 5) is to choose a minimum subset of compatibles satisfying covering and closure conditions, i.e., to find a minimum closed cover. <p> We were able to construct a suite of FSM's where the number of prime compatibles is exponential in the number of states. Rubin gave in <ref> [66] </ref> a sharp upper bound for the number of maximal compatibles of an ISFSM. He showed that M (n), the maximum number of maximal compatibles over all ISFSM's with n &gt; 1 states, is given by M (n) = i:3 m , if n = 3:m + i.
Reference: [67] <author> R. Rudell. </author> <title> ESPRESSO. </title> <booktitle> Computer Program, </booktitle> <year> 1987. </year>
Reference-contexts: This technique has been described in [29, 28, 9, 10], and implemented in successful computer programs <ref> [67, 64, 76] </ref>. The branch-and-bound solution of minimum binate covering is based on a recursive procedure. A run of the algorithm can be described by its computation tree. <p> Since finding a maximum independent set is an NP-complete problem, in practice an heuristic is used that provides a weaker lower bound. Notice that even the lower bound provided by solving exactly maximum independent set is not sharp. 114 CHAPTER 5. BINATE COVERING In <ref> [67, 64, 76] </ref>, the adjacency matrix B of a graph whose nodes correspond to rows in the cover matrix M is created. In the binate case, only rows are taken into consideration which do not contain any 0 element. <p> Since the time taken by the selection is a significant part of the total, a trade-off must be made between quality and efficiency. In <ref> [67, 64, 76] </ref>, the selection of the branching variable is restricted to columns intersecting the rows of the independent set, because a unique column must eventually be selected from each row of the maximal independent set. <p> The effect of reductions depends on the order of their application. Reductions are usually attempted in a given order, until nothing changes any more (i.e., the covering matrix has been reduced to a cyclic core). Figure 5.5 shows how reductions are applied in <ref> [67, 64, 76] </ref> 1 . 5.5.1 Row Dominance Definition 5.1 A row R i dominates another row R j if R j has all the 1's and 0's of R i ; i.e., for each column C k of M , one of the following occurs: * M i;k = 1 <p> Gimpel's rule has been first proposed in [27] and then implemented in <ref> [67] </ref>. In [64, 76] Gimpel's rule has been extended to handle the binate case.
Reference: [68] <author> R. Rudell. </author> <title> Logic synthesis for VLSI design. </title> <type> PhD thesis, </type> <institution> University of California, Berkeley, </institution> <month> April </month> <year> 1989. </year> <note> BIBLIOGRAPHY 209 </note>
Reference-contexts: This dissertation addresses state minimization problems of various classes of finite state machines (FSM's). An exact algorithm [60, 28] usually consists of the generation of compatibles and the solution of a binate covering problem <ref> [68] </ref>. The state-of-the-art explicit minimizer [65] fails on FSM's requiring an exponential number of compatibles, or huge binate tables. We indicate also where such examples arise in practice. This dissertation first contributes a fully implicit algorithm for exact state minimization of incompletely specified FSM's, and a software implementation called ISM. <p> We indicate also where such examples arise in practice. The final step of an implicit exact state minimization procedure, i.e., solving a binate table covering problem <ref> [68] </ref>, will be presented in the next chapter, Chapter 5. The remainder of this chapter is organized as follows. Section 4.2 gives an introduction to classical exact algorithms for state minimization of ISFSM's. An implicit version of the exact algorithm is presented in Section 4.3. <p> Even though more complex criteria of dominance have been investigated (for instance, Section 5.5.12), the previous ones are basic in any table covering solver. Reduction rules have previously been stated for the binate covering case [28, 29, 10, 9], and also for the unate covering case <ref> [54, 68, 9] </ref>. The former set of reductions are needed for state minimization. Here we will present the known reduction rules directly for binate covering and indicate how they simplify for unate covering, when applicable. <p> The resulting cover is a minimum cover for p. A proof can be found in <ref> [68] </ref>, where a more extended discussion is presented. Gimpel's reduction step was originally stated for covering problems where each column had cost 1. <p> This shows that the proposed approach has not only a theoretical interest, but also practical relevance for current logic synthesis applications. A fully implicit exact algorithm for solving the binate covering problem <ref> [68] </ref> was presented in Chapter 5. This is used as the final step of an implicit exact state minimization procedure for ISFSM's, to select a minimum closed cover of compatibles. A literature survey has been given for table reduction rules currently known to us.
Reference: [69] <author> R. Rudell. </author> <title> Dynamic variable ordering for ordered binary decision diagrams. </title> <booktitle> In Digest of Technical Papers of the IEEE International Conference on Computer-Aided Design, </booktitle> <pages> pages 42-47, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: Faster variable ordering heuristics for BDD's have been provided by Malik et al. in [52] and Fujita et al. in [25]. Rudell <ref> [69] </ref> recently proposed an effective dynamic variable reordering heuristic which offers a tradeoff of runtime for compactness of BDD representation. The goal in this section is to find a good variable ordering so as to minimize the total number of vertices used.
Reference: [70] <author> R. Rudell and A. Sangiovanni-Vincentelli. </author> <title> Multiple-valued minimization for PLA optimization. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> vol. 6 </volume> <pages> 727-750, </pages> <month> September </month> <year> 1987. </year>
Reference-contexts: R S represents the set of reset states. 1 Note that in this and subsequent definitions, the state space S, the input space I and the output space O can be generic discrete spaces and so S, I and O can assume symbolic values <ref> [21, 70] </ref>. A special case is when S, I and O are the Cartesian product of copies of the space B = f0; 1g, i.e., they are binary variables.
Reference: [71] <author> A. Saldanha, T. Villa, R. Brayton, and A. Sangiovanni-Vincentelli. </author> <title> A uniform framework for satisfying input and output encoding constraints. </title> <booktitle> Proceedings of the Design Automation Conference, </booktitle> <pages> pages 170-175, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: For instance the implicit computation of maximal compatibles given here can be easily converted into an implicit computation of prime encoding-dichotomies (see <ref> [71] </ref>). Therefore the computational methods described here contribute to build a body of implicit techniques whose scope goes much beyond a specific application. In this chapter, we address the problem of computing sets of compatibles for the exact state minimization of ISFSM's [37]. <p> Using techniques as in [48], GPI's can be generated implicitly. An implicit binate table solver is therefore needed there too. Notice that potential applications include unate covering problems, such as selecting the minimum number of encoding-dichotomies that satisfy a set of encoding constraints <ref> [71] </ref>. This chapter describes an implicit formulation of the binate covering problem and presents an implementation. <p> For instance similar techniques are used in an implicit algorithm [81] for exact state encoding based on generalized prime implicants (GPI's). Also, the implicit computation of maximal compatibles given here can be easily converted 202 CHAPTER 8. CONCLUSIONS into an implicit computation of prime encoding-dichotomies (see <ref> [71] </ref>). Moreover, the binate covering problem is at the core of many CAD problems, and our general implicit binate covering algorithm should be useful in solving large binate tables for those applications as well.
Reference: [72] <author> S. C. De Sarkar, A. K. Basu, and A. K. Choudhury. </author> <title> Simplification of incompletely specified flow tables with the help of prime closed sets. </title> <journal> IEEE Transactions on Computers, </journal> <volume> vol. 18 </volume> <pages> 953-956, </pages> <month> October </month> <year> 1969. </year>
Reference-contexts: Therefore techniques for the latter solve also the former. In the other direction, exact state minimization, a problem naturally formulated as a binate covering problem, can be reduced to a unate covering problem, after the generation of irredundant prime closed sets <ref> [72] </ref>. But there is a catch here: the cost function is not any more additive, so that the reduction techniques so convenient to solve covering problems, are not any more applicable as they are. In this chapter, we are interested in exact solutions of binate covering.
Reference: [73] <author> E. Sentovich, K. Singh, C. Moon, H. Savoj, R. Brayton, and A. Sangiovanni-Vincentelli. </author> <title> Sequential Circuit Design Using Synthesis and Optimization. </title> <booktitle> In Proceedings of the International Conference on Computer Design, </booktitle> <pages> pages 328-333, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: A state transition graph (STG) (Definition 2.4) is commonly used as the internal representation of FSM's in sequential synthesis systems, such as SIS <ref> [73] </ref>. Many algorithms for sequential synthesis have been developed to apply to STG's. However, large FSM's cannot be stored and manipulated without memory 60 CHAPTER 3.
Reference: [74] <author> M. Servit and J. Zamazal. </author> <title> Exact approaches to binate covering problem. </title> <note> Manuscript in preparation, </note> <month> October </month> <year> 1992. </year>
Reference-contexts: This definition of column mutual dominance is * identical to rule for mutually reducible variables in <ref> [74] </ref>, * not mentioned in other papers. 5.5. REDUCTION TECHNIQUES 121 5.5.7 Essential Column Definition 5.8 A column C j is an essential column if there exists a row R i having a 1 in column C j and 2's everywhere else.
Reference: [75] <author> T. Shiple, H. Touati, and G. Berry. </author> <title> Causality analysis of circuits. </title> <note> Manuscript in preparation, </note> <month> December </month> <year> 1994. </year>
Reference-contexts: Analysis of combinational cycles in circuits has been reported in <ref> [51, 12, 75] </ref>. Example Consider p ((s 1 ; s 2 ); x) = z.
Reference: [76] <editor> F. Somenzi. COOKIE. </editor> <booktitle> Computer Program, </booktitle> <year> 1989. </year>
Reference-contexts: This technique has been described in [29, 28, 9, 10], and implemented in successful computer programs <ref> [67, 64, 76] </ref>. The branch-and-bound solution of minimum binate covering is based on a recursive procedure. A run of the algorithm can be described by its computation tree. <p> Bi-partitioning is implemented in <ref> [64, 76] </ref> as follows. When checking for a partition of the problem (line 7), the routine sm mincov is called recursively on two independents subproblems (lines 8 and 10), if they exist. <p> Since finding a maximum independent set is an NP-complete problem, in practice an heuristic is used that provides a weaker lower bound. Notice that even the lower bound provided by solving exactly maximum independent set is not sharp. 114 CHAPTER 5. BINATE COVERING In <ref> [67, 64, 76] </ref>, the adjacency matrix B of a graph whose nodes correspond to rows in the cover matrix M is created. In the binate case, only rows are taken into consideration which do not contain any 0 element. <p> Since the time taken by the selection is a significant part of the total, a trade-off must be made between quality and efficiency. In <ref> [67, 64, 76] </ref>, the selection of the branching variable is restricted to columns intersecting the rows of the independent set, because a unique column must eventually be selected from each row of the maximal independent set. <p> The effect of reductions depends on the order of their application. Reductions are usually attempted in a given order, until nothing changes any more (i.e., the covering matrix has been reduced to a cyclic core). Figure 5.5 shows how reductions are applied in <ref> [67, 64, 76] </ref> 1 . 5.5.1 Row Dominance Definition 5.1 A row R i dominates another row R j if R j has all the 1's and 0's of R i ; i.e., for each column C k of M , one of the following occurs: * M i;k = 1 <p> This definition of row dominance is 1 The reductions fi-dominance and row consensus are only in [64] and the reduction by implication is only in <ref> [76] </ref>. 116 CHAPTER 5. <p> Gimpel's rule has been first proposed in [27] and then implemented in [67]. In <ref> [64, 76] </ref> Gimpel's rule has been extended to handle the binate case. This extension has been described in [77]. 5.6 Implicit Binate Covering The classical branch-and-bound algorithm [28, 29] for minimum-cost binate covering has been described in previous sections, and implemented by means of efficient computer programs (ESPRESSO and STAMINA).
Reference: [77] <author> F. Somenzi. </author> <title> Gimpel's reduction technique extended to the binate covering problem. </title> <type> Unpublished manuscript, </type> <year> 1989. </year>
Reference-contexts: Gimpel's rule has been first proposed in [27] and then implemented in [67]. In [64, 76] Gimpel's rule has been extended to handle the binate case. This extension has been described in <ref> [77] </ref>. 5.6 Implicit Binate Covering The classical branch-and-bound algorithm [28, 29] for minimum-cost binate covering has been described in previous sections, and implemented by means of efficient computer programs (ESPRESSO and STAMINA). These state-of-the-art binate table solvers represent binate tables efficiently using sparse matrix packages.
Reference: [78] <author> A. Srinivasan, T. Kam, S. Malik, and R. Brayton. </author> <title> Algorithms for discrete function manipulation. </title> <booktitle> In Digest of Technical Papers of the IEEE International Conference on Computer-Aided Design, </booktitle> <pages> pages 92-95, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: This allows us to construct a function by recursive decomposition. 3.2. MULTI-VALUED DECISION DIAGRAMS 35 3.2 Multi-valued Decision Diagrams This section describes a new data structure the multi-valued decision diagram <ref> [78, 36] </ref> that is used to solve discrete variable problems [36, 45, 84, 44, 3]. Our definition of multi-valued decision diagrams closely follows that of Bryant, [11], with two exceptions: we do not restrict ourselves to the Boolean domain, and the range of our functions is multi-valued. <p> Theorem 3.1 For any multi-valued function F , there is a unique reduced ordered (up to isomor-phism) MDD denoting F . Any other MDD denoting F contains more vertices. Proof: The complete proof has been given in <ref> [78] </ref>. Corollary 3.2 Two functions are equivalent if and only if the ROMDD's for each function are isomorphic. 3.2. MULTI-VALUED DECISION DIAGRAMS 37 3.2.2 CASE Operator The CASE operator forms the basis for manipulating MDD's. <p> By Equation 3.3, Shannon decomposition with respect to x is equivalent to the (p + 1)-tuple (x; H x 0 ; : : : ; H x p1 ). It is shown in <ref> [78] </ref> that the worst-case time complexity of the CASE algorithm is O (p max j F j j G 0 j : : : j G m1 j). 3.3 Binary Decision Diagrams The literal x i denotes that variable x i has the value 1 and the literal x i denotes
Reference: [79] <author> G. Swamy, R. Brayton, and P. McGeer. </author> <title> A fully implicit Quine-McCluskey procedure using BDD's. </title> <type> Tech. </type> <note> Report No. UCB/ERL M92/127, 1992. 210 BIBLIOGRAPHY </note>
Reference-contexts: Reported experiments show a suite of examples where all primes could be computed, whereas explicit techniques implemented in ESPRESSO [7] failed to do so. Finally, the fixed-point dominance computation in the covering step of the Quine-McCluskey procedure has been made implicit in current work <ref> [18, 79] </ref>. The experiments reported show that the cyclic core of all logic functions of the ESPRESSO benchmark can be successfully computed. For some of them ESPRESSO failed the task.
Reference: [80] <author> H. Touati, H. Savoj, B. Lin, R. K. Brayton, and A. Sangiovanni-Vincentelli. </author> <title> Implicit state enumeration of finite state machines using BDD's. </title> <booktitle> In Digest of Technical Papers of the IEEE International Conference on Computer-Aided Design, </booktitle> <pages> pages 130-133, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: By implicit manipulation, we mean that in one step, many objects are processed simultaneously. Seminal work by researchers at Bull [16] and improvements at U.C. Berkeley <ref> [80] </ref> produced powerful techniques for implicit enumeration of subsets of states of an FSM. These techniques are based on the idea of operating on large sets of states by their characteristic functions [13] represented by binary decision diagrams (BDD's) [11]. <p> In fact, an unused point is assigned to the same path as the used point whose encoding is closest to the unused code point. This mapping is related to the generalized cofactor operator in <ref> [80] </ref> which was initially proposed in [17] as the constraint operator. <p> A small BDD for N EW (y; z) can be obtained using the generalized cofactor <ref> [80] </ref> using ICP k (y; z) as the don't care set: N EW (y; z) = N EW (y; z)j :ICP k (y;z) 3 In Figure 4.2, the direction of the arrows shows the inverse projections. 4.5. <p> Special care must be exercised with quantifications, that bring more danger of BDD blowups. All of this goes often under the name of implicit representations and computations. The previous insight has already been tested in a series of applications. Research at Bull [16] and U.C. Berkeley <ref> [80] </ref> produced powerful techniques for implicit enumeration of subsets of states of a Finite State Machine (FSM). Later work at Bull [19, 48] has shown how implicants, primes and essential primes of a two-valued or multi-valued function can also be computed implicitly.
Reference: [81] <author> T. Villa. </author> <title> Encoding Problems in Logic Synthesis. </title> <type> PhD thesis, </type> <institution> University of California, Berkeley, </institution> <month> May </month> <year> 1995. </year>
Reference-contexts: The implicit binate solver has been tested in the case of state minimization of ISFSM's (Chapter 4) and pseudo NDFSM's (Chapters 6 and 7), and also for optimum selection of an encodable set of generalized prime implicants for state assignment <ref> [81] </ref>. The reported experiments show that implicit techniques have pushed the frontier of instances where binate covering problems 5.2. RELATION TO 0-1 INTEGER LINEAR PROGRAMMING 105 can be solved exactly, resulting in better optimizations possible in key steps of sequential logic synthesis. <p> It is worth while to underline that besides the intrinsic interest of state minimization and its variants for sequential synthesis, the implicit techniques reported in this dissertation can be applied to other problems of logic synthesis and combinatorial optimization. For instance similar techniques are used in an implicit algorithm <ref> [81] </ref> for exact state encoding based on generalized prime implicants (GPI's). Also, the implicit computation of maximal compatibles given here can be easily converted 202 CHAPTER 8. CONCLUSIONS into an implicit computation of prime encoding-dichotomies (see [71]).
Reference: [82] <author> H.-Y. Wang and R. K. Brayton. </author> <title> Input don't care sequences in FSM networks. </title> <booktitle> In Digest of Technical Papers of the IEEE International Conference on Computer-Aided Design, </booktitle> <pages> pages 321-328, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: We report results on the following suites of FSM's. They are: 1. the MCNC benchmark and other examples, 4.7. EXPERIMENTAL RESULTS 89 2. FSM's generated by a synthesis procedure for asynchronous logic [46], 3. FSM's from learning I/O sequences [23], 4. FSM's from synthesis of interacting FSM's <ref> [82] </ref>, 5. FSM's with exponentially many prime compatibles, 6. FSM's with many maximal compatibles, and 7. randomly generated FSM's. Each suite has different features with respect to state minimization. We discuss features of the experiments and results in different subsections. <p> The examples ifsm0, ifsm1, ifsm2 come from a set of FSM's produced by FSM optimization, using the input don't care sequences induced by a surrounding network of FSM's <ref> [82] </ref>. They exhibit often large number of compatibles and prime compatibles, as shown in Table 4.4. For such cases, the run times of the implicit algorithm ISM are shorter than those by STAMINA. 4.7. EXPERIMENTAL RESULTS 93 # # # prime CPU time (sec) machine state compat. compat.
Reference: [83] <author> Y. Watanabe. </author> <title> Logic Optimization of Interacting Components in Synchronous Digital Systems. </title> <type> PhD thesis, </type> <institution> University of California, Berkeley, </institution> <month> April </month> <year> 1994. </year>
Reference-contexts: The entire branch-and-bound procedure is carried out implicitly. To handle a more general and useful class of FSM's, the first implicit algorithm for exact state minimization of pseudo non-deterministic FSM's is presented. Its implementation ISM2 is shown experimentally to be superior to a previous explicit formulation <ref> [83] </ref>. ISM2 could solve exactly all but one problem of a set of published benchmarks, while the explicit program could complete approximately one half of the examples, and in those cases with longer running times. <p> A theoretical solution is presented for the problem of exact state minimization of general non-deterministic FSM's, based on the proposal of generalized compatibles. This gives an algorithmic foundation for exploring behaviors contained in an NDFSM. Recent research <ref> [83, 4, 2] </ref> in sequential synthesis, verification and supervisory control relies, as a final step, on the selection of an optimum behavior to be implemented at a component FSM within a network of FSM's. <p> If such a representation exists, Theorem 6.1 gives a constructive definition of generalized compatible, and the covering and closure conditions in Section 6.1.2 can be solved as a binate covering problem. As an alternative, suggested in <ref> [83] </ref>, one can convert any NDFSM to a PNDFSM (Theorem 2.9) by an implicit determinization (via subset construction) step as described in Section 6.2.1 and then apply to the PNDFSM our implicit (or any) state minimization algorithm which will be presented in Section 6.3. <p> It is an open problem whether a better procedure can be devised, or instead this exponential blow-up is intrinsic to the problem of minimizing NDFSM's. It must also be stressed that we do not have yet good sources of general NDFSM's in sequential synthesis, while the work in <ref> [83] </ref> has shown the pivotal importance of PNDFSM's in the synthesis of interconnected FSM's. 156 CHAPTER 6. STATE MINIMIZATION OF NON-DETERMINISTIC FSM'S 6.2.3 Heuristic Algorithms for State Minimization It has been shown that exact minimization of NDFSM's requires computation of the generalized compatibles, instead of the usual compatibles. <p> Prime compatibles and the binate table are generated according to the algorithm described above; then a minimum cover of the table is found by our implicit binate covering solver presented in Chapter 5. We perform and report experiments on the complete set of examples obtained by Watanabe in <ref> [83] </ref>. Each PNDFSM is an E-machine derived from an arbitrary connection of two completely specified deterministic FSM's, M 1 and M 2 , from the MCNC benchmark. The product machine M = M 1 fi M 2 is used as the specification. <p> In its exact mode, compatible selection is performed by an explicit binate table solver available in the logic synthesis package SIS. In its heuristic mode, it finds instead a Moore 4 machine in the E-machine, by `expand' and `reduce' operations <ref> [83] </ref> on a closed cover of compatibles. As the heuristic looks only to Moore solutions, it is understandable that it will give a worse solution than the minimum contained machine if the latter is not Moore. Also the run times might not be directly comparable. <p> In particular, a more restricted notion of permissible behavior proposed in [86, 85] will guarantee that the composition is well-defined, i.e., that potentially hazardous implementations are ruled out. The maximal set of permissible behaviors can be captured by the E-machine and its related theory in <ref> [83] </ref> will be reviewed in Section 7.1.2. If the set of behaviors permissible at M 1 is found, a `best' one can then be chosen. <p> A sufficient condition for well-definedness, called implementability, has been proposed in <ref> [83] </ref>. We shall review it later. Here we introduce a more general condition under which a product is well-defined. <p> by the following fixed point computation: S 0 S k+1 p (s 1 ; s 2 ) + [(s 0 2 ) ! (s 1 ; s 2 )] p (s 1 ; s 2 ) T 1 (u; s 1 ; s 0 2 ; uz)] Implementable FSM's In <ref> [83] </ref>, a definition of product machine is given, based on the existence of a unique pair u; v such that the equations are satisfied. Moreover, a sufficient condition, called implementability, for the existence of such a unique pair u; v is introduced. <p> Given M and M 2 (e.g., consider Figure 7.4 from <ref> [83] </ref>), many permissible behaviors can be implemented at M 1 . The problem is how to compute all of them and how to represent them in the most compact way. <p> In this case it is expected that the PNDFSM has a smaller number of states than when the global inputs X are not available directly to M 1 . It has been proved formally in <ref> [83] </ref> that a behavior implementable at M 1 is permissible if and only if the behavior is contained in the PNDFSM obtained by the fixed point computation presented in this section. It is obvious by construction that a behavior implementable at M 1 contained in the PNDFSM is permissible. <p> They differ on how the table is set up, and also if the classical branch and bound algorithm needs to be modified. One approach proposed in <ref> [83] </ref> to solve P3 and P5 is by expanding on the number of table columns so that the problems can be cast exactly as a binate covering problem. For problem P3, each column corresponds to a pair (c; v) where c is a compatible and v is an output minterm. <p> So if a solution exists for problems P2 and P3, there must be a reduced machine which states corresponds to distinct compatible state sets. A similar concept was mentioned by Watanabe in the second half of Section 5.4.3 in <ref> [83] </ref> but he didn't continue to give an algorithm after noting that the problem reduces to a 0-1 integer non-linear programming problem. 7.4.1 Moore Compatible Generation To explore behaviors that are behaviorally contained in a PNDFSM M , Theorem 2.20 shows that we can construct its power machine M power and <p> Implicit Selection of M-Compatibles The selection problem of a minimum subset of M-compatibles which satisfies the covering and Moore closure condition cannot be solved as a binate covering problem, as noted in <ref> [83] </ref>. This is because the form of each Moore condition requires a disjunction of conjunctions of disjunctions of literals (i.e., M-compatibles) which arises from the quantifications 9v 8u 9c 0 in Definition 7.10. <p> The results of our implementation are reported and shown to be superior to the explicit formulation described in [86]. We could solve exactly all the problems of the benchmark used in <ref> [83] </ref> (except one case, where a minimal solution not guaranteed to be the minimum was found). The explicit program could complete approximately one half of the examples, and in those cases with longer running times.
Reference: [84] <author> Y. Watanabe and R. Brayton. </author> <title> Heuristic minimization of multi-valued relations. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> vol. 12(no. </volume> 10):1458-1472, October 1993. 
Reference-contexts: This allows us to construct a function by recursive decomposition. 3.2. MULTI-VALUED DECISION DIAGRAMS 35 3.2 Multi-valued Decision Diagrams This section describes a new data structure the multi-valued decision diagram [78, 36] that is used to solve discrete variable problems <ref> [36, 45, 84, 44, 3] </ref>. Our definition of multi-valued decision diagrams closely follows that of Bryant, [11], with two exceptions: we do not restrict ourselves to the Boolean domain, and the range of our functions is multi-valued.
Reference: [85] <author> Y. Watanabe and R. K. Brayton. </author> <title> The maximum set of permissible behaviors for FSM networks. </title> <booktitle> In IEEE International Conference on Computer-Aided Design, </booktitle> <pages> pages 316-320, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: The product machine M = M 1 fi M 2 is used as the specification. The E-machine which contains all permissible behaviors at M 1 is derived using the procedure in <ref> [85] </ref>. Our problem is to find a minimum state machine behaviorally contained in the E-machine. Watanabe's minimizer, PND REDUCE, does not compute prime compatibles but finds all compatibles instead. In its exact mode, compatible selection is performed by an explicit binate table solver available in the logic synthesis package SIS. <p> Of all such sequential functions, those that satisfy given criteria of correctness are valid candidates for implementation (design verification stage). Of all valid candidates, one maximizing a given optimization criterion is implemented (synthesis stage). Recent papers <ref> [86, 85, 20] </ref> have proposed specific applications of NDFSM's, especially PNDFSM's, to sequential synthesis. Some examples are presented in [20]. NDFSM's arise in sequential synthesis when capturing all the flexibility that is in a node of a network of FSM's. <p> Some examples are presented in [20]. NDFSM's arise in sequential synthesis when capturing all the flexibility that is in a node of a network of FSM's. We will summarize the related theory, which was first proposed by Watanabe et al. in <ref> [86, 85] </ref>. We review in the sequel these applications that explore permissible behaviors in networks of FSM's. We detail all those parts of the theory that are important for the step of state minimization (i.e., to select an optimal behavior of all permissible ones). <p> Such a replacement is allowed if the composition is well-defined and the global behavior is the one expected. In the Section 7.1.1, relevant formal definitions will be given. In particular, a more restricted notion of permissible behavior proposed in <ref> [86, 85] </ref> will guarantee that the composition is well-defined, i.e., that potentially hazardous implementations are ruled out. The maximal set of permissible behaviors can be captured by the E-machine and its related theory in [83] will be reviewed in Section 7.1.2. <p> But there are two pairs of u; v such that the equations are satisfied, i.e., u = 0; v = 0 and u = 1; v = 1. In <ref> [86, 85] </ref> a sufficient condition called implementability is imposed on M 1 , to ensure that for each present state pair and each input, there is a unique (u; v) pair. <p> A necessary and sufficient condition for M 1 to be implementable is given in <ref> [86, 85] </ref>. <p> A DFSM that satisfies both implementability and containment is a valid choice for M 1 and is taken as the definition of permissible DFSM in <ref> [86, 85] </ref>. <p> STATE MINIMIZATION OF PNDFSM'S FOR FSM NETWORKS the NDFSM can be coverted into a PNDFSM. It is also possible to define a fixed point computation that builds directly the PNDFSM. The latter computation has been proposed in <ref> [85] </ref> and the PNDFSM so obtained has been called the E-machine 5 . Similarly, the result of the former computation has been called the NDE-machine. Since determinization could lead to an exponential increase of the state space, the first approach seems more attractive. <p> M 1 is behaviorally contained in the E-machine, and 2. the product machine M 1 fi M 2 is well-defined. Given DFSM's M 2 and M , Watanabe <ref> [85] </ref> provided an algorithm and a program to generate the E-machine, which is a PNDFSM. <p> Then we considered a dual problem of practical interest: given a DFSM M 2 and a specification M , find a behavior permissible at M 1 such that M 1 fi M 2 is well-defined. Watanabe proved in <ref> [85] </ref> that the E-machine captures the maximum set of permissible behaviors. Our contribution is to propose improved algorithms to find such a behavior contained in the E-machine which is either (1) Moore, or (2) well-defined with respect to M 2 .
Reference: [86] <author> Y. Watanabe and R. K. Brayton. </author> <title> State minimization of pseudo non-deterministic FSM's. </title> <booktitle> In European Conference on Design Automation, </booktitle> <pages> pages 184-191, </pages> <year> 1994. </year>
Reference-contexts: As a special case of Mealy machine, Moore machines have its output depends on its present state only (but not input). The definition of Moore machine presented here is the same as the one given by Moore in [58] and followed by authors in the field (e.g., <ref> [86] </ref>). The key fact to notice is that the output is associated with the present state. In other words, the common output associated to a given state, goes on all transitions that leave that state. This is a reasonable assumption when modeling an hardware system. <p> R S represents the set of reset states. Explicit algorithms for exact state minimization for PNDFSM's have been proposed by Watanabe et al. in <ref> [86] </ref> and by Damiani in [20]. In this section, we contribute the first fully implicit algorithms for exact state minimization of PNDFSM's. The theory for PNDFSM state minimization has already been given in Chapter 2. <p> Of all such sequential functions, those that satisfy given criteria of correctness are valid candidates for implementation (design verification stage). Of all valid candidates, one maximizing a given optimization criterion is implemented (synthesis stage). Recent papers <ref> [86, 85, 20] </ref> have proposed specific applications of NDFSM's, especially PNDFSM's, to sequential synthesis. Some examples are presented in [20]. NDFSM's arise in sequential synthesis when capturing all the flexibility that is in a node of a network of FSM's. <p> Some examples are presented in [20]. NDFSM's arise in sequential synthesis when capturing all the flexibility that is in a node of a network of FSM's. We will summarize the related theory, which was first proposed by Watanabe et al. in <ref> [86, 85] </ref>. We review in the sequel these applications that explore permissible behaviors in networks of FSM's. We detail all those parts of the theory that are important for the step of state minimization (i.e., to select an optimal behavior of all permissible ones). <p> Such a replacement is allowed if the composition is well-defined and the global behavior is the one expected. In the Section 7.1.1, relevant formal definitions will be given. In particular, a more restricted notion of permissible behavior proposed in <ref> [86, 85] </ref> will guarantee that the composition is well-defined, i.e., that potentially hazardous implementations are ruled out. The maximal set of permissible behaviors can be captured by the E-machine and its related theory in [83] will be reviewed in Section 7.1.2. <p> But there are two pairs of u; v such that the equations are satisfied, i.e., u = 0; v = 0 and u = 1; v = 1. In <ref> [86, 85] </ref> a sufficient condition called implementability is imposed on M 1 , to ensure that for each present state pair and each input, there is a unique (u; v) pair. <p> A necessary and sufficient condition for M 1 to be implementable is given in <ref> [86, 85] </ref>. <p> A DFSM that satisfies both implementability and containment is a valid choice for M 1 and is taken as the definition of permissible DFSM in <ref> [86, 85] </ref>. <p> This gives an algorithmic foundation for exploring behaviors contained in a general NDFSM. (2) A fully implicit algorithm for exact state minimization of PNDFSM's. The results of our implementation are reported and shown to be superior to the explicit formulation described in <ref> [86] </ref>. We could solve exactly all the problems of the benchmark used in [83] (except one case, where a minimal solution not guaranteed to be the minimum was found). The explicit program could complete approximately one half of the examples, and in those cases with longer running times. <p> We first characterize the necessary and sufficient condition when the composition M = M 1 fi M 2 is a well-defined FSM. Previously known conditions, such as requiring M 1 or M 2 to be Moore, or requiring M 1 to be `implementable' as defined in <ref> [86] </ref>, are sufficient conditions only. Then we considered a dual problem of practical interest: given a DFSM M 2 and a specification M , find a behavior permissible at M 1 such that M 1 fi M 2 is well-defined.
References-found: 86

