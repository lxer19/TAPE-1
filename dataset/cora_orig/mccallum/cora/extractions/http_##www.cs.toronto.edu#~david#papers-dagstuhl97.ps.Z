URL: http://www.cs.toronto.edu/~david/papers-dagstuhl97.ps.Z
Refering-URL: http://www.cs.toronto.edu/~david/papers.html
Root-URL: 
Email: david@cs.toronto.edu  
Title: Point-based Temporal Extensions of SQL and their Efficient Implementation  
Author: David Toman 
Address: Toronto, Ontario M5S 1A4, Canada  
Affiliation: Department of Computer Science, University of Toronto  
Abstract: This chapter introduces a new approach to temporal extensions of SQL. The main difference from most of the current proposals is the use single time points, rather than intervals or various other complex-values for references to time, while still achieving efficient query evaluation. The proposed language, SQL/TP, extends the syntax of SQL/92 to handle temporal data in a natural way: it adds a single data type to represent a linearly ordered universe of time instants. The semantics of the new language naturally extends the standard SQL semantics and eliminates or fixes many of the problems connected with defining a precise semantics to temporal query languages based on explicit interval-valued temporal attributes. The efficient query evaluation procedure is based on a compilation technique that translates SQL/TP queries to SQL/92. Therefore existing off-shelf database systems can be used as back-ends for implementations based on this approach to manage temporal data.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Abiteboul, S., Herr, L., Van den Bussche, J. </author> <title> Temporal versus First-Order Logic to Query Temporal Databases. </title> <booktitle> Proc. ACM PODS 1996, </booktitle> <pages> 49-57, </pages> <year> 1996. </year>
Reference-contexts: First, we argue that a single temporal dimension is not sufficient to formulate general temporal queries. Consider the query "are there two distinct time instants when a given relation contains exactly the same tuples?" <ref> [1] </ref> and [21] have independently shown that this query cannot be formulated in first-order temporal logic. A direct corollary of this result is that this query cannot be expressed in any single-dimensional temporal relational algebra 2 . <p> Therefore our proposal follows a different path that avoids all of the above problems: we let the temporal attributes in our language range over single time instants. The approach is based on several recent results in the area of temporal and constraint query languages <ref> [1, 15, 20, 21] </ref>. We also define a meaningful approach to duplicate semantics and aggregation that is independent of the particular encoding (building on the results in [10, 11]). <p> This way we can build a SQL/TP front-end to an existing RDBMS and provide tem poral capabilities without modifying the underlying database system itself. - SQL/TP can express all representation independent SQL/Temporal queries. Moreover, SQL/TP is complete in the sense of [8]. The results in <ref> [1, 21] </ref> show that this is not the case for any of the temporal query languages based on a fixed-dimensional temporal relational algebra, e.g., [7]; this issue is not clear for TSQL2-derived languages [5, 18, 19] because of the presence of explicit coercion operators that convert encoded temporal attributes to data <p> It is easy to see that all the relational operations, with the exception of duplicate preserving projection, meet this requirement. However, the duplicate-preserving projection can produce such tables, e.g.: f ("Poland"; <ref> [1945; 1] </ref>)g k:k ! f ("Poland"; n) : n 1945g 1 ! f ("Poland"); : : : ; ("Poland"); : : :g The result of the projection contains infinite duplication of the tuple ("Poland"). <p> We can also express queries shown not to be expressible in TRA [7], e.g., the query "is there a pair of distinct time instants, when exactly the same countries were independent?" <ref> [1, 21] </ref>. This is not possible in any temporal query language that assumes a fixed number of temporal dimensions in its data model. 3.3 Examples of Queries In this section we provide illustrative examples of SQL/TP queries. The examples are chosen to highlight the ease of formulating queries in SQL/TP. <p> The results in <ref> [1, 21] </ref> show that the two dimensionality is inherent to this query (this remains true even when we consider the existential closure of this query). 3.4 Database Updates Besides considering the query language, in a truly practical approach we also need to address updates of temporal relations.
Reference: 2. <author> Allen, J. F. </author> <title> Maintaining knowledge about temporal intervals. </title> <journal> Communications of the ACM, </journal> <volume> 26(11) </volume> <pages> 832-843, </pages> <year> 1983. </year>
Reference-contexts: syntax of the chosen encoding then provides a domain of values for temporal attributes in the languages, e.g., pairs of interval endpoints (ATSQL [5] and SQL/Temporal [19] use the BEGIN and END keywords to extract the endpoints of intervals, PERIOD keyword to construct new interval timestamps, and Allen's interval algebra <ref> [2] </ref> operators to compare the timestamps). However, this is only possible if the user knows that the timestamps are encoded by intervals. <p> Before we start the technical part of the chapter, we would like to reiterate (to avoid any misunderstanding) that we are interested in intervals as a physical encoding of sets on time instants. This is very different from the approaches taken in the various interval logics <ref> [2] </ref>, where intervals represent points in a two-dimensional (half-)space. However, due to the natural multidimensionality of SQL/TP, we can represent the true intervals using pairs temporal attributes.
Reference: 3. <author> Bohlen, M. H., Chomicki, J., Snodgrass, R. T., Toman, D. </author> <title> Querying TSQL2 Databases with Temporal Logic. </title> <booktitle> In Proc. EDBT'96, </booktitle> <volume> LNCS 1057, </volume> <pages> 325-341, </pages> <year> 1996. </year>
Reference-contexts: In a single-dimensional case, the representation dependency problem can be successfully evaded using coalescing [6]. TSQL2's informal semantics (including many examples of queries in TSQL2) is implicitly based on this assumption <ref> [3, 18] </ref>. In the rest of this section we argue however, that the situation in Example 1 naturally arises during temporal query evaluation and cannot be avoided in general. First, we argue that a single temporal dimension is not sufficient to formulate general temporal queries. <p> Using this result we can show that, e.g., the first-order temporal logic queries can be efficiently translated to SQL/TP: all the temporal operators can be translated into small fixed-size subqueries and views with exactly one temporal attribute <ref> [3] </ref>. Similar result holds for all TRA [7] based languages. View Definitions in SQL/TP. A side effect of this observation is a natural defi-nition of views in the SQL/TP.
Reference: 4. <author> Bohlen, M. H., Jensen, C. S. </author> <title> Seamless Integration of Time into SQL. </title> <institution> University of Aalborg, </institution> <address> http://www.cs.auc.dk/ boehlen/Software/Tiger/atsql.ps.gz, </address> <year> 1996. </year>
Reference-contexts: Therefore, tuples are associated with compact encodings of a set of time instants (often called period of validity). The sets of time instants are commonly stored using (finite sets of) intervals [17, 19], bitemporal elements <ref> [4, 14] </ref>, or other fixed-dimensional products of intervals (hyper-rectangles). <p> However, this is only possible if the user knows that the timestamps are encoded by intervals. It also leads to a tension between the syntax of the query languages and their intended semantics: the data model and the semantics of the languages are point-based 1 <ref> [4, 9] </ref>, while temporal attributes in the syntax refer to the actual encoding for sets of time instants (e.g., interval endpoints). This conflict leads to several unpleasant surprises when precise semantics needs to be defined.
Reference: 5. <author> Bohlen, M. H., Jensen, C. S., Snodgrass, R. T. </author> <title> Evaluating and Enhancing the Completeness of TSQL2. </title> <type> Technical Report TR 95-5, </type> <institution> Computer Science Department, University of Arizona, </institution> <month> June </month> <year> 1995. </year>
Reference-contexts: Hence, there are dozens of mutually incompatible models and proposals. Many of them based on (often ad-hoc) extensions of existing relational languages, e.g., TQUEL [17] and various temporal extensions of SQL: TSQL2 [18], ATSQL2 <ref> [5] </ref>, and SQL/Temporal [19], the current proposal of temporal extension of SQL3 to the ISO and ANSI standardization committees. <p> The syntax of the chosen encoding then provides a domain of values for temporal attributes in the languages, e.g., pairs of interval endpoints (ATSQL <ref> [5] </ref> and SQL/Temporal [19] use the BEGIN and END keywords to extract the endpoints of intervals, PERIOD keyword to construct new interval timestamps, and Allen's interval algebra [2] operators to compare the timestamps). However, this is only possible if the user knows that the timestamps are encoded by intervals. <p> Moreover, SQL/TP is complete in the sense of [8]. The results in [1, 21] show that this is not the case for any of the temporal query languages based on a fixed-dimensional temporal relational algebra, e.g., [7]; this issue is not clear for TSQL2-derived languages <ref> [5, 18, 19] </ref> because of the presence of explicit coercion operators that convert encoded temporal attributes to data attributes. The proposal can easily be extended to support migration requirements [19] for upward temporal compatibility with SQL.
Reference: 6. <author> Bohlen, M. H., Snodgrass, R. T., Soo, M. D. </author> <title> Coalescing in Temporal Databases. </title> <booktitle> Proc. 22nd Int. Conf. on Very Large Databases, </booktitle> <pages> 180-191, </pages> <year> 1996. </year>
Reference-contexts: In a single-dimensional case, the representation dependency problem can be successfully evaded using coalescing <ref> [6] </ref>. TSQL2's informal semantics (including many examples of queries in TSQL2) is implicitly based on this assumption [3, 18]. In the rest of this section we argue however, that the situation in Example 1 naturally arises during temporal query evaluation and cannot be avoided in general. <p> How do we perform updates efficiently? The area of updates presents a completely new set of problems, the main problem being the in-place updates of the encoded temporal relations. This problem goes hand in hand with defining various normal forms <ref> [6, 20] </ref> of temporal relations and enforcing them over updates 13 .
Reference: 7. <author> Clifford J., Croker A., Tuzhilin A. </author> <title> On Completeness of Historical Relational Query Languages. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> Vol. 19, No. 1, </volume> <pages> 64-116, </pages> <year> 1994. </year>
Reference-contexts: Moreover, SQL/TP is complete in the sense of [8]. The results in [1, 21] show that this is not the case for any of the temporal query languages based on a fixed-dimensional temporal relational algebra, e.g., <ref> [7] </ref>; this issue is not clear for TSQL2-derived languages [5, 18, 19] because of the presence of explicit coercion operators that convert encoded temporal attributes to data attributes. The proposal can easily be extended to support migration requirements [19] for upward temporal compatibility with SQL. <p> Theorem 12 The first-order fragment of SQL/TP is expressively equivalent to range restricted two-sorted first order logic (temporal relational calculus). We can also express queries shown not to be expressible in TRA <ref> [7] </ref>, e.g., the query "is there a pair of distinct time instants, when exactly the same countries were independent?" [1, 21]. <p> Using this result we can show that, e.g., the first-order temporal logic queries can be efficiently translated to SQL/TP: all the temporal operators can be translated into small fixed-size subqueries and views with exactly one temporal attribute [3]. Similar result holds for all TRA <ref> [7] </ref> based languages. View Definitions in SQL/TP. A side effect of this observation is a natural defi-nition of views in the SQL/TP. Again, we use the familiar SQL/92 syntax: create view &lt;rid&gt; ( &lt;query&gt; ) where &lt;rid&gt; is a view name and &lt;query&gt; an SQL/TP query.
Reference: 8. <author> Codd, E. F. </author> <title> Relational completeness of database sublanguages. In Rustin, R.(ed.) </title> <booktitle> Courant Computer Science Symposium 6: Data Base Systems, </booktitle> <pages> 65-98, </pages> <publisher> Prentice-Hall, </publisher> <year> 1972. </year>
Reference-contexts: This way we can build a SQL/TP front-end to an existing RDBMS and provide tem poral capabilities without modifying the underlying database system itself. - SQL/TP can express all representation independent SQL/Temporal queries. Moreover, SQL/TP is complete in the sense of <ref> [8] </ref>. <p> This fact does not affect the generality of our proposal: it is an easy exercise to show that the proposed fragment forms a (first-order) complete query language <ref> [8] </ref>. Moreover, all representation independent SQL/Temporal queries, including queries with aggregation and universal subqueries, can be equivalently formulated in this fragment. Syntax. The chosen syntactic subset of SQL/TP uses two basic syntactic constructs: Select block.
Reference: 9. <author> Chomicki J. </author> <title> Temporal Query Languages: a Survey. </title> <booktitle> Proc. International Conference on Temporal Logic, </booktitle> <address> July 1994, Germany, </address> <publisher> Springer-Verlag (LNAI 827), </publisher> <pages> 506-534. </pages>
Reference-contexts: However, this is only possible if the user knows that the timestamps are encoded by intervals. It also leads to a tension between the syntax of the query languages and their intended semantics: the data model and the semantics of the languages are point-based 1 <ref> [4, 9] </ref>, while temporal attributes in the syntax refer to the actual encoding for sets of time instants (e.g., interval endpoints). This conflict leads to several unpleasant surprises when precise semantics needs to be defined. <p> The rest of the chapter is organized as follows: Section 2 introduces the temporal data model: the abstract and concrete (interval-based) temporal databases (following the terminology introduced in <ref> [9] </ref>). Section 3 defines the syntax and semantics of SQL/TP and gives examples of temporal queries. We also include a brief discussion of compatibility issues and migration of SQL queries to SQL/TP (Section 3.5). Section 4 provides the foundation of the proposed compilation technique. <p> We summarily refer to those data types as the uninterpreted constants. The relationships between the time instants and the uninterpreted constants are captured in a finite set of temporal relations stored in the database. Following the terminology of <ref> [9] </ref> we distinguish the abstract temporal databases from the concrete temporal databases: 4 A dense linearly ordered time can be used with only a minor adjustment. 5 For our purposes any fixed granularity will do.
Reference: 10. <author> Chomicki, J., Kuper, G. M. </author> <title> Measuring Infinite Relations. </title> <booktitle> Proc. ACM PODS 1995, </booktitle> <pages> 78-85, </pages> <year> 1995. </year>
Reference-contexts: The approach is based on several recent results in the area of temporal and constraint query languages [1, 15, 20, 21]. We also define a meaningful approach to duplicate semantics and aggregation that is independent of the particular encoding (building on the results in <ref> [10, 11] </ref>). The two main design principles behind the new language are: (1) The syntax and semantics of standard SQL are extended in a natural way: by adding a new data type to represent the universe of time instants. <p> For similar reasons we restrict the use of aggregate operations: we require the aggregated attribute to be independent of the group by attributes <ref> [10] </ref>. Moreover, the aggregation has to obey the restrictions in Figure 1. We also restrict the use of duplicate-preserving projection on all temporal attributes encoded by intervals. We have already seen that duplicate-preserving projection is not possible for unbounded data types. <p> Note that cnt ' G maps concrete tuples to natural numbers. However, if we used a dense model of time then cnt would be a measure on the sets of time instants and could return non-integral counts, e.g., 1.5 years. For details on aggregation and measures see <ref> [10] </ref>. Lemma 18 Given fixed E, G E, and ', the function cnt ' G can be defined using an integer expression over the value of x. The cnt function operates on single tuples and thus contributes only a constant to the overall data complexity of queries.
Reference: 11. <author> Chomicki, J., Goldin, D. Q., Kuper, G. M. </author> <title> Variable Independence and Aggregation Closure. </title> <booktitle> Proc. ACM PODS 1996, </booktitle> <pages> 40-48, </pages> <year> 1996. </year>
Reference-contexts: The approach is based on several recent results in the area of temporal and constraint query languages [1, 15, 20, 21]. We also define a meaningful approach to duplicate semantics and aggregation that is independent of the particular encoding (building on the results in <ref> [10, 11] </ref>). The two main design principles behind the new language are: (1) The syntax and semantics of standard SQL are extended in a natural way: by adding a new data type to represent the universe of time instants. <p> To avoid this problem we use the notion of attribute independence. Rather than a semantic definition of attribute independence <ref> [11] </ref> we use a syntactic inference system to detect attribute independence in a SQL/TP expression: Definition 8 (Attribute Independence) Let t 1 and t 2 be two temporal attributes in the signature of a SQL/TP expression exp.
Reference: 12. <author> Date, C. J., Drawen, H. </author> <title> A Guide to the SQL Standard (3rd ed.), </title> <address> Addison-Welsley, </address> <year> 1993. </year>
Reference-contexts: There are several other features of the proposal: - SQL/TP statements can be compiled to standard SQL/92 3 <ref> [12] </ref>; the translated queries can be evaluated using an off-shelf database system. This way we can build a SQL/TP front-end to an existing RDBMS and provide tem poral capabilities without modifying the underlying database system itself. - SQL/TP can express all representation independent SQL/Temporal queries.
Reference: 13. <author> IBM Database 2, </author> <title> SQL Reference for common servers. </title> <institution> IBM Corp., </institution> <year> 1995. </year>
Reference-contexts: R by the expression Q [R i 7! V t i =N (R i )] where V is the list of R i 's data attributes, t i is R i 's temporal attribute, and N is a constant representing the current time instant (e.g., a CURRENT DATE in DB2 <ref> [13] </ref>). This transformation removes all temporal attributes and thus the original SQL query is evaluated on the current snapshot of the database. Sequenced Queries.
Reference: 14. <author> Jensen, C. S., Snodgrass, R. T., Soo, M. J. </author> <title> Unification of Temporal Data Models. </title> <booktitle> Proc. 9th Int. Conf. on Data Engineering, </booktitle> <pages> 262-271, </pages> <year> 1993. </year>
Reference-contexts: Therefore, tuples are associated with compact encodings of a set of time instants (often called period of validity). The sets of time instants are commonly stored using (finite sets of) intervals [17, 19], bitemporal elements <ref> [4, 14] </ref>, or other fixed-dimensional products of intervals (hyper-rectangles). <p> This fact, combined with the use of explicit interval-valued temporal attributes, leads directly to situations similar to Example 1. There are other reasons for including multiple temporal dimensions in a temporal database system, e.g., the need for representing both valid and transaction time <ref> [14] </ref>. However, we would like to emphasize at this point that the need for an unbounded number of temporal dimensions originates from the inherent properties of first-order queries alone, even if the temporal database and the results of the queries are single-dimensional.
Reference: 15. <author> Kanellakis, P. C., Kuper, G. M., Revesz, </author> <title> P.Z . Constraint Query Languages. </title> <journal> Journal of Computer and System Sciences 51(1) </journal> <pages> 26-52, </pages> <year> 1995. </year>
Reference-contexts: Therefore our proposal follows a different path that avoids all of the above problems: we let the temporal attributes in our language range over single time instants. The approach is based on several recent results in the area of temporal and constraint query languages <ref> [1, 15, 20, 21] </ref>. We also define a meaningful approach to duplicate semantics and aggregation that is independent of the particular encoding (building on the results in [10, 11]).
Reference: 16. <author> Ladkin, P. </author> <title> The Logic of Time Representation. </title> <type> PhD Dissertation, </type> <institution> University of California, Berkeley, </institution> <year> 1987. </year>
Reference-contexts: We would also like to note that a naive direct translation of time instants to singleton intervals <ref> [16] </ref> fails as an efficient query evaluation technique as it causes an exponential blowup in complexity. The rest of the chapter is organized as follows: Section 2 introduces the temporal data model: the abstract and concrete (interval-based) temporal databases (following the terminology introduced in [9]).
Reference: 17. <author> Snodgrass R. T. </author> <title> The Temporal Query Language TQuel. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 12(2) </volume> <pages> 247-298, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: Hence, there are dozens of mutually incompatible models and proposals. Many of them based on (often ad-hoc) extensions of existing relational languages, e.g., TQUEL <ref> [17] </ref> and various temporal extensions of SQL: TSQL2 [18], ATSQL2 [5], and SQL/Temporal [19], the current proposal of temporal extension of SQL3 to the ISO and ANSI standardization committees. <p> Therefore, tuples are associated with compact encodings of a set of time instants (often called period of validity). The sets of time instants are commonly stored using (finite sets of) intervals <ref> [17, 19] </ref>, bitemporal elements [4, 14], or other fixed-dimensional products of intervals (hyper-rectangles).
Reference: 18. <author> Snodgrass R.T. </author> <title> (editor). The TSQL2 Temporal Query Language. </title> <publisher> Kluwer Academic Publishers, </publisher> <address> 674+xxiv pages, </address> <year> 1995. </year>
Reference-contexts: Hence, there are dozens of mutually incompatible models and proposals. Many of them based on (often ad-hoc) extensions of existing relational languages, e.g., TQUEL [17] and various temporal extensions of SQL: TSQL2 <ref> [18] </ref>, ATSQL2 [5], and SQL/Temporal [19], the current proposal of temporal extension of SQL3 to the ISO and ANSI standardization committees. <p> In a single-dimensional case, the representation dependency problem can be successfully evaded using coalescing [6]. TSQL2's informal semantics (including many examples of queries in TSQL2) is implicitly based on this assumption <ref> [3, 18] </ref>. In the rest of this section we argue however, that the situation in Example 1 naturally arises during temporal query evaluation and cannot be avoided in general. First, we argue that a single temporal dimension is not sufficient to formulate general temporal queries. <p> Moreover, SQL/TP is complete in the sense of [8]. The results in [1, 21] show that this is not the case for any of the temporal query languages based on a fixed-dimensional temporal relational algebra, e.g., [7]; this issue is not clear for TSQL2-derived languages <ref> [5, 18, 19] </ref> because of the presence of explicit coercion operators that convert encoded temporal attributes to data attributes. The proposal can easily be extended to support migration requirements [19] for upward temporal compatibility with SQL. <p> Poland 1025 Poland 1794 Poland 1918 Poland 1938 Poland 1945 Czech Kingdom 1198 Czech Kingdom 1620 Czechoslovakia 1918 Czechoslovakia 1938 Czechoslovakia 1945 Czechoslovakia 1992 Czech Republic 1995 Slovakia 1940 Slovakia 1944 Slovakia 1993 We do not impose any restrictions on the number of temporal attributes in relations (unlike, e.g., TSQL2 <ref> [18] </ref>). Indeed, in general we may want to record relationships between different time instants as well as relationships between tuples of uninterpreted constants and a single time instant.
Reference: 19. <author> Snodgrass, R. T., Bohlen, M. H., Jensen C. S., Steiner, A. </author> <title> Adding Valid Time to SQL/Temporal, ISO/IEC JTC1/SC21/WG3 DBL MAD-146r2 21/11/96, (change proposal). </title>
Reference-contexts: Hence, there are dozens of mutually incompatible models and proposals. Many of them based on (often ad-hoc) extensions of existing relational languages, e.g., TQUEL [17] and various temporal extensions of SQL: TSQL2 [18], ATSQL2 [5], and SQL/Temporal <ref> [19] </ref>, the current proposal of temporal extension of SQL3 to the ISO and ANSI standardization committees. <p> Therefore, tuples are associated with compact encodings of a set of time instants (often called period of validity). The sets of time instants are commonly stored using (finite sets of) intervals <ref> [17, 19] </ref>, bitemporal elements [4, 14], or other fixed-dimensional products of intervals (hyper-rectangles). <p> The syntax of the chosen encoding then provides a domain of values for temporal attributes in the languages, e.g., pairs of interval endpoints (ATSQL [5] and SQL/Temporal <ref> [19] </ref> use the BEGIN and END keywords to extract the endpoints of intervals, PERIOD keyword to construct new interval timestamps, and Allen's interval algebra [2] operators to compare the timestamps). However, this is only possible if the user knows that the timestamps are encoded by intervals. <p> Moreover, SQL/TP is complete in the sense of [8]. The results in [1, 21] show that this is not the case for any of the temporal query languages based on a fixed-dimensional temporal relational algebra, e.g., [7]; this issue is not clear for TSQL2-derived languages <ref> [5, 18, 19] </ref> because of the presence of explicit coercion operators that convert encoded temporal attributes to data attributes. The proposal can easily be extended to support migration requirements [19] for upward temporal compatibility with SQL. <p> The proposal can easily be extended to support migration requirements <ref> [19] </ref> for upward temporal compatibility with SQL. While SQL/TP itself does not literally follow these requirements, the compatibility can be easily achieved using a very simple syntactic manipulation of the source queries and adding tags to distinguish the particular compatibility modes, cf. <p> The delete construction is more powerful than the SQL/92 version (as it handles duplication correctly). 3.5 Compatibility with SQL/92 To allow easy migration from SQL/92 to SQL/TP we follow <ref> [19] </ref> and introduce two compatibility modes that allow standard SQL queries to be evaluated over a temporal database: Temporal Upward Compatibility (TUC). The first level of compatibility treats standard SQL queries as queries operating with respect to the current time instant. <p> that we could extend SQL/TP with keywords to tag queries and to distinguish the compatibility 9 The query evaluation algorithm defined in Section 4 executes such queries efficiently with respect to the interval encoding, rather than by separate evaluation for every time instant. modes on the syntactic level (similarly to <ref> [19] </ref>). The tagging mechanism would guarantee a syntactic temporal upward compatibility, should it become necessary.
Reference: 20. <author> Toman, D. </author> <title> Point-based vs. Interval-based Temporal Query Languages Proc. </title> <booktitle> ACM PODS 1996, </booktitle> <pages> 58-67, </pages> <year> 1996. </year>
Reference-contexts: Therefore our proposal follows a different path that avoids all of the above problems: we let the temporal attributes in our language range over single time instants. The approach is based on several recent results in the area of temporal and constraint query languages <ref> [1, 15, 20, 21] </ref>. We also define a meaningful approach to duplicate semantics and aggregation that is independent of the particular encoding (building on the results in [10, 11]). <p> In the rest of this section we give a sketch of the SQL/TP to SQL/92 translation and is based on an extension of results in <ref> [20] </ref> to duplicate semantics and uses a nouveau normalization technique. 4.1 Data Definition Language The translation of the data definition language statements is fairly simple: we merely convert the abstract signature to its concrete counterpart. <p> All this is achieved while maintaining efficient query evaluation over temporal databases based on interval encoding of timestamps. We have also shown that all representation independent TSQL2 queries are expressible in SQL/TP (follows from <ref> [20] </ref>). Future Work. This proposal is only the first step towards the implementation of SQL/TP. There are still many open questions: Can we use more complex temporal domains? In our proposal we used a discrete linear order with a limited way of counting. <p> How do we perform updates efficiently? The area of updates presents a completely new set of problems, the main problem being the in-place updates of the encoded temporal relations. This problem goes hand in hand with defining various normal forms <ref> [6, 20] </ref> of temporal relations and enforcing them over updates 13 .
Reference: 21. <author> Toman, D., Niwinski, D. </author> <title> First-Order Temporal Queries Inexpressible in Temporal Logic Proc. </title> <editor> EDBT'96, Arpes, Bouzeghoub (eds.), </editor> <volume> LNCS 1057, </volume> <pages> 307-324, </pages> <year> 1996. </year>
Reference-contexts: First, we argue that a single temporal dimension is not sufficient to formulate general temporal queries. Consider the query "are there two distinct time instants when a given relation contains exactly the same tuples?" [1] and <ref> [21] </ref> have independently shown that this query cannot be formulated in first-order temporal logic. A direct corollary of this result is that this query cannot be expressed in any single-dimensional temporal relational algebra 2 . Moreover, [21] shows that to express all first-order queries the number of temporal dimensions cannot be <p> distinct time instants when a given relation contains exactly the same tuples?" [1] and <ref> [21] </ref> have independently shown that this query cannot be formulated in first-order temporal logic. A direct corollary of this result is that this query cannot be expressed in any single-dimensional temporal relational algebra 2 . Moreover, [21] shows that to express all first-order queries the number of temporal dimensions cannot be bounded by any constant. Therefore, multiple temporal dimensions cannot be avoided during the bottom-up evaluation of temporal queries even if the final result is a single-dimensional temporal relation or boolean. <p> Therefore our proposal follows a different path that avoids all of the above problems: we let the temporal attributes in our language range over single time instants. The approach is based on several recent results in the area of temporal and constraint query languages <ref> [1, 15, 20, 21] </ref>. We also define a meaningful approach to duplicate semantics and aggregation that is independent of the particular encoding (building on the results in [10, 11]). <p> This way we can build a SQL/TP front-end to an existing RDBMS and provide tem poral capabilities without modifying the underlying database system itself. - SQL/TP can express all representation independent SQL/Temporal queries. Moreover, SQL/TP is complete in the sense of [8]. The results in <ref> [1, 21] </ref> show that this is not the case for any of the temporal query languages based on a fixed-dimensional temporal relational algebra, e.g., [7]; this issue is not clear for TSQL2-derived languages [5, 18, 19] because of the presence of explicit coercion operators that convert encoded temporal attributes to data <p> We can also express queries shown not to be expressible in TRA [7], e.g., the query "is there a pair of distinct time instants, when exactly the same countries were independent?" <ref> [1, 21] </ref>. This is not possible in any temporal query language that assumes a fixed number of temporal dimensions in its data model. 3.3 Examples of Queries In this section we provide illustrative examples of SQL/TP queries. The examples are chosen to highlight the ease of formulating queries in SQL/TP. <p> The results in <ref> [1, 21] </ref> show that the two dimensionality is inherent to this query (this remains true even when we consider the existential closure of this query). 3.4 Database Updates Besides considering the query language, in a truly practical approach we also need to address updates of temporal relations.
Reference: 22. <author> Williams, H. P. </author> <title> Fourier-Motzkin Elimination Extension to Integer Programming Problems. </title> <journal> In Journal of Combinatorial Theory (A) 21, </journal> <pages> 118-123, </pages> <year> 1976. </year>
Reference-contexts: While the result of the translation can be defined using a SQL/92 query, we may decide to implement parts of it, e.g., the normalization operation; cf. Definition 15, natively to improve the efficiency of query evaluation. The translation also utilizes the quantifier elimination procedure for linear order <ref> [22] </ref> to replace references to individual time instants in the queries with references to interval endpoints.
Reference: 23. <author> Kabanza, F., Stevenne, J.-M., Wolper, P. </author> <title> Handling Infinite Temporal Data. </title> <journal> JCSS 51(1): </journal> <pages> 3-17, </pages> <year> 1995. </year>
Reference-contexts: While we mostly concentrate on efficient evaluation of temporal queries over an interval-based encoding of time, conforming to the above principles provides the basis for introducing additional ways to encode sets of time instants, e.g., the linear repeating points <ref> [23] </ref> for periodic events, without the need for new syntax and semantics. There are several other features of the proposal: - SQL/TP statements can be compiled to standard SQL/92 3 [12]; the translated queries can be evaluated using an off-shelf database system.
References-found: 23

