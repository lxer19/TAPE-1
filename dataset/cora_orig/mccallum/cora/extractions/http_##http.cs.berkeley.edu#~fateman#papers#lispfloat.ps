URL: http://http.cs.berkeley.edu/~fateman/papers/lispfloat.ps
Refering-URL: http://http.cs.berkeley.edu/~fateman/algebra.html
Root-URL: http://www.cs.berkeley.edu
Title: Fast Floating-Point Processing in Common Lisp  
Author: RICHARD J. FATEMAN KEVIN A. BROUGHAN and DIANE K. WILLCOCK DUANE RETTIG Franz Inc. 
Keyword: Categories and Subject Descriptors: G.4 [Mathematics of Computing]: Mathematical Software-efficiency, portability; D.3.4 [Programming Languages]: Processors-compilers, interpreters, optimization General terms: Common Lisp, Fortran, C, Floating-point arithmetic Additional Key Words and Phrases: Compiler optimization, Symbolic computation, Numerical algorithms  
Affiliation: University of California, Berkeley and  University of Waikato and  
Abstract: Lisp, one of the oldest higher-level programming languages [29] [21] has rarely been used for fast numerical (floating-point) computation. We explore the benefits of Common Lisp [35], an emerging new language standard with some excellent implementations, for numerical computation. We compare it to Fortran in terms of the speed of efficiency of generated code, as well as the structure and convenience of the language. There are a surprising number of advantages to Lisp, especially in cases where a mixture of symbolic and numeric processing is needed. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A. V. Aho, J. Hopcroft, J. D. Ullman, </author> <title> The Design and Analysis of Computer Algorithms, </title> <publisher> Addison-Wesley Publ. Co. </publisher> <year> 1974. </year>
Reference-contexts: In a 2-dimensional array of size m by n, using Lisp's zero-based array, the entries are laid out in memory in row-major order: a [0,0], a <ref> [0, 1] </ref>, ..., a [0,n-1], ... So if r is the address of a [0; 0], and the "stride" of the array is s (for example 8 bytes if the array holds double-floats), then a [i; j] is stored at location r + s (i n + j). <p> Fortran's 1-based array has the entries laid out this way for an m by n array: a [1,1], a <ref> [2, 1] </ref>, ..., a [m,1], ... <p> Fortran's 1-based array has the entries laid out this way for an m by n array: a [1,1], a [2, 1], ..., a [m,1], ... So if r is the address of a <ref> [1; 1] </ref>, and the "stride" of the array is s then a [i; j] is stored at location r + s ((j 1) m + (i 1)) which can be re-written as r + s (j m + i) s (m + 1).
Reference: 2. <author> A. V. Aho, Ravi Sethi, J. D. Ullman, </author> <title> Compiler: Principles, Techniques, and Tools, </title> <publisher> Addison-Wesley Publ. Co. </publisher> <year> 1986. </year>
Reference-contexts: By hand coding we can remove one more instruction; whether this runs faster or not, and whether it should be unrolled <ref> [2] </ref> for speed, depends on the hardware in ways we are not prepared to explain here. 16 R. J. Fateman et al. The Lisp compiler generating the code does not use sophisticated techniques for floating-point, and in fact does no common subexpressions elimination. <p> Representations for x and for the location of the result (on the top of the floating-point stack) must be taken into account at the transition points between "normal" Lisp and numerically-oriented Lisp. More sophisticated translation can easily be constructed using techniques in many texts (e.g. <ref> [2] </ref>) on programming language compilation. 4.6 Register or other models In fact, one could argue that the Lisp compiler writers could very well directly compute a translation from delimited prefix arithmetic notation (that is, normal Lisp) to a conventional n-register model, and thus the intermediate description in the previous section is <p> Ironically, Lisp is an especially well-suited language for developing and specifying such tools: an intermediate form for a Fortran program as it is compiled is likely to look very much like Lisp! [18] <ref> [2] </ref>. <p> Fortran's 1-based array has the entries laid out this way for an m by n array: a [1,1], a <ref> [2, 1] </ref>, ..., a [m,1], ... <p> Let us start with a Fortran-based loop that looks like DO 10 I=1,M 10 A (I, J) = 0.0D0 We insist that there be no branches to statement 10 and all access is from coming through the "top" (the compiler terminology is that this is a basic block <ref> [2] </ref>). Pre Fast Floating-Point Processing in Common Lisp 21 sumably the Fortran language standard allows jumps into this loop (perhaps after re-setting i and j), but it would certainly be poor programming practice to write a program to do so. <p> How can we speed this up? There are standard ideas from compiler optimization <ref> [2] </ref> that can be applied. For a starter, let's pre-compute the invariant quantity mnp1= -(n+1).
Reference: 3. <editor> Allegro CL Users Guide, Release 4.0, </editor> <publisher> Franz Inc, </publisher> <address> Berkeley CA, </address> <year> 1991. </year>
Reference-contexts: The function clear-a, imposing a 1-D access model on a 2-D array can be compared with the best direct 2-D array version, which we show as the function clear-aa below. The times on a SPARC1+ in Allegro 4.1 <ref> [3] </ref> to clear a 100 by 100 array are 8.5 ms by the 1-D method; 29.5 in the normal 2-D code.
Reference: 4. <author> E. Anderson, Z. Bai, C. Bischof, J. Demmel, J. Dongarra, J. Du Croz, A. Greenbaum, S. Hammarling, A. McKenney, S. Ostrouchov, and D. Sorensen, </author> <note> LAPACK Users' Guide, Release 1.0, SIAM, </note> <year> 1992. </year>
Reference-contexts: An important point we wish to emphasize is the use of higher level targets like the poly-eval macro illustrated earlier, a scalar-product array primitive (see below), or canned BLAS <ref> [4] </ref> which form the core building blocks for portable high-speed reliable linear algebra programs. By appropriately re-defining the BLAS in machine-dependent fashion, a large percentage of the vector and parallel speedups possible in parallel machines can be exploited, while still using the same "top-level" subprograms. <p> these organizations, it is possible that they could further narrow the gap with the best Fortran. (Note, incidentally, that if you were really concerned with speed of multiplication of matrices as part of a larger calculation, you might be better off looking at a state-of-the art implementation of the BLAS <ref> [4] </ref> for your machine). This function is perhaps atypically small, and thus we consider a more complicated program, the singular value decomposition example below.
Reference: 5. <author> Henry G. Baker. </author> <title> "The Nimble Type Inferencer for Common Lisp-84" Nimble Computer Corp. </title> <address> Encino, CA. </address> <note> 1990 (submitted for publication). </note>
Reference-contexts: H. Baker claims, "The polymorphic type complexity of the Common Lisp library functions is mostly gratuitous, and both the efficiency of compiled code and the efficiency of the programmer could be increased by rationalizing this complexity." <ref> [5] </ref> For example the type of the result of the some functions (e.g. sqrt or log) cannot be computed based solely on the type of argument. One must know something about the value: a negative argument to sqrt will result in a complex number. <p> To solve some of the problem Baker identifies, one can also use overloading, as distinct from polymorphism, and demand that the compiler be sufficiently clever. As an example, consider this example from Baker <ref> [5] </ref> (defun asinh (z) (typecase z (single-float (log (+ z (sqrt (1+ (* z z)))))) (double-float (log (+ z (sqrt (1+ (* z z)))))) ((complex single-float) (log (+ z (sqrt (1+ (* z z)))))) ;; etc ... where each of the apparently identical "arms" of the typecase are compiled quite differently
Reference: 6. <author> R. F. Boisvert, S. E. Howe, and D. K. Kahaner, </author> <title> GAMS a framework for the management of scientific software, </title> <journal> ACM Trans. Math. Soft., </journal> <volume> 11 (1985), </volume> <pages> pp. 313-355. </pages>
Reference-contexts: We expect to continue to refine the tool. The principle reason for writing f2cl is to demonstrate that with reasonable ease we can make effective use of algorithmic content of the large body of existing numeric code, mostly written in Fortran <ref> [6] </ref>, within Lisp-based environments. This should weaken one argument in favor of continuing to use Fortran, regardless of its suitability for new code, that there is too high a value in the large body of existing code already written in Fortran to switch.
Reference: 7. <author> K. A. Broughan, </author> <title> The SENAC Manual, </title> <type> Vols 1, </type> <institution> 2 and 3, University of London, </institution> <address> London, </address> <year> 1990. </year>
Reference-contexts: Some recent work includes work by Wirth [39], Lanam [25], Wang [36], Broughan <ref> [7] </ref>, Cook [19], and Kajler [23]). As a principal example of the approach of linking Lisp programs with numerics, consider the development of symbolic-numeric algorithms for the Senac environment, under way at the University of Waikato (New Zealand) Mathematical Software Project. <p> Using both of these methods, the Waikato group has written a number of interfaces. Naglink: [13, 14, 15] was written between Macsyma [28] and the NAG Library [22]; Numlink: [8, 10, 11, 12] between Senac and Graflink <ref> [7] </ref> and the NAG Fortran Library and Graphics Library. These references describe how components have been integrated to provide a very highly automated problem-solving environment, combining symbolic, numeric and graphic tools. <p> A FORTRAN TO LISP TRANSLATION TOOL 6.1 Motivation A rapid prototyping tool f2cl was written in Lisp to assist in the development of a form of Numerical Recipes [33] in Lisp (Lispack) as a prelude to its inclusion in a numerical library for Senac (Senpack) <ref> [7] </ref>. F2cl produces an automatic derivation of an equivalent prototype Lisp code for a Fortran program.
Reference: 8. <author> K. A. Broughan, </author> <title> Interactive access to subroutine libraries: an interlink for SENAC, </title> <booktitle> in Proceedings of the International Conference on Computational Techniques and Applications, </booktitle> <editor> CTAC-89, J. Horvath ed, Hemisphere, </editor> <address> Washington 1990, </address> <pages> pp. 145-151. </pages>
Reference-contexts: Using both of these methods, the Waikato group has written a number of interfaces. Naglink: [13, 14, 15] was written between Macsyma [28] and the NAG Library [22]; Numlink: <ref> [8, 10, 11, 12] </ref> between Senac and Graflink [7] and the NAG Fortran Library and Graphics Library. These references describe how components have been integrated to provide a very highly automated problem-solving environment, combining symbolic, numeric and graphic tools.
Reference: 9. <author> K. A. Broughan, G. Keady, T. D. Robb, M. G. Richardson and M. C. </author> <title> Dewar Some Symbolic Computing Links to the NAG Numeric Library, </title> <journal> SIGSAM Bulletin, </journal> <volume> 3/25 (1991), </volume> <pages> pp. 28-37. </pages>
Reference: 10. <author> K. A. Broughan, </author> <title> SENAC: a high level interface for the NAG Library, </title> <journal> ACM Trans. Math. Soft., </journal> <volume> 17 (1991), </volume> <pages> pp. 462-480. </pages>
Reference-contexts: Using both of these methods, the Waikato group has written a number of interfaces. Naglink: [13, 14, 15] was written between Macsyma [28] and the NAG Library [22]; Numlink: <ref> [8, 10, 11, 12] </ref> between Senac and Graflink [7] and the NAG Fortran Library and Graphics Library. These references describe how components have been integrated to provide a very highly automated problem-solving environment, combining symbolic, numeric and graphic tools.
Reference: 11. <author> K. A. Broughan, </author> <title> SENAC: Lisp as a platform for constructing a problem solving environment, in Programming Environments for High-level Scientific Problem solving, </title> <editor> P. W. Gaffney and E. N. Houstis (Eds), North-Holland/IFIP, </editor> <year> 1992, </year> <pages> pp. 351-359. </pages>
Reference-contexts: Using both of these methods, the Waikato group has written a number of interfaces. Naglink: [13, 14, 15] was written between Macsyma [28] and the NAG Library [22]; Numlink: <ref> [8, 10, 11, 12] </ref> between Senac and Graflink [7] and the NAG Fortran Library and Graphics Library. These references describe how components have been integrated to provide a very highly automated problem-solving environment, combining symbolic, numeric and graphic tools.
Reference: 12. <author> K. A. Broughan and G. Keady, Numlink and Naglink: </author> <title> links to the NAG library from SENAC and Macsyma, Proceedings on the Interface between Symbolic and Numeric Computing, </title> <publisher> Helsinki, </publisher> <year> 1991, </year> <type> Helsinki University Technical Report, </type> <pages> pp. 19-34. </pages>
Reference-contexts: Using both of these methods, the Waikato group has written a number of interfaces. Naglink: [13, 14, 15] was written between Macsyma [28] and the NAG Library [22]; Numlink: <ref> [8, 10, 11, 12] </ref> between Senac and Graflink [7] and the NAG Fortran Library and Graphics Library. These references describe how components have been integrated to provide a very highly automated problem-solving environment, combining symbolic, numeric and graphic tools.
Reference: 13. <author> K. A. Broughan, </author> <booktitle> Naglink a working symbolic/numeric interface in IFIP TC2/W.G.2.5 Working Conference on Problem solving Environments for Scientific Computing, </booktitle> <editor> B. Ford and F. chatelin Eds., </editor> <publisher> Elsevier, </publisher> <address> Amsterdam, </address> <year> 1987, </year> <pages> pp. 343-350. </pages>
Reference-contexts: Using both of these methods, the Waikato group has written a number of interfaces. Naglink: <ref> [13, 14, 15] </ref> was written between Macsyma [28] and the NAG Library [22]; Numlink: [8, 10, 11, 12] between Senac and Graflink [7] and the NAG Fortran Library and Graphics Library.
Reference: 14. <author> K. A. Broughan, </author> <title> The Naglink Manual An interface between MACSYMA and NAG, </title> <type> Version 1.0, </type> <institution> Development Finance Corporation of New Zealand, </institution> <year> 1985. </year>
Reference-contexts: Using both of these methods, the Waikato group has written a number of interfaces. Naglink: <ref> [13, 14, 15] </ref> was written between Macsyma [28] and the NAG Library [22]; Numlink: [8, 10, 11, 12] between Senac and Graflink [7] and the NAG Fortran Library and Graphics Library.
Reference: 15. <author> K. A. Broughan, </author> <title> A symbolic numeric interface for the NAG Library, Newsletter of the Numerical Algorithms Group, </title> <month> August </month> <year> 1986, </year> <pages> pp. 16-24. </pages>
Reference-contexts: Using both of these methods, the Waikato group has written a number of interfaces. Naglink: <ref> [13, 14, 15] </ref> was written between Macsyma [28] and the NAG Library [22]; Numlink: [8, 10, 11, 12] between Senac and Graflink [7] and the NAG Fortran Library and Graphics Library.
Reference: 16. <author> W. C. Schou and K. A. Broughan, </author> <title> The Risch algorithms of Macsyma and SENAC, </title> <journal> SIGSAM Bulletin, </journal> <volume> 23 (1989), </volume> <pages> pp. 19-22. </pages>
Reference: 17. <author> D. S. Burnett, </author> <title> Finite Element Analysis, </title> <publisher> Addison-Wesley, </publisher> <address> Reading MA, </address> <year> 1988. </year>
Reference-contexts: Numerical Recipes has about 10. We have come across code where common blocks are used uniformly to pass data between subroutines, bypassing the normal, safer mechanism (e.g. UNAFEM <ref> [17] </ref>). The cases where named common blocks are used with different substructure and names within different subprograms are, in our experience, quite rare. As indicated in section 2 above, lexical closures or perhaps global data in packages are two appropriate mechanisms for functions to share data in Lisp.
Reference: 18. <author> S. I. Feldman. </author> <type> Personal Communication 8 March, </type> <year> 1993. </year> <title> (author of f77 compiler). </title>
Reference-contexts: Many of the loop optimizing and rewriting techniques developed for other languages can be applied to Lisp. Ironically, Lisp is an especially well-suited language for developing and specifying such tools: an intermediate form for a Fortran program as it is compiled is likely to look very much like Lisp! <ref> [18] </ref> [2].
Reference: 19. <author> Grant O. Cook, Jr., </author> <title> Code Generation in ALPAL using Symbolic Techniques, </title> <booktitle> in Proceedings of the International Symposium on Symbolic and Algebraic Computation, </booktitle> <year> 1992, </year> <editor> P. Wang Ed., </editor> <address> Berkeley CA, 1992, </address> <publisher> ACM, </publisher> <address> New York, </address> <pages> pp. 27-35. </pages>
Reference-contexts: Some recent work includes work by Wirth [39], Lanam [25], Wang [36], Broughan [7], Cook <ref> [19] </ref>, and Kajler [23]). As a principal example of the approach of linking Lisp programs with numerics, consider the development of symbolic-numeric algorithms for the Senac environment, under way at the University of Waikato (New Zealand) Mathematical Software Project.
Reference: 20. <author> J. K. Foderaro, K. L. Sklower, and K. </author> <title> Layer, The Franz Lisp Manual, </title> <institution> University of California, Berkeley CA, </institution> <year> 1983. </year>
Reference-contexts: While these experiments were modestly successful, the particular systems are obsolete. Fortunately, some of those ideas used in Maclisp [37], NIL [38] and Franz Lisp <ref> [20] </ref> were incorporated in the subsequent standardization of Common Lisp (CL) [35]. In this new setting it is appropriate to re-examine the theoretical and practical implications of writing numeric code in Lisp.
Reference: 21. <editor> J. K. Foderaro (editor), </editor> <booktitle> Special Section on Lisp: Communications of the ACM volume 34, </booktitle> <address> 9 Sept. </address> <year> 1991, </year> <pages> pp. 27-69. </pages>
Reference: 22. <author> B. Ford, </author> <title> Transportable Numerical Software, </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> vol. 142, </volume> <pages> pp. 128-140, </pages> <publisher> Springer-Verlag, </publisher> <year> 1982. </year>
Reference-contexts: Using both of these methods, the Waikato group has written a number of interfaces. Naglink: [13, 14, 15] was written between Macsyma [28] and the NAG Library <ref> [22] </ref>; Numlink: [8, 10, 11, 12] between Senac and Graflink [7] and the NAG Fortran Library and Graphics Library. These references describe how components have been integrated to provide a very highly automated problem-solving environment, combining symbolic, numeric and graphic tools.
Reference: 23. <author> N. Kajler, </author> <title> A Portable and Extensible Interface for Computer Algebra Systems, </title> <booktitle> in Proceedings of the International Symposium on Symbolic and Algebraic Computation, </booktitle> <year> 1992, </year> <editor> P. Wang Ed., </editor> <address> Berkeley CA, 1992, </address> <publisher> ACM New York, </publisher> <pages> pp. 376-386. </pages>
Reference-contexts: Some recent work includes work by Wirth [39], Lanam [25], Wang [36], Broughan [7], Cook [19], and Kajler <ref> [23] </ref>). As a principal example of the approach of linking Lisp programs with numerics, consider the development of symbolic-numeric algorithms for the Senac environment, under way at the University of Waikato (New Zealand) Mathematical Software Project.
Reference: 24. <author> D. E. Knuth, </author> <booktitle> The Art of Computer Programming: Vol. 2 2nd ed. </booktitle> <publisher> Addison-Wesley Publ. Co. </publisher> <year> 1981. </year> <note> 34 R. J. Fateman et al. </note>
Reference-contexts: As one example, if you have two independent units to evaluate polynomials, decomposing p (x) into p 1 (x 2 )+xp 0 (x 2 ) may save about half the computing time <ref> [24] </ref> | if you are just counting multiplications and additions. In an environment devoted to generating and making available top-quality software, implementation of alternative ideas like poly-eval or stable evaluation [30] could reside in a "symbolic computation optimization kernel" independent of the is possible. <p> In an environment devoted to generating and making available top-quality software, implementation of alternative ideas like poly-eval or stable evaluation [30] could reside in a "symbolic computation optimization kernel" independent of the is possible. In general, about n=2 + 2 multiplications and about n additions suffice (see Knuth <ref> [24] </ref> section 4.6.4 for a general discussion.) 5 Computing the pre-conditioned coefficients used in the macro-expansion can require substantial arithmetic; here we used the numerical solution of a cubic equation. Fast Floating-Point Processing in Common Lisp 13 language.
Reference: 25. <author> D. H. Lanam. </author> <title> An Algebraic Front-end for the Production and Use of Numeric Programs. </title> <booktitle> in Proc. of 1981 ACM Symp. on Symbolic and Algebraic Computation, </booktitle> <editor> P. Wang Ed,. </editor> <address> Snowbird, Utah. </address> <month> Aug. </month> <pages> 1981 pp. 223-227. </pages>
Reference-contexts: This last approach tends to be delicate; but several systems have been built around the use of symbolic systems to help code Fortran subroutines which are then fit into templates of other Fortran code to produce complete packages. Some recent work includes work by Wirth [39], Lanam <ref> [25] </ref>, Wang [36], Broughan [7], Cook [19], and Kajler [23]). As a principal example of the approach of linking Lisp programs with numerics, consider the development of symbolic-numeric algorithms for the Senac environment, under way at the University of Waikato (New Zealand) Mathematical Software Project.
Reference: 26. <author> C. L. Lawson, R. J. Hanson, D. Kincaid, and F. T. Krogh, </author> <title> Basic linear algebra subprograms for FORTRAN usage, </title> <journal> ACM Trans. Math. Soft. </journal> <volume> 5 (1979), </volume> <pages> pp. 308-323. </pages>
Reference-contexts: A number of other minor features are also not covered. We do not automatically handle the Fortran entry statement, used only once in Numerical Recipes, and in the NAG Library only in Chapter F06 devoted to NAG's implementation of the Basic Linear Algebra Routines (BLAS <ref> [26] </ref>), where the essentially trivial use of the statement is to set up aliases for subroutines names: F06AAF and DROTG for example, where the latter is the original BLAS name.
Reference: 27. <institution> Lucid Common Lisp/SUN Advanced User's Guide, Release 4.0, Lucid Inc, </institution> <address> Menlo Park CA, </address> <year> 1991. </year>
Reference: 28. <author> The Macsyma Reference Manual, </author> <type> Version 9, </type> <institution> Mathlab Group, Laboratory for Computer Science, MIT, </institution> <address> Cambridge MA, </address> <year> 1977. </year>
Reference-contexts: Using both of these methods, the Waikato group has written a number of interfaces. Naglink: [13, 14, 15] was written between Macsyma <ref> [28] </ref> and the NAG Library [22]; Numlink: [8, 10, 11, 12] between Senac and Graflink [7] and the NAG Fortran Library and Graphics Library. These references describe how components have been integrated to provide a very highly automated problem-solving environment, combining symbolic, numeric and graphic tools.
Reference: 29. <author> J. McCarthy, P. W. Abrahams, D. J. Edwards, P. A. Fox, T. P. Hart, and M. J. Levin, </author> <title> Lisp 1.5 Programmers Manual, </title> <publisher> MIT Press, </publisher> <year> 1962. </year>
Reference-contexts: We occasionally deal with issues (often misconceptions) about the earlier language design dating back to McCarthy <ref> [29] </ref>. Our objective is to examine the major reasons for and against numerical programming in Lisp. Fast Floating-Point Processing in Common Lisp 5 In comparing features of CL and "Fortran," it is important to realize that many programmers use implementations of Fortran 77 (or even Fortran 66 language standards).
Reference: 30. <author> C. Meszteny and C. Witzgall, </author> <title> "Stable Evaluation of Polynomials," </title> <journal> J. of Res. of the Nat'l Bur. of Stds.-B, 71B, </journal> <volume> no 1 (Jan., </volume> <pages> 1967) pp. 11-17. </pages>
Reference-contexts: If this particular pre-conditioned expression is unstable, there are other choices for pre-conditioning coefficients with different properties. There are alternative techniques known to evaluate a polynomial with "optimal" accuracy (e.g. Meszteny and Witsgall <ref> [30] </ref>), involving a kind of Taylor-series expansion of the polynomial about a zero near the interval of interest. <p> In an environment devoted to generating and making available top-quality software, implementation of alternative ideas like poly-eval or stable evaluation <ref> [30] </ref> could reside in a "symbolic computation optimization kernel" independent of the is possible.
Reference: 31. <author> R. E. Marsten, </author> <title> The design of the XMP linear programming library, </title> <journal> ACM Trans. Math. Soft. </journal> <volume> 7 (1981), </volume> <pages> pp. 481-497. </pages>
Reference-contexts: Another rarely used Fortran structure is the equivalence statement. This construction is used about 50 times in the NAG Library and once in Numerical Recipes. Some programs use the statement in an essential way (XMP <ref> [31] </ref> for example). The Common Lisp displaced-array enables these to be modeled effectively, although we have not chosen to automate this feature.
Reference: 32. <author> Robert A. MacLachlan, </author> <title> "The Python Compiler for CMU Common Lisp," </title> <booktitle> Proc. ACM Conf. on Lisp and Functional Programming, </booktitle> <month> Oct, </month> <year> 1992. </year> <note> See also CMU Common Lisp User's Manual, CMU-CS-91-108, or updates (1991). </note>
Reference-contexts: In the case of in-line expansion the CMU-CL <ref> [32] </ref> compiler can, given appropriate declarations, remove the type check as well as the dead code from the unused arms of the typecase.(See the appendix for further discussion). 3. MOTIVATION FOR NUMERICAL LISP We contend that Lisp features are useful for numerical programs specifically, as well as programming in general.
Reference: 33. <author> W. H. Press, B. P. Flannery, S. A. Teukolsky and W. T. Vetterling, </author> <title> Numerical Recipes (Fortran), </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge UK, </address> <year> 1989. </year>
Reference-contexts: CL code as produced by current compilers is really fairly good; c. Even more improved basic numeric capabilities can be incorporated in CL; d. Converting existing Fortran-like numeric code to Lisp can be automated; e. Numerical Recipes <ref> [33] </ref> or other numerical code libraries can be written in Lisp and may be viable alternatives to versions in Fortran or C. 2. <p> They also are excellent at indenting programs to show structure, whether the language is C, Fortran or Lisp. One rapidly becomes accustomed to seeing parentheses rather than the "begin-end" or "do-od" pairs of wordier languages. Here's an extract of Fortran from Numerical Recipes <ref> [33] </ref> (p. 178) computing an approximation to a Bessel function: ... DATA Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q8,Q9/0.39894228D0,-0.3988024D-1, * -0.362018D-2,0.163801D-2,-0.1031555D-1,0.2282967D-1, ... BESSI1=(EXP (AX)/SQRT (AX))*(Q1+Y*(Q2+Y*(Q3+Y*(Q4+ * Y*(Q5+Y*(Q6+Y*(Q7+Y*(Q8+Y*Q9)))))))) The assignment statement has 11 pairs of parentheses, and does not make easy reading. If there were an error in it, would you notice? 10 R. J. <p> program takes advantage of the SPARC cache architecture and multiplies matrices at more than twice the rate of the best Fortran to date. 5.3 Singular value decomposition The final extended example of our experiments with Fortran-like code is the singular value decomposition algorithm found (as Fortran code) in Numerical Recipes <ref> [33] </ref>. Numerical Recipes is the product of a collaboration among four scientists in academic research and industry. It comes in the form of a text on the "art" of scientific computing and numerical methods together with the source code for the programs described in the text on diskette. <p> This does not look advisable to us. 6. A FORTRAN TO LISP TRANSLATION TOOL 6.1 Motivation A rapid prototyping tool f2cl was written in Lisp to assist in the development of a form of Numerical Recipes <ref> [33] </ref> in Lisp (Lispack) as a prelude to its inclusion in a numerical library for Senac (Senpack) [7]. F2cl produces an automatic derivation of an equivalent prototype Lisp code for a Fortran program.
Reference: 34. <author> K. Stanley, </author> <title> private communication. </title>
Reference-contexts: Fast Floating-Point Processing in Common Lisp 25 Taking full advantage of locality requires substantial effort to tune the program to the memory characteristics of the architecture and its implementation. The final column is the time (estimated) taken by a highly tuned program written by Ken Stanley <ref> [34] </ref> using a combination of C and assembler. This program is based on partitioning the arrays into 2 fi 3 submatrices and multiplying these blocks.
Reference: 35. <author> Guy L. Steele, Jr., </author> <title> Common Lisp the Language, 2nd ed., </title> <publisher> Digital Press, </publisher> <year> 1990. </year>
Reference-contexts: While these experiments were modestly successful, the particular systems are obsolete. Fortunately, some of those ideas used in Maclisp [37], NIL [38] and Franz Lisp [20] were incorporated in the subsequent standardization of Common Lisp (CL) <ref> [35] </ref>. In this new setting it is appropriate to re-examine the theoretical and practical implications of writing numeric code in Lisp. The popular conceptions of Lisp's inefficiency for numerics have been based on rumor, supposition, and experience with early and (in fact) inefficient implementations. <p> Numerical Recipes [33] or other numerical code libraries can be written in Lisp and may be viable alternatives to versions in Fortran or C. 2. LANGUAGE FEATURES AND NUMERICAL PROGRAMMING 2.1 Introduction In this section we deal primarily with the Common Lisp (CL) language as described informally by Steele <ref> [35] </ref>, and the subject of a forthcoming language standard (the ANSI X3J13 committee). We occasionally deal with issues (often misconceptions) about the earlier language design dating back to McCarthy [29]. Our objective is to examine the major reasons for and against numerical programming in Lisp.
Reference: 36. <author> P. S. Wang, </author> <title> "FINGER: A Symbolic System for Automatic Generation of Numerical Programs in Finite Element Analysis," </title> <journal> J. Symbolic Computation, </journal> <volume> 2 (1986), </volume> <pages> pp. 305-316. </pages>
Reference-contexts: This last approach tends to be delicate; but several systems have been built around the use of symbolic systems to help code Fortran subroutines which are then fit into templates of other Fortran code to produce complete packages. Some recent work includes work by Wirth [39], Lanam [25], Wang <ref> [36] </ref>, Broughan [7], Cook [19], and Kajler [23]). As a principal example of the approach of linking Lisp programs with numerics, consider the development of symbolic-numeric algorithms for the Senac environment, under way at the University of Waikato (New Zealand) Mathematical Software Project.
Reference: 37. <author> Jon L White. </author> <title> Lisp: Program is Data: A historical perspective on MACLISP, </title> <booktitle> Proceedings of the 1977 MACSYMA Users' Conference, </booktitle> <institution> MIT Laboratory for Computer Science, </institution> <address> Cambridge, Mass, </address> <year> 1977. </year> <note> (published as NASA CP-2012) pp. 181-189. </note>
Reference-contexts: While these experiments were modestly successful, the particular systems are obsolete. Fortunately, some of those ideas used in Maclisp <ref> [37] </ref>, NIL [38] and Franz Lisp [20] were incorporated in the subsequent standardization of Common Lisp (CL) [35]. In this new setting it is appropriate to re-examine the theoretical and practical implications of writing numeric code in Lisp.
Reference: 38. <author> Jon L White. </author> <title> NIL: A Perspective, </title> <booktitle> Proceedings of the 1979 MACSYMA Users' Conference, </booktitle> <institution> MIT Laboratory for Computer Science, </institution> <address> Cambridge, Mass, </address> <year> 1979. </year>
Reference-contexts: While these experiments were modestly successful, the particular systems are obsolete. Fortunately, some of those ideas used in Maclisp [37], NIL <ref> [38] </ref> and Franz Lisp [20] were incorporated in the subsequent standardization of Common Lisp (CL) [35]. In this new setting it is appropriate to re-examine the theoretical and practical implications of writing numeric code in Lisp.
Reference: 39. <author> Michael C. Wirth. </author> <title> On the Automation of Computational Physics. </title> <type> PhD. </type> <institution> diss. Univ. Calif., Davis School of Applied Science, Lawrence Livermore Lab., </institution> <month> Sept. </month> <year> 1980. </year>
Reference-contexts: This last approach tends to be delicate; but several systems have been built around the use of symbolic systems to help code Fortran subroutines which are then fit into templates of other Fortran code to produce complete packages. Some recent work includes work by Wirth <ref> [39] </ref>, Lanam [25], Wang [36], Broughan [7], Cook [19], and Kajler [23]). As a principal example of the approach of linking Lisp programs with numerics, consider the development of symbolic-numeric algorithms for the Senac environment, under way at the University of Waikato (New Zealand) Mathematical Software Project.
References-found: 39

