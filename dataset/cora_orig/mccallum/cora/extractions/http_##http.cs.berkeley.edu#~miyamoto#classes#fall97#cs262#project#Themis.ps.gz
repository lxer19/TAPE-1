URL: http://http.cs.berkeley.edu/~miyamoto/classes/fall97/cs262/project/Themis.ps.gz
Refering-URL: http://http.cs.berkeley.edu/~miyamoto/classes/fall97/cs262/project/index.html
Root-URL: http://www.cs.berkeley.edu
Email: miyamoto,liblit-@CS.Berkeley.EDU  
Title: Themis: Enforcing Titanium Consistency on the NOW  
Author: Carleton Miyamoto and Ben Liblit 
Address: Berkeley  
Affiliation: Computer Science Division University of California at  
Pubnum: CS262 Semester Project Report  
Abstract: Titanium is a single program, multiple data (SPMD) programming language based on Java. Titanium defines a data consistency model equivalent to the Java specification. This consistency model calls for locally sequential consistency, with global consistency attained at synchronization points and arbitrary write reordering. The Titanium language is targeted at homogeneous multiprocessors on distributed memory architectures. Accesses to distant memory locations may result in communication over a network. The Themis system builds a Titanium-compliant consistency interface for Active Messages running on a NOW. This paper examines several methods for designing a Themis system that performs well for Titanium applications. Microbenchmark tests and a Conjugate Gradient Method test show the viability of each of these designs. One of the methods, a caching mechanism called OrderCache, displays promise for reducing communication loads and exploiting the locality of data within applications. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Remzi H. Arpaci, David E. Culler, Arvind Krishnamurthy, Steve G. Steinberg, and Katherine Yelick, </author> <title> Empirical Evaluation of the CRAY-T3D: A Compiler Perspective, </title> <booktitle> International Symposium on Computer Architecture, </booktitle> <address> Santa Margherita Ligure, Italy, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: The Stanford FLASH (with the SPLASH-2 benchmarks) and the MIT Alewife projects are attempting to address the cache coherence performance problems. Also, the Cray T3D uses a hardware version of a weakly consistent cache <ref> [1] </ref>. In the area of language design, Split-C [2] is a SPMD style programming language used in explicit communication programs. For Internet caches, a concept called BASE [10] was proposed to describe the weak consistency of these caches and how to deal with them.
Reference: [2] <author> E. Bugnion, J. Anderson, T. Mowry, M. Rosenblum, M. Lam, </author> <title> Compiler-Directed Page Coloring for Multiprocessors, </title> <booktitle> Proceedings of the Seventh International Symposium on Architectural Support for Programming Languages and Operating Systems (ASPLOS VII), </booktitle> <month> October, </month> <year> 1996. </year>
Reference-contexts: Stronger consistency models, though simpler to understand, may severely limit the optimizations that can take place, hampering performance [3]. A balance between the extremes should be reached. 1.1 The Java Consistency Model The Java consistency model is defined in the original Java language specification <ref> [2] </ref>. The model is described in terms of actions that may be executed by different parts of the system and the ordering that must be imposed on these actions. This paper interprets the model to be: 1. Locally sequentially consistent. <p> In the process, however, the original, easily understandable algorithm becomes clouded and hidden. To test the effectiveness of the OrderCache, a nave CG method on OrderCache was pitted against four different versions of CG running on the normal Split-C <ref> [2] </ref> Active Messages runtime (libsplit-c). A new version of the Split-C runtime (libOC-c) re-implemented certain calls to channel through the OrderCache. <p> Far fewer requests are sent, which greatly improves performance. 3.3.3 Ghost Nodes A common practice when hand optimizing these algorithms is to create ghost nodes <ref> [2] </ref>. A processor explicitly communicates with other processors early on in the computation to prefetch the values it needs for this round. These are then stored locally and the computation proceeds. This is the root cause of much of the added complexity in these codes. <p> Additionally, adopting a proactive posture in cache flushing could help to lessen the network burstiness currently experienced at synchronization events. Help from the compiler in the form of profiling and cache page coloring <ref> [2] </ref> could also boost the effectiveness of the cache. In addition, both would aid in the determination of optimal cache sizes under various conditions. When dealing with Clumps [14], networks of SMPs, the network problems become even worse as more processors are tied to fewer network interfaces. <p> The Stanford FLASH (with the SPLASH-2 benchmarks) and the MIT Alewife projects are attempting to address the cache coherence performance problems. Also, the Cray T3D uses a hardware version of a weakly consistent cache [1]. In the area of language design, Split-C <ref> [2] </ref> is a SPMD style programming language used in explicit communication programs. For Internet caches, a concept called BASE [10] was proposed to describe the weak consistency of these caches and how to deal with them. The Xerox-PARC Bayou project [2] proposed a weakly consistent database for mobile users, and the <p> In the area of language design, Split-C <ref> [2] </ref> is a SPMD style programming language used in explicit communication programs. For Internet caches, a concept called BASE [10] was proposed to describe the weak consistency of these caches and how to deal with them. The Xerox-PARC Bayou project [2] proposed a weakly consistent database for mobile users, and the Coda project [12] allows weak consistency in file systems. 6 Conclusions In a NOW, hardware support for consistency across processors is nonexistent.
Reference: [3] <author> David Chaiken, Anant Agarwal. </author> <title> Software-Extended Coherent Shared Memory: Performance and Cost, </title> <booktitle> Proceedings of the 21 st Annual Symposium on Computer Architecture, </booktitle> <pages> pages 314-324, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: Although this allows the systems to better optimize the communication and computation patterns [14], the programmer has a more difficult job in understanding the language. Stronger consistency models, though simpler to understand, may severely limit the optimizations that can take place, hampering performance <ref> [3] </ref>. A balance between the extremes should be reached. 1.1 The Java Consistency Model The Java consistency model is defined in the original Java language specification [2].
Reference: [4] <editor> David E. Culler, et al., </editor> <booktitle> Parallel Programming in Split-C, Supercomputing, </booktitle> <address> Portland, Oregon, </address> <month> November </month> <year> 1993. </year>
Reference: [5] <author> A. Demers, K. Petersen, M. Spreitzer, D. Terry, M. Theimer, B. Welch, </author> <title> The Bayou Architecture: Support for Data Sharing among Mobile Users, </title> <booktitle> 1994 Institute of Electrical and Electronics Engineers. Proceedings of the Workshop on Mobile Computing Systems and Applications, </booktitle> <address> Santa Cruz, California, December 1994, </address> <publisher> pages 2-7 (IEEE Computer Society Press). </publisher>
Reference: [6] <author> T. von Eicken, V. Avula, A. Basu, and V. </author> <title> Buch, Low-Latency Communication over ATM Networks using Active Messages, Presented at Hot Interconnects II, </title> <address> Aug 1994, Palo Alto, CA. </address> <note> An abridged version of this paper appears in IEEE Micro Magazine, </note> <month> Feb. </month> <year> 1995. </year>
Reference-contexts: The low reordering rate is likely the result of the use of Myrinet switches in the Berkeley NOW. Future deployments of Sequencer on other network hardware may allow us to explore this issue more deeply. Active Messages on ATM networks, for example, are known to have higher reordering rates <ref> [6] </ref>. One might also use randomized fault injection to artificially elevate the reordering rate on the current NOW network. 5 Related Work There has been a lot of work across disciplines on cache coherence and consistency related issues. These range from multiprocessor machines to file systems and the Internet.
Reference: [7] <author> A. Fox, S. Gribble, Y. Chawathe, E. Brewer, and P. Gauthier, </author> <title> Cluster-Based Scalable Network Services, </title> <address> SOSP-16, </address> <year> 1997. </year>
Reference: [8] <author> Douglas P. Ghormley, David Petrou, Steven H. Rodrigues, Amin M. Vahdat, Thomas E. Anderson., GLUnix: </author> <title> A Global Layer Unix for a Network of Workstations, </title> <note> to appear in Software Practice and Experience, </note> <year> 1997. </year>
Reference-contexts: All three schemes use the GLUnix 1.0a network operating system <ref> [8] </ref> on top of Solaris 2.5.1 to coordinate SMP execution across a network of workstations. Active Messages II release 3.1 provides the message exchange primitives. Both libraries and benchmarks were compiled using gcc 2.7.2.2 with aggressive optimization (-O3) enabled. All benchmarks were performed on the Berkeley NOW.
Reference: [9] <author> J Gosling, B. Joy, G. Steele, </author> <title> The Java Language Specification, Addison-Wesley, Copyright 1996 Sun Microsystems, </title> <publisher> Inc, </publisher> <year> 1996. </year>
Reference: [10] <institution> Information Sciences Institute, RFC-793: Transmission Control Protocol, Defense Advanced Research Projects Agency, </institution> <year> 1981. </year>
Reference-contexts: In order to enforce the consistency model, then, we must enforce ordered processing of network messages. Layering an ordered network upon an unordered one is a well-known challenge. For example, solving this problem was part of building TCP on top of IP <ref> [10] </ref>. In that case, the solution was to embed a sequence number within each packet. <p> These range from multiprocessor machines to file systems and the Internet. The C Region Library (CRL) showed that a high-performance software-only distributed shared memory system is viable <ref> [10] </ref>. The Stanford FLASH (with the SPLASH-2 benchmarks) and the MIT Alewife projects are attempting to address the cache coherence performance problems. Also, the Cray T3D uses a hardware version of a weakly consistent cache [1]. <p> Also, the Cray T3D uses a hardware version of a weakly consistent cache [1]. In the area of language design, Split-C [2] is a SPMD style programming language used in explicit communication programs. For Internet caches, a concept called BASE <ref> [10] </ref> was proposed to describe the weak consistency of these caches and how to deal with them.
Reference: [11] <author> K. Johnson, et al., </author> <title> CRL: High Performance All-Software Distributed Shared Memory, </title> <booktitle> SOSP 1995. </booktitle>
Reference: [12] <author> Kaashoek et al., </author> <title> Application Performance and Flexibility on Exokernel Systems, </title> <booktitle> SOSP, </booktitle> <year> 1997. </year>
Reference-contexts: Because the caching system is under software control, its use and its policies could ultimately be decided by the application itself, leading to better performance. This argument is similar in flavor to that of extensible operating systems, such as the Exokernel <ref> [12] </ref>. The Sequencer, although too strongly consistent for Titaniums needs, may yet prove useful in other language environments. A reordering rate of roughly one in two million compellingly justifies the deployment of a fast path for ordered messages. <p> For Internet caches, a concept called BASE [10] was proposed to describe the weak consistency of these caches and how to deal with them. The Xerox-PARC Bayou project [2] proposed a weakly consistent database for mobile users, and the Coda project <ref> [12] </ref> allows weak consistency in file systems. 6 Conclusions In a NOW, hardware support for consistency across processors is nonexistent. Under these conditions, building strong consistency becomes very expensive, especially when communication costs are much higher than local memory accesses.
Reference: [13] <author> J.J. Kistler, M. Satyanarayanan, </author> <title> Disconnected Operation in the Coda File System, </title> <journal> ACM Transactions on Computer Systems Feb. 1992, </journal> <volume> Vol. 10, No. 1, </volume> <pages> pp. 3-25. </pages>
Reference: [14] <author> S. Lumetta, A. Mainwaring, D. Culler. </author> <title> Multi-Protocol Active Messages on a Cluster of SMPs. </title> <booktitle> Proceedings of SC97, </booktitle> <address> San Jose, California, </address> <month> November </month> <year> 1997. </year>
Reference-contexts: A consistency model describes the parts of a program that a compiler or runtime system may reorder to optimize performance or for convenience. Weak consistency models, such as the Java model, allow great flexibility in reordering. Although this allows the systems to better optimize the communication and computation patterns <ref> [14] </ref>, the programmer has a more difficult job in understanding the language. Stronger consistency models, though simpler to understand, may severely limit the optimizations that can take place, hampering performance [3]. <p> These systems actually appear often in many types of problems attacked by large parallel computers. Some examples are finite difference and finite element methods, which are used to solve problems in areas such as circuit and structural analysis <ref> [14] </ref>. The primary portion of the computation deals with a matrix-vector multiply. The multiply usually involves communication between processors to retrieve the matrix or vector components. A nave method could simply execute a standard multiply. Unfortunately, this often leads to poor performance due to network latency and congestion. <p> Help from the compiler in the form of profiling and cache page coloring [2] could also boost the effectiveness of the cache. In addition, both would aid in the determination of optimal cache sizes under various conditions. When dealing with Clumps <ref> [14] </ref>, networks of SMPs, the network problems become even worse as more processors are tied to fewer network interfaces. In this case, more aggressive caching and cache tuning would be necessary to alleviate these problems. It may be necessary to introduce additional multi-threaded support into the caching mechanisms.
Reference: [15] <author> A. Mainwaring. </author> <title> Active Message Application Programming Interface and Communication Subsystem Organization. </title> <institution> University of California at Berkeley, Computer Science Department, </institution> <type> Unpublished Manuscript, </type> <month> December </month> <year> 1995. </year>
Reference-contexts: This system has proven itself at handling and solving complex scientific problems. This combination, however, poses a few challenges to implementing an efficient system. For example, although AM-II is a reliable network delivery service, it does not make any guarantees about ordering <ref> [15] </ref>. Out-of-order packets must be handled by the higher level protocols. Doing so, however, may be tricky and require additional memory management or side stepping. This happens because of some of the assumptions (discussed later in this paper) made by AM-II. <p> The ordering of memory operations is equivalent to the ordering of network message delivery. The challenge in enforcing the Titanium consistency model stems from the fact that Active Messages does not guarantee ordered delivery. All messages will be delivered exactly once, but they may be reordered arbitrarily in transit <ref> [15] </ref>. If messages can be reordered, then memory operations can be reordered, and the consistency model breaks down. In order to enforce the consistency model, then, we must enforce ordered processing of network messages. Layering an ordered network upon an unordered one is a well-known challenge.
Reference: [16] <author> Vijay S. Pai, Parthasarathy Ranganathan, Sarita V. Adve and Tracy Harton, </author> <title> An Evaluation of Memory Consistency Models for Shared-Memory Systems with ILP Processors, </title> <booktitle> ASPLOS VII, </booktitle> <year> 1996. </year>
Reference: [17] <author> J. Shewchuk, </author> <title> An Introduction to the Conjugate Gradient Method Without the Agonizing Pain, </title> <type> CMU-CS 94-125, </type> <institution> Carnegie Mellon University, </institution> <year> 1994. </year>
References-found: 17

