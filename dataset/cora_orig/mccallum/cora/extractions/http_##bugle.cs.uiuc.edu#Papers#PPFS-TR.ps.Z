URL: http://bugle.cs.uiuc.edu/Papers/PPFS-TR.ps.Z
Refering-URL: http://bugle.cs.uiuc.edu/Papers/PPFS-TR.html
Root-URL: http://www.cs.uiuc.edu
Title: PPFS: A High Performance Portable Parallel File System  
Author: James V. Huber, Jr. Christopher L. Elford Daniel A. Reed Andrew A. Chien David S. Blumenthal 
Address: Urbana, Illinois 61801  
Affiliation: Department of Computer Science University of Illinois  
Abstract: Rapid increases in processor performance over the past decade have outstripped performance improvements in input/output devices, increasing the importance of input/output performance to overall system performance. Further, the performance of input/output systems is extremely sensitive to data layout choices and data management policies, making good choices critical. To explore this vast design space, we have developed a user-level library, the Portable Parallel File System (PPFS), which supports rapid experimentation and exploration. The PPFS includes a rich application interface, allowing the application to advertise access patterns, control caching and prefetching, and even control data layout. PPFS is both extensible and portable, both of which should facilitate a wide range of experiments on a broad variety of platforms and configurations. Initial performance results on simple benchmarks and two application programs are reported.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Arendt, J. W. </author> <title> Parallel Genome Sequence Comparison Using an iPSC/2 with a Concurrent File System. </title> <type> Master's thesis, </type> <institution> University of Illinois at Urbana-Champaign, Department of Computer Science, </institution> <month> Jan. </month> <year> 1991. </year>
Reference-contexts: This approach is rooted in our earlier analysis of secondary and tertiary storage access patterns <ref> [1, 14] </ref>. No single access pattern predominates, wide variability exists, and system performance is extremely sensitive to small variations in access patterns [18]. 3 PPFS Design Principles The portable parallel file system (PPFS) is a tool for exploring the design space for parallel input/output systems. <p> The input/output behavior of the first of these, a parallel gene sequence matching code <ref> [1, 28] </ref>, is strongly data-dependent.
Reference: [2] <author> Aydt, R. A. SDDF: </author> <title> The Pablo Self-Describing Data Format. </title> <type> Tech. rep., </type> <institution> University of Illinois at Urbana-Champaign, Department of Computer Science, </institution> <month> Sept. </month> <year> 1993. </year>
Reference-contexts: When PPFS is used with parallel applications, we can capture similar input/output data from the application when it uses the vendor's native file system. Because all performance data is written in the Pablo self-defining data format (SDDF) <ref> [2] </ref>, extensive, off-line analysis and behavioral comparisons are possible via the Pablo performance analysis environment. 10 5 PPFS Examples In x4.1 we described the PPFS components from the system perspective. Here, we illustrate their use via two small example codes, shown in Figures 3 and 4.
Reference: [3] <author> Cabrera, L.-F., and Long, D. D. E. </author> <title> Exploiting multiple I/O streams to provide high data-rates. </title> <booktitle> In Proceedings of the 1991 Summer Usenix Conference (1991), </booktitle> <pages> pp. 31-48. </pages>
Reference-contexts: These provide data striping and a small set of parallel file access modes. In many cases, these access modes do not allow the application enough control to extract good performance from the input/output system. Distributed file systems, such as Zebra [11] and Swift <ref> [3] </ref>, stripe data over distributed input/output servers, but do not provide distribution or policy control to the application layer. Further, because the performance requirements in this environment are quite different (users are not as willing to tune for input/output performance), these systems provide little control to the application program.
Reference: [4] <author> Choudary, A., Bordawekar, R., Harry, M., Krishnaiyer, R., Ponnusamy, R., Singh, T., and Thakur, R. </author> <title> PASSION: Parallel And Scalable Software for Input-Output. </title> <type> Tech. rep., </type> <institution> Department of Electrical and Computer Engineering, Syracuse University, </institution> <month> Nov. </month> <year> 1994. </year>
Reference-contexts: Unlike PPFS, PIOUS enforces sequential consistency on file accesses to provide fault-tolerance on unreliable, distributed systems. In PPFS, because our primary focus is on parallel systems, data consistency can be controlled by the application, enabling higher performance in many cases. PASSION <ref> [4] </ref> is another user-level library that provides many of the features in PPFS. However, PASSION focuses on out-of-core problems and support for compiler-generated input/output operations, rather than multiple autonomous input/output streams. IBM's Vesta parallel file system [5] allows applications to define logical partitions, and some access information.
Reference: [5] <author> Corbett, P., and Feitelson, D. </author> <title> Design and implementation of the vesta parallel file system. </title> <booktitle> In Scalable High-Performance Computing Conference (May 1994), </booktitle> <pages> pp. 63-70. </pages>
Reference-contexts: PASSION [4] is another user-level library that provides many of the features in PPFS. However, PASSION focuses on out-of-core problems and support for compiler-generated input/output operations, rather than multiple autonomous input/output streams. IBM's Vesta parallel file system <ref> [5] </ref> allows applications to define logical partitions, and some access information. Applications can also exercise some control over the data distribution.
Reference: [6] <author> Elford, C. L., Kuszmaul, C., Huber, J., and Madhyastha, T. M. </author> <title> Design of a Portable Parallel File System. </title> <type> Tech. rep., </type> <institution> University of Illinois at Urbana-Champaign, Department of Computer Science, </institution> <month> Nov. </month> <year> 1993. </year>
Reference-contexts: We consider three perspectives: an application program, an input/output server, and an intermediate object in the system (neither client nor server). For a more detailed description of the file system, see <ref> [7, 6, 8] </ref>. 4.2.1 Application View Just as with vendor parallel file systems, application programs are linked with the PPFS library, forming a PPFS client.
Reference: [7] <author> Elford, C. L., Kuszmaul, C., Huber, J., and Madhyastha, T. M. </author> <title> Portable Parallel File System Detailed Design. </title> <type> Tech. rep., </type> <institution> University of Illinois at Urbana-Champaign, Department of Computer Science, </institution> <month> Nov. </month> <year> 1993. </year>
Reference-contexts: We consider three perspectives: an application program, an input/output server, and an intermediate object in the system (neither client nor server). For a more detailed description of the file system, see <ref> [7, 6, 8] </ref>. 4.2.1 Application View Just as with vendor parallel file systems, application programs are linked with the PPFS library, forming a PPFS client.
Reference: [8] <author> Elford, C. L., Kuszmaul, C., Huber, J., and Madhyastha, T. M. </author> <title> Scenarios for the Portable Parallel File System. </title> <type> Tech. rep., </type> <institution> University of Illinois at Urbana-Champaign, Department of Computer Science, </institution> <month> Nov. </month> <year> 1993. </year>
Reference-contexts: We consider three perspectives: an application program, an input/output server, and an intermediate object in the system (neither client nor server). For a more detailed description of the file system, see <ref> [7, 6, 8] </ref>. 4.2.1 Application View Just as with vendor parallel file systems, application programs are linked with the PPFS library, forming a PPFS client.
Reference: [9] <author> Ellis, C. S., and Kotz, D. </author> <title> Prefetching in file systems for MIMD multiprocessors. </title> <booktitle> In Proceedings of the 1989 International Conference on Parallel Processing (August 1989), </booktitle> <pages> pp. </pages> <month> I:306-314. </month>
Reference-contexts: Several groups have proposed schemes for exploiting access pattern information both in sequential and parallel systems [24, 15]. In [15], Kotz uses pattern predictors to anticipate an application's future access patterns. A variety of data management strategies for parallel input/output systems are explored in <ref> [17, 9, 16] </ref>. Acknowledgments Our thanks to Tara Madhyastha and Chris Kuszmaul for their early contributions to the design of PPFS. Some of the experimental data presented in this paper is derived from runs on the Intel Paragon at the CalTech Concurrent Supercomputing Facility. 25
Reference: [10] <author> French, J. C., Pratt, T. W., and Das, M. </author> <title> Performance measurement of the Concurrent File System of the Intel iPSC/2 hypercube. </title> <journal> Journal of Parallel and Distributed Computing 17, </journal> <note> 1-2 (January and February 1993), 115-121. </note>
Reference-contexts: This infrastructure is far more flexible than current vendor parallel systems; both Thinking Machines' SFS [19] and Intel's CFS/PFS <ref> [10, 13] </ref> support only a small number of access modes and an even smaller number of automatic file data distributions among the disks. <p> Applications can also exercise some control over the data distribution. Related work also includes a number of commercial parallel file systems | the CM-5 Scalable Parallel File System [19, 18], the Intel Concurrent File System <ref> [10] </ref> for the iPSC/2 and iPSC/860, and the Intel Paragon's Parallel File System [13]. These provide data striping and a small set of parallel file access modes. In many cases, these access modes do not allow the application enough control to extract good performance from the input/output system.
Reference: [11] <author> Hartman, J. H., and Ousterhout, J. K. </author> <title> Zebra: A striped network file system. </title> <booktitle> In Proceedings of the Usenix File Systems Workshop (May 1992), </booktitle> <pages> pp. 71-78. </pages>
Reference-contexts: These provide data striping and a small set of parallel file access modes. In many cases, these access modes do not allow the application enough control to extract good performance from the input/output system. Distributed file systems, such as Zebra <ref> [11] </ref> and Swift [3], stripe data over distributed input/output servers, but do not provide distribution or policy control to the application layer.
Reference: [12] <author> HPFF. </author> <title> High-Performance Fortran Language Specfication. </title> <type> Tech. rep., </type> <institution> High Performance Fortran Forum, </institution> <month> Nov. </month> <year> 1992. </year>
Reference-contexts: File distribution interfaces allow the application program to control the mapping of file data records onto input/output servers. The PPFS design supports a wide range of file distributions including HPF-style block and cyclic decompositions <ref> [12] </ref>, as well as a variety of striping and declustering alternatives. To provide complete flexibility, file distributions can also be described procedurally. Together, the file control interfaces of PPFS provide a wide range of information advertisement and policy control capabilities to the application.
Reference: [13] <institution> Intel Supercomputer Systems Division. Paragon XP/S Product Overview. Beaverton, Oregon, </institution> <month> Nov. </month> <year> 1991. </year>
Reference-contexts: In an effort to balance impressive peak processing rates with sufficient input/output bandwidth, most parallel systems support multiple, redundant arrays of inexpensive disks (RAIDs) <ref> [23, 13] </ref>. <p> This infrastructure is far more flexible than current vendor parallel systems; both Thinking Machines' SFS [19] and Intel's CFS/PFS <ref> [10, 13] </ref> support only a small number of access modes and an even smaller number of automatic file data distributions among the disks. <p> Applications can also exercise some control over the data distribution. Related work also includes a number of commercial parallel file systems | the CM-5 Scalable Parallel File System [19, 18], the Intel Concurrent File System [10] for the iPSC/2 and iPSC/860, and the Intel Paragon's Parallel File System <ref> [13] </ref>. These provide data striping and a small set of parallel file access modes. In many cases, these access modes do not allow the application enough control to extract good performance from the input/output system.
Reference: [14] <author> Jensen, D. W., and Reed, D. A. </author> <title> File Archive Activity in a Supercomputing Environment. </title> <booktitle> In Proceedings of the 1993 ACM International Conference on Supercomputing (July 1993). </booktitle> <pages> 26 </pages>
Reference-contexts: This approach is rooted in our earlier analysis of secondary and tertiary storage access patterns <ref> [1, 14] </ref>. No single access pattern predominates, wide variability exists, and system performance is extremely sensitive to small variations in access patterns [18]. 3 PPFS Design Principles The portable parallel file system (PPFS) is a tool for exploring the design space for parallel input/output systems.
Reference: [15] <author> Kotz, D. </author> <title> Disk-directed I/O for MIMD Multiprocessors. </title> <type> Tech. rep., </type> <institution> Department of Computer Science, Dartmouth College, </institution> <month> July </month> <year> 1994. </year>
Reference-contexts: Further, because the performance requirements in this environment are quite different (users are not as willing to tune for input/output performance), these systems provide little control to the application program. Several groups have proposed schemes for exploiting access pattern information both in sequential and parallel systems <ref> [24, 15] </ref>. In [15], Kotz uses pattern predictors to anticipate an application's future access patterns. A variety of data management strategies for parallel input/output systems are explored in [17, 9, 16]. Acknowledgments Our thanks to Tara Madhyastha and Chris Kuszmaul for their early contributions to the design of PPFS. <p> Further, because the performance requirements in this environment are quite different (users are not as willing to tune for input/output performance), these systems provide little control to the application program. Several groups have proposed schemes for exploiting access pattern information both in sequential and parallel systems [24, 15]. In <ref> [15] </ref>, Kotz uses pattern predictors to anticipate an application's future access patterns. A variety of data management strategies for parallel input/output systems are explored in [17, 9, 16]. Acknowledgments Our thanks to Tara Madhyastha and Chris Kuszmaul for their early contributions to the design of PPFS.
Reference: [16] <author> Kotz, D., and Ellis, C. S. </author> <title> Practical prefetching techniques for parallel file systems. </title> <booktitle> In Proceedings of the First International Conference on Parallel and Distributed Information Systems (December 1991), </booktitle> <pages> pp. 182-189. </pages>
Reference-contexts: Several groups have proposed schemes for exploiting access pattern information both in sequential and parallel systems [24, 15]. In [15], Kotz uses pattern predictors to anticipate an application's future access patterns. A variety of data management strategies for parallel input/output systems are explored in <ref> [17, 9, 16] </ref>. Acknowledgments Our thanks to Tara Madhyastha and Chris Kuszmaul for their early contributions to the design of PPFS. Some of the experimental data presented in this paper is derived from runs on the Intel Paragon at the CalTech Concurrent Supercomputing Facility. 25
Reference: [17] <author> Kotz, D., and Ellis, C. S. </author> <title> Caching and writeback policies in parallel file systems. </title> <journal> Journal of Parallel and Distributed Computing 17, </journal> <note> 1-2 (January and February 1993), 140-145. </note>
Reference-contexts: Several groups have proposed schemes for exploiting access pattern information both in sequential and parallel systems [24, 15]. In [15], Kotz uses pattern predictors to anticipate an application's future access patterns. A variety of data management strategies for parallel input/output systems are explored in <ref> [17, 9, 16] </ref>. Acknowledgments Our thanks to Tara Madhyastha and Chris Kuszmaul for their early contributions to the design of PPFS. Some of the experimental data presented in this paper is derived from runs on the Intel Paragon at the CalTech Concurrent Supercomputing Facility. 25
Reference: [18] <author> Kwan, T. T., and Reed, D. A. </author> <title> Performance of the CM-5 Scalable File System. </title> <booktitle> In Proceedings of the 1994 ACM International Conference on Supercomputing (July 1994). </booktitle>
Reference-contexts: This approach is rooted in our earlier analysis of secondary and tertiary storage access patterns [1, 14]. No single access pattern predominates, wide variability exists, and system performance is extremely sensitive to small variations in access patterns <ref> [18] </ref>. 3 PPFS Design Principles The portable parallel file system (PPFS) is a tool for exploring the design space for parallel input/output systems. To support experimentation and optimization of input/output performance, PPFS has an open application interface, and is portable across a number of parallel platforms. <p> IBM's Vesta parallel file system [5] allows applications to define logical partitions, and some access information. Applications can also exercise some control over the data distribution. Related work also includes a number of commercial parallel file systems | the CM-5 Scalable Parallel File System <ref> [19, 18] </ref>, the Intel Concurrent File System [10] for the iPSC/2 and iPSC/860, and the Intel Paragon's Parallel File System [13]. These provide data striping and a small set of parallel file access modes.
Reference: [19] <author> LoVerso, S. J., Isman, M., Nanopoulos, A., Nesheim, W., Milne, E. D., and Wheeler, R. sfs: </author> <title> A Parallel File System for the CM-5. </title> <booktitle> In Proceedings of the 1993 Summer Usenix Conference (1993), </booktitle> <pages> pp. 291-305. </pages>
Reference-contexts: This infrastructure is far more flexible than current vendor parallel systems; both Thinking Machines' SFS <ref> [19] </ref> and Intel's CFS/PFS [10, 13] support only a small number of access modes and an even smaller number of automatic file data distributions among the disks. <p> IBM's Vesta parallel file system [5] allows applications to define logical partitions, and some access information. Applications can also exercise some control over the data distribution. Related work also includes a number of commercial parallel file systems | the CM-5 Scalable Parallel File System <ref> [19, 18] </ref>, the Intel Concurrent File System [10] for the iPSC/2 and iPSC/860, and the Intel Paragon's Parallel File System [13]. These provide data striping and a small set of parallel file access modes.
Reference: [20] <author> Moyer, S. A., and Sundaram, V. S. </author> <title> PIOUS: A Scalable Parallel I/O System for Distributed Computing Environments. </title> <booktitle> In 1994 Scalable High Performance Computing Conference (May 1994), </booktitle> <pages> pp. 71-78. </pages>
Reference-contexts: The major distinguishing feature of PPFS is its rich interface that supports advertising a variety of access information as well as control and augmentation of input/output system policies. PIOUS (Parallel Input/OUtput System) <ref> [20] </ref> is a portable input/output system primarily for use with PVM. Unlike PPFS, PIOUS enforces sequential consistency on file accesses to provide fault-tolerance on unreliable, distributed systems.
Reference: [21] <author> MPI. </author> <title> MPI: A Message Passing Interface Standard. </title> <type> Tech. rep., Message Passing Interface Forum, </type> <month> May </month> <year> 1994. </year>
Reference-contexts: Unix, the sequential file system base, is a de facto standard. Similarly, the NXLIB message passing library provides Intel Paragon XP/S message passing semantics on a workstation network and compatibility with the native XP/S software environment; however, it can be easily replaced with other message passing substrates (e.g., MPI <ref> [21] </ref>). Finally, C ++ has allowed us to isolate implementation details in objects and to inherit implementation features when porting the software to new environments.
Reference: [22] <author> Needleman, S. B., and Wunsch, C. D. </author> <title> An Efficient Method Applicable to the Search for Similarities in the Amino Acid Sequences of Two Proteins. </title> <journal> Journal of Molecular Biology 48 (1970), </journal> <pages> 444-453. </pages>
Reference-contexts: One approximate sequence matching approach is based on a generalization of the Needleman, Wunsch, and Sellers (NWS) <ref> [22] </ref> dynamic programming algorithm, with a K-tuple heuristic to improve performance. 4 The NWS algorithm uses dynamic programming to determine the minimum set of changes needed to bring two (presumably) related sequences into alignment.
Reference: [23] <author> Patterson, D., Gibson, G., and Katz, R. </author> <title> A Case For Redundant Arrays of Inexpensive Disks (RAID). </title> <booktitle> In Proceedings of ACM SIGMOD (December 1988), </booktitle> <pages> pp. 109-116. </pages>
Reference-contexts: In an effort to balance impressive peak processing rates with sufficient input/output bandwidth, most parallel systems support multiple, redundant arrays of inexpensive disks (RAIDs) <ref> [23, 13] </ref>.
Reference: [24] <author> Patterson, D., Gibson, G., and Satyanarayanan, M. </author> <title> A Status Report on Research in Transparent Informed Prefetching. </title> <type> Tech. Rep. </type> <institution> CMU-CS-93-113, Department of Computer Science, Carnegie-Mellon University, </institution> <month> Feb. </month> <year> 1993. </year>
Reference-contexts: Further, because the performance requirements in this environment are quite different (users are not as willing to tune for input/output performance), these systems provide little control to the application program. Several groups have proposed schemes for exploiting access pattern information both in sequential and parallel systems <ref> [24, 15] </ref>. In [15], Kotz uses pattern predictors to anticipate an application's future access patterns. A variety of data management strategies for parallel input/output systems are explored in [17, 9, 16]. Acknowledgments Our thanks to Tara Madhyastha and Chris Kuszmaul for their early contributions to the design of PPFS.
Reference: [25] <author> Reed, D. A. </author> <title> Performance Instrumentation Techniques for Parallel Systems. In Models and Techniques for Performance Evaluation of Computer and Communications Systems, </title> <editor> L. Do-natiello and R. Nelson, Eds. </editor> <booktitle> Springer-Verlag Lecture Notes in Computer Science, </booktitle> <year> 1993. </year>
Reference-contexts: By inserting instrumentation in key software modules, one can obtain client and server cache hit ratios, cache utilizations, request counts, and access latencies. We have exploited our existing Pablo performance instrumentation and analysis suite <ref> [26, 25] </ref> to instrument PPFS. In addition to capturing client input/output requests and message passing among PPFS clients and servers, we also record the times, durations, and sizes of all input/output requests that PPFS servers generate for the underlying file system.
Reference: [26] <author> Reed, D. A. </author> <title> Experimental Performance Analysis of Parallel Systems: Techniques and Open Problems. </title> <booktitle> In Proceedings of the 7th International Conference on Modelling Techniques and Tools for Computer Performance Evaluation (May 1994). </booktitle>
Reference-contexts: By inserting instrumentation in key software modules, one can obtain client and server cache hit ratios, cache utilizations, request counts, and access latencies. We have exploited our existing Pablo performance instrumentation and analysis suite <ref> [26, 25] </ref> to instrument PPFS. In addition to capturing client input/output requests and message passing among PPFS clients and servers, we also record the times, durations, and sizes of all input/output requests that PPFS servers generate for the underlying file system.
Reference: [27] <author> Reed, D. A., Aydt, R. A., Noe, R. J., Roth, P. C., Shields, K. A., Schwartz, B. W., and Tavera, L. F. </author> <title> Scalable Performance Analysis: The Pablo Performance Analysis Environment. </title> <booktitle> In Proceedings of the Scalable Parallel Libraries Conference (1993), </booktitle> <editor> A. Skjellum, Ed., </editor> <publisher> IEEE Computer Society, </publisher> <pages> pp. 104-113. </pages>
Reference-contexts: For the latter, traces are taken from our portable input/output instrumentation <ref> [27, 28] </ref>. * Third, we are exploring distributed techniques for dynamically classifying file access patterns and automatically adapting data management algorithms to minimize access latencies for those patterns. This approach is rooted in our earlier analysis of secondary and tertiary storage access patterns [1, 14].
Reference: [28] <author> Shields, K., Tavera, L., Scullin, W. H., Elford, C. L., and Reed, D. A. </author> <title> Virtual Reality for Parallel Computer Systems Analysis. </title> <booktitle> In ACM SIGGRAPH '94 Visual Proceedings (July 1994), p. </booktitle> <volume> 261. </volume> <pages> 27 </pages>
Reference-contexts: For the latter, traces are taken from our portable input/output instrumentation <ref> [27, 28] </ref>. * Third, we are exploring distributed techniques for dynamically classifying file access patterns and automatically adapting data management algorithms to minimize access latencies for those patterns. This approach is rooted in our earlier analysis of secondary and tertiary storage access patterns [1, 14]. <p> The input/output behavior of the first of these, a parallel gene sequence matching code <ref> [1, 28] </ref>, is strongly data-dependent.
Reference: [29] <author> Stellner, G., Bode, A., Lamberts, S., and Ludwig, T. </author> <title> Developing Applications for Multicomputer Systems on Workstation Clusters. </title> <booktitle> In HPCN Europe, The International Conference and Exhibition on High-Performance Computing and Networking (1994). </booktitle>
Reference-contexts: Hence, the only system requirements to support a port of PPFS are: * an underlying Unix file system for each input/output node, 5 * a typed message passing library (currently NXLIB <ref> [29] </ref>), and * a C ++ language implementation. We view these porting requirements as minimal. Unix, the sequential file system base, is a de facto standard.
Reference: [30] <author> Wilbur, W. J., and Lipman, D. J. </author> <title> Rapid Similarity Searches of Nucleic Acid and Protein Data Banks. </title> <booktitle> In Proceedings of the National Academy of Sciences (1983), </booktitle> <volume> vol. 80, </volume> <pages> pp. 726-730. </pages>
Reference-contexts: Because genetic sequences can contain thousands of elements, the quadratic complexity of the NWS algorithm can make string comparison costs prohibitive. To reduce comparison time, a K-tuple heuristic <ref> [30] </ref> is used initially to prune the search space by determining the most likely set of elements in each sequence whose comparison would give the best score for overall sequence comparison.
Reference: [31] <author> Winstead, C., and McKoy, V. </author> <title> Studies of Electron-Molecule Collisions on Massively Parallel Computers. In Modern Electronic Structure Theory, </title> <editor> D. R. Yarkony, Ed., </editor> <volume> vol. 2. </volume> <publisher> World Scientific, </publisher> <year> 1994. </year> <month> 28 </month>
Reference-contexts: The input/output behavior of the first of these, a parallel gene sequence matching code [1, 28], is strongly data-dependent. The second, a low temperature plasma electron scattering code <ref> [31] </ref>, has more regular spatial and temporal input/output patterns. 15 One I/O Node Two I/O Nodes Sixteen I/O Nodes (a) Reads (b) Writes 16 One I/O Node Two I/O Nodes Sixteen I/O Nodes (a) Reads (b) Writes 17 7.1 Gene Sequence Matching Because the synthesis methods currently used to determine genetic <p> Despite plasma processing's economic importance to the semiconductor industry, at present there are no simple techniques for its optimization. Instead, current engineering practice is often ad hoc. One alternative to current, ad hoc practice is the computation of plasma behavior from first principles <ref> [31] </ref>. Such computations predict the rates for surface reactions and the probabilities, or cross sections, for collision processes in the plasma. A quantum-mechanical approach, based on the Lippmann-Schwinger equation, can provide the requisite predictions, albeit at great computational expense.
References-found: 31

