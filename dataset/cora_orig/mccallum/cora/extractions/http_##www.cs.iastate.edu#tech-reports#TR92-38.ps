URL: http://www.cs.iastate.edu/tech-reports/TR92-38.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: http://www.cs.iastate.edu
Title: Icon: An Interpreter-Based Approach  
Author: TR - Dong Wei 
Address: 226 Atanasoff Ames, IA 50011  
Affiliation: Iowa State University of Science and Technology Department of Computer Science  
Date: December 3, 1992  
Abstract-found: 0
Intro-found: 1
Reference: 1. <author> Tim Budd, </author> <title> the Kamin Interpreters in C++ (report and programs), </title> <note> anonymous ftp from cs.orst.edu, directory pub/budd/kamin. </note>
Reference-contexts: Since the Icon interpreter reuses considerable code from the Lisp interpreter, this section focuses primarily on the implementation of generators and goal-directed evaluation in the Icon interpreter. See references <ref> [1] </ref> and [4] for background discussions of the Lisp interpreter implementation. 3.1 Declaration Generators and goal-directed evaluation pose special difficulties to the implementor. The internal state of a generator must be saved between the time the generator produces a result and the time it is resumed to produce alternative results. <p> It first evaluates the arguments, using the simple recursive routine evalArgs, and then invokes 14 the function applyWithArgs, which applies the operation to the arguments, assigning the result to target. More details can be found in reference <ref> [1] </ref>. 3.3 Backtracking and the Resume Function Each class of operation has a corresponding resume function. If the operation is resumed, the resume function for it is called. In our version of Icon, when a comparison operation fails, control backtracking occurs and the resume function for binary operations is invoked. <p> Therefore, the pseudo code of the applyWithArgs function for the integer comparison operations is as follows (the applyWithArgs function for the string comparison operations is similar): /* target is the result produced by the operation; args is the argument list; args [0] and args <ref> [1] </ref> stand for the first and second argument; args [0].h and args [1].h are the values of the arguments; args [0].oldh and args [1].oldh point to the unevaluated expressions representing the arguments; environment maintains the symbol-value pairs, such as the values of arguments passed to a function */ BooleanBinaryFunction::applyWithArgs (target, args, <p> Otherwise, the first argument is resumed. If it succeeds, the whole second argument is reevaluated, and finally the operation is applied to the arguments. The operation fails if none of its two arguments can produce alternative results. BinaryFunction::resume (target, args, environment) - if args <ref> [1] </ref> can be resumed - resume it; if a new value returned - assign it to args [1].h; applyWithArgs (target, args, environment); return; 17 - if args [0] can be resumed - resume it; if a new value returned - assign it to args [0].h; evaluate args [1]; applyWithArgs (target, args, <p> - if args <ref> [1] </ref> can be resumed - resume it; if a new value returned - assign it to args [1].h; applyWithArgs (target, args, environment); return; 17 - if args [0] can be resumed - resume it; if a new value returned - assign it to args [0].h; evaluate args [1]; applyWithArgs (target, args, environment); return; - target = failure; /* fails */ - 3.5 Resume Functions for Generators The resume functions for generators are tricky, since the expressions representing the arguments of a generator can be generators.
Reference: 2. <author> Ralph E. Griswold and Madge T. Griswold, </author> <title> The Icon Programming Language, </title> <publisher> Prentice-Hall, Inc., </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1983. </year>
Reference-contexts: failure) or (args [1].h == failure) - BinaryFunction::resume (target, args, environment); return; - if (args [0].h or args [1].h is not integer) - target = error ("noninteger args") return; 18 - if (args [0].h &lt;= args [1].h) - create a new node and append it to args list as args <ref> [2] </ref>; args [2].h = args [0].h; /* The new node is needed in order to correctly handle nested generator expressions, e.g., (to 1 (| 3 5)). */ target = value of args [0].h; args [0].h = args [0].h + 1; - else resume (target, args, environment); - To::resume (target, args, environment) <p> An empty list can be produced by [ ] or list (0). An element of a list is referenced by a subscripting expression, and a list value is a pointer to a structure that contains the elements of the list. For example, states := ["Iowa", "Texas", "Michigan"] states <ref> [2] </ref> := "Kansas" alist := states alist [3] := "Georgia" results in states and alist both pointing to the list ["Iowa", "Kansas", "Geor-gia"]. The values in a list may be of any types. For example, x := ["*", ["a"], ["+", ["b"], [2]]] can be thought of as representing a tree in <p> For example, states := ["Iowa", "Texas", "Michigan"] states <ref> [2] </ref> := "Kansas" alist := states alist [3] := "Georgia" results in states and alist both pointing to the list ["Iowa", "Kansas", "Geor-gia"]. The values in a list may be of any types. For example, x := ["*", ["a"], ["+", ["b"], [2]]] can be thought of as representing a tree in which the first value in the list is associated with the position in the tree and subsequent values represent subtrees. Thus, x represents the parse tree of expression a fl (b + 2). Lists are not fixed in size.
Reference: 3. <author> Ralph E. Griswold and Madge T. Griswold, </author> <title> The Implementation of the Icon Programming Language, </title> <publisher> Princeton University Press, </publisher> <year> 1986. </year>
Reference-contexts: An element of a list is referenced by a subscripting expression, and a list value is a pointer to a structure that contains the elements of the list. For example, states := ["Iowa", "Texas", "Michigan"] states [2] := "Kansas" alist := states alist <ref> [3] </ref> := "Georgia" results in states and alist both pointing to the list ["Iowa", "Kansas", "Geor-gia"]. The values in a list may be of any types.
Reference: 4. <author> Samuel N. Kamin, </author> <title> Programming Languages: An Interpreter-Based Approach, </title> <publisher> Addison-Wesley, Inc., </publisher> <year> 1990. </year>
Reference-contexts: Since the Icon interpreter reuses considerable code from the Lisp interpreter, this section focuses primarily on the implementation of generators and goal-directed evaluation in the Icon interpreter. See references [1] and <ref> [4] </ref> for background discussions of the Lisp interpreter implementation. 3.1 Declaration Generators and goal-directed evaluation pose special difficulties to the implementor. The internal state of a generator must be saved between the time the generator produces a result and the time it is resumed to produce alternative results.
Reference: 5. <author> Janalee O'Bagy, </author> <title> The Implementation of Generators and Goal-Directed Evaluation in Icon, </title> <institution> The Univ. of Arizona Tech. </institution> <type> Rep. </type> <pages> 88-31, </pages> <year> 1988. </year>
Reference: 6. <author> Ira Pohl, </author> <title> C++ for C Programmers, </title> <publisher> Benjamin/Cummings Pub., </publisher> <year> 1989. </year>
Reference: 7. <author> Bjarne Stroustrup, </author> <title> The C++ Programming Language, Second Edition, </title> <publisher> Addison-Welsey, Inc., </publisher> <year> 1991. </year>
Reference: 8. <author> Stephen B. Wampler and Ralph E. Griswold, </author> <title> The Implementation of Generators and Goal-Directed Evaluation in Icon, </title> <journal> Software Practice and Experience 13, </journal> <month> 6 (June </month> <year> 1983), </year> <pages> 495-518. 29 </pages>
References-found: 8

