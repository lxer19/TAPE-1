URL: http://iamwww.unibe.ch/~rvswww/Publikationen/TechReports/iam-93-010.ps.gz
Refering-URL: http://iamwww.unibe.ch/~rvswww/Publikationen/index.html
Root-URL: 
Title: A Method for the Generation of Test Cases Based on SDL and MSCs  
Author: Jens Grabowski Dieter Hogrefe Robert Nahm 
Date: April 1993  
Address: Langgassstr. 51, CH-3012 Bern  
Affiliation: Institut fur Informatik, Universitat Bern  
Pubnum: IAM-93-010  
Abstract-found: 0
Intro-found: 1
Reference: [Bri87] <author> E. Brinksma. </author> <title> On the existence of canonical tests. </title> <type> Technical Report INF-87-5, </type> <institution> University of Twente, Niederlande, </institution> <year> 1987. </year>
Reference-contexts: The inputs and outputs of the system which can be observed by its environment are inverted. Inputs become outputs and vice versa. Brinksma <ref> [Bri87] </ref> uses this technique to define the canonical tester. 4 Traces and observables: A trace describes the ordering of events which are performed during a system run. A trace of an SDL description may include the events tasks, inputs, outputs, saves, etc. of its processes.
Reference: [BRP89] <author> Anne Bourget-Rouger and Combes Pierre. </author> <title> Exhaustive validation and test generation in Elvis. </title> <editor> In O. Faergemand and M.M. Marques, editors, SDL'89: </editor> <booktitle> The language at work, volume 4 of Proceedings of the fourth SDL Forum, </booktitle> <pages> pages 231-245. </pages> <publisher> North Holland, </publisher> <year> 1989. </year>
Reference-contexts: For simplification the PCOs are not mentioned within the test case descriptions (e.g. Figure 4 and 5), but it is assumed that each tester serves its own PCO. 3 which can send and receive any valid signal at any time 4 . A similar approach is used in <ref> [BRP89] </ref>. The system under test (SUT) consists of an Initiator implementation which is the implementation under test (IUT) and a Medium implementation which is assumed to work correct. We want to concentrate on testing a part of the retransmission property.
Reference: [BZ83] <author> Daniel Brand and Pitro Zafiropulo. </author> <title> On communicating finite state machines. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 30(2) </volume> <pages> 323-342, </pages> <month> April </month> <year> 1983. </year>
Reference-contexts: However, there can not exist test methods which guarantee behavioural equivalence for systems with an infinite state space. Even finite state machines which communicate by means of unbounded FIFO buffers (i.e. the base model of SDL) are as powerful as Turing Machines <ref> [BZ83] </ref> for which the behavioural equivalence is undecidable [HU79]. For testing the situation is more complicated since there is in general no knowledge about the whole implementation. Only the interactions between an implementation and its environment are observed for a certain time. <p> For finite automata the reachability problem is solved and there exist efficient algorithms to calculate shortest traces, which lead to a certain state or contain a certain event [HU79]. But the decidability of the reachability problem of the labeled transition system depends heavily on its design. In <ref> [BZ83] </ref> it is proved, that the reachability problem for communicating finite state machines, which communicate by means of unbounded FIFO buffers is undecidable. Subsequently the reachability problem for a labeled transition system, which represent asynchronously communicating processes e.g. like SDL descriptions, is undecidable.
Reference: [CCI92a] <author> CCITT SG X. </author> <title> Message Sequence Chart (MSC). Recommendation Z.120, </title> <booktitle> 1992. </booktitle> <address> Geneva. </address>
Reference-contexts: It combines test purposes defined by Message Sequence Charts (MSCs) <ref> [CCI92a, GR92] </ref> and a corresponding SDL description [CCI92b] in order to generate test cases. MSCs (cf. Figure 2) are a widespread means for the graphical visualisation of selected system runs of communication systems [GGR]. <p> The test case generator is structured in four modules: * Calculation of possible Pass observables. * Calculation of unique Pass observables. * Calculation of Inconclusive observables. * Generation of the corresponding TTCN/MP 13 code. The tool is implemented on Sun workstations. Its inputs are MSC/PR and SDL/PR descriptions <ref> [CCI92a, CCI92b] </ref>, and its output is a TTCN/MP description [ISO91b]. Front-and backends of the tool are commercial SDL, MSC and TTCN editors. 6 Summary and outlook A method for the generation of test cases based on SDL descriptions and MSCs is presented.
Reference: [CCI92b] <author> CCITT SG X. </author> <title> Specification and description language (SDL). Recommendation z.100, </title> <booktitle> 1992. </booktitle> <address> Geneva. </address> <month> 20 </month>
Reference-contexts: It combines test purposes defined by Message Sequence Charts (MSCs) [CCI92a, GR92] and a corresponding SDL description <ref> [CCI92b] </ref> in order to generate test cases. MSCs (cf. Figure 2) are a widespread means for the graphical visualisation of selected system runs of communication systems [GGR]. A test purpose can be defined by an MSC in form of the required signal exchange 2 . <p> The test case generator is structured in four modules: * Calculation of possible Pass observables. * Calculation of unique Pass observables. * Calculation of Inconclusive observables. * Generation of the corresponding TTCN/MP 13 code. The tool is implemented on Sun workstations. Its inputs are MSC/PR and SDL/PR descriptions <ref> [CCI92a, CCI92b] </ref>, and its output is a TTCN/MP description [ISO91b]. Front-and backends of the tool are commercial SDL, MSC and TTCN editors. 6 Summary and outlook A method for the generation of test cases based on SDL descriptions and MSCs is presented.
Reference: [Cho78] <author> T.S. Chow. </author> <title> Testing software design modeled by finite state machines. </title> <journal> IEEE-SE, </journal> <volume> 4(3) </volume> <pages> 178-187, </pages> <year> 1978. </year>
Reference-contexts: PASS, or FAIL)? and What can be concluded from a test verdict? Furthermore, there exists a gap between research and practical testing. Research: Approaches coming from research like UIO [Wez90] or the W-method <ref> [Cho78] </ref> can handle systems with a small state space. They test every state transition exactly one time. Therefore, the length of the test cases is determined and the test verdicts are PASS and FAIL. From a PASS verdict a behavioural equivalence between specification and implementation can be concluded.
Reference: [Fin88] <author> Alan Finkel. </author> <title> A new class of analyzable CFSMs with unbounded FIFO channels. </title> <editor> In S. Aggrawal and K. Sabnani, editors, </editor> <title> Protocol Specification, Verification and Testing, </title> <booktitle> volume 9 of Proceedings of the IFIP WG 6.1 eighth International Symposium on Protocol Specification, Testing and Verification, </booktitle> <pages> pages 283-294. </pages> <publisher> North Holland, </publisher> <year> 1988. </year>
Reference-contexts: Only the interactions between an implementation and its environment are observed for a certain time. One solution is to guarantee a finite state space by giving static restrictions to the specification. But such restrictions often are also undecidable and they do not prevent state explosion <ref> [Fin88] </ref>. Practical Testing: Real systems are very complex and approaches like UIO or the W-method can not applied. The present procedure of writing test cases is an intuitive and creative process which only is restricted by informal regulations.
Reference: [GGR] <author> Jens Grabowski, Peter Graubmann, and Ekkart Rudolph. </author> <title> The standardisation of Message Sequence Charts. </title> <note> submitted to the Software Engineering Standards Symposium '93. </note>
Reference-contexts: It combines test purposes defined by Message Sequence Charts (MSCs) [CCI92a, GR92] and a corresponding SDL description [CCI92b] in order to generate test cases. MSCs (cf. Figure 2) are a widespread means for the graphical visualisation of selected system runs of communication systems <ref> [GGR] </ref>. A test purpose can be defined by an MSC in form of the required signal exchange 2 . An MSC does not define a complete test case. It does not describe the signal exchange which drives the implementation into a state from which the MSC can be performed (preamble).
Reference: [GHL + 92] <author> Jens Grabowski, Dieter Hogrefe, Peter Ladkin, Stefan Leue, and Robert Nahm. </author> <title> Conformance testing a tool for the generation of test cases. Interim Report of the F & E project contract no. </title> <type> 233, </type> <institution> funded by Swiss PTT, </institution> <year> 1992. </year>
Reference-contexts: Figure 12c). * Step 1: The Automaton 1 in Figure 12 accepts exactly the sequences of events, which are compatible with the partial order of the MSC MSC 1. One way for the translation of an MSC into a finite automaton is described in <ref> [GHL + 92] </ref>. MSC 1 consists of two instances P1 and P2, which exchange the signal CR two times. It describes a partial ordered set of communication events, which allows the traces &lt;P1!CR,P1!CR,P2?CR,P2?CR&gt; and &lt;P1!CR,P2?CR,P1!CR,P2?CR&gt;.
Reference: [GR92] <author> J Grabowski and E Rudolph. </author> <title> Message Sequence Charts (MSC) a survey of the new CCITT language for the description of traces within communicating systems. </title> <type> Technical Report IAM-92-022, </type> <institution> University of Berne, </institution> <month> November </month> <year> 1992. </year>
Reference-contexts: It combines test purposes defined by Message Sequence Charts (MSCs) <ref> [CCI92a, GR92] </ref> and a corresponding SDL description [CCI92b] in order to generate test cases. MSCs (cf. Figure 2) are a widespread means for the graphical visualisation of selected system runs of communication systems [GGR].
Reference: [Hog91a] <author> Dieter Hogrefe. </author> <title> Conformance testing of communication protocols in the framework of formal description techniques. </title> <type> Technical Report IAM-91-007, </type> <institution> University of Berne, Institut for Informatik, </institution> <year> 1991. </year> <note> 32 p. </note>
Reference-contexts: The missing information can be provided by an additional FDT description. We choose SDL as FDT because SDL is more used within industry and standardization bodies (e.g. CCITT, ISO/IEC, or ETSI) than any other standardized FDT <ref> [Hog91a] </ref>. The rest of the paper is organized in the following way. In chapter 2 the basic ideas of our approach are presented by means of an example. We formalize our approach by relating the traces of an SDL description and an MSC.
Reference: [Hog91b] <author> Dieter Hogrefe. </author> <title> OSI formal specification case study: The INRES protocol and service. </title> <type> Technical Report IAM-91-012, </type> <institution> University of Berne, </institution> <year> 1991. </year>
Reference-contexts: Finally, a summary and an outlook are given. 2 The basic ideas In the following the basic ideas for using MSCs together with SDL descriptions as the basis for test case generation are illustrated by means of an example which is taken from the behaviour of the Inres protocol <ref> [Hog91b] </ref>. 2 It should be noted that some test purposes (e.g. time constraints, or reliability requirements) can not be expressed by MSCs. But the use of MSCs for describing the class of test purposes which can be expressed seems to be common industrial practice.
Reference: [HU79] <author> John E. Hopcroft and Jeffrey D. Ullman. </author> <title> Introduction to Automata Theory, Languages and Computation. </title> <publisher> Addison Wesley, </publisher> <year> 1979. </year>
Reference-contexts: Even finite state machines which communicate by means of unbounded FIFO buffers (i.e. the base model of SDL) are as powerful as Turing Machines [BZ83] for which the behavioural equivalence is undecidable <ref> [HU79] </ref>. For testing the situation is more complicated since there is in general no knowledge about the whole implementation. Only the interactions between an implementation and its environment are observed for a certain time. One solution is to guarantee a finite state space by giving static restrictions to the specification. <p> An MSC describes a partially ordered set of events. Every event is atomic and a linear time representation is used. 3. TTCN describe traces by trees. Every node of the tree is an event and the events are atomic. 4. Automata theory <ref> [HU79] </ref> is a mathematical model, which works with sequences of atomic events. Furthermore, a linear time representation is used. Our approach. In order to relate the traces of SDL descriptions, MSCs and TTCN we choose an automata theoretic approach and represent traces as sequences of atomic events. <p> For finite automata the reachability problem is solved and there exist efficient algorithms to calculate shortest traces, which lead to a certain state or contain a certain event <ref> [HU79] </ref>. But the decidability of the reachability problem of the labeled transition system depends heavily on its design. In [BZ83] it is proved, that the reachability problem for communicating finite state machines, which communicate by means of unbounded FIFO buffers is undecidable.
Reference: [ISO91a] <author> ISO/IEC JTC 1/SC 21 N. </author> <title> Information technology Open System Interconnection conformance testing methodology and framework - Part1-5. International Standard 9646, </title> <address> ISO/IEC, </address> <year> 1991. </year>
Reference-contexts: The MSC in Figure 2 shows a complete system run including connection establishment, data transfer and disconnection. 2.2 Testing the retransmission of the Initiator A suitable test architecture for testing the Initiator entity of the Inres protocol might be the distributed test method <ref> [ISO91a] </ref> as sketched in Figure 3. The architecture of the Inres protocol (cf. Figure 1) can be adjusted to the distributed test method. The Responder is replaced by the lower tester (LT) and the upper tester (UT) 3 plays the role of the Initiator User.
Reference: [ISO91b] <author> ISO/IEC JTC 1/SC21. </author> <title> Information technology Open Systems Interconnection conformance testing methodology and framework Part 3: The Tree and Tabular Combined Notation. International Standard 9646-3, ISO, </title> <year> 1991. </year>
Reference-contexts: The representation of test cases: Test cases for conformance tests are usually represented by the Tree and Tabular Combined Notation (TTCN) which is standardized by the ISO/IEC <ref> [ISO91b] </ref>. A TTCN test case for an Initiator implementation of the Inres protocol may look like the table in Figure 5. TTCN describes observables by means of a tree notation (cf. Behaviour Description in Figure 5). The tree structure is determined by the ordering and the indent of the events. <p> The tool is implemented on Sun workstations. Its inputs are MSC/PR and SDL/PR descriptions [CCI92a, CCI92b], and its output is a TTCN/MP description <ref> [ISO91b] </ref>. Front-and backends of the tool are commercial SDL, MSC and TTCN editors. 6 Summary and outlook A method for the generation of test cases based on SDL descriptions and MSCs is presented. The approach assumes that the purpose of a test case is given by at least one MSC.
Reference: [KW91] <author> Jan Kroon and Antony Wiles. </author> <title> A tutorial on TTCN. In Protocol, Specification, Testing and Verification, </title> <booktitle> volume 11 of 11th International IFIP WG6.1 Symposium on Protocol, Specification, Testing and Verification, </booktitle> <pages> pages 40-92, </pages> <year> 1991. </year>
Reference-contexts: Such defaults have to be referenced in the test case header (cf. Default in Figure 5). TTCN offers much more facilities like Constraints, Labels or Timer which are not relevant for the understanding of this paper. A tutorial on TTCN can be found in <ref> [KW91] </ref>. 6 The role of MSCs and FDT descriptions for test case generation: Up to now, the complete FDT specification of a protocol hasn't been considered but will have to be for the following reason. It is assumed that an MSC defines the test purpose of a test case.
Reference: [Nah93] <author> Robert Nahm. </author> <title> Semantics of simple SDL. </title> <booktitle> In GI/ITG Fachgesprach, </booktitle> <year> 1993. </year>
Reference-contexts: There are different methods to derive a labeled transition system from an SDL specification. One method is described in <ref> [Nah93] </ref>. Labeled transition system.
Reference: [Wez90] <author> Clazien D. Wezeman. </author> <title> Protocol conformance testing using multiple UIO-sequences. </title> <editor> In E. Brinksma, G. Scollo, and C.A. Vissors, editors, </editor> <title> Workhop on Protocol Specification, Verification and Testing, </title> <booktitle> volume 9 of Proceedings of the IFIP WG 6.1 ninth International Symposium on Protocol Specification, Testing and Verification, </booktitle> <pages> pages 131-143. </pages> <publisher> North Holland, </publisher> <year> 1990. </year> <month> 21 </month>
Reference-contexts: The basic problems deal with the questions: How long is a test case? What is the test verdict (e.g. PASS, or FAIL)? and What can be concluded from a test verdict? Furthermore, there exists a gap between research and practical testing. Research: Approaches coming from research like UIO <ref> [Wez90] </ref> or the W-method [Cho78] can handle systems with a small state space. They test every state transition exactly one time. Therefore, the length of the test cases is determined and the test verdicts are PASS and FAIL.
References-found: 18

