URL: http://www.cs.utexas.edu/users/cpg/pub/97-ICSE.ps.gz
Refering-URL: http://www.cs.utexas.edu/users/cpg/pub/abs.html
Root-URL: 
Title: Specification-based Testing of Reactive Software: Tools and Experiments Experience  
Author: Lalita Jategaonkar Jagadeesan Adam Porter Carlos Puchol J. Christopher Ramming and Lawrence G. Votta 
Keyword: Specification-based Testing, Reactive Systems, Temporal Logic, Empirical Studies  
Affiliation: Department of Computer Science, University of Maryland at  Department of Computer Sciences, The University of Texas at  
Address: Rd., Naperville, IL 60566 (USA),  College Park,  Austin,  
Note: (To appear in the Proceedings of the International Conference on Software Engineering,  Software Production Research Department, Bell Laboratories, 1000 E. Warrenville  This work is supported in part by a National Science Foundation Faculty Early Career Development Award, CCR-9501354.  This work was partially supported by a Fulbright fellowship and The University of Texas at Austin. This work was performed while the author was visiting Bell Laboratories. Innovative Services Research Department, AT&T Laboratories,  
Pubnum: Report  
Email: flalita,vottag@bell-labs.com  aporter@cs.umd.edu.  cpg@cs.utexas.edu.  jcr@research.att.com  
Date: May 1997)  
Abstract: Testing commercial software is expensive and time consuming. Automated testing methods promise to save a great deal of time and money throughout the software industry. One approach that is well-suited for the reactive systems found in telephone switching systems is specification-based testing. We have built a set of tools to automatically test software applications for violations of safety properties expressed in temporal logic. Our testing system automatically constructs finite state machine oracles corresponding to safety properties, builds test harnesses, and integrates them with the application. The test harness then generates inputs automatically to test the application. We describe a study examining the feasibility of this approach for testing industrial applications. To conduct this study we formally modeled an Automatic Protection Switching system (APS), which is an application common to many telephony systems. We then asked a number of computer science graduate students to develop several versions of the APS and use our tools to test them. We found that the tools are very effective, save significant amounts of human effort (at the expense of machine resources), and are easy to use. We also dis cuss improvements that are needed before we can use the tools with professional developers building commercial products. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Ardis, J. Chaves, L. Jagadeesan, P. Mataga, C. Puchol, M. Staskauskas, and J. Von Olnhausen. </author> <title> A framework for evaluating specification methods for reactive systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 22(6) </volume> <pages> 378-389, </pages> <month> June </month> <year> 1996. </year>
Reference-contexts: The purpose of this system is to manage M redundant resources such as phone lines to ensure that N &lt; M of the highest-quality resources are always selected for use. In earlier work, Ardis et al. <ref> [1] </ref> used temporal logic safety properties to formally specify the APS requirements. Based on this specification, we developed thirty APS implementations and tested them on literally millions of test cases. Our toolset automatically found and revealed violations of the requirements. <p> A TELECOMMUNICATIONS APPLICATION The Automatic Protection Switching System As described in <ref> [1] </ref>, communication channels bridging switching systems need to interface to components manufactured by different vendors. In order to facilitate cooperation between components, standards have been established. One of the standards for maintaining connectivity is called "Automatic Protection Switching (APS)" [2]. <p> The output of the system consists of the state of the switch that selects the current communication line. As we described earlier, the requirements of the APS were formally specified as part of a formal methods case study by Ardis et al. <ref> [1] </ref>. We used this specification as the starting point for the following feasibility study. FEASIBILITY STUDY We conducted a feasibility study to understand the strengths and weaknesses of our testing tools.
Reference: [2] <author> Bellcore. </author> <title> Synchronous optical network (SONET) transport systems: Common generic criteria. </title> <type> Technical Report TR-NWT-000253, Issue 2, </type> <institution> Bellcore, </institution> <year> 1991. </year>
Reference-contexts: In order to assess the suitability and advantages of our approach on industrial systems, we have applied our toolset to several implementations of an Automatic Protection Switching (APS) system <ref> [2] </ref>. The purpose of this system is to manage M redundant resources such as phone lines to ensure that N &lt; M of the highest-quality resources are always selected for use. In earlier work, Ardis et al. [1] used temporal logic safety properties to formally specify the APS requirements. <p> In order to facilitate cooperation between components, standards have been established. One of the standards for maintaining connectivity is called "Automatic Protection Switching (APS)" <ref> [2] </ref>. The idea is to provide more than one line for each communication channel (in switching systems, reliability is often provided by duplicating critical elements). If a line degrades or fails, a backup line, called the "protection line" is used instead.
Reference: [3] <author> G. Berry and G. Gonthier. </author> <title> The Esterel synchronous programming language: design, semantics, </title> <booktitle> implementation. Science of Computer Programming, </booktitle> <volume> 19 </volume> <pages> 87-152, </pages> <year> 1992. </year>
Reference-contexts: We then present a case study and empirical observations. Finally, we discuss the challenges and opportunities that would come from using our tools in industrial software development. THE TESTING FRAMEWORK AND TOOLS The Computation Model Our tools test reactive applications [9]. Specifically, applications must conform to the synchrony hypothesis <ref> [3] </ref>, Inputs: MOVING, STOPPED, OPEN, CLOSED, F-3, GO-3; Relation: MOVING # STOPPED; Relation: OPEN # CLOSED; S0 := - (OPEN -&gt; not MOVING) and (MOVING -&gt; not OPEN) - S1 := - F-3 RespondsTo GO-3 In 10 TICK - P := Always - S0 and S1 - which implies that applications <p> In our toolset, oracle state machines are constructed through the following chain of events. First, safety properties are specified by the system engineer using the temporal logic syntax described earlier [13]. Next, as an engineering convenience, our toolset automatically translates the temporal logic formulae into Esterel <ref> [3] </ref> programs. These programs express deterministic finite-state machines, which we extract easily by invoking the Esterel compiler. The resulting information is then automatically analyzed and eventually linked with the test harness and the application.
Reference: [4] <author> E. Brinksma. </author> <title> A theory for the derivation of tests. In Proceedings of the Symposium on Protocol Specification, Testing, and Verification, </title> <year> 1988. </year>
Reference-contexts: Many approaches to conformance testing have been proposed, corresponding to a variety of specification languages. For example, Gaudel [8] presents a framework for the testing of algebraic specifications. Brinksma et al. <ref> [4, 5] </ref> present a theory of testing based on labeled transition systems, and applications to the specification language LOTOS are shown in [5, 19]. In the remainder of this article we present our method and toolset, discuss the Automatic Protection Switching system, and our various implementations of it.
Reference: [5] <author> E. Brinksma, G. Scollo, and C. Steenbergen. </author> <title> LOTOS specifications, their implementations and their tests. In Proceedings of the Symposium on Protocol Specification, Testing, and Verification, </title> <year> 1986. </year>
Reference-contexts: Many approaches to conformance testing have been proposed, corresponding to a variety of specification languages. For example, Gaudel [8] presents a framework for the testing of algebraic specifications. Brinksma et al. <ref> [4, 5] </ref> present a theory of testing based on labeled transition systems, and applications to the specification language LOTOS are shown in [5, 19]. In the remainder of this article we present our method and toolset, discuss the Automatic Protection Switching system, and our various implementations of it. <p> For example, Gaudel [8] presents a framework for the testing of algebraic specifications. Brinksma et al. [4, 5] present a theory of testing based on labeled transition systems, and applications to the specification language LOTOS are shown in <ref> [5, 19] </ref>. In the remainder of this article we present our method and toolset, discuss the Automatic Protection Switching system, and our various implementations of it. We then present a case study and empirical observations.
Reference: [6] <author> L. Dillon, G. Kutty, L. Moser, P. M. Melliar-Smith, and Y. Ramakrishna. </author> <title> A graphical interval logic for specifying concurrent systems. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 3(2) </volume> <pages> 131-165, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: Our toolset automatically found and revealed violations of the requirements. This work was inspired by Dillon&Yu [7], who present a method for testing reactive software against specifications written in a version of temporal logic called Graphical Interval Logic <ref> [6] </ref>. Properties written in this logic are translated into FSM's whose language is the set of executions that violate the given property; the resulting FSM's are then used to generate test inputs.
Reference: [7] <author> L. Dillon and Q. Yu. </author> <title> Oracles for checking temporal properties of concurrent systems. </title> <journal> Software Engineering Notes, </journal> <volume> 19(5) </volume> <pages> 140-153, </pages> <month> December </month> <year> 1994. </year> <booktitle> Proceedings of the 2nd ACM SIGSOFT Symposium on Foundations of Software Engineering. </booktitle>
Reference-contexts: Based on this specification, we developed thirty APS implementations and tested them on literally millions of test cases. Our toolset automatically found and revealed violations of the requirements. This work was inspired by Dillon&Yu <ref> [7] </ref>, who present a method for testing reactive software against specifications written in a version of temporal logic called Graphical Interval Logic [6].
Reference: [8] <author> M. </author> <title> Gaudel. Testing can be formal, too. </title> <booktitle> In Proceedings of International Joint Conference on Theory and Practice of Software Development, Volume 915 of the Lecture Notes In Computer Science, </booktitle> <year> 1995. </year>
Reference-contexts: Our approach is a form of conformance testing black-box testing for determining whether an implementation exhibits the behavior prescribed by its specification. Many approaches to conformance testing have been proposed, corresponding to a variety of specification languages. For example, Gaudel <ref> [8] </ref> presents a framework for the testing of algebraic specifications. Brinksma et al. [4, 5] present a theory of testing based on labeled transition systems, and applications to the specification language LOTOS are shown in [5, 19].
Reference: [9] <author> N. Halbwachs. </author> <title> Synchronous Programming of Reactive Systems. </title> <publisher> Kluwer Academic, </publisher> <year> 1993. </year>
Reference-contexts: We then present a case study and empirical observations. Finally, we discuss the challenges and opportunities that would come from using our tools in industrial software development. THE TESTING FRAMEWORK AND TOOLS The Computation Model Our tools test reactive applications <ref> [9] </ref>.
Reference: [10] <author> N. Halbwachs, P. Caspi, P. Raymond, and D. Pi-laud. </author> <title> The synchronous data-flow programming language lustre. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 79(9) </volume> <pages> 1305-1320, </pages> <year> 1991. </year>
Reference-contexts: Dillon and Yu indicate that they are currently developing tools to support this method, and that they will be integrated with Richardson's TAOS [20] test management system. Parissis&Ouabdesselam [18] present a technique for testing whether reactive software satisfies specifications written in Lustre <ref> [10] </ref>, a synchronous data-flow language that can also be viewed as a temporal logic. We have used standard temporal logic rather than Graphical Interval Logic or Lustre mainly to take advantage of some temporal logic tools that we had developed in the course of earlier work [13].
Reference: [11] <author> D. Harel. Statecharts: </author> <title> A visual formalism for complex systems. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8 </volume> <pages> 231-274, </pages> <year> 1987. </year>
Reference-contexts: They have constructors, destructors, and driver methods. Also, since some of the system design in the telecommuni cations industry is done using object-oriented CASE tools such as Real-Time Object-Oriented Modeling (ROOM)/ObjecTime [22] and O-Charts/O-MATE [12] an object-oriented extension of Statecharts <ref> [11] </ref>, there is a clear opportunity to create test-enabled applications in conjunction with these executable design tools. This looks promising because these objects satisfy the synchrony hypothesis by design [22].
Reference: [12] <author> D. Harel and E. Gery. </author> <title> Executable object modeling with statecharts. </title> <booktitle> In Proceedings of the 18th International Symposium on Software Engineering, </booktitle> <pages> pages 246-257, </pages> <year> 1996. </year>
Reference-contexts: An interesting observation is that object-oriented designs naturally conform to our interface. They have constructors, destructors, and driver methods. Also, since some of the system design in the telecommuni cations industry is done using object-oriented CASE tools such as Real-Time Object-Oriented Modeling (ROOM)/ObjecTime [22] and O-Charts/O-MATE <ref> [12] </ref> an object-oriented extension of Statecharts [11], there is a clear opportunity to create test-enabled applications in conjunction with these executable design tools. This looks promising because these objects satisfy the synchrony hypothesis by design [22].
Reference: [13] <author> L. Jagadeesan, C. Puchol, and J. Von Olnhausen. </author> <title> Safety property verification of Esterel programs and applications to telecommunications software. </title> <booktitle> In Proceedings of the 7th International Conference on Computer Aided Verification, Volume 939 of the Lecture Notes in Computer Science, </booktitle> <pages> pages 127-140, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: We have used standard temporal logic rather than Graphical Interval Logic or Lustre mainly to take advantage of some temporal logic tools that we had developed in the course of earlier work <ref> [13] </ref>. Richardson et al. [21] present an approach for deriving oracles from formal multi-paradigm specifications. Our approach is focused on temporal logic safety properties, and oracles are derived automatically. Our work extends these efforts through an industrial case study. <p> The safety properties themselves are composed of signals, the standard boolean operators, simple temporal operators: previous, since, has-always-been, once, and back-to, and a bounded-response operator (property S1 in Figure 1 is an example of a bounded response property). See <ref> [15, 13] </ref> for formal definitions of the operators. The Toolset We have developed techniques and tools that automatically test whether a software application satisfies temporal logic safety properties. <p> In our toolset, oracle state machines are constructed through the following chain of events. First, safety properties are specified by the system engineer using the temporal logic syntax described earlier <ref> [13] </ref>. Next, as an engineering convenience, our toolset automatically translates the temporal logic formulae into Esterel [3] programs. These programs express deterministic finite-state machines, which we extract easily by invoking the Esterel compiler. The resulting information is then automatically analyzed and eventually linked with the test harness and the application.
Reference: [14] <author> L. Jagadeesan, C. Puchol, and J. Von Olnhausen. </author> <title> A formal approach to reactive systems software: A telecommunications application in Esterel. Formal Methods in System Design, </title> <type> 8(2), </type> <month> March </month> <year> 1996. </year>
Reference-contexts: Even when existing switch software is not compatible with our testing technique, it may still be possible to upgrade the software to satisfy the tool's requirements. For example, in a separate study <ref> [14] </ref>, we re-wrote part of the 5ESS software. This new system satisfied the synchrony hypothesis and would have met our testing tool's interface requirements. Modular Design Our testing technique involves a form of black-box testing.
Reference: [15] <author> Z. Manna and A. Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems, Specification. </title> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Testing techniques should alert developers only when a failure has occurred, rather than require developers to evaluate test results by hand. We have developed a toolset that supports highly automated testing of reactive systems. In our approach, requirements are specified as a restricted class of temporal logic safety properties <ref> [15] </ref>. From these specifications we automatically generate finite state machines (FSMs) that accept the language of input-output traces that violate the safety properties. <p> Consequently, safety properties are sufficient to describe the intended behavior of most reactive systems. Temporal logic is a well-known formalism for specifying safety properties, and our specification language is based on its propositional linear-time variant <ref> [15] </ref>. The specifications used by our tool are written with a specially designed notation. <p> The safety properties themselves are composed of signals, the standard boolean operators, simple temporal operators: previous, since, has-always-been, once, and back-to, and a bounded-response operator (property S1 in Figure 1 is an example of a bounded response property). See <ref> [15, 13] </ref> for formal definitions of the operators. The Toolset We have developed techniques and tools that automatically test whether a software application satisfies temporal logic safety properties.
Reference: [16] <author> K. Martersteck and A. Spencer. </author> <title> Introduction to the 5ESS(TM) switching system. </title> <journal> AT&T Technical Journal, </journal> <volume> 64(6 part </volume> 2):1305-1314, July-August 1985. 
Reference-contexts: Examples of reactive systems include elevators, traffic controllers, and avionics controllers; most real-time systems are also reactive in nature. Reactive systems are also ubiquitous in the software for Lucent Technologies' 5ESS R fl telephone switching system <ref> [16] </ref>, which provides telecommunications services. Reactive systems are often safety-critical and must be thoroughly tested to ensure that they meet stringent requirements. Since the number of potential input sequences that a reactive system must handle is infinite, much testing is needed to establish confidence in the system.
Reference: [17] <author> J. Musa, A. Iannino, and K. Okumoto. </author> <title> Software Reliability: Measurement, Prediction, Application. </title> <publisher> McGraw-Hill Book Company, </publisher> <year> 1987. </year> <note> See pages 227ff. </note>
Reference-contexts: Another enhancement to our tool that might be useful is to allow inputs to be selected with non-uniform weights. Sometimes testers may wish to exercise the systems in conditions closely approximating its intended use, for example, using notions of operational profiling <ref> [17] </ref>. Other times they may want to overload the system with a certain type or sequence of operations, for example, when performing stress-testing. Costs and Benefits One aspect of the tool's cost-benefits is that it is designed to ensure conformance to certain specifications.
Reference: [18] <author> O. Parissis and F. Ouabdesselam. </author> <title> Specification-based testing of synchronous software. </title> <booktitle> In Proceedings of the 4th ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <year> 1996. </year>
Reference-contexts: Dillon and Yu indicate that they are currently developing tools to support this method, and that they will be integrated with Richardson's TAOS [20] test management system. Parissis&Ouabdesselam <ref> [18] </ref> present a technique for testing whether reactive software satisfies specifications written in Lustre [10], a synchronous data-flow language that can also be viewed as a temporal logic.
Reference: [19] <author> D. Pitt and D. Freestone. </author> <title> The derivation of conformance tests from LOTOS specifications. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(12) </volume> <pages> 1337-1343, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: For example, Gaudel [8] presents a framework for the testing of algebraic specifications. Brinksma et al. [4, 5] present a theory of testing based on labeled transition systems, and applications to the specification language LOTOS are shown in <ref> [5, 19] </ref>. In the remainder of this article we present our method and toolset, discuss the Automatic Protection Switching system, and our various implementations of it. We then present a case study and empirical observations.
Reference: [20] <author> D. Richardson. TAOS: </author> <title> Testing with analysis and oracle support. </title> <booktitle> In Proceedings of the International Symposium on Software Testing and Analysis, </booktitle> <month> August </month> <year> 1994. </year>
Reference-contexts: Dillon and Yu indicate that they are currently developing tools to support this method, and that they will be integrated with Richardson's TAOS <ref> [20] </ref> test management system. Parissis&Ouabdesselam [18] present a technique for testing whether reactive software satisfies specifications written in Lustre [10], a synchronous data-flow language that can also be viewed as a temporal logic.
Reference: [21] <author> D. Richardson, S. Aha, and T. O'Malley. </author> <title> Specification-based test oracles for reactive systems. </title> <booktitle> In Proceedings of the 14th International Conference on Software Engineering, </booktitle> <month> May </month> <year> 1992. </year>
Reference-contexts: We have used standard temporal logic rather than Graphical Interval Logic or Lustre mainly to take advantage of some temporal logic tools that we had developed in the course of earlier work [13]. Richardson et al. <ref> [21] </ref> present an approach for deriving oracles from formal multi-paradigm specifications. Our approach is focused on temporal logic safety properties, and oracles are derived automatically. Our work extends these efforts through an industrial case study. <p> We are currently exploring this connection. The Signal Mapping Problem One difficult problem that arises in practice involves mapping specification names onto implementation names. This can be necessary when the specifications are written at a higher level of abstraction than the implementation. The work of Richardson et al <ref> [21] </ref> takes a significant step towards solving this problem, but more work is still needed in this direction. Tool Enhancements Although our current tools are written in C, the test system is inherently language-independent.
Reference: [22] <author> B. Selic, G. Gullekson, and P. Ward. </author> <title> Real-Time Object Oriented Modeling. </title> <publisher> John Wiley and Sons, Inc., </publisher> <year> 1994. </year>
Reference-contexts: An interesting observation is that object-oriented designs naturally conform to our interface. They have constructors, destructors, and driver methods. Also, since some of the system design in the telecommuni cations industry is done using object-oriented CASE tools such as Real-Time Object-Oriented Modeling (ROOM)/ObjecTime <ref> [22] </ref> and O-Charts/O-MATE [12] an object-oriented extension of Statecharts [11], there is a clear opportunity to create test-enabled applications in conjunction with these executable design tools. This looks promising because these objects satisfy the synchrony hypothesis by design [22]. <p> is done using object-oriented CASE tools such as Real-Time Object-Oriented Modeling (ROOM)/ObjecTime <ref> [22] </ref> and O-Charts/O-MATE [12] an object-oriented extension of Statecharts [11], there is a clear opportunity to create test-enabled applications in conjunction with these executable design tools. This looks promising because these objects satisfy the synchrony hypothesis by design [22]. The objects are essentially hierarchical finite-state machines, whose inputs are the external inputs to the system and the outputs from other objects. We are currently exploring this connection. The Signal Mapping Problem One difficult problem that arises in practice involves mapping specification names onto implementation names.
Reference: [23] <author> P. Wolper, M. Vardi, and A. Sistla. </author> <title> Reasoning about infinite computation paths. </title> <booktitle> In IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 185-194, </pages> <year> 1983. </year>
Reference-contexts: A portion of the interface functions (written in C) appears in Figure 3. Oracle State Machines In order to generate test cases, our system uses the following important fact about safety properties <ref> [23] </ref>: For any safety property, there exists a finite state machine whose language is the set of all possible finite executions that violate the prop erty. We refer to these finite-state machines as oracles, and they are the mechanism by which an application's flaws are revealed.
Reference: [24] <institution> Personal communication. Mary Zajac. </institution>
Reference-contexts: We need to develop a better understanding of error coverage provided by this approach. One the other hand, we saw that this approach was excellent at finding problems involving rare scenarios. Since this is the most frequent root cause of problems detected in the field <ref> [24] </ref> (when the cost to repair defects is by far the greatest), the tool is very useful in these cases. The value of this tool depends on a tradeoff between machine expense and human expense.
References-found: 24

