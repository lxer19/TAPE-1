URL: ftp://ftp.cis.ohio-state.edu/pub/tech-report/1994/TR45.ps.gz
Refering-URL: http://www.cis.ohio-state.edu/rsrg/bib-language.html
Root-URL: 
Email: heym,long,ogden,weide-@cis.ohio-state.edu  
Title: Mathematical Foundations and Notation of RESOLVE  
Author: Wayne D. Heym Timothy J. Long William F. Ogden Bruce W. Weide 
Note: Copyright 1994 by the authors. All rights reserved.  
Date: (Aug. 1994; slightly revised Oct. and Nov. 1994)  
Address: Columbus, OH 43210  
Affiliation: Department of Computer and Information Science The Ohio State University  
Pubnum: Technical Report OSU-CISRC-8/94-TR45  
Abstract: The RESOLVE approach to reusable component-based software engineering is mathematically-based. This paper discusses the logical foundations and terminology of RESOLVE, the built-in RESOLVE notation for writing mathematics, and the RESOLVE mechanisms that support description of mathematics that has no built-in notation. It is intended to serve primarily as a reference document. 
Abstract-found: 1
Intro-found: 1
Reference: [Bucci 94] <author> Bucci, P., Hollingsworth, J.E., Krone, J., and Weide, B.W., </author> <title> Implementing Components in RESOLVE, </title> <journal> Softw. Eng. </journal> <note> Notes 19, </note> <month> 4 (Oct. </month> <year> 1994), </year> <note> to appear. </note>
Reference-contexts: 1. Introduction RESOLVE is our framework, language, and discipline for supporting component-based software <ref> [Ogden 94, Edwards 94, Bucci 94] </ref>. <p> Again, there is nothing wrong with this expression mathematically, but from the standpoint of human understanding it leaves something to be desired. Section 3 explains how you declare various new theory-related entities, including math subtypes. Before we discuss this, however, we introduce the built-in mathematical notation used throughout RESOLVE <ref> [Edwards 94, Bucci 94] </ref>. 2. <p> All RESOLVE math modules are generic, in the same sense as for program modules <ref> [Edwards 94, Bucci 94] </ref>. This means that a client must instantiate a math module before using it. An instance of a math module is called a math facility. A typical math module defines a math type family, possibly some math subtype families, and some math operation families.
Reference: [Dahl 92] <author> Dahl, O-J., </author> <title> Verifiable Programming, </title> <publisher> Prentice-Hall International (UK) Ltd., </publisher> <year> 1992. </year> <note> MATHEMATICAL FOUNDATIONS AND NOTATION OF RESOLVE 21 </note>
Reference-contexts: Some authors call types sorts, and some call operators function symbols and predicate symbols, among other things. 3 Dahl <ref> [Dahl 92] </ref> calls the same notion a semantic subtype. MATHEMATICAL FOUNDATIONS AND NOTATION OF RESOLVE 4 subset of the universe of discourse. Each math subtype has a parent math subtype, possibly a grandparent, and so on up a chain.
Reference: [Edwards 94] <author> Edwards, S.H., Long, T.J., Sitaraman, M., and Weide, B.W., </author> <title> Specifying Components in RESOLVE, </title> <journal> Softw. Eng. </journal> <note> Notes 19, </note> <month> 4 (Oct. </month> <year> 1994), </year> <note> to appear. </note>
Reference-contexts: 1. Introduction RESOLVE is our framework, language, and discipline for supporting component-based software <ref> [Ogden 94, Edwards 94, Bucci 94] </ref>. <p> The set of the axioms and all theorems provable from them in this way constitutes a theory. Meaning comes via an interpretation of a theory, i.e., a mapping that assigns a set of values (the universe of discourse, as discussed in the companion paper on specifications <ref> [Edwards 94] </ref>) to every type of the theory; and a total function or relation to every operator of the theory. <p> Its most distant ancestor is a full-fledged math type called its base type. The first use of math subtypes is to serve as mathematical models for program types whose model values are constrained to lie in some subset of the base types set. Partial_Map_Template <ref> [Edwards 94] </ref> gives an example of this use. The other use of math subtypes is to make it possible to be explicit about intent when defining a math operation that otherwise might be thought of as only partially defined. <p> Again, there is nothing wrong with this expression mathematically, but from the standpoint of human understanding it leaves something to be desired. Section 3 explains how you declare various new theory-related entities, including math subtypes. Before we discuss this, however, we introduce the built-in mathematical notation used throughout RESOLVE <ref> [Edwards 94, Bucci 94] </ref>. 2. <p> The first is to define an appropriate math subtype to be the domain of a function. But this only works when the domain can be characterized in advance. The second approach which we use, for example, in specifying the programming type Partial_Map <ref> [Edwards 94] </ref>, where the domain of the partial function can change dynamically under program control is to treat a partial function as set of ordered pairs with the function property. Again, a math subtype is involved: a math subtype of set of (x: MT1 y: MT2). <p> So, for consistency, we use similar keywords for similar ideas in the various RESOLVE modules. Because of the many connections, you should find that having read about specifying concepts <ref> [Edwards 94] </ref> makes this section much easier to understand. For all the parallels between conceptual and math modules, a natural question is why both are needed. The primary reason is separation of concerns, as the developers of Larchs two-tiered approach to formal specification have explained well. <p> All RESOLVE math modules are generic, in the same sense as for program modules <ref> [Edwards 94, Bucci 94] </ref>. This means that a client must instantiate a math module before using it. An instance of a math module is called a math facility. A typical math module defines a math type family, possibly some math subtype families, and some math operation families. <p> Math Module Conceptual Module math type family type family math type type math operation family operation family math operation operation math facility facility We recommend that you organize math modules into the three main categories suggested for conceptual modules: kernels, additions, and enhancements <ref> [Edwards 94] </ref>. Figure 2 shows a kernel math module, i.e., one that defines a new theory. In this case the module defines a theory of binary trees, which is useful but not built-in to RESOLVE. <p> We do not show an example enhancement, but you can combine math modules in the same way as you can combine conceptual modules <ref> [Edwards 94] </ref>. This is most useful if there are several additions to a theory that might be reused together in many places. <p> Context Section A math module can have two different kinds of context, global and parametric: &lt;math_context_section&gt; ::= context [&lt;math_global_context_section&gt;] [&lt;math_parametric_context_section&gt;] Visibility, scope, and name qualification rules are the same as for conceptual modules <ref> [Edwards 94] </ref>. Namely, when you introduce an instance of a math module into a context, you make visible all identifiers that are declared in its interface and those visible through or declared in its context. Overloading of identifiers is permitted, with no qualification required unless an ambiguity arises. <p> Alternatively, we could have left out the interface section. The reason is that there can be no difference between declarations made in the local context section and the interface section, because there is no need here to distinguish between mathematical and programming identifiers as there is for conceptual modules <ref> [Edwards 94] </ref>. All identifiers in math modules are mathematical identifiers and are implicitly exported by virtue of being in the context. 3.2.1. <p> Here, you use global context and parametric context to connect new math operations and theorems to underlying theories. You do this in a stylized way that parallels the method for making additions to a kernel concept <ref> [Edwards 94] </ref>. MATHEMATICAL FOUNDATIONS AND NOTATION OF RESOLVE 16 3.2.2. <p> You also may combine a kernel math module and one or more additions into an enhancement, using MATHEMATICAL FOUNDATIONS AND NOTATION OF RESOLVE 18 the reexports feature and optional renaming, in precisely the same way as for conceptual modules <ref> [Edwards 94] </ref>. 3.3.1.
Reference: [Gries 93] <author> Gries, D., and Schneider, </author> <title> F.B., A Logical Approach to Disrcete Math, </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: There are two main reasons we prefer it nonetheless: More compact notations tend to use symbols, such as $, that are not standard ASCII characters. This makes it difficult to build portable tools that process mathematical notation. 4 Gries and Schneider <ref> [Gries 93] </ref> give axioms for various theories, precedence rules, etc. We dont necessarily use precisely the same axioms, but we do adopt the same rules for precedence and other convenience features such as conjunctional operators.
Reference: [Guttag 93] <author> Guttag, J.V., and Horning, J.J., </author> <title> Larch: Languages and Tools for Formal Specification, </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: History demonstrates that its easy to get it wrong, and the consequences can be serious if you expect to specify and prove things about, say, safety-critical software systems. 1 1 Z [Spivey 89] and Larch <ref> [Guttag 93] </ref> are two formal specification languages used today that help establish some context for RESOLVE. Z leans heavily toward meeting objective O-1, while Larch leans heavily toward meeting objective O-2. Z deals directly with sets, functions, and relations.
Reference: [Harms 90] <author> Harms, D.E., </author> <title> The Influence of Software Reuse on Programming Language Design. </title> <type> Ph.D. </type> <institution> diss., Dept. of Comp. and Inf. Sci., Ohio State Univ., Columbus, </institution> <month> Aug. </month> <year> 1990. </year> <note> Available from UMI (phone: 800-521 0600). </note>
Reference-contexts: Mathematical and programming ideas are similar and the notational requirements analogous, but they are not identical. There are a variety of technical differences in RESOLVE, e.g., the treatment of type matching <ref> [Harms 90, Harms 91] </ref>.
Reference: [Harms 91] <author> Harms, D.E., and Weide, B.W., </author> <title> Copying and Swapping: Influences on the Design of Reusable Software Components, </title> <journal> IEEE Trans. on Software Eng. </journal> <volume> 17, </volume> <month> 5 (May </month> <year> 1991), </year> <pages> 424-435. </pages>
Reference-contexts: Mathematical and programming ideas are similar and the notational requirements analogous, but they are not identical. There are a variety of technical differences in RESOLVE, e.g., the treatment of type matching <ref> [Harms 90, Harms 91] </ref>.
Reference: [Ogden 94] <author> Ogden, W.F., Sitaraman, M., Weide, B.W., and Zweben, S.H., </author> <title> The RESOLVE Framework and Discipline A Research Synopsis, </title> <journal> Softw. Eng. </journal> <note> Notes 19, </note> <month> 4 (Oct. </month> <year> 1994), </year> <note> to appear. </note>
Reference-contexts: 1. Introduction RESOLVE is our framework, language, and discipline for supporting component-based software <ref> [Ogden 94, Edwards 94, Bucci 94] </ref>.
Reference: [Spivey 89] <author> Spivey, J.M., </author> <title> The Z Notation, </title> <publisher> Prentice-Hall International (UK) Ltd., </publisher> <year> 1989. </year>
Reference-contexts: History demonstrates that its easy to get it wrong, and the consequences can be serious if you expect to specify and prove things about, say, safety-critical software systems. 1 1 Z <ref> [Spivey 89] </ref> and Larch [Guttag 93] are two formal specification languages used today that help establish some context for RESOLVE. Z leans heavily toward meeting objective O-1, while Larch leans heavily toward meeting objective O-2. Z deals directly with sets, functions, and relations.
References-found: 9

