URL: ftp://ftp.cse.ucsc.edu/pub/tr/ucsc-crl-94-38.ps.Z
Refering-URL: ftp://ftp.cse.ucsc.edu/pub/tr/README.html
Root-URL: http://www.cse.ucsc.edu
Title: Analysis and Transformation of Logic Programs  approved:  
Author: by Kjell Erik Post Allen Van Gelder Charles E. McDowell Wayne Dai Dean 
Degree: A dissertation submitted in partial satisfaction of the requirements for the degree of Doctor of Philosophy in  
Note: The dissertation of Kjell Erik Post is  
Date: December 1994  
Affiliation: University of California Santa Cruz  Computer and Information Sciences  of Graduate Studies and Research  
Abstract-found: 0
Intro-found: 1
Reference: [AJ74] <author> A. V. Aho and S. C. Johnson. </author> <title> LR parsing. </title> <journal> Computing Surveys, </journal> <month> June </month> <year> 1974. </year>
Reference-contexts: Fortunately, this area is well understood and numerous so 4 Logic Program Parsing Analysis Transformations Compiler ? ? Example Tools Parser Generator Mode Analysis Termination Analysis Type Derivation Partial Evaluators Quintus Prolog called parser generators <ref> [Joh75, ASU85, AJ74, FJ88, Udd88, HKR90, Hor90] </ref> are available to the language designer, who rarely needs to write a parser by hand. Instead, specifications in the form of production rules, with embedded code or "action" routines, are fed into a parser generator which then generates the parser. <p> Preliminaries In order to set the stage for the following chapters, we first review some notation and concepts on parsing and logic programming. For a more extensive treatment we refer the reader to <ref> [ASU85, AJ74, FJ88] </ref> for context-free grammars and parsing, and [Llo87, Apt90, CM81, SS86] for logic programming. A unifying presentation of these two fields can also be found in [DM93]. 2.1 Context Free Grammars A context-free grammar is a four-tuple G = hV N ; V T ; S; P i. <p> Such knowledge is stored in a parse table whose construction requires a rather complicated analysis of the production rules (not described here, but see <ref> [BL89, AJ74] </ref>). The parse table encodes a state machine where a state S may have zero or more outgoing arcs, each labeled by some distinct grammar symbol X . Hence, the parse table can be implemented with an array parse table (S; X ). <p> Excellent methods have been developed for generating efficient LL parsers and LR parsers from specifications in the form of production rules, sometimes augmented with associativity and precedence declarations for infix operators <ref> [AJ74, ASU85, BL89, FJ88, Joh75] </ref>. Parser generation methods enjoy several significant advantages over "hand coding": 28 1. The language syntax can be presented in a readable, nonprocedural form, similar to production rules. 2. Embedded semantic actions can be triggered by parsing situations. 3.
Reference: [AJU75] <author> A. V. Aho, S. C. Johnson, and J. D. Ullman. </author> <title> Deterministic Parsing of Ambiguous Grammars. </title> <journal> Communications of the ACM, </journal> <volume> 18(8) </volume> <pages> 441-52, </pages> <year> 1975. </year>
Reference-contexts: The resolution is done by the policy that is used at table-construction time by Yacc <ref> [AJU75, ASU85] </ref>, with extensions to cover cases that cannot be declared in Yacc (cf. section 3.4). The details, for those conversant with the operation of the LR parser, are as follows.
Reference: [Apt90] <author> K. R. Apt. </author> <title> Logic Programming. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <pages> pages 495-574. </pages> <publisher> MIT Press/Elsevier, </publisher> <year> 1990. </year>
Reference-contexts: Preliminaries In order to set the stage for the following chapters, we first review some notation and concepts on parsing and logic programming. For a more extensive treatment we refer the reader to [ASU85, AJ74, FJ88] for context-free grammars and parsing, and <ref> [Llo87, Apt90, CM81, SS86] </ref> for logic programming. A unifying presentation of these two fields can also be found in [DM93]. 2.1 Context Free Grammars A context-free grammar is a four-tuple G = hV N ; V T ; S; P i.
Reference: [ASU85] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers, Principles, Techniques, and Tools. </booktitle> <publisher> Addison Wesley, </publisher> <address> ISBN 0-201-10088-6, </address> <year> 1985. </year>
Reference-contexts: Fortunately, this area is well understood and numerous so 4 Logic Program Parsing Analysis Transformations Compiler ? ? Example Tools Parser Generator Mode Analysis Termination Analysis Type Derivation Partial Evaluators Quintus Prolog called parser generators <ref> [Joh75, ASU85, AJ74, FJ88, Udd88, HKR90, Hor90] </ref> are available to the language designer, who rarely needs to write a parser by hand. Instead, specifications in the form of production rules, with embedded code or "action" routines, are fed into a parser generator which then generates the parser. <p> Preliminaries In order to set the stage for the following chapters, we first review some notation and concepts on parsing and logic programming. For a more extensive treatment we refer the reader to <ref> [ASU85, AJ74, FJ88] </ref> for context-free grammars and parsing, and [Llo87, Apt90, CM81, SS86] for logic programming. A unifying presentation of these two fields can also be found in [DM93]. 2.1 Context Free Grammars A context-free grammar is a four-tuple G = hV N ; V T ; S; P i. <p> Excellent methods have been developed for generating efficient LL parsers and LR parsers from specifications in the form of production rules, sometimes augmented with associativity and precedence declarations for infix operators <ref> [AJ74, ASU85, BL89, FJ88, Joh75] </ref>. Parser generation methods enjoy several significant advantages over "hand coding": 28 1. The language syntax can be presented in a readable, nonprocedural form, similar to production rules. 2. Embedded semantic actions can be triggered by parsing situations. 3. <p> The resolution is done by the policy that is used at table-construction time by Yacc <ref> [AJU75, ASU85] </ref>, with extensions to cover cases that cannot be declared in Yacc (cf. section 3.4). The details, for those conversant with the operation of the LR parser, are as follows. <p> There are techniques for eliminating left recursion, but they enlarge the grammar, sometimes significantly <ref> [ASU85] </ref>. Also, there is no clearcut way to transform the semantic actions correctly. 44 * Unless the parser is predictive [ASU85] it may spend considerable time on backtrack ing. * A backtracking parser requires the whole input stream of tokens to be present during parsing. * Backtracking may be undesirable in <p> There are techniques for eliminating left recursion, but they enlarge the grammar, sometimes significantly <ref> [ASU85] </ref>. Also, there is no clearcut way to transform the semantic actions correctly. 44 * Unless the parser is predictive [ASU85] it may spend considerable time on backtrack ing. * A backtracking parser requires the whole input stream of tokens to be present during parsing. * Backtracking may be undesirable in a compiler where semantic actions are not idem potent, for example in the generation of object code. <p> Nilsson [Nil86] has implemented a nondeterministic bottom-up evaluator for DCGs by letting the parser backtrack over conflicting entries in the parse table. Our approach is to view Definite Clause Grammars as attribute grammars , which have been studied extensively in connection with deterministic translation schemes <ref> [ASU85] </ref>. In terms of argument modes of DCG goals, synthesized attributes correspond to "output" arguments, while inherited attributes correspond to "input" arguments. S-attributed definitions, that is, syntax-directed definitions with only synthesized attributes, can be evaluated by a bottom-up parser as the input is being parsed. <p> The L-attributed definitions allow certain inherited attributes as well, thus forming a proper superset of the S-attributed definitions. Implementation techniques for L-attributed definitions based on grammar modifications or post-traversals of the parse tree are known <ref> [ASU85] </ref>. <p> Top-down parsers have a simple correspondence to L-attributed evaluation <ref> [ASU85] </ref>. Evaluation of inherited attributes in a bottom-up parser is more difficult but can for instance be arranged by the insertion of so called "copy symbols" [Wat77]. One-pass evaluation methods are surveyed by op den Akker et al [odAMT91].
Reference: [AVW93] <author> J. Armstrong, R. Virding, and M. Williams. </author> <title> Concurrent Programming in Erlang. </title> <publisher> Prentice Hall, </publisher> <year> 1993. </year>
Reference-contexts: Today, logic programming is part of college curriculums around the world and thousands of "real" applications have been written in Prolog. Although Prolog is the predominant logic programming language, a number of different dialects have evolved for such areas as parallel programming [Tic91], constraint solving [BC93], and process control <ref> [AVW93] </ref>.
Reference: [BBP + 82] <author> D. L. Bowen, L. Byrd, F. C. N. Pereira, L. M. Pereira, and D. H. D. Warren. </author> <title> DECsystem-10 Prolog User's Manual, </title> <year> 1982. </year>
Reference-contexts: However, Prolog offers very general operator-declaration capabilities, which in theory can introduce significant difficulties with overloaded operators. (Actually, these complicated situations rarely arise in practice, as users refrain from defining an operator structure that they cannot understand themselves.) In Edinburgh Prolog <ref> [BBP + 82] </ref> for instance, the user can define a symbol as an operator of all three fixities and then use the symbol as an operator, or as an operand (nullary operator), or as the functor of a compound term. <p> So-called Definite Clause Grammars (DCGs) are a syntactic variant of Prolog, in which statements are written in a production-rule style, with embedded semantic actions <ref> [BBP + 82] </ref>. This style permits input-driven programs to be developed quickly and concisely. Our parser generator provides a foundation for DCG compilation that overcomes some of the deficiencies of existing implementations. <p> The rules stated here apply to the family of Prolog implementations that adhere to the so called "Edinburgh syntax" <ref> [BBP + 82] </ref>. Since whitespace is important in some examples, we will use the symbol t to indicate any sequence of one or more whitespace characters. 1. Compound terms written in standard syntax have precedence 0. 2.
Reference: [BC93] <editor> F. Benhamou and A. Colmerauer. </editor> <booktitle> Constraint Logic Programming | Selected Research. </booktitle> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: Today, logic programming is part of college curriculums around the world and thousands of "real" applications have been written in Prolog. Although Prolog is the predominant logic programming language, a number of different dialects have evolved for such areas as parallel programming [Tic91], constraint solving <ref> [BC93] </ref>, and process control [AVW93].
Reference: [Bee88] <author> J. Beer. </author> <title> The Occur-Check Problem Revisited. </title> <journal> The Journal of Logic Programming, </journal> <volume> 5(3) </volume> <pages> 243-262, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: Type information can also guide the compiler in replacing costly operations with cheaper ones, as well as assist in other forms of transformations. Occur check The so called occur check <ref> [Pla84, Bee88] </ref> in unification, that is, verifying that the substitution that makes two terms equal does not contain a circular binding, is usually omitted in Prolog systems for efficiency reasons. This may lead to infinite loops or even incorrect answers.
Reference: [BJCD87] <author> M. Bruynooghe, G. Janssens, A. Callebaut, and B. Demoen. </author> <title> Abstract Interpretation: Towards the Global Optimization of Prolog Programs. </title> <booktitle> In Proceedings of the 1987 Symposium on Logic Programming, </booktitle> <pages> pages 192-204, </pages> <address> San Francisco, </address> <month> August - September </month> <year> 1987. </year> <title> IEEE, </title> <publisher> Computer Society Press. </publisher>
Reference-contexts: Logic programs typically have fewer side-effects than their imperative counterparts, and may therefore have more opportunities for parallelization [Tic91, PN91, CWY91, HB88]. Abstract Interpretation Many analysis methods can be captured in the framework of abstract interpretation <ref> [CC92, CC77, Jan90, BJCD87, Bru91, Mel87, MS88] </ref>. In essence, a property of a program can sometimes be deduced by running an "abstract" form of the program, where operations and data values in the original, "concrete", program have been replaced by corresponding abstract values. <p> Further analysis and improvement of the mutual exclusion algorithm may lead to a description in terms of abstract interpretation <ref> [CC92, CC77, Jan90, BJCD87, Bru91] </ref>. Since our method mimics a bottom-up execution, the integration with [MS88] seems most probable. 98
Reference: [BL89] <author> M. E. Bermudez and G. Logothetis. </author> <title> Simple Computation of LALR(1) Lookahead Sets. </title> <journal> Information Processing Letters, </journal> <volume> 31 </volume> <pages> 233-238, </pages> <year> 1989. </year>
Reference-contexts: Such knowledge is stored in a parse table whose construction requires a rather complicated analysis of the production rules (not described here, but see <ref> [BL89, AJ74] </ref>). The parse table encodes a state machine where a state S may have zero or more outgoing arcs, each labeled by some distinct grammar symbol X . Hence, the parse table can be implemented with an array parse table (S; X ). <p> Excellent methods have been developed for generating efficient LL parsers and LR parsers from specifications in the form of production rules, sometimes augmented with associativity and precedence declarations for infix operators <ref> [AJ74, ASU85, BL89, FJ88, Joh75] </ref>. Parser generation methods enjoy several significant advantages over "hand coding": 28 1. The language syntax can be presented in a readable, nonprocedural form, similar to production rules. 2. Embedded semantic actions can be triggered by parsing situations. 3.
Reference: [Boc76] <author> G. V. Bochmann. </author> <title> Semantic Evaluation from Left to Right. </title> <journal> Communications of the ACM, </journal> <volume> 19(2) </volume> <pages> 55-62, </pages> <month> February </month> <year> 1976. </year>
Reference-contexts: Inherent in their design is the 59 assumption that dependencies are no more complicated than that the attribute values of the "working frontier" of the parse tree can be kept on a stack so that evaluation can be done in some left-to-right fashion <ref> [Boc76] </ref>. Therefore, these methods are restricted to the L-attributed grammars. Post-parsing evaluators save the entire parse tree, or its dependency graph, and are thus capable of handling any non-circular grammar by executing the evaluation rules according to the order of the graph.
Reference: [BR91] <author> C. Beeri and R. Ramakrishnan. </author> <title> On the Power of Magic. </title> <journal> The Journal of Logic Programming, 10(1,2,3 and </journal> 4):225-300, 1991. 
Reference-contexts: For imperative languages, this technique has been used in the implementation of for instance RATFOR and C++. In the field of logic programming, the promising new language Goedel is implemented on top of Prolog, and the so called "magic set" transformation <ref> [Ram91, BR91, MSU86] </ref> has been used to implement a bottom-up search using the top-down search method of Prolog. A second reason for transformation is optimization, replacing parts of the program by semantically equivalent code that is more efficient, in some respect, usually time or space.
Reference: [Bro74] <author> B. M. Brosgol. </author> <title> Deterministic Translation Grammars. </title> <type> PhD thesis, </type> <institution> Harvard University, Cambridge, Massachusetts, </institution> <year> 1974. </year> <type> TR 3-74. </type>
Reference-contexts: It is not true, however, that a top-down parser, such as an LL (1) parser is a more powerful specification tool than an bottom-up, LR (1) parser <ref> [Bro74] </ref>. Besides the obvious time and space savings obtained from the one-pass model, attribute values can also be used to solve parsing conflicts, or assist in error recovery. 5.1.1 Related Work Prior work in this area can be divided into one-pass evaluators, post-parsing evaluators, and compromises thereof.
Reference: [Bru91] <author> M. Bruynooghe. </author> <title> A Framework for the Abstract Interpretation of Logic Programs. </title> <journal> The Journal of Logic Programming, 10(1,2,3 and </journal> 4):91-124, 1991. 
Reference-contexts: Logic programs typically have fewer side-effects than their imperative counterparts, and may therefore have more opportunities for parallelization [Tic91, PN91, CWY91, HB88]. Abstract Interpretation Many analysis methods can be captured in the framework of abstract interpretation <ref> [CC92, CC77, Jan90, BJCD87, Bru91, Mel87, MS88] </ref>. In essence, a property of a program can sometimes be deduced by running an "abstract" form of the program, where operations and data values in the original, "concrete", program have been replaced by corresponding abstract values. <p> Further analysis and improvement of the mutual exclusion algorithm may lead to a description in terms of abstract interpretation <ref> [CC92, CC77, Jan90, BJCD87, Bru91] </ref>. Since our method mimics a bottom-up execution, the integration with [MS88] seems most probable. 98
Reference: [BS89a] <author> A. Brodsky and Y. Sagiv. </author> <title> Inference of Monotonicity Constraints in Datalog Programs. </title> <booktitle> In Eighth ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 190-199, </pages> <year> 1989. </year>
Reference-contexts: Therefore son is determinate, but not functional. Various methods for constraint inference in logical rules have been proposed <ref> [UVG88, BS89a, BS89b, KKR90, Las90, SVG91, VG91, BS91] </ref>, but to our knowledge none have been implemented.
Reference: [BS89b] <author> A. Brodsky and Y. Sagiv. </author> <title> On Termination of Datalog Programs. </title> <booktitle> In First International Conference on Deductive and Object-Oriented Databases, </booktitle> <pages> pages 95-112, </pages> <address> Kyoto, Japan, </address> <year> 1989. </year>
Reference-contexts: To deal with this "flaw", researchers have designed criteria for which termination is guaranteed <ref> [Soh93, Plu90, UVG88, BS89b, SVG91, Ped91] </ref>. Again, this illustrates how a deficiency in the language, introduced for efficiency reasons, can be compensated by a static analysis check. The price that is paid, however, is that the analyzer may be overly pessimistic and "reject" a program that does not loop. <p> Therefore son is determinate, but not functional. Various methods for constraint inference in logical rules have been proposed <ref> [UVG88, BS89a, BS89b, KKR90, Las90, SVG91, VG91, BS91] </ref>, but to our knowledge none have been implemented.
Reference: [BS91] <author> A. Brodsky and Y. Sagiv. </author> <title> Inference of inequality constraints in logic programs. </title> <booktitle> In Tenth ACM Symposium on Principles of Database Systems, </booktitle> <year> 1991. </year> <month> 99 </month>
Reference-contexts: Therefore son is determinate, but not functional. Various methods for constraint inference in logical rules have been proposed <ref> [UVG88, BS89a, BS89b, KKR90, Las90, SVG91, VG91, BS91] </ref>, but to our knowledge none have been implemented.
Reference: [CC77] <author> P. Cousot and R. Cousot. </author> <title> Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints. </title> <booktitle> In Conference Record of the 4th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1977. </year>
Reference-contexts: Logic programs typically have fewer side-effects than their imperative counterparts, and may therefore have more opportunities for parallelization [Tic91, PN91, CWY91, HB88]. Abstract Interpretation Many analysis methods can be captured in the framework of abstract interpretation <ref> [CC92, CC77, Jan90, BJCD87, Bru91, Mel87, MS88] </ref>. In essence, a property of a program can sometimes be deduced by running an "abstract" form of the program, where operations and data values in the original, "concrete", program have been replaced by corresponding abstract values. <p> Further analysis and improvement of the mutual exclusion algorithm may lead to a description in terms of abstract interpretation <ref> [CC92, CC77, Jan90, BJCD87, Bru91] </ref>. Since our method mimics a bottom-up execution, the integration with [MS88] seems most probable. 98
Reference: [CC92] <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation and application to logic programs. </title> <journal> The Journal of Logic Programming, </journal> <volume> 13(1, 2, 3 and </volume> 4):103-179, 1992. 
Reference-contexts: Logic programs typically have fewer side-effects than their imperative counterparts, and may therefore have more opportunities for parallelization [Tic91, PN91, CWY91, HB88]. Abstract Interpretation Many analysis methods can be captured in the framework of abstract interpretation <ref> [CC92, CC77, Jan90, BJCD87, Bru91, Mel87, MS88] </ref>. In essence, a property of a program can sometimes be deduced by running an "abstract" form of the program, where operations and data values in the original, "concrete", program have been replaced by corresponding abstract values. <p> Further analysis and improvement of the mutual exclusion algorithm may lead to a description in terms of abstract interpretation <ref> [CC92, CC77, Jan90, BJCD87, Bru91] </ref>. Since our method mimics a bottom-up execution, the integration with [MS88] seems most probable. 98
Reference: [CFZ82] <author> B. Courcelle and P. Franchi-Zannettacci. </author> <title> Attribute Grammars and Recursive Program Schemes (I and II). </title> <booktitle> Theoretical Computer Science, 17(2 and </booktitle> 3):163-191 and 235-257, 1982. 
Reference-contexts: An interesting variation on this method is described by Mayoh [May81]. He shows that attribute grammars can be reformulated as sets of recursive functions, taking the parse tree as an argument. Related ideas have appeared earlier by Kennedy and Warren [KW76], and later by Courcelle et al <ref> [CFZ82] </ref>. Our first method differs in that the functions, which are passed as synthesized attributes, are created while parsing, and only when the evaluation rules contains non-S-attributed constructs. <p> An attribute grammar is strongly non-circular if, for all productions p, there are no cycles in p's strong composite graph. An algorithm for strong non-circularity testing was (accidentally) first given in [Knu68]. Strong non-circularity can be verified in polynomial time <ref> [CFZ82] </ref>. 3. An attribute grammar is L-attributed if it is strongly non-circular and the inherited attributes of X pj depend only on the attributes in I (X p0 ) [ A (X p1 ) [ [ A (X pj1 ). 4.
Reference: [CH87] <author> J. Cohen and T. J. Hickey. </author> <title> Parsing and Compiling Using Prolog. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(2), </volume> <year> 1987. </year>
Reference-contexts: Since Prolog employs a top-down backtracking execution style, the evaluation of DCGs will resemble the behavior of a top-down parser with backtracking. In compiler theory, interest is commonly focused on deterministic languages. The benefit of Prolog as a compiler tool has been observed by Cohen and Hickey <ref> [CH87] </ref>. However, there are several reasons why a top-down backtracking parser is unsuitable for recognizing sentences such as programming language constructs. * A left-recursive production, such as E ! E T , will send the parser into an infinite loop, even though the grammar is not ambiguous.
Reference: [CM81] <author> W. F. Clocksin and C. S. Mellish. </author> <title> Programming in Prolog. </title> <publisher> Springer Verlag, </publisher> <year> 1981. </year>
Reference-contexts: The capabilities of parser generators are limited to LR (1) languages, which is usually considered sufficiently large, and a static input grammar, possibly augmented with associativity and precedence declarations for operators such as "+" and "fl". With the advent of programming languages like Prolog <ref> [SS86, CM81] </ref>, and newer languages such as ML [MTH90] and Haskell [HW90], programmers were allowed to define operators at run time. <p> Preliminaries In order to set the stage for the following chapters, we first review some notation and concepts on parsing and logic programming. For a more extensive treatment we refer the reader to [ASU85, AJ74, FJ88] for context-free grammars and parsing, and <ref> [Llo87, Apt90, CM81, SS86] </ref> for logic programming. A unifying presentation of these two fields can also be found in [DM93]. 2.1 Context Free Grammars A context-free grammar is a four-tuple G = hV N ; V T ; S; P i. <p> In this section we study some typical uses of cuts that has been gathered from textbooks and software libraries. Traditionally, one can identify three uses of cuts <ref> [CM81] </ref>. 1. "If you get this far, you have picked the correct rule for this goal." 2. "If you get to here, you should stop trying to satisfy this goal." 91 3. "If you get to here, you have found the only solution to this problem, and there is no point
Reference: [CWA + 91] <author> M. Carlsson, J. Widen, J. Andersson, S. Andersson, K. Boortz, H. Nilsson, and T. Sjoland. </author> <title> SICStus Prolog User's Manual. </title> <type> Technical report, </type> <institution> Swedish Institute of Computer Science, </institution> <month> Oct </month> <year> 1991. </year>
Reference-contexts: The motivation for this rule is obscure. It does not appear to make Prolog any easier to use, and it certainly complicates the parsing process. In fact, SICSTUS Prolog, who used to implement this rule, have now discarded it <ref> [CWA + 91] </ref>. Rule 4 simply tells us that for instance 'a+' and a+ are not interchangeable because a+ is not a legal atom. <p> For the purposes of this exposition we will use the rather self-explanatory predicate when (Cond; Goal) from SICSTUS Prolog <ref> [CWA + 91] </ref>. When executed, this predicate blocks the execution of Goal until Cond is true. The idea of the transformation is that evaluation rules are "frozen" until their referenced attributes are available. <p> Because of a feature called clause indexing (which most Prolog systems implement, see for instance <ref> [CWA + 91] </ref>) it is not necessary to insert a cut into the first clause. Clause indexing works by letting the interpreter examine the principal functor of the first argument to select the right clause.
Reference: [CWY91] <author> V. Santos Costa, D. H. D. Warren, and R. Yang. </author> <title> The Andorra-I Preprocessor: Supporting Full Prolog on the Basic Andorra Model. </title> <booktitle> In International Conference on Logic Programming, </booktitle> <pages> pages 443-456. </pages> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: In contrast, the algorithm presented in chapter 6 [Pos94] also examines user-defined predicates. Parallelizers On multi-processor machines it is of course desirable to keep all processors occupied. Logic programs typically have fewer side-effects than their imperative counterparts, and may therefore have more opportunities for parallelization <ref> [Tic91, PN91, CWY91, HB88] </ref>. Abstract Interpretation Many analysis methods can be captured in the framework of abstract interpretation [CC92, CC77, Jan90, BJCD87, Bru91, Mel87, MS88]. <p> Also, in the Andorra model [HB88], goals with only one matching clause are executed before other goals. Static analysis has been used to detect such properties of goals <ref> [CWY91, PN91] </ref>. After discussing related work and establishing some required terminology, we illustrate the ideas of our technique by means of a small example before describing the full algorithm. <p> In contrast to earlier work, our algorithm also examines user-defined predicates, even those with recursive definitions. Several methods for static or dynamic inference of determinacy in the parallel language Andorra have been proposed <ref> [PN91, CWY91, KT91] </ref>. In the Andorra model, a goal is determinate if it has at most one matching rule; thus the effort has been directed into checking whether two or more rules can satisfy a goal invocation.
Reference: [Deb89] <author> S. K. Debray. </author> <title> Static Inference of Modes and Data Dependencies in Logic Programs. </title> <journal> ACM TOPLAS, </journal> <volume> 11(3) </volume> <pages> 418-450, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: The following (incomplete) list mentions some analysis methods for logic programming that have been developed throughout the years, primarily for the language Prolog: Mode analysis Probably the most well-known form of analysis is Mode analysis <ref> [Deb89, DW88, Mel81] </ref>. A mode for an argument of a procedure is an adornment, akin to a type declaration, describing how the argument will be bound at the point of invocation. Since procedures compute relations, there is in general no notion of input and output in logic programming.
Reference: [DM93] <author> P. Deransart and J. Ma luszynski. </author> <title> A Grammatical View of Logic Programming. </title> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: For a more extensive treatment we refer the reader to [ASU85, AJ74, FJ88] for context-free grammars and parsing, and [Llo87, Apt90, CM81, SS86] for logic programming. A unifying presentation of these two fields can also be found in <ref> [DM93] </ref>. 2.1 Context Free Grammars A context-free grammar is a four-tuple G = hV N ; V T ; S; P i. The finite disjoint sets of nonterminals V N and terminals V T form the vocabulary V = V N [ V T .
Reference: [DW88] <author> S. K. Debray and D. S. Warren. </author> <title> Automatic Mode Inference for Logic Programs. </title> <journal> The Journal of Logic Programming, </journal> <volume> 5 </volume> <pages> 207-229, </pages> <year> 1988. </year>
Reference-contexts: The following (incomplete) list mentions some analysis methods for logic programming that have been developed throughout the years, primarily for the language Prolog: Mode analysis Probably the most well-known form of analysis is Mode analysis <ref> [Deb89, DW88, Mel81] </ref>. A mode for an argument of a procedure is an adornment, akin to a type declaration, describing how the argument will be bound at the point of invocation. Since procedures compute relations, there is in general no notion of input and output in logic programming.
Reference: [DW89] <author> S. K. Debray and D. S. Warren. </author> <title> Functional Computations in Logic Programs. </title> <journal> ACM TOPLAS, </journal> <volume> 3(3) </volume> <pages> 451-481, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: Traditionally, this is done with the use of a "cut" symbol which cancels certain backtracking activities that would occur in the future. Static analysis can be used to infer these functional computations and insert cut symbols automatically <ref> [DW89] </ref>. The conservative nature 7 of the analyzer guarantees that no solutions are left out because of an inadvertent cut. <p> Existing algorithms <ref> [Mel85, DW89, VR90, ST85] </ref> detect mutual exclusion by looking only at built-in predicates, such as "&lt;" and "". In contrast, the algorithm presented in chapter 6 [Pos94] also examines user-defined predicates. Parallelizers On multi-processor machines it is of course desirable to keep all processors occupied. <p> Mutual exclusion analysis can provide a sufficient condition for cuts to be "green". In a reasonably expressive language (say SQL) the question is undecidable (by essentially the same arguments that show undecidability of "domain independence"). 4. The detection of functionality <ref> [DW89] </ref> represents an important space and time saving optimization for Prolog-like languages. Various forms of functionality have been considered; the algorithm by Debray and Warren defines functionality as when "all alternatives produce the same result, which therefore need not be computed repeatedly" [DW89]. <p> The detection of functionality <ref> [DW89] </ref> represents an important space and time saving optimization for Prolog-like languages. Various forms of functionality have been considered; the algorithm by Debray and Warren defines functionality as when "all alternatives produce the same result, which therefore need not be computed repeatedly" [DW89]. With this information at hand, the execution engine does not need 75 to waste time on, or save state information for finding alternative solutions. Debray and Warren demonstrate that a predicate is functional by showing that each individual clause is functional, and that the clauses are pairwise mutually exclusive. <p> A larger example concludes the chapter. 6.1.1 Related Work The idea of recognizing mutual exclusion in Prolog programs has been considered by Hickey and Mudambi [HM89], Debray and Warren <ref> [DW89] </ref>, and Van Roy [VR90]. Their methods works on the level of primitives, that is, only built-in predicates such as arithmetic comparisons and unifications are examined. In contrast to earlier work, our algorithm also examines user-defined predicates, even those with recursive definitions. <p> based not only on the information in the head of the rule, but also the presence of mutually exclusive subgoals in the bodies, can be useful for this purpose, remains to be explored. 76 A related topic, that of detecting functionality 2 , has been investigated by Debray and Warren <ref> [DW89] </ref>, Sawamura and Takeshima [ST85], and Mellish [Mel85]. A functional predicate is one where all alternatives produce the same result. <p> The third use of the cut is used with the previously mentioned functional computations <ref> [DW89] </ref>; one will often find this type of cut at the very end of a clause. In this chapter, we are naturally interested with the first usage, where the cut is usually found at the beginning of the clause, possibly after some test goals. <p> flag in [O'K90], where colors can be red, white, or blue For the type of mutual exclusion detection discussed here, where the cut is placed early in the clause body, after some initial tests, the author has estimated that about 95% of all programs can be handled by previous algorithms <ref> [HM89, DW89, VR90] </ref>. For the remaining 5% it seems that our algorithm does the job | the limitations mentioned in section 6.5 is not an issue in practice. <p> As mentioned in section 6.1.1 and 6.5, constraint inference methods and detection of functionality can be applied. In this thesis I have not been specific on how mutual exclusion information can be used to optimize programs. In <ref> [DW89] </ref> there is a section on choice points that should be studied by anyone who undertakes an implementation. Specifically, the savecp/cutto-primitives must be used rather than ordinary cuts to eliminate other clauses, for otherwise choice points created by subgoals leading up to the cut gets killed too.
Reference: [Ear70] <author> J. Earley. </author> <title> An Efficient Context-Free Parsing Algorithm. </title> <journal> Communications of the ACM, </journal> <volume> 13(2), </volume> <year> 1970. </year>
Reference-contexts: Parsing runs in linear time and normally uses sublinear stack space. The price that is paid is that only the class of LR (1) languages can be treated, but this is normally a sufficiently large class in practice. Earley's algorithm <ref> [Ear70] </ref> is a general context-free parser. It can handle any grammar but is more expensive than the LR-style techniques because the configuration states of the LR (0) automaton are computed and manipulated as the parse proceeds.
Reference: [FJ88] <author> C. N. Fischer and R. J. LeBlanc Jr. </author> <title> Crafting a Compiler. </title> <publisher> Benjamin-Cummings Publishing Company, Inc, </publisher> <year> 1988. </year>
Reference-contexts: Fortunately, this area is well understood and numerous so 4 Logic Program Parsing Analysis Transformations Compiler ? ? Example Tools Parser Generator Mode Analysis Termination Analysis Type Derivation Partial Evaluators Quintus Prolog called parser generators <ref> [Joh75, ASU85, AJ74, FJ88, Udd88, HKR90, Hor90] </ref> are available to the language designer, who rarely needs to write a parser by hand. Instead, specifications in the form of production rules, with embedded code or "action" routines, are fed into a parser generator which then generates the parser. <p> Preliminaries In order to set the stage for the following chapters, we first review some notation and concepts on parsing and logic programming. For a more extensive treatment we refer the reader to <ref> [ASU85, AJ74, FJ88] </ref> for context-free grammars and parsing, and [Llo87, Apt90, CM81, SS86] for logic programming. A unifying presentation of these two fields can also be found in [DM93]. 2.1 Context Free Grammars A context-free grammar is a four-tuple G = hV N ; V T ; S; P i. <p> Excellent methods have been developed for generating efficient LL parsers and LR parsers from specifications in the form of production rules, sometimes augmented with associativity and precedence declarations for infix operators <ref> [AJ74, ASU85, BL89, FJ88, Joh75] </ref>. Parser generation methods enjoy several significant advantages over "hand coding": 28 1. The language syntax can be presented in a readable, nonprocedural form, similar to production rules. 2. Embedded semantic actions can be triggered by parsing situations. 3.
Reference: [HB88] <author> S. Haridi and P. Brand. </author> <title> Andorra Prolog An integration of Prolog and Committed Choice Languages. </title> <booktitle> In Proceedings of the 1988 International Conference on Fifth Generation Computer Systems, </booktitle> <address> Tokyo, Japan, </address> <pages> pages 745-754, </pages> <year> 1988. </year>
Reference-contexts: In contrast, the algorithm presented in chapter 6 [Pos94] also examines user-defined predicates. Parallelizers On multi-processor machines it is of course desirable to keep all processors occupied. Logic programs typically have fewer side-effects than their imperative counterparts, and may therefore have more opportunities for parallelization <ref> [Tic91, PN91, CWY91, HB88] </ref>. Abstract Interpretation Many analysis methods can be captured in the framework of abstract interpretation [CC92, CC77, Jan90, BJCD87, Bru91, Mel87, MS88]. <p> In a parallel execution strategy with or-parallelism, a set of processors working on mutually exclusive rules can be relieved of their duties as soon as one of them succeeds. Also, in the Andorra model <ref> [HB88] </ref>, goals with only one matching clause are executed before other goals. Static analysis has been used to detect such properties of goals [CWY91, PN91].
Reference: [HKR90] <author> J. Heering, P. Klint, and J. Rekers. </author> <title> Incremental Generation of Parsers. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(12) </volume> <pages> 1344-1351, </pages> <month> Dec </month> <year> 1990. </year>
Reference-contexts: Fortunately, this area is well understood and numerous so 4 Logic Program Parsing Analysis Transformations Compiler ? ? Example Tools Parser Generator Mode Analysis Termination Analysis Type Derivation Partial Evaluators Quintus Prolog called parser generators <ref> [Joh75, ASU85, AJ74, FJ88, Udd88, HKR90, Hor90] </ref> are available to the language designer, who rarely needs to write a parser by hand. Instead, specifications in the form of production rules, with embedded code or "action" routines, are fed into a parser generator which then generates the parser. <p> Tomita's algorithm [Tom86] improves on Earley's algorithm by precompiling the grammar into a parse table, possibly with multiple entries. Still, the language is fixed during the parse and it would not be possible to introduce or change properties of operators on the fly. Incremental parser generators <ref> [HKR90, Hor90] </ref> can be viewed as an application of Tomita's parsing method. They can handle modifications to the input grammar at the expense of recomputing parts of the parse table and having the LR (0) automaton available at run time. Garbage collection also becomes an issue.
Reference: [HM89] <author> T. Hickey and S. Mudambi. </author> <title> Global Compilaton of Prolog. </title> <journal> The Journal of Logic Programming, </journal> <volume> 7 </volume> <pages> 193-230, </pages> <year> 1989. </year>
Reference-contexts: A larger example concludes the chapter. 6.1.1 Related Work The idea of recognizing mutual exclusion in Prolog programs has been considered by Hickey and Mudambi <ref> [HM89] </ref>, Debray and Warren [DW89], and Van Roy [VR90]. Their methods works on the level of primitives, that is, only built-in predicates such as arithmetic comparisons and unifications are examined. In contrast to earlier work, our algorithm also examines user-defined predicates, even those with recursive definitions. <p> algorithm is guaranteed to terminate in so-called semi-polynomial time (O (n 3 )), i.e., polynomial in the size of the rule/goal graph and exponential in the maximum arity of any relation in the program. 6.3.3 Correctness As already pointed out, the mutual exclusion detection problem is, in general, unsolvable (cf. <ref> [HM89] </ref> for an example) and hence no complete algorithm exists. Soundness can be verified by making sure that the function try does not derive a mutual exclusion between two nodes when in fact they are not mutually exclusive. In the proof, we study variable binding relations. <p> flag in [O'K90], where colors can be red, white, or blue For the type of mutual exclusion detection discussed here, where the cut is placed early in the clause body, after some initial tests, the author has estimated that about 95% of all programs can be handled by previous algorithms <ref> [HM89, DW89, VR90] </ref>. For the remaining 5% it seems that our algorithm does the job | the limitations mentioned in section 6.5 is not an issue in practice.
Reference: [Hor90] <author> R. Nigel Horspool. </author> <title> Incremental Generation of LR Parsers. </title> <journal> Computer Languages, </journal> <volume> 15(4) </volume> <pages> 205-223, </pages> <year> 1990. </year>
Reference-contexts: Fortunately, this area is well understood and numerous so 4 Logic Program Parsing Analysis Transformations Compiler ? ? Example Tools Parser Generator Mode Analysis Termination Analysis Type Derivation Partial Evaluators Quintus Prolog called parser generators <ref> [Joh75, ASU85, AJ74, FJ88, Udd88, HKR90, Hor90] </ref> are available to the language designer, who rarely needs to write a parser by hand. Instead, specifications in the form of production rules, with embedded code or "action" routines, are fed into a parser generator which then generates the parser. <p> Tomita's algorithm [Tom86] improves on Earley's algorithm by precompiling the grammar into a parse table, possibly with multiple entries. Still, the language is fixed during the parse and it would not be possible to introduce or change properties of operators on the fly. Incremental parser generators <ref> [HKR90, Hor90] </ref> can be viewed as an application of Tomita's parsing method. They can handle modifications to the input grammar at the expense of recomputing parts of the parse table and having the LR (0) automaton available at run time. Garbage collection also becomes an issue.
Reference: [HTSW74] <author> G. Holloway, J. Townley, J. Spitzen, and B. Wegbreit. </author> <title> ECL Programmer's Manual, </title> <booktitle> 1974. </booktitle> <pages> 100 </pages>
Reference-contexts: Operator precedence parsing is another method with applications to dynamic operators [LdR81] but it can not handle overloaded operators. Permitting user-defined operators was part of the design of several early procedural languages, such as Algol-68 [vW76] and EL1 <ref> [HTSW74] </ref>, but these designs avoided most of the technical difficulties by placing severe restrictions on the definable operators. First, infix operators were limited to 7 to 10 precedence levels. By comparison, C has 15 built-in 29 precedence levels, and Prolog permits 1200. <p> details of the parsing methods can be found in the literature, but it appears that one implementation of EL1 used LR parsing with a mechanism for changing the token of an identifier that had been dynamically declared as an operator "based on local context" before the token reached the parser <ref> [HTSW74] </ref>. Our approach generalizes this technique, postponing the decision until after the parser has seen the token, and even until after additional tokens have been read. Languages have been designed to allow other forms of user-defined syntax besides unary and binary operators. <p> Languages have been designed to allow other forms of user-defined syntax besides unary and binary operators. Among them, EL1 included "bracket-fix operators" and other dynamic syntax; in some cases a new parser would be generated <ref> [HTSW74] </ref>. More recently, Peyton Jones [Jon86] describes a technique for parsing programs that involves user-defined distfix operators, for instance if-then-else-fi, but without support for precedence and associativity declarations. With the advent of languages that permit dynamic operators, numerous ad hoc parsers have been developed.
Reference: [HW90] <editor> P. Hudak and P. Wadler, editors. </editor> <title> Report on the Programming Language Haskell. </title> <institution> Yale University, </institution> <year> 1990. </year>
Reference-contexts: With the advent of programming languages like Prolog [SS86, CM81], and newer languages such as ML [MTH90] and Haskell <ref> [HW90] </ref>, programmers were allowed to define operators at run time. Although operator expressions are only "syntactic sugar", that is, there is always an equivalent prefix form, Prolog's syntax is generally perceived as being easier to read than LISP's prefix notation. <p> Users could define new operators at run time with great flexibility 1 . 2. Expressions using operators were semantically equivalent to prefix form expressions; they were a convenience rather than a necessity. Notably, new functional programming languages, such as ML [MTH90] and Haskell <ref> [HW90] </ref>, are following Prolog's lead in the use of operators. Proper use of operators can make a program easier to read but also complicates the job of parsing the language. Example 3.1.1: The following Prolog rules make extensive use of operators to improve readability.
Reference: [Jan90] <author> G. Janssens. </author> <title> Deriving Run-Time Properties of Logic Programs by means of Abstract Interpretation. </title> <type> PhD thesis, </type> <institution> Dept of Computer Science, Katholieke Universiteit Leuven, Belgium, </institution> <year> 1990. </year>
Reference-contexts: Logic programs typically have fewer side-effects than their imperative counterparts, and may therefore have more opportunities for parallelization [Tic91, PN91, CWY91, HB88]. Abstract Interpretation Many analysis methods can be captured in the framework of abstract interpretation <ref> [CC92, CC77, Jan90, BJCD87, Bru91, Mel87, MS88] </ref>. In essence, a property of a program can sometimes be deduced by running an "abstract" form of the program, where operations and data values in the original, "concrete", program have been replaced by corresponding abstract values. <p> Further analysis and improvement of the mutual exclusion algorithm may lead to a description in terms of abstract interpretation <ref> [CC92, CC77, Jan90, BJCD87, Bru91] </ref>. Since our method mimics a bottom-up execution, the integration with [MS88] seems most probable. 98
Reference: [JM80] <author> N. D. Jones and C. M. Madsen. </author> <title> Attribute-influenced LR parsing. </title> <editor> In N. D. Jones, editor, </editor> <booktitle> Semantics Directed Compiler Generation, </booktitle> <volume> 94, </volume> <pages> pages 393-407. </pages> <publisher> Springer-Verlag, </publisher> <year> 1980. </year>
Reference-contexts: Our first method differs in that the functions, which are passed as synthesized attributes, are created while parsing, and only when the evaluation rules contains non-S-attributed constructs. Another related method is given in <ref> [JM80] </ref> where attribute grammars are analyzed to find out which attributes can be computed during an LR parse. The remaining attributes, called "unknown", are saved for a post-parsing evaluation phase.
Reference: [Joh75] <author> S. C. Johnsson. </author> <title> Yacc|Yet another compiler compiler. </title> <type> Technical Report CSTR 32, </type> <institution> AT&T Bell Laboratories, </institution> <address> Murray Hill, NJ, </address> <year> 1975. </year>
Reference-contexts: Fortunately, this area is well understood and numerous so 4 Logic Program Parsing Analysis Transformations Compiler ? ? Example Tools Parser Generator Mode Analysis Termination Analysis Type Derivation Partial Evaluators Quintus Prolog called parser generators <ref> [Joh75, ASU85, AJ74, FJ88, Udd88, HKR90, Hor90] </ref> are available to the language designer, who rarely needs to write a parser by hand. Instead, specifications in the form of production rules, with embedded code or "action" routines, are fed into a parser generator which then generates the parser. <p> Excellent methods have been developed for generating efficient LL parsers and LR parsers from specifications in the form of production rules, sometimes augmented with associativity and precedence declarations for infix operators <ref> [AJ74, ASU85, BL89, FJ88, Joh75] </ref>. Parser generation methods enjoy several significant advantages over "hand coding": 28 1. The language syntax can be presented in a readable, nonprocedural form, similar to production rules. 2. Embedded semantic actions can be triggered by parsing situations. 3. <p> They use substantially less time and space than Earley's algorithm. In "standard" LR parser generation, as done by Yacc and similar tools, shift/reduce conflicts, as evidenced by multiple entries in the initial parse table, are resolved by consulting declarations concerning (static) operator precedence and associativity <ref> [Joh75] </ref>. If the process is successful, the final parse table becomes deterministic. The main idea of deferred decision parsing is that shift/reduce conflicts involving dynamic operators are left unresolved when the parser is generated.
Reference: [Jon86] <author> S. L. Peyton Jones. </author> <title> Parsing Distfix Operators. </title> <journal> Communications of the ACM, </journal> <volume> 29(2), </volume> <month> Feb </month> <year> 1986. </year>
Reference-contexts: Languages have been designed to allow other forms of user-defined syntax besides unary and binary operators. Among them, EL1 included "bracket-fix operators" and other dynamic syntax; in some cases a new parser would be generated [HTSW74]. More recently, Peyton Jones <ref> [Jon86] </ref> describes a technique for parsing programs that involves user-defined distfix operators, for instance if-then-else-fi, but without support for precedence and associativity declarations. With the advent of languages that permit dynamic operators, numerous ad hoc parsers have been developed. The tokenizer is often embedded in these parsers with attendant complications.
Reference: [JOR75] <author> M. Jazayeri, W. F. Ogden, and W. C. </author> <title> Rounds. The Intrinsically Exponential Complexity of the Circularity Problem for Attribute Grammars. </title> <journal> Communications of the ACM, </journal> <volume> 18 </volume> <pages> 697-721, </pages> <year> 1975. </year>
Reference-contexts: An algorithm for verifying that an attribute grammar is non-circular was first given in [Knu71]. The problem has been shown to have exponential complexity <ref> [JOR75] </ref>. 65 2. An attribute grammar is strongly non-circular if, for all productions p, there are no cycles in p's strong composite graph. An algorithm for strong non-circularity testing was (accidentally) first given in [Knu68]. Strong non-circularity can be verified in polynomial time [CFZ82]. 3.
Reference: [Ker89] <author> J. Kerr. </author> <title> On LR Parsing of Languages with Dynamic Operators. </title> <type> Technical Report UCSC-CRL-89-13, </type> <institution> UC Santa Cruz, </institution> <year> 1989. </year>
Reference-contexts: The method is an extension of earlier work by Kerr <ref> [Ker89] </ref>. It supports all four features that were listed above as being needed by languages with dynamic operators. The resulting parsers are deterministic, and suffer only a small time penalty when compared to LR parsing without dynamic operators. They use substantially less time and space than Earley's algorithm.
Reference: [KKR90] <author> P. C. Kanellakis, G. M. Kuper, and P. Z. Revesz. </author> <title> Constraint query languages. </title> <booktitle> In Ninth ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 299-313, </pages> <year> 1990. </year>
Reference-contexts: Therefore son is determinate, but not functional. Various methods for constraint inference in logical rules have been proposed <ref> [UVG88, BS89a, BS89b, KKR90, Las90, SVG91, VG91, BS91] </ref>, but to our knowledge none have been implemented.
Reference: [Knu68] <author> D. E. Knuth. </author> <title> Semantics of Context-Free Languages. </title> <journal> Mathematical Systems Theory, </journal> <volume> 2(2) </volume> <pages> 127-145, </pages> <year> 1968. </year>
Reference-contexts: The methods presented here can be used as a preprocessor to any parser generator that supports synthesized attributes, for instance Yacc. 5.1 Introduction and Background An attribute grammar <ref> [Knu68] </ref> extends a context-free grammar by attaching attributes to each grammar symbol and by associating evaluation rules to each production, specifying how an attribute value may be computed in terms of other attribute occurrences in the same production. <p> The problem has been shown to have exponential complexity [JOR75]. 65 2. An attribute grammar is strongly non-circular if, for all productions p, there are no cycles in p's strong composite graph. An algorithm for strong non-circularity testing was (accidentally) first given in <ref> [Knu68] </ref>. Strong non-circularity can be verified in polynomial time [CFZ82]. 3. An attribute grammar is L-attributed if it is strongly non-circular and the inherited attributes of X pj depend only on the attributes in I (X p0 ) [ A (X p1 ) [ [ A (X pj1 ). 4.
Reference: [Knu71] <author> D. E. Knuth. </author> <title> Semantics of Context-Free Languages; Correction. </title> <journal> Mathematical Systems Theory, </journal> <volume> 3(1) </volume> <pages> 95-96, </pages> <year> 1971. </year>
Reference-contexts: An algorithm for verifying that an attribute grammar is non-circular was first given in <ref> [Knu71] </ref>. The problem has been shown to have exponential complexity [JOR75]. 65 2. An attribute grammar is strongly non-circular if, for all productions p, there are no cycles in p's strong composite graph. An algorithm for strong non-circularity testing was (accidentally) first given in [Knu68].
Reference: [Kow74] <author> R. A. Kowalski. </author> <title> Predicate logic as a programming language. </title> <booktitle> In Proceedings of IFIP'74, </booktitle> <pages> pages 569-574, </pages> <address> Amsterdam, 1974. </address> <publisher> North-Holland. </publisher>
Reference-contexts: Today, the majority of implementations for logic programming are for the language Prolog, invented in 1972 by Kowalski and Colmerauer <ref> [Kow74, Kow79] </ref>. The success of Prolog as a useful programming language is mostly due to D. H. D. Warren and his work on the WAM [War77, War83], an abstract machine for Prolog execution with a relatively easy translation to today's hardware.
Reference: [Kow79] <author> R. A. Kowalski. </author> <title> Algorithm = logic + control. </title> <journal> Communications of the ACM, </journal> <volume> 22 </volume> <pages> 424-431, </pages> <year> 1979. </year>
Reference-contexts: Today, the majority of implementations for logic programming are for the language Prolog, invented in 1972 by Kowalski and Colmerauer <ref> [Kow74, Kow79] </ref>. The success of Prolog as a useful programming language is mostly due to D. H. D. Warren and his work on the WAM [War77, War83], an abstract machine for Prolog execution with a relatively easy translation to today's hardware.
Reference: [KT91] <author> M. Korsloot and E. Tick. </author> <title> Compilation Techniques for Nondeterministic Flat Concurrent Logic Programming Languages. </title> <booktitle> In International Conference on Logic Programming, </booktitle> <pages> pages 457-471. </pages> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: In contrast to earlier work, our algorithm also examines user-defined predicates, even those with recursive definitions. Several methods for static or dynamic inference of determinacy in the parallel language Andorra have been proposed <ref> [PN91, CWY91, KT91] </ref>. In the Andorra model, a goal is determinate if it has at most one matching rule; thus the effort has been directed into checking whether two or more rules can satisfy a goal invocation.
Reference: [Kun87] <author> K. Kunen. </author> <title> Negation in Logic Programming. </title> <journal> The Journal of Logic Programming, </journal> <volume> 4(4) </volume> <pages> 289-308, </pages> <month> December </month> <year> 1987. </year>
Reference-contexts: Some other transformation methods in logic programming are: various means of implementing negation <ref> [Kun87] </ref>, the replacement of lists with so called "difference lists" [SS86] (which can be concatenated in constant time), and the automatic insertion of control directives which can be done for instance when information on functional computations and mutual exclusion is available. 1.3 Summary of Contributions The results presented in this thesis
Reference: [KW76] <author> K. Kennedy and S. E. Warren. </author> <title> Automatic generation of efficient evaluators. </title> <booktitle> In Proc. 3rd ACM Conference on Principles of Programming Languages, </booktitle> <pages> pages 32-49, </pages> <address> Atlanta, Georgia, </address> <year> 1976. </year>
Reference-contexts: An interesting variation on this method is described by Mayoh [May81]. He shows that attribute grammars can be reformulated as sets of recursive functions, taking the parse tree as an argument. Related ideas have appeared earlier by Kennedy and Warren <ref> [KW76] </ref>, and later by Courcelle et al [CFZ82]. Our first method differs in that the functions, which are passed as synthesized attributes, are created while parsing, and only when the evaluation rules contains non-S-attributed constructs. <p> The first method, based on the ideas by Mayoh [May81], and Kennedy and Warren <ref> [KW76] </ref>, postpones evaluation rules by passing them to the ancestor node as synthesized attributes. In addition to the algorithm we give a theorem to guarantee that attribute evaluation is not unnecessarily delayed and that the transformation is safe.
Reference: [Las90] <author> J.-L. Lassez. </author> <title> Querying constraints. </title> <booktitle> In Ninth ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 288-298, </pages> <year> 1990. </year>
Reference-contexts: Therefore son is determinate, but not functional. Various methods for constraint inference in logical rules have been proposed <ref> [UVG88, BS89a, BS89b, KKR90, Las90, SVG91, VG91, BS91] </ref>, but to our knowledge none have been implemented.
Reference: [LdR81] <author> W. R. LaLonde and J. </author> <title> des Rivieres. Handling Operator Precedence in Arithmetic Expressions with Tree Transformations. </title> <journal> ACM TOPLAS, </journal> <volume> 3(1), </volume> <year> 1981. </year>
Reference-contexts: Garbage collection also becomes an issue. To our knowledge these methods have never been applied to parse languages with dynamically declared operators. Operator precedence parsing is another method with applications to dynamic operators <ref> [LdR81] </ref> but it can not handle overloaded operators. Permitting user-defined operators was part of the design of several early procedural languages, such as Algol-68 [vW76] and EL1 [HTSW74], but these designs avoided most of the technical difficulties by placing severe restrictions on the definable operators.
Reference: [Llo87] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <year> 1987. </year> <month> 101 </month>
Reference-contexts: Preliminaries In order to set the stage for the following chapters, we first review some notation and concepts on parsing and logic programming. For a more extensive treatment we refer the reader to [ASU85, AJ74, FJ88] for context-free grammars and parsing, and <ref> [Llo87, Apt90, CM81, SS86] </ref> for logic programming. A unifying presentation of these two fields can also be found in [DM93]. 2.1 Context Free Grammars A context-free grammar is a four-tuple G = hV N ; V T ; S; P i. <p> In languages where recursion is the only looping construct, such information could mean the difference of executing in constant space as opposed to space being linear with time. 6.2 Definitions Following the standard terminology of <ref> [Llo87] </ref> some additional terms are defined for this chapter. The position of a term t in an atom A is given by the relation A 7! t where is a sequence of numbers that "spells" the argument path to t in A ("Dewey notation").
Reference: [LS91] <author> J. W. Lloyd and J. C. Sheperdson. </author> <title> Partial Evaluation in Logic Programming. </title> <journal> The Journal of Logic Programming, </journal> <volume> 11(3 </volume> & 4):217-242, October/November 1991. 
Reference-contexts: Optimization methods in logic programming are normally targeted at the two "expensive" features of the language, unification and backtracking, as can be witnessed by the analysis methods listed in the previous section. A well-known and very general optimization technique is partial evaluation <ref> [LS91] </ref> whereby a program is in some sense "specialized" with respect to its input. In logic programming, partial evaluation has a particularly easy formulation.
Reference: [May81] <author> B. H. Mayoh. </author> <title> Attribute Grammars and Mathematical Semantics. </title> <journal> SIAM J. Comput., </journal> <volume> 10(3) </volume> <pages> 503-518, </pages> <year> 1981. </year>
Reference-contexts: Post-parsing evaluators save the entire parse tree, or its dependency graph, and are thus capable of handling any non-circular grammar by executing the evaluation rules according to the order of the graph. An interesting variation on this method is described by Mayoh <ref> [May81] </ref>. He shows that attribute grammars can be reformulated as sets of recursive functions, taking the parse tree as an argument. Related ideas have appeared earlier by Kennedy and Warren [KW76], and later by Courcelle et al [CFZ82]. <p> The first method, based on the ideas by Mayoh <ref> [May81] </ref>, and Kennedy and Warren [KW76], postpones evaluation rules by passing them to the ancestor node as synthesized attributes. In addition to the algorithm we give a theorem to guarantee that attribute evaluation is not unnecessarily delayed and that the transformation is safe.
Reference: [Mel81] <author> C. S. Mellish. </author> <title> The Automatic Generation of Mode Declarations for Logic Programs. </title> <type> Technical Report DAI Research Paper 163, </type> <institution> Department of Artificial Intelligence, University of Edinburgh, </institution> <address> Scotland, </address> <year> 1981. </year>
Reference-contexts: The following (incomplete) list mentions some analysis methods for logic programming that have been developed throughout the years, primarily for the language Prolog: Mode analysis Probably the most well-known form of analysis is Mode analysis <ref> [Deb89, DW88, Mel81] </ref>. A mode for an argument of a procedure is an adornment, akin to a type declaration, describing how the argument will be bound at the point of invocation. Since procedures compute relations, there is in general no notion of input and output in logic programming.
Reference: [Mel85] <author> C. S. Mellish. </author> <title> Some Global Optimizations for a Prolog Compiler. </title> <journal> Journal of Logic Programming, </journal> <volume> 2(1) </volume> <pages> 43-66, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: Existing algorithms <ref> [Mel85, DW89, VR90, ST85] </ref> detect mutual exclusion by looking only at built-in predicates, such as "&lt;" and "". In contrast, the algorithm presented in chapter 6 [Pos94] also examines user-defined predicates. Parallelizers On multi-processor machines it is of course desirable to keep all processors occupied. <p> the head of the rule, but also the presence of mutually exclusive subgoals in the bodies, can be useful for this purpose, remains to be explored. 76 A related topic, that of detecting functionality 2 , has been investigated by Debray and Warren [DW89], Sawamura and Takeshima [ST85], and Mellish <ref> [Mel85] </ref>. A functional predicate is one where all alternatives produce the same result.
Reference: [Mel87] <author> C. S. Mellish. </author> <title> Abstract Interpretation of Prolog Programs. </title> <editor> In S. Abramsky and C. Hankin, editors, </editor> <booktitle> Abstract Interpretation of Declarative Languages, </booktitle> <pages> pages 181-198. </pages> <publisher> Ellis Horword, </publisher> <address> Chichester, U.K., </address> <year> 1987. </year>
Reference-contexts: Logic programs typically have fewer side-effects than their imperative counterparts, and may therefore have more opportunities for parallelization [Tic91, PN91, CWY91, HB88]. Abstract Interpretation Many analysis methods can be captured in the framework of abstract interpretation <ref> [CC92, CC77, Jan90, BJCD87, Bru91, Mel87, MS88] </ref>. In essence, a property of a program can sometimes be deduced by running an "abstract" form of the program, where operations and data values in the original, "concrete", program have been replaced by corresponding abstract values.
Reference: [MO81] <author> T. Moto-Oka. </author> <title> Challenge for Knowledge Information Processing Systems (Preliminary Report on Fifth Generation Computer Systems). </title> <booktitle> In International Conference on Fifth Generation Computer Systems, Tokyo, </booktitle> <pages> pages 1-85, </pages> <year> 1981. </year>
Reference-contexts: Originating from such fields as Artificial Intelligence, Automated Theorem-Proving, and Formal Language Theory , logic programming initially received limited attention outside Europe but later gained considerable momentum when the Japanese in 1982 announced that they had chosen logic programming as their vehicle for their Fifth Generation Computer Systems Project FGCS <ref> [MO81] </ref>, also known as the "computer science Pearl Harbor". Today, logic programming is part of college curriculums around the world and thousands of "real" applications have been written in Prolog.
Reference: [MS88] <author> K. Marriott and H. Stndergaard. </author> <title> Bottom-up Abstract Interpretation of Logic Programs. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> <booktitle> Proceedings of the Fifth International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 733-748, </pages> <address> Seattle, 1988. </address> <publisher> ALP, IEEE, The MIT Press. </publisher>
Reference-contexts: Logic programs typically have fewer side-effects than their imperative counterparts, and may therefore have more opportunities for parallelization [Tic91, PN91, CWY91, HB88]. Abstract Interpretation Many analysis methods can be captured in the framework of abstract interpretation <ref> [CC92, CC77, Jan90, BJCD87, Bru91, Mel87, MS88] </ref>. In essence, a property of a program can sometimes be deduced by running an "abstract" form of the program, where operations and data values in the original, "concrete", program have been replaced by corresponding abstract values. <p> Further analysis and improvement of the mutual exclusion algorithm may lead to a description in terms of abstract interpretation [CC92, CC77, Jan90, BJCD87, Bru91]. Since our method mimics a bottom-up execution, the integration with <ref> [MS88] </ref> seems most probable. 98
Reference: [MSU86] <author> F. Bancilhon D. Maier, Y. Sagiv, and J. D. Ullman. </author> <title> Magic sets and other strange ways to implement logic programs. </title> <booktitle> In Fifth ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 1-15, </pages> <year> 1986. </year>
Reference-contexts: For imperative languages, this technique has been used in the implementation of for instance RATFOR and C++. In the field of logic programming, the promising new language Goedel is implemented on top of Prolog, and the so called "magic set" transformation <ref> [Ram91, BR91, MSU86] </ref> has been used to implement a bottom-up search using the top-down search method of Prolog. A second reason for transformation is optimization, replacing parts of the program by semantically equivalent code that is more efficient, in some respect, usually time or space.
Reference: [MTH90] <author> R. Milner, M. Tofte, and R. Harper. </author> <title> The definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: With the advent of programming languages like Prolog [SS86, CM81], and newer languages such as ML <ref> [MTH90] </ref> and Haskell [HW90], programmers were allowed to define operators at run time. Although operator expressions are only "syntactic sugar", that is, there is always an equivalent prefix form, Prolog's syntax is generally perceived as being easier to read than LISP's prefix notation. <p> Users could define new operators at run time with great flexibility 1 . 2. Expressions using operators were semantically equivalent to prefix form expressions; they were a convenience rather than a necessity. Notably, new functional programming languages, such as ML <ref> [MTH90] </ref> and Haskell [HW90], are following Prolog's lead in the use of operators. Proper use of operators can make a program easier to read but also complicates the job of parsing the language. Example 3.1.1: The following Prolog rules make extensive use of operators to improve readability. <p> ML is a language with infix operators only, but these can be declared locally in blocks, with accompanying scope rules <ref> [MTH90] </ref>. Thus in the following example let infix 5 * ; infix 4 + in 1+2*3 + let infix 3 * in 1+2*3 end + 1+2*3 end only the middle use of * would have an unusually low precedence, yielding the answer 23.
Reference: [Nil86] <author> U. Nilsson. </author> <title> AID: An Alternative Implementation of DCGs. </title> <journal> New Generation Computing, </journal> <volume> 4 </volume> <pages> 383-399, </pages> <year> 1986. </year>
Reference-contexts: Deterministic bottom-up parsers, on the other hand, run in linear time, require no input buffering, and handle left-recursive productions as well as right-recursive. They do not normally support ambiguous grammars. Nilsson <ref> [Nil86] </ref> has implemented a nondeterministic bottom-up evaluator for DCGs by letting the parser backtrack over conflicting entries in the parse table. Our approach is to view Definite Clause Grammars as attribute grammars , which have been studied extensively in connection with deterministic translation schemes [ASU85].
Reference: [odAMT91] <author> R. op den Akker, B. Melichar, and J. Tarhio. </author> <title> Attribute evaluation and parsing. </title> <editor> In H. Alblas and B. Melichar, editors, </editor> <title> Attribute Grammars, </title> <booktitle> Applications and Systems, </booktitle> <pages> pages 187-214, </pages> <address> Prague, Czechoslovakia, June 1991. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Top-down parsers have a simple correspondence to L-attributed evaluation [ASU85]. Evaluation of inherited attributes in a bottom-up parser is more difficult but can for instance be arranged by the insertion of so called "copy symbols" [Wat77]. One-pass evaluation methods are surveyed by op den Akker et al <ref> [odAMT91] </ref>. Inherent in their design is the 59 assumption that dependencies are no more complicated than that the attribute values of the "working frontier" of the parse tree can be kept on a stack so that evaluation can be done in some left-to-right fashion [Boc76].
Reference: [O'K84] <author> R. O'Keefe. </author> <title> Draft Proposed Standard for Prolog Evaluable Predicates. </title> <type> Technical report, </type> <institution> Department of Artificial Intelligence, University of Edinburgh, </institution> <year> 1984. </year>
Reference-contexts: Back in 1984, when the first efforts on a standardization of Prolog began, it was said that syntactical differences between Prolog versions could be trivially overcome, due to the availability of the DEC-10 Prolog parser read.pl <ref> [O'K84] </ref>. Almost ten years later we find that two of the most widely used Prolog systems are based on read.pl, but because of changes and bug-fixes disagree on some inputs.
Reference: [O'K90] <author> R. O'Keefe. </author> <title> The Craft of Prolog. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Fig. 4.2 shows the input to our parser generator DDGEN. The scanner we use is rdtok.pl <ref> [O'K90] </ref> with a minor modification: rather than acquiring the whole list of tokens before parsing commences we get the next token each time we perform a shift. <p> Other examples requiring our algorithm are databases, parsers, and the problem of the Dutch national flag in <ref> [O'K90] </ref>, where colors can be red, white, or blue For the type of mutual exclusion detection discussed here, where the cut is placed early in the clause body, after some initial tests, the author has estimated that about 95% of all programs can be handled by previous algorithms [HM89, DW89, VR90].
Reference: [Ped91] <author> K. R. Apt D. Pedreschi. </author> <title> Proving termination of general Prolog programs. </title> <booktitle> In Proceedings of International Conference on Theoretical Aspects of Computer Science, Sendai, </booktitle> <address> Japan, </address> <year> 1991. </year>
Reference-contexts: To deal with this "flaw", researchers have designed criteria for which termination is guaranteed <ref> [Soh93, Plu90, UVG88, BS89b, SVG91, Ped91] </ref>. Again, this illustrates how a deficiency in the language, introduced for efficiency reasons, can be compensated by a static analysis check. The price that is paid, however, is that the analyzer may be overly pessimistic and "reject" a program that does not loop.
Reference: [Pfe92] <editor> F. Pfenning, editor. </editor> <booktitle> Types in Logic Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: Mode analysis is often assumed for other analysis tools, in particular the mutual exclusion test described in chapter 6. Modes are also described in chapter 2. Type derivation Experience with languages such as ML have lead people to incorporate type derivation and type checking into logic programming as well <ref> [Pfe92] </ref>. As opposed 6 to type systems in older languages, such as Pascal, the types of arguments are derived automatically, with minimal assistance from the programmer. Type errors, appearing as inconsistencies in the derivation, can help the programmer find subtle bugs at compile-time, rather than at run-time (by chance).
Reference: [Pla84] <author> D. A. Plaisted. </author> <title> The Occur-Check Problem in Prolog. </title> <booktitle> In Proc. International Symposium on Logic Programming, </booktitle> <pages> pages 272-280, </pages> <address> Atlantic City, 1984. </address> <publisher> IEEE, Computer Society Press. </publisher>
Reference-contexts: Type information can also guide the compiler in replacing costly operations with cheaper ones, as well as assist in other forms of transformations. Occur check The so called occur check <ref> [Pla84, Bee88] </ref> in unification, that is, verifying that the substitution that makes two terms equal does not contain a circular binding, is usually omitted in Prolog systems for efficiency reasons. This may lead to infinite loops or even incorrect answers.
Reference: [Plu90] <author> L. Plumer. </author> <title> Termination Proofs for Logic Programs, </title> <booktitle> volume 446 of Lecture Notes in Artificial Intelligence. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1990. </year> <month> 102 </month>
Reference-contexts: To deal with this "flaw", researchers have designed criteria for which termination is guaranteed <ref> [Soh93, Plu90, UVG88, BS89b, SVG91, Ped91] </ref>. Again, this illustrates how a deficiency in the language, introduced for efficiency reasons, can be compensated by a static analysis check. The price that is paid, however, is that the analyzer may be overly pessimistic and "reject" a program that does not loop.
Reference: [PN91] <author> D. Palmer and L. Naish. NUA-Prolog: </author> <title> An Extension to the WAM for Parallel Andorra. </title> <booktitle> In International Conference on Logic Programming, </booktitle> <pages> pages 429-442. </pages> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: In contrast, the algorithm presented in chapter 6 [Pos94] also examines user-defined predicates. Parallelizers On multi-processor machines it is of course desirable to keep all processors occupied. Logic programs typically have fewer side-effects than their imperative counterparts, and may therefore have more opportunities for parallelization <ref> [Tic91, PN91, CWY91, HB88] </ref>. Abstract Interpretation Many analysis methods can be captured in the framework of abstract interpretation [CC92, CC77, Jan90, BJCD87, Bru91, Mel87, MS88]. <p> Also, in the Andorra model [HB88], goals with only one matching clause are executed before other goals. Static analysis has been used to detect such properties of goals <ref> [CWY91, PN91] </ref>. After discussing related work and establishing some required terminology, we illustrate the ideas of our technique by means of a small example before describing the full algorithm. <p> In contrast to earlier work, our algorithm also examines user-defined predicates, even those with recursive definitions. Several methods for static or dynamic inference of determinacy in the parallel language Andorra have been proposed <ref> [PN91, CWY91, KT91] </ref>. In the Andorra model, a goal is determinate if it has at most one matching rule; thus the effort has been directed into checking whether two or more rules can satisfy a goal invocation.
Reference: [Pos94] <author> K. Post. </author> <title> Mutually Exclusive Rules in Logic Programming. </title> <booktitle> In Logic Programming | Proceedings of the 1994 International Symposium. </booktitle> <publisher> MIT Press, </publisher> <year> 1994. </year> <note> To appear. </note>
Reference-contexts: Existing algorithms [Mel85, DW89, VR90, ST85] detect mutual exclusion by looking only at built-in predicates, such as "&lt;" and "". In contrast, the algorithm presented in chapter 6 <ref> [Pos94] </ref> also examines user-defined predicates. Parallelizers On multi-processor machines it is of course desirable to keep all processors occupied. Logic programs typically have fewer side-effects than their imperative counterparts, and may therefore have more opportunities for parallelization [Tic91, PN91, CWY91, HB88].
Reference: [PVGK93] <author> K. Post, A. Van Gelder, and J. Kerr. </author> <title> Deterministic Parsing of Languages with Dynamic Operators. </title> <editor> In D. Miller, editor, </editor> <booktitle> Logic Programming | Proceedings of the 1993 International Symposium, </booktitle> <pages> pages 456-472. </pages> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: In addition to the algorithm we give a theorem to guarantee that attribute evaluation is not unnecessarily delayed and that the transformation is safe. The second method is influenced by ideas in [Udd88] and also by comments from the reviewers of <ref> [PVGK93] </ref>. <p> those who transitively depend on the unavailable I (X p0 ); the other attributes (that can be computed) are captured by the definition of Ready (p) 70 Implementation We have implemented algorithm 5.3.1 in Prolog as a front-end to our LR parser generator DDGEN, which in itself generates Prolog parsers <ref> [PVGK93] </ref>. Together, they serve as a replacement for the traditional implementation of Definite Clause Grammars, namely top-down parsing with backtracking. In Prolog, synthesized functions can be implemented either by passing goals and using call for application, or by creating new predicates with assert.
Reference: [Ram91] <author> R. Ramakrishnan. </author> <title> Magic Templates: A Spellbinding Approach To Logic Programs. </title> <journal> The Journal of Logic Programming, </journal> <volume> 11(3 </volume> & 4):189-216, Octo-ber/November 1991. 
Reference-contexts: For imperative languages, this technique has been used in the implementation of for instance RATFOR and C++. In the field of logic programming, the promising new language Goedel is implemented on top of Prolog, and the so called "magic set" transformation <ref> [Ram91, BR91, MSU86] </ref> has been used to implement a bottom-up search using the top-down search method of Prolog. A second reason for transformation is optimization, replacing parts of the program by semantically equivalent code that is more efficient, in some respect, usually time or space.
Reference: [Rob65] <author> J. A. Robinson. </author> <title> A machine-oriented logic based on the resolution principle. </title> <journal> The Journal of the ACM, </journal> <volume> 12(1) </volume> <pages> 23-41, </pages> <year> 1965. </year>
Reference-contexts: Two expressions E 1 and E 2 are said to be unifiable if there exists a substitution such that E 1 = E 2 . If so, is called a unifier. There exists a unification algorithm <ref> [Rob65] </ref> that for any two expressions produces their most general unifier (mgu) if they are unifiable and otherwise reports that the two expressions are not unifiable.
Reference: [Sah93] <author> D. Sahlin. MIXTUS: </author> <title> An Automatic Partial Evaluator for Full Prolog. </title> <journal> New Generation Computing, </journal> <volume> 12(1) </volume> <pages> 7-51, </pages> <year> 1993. </year>
Reference-contexts: notation [XjT ] which represents a list whose first element is X and whose tail is T . 9 Partial evaluation for Prolog is in general more difficult due to the presence of extra-logical features and side effects, although successful partial evaluators have been built, for instance the MIXTUS system <ref> [Sah93] </ref>.
Reference: [Sco90] <author> R. S. Scowen. </author> <title> Prolog - Budapest papers - 2 - Input/Output, Arithmetic, Modules, </title> <type> etc. </type> <institution> Technical Report ISO/IEC JTC1 SC22 WG17 N69, International Organization for Standardization, </institution> <year> 1990. </year>
Reference-contexts: As the Prolog standardization committee recognized in a 1990 report <ref> [Sco90] </ref>, "These possibilities provide multiple opportunities for ambiguity and the draft standard has therefore defined restrictions on the syntax so that a) ex 32 pressions can still be parsed from left to right without needing significant back tracking or look-ahead: : : " A preliminary report on this work showed that
Reference: [Sco92] <author> R. S. Scowen. </author> <title> Draft Prolog Standard. </title> <note> Technical Report ISO/IEC JTC1 SC22 WG17 N92, International Organization for Standardization, </note> <year> 1992. </year>
Reference-contexts: The ISO committee has subsequently relaxed most of the restrictions, but at the expense of more complex rules for terms <ref> [Sco92] </ref>. The modular design of our system permits different conflict resolution strategies and operator-restriction policies to be "plugged in", and thus may serve as a valuable tool for investigating languages that are well-defined, yet have very flexible operator capabilities. <p> the input is 1 R 2 L 3. (R and L have the same precedence, but are declared right-associative and left-associative, respectively.) This is parsed as 1 R (2 L 3), which conform with all Prolog systems that we are aware of, as well as the most recent ISO draft <ref> [Sco92] </ref>. 37 Stack 1 0 3 0 op (-) 3 var (X) 4 4 0 op (-) 3 term 5 5 0 term 10 6 0 term 10 op (+) 6 7 0 term 10 op (+) 6 var (Y) 4 8 0 term 10 op (+) 6 term 7 9 <p> Working backwards, we can remove the production A N i ! B right to make the grammar deterministic again, which leads to the policy just presented The recent ISO draft proposes a different set of restrictions to avoid ambiguities <ref> [Sco92] </ref>. Probably neither solution is the final word.
Reference: [Soh93] <author> K. Sohn. </author> <title> Automated Termination Analysis for Logic Programs. </title> <type> PhD thesis, </type> <institution> UC Santa Cruz, </institution> <year> 1993. </year>
Reference-contexts: To deal with this "flaw", researchers have designed criteria for which termination is guaranteed <ref> [Soh93, Plu90, UVG88, BS89b, SVG91, Ped91] </ref>. Again, this illustrates how a deficiency in the language, introduced for efficiency reasons, can be compensated by a static analysis check. The price that is paid, however, is that the analyzer may be overly pessimistic and "reject" a program that does not loop.
Reference: [SS86] <author> L. Sterling and E. Shapiro. </author> <title> The Art of Prolog. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mas-sachusetts, </address> <year> 1986. </year>
Reference-contexts: The capabilities of parser generators are limited to LR (1) languages, which is usually considered sufficiently large, and a static input grammar, possibly augmented with associativity and precedence declarations for operators such as "+" and "fl". With the advent of programming languages like Prolog <ref> [SS86, CM81] </ref>, and newer languages such as ML [MTH90] and Haskell [HW90], programmers were allowed to define operators at run time. <p> Some other transformation methods in logic programming are: various means of implementing negation [Kun87], the replacement of lists with so called "difference lists" <ref> [SS86] </ref> (which can be concatenated in constant time), and the automatic insertion of control directives which can be done for instance when information on functional computations and mutual exclusion is available. 1.3 Summary of Contributions The results presented in this thesis fit directly into the various stages for the framework that <p> Preliminaries In order to set the stage for the following chapters, we first review some notation and concepts on parsing and logic programming. For a more extensive treatment we refer the reader to [ASU85, AJ74, FJ88] for context-free grammars and parsing, and <ref> [Llo87, Apt90, CM81, SS86] </ref> for logic programming. A unifying presentation of these two fields can also be found in [DM93]. 2.1 Context Free Grammars A context-free grammar is a four-tuple G = hV N ; V T ; S; P i.
Reference: [ST85] <author> H. Sawamura and T. Takeshima. </author> <title> Recursive Unsolvability of Determinacy, Solvable Cases of Determinacy and their Applications to Prolog Optimization. </title> <booktitle> In Proceedings of the 1985 Symposium on Logic Programming, </booktitle> <pages> pages 200-207, </pages> <address> Boston, Massachusetts, 1985. </address> <publisher> IEEE, </publisher> <address> Washington D.C. </address>
Reference-contexts: Existing algorithms <ref> [Mel85, DW89, VR90, ST85] </ref> detect mutual exclusion by looking only at built-in predicates, such as "&lt;" and "". In contrast, the algorithm presented in chapter 6 [Pos94] also examines user-defined predicates. Parallelizers On multi-processor machines it is of course desirable to keep all processors occupied. <p> the information in the head of the rule, but also the presence of mutually exclusive subgoals in the bodies, can be useful for this purpose, remains to be explored. 76 A related topic, that of detecting functionality 2 , has been investigated by Debray and Warren [DW89], Sawamura and Takeshima <ref> [ST85] </ref>, and Mellish [Mel85]. A functional predicate is one where all alternatives produce the same result.
Reference: [SVG91] <author> K. Sohn and A. Van Gelder. </author> <title> Termination detection in logic program using argument sizes. </title> <booktitle> In Tenth ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 216-226, </pages> <year> 1991. </year>
Reference-contexts: To deal with this "flaw", researchers have designed criteria for which termination is guaranteed <ref> [Soh93, Plu90, UVG88, BS89b, SVG91, Ped91] </ref>. Again, this illustrates how a deficiency in the language, introduced for efficiency reasons, can be compensated by a static analysis check. The price that is paid, however, is that the analyzer may be overly pessimistic and "reject" a program that does not loop. <p> Therefore son is determinate, but not functional. Various methods for constraint inference in logical rules have been proposed <ref> [UVG88, BS89a, BS89b, KKR90, Las90, SVG91, VG91, BS91] </ref>, but to our knowledge none have been implemented.
Reference: [Tic91] <author> E. Tick. </author> <title> Parallel Logic Programming. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: Today, logic programming is part of college curriculums around the world and thousands of "real" applications have been written in Prolog. Although Prolog is the predominant logic programming language, a number of different dialects have evolved for such areas as parallel programming <ref> [Tic91] </ref>, constraint solving [BC93], and process control [AVW93]. <p> In contrast, the algorithm presented in chapter 6 [Pos94] also examines user-defined predicates. Parallelizers On multi-processor machines it is of course desirable to keep all processors occupied. Logic programs typically have fewer side-effects than their imperative counterparts, and may therefore have more opportunities for parallelization <ref> [Tic91, PN91, CWY91, HB88] </ref>. Abstract Interpretation Many analysis methods can be captured in the framework of abstract interpretation [CC92, CC77, Jan90, BJCD87, Bru91, Mel87, MS88].
Reference: [Tom86] <author> M. Tomita. </author> <title> Efficient Parsing for Natural Language. </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, Massachusetts, </address> <year> 1986. </year>
Reference-contexts: Parsing an input string of length n may require O (n 3 ) time (although LR (k) grammars only take linear time), O (n 2 ) space, and an input-buffer of size n. Tomita's algorithm <ref> [Tom86] </ref> improves on Earley's algorithm by precompiling the grammar into a parse table, possibly with multiple entries. Still, the language is fixed during the parse and it would not be possible to introduce or change properties of operators on the fly.
Reference: [Udd88] <author> G. Uddeborg. </author> <title> A Functional Parser Generator. </title> <type> Technical Report 43, </type> <institution> Dept. of Computer Sciences, Chalmers University of Technology, Goteborg, </institution> <year> 1988. </year>
Reference-contexts: Fortunately, this area is well understood and numerous so 4 Logic Program Parsing Analysis Transformations Compiler ? ? Example Tools Parser Generator Mode Analysis Termination Analysis Type Derivation Partial Evaluators Quintus Prolog called parser generators <ref> [Joh75, ASU85, AJ74, FJ88, Udd88, HKR90, Hor90] </ref> are available to the language designer, who rarely needs to write a parser by hand. Instead, specifications in the form of production rules, with embedded code or "action" routines, are fed into a parser generator which then generates the parser. <p> The remaining attributes, called "unknown", are saved for a post-parsing evaluation phase. In contrast, our methods are more "eager" because computation of unknown attributes is not necessarily put off until after the parse. The functional parser generator FPG <ref> [Udd88] </ref> generates parsers for Lazy ML, a functional programming language with lazy evaluation. Due to the demand-driven nature of this evaluation method, attribute evaluation comes "for free" and works for all non-circular grammars. <p> In addition to the algorithm we give a theorem to guarantee that attribute evaluation is not unnecessarily delayed and that the transformation is safe. The second method is influenced by ideas in <ref> [Udd88] </ref> and also by comments from the reviewers of [PVGK93].
Reference: [Ull89] <author> J. D. Ullman. </author> <title> Database and Knowledge-Base Systems. </title> <publisher> Computer Science Press, </publisher> <year> 1989. </year>
Reference-contexts: In the proof, we study variable binding relations. These are relations whose attributes corresponds to the variables appearing in a node, and whose values represent possible bindings for the variables. For a precise definition of variable bindings, see <ref> [Ull89, page 748] </ref>. <p> p 0 p 1 ; : : : ; p m the variable bindings V 0 for p 0 can be described in terms of a natural join between the variable bindings V i for the subgoals in the body: V 0 = V 1 1 1 V m (cf. <ref> [Ull89, page 751] </ref>) Lemma 6.3.1: If R = R 1 1 1 R m then R i (R) R i . Proof: Assume by contradiction that there is a in R such that [R i ] is not in R i .
Reference: [UVG88] <author> J. D. Ullman and A. Van Gelder. </author> <title> Efficient tests for top-down termination of logical rules. </title> <journal> Journal of the ACM, </journal> <volume> 35(2) </volume> <pages> 345-373, </pages> <year> 1988. </year>
Reference-contexts: To deal with this "flaw", researchers have designed criteria for which termination is guaranteed <ref> [Soh93, Plu90, UVG88, BS89b, SVG91, Ped91] </ref>. Again, this illustrates how a deficiency in the language, introduced for efficiency reasons, can be compensated by a static analysis check. The price that is paid, however, is that the analyzer may be overly pessimistic and "reject" a program that does not loop. <p> Therefore son is determinate, but not functional. Various methods for constraint inference in logical rules have been proposed <ref> [UVG88, BS89a, BS89b, KKR90, Las90, SVG91, VG91, BS91] </ref>, but to our knowledge none have been implemented.
Reference: [VG91] <author> A. Van Gelder. </author> <title> Deriving constraints among argument sizes in logic programs. </title> <journal> Annals of Mathematics and Artificial Intelligence, </journal> <volume> 1(3) </volume> <pages> 361-392, </pages> <year> 1991. </year> <month> 103 </month>
Reference-contexts: Therefore son is determinate, but not functional. Various methods for constraint inference in logical rules have been proposed <ref> [UVG88, BS89a, BS89b, KKR90, Las90, SVG91, VG91, BS91] </ref>, but to our knowledge none have been implemented.
Reference: [VR90] <author> P. Van Roy. </author> <title> Can Logic Programming Execute as Fast as Imperative Programming? PhD thesis, </title> <institution> UC Berkeley, </institution> <year> 1990. </year>
Reference-contexts: Existing algorithms <ref> [Mel85, DW89, VR90, ST85] </ref> detect mutual exclusion by looking only at built-in predicates, such as "&lt;" and "". In contrast, the algorithm presented in chapter 6 [Pos94] also examines user-defined predicates. Parallelizers On multi-processor machines it is of course desirable to keep all processors occupied. <p> A larger example concludes the chapter. 6.1.1 Related Work The idea of recognizing mutual exclusion in Prolog programs has been considered by Hickey and Mudambi [HM89], Debray and Warren [DW89], and Van Roy <ref> [VR90] </ref>. Their methods works on the level of primitives, that is, only built-in predicates such as arithmetic comparisons and unifications are examined. In contrast to earlier work, our algorithm also examines user-defined predicates, even those with recursive definitions. <p> flag in [O'K90], where colors can be red, white, or blue For the type of mutual exclusion detection discussed here, where the cut is placed early in the clause body, after some initial tests, the author has estimated that about 95% of all programs can be handled by previous algorithms <ref> [HM89, DW89, VR90] </ref>. For the remaining 5% it seems that our algorithm does the job | the limitations mentioned in section 6.5 is not an issue in practice.
Reference: [vW76] <author> A. van Wijngaarden, </author> <title> editor. Revised Report on the Algorithmic Language Algol 68. </title> <publisher> Springer-Verlag, </publisher> <year> 1976. </year>
Reference-contexts: Operator precedence parsing is another method with applications to dynamic operators [LdR81] but it can not handle overloaded operators. Permitting user-defined operators was part of the design of several early procedural languages, such as Algol-68 <ref> [vW76] </ref> and EL1 [HTSW74], but these designs avoided most of the technical difficulties by placing severe restrictions on the definable operators. First, infix operators were limited to 7 to 10 precedence levels. By comparison, C has 15 built-in 29 precedence levels, and Prolog permits 1200.
Reference: [War77] <author> D. H. D. Warren. </author> <title> Implementing Prolog Compiling Predicate Logic Programs. </title> <note> Technical Report DAI Research Paper 39 and 40, </note> <institution> Department of Artificial Intelligence, University of Edinburgh, </institution> <address> Scotland, </address> <year> 1977. </year>
Reference-contexts: Today, the majority of implementations for logic programming are for the language Prolog, invented in 1972 by Kowalski and Colmerauer [Kow74, Kow79]. The success of Prolog as a useful programming language is mostly due to D. H. D. Warren and his work on the WAM <ref> [War77, War83] </ref>, an abstract machine for Prolog execution with a relatively easy translation to today's hardware. Since then, compilers have improved in many ways: they produce better code, generate better diagnostics, and partly relieve the programmer from supplying extra-logical information.
Reference: [War83] <author> D. H. D. Warren. </author> <title> An Abstract Prolog Instruction Set. </title> <type> Technical Report Tech. Note 309, </type> <institution> SRI International, </institution> <address> Menlo Park, CA, </address> <year> 1983. </year>
Reference-contexts: Today, the majority of implementations for logic programming are for the language Prolog, invented in 1972 by Kowalski and Colmerauer [Kow74, Kow79]. The success of Prolog as a useful programming language is mostly due to D. H. D. Warren and his work on the WAM <ref> [War77, War83] </ref>, an abstract machine for Prolog execution with a relatively easy translation to today's hardware. Since then, compilers have improved in many ways: they produce better code, generate better diagnostics, and partly relieve the programmer from supplying extra-logical information.
Reference: [War86] <author> D. H. D. Warren. </author> <title> Optimizing Tail Recursion in Prolog. </title> <booktitle> In Logic Programming and its Applications, </booktitle> <pages> pages 77-90. </pages> <publisher> Ablex Publishing, </publisher> <address> N.J., </address> <year> 1986. </year>
Reference-contexts: For instance, early Prolog compilers were quite naive in their execution of tail-recursive procedures and depended on the programmer to insert control information, so called "cut" symbols, into the code to prevent the stack from exploding. Today, tail recursion optimization <ref> [War86] </ref> is part of every serious Prolog system. <p> But if the rules are mutually exclusive to each other, such information can be discarded if the success of all subgoals appearing before the recursive call contradicts the other rules. This creates more opportunities for tail recursion optimization <ref> [War86] </ref> and will also prevent the execution engine from wasting time on the other rules, in case all solutions are asked for. 2. In a bottom-up execution strategy the union of relations from mutually exclusive rules is a disjoint union; duplicates cannot occur. 3.

Reference: [] <author> (empty list): </author> <title> 17 "+: 51 k (disjoint): 77 "j": </title> <type> 11 </type>
References-found: 94

