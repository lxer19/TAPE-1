URL: http://www.cs.wustl.edu/cs/techreports/1993/wucs-93-50.ps.Z
Refering-URL: http://www.cs.wustl.edu/cs/cs/publications.html
Root-URL: http://www.cs.wustl.edu
Title: DNA Mapping Algorithms: Fragment Matching Mistake Detection and Correction  
Author: Jim Daues Will Gillett 
Note: This work was supported by the James S. McDonnell Foundation under Grant 87-24 and NIH under grant R01 HG00180.  
Address: Saint Louis, Missouri 63130 (314) 935-6160  
Affiliation: DEPARTMENT OF COMPUTER SCIENCE WASHINGTON UNIVERSITY  
Date: October 1993  
Pubnum: WUCS-93-50  
Abstract-found: 0
Intro-found: 1
Reference: 1. <author> Maynard V. Olson, James E. Dutchik, Madge Y. G raham, Garret M. Brodeur, Cynthia Helms, Mark Frank, Mia MacCollin, Robert Scheinman, and Thomas Frank, </author> <title> Random-Clone Strategy for Genomic Restriction Mapping in Yeast, </title> <journal> Proc. Natl. Acad. Sci. (Genetics), </journal> <volume> Vol. 83, </volume> <pages> pp. </pages> <month> 7826-7830 (October, </month> <year> 1986). </year>
Reference-contexts: Consequently, 513 is chosen to match with 515, and 527 remains unmatched. Since there are no more fragments to consider, the mapping of Clone #1 with Clone #3 is complete. There is now a fragment matching or fragmat <ref> (i.e., 61986109, 40824087, 11501139, 10921078, 637630, 513515) </ref> which describes the matches which exist between the two clones. It is also known which fragments in each clone did not pair. Using these data, the two clones can be put together as shown in Figure 4. <p> STACK scan_right (ml,ps,s,lfs 1 ,lfs 2 ,starts) LIST ml; PARTIAL_SCAN ps; STACK s; SET lfs 1 ,lfs 2 ; INTEGER starts; - STACK ans; PARTIAL_SCAN ps'; ps' ps; ps'.atvml ps'.atvml || ml; if (lfs 1 = ) then ps'.cfs 1 ps'.ss 1 <ref> [1] </ref>; if (starts = 1) then ps'.first_set FALSE; fi else ps'.cfs 1 lfs 1 ; if (lfs 2 = ) then ps'.cfs 2 ps'.ss 2 [1]; if (starts = 2) then ps'.first_set FALSE; fi else ps'.cfs 2 lfs 2 ; ans s; stack_push (ans,ps'); returns (ans); - DNA Mapping - 33 <p> 2 ; INTEGER starts; - STACK ans; PARTIAL_SCAN ps'; ps' ps; ps'.atvml ps'.atvml || ml; if (lfs 1 = ) then ps'.cfs 1 ps'.ss 1 <ref> [1] </ref>; if (starts = 1) then ps'.first_set FALSE; fi else ps'.cfs 1 lfs 1 ; if (lfs 2 = ) then ps'.cfs 2 ps'.ss 2 [1]; if (starts = 2) then ps'.first_set FALSE; fi else ps'.cfs 2 lfs 2 ; ans s; stack_push (ans,ps'); returns (ans); - DNA Mapping - 33 - F MMD&C STACK fix_by_ignore (ml,ps,s,starts) LIST ml; PARTIAL_SCAN ps; STACK s; INTEGER starts; - STACK ans; PARTIAL_SCAN ps'; ans s; if (ml =/ [] <p> s; stack_push (ans,ps'); returns (ans); - DNA Mapping - 33 - F MMD&C STACK fix_by_ignore (ml,ps,s,starts) LIST ml; PARTIAL_SCAN ps; STACK s; INTEGER starts; - STACK ans; PARTIAL_SCAN ps'; ans s; if (ml =/ [] or ps.atvml =/ []) then ps' ps; ps'.atvml ps'.atvml || ml; ps'.cfs starts ps'.ss starts <ref> [1] </ref>; ps'.ss starts ps'.ss starts [2,...]; ps'.first_set FALSE; stack_push (ans,ps'); fi return (ans); - DNA Mapping - 34 - F MMD&C STACK fix_by_discard (ml,ps,s,lfs 1 ,lfs 2 ) LIST ml; PARTIAL_SCAN ps; STACK s; SET lfs 1 ,lfs 2 ; INTEGER i,j,dr 1 ,dr 2 ; BOOLEAN discard 1 ,discard 2 <p> = NOT_MATCHED and mt 2 = NOT_MATCHED) then discard 1+2 TRUE; fi if (discard 1+2 and dr 1 &gt; 0 and dr 2 &gt; 0) then ps' ps; ps'.atvml ps'.atvml || ml; ps'.discards 1 ps'.discards 1 lfs 1 ; ps'.discards 2 ps'.discards 2 lfs 2 ; ps'.cfs 1 ps'.ss 1 <ref> [1] </ref>; ps'.ss 1 ps'.ss 1 [2,...]; ps'.first_set FALSE; stack_push (ans,ps'); fi if (discard i and dr i &gt; 0) then if (i = 1) then j 2; else j 1; fi ps' ps; ps'.atvml ps'.atvml || ml; ps'.discards i ps'.discards i lfs i ; ps'.cfs i ps'.ss i [1]; ps'.ss i <p> ps'.ss 1 <ref> [1] </ref>; ps'.ss 1 ps'.ss 1 [2,...]; ps'.first_set FALSE; stack_push (ans,ps'); fi if (discard i and dr i &gt; 0) then if (i = 1) then j 2; else j 1; fi ps' ps; ps'.atvml ps'.atvml || ml; ps'.discards i ps'.discards i lfs i ; ps'.cfs i ps'.ss i [1]; ps'.ss i ps'.ss i [2,...]; if (starts = i) then ps'.first_set FALSE; fi stack_push (ans,ps'); fi return (ans); - DNA Mapping - 35 - F MMD&C If either of the new CFSs is NULL, then the scan cannot continue. <p> find_initial_partial_scan creates a PARTIAL_SCAN ps 0 that represents the initial state of the search for ATVMLs. (The pseudocode for find_initial_partial_scan is given in Figure 29, and the values of the PARTIAL_SCAN find_initial_partial_scan (ss 1 ,ss 2 ) LIST ss 1 ,ss 2 ; - PARTIAL_SCAN ans; ans.cfs 1 ss 1 <ref> [1] </ref>; ans.ss 1 ss 1 [2,...]; ans.atvml []; ans.discards 1 ; ans.discards 2 ; ans.first_set TRUE; return (ans); - DNA Mapping - 36 - F MMD&C various fields of ps 0 are given in Figure 30.) Then ps 0 is pushed onto an empty stack s and the while loop is <p> DNA Mapping - 40 - F MMD&C MATCH_TYPE best_match_ahead (s,ss) SET s; LIST ss; - MATCH_TYPE ans; SET s,mls; LIST ss,ml; if (s = ) then ans MATCHED; else if (ss = []) then ans RAN_OUT; else ans NOT_MATCHED; mls find_best_matchlists (s,ss <ref> [1] </ref>); for ml mls do s s left_elements_of (ml); if (s = ) then ans MATCHED; else if (|ml| = |ss [1]|) then ss ss [2,...]; if (best_match_ahead (s,ss) = MATCHED) then ans MATCHED; fi fi fi return (ans); - DNA Mapping - 41 - F MMD&C g 2 Z 2 <p> ss; - MATCH_TYPE ans; SET s,mls; LIST ss,ml; if (s = ) then ans MATCHED; else if (ss = []) then ans RAN_OUT; else ans NOT_MATCHED; mls find_best_matchlists (s,ss <ref> [1] </ref>); for ml mls do s s left_elements_of (ml); if (s = ) then ans MATCHED; else if (|ml| = |ss [1]|) then ss ss [2,...]; if (best_match_ahead (s,ss) = MATCHED) then ans MATCHED; fi fi fi return (ans); - DNA Mapping - 41 - F MMD&C g 2 Z 2 direction scan Now, fix_by_discard must decide which (if any) virtual fragments can be discarded based on rules dc 1 and dc
Reference: 2. <author> Linda Riles, James E. Dutchik, Amara Baktha, Brigid K. McCauley, Edward C. Thayer, Mary P. Leckie, Valerie V. Braden, Julie E. Depke, and Maynard V. Olson, </author> <title> Physical maps of the six smallest chromosomes of Saccharomyces cerevisiae at a resolution of 2.6 kilobase pairs, </title> <journal> Genetics, </journal> <volume> Vol. 134, </volume> <pages> pp. </pages> <month> 81-150 (May </month> <year> 1993). </year>
Reference: 3. <author> Will Gillett, </author> <title> DNA Mapping Algorithms: Strategies for Single Restriction Enzyme and Multiple Restriction Enzyme Mapping, </title> <institution> Washington University, Dept. of Computer Science, </institution> <type> Technical Report WUCS-92-29, </type> <month> August </month> <year> 1992. </year>
Reference-contexts: A fragment matching mistake can occur when two real fragments of similar length occur in the genome roughly one clone length apart. This is also referred to as the collapsed fragment error (e.g., in Gillett) <ref> [3] </ref> to emphasize the fact that two real fragments from the underlying genome have been incorrectly collapsed into one fragment in the map being constructed. Consider the example illustrated in Figure 10. The top horizontal line in Figure 10 represents a section of a genome.
Reference: 4. <author> Eric S. Lander and Michael S. Waterman, </author> <title> Genomic Mapping By Fingerprinting Random Clones: </title>
References-found: 4

