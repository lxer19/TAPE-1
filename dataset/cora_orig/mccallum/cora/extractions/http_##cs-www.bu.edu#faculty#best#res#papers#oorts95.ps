URL: http://cs-www.bu.edu/faculty/best/res/papers/oorts95.ps
Refering-URL: http://cs-www.bu.edu/faculty/best/res/Home.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: (best@cs.bu.edu)  
Title: Preserving the Causal and Structural Properties of Real-Time Systems using Object Oriented Specification in Cleopatra  
Author: Azer Bestavros 
Address: Boston University, MA 02215  
Affiliation: Computer Science Department  
Date: October 1995.  
Note: In OORTS'95: The 1995 IEEE Workshop on Object OrientedReal-Time Systems, San Antonio, Texas,  
Abstract: The specification of a real-time system is often the result of a process, whereby a conceptual control system is fleshed out as a computer program. To be accurate, this process must preserve important causal and structural properties of the control system. For example, if the control system has multiple functional components operating concurrently, then the process of mapping these components into a computer program executing on a single processor, must ensure that these components do not interact in ways that are physically impossible. In this paper we review our work on CLEOPATRA, an object oriented specification and programming language that restricts expressiveness in a way that allows the specification of only reactive, spontaneous, and causal computation. Unrealistic systems|possessing properties such as infinite capacities or perfect timing|cannot even be specified. We argue that this "ounce of prevention" at the specification level is likely to spare a lot of time and energy in the development cycle|not to mention the elimination of potential hazards that would have gone, otherwise, unnoticed. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Y. Aloimonos, I. Weiss, and A. Bandyopadhyay. </author> <title> Active vision. </title> <booktitle> In Proceedings of the 1st IEEE Conference on Computer Vision, </booktitle> <pages> pages 35-54, </pages> <address> London, Great Britain, </address> <year> 1987. </year>
Reference-contexts: In particular, it might require the robot to remain stand still at a given coordinate 14 Active perception implies usage of the robots manipulative systems to move about and interact with the environment in ways that serve the sensory processes <ref> [1, 2, 3] </ref>. for a specific period of time in the future to grab a frame. One can think of the motor units of the robot as a limited resource that must be shared between the active perception and manipulative systems.
Reference: [2] <author> R. </author> <title> Bajcsy. Active perception versus passive perception. </title> <booktitle> In Proceedings 3rd IEEE Workshop on Computer Vision, </booktitle> <pages> pages 55-59, </pages> <address> Bellaire, CA, </address> <year> 1985. </year>
Reference-contexts: In particular, it might require the robot to remain stand still at a given coordinate 14 Active perception implies usage of the robots manipulative systems to move about and interact with the environment in ways that serve the sensory processes <ref> [1, 2, 3] </ref>. for a specific period of time in the future to grab a frame. One can think of the motor units of the robot as a limited resource that must be shared between the active perception and manipulative systems.
Reference: [3] <author> R. </author> <title> Bajcsy. Perception with feedback. </title> <booktitle> In Proceedings of the 1988 Darpa Image Understanding Workshop, </booktitle> <year> 1988. </year>
Reference-contexts: In particular, it might require the robot to remain stand still at a given coordinate 14 Active perception implies usage of the robots manipulative systems to move about and interact with the environment in ways that serve the sensory processes <ref> [1, 2, 3] </ref>. for a specific period of time in the future to grab a frame. One can think of the motor units of the robot as a limited resource that must be shared between the active perception and manipulative systems.
Reference: [4] <author> Azer Bestavros. </author> <title> The Michael - Merlin Connection: Programming tools for the remote control of the American Cimflex robot. Robotics Laboratory, </title> <publisher> Harvard University, </publisher> <address> Cambridge, MA, </address> <month> September </month> <year> 1988. </year>
Reference-contexts: The VM02 master computer of the Merlin controller runs a High Speed Host Interface (HSHI) program that allows it to receive commands at a rate of up to 250 commands per second a 4 milliseconds latency to remotely control the robot from a host computer. In <ref> [4] </ref> we described an interface that we designed and implemented to allow a SUN workstation to communicate with HSHI via a dual-ported shared memory piggy-backed on the Bit-3 VME-VME adaptor. A drawback of that connection was our reliance on UNIX, a non-real-time operating system.
Reference: [5] <author> Azer Bestavros. </author> <title> TRA-based real-time executable specification using CLEOPATRA. </title> <booktitle> In Proceedings of the 10th Annual Rochester Forth Conference on Embedded Systems, </booktitle> <address> Rochester, NY, </address> <month> June </month> <year> 1990. </year> <month> (revised May </month> <year> 1991). </year>
Reference-contexts: In particular, we used it to simulate and analyze asynchronous digital circuits, sensory-motor behavior of autonomous creatures, and intelligent controllers <ref> [6, 11, 5] </ref>. A compiler that allows the execution of CLEOPATRA specifications has been developed [12, 9], and is available via FTP from cs.bu.edu:/bestavros/cleopatra/. CLEOPATRA is based on the Time-constrained Reactive Automata (TRA) formalism [7, 8].
Reference: [6] <author> Azer Bestavros. </author> <title> Planning for embedded systems: A real-time prospective. </title> <booktitle> In Proceedings of AIRTC-91: The 3rd IFAC Workshop on Artificial Intelligence in Real Time Control, Napa/Sonoma Region, </booktitle> <address> CA, </address> <month> September </month> <year> 1991. </year>
Reference-contexts: In particular, we used it to simulate and analyze asynchronous digital circuits, sensory-motor behavior of autonomous creatures, and intelligent controllers <ref> [6, 11, 5] </ref>. A compiler that allows the execution of CLEOPATRA specifications has been developed [12, 9], and is available via FTP from cs.bu.edu:/bestavros/cleopatra/. CLEOPATRA is based on the Time-constrained Reactive Automata (TRA) formalism [7, 8]. <p> We have used the CLEOPATRA compiler to simulate a variety of systems. In particular, we used it extensively to specify and analyze sensory-motor robotics applications [11] and to simulate complex behaviors of autonomous creatures <ref> [6] </ref>. Figure 5 shows the different stages involved in the compilation and execution of specifications written in CLEOPATRA. At the heart of this process is a one-pass preprocessor, written in C, which parses user-defined CLEOPATRA specifications, augmented with system defined TRA classes, 7 and generates an equivalent C simulator. <p> This methodology is in line with the subsumption architecture [13], which empowers a module from a higher layer to overwrite the output of a module from a lower layer. The higher layer is called TRA-class mimic (double CHECK_DLY, CNTRL_DLY, LATCH_DLY, FEED_DLY, ACK_DLY, TICK) i_pos (double <ref> [6] </ref>), c_pos (double [6]), ctrl_ack () -&gt; ctrl (double [6]), alarm (int) - state: double old_pos [6], req_pos [6] ; bool ready = FALSE ; internal: -&gt; safety_check () ; act: init () -&gt; safety_check (), ctrl (req_pos) : commit - initialize (req_pos,old_pos) ; ready = TRUE ; toggle = 0 <p> This methodology is in line with the subsumption architecture [13], which empowers a module from a higher layer to overwrite the output of a module from a lower layer. The higher layer is called TRA-class mimic (double CHECK_DLY, CNTRL_DLY, LATCH_DLY, FEED_DLY, ACK_DLY, TICK) i_pos (double <ref> [6] </ref>), c_pos (double [6]), ctrl_ack () -&gt; ctrl (double [6]), alarm (int) - state: double old_pos [6], req_pos [6] ; bool ready = FALSE ; internal: -&gt; safety_check () ; act: init () -&gt; safety_check (), ctrl (req_pos) : commit - initialize (req_pos,old_pos) ; ready = TRUE ; toggle = 0 ; - safety_check <p> The higher layer is called TRA-class mimic (double CHECK_DLY, CNTRL_DLY, LATCH_DLY, FEED_DLY, ACK_DLY, TICK) i_pos (double <ref> [6] </ref>), c_pos (double [6]), ctrl_ack () -&gt; ctrl (double [6]), alarm (int) - state: double old_pos [6], req_pos [6] ; bool ready = FALSE ; internal: -&gt; safety_check () ; act: init () -&gt; safety_check (), ctrl (req_pos) : commit - initialize (req_pos,old_pos) ; ready = TRUE ; toggle = 0 ; - safety_check () -&gt; safety_check (): within [CHECK_DLY~CHECK_DLY+TICK] <p> The higher layer is called TRA-class mimic (double CHECK_DLY, CNTRL_DLY, LATCH_DLY, FEED_DLY, ACK_DLY, TICK) i_pos (double <ref> [6] </ref>), c_pos (double [6]), ctrl_ack () -&gt; ctrl (double [6]), alarm (int) - state: double old_pos [6], req_pos [6] ; bool ready = FALSE ; internal: -&gt; safety_check () ; act: init () -&gt; safety_check (), ctrl (req_pos) : commit - initialize (req_pos,old_pos) ; ready = TRUE ; toggle = 0 ; - safety_check () -&gt; safety_check (): within [CHECK_DLY~CHECK_DLY+TICK] ; safety_check () -&gt; alarm (0): unless <p> The higher layer is called TRA-class mimic (double CHECK_DLY, CNTRL_DLY, LATCH_DLY, FEED_DLY, ACK_DLY, TICK) i_pos (double <ref> [6] </ref>), c_pos (double [6]), ctrl_ack () -&gt; ctrl (double [6]), alarm (int) - state: double old_pos [6], req_pos [6] ; bool ready = FALSE ; internal: -&gt; safety_check () ; act: init () -&gt; safety_check (), ctrl (req_pos) : commit - initialize (req_pos,old_pos) ; ready = TRUE ; toggle = 0 ; - safety_check () -&gt; safety_check (): within [CHECK_DLY~CHECK_DLY+TICK] ; safety_check () -&gt; alarm (0): unless (safe (req_pos,
Reference: [7] <author> Azer Bestavros. </author> <title> Specification and verification or real-time embedded systems using the Time-constrained Reactive Automata. </title> <booktitle> In Proceedings of RTSS'91: The 12 th IEEE Real-time Systems Symposium, </booktitle> <pages> pages 244-253, </pages> <address> San Antonio, Texas, </address> <month> December </month> <year> 1991. </year>
Reference-contexts: A compiler that allows the execution of CLEOPATRA specifications has been developed [12, 9], and is available via FTP from cs.bu.edu:/bestavros/cleopatra/. CLEOPATRA is based on the Time-constrained Reactive Automata (TRA) formalism <ref> [7, 8] </ref>. Using the TRA model, an embedded system is viewed as a set of automata (TRAs), each representing an autonomous system entity.
Reference: [8] <author> Azer Bestavros. </author> <title> Time-constrained Reactive Automata: A novel development methodology for embedded real-time systems. </title> <type> PhD thesis, </type> <institution> Harvard University, Division of Applied Sciences (Department of Computer Science), Cambridge, Massachusetts, </institution> <month> September </month> <year> 1991. </year>
Reference-contexts: A compiler that allows the execution of CLEOPATRA specifications has been developed [12, 9], and is available via FTP from cs.bu.edu:/bestavros/cleopatra/. CLEOPATRA is based on the Time-constrained Reactive Automata (TRA) formalism <ref> [7, 8] </ref>. Using the TRA model, an embedded system is viewed as a set of automata (TRAs), each representing an autonomous system entity. <p> This reduces the verification process to that of establishing correspondences preservation and implementation between such objects. The correspondence between CLEOPATRA and the TRA formalism is straightforward. Every object in CLEOPATRA corresponds to a TRA. In <ref> [8] </ref>, the construction of a TRA, given a CLEOPATRA object, is detailed. This paper is organized as follows. In Section 2, we describe the CLEOPATRA specification/programming language, along with an example that illustrates our "ounce of prevention" thesis [10]. <p> To avoid such malignant behaviors, the environment must wait for an acknowledg ment ack () 6 , or else wait for at least DLY MIN before issuing a new input. Such safety conditions can be verified using TRA-based verification techniques <ref> [8] </ref>. We argue that any finite implementation of a discrete-event delay element must have a finite capacity, which must not be exceeded for a correct behavior. Using CLEOPATRA, it is impossible to specify a fifo class that behaves correctly independent of its environment's behavior.
Reference: [9] <author> Azer Bestavros. Cleopatra: </author> <title> Physically-correct specifications of embedded real-time programs. </title> <booktitle> In Proceedings of the ACM SIGPLAN Workshop on Language, Compiler and Tool Support for Real-Time Systems, </booktitle> <address> Orlando, FL, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: In particular, we used it to simulate and analyze asynchronous digital circuits, sensory-motor behavior of autonomous creatures, and intelligent controllers [6, 11, 5]. A compiler that allows the execution of CLEOPATRA specifications has been developed <ref> [12, 9] </ref>, and is available via FTP from cs.bu.edu:/bestavros/cleopatra/. CLEOPATRA is based on the Time-constrained Reactive Automata (TRA) formalism [7, 8]. Using the TRA model, an embedded system is viewed as a set of automata (TRAs), each representing an autonomous system entity.
Reference: [10] <author> Azer Bestavros. </author> <title> An ounce of prevention is worth a pound of cure: Towards physically-correct specifications of embedded real-time systems. </title> <booktitle> In Proceedings of COMPASS'94: The Ninth Annual IEEE Conference on Computer Assurance, </booktitle> <address> Gaithersburg, MD, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: Every object in CLEOPATRA corresponds to a TRA. In [8], the construction of a TRA, given a CLEOPATRA object, is detailed. This paper is organized as follows. In Section 2, we describe the CLEOPATRA specification/programming language, along with an example that illustrates our "ounce of prevention" thesis <ref> [10] </ref>. In Section 3, we present a compiler that allows the execution of CLEOPATRA specifications for simulation/validation purposes. In Section 4, we describe an implementation environment, in which CLEOPATRA was used to program the motion controller for a robotics experiment.
Reference: [11] <author> Azer Bestavros, James Clark, and Nicola Ferrier. </author> <title> Management of sensori-motor activity in mobile robots. </title> <booktitle> In Proceedings of the 1990 IEEE International Conference on Robotics & Automation, </booktitle> <address> Cinci-nati, Ohio, May 1990. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: In particular, we used it to simulate and analyze asynchronous digital circuits, sensory-motor behavior of autonomous creatures, and intelligent controllers <ref> [6, 11, 5] </ref>. A compiler that allows the execution of CLEOPATRA specifications has been developed [12, 9], and is available via FTP from cs.bu.edu:/bestavros/cleopatra/. CLEOPATRA is based on the Time-constrained Reactive Automata (TRA) formalism [7, 8]. <p> We have used the CLEOPATRA compiler to simulate a variety of systems. In particular, we used it extensively to specify and analyze sensory-motor robotics applications <ref> [11] </ref> and to simulate complex behaviors of autonomous creatures [6]. Figure 5 shows the different stages involved in the compilation and execution of specifications written in CLEOPATRA. <p> The motion control operating system must arbitrate and/or coordinate between the conflicting requirements of these two systems in a way which allows the goals of the two systems to be attained. In <ref> [11] </ref>, we suggested a methodology based on the TRA model that allows one to schedule the motor commands sent to the various actuators in the robot in a manner appropriate to the robot goals. In [15], an experiment that adopts the TRA framework was proposed.
Reference: [12] <author> Azer Bestavros, Devora Reich, and Robert Popp. </author> <title> CLEOPATRA compiler design and implementation. </title> <type> Technical Report TR-92-019, </type> <institution> Computer Science Department, Boston University, </institution> <address> Boston, MA, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: In particular, we used it to simulate and analyze asynchronous digital circuits, sensory-motor behavior of autonomous creatures, and intelligent controllers [6, 11, 5]. A compiler that allows the execution of CLEOPATRA specifications has been developed <ref> [12, 9] </ref>, and is available via FTP from cs.bu.edu:/bestavros/cleopatra/. CLEOPATRA is based on the Time-constrained Reactive Automata (TRA) formalism [7, 8]. Using the TRA model, an embedded system is viewed as a set of automata (TRAs), each representing an autonomous system entity.
Reference: [13] <author> Rodney A. Brooks. </author> <title> A robust layered control system for a mobile robot. </title> <journal> IEEE Journal on Robotics and Automation, </journal> <volume> RA-2:14-23, </volume> <month> April </month> <year> 1986. </year>
Reference-contexts: Our implementation enabled more complex behaviors (specified in CLEOPATRA and running concurrently) to deal with these exceptions. This methodology is in line with the subsumption architecture <ref> [13] </ref>, which empowers a module from a higher layer to overwrite the output of a module from a lower layer.
Reference: [14] <author> Jen-Yao Chung, Jane Liu, and Kwei-Jay Lin. </author> <title> Scheduling periodic jobs that allow imprecise results. </title> <journal> IEEE Transaction on Computers, </journal> <volume> 19(9) </volume> <pages> 1156-1173, </pages> <month> Septem-ber </month> <year> 1990. </year>
Reference-contexts: It can be enhanced by restricting expressiveness as was done in Real-Time Euclid [17], by sacrificing accuracy as was done in the Flex system <ref> [14] </ref>, or by abstracting segmented resources as was done in the Spring kernel [19]. The TRA-development methodology we are advocating in this paper introduces one more way of improving predictability, that of allowing only physically-sound specifications.
Reference: [15] <author> James Clark, Nicola Ferrier, and Lei Wang. </author> <title> A robotics system for manipulation using directed vision feedback. </title> <type> Internal report, </type> <institution> Robotics laboratory, Harvard University, </institution> <address> Cambridge, MA, </address> <year> 1991. </year>
Reference-contexts: The absence of a unified suitable formal framework that addresses the aforementioned issues severely limits the usefulness of these studies. This situation is further exacerbated considering the range of disciplines employed in developing the various components of an embedded application. For example, in a simple sensory-motor robotic application <ref> [15] </ref>, algorithms from various disciplines like low-level imaging, active vision, tactile sensing, path planning, compliant motion control, and non-linear dynamics may be utilized [16]. <p> In [11], we suggested a methodology based on the TRA model that allows one to schedule the motor commands sent to the various actuators in the robot in a manner appropriate to the robot goals. In <ref> [15] </ref>, an experiment that adopts the TRA framework was proposed. The experiment involves the coordination of motor requests to perform manipulative tasks using directed-vision feedback. The testbed for the experiment (Figure 11) consists of a six-degrees of freedom (American Cimflex) industrial robot connected to a dedicated (Merlin) controller.
Reference: [16] <author> K. S. Fu, R. C. Gonzalez, and C. S. G. Lee. </author> <title> Robotics: Control, </title> <booktitle> sensing, vision, and intelligence. </booktitle> <publisher> McGraw-Hill Book Company, </publisher> <year> 1987. </year>
Reference-contexts: For example, in a simple sensory-motor robotic application [15], algorithms from various disciplines like low-level imaging, active vision, tactile sensing, path planning, compliant motion control, and non-linear dynamics may be utilized <ref> [16] </ref>. Not only are these disciplines different in their abstractions and programming styles, but also they differ in their computational requirements, which range from single-board dedicated processors to massively parallel general-purpose computers.
Reference: [17] <author> Eugene Kligerman and Alexander Stoyenko. </author> <title> Real-time Euclid: A language for reliable real-time systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 12(9) </volume> <pages> 941-949, </pages> <month> September </month> <year> 1986. </year>
Reference-contexts: Subsumption allows control systems to be patched up by allowing smarter (or higher priority) behaviors to take over from default behaviors whenever appropriate. 5 Conclusion Predictability can be enhanced in a variety of ways. It can be enhanced by restricting expressiveness as was done in Real-Time Euclid <ref> [17] </ref>, by sacrificing accuracy as was done in the Flex system [14], or by abstracting segmented resources as was done in the Spring kernel [19]. The TRA-development methodology we are advocating in this paper introduces one more way of improving predictability, that of allowing only physically-sound specifications.
Reference: [18] <author> Nancy Lynch and Mark Tuttle. </author> <title> An introduc tion to Input/Output Automata. </title> <type> Technical Report MIT/LCS/TM-373, </type> <institution> MIT, Cambridge, Massachusetts, </institution> <month> November </month> <year> 1988. </year>
Reference-contexts: CLEOPATRA is based on the Time-constrained Reactive Automata (TRA) formalism [7, 8]. Using the TRA model, an embedded system is viewed as a set of automata (TRAs), each representing an autonomous system entity. TRAs are reactive in that they abide by Lynch's input enabling property <ref> [18] </ref>; they communicate by signaling events on their output channels and by reacting to events signaled on their input channels. The behavior of a TRA is governed by time-constrained causal relationships between computation-triggering events.
Reference: [19] <author> John Stankovic and Krithi Ramamritham. </author> <title> The Spring Kernel: A new paradigm for real-time operating systems. </title> <journal> ACM Operating Systems Review, </journal> <volume> 23(3) </volume> <pages> 54-71, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: It can be enhanced by restricting expressiveness as was done in Real-Time Euclid [17], by sacrificing accuracy as was done in the Flex system [14], or by abstracting segmented resources as was done in the Spring kernel <ref> [19] </ref>. The TRA-development methodology we are advocating in this paper introduces one more way of improving predictability, that of allowing only physically-sound specifications. Pursuing the ideas presented in this paper will undoubtedly provide us with one more handle in our persistent quest for predictable systems.
Reference: [20] <author> Niklaus Wirth. </author> <title> Toward a discipline of real-time pro gramming. </title> <journal> Communications of the ACM, </journal> <volume> 20(8), </volume> <month> August </month> <year> 1977. </year>
Reference-contexts: The sustained demands of the environments in which such systems operate pose relatively rigid and urgent performance requirements. Often, these requirements are stated as tim fl This work has been partially supported by NSF (grant CCR-9308344). ing constraints on their behaviors. Wirth <ref> [20] </ref> singled out this aspect as the one aspect that differentiates real-time from other sequential and parallel systems. This led to a body of research on real-time computing, which encompasses issues of specification techniques, validation and prototyping, formal verification, fault-tolerance, safety analysis, programming languages, development tools, scheduling, and operating systems.
Reference: [21] <author> Pamela Zave. </author> <title> The operational versus the conventional approach to software development. </title> <journal> Communications of the ACM, </journal> <volume> 27(2) </volume> <pages> 104-118, </pages> <month> February </month> <year> 1984. </year>
Reference-contexts: In contrast to the black box approach, the operational approach calls for problem specification by formulating a system to solve it. The formulated system is given in terms of implementation-independent structures that, once implemented, would generate the required behavior <ref> [21] </ref>. 3 CLEOPATRA-based Validation We have developed a compiler that transforms CLEOPATRA specifications into an event-driven simulator for validation purposes. We have used the CLEOPATRA compiler to simulate a variety of systems.
References-found: 21

