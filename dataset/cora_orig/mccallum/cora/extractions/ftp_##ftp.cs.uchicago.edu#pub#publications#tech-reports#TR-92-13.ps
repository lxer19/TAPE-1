URL: ftp://ftp.cs.uchicago.edu/pub/publications/tech-reports/TR-92-13.ps
Refering-URL: http://cs-www.uchicago.edu/publications/tech-reports/
Root-URL: 
Phone: 2  
Title: Gap-Definability as a Closure Property  
Author: Stephen Fenner ?? Lance Fortnow ??? and Lide Li y 
Address: 96 Falmouth St., Portland, ME 04103, USA  1100 E. 58th St., Chicago, IL 60637, USA  
Affiliation: 1 University of Southern Maine, Computer Science Department,  University of Chicago, Department of Computer Science,  
Abstract: Gap-definability and the gap-closure operator were defined in [FFK91]. Few complexity classes were known at that time to be gap-definable. In this paper, we give simple characterizations of both gap-definability and the gap-closure operator, and we show that many com plexity classes are gap-definable, including P #P , P #P[1] , PSPACE, EXP, NEXP, MP, and BP P. If a class is closed under union, intersection and contains ; and fl , then it is gap-definable if and only if it contains SPP; its gap-closure is the closure of this class together with SPP under union and intersection. On the other hand, we give some examples of classes which are reasonable gap-definable but not closed under union (resp. intersection, complement). Finally, we show that a complexity class such as PP or PSPACE, if it is not equal to SPP, contains a maximal proper gap-definable subclass which is closed under many-one reductions.
Abstract-found: 1
Intro-found: 1
Reference: [BGH90] <author> R. Beigel, J. Gill, and U. Hertrampf. </author> <title> Counting classes: Thresholds, parity, </title> <booktitle> mods, and fewness. In Proceedings of the 7th Symposium on Theoretical Aspects of Computer Science, </booktitle> <pages> pages 49-57, </pages> <year> 1990. </year>
Reference-contexts: It has been shown that #P is closed under addition, multiplication and binomial coefficients <ref> [BGH90] </ref>. GapP has all these closure properties and it is also closed under subtraction [FFK91].
Reference: [BRS91] <author> R. Beigel, N. Reingold, and D. Spielman. </author> <title> PP is closed under intersection. </title> <booktitle> In Proc. of the 23rd ACM Symp. on the Theory of Computing, </booktitle> <pages> pages 1-9, </pages> <year> 1991. </year>
Reference-contexts: E-mail: lilide@cs.uchicago.edu rejecting paths of NP Turing machines. This class is exactly the closure of #P under subtraction. GapP also has all the other nice closure properties of #P, such as addition, multiplication, and binomial coefficients. Beigel, Reingold, & Spielman first used gaps to great advantage in <ref> [BRS91] </ref> to show that PP is closed under intersection. Toda and Ogiwara have also formulated their results in [TO92] using GapP instead of #P. Fenner, Fortnow and Kurtz looked at classes such as PP, C = P, P and SPP that can be defined in terms of GapP functions.
Reference: [FFK91] <author> S. Fenner, L. Fortnow, and S. Kurtz. </author> <title> Gap-definable counting classes. </title> <booktitle> In Proc. of the 6th Structure in Complexity Theory Conf., </booktitle> <pages> pages 30-42, </pages> <year> 1991. </year>
Reference-contexts: Also, one cannot express as a #P function the permanent of a matrix with arbitrary (possibly negative) integer entries, or even a simple polynomial-time function which outputs negative values. Fenner, Fortnow and Kurtz <ref> [FFK91] </ref> analyzed the class GapP, a function class consisting of differences|"gaps"|between the number of accepting and ? A full version of the paper is available from lilide@cs.uchicago.edu ?? Partially Supported by NSF Grant CCR-9209833. Email: fenner@usm.maine.edu ??? Partially Supported by NSF Grant CCR-9009936 and CCR-9253582. <p> The CM M is the machine identical to M but with the accepting and rejecting states interchanged. We assume that the reader is familiar with the common complexity classes such as P, NP, BPP, PH, PSPACE, EXP and NEXP. Definition 2. - [Val79] #P df - <ref> [FFK91] </ref> GapP df = fgap M j M is a CMg where gap M df We use FP to denote the classes of all poly-time computable functions. - [Gil77] [Sim75] PP is the class of all languages L such that there exists a CM M and an FP function f such <p> It has been shown that #P is closed under addition, multiplication and binomial coefficients [BGH90]. GapP has all these closure properties and it is also closed under subtraction <ref> [FFK91] </ref>. Definition 3. [FFK91] A class C of languages is gap-definable if there exist disjoint sets A; R fl fi Z such that, 8L, L 2 C if and only if there exists a GapP function g with x 2 L =) (x; g (x)) 2 A, and x 62 L <p> It has been shown that #P is closed under addition, multiplication and binomial coefficients [BGH90]. GapP has all these closure properties and it is also closed under subtraction <ref> [FFK91] </ref>. Definition 3. [FFK91] A class C of languages is gap-definable if there exist disjoint sets A; R fl fi Z such that, 8L, L 2 C if and only if there exists a GapP function g with x 2 L =) (x; g (x)) 2 A, and x 62 L =) (x; g <p> We let Gap (A; R) denote the class C. A function g 2 GapP is called (A,R)-proper if 8x; (x; g (x)) 2 A [ R. A gap-definable class C is called reasonable if C contains ; and fl . It has been shown in <ref> [FFK91] </ref> that if C is gap-definable, then C is reasonable if and only if SPP C. SPP is defined in Section 3 below. Definition 4. [FFK91] Let D = fL 1 ; L 2 ; L 3 ; : : :g be a countable collection of languages and W = fw <p> A gap-definable class C is called reasonable if C contains ; and fl . It has been shown in <ref> [FFK91] </ref> that if C is gap-definable, then C is reasonable if and only if SPP C. SPP is defined in Section 3 below. Definition 4. [FFK91] Let D = fL 1 ; L 2 ; L 3 ; : : :g be a countable collection of languages and W = fw 1 ; w 2 ; :::; g be an immune set, i.e., W is infinite with no infinite recursively enumerable subset. <p> In Theorem 20 and Corollary 21 we show that immune sets are not required to represent GapCl (C) as a gap-definable class. Certain functions ffi B k were defined in <ref> [FFK91] </ref>. They have the property that for integers k and B with 0 k B, we have ffi B k (x) = 1 if x = k; and ffi B if x 6= k and 0 x B. <p> Also, if f 2 GapP, then ffi B k (f (x)) 2 GapP. 3 Gap-definability We will first prove a theorem which characterizes gap-definability by a certain Boolean closure property with SPP. It will play an important role in the paper. Definition 5. <ref> [FFK91] </ref> SPP is the class of all languages L such that there exists g 2 GapP such that, for all x, x 2 L =) g (x) = 1, and x 62 L =) g (x) = 0. Theorem 6. Let C be a countable class of languages containing ;. <p> Corollary 7. If C is closed under union and intersection, and f;; fl g C, then C is gap-definable if and only if SPP C. Proof. If C is gap-definable and f;; fl g C, then SPP C <ref> [FFK91] </ref>. Conversely, if C is closed under union and intersection, and SPP C, then clearly we have condition 2 in Theorem 6. So C is gap-definable. 2 Corollary 8. <p> Proposition 16 then implies that NP [ co-NP is unlikely to be gap-definable. Corollary 17. If f;; fl g C and C is closed under m-reductions and complements, then GapCl (C) is closed under 1-tt-reductions. Proof. It was shown in <ref> [FFK91] </ref> that the GapCl operator preserves closure under m-reductions and closure under complements. 2 4 The Gap Closure Operator, GapCl The following theorem provides a simplified characterization of the gap-closure operator, GapCl. Theorem 18. Let C be a countable class of languages and L an arbitrary language. <p> If there is a universal recursive enumeration of C, then there are recursive sets A and R such that GapCl (C) = Gap (A; R). (For example, GapCl (NP) = Gap (A; R) for some recursive sets A and R.) 2 It was shown in <ref> [FFK91] </ref> that GapCl (C) inherits many closure properties of C. Here we add to that list, and obtain as a corollary a simple characterization of GapCl (C) for many common classes C. Lemma 22. 1. If class C is closed under union, then so is GapCl (C). 2.
Reference: [Gil77] <author> J. Gill. </author> <title> Computational complexity of probabilistic complexity classes. </title> <journal> SIAM Journal on Computing, </journal> <volume> 6 </volume> <pages> 675-695, </pages> <year> 1977. </year>
Reference-contexts: Definition 2. - [Val79] #P df - [FFK91] GapP df = fgap M j M is a CMg where gap M df We use FP to denote the classes of all poly-time computable functions. - <ref> [Gil77] </ref> [Sim75] PP is the class of all languages L such that there exists a CM M and an FP function f such that, for all x, x 2 L () #M (x) &gt; f (x).
Reference: [GKT92] <author> F. Green, J. Kobler, and J. Toran. </author> <title> The power of the middle bit. </title> <booktitle> In Proceedings of the 7th Structure in Complexity Theory Conf., </booktitle> <pages> pages 111-117, </pages> <year> 1992. </year>
Reference-contexts: An equivalent condition is, there exists a CM M such that for all x, x 2 L () gap M (x) &gt; 0. - [RS92] <ref> [GKT92] </ref> MP, or MidBitP, is the class of all languages L such that there exists a function f in #P and a function g in FP such that for all x; x 2 L iff there is a 1 at position g (x) in the binary representation of f (x).
Reference: [KST92] <author> J. Kobler, U. Schoning, and J. Toran. </author> <title> Graph isomorphism is low for PP. </title> <booktitle> In Proc. of the 9th Symp. on Theoretical Aspects of Computer Science, </booktitle> <year> 1992. </year>
Reference: [RS92] <author> K. Regan and T. </author> <title> Schwentick On the power of one bit of a #P function. </title> <booktitle> To appear in Proc. of the 4th Italian Conf. in Theoretical Comp. Sci., </booktitle> <year> 1992. </year>
Reference-contexts: An equivalent condition is, there exists a CM M such that for all x, x 2 L () gap M (x) &gt; 0. - <ref> [RS92] </ref> [GKT92] MP, or MidBitP, is the class of all languages L such that there exists a function f in #P and a function g in FP such that for all x; x 2 L iff there is a 1 at position g (x) in the binary representation of f (x).
Reference: [Sim75] <author> J. Simon. </author> <title> On some central problems in computational complexity. </title> <type> Technical Report TR75-224, </type> <institution> Cornell University Department of Computer Science, </institution> <year> 1975. </year>
Reference-contexts: Definition 2. - [Val79] #P df - [FFK91] GapP df = fgap M j M is a CMg where gap M df We use FP to denote the classes of all poly-time computable functions. - [Gil77] <ref> [Sim75] </ref> PP is the class of all languages L such that there exists a CM M and an FP function f such that, for all x, x 2 L () #M (x) &gt; f (x).
Reference: [Tod91] <author> S. </author> <title> Toda. PP is as hard as the polynomial-time hierarchy. </title> <journal> SIAM J. on Computing, </journal> <volume> 20(5) </volume> <pages> 865-877, </pages> <year> 1991. </year>
Reference-contexts: 1 Introduction In 1979, Valiant [Val79] defined the class #P, the class of functions definable as the number of accepting computations of some polynomial-time nondeterministic Turing machine. Valiant showed many natural problems complete for this class, including the permanent of a zero-one matrix. Toda <ref> [Tod91] </ref> showed that these functions have more power than previously believed; he showed how to reduce any problem in the polynomial-time hierarchy to a single value of a #P function. The class #P has its shortcomings, however.
Reference: [TO92] <author> S. Toda and M. Ogiwara. </author> <title> Counting classes are at least as hard as the polynomial-time hierarchy. </title> <journal> SIAM J. on Computing, </journal> <volume> 21(2) </volume> <pages> 316-328, </pages> <year> 1992. </year>
Reference-contexts: GapP also has all the other nice closure properties of #P, such as addition, multiplication, and binomial coefficients. Beigel, Reingold, & Spielman first used gaps to great advantage in [BRS91] to show that PP is closed under intersection. Toda and Ogiwara have also formulated their results in <ref> [TO92] </ref> using GapP instead of #P. Fenner, Fortnow and Kurtz looked at classes such as PP, C = P, P and SPP that can be defined in terms of GapP functions.
Reference: [Val79] <author> L. Valiant. </author> <title> The complexity of computing the permanent. </title> <journal> Theoretical Computer Science, </journal> <volume> 8 </volume> <pages> 189-201, </pages> <year> 1979. </year>
Reference-contexts: 1 Introduction In 1979, Valiant <ref> [Val79] </ref> defined the class #P, the class of functions definable as the number of accepting computations of some polynomial-time nondeterministic Turing machine. Valiant showed many natural problems complete for this class, including the permanent of a zero-one matrix. <p> The CM M is the machine identical to M but with the accepting and rejecting states interchanged. We assume that the reader is familiar with the common complexity classes such as P, NP, BPP, PH, PSPACE, EXP and NEXP. Definition 2. - <ref> [Val79] </ref> #P df - [FFK91] GapP df = fgap M j M is a CMg where gap M df We use FP to denote the classes of all poly-time computable functions. - [Gil77] [Sim75] PP is the class of all languages L such that there exists a CM M and an
Reference: [Wag86] <author> K. Wagner. </author> <title> The complexity of combinatorial problems with succinct input representation. </title> <journal> Acta Informatica, </journal> <volume> 23 </volume> <pages> 325-356, </pages> <year> 1986. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
References-found: 12

