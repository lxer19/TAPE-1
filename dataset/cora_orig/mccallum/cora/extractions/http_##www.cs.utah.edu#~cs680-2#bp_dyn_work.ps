URL: http://www.cs.utah.edu/~cs680-2/bp_dyn_work.ps
Refering-URL: http://www.cs.utah.edu/~cs680-2/index.html
Root-URL: 
Email: smith-@eecs.harvard.edu  
Title: An Analysis of Dynamic Branch Prediction Schemes on System Workloads  
Author: Nicolas Gloy, Cliff Young, J. Bradley Chen, and Michael D. Smith 
Keyword: branch prediction, correlation, 2-level adaptive prediction, system traces  
Address: -ng, cyoung, bchen,  
Affiliation: Division of Applied Sciences, Harvard University  
Abstract: Recent studies of dynamic branch prediction schemes rely almost exclusively on user-only simulations to evaluate performance. We find that an evaluation of these schemes with user and kernel references often leads to different conclusions. By analyzing our own Atom-generated system traces and the system traces from the Instruction Benchmark Suite, we quantify the effects of kernel and user interactions on branch prediction accuracy. We find that user-only traces yield accurate prediction results only when the kernel accounts for less than 5% of the total executed instructions. Schemes that appear to predict well under user-only traces are not always the most effective on fullsystem traces: the recently-pr o-posed two-level adaptive schemes can suffer from higher aliasing than the original per-branch 2-bit counter scheme. We also find that flushing the branch history state at fixed intervals does not acc u-rately model the true effects of user/kernel interaction. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Accetta, et al. </author> <title> Mach: A New Kernel Foundation for Unix Development, </title> <booktitle> Proc. Summer 1986 USENIX Conf., </booktitle> <month> Jul. </month> <year> 1986. </year>
Reference-contexts: IBS contains traces for two different operating sy stems, ULTRIX from Digital Equipment Corporation [19] and Mach 3.0 from Carnegie Mellon University <ref> [1, 3] </ref>. For our simulations, we used the following items from the IBS trace record: the memory address referenced; the flag that indicates whether the reference was to instruction or data space; the flag that indicates user or kernel mode; and the opcode fetched by an instruction reference.
Reference: [2] <author> J. Chen. </author> <title> Software Methods for System Address Tracing, </title> <booktitle> Proc. Fourth Workshop on Workstation Operating System s, </booktitle> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: When software-based measurements of system activity are used for architectural simulation, care must be taken to avoid excessive distortion in measured behavior due to the overhead of the me a-surement system. Two kinds of distortion occur: space dilation and time dilation <ref> [2] </ref>. To remove space dilation effects, we ran our experiments on a machine with enough physical memory so add i-tional system activity due to virtual memory effects did not occur.

Reference: [4] <author> J. Chen and A. Eustace. </author> <title> Kernel Instrumentation Tools and Techniques, </title> <type> Technical Report 26-95, </type> <institution> Center for Research in Computing Technology, Harvard University, </institution> <address> Cambridge, MA, </address> <month> Nov. </month> <year> 1995. </year>
Reference-contexts: A more detailed discussion of time dilation in Atom tools and techniques for avoiding their ill effects can be found in a separate technical report <ref> [4] </ref>. The bottom of Table 1 includes a brief description of the benc h-marks traced under Atom. Table 3 presents the statistics for these benchmarks. They represent a range of applications with differing degrees of kernel and user activity.
Reference: [5] <author> A. Eustace and A. Srivastava. </author> <title> ATOM: A Flexible Interface for Building High Performance Program Analysis Tools. </title> <booktitle> Proc. Winter 1995 USENIX Technical Conf. on UNIX and Advanced Computing Systems, </booktitle> <month> Jan. </month> <year> 1995 </year>
Reference-contexts: Since these benchmarks do not cover the entire spectrum of applications, we also evaluate the two-level adaptive schemes using our own system traces. We gathered these traces with the Atom tool-building sy stem <ref> [5] </ref>. Overall, our Atom traces include a selection of the SPEC92 benchmarks and several large, system-intensive applic a-tions like an HTTP server. Unlike the SPEC92 benchmarks, the HTTP server spends a significant amount of its execution time in kernel routines. <p> The top of Table 1 gives a description of the IBS benchmarks. Table 2 presents some general statistics for each IBS trace . We collected additional traces using Atom <ref> [5] </ref> on an Digital Alpha-Station 400/233 running Digital Unix (formally OSF-1), release 3.2.
Reference: [6] <author> L. Gwennap. </author> <title> New Algorithm Improves Branch Prediction, </title> <type> Microprocessor Report, </type> <institution> 9(4):1721, </institution> <month> Mar. 27, </month> <year> 1995. </year>
Reference-contexts: For example, the identifier 2bc.4K indicates that the simulator used the hardware 2bc branch prediction scheme with a BHT size of 2K 2-bit counters. The smallest hardware sizes correspond roughly to the amount of branch prediction hardware found in todays microprocessors <ref> [6, 7] </ref>. We chose the largest scheme size because it has the same number of storage bits as an 8-kilobyte cache. 1. For 2bc, GAs, and gshare, these sizes correspond to BHTs with 2K, 8K, and 32K 2-bit counters. <p> The larger GAs schemes were chosen by scaling up the NexGen parameters . 2 PAs, we initially experimented with an organization that corr e-sponded to the reported parameters used by the branch prediction unit in the Pentium Pro processor (i = 9, j = 9, k = 4) <ref> [6] </ref>. However, this organization did not achieve misprediction rates as low as the PAs configurations in Table 4. Similarly, PAs implementations 2. One might be tempted to run a set of GAs simulations to determine the best tradeoff between j and k parameters for our benchmarks. <p> These results have encouraged researchers to develop even more elaborate har d-ware and convinced microprocessor vendors to implement these two-level adaptive schemes in new superscalar processors <ref> [6, 7, 8] </ref>. The results in this section show that the mispredict rate obtained from a trace of user-level branches is often a poor indicator of a schemes mispredict rate on user and kernel branches.
Reference: [7] <author> L. Gwennap. </author> <title> Pentium Competitors Go Head to Head, </title> <type> Microprocessor Report, </type> <institution> 9(8):16, </institution> <month> Jun. 19, </month> <year> 1995. </year>
Reference-contexts: For example, the identifier 2bc.4K indicates that the simulator used the hardware 2bc branch prediction scheme with a BHT size of 2K 2-bit counters. The smallest hardware sizes correspond roughly to the amount of branch prediction hardware found in todays microprocessors <ref> [6, 7] </ref>. We chose the largest scheme size because it has the same number of storage bits as an 8-kilobyte cache. 1. For 2bc, GAs, and gshare, these sizes correspond to BHTs with 2K, 8K, and 32K 2-bit counters. <p> Please note that the UNIX server is a user process under Mach and its activity is counted in the user categories. Table 4 lists the specific parameters of each hardware scheme. The gas.4K entry matches the size and organization of the branch pr e-diction hardware in the NexGen Nx586 <ref> [7] </ref>. The larger GAs schemes were chosen by scaling up the NexGen parameters . 2 PAs, we initially experimented with an organization that corr e-sponded to the reported parameters used by the branch prediction unit in the Pentium Pro processor (i = 9, j = 9, k = 4) [6]. <p> These results have encouraged researchers to develop even more elaborate har d-ware and convinced microprocessor vendors to implement these two-level adaptive schemes in new superscalar processors <ref> [6, 7, 8] </ref>. The results in this section show that the mispredict rate obtained from a trace of user-level branches is often a poor indicator of a schemes mispredict rate on user and kernel branches.
Reference: [8] <author> L. Gwennap. </author> <title> Nx868 Goes Toe-to-Toe with Pentium Pro, </title> <type> Microprocessor Report, </type> <institution> 9(14):8, </institution> <month> Oct. 23, </month> <year> 1995. </year>
Reference-contexts: These results have encouraged researchers to develop even more elaborate har d-ware and convinced microprocessor vendors to implement these two-level adaptive schemes in new superscalar processors <ref> [6, 7, 8] </ref>. The results in this section show that the mispredict rate obtained from a trace of user-level branches is often a poor indicator of a schemes mispredict rate on user and kernel branches.
Reference: [9] <author> A. Krall. </author> <title> Improving Semi-static Branch Prediction by Code Replication, </title> <booktitle> Proc. ACM SIGPLAN 94 Conf. on Prog. Lang. Design and Implementation, </booktitle> <month> Jun. </month> <year> 1994. </year>
Reference-contexts: Their divider mechanisms use the contents of these shift registers in addition to branch address information to create highly predictable substreams. Krall <ref> [9] </ref> and Young and Smith [22] describe code transformations that yield similar results for static branch prediction approaches. In this paper, we focus on three two-level adaptive branch predi c-tion schemes that have been shown to be effective on user-level code [11, 14, 21].
Reference: [10] <author> J. Lee and A. Smith. </author> <title> Branch Prediction Strategies and Branch Target Buffer Design, </title> <journal> Computer, </journal> <volume> 17(1), </volume> <month> Jan. </month> <year> 1984. </year>
Reference-contexts: All dynamic branch prediction schemes in this study are similar in that they use a table of two-bit, up-down, saturating counters. A 2-bit counter summarizes the past outcomes of a branch stream, using this information to predict the next branch outcome <ref> [10, 17] </ref>. The method of selection of a 2-bit counter in this table defines the type of dynamic branch prediction implemented. <p> The divider in Figure 1 selects the predictor, e.g. a 2-bit counter, used for each prediction. Before 1991, the divider in the best branch prediction schemes chose a predictor based on the address of the branch to predict <ref> [10, 12, 17] </ref>. The dynamic versions of these schemes maintained a table of 2-bit counters, referred to as a branch history table (BHT), indexed by the branch address. Figure 2a illustrates the hardware for this approach, which we refer to as 2bc. <p> We are familiar with only one study that has performed branch prediction simulations with system-level traces. The study by Lee and Smith <ref> [10] </ref> contains three traces of the MVS operating system executing a commercial workload.
Reference: [11] <author> S. McFarling. </author> <title> Combining Branch Predictors, </title> <note> WRL Techn i-cal Note TN-36, </note> <month> June </month> <year> 1993. </year>
Reference-contexts: With the trend toward larger branch misprediction pe n-alties due to the use of deeper pipelines, breaks in the program flow can quickly throttle the performance of these wide-issue microprocessors. Several recent studies <ref> [11, 14, 20] </ref> have proposed new hardware branch prediction schemes to address this problem. To date, the evaluation of these new techniques has been done almost exclusively with user-level traces of applications such as those found in the SPEC92 benchmark suite. <p> The method of selection of a 2-bit counter in this table defines the type of dynamic branch prediction implemented. We evaluate four dynamic schemes that have been shown to be particularly succes s-ful at predicting user-level branches: simple per-branch dynamic [17], GAs [14, 21], gshare <ref> [11] </ref>, and PAs [21]. The last three schemes are two-level adaptive schemes which exploit patterns in the recent local or global branch history to improve prediction accuracy. <p> 2*2 k bits branch addr (c) gshare scheme p d n j bits BHT of 2*2 j+k bits branch addr k bits (d) PAs scheme k bits BHSR BHSRs i bits Recently, several researchers have empirically shown that we can improve branch prediction accuracy by building more elaborate divider mechanisms <ref> [11, 14, 20] </ref>. By appropriately dividing a pr o-grams dynamic branch stream into many substreams, we can pr o-duce substreams that are more predictable. <p> Krall [9] and Young and Smith [22] describe code transformations that yield similar results for static branch prediction approaches. In this paper, we focus on three two-level adaptive branch predi c-tion schemes that have been shown to be effective on user-level code <ref> [11, 14, 21] </ref>. Figure 2 depicts each of these schemes. The first is called GAs, and it uses a single, global BHSR to record the ou t-come of the past k branches. <p> GAs chooses a 2-bit counter from the BHT by concatena t-ing the contents of the global BHSR with the current branch address. McFarling <ref> [11] </ref> proposes a modification to this scheme where the BHSR contents are exclusive-or-ed with the branch address. McFarling refers to this new scheme as gshare. The exclusive-or function permits the use of longer history and more address bits for a fixed size BHT than GAs.
Reference: [12] <author> S. McFarling and J. Hennessy. </author> <title> Reducing the Cost of Branches, </title> <booktitle> Proc. of 13th Annual Intl. Symp. on Computer Architecture, </booktitle> <month> Jun. </month> <year> 1986. </year>
Reference-contexts: The divider in Figure 1 selects the predictor, e.g. a 2-bit counter, used for each prediction. Before 1991, the divider in the best branch prediction schemes chose a predictor based on the address of the branch to predict <ref> [10, 12, 17] </ref>. The dynamic versions of these schemes maintained a table of 2-bit counters, referred to as a branch history table (BHT), indexed by the branch address. Figure 2a illustrates the hardware for this approach, which we refer to as 2bc.
Reference: [13] <author> R. Nair. </author> <title> Dynamic Path-Based Branch Correlation, </title> <booktitle> Proc. 28th Annual Intl. Symp. on Microarchitecture, </booktitle> <month> Nov. </month> <year> 1995. </year>
Reference-contexts: The negative effect of aliasing on prediction accuracy is more pronounced in the two-level schemes with large history depths than in locally-oriented schemes that rely on small history depths [16]. We also find that flushing the branch history state <ref> [13, 15] </ref> at fixed intervals does not accurately model the true effects of user/kernel interactions: some schemes are more sensitive than others to periodic flushing. Section 2 summarizes the recent advances in branch prediction, and it describes the major reasons for poor prediction accuracy in a dynamic branch prediction scheme. <p> Nair <ref> [13] </ref> and Perleberg and Smith [15] attempt to model the effects of context switches on the user-level component of branch misprediction by regularly flushing the BHT during a user-only trace. We are familiar with only one study that has performed branch prediction simulations with system-level traces. <p> In this case, we found that the mispredict rate of the kernel-only trace is a good indicator of the fullsystem mispredict rate. 4.2 Simulating the effect of kernel branches To date, very few branch prediction studies have considered the effects of user/kernel interaction on prediction accuracy. Nair <ref> [13] </ref> and Perleberg and Smith [15] each attempt to model the effects of context switching on the user-only branch mispredict rates by flushing the BHT at a fixed interval of instructions.
Reference: [14] <author> S. Pan, K. So, and J. Rahmeh. </author> <title> Improving the Accuracy of Dynamic Branch Prediction Using Branch Correlation, </title> <booktitle> Proc. 5th Annual Intl. Conf. on Architectural Support for Prog. Lang. and Operating Systems, </booktitle> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: With the trend toward larger branch misprediction pe n-alties due to the use of deeper pipelines, breaks in the program flow can quickly throttle the performance of these wide-issue microprocessors. Several recent studies <ref> [11, 14, 20] </ref> have proposed new hardware branch prediction schemes to address this problem. To date, the evaluation of these new techniques has been done almost exclusively with user-level traces of applications such as those found in the SPEC92 benchmark suite. <p> The method of selection of a 2-bit counter in this table defines the type of dynamic branch prediction implemented. We evaluate four dynamic schemes that have been shown to be particularly succes s-ful at predicting user-level branches: simple per-branch dynamic [17], GAs <ref> [14, 21] </ref>, gshare [11], and PAs [21]. The last three schemes are two-level adaptive schemes which exploit patterns in the recent local or global branch history to improve prediction accuracy. <p> 2*2 k bits branch addr (c) gshare scheme p d n j bits BHT of 2*2 j+k bits branch addr k bits (d) PAs scheme k bits BHSR BHSRs i bits Recently, several researchers have empirically shown that we can improve branch prediction accuracy by building more elaborate divider mechanisms <ref> [11, 14, 20] </ref>. By appropriately dividing a pr o-grams dynamic branch stream into many substreams, we can pr o-duce substreams that are more predictable. <p> Krall [9] and Young and Smith [22] describe code transformations that yield similar results for static branch prediction approaches. In this paper, we focus on three two-level adaptive branch predi c-tion schemes that have been shown to be effective on user-level code <ref> [11, 14, 21] </ref>. Figure 2 depicts each of these schemes. The first is called GAs, and it uses a single, global BHSR to record the ou t-come of the past k branches. <p> Figure 2 depicts each of these schemes. The first is called GAs, and it uses a single, global BHSR to record the ou t-come of the past k branches. As discussed by Pan, So, and Rahmeh <ref> [14] </ref>, GAs exploits the correlation between branch executions in a program; correlation occurs when the outcome of one or more branch executions helps to determine the outcome of a future branch.
Reference: [15] <author> C. Perleberg and A. Smith. </author> <title> Branch Target Buffer Design and Optimization, </title> <journal> IEEE Transactions on Computers, </journal> <volume> 42(4) </volume> <pages> 396-412, </pages> <month> Apr. </month> <year> 1993. </year>
Reference-contexts: The negative effect of aliasing on prediction accuracy is more pronounced in the two-level schemes with large history depths than in locally-oriented schemes that rely on small history depths [16]. We also find that flushing the branch history state <ref> [13, 15] </ref> at fixed intervals does not accurately model the true effects of user/kernel interactions: some schemes are more sensitive than others to periodic flushing. Section 2 summarizes the recent advances in branch prediction, and it describes the major reasons for poor prediction accuracy in a dynamic branch prediction scheme. <p> Nair [13] and Perleberg and Smith <ref> [15] </ref> attempt to model the effects of context switches on the user-level component of branch misprediction by regularly flushing the BHT during a user-only trace. We are familiar with only one study that has performed branch prediction simulations with system-level traces. <p> Nair [13] and Perleberg and Smith <ref> [15] </ref> each attempt to model the effects of context switching on the user-only branch mispredict rates by flushing the BHT at a fixed interval of instructions. This method is ine x-act, because interactions with the kernel or other processes do not necessarily flush the branch history state.
Reference: [16] <author> S. Sechrest, C. Lee, and T. Mudge, </author> <title> The Role of Adaptivity in Two-Level Adaptive Branch Prediction, </title> <booktitle> Proc. 28th Annual Intl. Symp. on Microarchitecture, </booktitle> <month> Nov. </month> <year> 1995. </year>
Reference-contexts: The negative effect of aliasing on prediction accuracy is more pronounced in the two-level schemes with large history depths than in locally-oriented schemes that rely on small history depths <ref> [16] </ref>. We also find that flushing the branch history state [13, 15] at fixed intervals does not accurately model the true effects of user/kernel interactions: some schemes are more sensitive than others to periodic flushing.
Reference: [17] <author> J. Smith. </author> <title> A Study of Branch Prediction Strategies, </title> <booktitle> Proc. 8th Annual Intl. Symp. on Computer Architecture, </booktitle> <month> Jun. </month> <year> 1981. </year>
Reference-contexts: All dynamic branch prediction schemes in this study are similar in that they use a table of two-bit, up-down, saturating counters. A 2-bit counter summarizes the past outcomes of a branch stream, using this information to predict the next branch outcome <ref> [10, 17] </ref>. The method of selection of a 2-bit counter in this table defines the type of dynamic branch prediction implemented. <p> The method of selection of a 2-bit counter in this table defines the type of dynamic branch prediction implemented. We evaluate four dynamic schemes that have been shown to be particularly succes s-ful at predicting user-level branches: simple per-branch dynamic <ref> [17] </ref>, GAs [14, 21], gshare [11], and PAs [21]. The last three schemes are two-level adaptive schemes which exploit patterns in the recent local or global branch history to improve prediction accuracy. <p> The divider in Figure 1 selects the predictor, e.g. a 2-bit counter, used for each prediction. Before 1991, the divider in the best branch prediction schemes chose a predictor based on the address of the branch to predict <ref> [10, 12, 17] </ref>. The dynamic versions of these schemes maintained a table of 2-bit counters, referred to as a branch history table (BHT), indexed by the branch address. Figure 2a illustrates the hardware for this approach, which we refer to as 2bc.
Reference: [18] <author> R. Uhlig, D. Nagle, T. Mudge, S. Sechrest, and J. Emer. </author> <title> Instruction Fetching: Coping with Code Bloat, </title> <booktitle> Proc. 22nd Annual Intl. Symp. on Computer Architecture, </booktitle> <month> Jun. </month> <year> 1995. </year>
Reference-contexts: This study also analyzes the perfo r-mance of these dynamic branch prediction schemes on kernel-intensive applications such as an HTTP server and those found in the IBS benchmark suite <ref> [18] </ref>. All dynamic branch prediction schemes in this study are similar in that they use a table of two-bit, up-down, saturating counters. A 2-bit counter summarizes the past outcomes of a branch stream, using this information to predict the next branch outcome [10, 17]. <p> We evaluate two-level adaptive schemes on larger applications, such as those found in the Instruction Benchmark Suite (IBS) <ref> [18] </ref>. Since these benchmarks do not cover the entire spectrum of applications, we also evaluate the two-level adaptive schemes using our own system traces. We gathered these traces with the Atom tool-building sy stem [5]. <p> For our first set of traces, we used the IBS traces from the Unive r-sity of Michigan <ref> [18] </ref>. These traces were generated on a DECst a-tion 3100 with a MIPS R2000 processor. The traces are designed to provide a realistic instruction reference stream, overcoming limitations of benchmark suites such as SPEC92 which fit in most on-chip instruction caches and do not induce significant operating system activity. <p> We replaced the SPECint92 version of gcc with version 2.6.3 because we had trouble compiling it on our Alpha machines. The descriptions of the IBS benchmarks are based on those provided in <ref> [18] </ref>. 4 trace accurately reflect the effect of kernel branches on the user-level component of prediction accuracy? Sections 4.1 and 4.2, respectively, discuss our findings for these two questions.
Reference: [19] <author> ULTRIX Documentation Group. </author> <title> ULTRIX Documentation Overview for RISC Processor s, </title> <institution> Digital Equipment Corpor a-tion, </institution> <year> 1989. </year>
Reference-contexts: The traces are designed to provide a realistic instruction reference stream, overcoming limitations of benchmark suites such as SPEC92 which fit in most on-chip instruction caches and do not induce significant operating system activity. IBS contains traces for two different operating sy stems, ULTRIX from Digital Equipment Corporation <ref> [19] </ref> and Mach 3.0 from Carnegie Mellon University [1, 3].
Reference: [20] <author> T. Yeh and Y. Patt. </author> <title> Two-Level Adaptive Branch Prediction, </title> <booktitle> Proc. 24th Annual ACM/IEEE Intl. Symp. and Workshop on Microarchitecture, </booktitle> <month> Nov. </month> <year> 1991. </year>
Reference-contexts: With the trend toward larger branch misprediction pe n-alties due to the use of deeper pipelines, breaks in the program flow can quickly throttle the performance of these wide-issue microprocessors. Several recent studies <ref> [11, 14, 20] </ref> have proposed new hardware branch prediction schemes to address this problem. To date, the evaluation of these new techniques has been done almost exclusively with user-level traces of applications such as those found in the SPEC92 benchmark suite. <p> 2*2 k bits branch addr (c) gshare scheme p d n j bits BHT of 2*2 j+k bits branch addr k bits (d) PAs scheme k bits BHSR BHSRs i bits Recently, several researchers have empirically shown that we can improve branch prediction accuracy by building more elaborate divider mechanisms <ref> [11, 14, 20] </ref>. By appropriately dividing a pr o-grams dynamic branch stream into many substreams, we can pr o-duce substreams that are more predictable. <p> By appropriately dividing a pr o-grams dynamic branch stream into many substreams, we can pr o-duce substreams that are more predictable. For dynamic schemes, Yeh and Patt <ref> [20] </ref> introduced the concept of two-level adaptive branch prediction schemes whose dividers include branch history shift registers (BHSRs) which record the recent directions of pr o-gram branches. Their divider mechanisms use the contents of these shift registers in addition to branch address information to create highly predictable substreams.
Reference: [21] <author> T. Yeh and Y. Patt. </author> <title> A Comparison of Dynamic Branch Pr e-dictors that use Two Levels of Branch History, </title> <booktitle> Proc. 20th Annual Intl. Symp. on Computer Architecture, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: The method of selection of a 2-bit counter in this table defines the type of dynamic branch prediction implemented. We evaluate four dynamic schemes that have been shown to be particularly succes s-ful at predicting user-level branches: simple per-branch dynamic [17], GAs <ref> [14, 21] </ref>, gshare [11], and PAs [21]. The last three schemes are two-level adaptive schemes which exploit patterns in the recent local or global branch history to improve prediction accuracy. <p> The method of selection of a 2-bit counter in this table defines the type of dynamic branch prediction implemented. We evaluate four dynamic schemes that have been shown to be particularly succes s-ful at predicting user-level branches: simple per-branch dynamic [17], GAs [14, 21], gshare [11], and PAs <ref> [21] </ref>. The last three schemes are two-level adaptive schemes which exploit patterns in the recent local or global branch history to improve prediction accuracy. <p> Krall [9] and Young and Smith [22] describe code transformations that yield similar results for static branch prediction approaches. In this paper, we focus on three two-level adaptive branch predi c-tion schemes that have been shown to be effective on user-level code <ref> [11, 14, 21] </ref>. Figure 2 depicts each of these schemes. The first is called GAs, and it uses a single, global BHSR to record the ou t-come of the past k branches. <p> The exclusive-or function permits the use of longer history and more address bits for a fixed size BHT than GAs. Ideally, this extra information results in more substreams that are more predictable. The final two-level adaptive branch prediction scheme that we consider is called PAs <ref> [21] </ref>. The PAs scheme maps each program branch into a table of BHSRs; the contents of the selected BHSR are concat e-nated to a portion of the branch address to select a 2-bit counter from the BHT.
Reference: [22] <author> C. Young and M. Smith. </author> <title> Improving the Accuracy of Static Branch Prediction Using Branch Correlation, </title> <booktitle> Proc. 6th Annual Intl. Conf. on Architectural Support for Prog. Lang. and Operating Systems, </booktitle> <month> Oct. </month> <year> 1994. </year>
Reference-contexts: Their divider mechanisms use the contents of these shift registers in addition to branch address information to create highly predictable substreams. Krall [9] and Young and Smith <ref> [22] </ref> describe code transformations that yield similar results for static branch prediction approaches. In this paper, we focus on three two-level adaptive branch predi c-tion schemes that have been shown to be effective on user-level code [11, 14, 21]. Figure 2 depicts each of these schemes.

References-found: 21

