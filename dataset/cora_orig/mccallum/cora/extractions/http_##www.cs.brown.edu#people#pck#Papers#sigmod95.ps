URL: http://www.cs.brown.edu/people/pck/Papers/sigmod95.ps
Refering-URL: http://www.cs.brown.edu/people/pck/publications.html
Root-URL: http://www.cs.brown.edu/
Title: OODB Indexing by Class-Division  
Author: Sridhar Ramaswamy Paris C. Kanellakis 
Abstract: Indexing a class hierarchy, in order to efficiently search or update the objects of a class according to a (range of) value(s) of an attribute, impacts OODB performance heavily. For this indexing problem, most systems use the class hierarchy index (CH) technique of [15] implemented using B + -trees. Other techniques, such as those of [14,18,30], can lead to improved average-case performance but involve the implementation of new data-structures, which are not as well-understood parts of database technology as B + -trees. As a special form of external dynamic two-dimensional range searching, this OODB indexing problem is solvable within reasonable worst-case bounds [12]. Based on this insight, we have developed a technique, called indexing by class-division (CD), which we believe can be used as a practical alternative to CH. We present an optimized implementation and experimental validation of CD's average-case performance. The main advantages of the CD technique are: (1) CD is an extension of CH that provides a significant speed-up over CH for a wide spectrum of range queries this speed-up is at least linear in the number of classes queried for uniformly distributed data and larger otherwise; and (2) CD queries, updates and concurrent use are implementable using standard B + -tree technology. The basic idea of class-division involves a time-space tradeoff and CD requires some space and update overhead in comparison to CH. In practice, this overhead is a small factor (2 to 3) and, in worst-case, is bounded by the depth of the hierarchy and the logarithm of its size.
Abstract-found: 1
Intro-found: 1
Reference: [1] <editor> F. Bancilhon, C. Delobel, and P. Kanellakis, eds., </editor> <title> Building an Object-Oriented Database System The Story of O 2 , Morgan Kaufmann Publishers, </title> <year> 1992. </year>
Reference-contexts: The example class hierarchies in the experiments were selected to be a mixture of hierarchies that were difficult to index and typical examples from the literature. (For example, some of them came from <ref> [1] </ref>.) 9 The class-division algorithm was used to create collections that were then indexed using B + -trees. When populating class hierarchies with objects several simplifying assumptions were made: 1.
Reference: [2] <author> R. Bayer and E. McCreight, </author> <title> "Organization of Large Ordered Indexes," </title> <journal> Acta Informatica 1 (1972), </journal> <pages> 173-189. </pages>
Reference: [3] <author> J. L. Bentley, </author> <title> "Multidimensional Divide and Conquer," </title> <booktitle> CACM 23(6) (1980), </booktitle> <pages> 214-229. </pages>
Reference-contexts: However, both approaches are very new and it is unclear whether the performance gains justify a nonstandard data-structure. Internal 2D Searching: A large literature exists for internal algorithms for two-dimensional range searching. The range tree <ref> [3] </ref> can be used to solve the problem in O (N log 2 N ) space and static worst-case query time O (log 2 N + K) .
Reference: [4] <author> E. Bertino and W. Kim, </author> <title> "Indexing techniques for queries on nested objects," </title> <journal> IEEE Transactions on Knowledge and Data Engineering 1(2) (1989). </journal>
Reference: [5] <author> B. Chazelle and L. J. Guibas, "Fractional Cascading: I. </author> <title> A Data Structuring Technique," </title> <booktitle> Algorithmica 1 (1986), </booktitle> <pages> 133-162. </pages>
Reference-contexts: There have been three such experimental studies [14,18,30]. All involve new data-structures. The approach [18] is based on the H-tree data-structure. This data-structure threads many B + -trees together to facilitate simultaneous search. This idea is known as "fractional cascading" in the data structures literature <ref> [5] </ref> and is notoriously hard to make dynamic. The H-tree scheme, is heuristic. It offers no worst-case performance guarantees for range querying. More importantly, updates are fairly complex and potentially unbounded. The other two approaches are very recent and do share a number of features.
Reference: [6] <author> Y.-J. Chiang and R. Tamassia, </author> <title> "Dynamic Algorithms in Computational Geometry," </title> <booktitle> Proceedings of IEEE, Special Issue on Computational Geometry 80(9) (1992), </booktitle> <pages> 362-381. </pages>
Reference-contexts: By using fractional cascading, we can achieve a worst-case dynamic query time O (log 2 N log 2 log 2 N + K) and update time O (log 2 N log 2 log 2 N ) using the same space. We refer the reader to <ref> [6] </ref> for a detailed survey of the topic. The ideal worst-case I/O bounds would involve making all the above logarithms have base B and compacting the output term to K=B. The special structure of class indexing allows such improvements and is the basic idea behind CD. <p> This technique involves an external version of the (folklore <ref> [6] </ref>) range tree idea, with a number of preprocessing space heuristics, and is described in Section 2. A significant advantage of CD is that it is implementable with standard B + -trees as an extension of CH.
Reference: [7] <author> E. F. Codd, </author> <title> "A Relational Model for Large Shared Data Banks," </title> <booktitle> CACM 13(6) (1970), </booktitle> <pages> 377-387. </pages>
Reference-contexts: 1 Introduction 1.1 Motivation and Basic Problems of OODB Indexing Linguistic features of data models enhance their applicability, but are really useful only if they can be supported by efficient secondary storage access. For example, the relational data model <ref> [7] </ref> includes declarative programming in the form of relational calculus or algebra. Its commercial success was largely due to the fact that its elegant linguistic features can be supported by data-structures that make efficient use of secondary storage.
Reference: [8] <author> D. Comer, </author> <title> "The Ubiquitous B-tree," </title> <booktitle> Computing Surveys 11(2) (1979), </booktitle> <pages> 121-137. </pages>
Reference: [9] <author> O. Gunther, </author> <title> "The Design of the Cell Tree: An Object-Oriented Index Structure for Geometric Databases," </title> <booktitle> Proc. of the Fifth Int. Conf. on Data Engineering (1989), </booktitle> <pages> 598-605. </pages>
Reference-contexts: External 2D Searching: The practical need for general I/O support has led to the development of a large number of data structures for external k-dimensional searching. Examples are the grid-file [20], various quad-trees [25,26], z-orders [21] and other space filling curves, k-d-B-trees [24], hB-trees [17], cell-trees <ref> [9] </ref>, and various R-trees [10,27]. These data structures were designed to have very good average-case behavior for common spatial database problems. However, they are somewhat of an overkill for the simpler problem of class indexing. Correlation between key dimensions does make many of these general techniques degrade.
Reference: [10] <author> Antonin Guttman, "R-Trees: </author> <title> A Dynamic Index Structure for Spatial Searching," </title> <booktitle> Proc. 1984 ACM-SIGMOD Conference on Management of Data (1985), </booktitle> <pages> 47-57. </pages>
Reference-contexts: In the class indexing problem, one of the dimensions is of very low cardinality compared to the other. These experiments confirmed the intuition that it is very difficult to produce good partitions in this case. (We used Guttman's <ref> [10] </ref> quadratic split algorithm to process node splits.) The speed-up ratios in Figure 7 indicate that CD outperforms R-trees by a factor of over 30, even when the class hierarchy size is 6.
Reference: [11] <author> Y. Ishikawa, H. Kitagawa, and N. Ohbo, </author> <title> "Evaluation of signature files as set access facilities on oodbs," </title> <booktitle> Proc. of the ACM SIGMOD (1993). </booktitle>
Reference: [12] <author> P. C. Kanellakis, S. Ramaswamy, D. E. Vengroff, and J. S. Vitter, </author> <title> "Indexing for Data Models with Constraints and Classes," </title> <booktitle> Proc. 12th ACM PODS (1993), </booktitle> <pages> 233-243, </pages> <note> invited to the special issue of JCSS on Principles of Database Systems (to appear). A complete version of the paper appears as Technical Report 93-21, </note> <institution> Brown University. </institution>
Reference-contexts: It is the general data structure problem underlying efficient secondary storage manipulation for many data models (see <ref> [12] </ref> for a discussion of object-oriented, spatial and constraint models). The problem of k-dimensional range searching in both main memory and secondary memory has been the subject of much research. <p> The range in the class dimension is the range that we associate with the label-class algorithm. The labeling involved is really a pre-order traversal of the class hierarchy. Since we assume that the class hierarchy is static, the above reduction is a preprocessing step. In <ref> [12] </ref>, this insight was used to show that: class indexing is in dynamic query I/O time O (log 2 c log B N + K=B) and update I/O time O (log 2 c log B N ), using O ((N=B) log 2 c) pages. <p> For example, [22,29] examine mappings which maintain the logarithmic overheads and make the logarithms base B; however, their algorithms do not compact the K-sized output on K=B pages. Even in some cases when such mappings are possible (see <ref> [12] </ref>), the large constant factors make them unrealistic. In a sense, this is an algorithmic area where there is significant mismatch between (internal) theory and (external) practice. <p> Clearly class-division is possible for q = c and r = 1 and q = 1 and r = c. Interestingly, from the proof of (Lemma 2.3 of <ref> [12] </ref>) we have the following space-time tradeoff: Proposition 2.1 For any forest class hierarchy H with c classes, it is possible to do class-divison of H according to r = dlog 2 ce + 1 and q = 2dlog 2 ce.
Reference: [13] <author> A. Kemper and G. Moerkette, </author> <title> "Access support in Object Bases," </title> <booktitle> Proc. of the ACM SIGMOD (1990). </booktitle>
Reference: [14] <author> C. Kilger and G. Moerkotte, </author> <title> "Indexing Multiple Sets," </title> <booktitle> Proc. 1994 VLDB Conference. </booktitle>
Reference-contexts: The hcC-tree of [30] balances the CH indexes with indexes on single classes (or equivalently the class extents). This results in a doubling of space. The two kinds of indexes are integrated through the hcC-tree directory. Range searching is improved considerably. The CG-tree of <ref> [14] </ref> addresses the more general problem of indexing multiple sets. It consists of a special directory on indexes of single classes. Range searching is also improved. To combine it with the benefits of CH, a "grouping by indexed sets" extension is proposed, which is very similar to the hcC-tree.
Reference: [15] <author> W. Kim, K. C. Kim, and A. Dale, </author> <title> "Indexing Techniques for Object-Oriented Databases," in Object-Oriented Concepts, Databases, and Applications, </title> <editor> W. Kim and F. H. Lochovsky, eds., </editor> <publisher> Addison-Wesley, </publisher> <year> 1989, </year> <pages> 371-394. </pages>
Reference-contexts: Together with the different problem of nested object indexing (as in [4,11,13, 19]) it constitutes the current repertoire of OODB indexing problems. Class Indexing has been examined in <ref> [15] </ref> and more recently in [14,18,30]. These solutions are heuristic (with poor worst-case performance) and have been supported by experimental performance evaluation. Of these, the class hierarchy index (CH) solution of [15] is the only method used widely in practice. <p> Class Indexing has been examined in <ref> [15] </ref> and more recently in [14,18,30]. These solutions are heuristic (with poor worst-case performance) and have been supported by experimental performance evaluation. Of these, the class hierarchy index (CH) solution of [15] is the only method used widely in practice. We believe this is the case because it was the first reasonable approach proposed and because it uses standard data-structures such as B-trees. In this paper we propose a practical alternative (and addition) to CH. <p> This is essentially the solution that <ref> [15] </ref> calls class hierarchy index (CH). (Note that, in CH some care goes into the design of the information describing class membership for each key value). This solution has linear space usage and good update performance. <p> So its worst-case behavior is unbounded for queries against classes that are not the root of the hierarchy. Another obvious way to solve the problem is to index the extent of each class in a hierarchy separately. This is called single class indexing (SC) in <ref> [15] </ref> and would also have good update performance and linear space usage. Moreover, when querying a class, whose full extent spans c 0 classes it has worst-case query I/O time O (c 0 log B N + K=B). <p> This might be reasonable when c 0 is very small with respect to c, but might dominate the average-case cost otherwise. Indeed, for queries directed against the root class (c = c 0 ) <ref> [15] </ref> show that CH would be better than SC for any nontrivial hierarchies (c 2) and a wide range of distributions. <p> The replication factor is again three and the query factor is improved to two. CD as an extension of CH: (1) G always includes the set of all classes, so CH is one of the indexes maintained, with leaf structures as in <ref> [15] </ref> . In our implementation of CD, all point queries involving two or more class extents are handled by CH. <p> obtained tends to be many times the storage overhead factor, proving the efficacy of trading space for better query times. 5 Conclusions and Open Problems We have developed a practical technique, called indexing by class-division (CD), which can be used to significantly improve the class hierarchy index (CH) method of <ref> [15] </ref>. We present an optimized implementation and experimental validation of CD's average-case performance. The results of our experiments show the superior performance of CD over CH for range searching, given a small space tradeoff. There are a number of possible extensions of the investigation presented here.
Reference: [16] <editor> W. Kim and F. H. Lochovsky, eds., </editor> <title> Object-Oriented Concepts, Databases, and Applications, </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference: [17] <author> D. B. Lomet and B. Salzberg, </author> <title> "The hB-Tree: A Multiattribute Indexing Method with Good Guaranteed Performance," </title> <booktitle> ACM Transactions on Database Systems 15(4) (1990), </booktitle> <pages> 625-658. 22 </pages>
Reference-contexts: External 2D Searching: The practical need for general I/O support has led to the development of a large number of data structures for external k-dimensional searching. Examples are the grid-file [20], various quad-trees [25,26], z-orders [21] and other space filling curves, k-d-B-trees [24], hB-trees <ref> [17] </ref>, cell-trees [9], and various R-trees [10,27]. These data structures were designed to have very good average-case behavior for common spatial database problems. However, they are somewhat of an overkill for the simpler problem of class indexing. Correlation between key dimensions does make many of these general techniques degrade.
Reference: [18] <author> C. C. Low, B. C. Ooi, and H. Lu, "H-trees: </author> <title> A Dynamic Associative Search Index for OODB," </title> <booktitle> Proc. ACM SIGMOD (1992), </booktitle> <pages> 134-143. </pages>
Reference-contexts: The CH method clusters objects by key. Other approaches to this problem have clustered objects also by class membership. There have been three such experimental studies [14,18,30]. All involve new data-structures. The approach <ref> [18] </ref> is based on the H-tree data-structure. This data-structure threads many B + -trees together to facilitate simultaneous search. This idea is known as "fractional cascading" in the data structures literature [5] and is notoriously hard to make dynamic. The H-tree scheme, is heuristic.
Reference: [19] <author> D. Maier and J. Stein, </author> <title> "Indexing in an Object-Oriented DBMS," </title> <booktitle> IEEE Proc. International Workshop on Object-Oriented Database Systems (1986), </booktitle> <pages> 171-182. </pages>
Reference-contexts: Together with the different problem of nested object indexing (as in <ref> [4,11,13, 19] </ref>) it constitutes the current repertoire of OODB indexing problems. Class Indexing has been examined in [15] and more recently in [14,18,30]. These solutions are heuristic (with poor worst-case performance) and have been supported by experimental performance evaluation.
Reference: [20] <author> J. Nievergelt, H. Hinterberger, and K. C. Sevcik, </author> <title> "The Grid File: An Adaptable, Symmetric Multikey File Structure," </title> <booktitle> ACM Transactions on Database Systems 9(1) (1984), </booktitle> <pages> 38-71. </pages>
Reference-contexts: In a sense, this is an algorithmic area where there is significant mismatch between (internal) theory and (external) practice. External 2D Searching: The practical need for general I/O support has led to the development of a large number of data structures for external k-dimensional searching. Examples are the grid-file <ref> [20] </ref>, various quad-trees [25,26], z-orders [21] and other space filling curves, k-d-B-trees [24], hB-trees [17], cell-trees [9], and various R-trees [10,27]. These data structures were designed to have very good average-case behavior for common spatial database problems.
Reference: [21] <author> J. A. Orenstein, </author> <title> "Spatial Query Processing in an Object-Oriented Database System," </title> <booktitle> Proc. ACM SIG-MOD (1986), </booktitle> <pages> 326-336. </pages>
Reference-contexts: External 2D Searching: The practical need for general I/O support has led to the development of a large number of data structures for external k-dimensional searching. Examples are the grid-file [20], various quad-trees [25,26], z-orders <ref> [21] </ref> and other space filling curves, k-d-B-trees [24], hB-trees [17], cell-trees [9], and various R-trees [10,27]. These data structures were designed to have very good average-case behavior for common spatial database problems. However, they are somewhat of an overkill for the simpler problem of class indexing.
Reference: [22] <author> M. H. Overmars, M. H. M. Smid, M. T. de Berg, and M. J. van Kreveld, </author> <title> "Maintaining Range Trees in Secondary Memory: Part I: Partitions," </title> <journal> Acta Informatica 27 (1990), </journal> <pages> 423-452. </pages>
Reference: [23] <author> S. Ramaswamy, </author> <title> "Indexing for Data Models with Classes and Constraints," </title> <institution> Department of Computer Science, Brown University, </institution> <type> Ph.D. Thesis, </type> <year> 1994. </year>
Reference-contexts: The space overhead is a small factor for most reasonable class hierarchy examples and, in worst-case, it is bounded by the depth of the hierarchy and the logarithm of its size. The results are described in Section 4; see <ref> [23] </ref> for more details. They offer strong "proof" that we can successfully trade a small amount of storage for good, guaranteed query times. <p> In the experiments generating these graphs, the size of each individual class extent was 20; 000 objects, and 2000 queries uniformly distributed over the range of the key and the four classes in hierarchy H1 were used. Here we present only a sample of the results (see <ref> [23] </ref> for the details). The experiments we did differed in the nature of the queries asked (small or large) and the nature of the input used to construct the B + -trees (sorted or unsorted input).
Reference: [24] <author> J. T. Robinson, </author> <title> "The K-D-B Tree: A Search Structure for Large Multidimensional Dynamic Indexes," </title> <booktitle> Proc. ACM SIGMOD (1984). </booktitle>
Reference-contexts: External 2D Searching: The practical need for general I/O support has led to the development of a large number of data structures for external k-dimensional searching. Examples are the grid-file [20], various quad-trees [25,26], z-orders [21] and other space filling curves, k-d-B-trees <ref> [24] </ref>, hB-trees [17], cell-trees [9], and various R-trees [10,27]. These data structures were designed to have very good average-case behavior for common spatial database problems. However, they are somewhat of an overkill for the simpler problem of class indexing.
Reference: [25] <author> H. Samet, </author> <title> Applications of Spatial Data Structures: Computer Graphics, Image Processing, </title> <publisher> and GIS , Addison-Wesley, </publisher> <year> 1989. </year>
Reference: [26] <author> H. Samet, </author> <title> The Design and Analysis of Spatial Data Structures, </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference: [27] <author> T. Sellis, N. Roussopoulos, and C. Faloutsos, </author> <title> "The R + -Tree: A Dynamic Index for Multi-Dimensional Objects," </title> <booktitle> Proc. 1987 VLDB Conference, </booktitle> <address> Brighton, England (1987). </address>
Reference: [28] <author> M. Seltzer, K. Bostic, and O. Yigit, </author> <title> The Berkeley DB code, </title> <note> available by ftp from ftp.cs.berkeley.edu as ucb/4bsd/db.tar.Z </note> . 
Reference-contexts: A significant advantage of CD is that it is implementable with standard B + -trees as an extension of CH. In our implementation of B + -trees, we used a modified version of the Berkeley DB code <ref> [28] </ref> that went into the making of the POSTGRES database system [31]. Our contribution is an optimized implementation and experimental validation of CD's average-case performance. The CD method is properly viewed as an extension of CH. <p> Consistency of the small number of replicas can be maintained using small-sized transactions. 3 The Experiments 3.1 Methodology The experiments were conducted on Sparc 10 workstations running SunOS 4.1.3. A modified version of the Berkeley DB code <ref> [28] </ref> that went into the making of the POSTGRES database system [31] was used to implement B + -trees. The code builds B + -trees on disk using the OS-level file system.
Reference: [29] <author> M. H. M. Smid and M. H. Overmars, </author> <title> "Maintaining Range Trees in Secondary Memory: Part II: Lower Bounds," </title> <journal> Acta Informatica 27 (1990), </journal> <pages> 453-480. </pages>
Reference: [30] <author> B. Sreenath and S. Seshadri, </author> <title> "The hcC-tree: An Efficient Index Structure For Object Oriented Databases," </title> <booktitle> Proc. 1994 VLDB Conference. </booktitle>
Reference-contexts: The H-tree scheme, is heuristic. It offers no worst-case performance guarantees for range querying. More importantly, updates are fairly complex and potentially unbounded. The other two approaches are very recent and do share a number of features. The hcC-tree of <ref> [30] </ref> balances the CH indexes with indexes on single classes (or equivalently the class extents). This results in a doubling of space. The two kinds of indexes are integrated through the hcC-tree directory. Range searching is improved considerably. <p> These will be used for point and range queries for leaf classes, i.e., where extents and full extents are the same. Note that, the <ref> [30] </ref> data-structure has provision for querying both full extents and extents. The equivalent task here would involve adding indexes for the extents of all classes. (3) In CD, unlike CH, range queries of any class C are handled in CD using the small number of indexes covering C's full extent.
Reference: [31] <author> M. Stonebraker and L. Rowe, </author> <title> "The Design of POSTGRES," </title> <booktitle> Proc. ACM SIGMOD (1986). </booktitle>
Reference-contexts: A significant advantage of CD is that it is implementable with standard B + -trees as an extension of CH. In our implementation of B + -trees, we used a modified version of the Berkeley DB code [28] that went into the making of the POSTGRES database system <ref> [31] </ref>. Our contribution is an optimized implementation and experimental validation of CD's average-case performance. The CD method is properly viewed as an extension of CH. Namely, it consists of the index built for the root of the hierarchy (i.e., this is CH) plus some other indexes. <p> Consistency of the small number of replicas can be maintained using small-sized transactions. 3 The Experiments 3.1 Methodology The experiments were conducted on Sparc 10 workstations running SunOS 4.1.3. A modified version of the Berkeley DB code [28] that went into the making of the POSTGRES database system <ref> [31] </ref> was used to implement B + -trees. The code builds B + -trees on disk using the OS-level file system. The Berkeley DB code runs at the user level, does its own buffer management, and exercises no control over the virtual memory and paging activity of the operating system.
Reference: [32] <author> S. Zdonik and D. Maier, </author> <title> Readings in Object-Oriented Database Systems, </title> <publisher> Morgan Kaufmann, </publisher> <year> 1990. </year> <month> 23 </month>
Reference-contexts: Object-oriented data models offer additional linguistic features, such as class hierarchies, inherited attributes, and object types, that match application semantics better than the relational data model <ref> [1,16, 32] </ref>. We believe that efficient indexing is critical in making Object Oriented Databases (OODBs) competitive in terms of performance with relational technology. The principal motivation for our work is the development of indexing techniques to support OODBs as efficiently as B-trees [2,8] support relations.
References-found: 32

