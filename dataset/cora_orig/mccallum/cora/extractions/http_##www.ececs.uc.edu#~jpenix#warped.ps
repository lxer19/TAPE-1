URL: http://www.ececs.uc.edu/~jpenix/warped.ps
Refering-URL: http://www.ececs.uc.edu/~jpenix/kbse/pub/
Root-URL: 
Email: phil.wilsey@uc.edu  
Phone: (513) 556-4779  
Title: Formal Specification and Partial Verification of a Time Warp Simulation Kernel 1  
Author: John Penix, Perry Alexander, Dale Martin, and Philip A. Wilsey 
Note: 1 Support for this work was provided in part by the Advanced Research Projects Agency, contracts F33615-93-C-1315 and F33615-93-C-1316 monitored by Wright Laboratory and contract J-FBI-93-116 monitored by the Department of Justice. The authors also wish to thank Wright Labs and ARPA for their continuing support.  
Address: ECECS, PO Box 210030  45221-0030  
Affiliation: Department of  University of Cincinnati Cincinnati, Ohio  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Apt, K. R., and Olderog, E.-R. </author> <title> Verification of Sequential and Concurrent Programs. </title> <publisher> Springer-Verlag, </publisher> <address> New York, NY, </address> <year> 1991. </year>
Reference-contexts: 1 Introduction The creation of efficient parallel programs that yield maximum performance and correct operation is very difficult. While several researchers have proposed parallel computer languages and environments [5, 6, 10, 27] to support parallel programming, few investigations show how formal methods can be used to develop parallel programs <ref> [1, 19, 21] </ref>. This situation is even more bleak if one is desiring to construct parallel programs that use less constrained synchronization strategies such as convergent algorithms [7, 11] or virtual time simulation [12, 18].
Reference: [2] <author> Booch, G. </author> <title> Object Oriented Design. </title> <address> Benjamin/Cummings, Redwood City, CA, </address> <year> 1991. </year> <month> 31 </month>
Reference-contexts: The formal verification goal of the project rules out standard semi-formal specification techniques such as structured analysis [31] or object-oriented analysis <ref> [28, 9, 2] </ref>. Thus only formal techniques [30] were considered. Specifically, Z [29], Larch [15] and CSP [16] were chosen as a representative language subset.
Reference: [3] <author> Boyer, R., and Moore, S. </author> <title> A Computational Logic. </title> <booktitle> ACM Mongraph Series. </booktitle> <publisher> Academic Press, </publisher> <address> New York, NY, </address> <year> 1979. </year>
Reference-contexts: Specifications written in Larch/C ++ and LSL can be automatically checked and transformed into the Larch Prover's input language. The Larch Prover supports the basic proof techniques, primarily induction, needed for the verification process. Although other proof systems such as Boyer-Moore <ref> [3] </ref> provide a much more automated proof system, transforming the Larch specifications and libraries into another prover language would require verification of the transformation.
Reference: [4] <author> Bryant, R. E. </author> <title> Simulation on a distributed system. </title> <booktitle> In Proc. of the 16th Design Automation Conference (1979), </booktitle> <pages> pp. 544-552. </pages>
Reference-contexts: To ensure a correct simulation, messages must be processed in order of non-decreasing simulation time. This requires some sort of synchronization among the distributed processes. There are two primary mechanisms used for the distributed synchronization of parallel simulators, namely: conservative <ref> [4, 24] </ref> and optimistic [7, 18]. Conservative techniques ensure that all events are strictly processed according to their causal order. In contrast, optimistic mechanisms do not strictly enforce the causal order on event processing.
Reference: [5] <author> Carriero, N., and Gelernter, D. </author> <title> Coordination languages and their significance. </title> <journal> Communications of the ACM 35, </journal> <month> 2 (February </month> <year> 1992), </year> <pages> 97-107. </pages>
Reference-contexts: 1 Introduction The creation of efficient parallel programs that yield maximum performance and correct operation is very difficult. While several researchers have proposed parallel computer languages and environments <ref> [5, 6, 10, 27] </ref> to support parallel programming, few investigations show how formal methods can be used to develop parallel programs [1, 19, 21].
Reference: [6] <author> Chandra, R., Gupta, A., and Hennessy, J. </author> <title> COOL: A language for parallel programming. </title> <booktitle> In Languages and Compilers for Parallel Computing (1990), </booktitle> <editor> D. Gelernter et al., </editor> <booktitle> Eds., </booktitle> <pages> pp. 126-148. </pages>
Reference-contexts: 1 Introduction The creation of efficient parallel programs that yield maximum performance and correct operation is very difficult. While several researchers have proposed parallel computer languages and environments <ref> [5, 6, 10, 27] </ref> to support parallel programming, few investigations show how formal methods can be used to develop parallel programs [1, 19, 21].
Reference: [7] <author> Chandy, K. M., and Sherman, R. </author> <title> Space-time and simulation. </title> <booktitle> In Distributed Simulation (1989), Society for Computer Simulation, </booktitle> <pages> pp. 53-57. </pages>
Reference-contexts: This situation is even more bleak if one is desiring to construct parallel programs that use less constrained synchronization strategies such as convergent algorithms <ref> [7, 11] </ref> or virtual time simulation [12, 18]. Virtual time [18] is an optimistic synchronization strategy for parallel discrete event-driven simulation based on Lamport's work with clocks and event ordering in distributed systems [20]. <p> To ensure a correct simulation, messages must be processed in order of non-decreasing simulation time. This requires some sort of synchronization among the distributed processes. There are two primary mechanisms used for the distributed synchronization of parallel simulators, namely: conservative [4, 24] and optimistic <ref> [7, 18] </ref>. Conservative techniques ensure that all events are strictly processed according to their causal order. In contrast, optimistic mechanisms do not strictly enforce the causal order on event processing. One of the more widely used optimistic synchronization techniques, time warp, implements the virtual time paradigm developed by Jefferson [18].
Reference: [8] <author> Cheon, Y., and Leavens, G. T. </author> <title> A quick overview of Larch/C++. </title> <journal> Journal of Object-Oriented Programming (October 1994), </journal> <pages> 39-49. </pages>
Reference-contexts: To provide an interface that is consistent with C ++ , the formal specification was developed using Larch/C ++ <ref> [8, 22] </ref>. The Larch Prover [13] then became the natural choice to assist in verifying that messages are processed in the correct order. The remainder of this paper is organized as follows. Section 2 provides a brief overview of a time warp parallel simulator. <p> The upper level of a Larch-style specification is the interface specification. Since calling conventions vary widely among programming languages, interface specifications are written in a language tailored to a specific programming language. Larch/C ++ <ref> [8, 22] </ref> is an interface specification language for C ++ .
Reference: [9] <author> Coad, P., and Yourdon, E. </author> <title> Object-Oriented Analysis. </title> <publisher> Yourdon Press, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: The formal verification goal of the project rules out standard semi-formal specification techniques such as structured analysis [31] or object-oriented analysis <ref> [28, 9, 2] </ref>. Thus only formal techniques [30] were considered. Specifically, Z [29], Larch [15] and CSP [16] were chosen as a representative language subset.
Reference: [10] <author> Du, W. </author> <title> An intensional approach to parallel programming. </title> <booktitle> IEEE Parallel & Distributed Technology: System & Applications 1, </booktitle> <month> 3 (August </month> <year> 1993), </year> <pages> 22-32. </pages>
Reference-contexts: 1 Introduction The creation of efficient parallel programs that yield maximum performance and correct operation is very difficult. While several researchers have proposed parallel computer languages and environments <ref> [5, 6, 10, 27] </ref> to support parallel programming, few investigations show how formal methods can be used to develop parallel programs [1, 19, 21].
Reference: [11] <author> Freeman, T. L., and Phillips, C., Eds. </author> <title> Parallel Numerical Algorithms. </title> <publisher> Prentice Hall, </publisher> <address> New York, NY, </address> <year> 1992. </year>
Reference-contexts: This situation is even more bleak if one is desiring to construct parallel programs that use less constrained synchronization strategies such as convergent algorithms <ref> [7, 11] </ref> or virtual time simulation [12, 18]. Virtual time [18] is an optimistic synchronization strategy for parallel discrete event-driven simulation based on Lamport's work with clocks and event ordering in distributed systems [20].
Reference: [12] <author> Fujimoto, R. </author> <title> Parallel discrete event simulation. </title> <journal> Communications of the ACM 33, </journal> <month> 10 (October </month> <year> 1990), </year> <pages> 30-53. </pages>
Reference-contexts: This situation is even more bleak if one is desiring to construct parallel programs that use less constrained synchronization strategies such as convergent algorithms [7, 11] or virtual time simulation <ref> [12, 18] </ref>. Virtual time [18] is an optimistic synchronization strategy for parallel discrete event-driven simulation based on Lamport's work with clocks and event ordering in distributed systems [20]. <p> The notion of virtual time is an abstract mechanism to synchronize a parallel simulation; specific instances of virtual time exist only with explicit techniques to manage the distributed virtual clocks. One of the more popular instances of the virtual time synchronization protocol is called the time warp mechanism <ref> [12, 18] </ref>. Two of the authors, Martin and Wilsey, have been studying parallel and discrete event-driven simulation, time warp, and algorithms to optimize time warp for several years. In particular, we have been working with a time warp parallel simulator for digital system simulation [23]. <p> Finally, Section 8 contains some concluding remarks. 2 Parallel Discrete Event-Driven Simulation In a Parallel Discrete Event-driven Simulation (PDES), the system to be simulated is modeled by a set of communicating Logical Processes (LPs) that execute in parallel <ref> [12, 24, 25] </ref>. Event information is exchanged between the concurrently executing LPs as time-stamped messages. To ensure a correct simulation, messages must be processed in order of non-decreasing simulation time. This requires some sort of synchronization among the distributed processes.
Reference: [13] <author> Garland, S. J., and Guttag, J. V. </author> <title> A guide to LP, the larch prover. </title> <type> Tech. Rep. TR 82, </type> <institution> DEC/SRC, </institution> <month> December </month> <year> 1991. </year>
Reference-contexts: To provide an interface that is consistent with C ++ , the formal specification was developed using Larch/C ++ [8, 22]. The Larch Prover <ref> [13] </ref> then became the natural choice to assist in verifying that messages are processed in the correct order. The remainder of this paper is organized as follows. Section 2 provides a brief overview of a time warp parallel simulator. <p> requires (*handle)' =2 (self^.simArray); modifies self; ensures (*handle)' 2 self'.simArray; - void simulate (Time t)- // simulate until completion requires size (self^.simArray) = numObjects; modifies self; ensures self'.GVT t; - 7 Verification of Simulation Correctness A proof of simulation correctness was done with the help of the Larch Prover (LP) <ref> [13] </ref>. LP is a proof assistant compatible with LSL specifications. LSL trait specifications are converted into an equivalent set of rewrite, induction, and deduction rules. LP allows the user to make conjectures and apply the rules using both forward and backward inference.
Reference: [14] <author> Gropp, W., Lusk, E., and Skjellum, A., Eds. </author> <title> Using MPI: Portable Parallel Programming with the Message-Passing Interface. </title> <publisher> MIT Press, </publisher> <address> Boston, MA, </address> <year> 1994. </year>
Reference-contexts: Two pre-existing 1 constraints on the project are that (i) the time warp kernel will be implemented using C ++ , and (ii) the MPI message passing standard <ref> [14] </ref> must be used to exchange time-stamped messages. To provide an interface that is consistent with C ++ , the formal specification was developed using Larch/C ++ [8, 22]. The Larch Prover [13] then became the natural choice to assist in verifying that messages are processed in the correct order.
Reference: [15] <author> Guttag, J. V., and Horning, J. J. </author> <title> Larch: Languages and Tools for Formal Specification. </title> <publisher> Springer-Verlag, </publisher> <address> New York, NY, </address> <year> 1993. </year>
Reference-contexts: The formal verification goal of the project rules out standard semi-formal specification techniques such as structured analysis [31] or object-oriented analysis [28, 9, 2]. Thus only formal techniques [30] were considered. Specifically, Z [29], Larch <ref> [15] </ref> and CSP [16] were chosen as a representative language subset. Z was considered due to its widespread use and appeal of its model-based specification approach while CSP was considered due to its ability to represent multiple processes. <p> When considering development tool support, language parsers and proof systems exist in the public domain for Larch languages. Commercial parsers and provers do exist for both Z and CSP, however these tools were not available. In addition, the available standard handbook for Larch <ref> [15] </ref> 4 provides a wealth of basic specification constructs that dramatically reduce the specification effort. The Larch Prover was selected to support verification activities because a seamless path exists from Larch specifications to the Larch Prover's input language. <p> In addition, proof assistance required by the Larch Prover provides insight into the specification's structure providing valuable information when debugging the specification. 4 Larch and Larch/C ++ The Larch <ref> [15] </ref> style of specification is described as a two-tiered approach because specifications are written using two languages. The lower level is written using the Larch Shared Language (LSL). LSL is an algebraic specification language that is used to model abstract data types. <p> The includes clause allows the renaming of sort and operator names to avoid conflicts and to promote specification reuse. A standard handbook <ref> [15] </ref> contains specifications for associativity and commutativity as well as complex structures such as queues and strings. existing handbook traits for associativity and commutativity. The "parameters" after the trait names indicate renaming in the traits. This example portrays an additional feature of LSL.
Reference: [16] <author> Hoare, C. A. R. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, </address> <year> 1985. </year>
Reference-contexts: The formal verification goal of the project rules out standard semi-formal specification techniques such as structured analysis [31] or object-oriented analysis [28, 9, 2]. Thus only formal techniques [30] were considered. Specifically, Z [29], Larch [15] and CSP <ref> [16] </ref> were chosen as a representative language subset. Z was considered due to its widespread use and appeal of its model-based specification approach while CSP was considered due to its ability to represent multiple processes.
Reference: [17] <author> Horebeek, I. V., and Lewi, J. </author> <title> Algebraic Specifications in Software Engineering. </title> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: In order to define what is meant by the head and tail of a queue, it is necessary to know something about the queue itself. In general, the observer operators of a sort must be described in terms of the constructive operators <ref> [17] </ref>. For this reason, the head and tail operators are defined in terms of a queue constructed by appending a known element to the queue. There are three possible scenarios which produce different results for adding a new event to this augmented priority queue.
Reference: [18] <author> Jefferson, D. </author> <title> Virtual time. </title> <journal> ACM Transactions on Programming Languages and Systems 7, </journal> <month> 3 (July </month> <year> 1985), </year> <pages> 405-425. </pages>
Reference-contexts: This situation is even more bleak if one is desiring to construct parallel programs that use less constrained synchronization strategies such as convergent algorithms [7, 11] or virtual time simulation <ref> [12, 18] </ref>. Virtual time [18] is an optimistic synchronization strategy for parallel discrete event-driven simulation based on Lamport's work with clocks and event ordering in distributed systems [20]. <p> This situation is even more bleak if one is desiring to construct parallel programs that use less constrained synchronization strategies such as convergent algorithms [7, 11] or virtual time simulation [12, 18]. Virtual time <ref> [18] </ref> is an optimistic synchronization strategy for parallel discrete event-driven simulation based on Lamport's work with clocks and event ordering in distributed systems [20]. <p> The notion of virtual time is an abstract mechanism to synchronize a parallel simulation; specific instances of virtual time exist only with explicit techniques to manage the distributed virtual clocks. One of the more popular instances of the virtual time synchronization protocol is called the time warp mechanism <ref> [12, 18] </ref>. Two of the authors, Martin and Wilsey, have been studying parallel and discrete event-driven simulation, time warp, and algorithms to optimize time warp for several years. In particular, we have been working with a time warp parallel simulator for digital system simulation [23]. <p> To ensure a correct simulation, messages must be processed in order of non-decreasing simulation time. This requires some sort of synchronization among the distributed processes. There are two primary mechanisms used for the distributed synchronization of parallel simulators, namely: conservative [4, 24] and optimistic <ref> [7, 18] </ref>. Conservative techniques ensure that all events are strictly processed according to their causal order. In contrast, optimistic mechanisms do not strictly enforce the causal order on event processing. One of the more widely used optimistic synchronization techniques, time warp, implements the virtual time paradigm developed by Jefferson [18]. <p> Conservative techniques ensure that all events are strictly processed according to their causal order. In contrast, optimistic mechanisms do not strictly enforce the causal order on event processing. One of the more widely used optimistic synchronization techniques, time warp, implements the virtual time paradigm developed by Jefferson <ref> [18] </ref>. In a time warp synchronized parallel simulator the LPs operate as autonomous agents; each LP maintains a local clock, processing events in its local input event queue independent of the progress of other LPs in the system.
Reference: [19] <author> Knapp, E. </author> <title> An exercise in the formal derivation of parallel programs: Maximum flows in graphs. </title> <journal> ACM Transactions on Programming Languages and Systems 12, </journal> <month> 2 (April </month> <year> 1990), </year> <pages> 203-223. </pages>
Reference-contexts: 1 Introduction The creation of efficient parallel programs that yield maximum performance and correct operation is very difficult. While several researchers have proposed parallel computer languages and environments [5, 6, 10, 27] to support parallel programming, few investigations show how formal methods can be used to develop parallel programs <ref> [1, 19, 21] </ref>. This situation is even more bleak if one is desiring to construct parallel programs that use less constrained synchronization strategies such as convergent algorithms [7, 11] or virtual time simulation [12, 18].
Reference: [20] <author> Lamport, L. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <booktitle> Communica--tions of ACM (July 1978), </booktitle> <pages> 558-565. </pages>
Reference-contexts: Virtual time [18] is an optimistic synchronization strategy for parallel discrete event-driven simulation based on Lamport's work with clocks and event ordering in distributed systems <ref> [20] </ref>. The basic idea of virtual time is that a physical system is simulated using a collection of concurrently executing simulators who exchange time-stamped event messages whenever inter-simulator event information needs to be exchanged.
Reference: [21] <author> Lamport, L. </author> <title> A simple approach to specifying concurrent systems. </title> <journal> Communications of ACM (January 1989), </journal> <pages> 32-45. </pages>
Reference-contexts: 1 Introduction The creation of efficient parallel programs that yield maximum performance and correct operation is very difficult. While several researchers have proposed parallel computer languages and environments [5, 6, 10, 27] to support parallel programming, few investigations show how formal methods can be used to develop parallel programs <ref> [1, 19, 21] </ref>. This situation is even more bleak if one is desiring to construct parallel programs that use less constrained synchronization strategies such as convergent algorithms [7, 11] or virtual time simulation [12, 18].
Reference: [22] <author> Leavens, G. T., and Cheon, Y. </author> <title> Larch/C++ Reference Manual, </title> <year> 1995. </year>
Reference-contexts: To provide an interface that is consistent with C ++ , the formal specification was developed using Larch/C ++ <ref> [8, 22] </ref>. The Larch Prover [13] then became the natural choice to assist in verifying that messages are processed in the correct order. The remainder of this paper is organized as follows. Section 2 provides a brief overview of a time warp parallel simulator. <p> The upper level of a Larch-style specification is the interface specification. Since calling conventions vary widely among programming languages, interface specifications are written in a language tailored to a specific programming language. Larch/C ++ <ref> [8, 22] </ref> is an interface specification language for C ++ . <p> Therefore, it would seem ideal to use the Event sort from the domain model as the abstract sort for this class. However, to comply with the semantics of the Larch/C ++ state model, public data members must be modeled as program objects <ref> [22] </ref>. A modified version of the trait BasicEventTrait is shown in Figure 14. The sort State in this specification is the Larch/C ++ sort for program states, not to be confused with simulation states.
Reference: [23] <author> McBrayer, T., Charley, D., Wilsey, P. A., and Hensgen, D. A. </author> <title> A parallel, optimistically synchronized VHDL simulator executing on a network of workstations. </title> <booktitle> In Proc. of the Fall 1992 VHDL Int Users' Forum (October 1992), </booktitle> <pages> pp. 218-222. </pages>
Reference-contexts: Two of the authors, Martin and Wilsey, have been studying parallel and discrete event-driven simulation, time warp, and algorithms to optimize time warp for several years. In particular, we have been working with a time warp parallel simulator for digital system simulation <ref> [23] </ref>. A recent decision to separate the time warp simulation kernel from the application code provided us with the opportunity to redesign and rewrite the time warp kernel.
Reference: [24] <author> Misra, J. </author> <title> Distributed discrete-event simulation. </title> <journal> Computing Surveys 18, </journal> <month> 1 (March </month> <year> 1986), </year> <pages> 39-65. </pages>
Reference-contexts: Finally, Section 8 contains some concluding remarks. 2 Parallel Discrete Event-Driven Simulation In a Parallel Discrete Event-driven Simulation (PDES), the system to be simulated is modeled by a set of communicating Logical Processes (LPs) that execute in parallel <ref> [12, 24, 25] </ref>. Event information is exchanged between the concurrently executing LPs as time-stamped messages. To ensure a correct simulation, messages must be processed in order of non-decreasing simulation time. This requires some sort of synchronization among the distributed processes. <p> To ensure a correct simulation, messages must be processed in order of non-decreasing simulation time. This requires some sort of synchronization among the distributed processes. There are two primary mechanisms used for the distributed synchronization of parallel simulators, namely: conservative <ref> [4, 24] </ref> and optimistic [7, 18]. Conservative techniques ensure that all events are strictly processed according to their causal order. In contrast, optimistic mechanisms do not strictly enforce the causal order on event processing.
Reference: [25] <author> Nicol, D. M., and Fujimoto, R. M. </author> <title> Parallel simulation today. </title> <note> Annals of Operations Research 53 (1994), 249-. </note>
Reference-contexts: Finally, Section 8 contains some concluding remarks. 2 Parallel Discrete Event-Driven Simulation In a Parallel Discrete Event-driven Simulation (PDES), the system to be simulated is modeled by a set of communicating Logical Processes (LPs) that execute in parallel <ref> [12, 24, 25] </ref>. Event information is exchanged between the concurrently executing LPs as time-stamped messages. To ensure a correct simulation, messages must be processed in order of non-decreasing simulation time. This requires some sort of synchronization among the distributed processes.
Reference: [26] <editor> Proc. </editor> <booktitle> of the annual workshop on parallel and distributed simulation (PADS), </booktitle> <address> 1985-. </address>
Reference-contexts: There are many variations and optimizations to time warp, however, they are of no consequence to the discussion in the remainder of this paper. The interested reader is directed to the proceedings for the annual symposia on Parallel and Distributed Simulation <ref> [26] </ref>. 3 3 Specification Techniques and Proof Systems A number of specification styles and techniques are potentially applicable to this problem. The formal verification goal of the project rules out standard semi-formal specification techniques such as structured analysis [31] or object-oriented analysis [28, 9, 2].
Reference: [27] <author> Raj, R. </author> <title> Emerald: A general purpose programming language. </title> <journal> Software | Practive and Experience 21, </journal> <month> 1 (January </month> <year> 1991), </year> <month> 91. </month>
Reference-contexts: 1 Introduction The creation of efficient parallel programs that yield maximum performance and correct operation is very difficult. While several researchers have proposed parallel computer languages and environments <ref> [5, 6, 10, 27] </ref> to support parallel programming, few investigations show how formal methods can be used to develop parallel programs [1, 19, 21].
Reference: [28] <author> Rumbaugh, J., Blaha, M., Premerlani, W., Eddy, F., and Lorensen, W. </author> <title> Object-Oriented Modeling and Design. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: The formal verification goal of the project rules out standard semi-formal specification techniques such as structured analysis [31] or object-oriented analysis <ref> [28, 9, 2] </ref>. Thus only formal techniques [30] were considered. Specifically, Z [29], Larch [15] and CSP [16] were chosen as a representative language subset.
Reference: [29] <author> Spivey, J. M. </author> <title> Understanding Z: A Specification Language and its Formal Semantics, </title> <booktitle> vol. 3 of Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <address> Cambridge, </address> <year> 1988. </year>
Reference-contexts: The formal verification goal of the project rules out standard semi-formal specification techniques such as structured analysis [31] or object-oriented analysis [28, 9, 2]. Thus only formal techniques [30] were considered. Specifically, Z <ref> [29] </ref>, Larch [15] and CSP [16] were chosen as a representative language subset. Z was considered due to its widespread use and appeal of its model-based specification approach while CSP was considered due to its ability to represent multiple processes.
Reference: [30] <author> Wing, J. </author> <title> A specifier's introduction to formal methods. </title> <booktitle> IEEE Computer 23, </booktitle> <month> 9 (September </month> <year> 1990), </year> <pages> 8-24. </pages>
Reference-contexts: The formal verification goal of the project rules out standard semi-formal specification techniques such as structured analysis [31] or object-oriented analysis [28, 9, 2]. Thus only formal techniques <ref> [30] </ref> were considered. Specifically, Z [29], Larch [15] and CSP [16] were chosen as a representative language subset. Z was considered due to its widespread use and appeal of its model-based specification approach while CSP was considered due to its ability to represent multiple processes.
Reference: [31] <author> Yourdon, E. </author> <title> Techniques of Program Structure and Design. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1975. </year>
Reference-contexts: The formal verification goal of the project rules out standard semi-formal specification techniques such as structured analysis <ref> [31] </ref> or object-oriented analysis [28, 9, 2]. Thus only formal techniques [30] were considered. Specifically, Z [29], Larch [15] and CSP [16] were chosen as a representative language subset.
References-found: 31

