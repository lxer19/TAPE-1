URL: http://www.cs.columbia.edu/~kar/pubsk/groups.ps
Refering-URL: http://www.cs.columbia.edu/~kar/pubsk/pubsk.html
Root-URL: http://www.cs.columbia.edu
Email: damianos,kar@cs.columbia.edu  
Title: Querying Multiple Features of Groups in Relational Databases  
Author: Damianos Chatziantoniou Kenneth A. Ross 
Keyword: magnitude.  
Affiliation: Department of Computer Science, Columbia University  
Abstract: Some aggregate and grouping queries are conceptually simple, but difficult to express in SQL. This difficulty causes both conceptual and implementation problems for the SQL-based database system. Complicated queries and views are hard to understand and maintain. Further, the code produced is sometimes unnecessarily inefficient, as we demonstrate experimentally using a commercial database system. In this paper, we examine a class of queries involving (potentially repeated) selection, grouping and aggregation over the same groups, and propose an extension of SQL syntax that allows the succinct representation of these queries. We propose a new relational algebra operation that represents several levels of aggregation over the same groups in an operand relation. We demonstrate that the extended relational operator can be evaluated using efficient algorithms. We describe a translation from the extended SQL language into our algebraic language. We have implemented a preprocessor that evaluates our extended language on top of a commercial fl This research was supported by a grant from the AT&T Foundation, by a David and Lucile Packard Foundation Fellowship in Science and Engineering, by a Sloan Foundation Fellowship, by NSF grants IRI-9209029, CDA-90-24735, and by an NSF Young Investigator award. Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct commercial advantage, the VLDB copyright notice and the title of the publication and its date appear, and notice is given that copying is by permission of the Very Large Data Base Endowment. To copy otherwise, or to republish, requires a fee and/or special permission from the Endowment. Proceedings of the 22nd VLDB Conference Mumbai(Bombay), India, 1996 database system. We demonstrate that on a variety of examples, our implementation improves performance over standard SQL representations of the same examples by orders of
Abstract-found: 1
Intro-found: 1
Reference: [Cor94] <author> Sybase Corporation. </author> <title> Sybase SQL Server, Reference manual, Vol. </title> <type> 1. </type> <institution> Sybase, Inc, </institution> <year> 1994. </year>
Reference-contexts: While the change in SQL syntax is minimal, the expressivity of that keyword is limited. For example, they can have only one level of aggregation. Sybase allows some flexibility in the syntax of the select and having statements <ref> [Cor94] </ref>. In particular, select and having statements can include any attribute, not just those mentioned in the group by clause. Sybase's extended SQL can be used to express some group queries that would have to be phrased as a join in SQL92.
Reference: [Cou95] <institution> Transaction Processing Performance Council. </institution> <note> TPC-D benchmark description. (available from http://www.tpc.org), April 1995. </note>
Reference-contexts: These are natural queries for a marketing application or for a decision support system. Hence we have an important practical class of queries. Additional examples may be found in textbooks [DD92], business-related articles [KS95], and benchmarks <ref> [Cou95] </ref>. All of the examples are cumbersome to express in SQL. In every case, they need to be expressed using joins or subqueries.
Reference: [CS94] <author> Surajit Chaudhuri and Kyuseok Shim. </author> <title> Including group-by in query optimization. </title> <booktitle> In VLDB Conference, </booktitle> <pages> pages 354-366, </pages> <year> 1994. </year>
Reference-contexts: Yan and Larson in [YL94, YL95] describe a class of transformations that allow the query optimizer to push a group-by past a join (eager aggregation) or pulls a group-by above a join (lazy aggregation). In a similar direction, Chaudhuri and Shim in <ref> [CS94, CS96] </ref> present a similar class of pull-up and pushdown transformations. Furthermore, they incorporate these transformations in optimizers and propose a cost-based optimization algorithm to pick a plan. In [GHQ95], Gupta, Harinarayan and Quass try to unify these transformations, viewing aggregation as an extension of duplicate-eliminating projection.
Reference: [CS96] <author> Surajit Chaudhuri and Kyuseok Shim. </author> <title> Optimizing queries with aggregate views. </title> <booktitle> In Extending Database Technology, </booktitle> <pages> pages 167-182, </pages> <year> 1996. </year>
Reference-contexts: Yan and Larson in [YL94, YL95] describe a class of transformations that allow the query optimizer to push a group-by past a join (eager aggregation) or pulls a group-by above a join (lazy aggregation). In a similar direction, Chaudhuri and Shim in <ref> [CS94, CS96] </ref> present a similar class of pull-up and pushdown transformations. Furthermore, they incorporate these transformations in optimizers and propose a cost-based optimization algorithm to pick a plan. In [GHQ95], Gupta, Harinarayan and Quass try to unify these transformations, viewing aggregation as an extension of duplicate-eliminating projection.
Reference: [DD92] <author> C. J. Date and H. Darwen. </author> <title> Relational Database Writings 1989-1991. </title> <publisher> Addison-Wesley, </publisher> <year> 1992. </year>
Reference-contexts: These are natural queries for a marketing application or for a decision support system. Hence we have an important practical class of queries. Additional examples may be found in textbooks <ref> [DD92] </ref>, business-related articles [KS95], and benchmarks [Cou95]. All of the examples are cumbersome to express in SQL. In every case, they need to be expressed using joins or subqueries. <p> There is an overlapping of the class of queries that this operator expresses with our class. However, our techniques allow for significantly more complex aggregate queries. Several authors have pointed out that SQL cannot simply express a number of queries involving grouping and aggregation <ref> [DD92, KS95] </ref>. Kimball and Strehlo in [KS95] argued that SQL should be extended in order to be more powerful (in both syntax and performance) for queries related to grouping. They present some examples where standard SQL syntax is cumbersome and performance is bad, while the queries are conceptually easy.
Reference: [EN89] <author> Ramez Elmasri and Shamkant Navathe. </author> <title> Fundamentals of Database Systems. </title> <publisher> The Ben-jamin/Cummings Publishing Company, </publisher> <year> 1989. </year>
Reference-contexts: An additional renaming operator is defined as follows: i (R) simply prepends the label "i:" to every attribute name of R. There are several proposals for a grouping operator in the literature <ref> [EN89, Mum91] </ref>. <p> An additional renaming operator is defined as follows: i (R) simply prepends the label "i:" to every attribute name of R. There are several proposals for a grouping operator in the literature [EN89, Mum91]. We use a syntax similar to the syntax in <ref> [EN89] </ref>: an aggregate function operation F is defined as &lt;grouping attributes&gt; F [&lt;function list&gt;](R) where &lt;grouping attributes&gt; is the list of grouping attributes of the relation R, and &lt;function list&gt; is a list of the aggregate functions (min, max, count, average, sum), accompanied by an appropriate attribute of the relation specified
Reference: [GB + 96] <author> J. Gray, A. Bosworth, A. Layman, and H. Pi-rahesh. </author> <title> Datacube : A relational aggregation operator generalizing group-by, </title> <booktitle> cross-tab, and sub-totals. In IEEE International Conference on Data Engineering, </booktitle> <pages> pages 152-159, </pages> <year> 1996. </year> <pages> Page 11 </pages>
Reference-contexts: Gray, Bosworth, Layman and Pirahesh propose a relational aggregation operator, called datacube, which is useful in data analysis applications <ref> [GB + 96] </ref>. Each of the aggregation attributes is a dimension in a n-dimensional space. They propose an extension of SQL, using an argument similar to ours, i.e., the accomodation of this class of queries is important. The main contribution is a conceptualization of the the aggregation accross many dimensions.
Reference: [GHQ95] <author> Ashish Gupta, Venky Harinarayan, and Dallan Quass. </author> <title> Aggregate-query processing in data warehousing environments. </title> <booktitle> In VLDB Conference, </booktitle> <pages> pages 358-369, </pages> <year> 1995. </year>
Reference-contexts: In a similar direction, Chaudhuri and Shim in [CS94, CS96] present a similar class of pull-up and pushdown transformations. Furthermore, they incorporate these transformations in optimizers and propose a cost-based optimization algorithm to pick a plan. In <ref> [GHQ95] </ref>, Gupta, Harinarayan and Quass try to unify these transformations, viewing aggregation as an extension of duplicate-eliminating projection. A different type of optimization is found in [LMS94, LM96].
Reference: [KLK91] <author> Ravi Krishnamurthy, Witold Litwin, and William Kent. </author> <title> Language features for interoperability of databases with schematic discrepancies. </title> <booktitle> In ACM SIGMOD, Conference on Management of Data, </booktitle> <pages> pages 40-49, </pages> <year> 1991. </year>
Reference-contexts: Furthermore, the resulting implementation may be sub-optimal. (We shall address some of the resulting implementation difficulties in the next section.) Query Q2 is an example (a case of "Value-to-Attribute" conflict) of the well-known schematic discrepancies problem in database interoperability <ref> [KS91, KLK91, SCG93] </ref>. Data in one relation corresponds to Page 2 metadata in another, in this case the output result. Again, SQL needs a join of the CALLS relation with itself to express this query. <p> Our syntax can succinctly solve (for a known number of columns) the so-called Value-to-Attribute conflict, a case of schematic discrepancies in interoper-able databases. This conflict occurs when the same information is expressed as values in one table and as attributes in another <ref> [KS91, KLK91, SCG93, Roz94] </ref>. In [SCG93] the complexity of the SQL solution to this problem is criticized and a new operator is proposed.
Reference: [KS91] <author> Won Kim and Jungyum Seo. </author> <title> Classifying schematic and data heterogeneity in multi-database systems. </title> <journal> IEEE Computer, </journal> <volume> 24(12) </volume> <pages> 12-18, </pages> <year> 1991. </year>
Reference-contexts: Furthermore, the resulting implementation may be sub-optimal. (We shall address some of the resulting implementation difficulties in the next section.) Query Q2 is an example (a case of "Value-to-Attribute" conflict) of the well-known schematic discrepancies problem in database interoperability <ref> [KS91, KLK91, SCG93] </ref>. Data in one relation corresponds to Page 2 metadata in another, in this case the output result. Again, SQL needs a join of the CALLS relation with itself to express this query. <p> Our syntax can succinctly solve (for a known number of columns) the so-called Value-to-Attribute conflict, a case of schematic discrepancies in interoper-able databases. This conflict occurs when the same information is expressed as values in one table and as attributes in another <ref> [KS91, KLK91, SCG93, Roz94] </ref>. In [SCG93] the complexity of the SQL solution to this problem is criticized and a new operator is proposed.
Reference: [KS95] <author> Ralph Kimball and Kevin Strehlo. </author> <title> Why decision support fails and how to fix it. </title> <booktitle> SIGMOD RECORD, </booktitle> <volume> 24(3) </volume> <pages> 92-97, </pages> <year> 1995. </year>
Reference-contexts: These are natural queries for a marketing application or for a decision support system. Hence we have an important practical class of queries. Additional examples may be found in textbooks [DD92], business-related articles <ref> [KS95] </ref>, and benchmarks [Cou95]. All of the examples are cumbersome to express in SQL. In every case, they need to be expressed using joins or subqueries. <p> There is an overlapping of the class of queries that this operator expresses with our class. However, our techniques allow for significantly more complex aggregate queries. Several authors have pointed out that SQL cannot simply express a number of queries involving grouping and aggregation <ref> [DD92, KS95] </ref>. Kimball and Strehlo in [KS95] argued that SQL should be extended in order to be more powerful (in both syntax and performance) for queries related to grouping. They present some examples where standard SQL syntax is cumbersome and performance is bad, while the queries are conceptually easy. <p> However, our techniques allow for significantly more complex aggregate queries. Several authors have pointed out that SQL cannot simply express a number of queries involving grouping and aggregation [DD92, KS95]. Kimball and Strehlo in <ref> [KS95] </ref> argued that SQL should be extended in order to be more powerful (in both syntax and performance) for queries related to grouping. They present some examples where standard SQL syntax is cumbersome and performance is bad, while the queries are conceptually easy.
Reference: [LM96] <author> Alon Levy and Inderpal Singh Mumick. </author> <title> Reasoning with aggregation constraints. </title> <booktitle> In Extending Database Technology, </booktitle> <pages> pages 514-534, </pages> <year> 1996. </year>
Reference-contexts: In Section 2.2 we describe an efficient target implementation for these queries. Section 2.3 explains why relational database systems might have difficulty identifying such implementations given the specifications in Section 2.1. In the examples we shall use the following relation, taken from <ref> [LM96] </ref>. CALLS (FromAC,FromTel,ToAC,ToTel,Date,Length) The CALLS relation stores the calls placed on a telephone network over the period of one year. It includes the From number (area code and telephone number), the To number (area code and telphone number), the date and the length of the call. <p> Furthermore, they incorporate these transformations in optimizers and propose a cost-based optimization algorithm to pick a plan. In [GHQ95], Gupta, Harinarayan and Quass try to unify these transformations, viewing aggregation as an extension of duplicate-eliminating projection. A different type of optimization is found in <ref> [LMS94, LM96] </ref>. While the above mentioned authors give criteria on when to apply the pull-up and push-down tran-formations (given a set of predicates), Levy and Mu-mick consider an orthogonal problem.
Reference: [LMS94] <author> Alon Levy, Inderpal Singh Mumick, and Yehoshua Sagiv. </author> <title> Query optimization by predicate movearound. </title> <booktitle> In VLDB Conference, </booktitle> <pages> pages 96-107, </pages> <year> 1994. </year>
Reference-contexts: Furthermore, they incorporate these transformations in optimizers and propose a cost-based optimization algorithm to pick a plan. In [GHQ95], Gupta, Harinarayan and Quass try to unify these transformations, viewing aggregation as an extension of duplicate-eliminating projection. A different type of optimization is found in <ref> [LMS94, LM96] </ref>. While the above mentioned authors give criteria on when to apply the pull-up and push-down tran-formations (given a set of predicates), Levy and Mu-mick consider an orthogonal problem.
Reference: [Mum91] <author> I. S. Mumick. </author> <title> Query Optimization in Deductive and Relational Databases. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Stanford University, </institution> <year> 1991. </year>
Reference-contexts: An additional renaming operator is defined as follows: i (R) simply prepends the label "i:" to every attribute name of R. There are several proposals for a grouping operator in the literature <ref> [EN89, Mum91] </ref>.
Reference: [RBV96] <author> Sudhir Rao, Antonio Badia, and Dirk Van Gucht. </author> <title> Providing better support for a class of decision support queries. </title> <booktitle> In ACM SIGMOD, Conference on Management of Data, </booktitle> <pages> pages 217-227, </pages> <year> 1996. </year>
Reference-contexts: However, their techniques are significantly less general than ours; their syntax corresponds roughly with allowing just one grouping variable. Consequently, their extended syntax cannot succinctly express Queries Q2, Q3, or Q4. Rao, Badia and Van Gucht address the issue of supporting quantified subqueries <ref> [RBV96] </ref>. Their work, which was done independently from ours, is motivated by similar concerns that SQL's syntax is cumbersome for expressing and optimizing a natural class of queries.
Reference: [Roz94] <author> David Rozenshtein. </author> <title> Linguistic optimization: A new approach to writing efficient SQL queries. </title> <booktitle> In Ventures in Research, </booktitle> <address> Long Island University, </address> <year> 1994. </year>
Reference-contexts: Our syntax can succinctly solve (for a known number of columns) the so-called Value-to-Attribute conflict, a case of schematic discrepancies in interoper-able databases. This conflict occurs when the same information is expressed as values in one table and as attributes in another <ref> [KS91, KLK91, SCG93, Roz94] </ref>. In [SCG93] the complexity of the SQL solution to this problem is criticized and a new operator is proposed. <p> Rozenshtein emphasizes that the Value-to-Attribute conflict (which he calls Table-Pivoting) can be solved in just one pass over the grouped relation, and proposes a solution using the notion of characteristic functions <ref> [Roz94] </ref>. Again, our syntax expresses a significantly more general class of queries. 6 Conclusions We have identified redundancy in both relational algebra and SQL in the way these languages specify a number of conceptually simple aggregate queries.
Reference: [SCG93] <author> F. Saltor, M.G. Castelanos, and M. Garcia-Solaco. </author> <title> Overcoming schematic discrepancies in interoperable databases. </title> <booktitle> In Interoperable Database Systems, </booktitle> <pages> pages 191-205. </pages> <publisher> Elsevier Science Pub N.V. (North-Holland), </publisher> <year> 1993. </year>
Reference-contexts: Furthermore, the resulting implementation may be sub-optimal. (We shall address some of the resulting implementation difficulties in the next section.) Query Q2 is an example (a case of "Value-to-Attribute" conflict) of the well-known schematic discrepancies problem in database interoperability <ref> [KS91, KLK91, SCG93] </ref>. Data in one relation corresponds to Page 2 metadata in another, in this case the output result. Again, SQL needs a join of the CALLS relation with itself to express this query. <p> Our syntax can succinctly solve (for a known number of columns) the so-called Value-to-Attribute conflict, a case of schematic discrepancies in interoper-able databases. This conflict occurs when the same information is expressed as values in one table and as attributes in another <ref> [KS91, KLK91, SCG93, Roz94] </ref>. In [SCG93] the complexity of the SQL solution to this problem is criticized and a new operator is proposed. <p> Our syntax can succinctly solve (for a known number of columns) the so-called Value-to-Attribute conflict, a case of schematic discrepancies in interoper-able databases. This conflict occurs when the same information is expressed as values in one table and as attributes in another [KS91, KLK91, SCG93, Roz94]. In <ref> [SCG93] </ref> the complexity of the SQL solution to this problem is criticized and a new operator is proposed. Rozenshtein emphasizes that the Value-to-Attribute conflict (which he calls Table-Pivoting) can be solved in just one pass over the grouped relation, and proposes a solution using the notion of characteristic functions [Roz94].
Reference: [YL94] <author> Weipeng P. Yan and Per-Ake Larson. </author> <title> Performing Group-By before Join. </title> <booktitle> In IEEE International Conference on Data Engineering, </booktitle> <pages> pages 89-100, </pages> <year> 1994. </year>
Reference-contexts: However, none of these addresses the optimization of our particular class of queries. These authors mainly examine which of a group by and a join should be executed first. As we have seen, joins in our class of queries could be avoided completely. Yan and Larson in <ref> [YL94, YL95] </ref> describe a class of transformations that allow the query optimizer to push a group-by past a join (eager aggregation) or pulls a group-by above a join (lazy aggregation). In a similar direction, Chaudhuri and Shim in [CS94, CS96] present a similar class of pull-up and pushdown transformations.
Reference: [YL95] <author> Weipeng P. Yan and Per-Ake Larson. </author> <title> Eager aggregation and lazy aggregation. </title> <booktitle> In VLDB Conference, </booktitle> <pages> pages 345-357, </pages> <year> 1995. </year> <pages> Page 12 </pages>
Reference-contexts: However, none of these addresses the optimization of our particular class of queries. These authors mainly examine which of a group by and a join should be executed first. As we have seen, joins in our class of queries could be avoided completely. Yan and Larson in <ref> [YL94, YL95] </ref> describe a class of transformations that allow the query optimizer to push a group-by past a join (eager aggregation) or pulls a group-by above a join (lazy aggregation). In a similar direction, Chaudhuri and Shim in [CS94, CS96] present a similar class of pull-up and pushdown transformations.
References-found: 19

