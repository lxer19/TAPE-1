URL: http://www.cs.berkeley.edu/~guyb/real-world/class-notes/all/AlgsInRealWorld.ps.gz
Refering-URL: http://www.cs.berkeley.edu/~guyb/real-world/class-notes/list.html
Root-URL: 
Title: Algorithms in the Real World: Lecture Notes (Fall 1997) document. They did an excellent job
Author: Guy Blelloch 
Note: I would like to thank all the students who took the notes that appear in this  
Date: April 23, 1998  
Abstract: This document contains the lecture notes taken by the students in the course "Algorithms in the Real World" taught at UC Berkeley during the Fall semester, 1997. The class covered the following set of ten topics: Compression, Cryptography, Linear Programming, Integer Programming, Triangulation, N-body simulation, VLSI Physical Design, Pattern Matching in Biology, Indexing, and Clustering. Between 2 and 3 lectures were dedicated to each topic. For all topics we looked both at algorithms and at case studies in which the problems are used in real-world applications. The class was a graduate class and assumed that the students came in with a working knowledge of the material covered in a standard algorithms textbook, such as Cormen, Leiserson and Rivest's "Introduction to Algorithms". A goal of the class was to have the students gain an appreciation of how interesting algorithms and data-structures are used in many real-world applications. The notes contained in this document are based on what was covered in the lectures and are not meant to be complete, and although the scribe takers corrected many of the mistakes in my lectures, I expect many others got through. I must also apologize that the notes contain very few references to the original work on which they rely. Instead I have included at the end of the document a list of primary texts on the topics from which one can find further information. Also, there is a web page associated with the class that has many more online pointers http://www.cs.berkeley.edu/~guyb/algs.html.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Garland and P. Heckbert. </author> <title> "Fast polygonal approximation of terrains and height fields." </title> <type> CMU Technical Report, </type> <institution> CMU-CS-95-181, Carnegie Mellon University, </institution> <address> Pitts-burgh, PA, </address> <month> September </month> <year> 1995. </year>
Reference-contexts: The table below shows an example of our internal representation for the mesh shown in Figure 113. The value after the dot represents which of the 4 entries in the edge is being pointed to. 2 This was the format used by Garland and Heckbert <ref> [1] </ref> in their original work. However, in comments to Prof.
Reference: [2] <author> J. Ruppert. </author> <title> "A Delaunay refinement algorithm for quality 2-dimensional mesh generation." </title> <type> NASA Technical Report, </type> <institution> RNR-94-002, </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: 1 ; T 2 ) = Flip (T; T 0 ) Patch (p; T 1 ) Patch (p; T 2 ) end The function Flip flips two adjacent triangles so the crossedge changes. 1.3 Ruppert Meshing In this section we discuss two issues to consider when implementing Ruppert's meshing algorithm <ref> [2] </ref>. The first relates to how one finds encroaching points. First, recall that a point p encroaches upon a segment s if p lies within the diametrical circle defined by s (see Figure 116).
Reference: [3] <author> N. Sherwani. </author> <title> Algorithms for VLSI Physical Design Automation. </title> <publisher> Kluwer, </publisher> <year> 1995. </year> <month> 208 </month>
Reference-contexts: We will be making a number of references to diagrams shown in <ref> [3] </ref>. 3 2.1 Overview The following is a high-level description of the VLSI design process. The focus of our discussions will be on step 5 below. 1. System specification: The first step involves the creation of a formal, high-level representation of the system. <p> this entire design process is iterative, i.e., there is a kind of "feedback" effect in which we examine the results, perform any necessary hand-tuning, and re-run the process, continually refining our previous results. 3 In fact, most of the material here is simply a paraphrase of material that appears in <ref> [3] </ref>. 202 2.1.1 Physical design We now turn our attention to the physical design cycle which will be our focus. The following is a brief summary of the high-level process. <p> Clearly, this is the most difficult design style to automate because of the high degree of freedom. A full custom approach is really only appropriate when performance must be high. For instance, this is the method of choice for the layout of modern microprocessors. An example is shown in <ref> [3] </ref> (Figure 1.3). 2. Standard cell: In the standard cell design style, we predesign certain functional units as standard cells, or standard blocks, and create a cell library of "pre-packaged" blocks that we can then use for placement. Each cell is preanalyzed and pretested. <p> Each cell is preanalyzed and pretested. Given that the cells are predesigned, the main challenge is the layout and routing. An example of a standard cell layout is shown in <ref> [3] </ref> (Figure 1.4). Notice that the blocks are all of a similar shape and size, and that their layout is much more regular than the layout of the full-custom design shown in [3] (Figure 1.3). <p> An example of a standard cell layout is shown in <ref> [3] </ref> (Figure 1.4). Notice that the blocks are all of a similar shape and size, and that their layout is much more regular than the layout of the full-custom design shown in [3] (Figure 1.3). Observe that in the standard cell design, our only (roughly speaking) degree of freedom is the ability to shift blocks to open up routing channels between placed cells. 3. <p> Gate arrays: A gate array is like a standard cell except that all the "cells" are the same, and laid out in an array form as shown in <ref> [3] </ref> (Figure 1.5). The name is indicative of the idea that the cells could be as simple as a single gate (a 3-input NAND gate is shown). Furthermore, the routing channels are basically predetermined. The advantage of the gate array style over the previous two is its simplicity. <p> In particular, it is cheaper and easier to produce a wafer based on this style. Routing is also simplified, since we only have to make connections and not worry about minimizing the area used. An example of a routed gate array for a simple logic circuit is shown in <ref> [3] </ref> (Figure 1.6). However, the cost is the rigidity imposed|we would certainly be forced to produce larger chips and incur a performance penalty. 4. Field programmable gate arrays: A field programmable gate array (FPGA) is something in-between the gate array and standard cell. An example is shown in [3] (Figure 1.7). <p> shown in <ref> [3] </ref> (Figure 1.6). However, the cost is the rigidity imposed|we would certainly be forced to produce larger chips and incur a performance penalty. 4. Field programmable gate arrays: A field programmable gate array (FPGA) is something in-between the gate array and standard cell. An example is shown in [3] (Figure 1.7). Each "cell" of a FPGA (labeled by B i in the figure) can be viewed as a lookup table that can be programmed. <p> The partitioning problem for FPGAs is different from that of the other design styles, but the placement and routing problems are similar to those of the gate array. We summarize the various tradeoffs alluded to above as follows <ref> [3] </ref> (table 1.2): 204 based on the npn junction. (b) When a voltage has been applied to the gate, the induced electric field alters the conducting properties of the channel, thereby allowing current to flow. (c) Schematic representations of the process. [Taken from [3] (Figure 2.5).] style Area compact compact to <p> various tradeoffs alluded to above as follows <ref> [3] </ref> (table 1.2): 204 based on the npn junction. (b) When a voltage has been applied to the gate, the induced electric field alters the conducting properties of the channel, thereby allowing current to flow. (c) Schematic representations of the process. [Taken from [3] (Figure 2.5).] style Area compact compact to moderate moderate large Performance high high to moderate moderate low Fabrication layers all all routing layer none In general, within a given column of the table there is a correlation between the rows. <p> In all other cases, the channels of at least one of the lower transistors will be closed which will break the connection between GND and C, whereas when either channel of the upper two transistors are open, C will be pulled up to VDD. [Taken from <ref> [3] </ref> (Figure 2.7).] the design parameter . The ".35" of the terms ".35 micron technology," et al., refer to this parameter. [Taken from [3] (Figure 2.10).] 206 2.2 The role of algorithms Algorithms have played a crucial role in the explosive growth of VLSI technology. <p> break the connection between GND and C, whereas when either channel of the upper two transistors are open, C will be pulled up to VDD. [Taken from <ref> [3] </ref> (Figure 2.7).] the design parameter . The ".35" of the terms ".35 micron technology," et al., refer to this parameter. [Taken from [3] (Figure 2.10).] 206 2.2 The role of algorithms Algorithms have played a crucial role in the explosive growth of VLSI technology. Graph theory has played a particularly important part. Here is a list of some of the many algorithms that have been applied to VLSI physical design automation: 1.
Reference: [4] <author> C. Kittel. </author> <title> Introduction to Solid-State Physics. </title> <editor> Merriam, (fill in details), </editor> <year> 1995. </year>
Reference-contexts: For a more general introduction to the basic solid-state physics behind the operation of these devices, see <ref> [4] </ref> and [5]. By combining several transistors, we can construct basic logic gates such as the NAND gate shown in Figure 120. See the figure caption for a rough description of its operation.

References-found: 4

