URL: http://www.cs.sunysb.edu/~juliana/schedws.ps.gz
Refering-URL: http://www.cs.sunysb.edu/~juliana/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: juliana@research.bell-labs.com ftswift,warreng@cs.sunysb.edu  
Title: Scheduling in SLG Revisited  
Address: 600 Mountain Avenue  Murray Hill, NJ 07974 Stony Brook, NY 11794-4400 U.S.A U.S.A.  
Affiliation: Bell Laboratories Department of Computer Science  SUNY at Stony Brook  
Abstract:  
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Boulanger. </author> <title> Fine-grained goal-directed declarative analysis of logic programs. </title> <booktitle> Proceedings of the International Workshop on Verification, Model Checking and Abstract Interpretation, </booktitle> <year> 1997. </year> <note> Available at http://www.dsi.unive.it/bossi/VMCAI.html. </note>
Reference-contexts: 1 Introduction Applications of Tabled Logic Programming are becoming common. Many abstract interpreters use tabling (or magic) to determine properties of programs <ref> [9, 3, 1] </ref>. Tabling is also used for model checking [12], for natural language analysis [11, 10], and for medical diagnosis [8].
Reference: [2] <author> W. Chen and D.S. Warren. </author> <title> Tabled Evaluation with Delaying for General Logic Programs. </title> <journal> JACM, </journal> <volume> 43(1):2074, </volume> <month> January </month> <year> 1996. </year>
Reference-contexts: Various formulations either rely implicitly on a given scheduling strategy, such as OLDT [17] or WFOS [15], or do not formulate scheduling at all, such as SLG <ref> [2] </ref>. Indeed, one might say that tabled evaluations can be characterized by their operations (such as whether a subsumption or variant check is used to examine whether calls or answers reside in a table) along with their scheduling strategy.
Reference: [3] <author> S. Dawson, C.R. Ramakrishnan, and D.S. Warren. </author> <title> Practical Program Analysis Using General Purpose Logic Programming Systems A Case Study. </title> <booktitle> In Proceedings of the ACM Conference on Programming Language Design and Implementation (PLDI), </booktitle> <pages> pages 117125. </pages> <publisher> ACM, </publisher> <year> 1996. </year>
Reference-contexts: 1 Introduction Applications of Tabled Logic Programming are becoming common. Many abstract interpreters use tabling (or magic) to determine properties of programs <ref> [9, 3, 1] </ref>. Tabling is also used for model checking [12], for natural language analysis [11, 10], and for medical diagnosis [8].
Reference: [4] <author> J. Freire, R. Hu, T. Swift, and D.S. Warren. </author> <title> Exploiting Parallelism in Tabled Evaluations. </title> <booktitle> In 7th International Symposium PLILP, </booktitle> <pages> pages 115132, </pages> <year> 1995. </year>
Reference-contexts: Indeed, despite the results about iteration equivalence between breadth-first tabling and magic mentioned above, the question of comparing magic-based evaluations such as well-founded ordered search [15] or [19] to tabled evaluations remains open for programs with negation. Similar questions about scheduling occur when tabling is combined with parallelism <ref> [4, 13] </ref>. Work on both of these questions on mixing scheduling strategies and on comparing evaluation methods has been made difficult by the lack of a formal basis for scheduling in tabled evaluations.
Reference: [5] <author> J. Freire, T. Swift, and D.S. Warren. </author> <title> Beyond Depth-First: Improving tabled logic programs through alternative scheduling strategies. </title> <journal> Journal of Functional and Logic Programming, </journal> <note> 1997. To appear (An earlier version appeared in Proceedings of the 8th International Symposium PLILP, </note> <year> 1996). </year>
Reference-contexts: Experience has indicated that tabled evaluations can be highly sensitive to the order in which operations are performed, or scheduling strategy for an evaluation. Previous empirical work <ref> [5, 6] </ref> has shown that the scheduling strategy used can radically affect memory usage, execution time, and disk access patterns. Strategies that have been evaluated in the XSB system include: * Single Stack Scheduling, the original scheduling for XSB [16]. <p> SingleStack = op 1 ; : : : ; op m ; op new ; : : : ; op n * Otherwise, op new SingleStack = op new ; : 2 The full version of this paper defines sequence combinators for Batched Scheduling and Local Scheduling (both introduced in <ref> [5] </ref>), as well as for Breadth-First Scheduling (introduced in [6]). In addition, all of these sequence combinators are proven to be fair. <p> The empiric results of <ref> [5] </ref>, [6] and [7] highlighted some of the characteristics of specific scheduling strategies. However, the lack of a formal structure made it difficult to define these strategies more precisely, prove their correctness and compare different strategies.
Reference: [6] <author> J. Freire, T. Swift, and D.S. Warren. </author> <title> Taking I/O seriously: Resolution reconsidered for disk. </title> <booktitle> In Proceedings of the International Conference on Logic Programming (ICLP), </booktitle> <pages> pages 198212, </pages> <year> 1997. </year>
Reference-contexts: Experience has indicated that tabled evaluations can be highly sensitive to the order in which operations are performed, or scheduling strategy for an evaluation. Previous empirical work <ref> [5, 6] </ref> has shown that the scheduling strategy used can radically affect memory usage, execution time, and disk access patterns. Strategies that have been evaluated in the XSB system include: * Single Stack Scheduling, the original scheduling for XSB [16]. <p> op m ; op new ; : : : ; op n * Otherwise, op new SingleStack = op new ; : 2 The full version of this paper defines sequence combinators for Batched Scheduling and Local Scheduling (both introduced in [5]), as well as for Breadth-First Scheduling (introduced in <ref> [6] </ref>). In addition, all of these sequence combinators are proven to be fair. <p> The empiric results of [5], <ref> [6] </ref> and [7] highlighted some of the characteristics of specific scheduling strategies. However, the lack of a formal structure made it difficult to define these strategies more precisely, prove their correctness and compare different strategies.
Reference: [7] <author> J. Freire and D.S. Warren. </author> <title> Combining scheduling strategies in tabled evaluation. </title> <booktitle> In Workshop on Parallelism and Implementation Technology for Logic Programming, </booktitle> <year> 1997. </year> <note> Available at http://www.cs.nmsu.edu/lldap/ilps97. </note>
Reference-contexts: Because different scheduling strategies have advantages in different situations, one would expect a fully mature tabling system to take advantage of these different strategies within the same evaluation when addressing practical problems <ref> [7] </ref>. Scheduling is also an important element to understand when comparing different formalisms. Indeed, despite the results about iteration equivalence between breadth-first tabling and magic mentioned above, the question of comparing magic-based evaluations such as well-founded ordered search [15] or [19] to tabled evaluations remains open for programs with negation. <p> The empiric results of [5], [6] and <ref> [7] </ref> highlighted some of the characteristics of specific scheduling strategies. However, the lack of a formal structure made it difficult to define these strategies more precisely, prove their correctness and compare different strategies. Here, we address this problem by proposing a formal framework to model scheduling strategies, SLG sched .
Reference: [8] <institution> Medicine Rules Inc. Diagnostica. </institution> <type> Technical report. </type> <note> http://medicinerules.com. </note>
Reference-contexts: 1 Introduction Applications of Tabled Logic Programming are becoming common. Many abstract interpreters use tabling (or magic) to determine properties of programs [9, 3, 1]. Tabling is also used for model checking [12], for natural language analysis [11, 10], and for medical diagnosis <ref> [8] </ref>. Several reasons account for this profusion of applications, among them the fact that tabled logic programs have a clear declarative semantics in the Well-Founded Semantics, well-defined operational semantics, and high-quality implementations (e.g., the XSB system [14]).
Reference: [9] <author> G. Janssens, M. Bruynooghe, and V. Dumortier. </author> <title> A Blueprint for an Abstract Machine for Abstract Interpretation of (Constraint) Logic Programs. </title> <booktitle> In Proceedings of the International Symposium on Logic Programming (ILPS), </booktitle> <pages> pages 336 350, </pages> <year> 1995. </year>
Reference-contexts: 1 Introduction Applications of Tabled Logic Programming are becoming common. Many abstract interpreters use tabling (or magic) to determine properties of programs <ref> [9, 3, 1] </ref>. Tabling is also used for model checking [12], for natural language analysis [11, 10], and for medical diagnosis [8].
Reference: [10] <author> R.K. Larson, D.S. Warren, J. Freire, P. Gomez, and K. </author> <title> Sagonas. </title> <publisher> Semantica. MIT Press, </publisher> <year> 1997. </year>
Reference-contexts: 1 Introduction Applications of Tabled Logic Programming are becoming common. Many abstract interpreters use tabling (or magic) to determine properties of programs [9, 3, 1]. Tabling is also used for model checking [12], for natural language analysis <ref> [11, 10] </ref>, and for medical diagnosis [8]. Several reasons account for this profusion of applications, among them the fact that tabled logic programs have a clear declarative semantics in the Well-Founded Semantics, well-defined operational semantics, and high-quality implementations (e.g., the XSB system [14]).
Reference: [11] <author> R.K. Larson, D.S. Warren, J. Freire, and K. </author> <title> Sagonas. </title> <publisher> Syntactica. MIT Press, </publisher> <year> 1996. </year>
Reference-contexts: 1 Introduction Applications of Tabled Logic Programming are becoming common. Many abstract interpreters use tabling (or magic) to determine properties of programs [9, 3, 1]. Tabling is also used for model checking [12], for natural language analysis <ref> [11, 10] </ref>, and for medical diagnosis [8]. Several reasons account for this profusion of applications, among them the fact that tabled logic programs have a clear declarative semantics in the Well-Founded Semantics, well-defined operational semantics, and high-quality implementations (e.g., the XSB system [14]).
Reference: [12] <author> Y. Ramakrishna, C.R. Ramakrishnan, I.V. Ramakrishnan, S. Smolka, T. Swift, and D. Warren. </author> <title> Efficient model checking using tabled resolution. </title> <booktitle> In Proceedings of Computer Aided Verification (CAV), </booktitle> <year> 1997. </year>
Reference-contexts: 1 Introduction Applications of Tabled Logic Programming are becoming common. Many abstract interpreters use tabling (or magic) to determine properties of programs [9, 3, 1]. Tabling is also used for model checking <ref> [12] </ref>, for natural language analysis [11, 10], and for medical diagnosis [8]. Several reasons account for this profusion of applications, among them the fact that tabled logic programs have a clear declarative semantics in the Well-Founded Semantics, well-defined operational semantics, and high-quality implementations (e.g., the XSB system [14]).
Reference: [13] <author> R. Rocha, F. Silva, </author> <title> and V.S. Costa. On applying or-parallelism to tabled evaluations. </title> <booktitle> In Proceedings of the First International Workshop on Tabling in Logic Programming, </booktitle> <year> 1997. </year>
Reference-contexts: Indeed, despite the results about iteration equivalence between breadth-first tabling and magic mentioned above, the question of comparing magic-based evaluations such as well-founded ordered search [15] or [19] to tabled evaluations remains open for programs with negation. Similar questions about scheduling occur when tabling is combined with parallelism <ref> [4, 13] </ref>. Work on both of these questions on mixing scheduling strategies and on comparing evaluation methods has been made difficult by the lack of a formal basis for scheduling in tabled evaluations.
Reference: [14] <author> K. Sagonas, T. Swift, D.S. Warren, J. Freire, and P. Rao. </author> <title> The XSB Programmer's Manual, </title> <note> 1997. Available at http://www.cs.sunysb.edu/sbprolog. </note>
Reference-contexts: Several reasons account for this profusion of applications, among them the fact that tabled logic programs have a clear declarative semantics in the Well-Founded Semantics, well-defined operational semantics, and high-quality implementations (e.g., the XSB system <ref> [14] </ref>). Experience has indicated that tabled evaluations can be highly sensitive to the order in which operations are performed, or scheduling strategy for an evaluation. Previous empirical work [5, 6] has shown that the scheduling strategy used can radically affect memory usage, execution time, and disk access patterns.
Reference: [15] <author> P. Stuckey and S. Sudarshan. </author> <title> Well-Founded Ordered Search: Goal Directed Bottom-Up Evaluation of Well-Founded Models. </title> <journal> Journal of Logic Programming, </journal> <volume> 32(3):171205, </volume> <year> 1997. </year>
Reference-contexts: Scheduling is also an important element to understand when comparing different formalisms. Indeed, despite the results about iteration equivalence between breadth-first tabling and magic mentioned above, the question of comparing magic-based evaluations such as well-founded ordered search <ref> [15] </ref> or [19] to tabled evaluations remains open for programs with negation. Similar questions about scheduling occur when tabling is combined with parallelism [4, 13]. <p> Work on both of these questions on mixing scheduling strategies and on comparing evaluation methods has been made difficult by the lack of a formal basis for scheduling in tabled evaluations. Various formulations either rely implicitly on a given scheduling strategy, such as OLDT [17] or WFOS <ref> [15] </ref>, or do not formulate scheduling at all, such as SLG [2]. Indeed, one might say that tabled evaluations can be characterized by their operations (such as whether a subsumption or variant check is used to examine whether calls or answers reside in a table) along with their scheduling strategy.
Reference: [16] <author> T. Swift and D.S. Warren. </author> <title> An Abstract Machine for SLG Resolution: Definite Programs. </title> <booktitle> In Proceedings of the International Symposium on Logic Programming (ILPS), </booktitle> <pages> pages 633654, </pages> <year> 1994. </year>
Reference-contexts: Previous empirical work [5, 6] has shown that the scheduling strategy used can radically affect memory usage, execution time, and disk access patterns. Strategies that have been evaluated in the XSB system include: * Single Stack Scheduling, the original scheduling for XSB <ref> [16] </ref>. As its name implies, Single Stack Scheduling uses a stack to control scheduling of all program clause and answer resolution steps. * Batched Scheduling, the default scheduling of XSB v. 1.5 and higher. <p> In fact, sequence combinators have been constructed for all scheduling strategies that have been implemented in XSB. Here, we illustrate the simplest scheduling strategy, Single Stack Scheduling, as defined in <ref> [16] </ref>. In order to define the sequence combinator for Single Stack Scheduling (and as a matter of fact, for all other scheduling strategies for SLG) we need the notions of subgoal dependency graph (SDG) and leader of a strongly connected component.
Reference: [17] <author> H. Tamaki and T. Sato. </author> <title> OLDT resolution with tabulation. </title> <booktitle> In Proceedings of the International Conference on Logic Programming (ICLP), </booktitle> <pages> pages 8498, </pages> <year> 1986. </year>
Reference-contexts: Work on both of these questions on mixing scheduling strategies and on comparing evaluation methods has been made difficult by the lack of a formal basis for scheduling in tabled evaluations. Various formulations either rely implicitly on a given scheduling strategy, such as OLDT <ref> [17] </ref> or WFOS [15], or do not formulate scheduling at all, such as SLG [2].
Reference: [18] <author> A. van Gelder, K.A. Ross, and J.S. Schlipf. </author> <title> Unfounded sets and well-founded semantics for general logic programs. </title> <journal> JACM, </journal> <volume> 38(3):620650, </volume> <year> 1991. </year>
Reference: [19] <author> U. Zukowski and B. Freitag. </author> <title> Adding flexibility to query evaluation for modularly stratified databases. </title> <booktitle> In Proceedings of the Joint International Conference and Symposium on Logic Programming (JICSLP), </booktitle> <pages> pages 304318, </pages> <year> 1996. </year> <month> 5 </month>
Reference-contexts: Scheduling is also an important element to understand when comparing different formalisms. Indeed, despite the results about iteration equivalence between breadth-first tabling and magic mentioned above, the question of comparing magic-based evaluations such as well-founded ordered search [15] or <ref> [19] </ref> to tabled evaluations remains open for programs with negation. Similar questions about scheduling occur when tabling is combined with parallelism [4, 13].
References-found: 19

