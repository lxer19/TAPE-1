URL: http://www.isi.edu/isd/I-DOC/kbse95.ps
Refering-URL: http://www.isi.edu/isd/I-DOC/i-doc.html
Root-URL: http://www.isi.edu
Email: fjohnson,erdemg@isi.edu  
Title: Interactive Explanation of Software Systems  
Author: W. Lewis Johnson and Ali Erdem 
Note: Submitted to the 10th Knowledge-Based Software Engineering Conference (KBSE-95)  
Web: WWW: http://www.isi.edu/isd/johnson.html, erdem.html  
Address: 4676 Admiralty Way, Marina del Rey, CA 90292-6695  
Affiliation: USC Information Sciences Institute Computer Science Dept.  
Abstract: This paper describes an effort to provide automated support for the interactive inquiry and explanation process that is at the heart of software understanding. A hypermedia tool called I-Doc allows software engineers to post queries about a software system, and generates focused explanations in response. These explanations are task-oriented, i.e., they are sensitive to the software engineering task being performed by the user that led to the query. Task orientation leads to more effective explanations, and is particularly helpful for understanding large software systems. Empirical studies of inquiry episodes were conducted which support this claim. The I-Doc tool is being developed to embody these principles, employing knowledge-based techniques. The presentation mechanism employs World Wide Web technology, making it suitable for widespread use. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Brooks. </author> <title> Towards a theory of the comprehension of computer programs. </title> <journal> International Journal of Man-Machine Studies, </journal> <volume> 18 </volume> <pages> 543-554, </pages> <year> 1983. </year>
Reference-contexts: 1 Introduction and Motivation Software engineers, and software maintainers in particular, spend significant amounts of time attempting to understand software artifacts [2]. These software understanding activities have been characterized by Brooks and Soloway <ref> [1, 15] </ref> as being composed of inquiry episodes. According to Soloway et al., inquiry episodes involve the following steps: read some code, ask a question about the code, conjecture an answer, and search the documentation and code for confirmation of the conjecture. <p> Software engineering tasks such as design or maintenance are much broader, and the influence of such tasks on software understanding is unclear, although software understanding researchers such as Brooks have conjectured that such influences exist <ref> [1] </ref>. In order to develop tools that approach the ideal of an on-line software consultant, our work has proceeded on two thrusts.
Reference: [2] <author> T.A. Corbi. </author> <title> Program understanding: Challenge for the 1990s. </title> <journal> IBM Systems Journal, </journal> <volume> 28(2) </volume> <pages> 294-306, </pages> <year> 1990. </year>
Reference-contexts: 1 Introduction and Motivation Software engineers, and software maintainers in particular, spend significant amounts of time attempting to understand software artifacts <ref> [2] </ref>. These software understanding activities have been characterized by Brooks and Soloway [1, 15] as being composed of inquiry episodes.
Reference: [3] <author> J.H. </author> <title> Cross and T.D. Hendrix. Using generalized markup and SGML for reverse engineering graphical representations of software. </title> <booktitle> In Proceedings of the 2d Working Conference on Reengineering, </booktitle> <year> 1995. </year>
Reference-contexts: The tags are enclosed in angle brackets, and either represent the attribute values individually or serve as starting and ending delimiters surrounding the attribute value. This scheme is somewhat similar to the one used by the GRASP-ML system for annotating source code <ref> [3] </ref>. Attribute values may be text strings or collections of features used to identify the object that is the attribute value. Figure 8 shows the internal representation of the control portion of AMPSE's application programmer interface.
Reference: [4] <author> D.E. Egan. </author> <title> Individual differences in human-computer interaction. </title> <editor> In M. Helander, editor, </editor> <title> Handbook of Human-Computer Interaction, </title> <booktitle> chapter 24, </booktitle> <pages> pages 543-568. </pages> <publisher> Elsevier Science Publishers B.V. (North Holland), </publisher> <year> 1988. </year>
Reference-contexts: However this difference is not as significant as the previous one, since both Tcl and Tk are interpretive languages. Egan claimed that there is some overlap in terms of the mental processes for coding and debugging in interpretive languages <ref> [4] </ref>. Programmers using interpreted languages generate a small amount of code, read it for comprehension and correct errors in a continuous fashion [4]. <p> Egan claimed that there is some overlap in terms of the mental processes for coding and debugging in interpretive languages <ref> [4] </ref>. Programmers using interpreted languages generate a small amount of code, read it for comprehension and correct errors in a continuous fashion [4]. Although most of the questions posted to this newsgroup came from program developers, we believe that similar questions will be asked by maintenance programmers when they try to understand the same programs. 2.3 Data Analysis We read 1250 messages posted to the newsgroup between 2/17/95 and 4/22/95.
Reference: [5] <author> J.D. Herbsleb and E. Kuwana. </author> <title> Preserving knowledge in design projects: What designers need to know. </title> <booktitle> In INTERCHI'93, </booktitle> <year> 1993. </year>
Reference-contexts: For data analysis we followed a method similar to <ref> [5] </ref> in that we considered only the messages that asked questions about Tcl/Tk. Messages asking irrelevant questions (distribution sites, FAQ location etc.), product announcements, opinions were ignored. We found 249 questions and classified them as follows: We first tried to estimate the user's expertise level. <p> Finally we identified the target for each question in order to find out the relations between question type, level of expertise and target. As in Herbsleb and Kuwana's study <ref> [5] </ref>, we defined target as the subject of the question or the task user was asking about. For example How can I pass an array from Tcl to C? had the target array. 2.4 Results After all the messages were classified, we counted the number of messages in each group.
Reference: [6] <author> W.C. Hill and J.R Miller. </author> <title> Justified advice: A semi-naturalistic study of advisory strategies. </title> <booktitle> In CHI'88. ACM, </booktitle> <year> 1988. </year>
Reference-contexts: For experts, system oriented questions increased to 11% mainly because of explanatory questions. Hill and Miller studied the types of questions asked by users of an experimental graphical statistics system <ref> [6] </ref>. They categorized questions differently like plans to subgoal, describe system object etc. When we converted their results to our categorization we found that in their study goal oriented questions were 70%, system oriented questions were 22% and problem oriented questions were 4% of the total questions.
Reference: [7] <author> W.L. Johnson, M.S. Feather, and D.R. Harris. </author> <title> Representation and presentation of requirements knowledge. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 18(10) </volume> <pages> 853-869, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: For example, the attributes of an Ada procedure body may be derived from attributes of the corresponding procedure specification or from the package specification containing it. This capability is similar to the relation derivation mechanisms incorporated in the ARIES system <ref> [7] </ref>, although somewhat limited in that no provision exists as of yet for editing derived attributes. 5.2 Presentation mechanisms Presentations are generated by scripts written in the Perl language [16].
Reference: [8] <author> A. Lakhotia. </author> <title> Understanding someone else's code: Analysis of experiences. </title> <journal> Journal of Systems Software, </journal> <volume> 2 </volume> <pages> 93-100, </pages> <year> 1993. </year>
Reference-contexts: Such manuals attempt to anticipate the tasks that users might need to perform, and provide information to help achieve them. Although advocates of minimal manuals claim that novice users are in particular need of task-oriented documentation, it is reasonable to hypothesize that software professionals would benefit as well. Lakhotia <ref> [8] </ref>, for example, quotes a software developer who says that what he would like in the way of a software understanding tool is "something that helps me get the job done, fast." Unfortunately, the tasks of software professionals in general are not precisely defined.
Reference: [9] <author> A.W. Lazonder and J. van der Meij. </author> <title> The minimal manual: is less really more? Int. </title> <journal> J Man-Machine Studies, </journal> <volume> 39 </volume> <pages> 729-752, </pages> <year> 1993. </year>
Reference-contexts: Third, they should take into account the goals of the questioner. The content of the answer can depend upon what the user is trying to do with the information. Principles similar to these are already the basis for the design of certain types of user manuals, namely minimal manuals <ref> [9] </ref>. Such manuals attempt to anticipate the tasks that users might need to perform, and provide information to help achieve them. Although advocates of minimal manuals claim that novice users are in particular need of task-oriented documentation, it is reasonable to hypothesize that software professionals would benefit as well.
Reference: [10] <author> D. </author> <title> Mayhew. Principles & Guidelines in Software User Interface Design. </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: For example, a person from Germany asked how to display umlauts in entry widgets and not surprisingly the answer also came from Germany. Accumulating user discoveries in a repository will provide learning and discovery sharing capabilities. 2.5 Implications for I-Doc Some of the properties of good documentation <ref> [10] </ref> and this study's implications on them are as follows: * Organize around users tasks and goals, hide unnecessary complexity: We will tailor the documentation depending on user's task, expertise and individual characteristics and present the answer in a brief, understandable form.
Reference: [11] <author> J.D. Moore. </author> <title> Participating in Explanatory Dialogues. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1995. </year>
Reference-contexts: Such a tool should be able to respond directly to the user's inquiry with information that helps provide an answer. Research in automating consultative dialogs has identified a number of important requirements for explanation systems <ref> [11] </ref>. First, they must of course have the necessary knowledge to provide the desired answers. Second, they must provide answers in a form that the questioner can understand, and avoid concepts that the questioner is unfamiliar with. Third, they should take into account the goals of the questioner.
Reference: [12] <author> V. Rajlich, J. Doran, and R.T.S. Gudla. </author> <title> Layered explanation of software: A methodology for program comprehension. </title> <booktitle> In Proceedings of the Workshop on Program Comprehension, </booktitle> <year> 1994. </year>
Reference-contexts: Soloway uses this technique to document delocalized plans, linking the various elements of the plan together. The other method is to layer documentation, so that different types of information reside in different layers. For example, Rajlich <ref> [12] </ref> organizes information into a problem domain layer, an algorithm layer, and a representation layer. Understanders can then limit their reading and searching to particular layers.
Reference: [13] <author> P.L. Hunsaker R.E. Coffey, C.W. Cook. </author> <title> Management and Organizational Behavior. </title> <publisher> Austen Press, </publisher> <year> 1994. </year>
Reference-contexts: Research in behavioral theory supports this observation. It is known that when faced with a problem some people use just enough information to arrive at a feasible solution (satisficers) whereas some others gather as much information as they can (maximizers) <ref> [13] </ref>. Individual differences has to be taken into consideration in answering users' questions. 2.4.3 To what extent is the information available from conventional documentation sources? Half of the questions could have been answered by consulting the documentation or source code.
Reference: [14] <author> P.S. Selfridge. </author> <title> Integrating code knowledge with a software information system. </title> <booktitle> In Proceedings of the 5th Annual Knowledge-Based Software Assistant Conference, </booktitle> <pages> pages 183-195, </pages> <address> Syracuse, NY, </address> <year> 1990. </year>
Reference-contexts: Because of the important roles that conjecture and search play in the process, Selfridge has described software understanding as a discovery process <ref> [14] </ref>. Search in software understanding is very error-prone; people do not always know where to look for information to support their conjectures. In Soloway's studies the most successful subjects systematically scanned code and documentation from beginning to end, to make sure they found the information they required.
Reference: [15] <author> E. Soloway, J. Pinto, S.I. Letovsky, D. Littman, and R. Lampert. </author> <title> Designing documentation to compensate for delocalized plans. </title> <journal> Communications of the ACM, </journal> <volume> 31(11), </volume> <month> November </month> <year> 1988. </year>
Reference-contexts: 1 Introduction and Motivation Software engineers, and software maintainers in particular, spend significant amounts of time attempting to understand software artifacts [2]. These software understanding activities have been characterized by Brooks and Soloway <ref> [1, 15] </ref> as being composed of inquiry episodes. According to Soloway et al., inquiry episodes involve the following steps: read some code, ask a question about the code, conjecture an answer, and search the documentation and code for confirmation of the conjecture. <p> What does really happen in 'open' ? Is there any way out of this? Soloway et al. found that users employed two macro strategies for finding the answer to their questions, systematic and as-needed <ref> [15] </ref>. Systematic strategy users read all the documentation whereas as-needed strategy users sought information only when necessary. Research in behavioral theory supports this observation. <p> The documentation, which was structured similarly, was maintainable, but didn't make finding the answer to the second question easier. Documentation that supported delocalized plans could have shortened the time to find the answer <ref> [15] </ref>. However, the information that needs to be delocalized depends on the task and separate documentation is required for different tasks, e.g. programmer's manual, maintenance manual etc. It is easier to maintain a question answering system's repository than task dependent manuals.
Reference: [16] <author> L. Wall and R.L. Schwartz. </author> <title> Programming perl. </title> <publisher> O'Reilly & Associates, </publisher> <address> Sebastopol, CA, </address> <year> 1991. </year>
Reference-contexts: This capability is similar to the relation derivation mechanisms incorporated in the ARIES system [7], although somewhat limited in that no provision exists as of yet for editing derived attributes. 5.2 Presentation mechanisms Presentations are generated by scripts written in the Perl language <ref> [16] </ref>. Perl was chosen because it is a high-level language somewhat comparable to Lisp, has strong string manipulation facilities, but does not produce large binary files. The scripts can executed on demand by the HTTPD server, without delays for system initialization as in Lisp.
Reference: [17] <author> P. Wright. </author> <title> Issues of content and presentation in document design. </title> <editor> In M. Helander, editor, </editor> <title> Handbook of Human-Computer Interaction, </title> <booktitle> chapter 28, </booktitle> <pages> pages 629-652. </pages> <publisher> Elsevier Science Publishers B.V. (North Holland), </publisher> <year> 1988. </year>
Reference-contexts: An example was What is an option menu?. Explanatory: These questions requested explanations about how the system worked. An example was How does auto path variable work?. Wright claimed that users' questions are either task oriented or symptom oriented <ref> [17] </ref>. This is the same as our goal oriented and problem oriented classification. System oriented questions are less frequently asked than others, but they are important for some users. Motivational and conceptual questions are important for novices and explanatory questions are frequently asked by experts.
References-found: 17

