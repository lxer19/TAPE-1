URL: ftp://ftp.cs.rpi.edu/pub/goldberg/monitoring.ps.gz
Refering-URL: http://www.cs.rpi.edu/~goldberg/papers/
Root-URL: http://www.cs.rpi.edu
Title: Monitoring an Algorithm's Execution  
Author: DAVID A. BERQUE MARK K. GOLDBERG 
Abstract: Many software systems for Discrete Mathematics incorporate routines that compute NP-hard functions. In spite of their worst-case exponential running time, there are often a wide range of inputs for which these routines run in interactive time. It is generally difficult for a user to distinguish, a priori, the "easy" inputs from those that are "hard". A percent-done progress indicator is a software tool that allows a user to monitor the percentage of a computation that has been completed. Such indicators have been implemented for linear algorithms (e.g., file transfer programs). This paper introduces a paradigm which we call dynamic bound evaluation for monitoring the progress of a wide class of recursive algorithms that need not be linear. Further, empirical results are presented that illustrate the effectiveness of the technique as it has been implemented in the SetPlayer system for symbolic set manipulation. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Alfred V. Aho, John E. Hopcroft, and Jeffrey D. Ullman, </author> <title> Data Structures and Algorithms. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, Mas-sachusetts, </address> <year> 1982. </year>
Reference: 2. <author> David Berque, </author> <title> Implicit Set Manipulation: Theory and Practice. </title> <type> PhD thesis, </type> <institution> Rensselaer Polytechnic Institute, </institution> <address> 1991. </address> <publisher> UMI Dissertation Service Publishers, </publisher> <address> Ann Arbor, Michigan. </address> <month> 10 </month>
Reference-contexts: The derivations of these functions are based on modeling the best and worst-case behavior of the algorithm with recurrence relations, and then finding closed-form solutions to these relations. The interested reader is referred to <ref> [2] </ref> for a complete description of SetPlayer's algorithm for computing Trs, as well as a discussion of the recurrence relations that model the algorithms and the solutions to these recurrences.
Reference: 3. <author> David Berque, Ron Cecchini, Mark Goldberg, and Reid Rivenburg, </author> <title> The SetPlayer System for Symbolic Computation on Power Sets. </title> <journal> J. of Symbolic Computation, </journal> <volume> 14, </volume> <year> (1992), </year> <title> pp.645 - 662. 4. , The SetPlayer System: An Overview and a User Manual. </title> <type> Technical Report 91-17, </type> <institution> Rensselaer Polytechnic Institute, Department of Computer Science, </institution> <year> 1991. </year>
Reference-contexts: The details of the algorithm that SetPlayer uses to compute Trs are beyond the scope of this paper (the interested reader is referred to <ref> [3] </ref>). However, it is useful to point out that the algorithm follows a basic strategy that is employed by many recursive algorithms. First, a simplification stage checks to see if the problem instance can be replaced by a simpler instance or can be solved directly.
Reference: 5. <editor> B. F. Caviness and A. Boyle (editors), </editor> <title> Future Directions for Research in Symbolic Computation. Report of a Workshop on Symbolic and Algebraic Computation, </title> <journal> Society of Industrial and Applied Mathematics, </journal> <month> August </month> <year> 1989. </year>
Reference-contexts: This need has been recognized by Caviness and Boyle in the report entitled Future Directions for Research in Symbolic Computation where they write that "Carefully designed monitoring aids for software and hardware would be useful in measuring space, time, and progress toward a solution" <ref> [5] </ref>. The need for a technique that monitors the progress that a software system has made toward responding to a user's command is especially strong in many software systems that deal with Discrete Mathematics.
Reference: 6. <author> Bruce W. Char, </author> <title> First Leaves: A Tutorial Introduction to Maple. </title> <publisher> WATCOM Publications, </publisher> <address> Waterloo, Ontario, </address> <year> 1988. </year>
Reference-contexts: Of course, many algorithms do not fall into the "linear pass over data" paradigm. For example, many of the increasingly popular symbolic computation packages (e.g., Maple, Mathematica) rely heavily on non-linear algorithms <ref> [6, 12] </ref>. Software systems driven by non-linear algorithms are likely to exhibit a greater variation in running time on different inputs than those driven by linear algorithms.
Reference: 7. <author> M. R. Garey, and D. S. Johnson, </author> <title> Computers and Intractability: A Guide to the Theory of NP-completeness, W.M. </title> <publisher> Freeman and Co, </publisher> <year> 1979. </year>
Reference-contexts: Note also that if G = (V; E) is a graph then computing Trs:k (V; E) is identical to computing the number of vertex covers of size k in G, which is a well-known #P-complete problem <ref> [7] </ref>. The details of the algorithm that SetPlayer uses to compute Trs are beyond the scope of this paper (the interested reader is referred to [3]). However, it is useful to point out that the algorithm follows a basic strategy that is employed by many recursive algorithms.
Reference: 8. <author> Donald E. Knuth, </author> <title> Estimating the Efficiency of Backtrack Programs. </title> <journal> Mathematics of Computation, </journal> <volume> 29(129) </volume> <pages> 121-136, </pages> <month> January </month> <year> 1975. </year>
Reference-contexts: Knuth illustrates the problems which can arise from these characteristics when he writes that he "...once waited all night for the output ... only to discover that the answers would not be forthcoming for about 10 6 centuries" <ref> [8] </ref>. The authors' own motivation for developing a technique for monitoring the progress of an algorithm arises from our experiences in designing and implementing the SetPlayer system. <p> The user could then decide to continue the computation interactively, to finish the computation as a batch job, or to abort the computation entirely. 2. Dynamic bound evaluation 2.1. Background. In <ref> [8] </ref> Knuth discusses a Monte-Carlo technique for estimating he run-time of backtrack programs. The approach requires carrying out a separate estimation procedure before starting the primary computation. The estimation procedure provides a static pre-estimate on the required computation time.
Reference: 9. <author> Brad A. Myers, </author> <title> The Importance of Percent-done Progress Indicators for Computer-human Interfaces. </title> <booktitle> In CHI '85 Proceedings, </booktitle> <pages> pages 11-17, </pages> <month> April </month> <year> 1985. </year> <title> 10. , Using Percent-done Indicators to Enhance User Interfaces. </title> <booktitle> In Graphics Interface '85, </booktitle> <pages> pages 167-170, </pages> <month> May </month> <year> 1985. </year>
Reference-contexts: This can be unsettling for users, particularly if a good estimate of the total computation time for a particular input is not available. In <ref> [9] </ref> Myers describes a percent-done progress indicator as a software tool that allows a user to monitor the percentage of a computation that has been completed. He notes, however, that relatively few software systems support these indicators. <p> For this reason most percent-done progress indicators have been found in systems that are driven primarily by linear algorithms (for example the Macterminal program that runs on Macintosh computers) <ref> [9] </ref>. Of course, many algorithms do not fall into the "linear pass over data" paradigm. For example, many of the increasingly popular symbolic computation packages (e.g., Maple, Mathematica) rely heavily on non-linear algorithms [6, 12].
Reference: 11. <author> Leslie G. Valiant, </author> <title> The Complexity of Enumeration and Reliability Problems. </title> <journal> SIAM Journal of Computing, </journal> <volume> 8(3) </volume> <pages> 410-421, </pages> <year> 1979. </year>
Reference-contexts: : ; A m g; then Card (A) = 2 jUj Trs (U; A); Card :k (A) = k Trs:k (U; A): Obviously, the special case of Trs that occurs when all the input sets have cardinality 2 is the Monotone 2-SAT Problem, which is proved to be #P-complete in <ref> [11] </ref>. Note also that if G = (V; E) is a graph then computing Trs:k (V; E) is identical to computing the number of vertex covers of size k in G, which is a well-known #P-complete problem [7].
Reference: 12. <author> Stephen Wolfram, </author> <title> Mathematica: A System for Doing Mathematics by Computer. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Redwood City, California, </address> <year> 1988. </year> <institution> David A. Berque Department of Mathematics and Computer Science, DePauw University, Greencastle, Indiana 46135 E-mail address: dberque@depauw.bitnet Mark K. Goldberg Department of Computer Science, Rensselaer Polytechnic Institute, </institution> <address> Troy, New York 12180 E-mail address: goldberg@cs.rpi.edu 11 </address>
Reference-contexts: Of course, many algorithms do not fall into the "linear pass over data" paradigm. For example, many of the increasingly popular symbolic computation packages (e.g., Maple, Mathematica) rely heavily on non-linear algorithms <ref> [6, 12] </ref>. Software systems driven by non-linear algorithms are likely to exhibit a greater variation in running time on different inputs than those driven by linear algorithms.
References-found: 10

