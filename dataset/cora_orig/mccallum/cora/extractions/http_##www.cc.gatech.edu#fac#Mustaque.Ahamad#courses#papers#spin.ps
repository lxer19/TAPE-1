URL: http://www.cc.gatech.edu/fac/Mustaque.Ahamad/courses/papers/spin.ps
Refering-URL: http://www.cs.gatech.edu/computing/classes/cs6420_97_fall/reading.html
Root-URL: 
Title: Extensibility, Safety and Performance in the SPIN Operating System  
Author: Brian N. Bershad Stefan Savage Przemys law Pardyak Emin Gun Sirer Marc Fiuczynski David Becker Susan Eggers Craig Chambers 
Date: March 30, 1995  
Note: DRAFT of  
Address: Seattle, WA 98195  
Affiliation: Department of Computer Science and Engineering University of Washington  
Abstract: This paper describes the motivation, architecture and performance of SPIN, an extensible operating system. SPIN provides an extension infrastructure together with a core set of extensible services that allow applications to safely change the operating system's interface and implementation. These changes can be specified with fine-granularity, allowing applications to achieve a desired level of performance and functionality from the system. Extensions are dynamically linked into the operating system kernel at application runtime, enabling them to access system services with low overhead. A capability-based protection model that relies on language and link-time mechanisms enables the system to inexpensively export fine-grained interfaces to system services. SPIN and its extensions are written in Modula-3 and run on DEC Alpha workstations. 
Abstract-found: 1
Intro-found: 1
Reference: [ABLL92] <author> Thomas E. Anderson, Brian N. Bershad, Edward D. Lazowska, and Henry M. Levy. </author> <title> Scheduler Activations: Effective Kernel Support for the User-Level Management of Parallelism. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 10(1) </volume> <pages> 53-79, </pages> <month> February </month> <year> 1992. </year>
Reference-contexts: The implementation of the model determines its performance and functionality. Application requirements are often mismatched (in terms of performance or semantics) by the processor management interface exported by operating systems. User-level thread management systems have addressed this mismatch <ref> [WLH81, CD88, MSLM91, ABLL92] </ref>, but only partially. For example, Mach's user-level C-Threads implementation [CD88], although flexible, is poorly integrated with kernel services [ABLL92]. In contrast, scheduler activations, which were well-integrated with the kernel, had excessively high overhead [DMVL93]. <p> User-level thread management systems have addressed this mismatch [WLH81, CD88, MSLM91, ABLL92], but only partially. For example, Mach's user-level C-Threads implementation [CD88], although flexible, is poorly integrated with kernel services <ref> [ABLL92] </ref>. In contrast, scheduler activations, which were well-integrated with the kernel, had excessively high overhead [DMVL93]. SPIN avoids the problem of defining the wrong execution model for applications by not defining one at all. Instead, SPIN defines set of events that coordinate processor allocation between schedulers and thread packages.
Reference: [AL91] <author> W. Appel and K. Li. </author> <title> Virtual Memory Primitives for User Programs. </title> <booktitle> In Proceedings of the Fourth Symposium on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 96-107, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: If instead, it accesses an allocated, but unmapped virtual page, then the Translation.PageNotPresent event is raised. Implementors of higher level memory management abstractions use these events to implement services such as demand paging, copy-on-write [RTY + 87], distributed shared memory [CBZ91], or concurrent garbage collection <ref> [AL91] </ref>. Resource reclamation The physical page service may at any time reclaim memory. A page is recalled by raising the Physical-Page.Recall event with the specific physical page specified as an argument. <p> They define the bounds of system performance and provide a framework for understanding larger operations. Page faults Applications frequently exploit the virtual memory fault path as the basis for extending system services <ref> [AL91] </ref>. For example, concurrent and generational garbage collectors rely on write faults to maintain invariants or collect reference information. In the most common use of this strategy, application code updates a data structure when the fault occurs, promotes the page to allow read-write access, and resumes the faulting thread.
Reference: [ALBL91] <author> Thomas E. Anderson, Henry M. Levy, Brian N. Ber-shad, and Edward D. Lazowska. </author> <title> The Interaction of Architecture and Operating System Design. </title> <booktitle> In Proceedings of the Fourth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-IV), </booktitle> <pages> pages 108-120, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: A longstanding problem with fault-based strategies has been the overhead of safely reflecting the page fault to application-code, so that it can be recovered from <ref> [TL94, ALBL91] </ref>. Overheads are high because each fault requires five crossings of the user/kernel boundary (fault, notify, request-page-unprotect, reply-page-protect, restart-faulting-thread), with each saving and restoring processor state.
Reference: [B + 92] <editor> D. L. Black et al. </editor> <booktitle> Microkernel Operating System Architecture and Mach. In Proceedings of the Workshop on Micro-kernels and Other Kernel Architectures, </booktitle> <pages> pages 11-30, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: Lastly, the system was designed with the notion of "large objects" as the basic building blocks, requiring a large programming effort to affect even a small extension. Recently, researchers have investigated the use of microkernels as a vehicle for building extensible systems <ref> [B + 92, MRT + 90, CZ83, CD94, TSS88] </ref>. In a microkernel-based system, operating system services are implemented as user-level programs and accessed through an interprocess communication service provided by the kernel. <p> Interfaces and collections of interfaces can be protected to allow different extensions to have different views on the set of available services. Unlike other capability-based operating systems, which implement capabilities using special-purpose hardware [CKD94], virtual memory mechanisms [WLH81], probabilistic protection [EKO94], or protected message channels <ref> [B + 92] </ref>, SPIN's capabilities are implemented in terms of opaque references. An opaque reference is simply a type safe pointer to an abstract data type. The type system statically ensures that only modules in which the reference can be revealed have access to the underlying data structure.
Reference: [BALL90] <author> Brian N. Bershad, Thomas E. Anderson, Edward D. Lazowska, and Henry M. Levy. </author> <title> Lightweight Remote Procedure Call. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 14 8(1) </volume> <pages> 37-55, </pages> <month> February </month> <year> 1990. </year> <booktitle> Also appeared in Proceedings of the 12th ACM Symposium on Operating Systems Principles, </booktitle> <month> December </month> <year> 1989. </year>
Reference-contexts: Unlike a thread though, a strand has no minimal or requisite kernel state other than a name. The application-specific thread package that implements the strands interface defines a strand's state. For example, a strand may be associated with a single address spaces, or multiple <ref> [BALL90] </ref>, have thread-private data, or even a different set of virtual memory mappings than other strands in the same address space.
Reference: [BB93] <author> Jose C. Brustoloni and Brian N. Bershad. </author> <title> Simple Protocol Processing for High-Bandwidth Low-Latency Networking. </title> <type> Technical Report CMU-CS-93-132, </type> <institution> Carnegie Mellon University, </institution> <month> March </month> <year> 1993. </year>
Reference-contexts: For our networking experiments, we use 10Mb/sec Ethernet and ATM. Our ATM network consists of FORE TCA-100 155Mb/sec adapter cards. The FORE cards use programmed I/O and deliver substantially less bandwidth than 155 Mb/sec <ref> [BB93] </ref>. We use the DEC SRC Modula-3 compiler, release 3.3, to compile the SPIN kernel and extensions. We compare the performance of operations on three operating systems running on our hardware: SPIN, DEC OSF/1 V2.1, and Mach 3.0+DEC OSF/1 server.
Reference: [Ber93] <author> Brian N. Bershad. </author> <title> Practical Considerations for Non-Blocking Concurrent Objects. </title> <booktitle> In Proceedings of the 13th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 264-274, </pages> <month> May </month> <year> 1993. </year>
Reference: [BKW94] <author> Kavita Bala, M. Frans Kaashoek, and William E. Weihl. </author> <title> Software prefetching and caching for translation lookaside buffers. </title> <booktitle> In Proc. of the First Symposium on Operating Systems Design and Implementation, </booktitle> <pages> pages 243-253, </pages> <address> Monterey, CA, </address> <month> November </month> <year> 1994. </year> <note> USENIX Assoc. </note>
Reference-contexts: Others have enabled control over relatively small objects, for example cache pages [RLB94] or TLB entries <ref> [BKW94] </ref>, entirely from the kernel. None have allowed for fast, fine-grained control over the physical and virtual memory resources required by applications. The SPIN core virtual memory management system decomposes memory services into three basic components: physical storage, naming, and protection.
Reference: [BRE92] <author> Brian N. Bershad, David D. Redell, and John R. Ellis. </author> <title> Fast Mutual Exclusion for Uniprocessors. </title> <booktitle> In Proceedings of the Fifth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-V), </booktitle> <pages> pages 223-233, </pages> <month> October </month> <year> 1992. </year>
Reference: [CBZ91] <author> John B. Carter, John K. Bennett, and Willy Zwaenepoel. </author> <title> Implementation and performance of Munin. </title> <booktitle> In Proceedings of 13th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 152-64. </pages> <institution> Association for Computing Machinery SIGOPS, </institution> <month> October </month> <year> 1991. </year>
Reference-contexts: If instead, it accesses an allocated, but unmapped virtual page, then the Translation.PageNotPresent event is raised. Implementors of higher level memory management abstractions use these events to implement services such as demand paging, copy-on-write [RTY + 87], distributed shared memory <ref> [CBZ91] </ref>, or concurrent garbage collection [AL91]. Resource reclamation The physical page service may at any time reclaim memory. A page is recalled by raising the Physical-Page.Recall event with the specific physical page specified as an argument.
Reference: [CD88] <author> Eric C. Cooper and Richard P. Draves. </author> <title> C threads. </title> <type> Technical Report CMU-CS-88-54, </type> <institution> Carnegie Mellon University, </institution> <month> February </month> <year> 1988. </year>
Reference-contexts: The implementation of the model determines its performance and functionality. Application requirements are often mismatched (in terms of performance or semantics) by the processor management interface exported by operating systems. User-level thread management systems have addressed this mismatch <ref> [WLH81, CD88, MSLM91, ABLL92] </ref>, but only partially. For example, Mach's user-level C-Threads implementation [CD88], although flexible, is poorly integrated with kernel services [ABLL92]. In contrast, scheduler activations, which were well-integrated with the kernel, had excessively high overhead [DMVL93]. <p> Application requirements are often mismatched (in terms of performance or semantics) by the processor management interface exported by operating systems. User-level thread management systems have addressed this mismatch [WLH81, CD88, MSLM91, ABLL92], but only partially. For example, Mach's user-level C-Threads implementation <ref> [CD88] </ref>, although flexible, is poorly integrated with kernel services [ABLL92]. In contrast, scheduler activations, which were well-integrated with the kernel, had excessively high overhead [DMVL93]. SPIN avoids the problem of defining the wrong execution model for applications by not defining one at all.
Reference: [CD94] <author> David R. Cheriton and Kenneth J. Duda. </author> <title> A Caching Model of Operating System Kernel Functionality. </title> <booktitle> In Proceedings of the First USENIX Symposium on Operting Systems Design and Implementation (OSDI), </booktitle> <pages> pages 179-194, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: Lastly, the system was designed with the notion of "large objects" as the basic building blocks, requiring a large programming effort to affect even a small extension. Recently, researchers have investigated the use of microkernels as a vehicle for building extensible systems <ref> [B + 92, MRT + 90, CZ83, CD94, TSS88] </ref>. In a microkernel-based system, operating system services are implemented as user-level programs and accessed through an interprocess communication service provided by the kernel.
Reference: [CFL94] <author> Pei Cao, Edward W. Felten, and Kai Li. </author> <title> Implementation and performance of application-controlled file caching. </title> <booktitle> In Proc. of the First Symposium on Operating Systems Design and Implementation, </booktitle> <pages> pages 165-177, </pages> <address> Monterey, CA, </address> <month> November </month> <year> 1994. </year> <note> USENIX Assoc. </note>
Reference-contexts: Some of these interfaces have made it possible to manipulate large objects, for example entire address spaces [YTR + 87, KN93], or to direct expensive operations, for example page 7 out <ref> [HC91, MA90, CFL94] </ref>, entirely from user level. Others have enabled control over relatively small objects, for example cache pages [RLB94] or TLB entries [BKW94], entirely from the kernel. None have allowed for fast, fine-grained control over the physical and virtual memory resources required by applications.
Reference: [CHL91] <author> Eric Cooper, Robert Harper, and Peter Lee. </author> <title> The Fox Project: Advanced Developement of Systems Software. </title> <type> Technical Report CMU-CS-91-187, </type> <institution> Carnegie Mellon University, </institution> <year> 1991. </year>
Reference-contexts: Unlike the SPIN kernel, which provides extension-oriented facilities for logical protection domains and event binding, their system provides no abstractions beyond those minimally provided by the hardware [EK95]. Several systems <ref> [CHL91, RDH + 80, Mos94, SS94] </ref>, like SPIN, have leveraged type safety to build an extensible system. Pilot, for example, was a single-address space system which ran programs written in Mesa [GMS77], a high-level systems programming language which is an ancestor of Modula-3 [Nel91].
Reference: [CKD94] <author> Nicholas P. Carter, Stephen W. Keckler, and William J. Dally. </author> <title> Hardware Support for Fast Capability-Based Addressing. </title> <booktitle> In Proceedings of the Fifth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-VI), </booktitle> <pages> pages 319-327, </pages> <month> Oc-tober </month> <year> 1994. </year>
Reference-contexts: Interfaces and collections of interfaces can be protected to allow different extensions to have different views on the set of available services. Unlike other capability-based operating systems, which implement capabilities using special-purpose hardware <ref> [CKD94] </ref>, virtual memory mechanisms [WLH81], probabilistic protection [EKO94], or protected message channels [B + 92], SPIN's capabilities are implemented in terms of opaque references. An opaque reference is simply a type safe pointer to an abstract data type.
Reference: [CZ83] <author> David R. Cheriton and Willy Zwaenepoel. </author> <title> The Distributed V Kernel and its Performance for Diskless Workstations. </title> <booktitle> In Proceedings of the Eighth Symposium on Operating Systems Principles, </booktitle> <pages> pages 129-140, </pages> <month> October </month> <year> 1983. </year>
Reference-contexts: Lastly, the system was designed with the notion of "large objects" as the basic building blocks, requiring a large programming effort to affect even a small extension. Recently, researchers have investigated the use of microkernels as a vehicle for building extensible systems <ref> [B + 92, MRT + 90, CZ83, CD94, TSS88] </ref>. In a microkernel-based system, operating system services are implemented as user-level programs and accessed through an interprocess communication service provided by the kernel.
Reference: [DBRD91] <author> Richard P. Draves, Brian N. Bershad, Richard F. Rashid, and Randall W. Dean. </author> <title> Using Continuations to Implement Thread Management and Communication in Operating Systems. </title> <booktitle> In Proceedings of the 13th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 122-136, </pages> <month> October </month> <year> 1991. </year>
Reference: [DEFS88] <author> C. Anthony DellaFera, Mark W. Eichin, Robert S. French, and William E. Summersfeld. </author> <title> The Zephyr Notification Service. </title> <booktitle> In Proceedings of the 1988 USENIX Conference, </booktitle> <month> February </month> <year> 1988. </year>
Reference-contexts: In SPIN, the reference is a domain capability against which extensions resolve. Rather than providing a nameserver, SPIN provides only a nameserver interface that describes a publish and subscribe interface <ref> [DEFS88, OPS + 93] </ref>. Potential users of a domain can raise a Subscribe event, specifying as an argument to the event the textual name of the requested interface. An interface implementation registers a handler, which acts as a publisher, for the interface.
Reference: [DMVL93] <author> Paul-Barton Davis, Dylan McNamee, Raj Vaswani, and Ed Lazowska. </author> <title> Adding Scheduler Activations to Mach 3.0. </title> <booktitle> In Proceedings of the USENIX Mach III Symposium, </booktitle> <pages> pages 119-136, </pages> <year> 1993. </year>
Reference-contexts: User-level thread management systems have addressed this mismatch [WLH81, CD88, MSLM91, ABLL92], but only partially. For example, Mach's user-level C-Threads implementation [CD88], although flexible, is poorly integrated with kernel services [ABLL92]. In contrast, scheduler activations, which were well-integrated with the kernel, had excessively high overhead <ref> [DMVL93] </ref>. SPIN avoids the problem of defining the wrong execution model for applications by not defining one at all. Instead, SPIN defines set of events that coordinate processor allocation between schedulers and thread packages.
Reference: [Dra93] <author> Richard Draves. </author> <title> The Case for Tun-Time Replaceable Kernel Modules. </title> <booktitle> In Proceedings of the Fourth Workshop on Workstation Operating Systems, </booktitle> <month> October </month> <year> 1993. </year>
Reference-contexts: While individual applications have benefited from this level of freedom, the lack of safe interfaces to either operating system services, or operating system extension services, has created system configuration "chaos <ref> [Dra93] </ref>." SPIN directly addresses this deficit. 2.1 Related work There have been several attempts to build extensible systems. For example, Hydra [WLH81] provided an infrastructure that allowed applications to manage resources through multi-level policies.
Reference: [EK95] <author> Dawson Engler and M. Frans Kaashoek. </author> <title> Exterminate All Operating System Abstractions. </title> <booktitle> In Proceedings of the Fifth Workshop on Hot Topics in Operating Systems, </booktitle> <month> May </month> <year> 1995. </year>
Reference-contexts: Unlike the SPIN kernel, which provides extension-oriented facilities for logical protection domains and event binding, their system provides no abstractions beyond those minimally provided by the hardware <ref> [EK95] </ref>. Several systems [CHL91, RDH + 80, Mos94, SS94], like SPIN, have leveraged type safety to build an extensible system. Pilot, for example, was a single-address space system which ran programs written in Mesa [GMS77], a high-level systems programming language which is an ancestor of Modula-3 [Nel91].
Reference: [EKO94] <author> Dawson Engler, M. Frans Kaashoek, and James O'Toole. </author> <title> The Operating System Kernel as a Secure Programmable Machine. </title> <booktitle> In Proceedings of the 1994 European SIGOPS Workshop, </booktitle> <month> September </month> <year> 1994. </year>
Reference-contexts: Second, the interface between the language's programming environment and the rest of the system is generally narrow, making system integration difficult. Finally, interpretation overhead may be a limiting factor to performance. Several projects <ref> [Luc94, EKO94, SS94] </ref> are exploring the use of software fault isolation [WLAG93] to allow application code, written in any language, to be linked into the kernel's virtual address space. Software fault isolation relies on a binary rewriting tool that inserts explicit checks on memory references and branch instructions. <p> Researchers at MIT are building a microkernel that exports fine-grained hardware services, such as TLB management, directly to applications <ref> [EKO94] </ref>. The system uses a combination of techniques, including software fault isolation, code inspection, type safety, and probabilistic capabilities, to provide low-latency access to hardware resources. <p> Interfaces and collections of interfaces can be protected to allow different extensions to have different views on the set of available services. Unlike other capability-based operating systems, which implement capabilities using special-purpose hardware [CKD94], virtual memory mechanisms [WLH81], probabilistic protection <ref> [EKO94] </ref>, or protected message channels [B + 92], SPIN's capabilities are implemented in terms of opaque references. An opaque reference is simply a type safe pointer to an abstract data type.
Reference: [Fel92] <author> Edward W. Felten. </author> <title> The case for application-specific communication protocols. </title> <booktitle> In Intel Supercomputer Systems Technology Focus Conference, </booktitle> <pages> pages 171-181, </pages> <month> April </month> <year> 1992. </year>
Reference: [FP93] <author> Kevin Fall and Joseph Pasquale. </author> <title> An Implementation of UNIX on an Object-Oriented Operating System. In Exploiting in-kernel data paths to improve I/O throughput and CPU availabilit, </title> <address> pages 327-333, </address> <month> January </month> <year> 1993. </year>
Reference: [GDFR90] <author> David Golub, Randall Dean, Alessandro Forin, and Richard Rashid. </author> <title> Unix as an Application Program. </title> <booktitle> In Proceedings of the 1990 Summer USENIX Conference, </booktitle> <pages> pages 87-95, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Systems implement this abstraction with different mechanisms and semantics according to the needs of their intended class of applications. For example, the lazy evaluation strategies 9 used in Mach's virtual memory system are intended to support UNIX applications <ref> [GDFR90] </ref>, but are inappropriate for real-time applications. The SPIN core services do not define an address space model directly, but may be used to implement a range of models using a variety of optimization techniques.
Reference: [GMS77] <author> C.M. Geschke, J.H. Morris, </author> <title> and E.H. Satterthwaite. Early Experiences with Mesa. </title> <journal> cacm, </journal> <volume> 20(8) </volume> <pages> 540-553, </pages> <month> August </month> <year> 1977. </year>
Reference-contexts: Several systems [CHL91, RDH + 80, Mos94, SS94], like SPIN, have leveraged type safety to build an extensible system. Pilot, for example, was a single-address space system which ran programs written in Mesa <ref> [GMS77] </ref>, a high-level systems programming language which is an ancestor of Modula-3 [Nel91]. In general, systems such as Pilot have depended on the language for all protection in the system, not just for the protection of operating system extensions.
Reference: [HC91] <author> Kieran Harty and David R. Cheriton. </author> <title> Application-Controlled Physical Memory using External Page-Cache Management. </title> <booktitle> In Proceedings of the Fourth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-IV), </booktitle> <pages> pages 187-197, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: Some of these interfaces have made it possible to manipulate large objects, for example entire address spaces [YTR + 87, KN93], or to direct expensive operations, for example page 7 out <ref> [HC91, MA90, CFL94] </ref>, entirely from user level. Others have enabled control over relatively small objects, for example cache pages [RLB94] or TLB entries [BKW94], entirely from the kernel. None have allowed for fast, fine-grained control over the physical and virtual memory resources required by applications.
Reference: [HP94] <author> J.S. Heidemann and G.J. Popek. </author> <title> File-System Development with Stackable Layers. </title> <journal> cacm, </journal> <volume> 12(1) </volume> <pages> 58-89, </pages> <month> February </month> <year> 1994. </year>
Reference-contexts: Address spaces are used to otherwise isolate the operating system and programs from one another. Many systems provide interfaces that enable code to be installed into the kernel at runtime. Examples include dynamically linked device drivers, stackable layers <ref> [HP94] </ref>, or server-co-location [LHfL93, RAA + 88]. Reflective operating systems, such as Apertos [YTT89], provide arbitrary access to system internals. In all of these systems, the right to define extensions is restricted because any extension can bring down the entire system.
Reference: [HPAO89] <author> Norman C. Hutchinson, Larry Peterson, Mark B. Ab-bott, and Sean O'Malley. </author> <title> RPC in x-kernel: Evaluating New Design Techniques. </title> <booktitle> In Proceedings of the Thirteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 91-101, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: SPIN's protocol stacks have structure similar to the x-kernel's <ref> [HPAO89] </ref> except that SPIN permits user code to be placed within the stack. the kernel. Each guard is responsible for demultiplexing through one layer of the stack, and each handler is responsible for pushing the packet up to the next layer. "PA" indicates a PacketArrived event.
Reference: [Jon93] <author> Michael B. Jones. </author> <title> Interposition Agents: Transparently Interposing User Code at the System Call. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 80-93, </pages> <year> 1993. </year>
Reference-contexts: A few systems offer application-specific trap vectoring, whereby system call vector tables can be installed on a per application basis enabling system calls to be redirected out to user space. This mechanism serves as the foundation for building operating system emulation environments <ref> [Jon93] </ref>, and is often a critical factor in their performance [Pat93]. In SPIN, a system call is simply an event that takes place within the context of some strand, and is reflected by the SystemCall event, which is raised by the kernel when the system call occurs.
Reference: [KEH93] <author> D. Keppel, S.J. Eggers, and R.R. Henry. </author> <title> Evaluating Runtime-Compiled, Value-Specific Optimizations. </title> <type> Technical Report UW-CSE-93-11-02, </type> <institution> Department of Computer Science and Engineering, University of Washington, </institution> <month> November </month> <year> 1993. </year>
Reference-contexts: In practice, separating the "what" from the "when" simplifies the system because the predicate only needs to be specified once rather than every time the event is raised, and enables centralized optimization in the dispatcher, such as decision-tree pruning, executable data structures [MP89], and dynamic code generation <ref> [KEH93] </ref>. Event properties The dispatcher provides a central point of control through which a rich set of event handling semantics can be defined.
Reference: [KN93] <author> Yousef A. Khalidi and MichaelN. Nelson. </author> <title> An Implementation of UNIX on an Object-Oriented Operating System. </title> <booktitle> In Proceedings of the 1993 Winter USENIX Conference, </booktitle> <pages> pages 469-480, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Other systems have demonstrated significant performance improvements from specialized or "tuned" memory management policies that are accessible through interfaces exposed by the memory management system. Some of these interfaces have made it possible to manipulate large objects, for example entire address spaces <ref> [YTR + 87, KN93] </ref>, or to direct expensive operations, for example page 7 out [HC91, MA90, CFL94], entirely from user level. Others have enabled control over relatively small objects, for example cache pages [RLB94] or TLB entries [BKW94], entirely from the kernel.
Reference: [LCC94] <author> Chao Hsien Lee, Meng Chang Chen, and Ruei Chuan Chang. </author> <title> HiPEC: High performance external virtual memory caching. </title> <booktitle> In Proc. of the First Symposium on Operating Systems Design and Implementation, </booktitle> <pages> pages 153-164, </pages> <address> Mon-terey, CA, </address> <month> November </month> <year> 1994. </year> <note> USENIX Assoc. </note>
Reference-contexts: Moreover, the granularity with which exten sions can be specified in microkernel-based systems is quite large. Some systems rely on "little languages" to extend safely the system call interface through the use of interpreted code that runs in the kernel <ref> [LCC94, MRA87, YBMM94] </ref>. These systems suffer from two problems. First, the languages, being little, make cumbersome the expression of arbitrary control and data structures, therefore limiting the range of possible extensions.
Reference: [LHfL93] <author> Jay Lepreau, Mike Hibler, Bryan ford, and Jeffrey Law. </author> <title> In-Kernel Servers on Mach 3.0: Implementation and Performance. </title> <booktitle> In Proceedings of the Usenix Mach III Symposium, </booktitle> <pages> pages 39-56, </pages> <year> 1993. </year>
Reference-contexts: Address spaces are used to otherwise isolate the operating system and programs from one another. Many systems provide interfaces that enable code to be installed into the kernel at runtime. Examples include dynamically linked device drivers, stackable layers [HP94], or server-co-location <ref> [LHfL93, RAA + 88] </ref>. Reflective operating systems, such as Apertos [YTT89], provide arbitrary access to system internals. In all of these systems, the right to define extensions is restricted because any extension can bring down the entire system.
Reference: [Luc94] <author> Steven Lucco. </author> <title> High-Performance Microkernel Systems. </title> <booktitle> In Proceedings of the First USENIX Symposium on Op-erting Systems Design and Implementation (OSDI), </booktitle> <pages> page 199, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: Second, the interface between the language's programming environment and the rest of the system is generally narrow, making system integration difficult. Finally, interpretation overhead may be a limiting factor to performance. Several projects <ref> [Luc94, EKO94, SS94] </ref> are exploring the use of software fault isolation [WLAG93] to allow application code, written in any language, to be linked into the kernel's virtual address space. Software fault isolation relies on a binary rewriting tool that inserts explicit checks on memory references and branch instructions.
Reference: [MA90] <author> Dylan McNamee and Katherine Armstrong. </author> <title> Extending the Mach External Pager Interface to Accommodate User-Level Page Replacement Policies. </title> <booktitle> In Proceedings of the USENIX Association Mach Workshop, </booktitle> <pages> pages 17-29, </pages> <year> 1990. </year>
Reference-contexts: Some of these interfaces have made it possible to manipulate large objects, for example entire address spaces [YTR + 87, KN93], or to direct expensive operations, for example page 7 out <ref> [HC91, MA90, CFL94] </ref>, entirely from user level. Others have enabled control over relatively small objects, for example cache pages [RLB94] or TLB entries [BKW94], entirely from the kernel. None have allowed for fast, fine-grained control over the physical and virtual memory resources required by applications.
Reference: [MB93] <author> Chris Maeda and Brian N. Bershad. </author> <title> Protocol Service Decomposition for High-Performance Networking. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 244-255, </pages> <month> December </month> <year> 1993. </year> <month> 15 </month>
Reference-contexts: For SPIN, we use the space and thread operations described earlier. All times are in microseconds. Networking A common problem with networking protocols is that the operating system introduces too many layers between the application and the physical device <ref> [MB93] </ref>. This often results in networking performance that is substantially worse than the raw hardware is capable of delivering. SPIN allows code to execute close to the network interface, eliminating much of the overhead that occurs in traditional network architectures.
Reference: [Mos94] <author> H. Mossenbock. </author> <title> Extensibility in the Oberon System. </title> <journal> Nordic Journal of Computing, </journal> <volume> 1(1) </volume> <pages> 77-93, </pages> <month> February </month> <year> 1994. </year>
Reference-contexts: Unlike the SPIN kernel, which provides extension-oriented facilities for logical protection domains and event binding, their system provides no abstractions beyond those minimally provided by the hardware [EK95]. Several systems <ref> [CHL91, RDH + 80, Mos94, SS94] </ref>, like SPIN, have leveraged type safety to build an extensible system. Pilot, for example, was a single-address space system which ran programs written in Mesa [GMS77], a high-level systems programming language which is an ancestor of Modula-3 [Nel91].
Reference: [MP89] <author> Henry Massalin and Calton Pu. </author> <title> Threads and Input/Output in the Synthesis Kernel. </title> <booktitle> In Proceedings of the Thirteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 191-201, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: In practice, separating the "what" from the "when" simplifies the system because the predicate only needs to be specified once rather than every time the event is raised, and enables centralized optimization in the dispatcher, such as decision-tree pruning, executable data structures <ref> [MP89] </ref>, and dynamic code generation [KEH93]. Event properties The dispatcher provides a central point of control through which a rich set of event handling semantics can be defined.
Reference: [MRA87] <author> J. Mogul, R. Rashid, and M. Accetta. </author> <title> The Packet Filter: An Efficient Mechanism for User-level Network Code. </title> <booktitle> In Proceedings of the Eleventh ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 39-51, </pages> <year> 1987. </year>
Reference-contexts: Moreover, the granularity with which exten sions can be specified in microkernel-based systems is quite large. Some systems rely on "little languages" to extend safely the system call interface through the use of interpreted code that runs in the kernel <ref> [LCC94, MRA87, YBMM94] </ref>. These systems suffer from two problems. First, the languages, being little, make cumbersome the expression of arbitrary control and data structures, therefore limiting the range of possible extensions.
Reference: [MRT + 90] <author> Sape J. Mullender, G. Van Rossum, A. S. Tanenbaum, R. Van Renesse, and H. van Staveren. </author> <title> Amoeba A Distributed Operating System for the 1990's. </title> <journal> IEEE Computer Magazine, </journal> <month> May </month> <year> 1990. </year>
Reference-contexts: Lastly, the system was designed with the notion of "large objects" as the basic building blocks, requiring a large programming effort to affect even a small extension. Recently, researchers have investigated the use of microkernels as a vehicle for building extensible systems <ref> [B + 92, MRT + 90, CZ83, CD94, TSS88] </ref>. In a microkernel-based system, operating system services are implemented as user-level programs and accessed through an interprocess communication service provided by the kernel.
Reference: [MSLM91] <author> Brian Marsh, Michael Scott, Thomas LeBlanc, and Evangelos Markatos. </author> <title> First-Class User-Level Threads. </title> <booktitle> In Proceedings of the 13th ACM Symposium on Operating Systems Principles, </booktitle> <month> October </month> <year> 1991. </year>
Reference-contexts: The implementation of the model determines its performance and functionality. Application requirements are often mismatched (in terms of performance or semantics) by the processor management interface exported by operating systems. User-level thread management systems have addressed this mismatch <ref> [WLH81, CD88, MSLM91, ABLL92] </ref>, but only partially. For example, Mach's user-level C-Threads implementation [CD88], although flexible, is poorly integrated with kernel services [ABLL92]. In contrast, scheduler activations, which were well-integrated with the kernel, had excessively high overhead [DMVL93].
Reference: [Nel91] <author> Greg Nelson, </author> <title> editor. System Programming in Modula-3. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: Extensions execute in the kernel's address space where they are prevented from accessing memory or issuing privileged instructions that could violate the base integrity of the operating system. We rely on a type safe, modular programming language, Modula-3 <ref> [Nel91] </ref>, to ensure that extensions do not issue privileged instructions, or reference memory to which they have not been given 1 explicit access through an interface. A type safe language permits many memory references to be validated at compile-time rather than runtime using either hardware or software mechanisms. <p> Several systems [CHL91, RDH + 80, Mos94, SS94], like SPIN, have leveraged type safety to build an extensible system. Pilot, for example, was a single-address space system which ran programs written in Mesa [GMS77], a high-level systems programming language which is an ancestor of Modula-3 <ref> [Nel91] </ref>. In general, systems such as Pilot have depended on the language for all protection in the system, not just for the protection of operating system extensions. In contrast, SPIN's reliance on type safety applies only to extension code that runs in the kernel. <p> Currently, we generate safe object files using a Modula-3 compiler or a special program with which trusted users can vet code. 1 A Modula-3 program is "safe" if it is pointer safe, uses only the safe subset of Modula-3 operators, and imports only safe interfaces <ref> [Nel91] </ref>. The Resolve operation serves as the basis for dynamic linking. It takes two domains, the target and the source. Any unresolved symbols in the target domain are resolved by linking against symbols in the source. Cross-linking occurs through a pair of Resolve operations. <p> Application-specific strand packages, although executing in the kernel, only manipulate the flow of control for threads executing outside of the kernel, or application threads. Within the kernel, SPIN supplies a trusted strand package that implements the Modula-3 thread semantics <ref> [Nel91] </ref>. Applications can not change the implementation of this package. The rationale for this restriction is straightforward: the SPIN kernel runs code on behalf of applications, but it does not let applications control how the code will be run.
Reference: [OPS + 93] <author> Brian Oki, Manfred Pfleugl, Alex Siegel, , and Dale Skeen. </author> <title> The Information Bus an Architecture for Extensible Distributed Systems. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 58-68, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: In SPIN, the reference is a domain capability against which extensions resolve. Rather than providing a nameserver, SPIN provides only a nameserver interface that describes a publish and subscribe interface <ref> [DEFS88, OPS + 93] </ref>. Potential users of a domain can raise a Subscribe event, specifying as an argument to the event the textual name of the requested interface. An interface implementation registers a handler, which acts as a publisher, for the interface.
Reference: [Pat93] <author> Simon Patience. </author> <title> Redirecting Systems Calls in Mach 3.0, An Alternative to the Emulat or. </title> <booktitle> In Proceedings of 3rd USENIX Mach Symposium, </booktitle> <month> April </month> <year> 1993. </year>
Reference-contexts: This mechanism serves as the foundation for building operating system emulation environments [Jon93], and is often a critical factor in their performance <ref> [Pat93] </ref>. In SPIN, a system call is simply an event that takes place within the context of some strand, and is reflected by the SystemCall event, which is raised by the kernel when the system call occurs. <p> This implementation does not signal using the Mach kernel's IPC facilities, and as such has slightly lower overhead than the standard Mach kernel <ref> [Pat93] </ref>. Table 4 shows the system call overhead using the different operating systems. The table shows that SPIN is slightly slower at handling system calls than either Mach or the DEC OSF/1 kernel.
Reference: [PB94] <author> Przemyslaw Pardyak and Brian Bershad. </author> <title> A Group Structuring Mechanism for a Distributed Object Oriented Language Objects. </title> <booktitle> In Proceedings of the 14th International Conference on Distributed Computing Systems, </booktitle> <year> 1994. </year>
Reference-contexts: Finally, while multiple handlers may execute in response to an event, a single result must be communicated back to the raiser by associating with each event a procedure which ultimately determines the final result <ref> [PB94] </ref>. Locating an interface SPIN's nameservice facilities demonstrate the use of the event machinery. Typically, systems provide some type of a nameserver that allows programs to map from some symbolic name, such as "SFS," to a system-dependent reference, such as a port.
Reference: [RAA + 88] <author> M. Rozier, V. Abrossimov, F. Armand, I. Boule, M. Giend, M. Guillemont, F. Herrmann, P. Leonard, S. Langlois, and W. Neuhauser. </author> <title> The Chorus Distributed Operating System. </title> <journal> Computing Systems, </journal> <volume> 1(4), </volume> <year> 1988. </year>
Reference-contexts: Address spaces are used to otherwise isolate the operating system and programs from one another. Many systems provide interfaces that enable code to be installed into the kernel at runtime. Examples include dynamically linked device drivers, stackable layers [HP94], or server-co-location <ref> [LHfL93, RAA + 88] </ref>. Reflective operating systems, such as Apertos [YTT89], provide arbitrary access to system internals. In all of these systems, the right to define extensions is restricted because any extension can bring down the entire system.
Reference: [RDH + 80] <author> David D. Redell, Yogen K. Dalal, Thomas R. Hors-ley, Hugh C. Lauer, William C. Lynch, Paul R. McJones, Hal G. Murray, and Stephen C. Purcell. </author> <title> Pilot: An Operating System for a Personal Computer. </title> <journal> Communications of the ACM, </journal> <volume> 23(2) </volume> <pages> 81-92, </pages> <month> February </month> <year> 1980. </year>
Reference-contexts: Unlike the SPIN kernel, which provides extension-oriented facilities for logical protection domains and event binding, their system provides no abstractions beyond those minimally provided by the hardware [EK95]. Several systems <ref> [CHL91, RDH + 80, Mos94, SS94] </ref>, like SPIN, have leveraged type safety to build an extensible system. Pilot, for example, was a single-address space system which ran programs written in Mesa [GMS77], a high-level systems programming language which is an ancestor of Modula-3 [Nel91].
Reference: [RLB94] <author> Theodore H. Romer, Dennis Lee, and Brian N. Bershad. </author> <title> Dynamic page mapping policies for cache conflict resolution on standard hardware. </title> <booktitle> In Proc. of the First Symposium on Operating Systems Design and Implementation, </booktitle> <pages> pages 255-266, </pages> <address> Monterey, CA, </address> <month> November </month> <year> 1994. </year> <note> USENIX Assoc. </note>
Reference-contexts: Others have enabled control over relatively small objects, for example cache pages <ref> [RLB94] </ref> or TLB entries [BKW94], entirely from the kernel. None have allowed for fast, fine-grained control over the physical and virtual memory resources required by applications. The SPIN core virtual memory management system decomposes memory services into three basic components: physical storage, naming, and protection.
Reference: [ROKB95] <author> Theodore Romer, Wayne Ohlrich, Anna Karlin, and Brian Bershad. </author> <title> Reducing TLB and Memory Overhead Using Online Superpage Promotion. </title> <booktitle> In Proceedings of the 23rd International Symposium on Computer Architecture, </booktitle> <year> 1995. </year>
Reference: [RTY + 87] <author> Richard Rashid, Avadis Tevanian, Jr., Michael Young, David Golub, Robert Baron, David Black, William Bolosky, and Jonathan Chew. </author> <title> Machine-Independent Virtual Memory Management for Paged Uniprocessor and Multiprocessor Architectures. </title> <booktitle> In Proceedings of the 2nd Symposium on Architectural Support for Programming Languages and Operating Systems, </booktitle> <month> April </month> <year> 1987. </year>
Reference-contexts: If instead, it accesses an allocated, but unmapped virtual page, then the Translation.PageNotPresent event is raised. Implementors of higher level memory management abstractions use these events to implement services such as demand paging, copy-on-write <ref> [RTY + 87] </ref>, distributed shared memory [CBZ91], or concurrent garbage collection [AL91]. Resource reclamation The physical page service may at any time reclaim memory. A page is recalled by raising the Physical-Page.Recall event with the specific physical page specified as an argument.
Reference: [SBC93] <author> Daniel Stodolsky, Brian N. Bershad, and Brad Chen. </author> <title> Fast Interrupt Priority Management for Operating System Kernels. </title> <booktitle> In Proceedings of the 2nd Usenix Workshop on Microkernels and Other Kernels, </booktitle> <month> September </month> <year> 1993. </year>
Reference: [SMP92] <author> Andrew Schulman, David Maxey, and Matt Pietrek. </author> <title> Undocumented Windows. </title> <publisher> Addison-Wesley, </publisher> <year> 1992. </year>
Reference-contexts: Although these systems were not designed to be extensible, application builders have been able to exploit weaknesses in their protection mechanisms to directly modify operating system data structures and code <ref> [SMP92] </ref>. While individual applications have benefited from this level of freedom, the lack of safe interfaces to either operating system services, or operating system extension services, has created system configuration "chaos [Dra93]." SPIN directly addresses this deficit. 2.1 Related work There have been several attempts to build extensible systems.
Reference: [SS94] <author> Christopher Small and Margo Seltzer. VINO: </author> <title> An Integrated Platform for Operating System and Database Research. </title> <type> Technical Report TR-30-94, </type> <institution> Harvard University, </institution> <year> 1994. </year>
Reference-contexts: Second, the interface between the language's programming environment and the rest of the system is generally narrow, making system integration difficult. Finally, interpretation overhead may be a limiting factor to performance. Several projects <ref> [Luc94, EKO94, SS94] </ref> are exploring the use of software fault isolation [WLAG93] to allow application code, written in any language, to be linked into the kernel's virtual address space. Software fault isolation relies on a binary rewriting tool that inserts explicit checks on memory references and branch instructions. <p> Unlike the SPIN kernel, which provides extension-oriented facilities for logical protection domains and event binding, their system provides no abstractions beyond those minimally provided by the hardware [EK95]. Several systems <ref> [CHL91, RDH + 80, Mos94, SS94] </ref>, like SPIN, have leveraged type safety to build an extensible system. Pilot, for example, was a single-address space system which ran programs written in Mesa [GMS77], a high-level systems programming language which is an ancestor of Modula-3 [Nel91].
Reference: [TL94] <author> Chandramohan A. Thekkath and Henry M. Levy. </author> <title> Hardware and Software Support for Efficient Exception Handling. </title> <booktitle> In Proceedings of the Fifth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-VI), </booktitle> <pages> pages 145-156, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: A longstanding problem with fault-based strategies has been the overhead of safely reflecting the page fault to application-code, so that it can be recovered from <ref> [TL94, ALBL91] </ref>. Overheads are high because each fault requires five crossings of the user/kernel boundary (fault, notify, request-page-unprotect, reply-page-protect, restart-faulting-thread), with each saving and restoring processor state.
Reference: [TSS88] <author> Charles P. Thacker, Lawrence C. Stewart, and Edwin H. Satterthwaite, Jr. Firefly: </author> <title> a multiprocessor workstation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 37(8) </volume> <pages> 909-920, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: Lastly, the system was designed with the notion of "large objects" as the basic building blocks, requiring a large programming effort to affect even a small extension. Recently, researchers have investigated the use of microkernels as a vehicle for building extensible systems <ref> [B + 92, MRT + 90, CZ83, CD94, TSS88] </ref>. In a microkernel-based system, operating system services are implemented as user-level programs and accessed through an interprocess communication service provided by the kernel.
Reference: [vECGS92] <author> Thorsten von Eicken, David E. Culler, Seth Copen Goldstein, and Klaus Erik Schauser. </author> <title> Active Messages: A Mechanism for Integrated Communication and Computation. </title> <booktitle> In Proceedings of the 19th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 256-266, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: In the figure, several application-specific protocol handlers are shown: "UDP count" simply counts the number of incoming UDP packets, "A.M." is an extension that implements active messages <ref> [vECGS92] </ref>, "RPC" implements the network transport for a remote procedure call package, and "Video" provides a direct path for video packets from the network to the frame-buffer.
Reference: [VGA94] <author> A. Vahdat, P. Ghormley, and T.E. Anderson. </author> <title> Efficient, Portable and Robust Extension of Operating System Functionality. </title> <type> Technical Report UCB CS-94-842, </type> <institution> University of California, Berkeley, </institution> <month> December </month> <year> 1994. </year>
Reference-contexts: Moreover, each change intended to improve the performance of one class of applications would often degrade that of others. Commodity operating systems have been slow to adopt new technologies to support advanced applications <ref> [VGA94] </ref>. In order to justify the cost of introducing a new service, it must be demonstrated that the service has broad applicability. By its very nature, this demonstration precludes application-specific services for all but the most common applications.
Reference: [WB92] <author> Bob Wheeler and Brian N. Bershad. </author> <title> Consistency Management for Virtually Indexed Caches. </title> <booktitle> In Proceedings of the Fifth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-V), </booktitle> <month> October </month> <year> 1992. </year>
Reference: [WLAG93] <author> Robert Wahbe, Steven Lucco, Thomas E. Anderson, and Susan L. Graham. </author> <title> Efficient software-based fault isolation. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 203-216, </pages> <year> 1993. </year>
Reference-contexts: Second, the interface between the language's programming environment and the rest of the system is generally narrow, making system integration difficult. Finally, interpretation overhead may be a limiting factor to performance. Several projects [Luc94, EKO94, SS94] are exploring the use of software fault isolation <ref> [WLAG93] </ref> to allow application code, written in any language, to be linked into the kernel's virtual address space. Software fault isolation relies on a binary rewriting tool that inserts explicit checks on memory references and branch instructions.
Reference: [WLH81] <author> William A. Wulf, Roy Levin, and Samuel P. Harbi-son. Hydra/C.mmp: </author> <title> An Experimental Computer System. </title> <publisher> McGraw-Hill, </publisher> <year> 1981. </year>
Reference-contexts: For example, Hydra <ref> [WLH81] </ref> provided an infrastructure that allowed applications to manage resources through multi-level policies. The kernel provided the mechanism for allocating resources between processes, and the processes themselves implemented the mechanisms for managing those resources. Hydra's approach, although highly influential, was expensive to use. <p> Interfaces and collections of interfaces can be protected to allow different extensions to have different views on the set of available services. Unlike other capability-based operating systems, which implement capabilities using special-purpose hardware [CKD94], virtual memory mechanisms <ref> [WLH81] </ref>, probabilistic protection [EKO94], or protected message channels [B + 92], SPIN's capabilities are implemented in terms of opaque references. An opaque reference is simply a type safe pointer to an abstract data type. <p> The implementation of the model determines its performance and functionality. Application requirements are often mismatched (in terms of performance or semantics) by the processor management interface exported by operating systems. User-level thread management systems have addressed this mismatch <ref> [WLH81, CD88, MSLM91, ABLL92] </ref>, but only partially. For example, Mach's user-level C-Threads implementation [CD88], although flexible, is poorly integrated with kernel services [ABLL92]. In contrast, scheduler activations, which were well-integrated with the kernel, had excessively high overhead [DMVL93].
Reference: [YBMM94] <author> Masanobu Yuhara, Brian N. Bershad, Chris Maeda, and J. Eliot B. Moss. </author> <title> Efficient Packet Demultiplexing for Multiple Endpoints and Large Messages. </title> <booktitle> In Proceedings of the 1994 Winter USENIX Conference, </booktitle> <month> January </month> <year> 1994. </year>
Reference-contexts: Moreover, the granularity with which exten sions can be specified in microkernel-based systems is quite large. Some systems rely on "little languages" to extend safely the system call interface through the use of interpreted code that runs in the kernel <ref> [LCC94, MRA87, YBMM94] </ref>. These systems suffer from two problems. First, the languages, being little, make cumbersome the expression of arbitrary control and data structures, therefore limiting the range of possible extensions.
Reference: [YTR + 87] <author> M. Young, A. Tevanian, R. Rashid, D. Golub, J. Ep-pinger, J. Chew, W. Bolosky, D. Black, and R. Baron. </author> <title> The Duality of Memory and Communication in the Implementation of a Multiprocessor Operating System. </title> <booktitle> In Proceedings of the Eleventh ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 63-76, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: Other systems have demonstrated significant performance improvements from specialized or "tuned" memory management policies that are accessible through interfaces exposed by the memory management system. Some of these interfaces have made it possible to manipulate large objects, for example entire address spaces <ref> [YTR + 87, KN93] </ref>, or to direct expensive operations, for example page 7 out [HC91, MA90, CFL94], entirely from user level. Others have enabled control over relatively small objects, for example cache pages [RLB94] or TLB entries [BKW94], entirely from the kernel. <p> We hope to report on times using this configuration in the final paper. specific code that requests that the page be marked read-write. For DEC OSF/1, we implemented the application-specific code using signals and the mprotect system call. For Mach 3.0, we used the external pager interface <ref> [YTR + 87] </ref>. For SPIN, we installed an extension that handled VM.WriteProtect events for the application's virtual address space, and then performed a call to the translation service requesting that the faulted page be made writeable.
Reference: [YTT89] <author> Yasuhiko Yokote, Fumio Teraoka, and Mario Tokoro. </author> <title> A reflective architecture for an object-oriented distributed operating system. </title> <editor> In S. Cook, editor, </editor> <booktitle> Proceedings ECOOP '89, </booktitle> <pages> pages 89-106, </pages> <address> Nottingham, </address> <month> July 10-14 </month> <year> 1989. </year> <note> Cam-bridge University Press. 16 </note>
Reference-contexts: Many systems provide interfaces that enable code to be installed into the kernel at runtime. Examples include dynamically linked device drivers, stackable layers [HP94], or server-co-location [LHfL93, RAA + 88]. Reflective operating systems, such as Apertos <ref> [YTT89] </ref>, provide arbitrary access to system internals. In all of these systems, the right to define extensions is restricted because any extension can bring down the entire system.
References-found: 64

