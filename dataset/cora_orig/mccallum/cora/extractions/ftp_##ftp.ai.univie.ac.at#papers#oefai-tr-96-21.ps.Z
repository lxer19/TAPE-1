URL: ftp://ftp.ai.univie.ac.at/papers/oefai-tr-96-21.ps.Z
Refering-URL: http://www.ai.univie.ac.at/clpqr/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: email: christian@ai.univie.ac.at  email: ffm,pbg@fct.unl.pt  
Title: Defeasibility in CLP(Q) through Generalized Slack Variables  
Author: Christian Holzbaur Francisco Menezes and Pedro Barahona 
Keyword: Constraint Logic Programming, Linear Programming, Defeasible Constraint Solving  
Address: Freyung 6, A-1010 Vienna, Austria  2825 Monte da Caparica, Portugal  
Affiliation: Austrian Research Institute for Artificial Intelligence, and Department of Medical Cybernetics and Artificial Intelligence University of Vienna  Departamento de Informatica Faculdade de Ci^encias e Tecnologia Universidade Nova de Lisboa  
Abstract: This paper presents a defeasible constraint solver for the domain of linear equations, disequations and inequalities over the body of rational/real numbers. As extra requirements resulting from the incorporation of the solver into an Incremental Hierarchical Constraint Solver (IHCS) scenario we identified: a)the ability to refer to individual constraints by a label, b) the ability to report the (minimal) cause for the unsatisfiability of a set of constraints, and c) the ability to undo the effects of a formerly activated constraint. We develop the new functionalities after starting the presentation with a general architecture for defeasible constraint solving, through a solved form algorithm that utilizes a generalized, incremental variant of the Simplex algorithm, where the domain of a variable can be restricted to an arbitrary interval. We demonstrate how generalized slacks form the basis for the computation of explanations regarding the cause of unsatisfiability and/or entailment in terms of the constraints told, and the possible deactivation of constraints as demanded by the hierarchy handler.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Backer B.de, Beringer H.: </author> <title> Intelligent Backtracking for CLP Languages: An Application to CLP(R), </title> <editor> in Saraswat V. & Ueda K.(eds.), </editor> <booktitle> Symposion on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, MA, pp.405-419, </address> <year> 1991. </year>
Reference-contexts: A stronger result is: Theorem 4. Once the solved form algorithm detects unsatisfiability in (5), the constraints identified by the non-basic variables with nonzero coefficients constitute a minimal inconsistent subset of the set of constraints. We draw upon a result by deBacker <ref> [1] </ref>, which extended Lassez's Quasi-Dual results [11] based on Fourier's theorem. Theorem 5 Fourier 1827. A set S of inequalities is inconsistent iff there exists a positive linear combination of inequalities which give 0 k, where k &lt; 0.
Reference: 2. <author> A. Borning, M. Maher, A. Martingale, and M. Wilson. </author> <title> Constraints hierarchies and logic programming. </title> <editor> In Levi and Martelli, editors, </editor> <booktitle> Logic Programming: Proceedings of the 6th International Conference, </booktitle> <pages> pages 149-164, </pages> <address> Lisbon, Portugal, June 1989. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: An alternative approach is to use an overconstrained specification, including both hard constraints and soft constraints (that merely specify preferences), and have a system to compute the solutions that satisfy in the best possible way a subset of these preference constraints. This was the approach taken by <ref> [2, 16] </ref>, that proposed an HCLP scheme that allows non-required (or soft) constraints to be specified with some preference level and rely on a constraint solver that explores this hierarchy of constraints to detect the best solutions.
Reference: 3. <author> Burg J., Lang S.-D., Hughes C.E.: </author> <title> Finding Conflict Sets and Backtrack Points in CLP(R), </title> <editor> in Hentenryck P.van(ed.), </editor> <booktitle> Proceedings of the Eleventh International Conference on Logic Programming (ICLP94), </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1994. </year>
Reference-contexts: Our work shares objectives with <ref> [3] </ref>. Our improvement is in the addition of defeasibility to the thread and that we don't need an explicit inverse of the basis for CS computations.
Reference: 4. <author> Colmerauer A.: </author> <title> An Introduction to Prolog III, </title> <journal> Communications of the ACM, </journal> <volume> 33(7), </volume> <pages> 69-90, </pages> <year> 1990. </year>
Reference-contexts: Empirics: In the following table we list the execution time ratio b=s between the solved form algorithm using bounded variables and a 'crippled' version which works like the original Simplex with one slack and a row for each inequality. The first two examples are from <ref> [4] </ref> computing the first and all solutions to the geometric covering problem where nine squares of unknown and different sizes are required fill an unspecified rectangle, the remaining ones are executions of a very simple minded branch and bound (BB) code on top of our solved form for some of the
Reference: 5. <author> Dantzig G.B.: </author> <title> Linear Programming and Extensions, </title> <publisher> Princeton University Press, </publisher> <address> Princeton, NJ, </address> <year> 1963. </year>
Reference-contexts: This requirements are met by our finite domain constraint solver described in [14]. The rest of this paper explains the changes made to a Constraint Solver for linear constraints over rational/real numbers, namely its explanatory and defeasibility enhancements. 3 Simplex with Generalized Slack Variables Classical Simplex <ref> [5] </ref> deals with a single sort of slack variables: S i 0. Free variables, negative variables and strict inequalities create minor problems, some of which are addressed by using pairs of slacks.
Reference: 6. <author> Hentenryck P.van, Ranachandran V.: </author> <title> Backtracking without Trailing in CLP(R), </title> <institution> Dept.of Computer Science, Brown University, CS-93-51, </institution> <year> 1993. </year>
Reference-contexts: The basis for the validity of this operation is that one may substitute zero at any time for all such variables without changing the original problem statement. We call this special sort of slack variables witness variables after <ref> [6] </ref> where the very same trick was applied for a completely different purpose. The initial coefficients for the witness variables is immaterial, but 1 is convenient. <p> If there are (implicitly) fixed values and/or additional equations, the extra cost for carrying along the witness variables is rewarded by the possibilities a) to deactivate the constraints later, and b) although not elaborated on here, to have backtracking without trailing in the constraint solver <ref> [6] </ref>. Our work shares objectives with [3]. Our improvement is in the addition of defeasibility to the thread and that we don't need an explicit inverse of the basis for CS computations.
Reference: 7. <author> Holzbaur C.: </author> <title> Specification of Constraint Based Inference Mechanisms through Extended Unification, </title> <institution> Department of Medical Cybernetics and Artificial Intelligence, University of Vienna, Dissertation, </institution> <year> 1990. </year>
Reference-contexts: It is coded in Prolog using Attributed Variables [8] which serve as direct access storage locations for properties associated with variables. At the same time, attributed variables make the unification part of a unification based language, Prolog in our particular case, user-definable within the language under extension <ref> [7, 9] </ref>. Empirics: In the following table we list the execution time ratio b=s between the solved form algorithm using bounded variables and a 'crippled' version which works like the original Simplex with one slack and a row for each inequality.
Reference: 8. <author> Holzbaur C.: </author> <title> Metastructures vs. Attributed Variables in the Context of Extensible Unification, </title> <editor> in Bruynooghe M. & Wirsing M.(eds.), </editor> <booktitle> Programming Language Implementation and Logic Programming, </booktitle> <publisher> Springer, LNCS 631, </publisher> <address> pp.260-268, </address> <year> 1992. </year>
Reference-contexts: It is coded in Prolog using Attributed Variables <ref> [8] </ref> which serve as direct access storage locations for properties associated with variables. At the same time, attributed variables make the unification part of a unification based language, Prolog in our particular case, user-definable within the language under extension [7, 9].
Reference: 9. <author> Holzbaur C.: </author> <title> Extensible Unification as Basis for the Implementation of CLP Languages, </title> <editor> in Baader F., et al., </editor> <booktitle> Proceedings of the Sixth International Workshop on Unification, </booktitle> <address> Boston University, MA, TR-93-004, pp.56-60, </address> <year> 1993. </year>
Reference-contexts: It is coded in Prolog using Attributed Variables [8] which serve as direct access storage locations for properties associated with variables. At the same time, attributed variables make the unification part of a unification based language, Prolog in our particular case, user-definable within the language under extension <ref> [7, 9] </ref>. Empirics: In the following table we list the execution time ratio b=s between the solved form algorithm using bounded variables and a 'crippled' version which works like the original Simplex with one slack and a row for each inequality.
Reference: 10. <author> Imbert J.-L., Cohen J., Weeger M.-D.: </author> <title> An Algorithm for Linear Constraint Solving: Its Incorporation in a Prolog Meta-Interpreter for CLP, in Special Issue: Constraint Logic Programming, </title> <journal> Journal of Logic Programming, </journal> <volume> 16(3&4), </volume> <pages> 235-253, </pages> <year> 1993. </year>
Reference-contexts: Trivial non-satisfiability, redundancy and implicit equalities are detected by trivial tests of O (1) complexity. Obviously the thread matches and advances current activities in the CLP area that try to restrict the use of general decision methods to the cases where they are unavoidable <ref> [10] </ref>.
Reference: 11. <author> Lassez J.L.: </author> <title> Parametric Queries, Linear Constraints and Variable Elimination, </title> <booktitle> in Proceedings of the Conference on Design and Implementation of Symbolic Computation Systems, </booktitle> <address> Capri, pp.164-173, </address> <year> 1990. </year>
Reference-contexts: A stronger result is: Theorem 4. Once the solved form algorithm detects unsatisfiability in (5), the constraints identified by the non-basic variables with nonzero coefficients constitute a minimal inconsistent subset of the set of constraints. We draw upon a result by deBacker [1], which extended Lassez's Quasi-Dual results <ref> [11] </ref> based on Fourier's theorem. Theorem 5 Fourier 1827. A set S of inequalities is inconsistent iff there exists a positive linear combination of inequalities which give 0 k, where k &lt; 0. S : &lt; n X a ij x j b i = i*1::m Theorem 6 Lassez 1990.
Reference: 12. <author> Menezes F., Barahona P.: </author> <title> Preliminary Formalization of an Incremental Hierarchical Constraint Solver. </title> <editor> In L. Damas L and M. Filgueiras (eds.), </editor> <booktitle> In Proceedings of EPIA'93, </booktitle> <publisher> Springer-Verlag, Porto, </publisher> <month> October </month> <year> 1993. </year>
Reference-contexts: were a) early detection of failures through the use of the usual node- and arc-consistency techniques for these domains; b) detection of conflict sets, i.e. the sets of constraints responsible for the failures (this is done by keeping dependencies between constraints through shared variables by adaptation of the AC-5 algorithm <ref> [12] </ref>); c) selection from these conflict sets of constraints that should be relaxed, together with the selection of constraints (currently relaxed because of conflicts with the former) that can now be safely reactivated; and d) defeating the constraints, i.e. remove the effects of relaxed constraints avoiding reevaluation from scratch.
Reference: 13. <author> Menezes F., Barahona P.: </author> <title> An Incremental Hierarchical Constraint Solver. </title> <editor> In V. Saraswat and P. Van Hentenryck, editors, </editor> <booktitle> Principles and Practice of Constraint Programming, </booktitle> <publisher> MIT Press, </publisher> <year> 1995. </year>
Reference-contexts: Although the scheme is quite general, little details were published on the implementation of this scheme. In <ref> [13, 14] </ref> we presented, IHCS, an efficient and incremental defeasible constraint solver that is used as the kernel of an HCLP instance for finite domains. <p> The following sections will describe a general architecture for defeasible constraint solving, recapture the working of the traditional Simplex algorithm, introduce a variant through the generalization of slack variables, cover the identification of minimal conflict sets, and derive defeasibility. 2 An Architecture for Defeasible Constraint Solving In <ref> [13, 14] </ref> an Incremental Hierarchical Constraint Solver (IHCS (X, )) is presented as a general framework to handle, incrementally, hierarchies of constraints in some domain X using some comparator .
Reference: 14. <author> Menezes F., Barahona P.: </author> <title> Defeasible Constraint Solving. </title> <booktitle> In Proceedings of Ib-eramia 94, </booktitle> <publisher> McGraw-Hill Interamericana de Venezuela, </publisher> <address> Caracas, </address> <month> October </month> <year> 1994. </year>
Reference-contexts: Although the scheme is quite general, little details were published on the implementation of this scheme. In <ref> [13, 14] </ref> we presented, IHCS, an efficient and incremental defeasible constraint solver that is used as the kernel of an HCLP instance for finite domains. <p> The following sections will describe a general architecture for defeasible constraint solving, recapture the working of the traditional Simplex algorithm, introduce a variant through the generalization of slack variables, cover the identification of minimal conflict sets, and derive defeasibility. 2 An Architecture for Defeasible Constraint Solving In <ref> [13, 14] </ref> an Incremental Hierarchical Constraint Solver (IHCS (X, )) is presented as a general framework to handle, incrementally, hierarchies of constraints in some domain X using some comparator . <p> Of course all the above requirements impose that, the labels used by the hierarchical manager to refer to individual constraints are shared by the constraint solver. This requirements are met by our finite domain constraint solver described in <ref> [14] </ref>. The rest of this paper explains the changes made to a Constraint Solver for linear constraints over rational/real numbers, namely its explanatory and defeasibility enhancements. 3 Simplex with Generalized Slack Variables Classical Simplex [5] deals with a single sort of slack variables: S i 0.
Reference: 15. <author> Murty K.G.: </author> <title> Linear and Combinatorial Programming, </title> <publisher> Wiley, </publisher> <address> New York, </address> <year> 1976. </year>
Reference-contexts: X 10 X 2 The next section deals with the interaction of generalized slacks with higher dimensional constraints. 3.1 Solved Form for Inequalities over Bounded Variables The idea proper has been realized a long time ago in the area of linear programming under the name of bounded variable linear programs <ref> [15] </ref>. In bounded variable linear programs, some or all variables are restricted to lie within individual lower and upper bounds. Such problems can of course be solved by including all bound restrictions as constraints, i.e. rows in the simplex tableau. <p> Proof of theorem 4. We exhibit the correspondence between the dual problem that arises from the repair action in the solved form algorithm for an unsatisfiable constraint and the quasi dual formulation for the whole system of constraints. The dual problem <ref> [15] </ref> for an optimization problem in standard form n P n o maximize P n (11) j=1 a ij j c i i*1::n 0 minimize P m 0 (12) The quasi dual for the total system including the m + 1-th row is Q total : 8 : i=1 i a
Reference: 16. <author> Wilson M., Borning A.: </author> <title> Hierarchical Constraint Logic Programming. </title> <journal> J. Logic Programming, 1993:16. </journal>
Reference-contexts: An alternative approach is to use an overconstrained specification, including both hard constraints and soft constraints (that merely specify preferences), and have a system to compute the solutions that satisfy in the best possible way a subset of these preference constraints. This was the approach taken by <ref> [2, 16] </ref>, that proposed an HCLP scheme that allows non-required (or soft) constraints to be specified with some preference level and rely on a constraint solver that explores this hierarchy of constraints to detect the best solutions.
References-found: 16

