URL: ftp://ftp.cs.uoregon.edu/pub/ariola/narrowing.ps
Refering-URL: http://www.cs.uoregon.edu/~ariola/publications.html
Root-URL: http://www.cs.uoregon.edu
Title: Narrowing the Narrowing Space  
Author: Sergio Antoy and Zena M. Ariola 
Keyword: Functional logic programming, Narrowing, Narrowing space, Computed expression, Regular computed expression, Finite representation.  
Affiliation: 1 Portland State University 2 University of Oregon  
Abstract: We introduce a framework for managing as a whole the space of a narrowing computation. The aim of our framework is to find a finite representation of an infinite narrowing space. This, in turn, allows us to replace an infinite enumeration of computed answers with an equivalent finite representation. We provide a semidecidable condition for this result. Our framework is intended to be used by implementations of functional logic programming languages. Our approach borrows from the memoization technique used in the implementation of functional languages. Since narrowing adds non-determinism and unifiers to functional evaluation, we develop a new approach based on graphs to memoize the outcome of a goal.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> D. Angluin and C. Smith. </author> <title> Inductive inference: Theory and methods. </title> <journal> Computing Surveys, </journal> <volume> 15(3) </volume> <pages> 237-269, </pages> <year> 1983. </year>
Reference-contexts: Our framework accommodates techniques, or even extends them and pro-motes new ones, intended to reduce the size of the narrowing space. We limited our detailed discussion to simplification and fertilization. Generalization [5], similar to fertilization, turns out to be useful in some situations. Inductive inference <ref> [1] </ref> allows us to detect situations in which simply performing further narrowing steps to find a graph representation of the narrowing space is useless.
Reference: 2. <author> S. Antoy, R. Echahed, and M. Hanus. </author> <title> A needed narrowing strategy. </title> <booktitle> In Proc. 21st ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 268-279, </pages> <address> Portland, </address> <year> 1994. </year> <note> URL www.cs.pdx.edu/~antoy/publications.html. </note>
Reference-contexts: It is easy to generalize the rules above to other types. Our framework is largely independent of the narrowing strategy. In all our examples we employ the strategy presented in <ref> [2] </ref>. 3 The Framework Memoization [25] is a technique aimed at improving the performance of functional languages. A memoized function remembers the arguments to which it has been applied together with the results it generates on them.
Reference: 3. <author> S. Antoy, R. Echahed, and M. Hanus. </author> <title> A parallel narrowing strategy. </title> <booktitle> In 14th Int'l Conference on Logic Programming, </booktitle> <address> Leuven, Belgium, </address> <month> July </month> <year> 1997. </year> <note> (to appear) URL www.cs.pdx.edu/~antoy/publications.html. </note>
Reference: 4. <author> A. Bockmayr, S. Krischer, and A. Werner. </author> <title> An optimal narrowing strategy for general canonical systems. </title> <booktitle> In Proc. of the 3rd Intern. Workshop on Conditional Term Rewriting Systems, </booktitle> <pages> pages 483-497. </pages> <publisher> Springer LNCS 656, </publisher> <year> 1992. </year>
Reference: 5. <author> R.S. Boyer and J.S. Moore. </author> <title> Proving theorems about LISP functions. </title> <journal> JACM, </journal> <volume> 22(1) </volume> <pages> 129-144, </pages> <month> Jan. </month> <year> 1975. </year>
Reference-contexts: When the goal is an equation, theorem provers apply an induction hypothesis by replacing in the current goal an instance of the equation's left-hand side with the corresponding instance of the right-hand side or vice versa. This operation is called "fertilization" in <ref> [5] </ref>. <p> Furthermore, each simplification rule must be tried on every subgoal, whereas fertilization rules are applied more selectively. In <ref> [5] </ref> a fertilization rule is used only once and then discarded, a policy that further speeds up a computation. Finally, simplification rules must be terminating, whereas fertilization rules have no such a requirement. Earlier we considered x + y == y + x as a simplification rule. <p> The right part of Figure 1 contains an example that proves this point. Our framework accommodates techniques, or even extends them and pro-motes new ones, intended to reduce the size of the narrowing space. We limited our detailed discussion to simplification and fertilization. Generalization <ref> [5] </ref>, similar to fertilization, turns out to be useful in some situations. Inductive inference [1] allows us to detect situations in which simply performing further narrowing steps to find a graph representation of the narrowing space is useless.
Reference: 6. <author> J. Darlington and Y. Guo. </author> <title> Narrowing and unification in functional programming - an evaluation mechanism for absolute set abstraction. </title> <booktitle> In Proc. of the Conference on Rewriting Techniques and Applications, </booktitle> <pages> pages 92-108. </pages> <publisher> Springer LNCS 355, </publisher> <year> 1989. </year>
Reference: 7. <author> N. Dershowitz and J. Jouannaud. </author> <title> Rewrite systems. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science B: Formal Methods and Semantics, chapter 6, </booktitle> <pages> pages 243-320. </pages> <publisher> North Holland, </publisher> <address> Amsterdam, </address> <year> 1990. </year>
Reference: 8. <author> R. Echahed. </author> <title> On completeness of narrowing strategies. </title> <booktitle> In Proc. CAAP'88, </booktitle> <pages> pages 89-101. </pages> <publisher> Springer LNCS 299, </publisher> <year> 1988. </year>
Reference: 9. <author> R. Echahed. </author> <title> Uniform narrowing strategies. </title> <booktitle> In Proceedings of the Third International Conference on Algebraic and Logic Programming, </booktitle> <pages> pages 259-275, </pages> <address> Volterra, Italy, </address> <month> September </month> <year> 1992. </year>
Reference: 10. <author> M. J. Fay. </author> <title> First-order unification in an equational theory. </title> <booktitle> In Proc. 4th Workshop on Automated Deduction, </booktitle> <pages> pages 161-167, </pages> <address> Austin (Texas), 1979. </address> <publisher> Academic Press. </publisher>
Reference-contexts: Then, 0 + 0 is rewritten as usual. Choosing instantiations and rewrites is the task of a narrowing strategy. Narrowing is often used in functional logic programming for its ability to solve equations, i.e., computing unifiers with respect to an equational theory <ref> [10] </ref>. For example, consider the equation u + s 0 == s (s 0), where "==" denotes the equality predicate. The second rule is applied to the equation by instantiating u to s w obtaining s (w + s 0) == s (s 0).
Reference: 11. <author> L. Fribourg. SLOG: </author> <title> A logic programming language interpreter based on clausal superposition and rewriting. </title> <booktitle> In Proc. IEEE Internat. Symposium on Logic Programming, </booktitle> <pages> pages 172-184, </pages> <address> Boston, </address> <year> 1985. </year>
Reference: 12. <author> S.J. Garland and J.V. Guttag. </author> <title> Inductive methods for reasoning about abstract data types. </title> <booktitle> In ACM SIGACT-SIGPLAN Symposium of Principles of Programming Languages, </booktitle> <pages> pages 219-228, </pages> <year> 1988. </year>
Reference: 13. <author> E. Giovannetti, G. Levi, C. Moiso, and C. Palamidessi. </author> <title> Kernel LEAF: a logic plus functional language. </title> <journal> The Journal of Computer and System Sciences, </journal> <volume> 42 </volume> <pages> 139-185, </pages> <year> 1991. </year>
Reference: 14. <author> W. Hans, R. Loogen, and S. Winkler. </author> <title> On the interaction of lazy evaluation and backtracking. </title> <booktitle> In Proc. of the 4th International Symposium on Programming Language Implementation and Logic Programming, </booktitle> <pages> pages 355-369. </pages> <publisher> Springer LNCS 631, </publisher> <year> 1992. </year>
Reference: 15. <author> M. Hanus. </author> <title> Lazy narrowing with simplification. </title> <note> Computer Languages (to appear), </note> <year> 1997. </year>
Reference-contexts: Later results could be more informative than earlier results, since more computed expressions may become known, a situation that we think is undesirable in a declarative environment. 3.4 Simplification It is well known that simplification rules reduce the size of the narrowing space of certain goals <ref> [15] </ref>. A simplification rule is a rewrite rule used to perform deterministic steps during a narrowing derivation. <p> Since our framework thrives on cycles, it is interesting to explore the effects of non-terminating simplification rules. Take for example the rule x+y = y+x (1) that subsumes both the simplification rules for addition proposed earlier, but cannot be used in the classic approach <ref> [15] </ref>. If we use this rule in place of the defining rules of "+" we immediately get a cycle, but nothing else.
Reference: 16. <author> A. Herold. </author> <title> Narrowing techniques applied to idempotent unification. </title> <type> Technical Report SR-86-16, SEKI, </type> <year> 1986. </year>
Reference: 17. <author> S. Holldobler. </author> <title> Foundations of Equational Logic Programming. </title> <publisher> Springer LNCS 353, </publisher> <year> 1989. </year>
Reference: 18. <author> G. Huet and J.-M. Hullot. </author> <title> Proofs by induction in equational theories with constructors. </title> <journal> JCSS, </journal> <volume> 25 </volume> <pages> 239-266, </pages> <year> 1982. </year>
Reference-contexts: Consider the regular substitution fu 7! t 1 g j : : : j fu 7! t n g (3) If the set of terms ft 1 ; : : : ; t n g is complete for (the constructors of) T in the sense of <ref> [18] </ref>, then the regular substitution of display (3) defines all the instances of type T [18, Lemma 3], and consequently can be simplified to the identity substitution. <p> : : j fu 7! t n g (3) If the set of terms ft 1 ; : : : ; t n g is complete for (the constructors of) T in the sense of [18], then the regular substitution of display (3) defines all the instances of type T <ref> [18, Lemma 3] </ref>, and consequently can be simplified to the identity substitution. Referring to Figure 4, we first simplify the substitution of the goal's RCE by repeatedly applying the simplification rule of display (2) thus obtaining fu 7! 0g j fu 7! s wg.
Reference: 19. <author> J. W. Klop. </author> <title> Term Rewriting Systems. </title> <editor> In S. Abramsky, D. Gabbay, and T. Maibaum, editors, </editor> <booktitle> Handbook of Logic in Computer Science, </booktitle> <volume> Vol. II, </volume> <pages> pages 1-112. </pages> <publisher> Oxford University Press, </publisher> <year> 1992. </year>
Reference: 20. <author> S. Krischer and A. Bockmayr. </author> <title> Detecting redundant narrowing derivations by the LSE-SL reducibility test. </title> <booktitle> In Proc. </booktitle> <address> RTA'91. </address> <publisher> Springer LNCS 488, </publisher> <year> 1991. </year>
Reference: 21. <author> A. Middeldorp and E. Hamoen. </author> <title> Counterexamples to completeness results for basic narrowing (extended abstract). </title> <booktitle> In Proceedings of the Third International Conference on Algebraic and Logic Programming, </booktitle> <pages> pages 244-258, </pages> <address> Volterra, Italy, </address> <month> Septem-ber </month> <year> 1992. </year>
Reference: 22. <author> J. J. Moreno-Navarro, H. Kuchen, R. Loogen, and M. Rodrguez-Artalejo. </author> <title> Lazy narrowing in a graph machine. </title> <booktitle> In Proc. Second International Conference on Algebraic and Logic Programming, </booktitle> <pages> pages 298-317. </pages> <publisher> Springer LNCS 463, </publisher> <year> 1990. </year>
Reference: 23. <author> J. J. Moreno-Navarro and M. Rodrguez-Artalejo. </author> <title> Logic programming with functions and predicates: The language BABEL. </title> <journal> Journal of Logic Programming, </journal> <volume> 12 </volume> <pages> 191-223, </pages> <year> 1992. </year>
Reference: 24. <author> W. Nutt, P. Rety, and G. Smolka. </author> <title> Basic narrowing revisited. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 7 </volume> <pages> 295-317, </pages> <year> 1989. </year>
Reference: 25. <editor> S. L. Peyton Jones. </editor> <booktitle> The implementation of Functional Programming Languages. Prentice-Hall International, </booktitle> <address> Englewood Cliffs, N.J., </address> <year> 1987. </year>
Reference-contexts: It is easy to generalize the rules above to other types. Our framework is largely independent of the narrowing strategy. In all our examples we employ the strategy presented in [2]. 3 The Framework Memoization <ref> [25] </ref> is a technique aimed at improving the performance of functional languages. A memoized function remembers the arguments to which it has been applied together with the results it generates on them.
Reference: 26. <author> U. S. Reddy. </author> <title> Narrowing as the operational semantics of functional languages. </title> <booktitle> In Proc. IEEE Internat. Symposium on Logic Programming, </booktitle> <pages> pages 138-151, </pages> <address> Boston, </address> <year> 1985. </year>
Reference: 27. <author> J.-H. </author> <title> You. Unification modulo an equality theory for equational logic programming. </title> <journal> The Journal of Computer and System Sciences, </journal> <volume> 42(1) </volume> <pages> 54-75, </pages> <year> 1991. </year>
References-found: 27

