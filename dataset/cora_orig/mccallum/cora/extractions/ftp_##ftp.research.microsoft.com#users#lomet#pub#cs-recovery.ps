URL: ftp://ftp.research.microsoft.com/users/lomet/pub/cs-recovery.ps
Refering-URL: http://www.research.microsoft.com/db/
Root-URL: http://www.research.microsoft.com
Email: EMail: lomet@microsoft.com, weikum@cs.uni-sb.de  
Title: Efficient Transparent Application Recovery In ClientServer Information Systems  
Author: David Lomet and Gerhard Weikum 
Affiliation: Microsoft Research  
Abstract: Database systems recover persistent data, providing high database availability. However, database applications, typically residing on client or middle-tier applicationserver machines, may lose work because of a server failure. This prevents the masking of server failures from the human user and substantially degrades application availability. This paper aims to enable high application availability with an integrated method for database server recovery and transparent application recovery in a clientserver system. The approach, based on application message logging, is similar to earlier work on distributed system fault tolerance. However, we exploit advanced database logging and recovery techniques and request/reply messaging properties to significantly improve efficiency. Forced log I/Os, frequently required by other methods, are usually avoided. Restart time, for both failed server and failed client, is reduced by checkpointing and log truncation. Our method ensures that a server can recover independently of clients. A client may reduce logging overhead in return for dependency on server availability during client restart. 
Abstract-found: 1
Intro-found: 1
Reference: [Alvisi95] <author> Lorenzo Alvisi, Keith Marzullo: </author> <title> Message Logging: Pessimistic, Optimistic, and Causal. </title> <booktitle> International Conference on Distributed Computing Systems, </booktitle> <year> 1995 </year>
Reference-contexts: It requires either an installation point or a forced message log record at every process interaction. This frequently required disk I/O greatly limits the achievable throughput of both server and clients. Distributed state tracking: Approaches from the distributed algorithms community (see, e.g., <ref> [Strom85, Johnson87, Strom88, Alvisi95, Elnozahy96] </ref>) have a relaxed model of communicating processes. Processes generate installation points only occasionally and independently. Messages are logged in an optimistic, non-forced manner.
Reference: [Bartlett81] <author> J.F. Bartlett: </author> <title> A NonStop Kernel, </title> <booktitle> ACM Symposium on Operation Systems Principles, </booktitle> <year> 1981 </year>
Reference-contexts: When the primary process fails, the standby process takes over and re-executes starting from the last installation point of the primary process. The sending of regenerated messages is conditionally suppressed, based on testing sequence numbers against logged messages. This approach was pioneered in the early eighties <ref> [Bartlett81, Borr81, Borg83, Borg89, Kim84] </ref> but is a heavyweight solution justifiable only for mission-critical high-end applications. It requires either an installation point or a forced message log record at every process interaction. This frequently required disk I/O greatly limits the achievable throughput of both server and clients.
Reference: [Bernstein97] <author> Philip A. Bernstein, Brian Harry, Paul Sanders, David Shutt, Jason Zander: </author> <title> The Microsoft Repository. Invited Keynote Paper, </title> <booktitle> VLDB Conference, </booktitle> <address> Athens, </address> <year> 1997 </year>
Reference-contexts: Because the state of application processes is lost, applications must be stateless between transactions. However, the rich states of modern applications cannot be reduced to a queued message. Consider long interactive sessions with a repository tool <ref> [Bernstein97] </ref>, authoring tools [Kaiser97], workflow systems [Georgakopoulos95], a CAD system that may involve long-running computations, or a middle-tier application service such as SAP R/3, which invokes database services and itself supports many clients.
Reference: [Bernstein90] <author> Philip A. Bernstein, Meichun Hsu, Bruce Mann: </author> <title> Implementing Recoverable Requests Using Queues, </title> <booktitle> ACM SIGMOD Conference, </booktitle> <year> 1990 </year>
Reference-contexts: Unfortunately, this approach is very expensive as it forces every log record immediately. Most of this research ignores the need both to minimize logging cost and to truncate the log for fast restart. Persistent queues: This approach requires interactions between processes to be via persistent queues <ref> [Bernstein90] </ref>. When a process sends a message to another process, the sender enqueues the message to a persistent queue within the boundaries of a distributed transaction involving the queue and the sender. This incurs the high forced logging costs of a two-phase commit protocol [Gray93].
Reference: [Borg83] <author> Anita Borg, Jim Baumbach, Sam Glazer: </author> <title> A Message System Supporting Fault Tolerance. </title> <booktitle> ACM Symposium on Operating Systems Principles, </booktitle> <year> 1983 </year>
Reference-contexts: When the primary process fails, the standby process takes over and re-executes starting from the last installation point of the primary process. The sending of regenerated messages is conditionally suppressed, based on testing sequence numbers against logged messages. This approach was pioneered in the early eighties <ref> [Bartlett81, Borr81, Borg83, Borg89, Kim84] </ref> but is a heavyweight solution justifiable only for mission-critical high-end applications. It requires either an installation point or a forced message log record at every process interaction. This frequently required disk I/O greatly limits the achievable throughput of both server and clients.
Reference: [Borg89] <author> Anita Borg, Wolfgang Blau, Wolfgang Graetsch, Ferdinand Herrmann, Wolfgang Oberle: </author> <title> Fault Tolerance Under UNIX, </title> <journal> ACM Transactions on Computer Systems Vol.7 No.1, </journal> <month> February </month> <year> 1989, </year> <pages> pp. 1-24 </pages>
Reference-contexts: When the primary process fails, the standby process takes over and re-executes starting from the last installation point of the primary process. The sending of regenerated messages is conditionally suppressed, based on testing sequence numbers against logged messages. This approach was pioneered in the early eighties <ref> [Bartlett81, Borr81, Borg83, Borg89, Kim84] </ref> but is a heavyweight solution justifiable only for mission-critical high-end applications. It requires either an installation point or a forced message log record at every process interaction. This frequently required disk I/O greatly limits the achievable throughput of both server and clients.
Reference: [Borr81] <author> Andrea Borr: </author> <title> Transaction Monitoring in Encompass: </title> <booktitle> Reliable Distributed Transaction Processing. VLDB Conference, </booktitle> <address> Cannes, </address> <year> 1981 </year>
Reference-contexts: When the primary process fails, the standby process takes over and re-executes starting from the last installation point of the primary process. The sending of regenerated messages is conditionally suppressed, based on testing sequence numbers against logged messages. This approach was pioneered in the early eighties <ref> [Bartlett81, Borr81, Borg83, Borg89, Kim84] </ref> but is a heavyweight solution justifiable only for mission-critical high-end applications. It requires either an installation point or a forced message log record at every process interaction. This frequently required disk I/O greatly limits the achievable throughput of both server and clients.
Reference: [Bulterman95] <author> Dick C.A. Bultermann and Lynda Hardman: </author> <title> Multimedia Authoring Tools: State of the Art and Research Challenges, </title> <editor> in: Jan van Leeuwen (Editor), </editor> <booktitle> Computer Science Today: Recent Trend and Developments, </booktitle> <publisher> Springer, LNCS 1000, </publisher> <year> 1995 </year>
Reference: [Chandy85] <author> K.M. Chandy and Leslie Lamport: </author> <title> Distributed Snapshots: Determining Global States of Distributed Systems, </title> <journal> ACM Transactions on Computing Systems Vol.3 No.1, </journal> <month> Feb. </month> <year> 1985, </year> <pages> pp. 63-75 </pages>
Reference-contexts: Processes generate installation points only occasionally and independently. Messages are logged in an optimistic, non-forced manner. A failed process restarts from its most recent installation point, but other processes may be forced to restart from earlier states to guarantee a causally consistent global state <ref> [Chandy85] </ref>. This induces recovery dependencies among the processes that are unacceptable for a database server. Further, the restored global state is not necessarily the last externally observed state. This is fine for number-crunching computations, an initial target of this work, but it does not mask application failures from the user.
Reference: [Elmagarmid92] <editor> Ahmed K. Elmagarmid (Editor): </editor> <title> Database Transaction Models for Advanced Applications. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1992 </year>
Reference-contexts: Undo or compensation of certain application steps and/or database updates may also be necessary after a failure, but this is an orthogonal subject. Indeed, the capability for undo is needed during normal operation as well. This undo recovery is no different from what is already in the literature (see <ref> [Elmagarmid92, Ramamritham96] </ref> for overviews). The rest of the paper is organized as follows. Section 2 introduces clientserver information systems and their requirements for recovery, and discusses various design considerations.
Reference: [Elnozahy96] <author> E.N. Elnozahy, D.B. Johnson, Y.M. Wang: </author> <title> A Survey of Rollback-Recovery Protocols in Message-Passing Systems. </title> <type> Technical Report, </type> <institution> Carnegie-Mellon University, Pittsburgh, </institution> <year> 1996 </year>
Reference-contexts: It requires either an installation point or a forced message log record at every process interaction. This frequently required disk I/O greatly limits the achievable throughput of both server and clients. Distributed state tracking: Approaches from the distributed algorithms community (see, e.g., <ref> [Strom85, Johnson87, Strom88, Alvisi95, Elnozahy96] </ref>) have a relaxed model of communicating processes. Processes generate installation points only occasionally and independently. Messages are logged in an optimistic, non-forced manner.
Reference: [Georgakopoulos95] <author> Dimitrios Georgakopoulos, Mark Hornick, Amit Sheth: </author> <title> An Overview of Workflow Management: From Process Modeling to Workflow Automation Infrastructure. Distributed and Parallel Databases Vol.3 No.2, </title> <booktitle> 1995, </booktitle> <pages> pp. 119-153 </pages>
Reference-contexts: Because the state of application processes is lost, applications must be stateless between transactions. However, the rich states of modern applications cannot be reduced to a queued message. Consider long interactive sessions with a repository tool [Bernstein97], authoring tools [Kaiser97], workflow systems <ref> [Georgakopoulos95] </ref>, a CAD system that may involve long-running computations, or a middle-tier application service such as SAP R/3, which invokes database services and itself supports many clients.
Reference: [Gray93] <author> Jim Gray, Andreas Reuter: </author> <title> Transaction Processing: Concepts and Techniques. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1993 </year>
Reference-contexts: To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. SIGMOD98 Seattle, WA, USA 1998 ACM 0-89791-995-5/98/006...$5.00 black art unless one limits application structure to special programming models, like queued transactions supported by TP monitors <ref> [Gray93] </ref>. TP-monitor recovery is limited to undoing incomplete transactions and restoring the last committed state of message queues. Because the state of application processes is lost, applications must be stateless between transactions. However, the rich states of modern applications cannot be reduced to a queued message. <p> Installation points are called application checkpoints in the literature, meaning that an applications state is saved to stable storage. We avoid this term to avoid confusion with database checkpoints, which are special log records permitting log truncation <ref> [Gray93, Mohan92] </ref>. The prior work can be categorized into three approaches, all of which incur high normal operation and/or recovery costs: Fault-tolerant process pairs: This approach provides a primary process with a hot-standby process, usually on a different processor. <p> When a process sends a message to another process, the sender enqueues the message to a persistent queue within the boundaries of a distributed transaction involving the queue and the sender. This incurs the high forced logging costs of a two-phase commit protocol <ref> [Gray93] </ref>. Moreover, the same protocol is used when the receiver dequeues the message. This solution has been very successful in the context of transactionstructured applications such as reservation systems, and is even suitable for heterogeneous platforms. <p> We believe this is important for making application fault tolerance an affordable "commodity feature", not just an exotic high-end luxury. Throughout the paper we consider only redo recovery (equivalently, the repeating-history part of recovery <ref> [Gray93, Mohan92] </ref>) as the most important component of fault tolerance. We do not make any specific assumptions on the embedding of client requests into transactions. <p> It does this by flushing the database log buffer, including the write log records of the corresponding request-reply pair, the reply log record being the last log record that must be written. In addition, the server may perform an optimization similar to group-commit <ref> [Gray93] </ref>; i.e., it postpones sending a reply until either a timeout occurs or a sufficiently large batch of log records has accumulated. It then writes the batch to the stable log file in a single disk I/O. The server can choose among a number of options for replaying requests.
Reference: [Huang95] <author> Yennun Huang, Yi-Min Wang: </author> <title> Why Optimistic Message Logging Has Not Been Used In Telecommunications Systems. </title> <booktitle> International Symposium on Fault-Tolerant Computing Systems, </booktitle> <year> 1995 </year>
Reference-contexts: Further, the restored global state is not necessarily the last externally observed state. This is fine for number-crunching computations, an initial target of this work, but it does not mask application failures from the user. Thus, this work has had little impact on real systems <ref> [Huang95] </ref>. A variation of message logging that eliminates recovery dependencies is pessimistic message logging. Unfortunately, this approach is very expensive as it forces every log record immediately. Most of this research ignores the need both to minimize logging cost and to truncate the log for fast restart.
Reference: [Johnson87] <author> David B. Johnson, Willy Zwaenepoel: </author> <title> Sender-based Message Logging. </title> <booktitle> International Symposium on Fault-Tolerant Computing Systems, </booktitle> <year> 1987 </year>
Reference-contexts: It requires either an installation point or a forced message log record at every process interaction. This frequently required disk I/O greatly limits the achievable throughput of both server and clients. Distributed state tracking: Approaches from the distributed algorithms community (see, e.g., <ref> [Strom85, Johnson87, Strom88, Alvisi95, Elnozahy96] </ref>) have a relaxed model of communicating processes. Processes generate installation points only occasionally and independently. Messages are logged in an optimistic, non-forced manner.
Reference: [Kaiser97] <author> Gail E. Kaiser and Jim Whitehead, </author> <title> Collaborative Work: Distributed Authoring and Versioning. </title> <journal> IEEE Internet Computing Vol.1 No.2, </journal> <year> 1997, </year> <pages> pp. 76-77 </pages>
Reference-contexts: Because the state of application processes is lost, applications must be stateless between transactions. However, the rich states of modern applications cannot be reduced to a queued message. Consider long interactive sessions with a repository tool [Bernstein97], authoring tools <ref> [Kaiser97] </ref>, workflow systems [Georgakopoulos95], a CAD system that may involve long-running computations, or a middle-tier application service such as SAP R/3, which invokes database services and itself supports many clients.
Reference: [Kim84] <author> Won Kim: </author> <title> Highly Available Systems for Database Applications. </title> <journal> ACM Computing Surveys Vol.16 No.1, </journal> <year> 1984, </year> <pages> pp. 71-98 </pages>
Reference-contexts: When the primary process fails, the standby process takes over and re-executes starting from the last installation point of the primary process. The sending of regenerated messages is conditionally suppressed, based on testing sequence numbers against logged messages. This approach was pioneered in the early eighties <ref> [Bartlett81, Borr81, Borg83, Borg89, Kim84] </ref> but is a heavyweight solution justifiable only for mission-critical high-end applications. It requires either an installation point or a forced message log record at every process interaction. This frequently required disk I/O greatly limits the achievable throughput of both server and clients.
Reference: [Lomet92] <author> David Lomet: MLR: </author> <title> A Recovery Method for Multi--Level Systems. </title> <booktitle> ACM SIGMOD Conference, </booktitle> <year> 1992 </year>
Reference-contexts: The effects of the original transactions would have to be kept quasi-isolated at a higher level of abstraction taking into account application semantics <ref> [Lomet92, Weikum90] </ref>. 2. Redo/continue request execution: To make the servers nondeterministic behavior deterministically replayable, the server logs all database reads as well as writes. To ensure deterministic replay after the reply message is sent, the server must flush the log buffer before sending the reply. <p> Therefore, if any of these log records are still in the log buffer, they can be safely discarded without being written. This technique is similar to how atomic subtransactions are dealt with in the multilevel recovery methods of <ref> [Weikum90, Lomet92, Weikum93] </ref>, where some log records become irrelevant when subtransactions commit. However, should these log records be written to the stable log, they must appear in the log in their chronological order for correct recovery. There is no clear choice among our three options.
Reference: [Lomet95] <author> David Lomet, Mark Tuttle: </author> <title> Redo Recovery after System Crashes. </title> <booktitle> VLDB Conference, </booktitle> <address> Zurich, </address> <year> 1995 </year>
Reference-contexts: However, current cache managers write pages back to the stable database in any order, and hence may overwrite the version required by a read. Thus, the cache manager must not overwrite a page whose prior version is still needed to replay a read, by tracking and enforcing installation dependencies <ref> [Lomet95] </ref>. A danger is that installation dependencies may prevent the flushing of a dirty page (containing a version needed for recovery) for a very long time. Forced logging of the reply ends this installation dependency. None of the options incurs additional forced log I/O for incomplete requests.
Reference: [Lomet97] <author> David Lomet: </author> <title> Application Recovery with Logical Write Operations. </title> <type> Technical Report, </type> <institution> Microsoft Research, </institution> <address> Redmond, Washington, </address> <month> June </month> <year> 1997 </year>
Reference-contexts: The key to this is to exploit the special properties of request/reply messaging, and to use advanced databasestyle logging and recovery techniques which minimize log forcing, batch log I/Os, and efficiently truncate the log. These techniques integrate application recovery with database recovery. The only prior integrated approach <ref> [Lomet97, Lomet98] </ref> carefully coordinates the writing of log records and the installing of updates for both database and applicationstate modifications. It handles applications that run under the direct control of the database system (resource manager) on the same machine.
Reference: [Lomet98] <author> David Lomet: </author> <title> Persistent Applications Using Generalized Redo Recovery. </title> <booktitle> IEEE Int. Conference on Data Engineering, </booktitle> <address> Orlando, FL 1998 </address>
Reference-contexts: The key to this is to exploit the special properties of request/reply messaging, and to use advanced databasestyle logging and recovery techniques which minimize log forcing, batch log I/Os, and efficiently truncate the log. These techniques integrate application recovery with database recovery. The only prior integrated approach <ref> [Lomet97, Lomet98] </ref> carefully coordinates the writing of log records and the installing of updates for both database and applicationstate modifications. It handles applications that run under the direct control of the database system (resource manager) on the same machine. <p> During recovery, read values are extracted from the logged values. The danger is that logging read values can greatly increase the amount of data logged. b) Log logical read operations that record the occurrence of a database read and its source <ref> [Lomet98] </ref>. During recovery, read values are reread from the database. Thus, recovery must read the same versions as originally read. However, current cache managers write pages back to the stable database in any order, and hence may overwrite the version required by a read.
Reference: [Lomet98a] <author> David Lomet, Gerhard Weikum: </author> <title> Efficient Transparent Application Recovery in Cient-Server Information Systems, </title> <type> Technical Report, </type> <institution> Microsoft Research, </institution> <address> Redmond, Washington, </address> <year> 1998 </year>
Reference-contexts: Section 4 discusses additional refinements and optimizations of the algorithm, and an outlook on possible extensions, while Section 5 concludes the paper with a summary of the salient features of the algorithm. Pseudo-code for the developed algorithms and additional correctness reasoning can be found in <ref> [Lomet98a] </ref>. 2 Design Rationale for Recoverable ClientServer Systems We focus on request-reply interactions between client applications and a server. We assume that all requests of client applications are intercepted by the clients runtime system (e.g., the clients ODBC stub).
Reference: [Mohan92] <author> C. Mohan, Don Haderle, Bruce Lindsay, Hamid Pirahesh, Peter Schwarz: </author> <title> ARIES: A Transaction Recovery Method Supporting Fine-Granularity Locking and Partial Rollbacks Using Write-Ahead Logging. </title> <journal> ACM Transactions on Database Systems Vol.17 No.1, </journal> <month> March </month> <year> 1992, </year> <pages> pp. 94-162 </pages>
Reference-contexts: Installation points are called application checkpoints in the literature, meaning that an applications state is saved to stable storage. We avoid this term to avoid confusion with database checkpoints, which are special log records permitting log truncation <ref> [Gray93, Mohan92] </ref>. The prior work can be categorized into three approaches, all of which incur high normal operation and/or recovery costs: Fault-tolerant process pairs: This approach provides a primary process with a hot-standby process, usually on a different processor. <p> We believe this is important for making application fault tolerance an affordable "commodity feature", not just an exotic high-end luxury. Throughout the paper we consider only redo recovery (equivalently, the repeating-history part of recovery <ref> [Gray93, Mohan92] </ref>) as the most important component of fault tolerance. We do not make any specific assumptions on the embedding of client requests into transactions.
Reference: [Mohan93] <author> C. Mohan: </author> <title> A Cost-effective Method for Providing Improved Data Availability During DBMS Restart Recovery After a Failure. </title> <booktitle> VLDB Conference, </booktitle> <year> 1993 </year>
Reference: [Ramamritham96] <author> Krithi Ramamritham and Panos Chrysanthis: </author> <title> Advances in Concurrency Control and Transaction Processing. </title> <publisher> IEEE Computer Society Press, </publisher> <year> 1996 </year>
Reference-contexts: Undo or compensation of certain application steps and/or database updates may also be necessary after a failure, but this is an orthogonal subject. Indeed, the capability for undo is needed during normal operation as well. This undo recovery is no different from what is already in the literature (see <ref> [Elmagarmid92, Ramamritham96] </ref> for overviews). The rest of the paper is organized as follows. Section 2 introduces clientserver information systems and their requirements for recovery, and discusses various design considerations.
Reference: [Strom85] <author> Robert E. Strom, Shaula Yemini: </author> <title> Optimistic Recovery in Distributed Systems. </title> <journal> ACM Transactions on Computer Systems Vol.3 No.3, </journal> <month> August </month> <year> 1985, </year> <pages> pp. 204-226 </pages>
Reference-contexts: It requires either an installation point or a forced message log record at every process interaction. This frequently required disk I/O greatly limits the achievable throughput of both server and clients. Distributed state tracking: Approaches from the distributed algorithms community (see, e.g., <ref> [Strom85, Johnson87, Strom88, Alvisi95, Elnozahy96] </ref>) have a relaxed model of communicating processes. Processes generate installation points only occasionally and independently. Messages are logged in an optimistic, non-forced manner.
Reference: [Strom88] <author> Robert E. Strom, David F. Bacon, Shaula A. Yemini: </author> <title> Volatile Logging in n-Fault-Tolerant Distributed Systems. </title> <booktitle> International Symposium on Fault-Tolerant Computing, </booktitle> <address> Tokyo, </address> <year> 1988 </year>
Reference-contexts: It requires either an installation point or a forced message log record at every process interaction. This frequently required disk I/O greatly limits the achievable throughput of both server and clients. Distributed state tracking: Approaches from the distributed algorithms community (see, e.g., <ref> [Strom85, Johnson87, Strom88, Alvisi95, Elnozahy96] </ref>) have a relaxed model of communicating processes. Processes generate installation points only occasionally and independently. Messages are logged in an optimistic, non-forced manner.
Reference: [Weikum90] <author> Gerhard Weikum, Christof Hasse, Peter Broessler, Peter Muth: </author> <title> MultiLevel Recovery. </title> <booktitle> ACM PODS Symposium, </booktitle> <address> Nashville, </address> <year> 1990 </year>
Reference-contexts: The effects of the original transactions would have to be kept quasi-isolated at a higher level of abstraction taking into account application semantics <ref> [Lomet92, Weikum90] </ref>. 2. Redo/continue request execution: To make the servers nondeterministic behavior deterministically replayable, the server logs all database reads as well as writes. To ensure deterministic replay after the reply message is sent, the server must flush the log buffer before sending the reply. <p> Therefore, if any of these log records are still in the log buffer, they can be safely discarded without being written. This technique is similar to how atomic subtransactions are dealt with in the multilevel recovery methods of <ref> [Weikum90, Lomet92, Weikum93] </ref>, where some log records become irrelevant when subtransactions commit. However, should these log records be written to the stable log, they must appear in the log in their chronological order for correct recovery. There is no clear choice among our three options.
Reference: [Weikum93] <author> Gerhard Weikum, Christof Hasse: </author> <title> MultiLevel Transaction Management for Complex Objects: Implementation, Performance, Parallelism. </title> <journal> VLDB Journal Vol.2 No.4, </journal> <year> 1993 </year>
Reference-contexts: Therefore, if any of these log records are still in the log buffer, they can be safely discarded without being written. This technique is similar to how atomic subtransactions are dealt with in the multilevel recovery methods of <ref> [Weikum90, Lomet92, Weikum93] </ref>, where some log records become irrelevant when subtransactions commit. However, should these log records be written to the stable log, they must appear in the log in their chronological order for correct recovery. There is no clear choice among our three options.
References-found: 29

