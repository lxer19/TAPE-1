URL: http://www.eecs.umich.edu/~avigupta/papers/dac97.ps
Refering-URL: http://www.eecs.umich.edu/~avigupta/professional.html
Root-URL: http://www.eecs.umich.edu
Title: CLIP: An Optimizing Layout Generator for Two-Dimensional CMOS Cells  
Author: Avaneendra Gupta and John P. Hayes 
Keyword: Topic Area: Module Generation and Compaction (Topic T3.3) Keywords: Leaf cell synthesis, module generation, layout optimization, two-dimensional layout, diffusion sharing, transistor chains, circuit clustering, CMOS networks  
Address: 1301 Beal Ave., Ann Arbor, MI 48109, U.S.A.  2200 Mission College Blvd., Santa Clara, CA 95052, U.S.A.  
Affiliation: Advanced Computer Architecture Laboratory Department of Electrical Engineering and Computer Science The University of Michigan  Design Technology Division Intel Corporation  
Note: Submitted to the 34th Design Automation Conference, 1997.  Principal author Presenter: Avaneendra Gupta  This research project was sponsored by a grant from Intel Corporation.  
Email: avigupta@eecs.umich.edu, jhayes@eecs.umich.edu  E-Mail: avigupta@eecs.umich.edu  
Phone: Phone: (313) 913-4314 Fax: (313) 763-4617  
Abstract: All appropriate organizational approvals for the publication of this paper have been obtained. If accepted, the author(s) will prepare the final manuscript in time for inclusion in the Conference proceedings and will present the paper at the Conference. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. G. Baltus and J. Allen, </author> <title> SOLO: A Generator of Efficient Layouts From Optimized MOS Circuit Schematics, </title> <booktitle> Proc. 25th Design Automation Conf., </booktitle> <pages> pp. 445-452, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: Even in the constrained 1-D style, fe w existing techniques efficiently solve the problem of both width and height minimization <ref> [1, 4, 7, 13, 17, 18] </ref>. Man y of these techniques, such as SOLO [1] and GENAC [17], use heuristics that perform a limited search of the possible transistor placements and their orientations. Others such as LiB [13] consider height reduction after transistor placement has been determined. <p> Even in the constrained 1-D style, fe w existing techniques efficiently solve the problem of both width and height minimization [1, 4, 7, 13, 17, 18]. Man y of these techniques, such as SOLO <ref> [1] </ref> and GENAC [17], use heuristics that perform a limited search of the possible transistor placements and their orientations. Others such as LiB [13] consider height reduction after transistor placement has been determined. <p> S X <ref> [p, 1, r] </ref> = 1 " r rows (7) p pairs S X [p, s 1, r] S X [p, s, r] " r rows, (8) p pairs p pairs s slots 3. <p> right. merged [p i , p j ] = or -Xor [p i , o i ] and Xor [p j , o j ]: " o i , o j orients such that share [p i , o i , p j , o j ]- (10) = Xor <ref> [p i , 1] </ref> and or -Xor [p j , o j ]: " o j orients such that share [p i , 1, p j , o j ]- or Xor [p i , 2] and or -Xor [p j , o j ]: " o j orients such that <p> j , o j ]: " o i , o j orients such that share [p i , o i , p j , o j ]- (10) = Xor [p i , 1] and or -Xor [p j , o j ]: " o j orients such that share <ref> [p i , 1, p j , o j ] </ref>- or Xor [p i , 2] and or -Xor [p j , o j ]: " o j orients such that share [p i , 2, p j , o j ]- or Xor [p i , 3] and or -Xor <p> Figure 2 illustrates the diffusion sharing constraints in the CLIP-W model using a 2-to-1 multiple xer circuit consisting of seven P/N pairs. All possible pairwise dif fusion abutments, represented by the array share, are shown in Fig. 2 b. Figure 2c lists the diffusion sharing constraints for nogap <ref> [1, 1] </ref> for a single ro w placement (s = r = 1). 4. Inter-row connectivity: These constraints, identical to those in [8], determine the nets that must be routed from one P/N row to another, contributing to the overall 2-D cell width. <p> b and t) or (y and b and t) (13) s 2 1 b 5 p 3 p 5 p 1 6 Fig. 2 : (a) A 2-to-1 multiplexer, (b) its array share [p i , o i , p j , o j ], and (c) constraints for nogap <ref> [1, 1] </ref> share [p i , o i , p j, o j ] Pair p i Orient o i Pair p j Orient o j p 1 3 2 p 2 p 6 p 7 2 4 p 2 3 p 1 p 6 2 p 3 1 p 4 <p> 7 2 4 p 2 3 p 1 p 6 2 p 3 1 p 4 3 p 4 2 p 2 p 6 4 p 5 1 p 6 3 p 6 3 2 p 1 p 4 p 5 2 4 p 7 3 p 1 1 nogap <ref> [1, 1] </ref> = X [p 1 , 1, 1] and ( (X [p 2 , 2, 1] and merged [p 1 , p 2 ]) or (X [p 4 , 2, 1] and merged [p 1 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 1 <p> 2 3 p 1 p 6 2 p 3 1 p 4 3 p 4 2 p 2 p 6 4 p 5 1 p 6 3 p 6 3 2 p 1 p 4 p 5 2 4 p 7 3 p 1 1 nogap [1, 1] = X <ref> [p 1 , 1, 1] </ref> and ( (X [p 2 , 2, 1] and merged [p 1 , p 2 ]) or (X [p 4 , 2, 1] and merged [p 1 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 1 , p 6 ]) <p> 3 1 p 4 3 p 4 2 p 2 p 6 4 p 5 1 p 6 3 p 6 3 2 p 1 p 4 p 5 2 4 p 7 3 p 1 1 nogap [1, 1] = X [p 1 , 1, 1] and ( (X <ref> [p 2 , 2, 1] </ref> and merged [p 1 , p 2 ]) or (X [p 4 , 2, 1] and merged [p 1 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 1 , p 6 ]) or (X [p 7 , 2, 1] and <p> 1 p 6 3 p 6 3 2 p 1 p 4 p 5 2 4 p 7 3 p 1 1 nogap [1, 1] = X [p 1 , 1, 1] and ( (X [p 2 , 2, 1] and merged [p 1 , p 2 ]) or (X <ref> [p 4 , 2, 1] </ref> and merged [p 1 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 1 , p 6 ]) or (X [p 7 , 2, 1] and merged [p 1 , p 7 ]) ) or X [p 2 , 1, 1] <p> 4 p 7 3 p 1 1 nogap [1, 1] = X [p 1 , 1, 1] and ( (X [p 2 , 2, 1] and merged [p 1 , p 2 ]) or (X [p 4 , 2, 1] and merged [p 1 , p 4 ]) or (X <ref> [p 6 , 2, 1] </ref> and merged [p 1 , p 6 ]) or (X [p 7 , 2, 1] and merged [p 1 , p 7 ]) ) or X [p 2 , 1, 1] and ( (X [p 1 , 2, 1] and merged [p 2 , p 1 <p> 1, 1] and ( (X [p 2 , 2, 1] and merged [p 1 , p 2 ]) or (X [p 4 , 2, 1] and merged [p 1 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 1 , p 6 ]) or (X <ref> [p 7 , 2, 1] </ref> and merged [p 1 , p 7 ]) ) or X [p 2 , 1, 1] and ( (X [p 1 , 2, 1] and merged [p 2 , p 1 ]) or (X [p 4 , 2, 1] and merged [p 2 , p 4 <p> 2 ]) or (X [p 4 , 2, 1] and merged [p 1 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 1 , p 6 ]) or (X [p 7 , 2, 1] and merged [p 1 , p 7 ]) ) or X <ref> [p 2 , 1, 1] </ref> and ( (X [p 1 , 2, 1] and merged [p 2 , p 1 ]) or (X [p 4 , 2, 1] and merged [p 2 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 2 , p 6 ]) <p> 1] and merged [p 1 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 1 , p 6 ]) or (X [p 7 , 2, 1] and merged [p 1 , p 7 ]) ) or X [p 2 , 1, 1] and ( (X <ref> [p 1 , 2, 1] </ref> and merged [p 2 , p 1 ]) or (X [p 4 , 2, 1] and merged [p 2 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 2 , p 6 ]) ) or X [p 3 , 2, 1] <p> 1] and merged [p 1 , p 6 ]) or (X [p 7 , 2, 1] and merged [p 1 , p 7 ]) ) or X [p 2 , 1, 1] and ( (X [p 1 , 2, 1] and merged [p 2 , p 1 ]) or (X <ref> [p 4 , 2, 1] </ref> and merged [p 2 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 2 , p 6 ]) ) or X [p 3 , 2, 1] and ( (X [p 4 , 2, 1] and merged [p 3 , p 4 <p> 1] and merged [p 1 , p 7 ]) ) or X [p 2 , 1, 1] and ( (X [p 1 , 2, 1] and merged [p 2 , p 1 ]) or (X [p 4 , 2, 1] and merged [p 2 , p 4 ]) or (X <ref> [p 6 , 2, 1] </ref> and merged [p 2 , p 6 ]) ) or X [p 3 , 2, 1] and ( (X [p 4 , 2, 1] and merged [p 3 , p 4 ]) ) or X [p 4 , 2, 1] and ( (X [p 2 , <p> 1] and ( (X [p 1 , 2, 1] and merged [p 2 , p 1 ]) or (X [p 4 , 2, 1] and merged [p 2 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 2 , p 6 ]) ) or X <ref> [p 3 , 2, 1] </ref> and ( (X [p 4 , 2, 1] and merged [p 3 , p 4 ]) ) or X [p 4 , 2, 1] and ( (X [p 2 , 2, 1] and merged [p 4 , p 2 ]) or (X [p 3 , 2, <p> 1] and merged [p 2 , p 1 ]) or (X <ref> [p 4 , 2, 1] </ref> and merged [p 2 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 2 , p 6 ]) ) or X [p 3 , 2, 1] and ( (X [p 4 , 2, 1] and merged [p 3 , p 4 ]) ) or X [p 4 , 2, 1] and ( (X [p 2 , 2, 1] and merged [p 4 , p 2 ]) or (X [p 3 , 2, 1] and merged [p 4 , p 3 <p> and merged [p 2 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 2 , p 6 ]) ) or X [p 3 , 2, 1] and ( (X <ref> [p 4 , 2, 1] </ref> and merged [p 3 , p 4 ]) ) or X [p 4 , 2, 1] and ( (X [p 2 , 2, 1] and merged [p 4 , p 2 ]) or (X [p 3 , 2, 1] and merged [p 4 , p 3 ]) or (X [p 6 , 2, 1] and merged [p 4 , p 6 ]) <p> or (X [p 6 , 2, 1] and merged [p 2 , p 6 ]) ) or X [p 3 , 2, 1] and ( (X [p 4 , 2, 1] and merged [p 3 , p 4 ]) ) or X [p 4 , 2, 1] and ( (X <ref> [p 2 , 2, 1] </ref> and merged [p 4 , p 2 ]) or (X [p 3 , 2, 1] and merged [p 4 , p 3 ]) or (X [p 6 , 2, 1] and merged [p 4 , p 6 ]) ) or X [p 5 , 2, 1] <p> ) or X <ref> [p 3 , 2, 1] </ref> and ( (X [p 4 , 2, 1] and merged [p 3 , p 4 ]) ) or X [p 4 , 2, 1] and ( (X [p 2 , 2, 1] and merged [p 4 , p 2 ]) or (X [p 3 , 2, 1] and merged [p 4 , p 3 ]) or (X [p 6 , 2, 1] and merged [p 4 , p 6 ]) ) or X [p 5 , 2, 1] and ( (X [p 6 , 2, 1] and merged [p 5 , p 6 <p> 1] and merged [p 3 , p 4 ]) ) or X [p 4 , 2, 1] and ( (X [p 2 , 2, 1] and merged [p 4 , p 2 ]) or (X [p 3 , 2, 1] and merged [p 4 , p 3 ]) or (X <ref> [p 6 , 2, 1] </ref> and merged [p 4 , p 6 ]) ) or X [p 5 , 2, 1] and ( (X [p 6 , 2, 1] and merged [p 5 , p 6 ]) ) or X [p 6 , 2, 1] and ( (X [p 1 , <p> 1] and ( (X [p 2 , 2, 1] and merged [p 4 , p 2 ]) or (X [p 3 , 2, 1] and merged [p 4 , p 3 ]) or (X [p 6 , 2, 1] and merged [p 4 , p 6 ]) ) or X <ref> [p 5 , 2, 1] </ref> and ( (X [p 6 , 2, 1] and merged [p 5 , p 6 ]) ) or X [p 6 , 2, 1] and ( (X [p 1 , 2, 1] and merged [p 6 , p 1 ]) or (X [p 2 , 2, <p> 1] and merged [p 4 , p 2 ]) or (X [p 3 , 2, 1] and merged [p 4 , p 3 ]) or (X <ref> [p 6 , 2, 1] </ref> and merged [p 4 , p 6 ]) ) or X [p 5 , 2, 1] and ( (X [p 6 , 2, 1] and merged [p 5 , p 6 ]) ) or X [p 6 , 2, 1] and ( (X [p 1 , 2, 1] and merged [p 6 , p 1 ]) or (X [p 2 , 2, 1] and merged [p 6 , p 2 <p> and merged [p 4 , p 3 ]) or (X <ref> [p 6 , 2, 1] </ref> and merged [p 4 , p 6 ]) ) or X [p 5 , 2, 1] and ( (X [p 6 , 2, 1] and merged [p 5 , p 6 ]) ) or X [p 6 , 2, 1] and ( (X [p 1 , 2, 1] and merged [p 6 , p 1 ]) or (X [p 2 , 2, 1] and merged [p 6 , p 2 ]) or (X [p 4 , 2, 1] and merged [p 6 , p 4 ]) <p> or (X [p 6 , 2, 1] and merged [p 4 , p 6 ]) ) or X [p 5 , 2, 1] and ( (X [p 6 , 2, 1] and merged [p 5 , p 6 ]) ) or X [p 6 , 2, 1] and ( (X <ref> [p 1 , 2, 1] </ref> and merged [p 6 , p 1 ]) or (X [p 2 , 2, 1] and merged [p 6 , p 2 ]) or (X [p 4 , 2, 1] and merged [p 6 , p 4 ]) or (X [p 5 , 2, 1] and <p> ) or X [p 5 , 2, 1] and ( (X [p 6 , 2, 1] and merged [p 5 , p 6 ]) ) or X [p 6 , 2, 1] and ( (X [p 1 , 2, 1] and merged [p 6 , p 1 ]) or (X <ref> [p 2 , 2, 1] </ref> and merged [p 6 , p 2 ]) or (X [p 4 , 2, 1] and merged [p 6 , p 4 ]) or (X [p 5 , 2, 1] and merged [p 6 , p 5 ]) ) or X [p 7 , 2, 1] <p> 1] and merged [p 5 , p 6 ]) ) or X [p 6 , 2, 1] and ( (X [p 1 , 2, 1] and merged [p 6 , p 1 ]) or (X [p 2 , 2, 1] and merged [p 6 , p 2 ]) or (X <ref> [p 4 , 2, 1] </ref> and merged [p 6 , p 4 ]) or (X [p 5 , 2, 1] and merged [p 6 , p 5 ]) ) or X [p 7 , 2, 1] and ( (X [p 1 , 2, 1] and merged [p 7 , p 1 <p> 2, 1] and ( (X [p 1 , 2, 1] and merged [p 6 , p 1 ]) or (X [p 2 , 2, 1] and merged [p 6 , p 2 ]) or (X [p 4 , 2, 1] and merged [p 6 , p 4 ]) or (X <ref> [p 5 , 2, 1] </ref> and merged [p 6 , p 5 ]) ) or X [p 7 , 2, 1] and ( (X [p 1 , 2, 1] and merged [p 7 , p 1 ]) ) merged [p 1 , p 2 ] = merged [p 1 , p <p> 1 ]) or (X [p 2 , 2, 1] and merged [p 6 , p 2 ]) or (X [p 4 , 2, 1] and merged [p 6 , p 4 ]) or (X [p 5 , 2, 1] and merged [p 6 , p 5 ]) ) or X <ref> [p 7 , 2, 1] </ref> and ( (X [p 1 , 2, 1] and merged [p 7 , p 1 ]) ) merged [p 1 , p 2 ] = merged [p 1 , p 4 ] = merged [p 1 , p 6 ] = merged [p 1 , p <p> 1] and merged [p 6 , p 2 ]) or (X [p 4 , 2, 1] and merged [p 6 , p 4 ]) or (X [p 5 , 2, 1] and merged [p 6 , p 5 ]) ) or X [p 7 , 2, 1] and ( (X <ref> [p 1 , 2, 1] </ref> and merged [p 7 , p 1 ]) ) merged [p 1 , p 2 ] = merged [p 1 , p 4 ] = merged [p 1 , p 6 ] = merged [p 1 , p 7 ] = merged [p 2 , p <p> Xor [p 6 , 2] Xor [p 4 , 3] and Xor [p 2 , 2] Xor [p 4 , 3] and Xor [p 6 , 2] Xor [p 6 , 3] and Xor [p 1 , 2] Xor [p 6 , 3] and Xor [p 4 , 2] Xor <ref> [p 7 , 1] </ref> and Xor [p 1 , 3] + Xor [p 7 , 3] and Xor [p 1 , 1] (b) 7 As shown in the appendix, this equation can be linearized without introducing intermediate variables. <p> 4 , 3] and Xor [p 6 , 2] Xor [p 6 , 3] and Xor [p 1 , 2] Xor [p 6 , 3] and Xor [p 4 , 2] Xor [p 7 , 1] and Xor [p 1 , 3] + Xor [p 7 , 3] and Xor <ref> [p 1 , 1] </ref> (b) 7 As shown in the appendix, this equation can be linearized without introducing intermediate variables. Experimental results: Table 3 presents results of applying CLIP-W to a few representative circuits from the literature for optimum-width layouts in one through four P/N ro ws. <p> Numbers in brackets refer to the cell width obtained with and-stacking (HCLIP), when different from the optimum value for the original circuit. CPU time (secs) Cell width # Circuit No. of trans. No. of rows Original cct. With stacking CLIP-W 1 Virtuoso [3] 1. 2-input parity circuit (Xor) <ref> [1] </ref> 1 3 0.01 0.05 0.01 0.03 5 3 5 4 2. <p> Let span <ref> [n, 1, r] </ref> denote the presence of net n in the first column of row r. <p> Thus, if c represents a left diffusion column (c = 1, 4, 7, ...), net [n, c, r] is given by: net [n, c, r] = X [p, (c + 2) / 3, r] and ( Nsrc [p, n] and (Xor <ref> [p, 1] </ref> or Xor [p, 3]) " p pairs (21) or Ndrn [p, n] and (Xor [p, 2] or Xor [p, 4]) or Psrc [p, n] and (Xor [p, 1] or Xor [p, 2]) or Pdrn [p, n] and (Xor [p, 3] or Xor [p, 4])) The value of net [n, <p> given by: net [n, c, r] = X [p, (c + 2) / 3, r] and ( Nsrc [p, n] and (Xor <ref> [p, 1] </ref> or Xor [p, 3]) " p pairs (21) or Ndrn [p, n] and (Xor [p, 2] or Xor [p, 4]) or Psrc [p, n] and (Xor [p, 1] or Xor [p, 2]) or Pdrn [p, n] and (Xor [p, 3] or Xor [p, 4])) The value of net [n, c, r] is similarly defined for columns that represent the right diffusions (c = 3, 6, 9, ...). <p> However, a few special cases, illustrated in Fig. 4, need to be considered to accommodate the presence or absence of diffusion gaps. 12 Consider the net a in columns 1 and 3. Since columns 1, 2, and 3 need a track to connect net a, span <ref> [a, 1, r] </ref> = span [a, 2, r] = span [a, 3, r] = 1. Also, since columns 3 and 4 are connected by diffusion sharing, we set span [a, 4, r] = 1. However, net b appears only in columns 9 and 10, which are connected via diffusion sharing.
Reference: [2] <author> P. Barth, </author> <title> Logic Based 0-1 Constraint Programming, </title> <publisher> Kluwer, </publisher> <address> Boston, </address> <year> 1995. </year>
Reference-contexts: such that share [p i , o i , p j , o j ]- (10) = Xor [p i , 1] and or -Xor [p j , o j ]: " o j orients such that share [p i , 1, p j , o j ]- or Xor <ref> [p i , 2] </ref> and or -Xor [p j , o j ]: " o j orients such that share [p i , 2, p j , o j ]- or Xor [p i , 3] and or -Xor [p j , o j ]: " o j orients such that <p> , 1] and or -Xor [p j , o j ]: " o j orients such that share [p i , 1, p j , o j ]- or Xor [p i , 2] and or -Xor [p j , o j ]: " o j orients such that share <ref> [p i , 2, p j , o j ] </ref>- or Xor [p i , 3] and or -Xor [p j , o j ]: " o j orients such that share [p i , 3, p j , o j ]- or Xor [p i , 4] and or -Xor <p> 3 1 p 4 3 p 4 2 p 2 p 6 4 p 5 1 p 6 3 p 6 3 2 p 1 p 4 p 5 2 4 p 7 3 p 1 1 nogap [1, 1] = X [p 1 , 1, 1] and ( (X <ref> [p 2 , 2, 1] </ref> and merged [p 1 , p 2 ]) or (X [p 4 , 2, 1] and merged [p 1 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 1 , p 6 ]) or (X [p 7 , 2, 1] and <p> 1 p 6 3 p 6 3 2 p 1 p 4 p 5 2 4 p 7 3 p 1 1 nogap [1, 1] = X [p 1 , 1, 1] and ( (X [p 2 , 2, 1] and merged [p 1 , p 2 ]) or (X <ref> [p 4 , 2, 1] </ref> and merged [p 1 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 1 , p 6 ]) or (X [p 7 , 2, 1] and merged [p 1 , p 7 ]) ) or X [p 2 , 1, 1] <p> 4 p 7 3 p 1 1 nogap [1, 1] = X [p 1 , 1, 1] and ( (X [p 2 , 2, 1] and merged [p 1 , p 2 ]) or (X [p 4 , 2, 1] and merged [p 1 , p 4 ]) or (X <ref> [p 6 , 2, 1] </ref> and merged [p 1 , p 6 ]) or (X [p 7 , 2, 1] and merged [p 1 , p 7 ]) ) or X [p 2 , 1, 1] and ( (X [p 1 , 2, 1] and merged [p 2 , p 1 <p> 1, 1] and ( (X [p 2 , 2, 1] and merged [p 1 , p 2 ]) or (X [p 4 , 2, 1] and merged [p 1 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 1 , p 6 ]) or (X <ref> [p 7 , 2, 1] </ref> and merged [p 1 , p 7 ]) ) or X [p 2 , 1, 1] and ( (X [p 1 , 2, 1] and merged [p 2 , p 1 ]) or (X [p 4 , 2, 1] and merged [p 2 , p 4 <p> 1] and merged [p 1 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 1 , p 6 ]) or (X [p 7 , 2, 1] and merged [p 1 , p 7 ]) ) or X [p 2 , 1, 1] and ( (X <ref> [p 1 , 2, 1] </ref> and merged [p 2 , p 1 ]) or (X [p 4 , 2, 1] and merged [p 2 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 2 , p 6 ]) ) or X [p 3 , 2, 1] <p> 1] and merged [p 1 , p 6 ]) or (X [p 7 , 2, 1] and merged [p 1 , p 7 ]) ) or X [p 2 , 1, 1] and ( (X [p 1 , 2, 1] and merged [p 2 , p 1 ]) or (X <ref> [p 4 , 2, 1] </ref> and merged [p 2 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 2 , p 6 ]) ) or X [p 3 , 2, 1] and ( (X [p 4 , 2, 1] and merged [p 3 , p 4 <p> 1] and merged [p 1 , p 7 ]) ) or X [p 2 , 1, 1] and ( (X [p 1 , 2, 1] and merged [p 2 , p 1 ]) or (X [p 4 , 2, 1] and merged [p 2 , p 4 ]) or (X <ref> [p 6 , 2, 1] </ref> and merged [p 2 , p 6 ]) ) or X [p 3 , 2, 1] and ( (X [p 4 , 2, 1] and merged [p 3 , p 4 ]) ) or X [p 4 , 2, 1] and ( (X [p 2 , <p> 1] and ( (X [p 1 , 2, 1] and merged [p 2 , p 1 ]) or (X [p 4 , 2, 1] and merged [p 2 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 2 , p 6 ]) ) or X <ref> [p 3 , 2, 1] </ref> and ( (X [p 4 , 2, 1] and merged [p 3 , p 4 ]) ) or X [p 4 , 2, 1] and ( (X [p 2 , 2, 1] and merged [p 4 , p 2 ]) or (X [p 3 , 2, <p> 1] and merged [p 2 , p 1 ]) or (X <ref> [p 4 , 2, 1] </ref> and merged [p 2 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 2 , p 6 ]) ) or X [p 3 , 2, 1] and ( (X [p 4 , 2, 1] and merged [p 3 , p 4 ]) ) or X [p 4 , 2, 1] and ( (X [p 2 , 2, 1] and merged [p 4 , p 2 ]) or (X [p 3 , 2, 1] and merged [p 4 , p 3 <p> and merged [p 2 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 2 , p 6 ]) ) or X [p 3 , 2, 1] and ( (X <ref> [p 4 , 2, 1] </ref> and merged [p 3 , p 4 ]) ) or X [p 4 , 2, 1] and ( (X [p 2 , 2, 1] and merged [p 4 , p 2 ]) or (X [p 3 , 2, 1] and merged [p 4 , p 3 ]) or (X [p 6 , 2, 1] and merged [p 4 , p 6 ]) <p> or (X [p 6 , 2, 1] and merged [p 2 , p 6 ]) ) or X [p 3 , 2, 1] and ( (X [p 4 , 2, 1] and merged [p 3 , p 4 ]) ) or X [p 4 , 2, 1] and ( (X <ref> [p 2 , 2, 1] </ref> and merged [p 4 , p 2 ]) or (X [p 3 , 2, 1] and merged [p 4 , p 3 ]) or (X [p 6 , 2, 1] and merged [p 4 , p 6 ]) ) or X [p 5 , 2, 1] <p> ) or X <ref> [p 3 , 2, 1] </ref> and ( (X [p 4 , 2, 1] and merged [p 3 , p 4 ]) ) or X [p 4 , 2, 1] and ( (X [p 2 , 2, 1] and merged [p 4 , p 2 ]) or (X [p 3 , 2, 1] and merged [p 4 , p 3 ]) or (X [p 6 , 2, 1] and merged [p 4 , p 6 ]) ) or X [p 5 , 2, 1] and ( (X [p 6 , 2, 1] and merged [p 5 , p 6 <p> 1] and merged [p 3 , p 4 ]) ) or X [p 4 , 2, 1] and ( (X [p 2 , 2, 1] and merged [p 4 , p 2 ]) or (X [p 3 , 2, 1] and merged [p 4 , p 3 ]) or (X <ref> [p 6 , 2, 1] </ref> and merged [p 4 , p 6 ]) ) or X [p 5 , 2, 1] and ( (X [p 6 , 2, 1] and merged [p 5 , p 6 ]) ) or X [p 6 , 2, 1] and ( (X [p 1 , <p> 1] and ( (X [p 2 , 2, 1] and merged [p 4 , p 2 ]) or (X [p 3 , 2, 1] and merged [p 4 , p 3 ]) or (X [p 6 , 2, 1] and merged [p 4 , p 6 ]) ) or X <ref> [p 5 , 2, 1] </ref> and ( (X [p 6 , 2, 1] and merged [p 5 , p 6 ]) ) or X [p 6 , 2, 1] and ( (X [p 1 , 2, 1] and merged [p 6 , p 1 ]) or (X [p 2 , 2, <p> 1] and merged [p 4 , p 2 ]) or (X [p 3 , 2, 1] and merged [p 4 , p 3 ]) or (X <ref> [p 6 , 2, 1] </ref> and merged [p 4 , p 6 ]) ) or X [p 5 , 2, 1] and ( (X [p 6 , 2, 1] and merged [p 5 , p 6 ]) ) or X [p 6 , 2, 1] and ( (X [p 1 , 2, 1] and merged [p 6 , p 1 ]) or (X [p 2 , 2, 1] and merged [p 6 , p 2 <p> and merged [p 4 , p 3 ]) or (X <ref> [p 6 , 2, 1] </ref> and merged [p 4 , p 6 ]) ) or X [p 5 , 2, 1] and ( (X [p 6 , 2, 1] and merged [p 5 , p 6 ]) ) or X [p 6 , 2, 1] and ( (X [p 1 , 2, 1] and merged [p 6 , p 1 ]) or (X [p 2 , 2, 1] and merged [p 6 , p 2 ]) or (X [p 4 , 2, 1] and merged [p 6 , p 4 ]) <p> or (X [p 6 , 2, 1] and merged [p 4 , p 6 ]) ) or X [p 5 , 2, 1] and ( (X [p 6 , 2, 1] and merged [p 5 , p 6 ]) ) or X [p 6 , 2, 1] and ( (X <ref> [p 1 , 2, 1] </ref> and merged [p 6 , p 1 ]) or (X [p 2 , 2, 1] and merged [p 6 , p 2 ]) or (X [p 4 , 2, 1] and merged [p 6 , p 4 ]) or (X [p 5 , 2, 1] and <p> ) or X [p 5 , 2, 1] and ( (X [p 6 , 2, 1] and merged [p 5 , p 6 ]) ) or X [p 6 , 2, 1] and ( (X [p 1 , 2, 1] and merged [p 6 , p 1 ]) or (X <ref> [p 2 , 2, 1] </ref> and merged [p 6 , p 2 ]) or (X [p 4 , 2, 1] and merged [p 6 , p 4 ]) or (X [p 5 , 2, 1] and merged [p 6 , p 5 ]) ) or X [p 7 , 2, 1] <p> 1] and merged [p 5 , p 6 ]) ) or X [p 6 , 2, 1] and ( (X [p 1 , 2, 1] and merged [p 6 , p 1 ]) or (X [p 2 , 2, 1] and merged [p 6 , p 2 ]) or (X <ref> [p 4 , 2, 1] </ref> and merged [p 6 , p 4 ]) or (X [p 5 , 2, 1] and merged [p 6 , p 5 ]) ) or X [p 7 , 2, 1] and ( (X [p 1 , 2, 1] and merged [p 7 , p 1 <p> 2, 1] and ( (X [p 1 , 2, 1] and merged [p 6 , p 1 ]) or (X [p 2 , 2, 1] and merged [p 6 , p 2 ]) or (X [p 4 , 2, 1] and merged [p 6 , p 4 ]) or (X <ref> [p 5 , 2, 1] </ref> and merged [p 6 , p 5 ]) ) or X [p 7 , 2, 1] and ( (X [p 1 , 2, 1] and merged [p 7 , p 1 ]) ) merged [p 1 , p 2 ] = merged [p 1 , p <p> 1 ]) or (X [p 2 , 2, 1] and merged [p 6 , p 2 ]) or (X [p 4 , 2, 1] and merged [p 6 , p 4 ]) or (X [p 5 , 2, 1] and merged [p 6 , p 5 ]) ) or X <ref> [p 7 , 2, 1] </ref> and ( (X [p 1 , 2, 1] and merged [p 7 , p 1 ]) ) merged [p 1 , p 2 ] = merged [p 1 , p 4 ] = merged [p 1 , p 6 ] = merged [p 1 , p <p> 1] and merged [p 6 , p 2 ]) or (X [p 4 , 2, 1] and merged [p 6 , p 4 ]) or (X [p 5 , 2, 1] and merged [p 6 , p 5 ]) ) or X [p 7 , 2, 1] and ( (X <ref> [p 1 , 2, 1] </ref> and merged [p 7 , p 1 ]) ) merged [p 1 , p 2 ] = merged [p 1 , p 4 ] = merged [p 1 , p 6 ] = merged [p 1 , p 7 ] = merged [p 2 , p <p> 6 ] = merged [p 6 , p 1 ] = merged [p 6 , p 2 ] = merged [p 6 , p 4 ] = merged [p 6 , p 5 ] = merged [p 7 , p 1 ] = Xor [p 1 , 3] and Xor <ref> [p 2 , 2] </ref> Xor [p 1 , 3] and Xor [p 6 , 2] Xor [p 2 , 3] and Xor [p 1 , 2] Xor [p 2 , 3] and Xor [p 6 , 2] Xor [p 4 , 3] and Xor [p 2 , 2] Xor [p 4 <p> merged [p 6 , p 2 ] = merged [p 6 , p 4 ] = merged [p 6 , p 5 ] = merged [p 7 , p 1 ] = Xor [p 1 , 3] and Xor [p 2 , 2] Xor [p 1 , 3] and Xor <ref> [p 6 , 2] </ref> Xor [p 2 , 3] and Xor [p 1 , 2] Xor [p 2 , 3] and Xor [p 6 , 2] Xor [p 4 , 3] and Xor [p 2 , 2] Xor [p 4 , 3] and Xor [p 6 , 2] Xor [p 6 <p> , p 4 ] = merged [p 6 , p 5 ] = merged [p 7 , p 1 ] = Xor [p 1 , 3] and Xor [p 2 , 2] Xor [p 1 , 3] and Xor [p 6 , 2] Xor [p 2 , 3] and Xor <ref> [p 1 , 2] </ref> Xor [p 2 , 3] and Xor [p 6 , 2] Xor [p 4 , 3] and Xor [p 2 , 2] Xor [p 4 , 3] and Xor [p 6 , 2] Xor [p 6 , 3] and Xor [p 1 , 2] Xor [p 6 <p> ] = merged [p 7 , p 1 ] = Xor [p 1 , 3] and Xor [p 2 , 2] Xor [p 1 , 3] and Xor <ref> [p 6 , 2] </ref> Xor [p 2 , 3] and Xor [p 1 , 2] Xor [p 2 , 3] and Xor [p 6 , 2] Xor [p 4 , 3] and Xor [p 2 , 2] Xor [p 4 , 3] and Xor [p 6 , 2] Xor [p 6 , 3] and Xor [p 1 , 2] Xor [p 6 , 3] and Xor [p 4 , 2] Xor [p 7 <p> [p 1 , 3] and Xor <ref> [p 2 , 2] </ref> Xor [p 1 , 3] and Xor [p 6 , 2] Xor [p 2 , 3] and Xor [p 1 , 2] Xor [p 2 , 3] and Xor [p 6 , 2] Xor [p 4 , 3] and Xor [p 2 , 2] Xor [p 4 , 3] and Xor [p 6 , 2] Xor [p 6 , 3] and Xor [p 1 , 2] Xor [p 6 , 3] and Xor [p 4 , 2] Xor [p 7 , 1] and Xor [p 1 , 3] + Xor [p <p> [p 1 , 3] and Xor <ref> [p 6 , 2] </ref> Xor [p 2 , 3] and Xor [p 1 , 2] Xor [p 2 , 3] and Xor [p 6 , 2] Xor [p 4 , 3] and Xor [p 2 , 2] Xor [p 4 , 3] and Xor [p 6 , 2] Xor [p 6 , 3] and Xor [p 1 , 2] Xor [p 6 , 3] and Xor [p 4 , 2] Xor [p 7 , 1] and Xor [p 1 , 3] + Xor [p 7 , 3] and Xor [p 1 , 1] (b) 7 <p> [p 2 , 3] and Xor <ref> [p 1 , 2] </ref> Xor [p 2 , 3] and Xor [p 6 , 2] Xor [p 4 , 3] and Xor [p 2 , 2] Xor [p 4 , 3] and Xor [p 6 , 2] Xor [p 6 , 3] and Xor [p 1 , 2] Xor [p 6 , 3] and Xor [p 4 , 2] Xor [p 7 , 1] and Xor [p 1 , 3] + Xor [p 7 , 3] and Xor [p 1 , 1] (b) 7 As shown in the appendix, this equation can be linearized without <p> [p 2 , 3] and Xor [p 6 , 2] Xor [p 4 , 3] and Xor [p 2 , 2] Xor [p 4 , 3] and Xor [p 6 , 2] Xor [p 6 , 3] and Xor [p 1 , 2] Xor [p 6 , 3] and Xor <ref> [p 4 , 2] </ref> Xor [p 7 , 1] and Xor [p 1 , 3] + Xor [p 7 , 3] and Xor [p 1 , 1] (b) 7 As shown in the appendix, this equation can be linearized without introducing intermediate variables. <p> Although we evaluated several general-purpose ILP solvers, such as OSL [14] and CPLEX [5] and found their run time performance satisfactory, the specialized 0-1 solv er OPBDP <ref> [2] </ref> proved to be best suited to our optimization problem. Hence, the CLIP-W run times presented here have been obtained with the OPBDP solver. For most circuits, CLIP-W performs at least as well as the technique presented in [8]. <p> column (c = 1, 4, 7, ...), net [n, c, r] is given by: net [n, c, r] = X [p, (c + 2) / 3, r] and ( Nsrc [p, n] and (Xor [p, 1] or Xor [p, 3]) " p pairs (21) or Ndrn [p, n] and (Xor <ref> [p, 2] </ref> or Xor [p, 4]) or Psrc [p, n] and (Xor [p, 1] or Xor [p, 2]) or Pdrn [p, n] and (Xor [p, 3] or Xor [p, 4])) The value of net [n, c, r] is similarly defined for columns that represent the right diffusions (c = 3, 6, <p> c, r] = X [p, (c + 2) / 3, r] and ( Nsrc [p, n] and (Xor [p, 1] or Xor [p, 3]) " p pairs (21) or Ndrn [p, n] and (Xor <ref> [p, 2] </ref> or Xor [p, 4]) or Psrc [p, n] and (Xor [p, 1] or Xor [p, 2]) or Pdrn [p, n] and (Xor [p, 3] or Xor [p, 4])) The value of net [n, c, r] is similarly defined for columns that represent the right diffusions (c = 3, 6, 9, ...). <p> Since columns 1, 2, and 3 need a track to connect net a, span [a, 1, r] = span <ref> [a, 2, r] </ref> = span [a, 3, r] = 1. Also, since columns 3 and 4 are connected by diffusion sharing, we set span [a, 4, r] = 1. However, net b appears only in columns 9 and 10, which are connected via diffusion sharing.
Reference: [3] <author> Cadence Design Systems, Inc., </author> <title> Virtuoso Layout Synthesizer Tutorial and Reference, </title> <type> 1992-94. </type>
Reference-contexts: For example, Poirier [18] proposes a greedy transistor placement method that can handle constraints on the number of dif fusion rows or the shape of the cell boundary . A few layout tools, such as Virtuoso <ref> [3] </ref>, perform 2-D cell synthesis but use heuristics that, while being capable of handling cells with a few hundred transistors, yield non-optimal layouts even for small cells. Recently, integer linear programming (ILP) has been successfully emplo yed to generate minimum-width 2-D layouts of CMOS cells [8, 9]. <p> o j orients such that share [p i , 1, p j , o j ]- or Xor [p i , 2] and or -Xor [p j , o j ]: " o j orients such that share [p i , 2, p j , o j ]- or Xor <ref> [p i , 3] </ref> and or -Xor [p j , o j ]: " o j orients such that share [p i , 3, p j , o j ]- or Xor [p i , 4] and or -Xor [p j , o j ]: " o j orients such that <p> , 2] and or -Xor [p j , o j ]: " o j orients such that share [p i , 2, p j , o j ]- or Xor [p i , 3] and or -Xor [p j , o j ]: " o j orients such that share <ref> [p i , 3, p j , o j ] </ref>- or Xor [p i , 4] and or -Xor [p j , o j ]: " o j orients such that share [p i , 4, p j , o j ]- To prevent cyclic conditions in diffusion sharing, we include <p> = merged [p 5 , p 6 ] = merged [p 6 , p 1 ] = merged [p 6 , p 2 ] = merged [p 6 , p 4 ] = merged [p 6 , p 5 ] = merged [p 7 , p 1 ] = Xor <ref> [p 1 , 3] </ref> and Xor [p 2 , 2] Xor [p 1 , 3] and Xor [p 6 , 2] Xor [p 2 , 3] and Xor [p 1 , 2] Xor [p 2 , 3] and Xor [p 6 , 2] Xor [p 4 , 3] and Xor [p <p> 6 , p 1 ] = merged [p 6 , p 2 ] = merged [p 6 , p 4 ] = merged [p 6 , p 5 ] = merged [p 7 , p 1 ] = Xor <ref> [p 1 , 3] </ref> and Xor [p 2 , 2] Xor [p 1 , 3] and Xor [p 6 , 2] Xor [p 2 , 3] and Xor [p 1 , 2] Xor [p 2 , 3] and Xor [p 6 , 2] Xor [p 4 , 3] and Xor [p 2 , 2] Xor [p 4 , 3] and Xor [p <p> 2 ] = merged [p 6 , p 4 ] = merged [p 6 , p 5 ] = merged [p 7 , p 1 ] = Xor [p 1 , 3] and Xor [p 2 , 2] Xor [p 1 , 3] and Xor [p 6 , 2] Xor <ref> [p 2 , 3] </ref> and Xor [p 1 , 2] Xor [p 2 , 3] and Xor [p 6 , 2] Xor [p 4 , 3] and Xor [p 2 , 2] Xor [p 4 , 3] and Xor [p 6 , 2] Xor [p 6 , 3] and Xor [p <p> merged [p 6 , p 5 ] = merged [p 7 , p 1 ] = Xor [p 1 , 3] and Xor [p 2 , 2] Xor [p 1 , 3] and Xor [p 6 , 2] Xor <ref> [p 2 , 3] </ref> and Xor [p 1 , 2] Xor [p 2 , 3] and Xor [p 6 , 2] Xor [p 4 , 3] and Xor [p 2 , 2] Xor [p 4 , 3] and Xor [p 6 , 2] Xor [p 6 , 3] and Xor [p 1 , 2] Xor [p 6 , 3] and Xor [p <p> , p 1 ] = Xor [p 1 , 3] and Xor [p 2 , 2] Xor [p 1 , 3] and Xor [p 6 , 2] Xor [p 2 , 3] and Xor [p 1 , 2] Xor [p 2 , 3] and Xor [p 6 , 2] Xor <ref> [p 4 , 3] </ref> and Xor [p 2 , 2] Xor [p 4 , 3] and Xor [p 6 , 2] Xor [p 6 , 3] and Xor [p 1 , 2] Xor [p 6 , 3] and Xor [p 4 , 2] Xor [p 7 , 1] and Xor [p <p> Xor [p 2 , 2] Xor [p 1 , 3] and Xor [p 6 , 2] Xor [p 2 , 3] and Xor [p 1 , 2] Xor [p 2 , 3] and Xor [p 6 , 2] Xor <ref> [p 4 , 3] </ref> and Xor [p 2 , 2] Xor [p 4 , 3] and Xor [p 6 , 2] Xor [p 6 , 3] and Xor [p 1 , 2] Xor [p 6 , 3] and Xor [p 4 , 2] Xor [p 7 , 1] and Xor [p 1 , 3] + Xor [p 7 , 3] and Xor <p> Xor [p 6 , 2] Xor [p 2 , 3] and Xor [p 1 , 2] Xor [p 2 , 3] and Xor [p 6 , 2] Xor [p 4 , 3] and Xor [p 2 , 2] Xor [p 4 , 3] and Xor [p 6 , 2] Xor <ref> [p 6 , 3] </ref> and Xor [p 1 , 2] Xor [p 6 , 3] and Xor [p 4 , 2] Xor [p 7 , 1] and Xor [p 1 , 3] + Xor [p 7 , 3] and Xor [p 1 , 1] (b) 7 As shown in the appendix, <p> Xor [p 1 , 2] Xor [p 2 , 3] and Xor [p 6 , 2] Xor [p 4 , 3] and Xor [p 2 , 2] Xor [p 4 , 3] and Xor [p 6 , 2] Xor <ref> [p 6 , 3] </ref> and Xor [p 1 , 2] Xor [p 6 , 3] and Xor [p 4 , 2] Xor [p 7 , 1] and Xor [p 1 , 3] + Xor [p 7 , 3] and Xor [p 1 , 1] (b) 7 As shown in the appendix, this equation can be linearized without introducing intermediate variables. <p> [p 4 , 3] and Xor [p 2 , 2] Xor [p 4 , 3] and Xor [p 6 , 2] Xor [p 6 , 3] and Xor [p 1 , 2] Xor [p 6 , 3] and Xor [p 4 , 2] Xor [p 7 , 1] and Xor <ref> [p 1 , 3] </ref> + Xor [p 7 , 3] and Xor [p 1 , 1] (b) 7 As shown in the appendix, this equation can be linearized without introducing intermediate variables. <p> [p 2 , 2] Xor [p 4 , 3] and Xor [p 6 , 2] Xor [p 6 , 3] and Xor [p 1 , 2] Xor [p 6 , 3] and Xor [p 4 , 2] Xor [p 7 , 1] and Xor [p 1 , 3] + Xor <ref> [p 7 , 3] </ref> and Xor [p 1 , 1] (b) 7 As shown in the appendix, this equation can be linearized without introducing intermediate variables. <p> Numbers in brackets refer to the cell width obtained with and-stacking (HCLIP), when different from the optimum value for the original circuit. CPU time (secs) Cell width # Circuit No. of trans. No. of rows Original cct. With stacking CLIP-W 1 Virtuoso <ref> [3] </ref> 1. 2-input parity circuit (Xor) [1] 1 3 0.01 0.05 0.01 0.03 5 3 5 4 2. <p> Thus, if c represents a left diffusion column (c = 1, 4, 7, ...), net [n, c, r] is given by: net [n, c, r] = X [p, (c + 2) / 3, r] and ( Nsrc [p, n] and (Xor [p, 1] or Xor <ref> [p, 3] </ref>) " p pairs (21) or Ndrn [p, n] and (Xor [p, 2] or Xor [p, 4]) or Psrc [p, n] and (Xor [p, 1] or Xor [p, 2]) or Pdrn [p, n] and (Xor [p, 3] or Xor [p, 4])) The value of net [n, c, r] is similarly <p> / 3, r] and ( Nsrc [p, n] and (Xor [p, 1] or Xor <ref> [p, 3] </ref>) " p pairs (21) or Ndrn [p, n] and (Xor [p, 2] or Xor [p, 4]) or Psrc [p, n] and (Xor [p, 1] or Xor [p, 2]) or Pdrn [p, n] and (Xor [p, 3] or Xor [p, 4])) The value of net [n, c, r] is similarly defined for columns that represent the right diffusions (c = 3, 6, 9, ...). <p> Since columns 1, 2, and 3 need a track to connect net a, span [a, 1, r] = span [a, 2, r] = span <ref> [a, 3, r] </ref> = 1. Also, since columns 3 and 4 are connected by diffusion sharing, we set span [a, 4, r] = 1. However, net b appears only in columns 9 and 10, which are connected via diffusion sharing. <p> Numbers in brackets refer to the 2-D cell width or height obtained with and-stacking (HCLIP), when different from the optimum value for the original circuit, or when the optimum value is not known due to large solution times. CPU time (secs) 1 CLIP-WH layout 2 Virtuoso <ref> [3] </ref> layout Cct. No. of trans. No. of rows Original circuit With stacking Opt. cell width Opt. cell height Cell width Cell height First opt. sol. Final opt. sol. First opt. sol.
Reference: [4] <author> C. C. Chen and S. L. Chow, </author> <title> The Layout Synthesizer: An Automatic Netlist-to-Layout System, </title> <booktitle> Proc. 26th Design Automation Conf., </booktitle> <pages> pp. 232-238, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Even in the constrained 1-D style, fe w existing techniques efficiently solve the problem of both width and height minimization <ref> [1, 4, 7, 13, 17, 18] </ref>. Man y of these techniques, such as SOLO [1] and GENAC [17], use heuristics that perform a limited search of the possible transistor placements and their orientations. Others such as LiB [13] consider height reduction after transistor placement has been determined. <p> o j orients such that share [p i , 2, p j , o j ]- or Xor [p i , 3] and or -Xor [p j , o j ]: " o j orients such that share [p i , 3, p j , o j ]- or Xor <ref> [p i , 4] </ref> and or -Xor [p j , o j ]: " o j orients such that share [p i , 4, p j , o j ]- To prevent cyclic conditions in diffusion sharing, we include the following constraints to ensure that a pair can share its diffusion <p> , 3] and or -Xor [p j , o j ]: " o j orients such that share [p i , 3, p j , o j ]- or Xor [p i , 4] and or -Xor [p j , o j ]: " o j orients such that share <ref> [p i , 4, p j , o j ] </ref>- To prevent cyclic conditions in diffusion sharing, we include the following constraints to ensure that a pair can share its diffusion with at most one pair placed on its immediate right and left sides: S merged [p 1 , p 2 <p> Hence, the routing model described here for cell layout can be applied to channel, OTC, and related routing problems as well. While channel routing algorithms must consider both horizontal and vertical constraints to compute T R , cell synthesis techniques ha ve generally ignored v ertical constraints <ref> [4, 12, 15] </ref>. The fundamental problem is to determine whether a net n requires a track in a column c. Let the array net of binary variables be such that net [n, c, r] = 1 if net n exists on a transistor terminal in column c. <p> Net presence: If c represents a diffusion terminal (c = 1, 3, 4, 6, ...), net [n, c, r] depends on the pair that is placed in the slot corresponding to c, and its orientation. For example, for c = 4, net <ref> [n, 4, r] </ref> = 1 if there is a pair placed in slot s = 2, and its orientation causes its diffusion terminal on net n to appear on its left side. <p> 4, 7, ...), net [n, c, r] is given by: net [n, c, r] = X [p, (c + 2) / 3, r] and ( Nsrc [p, n] and (Xor [p, 1] or Xor [p, 3]) " p pairs (21) or Ndrn [p, n] and (Xor [p, 2] or Xor <ref> [p, 4] </ref>) or Psrc [p, n] and (Xor [p, 1] or Xor [p, 2]) or Pdrn [p, n] and (Xor [p, 3] or Xor [p, 4])) The value of net [n, c, r] is similarly defined for columns that represent the right diffusions (c = 3, 6, 9, ...). <p> ( Nsrc [p, n] and (Xor [p, 1] or Xor [p, 3]) " p pairs (21) or Ndrn [p, n] and (Xor [p, 2] or Xor <ref> [p, 4] </ref>) or Psrc [p, n] and (Xor [p, 1] or Xor [p, 2]) or Pdrn [p, n] and (Xor [p, 3] or Xor [p, 4])) The value of net [n, c, r] is similarly defined for columns that represent the right diffusions (c = 3, 6, 9, ...). <p> Since columns 1, 2, and 3 need a track to connect net a, span [a, 1, r] = span [a, 2, r] = span [a, 3, r] = 1. Also, since columns 3 and 4 are connected by diffusion sharing, we set span <ref> [a, 4, r] </ref> = 1. However, net b appears only in columns 9 and 10, which are connected via diffusion sharing. Hence, span [b, 9, r] = span [b, 10, r] = 0.
Reference: [5] <institution> CPLEX Optimization, Inc., CPLEX Documentation, </institution> <year> 1990. </year> <month> 18 </month>
Reference-contexts: Experimental results: Table 3 presents results of applying CLIP-W to a few representative circuits from the literature for optimum-width layouts in one through four P/N ro ws. Although we evaluated several general-purpose ILP solvers, such as OSL [14] and CPLEX <ref> [5] </ref> and found their run time performance satisfactory, the specialized 0-1 solv er OPBDP [2] proved to be best suited to our optimization problem. Hence, the CLIP-W run times presented here have been obtained with the OPBDP solver.
Reference: [6] <author> B. Guan and C. Sechen, </author> <title> An Area Minimizing Layout Generator for Random Logic Blocks, </title> <booktitle> Proc. Custom Integrated Circuits Conf., </booktitle> <pages> pp. 457-460, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: Hence, span [b, 9, r] = span [b, 10, r] = 0. Now consider net c in columns 6 and 7 of the P and N diffusion terminals of pairs p 2 and p 3 , respectively. These columns are separated by a diffusion gap. Hence, span <ref> [c, 6, r] </ref> = span [c, 7, r] = 1.
Reference: [7] <author> A. Gupta, S-C. The, and J. P. Hayes, XPRESS: </author> <title> A Cell Layout Generator with Integrated Transistor Folding, </title> <booktitle> Proc. European Design & Test Conf., </booktitle> <pages> pp. 393-400, </pages> <month> March </month> <year> 1996. </year>
Reference-contexts: Even in the constrained 1-D style, fe w existing techniques efficiently solve the problem of both width and height minimization <ref> [1, 4, 7, 13, 17, 18] </ref>. Man y of these techniques, such as SOLO [1] and GENAC [17], use heuristics that perform a limited search of the possible transistor placements and their orientations. Others such as LiB [13] consider height reduction after transistor placement has been determined. <p> Now consider net c in columns 6 and 7 of the P and N diffusion terminals of pairs p 2 and p 3 , respectively. These columns are separated by a diffusion gap. Hence, span [c, 6, r] = span <ref> [c, 7, r] </ref> = 1. We assume that if a net, such as d, appears on the same (P or N) diffusion of two P/N pairs separated by a gap, it is connected using metal1 to avoid long diffusion wires, and hence requires a horizontal track.
Reference: [8] <author> A. Gupta and J. P. Hayes, </author> <title> Width Minimization of Two-Dimensional CMOS Cells Using Integer Programming, </title> <booktitle> Proc. Intl Conf. on Computer-Aided Design, </booktitle> <month> Nov. </month> <year> 1996, </year> <note> to appear. </note>
Reference-contexts: Recently, integer linear programming (ILP) has been successfully emplo yed to generate minimum-width 2-D layouts of CMOS cells <ref> [8, 9] </ref>. The problem is formulated as a 0-1 ILP problem which is then solved using an inte ger solver. The technique w as demonstrated to be computationally viable and to guarantee layouts of optimum width for practical-sized circuits. <p> W cell by placing the P/N pairs in a given number of rows such that the maximum width among all rows is minimized, that is, minimize W cell , where W cell = max -W r : for each P/N row r = 1, 2, ...- (1) As discussed in <ref> [8] </ref>, W cell for a 2-D layout depends on several factors: Chain cover or diffusion sharing: The selection of the chain cover affects W cell since covers that yield optimum 1-D widths do not also guarantee minimum 2-D widths. <p> The ILP model of <ref> [8] </ref> implicitly models the problem of dif fusion sharingthe circuit is preprocessed to generate an e xhaustive set of transistor chains and the layout problem is transformed to a set-co vering problem whose goal is to determine the smallest set of chains that covers each pair. <p> The next section describes an ILP-based methodreferred to as CLIP-W where the W indicates that the model minimizes the cell width onlythat is based on P/N pairs and e xplicitly models pair locations, orientations, and diffusion sharing; inter-row connectivity is modeled as described in <ref> [8] </ref>. 4 3 Width Minimization Model Given a set of P/N pairs and the number of P/N ro ws, the following parameters must be determined to specify a 2-D layout: The row, location, and orientation of each pair, the diffusion sharing among adjacent pairs, and the vertical nets that connect transistor <p> All possible pairwise dif fusion abutments, represented by the array share, are shown in Fig. 2 b. Figure 2c lists the diffusion sharing constraints for nogap [1, 1] for a single ro w placement (s = r = 1). 4. Inter-row connectivity: These constraints, identical to those in <ref> [8] </ref>, determine the nets that must be routed from one P/N row to another, contributing to the overall 2-D cell width. <p> Hence, the CLIP-W run times presented here have been obtained with the OPBDP solver. For most circuits, CLIP-W performs at least as well as the technique presented in <ref> [8] </ref>. F or these experiments, the OPBDP heuristic -h103, that selects a branching variable at each stage in the branch-and bound search tree, w as used. <p> Thus, span [n, c, r] for an inter-row channel is given by the following equation: span [n, c, r] = net appears on top diffusion and net appears on bottom diffusion Both the terms in the abo ve and expression are available as variables that model inter-row connectivity (see <ref> [8] </ref>), and can be used directly. <p> As seen in the next section, HCLIP extends our technique to circuits with over 30 transistors while yielding layouts that are at or near the optimum. 15 7 Circuit Clustering An and-stack <ref> [8] </ref> of size n is a group of n 2 transistors connected in series. For example, the N transistors of pairs p 1 and p 7 in Fig. 2 a form an and-stack of size tw o.
Reference: [9] <author> A. Gupta and J. P. Hayes, </author> <title> A Hierarchical Technique for Minimum-Width Layout of Two-Dimensional CMOS Cells, </title> <booktitle> Proc. International Conf. on VLSI Design, </booktitle> <month> Jan. </month> <year> 1997, </year> <note> to appear. </note>
Reference-contexts: Recently, integer linear programming (ILP) has been successfully emplo yed to generate minimum-width 2-D layouts of CMOS cells <ref> [8, 9] </ref>. The problem is formulated as a 0-1 ILP problem which is then solved using an inte ger solver. The technique w as demonstrated to be computationally viable and to guarantee layouts of optimum width for practical-sized circuits. <p> Also, since columns 3 and 4 are connected by diffusion sharing, we set span [a, 4, r] = 1. However, net b appears only in columns 9 and 10, which are connected via diffusion sharing. Hence, span <ref> [b, 9, r] </ref> = span [b, 10, r] = 0. Now consider net c in columns 6 and 7 of the P and N diffusion terminals of pairs p 2 and p 3 , respectively. These columns are separated by a diffusion gap. <p> F or example, CLIP can be extended to accommodate transistor folding and performance-directed synthesis. It can also be modified to generate layouts hierarchically, based on a predetermined circuit partitioning, which can extend our technique to much larger circuits <ref> [9] </ref>.
Reference: [10] <author> D. V. Heinbuch, </author> <title> CMOS3 Cell Library, </title> <publisher> Addison-Wesley, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1988. </year>
Reference-contexts: Also, since columns 3 and 4 are connected by diffusion sharing, we set span [a, 4, r] = 1. However, net b appears only in columns 9 and 10, which are connected via diffusion sharing. Hence, span [b, 9, r] = span <ref> [b, 10, r] </ref> = 0. Now consider net c in columns 6 and 7 of the P and N diffusion terminals of pairs p 2 and p 3 , respectively. These columns are separated by a diffusion gap. Hence, span [c, 6, r] = span [c, 7, r] = 1.
Reference: [11] <author> T. W. Her and D. F. Wong, </author> <title> On Over-the-Cell Channel Routing with Cell Orientation Consideration, </title> <journal> IEEE Trans. on CAD, </journal> <volume> Vol. 14, </volume> <pages> pp. 766-771, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Thus, to compute T R , we must determine, for each column c in region R, the number of nets that must be routed horizontally through it. This has traditionally been referred to as the channel routing problem [19]. A variant of this problem occurs in over-the-cell (OTC) routing <ref> [11] </ref> where, given a row of cells with pin terminals located at their top and bottom edges, the goal is to determine the set of nets that can be routed entirely o ver the cells, subject to constraints on the number of a vailable routing tracks.
Reference: [12] <author> D.D. Hill, Sc2: </author> <title> A Hybrid Automatic Layout System, </title> <booktitle> Proc. Intl Conf. on Computer-Aided Design, </booktitle> <pages> pp. 172-174, </pages> <month> Nov. </month> <year> 1985. </year>
Reference-contexts: Hence, the routing model described here for cell layout can be applied to channel, OTC, and related routing problems as well. While channel routing algorithms must consider both horizontal and vertical constraints to compute T R , cell synthesis techniques ha ve generally ignored v ertical constraints <ref> [4, 12, 15] </ref>. The fundamental problem is to determine whether a net n requires a track in a column c. Let the array net of binary variables be such that net [n, c, r] = 1 if net n exists on a transistor terminal in column c. <p> We assume that if a net, such as d, appears on the same (P or N) diffusion of two P/N pairs separated by a gap, it is connected using metal1 to avoid long diffusion wires, and hence requires a horizontal track. Thus, span <ref> [d, 12, r] </ref> = span [d, 13, r] = 1.
Reference: [13] <author> Y-C Hsieh, C-Y Hwang, Y-L Lin, and Y-C Hsu, </author> <title> LiB: A CMOS Cell Compiler, </title> <journal> IEEE Trans. on CAD, </journal> <volume> Vol. 10, </volume> <pages> pp. 994-1005, </pages> <month> Aug. </month> <year> 1991. </year>
Reference-contexts: Even in the constrained 1-D style, fe w existing techniques efficiently solve the problem of both width and height minimization <ref> [1, 4, 7, 13, 17, 18] </ref>. Man y of these techniques, such as SOLO [1] and GENAC [17], use heuristics that perform a limited search of the possible transistor placements and their orientations. Others such as LiB [13] consider height reduction after transistor placement has been determined. <p> Man y of these techniques, such as SOLO [1] and GENAC [17], use heuristics that perform a limited search of the possible transistor placements and their orientations. Others such as LiB <ref> [13] </ref> consider height reduction after transistor placement has been determined. Only a few techniques [15] use e xact methods that explore the entire range of possible placements and diffusion sharing and generate a layout that is truly optimal in width and height. <p> We assume that if a net, such as d, appears on the same (P or N) diffusion of two P/N pairs separated by a gap, it is connected using metal1 to avoid long diffusion wires, and hence requires a horizontal track. Thus, span [d, 12, r] = span <ref> [d, 13, r] </ref> = 1. Based on the above discussion, the constraint for span [n, c, r] for c = 3, 6, 9, etc. is split into two, one that considers all columns c 2 c + 2, and the other for the column c + 1 on its right.
Reference: [14] <author> IBM Corporation, </author> <title> Optimization Subroutine Library, </title> <year> 1990. </year>
Reference-contexts: Experimental results: Table 3 presents results of applying CLIP-W to a few representative circuits from the literature for optimum-width layouts in one through four P/N ro ws. Although we evaluated several general-purpose ILP solvers, such as OSL <ref> [14] </ref> and CPLEX [5] and found their run time performance satisfactory, the specialized 0-1 solv er OPBDP [2] proved to be best suited to our optimization problem. Hence, the CLIP-W run times presented here have been obtained with the OPBDP solver.
Reference: [15] <author> R. L. Maziasz and J. P. Hayes, </author> <title> Layout Minimization of CMOS Cells, </title> <publisher> Kluwer, </publisher> <address> Boston, </address> <year> 1992. </year>
Reference-contexts: 1 Introduction The overall objective in cell layout synthesis is to minimize the cell area subject to gi ven constraints. Maziasz and Hayes <ref> [15] </ref> demonstrate that, for one-dimensional (1-D) layouts, which place all the transistors in a single pair of parallel P and N dif fusion rows, minimizing both cell width and height can result in area savings of more than 80% o ver width minimization alone. <p> Man y of these techniques, such as SOLO [1] and GENAC [17], use heuristics that perform a limited search of the possible transistor placements and their orientations. Others such as LiB [13] consider height reduction after transistor placement has been determined. Only a few techniques <ref> [15] </ref> use e xact methods that explore the entire range of possible placements and diffusion sharing and generate a layout that is truly optimal in width and height. <p> The CLIP-W model has all information necessary for a 2-D placement. In subsequent sections, we propose a model that extends CLIP-W to minimize the 2-D cell height in addition to the width. 4 Height Minimization The height of a cell is determined by the cells horizontal routing (track) density <ref> [15] </ref>, that is, the number of horizontal tracks needed to connect electrically equivalent transistor terminals. <p> Hence, the routing model described here for cell layout can be applied to channel, OTC, and related routing problems as well. While channel routing algorithms must consider both horizontal and vertical constraints to compute T R , cell synthesis techniques ha ve generally ignored v ertical constraints <ref> [4, 12, 15] </ref>. The fundamental problem is to determine whether a net n requires a track in a column c. Let the array net of binary variables be such that net [n, c, r] = 1 if net n exists on a transistor terminal in column c.
Reference: [16] <author> G. L. Nemhauser and L. A. Wolsey, </author> <title> Integer and Combinatorial Optimization, </title> <publisher> John Wiley, </publisher> <address> New York, </address> <year> 1988. </year>
Reference: [17] <author> C.L. Ong, J.T. Li, and C.Y. Lo, GENAC: </author> <title> An Automatic Cell Synthesis Tool, </title> <booktitle> Proc. 26th Design Automation Conf., </booktitle> <pages> pp. 239-244, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Even in the constrained 1-D style, fe w existing techniques efficiently solve the problem of both width and height minimization <ref> [1, 4, 7, 13, 17, 18] </ref>. Man y of these techniques, such as SOLO [1] and GENAC [17], use heuristics that perform a limited search of the possible transistor placements and their orientations. Others such as LiB [13] consider height reduction after transistor placement has been determined. <p> Even in the constrained 1-D style, fe w existing techniques efficiently solve the problem of both width and height minimization [1, 4, 7, 13, 17, 18]. Man y of these techniques, such as SOLO [1] and GENAC <ref> [17] </ref>, use heuristics that perform a limited search of the possible transistor placements and their orientations. Others such as LiB [13] consider height reduction after transistor placement has been determined.
Reference: [18] <author> C.J. Poirier, Excellerator: </author> <title> Custom CMOS Leaf Cell Layout Generator, </title> <journal> IEEE Trans. on CAD, </journal> <volume> Vol. 8, </volume> <pages> pp. 744-755, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: Even in the constrained 1-D style, fe w existing techniques efficiently solve the problem of both width and height minimization <ref> [1, 4, 7, 13, 17, 18] </ref>. Man y of these techniques, such as SOLO [1] and GENAC [17], use heuristics that perform a limited search of the possible transistor placements and their orientations. Others such as LiB [13] consider height reduction after transistor placement has been determined. <p> In contrast to the 1-D style, 2-D layout generation has been little studied and the few techniques proposed are ad hoc <ref> [18, 20, 24] </ref>. For example, Poirier [18] proposes a greedy transistor placement method that can handle constraints on the number of dif fusion rows or the shape of the cell boundary . <p> In contrast to the 1-D style, 2-D layout generation has been little studied and the few techniques proposed are ad hoc [18, 20, 24]. For example, Poirier <ref> [18] </ref> proposes a greedy transistor placement method that can handle constraints on the number of dif fusion rows or the shape of the cell boundary .
Reference: [19] <author> R. L. Rivest and C. M. Fiduccia, </author> <title> A Greedy Channel Router, </title> <booktitle> Proc. 19th Design Automation Conf., </booktitle> <pages> pp. 120-125, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: Thus, to compute T R , we must determine, for each column c in region R, the number of nets that must be routed horizontally through it. This has traditionally been referred to as the channel routing problem <ref> [19] </ref>.
Reference: [20] <author> K. Tani, K. Izumi, M. Kashimura, T. Matsuda, and T. Fujii, </author> <title> Two-Dimensional Layout Synthesis for Large-Scale CMOS Circuits, </title> <booktitle> Proc. Intl Conf. on Computer-Aided Design, </booktitle> <pages> pp. 490-493, </pages> <month> Nov. </month> <year> 1991. </year>
Reference-contexts: In contrast to the 1-D style, 2-D layout generation has been little studied and the few techniques proposed are ad hoc <ref> [18, 20, 24] </ref>. For example, Poirier [18] proposes a greedy transistor placement method that can handle constraints on the number of dif fusion rows or the shape of the cell boundary .
Reference: [21] <author> T. Uehara and W.M. VanCleemput, </author> <title> Optimal Layout of CMOS Functional Arrays, </title> <journal> IEEE Trans. on Computers, </journal> <volume> Vol. C-30, </volume> <pages> pp. 305-312, </pages> <month> May </month> <year> 1981. </year>
Reference: [22] <author> H. P. Williams, </author> <title> Model Building in Mathematical Programming, 2nd ed., </title> <publisher> John Wiley, </publisher> <address> New York, </address> <year> 1985. </year>
Reference: [23] <author> S. Wimer, R.Y. Pinter, and J.A. Feldman, </author> <title> Optimal Chaining of CMOS Transistors in a Functional Cell, </title> <journal> IEEE Trans. on CAD, </journal> <volume> Vol. CAD-6, </volume> <pages> pp. 795-801, </pages> <month> Sept. </month> <year> 1987. </year>
Reference: [24] <author> H. Zhang and K. Asada, </author> <title> An Improved Algorithm of Transistors Pairing for Compact Layout of Non-Series-Parallel CMOS Networks, </title> <booktitle> Proc. Custom Integrated Circuits Conf., </booktitle> <pages> pp. </pages> <address> 17.2.1-17.2.4, </address> <year> 1993. </year> <month> 19 </month>
Reference-contexts: In contrast to the 1-D style, 2-D layout generation has been little studied and the few techniques proposed are ad hoc <ref> [18, 20, 24] </ref>. For example, Poirier [18] proposes a greedy transistor placement method that can handle constraints on the number of dif fusion rows or the shape of the cell boundary . <p> CPU time (secs) Cell width # Circuit No. of trans. No. of rows Original cct. With stacking CLIP-W 1 Virtuoso [3] 1. 2-input parity circuit (Xor) [1] 1 3 0.01 0.05 0.01 0.03 5 3 5 4 2. Non-series-parallel bridge circuit <ref> [24] </ref> 1 3 0.03 0.07 0.03 0.07 6 4 6 5 3. 2-level implementation of z = (a' . (e + f)' + d)' 12 2 4 0.02 0.19 0.02 0.07 3 3 4 5 4. 2-to-1 multiplexer 14 1 3 0.06 0.06 0.04 0.04 8 3 8 3 5.
References-found: 24

