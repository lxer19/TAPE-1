URL: http://www.cs.brandeis.edu/~mairson/Papers/KMM.ps.gz
Refering-URL: http://www.cs.brandeis.edu/~mairson/
Root-URL: http://www.cs.brandeis.edu
Title: Unification and ML Type Reconstruction  
Author: Paris C. Kanellakis Harry G. Mairson John C. Mitchell 
Note: The work of this author was supported by NSF grant IRI-8617344, ONR grant N00014-83-K-0146 ARPA Order No. 4786, and an Alfred P. Sloan Fellowship. Supported by grants from Texas Instruments and from the Tyson Foundation. Supported by an NSF Presidential Young Investigator Award with matching funds from Digital Equip ment Corporation, the Powell Foundation, and Xerox Corporation; and NSF grant CCR-8814921.  
Date: May 18, 1990  
Address: Providence, Rhode Island 02912  Waltham, Massachusetts 02254  Stanford, California 94305  
Affiliation: Department of Computer Science Brown University  Department of Computer Science Brandeis University  Department of Computer Science Stanford University  
Abstract: We study the complexity of type reconstruction for a core fragment of ML with lambda abstraction, function application, and the polymorphic let declaration. We derive exponential upper and lower bounds on recognizing the typable core ML expressions. Our primary technical tool is unification of succinctly represented type expressions. After observing that core ML expressions, of size n, can be typed in DTIME(2 n ), we exhibit two different families of programs whose principal types grow exponentially. We show how to exploit the expressiveness of the let-polymorphism in these constructions to derive lower bounds on deciding typability: one leads naturally to NP-hardness and the other to DTIME(2 n k )-hardness for each integer k 1. Our generic simulation of any exponential time Turing Machine by ML type reconstruction may be viewed as a nonstandard way of computing with types. Our worst-case lower bounds stand in contrast to practical experience, which suggests that commonly used algorithms for type reconstruction do not slow compilation substantially. fl To appear as a chapter in Computational Logic: Essays in Honor of Alan Robinson, ed. J.-L. Lassez and G. Plotkin, MIT Press. Preliminary versions of the results in this paper appeared in the Proc. 16-th ACM Symposium on Principles of Programming Languages, pages 105-115, January 1989, and in the Proc. 17-th ACM Symposium on Principles of Programming Languages, pages 382-401, January 1990. 
Abstract-found: 1
Intro-found: 1
Reference: [AS85] <author> H. Abelson and G. J. Sussman. </author> <title> Structure and Interpretation of Computer Programs. </title> <publisher> MIT Press, </publisher> <year> 1985. </year>
Reference-contexts: The generic reduction is just a compiler: namely, how to compile Turing Machines into ML types. Since our "object code" is ML, we have endeavored to follow the gospel of <ref> [AS85] </ref> wherever possible, using modularization and data abstraction to make the program and proof more understandable. 5.1 Pairing and projection. pair = x:y:x 0 :y 0 :z:K z hEq (x 0 ; x); Eq (y 0 ; y)i : a ! b ! a ! b ! c ! c The
Reference: [AHU] <author> A. V. Aho, J. E. Hopcroft, and J. D. Ullman. </author> <title> The Design and Analysis of Computer Algorithms. </title> <publisher> Addison-Wesley, </publisher> <year> 1974. </year>
Reference-contexts: To achieve linear time, types must be represented and printed out as directed acyclic graphs, or dags (see <ref> [AHU] </ref>), since the string representation of a type may be exponentially longer than the expression to be typed. Dag representations are a common data structure in unification [PW78, MM82, DKM84]. <p> To perform unification efficiently, it is common to represent the expressions to be unified (in our case, type expressions) as directed acyclic graphs, <ref> [AHU] </ref>. A directed acyclic graph (dag) representation is like the parse tree of an expression, with each node labelled by an operator or operand (in our case, ! or a type variable). Repeated subexpressions need be represented only once, resulting in nodes with indegree greater than one.
Reference: [Bar84] <author> H. P. Barendregt. </author> <title> The Lambda Calculus: Its Syntax and Semantics. </title> <publisher> North Holland, </publisher> <year> 1984. </year>
Reference-contexts: Each of the lower bound proofs uses lambda calculus programming of approximately the same sophistication as the proof of Turing completeness for untyped lambda calculus <ref> [Bar84] </ref>. The first of these constructions gives a natural encoding of truth tables, and as a consequence, we derive an NP-hardness bound on typability (see Section 4). We include this construction because of its simplicity. <p> An interesting fact about let-reduction (only) is that it is finite Church-Rosser. The following proposition is essentially the uniqueness and finiteness of developments for untyped lambda calculus <ref> [Bar84] </ref>. The idea is that let x = M in N may be regarded as the marked redex (x:N ) 1 M , as opposed to the unmarked redex (x:N )M . The reader is referred to [Bar84] for further discussion and proof. <p> proposition is essentially the uniqueness and finiteness of developments for untyped lambda calculus <ref> [Bar84] </ref>. The idea is that let x = M in N may be regarded as the marked redex (x:N ) 1 M , as opposed to the unmarked redex (x:N )M . The reader is referred to [Bar84] for further discussion and proof. Proposition 2.1 Let M be any core ML expression. There is a unique let-free expression N such that every maximal sequence of let-reductions starting from M terminates at N . In particular, there are no infinite sequences of let-reductions.
Reference: [CCM85] <author> G. Cousineau, P.-L. Curien, and M. Mauny. </author> <title> The categorical abstract machine. </title> <booktitle> In IFIP International Conference on Functional Programming and Computer Architecture, Nancy, Lecture Notes in Computer Science 201, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: There are two likely explanations. The first is that as noted in Corollary 3.15, ML typing depends primarily on the let-depth of terms, as opposed to their length. While programs such as the CAML compiler <ref> [CCM85] </ref> begin with a very long sequence of let declarations, it is possible that the actual chains of declarations which depend on each other nontrivially are relatively short. A second possibility is that although functions declared by let are typically polymorphic, it seems common to apply them to non-polymorphic arguments.
Reference: [CF58] <author> H. B. Curry and R. Feys. </author> <title> Combinatory Logic I. </title> <publisher> North-Holland, </publisher> <year> 1958. </year>
Reference-contexts: This is another example of a fundamental theme from complexity theory, namely, the use of succinctness for deriving unconditional lower bounds on natural computational problems, e.g., [Mey72, SM73]. Note that without let, ML type reconstruction can be done efficiently. This is type reconstruction for the simply typed lambda calculus, <ref> [CF58, Hin69, Wan87] </ref>. Using a linear time unification algorithm (e.g., [PW78]), we can compute the principal type of any let-free core ML expression in linear time. <p> Then N 0 , the unique let normal form of M 0 (see Proposition 2.1), and M have exactly the same typings. But, for let normal forms the above inference system is the one for the first order typed lambda calculus <ref> [CF58, Hin69] </ref>. It is well known that, for the first order typed lambda calculus provable assertions are closed under substitution and principal typings exist. This leads us to two basic properties of ML (first shown in [Mil78, DM82]). Proposition 2.3 If 0 .
Reference: [DM82] <author> L. Damas and R. Milner. </author> <title> Principal type schemes for functional programs. </title> <booktitle> In 9-th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 207-212, </pages> <month> January </month> <year> 1982. </year>
Reference-contexts: 1 Introduction. A convenient feature of the programming language ML [GMW79, Mil85] is the manner in which type reconstruction 1 is used to eliminate the need for type declarations <ref> [Mil78, DM82] </ref>. When the programmer enters an untyped expression, the compiler responds with the type of the expression. <p> In studying the complexity of ML typing, we think of the meaning of ML expressions as their types represented by dags. A type reconstruction computation (such as the commonly used algorithm of <ref> [DM82] </ref>) proceeds in a syntax directed manner, where the types of expressions are derived via unification. Because of the succinctness introduced by let-polymorphism, the resulting unification is harder than classical first-order unification [Rob65, PW78, MM82]. <p> This generic simulation illustrates how type reconstruction can be used (in an unconventional fashion) for computing with types. In Section 2, we review some basic notions. We follow the exposition of [MH88, Mit90]. We observe that the inference rule for let is not the one found in <ref> [DM82] </ref>. This alternative exposition does not change the semantics. Its primary virtues are the explicit identification of let as a powerful abbreviation mechanism in the language, and the complete elimination of type schemes by reducing them to types. <p> Its primary virtues are the explicit identification of let as a powerful abbreviation mechanism in the language, and the complete elimination of type schemes by reducing them to types. The Appendix includes a description of the algorithm and inference rules for the system in <ref> [DM82] </ref>, and an equivalence theorem with our inference system. In Section 3, we exhibit two different constructions of ML expressions whose principal types grow exponentially. <p> The core ML expressions have the following abstract syntax M : : = x j M M j x:M j let x = M in M; where x may be any expression variable (cf. <ref> [DM82, Mil78] </ref>). In writing expressions, we use parentheses and the usual conventions of the lambda calculus. For example, M N P should be read as ((M N )P ), and x:M N read as x:(M N ). <p> We use this inference system in our exposition. We observe that the inference rule for let is not the one found in <ref> [DM82] </ref>, though it does not change the semantics. Its primary virtues are the explicit identification of let as a powerful "abbreviation" mechanism in the language, and the complete elimination of "type schemes" by reducing them to type expressions. <p> Its primary virtues are the explicit identification of let as a powerful "abbreviation" mechanism in the language, and the complete elimination of "type schemes" by reducing them to type expressions. The Appendix includes a description of the algorithm and inference rules for the system in <ref> [DM82] </ref>, and an equivalence theorem with the inference system above. A substitution will be a function from type variables to type expressions. A substitution S is applied to a type expression as usual, and to a type assignment by applying S to every type expression in . <p> It is well known that, for the first order typed lambda calculus provable assertions are closed under substitution and principal typings exist. This leads us to two basic properties of ML (first shown in <ref> [Mil78, DM82] </ref>). Proposition 2.3 If 0 . M : t 0 is an instance of a provable typing assertion . M : t , then 0 . M : t 0 is provable. Proposition 2.4 If M is typable, then M has a principal typing.
Reference: [DKM84] <author> C. Dwork, P. Kanellakis, and J. C. Mitchell. </author> <title> On the sequential nature of unification. </title> <journal> Journal of Logic Programming 1 </journal> <pages> 35-50, </pages> <year> 1984. </year>
Reference-contexts: To achieve linear time, types must be represented and printed out as directed acyclic graphs, or dags (see [AHU]), since the string representation of a type may be exponentially longer than the expression to be typed. Dag representations are a common data structure in unification <ref> [PW78, MM82, DKM84] </ref>. For a core ML expression with let, we give a straightforward deterministic type reconstruction algorithm which is exponential in the number of nested let declarations in the expression. The algorithm is based on a type-preserving transformation of the expression into a let-free equivalent. <p> The output of the circuit indicates the new state, what is written on the tape cell, and the head direction. All of this circuitry is realized by lambda terms, using the Boolean gadgets defined in <ref> [DKM84] </ref>. We add a Boolean "fanout" gate to this logical menagerie in the interest of facilitating our proof. <p> By encoding zero and one as these pairs of Boolean values, we do not need to simulate negation. 5.4 Monotone Boolean logic. We implement the monotone Boolean operators and and or using gadgets similar to those introduced in <ref> [DKM84] </ref>. and = x 1 :y 1 :x 2 :y 2 :w: x 1 u; y 1 w; x 2 w; y 2 vi Observe that if u: a, v: b, and w: c, then the subterms x 1 u; y 1 w; x 2 w; y 2 v get typed <p> :out 2 :z:Kz hin u v; out 1 x 1 y 1 ; Eq (out 1 ; false); out 2 x 2 y 2 ; Eq (out 2 ; false); u x 1 x 2 ; v y 1 y 2 i Viewed as a dag in the style of <ref> [DKM84] </ref> (see Figure 1), the fanout gate is just an upside-down or gate.
Reference: [GR88] <author> P. Giannini and S. Ronchi Della Rocca. </author> <title> Characterization of typings in polymorphic type discipline. </title> <booktitle> In Proceedings of the 3-rd IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 61-70, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: The Curry typing rules are syntax directed <ref> [GR88, Mit88] </ref>. Thus, by structural induction on lambda terms, one can show that the above nonrecursive algorithm is correct; a correctness proof for essentially this algorithm appears in [Wan87]. Steps (1-3) are clearly linear time. By [PW78], step (4) can be done in linear time. 3.2 Type size with let. <p> The analysis of semi-unification, under an acyclicity condition, is the basis for the proof of the exponential lower bounds in [KTU90a]. One promising direction for further work is to apply the unification techniques here as well as the theory of semi-unification to other typing problems, e.g., see <ref> [Lei83, Mit88, GR88, Hen89, KTU89] </ref>. The major remaining open problem is the decidability question (or 27 even any nontrivial lower bound) for type reconstruction in System F or second order typed lambda calculus [Gir72, Rey74]. Acknowledgements: Earlier versions of this work appeared in [KM89, Mai90].
Reference: [Gir72] <author> J.-Y. Girard, </author> <title> Interpretation Fonctionelle et Elimination des Coupures de l'Arithmetique d'Ordre Superieur. </title> <institution> These de Doctorat d'Etat, Universite de Paris VII, </institution> <year> 1972. </year>
Reference-contexts: The major remaining open problem is the decidability question (or 27 even any nontrivial lower bound) for type reconstruction in System F or second order typed lambda calculus <ref> [Gir72, Rey74] </ref>. Acknowledgements: Earlier versions of this work appeared in [KM89, Mai90]. We are grateful to Mitchell Wand and Peter Buneman for pointing out a number of interesting examples, and thank Gerard Huet and David MacQueen for discussions regarding the relevance of our lower bound to ML practice.
Reference: [GMW79] <author> M. J. Gordon, R. Milner, and C. P. Wadsworth. </author> <title> Edinburgh LCF. </title> <booktitle> Lecture Notes in Computer Science 78, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: 1 Introduction. A convenient feature of the programming language ML <ref> [GMW79, Mil85] </ref> is the manner in which type reconstruction 1 is used to eliminate the need for type declarations [Mil78, DM82]. When the programmer enters an untyped expression, the compiler responds with the type of the expression.
Reference: [Hen89] <author> F. Henglein. </author> <title> Polymorphic type inference and semi-unification. </title> <institution> New York University Technical Report 443, </institution> <month> May </month> <year> 1989. </year> <booktitle> Also see Proceedings of the ACM Symposium on Lisp and Functional Programming Languages, </booktitle> <pages> pages 184-197, </pages> <month> July </month> <year> 1988. </year> <month> 28 </month>
Reference-contexts: In addition to the syntax of core ML, most ML dialects have a fixpoint combinator whose presence does not affect the complexity of type reconstruction. However, one extension of ML is based on polymorphic typing of the fixpoint combinator [Myc84]. Type reconstruction for this extension has been characterized in <ref> [Hen89, KTU89] </ref> as equivalent to semi-unification, and has recently been shown to be undecidable [KTU90b]. The analysis of semi-unification, under an acyclicity condition, is the basis for the proof of the exponential lower bounds in [KTU90a]. <p> The analysis of semi-unification, under an acyclicity condition, is the basis for the proof of the exponential lower bounds in [KTU90a]. One promising direction for further work is to apply the unification techniques here as well as the theory of semi-unification to other typing problems, e.g., see <ref> [Lei83, Mit88, GR88, Hen89, KTU89] </ref>. The major remaining open problem is the decidability question (or 27 even any nontrivial lower bound) for type reconstruction in System F or second order typed lambda calculus [Gir72, Rey74]. Acknowledgements: Earlier versions of this work appeared in [KM89, Mai90].
Reference: [Hin69] <author> R. Hindley. </author> <title> The principal type scheme of an object in combinatory logic. </title> <journal> Trans--actions of the American Mathematical Society 146 29-60,1969. </journal>
Reference-contexts: This is another example of a fundamental theme from complexity theory, namely, the use of succinctness for deriving unconditional lower bounds on natural computational problems, e.g., [Mey72, SM73]. Note that without let, ML type reconstruction can be done efficiently. This is type reconstruction for the simply typed lambda calculus, <ref> [CF58, Hin69, Wan87] </ref>. Using a linear time unification algorithm (e.g., [PW78]), we can compute the principal type of any let-free core ML expression in linear time. <p> Then N 0 , the unique let normal form of M 0 (see Proposition 2.1), and M have exactly the same typings. But, for let normal forms the above inference system is the one for the first order typed lambda calculus <ref> [CF58, Hin69] </ref>. It is well known that, for the first order typed lambda calculus provable assertions are closed under substitution and principal typings exist. This leads us to two basic properties of ML (first shown in [Mil78, DM82]). Proposition 2.3 If 0 .
Reference: [HU] <author> J. E. Hopcroft and J. D. Ullman. </author> <title> Introduction to Automata Theory, Languages, and Computation. </title> <publisher> Addison Wesley 1979. </publisher>
Reference-contexts: The reduction is not only polynomial time, but may also be carried out in log n work space by a Turing Machine transducer (for details of these definitions, see <ref> [HU] </ref>). The output M;x requires n k nested let definitions to define the exponential tape, and n k nested let definitions to define the transition function, where the lengths of the let bindings are constant. <p> In particular, consider the proof of the previous theorem with k = 1. In this case j M;x j cjxj for some constant c &gt; 0 depending on M . Using an argument analogous to that of Theorem 13.15 from <ref> [HU] </ref> we have: Theorem 5.24 Any algorithm recognizing the typable core ML expressions of length n is at least of time complexity bc n infinitely often, for some constants b &gt; 0 and c &gt; 1. 5.12 Some comments on the lower bound.
Reference: [HW88] <editor> P. Hudak and P. L. Wadler, editors. </editor> <title> Report on the Functional Programming Language Haskell. </title> <institution> Yale University Technical Report YALEU/DCS/RR656, </institution> <year> 1988. </year>
Reference-contexts: Since the combination of ML polymorphism and type reconstruction has proven very useful in practice, the main ideas have also been adopted in other languages, such as Miranda [Tur85] and Haskell <ref> [HW88] </ref>. To simplify our analysis, we will focus on core ML expressions without recursion, using only lambda abstraction, function application, and let. Choosing a small fragment of ML makes our lower bound applicable to any extension.
Reference: [KM89] <author> P. C. Kanellakis and J. C. Mitchell. </author> <title> Polymorphic unification and ML typing. </title> <institution> Brown University Technical Report CS-89-40, </institution> <month> August </month> <year> 1989. </year> <booktitle> Also in Proceedings of the 16-th ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 105-115, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: Theorem 4.21 Deciding if an ML expression is typable is NP-hard. We observe that by elaborating some of the above constructions, Theorem 4.21 can be strengthened to derive a PSPACE-hardness lower bound <ref> [KM89] </ref>. This stronger bound involves the introduction of Boolean logic gates in the place of the pairing operator h; i, so that the subtrees act like inputs in a Boolean circuit. <p> The major remaining open problem is the decidability question (or 27 even any nontrivial lower bound) for type reconstruction in System F or second order typed lambda calculus [Gir72, Rey74]. Acknowledgements: Earlier versions of this work appeared in <ref> [KM89, Mai90] </ref>. We are grateful to Mitchell Wand and Peter Buneman for pointing out a number of interesting examples, and thank Gerard Huet and David MacQueen for discussions regarding the relevance of our lower bound to ML practice.
Reference: [KTU89] <author> A. J. Kfoury, J. Tiuryn, and P. Urzyczyn. </author> <title> Computational consequences and partial solutions of a generalized unification problem. </title> <booktitle> In Proceedings of the 4-th IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 98-105, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: In addition to the syntax of core ML, most ML dialects have a fixpoint combinator whose presence does not affect the complexity of type reconstruction. However, one extension of ML is based on polymorphic typing of the fixpoint combinator [Myc84]. Type reconstruction for this extension has been characterized in <ref> [Hen89, KTU89] </ref> as equivalent to semi-unification, and has recently been shown to be undecidable [KTU90b]. The analysis of semi-unification, under an acyclicity condition, is the basis for the proof of the exponential lower bounds in [KTU90a]. <p> The analysis of semi-unification, under an acyclicity condition, is the basis for the proof of the exponential lower bounds in [KTU90a]. One promising direction for further work is to apply the unification techniques here as well as the theory of semi-unification to other typing problems, e.g., see <ref> [Lei83, Mit88, GR88, Hen89, KTU89] </ref>. The major remaining open problem is the decidability question (or 27 even any nontrivial lower bound) for type reconstruction in System F or second order typed lambda calculus [Gir72, Rey74]. Acknowledgements: Earlier versions of this work appeared in [KM89, Mai90].
Reference: [KTU90a] <author> A. J. Kfoury, J. Tiuryn, and P. Urzyczyn. </author> <title> ML Typability is Dexptime-Complete. </title> <booktitle> To appear in the Proceedings of the 15-th Colloquium on Trees in Algebra and Programming, </booktitle> <month> May </month> <year> 1990. </year> <note> (See also Boston University Technical Report, </note> <month> October </month> <year> 1989). </year>
Reference-contexts: They also stand in contrast to the perceived efficiency of the algorithm in practice. We note that exponential lower bounds on ML type reconstruction have also been shown (independently and using altogether different methods) in <ref> [KTU90a] </ref>. 2 To the embarrassment of the third author, the incorrect "folk theorem" was put in print in [MH88]. A quadratic time bound for the problem was also claimed in [Lei83]. 3 2 ML expressions, types and unification. 2.1 Core ML. <p> Type reconstruction for this extension has been characterized in [Hen89, KTU89] as equivalent to semi-unification, and has recently been shown to be undecidable [KTU90b]. The analysis of semi-unification, under an acyclicity condition, is the basis for the proof of the exponential lower bounds in <ref> [KTU90a] </ref>. One promising direction for further work is to apply the unification techniques here as well as the theory of semi-unification to other typing problems, e.g., see [Lei83, Mit88, GR88, Hen89, KTU89].
Reference: [KTU90b] <author> A. J. Kfoury, J. Tiuryn, and P. Urzyczyn. </author> <title> Undecidability of the semi-unification problem. </title> <booktitle> To appear in the Proceedings of the 22nd ACM Symposium on Theory of Computing, </booktitle> <month> May </month> <year> 1990. </year> <note> (See also Boston University Technical Report, </note> <month> October </month> <year> 1989). </year>
Reference-contexts: However, one extension of ML is based on polymorphic typing of the fixpoint combinator [Myc84]. Type reconstruction for this extension has been characterized in [Hen89, KTU89] as equivalent to semi-unification, and has recently been shown to be undecidable <ref> [KTU90b] </ref>. The analysis of semi-unification, under an acyclicity condition, is the basis for the proof of the exponential lower bounds in [KTU90a].
Reference: [Lei83] <author> D. Leivant. </author> <title> Polymorphic type inference. </title> <booktitle> In Proceedings of the 10-th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 88-98, </pages> <month> Jan-uary </month> <year> 1983. </year>
Reference-contexts: A quadratic time bound for the problem was also claimed in <ref> [Lei83] </ref>. 3 2 ML expressions, types and unification. 2.1 Core ML. The core ML expressions have the following abstract syntax M : : = x j M M j x:M j let x = M in M; where x may be any expression variable (cf. [DM82, Mil78]). <p> The analysis of semi-unification, under an acyclicity condition, is the basis for the proof of the exponential lower bounds in [KTU90a]. One promising direction for further work is to apply the unification techniques here as well as the theory of semi-unification to other typing problems, e.g., see <ref> [Lei83, Mit88, GR88, Hen89, KTU89] </ref>. The major remaining open problem is the decidability question (or 27 even any nontrivial lower bound) for type reconstruction in System F or second order typed lambda calculus [Gir72, Rey74]. Acknowledgements: Earlier versions of this work appeared in [KM89, Mai90].
Reference: [Mai90] <author> H. G. Mairson. </author> <title> Deciding ML typability is complete for deterministic exponential time. </title> <booktitle> In Proceedings of the 17-th ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 382-401, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: The major remaining open problem is the decidability question (or 27 even any nontrivial lower bound) for type reconstruction in System F or second order typed lambda calculus [Gir72, Rey74]. Acknowledgements: Earlier versions of this work appeared in <ref> [KM89, Mai90] </ref>. We are grateful to Mitchell Wand and Peter Buneman for pointing out a number of interesting examples, and thank Gerard Huet and David MacQueen for discussions regarding the relevance of our lower bound to ML practice.
Reference: [MM82] <author> A. Martelli and U. Montanari. </author> <title> An efficient unification algorithm. </title> <journal> ACM Transactions on Programming Languages and Systems 4(2), </journal> <month> Feb. </month> <year> 1982. </year>
Reference-contexts: To achieve linear time, types must be represented and printed out as directed acyclic graphs, or dags (see [AHU]), since the string representation of a type may be exponentially longer than the expression to be typed. Dag representations are a common data structure in unification <ref> [PW78, MM82, DKM84] </ref>. For a core ML expression with let, we give a straightforward deterministic type reconstruction algorithm which is exponential in the number of nested let declarations in the expression. The algorithm is based on a type-preserving transformation of the expression into a let-free equivalent. <p> A type reconstruction computation (such as the commonly used algorithm of [DM82]) proceeds in a syntax directed manner, where the types of expressions are derived via unification. Because of the succinctness introduced by let-polymorphism, the resulting unification is harder than classical first-order unification <ref> [Rob65, PW78, MM82] </ref>. In fact, as we show, the resulting unification can simulate any exponential time Turing Machine computation. This generic simulation illustrates how type reconstruction can be used (in an unconventional fashion) for computing with types. In Section 2, we review some basic notions.
Reference: [Mey72] <author> A. R. Meyer. </author> <title> Weak S1S cannot be decided. </title> <journal> In Notices Amer. Math. Soc., </journal> <note> 19, A-598, Abstract 72T-E67, </note> <year> 1972. </year> <title> (See also, </title> <booktitle> Lecture Notes in Mathematics 453, </booktitle> <publisher> Springer Verlag, </publisher> <pages> pages 132-154, </pages> <year> 1975.) </year>
Reference-contexts: This is another example of a fundamental theme from complexity theory, namely, the use of succinctness for deriving unconditional lower bounds on natural computational problems, e.g., <ref> [Mey72, SM73] </ref>. Note that without let, ML type reconstruction can be done efficiently. This is type reconstruction for the simply typed lambda calculus, [CF58, Hin69, Wan87]. Using a linear time unification algorithm (e.g., [PW78]), we can compute the principal type of any let-free core ML expression in linear time. <p> This counting can be realized in O (log n) bits, to be represented in log n space given a suitably large work tape alphabet. Our generic simulation leads to completeness lower bounds, but also to unconditional lower bounds in the style of <ref> [Mey72, SM73] </ref>. In particular, consider the proof of the previous theorem with k = 1. In this case j M;x j cjxj for some constant c &gt; 0 depending on M .
Reference: [Mil78] <author> R. Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences 17, </journal> <pages> pages 348-375, </pages> <year> 1978. </year>
Reference-contexts: 1 Introduction. A convenient feature of the programming language ML [GMW79, Mil85] is the manner in which type reconstruction 1 is used to eliminate the need for type declarations <ref> [Mil78, DM82] </ref>. When the programmer enters an untyped expression, the compiler responds with the type of the expression. <p> The core ML expressions have the following abstract syntax M : : = x j M M j x:M j let x = M in M; where x may be any expression variable (cf. <ref> [DM82, Mil78] </ref>). In writing expressions, we use parentheses and the usual conventions of the lambda calculus. For example, M N P should be read as ((M N )P ), and x:M N read as x:(M N ). <p> It is well known that, for the first order typed lambda calculus provable assertions are closed under substitution and principal typings exist. This leads us to two basic properties of ML (first shown in <ref> [Mil78, DM82] </ref>). Proposition 2.3 If 0 . M : t 0 is an instance of a provable typing assertion . M : t , then 0 . M : t 0 is provable. Proposition 2.4 If M is typable, then M has a principal typing.
Reference: [Mil85] <author> R. Milner. </author> <title> The Standard ML core language. </title> <journal> Polymorphism, </journal> <volume> 2(2), </volume> <pages> 28 pages, </pages> <year> 1985. </year> <note> An earlier version appeared in Proceedings of the 1984 ACM Symposium on Lisp and Functional Programming. </note>
Reference-contexts: 1 Introduction. A convenient feature of the programming language ML <ref> [GMW79, Mil85] </ref> is the manner in which type reconstruction 1 is used to eliminate the need for type declarations [Mil78, DM82]. When the programmer enters an untyped expression, the compiler responds with the type of the expression.
Reference: [Mit88] <author> J. C. Mitchell. </author> <title> Polymorphic type inference and containment. </title> <booktitle> Information and Computation 76(2/3), </booktitle> <year> 1988. </year> <month> 29 </month>
Reference-contexts: The Curry typing rules are syntax directed <ref> [GR88, Mit88] </ref>. Thus, by structural induction on lambda terms, one can show that the above nonrecursive algorithm is correct; a correctness proof for essentially this algorithm appears in [Wan87]. Steps (1-3) are clearly linear time. By [PW78], step (4) can be done in linear time. 3.2 Type size with let. <p> The analysis of semi-unification, under an acyclicity condition, is the basis for the proof of the exponential lower bounds in [KTU90a]. One promising direction for further work is to apply the unification techniques here as well as the theory of semi-unification to other typing problems, e.g., see <ref> [Lei83, Mit88, GR88, Hen89, KTU89] </ref>. The major remaining open problem is the decidability question (or 27 even any nontrivial lower bound) for type reconstruction in System F or second order typed lambda calculus [Gir72, Rey74]. Acknowledgements: Earlier versions of this work appeared in [KM89, Mai90].
Reference: [Mit90] <author> J. C. Mitchell. </author> <title> Type systems for programming languages. </title> <note> To appear as a chapter in the Handbook of Theoretical Computer Science, </note> <editor> van Leeuwen et al., eds. </editor> <publisher> North-Holland, </publisher> <year> 1990. </year>
Reference-contexts: In fact, as we show, the resulting unification can simulate any exponential time Turing Machine computation. This generic simulation illustrates how type reconstruction can be used (in an unconventional fashion) for computing with types. In Section 2, we review some basic notions. We follow the exposition of <ref> [MH88, Mit90] </ref>. We observe that the inference rule for let is not the one found in [DM82]. This alternative exposition does not change the semantics.
Reference: [MH88] <author> J. C. Mitchell and R. Harper. </author> <title> The essence of ML. </title> <booktitle> In Proceedings of the 15-th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 28-46, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: In fact, as we show, the resulting unification can simulate any exponential time Turing Machine computation. This generic simulation illustrates how type reconstruction can be used (in an unconventional fashion) for computing with types. In Section 2, we review some basic notions. We follow the exposition of <ref> [MH88, Mit90] </ref>. We observe that the inference rule for let is not the one found in [DM82]. This alternative exposition does not change the semantics. <p> We note that exponential lower bounds on ML type reconstruction have also been shown (independently and using altogether different methods) in [KTU90a]. 2 To the embarrassment of the third author, the incorrect "folk theorem" was put in print in <ref> [MH88] </ref>. A quadratic time bound for the problem was also claimed in [Lei83]. 3 2 ML expressions, types and unification. 2.1 Core ML.
Reference: [Myc84] <author> A. Mycroft. </author> <title> Polymorphic types schemes and recursive definitions. </title> <booktitle> In Proceedings International Symposium on Programming, </booktitle> <editor> M. Paul and B. Robinet eds, </editor> <booktitle> Lecture Notes in Computer Science 167, </booktitle> <publisher> Springer Verlag, </publisher> <pages> pages 217-228, </pages> <year> 1984. </year>
Reference-contexts: Both of these explanations deserve further investigation. In addition to the syntax of core ML, most ML dialects have a fixpoint combinator whose presence does not affect the complexity of type reconstruction. However, one extension of ML is based on polymorphic typing of the fixpoint combinator <ref> [Myc84] </ref>. Type reconstruction for this extension has been characterized in [Hen89, KTU89] as equivalent to semi-unification, and has recently been shown to be undecidable [KTU90b]. The analysis of semi-unification, under an acyclicity condition, is the basis for the proof of the exponential lower bounds in [KTU90a].
Reference: [PW78] <author> M. S. Paterson and M. N. Wegman. </author> <title> Linear unification. </title> <journal> Journal of Computer and System Sciences 16, </journal> <pages> pages 158-167, </pages> <year> 1978. </year>
Reference-contexts: Note that without let, ML type reconstruction can be done efficiently. This is type reconstruction for the simply typed lambda calculus, [CF58, Hin69, Wan87]. Using a linear time unification algorithm (e.g., <ref> [PW78] </ref>), we can compute the principal type of any let-free core ML expression in linear time. Even in this simple case, however, one must be 1 Following a proposal of Albert Meyer, we use the more precise term "type reconstruction" instead of "type inference". <p> To achieve linear time, types must be represented and printed out as directed acyclic graphs, or dags (see [AHU]), since the string representation of a type may be exponentially longer than the expression to be typed. Dag representations are a common data structure in unification <ref> [PW78, MM82, DKM84] </ref>. For a core ML expression with let, we give a straightforward deterministic type reconstruction algorithm which is exponential in the number of nested let declarations in the expression. The algorithm is based on a type-preserving transformation of the expression into a let-free equivalent. <p> A type reconstruction computation (such as the commonly used algorithm of [DM82]) proceeds in a syntax directed manner, where the types of expressions are derived via unification. Because of the succinctness introduced by let-polymorphism, the resulting unification is harder than classical first-order unification <ref> [Rob65, PW78, MM82] </ref>. In fact, as we show, the resulting unification can simulate any exponential time Turing Machine computation. This generic simulation illustrates how type reconstruction can be used (in an unconventional fashion) for computing with types. In Section 2, we review some basic notions. <p> If and t share type variables, then the type of M N will be t subject to the further constraints induced by the unification of and %. 6 While most implementations of unification have slightly higher asymptotic running time, unification can be done in linear time e.g., <ref> [PW78] </ref>. To perform unification efficiently, it is common to represent the expressions to be unified (in our case, type expressions) as directed acyclic graphs, [AHU]. <p> The Curry typing rules are syntax directed [GR88, Mit88]. Thus, by structural induction on lambda terms, one can show that the above nonrecursive algorithm is correct; a correctness proof for essentially this algorithm appears in [Wan87]. Steps (1-3) are clearly linear time. By <ref> [PW78] </ref>, step (4) can be done in linear time. 3.2 Type size with let. Before discussing expressions with large types, it may be helpful to review the behavior of the Damas-Milner ML typing algorithm on let expressions (algorithm PT in the Appendix).
Reference: [Rey74] <author> J. C. Reynolds. </author> <title> Towards a theory of type structure. </title> <booktitle> In Proceedings of the Paris Colloquium on Programming, Lecture Notes in Computer Science 19, </booktitle> <publisher> Springer Verlag, </publisher> <pages> pages 408-425, </pages> <year> 1974. </year>
Reference-contexts: The major remaining open problem is the decidability question (or 27 even any nontrivial lower bound) for type reconstruction in System F or second order typed lambda calculus <ref> [Gir72, Rey74] </ref>. Acknowledgements: Earlier versions of this work appeared in [KM89, Mai90]. We are grateful to Mitchell Wand and Peter Buneman for pointing out a number of interesting examples, and thank Gerard Huet and David MacQueen for discussions regarding the relevance of our lower bound to ML practice.
Reference: [Rob65] <author> J. A. Robinson. </author> <title> A machine oriented logic based on the resolution principle. </title> <journal> Journal of the ACM 12(1) </journal> <pages> 23-41, </pages> <year> 1965. </year>
Reference-contexts: A type reconstruction computation (such as the commonly used algorithm of [DM82]) proceeds in a syntax directed manner, where the types of expressions are derived via unification. Because of the succinctness introduced by let-polymorphism, the resulting unification is harder than classical first-order unification <ref> [Rob65, PW78, MM82] </ref>. In fact, as we show, the resulting unification can simulate any exponential time Turing Machine computation. This generic simulation illustrates how type reconstruction can be used (in an unconventional fashion) for computing with types. In Section 2, we review some basic notions. <p> If E is a set of equations between type expressions, then a substitution S unifies E if S = St for every equation = t 2 E. The unification algorithm of <ref> [Rob65] </ref> computes a most general unifying substitution, where S is more general than R if there is a substitution T with R = T ffi S (ffi denotes function composition). Proposition 2.5 (Robinson 65) Let E be any set of equations between type expressions.
Reference: [SM73] <author> L. J. Stockmeyer and A. R. Meyer. </author> <title> Word problems requiring exponential time. </title> <booktitle> In Proceedings of the 5-th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 1-9, </pages> <year> 1973. </year>
Reference-contexts: This is another example of a fundamental theme from complexity theory, namely, the use of succinctness for deriving unconditional lower bounds on natural computational problems, e.g., <ref> [Mey72, SM73] </ref>. Note that without let, ML type reconstruction can be done efficiently. This is type reconstruction for the simply typed lambda calculus, [CF58, Hin69, Wan87]. Using a linear time unification algorithm (e.g., [PW78]), we can compute the principal type of any let-free core ML expression in linear time. <p> This counting can be realized in O (log n) bits, to be represented in log n space given a suitably large work tape alphabet. Our generic simulation leads to completeness lower bounds, but also to unconditional lower bounds in the style of <ref> [Mey72, SM73] </ref>. In particular, consider the proof of the previous theorem with k = 1. In this case j M;x j cjxj for some constant c &gt; 0 depending on M .
Reference: [Tur85] <author> D. A. Turner. Miranda: </author> <title> A non-strict functional language with polymorphic types. </title> <booktitle> In IFIP International Conference on Functional Programming and Computer Architecture, Nancy, Lecture Notes in Computer Science 201, </booktitle> <pages> pages 1-16, </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Since the combination of ML polymorphism and type reconstruction has proven very useful in practice, the main ideas have also been adopted in other languages, such as Miranda <ref> [Tur85] </ref> and Haskell [HW88]. To simplify our analysis, we will focus on core ML expressions without recursion, using only lambda abstraction, function application, and let. Choosing a small fragment of ML makes our lower bound applicable to any extension.
Reference: [Wan87] <author> M. Wand. </author> <title> A simple algorithm and proof for type inference. </title> <note> Fundamenta In-formaticae 10 (1987). 30 </note>
Reference-contexts: This is another example of a fundamental theme from complexity theory, namely, the use of succinctness for deriving unconditional lower bounds on natural computational problems, e.g., [Mey72, SM73]. Note that without let, ML type reconstruction can be done efficiently. This is type reconstruction for the simply typed lambda calculus, <ref> [CF58, Hin69, Wan87] </ref>. Using a linear time unification algorithm (e.g., [PW78]), we can compute the principal type of any let-free core ML expression in linear time. <p> The Curry typing rules are syntax directed [GR88, Mit88]. Thus, by structural induction on lambda terms, one can show that the above nonrecursive algorithm is correct; a correctness proof for essentially this algorithm appears in <ref> [Wan87] </ref>. Steps (1-3) are clearly linear time. By [PW78], step (4) can be done in linear time. 3.2 Type size with let. Before discussing expressions with large types, it may be helpful to review the behavior of the Damas-Milner ML typing algorithm on let expressions (algorithm PT in the Appendix).
References-found: 34

