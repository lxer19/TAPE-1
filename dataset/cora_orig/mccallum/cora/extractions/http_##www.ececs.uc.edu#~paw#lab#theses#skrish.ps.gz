URL: http://www.ececs.uc.edu/~paw/lab/theses/skrish.ps.gz
Refering-URL: http://www.ececs.uc.edu/~paw/lab/theses.html
Root-URL: 
Title: The Design of a Time Warp Synchronized VHDL Simulation Kernel  
Degree: A Thesis Submitted to the  in partial fulfillment of the requirements for the degree of Master of Science in the Department of Electrical and Computer Engineering and Computer Science of The College of Engineering  by Krishnan Subramani B.Tech., Indian Institute of Technology, Madras, India, 1995 Thesis Advisor and Committee Chair: Dr. Philip A. Wilsey  
Date: February 13, 1998  
Affiliation: Division of Graduate Studies and Research of the University of Cincinnati  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Ashenden, P. </author> <title> The Designers Guide to VHDL. </title> <publisher> Morgan Kaufmann Publishers, Inc, </publisher> <address> San Mateo, CA, </address> <year> 1996. </year>
Reference-contexts: introduction to the language syntax and the simulation semantics. This is not a tutorial for VHDL. For a tutorial on VHDL constructs and concepts, I recommend the following books: Dr. Ashenden <ref> [1] </ref>, D. L. Perry [27], Z. Nawabi [22].
Reference: [2] <author> Bangalore, S., Zhou, W., and Carter, H. AnaVHDL: </author> <title> A Mixed-signal Simulator Using VHDL. </title> <booktitle> In International Conference on simulation and Hardware Description Languages (January 1994), </booktitle> <pages> pp. 43 - 47. </pages>
Reference-contexts: Not only does it provide an implementation of a standard, the parser and analyzer can be extended by the user to implement various VHDL tools. Currently this analyzer is being used to implement a VHDL simulator (part of this thesis work) and an VHDL-AMS <ref> [2, 13] </ref> simulator. The SAVANT implementation uses C++ to implement the AIRE specifications. The structures specified in the AIRE are implemented as C++ classes and their public interfaces, as public member methods in the classes.
Reference: [3] <author> Bauer, H., and Sporrer, C. </author> <title> Distributed logic simulation and an approach to asynchronous GVT-calculation. </title> <booktitle> In 6th Workshop on Parallel and Distributed Simulation (Jan. 1992), Society for Computer Simulation, </booktitle> <pages> pp. 205-208. </pages>
Reference-contexts: According to the definition, GVT is a property of the instantaneous global snapshot of the system at time r. This global snapshot can not be implemented directly in a distributed system, but an estimate of GVT can be computed. Numerous distributed algorithms <ref> [3, 4, 7, 9, 17, 20, 29] </ref> to estimate GVT have been proposed. According to the definition of GVT, it represents a lower bound to the time to which a process can rollback. Further, it has been shown that GVT advances monotonically with real time [15].
Reference: [4] <author> Bellenot, S. </author> <title> Global virtual time algorithms. In Distributed Simulation (Jan. </title> <booktitle> 1990), Society for Computer Simulation, </booktitle> <pages> pp. 122-127. </pages>
Reference-contexts: According to the definition, GVT is a property of the instantaneous global snapshot of the system at time r. This global snapshot can not be implemented directly in a distributed system, but an estimate of GVT can be computed. Numerous distributed algorithms <ref> [3, 4, 7, 9, 17, 20, 29] </ref> to estimate GVT have been proposed. According to the definition of GVT, it represents a lower bound to the time to which a process can rollback. Further, it has been shown that GVT advances monotonically with real time [15].
Reference: [5] <author> Brown, R. </author> <title> Calendar queues: A fast O(1) priority queue implementation for the simulation event set problem. </title> <journal> Communications of the ACM 31, </journal> <month> 10 (Oct. </month> <year> 1988), </year> <pages> 1220-1227. </pages>
Reference-contexts: In the following section, certain important building blocks of the warped kernel are explained. 4.5.1 Queues The Input Queue contains the events that have to be processed by the objects in an LP. Many implementations of the input queue have been suggested for Time Warp <ref> [5, 28] </ref>. In the warped implementation, the input queue is maintained as an LTSF (Lowest Time Stamp First) sorted linked list. However, the rest of the kernel is mostly ignorant of this implementation. Any implementation of the input queue with the prescribed interface may be used instead.
Reference: [6] <author> Chetlur, M., Abu-Ghazaleh, N., Radhakrishnan, R., and Wilsey, P. A. </author> <title> Optimizing communication in time-warp simulators. </title> <booktitle> In Parallel and Distributed Simulation (PADS 98) (1998), Society for Computer Simulation. </booktitle>
Reference-contexts: Though this might result in a large number of messages being sent across the network, it does not affect the performance significantly since warped has 70 a message aggregation <ref> [6] </ref> strategy built into it. 9.2 Wait statement A wait statement causes the simulation to suspend processing of the sequential statements following it and resume when any one of the signals in its sensitivity list (if any) become active and the condition clause (if any) evaluates to true.
Reference: [7] <author> D'Souza, L. M., Fan, X., and Wilsey, P. A. pGVT: </author> <title> An algorithm for accurate GVT estimation. </title> <booktitle> In Proc. of the 8th Workshop on Parallel and Distributed Simulation (PADS 94) (July 1994), Society for Computer Simulation, </booktitle> <pages> pp. 102-109. </pages>
Reference-contexts: According to the definition, GVT is a property of the instantaneous global snapshot of the system at time r. This global snapshot can not be implemented directly in a distributed system, but an estimate of GVT can be computed. Numerous distributed algorithms <ref> [3, 4, 7, 9, 17, 20, 29] </ref> to estimate GVT have been proposed. According to the definition of GVT, it represents a lower bound to the time to which a process can rollback. Further, it has been shown that GVT advances monotonically with real time [15].
Reference: [8] <author> Fujimoto, R. </author> <title> Parallel discrete event simulation. </title> <journal> Communications of the ACM 33, </journal> <month> 10 (Oct. </month> <year> 1990), </year> <pages> 30-53. </pages>
Reference-contexts: Time Warp simulation using the warped simulation kernel. 3.3 Simulation kernel The VHDL simulation kernel is built in two layers: the VHDL specific layer called TyVIS, and a general purpose discrete event simulation kernel called warped. warped [18, 19] implements an optimistic discrete event simulator based on the Time Warp <ref> [8, 14] </ref> synchronization paradigm. The simulation is partitioned into various concurrently executing entities called processes. A process interacts with others by exchanging events in the form of messages. A collection of processes is assigned to a Logical Process (LP). <p> basic simulation kernel to provide these additional features. 23 Chapter 4 An overview of warped The VHDL simulation kernel, TyVIS, is built on top of the warped simulation kernel. warped [18, 19] implements a general-purpose discrete event simulation kernel based on the Virtual Time [14] paradigm and the Time Warp <ref> [8, 14] </ref> algorithm. A knowledge of some of the concepts, terminologies, and implementation details of Virtual Time, Time Warp, and warped are necessary to understand the implementation of the TyVIS kernel. This chapter provides an introduction to the concepts and implementation of warped.
Reference: [9] <author> Fujimoto, R. M., and Hybinette, M. </author> <title> Computing global virtual time in shared-memory multiprocessors, </title> <month> Aug. </month> <year> 1994. </year>
Reference-contexts: According to the definition, GVT is a property of the instantaneous global snapshot of the system at time r. This global snapshot can not be implemented directly in a distributed system, but an estimate of GVT can be computed. Numerous distributed algorithms <ref> [3, 4, 7, 9, 17, 20, 29] </ref> to estimate GVT have been proposed. According to the definition of GVT, it represents a lower bound to the time to which a process can rollback. Further, it has been shown that GVT advances monotonically with real time [15].
Reference: [10] <author> Gropp, W., Lusk, E., and Skjellum, A. </author> <title> Using MPI: Portable Parallel Programming with the Message-Passing Interface. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1994. </year>
Reference-contexts: Different LPs may be assigned to different processors, thus distributing the simulation across a network of workstations. Messages are sent between LPs using message send and receive 22 calls compliant to the MPI message passing standard <ref> [10] </ref>, a portable communication layer. Messages between processes within the same LP are exchanged directly, without involving the network. On the arrival of an message (event), the process responsible for handling that event is invoked and executed. This execution may result in further events being generated.
Reference: [11] <institution> IEEE Standard VHDL Language Reference Manual. </institution> <address> New York, NY, </address> <year> 1988. </year>
Reference-contexts: This is not a tutorial for VHDL. For a tutorial on VHDL constructs and concepts, I recommend the following books: Dr. Ashenden [1], D. L. Perry [27], Z. Nawabi [22]. For a complete reference on VHDL and the semantics of simulation, refer the VHDL Language Reference Manual <ref> [11, 12] </ref>. 17 Chapter 3 Components of the VHDL Analyzer & Simulator A compiler can be broadly divided into three functional units, the front-end analyzer responsible for parsing and syntax checking, the semantic analyzer responsible for validating the semantics of the input, and the back-end which performs the code generation.
Reference: [12] <institution> IEEE Standard VHDL Language Reference Manual. </institution> <address> New York, NY, </address> <year> 1993. </year> <month> 99 </month>
Reference-contexts: This is not a tutorial for VHDL. For a tutorial on VHDL constructs and concepts, I recommend the following books: Dr. Ashenden [1], D. L. Perry [27], Z. Nawabi [22]. For a complete reference on VHDL and the semantics of simulation, refer the VHDL Language Reference Manual <ref> [11, 12] </ref>. 17 Chapter 3 Components of the VHDL Analyzer & Simulator A compiler can be broadly divided into three functional units, the front-end analyzer responsible for parsing and syntax checking, the semantic analyzer responsible for validating the semantics of the input, and the back-end which performs the code generation. <p> Some of these structures may be rewritten as a combination of other structures without any difference in functionality. Such structures are transmuted to their equivalent alternative structures (according to the rules prescribed by the VHDL LRM 1076-1993 <ref> [12] </ref>) so that code generation needs to be performed only for a minimal set of classes. The basic philosophy behind code generation has been 21 * to keep the code generator simple, * to minimize code generation, and * to make the generated code extensible. <p> The process of elaboration is explained in Chapter 10. At the end of elaboration, the system is ready to begin simulation. The processes 35 are simulated by following the algorithm given in the VHDL LRM 1076-1993 <ref> [12] </ref>. Simu--lation begins by executing all the processes once in the initialization phase. This results in certain events being generated, which are maintained in the input queue of the corresponding process by warped. These events are scheduled in a LTSF (Lowest Time Stamp First) scheme. <p> The inheritance and the methods provided in this type define its properties. VHDL LRM 1076-1993 <ref> [12] </ref> suggests a type classification (shown in Figure 2.3) which is adopted in TyVIS as shown in Figure 6.1. The relationships between the types is established through appropriate inheritance. <p> How are file operations handled correctly? The answer to the first question is obtained partly from the VHDL LRM 1076-1993 <ref> [12, x 4.3.1.4] </ref>. If multiple file objects are associated with the same external file, the language does not specify any order in which operations on the file are performed. <p> The problem raised by the second question can be solved by maintaining separate file queues for each of the file type objects in the system. Number of such objects may vary at run time since file objects declared in subprograms are elaborated dynamically VHDL LRM 1076-1993 <ref> [12, x [] </ref>4.3.1.4]. File queues have to be dynamically instantiated and manipulated to accommodate dynamic elaboration of file type declarations. The commitment of the events representing file operations are managed by warped. 6.7 Subtypes A subtype is used in VHDL to constrain a base type. <p> TyVIS implements subtypes as derived classes of the base type class. The derived class methods may be modified to reflect the additional constraints (if any). The type attributes 46 of the subtype is implemented by overriding the definitions in the base class. 6.8 Predefined types The VHDL LRM 1076-1993 <ref> [12] </ref> defines certain predefined types in VHDL, included in the packages standard and textio. TyVIS contains these two packages as a part of the kernel. <p> The semantics of their assignment, update, and evaluation are different from that of variables in most programming languages. This section will focus in detail on how TyVIS implements the semantics specified by the VHDL LRM 1076-1993 <ref> [12] </ref>. In general, a signal assignment generates an event with the required information and sends this to all the fanouts of the signal. <p> On receipt of the event it is inserted into the appropriate input queue, to be executed in chronological order. This design integrates the transaction list mentioned in the VHDL LRM 1076-1993 <ref> [12] </ref> into the input queue. Apart from the input queue, each process maintains a marked queue used to implement the algorithm for updating the projected output waveform given in the VHDL LRM 1076-1993 [12, x 8.4.1]. Unlike signal resolution, marking is performed at the source. <p> This design integrates the transaction list mentioned in the VHDL LRM 1076-1993 [12] into the input queue. Apart from the input queue, each process maintains a marked queue used to implement the algorithm for updating the projected output waveform given in the VHDL LRM 1076-1993 <ref> [12, x 8.4.1] </ref>. Unlike signal resolution, marking is performed at the source. After sending the events to the appropriate destinations, a copy of the event is inserted into the marked queue. The algorithm given in the VHDL LRM 1076-1993 [12] is then performed on this queue. <p> Unlike signal resolution, marking is performed at the source. After sending the events to the appropriate destinations, a copy of the event is inserted into the marked queue. The algorithm given in the VHDL LRM 1076-1993 <ref> [12] </ref> is then performed on this queue. For every event in the marked queue corresponding to a deleted transaction, a negative event is generated to cancel the event generated earlier. <p> Once the effective value of the signal is computed, these signals are updated by comparing the old value to the new value. The implicit signal S'DELAYED is not implemented in the kernel, rather a new equivalent process statement is generated as described in the VHDL LRM 1076-1993 <ref> [12, x 14.1] </ref>. Instead of updating all the other attributes, only the last active time, the last event time, and the last value are saved. All the other attributes such as S'EVENT, S'ACTIVE, S'LAST EVENT, S'LAST ACTIVE, S'LAST VALUE, can be computed from this information. <p> Following this, the design of the other forms of concurrent statements are discussed. Instead of implementing all these concurrent statements in TyVIS, these statements are transmuted, to equivalent process statements according to the rules given in the VHDL LRM 1076-1993 <ref> [12] </ref>. Once this is accomplished, only process statements need to be implemented in TyVIS. 61 8.1 Process statement The process statements provide a way of describing sequential algorithms in VHDL. Since warped is used as the underlying simulator, there is not much choice regarding the implementation of the process statement. <p> Further, a sensitized process statement is not allowed to contain a wait statement in its body. The VHDL LRM 1076-1993 <ref> [12] </ref> gives a method to convert any sensitized process statement to a process statement with no sensitivity list by appending an appropriate wait statement to the sequential statement list in its body. Figure 8.1 illustrates this equality. The VHDL LRM 1076-1993 [12] defines equivalences between various constructs, such as the one <p> The VHDL LRM 1076-1993 <ref> [12] </ref> gives a method to convert any sensitized process statement to a process statement with no sensitivity list by appending an appropriate wait statement to the sequential statement list in its body. Figure 8.1 illustrates this equality. The VHDL LRM 1076-1993 [12] defines equivalences between various constructs, such as the one mentioned above. <p> the code generation required. * Maintenance required is greatly reduced. * Allows reuse of constructs which aids in debugging the system. 8.2 Other Concurrent statements All the concurrent statements mentioned in this section are transmuted to an equivalent process statement according to the rules given by the VHDL LRM 1076-1993 <ref> [12] </ref>. Once this is achieved, these process statements can be implemented in TyVIS as any other process statement. <p> The body of the transmuted process statement contains a sequential procedure call to the same procedure and a wait statement. The sensitivity list of the wait statement is built from the argument list of the procedure call statement according to the rules given in the VHDL LRM 1076-1993 <ref> [12, x 8.1] </ref>. 8.2.2 Concurrent Assertion statement Concurrent assertion statement: label: &lt;Assertion Statement&gt;; label: process begin &lt;Assertion Statement&gt;; wait; end process; 66 A concurrent assertion statement is transmuted to a process statement with the statement part containing the original assertion statement and an empty wait statement as shown in Figure 8.3 <p> If the boolean condition expression of the assertion statement contains a name that denotes a signal, the equivalent process statement contains a final wait statement built according to the rules given in the VHDL LRM 1076-1993 <ref> [12, x 8.1] </ref>. 8.2.3 Concurrent Signal Assignment statement A concurrent signal assignment statement can take one of two forms, a conditional signal assignment statement or a selected signal assignment statement. <p> The VHDL LRM 1076-1993 <ref> [12, x 9.5] </ref> gives detailed transformation scheme to convert either of these concurrent statements to a process statement. Similar to the other transmutations, this transmuted process also contains a final wait statement with a sensitivity list. <p> Depending on this, it makes an unconditional jump (goto) to the corresponding instruction. Here, a call to the method resumeWait is made with the id of the wait statement and the value of the condition expression. This method determines, according to the rules specified in the VHDL LRM 1076-1993 <ref> [12] </ref>, if the wait resumes or continues suspension. On resumption, the statements following the wait statement in the executeVHDL method are executed until it suspends again. <p> Some information regarding the hierarchy, such as the type conversion and resolution functions, is necessary during the simulation of the design. During elaboration, these data are collected and maintained by the simulation kernel for use during elaboration. The VHDL LRM 1076-1993 <ref> [12] </ref> defines two kinds of elaboration, static and dy 76 namic. The elaboration of the design that can be performed just before the commencement of the simulation, such as propagation of generic constant values and computation of the net list of the signals, is called static elaboration. <p> Many of these may be rewritten as a combination of other simpler constructs, and some of them even eliminated. A few of the obvious ones are described in the VHDL LRM 1076-1993 <ref> [12] </ref>. By identifying more of these, the functions of the simulation kernel can be reduced and optimized better. * The Time Warp simulation paradigm still poses many unanswered questions.
Reference: [13] <institution> IEEE Draft Standard VHDL-AMS Language Reference Manual. </institution> <address> New York, NY, </address> <year> 1997. </year>
Reference-contexts: Not only does it provide an implementation of a standard, the parser and analyzer can be extended by the user to implement various VHDL tools. Currently this analyzer is being used to implement a VHDL simulator (part of this thesis work) and an VHDL-AMS <ref> [2, 13] </ref> simulator. The SAVANT implementation uses C++ to implement the AIRE specifications. The structures specified in the AIRE are implemented as C++ classes and their public interfaces, as public member methods in the classes.
Reference: [14] <author> Jefferson, D. </author> <title> Virtual time. </title> <journal> ACM Transactions on Programming Languages and Systems 7, </journal> <month> 3 (July </month> <year> 1985), </year> <pages> 405-425. </pages>
Reference-contexts: Time Warp simulation using the warped simulation kernel. 3.3 Simulation kernel The VHDL simulation kernel is built in two layers: the VHDL specific layer called TyVIS, and a general purpose discrete event simulation kernel called warped. warped [18, 19] implements an optimistic discrete event simulator based on the Time Warp <ref> [8, 14] </ref> synchronization paradigm. The simulation is partitioned into various concurrently executing entities called processes. A process interacts with others by exchanging events in the form of messages. A collection of processes is assigned to a Logical Process (LP). <p> TyVIS extends the basic simulation kernel to provide these additional features. 23 Chapter 4 An overview of warped The VHDL simulation kernel, TyVIS, is built on top of the warped simulation kernel. warped [18, 19] implements a general-purpose discrete event simulation kernel based on the Virtual Time <ref> [14] </ref> paradigm and the Time Warp [8, 14] algorithm. A knowledge of some of the concepts, terminologies, and implementation details of Virtual Time, Time Warp, and warped are necessary to understand the implementation of the TyVIS kernel. This chapter provides an introduction to the concepts and implementation of warped. <p> basic simulation kernel to provide these additional features. 23 Chapter 4 An overview of warped The VHDL simulation kernel, TyVIS, is built on top of the warped simulation kernel. warped [18, 19] implements a general-purpose discrete event simulation kernel based on the Virtual Time [14] paradigm and the Time Warp <ref> [8, 14] </ref> algorithm. A knowledge of some of the concepts, terminologies, and implementation details of Virtual Time, Time Warp, and warped are necessary to understand the implementation of the TyVIS kernel. This chapter provides an introduction to the concepts and implementation of warped. <p> The Time Warp algorithm presents a different synchronization mecha-nism. It is based on the virtual time paradigm developed by Jefferson <ref> [14] </ref>. The processes in a Time Warp simulation are loosely-synchronized, thus allowing greater exploitation of the available parallelism in the system. 4.1.1 The Virtual Time paradigm The virtual time is a measure of the simulation progress. <p> Apart from these local control mechanisms, the Time Warp algorithm involves a few global control mechanisms which are critical for its operation. The GVT computation algorithm is one such global control mechanism. GVT of a system at real time r is defined as follows in <ref> [14] </ref>. GVT at real time r is the minimum of (1) all virtual times in all virtual clocks at time r, and (2) of the virtual send times of all messages that have been sent but have not yet been processed at time r.
Reference: [15] <author> Kannikeswaran, B., Radhakrishnan, R., Frey, P., Alexander, P., and Wilsey, P. A. </author> <title> Formal specification and verification of the pGVT algorithm. </title> <booktitle> In FME '96: Industrial Benefit and Advances in Formal Methods (Mar. </booktitle> <year> 1996), </year> <editor> M.-C. Gaudel and J. Woodcock, Eds., </editor> <volume> vol. </volume> <booktitle> 1051 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 405-424. </pages>
Reference-contexts: Numerous distributed algorithms [3, 4, 7, 9, 17, 20, 29] to estimate GVT have been proposed. According to the definition of GVT, it represents a lower bound to the time to which a process can rollback. Further, it has been shown that GVT advances monotonically with real time <ref> [15] </ref>. These properties make GVT an ideal candidate for representing the virtual time of the system, a measure of progress of the simulation. The properties of the monotonic advance of GVT can be used in memory management. The states of a process has to be saved periodically to enable rollback.
Reference: [16] <author> Lamport, L. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of ACM (July 1978), </journal> <pages> 558-565. </pages>
Reference-contexts: The processes in the simulation communicate with the others by sending and receiving events. Each of these events contain four values: the sender, the receiver, the send time, and the receive time. The sending and receiving of these events are subject to Lamport's clock conditions <ref> [16] </ref>.
Reference: [17] <author> Lin, Y.-B., and Lazowska, E. </author> <title> Determining the global virtual time in a distributed simulation. </title> <booktitle> In 1990 International Conference on Parallel Processing (1990), </booktitle> <pages> pp. </pages> <month> III-201-III-209. </month>
Reference-contexts: According to the definition, GVT is a property of the instantaneous global snapshot of the system at time r. This global snapshot can not be implemented directly in a distributed system, but an estimate of GVT can be computed. Numerous distributed algorithms <ref> [3, 4, 7, 9, 17, 20, 29] </ref> to estimate GVT have been proposed. According to the definition of GVT, it represents a lower bound to the time to which a process can rollback. Further, it has been shown that GVT advances monotonically with real time [15].
Reference: [18] <author> Martin, D. E., McBrayer, T., and Wilsey, P. A. </author> <title> warped: A time warp simulation kernel for analysis and application development, </title> <note> 1995. (available on the www at http://www.ece.uc.edu/~paw/warped/). </note>
Reference-contexts: It is responsible for scheduling the processes, propagating the signals, updating the resolved signals by invoking the resolution function, managing I/O, and so on. This VHDL simulation kernel is implemented by TyVIS, which is built on top of the warped <ref> [18, 19] </ref> general purpose parallel discrete event simulation kernel. The Figure 3.1 sums up the entire discussion in this chapter. The input VHDL is transformed into a basic intermediate representation (IR) by the parser. The IR is refined during the semantic analysis and transformation. <p> been governed by the basic aim of this project: research and studies on Time Warp simulation using the warped simulation kernel. 3.3 Simulation kernel The VHDL simulation kernel is built in two layers: the VHDL specific layer called TyVIS, and a general purpose discrete event simulation kernel called warped. warped <ref> [18, 19] </ref> implements an optimistic discrete event simulator based on the Time Warp [8, 14] synchronization paradigm. The simulation is partitioned into various concurrently executing entities called processes. A process interacts with others by exchanging events in the form of messages. <p> TyVIS extends the basic simulation kernel to provide these additional features. 23 Chapter 4 An overview of warped The VHDL simulation kernel, TyVIS, is built on top of the warped simulation kernel. warped <ref> [18, 19] </ref> implements a general-purpose discrete event simulation kernel based on the Virtual Time [14] paradigm and the Time Warp [8, 14] algorithm.
Reference: [19] <author> Martin, D. E., McBrayer, T. J., and Wilsey, P. A. </author> <title> warped: A time warp simulation kernel for analysis and application development. </title> <booktitle> In 29th Hawaii International Conference on System Sciences (HICSS-29) (Jan. </booktitle> <year> 1996), </year> <editor> H. El-Rewini and B. D. Shriver, Eds., </editor> <volume> vol. Volume I, </volume> <pages> pp. 383-386. </pages>
Reference-contexts: It is responsible for scheduling the processes, propagating the signals, updating the resolved signals by invoking the resolution function, managing I/O, and so on. This VHDL simulation kernel is implemented by TyVIS, which is built on top of the warped <ref> [18, 19] </ref> general purpose parallel discrete event simulation kernel. The Figure 3.1 sums up the entire discussion in this chapter. The input VHDL is transformed into a basic intermediate representation (IR) by the parser. The IR is refined during the semantic analysis and transformation. <p> been governed by the basic aim of this project: research and studies on Time Warp simulation using the warped simulation kernel. 3.3 Simulation kernel The VHDL simulation kernel is built in two layers: the VHDL specific layer called TyVIS, and a general purpose discrete event simulation kernel called warped. warped <ref> [18, 19] </ref> implements an optimistic discrete event simulator based on the Time Warp [8, 14] synchronization paradigm. The simulation is partitioned into various concurrently executing entities called processes. A process interacts with others by exchanging events in the form of messages. <p> TyVIS extends the basic simulation kernel to provide these additional features. 23 Chapter 4 An overview of warped The VHDL simulation kernel, TyVIS, is built on top of the warped simulation kernel. warped <ref> [18, 19] </ref> implements a general-purpose discrete event simulation kernel based on the Virtual Time [14] paradigm and the Time Warp [8, 14] algorithm.
Reference: [20] <author> Mattern, F. </author> <title> Efficient algorithms for distributed snapshots and global virtual time approximation. </title> <journal> Journal of Parallel and Distributed Computing 18, </journal> <month> 4 (Aug. </month> <year> 1993), </year> <pages> 423-434. </pages>
Reference-contexts: According to the definition, GVT is a property of the instantaneous global snapshot of the system at time r. This global snapshot can not be implemented directly in a distributed system, but an estimate of GVT can be computed. Numerous distributed algorithms <ref> [3, 4, 7, 9, 17, 20, 29] </ref> to estimate GVT have been proposed. According to the definition of GVT, it represents a lower bound to the time to which a process can rollback. Further, it has been shown that GVT advances monotonically with real time [15].
Reference: [21] <author> McBrayer, T., and Wilsey, P. A. </author> <title> Process combination to increase event granularity in parallel logic simulation. </title> <booktitle> In 9th International Parallel Processing Symposium (Apr. </booktitle> <year> 1995), </year> <pages> pp. 572-578. </pages>
Reference-contexts: Listed below are some of the suggested revisions to the TyVIS and the warped kernels. Static Elaboration: The TyVIS kernel currently uses runtime elaboration (Section 10). Though this has its own advantages, it hinders certain optimizations that can be achieved with a statically elaborated design, such as process folding <ref> [21] </ref>. This work 92 is currently in progress. Type conversions in ports: The initial design of the elaboration mechanism and the data structures to hold the hierarchical information could not accommodate type conversions in ports. The design has since been revised and the problem solved.
Reference: [22] <author> Navabi, Z. </author> <title> VHDL: Analysis and Modeling of Digital Systems. </title> <publisher> McGraw-Hill, </publisher> <address> New York, NY, </address> <year> 1993. </year>
Reference-contexts: introduction to the language syntax and the simulation semantics. This is not a tutorial for VHDL. For a tutorial on VHDL constructs and concepts, I recommend the following books: Dr. Ashenden [1], D. L. Perry [27], Z. Nawabi <ref> [22] </ref>.
Reference: [23] <author> Parr, T. J. </author> <title> Language translation using PCCTS and C++: a reference guide. </title> <publisher> Automata Publishing Company, </publisher> <address> San Jose, CA, USA, </address> <month> Jan. </month> <year> 1997. </year> <note> PCCTS is a precursor to the ANTLR system [24]. </note>
Reference-contexts: This executable produces the required output of the input VHDL. 19 3.1 SAVANT parser and analyzer The front end of the analyzer is responsible for parsing the input VHDL model, checking for semantic validity, and building the intermediate representation. The parser, generated by supplying the VHDL grammar to PCCTS <ref> [23, 24, 25, 26] </ref>, creates a basic intermediate structure from the input VHDL. This process identifies all the syntactic errors in the input and generates appropriate error messages. Once a syntactically valid VHDL input has been parsed, it is analyzed for semantic validity.
Reference: [24] <author> Parr, T. J., Lilley, J., and Stanchfield, S. </author> <title> ANTLR 2.xx Reference Manual. ????, ????, 1998. ANTLR [25] is a redesign and rewrite of PCCTS [26] in Java. ANTLR generates parsers in C++ and Java. </title> <note> This book is still in preparation, and the title has not been settled. </note>
Reference-contexts: This executable produces the required output of the input VHDL. 19 3.1 SAVANT parser and analyzer The front end of the analyzer is responsible for parsing the input VHDL model, checking for semantic validity, and building the intermediate representation. The parser, generated by supplying the VHDL grammar to PCCTS <ref> [23, 24, 25, 26] </ref>, creates a basic intermediate structure from the input VHDL. This process identifies all the syntactic errors in the input and generates appropriate error messages. Once a syntactically valid VHDL input has been parsed, it is analyzed for semantic validity.
Reference: [25] <author> Parr, T. J., and Quong, R. W. </author> <title> ANTLR: A predicated-LL(k) parser generator. </title> <journal> Software | Practice and Experience 25, </journal> <month> 7 (July </month> <year> 1995), </year> <pages> 789-810. 100 </pages>
Reference-contexts: This executable produces the required output of the input VHDL. 19 3.1 SAVANT parser and analyzer The front end of the analyzer is responsible for parsing the input VHDL model, checking for semantic validity, and building the intermediate representation. The parser, generated by supplying the VHDL grammar to PCCTS <ref> [23, 24, 25, 26] </ref>, creates a basic intermediate structure from the input VHDL. This process identifies all the syntactic errors in the input and generates appropriate error messages. Once a syntactically valid VHDL input has been parsed, it is analyzed for semantic validity.
Reference: [26] <author> Parr, T. J., and Quong, R. W. </author> <title> LL and LR translators need k &gt; 1 lookahead. </title> <journal> ACM SIGPLAN Notices 31, </journal> <month> 2 (Feb. </month> <year> 1996), </year> <pages> 27-34. </pages>
Reference-contexts: This executable produces the required output of the input VHDL. 19 3.1 SAVANT parser and analyzer The front end of the analyzer is responsible for parsing the input VHDL model, checking for semantic validity, and building the intermediate representation. The parser, generated by supplying the VHDL grammar to PCCTS <ref> [23, 24, 25, 26] </ref>, creates a basic intermediate structure from the input VHDL. This process identifies all the syntactic errors in the input and generates appropriate error messages. Once a syntactically valid VHDL input has been parsed, it is analyzed for semantic validity.
Reference: [27] <author> Perry, D. L. </author> <title> VHDL, 2nd ed. </title> <publisher> McGraw-Hill, </publisher> <address> New York, NY, </address> <year> 1994. </year>
Reference-contexts: introduction to the language syntax and the simulation semantics. This is not a tutorial for VHDL. For a tutorial on VHDL constructs and concepts, I recommend the following books: Dr. Ashenden [1], D. L. Perry <ref> [27] </ref>, Z. Nawabi [22].
Reference: [28] <author> R onngren, R., Riboe, J., and Ayani, R. </author> <title> Lazy queue: An efficient implementation of the pending-event set. </title> <booktitle> In Proc. of the 24th Annual Simulation Symposium (Apr. </booktitle> <year> 1991), </year> <pages> pp. 194-204. </pages>
Reference-contexts: In the following section, certain important building blocks of the warped kernel are explained. 4.5.1 Queues The Input Queue contains the events that have to be processed by the objects in an LP. Many implementations of the input queue have been suggested for Time Warp <ref> [5, 28] </ref>. In the warped implementation, the input queue is maintained as an LTSF (Lowest Time Stamp First) sorted linked list. However, the rest of the kernel is mostly ignorant of this implementation. Any implementation of the input queue with the prescribed interface may be used instead.
Reference: [29] <author> Tomlinson, A. I., and Garg, V. K. </author> <title> An algorithm for minimally latent global virtual time. </title> <booktitle> In Proc of the 7th Workshop on Parallel and Distributed Simulation (PADS) (July 1993), Society for Computer Simulation, </booktitle> <pages> pp. 35-42. </pages>
Reference-contexts: According to the definition, GVT is a property of the instantaneous global snapshot of the system at time r. This global snapshot can not be implemented directly in a distributed system, but an estimate of GVT can be computed. Numerous distributed algorithms <ref> [3, 4, 7, 9, 17, 20, 29] </ref> to estimate GVT have been proposed. According to the definition of GVT, it represents a lower bound to the time to which a process can rollback. Further, it has been shown that GVT advances monotonically with real time [15].
Reference: [30] <author> Umamageswaran, K., Subramani, K., Wilsey, P. A., and Alexander, P. </author> <title> Formal verification and empirical analysis of rollback relaxation. </title> <journal> Journal of Systems Architecture (forthcoming) (1997). </journal> <note> Available online at http://www.ece.uc.edu/~kodi/ papers/jsa97/. </note>
Reference-contexts: Optimizations: There exists a whole host of optimizations that are have been suggested for improving the performance of a Time Warp based simulator. One such opti 93 mization that originated from the Computer Architecture and Design Laboratory is rollback relaxation <ref> [33, 30] </ref>. 94 Chapter 14 Conclusions and Suggestions for Future Research This thesis described the design and analysis that went into the creation of a VHDL simulation system the parser and analyzer, the code generator, the elaborator, and the simulation kernel.
Reference: [31] <author> Willis, J. C., Wilsey, P. A., Peterson, G. D., Hines, J., Zamfriescu, A., Martin, D. E., and Newshutz, R. N. </author> <title> Advanced intermediate representation with extensibility (AIRE). </title> <booktitle> In VHDL Users' Group Fall 1996 Conference (Oct. </booktitle> <year> 1996), </year> <pages> pp. 33-40. </pages>
Reference-contexts: Such differences can be determined only during the semantic analysis. The intermediate representation is transformed appropriately to reflect these semantic information. The intermediate representation generated by the SAVANT analyzer conforms to the AIRE (Advanced Intermediate Representation with Extensibility) specifications <ref> [31] </ref>. This specification defines a set of C++ classes for representing the corresponding constructs in VHDL. The specification is hierarchically defined and is implemented in C++ using class inheritance. The properties of these classes are specified by member objects and public method interfaces. <p> Once the mapping between the VHDL source and the corresponding C++ equivalent has been identified, the process of translation can be automated using a parser analyzer- code generator. A parser and analyzer has been developed that converts the VHDL source to the AIRE <ref> [31] </ref> (Advanced Intermediate Representation with Extensibility) intermediate format. This parser differs from any other due to the fact that it is not developed for a particular purpose, but as a general utility aimed at promoting the cooperation of various VHDL tools by adhering to a universal standard. <p> This chapter provides an introduction to this intermediate 81 format. Following this, the parser and analyzer developed to convert the VHDL source to AIRE representation are described. Finally, the code generator that forms the back end of the compiler is presented. 11.1 AIRE intermediate format AIRE <ref> [31] </ref> has been a proposed standard for representing VHDL (1076-87/93, 1076.1, 1364) designs in an intermediate form that is extensible. The object oriented and language independent design of the specifications permits it to be implemented on a variety of languages and platforms.
Reference: [32] <author> Wilsey, P. A., Martin, D. E., and Chawla, P. </author> <title> SAVANT: An extensible object-oriented intermediate for VHDL. </title> <booktitle> In VHDL Users' Group Spring 1996 Conference (Mar. </booktitle> <year> 1996), </year> <pages> pp. 275-281. </pages>
Reference-contexts: Such extensions may implement any tool compliant with the specified interface. The definition of FIR is very similar to IIR in both structure and content. 1 Object Oriented 82 11.2 SAVANT Parser and Analyzer SAVANT <ref> [32] </ref> (Standard Analyzer of VHDL Applications for Next-generation Technology) is an implementation of a VHDL 1076-93 parser and analyzer based on the AIRE specifications. It is a freely (or nearly freely) distributed software that attempts to promote the integration of VHDL into the industrial & university research communities.
Reference: [33] <author> Wilsey, P. A., and Palaniswamy, A. </author> <title> Rollback relaxation. </title> <type> Tech. Rep. TR 135-2-92-ECE, </type> <institution> Department of Electrical and Computer Engineering, University of Cincin-nati, </institution> <month> Feb. </month> <year> 1992. </year> <month> 101 </month>
Reference-contexts: Optimizations: There exists a whole host of optimizations that are have been suggested for improving the performance of a Time Warp based simulator. One such opti 93 mization that originated from the Computer Architecture and Design Laboratory is rollback relaxation <ref> [33, 30] </ref>. 94 Chapter 14 Conclusions and Suggestions for Future Research This thesis described the design and analysis that went into the creation of a VHDL simulation system the parser and analyzer, the code generator, the elaborator, and the simulation kernel.
References-found: 33

