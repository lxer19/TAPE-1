URL: ftp://ftp.cs.utexas.edu/pub/predator/tr-95-03.ps.Z
Refering-URL: http://www.cs.utexas.edu/users/schwartz/pub.htm
Root-URL: 
Title: Validating Component Compositions in Software System Generators  
Author: Don Batory and Bart J. Geraci 
Keyword: Inscape, software architectures, software system generators, attribute grammars, domain models, GenVoca, software components, explanation-based error reporting.  
Address: Austin, Texas 78712  
Affiliation: Department of Computer Sciences The University of Texas  
Date: 1 9/1/95  
Abstract: Generators synthesize software systems by composing components from reuse libraries. In general, not all syntactically correct compositions are semantically correct. In this paper, we present domain-independent algorithms for the GenVoca model of software system generation to validate component compositions. Our work relies on attribute grammars and offers powerful debugging capabilities with explanation-based error reporting. We illustrate our approach by showing how component compositions are debugged by a GenVoca generator for container data structures. 
Abstract-found: 1
Intro-found: 1
Reference: [Aho88] <author> A.V. Aho, R. Sethi, and J.D. Ullman, </author> <booktitle> Compilers: Principles, Techniques, and Tools, </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1988. </year>
Reference-contexts: operators , fi, and D, there is a simple, recursive algorithm for the bottom-up propagation of postrestrictions and the testing of parameter prerestrictions (see Appendix). 4.3 Attribute Grammars McAllester [McA94] observed that the concepts of realms, components, attributes, top-down and bottom-up design rule checking can be unified by attribute grammars <ref> [Aho88] </ref>. From previous sections, we know that realms of components define a grammar.
Reference: [Bat85] <author> D. S. Batory, </author> <title> Modeling the Storage Architectures of Commercial Database Systems. </title> <journal> ACM Transactions on Database Systems, </journal> <month> December </month> <year> 1985. </year> <pages> 15 9/1/95 </pages>
Reference-contexts: That is: D ( postrestriction 1 , postrestriction 2 , ) = postrestriction 1 The reasons for this are rather involved and peculiar to the domain of data structures and databases (see <ref> [Bat85] </ref> for further justification).
Reference: [Bat92a] <author> D. Batory and S. OMalley, </author> <title> The Design and Implementation of Hierarchical Software Systems with Reusable Components, </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <month> October </month> <year> 1992. </year>
Reference-contexts: The particular class of generators that we consider in this paper, called GenVoca generators <ref> [Bat92a] </ref>, is distinguished from the above approaches in that their components are parameterized forward-refinement program transformations that encapsulate consistent data and operation refinements. Components also encapsulate logic to automate domain-specific decisions about when to use a particular algorithm or when to apply a domain-specific optimization. <p> Note that composing components can be interpreted as stacking layers in hierarchical software systems. We use the terms component and layer interchangeably in this paper. 4. Unix file filters can be composed in arbitrary orders and are simple examples of symmetric components. Other examples are given in <ref> [Bat92a] </ref>. 4 9/1/95 and random storage). mem components export standardized memory allocation and deallocation opera tions.
Reference: [Bat92b] <author> D. S. Batory and J. R. Barnett. DaTE: </author> <title> The Genesis DBMS Software Layout Editor. In Conceptual Modeling, Databases, and CASE, </title> <editor> Pericles Loucopoulos and Roberto Zicari, eds. </editor> <publisher> John Wiley & Sons, </publisher> <address> New York, New York. </address> <year> 1992. </year>
Reference-contexts: Shallow consistency checking is certainly not new to generators. DRACO, for example used a form of shallow consistency checking (called assertions and conditions) in composing layers of transformations [Nei80]. An early version of our DRC algorithms appeared in DaTE, the design rule checker for Genesis <ref> [Bat92b] </ref>. DaTE only supported component preconditions; there were no prerestric-tions. The limitations of DaTE led to the work presented in this paper. McAllester developed a functional programming language, VAG, based on variational attribute grammars, to address the design rule checking issues for the ADAGE generator [McA94].
Reference: [Bat93] <author> D. Batory, V. Singhal, M. Sirkin, and J. Thomas, </author> <title> Scalable Software Libraries, </title> <booktitle> Proc. ACM SIGSOFT, </booktitle> <month> December </month> <year> 1993. </year>
Reference-contexts: Although the number of fundamental abstractions in a domain is rather small, there is a huge number of potential implementations. GenVoca also advocates a layered decomposition of implementations, where each layer or component encapsulates a primitive domain feature. The advantage of GenVoca is scalability <ref> [Bat93, Big94] </ref>: component libraries are relatively small and grow at the rate new components are entered, whereas the number of possible combinations of components (i.e., distinct software systems in the domain that can be defined) grows astronomically. <p> Generators that use GenVoca organizations have been built for the domains of avionics, data structures, databases, file systems, and network protocols <ref> [Cog93, Bat93, Hei93, Hut91] </ref>. Components and Realms. A hierarchical software system is defined by a series of progressively more abstract virtual machines. A component or layer is an implementation of a virtual machine.
Reference: [Bat94] <author> D. Batory, J. Thomas, and M. Sirkin, </author> <title> Re-engineering a Complex Application Using a Scalable Data Structure Compiler, </title> <booktitle> Proc. ACM SIGSOFT 1994. </booktitle>
Reference: [Bat95] <author> D. Batory and B.J. Geraci, </author> <title> Validating Component Compositions in Software System Generators, </title> <institution> Dept. Computer Sciences, TR-95-03, University of Texas at Austin, </institution> <year> 1995. </year>
Reference: [Bax92] <author> I. Baxter, </author> <title> Design Maintenance Systems, </title> <journal> CACM April 1992, </journal> <pages> 73-89. </pages>
Reference-contexts: This will be accomplished through the use of software system generators. Such generators will automatically transform compact, high-level specifications of target systems into actual source code, and will rely on libraries of parameterized, plug-compatible, and reusable components for code synthesis. Generators <ref> [Bat92, Bax92, Bla91, Gom94, Gra92, Lei94, Nin94] </ref> are among a number of approaches that are now being explored to construct customized software systems quickly and inexpensively from reuse libraries.
Reference: [Bla91] <author> L. Blaine and A. Goldberg, </author> <title> DTRE - A Semi-Automatic Transformation System, in Constructing Programs from Specifications, </title> <publisher> Elsevier Science Publishers, </publisher> <year> 1991. </year>
Reference-contexts: This will be accomplished through the use of software system generators. Such generators will automatically transform compact, high-level specifications of target systems into actual source code, and will rely on libraries of parameterized, plug-compatible, and reusable components for code synthesis. Generators <ref> [Bat92, Bax92, Bla91, Gom94, Gra92, Lei94, Nin94] </ref> are among a number of approaches that are now being explored to construct customized software systems quickly and inexpensively from reuse libraries.
Reference: [Boo91] <author> G. Booch. </author> <title> Object-Oriented Design With Applications, </title> <address> Benjamin-Cummings, </address> <year> 1991. </year>
Reference-contexts: Second, we believe that GenVoca offers a powerful methodology for the design of reusable components. Object-oriented design methodologies, for example, are powerful because of their ability to manage and control software complexity <ref> [Rum91, Boo91] </ref>. It is not difficult to recognize that standardizing domain abstractions and their programming interfaces (i.e., the core of GenVoca) is also a powerful way of managing and controlling the complexity of software in a family of systems.
Reference: [Big94] <author> T. Biggerstaff. </author> <title> The Library Scaling Problem and the Limits of Concrete Component Reuse, </title> <booktitle> IEEE International Conference on Software Reuse, </booktitle> <month> November </month> <year> 1994. </year>
Reference-contexts: Although the number of fundamental abstractions in a domain is rather small, there is a huge number of potential implementations. GenVoca also advocates a layered decomposition of implementations, where each layer or component encapsulates a primitive domain feature. The advantage of GenVoca is scalability <ref> [Bat93, Big94] </ref>: component libraries are relatively small and grow at the rate new components are entered, whereas the number of possible combinations of components (i.e., distinct software systems in the domain that can be defined) grows astronomically.
Reference: [Coh95] <author> S. Cohen, R. Krut, S. Peterson, and J. Withey, </author> <title> Models for Domains and Architectures: A Prescription for Systematic Software Reuse, </title> <booktitle> 10th AIAA Computing in Aerospace, </booktitle> <year> 1995. </year>
Reference: [Cog93] <author> L. Coglianese and R. Szymanski, </author> <title> DSSA-ADAGE: An Environment for Architecture-based Avionics Development, </title> <booktitle> Proc. </booktitle> <address> AGARD, </address> <year> 1993. </year>
Reference-contexts: Generators that use GenVoca organizations have been built for the domains of avionics, data structures, databases, file systems, and network protocols <ref> [Cog93, Bat93, Hei93, Hut91] </ref>. Components and Realms. A hierarchical software system is defined by a series of progressively more abstract virtual machines. A component or layer is an implementation of a virtual machine. <p> Benign errors (such as the unnecessary redundancy of components) are reported to users by dreck, while fatal errors terminate code generation. Second, the notation that we adopted in Section 2 does not indicate that components often have non-realm parameters. Such parameters, called configuration parameters <ref> [Cog93] </ref>, include data types, tuning constants, performance constraints, etc. Configuration parameters are presently checked during the compilation of P2 programs or their corresponding C programs.
Reference: [Gar94] <author> D. Garlan, R. Allen, and J. Ockerbloom, </author> <title> Exploiting Style in Architectural Design Environments, </title> <booktitle> ACM SIGSOFT 1994. </booktitle>
Reference: [Gar95] <author> D. Garlan, R. Allen, J. Ockerbloom, </author> <title> Architectural Mismatch or Why Its Hard to Build Systems out of Existing Parts, </title> <booktitle> Proc. ICSE 1995, Seattle, </booktitle> <pages> 179-185. </pages>
Reference-contexts: We believe that standardization makes some problems tractable that would otherwise be very difficult. Standardization substantially simplifies software composition (c.f., <ref> [Gar95] </ref>). Design rule checking is another example: standardization seems to limit the number of ways in which components can constrain each others behavior. This, in turn, makes DRC tractable. 8 Conclusions Software system generators are becoming important tools for software developers.
Reference: [Gog83] <author> J.A. Goguen, </author> <title> Parameterized Programming, </title> <booktitle> Workshop on Reusability in Programming. </booktitle> <address> Newport, Rhode Island, </address> <month> September </month> <year> 1983. </year>
Reference-contexts: The VAG interpreter has limited reasoning abilities to infer values of unbound VAG program parameters. Parameterized programming is intimately associated with the verification of component compositions. Goguens work on OBJ <ref> [Gog83] </ref> and library interconnection languages, such as LIL and LILEANNA [Gog86, Tra93], are basic. The RESOLVE project explores the design of reusable and parameterized components, component certifiability, and the certifiability of component compositions [Sit94]. There are many similarities among these works and ours.
Reference: [Gog86] <author> J.A. Goguen, </author> <title> Reusing and Interconnecting Software Components, </title> <booktitle> Computer. </booktitle> <month> February </month> <year> 1986, </year> <pages> 16-28. </pages>
Reference-contexts: The VAG interpreter has limited reasoning abilities to infer values of unbound VAG program parameters. Parameterized programming is intimately associated with the verification of component compositions. Goguens work on OBJ [Gog83] and library interconnection languages, such as LIL and LILEANNA <ref> [Gog86, Tra93] </ref>, are basic. The RESOLVE project explores the design of reusable and parameterized components, component certifiability, and the certifiability of component compositions [Sit94]. There are many similarities among these works and ours. One similarity is that GenVoca type equations are a simple module/library interconnection language.
Reference: [Gom94] <author> H. Gomaa, L. Kerschberg, V. Sugumaran, C. Bosch, and I. Tavakoi, </author> <title> A Prototype Domain Modeling Environment for reusable Software Architectures, </title> <booktitle> IEEE International Conference on Software Reuse, </booktitle> <address> Rio de Janeiro, </address> <month> November </month> <year> 1994. </year>
Reference-contexts: This will be accomplished through the use of software system generators. Such generators will automatically transform compact, high-level specifications of target systems into actual source code, and will rely on libraries of parameterized, plug-compatible, and reusable components for code synthesis. Generators <ref> [Bat92, Bax92, Bla91, Gom94, Gra92, Lei94, Nin94] </ref> are among a number of approaches that are now being explored to construct customized software systems quickly and inexpensively from reuse libraries.
Reference: [Gra92] <author> M. Graham and E. Mettala, </author> <title> The Domain-Specific Software Architecture Program, </title> <booktitle> Proceedings of DARPA Software Technology Conference, </booktitle> <year> 1992. </year> <note> Also, in Crosstalk: The Journal of Defense Software Engineering, </note> <month> October </month> <year> 1992. </year>
Reference-contexts: This will be accomplished through the use of software system generators. Such generators will automatically transform compact, high-level specifications of target systems into actual source code, and will rely on libraries of parameterized, plug-compatible, and reusable components for code synthesis. Generators <ref> [Bat92, Bax92, Bla91, Gom94, Gra92, Lei94, Nin94] </ref> are among a number of approaches that are now being explored to construct customized software systems quickly and inexpensively from reuse libraries.
Reference: [Gri94] <author> M.L. Griss and K.D. Wentzel, </author> <title> Hybrid Domain-Specific Kits for a Flexible Software Factory, </title> <booktitle> Proceedings of SAC94, ACM, </booktitle> <month> March </month> <year> 1994. </year>
Reference-contexts: CORBA and its variants simplify the task of building distributed applications from components [Ude94]; CORBA can integrate components that are independently designed and stand-alone modules or executables in a heterogeneous environment. In contrast, generators are closer to toolkits <ref> [Gri94] </ref>, object-oriented frameworks [Joh92], and other reuse-driven approaches (e.g, [Wei90, Sit94]), because they focus on software domains whose components are not stand-alone, that are designed to be plug-compatible and interoperable with other components, and that are written in a single language.
Reference: [Hei93] <author> J. Heidemann and G. Popek, </author> <title> File System Development with Stackable Layers, </title> <journal> ACM Transactions on Computer Systems, </journal> <month> March </month> <year> 1993. </year>
Reference-contexts: Generators that use GenVoca organizations have been built for the domains of avionics, data structures, databases, file systems, and network protocols <ref> [Cog93, Bat93, Hei93, Hut91] </ref>. Components and Realms. A hierarchical software system is defined by a series of progressively more abstract virtual machines. A component or layer is an implementation of a virtual machine.
Reference: [Hut91] <author> N. Hutchinson and L. Peterson, </author> <title> The x-kernel: An Architecture for Implementing Network Protocols, </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> January </month> <year> 1991. </year>
Reference-contexts: Generators that use GenVoca organizations have been built for the domains of avionics, data structures, databases, file systems, and network protocols <ref> [Cog93, Bat93, Hei93, Hut91] </ref>. Components and Realms. A hierarchical software system is defined by a series of progressively more abstract virtual machines. A component or layer is an implementation of a virtual machine.
Reference: [Joh92] <author> R.E. Johnson, </author> <title> Documenting Frameworks using Patterns, </title> <booktitle> OOPSLA 1992, </booktitle> <pages> 63-76. </pages>
Reference-contexts: CORBA and its variants simplify the task of building distributed applications from components [Ude94]; CORBA can integrate components that are independently designed and stand-alone modules or executables in a heterogeneous environment. In contrast, generators are closer to toolkits [Gri94], object-oriented frameworks <ref> [Joh92] </ref>, and other reuse-driven approaches (e.g, [Wei90, Sit94]), because they focus on software domains whose components are not stand-alone, that are designed to be plug-compatible and interoperable with other components, and that are written in a single language.
Reference: [Lei94] <author> J.C.S. do Prado Leite, M. SantAnna, and F.G. de Freitas, Draco-PUC: </author> <title> A Technology Assembly for Domain-Oriented Software Development, </title> <booktitle> IEEE International Conference on Software Reuse, </booktitle> <address> Rio de Janeiro, </address> <month> November </month> <year> 1994. </year>
Reference-contexts: This will be accomplished through the use of software system generators. Such generators will automatically transform compact, high-level specifications of target systems into actual source code, and will rely on libraries of parameterized, plug-compatible, and reusable components for code synthesis. Generators <ref> [Bat92, Bax92, Bla91, Gom94, Gra92, Lei94, Nin94] </ref> are among a number of approaches that are now being explored to construct customized software systems quickly and inexpensively from reuse libraries.
Reference: [McA94] <author> D. McAllester. </author> <title> Variational Attribute Grammars for Computer Aided Design. </title> <journal> ADAGE-MIT-94-01. </journal> <volume> 16 9/1/95 </volume>
Reference-contexts: Given the operators , fi, and D, there is a simple, recursive algorithm for the bottom-up propagation of postrestrictions and the testing of parameter prerestrictions (see Appendix). 4.3 Attribute Grammars McAllester <ref> [McA94] </ref> observed that the concepts of realms, components, attributes, top-down and bottom-up design rule checking can be unified by attribute grammars [Aho88]. From previous sections, we know that realms of components define a grammar. <p> DaTE only supported component preconditions; there were no prerestric-tions. The limitations of DaTE led to the work presented in this paper. McAllester developed a functional programming language, VAG, based on variational attribute grammars, to address the design rule checking issues for the ADAGE generator <ref> [McA94] </ref>. Preconditions and prere-strictions are treated uniformly as constraints. The constraints associated with a component are expressed as a VAG program. When an avionics system is composed from components, the set of constraints that must be satisfied is defined by the composition of corresponding VAG programs.
Reference: [Mor94] <author> M. Moriconi and X. Qian, </author> <title> Correctness and Composition of Software Architectures, </title> <booktitle> ACM SIGSOFT 1994. </booktitle>
Reference-contexts: Compositions of OBJ, LILEANNA, and RESOLVE components are verified locally; components constrain the behavior of immediately adjacent components, and not components that reside far above or below them in a hierarchy. Our work is also an example of the types of consistency checking problems encountered in software architectures <ref> [Per92, Gar94-95, Mor94] </ref>. To our knowledge, other than Inscape, validating compositions of components in the context of architectures has only begun to be addressed. Insights. Our work on DRC was actually developed independently of DRACO and Inscape.
Reference: [Nei80] <author> J. Neighbors, </author> <title> Software Construction Using Components, </title> <type> Ph.D. Thesis, </type> <institution> TR-160, ICS Department, University of California at Irvine, </institution> <year> 1980. </year>
Reference-contexts: Shallow consistency checking is certainly not new to generators. DRACO, for example used a form of shallow consistency checking (called assertions and conditions) in composing layers of transformations <ref> [Nei80] </ref>. An early version of our DRC algorithms appeared in DaTE, the design rule checker for Genesis [Bat92b]. DaTE only supported component preconditions; there were no prerestric-tions. The limitations of DaTE led to the work presented in this paper.
Reference: [Nin94] <author> J.Q. Ning, K. Miriyala, and W. Kozaczynski, </author> <title> An Architecture-Driven, Business-Specific, and Component-Based Approach to Software Engineering, </title> <booktitle> IEEE International Conference on Software Reuse, </booktitle> <address> Rio de Janeiro, </address> <month> November </month> <year> 1994. </year>
Reference-contexts: This will be accomplished through the use of software system generators. Such generators will automatically transform compact, high-level specifications of target systems into actual source code, and will rely on libraries of parameterized, plug-compatible, and reusable components for code synthesis. Generators <ref> [Bat92, Bax92, Bla91, Gom94, Gra92, Lei94, Nin94] </ref> are among a number of approaches that are now being explored to construct customized software systems quickly and inexpensively from reuse libraries.
Reference: [Par76] <author> D.L. Parnas, </author> <title> On the Design and Development of Program Families, </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> March </month> <year> 1976. </year>
Reference-contexts: Figure 1a enumerated realms S, T, and W; the corresponding grammar is shown in Figure 1b. Just as the set of all sentences defines a language, the set of all component compositions defines a Parnas family of systems <ref> [Par76] </ref>. Adding a new component to a realm is akin to adding a new rule to a grammar; the family of systems enlarges automatically. Because large families of systems can be built using relatively few components, GenVoca is a scalable model of software construction. Symmetry.
Reference: [Per87] <author> D.E. Perry, </author> <title> Software Interconnection Models, </title> <booktitle> Proc. ICSE 1987, </booktitle> <pages> 61-69. </pages>
Reference: [Per89a] <author> D.E. Perry, </author> <title> The Logic of Propagation in The Inscape Environment, </title> <booktitle> ACM SIGSOFT 1989, </booktitle> <pages> 114-121. </pages>
Reference: [Per89b] <author> D. E. Perry, </author> <title> The Inscape Environment, </title> <booktitle> Proc. ICSE 1989, </booktitle> <pages> 2-12. </pages>
Reference-contexts: We believe that a domain-independent tool can be created that eliminates the burden of DRC software development. Generalizing attributes types, predicates, and DRC operators without sacrificing automatic DRC is the key issue <ref> [Per89b] </ref>. Fourth, it may be possible to be more aggressive in repairing composition errors. For example, it seems likely that some errors can be repaired automatically (e.g., inserting inbetween into an equation).
Reference: [Per92] <author> D.E. Perry and A.L. Wolf, </author> <title> Foundations for the Study of Software Architecture, </title> <booktitle> ACM SIGSOFT Software Engineering Notes, </booktitle> <month> October </month> <year> 1992, </year> <pages> 40-52. </pages>
Reference-contexts: Compositions of OBJ, LILEANNA, and RESOLVE components are verified locally; components constrain the behavior of immediately adjacent components, and not components that reside far above or below them in a hierarchy. Our work is also an example of the types of consistency checking problems encountered in software architectures <ref> [Per92, Gar94-95, Mor94] </ref>. To our knowledge, other than Inscape, validating compositions of components in the context of architectures has only begun to be addressed. Insights. Our work on DRC was actually developed independently of DRACO and Inscape.
Reference: [Rum91] <author> J. Rumbaugh, M. Blaha, W. Premerlani, F. Eddy, and W. Lorensen, </author> <title> Object-Oriented Modeling and Design, </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: Second, we believe that GenVoca offers a powerful methodology for the design of reusable components. Object-oriented design methodologies, for example, are powerful because of their ability to manage and control software complexity <ref> [Rum91, Boo91] </ref>. It is not difficult to recognize that standardizing domain abstractions and their programming interfaces (i.e., the core of GenVoca) is also a powerful way of managing and controlling the complexity of software in a family of systems.
Reference: [Sit94] <author> M. Sitaraman and B. Weide, </author> <title> Component-Based Software using RESOLVE, </title> <booktitle> ACM Software Engineering Notes, </booktitle> <month> October, </month> <year> 1994. </year>
Reference-contexts: CORBA and its variants simplify the task of building distributed applications from components [Ude94]; CORBA can integrate components that are independently designed and stand-alone modules or executables in a heterogeneous environment. In contrast, generators are closer to toolkits [Gri94], object-oriented frameworks [Joh92], and other reuse-driven approaches (e.g, <ref> [Wei90, Sit94] </ref>), because they focus on software domains whose components are not stand-alone, that are designed to be plug-compatible and interoperable with other components, and that are written in a single language. <p> Parameterized programming is intimately associated with the verification of component compositions. Goguens work on OBJ [Gog83] and library interconnection languages, such as LIL and LILEANNA [Gog86, Tra93], are basic. The RESOLVE project explores the design of reusable and parameterized components, component certifiability, and the certifiability of component compositions <ref> [Sit94] </ref>. There are many similarities among these works and ours. One similarity is that GenVoca type equations are a simple module/library interconnection language. However, there is a basic difference: there is no action-at-a-distance.
Reference: [Tra93] <author> W. Tracz, LILEANNA: </author> <title> A Parameterized Programming Language, </title> <booktitle> Advances in Software Reuse: Selected Papers from the Second International Workshop on Software Reusability. Lucca, Italy. </booktitle> <editor> R. Prieto-Daz and W.B. Frakes, eds. </editor> <publisher> IEEE Computer Science Press, </publisher> <year> 1993. </year>
Reference-contexts: The VAG interpreter has limited reasoning abilities to infer values of unbound VAG program parameters. Parameterized programming is intimately associated with the verification of component compositions. Goguens work on OBJ [Gog83] and library interconnection languages, such as LIL and LILEANNA <ref> [Gog86, Tra93] </ref>, are basic. The RESOLVE project explores the design of reusable and parameterized components, component certifiability, and the certifiability of component compositions [Sit94]. There are many similarities among these works and ours. One similarity is that GenVoca type equations are a simple module/library interconnection language.
Reference: [Ude94] <author> J. Udell, Componentware, BYTE, </author> <month> May </month> <year> 1994. </year>
Reference-contexts: Generators [Bat92, Bax92, Bla91, Gom94, Gra92, Lei94, Nin94] are among a number of approaches that are now being explored to construct customized software systems quickly and inexpensively from reuse libraries. CORBA and its variants simplify the task of building distributed applications from components <ref> [Ude94] </ref>; CORBA can integrate components that are independently designed and stand-alone modules or executables in a heterogeneous environment.

References-found: 37

