URL: ftp://ftp.eecs.umich.edu/groups/gasm/object.ps
Refering-URL: http://www.eecs.umich.edu/gasm/papers.html
Root-URL: http://www.cs.umich.edu
Email: e-mail: gottlob@vexpert.dbai.tuwien.ac.at  
Title: Semantics of Object-Oriented Data Models The Evolving Algebra Approach  
Author: Georg Gottlob Gerti Kappel Michael Schrefl 
Address: Paniglgasse 16, A-1040 Vienna, Austria  Vienna  
Affiliation: Department of Applied Computer Science,Vienna University of Technology  Department of Statistics and Computer Science, University of  
Abstract: The formal description of the semantics of object-oriented data models is still an open problem. Some characteristic features of object-oriented data models, such as methods and inheritance, involve investigating data and schema. Therefore they can not be handled straightforwardly with first order logic. As an alternative, we propose the evolving algebra approach to specify the formal semantics of object-oriented data models. Evolving algebras provide a framework for defining the operational semantics of programming languages based on dynamic structures. In this paper we show how evolving algebras can be used in particular to define the operational semantics of object creation, of overriding and dynamic binding, and of inheritance at the type level (type specialization) and at the instance level (object specialization).
Abstract-found: 1
Intro-found: 1
Reference: [Atki89] <author> M.B. Atkinson, F. Bancilhon, D. DeWitt, K. Dittrich, D. Maier and S. Zdonik, </author> <title> "The Object-Oriented Database System Manifesto," </title> <booktitle> Proc. </booktitle> <address> DOOD'89, </address> <year> 1989, </year> <pages> pp. 40-57. </pages>
Reference-contexts: 1 Introduction Object-oriented data models have gained wide attention in recent years. Much of the confusion about the characteristic features of an object-oriented data model has been clarified by "The Object-Oriented Database System Manifesto" <ref> [Atki89] </ref>. But the formal description of the semantics of object-oriented data models is still a research issue [Beer90]. The favorite approach of database theoreticians to define semantics in terms of first-order logic can not be applied straightforwardly to object-oriented data models.
Reference: [Beer90] <author> C. Beeri, </author> <title> "A Formal Approach to Object-Oriented Databases," </title> <booktitle> Data & Knowledge Engineering (5), </booktitle> <year> 1990, </year> <pages> pp. 353-382. </pages>
Reference-contexts: Much of the confusion about the characteristic features of an object-oriented data model has been clarified by "The Object-Oriented Database System Manifesto" [Atki89]. But the formal description of the semantics of object-oriented data models is still a research issue <ref> [Beer90] </ref>. The favorite approach of database theoreticians to define semantics in terms of first-order logic can not be applied straightforwardly to object-oriented data models. Defining characteristic features of object-oriented data models, such as methods and inheritance, involves investigating data and schema. As pointed out by Beeri [Beer90], it is burdensome to <p> still a research issue <ref> [Beer90] </ref>. The favorite approach of database theoreticians to define semantics in terms of first-order logic can not be applied straightforwardly to object-oriented data models. Defining characteristic features of object-oriented data models, such as methods and inheritance, involves investigating data and schema. As pointed out by Beeri [Beer90], it is burdensome to describe these with first order logic, whereas higher order logic is not axiomati-zable in general. We propose to specify the operational semantics based on evolving algebras as an alternative.
Reference: [Borg90a] <author> E. </author> <title> Borger , "A Logical Operational Semantics of Full Prolog, Part I: Selection Core and Control," </title> <publisher> CSL'89, Springer LCNS, </publisher> <editor> ed. E. Borger, H. Kleine Buning, and M. Richter, </editor> <year> 1990. </year>
Reference-contexts: It is shown in [Gure88b] that evolving algebras can be used to reason about the equivalence of programs, although this can be cumbersome. So far, to our knowledge, evolving algebras have been employed to define the operational semantics of Modula-2 [GuMo88, Morr88], Occam [GuMo90], and Prolog <ref> [Borg90a, Borg90b, Borg90c] </ref>. 3 Features of the Ob ject-Oriented Data Model and its Language EasyOBL In this section we describe EasyOBL (Easy Object/Behavior Language), a simple object-oriented data definition and manipulation language. EasyOBL exhibits some characteristic concepts of the graphical object-oriented design language Object/Behavior Diagrams [KaSc91].
Reference: [Borg90b] <author> E. </author> <title> Borger , "A Logical Operational Semantics of Full Prolog, Part II: Built-in Predicates for Database Manipulations," </title> <publisher> MFCS'90, Springer LCNS, </publisher> <year> 1990. </year>
Reference-contexts: It is shown in [Gure88b] that evolving algebras can be used to reason about the equivalence of programs, although this can be cumbersome. So far, to our knowledge, evolving algebras have been employed to define the operational semantics of Modula-2 [GuMo88, Morr88], Occam [GuMo90], and Prolog <ref> [Borg90a, Borg90b, Borg90c] </ref>. 3 Features of the Ob ject-Oriented Data Model and its Language EasyOBL In this section we describe EasyOBL (Easy Object/Behavior Language), a simple object-oriented data definition and manipulation language. EasyOBL exhibits some characteristic concepts of the graphical object-oriented design language Object/Behavior Diagrams [KaSc91].
Reference: [Borg90c] <author> E. </author> <title> Borger , "A Logical Operational Semantics of Full Prolog, Part III: Built-in Predicates for Files, Terms, Arithmetic, and Input-Output," </title> <booktitle> Proc. Workshop Logic for Computer Science (Nov. </booktitle> <volume> 89), </volume> <publisher> Springer, </publisher> <editor> ed. Y. Moschovakis, </editor> <year> 1990. </year>
Reference-contexts: It is shown in [Gure88b] that evolving algebras can be used to reason about the equivalence of programs, although this can be cumbersome. So far, to our knowledge, evolving algebras have been employed to define the operational semantics of Modula-2 [GuMo88, Morr88], Occam [GuMo90], and Prolog <ref> [Borg90a, Borg90b, Borg90c] </ref>. 3 Features of the Ob ject-Oriented Data Model and its Language EasyOBL In this section we describe EasyOBL (Easy Object/Behavior Language), a simple object-oriented data definition and manipulation language. EasyOBL exhibits some characteristic concepts of the graphical object-oriented design language Object/Behavior Diagrams [KaSc91].
Reference: [Gure88a] <author> Y. Gurevich, </author> <title> "Algorithms in the world of bounded resources," The universal Turing machine a half-century story, </title> <publisher> Oxford University Press, </publisher> <editor> ed. R. Herken, </editor> <year> 1988, </year> <pages> pp. 407-416. </pages>
Reference-contexts: The language supports all essential object-oriented concepts, which are encapsulation and message passing, object type definition and dynamic object creation, 1 Another characteristic feature of evolving algebras is that the sizes of universes may have an upper bound <ref> [Gure88a] </ref>, which allows to model limited resources, such as memory. In this paper, however, we assume unbounded universes and neglect universe contractions. type specialization and inheritance, and overriding and dynamic binding of operations. In addition, EasyOBL supports object specialization.
Reference: [Gure88b] <author> Y. Gurevich, </author> <booktitle> "Logic and the Challenge of Computer Science," Trends in Theoretical Computer Science, </booktitle> <publisher> Computer Science Press, </publisher> <editor> ed. E. Boerger, </editor> <year> 1988, </year> <pages> pp. 1-57. </pages>
Reference-contexts: We propose to specify the operational semantics based on evolving algebras as an alternative. Evolving algebras have been introduced recently by Yuri Gurevich as a framework to define the operational semantics of programming languages <ref> [Gure88b] </ref>. A major advantage of the operational approach is that language constructs involving data fl This research is supported in part by SIEMENS Austria under grant GR 21/96106/5 and schema can be handled rather easily. <p> We conclude with a short discussion in section 5. 2 Evolving Algebra The idea of using evolving algebras to describe the operational semantics of programming languages has been first worked out by Yuri Gurevich in <ref> [Gure88b] </ref>. In general, the operational semantics of a language L is defined by an abstract machine which interprets the constructs of L and changes its state accordingly. Yuri Gurevich proposes to use an evolving algebra to define the abstract machine. <p> Evolving algebras describe the operational semantics of a language. This approach defines the semantics of a program in terms of its input-output behavior. Two programs are called equivalent, i.e., have the same semantics, if they exhibit the same input-output behavior. It is shown in <ref> [Gure88b] </ref> that evolving algebras can be used to reason about the equivalence of programs, although this can be cumbersome. <p> We give the transition rule for creating a new role of an object and the transition rules for message passing. We do not describe other transition rules needed to define the semantics of EasyOBL. They are very close to the ones identified for Pascal <ref> [Gure88b] </ref> and Modula [GuMo88]. Before we introduce specific transition rules, let us recall the general strategy how a program is interpreted. The function ActiveNode identifies the node in the parse tree where control currently resides.
Reference: [GuMo88] <author> Y. Gurevich and J.M. Morris, </author> <title> "Algebraic Operational Semantics and Modula-2," </title> <publisher> CSL'87, Springer, LNCS 329, </publisher> <editor> ed. E. Borger, H. Kleine Buning, and M. Richter, </editor> <year> 1988, </year> <pages> pp. 81-101. </pages>
Reference-contexts: As space is limited, we do not elaborate on concepts also found in other languages, such as parameter passing and control flow primitives. The reader interested in these concepts is referred to the papers by Yuri Gurevich <ref> [GuMo88, GuMo90] </ref>. The paper is outlined as follows. We shortly explain the evolving algebra approach in section 2 to make the paper self-contained. In section 3, we introduce EasyOBL, an object-oriented data definition and manipulation language. <p> It is shown in [Gure88b] that evolving algebras can be used to reason about the equivalence of programs, although this can be cumbersome. So far, to our knowledge, evolving algebras have been employed to define the operational semantics of Modula-2 <ref> [GuMo88, Morr88] </ref>, Occam [GuMo90], and Prolog [Borg90a, Borg90b, Borg90c]. 3 Features of the Ob ject-Oriented Data Model and its Language EasyOBL In this section we describe EasyOBL (Easy Object/Behavior Language), a simple object-oriented data definition and manipulation language. <p> The static universes and static functions of A EasyOBL represent the parse tree of an EasyOBL program. The dynamic universes and dynamic functions represent a particular state during program execution. The evolving algebra for EasyOBL is based on the evolving algebra of Modula-2 <ref> [GuMo88, Morr88] </ref> as far as non object-oriented features are concerned. We use those universes and functions from [Morr88] which are equally applicable to EasyOBL and we adapt some transformation rules of [Morr88] to fit our needs. <p> We use those universes and functions from [Morr88] which are equally applicable to EasyOBL and we adapt some transformation rules of [Morr88] to fit our needs. As in <ref> [GuMo88] </ref>, we assume that a correct and statically type checked EasyOBL program is represented by its parse tree. 4.1 Universes Static universes represent parse tree elements, such as parse tree nodes and grammar symbols, and program elements, such as object types. <p> We give the transition rule for creating a new role of an object and the transition rules for message passing. We do not describe other transition rules needed to define the semantics of EasyOBL. They are very close to the ones identified for Pascal [Gure88b] and Modula <ref> [GuMo88] </ref>. Before we introduce specific transition rules, let us recall the general strategy how a program is interpreted. The function ActiveNode identifies the node in the parse tree where control currently resides.
Reference: [GuMo90] <author> Y. Gurevich and L.S. Moss, </author> <title> "Algebraic Operational Semantics and Occam," </title> <type> Tech. Rep. </type> <institution> RC15352, IBM Research Division, T.J. Watson Research Center, Yorktown Heights, </institution> <year> 1990. </year>
Reference-contexts: As space is limited, we do not elaborate on concepts also found in other languages, such as parameter passing and control flow primitives. The reader interested in these concepts is referred to the papers by Yuri Gurevich <ref> [GuMo88, GuMo90] </ref>. The paper is outlined as follows. We shortly explain the evolving algebra approach in section 2 to make the paper self-contained. In section 3, we introduce EasyOBL, an object-oriented data definition and manipulation language. <p> It is shown in [Gure88b] that evolving algebras can be used to reason about the equivalence of programs, although this can be cumbersome. So far, to our knowledge, evolving algebras have been employed to define the operational semantics of Modula-2 [GuMo88, Morr88], Occam <ref> [GuMo90] </ref>, and Prolog [Borg90a, Borg90b, Borg90c]. 3 Features of the Ob ject-Oriented Data Model and its Language EasyOBL In this section we describe EasyOBL (Easy Object/Behavior Language), a simple object-oriented data definition and manipulation language. EasyOBL exhibits some characteristic concepts of the graphical object-oriented design language Object/Behavior Diagrams [KaSc91].
Reference: [KaSc91] <author> G. Kappel and M. Schrefl, </author> <title> "Object/Behavior Diagrams," </title> <journal> IEEE Data Engineering'91, </journal> <year> 1991. </year>
Reference-contexts: EasyOBL exhibits some characteristic concepts of the graphical object-oriented design language Object/Behavior Diagrams <ref> [KaSc91] </ref>. The language supports all essential object-oriented concepts, which are encapsulation and message passing, object type definition and dynamic object creation, 1 Another characteristic feature of evolving algebras is that the sizes of universes may have an upper bound [Gure88a], which allows to model limited resources, such as memory.
Reference: [KNS88] <author> W. Klas, E.J. Neuhold and M. Schrefl, </author> <title> "On an object-oriented datamodel for a knowledge base," Research into Networks and Distriubted Application - EUTECO, </title> <publisher> North-Holland, </publisher> <editor> ed. R. Speth, </editor> <year> 1988. </year>
Reference-contexts: In this paper, however, we assume unbounded universes and neglect universe contractions. type specialization and inheritance, and overriding and dynamic binding of operations. In addition, EasyOBL supports object specialization. Object specialization has been introduced independently by <ref> [KNS88] </ref> and [Scio89], and is explained below. An EasyOBL program consists of an arbitrary number of object type definitions (the "data definition" part) and a main operation (the "data manipulation" part). An object type defines a set of typed instance variables and a set of operations.
Reference: [Morr88] <author> J.M. Morris, </author> <title> "Algebraic Operational Semantics for Modula-2," </title> <type> PhD Thesis, </type> <institution> University of Michigan, </institution> <year> 1988. </year>
Reference-contexts: It is shown in [Gure88b] that evolving algebras can be used to reason about the equivalence of programs, although this can be cumbersome. So far, to our knowledge, evolving algebras have been employed to define the operational semantics of Modula-2 <ref> [GuMo88, Morr88] </ref>, Occam [GuMo90], and Prolog [Borg90a, Borg90b, Borg90c]. 3 Features of the Ob ject-Oriented Data Model and its Language EasyOBL In this section we describe EasyOBL (Easy Object/Behavior Language), a simple object-oriented data definition and manipulation language. <p> The static universes and static functions of A EasyOBL represent the parse tree of an EasyOBL program. The dynamic universes and dynamic functions represent a particular state during program execution. The evolving algebra for EasyOBL is based on the evolving algebra of Modula-2 <ref> [GuMo88, Morr88] </ref> as far as non object-oriented features are concerned. We use those universes and functions from [Morr88] which are equally applicable to EasyOBL and we adapt some transformation rules of [Morr88] to fit our needs. <p> The dynamic universes and dynamic functions represent a particular state during program execution. The evolving algebra for EasyOBL is based on the evolving algebra of Modula-2 [GuMo88, Morr88] as far as non object-oriented features are concerned. We use those universes and functions from <ref> [Morr88] </ref> which are equally applicable to EasyOBL and we adapt some transformation rules of [Morr88] to fit our needs. <p> The evolving algebra for EasyOBL is based on the evolving algebra of Modula-2 [GuMo88, Morr88] as far as non object-oriented features are concerned. We use those universes and functions from <ref> [Morr88] </ref> which are equally applicable to EasyOBL and we adapt some transformation rules of [Morr88] to fit our needs. As in [GuMo88], we assume that a correct and statically type checked EasyOBL program is represented by its parse tree. 4.1 Universes Static universes represent parse tree elements, such as parse tree nodes and grammar symbols, and program elements, such as object types. <p> In the next step, the actual parameters are evaluated and assigned to the formal parameters. Parameter passing in EasyOBL is essentially the same as parameter passing in non object-oriented languages. Therefore it is not described here any further. The interested reader is referred to <ref> [Morr88] </ref>. Finally, the operation is performed on the receiver. Figure 6 illustrates the transition rule for activating the operation on the receiver. The precondition of the rule states that the active node is a node labeled hmessagei whose children, haddresseei, hopNamei, and hactualParlisti, have been evaluated.
Reference: [Scio89] <author> E. Sciore, </author> <title> "Object Specialization," </title> <booktitle> ACM TOIS 7(2), </booktitle> <month> April </month> <year> 1989, </year> <pages> pp. 103-122. </pages> <note> Acknowledgement Thanks are due to Oscar Nierstrasz for valuable comments on an earlier draft of this paper. </note>
Reference-contexts: In this paper, however, we assume unbounded universes and neglect universe contractions. type specialization and inheritance, and overriding and dynamic binding of operations. In addition, EasyOBL supports object specialization. Object specialization has been introduced independently by [KNS88] and <ref> [Scio89] </ref>, and is explained below. An EasyOBL program consists of an arbitrary number of object type definitions (the "data definition" part) and a main operation (the "data manipulation" part). An object type defines a set of typed instance variables and a set of operations.
References-found: 13

