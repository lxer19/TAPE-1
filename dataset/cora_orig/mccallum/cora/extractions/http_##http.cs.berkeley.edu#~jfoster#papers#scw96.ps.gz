URL: http://http.cs.berkeley.edu/~jfoster/papers/scw96.ps.gz
Refering-URL: http://http.cs.berkeley.edu/~jfoster/
Root-URL: 
Email: jfoster@cory.eecs.berkeley.edu  
Title: CLP(SC): Implementation and Efficiency Considerations  
Author: Jeffrey S. Foster 
Address: Berkeley, CA 94720  
Affiliation: University of California at Berkeley  
Abstract: CLP(SC) is a constraint logic programming language over set constraints proposed by Kozen [7]. In this paper, we describe a complete C++ implementation of CLP(SC). We describe the data structures used to represent systems of set constraints and an efficient algorithm, a modification of one given in [7], for unifying constraints. In addition, we investigate two further techniques for increasing efficiency: keeping track of variable equalities and doing PROLOG-style unification. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aiken, D. Kozen, M. Vardi, and E. Wimmers. </author> <title> The complexity of set constraints. </title> <booktitle> In Proc. 1993 Conf. Computer Science Logic (CSL '93), volume 832 of Lecture Notes in Computer Science, </booktitle> <pages> pages 1-17. </pages> <institution> Eur. Assoc. Comput. Sci. </institution> <address> Logic, </address> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1994. </year>
Reference-contexts: Although we do not currently have enough empirical evidence to state that our system is highly efficient, preliminary tests show that it may indeed be so. CLP (SC) allows positive inclusions and equalities between arbitrary set expressions composed with union, intersection, and complement. It is known <ref> [1] </ref> that solving systems of such constraints is NEXPTIME-complete. Our main contributions are to show that in practice, systems of constraints can be solved fairly efficiently, and that the hypergraph representation used in [1, 7] is in fact as practical for implementations as other techniques [2, 5, 6]. <p> It is known [1] that solving systems of such constraints is NEXPTIME-complete. Our main contributions are to show that in practice, systems of constraints can be solved fairly efficiently, and that the hypergraph representation used in <ref> [1, 7] </ref> is in fact as practical for implementations as other techniques [2, 5, 6]. In order to gain this efficiency, we developed an algorithm for conjoining new constraints to a pre-existing constraint system without doing the expensive cross-product-like operation suggested in [7]. <p> With these allowances, the algorithms are EXPTIME-complete <ref> [1] </ref> (not NEXPTIME, since we only allow constant and unary functors). However, preliminary tests show that, in practice, the running time of the program is tractable.
Reference: [2] <author> A. Aiken and E. Wimmers. </author> <title> Solving systems of set constraints. </title> <editor> In A. Scedrov, editor, </editor> <booktitle> Proceedings, Seventh Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 329-340. </pages> <publisher> IEEE, </publisher> <month> June </month> <year> 1992. </year>
Reference-contexts: It is known [1] that solving systems of such constraints is NEXPTIME-complete. Our main contributions are to show that in practice, systems of constraints can be solved fairly efficiently, and that the hypergraph representation used in [1, 7] is in fact as practical for implementations as other techniques <ref> [2, 5, 6] </ref>. In order to gain this efficiency, we developed an algorithm for conjoining new constraints to a pre-existing constraint system without doing the expensive cross-product-like operation suggested in [7].
Reference: [3] <author> A. Dovier, E. Pontelli, E. Omodeo, and G. Rossi. </author> <title> Embedding finite sets in a logic programming language. </title> <editor> In E. Lamma and P. Mello, editors, </editor> <booktitle> Proc. Third International Workshop Extensions of Logic Programming (ELP '92), volume 660 of Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 150-167. </pages> <publisher> Springer-Verlag, </publisher> <month> February </month> <year> 1992. </year>
Reference-contexts: Arbitrary regular sets [7] of ground terms, 1 This work was done while the author was at Cornell University, Ithaca, NY 14850 1 including infinite ones, can be computed. See <ref> [3] </ref> for an example of a different language, or [7] for comparisons with other languages. CLP (SC) works much the same as a standard PROLOG interpreter. Program clauses are stored in a database. Resolution uses the usual top-down, left-to-right rule.
Reference: [4] <author> J. Driscoll, N. Sarnak, D. Sleator, and R. Tarjan. </author> <title> Making data structures persistent. </title> <booktitle> In Proceedings of the Eigteenth Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 109-121. </pages> <publisher> ACM, </publisher> <month> May </month> <year> 1986. </year>
Reference-contexts: This requires a limited form of persistent data structures <ref> [4] </ref>. Although for some applications, such as an incremental compiler, it may be desirable to have full persistence (the ability to maintain and update arbitrary, distinct versions of the data structures), for our purposes it is sufficient to support a simple kind of partial persistence.
Reference: [5] <author> R. Gilleron, S. Tison, and M. Tommasi. </author> <title> Solving systems of set constraints using tree automata. </title> <editor> In P. Enjalbert, A. Finkel, and K. W. Wagner, editors, </editor> <booktitle> Proceedings of the Symposium on Theoretical Aspects of Computer Science (STACS '93), volume 665 of Lecture Notes in Computer Science, </booktitle> <pages> pages 505-514. </pages> <publisher> Springer-Verlag, </publisher> <month> February </month> <year> 1993. </year>
Reference-contexts: It is known [1] that solving systems of such constraints is NEXPTIME-complete. Our main contributions are to show that in practice, systems of constraints can be solved fairly efficiently, and that the hypergraph representation used in [1, 7] is in fact as practical for implementations as other techniques <ref> [2, 5, 6] </ref>. In order to gain this efficiency, we developed an algorithm for conjoining new constraints to a pre-existing constraint system without doing the expensive cross-product-like operation suggested in [7].
Reference: [6] <author> N. Heintze. </author> <title> Set Based Program Analysis. </title> <type> PhD dissertation, </type> <institution> Carnegie Mellon University, Department of Computer Science, </institution> <month> October </month> <year> 1992. </year>
Reference-contexts: It is known [1] that solving systems of such constraints is NEXPTIME-complete. Our main contributions are to show that in practice, systems of constraints can be solved fairly efficiently, and that the hypergraph representation used in [1, 7] is in fact as practical for implementations as other techniques <ref> [2, 5, 6] </ref>. In order to gain this efficiency, we developed an algorithm for conjoining new constraints to a pre-existing constraint system without doing the expensive cross-product-like operation suggested in [7].
Reference: [7] <author> D. Kozen. </author> <title> Set constraints and logic programming. </title> <type> Technical Report TR94-1467, </type> <institution> Cornell University, Computer Science Department, </institution> <month> November </month> <year> 1994. </year> <month> 9 </month>
Reference-contexts: 1 Introduction A set constraint is an inclusion or equality between two expressions representing sets of ground terms over a finite alphabet. CLP (SC) is a constraint logic programming language over set constraints proposed by Kozen <ref> [7] </ref>. This paper describes a complete C++ implementation of CLP (SC), filling in the details necessary to go from the high-level algorithmic descriptions of [7] to a working program. <p> CLP (SC) is a constraint logic programming language over set constraints proposed by Kozen <ref> [7] </ref>. This paper describes a complete C++ implementation of CLP (SC), filling in the details necessary to go from the high-level algorithmic descriptions of [7] to a working program. Although we do not currently have enough empirical evidence to state that our system is highly efficient, preliminary tests show that it may indeed be so. CLP (SC) allows positive inclusions and equalities between arbitrary set expressions composed with union, intersection, and complement. <p> It is known [1] that solving systems of such constraints is NEXPTIME-complete. Our main contributions are to show that in practice, systems of constraints can be solved fairly efficiently, and that the hypergraph representation used in <ref> [1, 7] </ref> is in fact as practical for implementations as other techniques [2, 5, 6]. In order to gain this efficiency, we developed an algorithm for conjoining new constraints to a pre-existing constraint system without doing the expensive cross-product-like operation suggested in [7]. <p> In order to gain this efficiency, we developed an algorithm for conjoining new constraints to a pre-existing constraint system without doing the expensive cross-product-like operation suggested in <ref> [7] </ref>. In addition, we describe two other methods to increase efficiency that may be of interest in the context of general constraint solving: using syntactic analysis (PROLOG-style unification) and taking advantage of variable equalities. In fact, our implementation is designed to be modular. <p> The grammar given here is exactly the grammar given by Kozen <ref> [7] </ref>. The objects in the language represent sets of ground terms. Ground terms themselves are promoted to singleton sets. In this way, there is no syntactic distinction between terms and sets, and membership can be written with an inclusion. Arbitrary regular sets [7] of ground terms, 1 This work was done <p> here is exactly the grammar given by Kozen <ref> [7] </ref>. The objects in the language represent sets of ground terms. Ground terms themselves are promoted to singleton sets. In this way, there is no syntactic distinction between terms and sets, and membership can be written with an inclusion. Arbitrary regular sets [7] of ground terms, 1 This work was done while the author was at Cornell University, Ithaca, NY 14850 1 including infinite ones, can be computed. See [3] for an example of a different language, or [7] for comparisons with other languages. <p> Arbitrary regular sets <ref> [7] </ref> of ground terms, 1 This work was done while the author was at Cornell University, Ithaca, NY 14850 1 including infinite ones, can be computed. See [3] for an example of a different language, or [7] for comparisons with other languages. CLP (SC) works much the same as a standard PROLOG interpreter. Program clauses are stored in a database. Resolution uses the usual top-down, left-to-right rule. <p> Program clauses are stored in a database. Resolution uses the usual top-down, left-to-right rule. Where PROLOG would try to unify terms, CLP (SC) calls the constraint solver. 2.1 Grammar Here is the grammar for CLP (SC), as proposed in <ref> [7] </ref>. We have replaced non-typeable characters by more computer-friendly symbols. A CLP (SC) program consists of a series of program clauses, and running a program corresponds to asking whether a query clause is satisfiable. <p> As a compromise, in a debugging mode offered by our implementation, we output the actual internal representation of the system. As in PROLOG, variables are capitalized, while functors are procedures are not. Functors and procedure names are distinguished from each other syntactically. We use a generalized DeMorgan law <ref> [7] </ref> to handle negated set expressions. Applying this law requires that the set of all functors is known. Accordingly, the interpreter for CLP (SC) has special predicates to declare the existence of functors. 2.2 Example The following is an actual CLP (SC) program that runs under our interpreter. <p> Accordingly, the interpreter for CLP (SC) has special predicates to declare the existence of functors. 2.2 Example The following is an actual CLP (SC) program that runs under our interpreter. These are exactly the sample predicates given in <ref> [7] </ref>. ?- const (a). ?- const (b). 2 ?- unary (f). ?- unary (g). // sng (X) == X is a singleton set sng (a). sng (f (X)) :- sng (X). empty (0). nonempty (X) :- Y &lt;= X, sng (Y). equal (X, X). unequal (X, Y) :- nonempty (X*(~Y)+Y*(~X)). // <p> The built-in predicates const and unary declare that a and b have arity 0 while f and g have arity 1. We currently do not allow greater arities. 3 Solving Set Constraints 3.1 Atomic Form and Hypergraphs In <ref> [7] </ref>, Kozen describes a normal form for set constraints called atomic form and shows how set constraints in this form can be interpreted as a hypergraph. CLP (SC) solves constraints by building this hypergraph and testing for closure, the equivalent of satisfiability. <p> CLP (SC) solves constraints by building this hypergraph and testing for closure, the equivalent of satisfiability. As set constraints are added and removed from the system, the hypergraph is updated. The following definition is taken directly from <ref> [7] </ref>. Let be a finite ranked alphabet. Denote by n the n-ary elements of . We refer to the elements of as functors. <p> As mentioned in the results section, the method we chose, which does not duplicate any unnecessary information, works well in practice. 3.3 Building the Hypergraph 3.3.1 Partial Reduction to Atomic Form The hypergraph is constructed from the original set of constraints using the algorithm in <ref> [7] </ref>, modified substantially to be more efficient and to allow the addition of constraints one by one. This first step, partial reduction to atomic form, is exactly as outlined in [7], except that some effort is made to avoid introducing excess variables. <p> 3.3.1 Partial Reduction to Atomic Form The hypergraph is constructed from the original set of constraints using the algorithm in <ref> [7] </ref>, modified substantially to be more efficient and to allow the addition of constraints one by one. This first step, partial reduction to atomic form, is exactly as outlined in [7], except that some effort is made to avoid introducing excess variables. Given a set of constraints C, we first create two new sets of constraints, F and B. <p> This last step uses the generalized DeMorgan law <ref> [7] </ref> to replace ~ f (l 1 ; : : : ; l n ). It is here that knowing is essential to the algorithm. <p> Given the boolean constraints B, constructing these satisfying assignments is an NP-complete problem. 5 Kozen <ref> [7] </ref> gave a method for building separate systems of set constraints from scratch and then conjoining them using a cross-product-like operation. That technique did not address the issue of finding satisfying assignments to the variables or the need for backtracking. <p> The new system, (U 0 ; Y; P 0 ; E 0 ) represents the old constraints conjoined with both B and F . 6 3.4 Testing Satisfiability Satisfiability of a constraint system C put into atomic form (U; X; P; E) is equivalent to closure of the hypergraph <ref> [7] </ref>. To test satisfiability, the interpreter first computes the largest closed induced subgraph of the graph (U; E), applying the following step until no longer possible: * Find a node u 2 U such that, for some unary functor f , E f (u) = ;. Delete node u. <p> Because set expressions are defined over an Herbrand domain, in certain, limited cases the standard unification procedure of PROLOG can solve set constraints. In our system, we make use of the following lemma, which can be proven using the axioms for termset algebra as given in <ref> [7] </ref>.
References-found: 7

