URL: http://www.cs.purdue.edu/homes/palsberg/paper/popl98.ps.gz
Refering-URL: http://www.cs.purdue.edu/homes/palsberg/publications.html
Root-URL: http://www.cs.purdue.edu
Email: fpalsberg,pavlog@cs.purdue.edu  
Title: From Polyvariant Flow Information to Intersection and Union Types  
Author: Jens Palsberg Christina Pavlopoulou 
Address: San Diego, California,  Lafayette, IN 47907, USA,  
Note: A preliminary version is in Proc. POPL'98, 25th Annual SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 197-208,  
Date: March 18, 1998  January 1998.  
Affiliation: Purdue University  Purdue University, Dept of Computer Science, W  
Abstract: Many polyvariant program analyses have been studied in the 1990s, including k-CFA, poly-k-CFA, and the cartesian product algorithm. The idea of polyvariance is to analyze functions more than once and thereby obtain better precision for each call site. In this paper we present the first formal relationship between polyvariant analysis and standard notions of type. In the spirit of Nielson and Nielson, we study a parameterized flow analysis which can be instantiated to the analyses of Agesen, Schmidt, and as a simple case also 0-CFA. Extended with safety checks, the flow analysis accepts and rejects programs, much like a type checker. We prove that if a program can be safety-checked by a finitary instantiation of the flow analysis, then it can also be typed in a type system with intersection types, union types, subtyping, and recursive types, but no universal or existential quantifiers. This provides a framework for designing and understanding combinations of flow analyses and type systems. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Ole Agesen. </author> <title> The cartesian product algorithm. </title> <booktitle> In Proc. ECOOP'95, Seventh European Conference on Object-Oriented Programming, </booktitle> <pages> pages 2-26. </pages> <publisher> Springer-Verlag (LNCS 952), </publisher> <year> 1995. </year>
Reference-contexts: Polyvariant analysis was pioneered by Sharir and Pnueli [41], and Jones and Muchnick [26]. In the 1990s the study of polyvariant analysis has been intensive. Well known are the k-CFA of Shivers [42], the poly-k-CFA of Jagannathan and Weeks [23], and the cartesian product algorithm of Agesen <ref> [1, 2] </ref>. A particularly simple polyvariant analysis was presented by Schmidt [40]. Frameworks for defining polyvariant analyses have been presented by Stefanescu and Zhou [43], Jagannathan and Weeks [22], and Nielson and Nielson [31]. <p> clos ; s arg ; s res ; C; R) = 8hx:e l ; i 2 s clos : (C; ; e) 2 R ^ C (l; ) s res ^ s arg (x) : The predicates are defined such that P Agesen captures the cartesian product algorithm of Agesen <ref> [1, 2] </ref>; P Schmidt captures the flow analysis of Schmidt [40]; and P 0-CF A captures a variant of 0-CFA where all functions are analyzed exactly once, see for example [32].
Reference: [2] <author> Ole Agesen. </author> <title> Concrete Type Inference: Delivering Object-Oriented Applications. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <year> 1995. </year>
Reference-contexts: Polyvariant analysis was pioneered by Sharir and Pnueli [41], and Jones and Muchnick [26]. In the 1990s the study of polyvariant analysis has been intensive. Well known are the k-CFA of Shivers [42], the poly-k-CFA of Jagannathan and Weeks [23], and the cartesian product algorithm of Agesen <ref> [1, 2] </ref>. A particularly simple polyvariant analysis was presented by Schmidt [40]. Frameworks for defining polyvariant analyses have been presented by Stefanescu and Zhou [43], Jagannathan and Weeks [22], and Nielson and Nielson [31]. <p> clos ; s arg ; s res ; C; R) = 8hx:e l ; i 2 s clos : (C; ; e) 2 R ^ C (l; ) s res ^ s arg (x) : The predicates are defined such that P Agesen captures the cartesian product algorithm of Agesen <ref> [1, 2] </ref>; P Schmidt captures the flow analysis of Schmidt [40]; and P 0-CF A captures a variant of 0-CFA where all functions are analyzed exactly once, see for example [32].
Reference: [3] <author> Alexander Aiken and Edward Wimmers. </author> <title> Type inclusion constraints and type inference. </title> <booktitle> In Proc. Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 31-41, </pages> <year> 1993. </year>
Reference-contexts: Three more such results for restrictions of 0-CFA have later been presented by Heintze [18]. The Amadio-Cardelli type system, in turn, is equivalent to a form of constrained types <ref> [28, 29, 3, 13, 12] </ref>, as shown by Palsberg and Smith [35]. In this paper we address the above question for a family of polyvariant flow analyses. 3 1.2 Our Result We present the first formal relationship between polyvariant analysis and standard notions of type.
Reference: [4] <author> Roberto M. Amadio and Luca Cardelli. </author> <title> Subtyping recursive types. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(4) </volume> <pages> 575-631, </pages> <year> 1993. </year> <note> Also in Proc. POPL'91. </note>
Reference-contexts: This has been carried out for 0-CFA by Palsberg and O'Keefe [33], and the related type system turned out to be the one of Amadio and Cardelli <ref> [4] </ref> with subtyping and recursive types. Three more such results for restrictions of 0-CFA have later been presented by Heintze [18]. The Amadio-Cardelli type system, in turn, is equivalent to a form of constrained types [28, 29, 3, 13, 12], as shown by Palsberg and Smith [35]. <p> The safety check for succ ((f f )0) requires that the flow information for the argument of succ is a subset of fIntg so the safety check fails. This implies that the program is not typable in the type system with subtyping and recursive types of Amadio and Cardelli <ref> [4] </ref>, using the equivalence of Palsberg and O'Keefe [33]. The problems encountered above during type checking and safety checking are similar. The types/flows for x:x and y:z:z are combined, and later we cannot get sufficiently precise information about the result of (f f ). <p> In [33], Palsberg and O'Keefe present a mapping from 0-CFA flow information to the types of Amadio and Cardelli <ref> [4] </ref>. The type system of [4] involves subtyping and recursive types but not intersection and union types. We will now compare the mapping of this paper with the mapping of Pals-berg and O'Keefe. <p> In [33], Palsberg and O'Keefe present a mapping from 0-CFA flow information to the types of Amadio and Cardelli <ref> [4] </ref>. The type system of [4] involves subtyping and recursive types but not intersection and union types. We will now compare the mapping of this paper with the mapping of Pals-berg and O'Keefe.
Reference: [5] <author> Anindya Banerjee. </author> <title> A modular, polyvariant and type-based closure analysis. </title> <booktitle> In Proc. ACM International Conference on Functional Programming, </booktitle> <year> 1997. </year>
Reference-contexts: Is polyvariance related to polymorphism? This question is becoming increasingly important for the many recent efforts to integrate flow analysis and type systems, as pioneered by Tang and Jouvelot [44], Heintze [18], Banerjee <ref> [5] </ref>, and Wells et al [48, 45]. <p> Intuitively, polyvariant analysis is closer to intersection types [9, 21, 25] and union types [37, 6] than to universal and 2 existential quantifiers [27], as observed by Banerjee <ref> [5] </ref>, Wells et al [48], and others. The insight is that * "analyzing a function a number of times" can be modeled by an inter section type; and * "a set of abstract values" can be modeled by a union type.
Reference: [6] <author> F. Barbanera and M. Dezani-Ciancaglini. </author> <title> Intersection and union types. </title> <journal> Information and Computation, </journal> <volume> 119 </volume> <pages> 202-230, </pages> <year> 1995. </year>
Reference-contexts: Intuitively, polyvariant analysis is closer to intersection types [9, 21, 25] and union types <ref> [37, 6] </ref> than to universal and 2 existential quantifiers [27], as observed by Banerjee [5], Wells et al [48], and others. <p> Thus, in our setting, our definition of value presents no restriction at all. We chose to work with a call-by-value semantics because we are able to prove Subject Reduction for that semantics. It has been observed by Barbanera and Dezani-Ciancaglini <ref> [6] </ref>, and also by Wells et al [48] that in some type systems related, although not identical, to ours, Subject Reduction does not hold for arbitrary beta-reduction. 3 The Type System We use ff to range over type variables drawn from a countably infinite set Tv.
Reference: [7] <author> Anders Bondorf. </author> <title> Automatic autoprojection of higher order recursive equations. </title> <booktitle> Science of Computer Programming, </booktitle> <address> 17(1-3):3-34, </address> <month> December </month> <year> 1991. </year>
Reference-contexts: 1 Introduction 1.1 Background Flow analysis of higher-order programs is done for a variety of reasons, including: closure conversion [46], binding-time analysis <ref> [7] </ref>, optimizing strict functional programs [23], optimizing non-strict functional programs [15], optimizing object-oriented programs [36], optimizing concurrent programs [38], safety checking [16, 34], and detecting uncaught exceptions [49].
Reference: [8] <author> Charles Consel. </author> <title> A tour of Schism: A partial evaluation system for higher-order applicative languages. </title> <booktitle> In Proc. PEPM'93, Second ACM SIGPLAN Symposium on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <pages> pages 145-154, </pages> <year> 1993. </year>
Reference-contexts: Frameworks for defining polyvariant analyses have been presented by Stefanescu and Zhou [43], Jagannathan and Weeks [22], and Nielson and Nielson [31]. Successful applications of polyvariant analysis include the optimizing compilers of Hendren et al [14], and Chambers et al [17], and the partial evaluator of Consel <ref> [8] </ref>. Is polyvariance related to polymorphism? This question is becoming increasingly important for the many recent efforts to integrate flow analysis and type systems, as pioneered by Tang and Jouvelot [44], Heintze [18], Banerjee [5], and Wells et al [48, 45].
Reference: [9] <author> M. Coppo, M. Dezani-Ciancaglini, and B. Venneri. </author> <title> Principal type schemes and lambda-calculus semantics. </title> <editor> In J. Seldin and J. Hindley, editors, To H. B. </editor> <booktitle> Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism, </booktitle> <pages> pages 535-560. </pages> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference-contexts: Intuitively, polyvariant analysis is closer to intersection types <ref> [9, 21, 25] </ref> and union types [37, 6] than to universal and 2 existential quantifiers [27], as observed by Banerjee [5], Wells et al [48], and others.
Reference: [10] <author> Bruno Courcelle. </author> <title> Fundamental properties of infinite trees. </title> <journal> Theoretical Computer Science, </journal> <volume> 25(1) </volume> <pages> 95-169, </pages> <year> 1983. </year> <month> 31 </month>
Reference-contexts: Every such an equation system has a principal solution <ref> [10] </ref>. To see that, notice that for every variable in the equation system, there is at most one equation with that variable as left-hand side. Thus, intuitively, we obtain the principal solution by using each equation as an unfolding rule, possibly infinitely often.
Reference: [11] <author> Patrick Cousot. </author> <title> Types as abstract interpretations. </title> <booktitle> In Proc. POPL'97, 24th Annual SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 316-331, </pages> <year> 1997. </year>
Reference-contexts: a type inference algorithm for a large subset of the type system, perhaps a "rank 2" fragment in the spirit of [25]. * Extend the results to a combination of our analysis and the analysis of Nielson and Nielson. * Obtain our type rules systematically using the method of Cousot <ref> [11] </ref>. Paper Outline In the remainder of this section we illustrate our result by an example.
Reference: [12] <author> Jonathan Eifrig, Scott Smith, and Valery Trifonov. </author> <title> Sound polymorphic type inference for objects. </title> <booktitle> In Proc. OOPSLA'95, ACM SIGPLAN Tenth Annual Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 169-184, </pages> <year> 1995. </year>
Reference-contexts: Three more such results for restrictions of 0-CFA have later been presented by Heintze [18]. The Amadio-Cardelli type system, in turn, is equivalent to a form of constrained types <ref> [28, 29, 3, 13, 12] </ref>, as shown by Palsberg and Smith [35]. In this paper we address the above question for a family of polyvariant flow analyses. 3 1.2 Our Result We present the first formal relationship between polyvariant analysis and standard notions of type.
Reference: [13] <author> Jonathan Eifrig, Scott Smith, and Valery Trifonov. </author> <title> Type inference for recursively constrained types and it application to OOP. </title> <booktitle> In Proc. Mathematical Foundations of Programming Semantics, </booktitle> <year> 1995. </year> <note> To appear. </note>
Reference-contexts: Three more such results for restrictions of 0-CFA have later been presented by Heintze [18]. The Amadio-Cardelli type system, in turn, is equivalent to a form of constrained types <ref> [28, 29, 3, 13, 12] </ref>, as shown by Palsberg and Smith [35]. In this paper we address the above question for a family of polyvariant flow analyses. 3 1.2 Our Result We present the first formal relationship between polyvariant analysis and standard notions of type.
Reference: [14] <author> Maryam Emami, Rakesh Ghiya, and Laurie J. Hendren. </author> <title> Context-sensitive interprocedural points-to analysis in the presence of function pointers. </title> <booktitle> In Proc. ACM SIGPLAN 1994 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 242-256, </pages> <year> 1994. </year>
Reference-contexts: A particularly simple polyvariant analysis was presented by Schmidt [40]. Frameworks for defining polyvariant analyses have been presented by Stefanescu and Zhou [43], Jagannathan and Weeks [22], and Nielson and Nielson [31]. Successful applications of polyvariant analysis include the optimizing compilers of Hendren et al <ref> [14] </ref>, and Chambers et al [17], and the partial evaluator of Consel [8].
Reference: [15] <author> Karl-Filip Faxen. </author> <title> Optimizing lazy functional programs using flow inference. </title> <booktitle> In Proc. SAS'95, International Static Analysis Symposium. </booktitle> <publisher> Springer-Verlag (LNCS 983), </publisher> <address> Glasgow, Scotland, </address> <month> September </month> <year> 1995. </year>
Reference-contexts: 1 Introduction 1.1 Background Flow analysis of higher-order programs is done for a variety of reasons, including: closure conversion [46], binding-time analysis [7], optimizing strict functional programs [23], optimizing non-strict functional programs <ref> [15] </ref>, optimizing object-oriented programs [36], optimizing concurrent programs [38], safety checking [16, 34], and detecting uncaught exceptions [49]. A basic, often-seen form of flow analyses can be done in O (n 3 ) time where n is the size of the program.
Reference: [16] <author> Justin O. Graver and Ralph E. Johnson. </author> <title> A type system for Smalltalk. </title> <booktitle> In Seventeenth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 136-150, </pages> <year> 1990. </year>
Reference-contexts: 1 Introduction 1.1 Background Flow analysis of higher-order programs is done for a variety of reasons, including: closure conversion [46], binding-time analysis [7], optimizing strict functional programs [23], optimizing non-strict functional programs [15], optimizing object-oriented programs [36], optimizing concurrent programs [38], safety checking <ref> [16, 34] </ref>, and detecting uncaught exceptions [49]. A basic, often-seen form of flow analyses can be done in O (n 3 ) time where n is the size of the program.
Reference: [17] <author> David Grove, Greg DeFouw, Jeffrey Dean, and Craig Chambers. </author> <title> Call graph construction in object-oriented languages. </title> <booktitle> In Proc. OOPSLA'97, ACM SIGPLAN Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <year> 1997. </year>
Reference-contexts: Frameworks for defining polyvariant analyses have been presented by Stefanescu and Zhou [43], Jagannathan and Weeks [22], and Nielson and Nielson [31]. Successful applications of polyvariant analysis include the optimizing compilers of Hendren et al [14], and Chambers et al <ref> [17] </ref>, and the partial evaluator of Consel [8]. Is polyvariance related to polymorphism? This question is becoming increasingly important for the many recent efforts to integrate flow analysis and type systems, as pioneered by Tang and Jouvelot [44], Heintze [18], Banerjee [5], and Wells et al [48, 45].
Reference: [18] <author> Nevin Heintze. </author> <title> Control-flow analysis and type systems. </title> <booktitle> In Proc. SAS'95, International Static Analysis Symposium. </booktitle> <publisher> Springer-Verlag (LNCS 983), </publisher> <address> Glasgow, Scotland, </address> <month> September </month> <year> 1995. </year>
Reference-contexts: Is polyvariance related to polymorphism? This question is becoming increasingly important for the many recent efforts to integrate flow analysis and type systems, as pioneered by Tang and Jouvelot [44], Heintze <ref> [18] </ref>, Banerjee [5], and Wells et al [48, 45]. Benefits of integrating flow analysis and type systems include: easy correctness proofs (Heintze [18]), faster flow analysis without sacrificing precision (Heintze and McAllester [19]), a definition of a both sound and complete flow analysis (Mossin [30]), and a simplified compiler structure (Wells <p> to polymorphism? This question is becoming increasingly important for the many recent efforts to integrate flow analysis and type systems, as pioneered by Tang and Jouvelot [44], Heintze <ref> [18] </ref>, Banerjee [5], and Wells et al [48, 45]. Benefits of integrating flow analysis and type systems include: easy correctness proofs (Heintze [18]), faster flow analysis without sacrificing precision (Heintze and McAllester [19]), a definition of a both sound and complete flow analysis (Mossin [30]), and a simplified compiler structure (Wells et al [48]). <p> This has been carried out for 0-CFA by Palsberg and O'Keefe [33], and the related type system turned out to be the one of Amadio and Cardelli [4] with subtyping and recursive types. Three more such results for restrictions of 0-CFA have later been presented by Heintze <ref> [18] </ref>. The Amadio-Cardelli type system, in turn, is equivalent to a form of constrained types [28, 29, 3, 13, 12], as shown by Palsberg and Smith [35].
Reference: [19] <author> Nevin Heintze and David McAllester. </author> <title> Linear-time subtransitive control flow analysis. </title> <booktitle> In Proc. ACM SIGPLAN 1997 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 261-272, </pages> <year> 1997. </year> <month> 32 </month>
Reference-contexts: Benefits of integrating flow analysis and type systems include: easy correctness proofs (Heintze [18]), faster flow analysis without sacrificing precision (Heintze and McAllester <ref> [19] </ref>), a definition of a both sound and complete flow analysis (Mossin [30]), and a simplified compiler structure (Wells et al [48]).
Reference: [20] <author> Fritz Henglein and Christian Mossin. </author> <title> Polymorphic binding time analysis. </title> <booktitle> In Proc. ESOP'94, European Symposium on Programming, </booktitle> <pages> pages 287-301. </pages> <publisher> Springer-Verlag (LNCS 788), </publisher> <year> 1994. </year>
Reference-contexts: In simple cases these effects can also be achieved via universal quantifiers, for example, in binding-time analysis (Henglein and Mossin <ref> [20] </ref>). In general, polyvariance seems to be a concept distinct from universal and existential quantification. Further results on using universal quantifiers to achieve a form of polyvariance have been presented by Jagannathan, Wright, and Weeks [24].
Reference: [21] <author> J. Roger Hindley. </author> <title> Types with intersection: An introduction. </title> <journal> Formal Aspects of Computing, </journal> <volume> 4 </volume> <pages> 470-486, </pages> <year> 1991. </year>
Reference-contexts: Intuitively, polyvariant analysis is closer to intersection types <ref> [9, 21, 25] </ref> and union types [37, 6] than to universal and 2 existential quantifiers [27], as observed by Banerjee [5], Wells et al [48], and others.
Reference: [22] <author> Suresh Jagannathan and Stephen Weeks. </author> <title> A unified treatment of flow analysis in higher-order languages. </title> <booktitle> In Proc. POPL'95, 22nd Annual SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 393-407, </pages> <year> 1995. </year>
Reference-contexts: A particularly simple polyvariant analysis was presented by Schmidt [40]. Frameworks for defining polyvariant analyses have been presented by Stefanescu and Zhou [43], Jagannathan and Weeks <ref> [22] </ref>, and Nielson and Nielson [31]. Successful applications of polyvariant analysis include the optimizing compilers of Hendren et al [14], and Chambers et al [17], and the partial evaluator of Consel [8].
Reference: [23] <author> Suresh Jagannathan and Andrew Wright. </author> <title> Effective flow analysis for avoiding run-time checks. </title> <booktitle> In Proc. SAS'95, International Static Analysis Symposium. </booktitle> <publisher> Springer-Verlag (LNCS 983), </publisher> <address> Glasgow, Scotland, </address> <month> Septem-ber </month> <year> 1995. </year>
Reference-contexts: 1 Introduction 1.1 Background Flow analysis of higher-order programs is done for a variety of reasons, including: closure conversion [46], binding-time analysis [7], optimizing strict functional programs <ref> [23] </ref>, optimizing non-strict functional programs [15], optimizing object-oriented programs [36], optimizing concurrent programs [38], safety checking [16, 34], and detecting uncaught exceptions [49]. A basic, often-seen form of flow analyses can be done in O (n 3 ) time where n is the size of the program. <p> Polyvariant analysis was pioneered by Sharir and Pnueli [41], and Jones and Muchnick [26]. In the 1990s the study of polyvariant analysis has been intensive. Well known are the k-CFA of Shivers [42], the poly-k-CFA of Jagannathan and Weeks <ref> [23] </ref>, and the cartesian product algorithm of Agesen [1, 2]. A particularly simple polyvariant analysis was presented by Schmidt [40]. Frameworks for defining polyvariant analyses have been presented by Stefanescu and Zhou [43], Jagannathan and Weeks [22], and Nielson and Nielson [31].
Reference: [24] <author> Suresh Jagannathan, Andrew Wright, and Stephen Weeks. </author> <title> Type-directed flow analysis for typed intermediate languages. </title> <booktitle> In Proc. SAS'97, International Static Analysis Symposium. </booktitle> <publisher> Springer-Verlag (LNCS ), 1997. </publisher>
Reference-contexts: In general, polyvariance seems to be a concept distinct from universal and existential quantification. Further results on using universal quantifiers to achieve a form of polyvariance have been presented by Jagannathan, Wright, and Weeks <ref> [24] </ref>.
Reference: [25] <author> Trevor Jim. </author> <title> What are principal typings are what are they good for? In Proc. </title> <booktitle> POPL'96, 23nd Annual SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 42-53, </pages> <year> 1996. </year>
Reference-contexts: Intuitively, polyvariant analysis is closer to intersection types <ref> [9, 21, 25] </ref> and union types [37, 6] than to universal and 2 existential quantifiers [27], as observed by Banerjee [5], Wells et al [48], and others. <p> open problems remain, including: * Find a subset of the type system which types exactly the same programs as, for example, Schmidt's analysis extended with safety checks. * Provide a type inference algorithm for a large subset of the type system, perhaps a "rank 2" fragment in the spirit of <ref> [25] </ref>. * Extend the results to a combination of our analysis and the analysis of Nielson and Nielson. * Obtain our type rules systematically using the method of Cousot [11]. Paper Outline In the remainder of this section we illustrate our result by an example.
Reference: [26] <author> Neil Jones and Steven Muchnick. </author> <title> A flexible approach to interprocedu-ral data flow analysis of programs with recursive data structures. </title> <booktitle> In Ninth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 66-74, </pages> <year> 1982. </year>
Reference-contexts: Polyvariant analysis was pioneered by Sharir and Pnueli [41], and Jones and Muchnick <ref> [26] </ref>. In the 1990s the study of polyvariant analysis has been intensive. Well known are the k-CFA of Shivers [42], the poly-k-CFA of Jagannathan and Weeks [23], and the cartesian product algorithm of Agesen [1, 2]. A particularly simple polyvariant analysis was presented by Schmidt [40].
Reference: [27] <author> Robin Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: Intuitively, polyvariant analysis is closer to intersection types [9, 21, 25] and union types [37, 6] than to universal and 2 existential quantifiers <ref> [27] </ref>, as observed by Banerjee [5], Wells et al [48], and others. The insight is that * "analyzing a function a number of times" can be modeled by an inter section type; and * "a set of abstract values" can be modeled by a union type.
Reference: [28] <author> John Mitchell. </author> <title> Coercion and type inference. </title> <booktitle> In Eleventh Symposium on Principles of Programming Languages, </booktitle> <pages> pages 175-185, </pages> <year> 1984. </year>
Reference-contexts: Three more such results for restrictions of 0-CFA have later been presented by Heintze [18]. The Amadio-Cardelli type system, in turn, is equivalent to a form of constrained types <ref> [28, 29, 3, 13, 12] </ref>, as shown by Palsberg and Smith [35]. In this paper we address the above question for a family of polyvariant flow analyses. 3 1.2 Our Result We present the first formal relationship between polyvariant analysis and standard notions of type.
Reference: [29] <author> John C. Mitchell. </author> <title> Type inference with simple subtypes. </title> <journal> Journal of Functional Programming, </journal> <volume> 1 </volume> <pages> 245-285, </pages> <year> 1991. </year> <month> 33 </month>
Reference-contexts: Three more such results for restrictions of 0-CFA have later been presented by Heintze [18]. The Amadio-Cardelli type system, in turn, is equivalent to a form of constrained types <ref> [28, 29, 3, 13, 12] </ref>, as shown by Palsberg and Smith [35]. In this paper we address the above question for a family of polyvariant flow analyses. 3 1.2 Our Result We present the first formal relationship between polyvariant analysis and standard notions of type. <p> Consider the derivation of A ` x:e 1 : ! t . It is straightforward to prove, using the technique of Mitchell <ref> [29] </ref>, that we can produce another derivation of A ` x:e 1 : ! t in which no instance of rule (16) is immediately followed by an instance on rule (15) or an instance of rule (16).
Reference: [30] <author> Christian Mossin. </author> <title> Exact flow analysis. </title> <booktitle> In Proc. SAS'97, International Static Analysis Symposium. </booktitle> <publisher> Springer-Verlag (LNCS ), 1997. </publisher>
Reference-contexts: Benefits of integrating flow analysis and type systems include: easy correctness proofs (Heintze [18]), faster flow analysis without sacrificing precision (Heintze and McAllester [19]), a definition of a both sound and complete flow analysis (Mossin <ref> [30] </ref>), and a simplified compiler structure (Wells et al [48]). Intuitively, polyvariant analysis is closer to intersection types [9, 21, 25] and union types [37, 6] than to universal and 2 existential quantifiers [27], as observed by Banerjee [5], Wells et al [48], and others.
Reference: [31] <author> Flemming Nielson and Hanne Riis Nielson. </author> <title> Infinitary control flow analysis: A collecting semantics for closure analysis. </title> <booktitle> In Proc. POPL'97, 24th Annual SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 332-345, </pages> <year> 1997. </year>
Reference-contexts: A particularly simple polyvariant analysis was presented by Schmidt [40]. Frameworks for defining polyvariant analyses have been presented by Stefanescu and Zhou [43], Jagannathan and Weeks [22], and Nielson and Nielson <ref> [31] </ref>. Successful applications of polyvariant analysis include the optimizing compilers of Hendren et al [14], and Chambers et al [17], and the partial evaluator of Consel [8]. <p> In this paper we address the above question for a family of polyvariant flow analyses. 3 1.2 Our Result We present the first formal relationship between polyvariant analysis and standard notions of type. In the spirit of Nielson and Nielson <ref> [31] </ref>, we study a parameterized flow analysis which can be instantiated to the analyses of Agesen, Schmidt, and as a simple case also 0-CFA. <p> In slogan-form, our result reads: Polyvariance Monovariance + Intersection Types + Union Types. Monovariance, in turn, is equivalent to a combination of subtyping and recursive types [33]. 1.3 Related Work and Open Problems Our parameterized flow analysis is inspired by the one of Nielson and Nielson <ref> [31] </ref>. Following that, we consider a language with a small-step call-by-value semantics and we define our analysis co-inductively as a greatest fixed point. The use of a small-step semantics is important because it enables proofs of 4 correctness of type systems and flow analyses for non-terminating programs. <p> Define j= P to be the greatest fixed point of F P . Write C; j= P e for (C; ; e) 2 j= P . We use the notation C; j= P e following Nielson and Nielson <ref> [31] </ref>.
Reference: [32] <author> Jens Palsberg. </author> <title> Closure analysis in constraint form. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(1) </volume> <pages> 47-62, </pages> <month> January </month> <year> 1995. </year> <note> Preliminary version in Proc. </note> <editor> CAAP'94, </editor> <booktitle> Colloquium on Trees in Algebra and Programming, </booktitle> <publisher> Springer-Verlag (LNCS 787), </publisher> <pages> pages 276-290, </pages> <address> Edin-burgh, Scotland, </address> <month> April </month> <year> 1994. </year>
Reference-contexts: ^ s arg (x) : The predicates are defined such that P Agesen captures the cartesian product algorithm of Agesen [1, 2]; P Schmidt captures the flow analysis of Schmidt [40]; and P 0-CF A captures a variant of 0-CFA where all functions are analyzed exactly once, see for example <ref> [32] </ref>. Intuitively, P Agesen forms the cartesian product of s clos and s arg , and performs separate analyses for each element in that product. More conservatively, P Schmidt performs just one analysis for each element of s clos , applying each of them to s arg .
Reference: [33] <author> Jens Palsberg and Patrick M. O'Keefe. </author> <title> A type system equivalent to flow analysis. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(4) </volume> <pages> 576-599, </pages> <month> July </month> <year> 1995. </year> <note> Preliminary version in Proc. </note> <editor> POPL'95, </editor> <booktitle> 22nd Annual SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 367-378, </pages> <address> San Francisco, California, </address> <month> January </month> <year> 1995. </year>
Reference-contexts: This has been carried out for 0-CFA by Palsberg and O'Keefe <ref> [33] </ref>, and the related type system turned out to be the one of Amadio and Cardelli [4] with subtyping and recursive types. Three more such results for restrictions of 0-CFA have later been presented by Heintze [18]. <p> The condition that the set of abstract values is finite ensures that the equation system is finite. In slogan-form, our result reads: Polyvariance Monovariance + Intersection Types + Union Types. Monovariance, in turn, is equivalent to a combination of subtyping and recursive types <ref> [33] </ref>. 1.3 Related Work and Open Problems Our parameterized flow analysis is inspired by the one of Nielson and Nielson [31]. Following that, we consider a language with a small-step call-by-value semantics and we define our analysis co-inductively as a greatest fixed point. <p> In Section 6 we illustrate how different flow analyses lead to different typings, and we compare our mapping of flow information to types with the mapping presented by Palsberg and O'Keefe <ref> [33] </ref>. 5 1.4 Example The running example of this paper is the following program E = (f:succ ((f f )0)) (if0 c (x:x) (y:z:z)) : This example is chosen because it requires a rather powerful polyvariant analysis to produce better flow information than 0-CFA. <p> This implies that the program is not typable in the type system with subtyping and recursive types of Amadio and Cardelli [4], using the equivalence of Palsberg and O'Keefe <ref> [33] </ref>. The problems encountered above during type checking and safety checking are similar. The types/flows for x:x and y:z:z are combined, and later we cannot get sufficiently precise information about the result of (f f ). <p> These conditions correspond to the safety checks of <ref> [34, 33] </ref>. In the following we will use the notational convention that f ffi g (x) should be grouped as (f ffi g)(x). <p> We will also compare our mapping of flow information to types with the mapping presented by Palsberg and O'Keefe <ref> [33] </ref>. <p> For example, it gives y:y0 the type (Int ! Int) ! Int, where 0-CFA leads to the type ( ! ) ! , where = t _ Int, and t = ff:((ff _ Int) ! (ff _ Int)). In <ref> [33] </ref>, Palsberg and O'Keefe present a mapping from 0-CFA flow information to the types of Amadio and Cardelli [4]. The type system of [4] involves subtyping and recursive types but not intersection and union types.
Reference: [34] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Safety analysis versus type inference. </title> <journal> Information and Computation, </journal> <volume> 118(1) </volume> <pages> 128-141, </pages> <year> 1995. </year>
Reference-contexts: 1 Introduction 1.1 Background Flow analysis of higher-order programs is done for a variety of reasons, including: closure conversion [46], binding-time analysis [7], optimizing strict functional programs [23], optimizing non-strict functional programs [15], optimizing object-oriented programs [36], optimizing concurrent programs [38], safety checking <ref> [16, 34] </ref>, and detecting uncaught exceptions [49]. A basic, often-seen form of flow analyses can be done in O (n 3 ) time where n is the size of the program. <p> These conditions correspond to the safety checks of <ref> [34, 33] </ref>. In the following we will use the notational convention that f ffi g (x) should be grouped as (f ffi g)(x).
Reference: [35] <author> Jens Palsberg and Scott Smith. </author> <title> Constrained types and their expressiveness. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 18(5) </volume> <pages> 519-527, </pages> <month> September </month> <year> 1996. </year>
Reference-contexts: Three more such results for restrictions of 0-CFA have later been presented by Heintze [18]. The Amadio-Cardelli type system, in turn, is equivalent to a form of constrained types [28, 29, 3, 13, 12], as shown by Palsberg and Smith <ref> [35] </ref>. In this paper we address the above question for a family of polyvariant flow analyses. 3 1.2 Our Result We present the first formal relationship between polyvariant analysis and standard notions of type.
Reference: [36] <author> Hemant D. Pande and Barbara G. Ryder. </author> <title> Data-flow-based virtual function resolution. </title> <booktitle> In Proc. SAS'96, International Static Analysis Symposium, </booktitle> <pages> pages 238-254. </pages> <publisher> Springer-Verlag (LNCS 1145), </publisher> <month> September </month> <year> 1996. </year>
Reference-contexts: 1 Introduction 1.1 Background Flow analysis of higher-order programs is done for a variety of reasons, including: closure conversion [46], binding-time analysis [7], optimizing strict functional programs [23], optimizing non-strict functional programs [15], optimizing object-oriented programs <ref> [36] </ref>, optimizing concurrent programs [38], safety checking [16, 34], and detecting uncaught exceptions [49]. A basic, often-seen form of flow analyses can be done in O (n 3 ) time where n is the size of the program.
Reference: [37] <author> Benjamin Pierce. </author> <title> Programming with intersection types, union types, and polymorphism. </title> <type> Technical Report CMU-CS-91-106, </type> <institution> Carnegie Mel-lon University, </institution> <year> 1991. </year>
Reference-contexts: Intuitively, polyvariant analysis is closer to intersection types [9, 21, 25] and union types <ref> [37, 6] </ref> than to universal and 2 existential quantifiers [27], as observed by Banerjee [5], Wells et al [48], and others. <p> the following rules. t t 0 t 0 t 00 t t 0 t t 0 0 t t 0 ^ ( i ! t ) ( i2I We have chosen to be the smallest relation which is sufficient for our results; a larger subtyping relation was studied by Pierce <ref> [37] </ref>. It is unclear to us how much can be extended while preserving Subject Reduction. (Pierce [37] did not consider Subject Reduction.) Notice that (i) there is no separate rule for comparing recursive types, (ii) the relation is reflexive because t t _ ? = t , (iii) ? is a <p> 0 t t 0 ^ ( i ! t ) ( i2I We have chosen to be the smallest relation which is sufficient for our results; a larger subtyping relation was studied by Pierce <ref> [37] </ref>. It is unclear to us how much can be extended while preserving Subject Reduction. (Pierce [37] did not consider Subject Reduction.) Notice that (i) there is no separate rule for comparing recursive types, (ii) the relation is reflexive because t t _ ? = t , (iii) ? is a least type in the -ordering because ? ? _ t = t , and (iv) if
Reference: [38] <author> John Plevyak, Xingbin Zhang, and Andrew A. Chien. </author> <title> Obtaining sequential efficiency for concurrent object-oriented languages. </title> <booktitle> In Proc. POPL'95, 22nd Annual SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <year> 1995. </year> <month> 34 </month>
Reference-contexts: 1 Introduction 1.1 Background Flow analysis of higher-order programs is done for a variety of reasons, including: closure conversion [46], binding-time analysis [7], optimizing strict functional programs [23], optimizing non-strict functional programs [15], optimizing object-oriented programs [36], optimizing concurrent programs <ref> [38] </ref>, safety checking [16, 34], and detecting uncaught exceptions [49]. A basic, often-seen form of flow analyses can be done in O (n 3 ) time where n is the size of the program.
Reference: [39] <author> Gordon D. Plotkin. </author> <title> A structural approach to operational seman-tics. </title> <type> Technical Report DAIMI FN-19, </type> <institution> Computer Science Department, Aarhus University, </institution> <month> September </month> <year> 1981. </year>
Reference-contexts: Nielson and Nielson prove a subject-reduction theorem for their flow analysis with respect to a small-step semantics involving environments and intermediate expressions, in the style of Plotkin <ref> [39] </ref>.
Reference: [40] <author> David Schmidt. </author> <title> Natural-semantics-based abstract interpretation. </title> <booktitle> In Proc. SAS'95, International Static Analysis Symposium. </booktitle> <publisher> Springer-Verlag (LNCS 983), </publisher> <address> Glasgow, Scotland, </address> <month> September </month> <year> 1995. </year>
Reference-contexts: In the 1990s the study of polyvariant analysis has been intensive. Well known are the k-CFA of Shivers [42], the poly-k-CFA of Jagannathan and Weeks [23], and the cartesian product algorithm of Agesen [1, 2]. A particularly simple polyvariant analysis was presented by Schmidt <ref> [40] </ref>. Frameworks for defining polyvariant analyses have been presented by Stefanescu and Zhou [43], Jagannathan and Weeks [22], and Nielson and Nielson [31]. Successful applications of polyvariant analysis include the optimizing compilers of Hendren et al [14], and Chambers et al [17], and the partial evaluator of Consel [8]. <p> = 8hx:e l ; i 2 s clos : (C; ; e) 2 R ^ C (l; ) s res ^ s arg (x) : The predicates are defined such that P Agesen captures the cartesian product algorithm of Agesen [1, 2]; P Schmidt captures the flow analysis of Schmidt <ref> [40] </ref>; and P 0-CF A captures a variant of 0-CFA where all functions are analyzed exactly once, see for example [32]. Intuitively, P Agesen forms the cartesian product of s clos and s arg , and performs separate analyses for each element in that product.
Reference: [41] <author> M. Sharir and A. Pnueli. </author> <title> Two approaches to interprocedural data flow analysis. </title> <editor> In Steven Muchnick and Neil Jones, editors, </editor> <title> Program Flow Analysis, </title> <booktitle> Theory and Applications. </booktitle> <year> 1981. </year>
Reference-contexts: Polyvariant analysis was pioneered by Sharir and Pnueli <ref> [41] </ref>, and Jones and Muchnick [26]. In the 1990s the study of polyvariant analysis has been intensive. Well known are the k-CFA of Shivers [42], the poly-k-CFA of Jagannathan and Weeks [23], and the cartesian product algorithm of Agesen [1, 2].
Reference: [42] <author> Olin Shivers. </author> <title> Control-Flow Analysis of Higher-Order Languages. </title> <type> PhD thesis, CMU, </type> <month> May </month> <year> 1991. </year> <month> CMU-CS-91-145. </month>
Reference-contexts: Polyvariant analysis was pioneered by Sharir and Pnueli [41], and Jones and Muchnick [26]. In the 1990s the study of polyvariant analysis has been intensive. Well known are the k-CFA of Shivers <ref> [42] </ref>, the poly-k-CFA of Jagannathan and Weeks [23], and the cartesian product algorithm of Agesen [1, 2]. A particularly simple polyvariant analysis was presented by Schmidt [40]. Frameworks for defining polyvariant analyses have been presented by Stefanescu and Zhou [43], Jagannathan and Weeks [22], and Nielson and Nielson [31].
Reference: [43] <author> D. Stefanescu and Y. Zhou. </author> <title> An equational framework for flow analysis of higher-order functional programs. </title> <booktitle> In Proc. ACM Conference on LISP and Functional Programming, </booktitle> <pages> pages 318-327, </pages> <year> 1994. </year>
Reference-contexts: Well known are the k-CFA of Shivers [42], the poly-k-CFA of Jagannathan and Weeks [23], and the cartesian product algorithm of Agesen [1, 2]. A particularly simple polyvariant analysis was presented by Schmidt [40]. Frameworks for defining polyvariant analyses have been presented by Stefanescu and Zhou <ref> [43] </ref>, Jagannathan and Weeks [22], and Nielson and Nielson [31]. Successful applications of polyvariant analysis include the optimizing compilers of Hendren et al [14], and Chambers et al [17], and the partial evaluator of Consel [8].
Reference: [44] <author> Yan Mei Tang and Pierre Jouvelot. </author> <title> Separate abstract interpretation for control-flow analysis. </title> <booktitle> In Proc. TACS'94, Theoretical Aspects of Computing Software, </booktitle> <pages> pages 224-243. </pages> <publisher> Springer-Verlag (LNCS 789), </publisher> <year> 1994. </year>
Reference-contexts: Is polyvariance related to polymorphism? This question is becoming increasingly important for the many recent efforts to integrate flow analysis and type systems, as pioneered by Tang and Jouvelot <ref> [44] </ref>, Heintze [18], Banerjee [5], and Wells et al [48, 45].
Reference: [45] <author> Franklyn Turbak, Allyn Dimock, Robert Muller, and Joe Wells. </author> <title> Compiling with polymorphic and polyvariant flow types. </title> <booktitle> In Proc. Types in Compilation, </booktitle> <year> 1997. </year> <note> www.cs.bc.edu/ muller/TIC97/. </note>
Reference-contexts: Is polyvariance related to polymorphism? This question is becoming increasingly important for the many recent efforts to integrate flow analysis and type systems, as pioneered by Tang and Jouvelot [44], Heintze [18], Banerjee [5], and Wells et al <ref> [48, 45] </ref>. Benefits of integrating flow analysis and type systems include: easy correctness proofs (Heintze [18]), faster flow analysis without sacrificing precision (Heintze and McAllester [19]), a definition of a both sound and complete flow analysis (Mossin [30]), and a simplified compiler structure (Wells et al [48]).
Reference: [46] <author> Mitchell Wand and Paul Steckler. </author> <title> Selective and lightweight closure conversion. </title> <booktitle> In Proc. POPL'94, 21st Annual Symposium on Principles of Programming Languages, </booktitle> <pages> pages 434-445, </pages> <year> 1994. </year>
Reference-contexts: 1 Introduction 1.1 Background Flow analysis of higher-order programs is done for a variety of reasons, including: closure conversion <ref> [46] </ref>, binding-time analysis [7], optimizing strict functional programs [23], optimizing non-strict functional programs [15], optimizing object-oriented programs [36], optimizing concurrent programs [38], safety checking [16, 34], and detecting uncaught exceptions [49].
Reference: [47] <author> Joe Wells. </author> <type> Personal communication. </type> <year> 1997. </year>
Reference-contexts: If c terminates and one of the branches is passed to f:succ ((f f )0), then the result of (f f ) will be the identity function, and the result of evaluating the whole body will be succ 0. No run-time errors! Wells <ref> [47] </ref> has shown that this -term does not have a type in system F extended with a constant type Int. Notice also that a safety check based on 0-CFA fails. The 0-CFA flow information for the if0-expression is s = f x:x; y:z:z g.
Reference: [48] <author> Joe Wells, Allyn Dimock, Robert Muller, and Franklyn Turbak. </author> <title> A typed intermediate language for flow-directed compilation. </title> <booktitle> In Proc. TAPSOFT'97, Theory and Practice of Software Development. </booktitle> <publisher> Springer-Verlag (LNCS ), 1997. </publisher>
Reference-contexts: Is polyvariance related to polymorphism? This question is becoming increasingly important for the many recent efforts to integrate flow analysis and type systems, as pioneered by Tang and Jouvelot [44], Heintze [18], Banerjee [5], and Wells et al <ref> [48, 45] </ref>. Benefits of integrating flow analysis and type systems include: easy correctness proofs (Heintze [18]), faster flow analysis without sacrificing precision (Heintze and McAllester [19]), a definition of a both sound and complete flow analysis (Mossin [30]), and a simplified compiler structure (Wells et al [48]). <p> Benefits of integrating flow analysis and type systems include: easy correctness proofs (Heintze [18]), faster flow analysis without sacrificing precision (Heintze and McAllester [19]), a definition of a both sound and complete flow analysis (Mossin [30]), and a simplified compiler structure (Wells et al <ref> [48] </ref>). Intuitively, polyvariant analysis is closer to intersection types [9, 21, 25] and union types [37, 6] than to universal and 2 existential quantifiers [27], as observed by Banerjee [5], Wells et al [48], and others. <p> a both sound and complete flow analysis (Mossin [30]), and a simplified compiler structure (Wells et al <ref> [48] </ref>). Intuitively, polyvariant analysis is closer to intersection types [9, 21, 25] and union types [37, 6] than to universal and 2 existential quantifiers [27], as observed by Banerjee [5], Wells et al [48], and others. The insight is that * "analyzing a function a number of times" can be modeled by an inter section type; and * "a set of abstract values" can be modeled by a union type. <p> Thus, in our setting, our definition of value presents no restriction at all. We chose to work with a call-by-value semantics because we are able to prove Subject Reduction for that semantics. It has been observed by Barbanera and Dezani-Ciancaglini [6], and also by Wells et al <ref> [48] </ref> that in some type systems related, although not identical, to ours, Subject Reduction does not hold for arbitrary beta-reduction. 3 The Type System We use ff to range over type variables drawn from a countably infinite set Tv. <p> It is straightforward to prove (vi) by induction on the structure of the derivation of t ?. The rule ^ ( i ! t ) ( i2I is closely related to the (_ elim)-rule in <ref> [48] </ref>. A type environment is a partial function with finite domain which maps -variables to types of the form t . We use A to range over type environments.
Reference: [49] <author> Kwangkeun Yi. </author> <title> Compile-time detection of uncaught exceptions in standard ML programs. </title> <booktitle> In Proc. SAS'94, International Static Analysis Symposium. </booktitle> <publisher> Springer-Verlag (LNCS 983), </publisher> <year> 1994. </year> <month> 35 </month>
Reference-contexts: 1 Introduction 1.1 Background Flow analysis of higher-order programs is done for a variety of reasons, including: closure conversion [46], binding-time analysis [7], optimizing strict functional programs [23], optimizing non-strict functional programs [15], optimizing object-oriented programs [36], optimizing concurrent programs [38], safety checking [16, 34], and detecting uncaught exceptions <ref> [49] </ref>. A basic, often-seen form of flow analyses can be done in O (n 3 ) time where n is the size of the program.
References-found: 49

