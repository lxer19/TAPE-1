URL: ftp://ftp.cs.buffalo.edu/pub/tech-reports/95-14.ps.Z
Refering-URL: ftp://ftp.cs.buffalo.edu/pub/tech-reports/README.html
Root-URL: 
Email: E-Mail: fbharat,kmoong@cs.buffalo.edu  
Title: IMPLEMENTATION OF SUBSET LOGIC PROGRAMS  
Author: Bharat Jayaraman Kyonghee Moon Bell Hall 
Keyword: subset and relational program clauses, sets, monotonic aggregation, incremental and lazy enumeration of sets, memo tables, set matching and unification, WAM extensions, run-time structures, performance analysis  
Address: Buffalo, NY 14260 U.S.A.  
Affiliation: Department of Computer Science State University of New York at Buffalo  
Abstract: Subset-logic programs are built up of three kinds of program clauses: subset, equational, and relational clauses. Using these clauses, we can program solutions to a broad range of problems of interest in logic programming and deductive databases. In an earlier paper [Jay92], we discussed the implementation of subset and equational program clauses. This paper substantially extends that work, and focuses on the more expressive paradigm of subset and relational clauses. This paradigm supports setof operations, transitive closures, monotonic aggregation as well as incremental and lazy eager enumeration of sets. Although the subset-logic paradigm differs substantially from that of Prolog, we show that few additional changes are needed to the WAM [War83] to implement the paradigm and that these changes blend well with the overall machinery of the WAM. A central feature in the implementation of subset-logic programs is that of a "monotonic memo-table," i.e., a memo-table who entries can monotonically grow or shrink in an appropriate partial order. We present in stages the paradigm of subset-logic progams, showing the effect of each feature on the implementation. The implementation was completed in 1994, and we present performance figures to show the efficiency and costs of memoization. Our conclusion is that the monotonic memo-tables are a practical tool for implementing a set-oriented logic programming language. 
Abstract-found: 1
Intro-found: 1
Reference: [Ait91] <author> H. Ait-Kaci, </author> <title> Warren's Abstract Machine: A Tutorial Reconstruction, </title> <publisher> The MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: recently shown that the subset-logic paradigm and its generalization (i.e., replacing subset clauses by partial-order clauses) are particularly well-suited for programming such operations because the concepts of aggregation, subset, and monotonicity are more naturally expressed in terms of functions rather than predicates. 1.2 Implementation Issues The Warren Abstract Machine (WAM) <ref> [Ait91, War83] </ref>, designed by D.H.D. Warren, has proven to be a robust framework for implementing Prolog as well as several variants of the language [NJ89, DP93, Jay92, SW94]. <p> Finally, we note that whenever these instructions match a read-only variable, they initiate lazy-backtracking. 4 This instruction set is similar to that given in <ref> [Ait91] </ref>. 24 * The procedural instructions of the WAM are augmented with four set enumeration in-structions: call one, call all, call lazy, and execute lazy.
Reference: [AG91] <author> S. Abiteboul and S. Grumbach, </author> <title> A Rule-Based Language with Functions and Sets, </title> <journal> ACM TODS, </journal> <volume> 16(1) </volume> <pages> 1-30. </pages>
Reference-contexts: novel implementation issues that they raise, and outline our proposed solutions. 1.1 Subset Logic Programming Our interest in subset-logic programming stems from the fact that it provides a declarative and efficient means of working with sets, a feature that has received considerable recent interest in logic programming and deductive databases <ref> [AG91, BNST91, DOPR91, JP89, Kup90] </ref>. While sets are ubiquitous in applications of logical reasoning, practical functional and logic languages (such as ML or Prolog) do not support bona fide sets, apparently due to the difficulty of implementing them efficiently.
Reference: [CG86] <author> K. Clark and S. Gregory, </author> <title> Parlog: Parallel Programming in Logic, </title> <journal> ACM TOPLAS, </journal> <volume> 8(1) </volume> <pages> 1-49, </pages> <year> 1986. </year>
Reference-contexts: Whenever this read-only variable is matched against a set constructor, more elements of the lazy set are to be generated. This technique is similar to that employed in concurrent logic programming languages such as Parlog <ref> [CG86] </ref>; the main difference is that in concurrent languages these read-only variables are introduced by the programmer and their bindings are explicitly given by the program.
Reference: [DP93] <author> A. Dovier and E. Pontelli, </author> <title> A WAM-Based Implementation of a Logic Language with Sets, </title> <booktitle> Proc. PLILP, </booktitle> <publisher> Springer Verlag, </publisher> <month> August </month> <year> 1993. </year>
Reference-contexts: Warren, has proven to be a robust framework for implementing Prolog as well as several variants of the language <ref> [NJ89, DP93, Jay92, SW94] </ref>. Our basic strategy is to extend the WAM with new instructions and run-time structures in order to implement the new control regime as well as the new matching and unification operations of subset-logic programs.
Reference: [AU77] <author> A. Aho and J.D. Ullman, </author> <title> Principles of Compiler Design, </title> <publisher> Addison-Wesley, </publisher> <year> 1977. </year>
Reference-contexts: We illustrate this case with the following 9 program which defines the reaching definitions in a program flow graph, a set which is computed by a compiler during its optimization phase <ref> [AU77] </ref>: out (B) contains diff (in (B), kill (B)) out (B) contains gen (B) in (B) contains allout (pred (B)) allout (fP n g) contains out (P) The program flow graph is defined by the function pred which gives the set of immediate predecessor nodes of any given node. <p> The above program is a direct rendering of the flow analysis equations, and the computational model of memoization and re-do is ideally suited to solving such problems. The reader may contrast the above solution to the one given in <ref> [AU77] </ref>, wherein an imperative program is written to compute the desired sets using a bottom-up strategy. We require subset clauses to obey a generalized local stratification condition: All circular function calls must be defined in terms of one another through subset-monotonic functions.
Reference: [BNST91] <author> C. Beeri, S. Naqvi, O. Shmueli, and S. Tsur, </author> <title> Set Constructors in a Logic Database Language, </title> <journal> JLP, </journal> <volume> 10 </volume> <pages> 181-232, </pages> <year> 1991. </year>
Reference-contexts: novel implementation issues that they raise, and outline our proposed solutions. 1.1 Subset Logic Programming Our interest in subset-logic programming stems from the fact that it provides a declarative and efficient means of working with sets, a feature that has received considerable recent interest in logic programming and deductive databases <ref> [AG91, BNST91, DOPR91, JP89, Kup90] </ref>. While sets are ubiquitous in applications of logical reasoning, practical functional and logic languages (such as ML or Prolog) do not support bona fide sets, apparently due to the difficulty of implementing them efficiently. <p> The fX=Tg constructor has also been advocated by several other researchers in logic programming and deductive databases <ref> [DOPR91, BNST91] </ref> 2 . We illustrate the use of both constructors in section 2. All functions defined by subset clauses are invoked with ground arguments (possibly ground sets), and hence we must use set-matching in these cases.
Reference: [DOPR91] <author> A. Dovier, E.G. Omodeo, E. Pontelli, and G. Rossi, flogg: </author> <title> A Logic Programming Language with Finite Sets, </title> <booktitle> Proc. Eighth ICLP, </booktitle> <publisher> MIT Pess, </publisher> <month> June </month> <year> 1991, </year> <pages> pp. 111-124. </pages>
Reference-contexts: novel implementation issues that they raise, and outline our proposed solutions. 1.1 Subset Logic Programming Our interest in subset-logic programming stems from the fact that it provides a declarative and efficient means of working with sets, a feature that has received considerable recent interest in logic programming and deductive databases <ref> [AG91, BNST91, DOPR91, JP89, Kup90] </ref>. While sets are ubiquitous in applications of logical reasoning, practical functional and logic languages (such as ML or Prolog) do not support bona fide sets, apparently due to the difficulty of implementing them efficiently. <p> The fX=Tg constructor has also been advocated by several other researchers in logic programming and deductive databases <ref> [DOPR91, BNST91] </ref> 2 . We illustrate the use of both constructors in section 2. All functions defined by subset clauses are invoked with ground arguments (possibly ground sets), and hence we must use set-matching in these cases.
Reference: [FWW76] <author> D. Friedman, D. Wise, and M. Wand, </author> <title> Recursive Programming Through Table Lookup, </title> <booktitle> Proc. Symp. on Symbolic and Algebraic Computation, </booktitle> <pages> pp. 85-89, </pages> <publisher> ACM Press, </publisher> <year> 1976. </year>
Reference-contexts: Memoization in subset-logic programs differs from the way it is used in both functional and logic programming languages: In functional programming, memoization is traditionally used to detect dynamic common subexpressions <ref> [FWW76] </ref>, and serves as a way to obtain an efficient implementation of dynamic programming algorithms. In addition to the above motivation, memoization in logic programs is used in order to detect circular loops that arise in programs for problems such as transitive closure [SW94, War92].
Reference: [GSZ93] <author> S. Greco, D. Sacca, and C. Zaniolo, </author> <title> Dynamic Programming Optimization for Logic Queries with Aggregates, </title> <booktitle> Proc. ILPS 93, </booktitle> <pages> pp. 575-589, </pages> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: An aggregate operation is a function that maps a set to some value, e.g., the maximum or minimum in the set, the cardinality of this set, the summation of all its members, etc. This has been a topic of considerable interest in the deductive database literature recently <ref> [MPR90, KS91, RS92, Van92, GSZ93, SSRB93] </ref>. In considering the problems with various semantic approaches, Van Gelder notes that, for many applications in which the use of aggregates has been proposed, the concept of subset is what is really necessary [Van92].
Reference: [Jan94] <author> D. </author> <title> Jana, Semantics of Subset-Logic Languages, </title> <type> Ph.D. dissertation, </type> <institution> Department of Computer Science, SUNY-Buffalo, </institution> <month> August </month> <year> 1994. </year>
Reference-contexts: 1. INTRODUCTION This paper describes the implementation of a logic programming paradigm based upon three kinds of program clauses: equational, subset, and general relational clauses. This paradigm is called subset logic programming, and it has been the subject of our investigations over the past several years <ref> [JP87, JN88, JP89, Jay91, Jay92, OJ93, Jan94, JJ94, JOM95] </ref>. The particular language that was implemented is called SuRE, which stands for Subsets, Relations, and Equations 1 . While equational and relational clauses are well-known in functional and logic programming respectively, subset clauses are relatively a recent development. <p> We illustrate such programs in section 2. A more formal account of the theory of subset-logic programming can be found in <ref> [Jan94, OJ93] </ref>. Subset clauses can be used in combination with both equational and general relational clauses. The combination of equational and unconditional subset clauses is called subset-equational pro 1 To wit, SuRE is the affirmative answer to the question: Can programming be declarative and practical? 2 gramming. <p> The top-level goal is a ground expression e, and its meaning is the ground term t such that e = t is a logical consequence of a completion of the program <ref> [JP89, Jan94] </ref>. The completion incorporates two assumptions underlying the meaning of subset-equational programs: the collect-all assumption and the emptiness-as-failure assumption.
Reference: [Jay91] <author> B. Jayaraman, </author> <title> The SuRE Programming Framework, </title> <type> TR 91-011, </type> <institution> Department of Computer Science, SUNY-Buffalo, </institution> <month> August </month> <year> 1991. </year>
Reference-contexts: 1. INTRODUCTION This paper describes the implementation of a logic programming paradigm based upon three kinds of program clauses: equational, subset, and general relational clauses. This paradigm is called subset logic programming, and it has been the subject of our investigations over the past several years <ref> [JP87, JN88, JP89, Jay91, Jay92, OJ93, Jan94, JJ94, JOM95] </ref>. The particular language that was implemented is called SuRE, which stands for Subsets, Relations, and Equations 1 . While equational and relational clauses are well-known in functional and logic programming respectively, subset clauses are relatively a recent development.
Reference: [Jay92] <author> B. Jayaraman, </author> <title> Implementation of Subset-Equational Programs, </title> <journal> JLP, </journal> <volume> 11 </volume> <pages> 299-324, </pages> <year> 1992. </year>
Reference-contexts: 1. INTRODUCTION This paper describes the implementation of a logic programming paradigm based upon three kinds of program clauses: equational, subset, and general relational clauses. This paradigm is called subset logic programming, and it has been the subject of our investigations over the past several years <ref> [JP87, JN88, JP89, Jay91, Jay92, OJ93, Jan94, JJ94, JOM95] </ref>. The particular language that was implemented is called SuRE, which stands for Subsets, Relations, and Equations 1 . While equational and relational clauses are well-known in functional and logic programming respectively, subset clauses are relatively a recent development. <p> The combination of equational and unconditional subset clauses is called subset-equational pro 1 To wit, SuRE is the affirmative answer to the question: Can programming be declarative and practical? 2 gramming. This is a purely functional paradigm, and its implementation issues were mostly discussed in <ref> [JN88, Jay92] </ref>. However, these papers do not discuss circular subset constraints and their attendant implementation problems. This paper concentrates on the combination of relational and subset clauses (both unconditional and conditional), a paradigm which may be called subset-relational programming. <p> The paradigm of subset-logic programming is essentially a union of the subset-equational and subset-relational paradigms. In order to keep the paper self-contained, we include a brief coverage of relevant parts from our earlier work <ref> [Jay92] </ref>. In the subset-logic paradigm, sets are constructed using two novel set constructors, fXnTg and fX=Tg. The constructor fXnTg matches a set S such that X 2 S and T=S-fXg, i.e., the set S with X removed [Jay92]. <p> self-contained, we include a brief coverage of relevant parts from our earlier work <ref> [Jay92] </ref>. In the subset-logic paradigm, sets are constructed using two novel set constructors, fXnTg and fX=Tg. The constructor fXnTg matches a set S such that X 2 S and T=S-fXg, i.e., the set S with X removed [Jay92]. This constructor can be used only on the left-hand sides of subset clauses and it helps decompose a set into strictly smaller subsets|this is why we do not use the more familiar [ constructor for pattern-matching with sets. <p> We show that lazy enumeration of solutions is the key to pruning the search space in generate-and-test problems, while eager enumeration corresponds to the setof construct. We showed in our earlier work <ref> [JP87, Jay92] </ref> that when a function distributes over union with respect to one of its arguments, we can operate element-at-a-time with respect to this argument, and thereby avoid forming an intermediate set as well as avoid the check for duplicates in this argument. <p> This semantic property of a function is currently given as an annotation in our implementation, but it can be inferred automatically in most practical cases. Subset clauses are also useful in the deductive database context: They help render clear 2 In <ref> [Jay92] </ref> we used a single constructor f | g, which meant fXnTg on the left-hand sides of clauses, and meant fX/Tg on the right-hand sides of clauses. 3 and concise formulations to problems involving aggregate operations and recursion in database querying. <p> Warren, has proven to be a robust framework for implementing Prolog as well as several variants of the language <ref> [NJ89, DP93, Jay92, SW94] </ref>. Our basic strategy is to extend the WAM with new instructions and run-time structures in order to implement the new control regime as well as the new matching and unification operations of subset-logic programs. <p> Due to the presence of sets in the language, the efficient realization of set-matching and set-unification is a central implementation problem. The implementation of both these operations has been treated in earlier papers|set-matching is described in <ref> [Jay92] </ref> and set-unification in [DP93]|and therefore we discuss them only briefly here. Both operations can in general result in multiple maximally general matches/unifiers, and hence may cause additional branching in the search process. We showed in [Jay92] that set-matching can be compiled in terms of an extended WAM instruction set, and <p> implementation of both these operations has been treated in earlier papers|set-matching is described in <ref> [Jay92] </ref> and set-unification in [DP93]|and therefore we discuss them only briefly here. Both operations can in general result in multiple maximally general matches/unifiers, and hence may cause additional branching in the search process. We showed in [Jay92] that set-matching can be compiled in terms of an extended WAM instruction set, and that remainder sets in patterns of the form fXnTg can be efficiently constructed and represented. <p> SUBSET LOGIC PROGRAMS: AN INFORMAL INTRODUCTION A subset-logic program is built up of equational, subset, and general relational clauses. We do not treat equational clauses in this paper, as they have been fully discussed in <ref> [Jay92] </ref>. Our focus is on subset and relational clauses, each of which may be unconditional or conditional. We begin with unconditional subset clauses in section 2.1, and discuss set matching, distribution over union, memoization, and monotonic memo-tables in this context. <p> use the Prolog notation [ ] for the empty list and [XjL] for a nonempty list with head X and tail T): perms (phi) contains f [ ]g perms (fXnTg) contains distr (X; perms (T)) distr (X; fLn g) contains f [XjL]g A detailed explanation of this program appears in <ref> [Jay92] </ref>. The perms definition brings up the issue of nested expressions in the body of a subset clause. Basically these expressions are executed in leftmost-innermost order ("call by value"), and the default strategy is to compute the resulting set for an inner call before executing an outer call. <p> A more detailed discussion of the effect of this annotation on the performance improvement of programs is given in <ref> [Jay92] </ref>. 2.1.2 The Need for Memoization There are two different uses of memoization in subset clauses: (i) to detect dynamic common subexpressions, and (ii) to detect circular function calls. <p> We present the abstract machine for subset-logic programs in stages: In section 3.1 we briefly review the basic abstract machine for unconditional subset clauses. This description is adapted from <ref> [Jay92] </ref>, which discusses both equational and subset clauses. We then describe in section 3.2 the extension of the basic abstract machine to support memoization and re-do, which are needed in the implementation of unconditional subset clauses. <p> We also push on the control stack a new kind of record, called a branch point record, which saves the content of the appropriate branch register as well as the current bindings of H1 and T1, since new matches for H1 and T1 are constructed from previous matches (see <ref> [Jay92] </ref> for details). We think of branch point records as extending the choice point record of the subset clause; that is, a single choice point can contain multiple branch points. * Environment Records. <p> The new instructions fall into five main classes: get, adj, match, procedural, and choice instructions. These classes of instructions have been treated in our earlier paper <ref> [Jay92] </ref>, which dealt with only the basic abstract machine of section 3.1, i.e., for unconditional subset clauses without memoization and re-do. The new instructions for the full paradigm of subset-logic programs primarily lie in the procedural class. <p> Basically these instructions are used immediately after a get set instruction, to "adjust" the matching set so as to prepare it for the next match <ref> [Jay92] </ref>. These three instructions cannot be merged with the preceding get set instruction to give three new get set instructions because they may be the target of backtracking, whereas the get set is not. <p> This is borne out by the fact that many functions operate element-at-a-time on an input set (i.e., distribute over union in this argument set). In our earlier paper <ref> [Jay92] </ref>, we compared the call-one and the call-all modes of invoking functions, and showed that the former generally leads to much better performance. In this paper, we concentrate on the performance of memoization and re-do, which are the main new features of the implementation.
Reference: [JN88] <author> Jayaraman, B. and Nair A., </author> <title> Subset-Logic Programming: Application and Implementation, </title> <booktitle> Proc. JICSLP, </booktitle> <pages> pp. 841-858, </pages> <address> Seattle, </address> <year> 1988. </year> <month> 31 </month>
Reference-contexts: 1. INTRODUCTION This paper describes the implementation of a logic programming paradigm based upon three kinds of program clauses: equational, subset, and general relational clauses. This paradigm is called subset logic programming, and it has been the subject of our investigations over the past several years <ref> [JP87, JN88, JP89, Jay91, Jay92, OJ93, Jan94, JJ94, JOM95] </ref>. The particular language that was implemented is called SuRE, which stands for Subsets, Relations, and Equations 1 . While equational and relational clauses are well-known in functional and logic programming respectively, subset clauses are relatively a recent development. <p> The combination of equational and unconditional subset clauses is called subset-equational pro 1 To wit, SuRE is the affirmative answer to the question: Can programming be declarative and practical? 2 gramming. This is a purely functional paradigm, and its implementation issues were mostly discussed in <ref> [JN88, Jay92] </ref>. However, these papers do not discuss circular subset constraints and their attendant implementation problems. This paper concentrates on the combination of relational and subset clauses (both unconditional and conditional), a paradigm which may be called subset-relational programming.
Reference: [JP87] <author> B. Jayaraman and D.A. Plaisted, </author> <title> Functional Programming with Sets, </title> <booktitle> Proc. Third FPCA, </booktitle> <pages> pp. 194-210, </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: 1. INTRODUCTION This paper describes the implementation of a logic programming paradigm based upon three kinds of program clauses: equational, subset, and general relational clauses. This paradigm is called subset logic programming, and it has been the subject of our investigations over the past several years <ref> [JP87, JN88, JP89, Jay91, Jay92, OJ93, Jan94, JJ94, JOM95] </ref>. The particular language that was implemented is called SuRE, which stands for Subsets, Relations, and Equations 1 . While equational and relational clauses are well-known in functional and logic programming respectively, subset clauses are relatively a recent development. <p> We show that lazy enumeration of solutions is the key to pruning the search space in generate-and-test problems, while eager enumeration corresponds to the setof construct. We showed in our earlier work <ref> [JP87, Jay92] </ref> that when a function distributes over union with respect to one of its arguments, we can operate element-at-a-time with respect to this argument, and thereby avoid forming an intermediate set as well as avoid the check for duplicates in this argument.
Reference: [JP89] <author> B. Jayaraman and D.A. Plaisted, </author> <title> Programming with Equations, Subsets, and Relations, </title> <booktitle> Proc. NACLP, </booktitle> <pages> pp. 1051-1068, </pages> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: 1. INTRODUCTION This paper describes the implementation of a logic programming paradigm based upon three kinds of program clauses: equational, subset, and general relational clauses. This paradigm is called subset logic programming, and it has been the subject of our investigations over the past several years <ref> [JP87, JN88, JP89, Jay91, Jay92, OJ93, Jan94, JJ94, JOM95] </ref>. The particular language that was implemented is called SuRE, which stands for Subsets, Relations, and Equations 1 . While equational and relational clauses are well-known in functional and logic programming respectively, subset clauses are relatively a recent development. <p> novel implementation issues that they raise, and outline our proposed solutions. 1.1 Subset Logic Programming Our interest in subset-logic programming stems from the fact that it provides a declarative and efficient means of working with sets, a feature that has received considerable recent interest in logic programming and deductive databases <ref> [AG91, BNST91, DOPR91, JP89, Kup90] </ref>. While sets are ubiquitous in applications of logical reasoning, practical functional and logic languages (such as ML or Prolog) do not support bona fide sets, apparently due to the difficulty of implementing them efficiently. <p> The top-level goal is a ground expression e, and its meaning is the ground term t such that e = t is a logical consequence of a completion of the program <ref> [JP89, Jan94] </ref>. The completion incorporates two assumptions underlying the meaning of subset-equational programs: the collect-all assumption and the emptiness-as-failure assumption. <p> The use of conditional subset clauses to specify setof operations was one of the original motivations for introducing this feature <ref> [JP89] </ref>.
Reference: [JJ94] <author> D. Jana and B. Jayaraman, </author> <title> Set Constructors, Finite Sets, and Logical Semantics, </title> <note> submitted to JLP. Available as TR 94-030, </note> <institution> Department of Computer Science, </institution> <month> August </month> <year> 1994. </year>
Reference-contexts: 1. INTRODUCTION This paper describes the implementation of a logic programming paradigm based upon three kinds of program clauses: equational, subset, and general relational clauses. This paradigm is called subset logic programming, and it has been the subject of our investigations over the past several years <ref> [JP87, JN88, JP89, Jay91, Jay92, OJ93, Jan94, JJ94, JOM95] </ref>. The particular language that was implemented is called SuRE, which stands for Subsets, Relations, and Equations 1 . While equational and relational clauses are well-known in functional and logic programming respectively, subset clauses are relatively a recent development.
Reference: [JOM95] <author> B. Jayaraman, M. Osorio, and K. Moon, </author> <title> Partial Order Programming (Revisited), </title> <booktitle> Proc. Algebraic Methodology and Software Technology (AMAST 95), </booktitle> <publisher> Springer Verlag, </publisher> <month> July </month> <year> 1995 </year> <month> (to appear). </month>
Reference-contexts: 1. INTRODUCTION This paper describes the implementation of a logic programming paradigm based upon three kinds of program clauses: equational, subset, and general relational clauses. This paradigm is called subset logic programming, and it has been the subject of our investigations over the past several years <ref> [JP87, JN88, JP89, Jay91, Jay92, OJ93, Jan94, JJ94, JOM95] </ref>. The particular language that was implemented is called SuRE, which stands for Subsets, Relations, and Equations 1 . While equational and relational clauses are well-known in functional and logic programming respectively, subset clauses are relatively a recent development.
Reference: [Kup90] <author> G. M. Kuper, </author> <title> Logic Programming with Sets, </title> <journal> JCSS, </journal> <volume> 41(1) </volume> <pages> 44-64. </pages>
Reference-contexts: novel implementation issues that they raise, and outline our proposed solutions. 1.1 Subset Logic Programming Our interest in subset-logic programming stems from the fact that it provides a declarative and efficient means of working with sets, a feature that has received considerable recent interest in logic programming and deductive databases <ref> [AG91, BNST91, DOPR91, JP89, Kup90] </ref>. While sets are ubiquitous in applications of logical reasoning, practical functional and logic languages (such as ML or Prolog) do not support bona fide sets, apparently due to the difficulty of implementing them efficiently.
Reference: [KS91] <author> D.B. Kemp and P.J. Stuckey, </author> <title> Semantics of Logic Programs with Aggregates, </title> <booktitle> Proc. ILPS 91, </booktitle> <pages> pp. 387-401, </pages> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: An aggregate operation is a function that maps a set to some value, e.g., the maximum or minimum in the set, the cardinality of this set, the summation of all its members, etc. This has been a topic of considerable interest in the deductive database literature recently <ref> [MPR90, KS91, RS92, Van92, GSZ93, SSRB93] </ref>. In considering the problems with various semantic approaches, Van Gelder notes that, for many applications in which the use of aggregates has been proposed, the concept of subset is what is really necessary [Van92].
Reference: [Llo87] <author> J.W. Lloyd, </author> <title> Foundations of Logic Programming, </title> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: We require negated goals to obey the local stratification condition [Prz88], and, as before, all function calls must obey the generalized local stratification condition stated at the end of section 2.1.2. We treat negated goals by negation as failure <ref> [Llo87] </ref>.
Reference: [MPR90] <author> I.S. Mumick, H. Pirahesh, and R. Ramakrishnan, </author> <title> The Magic of Duplicates and Aggregates, </title> <booktitle> Proc. 16th VLDB, </booktitle> <pages> pp. 264-277, </pages> <year> 1990. </year>
Reference-contexts: An aggregate operation is a function that maps a set to some value, e.g., the maximum or minimum in the set, the cardinality of this set, the summation of all its members, etc. This has been a topic of considerable interest in the deductive database literature recently <ref> [MPR90, KS91, RS92, Van92, GSZ93, SSRB93] </ref>. In considering the problems with various semantic approaches, Van Gelder notes that, for many applications in which the use of aggregates has been proposed, the concept of subset is what is really necessary [Van92].
Reference: [OJ93] <author> M. Osorio and B. Jayaraman, </author> <title> Subset Assertions and Negation-as-Failure, </title> <booktitle> Proc. ILPS 93, poster paper, </booktitle> <publisher> MIT Press, </publisher> <year> 1993. </year> <note> Full paper available as TR 93-027, </note> <institution> Department of Computer Science, SUNY-Buffalo. </institution>
Reference-contexts: 1. INTRODUCTION This paper describes the implementation of a logic programming paradigm based upon three kinds of program clauses: equational, subset, and general relational clauses. This paradigm is called subset logic programming, and it has been the subject of our investigations over the past several years <ref> [JP87, JN88, JP89, Jay91, Jay92, OJ93, Jan94, JJ94, JOM95] </ref>. The particular language that was implemented is called SuRE, which stands for Subsets, Relations, and Equations 1 . While equational and relational clauses are well-known in functional and logic programming respectively, subset clauses are relatively a recent development. <p> We illustrate such programs in section 2. A more formal account of the theory of subset-logic programming can be found in <ref> [Jan94, OJ93] </ref>. Subset clauses can be used in combination with both equational and general relational clauses. The combination of equational and unconditional subset clauses is called subset-equational pro 1 To wit, SuRE is the affirmative answer to the question: Can programming be declarative and practical? 2 gramming.
Reference: [Prz88] <author> T. Przymusinski, </author> <title> "On the Declarative Semantics of Stratified Deductive Databases and Logic Programs," </title> <booktitle> Proc. Foundations of Deductive Databases and Logic Programming, </booktitle> <editor> J. Minker (ed.), </editor> <booktitle> pp. </booktitle> <pages> 193-216, </pages> <publisher> Morgan-Kaufmann, </publisher> <year> 1988. </year>
Reference-contexts: program has a well-defined meaning if it obeys a generalized local stratification condition in which all circularly defined function calls must depend upon one another through subset-monotonic functions, i.e., monotonic with respect to the subset ordering. (Note that this definition is more liberal than the usual definition of local stratification <ref> [Prz88] </ref>). We illustrate such programs in section 2. A more formal account of the theory of subset-logic programming can be found in [Jan94, OJ93]. Subset clauses can be used in combination with both equational and general relational clauses. <p> We require subset clauses to obey a generalized local stratification condition: All circular function calls must be defined in terms of one another through subset-monotonic functions. Noncircular function-call dependencies are not restricted in any way. Note that this definition of local stratification is more general than the one in <ref> [Prz88] </ref> because we permit disciplined forms of circularity to occur in the dependency graph of function calls. 2.2 Conditional Subset Clauses Conditional subset clauses have the form f (terms) contains expr :- condition where each variable in expr appears either in terms or in condition, and condition is a sequence of <p> The meaning of a ground expression e is the ground term t that follows from the completion of the program, following the collect-all and emptiness-as-failure assumptions. We require negated goals to obey the local stratification condition <ref> [Prz88] </ref>, and, as before, all function calls must obey the generalized local stratification condition stated at the end of section 2.1.2. We treat negated goals by negation as failure [Llo87].
Reference: [RS92] <author> K.A. Ross and Y. Sagiv, </author> <title> Monotonic Aggregation in Deductive Databases, </title> <booktitle> Proc. 11th PODS, </booktitle> <pages> pp. 114-126, </pages> <publisher> ACM Press, </publisher> <year> 1992. </year>
Reference-contexts: An aggregate operation is a function that maps a set to some value, e.g., the maximum or minimum in the set, the cardinality of this set, the summation of all its members, etc. This has been a topic of considerable interest in the deductive database literature recently <ref> [MPR90, KS91, RS92, Van92, GSZ93, SSRB93] </ref>. In considering the problems with various semantic approaches, Van Gelder notes that, for many applications in which the use of aggregates has been proposed, the concept of subset is what is really necessary [Van92]. <p> Moreover, for many problems requiring aggregate operations to be performed, the concept of monotonic functions is necessary <ref> [RS92] </ref>. <p> Except for this difference, the execution of a top-level query against this program is identical to that of the program given in section 2.1.2. The following program illustrates the conciseness and clarity of the paradigm for specifying monotonic aggregation. It is a specification of the company controls problem <ref> [RS92] </ref>, and makes use of a partial-order clause (for defining controls) and two subset clauses (for defining owns). The resulting type of the partial-order clause is boolean.
Reference: [SSRB93] <author> S. Sudarshan, D. Srivastava, R. Ramakrishnan, and C. Beeri, </author> <title> Extending the Well-Founded and Valid Semantics for Aggregation, </title> <booktitle> Proc. ILPS 93, </booktitle> <pages> pp. 590-608, </pages> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: An aggregate operation is a function that maps a set to some value, e.g., the maximum or minimum in the set, the cardinality of this set, the summation of all its members, etc. This has been a topic of considerable interest in the deductive database literature recently <ref> [MPR90, KS91, RS92, Van92, GSZ93, SSRB93] </ref>. In considering the problems with various semantic approaches, Van Gelder notes that, for many applications in which the use of aggregates has been proposed, the concept of subset is what is really necessary [Van92].
Reference: [SW94] <author> T. Swift and D.S. Warren, </author> <title> Analysis of SLG-WAM Evaluation of Definite Clause Programs, </title> <booktitle> Proc. ILPS 94, </booktitle> <pages> pp. 219-235, </pages> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: Warren, has proven to be a robust framework for implementing Prolog as well as several variants of the language <ref> [NJ89, DP93, Jay92, SW94] </ref>. Our basic strategy is to extend the WAM with new instructions and run-time structures in order to implement the new control regime as well as the new matching and unification operations of subset-logic programs. <p> Since memoization plays a crucial role in our implementation, the use of a top-down execution model has no inherent disadvantages. On the contrary, recent work indicates that a WAM model with memoization shows an order of magnitude performance improvement over bottom-up methods <ref> [SW94] </ref> for the class of definite clause (relational) programs. This improvement is attributed to the efficient data-structure representation and backtracking of the WAM. Due to the presence of sets in the language, the efficient realization of set-matching and set-unification is a central implementation problem. <p> In addition to the above motivation, memoization in logic programs is used in order to detect circular loops that arise in programs for problems such as transitive closure <ref> [SW94, War92] </ref>. In subset-logic programs, memoization is used for detecting dynamic common subexpressions as well as for loop detection. The latter capability is needed when circular function calls arise because of circular subset constraints. <p> Note that memo-table entries for subset-logic programs will always contain ground terms (possibly ground sets), because the arguments and results of functions will be ground. That is, we memoize only function calls, and not predicate calls. In this respect, our approach differs from that of <ref> [SW94] </ref>. However, as noted earlier, for many problems of involving aggregation in deductive 5 databases, such as shortest path, company controls, etc., it suffices to work with functions and ground terms. We provide performance figures for a variety of programs to illustrate various facets of our implementation of memoization. <p> We provide performance figures for a variety of programs to illustrate various facets of our implementation of memoization. We show that the overhead of memoization in subset-logic programs is minimal, a result that is similar to the one reported in <ref> [SW94] </ref>, namely, that tabled execution for programs that have no redundant computation is comparable with ordinary WAM execution. We show that the use of monotonic memo-tables to implement dynamic programming algorithms can be a more efficient way than using pure memo-tables.
Reference: [Van92] <author> A. Van Gelder, </author> <title> The Well-Founded Semantics of Aggregation, </title> <booktitle> Proc. 11th PODS, </booktitle> <pages> pp. 127-138, </pages> <publisher> ACM Press, </publisher> <year> 1992. </year>
Reference-contexts: An aggregate operation is a function that maps a set to some value, e.g., the maximum or minimum in the set, the cardinality of this set, the summation of all its members, etc. This has been a topic of considerable interest in the deductive database literature recently <ref> [MPR90, KS91, RS92, Van92, GSZ93, SSRB93] </ref>. In considering the problems with various semantic approaches, Van Gelder notes that, for many applications in which the use of aggregates has been proposed, the concept of subset is what is really necessary [Van92]. <p> In considering the problems with various semantic approaches, Van Gelder notes that, for many applications in which the use of aggregates has been proposed, the concept of subset is what is really necessary <ref> [Van92] </ref>. Moreover, for many problems requiring aggregate operations to be performed, the concept of monotonic functions is necessary [RS92].
Reference: [War83] <author> D.H.D. Warren, </author> <title> An Abstract Instruction Set for Prolog, </title> <type> Technical Note 309. </type> <institution> SRI International, </institution> <year> 1983. </year>
Reference-contexts: recently shown that the subset-logic paradigm and its generalization (i.e., replacing subset clauses by partial-order clauses) are particularly well-suited for programming such operations because the concepts of aggregation, subset, and monotonicity are more naturally expressed in terms of functions rather than predicates. 1.2 Implementation Issues The Warren Abstract Machine (WAM) <ref> [Ait91, War83] </ref>, designed by D.H.D. Warren, has proven to be a robust framework for implementing Prolog as well as several variants of the language [NJ89, DP93, Jay92, SW94]. <p> Compared with Prolog, the needed control in subset-logic programs is more complex, requiring memo-tables, re-execution of calls, as well as incremental and lazy exploration of a search space. Notwithstanding these differences, the Warren Abstract Machine <ref> [War83] </ref> has been a suitable framework for implementing these features. We summarize the salient points of our implementation: * Apart from the instructions needed for compiling set-matching and set-unification, only a few instructions were needed for compiling the control strategy.
Reference: [War92] <author> D.S. Warren, </author> <title> Memoing for Logic Progams, </title> <journal> CACM, </journal> <volume> 35(3) </volume> <pages> 93-111, </pages> <year> 1992. </year> <month> 32 </month>
Reference-contexts: In addition to the above motivation, memoization in logic programs is used in order to detect circular loops that arise in programs for problems such as transitive closure <ref> [SW94, War92] </ref>. In subset-logic programs, memoization is used for detecting dynamic common subexpressions as well as for loop detection. The latter capability is needed when circular function calls arise because of circular subset constraints.
References-found: 29

