URL: http://www.cs.nmsu.edu/lldap/jicslp98/p4.ps.gz
Refering-URL: http://www.cs.nmsu.edu/lldap/jicslp98/accepted.html
Root-URL: http://www.cs.nmsu.edu
Email: Email: fdsmith,markug@cs.waikato.ac.nz  
Title: Pseudo-Naive Evaluation: Mixing Top-down and Bottom-up Execution for Strongly Stratified Logic Programs  
Author: Donald A. Smith Mark Utting 
Date: May 30, 1998  
Address: Private Bag 3105, Hamilton, New Zealand  
Affiliation: Department of Computer Science The University of Waikato  
Abstract: We introduce a new bottom-up method, pseudo-naive evaluation, for execution of mixed top-down/bottom-up logic programs. The method is intermediate in power between naive evaluation and semi-naive evaluation. Pseudo-naive evaluation adds a data-driven component to naive evaluation without explicitly collecting the `delta' sets of new facts derivable at each iteration. Instead, pseudo-naive evaluation collects an abstraction of the delta sets, thereby simplifying the implementation. Pseudo-naive evaluation is most efficient on strongly-stratified programs: those programs for which all (positive and negative) bottom-up recursion is mediated by an increasing temporal parameter. We describe our compiler and interpreter and several interesting applications: an elevator simulator with GUI, a robot planner, and a graphical, individual-based ecology simulation. A desirable feature enjoyed by our system is that it runs piggyback on most logic programming implementations, as it uses the standard dynamic database (or equivalent library packages); but performance is good because most of the code is (compiled and) executed by the native Prolog system. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi and Z. Manna. </author> <title> Temporal logic programming. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 8(3) </volume> <pages> 277-295, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: Before describing pseudo-naive evaluation we must explain two preliminary notions: timestamps and strong-stratification. 3 Starlog, an Executable Temporal Logic We have designed and implemented pseudo-naive evaluation for use as the execution mechanism of Starlog [8, 5], an executable temporal logic <ref> [18, 2, 4, 10, 1] </ref>.
Reference: [2] <author> M. Baudinet, J. Chomicki, and P. Wolper. </author> <title> Temporal deductive databases. </title> <editor> In Tansel et al. </editor> <volume> [18]. </volume>
Reference-contexts: Before describing pseudo-naive evaluation we must explain two preliminary notions: timestamps and strong-stratification. 3 Starlog, an Executable Temporal Logic We have designed and implemented pseudo-naive evaluation for use as the execution mechanism of Starlog [8, 5], an executable temporal logic <ref> [18, 2, 4, 10, 1] </ref>.
Reference: [3] <author> A. Blum and M. Furst. </author> <title> Fast planning through planning graph analysis. </title> <journal> Artificial Intelligence, </journal> <volume> 90 </volume> <pages> 281-300, </pages> <year> 1997. </year>
Reference-contexts: Exactly how much faster it runs depends on the density of events: the longer the average interval between button presses, the more benefit accrues from data-driven execution. 11 graphplan <ref> [3] </ref> robot planner Space limitations preclude a full description of this application. The planning graph and its add, delete, and mutual exclusion edges are all represented re-lationally. Using relations instead of data structures has the advantage that data is more accessible.
Reference: [4] <author> J. Chomicki. </author> <title> Temporal query languages: A survey. </title> <editor> In D. M. Gabbay and H. J. Ohlbach, editors, </editor> <booktitle> Temporal Logic: First International Conference. </booktitle> <publisher> Springer-Verlag, LNCS 827, </publisher> <year> 1994. </year>
Reference-contexts: Before describing pseudo-naive evaluation we must explain two preliminary notions: timestamps and strong-stratification. 3 Starlog, an Executable Temporal Logic We have designed and implemented pseudo-naive evaluation for use as the execution mechanism of Starlog [8, 5], an executable temporal logic <ref> [18, 2, 4, 10, 1] </ref>.
Reference: [5] <author> J.G. Cleary. </author> <title> Colliding pucks solved in a temporal logic. </title> <booktitle> In Proc. Distributed Simulation Conference, </booktitle> <year> 1990. </year>
Reference-contexts: Before describing pseudo-naive evaluation we must explain two preliminary notions: timestamps and strong-stratification. 3 Starlog, an Executable Temporal Logic We have designed and implemented pseudo-naive evaluation for use as the execution mechanism of Starlog <ref> [8, 5] </ref>, an executable temporal logic [18, 2, 4, 10, 1].
Reference: [6] <editor> P. Hudak and P. Wadler et al. </editor> <title> Report on the programming language Haskell, a non-strict purely functional language (version 1.2). </title> <journal> SIGPLAN Notices, </journal> <month> March </month> <year> 1992. </year>
Reference-contexts: The typical structure of a Starlog program is basically bottom-up: the outermost loop of execution, which interacts with the external world, is bottom-up and data-driven. (By analogy, in 3 Haskell <ref> [6] </ref> or Mercury [16, 15], interaction with the real world is mediated by the outermost, singly threaded state of the world.) The reason for this is that in implementing the imperative future paradigm, Starlog uses the facts true at the current time, along with a record of some facts true in
Reference: [7] <author> Robert Kowalski and Fariba Sadri. </author> <title> The situation calculus and event calculus compared. </title> <editor> In Maurice Bruynooghe, editor, </editor> <booktitle> Logic Programming Proceedings of the 1994 International Symposium, </booktitle> <pages> pages 539-553, </pages> <institution> Massachusetts Institute of Technology, </institution> <address> 1994. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: As in the event calculus <ref> [7] </ref>, one specifies the initiating (terminating) conditions that cause a state variable to become true (false).
Reference: [8] <author> M. Liu and J.G. Cleary. </author> <title> Declarative updates in deductive databases. </title> <journal> Journal of Computing and Information, </journal> <volume> 1 </volume> <pages> 1435-1446, </pages> <year> 1994. </year>
Reference-contexts: Before describing pseudo-naive evaluation we must explain two preliminary notions: timestamps and strong-stratification. 3 Starlog, an Executable Temporal Logic We have designed and implemented pseudo-naive evaluation for use as the execution mechanism of Starlog <ref> [8, 5] </ref>, an executable temporal logic [18, 2, 4, 10, 1].
Reference: [9] <author> J.W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> 2nd edition, </address> <year> 1987. </year>
Reference-contexts: facts derived. naive_evaluation. % Iterate. naive_evaluation. % End of evaluation. it naturally allows programmers to mix top-down and bottom-up code, and it supports declarative programming of I/O and change. 2 Naive and Semi-Naive Evaluation Naive evaluation [12] is a direct implementation of the bottom-up, fixed point semantics of logic programs <ref> [9] </ref>, wherein the interpreter computes a monotonically increasing set of atoms derivable from the program clauses.
Reference: [10] <author> Mehmet A. Orgun and Wanli Ma. </author> <title> An overview of temporal and modal logic programming. </title> <editor> In D. M. Gabbay and H. J. Ohlbach, editors, </editor> <booktitle> Temporal Logic: First International Conference. </booktitle> <publisher> Springer-Verlag, LNCS 827, </publisher> <year> 1994. </year>
Reference-contexts: Before describing pseudo-naive evaluation we must explain two preliminary notions: timestamps and strong-stratification. 3 Starlog, an Executable Temporal Logic We have designed and implemented pseudo-naive evaluation for use as the execution mechanism of Starlog [8, 5], an executable temporal logic <ref> [18, 2, 4, 10, 1] </ref>. <p> Crucially, clauses are causal: the bodies of bottom-up rules must refer to the past and may not refer to the future. (This will be made more precise in the next section.) Thus Starlog rules follow the "Imperative Future" paradigm <ref> [10] </ref>.
Reference: [11] <author> Raghu Ramakrishnan, Divesh Srivastava, and S. Sudarshan. </author> <title> CORAL: Control, Relations and Logic. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <year> 1992. </year>
Reference-contexts: ; : : : ; A 0 n )@T 0 in the head of some rule, then either: p=n is executed top-down (by Prolog) or T must be strictly greater than T 0 . 1 We base this opinion partly on our experience using the the Coral Deductive Database System <ref> [11, 17] </ref>. 2 A separate implementation does handle constraints. 4 In other words, within each time step, bottom-up computation is hierarchical (non-recursive). We emphasize that negation too must be strongly stratified.
Reference: [12] <author> Raghu Ramakrishnan, Divesh Srivastava, and S. Sudarshan. </author> <title> Efficient Bottom-up Evaluation of Logic Programs. </title> <editor> In J. Vandewalle, editor, </editor> <booktitle> The State of the Art in Computer Systems and Software Engineering. </booktitle> <publisher> Kluwer Academic Publishers, </publisher> <year> 1992. </year>
Reference-contexts: We are developing a pure temporal logic programming language, Starlog, that supports both bottom-up and top-down execution in a natural way. Developing execution mechanisms that support both efficiently is an interesting challenge. Two common evaluation techniques for bottom-up systems are naive evaluation and semi-naive evaluation <ref> [12] </ref>. Naive evaluation evaluates all rules repeatedly, so is quite inefficient for many programs. Semi-naive evaluation improves efficiency by tracking newly-derived tuples (delta-sets) and only evaluating rules that use those tuples. <p> assert (some_change), fail. %Failure driven loop. naive_evaluation:- retract (some_change), % Fail if no new facts derived. naive_evaluation. % Iterate. naive_evaluation. % End of evaluation. it naturally allows programmers to mix top-down and bottom-up code, and it supports declarative programming of I/O and change. 2 Naive and Semi-Naive Evaluation Naive evaluation <ref> [12] </ref> is a direct implementation of the bottom-up, fixed point semantics of logic programs [9], wherein the interpreter computes a monotonically increasing set of atoms derivable from the program clauses. <p> Naive evaluation duplicates work. Each fact derivable at iteration i of the bottom-up computation is also derivable at iteration j for all j &gt; i. (Bottom-up computation of ancestor/2 is an example of a computation that would result in duplication.) Semi-naive evaluation <ref> [12] </ref> overcomes both inefficiencies by making sure that at least one newly derived fact is used to satisfy the body of a program clause. 2 Semi-naive Evaluation S 0 = ffi 0 = fH j (H true) 2 P g (facts) ffi i+1 = fH j (H B) 2 Rename (P <p> The programmer will certainly need to be careful that the constructed model is not too large | that not too many irrelevant facts are derived. (A similar need for care is present for programmers using forward-chaining expert system languages.) So far, we have envisioned no need to implement magic sets <ref> [12] </ref>, though we have not ruled out that option. Magic sets seem unwieldly to implement, analyze, and debug 1 and may be more appropriate for query-based deductive databases than for a (reactive) programming language like Starlog.
Reference: [13] <author> K. Sagonas, T. Swift, and D.S. Warren. </author> <title> XSB as an Efficient Deductive Database Engine. </title> <booktitle> In SIGMOD, </booktitle> <year> 1994. </year>
Reference-contexts: Make the culprit procedures top-down and use Prolog evaluation. For very many procedures | those efficiently executable by Prolog | this option will be entirely appropriate. 2. Make the procedure top-down and use tabling (OLDT resolution [14]), as in XSB <ref> [13] </ref>. This option will work for a larger class of programs (e.g., those with left recursion) and, unlike bottom-up computation without magic sets. has the advantage of being goal driven. Our implementation of Starlog runs also under XSB, and this option has been successfully used. 3.
Reference: [14] <author> T. Sato and H. Tamaki. </author> <title> Old resolution with tabulation. </title> <editor> In E. Shapiro, editor, </editor> <booktitle> Proceedings of the Third International Conference on Logic Programming, Lecture Notes in Computer Science, </booktitle> <address> Berlin Heidelberg, 1986. </address> <publisher> Springer-Verlag. </publisher> <pages> 13 </pages>
Reference-contexts: Make the culprit procedures top-down and use Prolog evaluation. For very many procedures | those efficiently executable by Prolog | this option will be entirely appropriate. 2. Make the procedure top-down and use tabling (OLDT resolution <ref> [14] </ref>), as in XSB [13]. This option will work for a larger class of programs (e.g., those with left recursion) and, unlike bottom-up computation without magic sets. has the advantage of being goal driven. Our implementation of Starlog runs also under XSB, and this option has been successfully used. 3.
Reference: [15] <author> Z. Somogyi. </author> <title> A Parallel Logic Programming System Based on Strong and Precise Modes. </title> <type> PhD thesis, </type> <institution> University of Melbourne, </institution> <year> 1989. </year>
Reference-contexts: The typical structure of a Starlog program is basically bottom-up: the outermost loop of execution, which interacts with the external world, is bottom-up and data-driven. (By analogy, in 3 Haskell [6] or Mercury <ref> [16, 15] </ref>, interaction with the real world is mediated by the outermost, singly threaded state of the world.) The reason for this is that in implementing the imperative future paradigm, Starlog uses the facts true at the current time, along with a record of some facts true in the past, to
Reference: [16] <author> Z. Somogyi, F. J. Henderson, and T. C. Conway. </author> <title> Code generation for Mercury. </title> <editor> In J. Lloyd, editor, </editor> <booktitle> Logic Programming, Proceedings of the 1995 International Symposium, </booktitle> <address> Portland, Oregon, USA, 1995. </address> <publisher> MIT Press. </publisher>
Reference-contexts: The typical structure of a Starlog program is basically bottom-up: the outermost loop of execution, which interacts with the external world, is bottom-up and data-driven. (By analogy, in 3 Haskell [6] or Mercury <ref> [16, 15] </ref>, interaction with the real world is mediated by the outermost, singly threaded state of the world.) The reason for this is that in implementing the imperative future paradigm, Starlog uses the facts true at the current time, along with a record of some facts true in the past, to
Reference: [17] <author> Divesh Srivastava, Raghu Ramakrishnan, S. Sudarshan, and Praveen Seshadri. </author> <title> Coral++: Adding object-orientation to a logic database language. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <year> 1993. </year>
Reference-contexts: ; : : : ; A 0 n )@T 0 in the head of some rule, then either: p=n is executed top-down (by Prolog) or T must be strictly greater than T 0 . 1 We base this opinion partly on our experience using the the Coral Deductive Database System <ref> [11, 17] </ref>. 2 A separate implementation does handle constraints. 4 In other words, within each time step, bottom-up computation is hierarchical (non-recursive). We emphasize that negation too must be strongly stratified.
Reference: [18] <author> A. Tansel, J Clifford, S. Gadia, S. Jajodia, A. Segev, and R. Snodgrass (editors), </author> <title> editors. Temporal Deductive Databases: Theory, Design, and Implementation. </title> <address> Benjamin/Cummings, </address> <year> 1993. </year>
Reference-contexts: Before describing pseudo-naive evaluation we must explain two preliminary notions: timestamps and strong-stratification. 3 Starlog, an Executable Temporal Logic We have designed and implemented pseudo-naive evaluation for use as the execution mechanism of Starlog [8, 5], an executable temporal logic <ref> [18, 2, 4, 10, 1] </ref>.
Reference: [19] <author> J. Wunderwald. </author> <title> Adding Bottom-up Evaluation to Prolog. </title> <type> PhD thesis, </type> <institution> Technical University of Munich, </institution> <year> 1996. </year> <month> 14 </month>
Reference-contexts: The next section elaborates on the compilation of triggers. We note some similarity between our pseudo-naive interpreter and the techniques described in <ref> [19] </ref> for converting bottom-up rules into Prolog rules. 7 6 Compilation for Pseudo-Naive Evaluation The most important aspect of compiling Starlog programs for the pseudo-naive evaluator is choosing one or more appropriate triggers for each clause.
References-found: 19

