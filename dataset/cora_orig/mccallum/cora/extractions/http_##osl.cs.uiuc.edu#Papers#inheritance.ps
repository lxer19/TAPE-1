URL: http://osl.cs.uiuc.edu/Papers/inheritance.ps
Refering-URL: http://osl.cs.uiuc.edu/Papers/Language.html
Root-URL: http://www.cs.uiuc.edu
Email: suresh@research.nj.nec.com  agha@cs.uiuc.edu  
Phone: 2  
Title: A Reflective Model of Inheritance  
Author: Suresh Jagannathan and Gul Agha 
Address: 4 Independence Way, Princeton, NJ 08540,  1304 W. Springfield Ave., University of Illinois, Urbana, IL 61801,  
Affiliation: 1 Computer Science Research, NEC Research Institute,  Dept. of Computer Science,  
Abstract-found: 0
Intro-found: 1
Reference: 1. <author> Harold Abelson and Gerald Sussman. </author> <title> Structure and Interpretation of Computer Programs. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1985. </year>
Reference-contexts: The binding value of c is not captured by evaluating reify . Unlike other language definitions that permit the explicit capture of bindings or environments <ref> [1, 6] </ref>, the semantics of reify permits selective capture of bindings found in its environment.
Reference: 2. <author> Norman Adams and Jonathan Rees. </author> <title> Object-Oriented Programming in Scheme. </title> <booktitle> In Proceedings of the 1988 Conference on Lisp and Functional Programming, </booktitle> <pages> pages 277-288, </pages> <year> 1988. </year>
Reference-contexts: Lexically-scoped languages that do not support reflective environments would be hard-pressed to support this functionality given the clumsiness of achieving late-binding using lexical scoping. Of course, it is possible to express object-based programming in languages like T <ref> [2] </ref> or Common Lisp [5, 28] that are statically scoped. Support for objects in these systems however often involves extensions to the language kernel (e.g., dynamically-scoped instance variables in Common Lisp) or significant alterations to the language kernel (e.g., as in T).
Reference: 3. <author> Pierre America. </author> <title> Issues in the design of a parallel object-oriented language. </title> <editor> In Pierre America and Jan Rutten, editors, </editor> <title> A Parallel Object-Oriented Language: </title> <booktitle> Design and Semantic Foundations, chapter 2. </booktitle> <publisher> Centrum voor Wiskunde en Informatica, </publisher> <address> Amsterdam, Netherlands, </address> <year> 1989. </year> <type> in PhD thesis. </type>
Reference-contexts: Rather than using type inference and subtyping, America <ref> [3] </ref> and Snyder [27] have argued that subtyping should be separated from inheritance which, in their view, serves primarily as a vehicle for code-sharing. <p> For example, in implementing a stack, we may wish to inherit code from an array but we would not want to consider a stack to be a subtype of an array <ref> [3] </ref>. Reflection permits us to support this kind of formulation as described earlier.
Reference: 4. <author> H. Barendregt. </author> <title> The Lambda Calculus. </title> <publisher> North-Holland, </publisher> <year> 1981. </year>
Reference-contexts: The definition of letrec follows from the definition of application and the assumption of a least fixpoint operator <ref> [4] </ref>; its definition is omitted as well. (Constants) ; ! ; y ` v =) v (Identifiers) (x) = (&lt; i ; i &gt;; e) i ; ! y ; ! ; y ` x =) v Since L is a non-strict language, the binding values of identifiers are always closures.
Reference: 5. <author> Daniel Bobrow, Linda DiMichiel, Richard Gabriel, Sonya Keene, Gregor Kicczales, and David Moon. </author> <title> Common Lisp Object System Specification 1. Programmer Interface Concepts. </title> <booktitle> Lisp and Symbolic Computation, </booktitle> <pages> pages 245-298, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: Lexically-scoped languages that do not support reflective environments would be hard-pressed to support this functionality given the clumsiness of achieving late-binding using lexical scoping. Of course, it is possible to express object-based programming in languages like T [2] or Common Lisp <ref> [5, 28] </ref> that are statically scoped. Support for objects in these systems however often involves extensions to the language kernel (e.g., dynamically-scoped instance variables in Common Lisp) or significant alterations to the language kernel (e.g., as in T).
Reference: 6. <author> Robert Burstall and Butler Lampson. </author> <title> A Kernel Language for Modules and Abstract Data Types. </title> <booktitle> In International Symposium on Semantics of Data Types. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1984. </year> <booktitle> Lecture Notes in Computer Science, Number 173. </booktitle>
Reference-contexts: Thus, expressions in e 2 that access a binding B in r force the evaluation of the deferred expression associated with B's binding value. The reflect operator is similar to the dot operator discussed by Gordon in [14] and to the let construct found in Pebble <ref> [6] </ref>, a higher-order language that treats bindings as first-class values. 3.3 Reification The transformation of an environment into a data object is accomplished using the reify operator. <p> The binding value of c is not captured by evaluating reify . Unlike other language definitions that permit the explicit capture of bindings or environments <ref> [1, 6] </ref>, the semantics of reify permits selective capture of bindings found in its environment.
Reference: 7. <author> Luca Cardelli. </author> <title> A Semantics of Multiple Inheritance. </title> <booktitle> In International Symposium on Semantics of Data Types. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1984. </year> <booktitle> Lecture Notes in Computer Science, Number 173. </booktitle>
Reference-contexts: There has been much interest in a type-theoretic description of inheritance [15, 24, 31]. Under this view, inheritance can be implemented given a suitable subtype relation (or similar constraint system) over objects or records. To paraphrase <ref> [7] </ref>, a record type t is considered to be a subtype of t 0 if it has at least all the fields of t such that the common fields of t and t 0 are related under the subtype rule.
Reference: 8. <author> Luca Cardelli and Peter Wegner. </author> <title> On Understanding Types, Data Abstraction, </title> <journal> and Poly-morphism. ACM Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <year> 1985. </year>
Reference-contexts: Class-based inheritance [12, 13, 21], delegation [22, 29, 30], and subtyping <ref> [8] </ref> are among competing proposals that address these issues. Code reusability and name overloading techniques are expressible given a mechanism that permits the free capture and projection of environments.
Reference: 9. <author> Craig Chambers and David Ungar. </author> <title> Customization: Optimizing Compiler Technology for SELF, A Dynamically-Typed Object-Oriented Programming Language. </title> <booktitle> In ACM SIG-PLAN '89 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 146-160, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: For example, if the abstraction returned by the above expression is called NewStackGen , evaluating: let MyNewStack = (NewStackGen size) in (reify MyNewStack.Push) returns a record containing the bindings of all public variables that occur free in Push 's closure. Reification permits the expression of dynamic inheritance <ref> [9] </ref>. A system that supports dynamic inheritance allows new methods to be incorporated into the object hierarchy dynamically. If the definition of the overflow exception handler defined in StackGen was changed 5 , modified stack implementations that use this procedure as the default exception handler would see the change. <p> Providing operations to reflect and reify over environment structures obviates the need for linguistic mechanisms (such as class or method definitions) tailored explicitly for inheritance. Lieberman [22], Ungar <ref> [30, 9] </ref>, and Stein [29] have advocated a variant of class-based inheritance in which objects subsume the functionality of classes. Objects receive messages which can be forwarded at their discretion to other objects.
Reference: 10. <author> William Cook, Walter Hill, and Peter Canning. </author> <title> Inheritance is Not Subtyping. </title> <booktitle> In 17 th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 125-135, </pages> <year> 1990. </year>
Reference-contexts: Inheritance is realized by constructing a type system that supports inclusion polymorphism on records. The pragmatic utility of such an approach stills appears to be an issue of debate given the subtlety and complexity of the type rules <ref> [10] </ref>. Our approach is orthogonal to these efforts; we don't rely on a strong type-system to build inheritance systems, although a type system for a reflective language similar to L does exist [17].
Reference: 11. <author> William Cook and Jens Palsberg. </author> <title> A Denotational Semantics of Inheritance and its Correctness. </title> <booktitle> In OOPSLA'89 Conference Proceedings, </booktitle> <pages> pages 433-444, </pages> <year> 1989. </year> <note> Published as SIGPLAN Notices 24(10), </note> <month> October, </month> <year> 1989. </year>
Reference-contexts: These primitives provide an expressive platform to express a number of inheritance-related abstractions. Our model is distinguished from other efforts that provide a formal semantic treatment of inheritance and delegation <ref> [11, 19] </ref>. In these systems, objects are represented as records, with fixpoints and record composition used to realize late-binding. Our work generalizes this approach in some important respects. Most notably, we define specific linguistic mechanisms to express inheritance and delegation that are couched in terms of reflective operations over environments. <p> Cook and Palsberg <ref> [11] </ref>, Reddy [26], and Kamin [19] discuss how to build class-based inheritance systems that permit construction of modified versions of recursive structures using explicit fixpoint notation. In essence, a fixpoint semantics is used to give a nonoperational definition of the "self" pseudo-variable found in Smalltalk-style languages. <p> Reification gives access to this environment. To illustrate how to use reflection to build inheritance systems that have recursive components, consider an example discussed in <ref> [11, 19] </ref>. A circle is a sub-class of a point .
Reference: 12. <author> O.J. Dahl, B. Myhruhaug, and K. Nygaard. </author> <title> The Simula67 Base Common Base Language. </title> <type> Technical report, </type> <institution> Norwegien Computing Center, </institution> <year> 1970. </year>
Reference-contexts: Thus, environments within this model have a well-defined concrete representation. operators described. Given a way to explicitly manipulate environments, inheritance based abstractions are implemented in terms of creation, composition, and reification of environments. In this regard, the model differs from traditional class-based inheritance systems (e.g., Simula <ref> [12] </ref> or Smalltalk [13]) in several important respects. <p> Class-based inheritance <ref> [12, 13, 21] </ref>, delegation [22, 29, 30], and subtyping [8] are among competing proposals that address these issues. Code reusability and name overloading techniques are expressible given a mechanism that permits the free capture and projection of environments. <p> All free names are resolved relative to the environment in effect at the time a class instance is created, not the environment extant at the time the class definition is evaluated. 7 Conclusions and Comparison to Related Work The operational view of inheritance in Simula <ref> [12] </ref> and Smalltalk [13, 16] led to its emphasis as a programming method to support sharing and reusability of code and data.
Reference: 13. <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley Press, </publisher> <year> 1983. </year>
Reference-contexts: Thus, environments within this model have a well-defined concrete representation. operators described. Given a way to explicitly manipulate environments, inheritance based abstractions are implemented in terms of creation, composition, and reification of environments. In this regard, the model differs from traditional class-based inheritance systems (e.g., Simula [12] or Smalltalk <ref> [13] </ref>) in several important respects. <p> Class-based inheritance <ref> [12, 13, 21] </ref>, delegation [22, 29, 30], and subtyping [8] are among competing proposals that address these issues. Code reusability and name overloading techniques are expressible given a mechanism that permits the free capture and projection of environments. <p> A point generator. of object-based languages such as Smalltalk <ref> [13] </ref>. Self is defined to be a record containing the bindings found in the caller ( obj ), point 's methods, and bindings for a and b . <p> All free names are resolved relative to the environment in effect at the time a class instance is created, not the environment extant at the time the class definition is evaluated. 7 Conclusions and Comparison to Related Work The operational view of inheritance in Simula [12] and Smalltalk <ref> [13, 16] </ref> led to its emphasis as a programming method to support sharing and reusability of code and data.
Reference: 14. <author> Michael Gordon. </author> <title> The Denotational Description of Programming Languages. </title> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: Thus, expressions in e 2 that access a binding B in r force the evaluation of the deferred expression associated with B's binding value. The reflect operator is similar to the dot operator discussed by Gordon in <ref> [14] </ref> and to the let construct found in Pebble [6], a higher-order language that treats bindings as first-class values. 3.3 Reification The transformation of an environment into a data object is accomplished using the reify operator.
Reference: 15. <author> Justin Graver and Ralph Johnson. </author> <title> A Type System for Smalltalk. </title> <booktitle> In 17 th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 136-150, </pages> <year> 1990. </year>
Reference-contexts: Reifying over closures closely captures the behavior of delegation since a closure defines a local namespace which, in the presence of reflection, constitutes a prototype object. There has been much interest in a type-theoretic description of inheritance <ref> [15, 24, 31] </ref>. Under this view, inheritance can be implemented given a suitable subtype relation (or similar constraint system) over objects or records.
Reference: 16. <author> Daniel Ingalls. </author> <title> The Smalltalk-76 Programming System: </title> <booktitle> Design and Implementation. In Fifth ACM Symposium on Principles of Programming Languages Conf., </booktitle> <pages> pages 9-16, </pages> <month> Jan-uary </month> <year> 1978. </year>
Reference-contexts: All free names are resolved relative to the environment in effect at the time a class instance is created, not the environment extant at the time the class definition is evaluated. 7 Conclusions and Comparison to Related Work The operational view of inheritance in Simula [12] and Smalltalk <ref> [13, 16] </ref> led to its emphasis as a programming method to support sharing and reusability of code and data.
Reference: 17. <author> Suresh Jagannathan. </author> <title> A Programming Language Supporting First-Class, Parallel Environments. </title> <type> Technical Report LCS-TR 434, </type> <institution> Massachusetts Institute of Technology, </institution> <month> December </month> <year> 1988. </year>
Reference-contexts: We consider the issue of delegation of operations across objects (rather than object generators) in the following section. 5 We haven't provided mutation operators in the kernel language, but a semantics that supports references and stores is straightforward to incorporate <ref> [17] </ref>. Critics might argue that building modified versions of object generators is possible even in the absence of reification and environment-based reflection. Consider two possible alternatives. <p> Our approach is orthogonal to these efforts; we don't rely on a strong type-system to build inheritance systems, although a type system for a reflective language similar to L does exist <ref> [17] </ref>. In our context, type information is used to determine the presence (or absence) of bindings in environment-yielding (reflective) operations. For example, in the code fragment: ( (x) (reflect x in y)) the binding-value of y is predicated on the meaning of x .
Reference: 18. <author> Suresh Jagannathan. </author> <title> Environment-based reflection. </title> <type> Technical Report 91-001-3-0050-1, </type> <institution> NEC Research Institute, </institution> <month> January </month> <year> 1991. </year>
Reference-contexts: The implications of this approach in the context of reflection is given in <ref> [18] </ref>. A circle is defined in terms of points. Because circles have a radius, they have a different meaning of distance from the origin.
Reference: 19. <author> Samuel Kamin. </author> <title> Inheritance in Smalltalk-80: A Denotational Definition. </title> <booktitle> In 15 th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 80-87, </pages> <year> 1988. </year>
Reference-contexts: These primitives provide an expressive platform to express a number of inheritance-related abstractions. Our model is distinguished from other efforts that provide a formal semantic treatment of inheritance and delegation <ref> [11, 19] </ref>. In these systems, objects are represented as records, with fixpoints and record composition used to realize late-binding. Our work generalizes this approach in some important respects. Most notably, we define specific linguistic mechanisms to express inheritance and delegation that are couched in terms of reflective operations over environments. <p> Cook and Palsberg [11], Reddy [26], and Kamin <ref> [19] </ref> discuss how to build class-based inheritance systems that permit construction of modified versions of recursive structures using explicit fixpoint notation. In essence, a fixpoint semantics is used to give a nonoperational definition of the "self" pseudo-variable found in Smalltalk-style languages. <p> Reification gives access to this environment. To illustrate how to use reflection to build inheritance systems that have recursive components, consider an example discussed in <ref> [11, 19] </ref>. A circle is a sub-class of a point .
Reference: 20. <author> Eugene Kohlbecker and Mitch Wand. Macro-by-Example: </author> <title> Deriving Syntactic Transformations from their Specifications. </title> <booktitle> In 14 th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 77-85, </pages> <year> 1987. </year>
Reference-contexts: We assume a sufficiently expressive macro language that would permit us to avoid specifying fields if they are irrelevant to the specification of the object. <ref> [20] </ref> describes one such system.
Reference: 21. <author> B.B. Kristensen, O.L. Madsen, B. Mtller-Pedersen, and K. Nygaard. </author> <title> The BEA Programming Language. </title> <editor> In Bruce Shiver and Peter Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: Class-based inheritance <ref> [12, 13, 21] </ref>, delegation [22, 29, 30], and subtyping [8] are among competing proposals that address these issues. Code reusability and name overloading techniques are expressible given a mechanism that permits the free capture and projection of environments.
Reference: 22. <author> Henry Liebermann. </author> <title> Using Prototypical Objects to Implement Shared Behavior in Object-Oriented Systems. </title> <booktitle> In OOPSLA'86 Conference Proceedings, </booktitle> <pages> pages 214-223, </pages> <year> 1986. </year> <note> Published as SIGPLAN Notice 21(11), </note> <month> November </month> <year> 1986. </year>
Reference-contexts: Inheritance is viewed as a programming method, not a fundamental property of a programming language. The model is also distinguished from delegation based systems <ref> [22, 30] </ref> insofar as (a) objects are implemented in terms of ordinary function abstractions and data structures, (b) there is no a priori static structure for an object that indicates its parent in the delegation hierarchy, and (c) objects instantiated from classes can be freely intermixed with objects instantiated via delegation. <p> Class-based inheritance [12, 13, 21], delegation <ref> [22, 29, 30] </ref>, and subtyping [8] are among competing proposals that address these issues. Code reusability and name overloading techniques are expressible given a mechanism that permits the free capture and projection of environments. <p> In class-based languages, name overloading becomes the key operational feature of inheritance and explicit linguistic mechanisms are provided to build class hierarchies. Providing operations to reflect and reify over environment structures obviates the need for linguistic mechanisms (such as class or method definitions) tailored explicitly for inheritance. Lieberman <ref> [22] </ref>, Ungar [30, 9], and Stein [29] have advocated a variant of class-based inheritance in which objects subsume the functionality of classes. Objects receive messages which can be forwarded at their discretion to other objects.
Reference: 23. <author> Satoshi Matsuoka, Takuo Watanabe, and Akinori Yonezawa. </author> <title> Hybrid Group Reflective Architecture for Object-Oriented Concurrent Reflective Programming. </title> <booktitle> In Proceedings of European Conference on Object-Oriented Programming, </booktitle> <pages> pages 231-250, </pages> <year> 1991. </year> <note> Published as Springer-Verlag LNCS 512. </note>
Reference-contexts: Reflection permits us to support this kind of formulation as described earlier. There has also been much work in generalizing reflection to work in the presence of fine-grained concurrency <ref> [23, 32] </ref>; the use of reflection in this context permits program control over implementation concerns such as monitoring, scheduling, migration, etc.
Reference: 24. <author> Jens Palsberg and Michal Schwartzbach. </author> <title> Object-Oriented Type Inference. </title> <booktitle> In OOPSLA'91 Conference Proceedings, </booktitle> <pages> pages 146-161, </pages> <year> 1991. </year>
Reference-contexts: Reifying over closures closely captures the behavior of delegation since a closure defines a local namespace which, in the presence of reflection, constitutes a prototype object. There has been much interest in a type-theoretic description of inheritance <ref> [15, 24, 31] </ref>. Under this view, inheritance can be implemented given a suitable subtype relation (or similar constraint system) over objects or records.
Reference: 25. <author> Gordon Plotkin. </author> <title> A Structural Approach to Operational Semantics. </title> <type> Technical Report DAIMI FN-19, </type> <institution> Computer Science Dept., Aarhus University, </institution> <year> 1981. </year>
Reference-contexts: b = 2, c = 11 ] The binding value of a is not captured in the record representation of d 's closure because of the prompt prefixing the inner let . 4 Formal Semantics The semantics of L is given in terms of a set of Plotkin-style rewrite rules <ref> [25] </ref>. The semantics of reflection is captured in three rules that manipulate environments. Applications augment the current evaluation environment with a binding for the -bound variable defined by the abstraction; prompts remove bindings from an evaluation environment; public variables project bindings outside the environment in which they were defined.
Reference: 26. <author> Uday Reddy. </author> <title> Objects as Closures: Abstract Semantics of Object-Oriented Languages. </title> <booktitle> In Proceedings of the Conference 1988 on Lisp and Functional Programming, </booktitle> <pages> pages 289-297, </pages> <year> 1988. </year>
Reference-contexts: Cook and Palsberg [11], Reddy <ref> [26] </ref>, and Kamin [19] discuss how to build class-based inheritance systems that permit construction of modified versions of recursive structures using explicit fixpoint notation. In essence, a fixpoint semantics is used to give a nonoperational definition of the "self" pseudo-variable found in Smalltalk-style languages.
Reference: 27. <author> Alan Snyder. </author> <title> Encapsulation and inheritance in object-oriented languages. </title> <booktitle> In Object-Oriented Programming Systems, Languages and Applications Conference Proceedings, </booktitle> <pages> pages 38-45. </pages> <publisher> ACM Press, </publisher> <year> 1986. </year>
Reference-contexts: Rather than using type inference and subtyping, America [3] and Snyder <ref> [27] </ref> have argued that subtyping should be separated from inheritance which, in their view, serves primarily as a vehicle for code-sharing.
Reference: 28. <author> Guy Steele Jr. </author> <title> Common Lisp: The Language, Second Edition. </title> <publisher> Digital Press, </publisher> <year> 1990. </year>
Reference-contexts: Lexically-scoped languages that do not support reflective environments would be hard-pressed to support this functionality given the clumsiness of achieving late-binding using lexical scoping. Of course, it is possible to express object-based programming in languages like T [2] or Common Lisp <ref> [5, 28] </ref> that are statically scoped. Support for objects in these systems however often involves extensions to the language kernel (e.g., dynamically-scoped instance variables in Common Lisp) or significant alterations to the language kernel (e.g., as in T).
Reference: 29. <author> Lynn Stein. </author> <title> Delegation is Inheritance. </title> <booktitle> In OOPSLA'87 Conference Proceedings, </booktitle> <pages> pages 138-146, </pages> <year> 1987. </year> <note> Published as SIGPLAN Notices 22(12), </note> <month> December, </month> <year> 1987. </year>
Reference-contexts: Class-based inheritance [12, 13, 21], delegation <ref> [22, 29, 30] </ref>, and subtyping [8] are among competing proposals that address these issues. Code reusability and name overloading techniques are expressible given a mechanism that permits the free capture and projection of environments. <p> Providing operations to reflect and reify over environment structures obviates the need for linguistic mechanisms (such as class or method definitions) tailored explicitly for inheritance. Lieberman [22], Ungar [30, 9], and Stein <ref> [29] </ref> have advocated a variant of class-based inheritance in which objects subsume the functionality of classes. Objects receive messages which can be forwarded at their discretion to other objects. An object is a prototype for a class and delegation replaces message-passing as the main protocol for realizing inheritance.
Reference: 30. <author> David Ungar and Randall Smith. </author> <title> self: The Power of Simplicity. </title> <booktitle> In OOPSLA'87 Confer--ence Proceedings, </booktitle> <pages> pages 227-241, </pages> <year> 1987. </year> <note> Published as SIGPLAN Notices 22(12), </note> <month> December, </month> <year> 1987. </year>
Reference-contexts: Inheritance is viewed as a programming method, not a fundamental property of a programming language. The model is also distinguished from delegation based systems <ref> [22, 30] </ref> insofar as (a) objects are implemented in terms of ordinary function abstractions and data structures, (b) there is no a priori static structure for an object that indicates its parent in the delegation hierarchy, and (c) objects instantiated from classes can be freely intermixed with objects instantiated via delegation. <p> Class-based inheritance [12, 13, 21], delegation <ref> [22, 29, 30] </ref>, and subtyping [8] are among competing proposals that address these issues. Code reusability and name overloading techniques are expressible given a mechanism that permits the free capture and projection of environments. <p> Providing operations to reflect and reify over environment structures obviates the need for linguistic mechanisms (such as class or method definitions) tailored explicitly for inheritance. Lieberman [22], Ungar <ref> [30, 9] </ref>, and Stein [29] have advocated a variant of class-based inheritance in which objects subsume the functionality of classes. Objects receive messages which can be forwarded at their discretion to other objects.
Reference: 31. <author> Mitchell Wand. </author> <title> Complete Type Inference for Simple Objects. </title> <booktitle> In Second IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 37-44, </pages> <year> 1987. </year>
Reference-contexts: Reifying over closures closely captures the behavior of delegation since a closure defines a local namespace which, in the presence of reflection, constitutes a prototype object. There has been much interest in a type-theoretic description of inheritance <ref> [15, 24, 31] </ref>. Under this view, inheritance can be implemented given a suitable subtype relation (or similar constraint system) over objects or records.
Reference: 32. <author> Akinori Yonezawa and Takuo Watanabe. </author> <title> An Introduction to Object-Based Reflective Concurrent Computations. </title> <booktitle> In Proceedings of the 1988 ACM SIGPLAN Workshop on Object-Based Concurrent Programming, </booktitle> <pages> pages 50-54, </pages> <year> 1989. </year>
Reference-contexts: Reflection permits us to support this kind of formulation as described earlier. There has also been much work in generalizing reflection to work in the presence of fine-grained concurrency <ref> [23, 32] </ref>; the use of reflection in this context permits program control over implementation concerns such as monitoring, scheduling, migration, etc.
References-found: 32

