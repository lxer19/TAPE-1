URL: http://www.cs.indiana.edu/l/www/ftp/pierce/dynamic.ps.gz
Refering-URL: http://www.cs.indiana.edu/l/www/ftp/pierce/
Root-URL: http://www.cs.indiana.edu
Title: Dynamic Typing in a Statically Typed Language  
Author: Martn Abadi Luca Cardelli Benjamin Pierce Gordon Plotkin 
Abstract: Statically typed programming languages allow earlier error checking, better enforcement of disciplined programming styles, and generation of more efficient object code than languages where all type consistency checks are performed at run time. However, even in statically typed languages, there is often the need to deal with data whose type cannot be determined at compile time. To handle such situations safely, we propose to add a type Dynamic whose values are pairs of a value v and a type tag T where v has the type denoted by T. Instances of Dynamic are built with an explicit tagging construct and inspected with a type safe typecase construct. This paper explores the syntax, operational semantics, and denotational semantics of a simple language including the type Dynamic. We give examples of how dynamically typed values can be used in programming. Then we discuss an operational semantics for our language and obtain a soundness theorem. We present two formulations of the denotational semantics of this language and relate them to the operational semantics. Finally, we consider the implications of polymorphism and some implementation issues. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Malcolm P. Atkinson and O. Peter Buneman. </author> <title> Types and persistence in database programming languages. </title> <journal> Computing Surveys, </journal> <volume> 19(2) </volume> <pages> 105-190, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: Dynamically typed objects have also been discussed recently in the database literature as an approach to dealing with persistent data in the context of statically typed database programming languages <ref> [1, 2, 10] </ref>.
Reference: [2] <author> Malcolm P. Atkinson and Ronald Morrison. </author> <title> Polymorphic names and iterations. </title> <type> Draft article, </type> <month> September </month> <year> 1987. </year>
Reference-contexts: Dynamically typed objects have also been discussed recently in the database literature as an approach to dealing with persistent data in the context of statically typed database programming languages <ref> [1, 2, 10] </ref>.
Reference: [3] <author> H. P. Barendregt. </author> <title> The Lambda Calculus. </title> <address> North Holland, </address> <note> revised edition, </note> <year> 1984. </year>
Reference-contexts: function f when applied to f: fix f = f (fix f): In call-by-value lambda-calculi, an extensional version of this property must be used instead: for any argument a, (fix f) a = f (fix f) a One function with this property (a call-by-value version of the standard Y combinator <ref> [3, p. 131] </ref>, [29]) can be expressed in an untyped variant of our notation by: fix = f. d d 3 PROGRAMMING WITH DYNAMIC 9 where d = x. z. (f (x x)) z: To see that (fix f) a = f (fix f) a for any function f and argument <p> obtained as the limit of a sequence of approximations V 0 , V 1 , : : : , where V 0 = f?g V i+1 = N + (V i !V i ) + (V i fiTypeCode) + W: We omit the details of the construction, which are standard <ref> [3, 22] </ref>. At this point, we have a universe suitable for assigning a meaning to expressions in our programming language.
Reference: [4] <author> Andrew D. Birrell and Bruce Jay Nelson. </author> <title> Implementing remote procedure calls. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(1) </volume> <pages> 39-59, </pages> <month> February </month> <year> 1984. </year>
Reference-contexts: Indeed, the entire file system could be based on Dynamic structures. Dynamic objects can also be used as the values exchanged during interprocess communication, thereby providing type safe interactions between processes. The Remote Procedure Call paradigm <ref> [4] </ref> uses essentially this mechanism. (Most RPC implementations optimize the conversions to and from the transport medium, so the Dynamic objects may exist only in principle.) A number of systems already incorporate mechanisms similar to those we have described.
Reference: [5] <author> Graham M. Birtwistle, Ole-Johan Dahl, Bjorn Myhrhaug, and Kristen Nygaard. </author> <title> Sim-ula Begin. </title> <institution> Studentlitteratur (Lund, Sweden), Bratt Institute Fuer Neues Lerned (Goch, FRG), Chartwell-Bratt Ltd (Kent, </institution> <address> England), </address> <year> 1979. </year>
Reference-contexts: Pascal). Both of these can be thought of as "finite versions" of Dynamic: they allow values of different types to be manipulated uniformly as elements of a tagged variant type, with the restriction that the set of variants must be fixed in advance. Simula-67's subclass structure <ref> [5] </ref>, on the other hand, can be thought of as an infinite disjoint union|essentially equivalent to Dynamic. The Simula-67 INSPECT statement allows a program to determine at run time which subclass a value belongs to, with an ELSE clause for subclasses that the program doesn't know or care about.
Reference: [6] <author> P. Borras, D. Clement, T. Despeyroux, J. Incerpi, G. Kahn, B. Lang, and V. Pascual. </author> <title> CENTAUR: the system. </title> <booktitle> In Proceedings of the Third Annual Symposium on Software Development Environments (SIGSOFT'88), </booktitle> <address> Boston, </address> <month> November </month> <year> 1988. </year> <note> REFERENCES 33 </note>
Reference-contexts: This breadth of coverage and "operational style" makes the notation a good one for specifying comparatively rich languages like Standard ML [25]. A group at INRIA has built a system for directly interpreting formal specifications written in a similar notation <ref> [6, 13, 14] </ref>. The rules below define the situations in which the judgement "expression e has type T" is valid under assumptions TE . This is written "TE ` e : T".
Reference: [7] <author> Luca Cardelli. </author> <title> Amber. </title> <editor> In Guy Cousineau, Pierre-Louis Curien, and Bernard Robinet, editors, </editor> <booktitle> Combinators and Functional Programming Languages. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1986. </year> <note> Lecture Notes in Computer Science No. 242. </note>
Reference-contexts: The innovation of allowing pattern variables in typecase expressions (see below) seems to originate with Mycroft. (Unfortunately, neither of these proposals were published.) Recent versions of the CAML language [37] include features quite similar to our dynamic and typecase constructs. Amber <ref> [7] </ref>, a language based on subtyping, includes a Dynamic type whose main use is for handling persistent data. In fact, the Amber system itself depends heavily on dynamically typed values. For example, when a module is compiled, it is stored in the file system as a single Dynamic object. <p> It would be possible to add another mechanism to the language, providing a way of "unpackaging" the type tag of a Dynamic into a data structure that could then be examined by the program. (Amber <ref> [7] </ref> and Cedar/Mesa [19] have this feature.) Although this would be a convenient way to implement operations like type printing|which may be important in practice|we believe that most of the theoretical interest of Dynamic lies in the interaction between statically and dynamically checked parts of the language that the typecase expression <p> Thus, a unique identifier can still be associated with each equivalence class of types, and, as in Simula-67, match can check that a given tag is a subtype of a typecase guard by quickly scanning a precompiled list of superclasses of the tag. Amber's notion of "structural subtyping" <ref> [7] </ref> requires a more sophisticated representation of type tags.
Reference: [8] <author> Luca Cardelli, James Donahue, Lucille Glassman, Mick Jordan, Bill Kalsow, and Greg Nelson. </author> <note> Modula-3 report (revised). Research report 52, DEC Systems Research Center, </note> <month> November </month> <year> 1989. </year>
Reference-contexts: Cedar/Mesa [19] provides very similar REFANY and TYPECASE. These features of Cedar/Mesa were carried over directly into Modula-2+ [32] and Modula-3 <ref> [8, 9] </ref>. In CLU and Cedar/Mesa, the primary motivation for including a dynamic type was to support programming idioms from LISP. Shaffert and Scheifler gave a formal definition [33] and denotational semantics [34] of CLU, including the type any and the force construct. <p> Modula-3, for example, includes a type similar to Dynamic, a typecase construct that allows only matching of complete type expressions (no pattern variables), and a notion of subtyping <ref> [8, 9] </ref>. (We do not know of a language with structural equivalence, Dynamic, and exact type matching, but without subtyping.) Efficient implementation of typecase is possible in Modula-3 because the rules for structural matching of subtypes are "rigid"|subtyping is based on an explicit hierarchy.
Reference: [9] <author> Luca Cardelli, James Donahue, Mick Jordan, Bill Kalsow, and Greg Nelson. </author> <title> The Modula-3 type system. </title> <booktitle> In Proceedings of the Sixteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 202-212, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: Cedar/Mesa [19] provides very similar REFANY and TYPECASE. These features of Cedar/Mesa were carried over directly into Modula-2+ [32] and Modula-3 <ref> [8, 9] </ref>. In CLU and Cedar/Mesa, the primary motivation for including a dynamic type was to support programming idioms from LISP. Shaffert and Scheifler gave a formal definition [33] and denotational semantics [34] of CLU, including the type any and the force construct. <p> Modula-3, for example, includes a type similar to Dynamic, a typecase construct that allows only matching of complete type expressions (no pattern variables), and a notion of subtyping <ref> [8, 9] </ref>. (We do not know of a language with structural equivalence, Dynamic, and exact type matching, but without subtyping.) Efficient implementation of typecase is possible in Modula-3 because the rules for structural matching of subtypes are "rigid"|subtyping is based on an explicit hierarchy.
Reference: [10] <author> Luca Cardelli and David MacQueen. </author> <title> Persistence and type abstraction. </title> <booktitle> In Proceedings of the Persistence and Datatypes Workshop, </booktitle> <month> August </month> <year> 1985. </year> <note> Proceedings published as University of St. Andrews, Department of Computational Science, Persistent Programming Research Report 16. </note>
Reference-contexts: Dynamically typed objects have also been discussed recently in the database literature as an approach to dealing with persistent data in the context of statically typed database programming languages <ref> [1, 2, 10] </ref>.
Reference: [11] <author> Luca Cardelli and Peter Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> Computing Surveys, </journal> <volume> 17(4), </volume> <month> December </month> <year> 1985. </year>
Reference-contexts: Following Mitchell and Plotkin [26], we can think of a Dynamic whose tag is an existential type as being a module with hidden implementation, or alternatively as an encapsulated element of an abstract data type. Our notation for existential types and labeled products follows that of Cardelli and Wegner <ref> [11] </ref>.
Reference: [12] <author> Alonzo Church. </author> <title> A formulation of the simple theory of types. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 5 </volume> <pages> 56-68, </pages> <year> 1940. </year>
Reference-contexts: Thatte [35] has described a "quasi-static" type system based on the one described here, where our explicit dynamic and typecase constructs are replaced by implicit coercions and run time checks. 3 Programming with Dynamic This section introduces the notation used in the rest of the paper|essentially Church's simply typed lambda-calculus <ref> [12, 17] </ref> with a call-by-value reduction scheme [29], extended with the type Dynamic and the dynamic and typecase constructs. We present a number of example programs to establish the notation and illustrate its expressiveness. Our fundamental constructs are -abstraction, application, conditionals, and arithmetic on natural numbers.
Reference: [13] <author> Dominique Clement, Joelle Despeyroux, Thierry Despeyroux, Laurent Hascoet, and Gilles Kahn. </author> <title> Natural semantics on the computer. </title> <type> Technical Report RR 416, </type> <institution> INRIA, </institution> <month> June </month> <year> 1985. </year>
Reference-contexts: This breadth of coverage and "operational style" makes the notation a good one for specifying comparatively rich languages like Standard ML [25]. A group at INRIA has built a system for directly interpreting formal specifications written in a similar notation <ref> [6, 13, 14] </ref>. The rules below define the situations in which the judgement "expression e has type T" is valid under assumptions TE . This is written "TE ` e : T".
Reference: [14] <author> Thierry Despeyroux. </author> <title> Typol: a formalism to implement natural semantics. </title> <type> Technical Report 94, </type> <institution> INRIA, </institution> <month> March </month> <year> 1988. </year>
Reference-contexts: This breadth of coverage and "operational style" makes the notation a good one for specifying comparatively rich languages like Standard ML [25]. A group at INRIA has built a system for directly interpreting formal specifications written in a similar notation <ref> [6, 13, 14] </ref>. The rules below define the situations in which the judgement "expression e has type T" is valid under assumptions TE . This is written "TE ` e : T".
Reference: [15] <author> Mike Gordon. </author> <title> Adding Eval to ML. </title> <type> Personal communication, </type> <month> circa </month> <year> 1980. </year>
Reference-contexts: Moreover, until recently ML has not been used for building software systems that deal much with persistent data. Still, there have been various proposals for extending ML with a dynamic type. Gordon seems to have thought of it first <ref> [15] </ref>; his ideas were later extended by Mycroft [27]. The innovation of allowing pattern variables in typecase expressions (see below) seems to originate with Mycroft. (Unfortunately, neither of these proposals were published.) Recent versions of the CAML language [37] include features quite similar to our dynamic and typecase constructs.
Reference: [16] <author> Robert Harper. </author> <title> Introduction to Standard ML. </title> <type> Technical Report ECS-LFCS-86-14, </type> <institution> Laboratory for the Foundations of Computer Science, Edinburgh University, </institution> <month> Septem-ber </month> <year> 1986. </year>
Reference-contexts: In particular, it is not claimed that run time values actually occurring in the evaluation of a well-typed program are tagged with the types that they actually possess. The proof of a soundness result for CLU would probably require techniques similar to those developed in this paper. ML <ref> [16, ?, 25] </ref> and its relatives have shown more resistance to the incorporation of dynamic typing than languages in the Algol family. Probably this is because many of the uses of Dynamic in Algol-like languages are captured in ML by polymorphic types.
Reference: [17] <author> J. Roger Hindley and Jonathan P. Seldin. </author> <title> Introduction to Combinators and -Calculus, volume 1 of London Mathematical Society Student Texts. </title> <publisher> Cambridge University Press, </publisher> <year> 1986. </year>
Reference-contexts: Thatte [35] has described a "quasi-static" type system based on the one described here, where our explicit dynamic and typecase constructs are replaced by implicit coercions and run time checks. 3 Programming with Dynamic This section introduces the notation used in the rest of the paper|essentially Church's simply typed lambda-calculus <ref> [12, 17] </ref> with a call-by-value reduction scheme [29], extended with the type Dynamic and the dynamic and typecase constructs. We present a number of example programs to establish the notation and illustrate its expressiveness. Our fundamental constructs are -abstraction, application, conditionals, and arithmetic on natural numbers. <p> We show that it can be used to build a fixpoint operator, allowing recursive computations to be expressed in the language even without the rec construct. It is well known that fixpoint operators cannot be expressed in the ordinary simply typed lambda-calculus. (This follows from the strong normalization property <ref> [17, p. 163] </ref>.) However, by hiding a certain parameter inside a dynamic value, smuggling it past the type system, and unpackaging it again where it is needed, we can write a well-typed version in our language.
Reference: [18] <author> Gilles Kahn. </author> <title> Natural semantics. </title> <booktitle> In Proceedings of the Symposium on Theoretical Aspects of Computer Science, </booktitle> <address> Passau, Germany, </address> <month> February </month> <year> 1987. </year> <note> Proceedings published as Springer-Verlag Lecture Notes in Computer Science 247. The paper is also available as INRIA Report 601, </note> <month> February, </month> <year> 1987. </year>
Reference-contexts: Because the inference rules are similar to those used in systems for natural deduction in logic, this style of description has also come to be known as "natural semantics" <ref> [18] </ref>. The rules closely follow the structure of expressions, and incorporate a strong notion of computation.
Reference: [19] <author> Butler Lampson. </author> <title> A description of the cedar language. </title> <type> Technical Report CSL-83-15, </type> <institution> Xerox Palo Alto Research Center, </institution> <year> 1983. </year> <note> REFERENCES 34 </note>
Reference-contexts: CLU [20] is a later language that incorporates the idea of dynamic typing in a static context. It has a type any and a force construct that attempts to coerce an any into an instance of a given type, raising an exception if the coercion is not possible. Cedar/Mesa <ref> [19] </ref> provides very similar REFANY and TYPECASE. These features of Cedar/Mesa were carried over directly into Modula-2+ [32] and Modula-3 [8, 9]. In CLU and Cedar/Mesa, the primary motivation for including a dynamic type was to support programming idioms from LISP. <p> It would be possible to add another mechanism to the language, providing a way of "unpackaging" the type tag of a Dynamic into a data structure that could then be examined by the program. (Amber [7] and Cedar/Mesa <ref> [19] </ref> have this feature.) Although this would be a convenient way to implement operations like type printing|which may be important in practice|we believe that most of the theoretical interest of Dynamic lies in the interaction between statically and dynamically checked parts of the language that the typecase expression allows.
Reference: [20] <author> B. Liskov, R. Atkinson, T. Bloom, E. Moss, J.C. Schaffert, R. Scheifler, and A. Snyder. </author> <title> CLU Reference Manual. </title> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: The Simula-67 INSPECT statement allows a program to determine at run time which subclass a value belongs to, with an ELSE clause for subclasses that the program doesn't know or care about. CLU <ref> [20] </ref> is a later language that incorporates the idea of dynamic typing in a static context. It has a type any and a force construct that attempts to coerce an any into an instance of a given type, raising an exception if the coercion is not possible. <p> Simula-67 Rigid Structural Equivalence Modula-3, Cedar Structural Equivalence Amber Pattern variables Our language ? Type matching is simplest in languages like CLU <ref> [20] </ref> and Modula-2+ [32], where the construct corresponding to our typecase allows only exact matches (no pattern variables), and where equivalence of types is "by name." In Modula-2+, for example, the type tags of dynamic values are just unique identifiers and type matching is a check for equality.
Reference: [21] <author> David MacQueen. </author> <title> Private communication. </title>
Reference-contexts: This is exactly the "first-order matching" problem. We can imagine speeding up this structural matching of type expressions by precompiling code to match an unknown expression against a given known expression, using techniques familiar from compilers for ML <ref> [21] </ref>.
Reference: [22] <author> David MacQueen, Gordon Plotkin, and Ravi Sethi. </author> <title> An ideal model for recursive polymorphic types. </title> <journal> Information and Control, </journal> <volume> 71 </volume> <pages> 95-130, </pages> <year> 1986. </year>
Reference-contexts: But T here ranges over all types, including Dynamic itself, so this definition as it stands is circular. We must build up the denotations of type expressions more carefully. We therefore turn to the ideal model of types, following MacQueen, Plotkin, and Sethi <ref> [22] </ref>. (We refer the reader to this paper for the technical background of our construction.) Typecodes denote ideals|nonempty subsets of V closed under approximations and limits. We denote by Idl the set of all ideals in V. The ideal model has several features worth appreciating. <p> obtained as the limit of a sequence of approximations V 0 , V 1 , : : : , where V 0 = f?g V i+1 = N + (V i !V i ) + (V i fiTypeCode) + W: We omit the details of the construction, which are standard <ref> [3, 22] </ref>. At this point, we have a universe suitable for assigning a meaning to expressions in our programming language. <p> We need to prove that these two operations are contractive. Theorem 5.1.5 The operation fi is contractive (when its second argument is fixed). The operation !! is contractive. Proof: The arguments are based on the corresponding ones for Theorem 7 of <ref> [22] </ref>. In fact, the proof for fi is a trivial variant of the corresponding one. We give only the proof for !!. Let c be a witness of minimum rank for I!!J and I'!!J', being, say, only in the former ideal. <p> Let c be a witness of minimum rank for I!!J and I'!!J', being, say, only in the former ideal. Then c 6=? (otherwise it would not be a witness), so c = hf; T!Ui for some f , T, and U. By the analogue of Proposition 4 of <ref> [22] </ref>, f = F (a i ) b i ) for some a i ; b i 2 V, with r (f ) &gt; max (r (a i ); r (b i )) (here a i ) b i denotes the step function which returns b i for arguments larger than <p> Let a = F b = fb i j a i v xg = f (x). Then a 2 I' T (since a v x) but b 62 J' U . Moreover, by the analogue of Proposition 4 of <ref> [22] </ref>, r (a) maxfr (a i ) j a i v xg &lt; r (f ) and r (b) &lt; r (f ). Similarly, r (a) + 1 &lt; r (c) and r (b) + 1 &lt; r (c). 5 DENOTATIONAL SEMANTICS 24 There are two cases.
Reference: [23] <author> Per Martin-Lof. </author> <title> Intuitionistic Type Theory. </title> <publisher> Bibliopolis, </publisher> <year> 1984. </year>
Reference-contexts: The test construct helps reduce the low-level clutter in our definitions by subsuming the usual if...then...else... construct, test for zero, predecessor function, and boolean datatype into a single construct. It is based on Martin-Lof's elimination rule for natural numbers <ref> [23] </ref>. 4 OPERATIONAL SEMANTICS 11 We give special names to certain subsets of TExp and OpenExp. FTV (e) is the set of free type variables in e. FV (e) is the set of free variables in e.
Reference: [24] <author> David B. McDonald, Scott E. Fahlman, and Skef Wholey. </author> <title> Internal design of cmu common lisp on the IBM RT PC. </title> <type> Technical Report CMU-CS-87-157, </type> <institution> Carnegie Mellon University, </institution> <month> April </month> <year> 1988. </year>
Reference-contexts: Many Lisp systems support "fasl" files, which can be used to store arbitrary heap structures. (See <ref> [24] </ref> for a description of a typical fasl format. The idea goes back to 1974, at least.) A mechanism for "pickling" heap structures in Cedar/Mesa was designed and implemented by Rovner and Maxwell, probably in 1982 or 1983.
Reference: [25] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> The MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: In particular, it is not claimed that run time values actually occurring in the evaluation of a well-typed program are tagged with the types that they actually possess. The proof of a soundness result for CLU would probably require techniques similar to those developed in this paper. ML <ref> [16, ?, 25] </ref> and its relatives have shown more resistance to the incorporation of dynamic typing than languages in the Algol family. Probably this is because many of the uses of Dynamic in Algol-like languages are captured in ML by polymorphic types. <p> The formalism extends fairly easily to describing a variety of programming language features like assignment statements and exceptions. This breadth of coverage and "operational style" makes the notation a good one for specifying comparatively rich languages like Standard ML <ref> [25] </ref>. A group at INRIA has built a system for directly interpreting formal specifications written in a similar notation [6, 13, 14]. The rules below define the situations in which the judgement "expression e has type T" is valid under assumptions TE .
Reference: [26] <author> John Mitchell and Gordon Plotkin. </author> <title> Abstract types have existential type. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 10(3), </volume> <month> July </month> <year> 1988. </year>
Reference-contexts: Z ! Nat) typecase de of (W) (e: W) f [W](e) else 0 6 EXTENSIONS 27 end else 0 end 6.2 Abstract Data Types In a similar vein, we can imagine extending the language of type tags to include existentially quantified variables. Following Mitchell and Plotkin <ref> [26] </ref>, we can think of a Dynamic whose tag is an existential type as being a module with hidden implementation, or alternatively as an encapsulated element of an abstract data type. Our notation for existential types and labeled products follows that of Cardelli and Wegner [11].
Reference: [27] <author> Alan Mycroft. </author> <title> Dynamic types in ML. </title> <type> Draft article, </type> <year> 1983. </year>
Reference-contexts: Moreover, until recently ML has not been used for building software systems that deal much with persistent data. Still, there have been various proposals for extending ML with a dynamic type. Gordon seems to have thought of it first [15]; his ideas were later extended by Mycroft <ref> [27] </ref>. The innovation of allowing pattern variables in typecase expressions (see below) seems to originate with Mycroft. (Unfortunately, neither of these proposals were published.) Recent versions of the CAML language [37] include features quite similar to our dynamic and typecase constructs. <p> There are other possible choices here. For instance, we could imagine requiring that the patterns form an "exclusive and exhaustive" covering of the space of type expressions so that a given type tag always matches exactly one pattern <ref> [27] </ref>. <p> One idea to find these domains is to solve the infinite set of simultaneous equations V Nat = N V Dynamic = X V T A similar use of sums appears in Mycroft's work <ref> [27] </ref>. 6 Extensions In this section we present some preliminary thoughts on extending the ideas in the rest of the paper to languages with implicit or explicit polymorphism, abstract data types, and more expressive type patterns. 6.1 Polymorphism For most of the section, we assume an explicitly typed polymorphic lambda calculus <p> Still, we might also want to consider how the dynamic construct might be restricted so that types need not be passed around during execution. A suitable restriction is that an expression dynamic e:T is well-formed only if T is closed. This restriction was proposed by Mycroft <ref> [27] </ref> in the context of an extension of ML, which uses implicit rather than explicit polymorphism.
Reference: [28] <author> Joseph M. Newcomer. </author> <title> Efficient binary I/O of IDL objects. </title> <journal> SIGPLAN Notices, </journal> <volume> 22(11) </volume> <pages> 35-42, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: A variant of their algorithm, due to Lampson, is heavily used in the Modula-2+ programming environment at the DEC Systems Research Center. Another scheme was implemented as part of Tartan Labs' Interface Description Language <ref> [28] </ref>.
Reference: [29] <author> Gordon Plotkin. </author> <title> Call-by-name, call-by-value, and the -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 125-159, </pages> <year> 1975. </year>
Reference-contexts: system based on the one described here, where our explicit dynamic and typecase constructs are replaced by implicit coercions and run time checks. 3 Programming with Dynamic This section introduces the notation used in the rest of the paper|essentially Church's simply typed lambda-calculus [12, 17] with a call-by-value reduction scheme <ref> [29] </ref>, extended with the type Dynamic and the dynamic and typecase constructs. We present a number of example programs to establish the notation and illustrate its expressiveness. Our fundamental constructs are -abstraction, application, conditionals, and arithmetic on natural numbers. <p> applied to f: fix f = f (fix f): In call-by-value lambda-calculi, an extensional version of this property must be used instead: for any argument a, (fix f) a = f (fix f) a One function with this property (a call-by-value version of the standard Y combinator [3, p. 131], <ref> [29] </ref>) can be expressed in an untyped variant of our notation by: fix = f. d d 3 PROGRAMMING WITH DYNAMIC 9 where d = x. z. (f (x x)) z: To see that (fix f) a = f (fix f) a for any function f and argument a, we calculate
Reference: [30] <author> Gordon D. Plotkin. </author> <title> A structural approach to operational semantics. </title> <type> Technical Report DAIMI FN-19, </type> <institution> Computer Science Department, Aarhus University, Aarhus, Denmark, </institution> <year> 1981. </year>
Reference-contexts: ! TypeCode type environments 4 OPERATIONAL SEMANTICS 12 x, y, z variables e expressions v, w canonical expressions (values) X, Y, Z type variables T, U, V, W type expressions substitutions TE type environments 4.2 Typechecking Our notation for describing typechecking and evaluation is a form of "structural operational semantics" <ref> [30] </ref>. The typing and evaluation functions are specified as systems of inference rules; showing that an expression has a given type or reduces to a given value amounts precisely to giving a proof of this fact using the rules.
Reference: [31] <author> John Reynolds. </author> <title> Three approaches to type structure. </title> <booktitle> In Mathematical Foundations of Software Development. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1985. </year> <note> Lecture Notes in Computer Science No. 185. </note>
Reference-contexts: present some preliminary thoughts on extending the ideas in the rest of the paper to languages with implicit or explicit polymorphism, abstract data types, and more expressive type patterns. 6.1 Polymorphism For most of the section, we assume an explicitly typed polymorphic lambda calculus along the lines of Reynolds' system <ref> [31] </ref>. The type abstraction operator is written as fl. Type application is written with square brackets. The types of polymorphic functions begin with 8. For example, 8T.T!T is the type of the polymorphic identity function, flT.x:T. x.
Reference: [32] <author> Paul Rovner. </author> <title> On extending Modula-2 to build large, integrated systems. </title> <journal> IEEE Software, </journal> <volume> 3(6) </volume> <pages> 46-57, </pages> <month> November </month> <year> 1986. </year>
Reference-contexts: It has a type any and a force construct that attempts to coerce an any into an instance of a given type, raising an exception if the coercion is not possible. Cedar/Mesa [19] provides very similar REFANY and TYPECASE. These features of Cedar/Mesa were carried over directly into Modula-2+ <ref> [32] </ref> and Modula-3 [8, 9]. In CLU and Cedar/Mesa, the primary motivation for including a dynamic type was to support programming idioms from LISP. Shaffert and Scheifler gave a formal definition [33] and denotational semantics [34] of CLU, including the type any and the force construct. <p> Readers may enjoy the exercise of defining a similar function that takes two functions as dynamic values and returns their composition as a dynamic value. In contrast to some languages with features similar to Dynamic (for example, Modula-2+ <ref> [32] </ref>), the set of type tags involved in a computation cannot be computed statically: our dynamic expressions can cause the creation of new tags at run time. <p> Simula-67 Rigid Structural Equivalence Modula-3, Cedar Structural Equivalence Amber Pattern variables Our language ? Type matching is simplest in languages like CLU [20] and Modula-2+ <ref> [32] </ref>, where the construct corresponding to our typecase allows only exact matches (no pattern variables), and where equivalence of types is "by name." In Modula-2+, for example, the type tags of dynamic values are just unique identifiers and type matching is a check for equality.
Reference: [33] <author> Justin Craig Schaffert. </author> <title> A formal definition of CLU. </title> <type> Master's thesis, </type> <institution> MIT, </institution> <month> January </month> <year> 1978. </year> <month> MIT/LCS/TR-193. </month>
Reference-contexts: Cedar/Mesa [19] provides very similar REFANY and TYPECASE. These features of Cedar/Mesa were carried over directly into Modula-2+ [32] and Modula-3 [8, 9]. In CLU and Cedar/Mesa, the primary motivation for including a dynamic type was to support programming idioms from LISP. Shaffert and Scheifler gave a formal definition <ref> [33] </ref> and denotational semantics [34] of CLU, including the type any and the force construct. This semantics relies on a domain of run time values where every value is tagged with its compile time type.
Reference: [34] <author> Robert William Scheifler. </author> <title> A denotational semantics of CLU. </title> <type> Master's thesis, </type> <institution> MIT, </institution> <month> May </month> <year> 1978. </year> <month> MIT/LCS/TR-201. </month>
Reference-contexts: These features of Cedar/Mesa were carried over directly into Modula-2+ [32] and Modula-3 [8, 9]. In CLU and Cedar/Mesa, the primary motivation for including a dynamic type was to support programming idioms from LISP. Shaffert and Scheifler gave a formal definition [33] and denotational semantics <ref> [34] </ref> of CLU, including the type any and the force construct. This semantics relies on a domain of run time values where every value is tagged with its compile time type.
Reference: [35] <author> Satish R. Thatte. </author> <title> Quasi-static typing (preliminary report). </title> <booktitle> In Proceedings of the Seventeenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 367-381, </pages> <year> 1990. </year> <note> REFERENCES 35 </note>
Reference-contexts: Dynamically typed objects have also been discussed recently in the database literature as an approach to dealing with persistent data in the context of statically typed database programming languages [1, 2, 10]. Recently, Thatte <ref> [35] </ref> has described a "quasi-static" type system based on the one described here, where our explicit dynamic and typecase constructs are replaced by implicit coercions and run time checks. 3 Programming with Dynamic This section introduces the notation used in the rest of the paper|essentially Church's simply typed lambda-calculus [12, 17]
Reference: [36] <author> Mads Tofte. </author> <title> Operational Semantics and Polymorphic Type Inference. </title> <type> PhD thesis, </type> <institution> Computer Science Department, Edinburgh University, </institution> <year> 1988. </year> <month> CST-52-88. </month>
Reference-contexts: Dynamics with non-generic variables can be used to break the ML type system. (The problem is analogous to that of "updateable refs" <ref> [36] </ref>.) 6.4 Higher-order Pattern Variables By enriching the language of type patterns, it is possible to express a much broader range of computations on Dynamics, including some interesting ones involving polymorphic functions. Our motivating example here is a generalization of the dynamic application function from Section 3.

References-found: 36

