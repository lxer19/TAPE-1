URL: http://www.cs.rpi.edu/~moorthy/MyResearch/Papers/joop.ps
Refering-URL: http://www.cs.rpi.edu/~moorthy/MyResearch/compgt.html
Root-URL: http://www.cs.rpi.edu
Email: gilderm@cs.rpi.edu  moorthy@cs.rpi.edu  
Title: An Object Oriented Intermediate Code Representation for the Development of Parallelization Tools  
Author: Mark R. Gilder Mukkai S. Krishnamoorthy 
Address: Troy, New York 12180  
Affiliation: Rensselaer Polytechnic Institute Department of Computer Science  
Pubnum: (518) 276-4857  (518) 276-6911  
Abstract-found: 0
Intro-found: 1
Reference: <institution> References </institution>
Reference: [1] <author> A. V. Aho and M. Ganapathi. </author> <title> Efficient tree pattern matching: An aid to code generation. </title> <booktitle> In Twelfth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 334-340, </pages> <address> New York, NY, </address> <month> January </month> <year> 1985. </year>
Reference: [2] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers, Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <month> March </month> <year> 1986. </year>
Reference: [3] <author> W. Baxter and H. R. Bauer, III. </author> <title> The program dependence graph and vectorization. </title> <booktitle> In Sixteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-11, </pages> <address> Austin, TX, </address> <month> January </month> <year> 1989. </year>
Reference-contexts: In particular, useful information that can be quickly attained from high-level source code constructs are often lost during the translation to an intermediate representation thereby complicating the design of parallelization tools. More importantly, current compilers do not easily allow the incorporation of newly proposed tools <ref> [3, 4, 5, 10, 13, 16, 21, 24] </ref> for lack of a formal interface in terms of the intermediate representation. Hence, the development of general-purpose parallelization tools becomes an expensive proposition. Current research efforts, such as ParaScope at Rice University [14], PTRAN at IBM T. J.
Reference: [4] <author> M. Burke, R. Cytron, J. Ferrante, and Wilson Hsieh. </author> <title> Automatic generation of nested, fork-join parallelism. </title> <journal> Journal of Supercomputing, </journal> <volume> 2(3) </volume> <pages> 71-88, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: In particular, useful information that can be quickly attained from high-level source code constructs are often lost during the translation to an intermediate representation thereby complicating the design of parallelization tools. More importantly, current compilers do not easily allow the incorporation of newly proposed tools <ref> [3, 4, 5, 10, 13, 16, 21, 24] </ref> for lack of a formal interface in terms of the intermediate representation. Hence, the development of general-purpose parallelization tools becomes an expensive proposition. Current research efforts, such as ParaScope at Rice University [14], PTRAN at IBM T. J.
Reference: [5] <author> K. D. Cooper and K. Kennedy. </author> <title> Fast interprocedural alias analysis. </title> <booktitle> In Sixteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 49-59, </pages> <address> Austin, TX, </address> <month> January </month> <year> 1989. </year>
Reference-contexts: In particular, useful information that can be quickly attained from high-level source code constructs are often lost during the translation to an intermediate representation thereby complicating the design of parallelization tools. More importantly, current compilers do not easily allow the incorporation of newly proposed tools <ref> [3, 4, 5, 10, 13, 16, 21, 24] </ref> for lack of a formal interface in terms of the intermediate representation. Hence, the development of general-purpose parallelization tools becomes an expensive proposition. Current research efforts, such as ParaScope at Rice University [14], PTRAN at IBM T. J.
Reference: [6] <author> R. Duncan. </author> <title> A survey of parallel computer architectures. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 5-16, </pages> <month> February </month> <year> 1990. </year>
Reference: [7] <editor> D. Gelernter, A. Nicolau, and D. Padua. </editor> <booktitle> Languages and Compilers for Parallel Computing. </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1990. </year>
Reference: [8] <author> M. R. Gilder. </author> <title> An object oriented intermediate code representation for an architecturally independent parallelizing compiler. </title> <type> PhD thesis proposal, </type> <institution> Rensselaer Polytechnic Institute, </institution> <month> October </month> <year> 1991. </year>
Reference-contexts: Tools constructed in this manner are inherently simpler since they can manipulate the representation at a much higher level of abstraction. Other tools constructed using this approach are described in <ref> [8, 9] </ref>. The object oriented approach employed clearly has its advantages over traditional approaches. The HDA algorithm, as we described in Section 3, makes no distinction between interproce-dural and intraprocedural analysis.
Reference: [9] <author> M. R. Gilder. </author> <title> An Object Oriented Intermediate Code Representation For An Architecturally Independent Parallelizing Compiler. </title> <type> PhD thesis, </type> <institution> Rensselaer Polytechnic Institute, </institution> <address> Troy, NY, </address> <year> 1993. </year> <note> In preparation. </note>
Reference-contexts: The filter systemati 2 1 INTRODUCTION cally manipulates the HICOR instance according to the constraints specified by the Target Architectural Description. The output of the system is an execution DAG (directed acyclic graph) appropriate for the specified target architecture. Using this DAG machine specific target code may be generated <ref> [9] </ref>. Current target architectures include the Sequent Balance 21, the Ardent Titan, and the IBM ESA/390. The system was implemented on a SPARC-station 2 and was written in C++. <p> For example, to generate Sun 630 MP/4 code for the MinMax () function, we simply invoke the GenCode () method on object 64 with the appropriate architecture specifier object. The details of the architecture specifier object may be found in <ref> [9] </ref>. Our purpose here is to demonstrate the simplicity of using an object oriented approach to design compilation tools. <p> Tools constructed in this manner are inherently simpler since they can manipulate the representation at a much higher level of abstraction. Other tools constructed using this approach are described in <ref> [8, 9] </ref>. The object oriented approach employed clearly has its advantages over traditional approaches. The HDA algorithm, as we described in Section 3, makes no distinction between interproce-dural and intraprocedural analysis.
Reference: [10] <author> M. Girkar and C. Polychronopoulos. </author> <title> Compiling issues for supercomputers. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 164-173, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: In particular, useful information that can be quickly attained from high-level source code constructs are often lost during the translation to an intermediate representation thereby complicating the design of parallelization tools. More importantly, current compilers do not easily allow the incorporation of newly proposed tools <ref> [3, 4, 5, 10, 13, 16, 21, 24] </ref> for lack of a formal interface in terms of the intermediate representation. Hence, the development of general-purpose parallelization tools becomes an expensive proposition. Current research efforts, such as ParaScope at Rice University [14], PTRAN at IBM T. J.
Reference: [11] <author> G. Goff, K. Kennedy, and C. Tseng. </author> <title> Practical dependence testing. </title> <booktitle> In Proc. of the SIGPLAN '91 Conf. on Programming Language Design and Implementation, </booktitle> <volume> volume 26, </volume> <pages> pages 15-29, </pages> <month> June </month> <year> 1991. </year>
Reference: [12] <author> M. Harrold and M. Soffa. </author> <title> Computation of interprocedural definition and use dependencies. </title> <booktitle> In Proc. 1990 IEEE Int. Conf. on Computing Languages, </booktitle> <pages> pages 297-306, </pages> <address> New Orleans, </address> <month> March </month> <year> 1990. </year> <note> REFERENCES 19 </note>
Reference: [13] <author> S. Horwitz, T. Reps, and D. Binkley. </author> <title> Interprocedural slicing using dependence graphs. </title> <booktitle> In Proceedings of the ACM SIGPLAN 88 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1988. </year>
Reference-contexts: In particular, useful information that can be quickly attained from high-level source code constructs are often lost during the translation to an intermediate representation thereby complicating the design of parallelization tools. More importantly, current compilers do not easily allow the incorporation of newly proposed tools <ref> [3, 4, 5, 10, 13, 16, 21, 24] </ref> for lack of a formal interface in terms of the intermediate representation. Hence, the development of general-purpose parallelization tools becomes an expensive proposition. Current research efforts, such as ParaScope at Rice University [14], PTRAN at IBM T. J.
Reference: [14] <author> K. Kennedy, K. S. Mckinley, and C. W. Tseng. </author> <title> Interactive parallel programming using the parascope editor. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 2(3) </volume> <pages> 329-341, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: Hence, the development of general-purpose parallelization tools becomes an expensive proposition. Current research efforts, such as ParaScope at Rice University <ref> [14] </ref>, PTRAN at IBM T. J. Watson Research Center [23], and the Typhoon parallelizing compiler project at Cornell University [18], address this issue but are with respect to a single programming language and are not explicitly based on object oriented principles.
Reference: [15] <author> D. Kuck, R. Kuhn, D. Padua, B. Leasure, and M. Wolfe. </author> <title> Dependence graphs and compiler optimizations. </title> <booktitle> In Eighth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 207-218, </pages> <month> January </month> <year> 1981. </year>
Reference: [16] <author> C. McCreary and H. Gill. </author> <title> Automatic determination of grain size for efficient parallel processing. </title> <journal> Communications of the ACM, </journal> <volume> 32(9) </volume> <pages> 1073-1078, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: In particular, useful information that can be quickly attained from high-level source code constructs are often lost during the translation to an intermediate representation thereby complicating the design of parallelization tools. More importantly, current compilers do not easily allow the incorporation of newly proposed tools <ref> [3, 4, 5, 10, 13, 16, 21, 24] </ref> for lack of a formal interface in terms of the intermediate representation. Hence, the development of general-purpose parallelization tools becomes an expensive proposition. Current research efforts, such as ParaScope at Rice University [14], PTRAN at IBM T. J.
Reference: [17] <author> D. Padua and M. Wolfe. </author> <title> Advanced compiler optimizations for supercomputers. </title> <journal> Communications of the ACM, </journal> <volume> 29(12) </volume> <pages> 1184-1201, </pages> <month> December </month> <year> 1986. </year>
Reference: [18] <author> K. Pingali, M. Beck, R. Johnson, M. Moudgill, and P. Stodghill. </author> <title> Dependence flow graphs: An algebraic approach to program dependencies. </title> <type> Technical Report TR 90-1152, </type> <institution> Cornell University, </institution> <month> September </month> <year> 1990. </year>
Reference-contexts: Hence, the development of general-purpose parallelization tools becomes an expensive proposition. Current research efforts, such as ParaScope at Rice University [14], PTRAN at IBM T. J. Watson Research Center [23], and the Typhoon parallelizing compiler project at Cornell University <ref> [18] </ref>, address this issue but are with respect to a single programming language and are not explicitly based on object oriented principles. In this paper, we present another approach to accomplishing this for multiple source languages and multiple target architectures.
Reference: [19] <author> C. D. Polychronopoulos. </author> <title> Parallel Programming and Compilers. </title> <publisher> Kluwer Academic, </publisher> <address> Boston, MA, </address> <year> 1988. </year>
Reference-contexts: The Hierarchical Dependency Analyzer presented in Section 3 computes a DAG (directed acyclic graph) object representing data dependencies for any set of HICOR objects. Once constructed the estimated speedup may be calculated <ref> [19, 22] </ref>. If acceptable, the DAG object would be responsible for generating the target code. Since each HICOR object represented by the DAG is responsible for its own code generation, the DAG object need only generate the necessary control structures needed to create each of the logical processes.
Reference: [20] <author> J. R. Punin, M. R. Gilder, and M. S. Krishnamoorthy. </author> <title> A GUI for parallel code generation. </title> <booktitle> In progress. </booktitle>
Reference-contexts: The system is open-ended and interfaces nicely to other packages which either produce C, Pascal, or Fortran as output; or accept C as input. Furthermore, a GUI has been developed for the system which provides the user with a visual representation of the parallelizations performed <ref> [20] </ref>. The remainder of this paper is organized as follows: Section 2 describes the HICOR intermediate representation; Section 3 describes the implementation of the Hierarchical Dependency Analyzer; and in Section 4 we conclude with an evaluation of the object oriented approach, as presented, to construct compiler tools.
Reference: [21] <author> S. Richardson and M. Ganapathi. </author> <title> Code optimization across procedures. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 42-50, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: In particular, useful information that can be quickly attained from high-level source code constructs are often lost during the translation to an intermediate representation thereby complicating the design of parallelization tools. More importantly, current compilers do not easily allow the incorporation of newly proposed tools <ref> [3, 4, 5, 10, 13, 16, 21, 24] </ref> for lack of a formal interface in terms of the intermediate representation. Hence, the development of general-purpose parallelization tools becomes an expensive proposition. Current research efforts, such as ParaScope at Rice University [14], PTRAN at IBM T. J.
Reference: [22] <author> V. Sarkar. </author> <title> Partitioning and Scheduling Parallel Programs for Multiprocessors. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1989. </year>
Reference-contexts: The Hierarchical Dependency Analyzer presented in Section 3 computes a DAG (directed acyclic graph) object representing data dependencies for any set of HICOR objects. Once constructed the estimated speedup may be calculated <ref> [19, 22] </ref>. If acceptable, the DAG object would be responsible for generating the target code. Since each HICOR object represented by the DAG is responsible for its own code generation, the DAG object need only generate the necessary control structures needed to create each of the logical processes.
Reference: [23] <author> B. K. Szymanski. </author> <title> Parallel Functional Languages and Compilers. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1991. </year>
Reference-contexts: Hence, the development of general-purpose parallelization tools becomes an expensive proposition. Current research efforts, such as ParaScope at Rice University [14], PTRAN at IBM T. J. Watson Research Center <ref> [23] </ref>, and the Typhoon parallelizing compiler project at Cornell University [18], address this issue but are with respect to a single programming language and are not explicitly based on object oriented principles. In this paper, we present another approach to accomplishing this for multiple source languages and multiple target architectures.
Reference: [24] <author> Y. Tanaka, K. Iwasawa, S. Gotoo, and Yukio Umetani. </author> <title> Compiling techniques for first-order linear recurrences on a vector computer. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 174-181, </pages> <month> Septem-ber </month> <year> 1988. </year>
Reference-contexts: In particular, useful information that can be quickly attained from high-level source code constructs are often lost during the translation to an intermediate representation thereby complicating the design of parallelization tools. More importantly, current compilers do not easily allow the incorporation of newly proposed tools <ref> [3, 4, 5, 10, 13, 16, 21, 24] </ref> for lack of a formal interface in terms of the intermediate representation. Hence, the development of general-purpose parallelization tools becomes an expensive proposition. Current research efforts, such as ParaScope at Rice University [14], PTRAN at IBM T. J.
Reference: [25] <author> A. E. Terrano, S. M. Dunn, and J. E. Peters. </author> <title> Using an architectural knowledge base to generate code for parallel computers. </title> <journal> Communications of the ACM, </journal> <volume> 32(9) </volume> <pages> 1065-1072, </pages> <month> September </month> <year> 1989. </year>
References-found: 26

