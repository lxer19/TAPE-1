URL: http://www.md.chalmers.se/~rjmh/Papers/whyfp.ps
Refering-URL: http://www.cms.dmu.ac.uk/~se96sb/softeng/softeng.html
Root-URL: 
Email: rjmh@cs.chalmers.se  
Title: Why Functional Programming Matters  
Author: John Hughes, Institutionen for Datavetenskap, 
Address: 41296 Goteborg, SWEDEN.  
Affiliation: Chalmers Tekniska Hogskola,  
Abstract: As software becomes more and more complex, it is more and more important to structure it well. Well-structured software is easy to write, easy to debug, and provides a collection of modules that can be re-used to reduce future programming costs. Conventional languages place conceptual limits on the way problems can be modularised. Functional languages push those limits back. In this paper we show that two features of functional languages in particular, higher-order functions and lazy evaluation, can contribute greatly to modularity. As examples, we manipulate lists and trees, program several numerical algorithms, and implement the alpha-beta heuristic (an algorithm from Artificial Intelligence used in game-playing programs). Since modularity is the key to successful programming, functional languages are vitally important to the real world.
Abstract-found: 1
Intro-found: 1
Reference: [AS86] <author> H. Abelson and G.J. Sussman. </author> <title> Structure and Interpretation of Computer Programs. </title> <publisher> MIT Press, </publisher> <address> Boston, </address> <year> 1986. </year>
Reference-contexts: For example, Turner shows how both can be used to great advantage in a program for generating chemical structures [Tur81]. Abelson and Sussman stress that streams (lazy lists) are a powerful tool for structuring programs <ref> [AS86] </ref>. Henderson has used streams to structure functional operating systems [P.H82]. The main contribution of this paper is to assert that better modularity alone is the key to the power of functional languages. It is also relevant to the present controversy over lazy evaluation. <p> It is also relevant to the present controversy over lazy evaluation. Some believe that functional languages should be lazy, others believe they should not. Some compromise and provide only lazy lists, with a special syntax for constructing them (as, for example, in SCHEME <ref> [AS86] </ref>). This paper provides further evidence that lazy evaluation is too important to be relegated to second-class citizenship. It is perhaps the most powerful glue functional programmers possess.
Reference: [Hug89] <author> J. Hughes. </author> <title> Why Functional Programming Matters. </title> <journal> Computer Journal, </journal> <volume> 32(2), </volume> <year> 1989. </year>
Reference-contexts: It says a lot about what functional programming is not (it has no fl This paper dates from 1984, and circulated as a Chalmers memo for many years. Slightly revised versions appeared in 1989 and 1990 as [Hug90] and <ref> [Hug89] </ref>. This version is based on the original Chalmers memo nroff source, lightly edited for LaTeX and to bring it closer to the published versions, and with one or two errors corrected.
Reference: [Hug90] <author> John Hughes. </author> <title> Why Functional Programming Matters. </title> <editor> In D. Turner, editor, </editor> <booktitle> Research Topics in Functional Programming. </booktitle> <publisher> Addison Wesley, </publisher> <year> 1990. </year>
Reference-contexts: It says a lot about what functional programming is not (it has no fl This paper dates from 1984, and circulated as a Chalmers memo for many years. Slightly revised versions appeared in 1989 and 1990 as <ref> [Hug90] </ref> and [Hug89]. This version is based on the original Chalmers memo nroff source, lightly edited for LaTeX and to bring it closer to the published versions, and with one or two errors corrected.
Reference: [MTH90] <author> R. Milner, M. Tofte, and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Thus one can enjoy the benefits of structured programming in FORTRAN or assembly language, even if it is a little more work. It is now generally accepted that modular design is the key to successful programming, and languages such as Modula-II [Wir82], Ada [oD80] and Standard ML <ref> [MTH90] </ref> include features specifically designed to help improve modularity. However, there is a very important point that is often missed. When writing a modular program to solve a problem, one first divides the problem into sub-problems, then solves the sub-problems and combines the solutions.
Reference: [oD80] <author> United States Department of Defense. </author> <title> The Programming Language Ada Reference Manual. </title> <publisher> Springer-Verlag, </publisher> <year> 1980. </year>
Reference-contexts: Thus one can enjoy the benefits of structured programming in FORTRAN or assembly language, even if it is a little more work. It is now generally accepted that modular design is the key to successful programming, and languages such as Modula-II [Wir82], Ada <ref> [oD80] </ref> and Standard ML [MTH90] include features specifically designed to help improve modularity. However, there is a very important point that is often missed. When writing a modular program to solve a problem, one first divides the problem into sub-problems, then solves the sub-problems and combines the solutions.
Reference: [P.H82] <author> P.Henderson. </author> <title> Purely Functional Operating Systems. </title> <year> 1982. </year>
Reference-contexts: For example, Turner shows how both can be used to great advantage in a program for generating chemical structures [Tur81]. Abelson and Sussman stress that streams (lazy lists) are a powerful tool for structuring programs [AS86]. Henderson has used streams to structure functional operating systems <ref> [P.H82] </ref>. The main contribution of this paper is to assert that better modularity alone is the key to the power of functional languages. It is also relevant to the present controversy over lazy evaluation. Some believe that functional languages should be lazy, others believe they should not.
Reference: [Tur81] <author> D. A. Turner. </author> <title> The Semantic Elegance of Applicative Languages. </title> <booktitle> In Proceedings 1981 Conference on Functional Languages and Computer Architecture, </booktitle> <address> Wentworth-by-the-Sea, Portsmouth, New Hampshire, </address> <year> 1981. </year>
Reference-contexts: Of course, we are not the first to point out the power and elegance of higher-order functions and lazy evaluation. For example, Turner shows how both can be used to great advantage in a program for generating chemical structures <ref> [Tur81] </ref>. Abelson and Sussman stress that streams (lazy lists) are a powerful tool for structuring programs [AS86]. Henderson has used streams to structure functional operating systems [P.H82]. The main contribution of this paper is to assert that better modularity alone is the key to the power of functional languages.
Reference: [Tur85] <author> D. A. Turner. Miranda: </author> <title> A non-strict language with polymorphic types. </title> <booktitle> In Proceedings 1985 Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 1-16, </pages> <address> Nancy, France, </address> <year> 1985. </year>
Reference-contexts: These functions are much like ordinary mathematical functions, and in this paper will be defined by ordinary equations. Our notation follows Turner's language Miranda (TM) <ref> [Tur85] </ref>, but should be readable with no prior knowledge of functional languages. (Miranda is a trademark of Research Software Ltd.) The special characteristics and advantages of functional programming are often summed up more or less as follows.
Reference: [Wir82] <author> N. Wirth. </author> <title> Programming in Modula-II. </title> <publisher> Springer-Verlag, </publisher> <year> 1982. </year> <month> 18 </month>
Reference-contexts: Thus one can enjoy the benefits of structured programming in FORTRAN or assembly language, even if it is a little more work. It is now generally accepted that modular design is the key to successful programming, and languages such as Modula-II <ref> [Wir82] </ref>, Ada [oD80] and Standard ML [MTH90] include features specifically designed to help improve modularity. However, there is a very important point that is often missed. When writing a modular program to solve a problem, one first divides the problem into sub-problems, then solves the sub-problems and combines the solutions.
References-found: 9

