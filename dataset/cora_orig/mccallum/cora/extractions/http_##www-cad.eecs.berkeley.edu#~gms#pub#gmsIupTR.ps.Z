URL: http://www-cad.eecs.berkeley.edu/~gms/pub/gmsIupTR.ps.Z
Refering-URL: http://www-cad.eecs.berkeley.edu:80/~gms/projects/research.html
Root-URL: 
Email: fsedwards,gms,braytong@eecs.berkeley.edu  
Title: Identifying Common Substructure for Incremental Methods  
Author: Stephen A. Edwards Gitanjali M. Swamy Robert K. Brayton 
Date: May 6, 1996  
Address: Berkeley, CA 94720  
Affiliation: Department of Electrical Engineering and Computer Sciences University of California,  
Abstract: In this paper we solve the problem of identifying a matching between two logic circuits or networks. A matching is a functions that maps each gate or node in the new circuit into one in the old circuit (if a matching does not exist it maps it to null). We present both an exact and a heuristic way to solve the maximal matching problem. The matching problem does not require any input correspondences; the purpose is to identify structurally identical regions in the networks. We apply this solution to the problem of incremental design. Logic design is usually an iterative process where errors are corrected and optimizations performed repeatedly. A designer rectifies, re-optimizes, and rechecks a design many times. In practice, it is common for small, incremental changes to be made to the design, rather than changing the entirety of the design. Currently, each time the system is modified, the entire set of computations (synthesis,verification) are repeated from the beginning. This results in unneces 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. Touati, H. Savoj, B. Lin, R. K. Brayton, and A. L. Sangiovanni-Vincentelli, </author> <title> Implicit State Enumeration of Finite State Machines using BDD's, </title> <booktitle> in Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pp. 130-133, </pages> <month> Nov. </month> <year> 1990. </year>
Reference-contexts: We choose to identify these because the global function at a node is a function only of its transitive fanin. An example is the transition function <ref> [1] </ref>, used frequently in formal verification and usually computed using BDDs [2]. Identifying matching nodes 3 allows us to compute the new BDD by substituting variables, which can be done ef-ficiently. Our approach does not require any additional matching information (e.g., correspondences between the primary inputs). <p> Thus, if at some iteration, any nodes in the same bucket have corresponding fanins in different buckets, then after that iteration, this nodes get put into different buckets. This algorithm is similar to the algorithm for the computation of equivalent states in an FSM [10], <ref> [1] </ref>. After this refinement, all pairs of nodes in a bucket are candidates. The algorithm is shown in Figure 9. Though we have described a procedure that matches entire cones, this procedure can be modified to match sub-regions by restricting the number of iterations of the refinement procedure.
Reference: [2] <author> R. Bryant, </author> <title> Graph-based Algorithms for Boolean Function Manipulation, </title> <journal> IEEE Trans. Computers, </journal> <volume> vol. C-35, </volume> <pages> pp. 677-691, </pages> <month> Aug. </month> <year> 1986. </year>
Reference-contexts: We choose to identify these because the global function at a node is a function only of its transitive fanin. An example is the transition function [1], used frequently in formal verification and usually computed using BDDs <ref> [2] </ref>. Identifying matching nodes 3 allows us to compute the new BDD by substituting variables, which can be done ef-ficiently. Our approach does not require any additional matching information (e.g., correspondences between the primary inputs).
Reference: [3] <author> D. Brand, </author> <title> Incremental Synthesis, </title> <booktitle> in Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pp. 126-129, </pages> <month> Nov. </month> <year> 1992. </year>
Reference-contexts: Section 5 describes the results of some experiments on the algorithms and presents our conclusions. 2 Previous Work Other approaches to incremental synthesis rely on knowing input correspondences. Brand et al.'s <ref> [3, 4] </ref> work on incremental synthesis identifies regions of commonality similar to our own, but they require knowledge of input correspondences and 4 can only detect regions that start at the inputs. Burch et al. [5] solve a functional matching problem that does not require input correspondence information.
Reference: [4] <author> D. Brand, A. Drumm, S. Kundu, and P. Narain, </author> <title> Incremental Synthesis, </title> <booktitle> in Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pp. 14-18, </pages> <month> Nov. </month> <year> 1994. </year> <month> 21 </month>
Reference-contexts: Section 5 describes the results of some experiments on the algorithms and presents our conclusions. 2 Previous Work Other approaches to incremental synthesis rely on knowing input correspondences. Brand et al.'s <ref> [3, 4] </ref> work on incremental synthesis identifies regions of commonality similar to our own, but they require knowledge of input correspondences and 4 can only detect regions that start at the inputs. Burch et al. [5] solve a functional matching problem that does not require input correspondence information.
Reference: [5] <author> J. Burch and D. </author> <title> Long, Efficient boolean function matching, </title> <booktitle> in Proceedings of IEEE/ACM International Conference on Computer-Aided Design, </booktitle> <pages> pp. 408-411, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: Brand et al.'s [3, 4] work on incremental synthesis identifies regions of commonality similar to our own, but they require knowledge of input correspondences and 4 can only detect regions that start at the inputs. Burch et al. <ref> [5] </ref> solve a functional matching problem that does not require input correspondence information. However, they are only comparing boolean functions, and their approach does not generalize to circuit designs.
Reference: [6] <author> R. K. Brayton, M. Chiodo, R. Hojati, T. Kam, K. Kodandapani, R. P. Kur-shan, S. Malik, A. L. Sangiovanni-Vincentelli, E. M. Sentovich, T. Shiple, K. J. Singh, and H.-Y. Wang, BLIF-MV: </author> <title> An Interchange Format for Design Verification and Synthesis, </title> <type> Tech. Rep. </type> <institution> UCB/ERL M91/97, Electronics Research Lab, Univ. of California, Berkeley, </institution> <address> CA 94720, </address> <month> Nov. </month> <year> 1991. </year>
Reference-contexts: However, they are only comparing boolean functions, and their approach does not generalize to circuit designs. We adopt a similar notion of a semi-canonical form, but our form is simpler (and hence faster) at the expense of some precision. Also, we deal with more general multi-valued functions <ref> [6] </ref>, rather than just binary. The techniques presented here can be used to drive the incremental verification algorithms of Swamy et a.l [7] [8] and Sokolosky et al. [9]. <p> These use information about the similarities between two designs to speed up the verification process. 3 Table Matching The nodes in our networks have discrete-valued functions (a generalization of boolean functions) associated with them. These are represented in BLIF-MV-style tables <ref> [6] </ref>, such as that in Figure 1. Each column on the left represents an input variable, and each row is a pattern that, when the inputs match it, produces the output in the rightmost column.
Reference: [7] <author> G. M. Swamy and R. K. Brayton, </author> <title> Incremental Formal Design Verification, </title> <booktitle> in Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pp. 458-465, </pages> <month> Nov. </month> <year> 1994. </year>
Reference-contexts: Also, we deal with more general multi-valued functions [6], rather than just binary. The techniques presented here can be used to drive the incremental verification algorithms of Swamy et a.l <ref> [7] </ref> [8] and Sokolosky et al. [9]. These use information about the similarities between two designs to speed up the verification process. 3 Table Matching The nodes in our networks have discrete-valued functions (a generalization of boolean functions) associated with them.
Reference: [8] <author> G. M. Swamy, V. Singhal, and R. K. Brayton, </author> <title> Incremental methods for Fsm Traversal, </title> <booktitle> in Proc. Intl. Conf. on Computer Design, </booktitle> <pages> pp. 590-595, </pages> <month> Oct. </month> <year> 1995. </year>
Reference-contexts: Also, we deal with more general multi-valued functions [6], rather than just binary. The techniques presented here can be used to drive the incremental verification algorithms of Swamy et a.l [7] <ref> [8] </ref> and Sokolosky et al. [9]. These use information about the similarities between two designs to speed up the verification process. 3 Table Matching The nodes in our networks have discrete-valued functions (a generalization of boolean functions) associated with them.
Reference: [9] <author> O. Sokolosky and S. Smolka, </author> <title> Incremental Model-Checking in Modal Mu-Calculus, </title> <booktitle> in Proc. of the Conf. on Computer-Aided Verification, </booktitle> <volume> vol. 818, </volume> <pages> pp. 351-363, </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1994. </year>
Reference-contexts: Also, we deal with more general multi-valued functions [6], rather than just binary. The techniques presented here can be used to drive the incremental verification algorithms of Swamy et a.l [7] [8] and Sokolosky et al. <ref> [9] </ref>. These use information about the similarities between two designs to speed up the verification process. 3 Table Matching The nodes in our networks have discrete-valued functions (a generalization of boolean functions) associated with them. These are represented in BLIF-MV-style tables [6], such as that in Figure 1.
Reference: [10] <author> J. Hopcroft, </author> <title> An n log n algorithm for minimizing states in a finite automaton, in Theory of Machines and Computations. </title> <booktitle> Proceedings of an International Symposium on the Theory of Machines and Computations. </booktitle> <editor> (Z. Kohavi and A. Paz, eds.), (Haifa, </editor> <booktitle> Isreal), </booktitle> <pages> pp. 189-196, </pages> <publisher> Academic Press, </publisher> <year> 1971. </year>
Reference-contexts: Thus, if at some iteration, any nodes in the same bucket have corresponding fanins in different buckets, then after that iteration, this nodes get put into different buckets. This algorithm is similar to the algorithm for the computation of equivalent states in an FSM <ref> [10] </ref>, [1]. After this refinement, all pairs of nodes in a bucket are candidates. The algorithm is shown in Figure 9. Though we have described a procedure that matches entire cones, this procedure can be modified to match sub-regions by restricting the number of iterations of the refinement procedure.
Reference: [11] <author> T. Kam, T. Villa, R. Brayton, and A. Sangiovanni-Vincentelli, </author> <title> A Fully Implicit Algorithm for Exact State Minimization, </title> <booktitle> in Proc. of the Design Automation Conf., </booktitle> <pages> pp. 684-690, </pages> <month> June </month> <year> 1994. </year> <month> 22 </month>
Reference-contexts: Proof Follows from the definition of matching, implied matching, and Lemmas 4.2 and 4.3. We can define a dominance relation <ref> [11] </ref> [12] as follows: Definition 14 A matching M 1 dominates a matching M 2 (written M 1 M 2 ) if M 1 * ) M 2 and M 1 + M 2 = M 1 .
Reference: [12] <author> G. M. Swamy, P. Mcgeer, and R. K. Brayton, </author> <title> An Exact Logic minimizer us-ing BDD based Methods , Tech. </title> <type> Rep. </type> <institution> UCB/ERL M92/127, Electronics Research Lab, Univ. of California, Berkeley, </institution> <address> CA 94720, </address> <year> 1992. </year>
Reference-contexts: Proof Follows from the definition of matching, implied matching, and Lemmas 4.2 and 4.3. We can define a dominance relation [11] <ref> [12] </ref> as follows: Definition 14 A matching M 1 dominates a matching M 2 (written M 1 M 2 ) if M 1 * ) M 2 and M 1 + M 2 = M 1 .
Reference: [13] <author> E. J. McClusky, </author> <title> Minimization of Boolean Functions, </title> <journal> Bell System Technical Journal, </journal> <volume> vol. 35, </volume> <year> 1956. </year>
Reference-contexts: We can do this naively by enumerating each prime matching and calculating its quality (in actuality, we implement a slightly more efficient procedure). However, since the number of primes of a set of n elements is O (3 n =n) <ref> [13] </ref> and our n can be O (N 2 ), where N is the number of nodes in each network, it is often impractical to explicitly search the entire set of primes.
Reference: [14] <author> R. K. Brayton et al., </author> <title> VIS: A System for Verification and Synthesis, </title> <booktitle> in Proc. of the Conf. on Computer-Aided Verification, </booktitle> <pages> pp. 332-334, </pages> <year> 1996. </year>
Reference-contexts: in each bucket Sort the candidate pairs by the number of nodes in their transitive fanin M (n) = f, the empty matching for M i largest to M i smallest if M * ) M i return M 5 Results We have implemented the algorithms described in the VIS <ref> [14] </ref> environment. We had to design a set of experiments to test our procedure. We assume that the design has been read in, and the designer has computed the output function BDDs of each node (as functions of the primary inputs).
Reference: [15] <author> E. M. Sentovich, K. J. Singh, C. Moon, H. Savoj, R. K. Brayton, and A. L. Sangiovanni-Vincentelli, </author> <title> Sequential Circuit Design Using Synthesis and Optimization, </title> <booktitle> in Proc. Intl. Conf. on Computer Design, </booktitle> <pages> pp. 328-333, </pages> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: Obviously, we assume that there is a sufficient amount of structural similarity between the old and the network design. To emulate a design change, we took MCNC and ISCAS benchmark examples and optimized them using a synthesis algorithm (script.delay in the SIS <ref> [15] </ref> system), to obtain a circuit called new. The original benchmark spec corresponds to the old design.
Reference: [16] <author> S. Malik, J. Mohnke, and P. Molitor, </author> <title> Limits of Using Signatures for Permutation Indepedant Boolean Matching, </title> <booktitle> in Proc. Intl. Workshop on Logic Synthesis, </booktitle> <address> (Tahoe), </address> <month> May </month> <year> 1995. </year> <month> 23 </month>
Reference-contexts: There were many possible matchings, and examining them all, while determining the qualities of matchings was expensive. As part of future work, we plan to use the work of Malik <ref> [16] </ref> to detect symmetries and speed up our computation. We found that as we increased the size of the example, the matching time increased significantly. This is due to our explicit formulation of the matching algorithm.
References-found: 16

