URL: file://ftp.cis.ohio-state.edu/pub/tech-report/1996/TR37.ps.gz
Refering-URL: ftp://ftp.cis.ohio-state.edu/pub/tech-report/TRList.html
Root-URL: 
Title: Multitolerance (Extended Abstract)  
Author: Anish Arora Sandeep S. Kulkarni 
Keyword: multiple fault-tolerances, design methods, detectors, correctors, interference-freedom, distributed systems software  
Address: Columbus, Ohio 43210 USA  
Affiliation: Department of Computer and Information Science 1 The Ohio State University  
Abstract: Multitolerance refers to the ability of a system to tolerate multiple classes of faults, each in a possibly different way. Achieving this ability is essential, not only because increasingly systems are subject to multiple classes of faults, but because designing a uniform type of tolerance to all their fault-classes is often inappropriate or inefficient. In this paper, we give a formal definition of what it means for a system to be multitolerant and we propose a method for the design of multitolerant systems. Our method simplifies the design task by proceeding in a stepwise fashion: In each step, tolerance to a new fault-class is added while preserving tolerance to the previously added classes. Each tolerance is added in terms of detectors and/or correctors. A simple theory is exploited to ensure mutual interference-freedom among the detectors, correctors, and underlying system. We demonstrate the method by designing novel, fully distributed, multitolerant programs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Siewiorek, C. Bell, and A. Newell. </author> <title> Reliable Computer Systems: Design and Evaluation, chapter 8. </title> <publisher> Digital Press, </publisher> <year> 1992. </year>
Reference-contexts: To tolerate severe voltage fluctuations, the current source is disconnected, by using, say, a safety device. Thus, the circuit tolerates mild fluctuations by masking them and tolerates severe fluctuations by failing safely in their presence. As another example, consider the ESS electronic switches developed by Bell Laboratories <ref> [1, 2] </ref>. These switches ensure that, in the presence of mild faults, no calls are lost. And, in the presence of a moderately severe fault, no calls in progress are lost but the calls being established may be lost. <p> Thus, the news service offers different qualities of service in the presence of different fault-classes. Although there are several examples of multitolerant systems in practice and there exists a growing body of research that presents instances of multitolerant computing systems <ref> [1, 2, 3, 4, 5, 6, 7, 8] </ref>, we are aware of little work that has considered the systematic design and analysis of multitolerance. Towards redressing this deficiency, we present in this paper a formal definition of multitolerance and a method for its design.
Reference: [2] <author> J. J. Kulzer. </author> <title> Systems reliability: A case study of number 4 ESS. System Security and Reliability, Infotech State of the Art Report, </title> <booktitle> pages 1.5-188, </booktitle> <year> 1977. </year>
Reference-contexts: To tolerate severe voltage fluctuations, the current source is disconnected, by using, say, a safety device. Thus, the circuit tolerates mild fluctuations by masking them and tolerates severe fluctuations by failing safely in their presence. As another example, consider the ESS electronic switches developed by Bell Laboratories <ref> [1, 2] </ref>. These switches ensure that, in the presence of mild faults, no calls are lost. And, in the presence of a moderately severe fault, no calls in progress are lost but the calls being established may be lost. <p> Thus, the news service offers different qualities of service in the presence of different fault-classes. Although there are several examples of multitolerant systems in practice and there exists a growing body of research that presents instances of multitolerant computing systems <ref> [1, 2, 3, 4, 5, 6, 7, 8] </ref>, we are aware of little work that has considered the systematic design and analysis of multitolerance. Towards redressing this deficiency, we present in this paper a formal definition of multitolerance and a method for its design.
Reference: [3] <author> F. B. Bastani, I.-L. Yen, and I.-R. Chen. </author> <title> A class of inherently fault-tolerant distributed programs. </title> <journal> IEEE Transactions on Software Engg., </journal> <volume> 14(10) </volume> <pages> 1431-1442, </pages> <year> 1988. </year>
Reference-contexts: Thus, the news service offers different qualities of service in the presence of different fault-classes. Although there are several examples of multitolerant systems in practice and there exists a growing body of research that presents instances of multitolerant computing systems <ref> [1, 2, 3, 4, 5, 6, 7, 8] </ref>, we are aware of little work that has considered the systematic design and analysis of multitolerance. Towards redressing this deficiency, we present in this paper a formal definition of multitolerance and a method for its design.
Reference: [4] <author> A. Arora. </author> <title> A Foundation of Fault-Tolerant Computing. </title> <type> PhD thesis, </type> <institution> The University of Texas at Austin, </institution> <year> 1992. </year>
Reference-contexts: Thus, the news service offers different qualities of service in the presence of different fault-classes. Although there are several examples of multitolerant systems in practice and there exists a growing body of research that presents instances of multitolerant computing systems <ref> [1, 2, 3, 4, 5, 6, 7, 8] </ref>, we are aware of little work that has considered the systematic design and analysis of multitolerance. Towards redressing this deficiency, we present in this paper a formal definition of multitolerance and a method for its design. <p> The reader may well ask whether permanent and intermittent faults, which apparently affect actions as opposed to variables, can be represented as state perturbations. It turns out that they can, with the addition of auxiliary variables <ref> [4, 9] </ref>. For example, consider a Byzantine fault that affects a process j: Let good:j be an auxiliary boolean variable that is true when j executes its actions in the absence of the fault.
Reference: [5] <author> A. Gopal and K. Perry. </author> <title> Unifying self-stabilization and fault-tolerance. </title> <booktitle> Proceedings of the Twelfth Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 1.5-206, </pages> <year> 1993. </year>
Reference-contexts: Thus, the news service offers different qualities of service in the presence of different fault-classes. Although there are several examples of multitolerant systems in practice and there exists a growing body of research that presents instances of multitolerant computing systems <ref> [1, 2, 3, 4, 5, 6, 7, 8] </ref>, we are aware of little work that has considered the systematic design and analysis of multitolerance. Towards redressing this deficiency, we present in this paper a formal definition of multitolerance and a method for its design.
Reference: [6] <author> S. Dolev and T. Herman. </author> <title> Superstabilizing protocols for dynamic distributed systems. </title> <booktitle> Proceedings of the Second Workshop on Self-Stabilizing Systems, </booktitle> <year> 1995. </year>
Reference-contexts: Thus, the news service offers different qualities of service in the presence of different fault-classes. Although there are several examples of multitolerant systems in practice and there exists a growing body of research that presents instances of multitolerant computing systems <ref> [1, 2, 3, 4, 5, 6, 7, 8] </ref>, we are aware of little work that has considered the systematic design and analysis of multitolerance. Towards redressing this deficiency, we present in this paper a formal definition of multitolerance and a method for its design.
Reference: [7] <author> M Gouda and M. Schneider. </author> <title> Maximal flow routing. </title> <booktitle> Proceedings of the Second Workshop on Self Stabilizing Systems, </booktitle> <year> 1995. </year>
Reference-contexts: Thus, the news service offers different qualities of service in the presence of different fault-classes. Although there are several examples of multitolerant systems in practice and there exists a growing body of research that presents instances of multitolerant computing systems <ref> [1, 2, 3, 4, 5, 6, 7, 8] </ref>, we are aware of little work that has considered the systematic design and analysis of multitolerance. Towards redressing this deficiency, we present in this paper a formal definition of multitolerance and a method for its design.
Reference: [8] <author> I. Yen and F. Bastani. </author> <title> A highly safe self-stabilizing mutual exclusion algorithm. </title> <booktitle> Proceedings of the Second Workshop on Self-Stabilizing Systems, </booktitle> <year> 1995. </year>
Reference-contexts: Thus, the news service offers different qualities of service in the presence of different fault-classes. Although there are several examples of multitolerant systems in practice and there exists a growing body of research that presents instances of multitolerant computing systems <ref> [1, 2, 3, 4, 5, 6, 7, 8] </ref>, we are aware of little work that has considered the systematic design and analysis of multitolerance. Towards redressing this deficiency, we present in this paper a formal definition of multitolerance and a method for its design.
Reference: [9] <author> A. Arora and M. G. Gouda. </author> <title> Closure and convergence: A foundation of fault-tolerant tomputing. </title> <journal> IEEE Transactions on Software Engineering, </journal> 19(11) 1015-1027, 1993. 
Reference-contexts: Our method for designing multitolerance is formalized in terms of a set of "new abstractions" for tolerance properties. These abstractions have been derived from a foundation of fault-tolerant computing <ref> [9] </ref> which formalizes that "fault-tolerance may be viewed as the ability of the system to withstand a destabilizing shock". (Both quotes have been taken from the editorial of the February 1995 Special Issue on Fault-Tolerant Computing of IEEE Transactions on Computer Systems.) We will discuss these abstractions in more precise terms <p> The formalization is adapted from earlier work of the first author with Mohamed Gouda <ref> [9] </ref> (with the exception of the definition of fail-safe tolerance, which is new). Programs. A program is a set of variables and a finite set of actions. Each variable has a predefined nonempty domain. <p> The reader may well ask whether permanent and intermittent faults, which apparently affect actions as opposed to variables, can be represented as state perturbations. It turns out that they can, with the addition of auxiliary variables <ref> [4, 9] </ref>. For example, consider a Byzantine fault that affects a process j: Let good:j be an auxiliary boolean variable that is true when j executes its actions in the absence of the fault.
Reference: [10] <author> S. S. Kulkarni and A. Arora. </author> <title> Multitolerance in distributed reset. </title> <type> Technical Report OSU-CISRC 02/96 TR13, </type> <institution> Ohio State University, </institution> <year> 1996. </year> <note> Submitted to Chicago Journal of Theoretical Computer Science, Special Issue on Self-Stabilization. </note>
Reference-contexts: We illustrate our method by designing novel, fully distributed, programs. For reasons of space, we focus our attention on only two case studies (the interested reader is referred to the full version of this paper and its companion papers <ref> [10, 11, 12] </ref> for other case studies). The first case study concerns token rings and demonstrates continuous tolerance to certain detectable transient faults. The second case study concerns tree-based mutual exclusion and demonstrates qualitative multitolerance to certain detectable permanent faults and undetectable transient faults. Organization of the paper. <p> We note that we have used our method to design multitolerant programs for barrier computations, tree maintenance, leader election, bounded-space distributed reset, and termination detection <ref> [10, 11, 12] </ref>. We have also studied the design of detectors and correctors for different types of tolerance [12] and the necessity and sufficiency of detection and correction for fault-tolerance [18].
Reference: [11] <author> S. S. Kulkarni and A. Arora. </author> <title> Stepwise design of tolerances in barrier computations. </title> <type> Technical Report OSU-CISRC-3/96-TR17, </type> <institution> Ohio State University, </institution> <month> March </month> <year> 1996. </year> <note> Submitted to Symposium on Reliable Distributed Systems 1996. </note>
Reference-contexts: We illustrate our method by designing novel, fully distributed, programs. For reasons of space, we focus our attention on only two case studies (the interested reader is referred to the full version of this paper and its companion papers <ref> [10, 11, 12] </ref> for other case studies). The first case study concerns token rings and demonstrates continuous tolerance to certain detectable transient faults. The second case study concerns tree-based mutual exclusion and demonstrates qualitative multitolerance to certain detectable permanent faults and undetectable transient faults. Organization of the paper. <p> Moreover, stabilizing tolerance can be added while preserving the O (K) masking tolerance to K detectable process state corruptions. Such an augmentation is illustrated in a companion paper <ref> [11] </ref>. 7 Case Study 2: Tree-based Mutual Exclusion In this case study, we design a multitolerant program for mutual exclusion. We consider two sets of faults, F:1 and F:2. Faults in F:1 permanently and detectably fail-stop any number of processes; to these faults, the program is masking tolerant. <p> We note that we have used our method to design multitolerant programs for barrier computations, tree maintenance, leader election, bounded-space distributed reset, and termination detection <ref> [10, 11, 12] </ref>. We have also studied the design of detectors and correctors for different types of tolerance [12] and the necessity and sufficiency of detection and correction for fault-tolerance [18].
Reference: [12] <author> S. S. Kulkarni and A. Arora. </author> <title> Design of fault-tolerances using detectors and correctors. </title> <type> Manuscript, </type> <month> April </month> <year> 1996. </year>
Reference-contexts: We illustrate our method by designing novel, fully distributed, programs. For reasons of space, we focus our attention on only two case studies (the interested reader is referred to the full version of this paper and its companion papers <ref> [10, 11, 12] </ref> for other case studies). The first case study concerns token rings and demonstrates continuous tolerance to certain detectable transient faults. The second case study concerns tree-based mutual exclusion and demonstrates qualitative multitolerance to certain detectable permanent faults and undetectable transient faults. Organization of the paper. <p> In our experience, however, the structure imposed by abstractions of closure and convergence has proven to be beneficial in several ways: (1) it has enabled us to discover the role of detectors and correctors in the design of all tolerance properties <ref> [12, 18] </ref>; (2) it has yielded simple theorems for composing tolerance actions and underlying actions in an interference-free manner (cf. Sections 3 and 4 and [19]); (3) it has facilitated our design of novel and complex distributed programs whose tolerances exceed those of comparable programs designed otherwise [16] . <p> We note that we have used our method to design multitolerant programs for barrier computations, tree maintenance, leader election, bounded-space distributed reset, and termination detection <ref> [10, 11, 12] </ref>. We have also studied the design of detectors and correctors for different types of tolerance [12] and the necessity and sufficiency of detection and correction for fault-tolerance [18]. <p> We note that we have used our method to design multitolerant programs for barrier computations, tree maintenance, leader election, bounded-space distributed reset, and termination detection [10, 11, 12]. We have also studied the design of detectors and correctors for different types of tolerance <ref> [12] </ref> and the necessity and sufficiency of detection and correction for fault-tolerance [18]. To apply our design method in practice, we are currently developing SIEFAST, a simulation and implementation environment that enables systematic implementation and validation of multitolerant distributed programs.
Reference: [13] <author> K. M. Chandy and J. Misra. </author> <title> Parallel Program Design: A Foundation, chapter 9. </title> <publisher> Addison Wesley Publishing Company, </publisher> <year> 1989. </year>
Reference-contexts: the subsequent execution of p satisfies the safety properties of p but not necessarily the availability properties.) 3 Detectors and Correctors In this section, we define the building blocks for our design of multitolerant programs, namely, detectors and correctors. (The definition of detectors is essentially due to Chandy and Misra <ref> [13] </ref>.) We also outline their basic properties and show how to construct them in a hierarchical and efficient manner.
Reference: [14] <author> K. Raymond. </author> <title> A tree based algorithm for mutual exclusion. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 7 </volume> <pages> 61-77, </pages> <year> 1989. </year>
Reference-contexts: Our design proceeds as follows: We start with a fault-intolerant program that is due to Raymond <ref> [14] </ref> and Snepscheut [15]. We add detectors and correctors to this program so as to achieve masking tolerance to the fail-stops of processes. <p> In other words, upon starting from an arbitrary state, the program eventually converges to a state from where the specification of mutual exclusion is continually satisfied. We proceed as follows: In Section 7.1, we recall (an abstract version of) a wellknown fault-intolerant program for mutual exclusion by Raymond <ref> [14] </ref>, and Snepscheut [15]. In Section 7.2, we add correctors and detectors to that program to add masking tolerance to F:1. Finally, in Section 7.3, we add correctors to add stabilizing tolerance to F:2.
Reference: [15] <author> J. L. A. van de Snepscheut. </author> <title> Fair mutual exclusion on a graph of processes. </title> <journal> Distributed Computing, </journal> <volume> 2(2) 113-1.5, </volume> <year> 1987. </year>
Reference-contexts: Our design proceeds as follows: We start with a fault-intolerant program that is due to Raymond [14] and Snepscheut <ref> [15] </ref>. We add detectors and correctors to this program so as to achieve masking tolerance to the fail-stops of processes. <p> We proceed as follows: In Section 7.1, we recall (an abstract version of) a wellknown fault-intolerant program for mutual exclusion by Raymond [14], and Snepscheut <ref> [15] </ref>. In Section 7.2, we add correctors and detectors to that program to add masking tolerance to F:1. Finally, in Section 7.3, we add correctors to add stabilizing tolerance to F:2.
Reference: [16] <author> A. Arora and S. S. Kulkarni. </author> <title> Designing masking fault-tolerance via nonmasking fault-tolerance. </title> <booktitle> Pro ceedings of the Fourteenth Symposium on Reliable Distributed Systems, </booktitle> <address> Bad Neuenahr, 14 174-1.5, </address> <year> 1995. </year> <note> Submitted to IEEE Transactions on Software Engineering. </note>
Reference-contexts: To achieve (1) we add correctors and to achieve (2) we add detectors. The correctors are added first, thereby yielding nonmasking tolerance to F:1. The detectors are added next, thereby enhancing the tolerance to masking. (The interested reader is referred to <ref> [16] </ref> for the foundations and details of this two-stage design method for masking fault-tolerance.) Stage 1: Adding nonmasking fault-tolerance to F:1. To add nonmasking fault-tolerance to F:1, we need to (a) add correctors for the parent relation to a tree and (b) add correctors for the holder relation. <p> Sections 3 and 4 and [19]); (3) it has facilitated our design of novel and complex distributed programs whose tolerances exceed those of comparable programs designed otherwise <ref> [16] </ref> . It is for these reasons that we have formalized the method in terms of closure and convergence.
Reference: [17] <author> A. Arora. </author> <title> Efficient reconfiguration of trees: A case study in the methodical design of nonmasking fault tolerance. </title> <booktitle> Proceedings of the Third International Symposium on Formal Techniques in Real Time and Fault-Tolerance, </booktitle> <year> 1994. </year> <note> Submitted to Science of Computer Programming. </note>
Reference-contexts: To add nonmasking fault-tolerance to F:1, we need to (a) add correctors for the parent relation to a tree and (b) add correctors for the holder relation. For (a), we use a program presented by the first author elsewhere <ref> [17] </ref>. Theis program preserves the fact that, in the presence of fail-stops of processes, the graph of the parent relation always remains acyclic, although it may consist of multiple, possibly unrooted, trees. For convenience, we recall this program here, in brief.
Reference: [18] <author> A. Arora. </author> <title> On the necessity and sufficiency of detection and correction for fault-tolerance. </title> <type> Manuscript, </type> <month> April </month> <year> 1996. </year> <month> 23 </month>
Reference-contexts: In our experience, however, the structure imposed by abstractions of closure and convergence has proven to be beneficial in several ways: (1) it has enabled us to discover the role of detectors and correctors in the design of all tolerance properties <ref> [12, 18] </ref>; (2) it has yielded simple theorems for composing tolerance actions and underlying actions in an interference-free manner (cf. Sections 3 and 4 and [19]); (3) it has facilitated our design of novel and complex distributed programs whose tolerances exceed those of comparable programs designed otherwise [16] . <p> We have also studied the design of detectors and correctors for different types of tolerance [12] and the necessity and sufficiency of detection and correction for fault-tolerance <ref> [18] </ref>. To apply our design method in practice, we are currently developing SIEFAST, a simulation and implementation environment that enables systematic implementation and validation of multitolerant distributed programs.
Reference: [19] <author> A. Arora, M. G. Gouda, and G. Varghese. </author> <title> Constraint satisfaction as a basis for designing nonmasking fault-tolerance. Journal of High Speed Networks, </title> <note> 1996, in press. 24 </note>
Reference-contexts: Sections 3 and 4 and <ref> [19] </ref>); (3) it has facilitated our design of novel and complex distributed programs whose tolerances exceed those of comparable programs designed otherwise [16] . It is for these reasons that we have formalized the method in terms of closure and convergence.
References-found: 19

