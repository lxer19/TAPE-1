URL: http://www.cs.utexas.edu/users/pclark/papers/uttr96b.ps
Refering-URL: http://www.cs.utexas.edu/users/pclark/papers/uttr96b.abs.html
Root-URL: 
Email: fpclark,porter,dsbg@cs.utexas.edu  
Title: Compositional Approach to Representing Planning Operators 1  
Author: Peter Clark, Bruce Porter and Don Batory 
Address: Austin, TX 78712, USA  
Affiliation: Dept. Computer Science Univ. Texas at Austin  
Note: A  
Abstract: Tech Report AI96-242, Dept CS, Univ Texas at Austin, 1996. http://www.cs.utexas.edu/users/pclark/papers/uttr96b.ps Abstract AI has frequently been criticized for being `stuck in the microworld' because of the common inability of AI systems to cope with the complexity of real domains. Often, adding details removes regularity, transforming a representation from a few simple structures to a large, unwieldy collection of specialized ones. This paper addresses this problem in the context of representing planning operators (domain-specific knowledge about the effects of actions in a domain) for use by AI planning systems. We present a novel approach in which domain-specific operators are represented as a composition of general components, and show that the problem of manually building a detailed set of operators can be avoided by constructing them from a small number of such components instead. Each component encapsulates information about a domain feature that might be modeled, and each may contribute to several operators. Moreover, we describe how the choice of what to model and what to ignore in a domain can then be easily varied, simply by controlling which components are used. Finally, we show how operator sets built in this way can be used by planning algorithms.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Batory and S. O'Malley. </author> <title> The design and implementation of hierarchical software systems with reusable components. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <month> Oct </month> <year> 1992. </year>
Reference-contexts: Finally, we show how planning algorithms can be easily modified to use operators specified in this manner. Our approach draws heavily on a recent, novel approach to software reuse, called the GenVoca method, developed in software engineering <ref> [1, 2, 3] </ref>.
Reference: [2] <author> D. Batory, V. Singhal, and M. Sirkin. </author> <title> Implementing a domain model for data structures. </title> <journal> Int. Journal of Software Engineering and Knowledge Engineering, </journal> <volume> 2(3) </volume> <pages> 375-402, </pages> <month> Sept </month> <year> 1992. </year>
Reference-contexts: Finally, we show how planning algorithms can be easily modified to use operators specified in this manner. Our approach draws heavily on a recent, novel approach to software reuse, called the GenVoca method, developed in software engineering <ref> [1, 2, 3] </ref>.
Reference: [3] <author> D. Batory, V. Singhal, M. Sirkin, and J. Thomas. </author> <title> Scalable software libraries. </title> <booktitle> In Proceedings ACM SIGSOFT'93 (Symposium on the Foundations of Software Engineering), </booktitle> <month> Dec </month> <year> 1993. </year>
Reference-contexts: Finally, we show how planning algorithms can be easily modified to use operators specified in this manner. Our approach draws heavily on a recent, novel approach to software reuse, called the GenVoca method, developed in software engineering <ref> [1, 2, 3] </ref>.
Reference: [4] <author> H. L. Dreyfus. </author> <title> From micro-worlds to knowledge representation: Ai at an impasse. </title> <editor> In J. Haugeland, editor, </editor> <booktitle> Mind Design, </booktitle> <pages> pages 161-204. </pages> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1981. </year> <title> (originally in "What Computers Can't Do" (NY: </title> <publisher> Harper and Row, </publisher> <year> 1979)). </year>
Reference-contexts: 1 Introduction AI has frequently been criticized for being `stuck in the microworld' (eg. <ref> [4] </ref>), referring to the common inability for methods to scale up from toy domains to more complex, real-world domains. Microworlds offer simple regularity, whereas the diversities and idiosyncracies of the real world are often complex to represent and reason about.
Reference: [5] <author> B. Falkenhainer and K. Forbus. </author> <title> Compositional modelling: Finding the right model for the job. </title> <journal> Artificial Intelligence, </journal> <volume> 51 </volume> <pages> 95-143, </pages> <year> 1991. </year>
Reference-contexts: Components provide the `seams' by which a representation can be appropriately disassembled 6 . This ability to generate and work with more abstract domain models is often desirable, both for efficiency and explainability to a user <ref> [5, 10] </ref>. Work on compositional modeling achieves this advantage in a similar way (eg. [5, 8, 10]). <p> This ability to generate and work with more abstract domain models is often desirable, both for efficiency and explainability to a user [5, 10]. Work on compositional modeling achieves this advantage in a similar way (eg. <ref> [5, 8, 10] </ref>). In compositional modeling, a component (called a `model fragment') contributes a set of constraints 7 to a representation of the domain, and composition involves collecting constraints from a suitably chosen set of model fragments. <p> However, Abstrips did not factor a representation into components, but instead abstracted representations by ignoring `low priority' preconditions. It thus assumed fixed layers of detail, and had no notion of encapsulating domain features as independent units. 7 sometimes called its `relations' [8] or `behavior conditions' <ref> [5] </ref> 13
Reference: [6] <author> R. Fikes, P. Hart, and N. Nilsson. </author> <title> Learning and executing generalized robot plans. </title> <editor> In B. Webber and N. Nilsson, editors, </editor> <booktitle> Readings in AI, </booktitle> <pages> pages 231-249. </pages> <publisher> Tioga, </publisher> <address> Palo Alto, CA, </address> <year> 1981. </year>
Reference-contexts: For convenience we present this work using the STRIPS planning formalism, in which operators are represented using precondition, delete and add lists <ref> [7, 6] </ref>. It is important to note that we are not claiming anything special about the STRIPS representation, and we acknowledge its many limitations.
Reference: [7] <author> R. Fikes and N. Nilsson. </author> <title> STRIPS: A new approach to the application of theorem-proving to problem-solving. </title> <journal> AI, </journal> <volume> 2 </volume> <pages> 189-208, </pages> <year> 1971. </year>
Reference-contexts: For convenience we present this work using the STRIPS planning formalism, in which operators are represented using precondition, delete and add lists <ref> [7, 6] </ref>. It is important to note that we are not claiming anything special about the STRIPS representation, and we acknowledge its many limitations. <p> For example, the chain of clauses used to test whether a container's lid is open: lid (Container,Lid), status (Lid,Status), Status = open can be re-expressed equivalently as Container.lid.status = open Many planners use operators represented with this formalism, or a similar one (eg. <ref> [7, 13, 12, 9] </ref>). A simple one is shown in Figure 1; given a goal, the planner finds an action to achieve it, (recursively) plans how to achieve the preconditions for that action, and returns, as the final plan, the concatenation of those plans plus the original action.
Reference: [8] <author> A. Y. Levy. </author> <note> Irrelevance reasoning in knowledge-based systems. Tech report STAN-CS-93-1482 (also KSL-93-58), </note> <institution> Dept CS, Stanford Univ., </institution> <address> CA, </address> <month> July </month> <year> 1993. </year> <note> (Chapter 6). </note>
Reference-contexts: This ability to generate and work with more abstract domain models is often desirable, both for efficiency and explainability to a user [5, 10]. Work on compositional modeling achieves this advantage in a similar way (eg. <ref> [5, 8, 10] </ref>). In compositional modeling, a component (called a `model fragment') contributes a set of constraints 7 to a representation of the domain, and composition involves collecting constraints from a suitably chosen set of model fragments. <p> However, Abstrips did not factor a representation into components, but instead abstracted representations by ignoring `low priority' preconditions. It thus assumed fixed layers of detail, and had no notion of encapsulating domain features as independent units. 7 sometimes called its `relations' <ref> [8] </ref> or `behavior conditions' [5] 13
Reference: [9] <author> D. McAllester and D. Rosenblitt. </author> <title> Systematic nonlinear planning. </title> <booktitle> In AAAI-91, </booktitle> <volume> volume 2, </volume> <pages> pages 634-639, </pages> <address> CA, 1991. </address> <publisher> AAAI Press. </publisher>
Reference-contexts: For example, the chain of clauses used to test whether a container's lid is open: lid (Container,Lid), status (Lid,Status), Status = open can be re-expressed equivalently as Container.lid.status = open Many planners use operators represented with this formalism, or a similar one (eg. <ref> [7, 13, 12, 9] </ref>). A simple one is shown in Figure 1; given a goal, the planner finds an action to achieve it, (recursively) plans how to achieve the preconditions for that action, and returns, as the final plan, the concatenation of those plans plus the original action.
Reference: [10] <author> J. W. Rickel. </author> <title> Automated Modeling of Complex Systems to Answer Prediction Questions. </title> <type> PhD thesis, </type> <institution> Dept CS, Univ. Texas at Austin, </institution> <year> 1995. </year> <note> (Also available as Tech Rept AI-95-234). </note>
Reference-contexts: Components provide the `seams' by which a representation can be appropriately disassembled 6 . This ability to generate and work with more abstract domain models is often desirable, both for efficiency and explainability to a user <ref> [5, 10] </ref>. Work on compositional modeling achieves this advantage in a similar way (eg. [5, 8, 10]). <p> This ability to generate and work with more abstract domain models is often desirable, both for efficiency and explainability to a user [5, 10]. Work on compositional modeling achieves this advantage in a similar way (eg. <ref> [5, 8, 10] </ref>). In compositional modeling, a component (called a `model fragment') contributes a set of constraints 7 to a representation of the domain, and composition involves collecting constraints from a suitably chosen set of model fragments.
Reference: [11] <author> E. D. Sacerdoti. </author> <title> Planning in a hierarchy of abstraction spaces. </title> <journal> Artificial Intelligence, </journal> <volume> 5(2) </volume> <pages> 115-135, </pages> <year> 1974. </year>
Reference-contexts: By interleaving composition and planning, operators to be constructed on demand. In addition to constructing representations, the compositional approach allows representations to be easily abstracted and extended, both important requirements for applying AI in real-world domains. 6 Another early pioneering attempt at this was Abstrips <ref> [11] </ref>. However, Abstrips did not factor a representation into components, but instead abstracted representations by ignoring `low priority' preconditions. It thus assumed fixed layers of detail, and had no notion of encapsulating domain features as independent units. 7 sometimes called its `relations' [8] or `behavior conditions' [5] 13
Reference: [12] <author> A. Tate. </author> <title> Generating project networks. </title> <booktitle> In IJCAI-77, </booktitle> <pages> pages 888-893, </pages> <year> 1977. </year>
Reference-contexts: For example, the chain of clauses used to test whether a container's lid is open: lid (Container,Lid), status (Lid,Status), Status = open can be re-expressed equivalently as Container.lid.status = open Many planners use operators represented with this formalism, or a similar one (eg. <ref> [7, 13, 12, 9] </ref>). A simple one is shown in Figure 1; given a goal, the planner finds an action to achieve it, (recursively) plans how to achieve the preconditions for that action, and returns, as the final plan, the concatenation of those plans plus the original action.
Reference: [13] <author> R. Waldinger. </author> <title> Achieving several goals simultaneously. </title> <editor> In B. L. Webber and N. J. Nilsson, editors, </editor> <booktitle> Readings in Artificial Intelligence, </booktitle> <pages> pages 250-271. </pages> <publisher> Tioga, </publisher> <address> CA, </address> <year> 1981. </year> <month> 14 </month>
Reference-contexts: For example, the chain of clauses used to test whether a container's lid is open: lid (Container,Lid), status (Lid,Status), Status = open can be re-expressed equivalently as Container.lid.status = open Many planners use operators represented with this formalism, or a similar one (eg. <ref> [7, 13, 12, 9] </ref>). A simple one is shown in Figure 1; given a goal, the planner finds an action to achieve it, (recursively) plans how to achieve the preconditions for that action, and returns, as the final plan, the concatenation of those plans plus the original action.
References-found: 13

