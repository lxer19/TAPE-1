URL: http://www.cs.wisc.edu/wpis/papers/tr1337r.ps
Refering-URL: http://www.cs.wisc.edu/wpis/html/
Root-URL: http://www.cs.wisc.edu
Email: fsiff, repsg@cs.wisc.edu  
Title: Identifying Modules Via Concept Analysis  
Author: Michael Siff and Thomas Reps 
Address: 1210 West Dayton Street Madison, WI 53706  
Affiliation: University of Wisconsin  
Abstract: We describe a general technique for identifying modules in legacy code. The method is based on concept analysis|a branch of lattice theory that can be used to identify similarities among a set of objects based on their attributes. We discuss how concept analysis can identify potential modules using both "positive" and "negative" information. We present an algorithmic framework to construct a lattice of concepts from a program, where each concept represents a potential module. We define the notion of a concept partition, present an algorithm for discovering all concept partitions of a given concept lattice, and prove the algorithm correct. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B. L. Achee and Doris L. Carver. </author> <title> A greedy approach to object identification in imperative code. </title> <booktitle> In Third Workshop on Program Comprehension, </booktitle> <pages> pages 4-11, </pages> <year> 1994. </year>
Reference-contexts: P 1 is the atomic partition. <ref> [1] </ref> A 0 A [3] while (O; A 0 ; R 0 ) is not well formed do [4] let x; y 2 O be such that (fxg) ( (fyg) [5] let a 2 A 0 be such that a 62 (fxg), a 2 (fyg) [6] A 0 A 0 [ <p> Before attempting to find a new partition, the algorithm would pause for the user to specify seed sets of concepts, which would be used to force the algorithm to find only coarser partitions than the seed sets (i.e., partitions that do not 26 <ref> [1] </ref> A covs (?) // the atomic partition [2] P fAg [4] while W 6= ; do [5] remove some p from W [6] for each c 2 p [7] for each c 0 2 covs (c) [8] p 0 p subs (c 0 ) [9] if ( p 0 ) <p> The additional discriminatory power of the concept-analysis approach is due to the fact that it is able to exploit both positive and negative information. In contrast with the approach to identifying objects described in <ref> [1] </ref>, our technique is aimed at analyzing relationships among functions and types to identify classes. In [1], the aim is to identify objects that link functions to specific variables. A similar effect can be achieved via concept analysis by introducing one attribute for each actual parameter. <p> In contrast with the approach to identifying objects described in <ref> [1] </ref>, our technique is aimed at analyzing relationships among functions and types to identify classes. In [1], the aim is to identify objects that link functions to specific variables. A similar effect can be achieved via concept analysis by introducing one attribute for each actual parameter. <p> A similar effect can be achieved via concept analysis by introducing one attribute for each actual parameter. There has been a certain amount of work involving the use of cluster analysis to identify potential modules (e.g., <ref> [11, 1, 12, 2] </ref>). This work (implicitly or explicitly) involves the identification of potential modules by determining a similarity measure among pairs of functions.
Reference: [2] <author> G. Canfora, A. Cimitile, and M. Munro. </author> <title> An improved algorithm for identifying objects in code. </title> <journal> Software | Practice and Experience, </journal> <volume> 26(1) </volume> <pages> 25-48, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: attempting to find a new partition, the algorithm would pause for the user to specify seed sets of concepts, which would be used to force the algorithm to find only coarser partitions than the seed sets (i.e., partitions that do not 26 [1] A covs (?) // the atomic partition <ref> [2] </ref> P fAg [4] while W 6= ; do [5] remove some p from W [6] for each c 2 p [7] for each c 0 2 covs (c) [8] p 0 p subs (c 0 ) [9] if ( p 0 ) " c 0 = ; // if p <p> Given that some user interaction will be required, the concept-analysis approach offers certain advantages over other previously proposed techniques (e.g., <ref> [14, 5, 16, 15, 2] </ref>), namely, the ability to "stay within the system" (as opposed to applying ad hoc methods) when the user judges that the modularization that the system suggests is unsatisfactory. <p> The reader is referred to <ref> [2, pp. 27-32] </ref> for an extensive discussion of the literature on the modularization problem. In the remainder of this section, we discuss only the work that is most relevant to the approach we have taken. <p> It may be possible to combine the techniques from [4] and [5] with the concept-analysis approach of this paper. Canfora et al. discuss two types of links that cause undesirable clustering of functions <ref> [2] </ref>. The first type, "coincidental links", caused by routines that im 36 plement more than one function, can be overcome by program slicing [22, 10]. The second type, "spurious links", is caused by functions that access supporting data structures of more than one object type. <p> The second type, "spurious links", is caused by functions that access supporting data structures of more than one object type. In most of the approaches mentioned above, spurious links arise from a function that accesses several global variables of different types. The work described in <ref> [14, 5, 15, 24, 2] </ref> will all stumble on examples that exhibit spurious links. In our approach, an analogous kind of spurious link arises due to functions that access internal fields of more than one struct. <p> A similar effect can be achieved via concept analysis by introducing one attribute for each actual parameter. There has been a certain amount of work involving the use of cluster analysis to identify potential modules (e.g., <ref> [11, 1, 12, 2] </ref>). This work (implicitly or explicitly) involves the identification of potential modules by determining a similarity measure among pairs of functions.
Reference: [3] <author> G. Canfora, A. Cimitile, M. Tortorella, and M. Munro. </author> <title> Experiments in identifying reusable abstract data types in program code. </title> <booktitle> In Second Workshop on Program Comprehension, </booktitle> <pages> pages 36-45, </pages> <year> 1993. </year>
Reference-contexts: Although other modularization algorithms are able to identify the same decomposition <ref> [3, 24] </ref>, they are unable to handle a variant of this example in which stacks and queues are more tightly intertwined (see Section 3.2). In Section 3.2, we show that concept analysis is able to group the code from the latter example into separate queue and stack modules. <p> It is relatively straightforward to separate the code shown in Figure 1 into two modules, and techniques such as those described in <ref> [3, 24] </ref> will also create the same grouping. We now show that concept analysis offers the possibility to go beyond previously defined methods: It offers the ability to tease apart code that is, in some sense, more "tangled". <p> P 1 is the atomic partition. [1] A 0 A <ref> [3] </ref> while (O; A 0 ; R 0 ) is not well formed do [4] let x; y 2 O be such that (fxg) ( (fyg) [5] let a 2 A 0 be such that a 62 (fxg), a 2 (fyg) [6] A 0 A 0 [ fag, where a is <p> As explained above, the concept-analysis approach can naturally generate a variety of possible decompositions (i.e., different collections of concepts that partition the set of objects). The concept-analysis approach is more general than that of Canfora et al. <ref> [3] </ref>, which identifies abstract data types by analyzing a graph that links functions to their argument types and return types. <p> By adding attributes that indicate whether fields of compound data types are used in a function, as is done in the example used in Section 3, concept-analysis becomes a more powerful tool for identifying potential modules than the technique described in <ref> [3] </ref>. The work described in [4] and [5] expands on the abstract-data-type identification technique described in [3]: Call and dominance information is used to introduce a hierarchical nesting structure to modules. It may be possible to combine the techniques from [4] and [5] with the concept-analysis approach of this paper. <p> of compound data types are used in a function, as is done in the example used in Section 3, concept-analysis becomes a more powerful tool for identifying potential modules than the technique described in <ref> [3] </ref>. The work described in [4] and [5] expands on the abstract-data-type identification technique described in [3]: Call and dominance information is used to introduce a hierarchical nesting structure to modules. It may be possible to combine the techniques from [4] and [5] with the concept-analysis approach of this paper. Canfora et al. discuss two types of links that cause undesirable clustering of functions [2].
Reference: [4] <author> G. Canfora, A. De Lucia, G. A. Di Lucca, and A. R. Fasolino. </author> <title> Recovering the architectural design for software comprehension. </title> <booktitle> In Third Workshop on Program Comprehension, </booktitle> <pages> pages 30-38, </pages> <year> 1994. </year>
Reference-contexts: P 1 is the atomic partition. [1] A 0 A [3] while (O; A 0 ; R 0 ) is not well formed do <ref> [4] </ref> let x; y 2 O be such that (fxg) ( (fyg) [5] let a 2 A 0 be such that a 62 (fxg), a 2 (fyg) [6] A 0 A 0 [ fag, where a is a new attribute [7] R 0 R 0 [ f (x; a)j (x; a) <p> a new partition, the algorithm would pause for the user to specify seed sets of concepts, which would be used to force the algorithm to find only coarser partitions than the seed sets (i.e., partitions that do not 26 [1] A covs (?) // the atomic partition [2] P fAg <ref> [4] </ref> while W 6= ; do [5] remove some p from W [6] for each c 2 p [7] for each c 0 2 covs (c) [8] p 0 p subs (c 0 ) [9] if ( p 0 ) " c 0 = ; // if p 0 and c <p> By adding attributes that indicate whether fields of compound data types are used in a function, as is done in the example used in Section 3, concept-analysis becomes a more powerful tool for identifying potential modules than the technique described in [3]. The work described in <ref> [4] </ref> and [5] expands on the abstract-data-type identification technique described in [3]: Call and dominance information is used to introduce a hierarchical nesting structure to modules. It may be possible to combine the techniques from [4] and [5] with the concept-analysis approach of this paper. <p> The work described in <ref> [4] </ref> and [5] expands on the abstract-data-type identification technique described in [3]: Call and dominance information is used to introduce a hierarchical nesting structure to modules. It may be possible to combine the techniques from [4] and [5] with the concept-analysis approach of this paper. Canfora et al. discuss two types of links that cause undesirable clustering of functions [2]. The first type, "coincidental links", caused by routines that im 36 plement more than one function, can be overcome by program slicing [22, 10].
Reference: [5] <author> A. Cimitile, M. Tortorella, and M. Munro. </author> <title> Program comprehension through the identification of abstract data types. </title> <booktitle> In Third Workshop on Program Comprehension, </booktitle> <pages> pages 12-19, </pages> <year> 1994. </year>
Reference-contexts: P 1 is the atomic partition. [1] A 0 A [3] while (O; A 0 ; R 0 ) is not well formed do [4] let x; y 2 O be such that (fxg) ( (fyg) <ref> [5] </ref> let a 2 A 0 be such that a 62 (fxg), a 2 (fyg) [6] A 0 A 0 [ fag, where a is a new attribute [7] R 0 R 0 [ f (x; a)j (x; a) 62 R 0 g [8] endwhile As an example, consider the atomic <p> The algorithm begins with the atomic partition (consisting of concepts, c 0 , c 1 , c 2 , and c 6 ) as the sole member of the worklist. The algorithm removes the atomic partition from the worklist, as p in line <ref> [5] </ref> of Figure 15. Suppose that in the first iteration of the for loop in line [6], c refers to c 0 . The covering set of c 0 is the singleton set consisting of c 4 , so c 0 is assigned c 4 in line [7]. <p> pause for the user to specify seed sets of concepts, which would be used to force the algorithm to find only coarser partitions than the seed sets (i.e., partitions that do not 26 [1] A covs (?) // the atomic partition [2] P fAg [4] while W 6= ; do <ref> [5] </ref> remove some p from W [6] for each c 2 p [7] for each c 0 2 covs (c) [8] p 0 p subs (c 0 ) [9] if ( p 0 ) " c 0 = ; // if p 0 and c 0 are disjoint [10] p 00 <p> Given that some user interaction will be required, the concept-analysis approach offers certain advantages over other previously proposed techniques (e.g., <ref> [14, 5, 16, 15, 2] </ref>), namely, the ability to "stay within the system" (as opposed to applying ad hoc methods) when the user judges that the modularization that the system suggests is unsatisfactory. <p> By adding attributes that indicate whether fields of compound data types are used in a function, as is done in the example used in Section 3, concept-analysis becomes a more powerful tool for identifying potential modules than the technique described in [3]. The work described in [4] and <ref> [5] </ref> expands on the abstract-data-type identification technique described in [3]: Call and dominance information is used to introduce a hierarchical nesting structure to modules. It may be possible to combine the techniques from [4] and [5] with the concept-analysis approach of this paper. <p> The work described in [4] and <ref> [5] </ref> expands on the abstract-data-type identification technique described in [3]: Call and dominance information is used to introduce a hierarchical nesting structure to modules. It may be possible to combine the techniques from [4] and [5] with the concept-analysis approach of this paper. Canfora et al. discuss two types of links that cause undesirable clustering of functions [2]. The first type, "coincidental links", caused by routines that im 36 plement more than one function, can be overcome by program slicing [22, 10]. <p> The second type, "spurious links", is caused by functions that access supporting data structures of more than one object type. In most of the approaches mentioned above, spurious links arise from a function that accesses several global variables of different types. The work described in <ref> [14, 5, 15, 24, 2] </ref> will all stumble on examples that exhibit spurious links. In our approach, an analogous kind of spurious link arises due to functions that access internal fields of more than one struct.
Reference: [6] <author> B.A. Davey and H.A. Priestley. </author> <title> Introduction to lattices and order. </title> <publisher> Cam-bridge University Press, </publisher> <year> 1990. </year>
Reference-contexts: 1 is the atomic partition. [1] A 0 A [3] while (O; A 0 ; R 0 ) is not well formed do [4] let x; y 2 O be such that (fxg) ( (fyg) [5] let a 2 A 0 be such that a 62 (fxg), a 2 (fyg) <ref> [6] </ref> A 0 A 0 [ fag, where a is a new attribute [7] R 0 R 0 [ f (x; a)j (x; a) 62 R 0 g [8] endwhile As an example, consider the atomic partition of the concept lattice derived from the uniquely-attributed mammal context (see Figure 12). <p> The algorithm removes the atomic partition from the worklist, as p in line [5] of Figure 15. Suppose that in the first iteration of the for loop in line <ref> [6] </ref>, c refers to c 0 . The covering set of c 0 is the singleton set consisting of c 4 , so c 0 is assigned c 4 in line [7]. <p> seed sets of concepts, which would be used to force the algorithm to find only coarser partitions than the seed sets (i.e., partitions that do not 26 [1] A covs (?) // the atomic partition [2] P fAg [4] while W 6= ; do [5] remove some p from W <ref> [6] </ref> for each c 2 p [7] for each c 0 2 covs (c) [8] p 0 p subs (c 0 ) [9] if ( p 0 ) " c 0 = ; // if p 0 and c 0 are disjoint [10] p 00 p 0 [ fc 0 g <p> This work (implicitly or explicitly) involves the identification of potential modules by determining a similarity measure among pairs of functions. We are currently investigating the link between concept analysis and cluster analysis. <ref> [6] </ref> offers background on lattice theory and an introduction to concept analysis. [23] formalizes the notions of concept analysis and provides a proof of the fundamental theorem. Concept analysis has been applied to many kinds of problems.
Reference: [7] <author> Jean-Fran~cois Girard. Personal communiation., </author> <month> July </month> <year> 1998. </year>
Reference-contexts: 0 ; R 0 ) is not well formed do [4] let x; y 2 O be such that (fxg) ( (fyg) [5] let a 2 A 0 be such that a 62 (fxg), a 2 (fyg) [6] A 0 A 0 [ fag, where a is a new attribute <ref> [7] </ref> R 0 R 0 [ f (x; a)j (x; a) 62 R 0 g [8] endwhile As an example, consider the atomic partition of the concept lattice derived from the uniquely-attributed mammal context (see Figure 12). <p> Suppose that in the first iteration of the for loop in line [6], c refers to c 0 . The covering set of c 0 is the singleton set consisting of c 4 , so c 0 is assigned c 4 in line <ref> [7] </ref>. In line [8], p 0 is assigned the value of p minus the subordinate concepts of c 4 (i.e., c 1 , c 0 , and bottom), so p 0 is fc 2 ; c 6 g. <p> be used to force the algorithm to find only coarser partitions than the seed sets (i.e., partitions that do not 26 [1] A covs (?) // the atomic partition [2] P fAg [4] while W 6= ; do [5] remove some p from W [6] for each c 2 p <ref> [7] </ref> for each c 0 2 covs (c) [8] p 0 p subs (c 0 ) [9] if ( p 0 ) " c 0 = ; // if p 0 and c 0 are disjoint [10] p 00 p 0 [ fc 0 g [12] P P [ fp 00
Reference: [8] <author> Jean-Fran~cois Girard and Rainer Koschke. </author> <title> Finding components in a hierarchy of modules: a step towards architectural understanding. </title> <booktitle> In International Conference on Software Maintenance, </booktitle> <pages> pages 58-65, </pages> <address> Bari, Italy, </address> <month> October </month> <year> 1997. </year>
Reference-contexts: O be such that (fxg) ( (fyg) [5] let a 2 A 0 be such that a 62 (fxg), a 2 (fyg) [6] A 0 A 0 [ fag, where a is a new attribute [7] R 0 R 0 [ f (x; a)j (x; a) 62 R 0 g <ref> [8] </ref> endwhile As an example, consider the atomic partition of the concept lattice derived from the uniquely-attributed mammal context (see Figure 12). <p> Suppose that in the first iteration of the for loop in line [6], c refers to c 0 . The covering set of c 0 is the singleton set consisting of c 4 , so c 0 is assigned c 4 in line [7]. In line <ref> [8] </ref>, p 0 is assigned the value of p minus the subordinate concepts of c 4 (i.e., c 1 , c 0 , and bottom), so p 0 is fc 2 ; c 6 g. <p> only coarser partitions than the seed sets (i.e., partitions that do not 26 [1] A covs (?) // the atomic partition [2] P fAg [4] while W 6= ; do [5] remove some p from W [6] for each c 2 p [7] for each c 0 2 covs (c) <ref> [8] </ref> p 0 p subs (c 0 ) [9] if ( p 0 ) " c 0 = ; // if p 0 and c 0 are disjoint [10] p 00 p 0 [ fc 0 g [12] P P [ fp 00 g [14] endif [15] endif [16] endfor [17]
Reference: [9] <author> R. Godin and R. Missaoui H. Alaoui. </author> <title> Incremental concept formation algorithms based on Galois (concept) lattices. </title> <journal> Computational Intelligence, </journal> <volume> 11(2) </volume> <pages> 246-267, </pages> <year> 1995. </year>
Reference-contexts: An example of the application of the fundamental theorem is shown in Figure 4. There are several algorithms for computing the concept lattice for a given context <ref> [9, 21] </ref>. We describe a simple bottom-up algorithm here. An important fact about concepts and contexts used in the algorithm is that, given a set of objects X, the smallest concept with extent containing X is (t ((X)); (X)). <p> In line [8], p 0 is assigned the value of p minus the subordinate concepts of c 4 (i.e., c 1 , c 0 , and bottom), so p 0 is fc 2 ; c 6 g. In line <ref> [9] </ref>, the union of the extents of c 2 and c 6 is disjoint with the extent of c 4 ; thus, in line [10], the partition p 00 = fc 2 ; c 6 g [ fc 4 g is formed. p 00 is added to the set of partitions <p> partitions that do not 26 [1] A covs (?) // the atomic partition [2] P fAg [4] while W 6= ; do [5] remove some p from W [6] for each c 2 p [7] for each c 0 2 covs (c) [8] p 0 p subs (c 0 ) <ref> [9] </ref> if ( p 0 ) " c 0 = ; // if p 0 and c 0 are disjoint [10] p 00 p 0 [ fc 0 g [12] P P [ fp 00 g [14] endif [15] endif [16] endfor [17] endfor [18] endwhile subdivide the seed sets).
Reference: [10] <author> Susan Horwitz, Thomas Reps, and David Binkley. </author> <title> Interprocedural slicing using dependence graphs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(1) </volume> <pages> 26-60, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: In such cases, it may be preferable to have objects correspond to slices <ref> [22, 10] </ref> rather than functions. 19 In practice, programs to be modularized will be much larger. <p> In line [9], the union of the extents of c 2 and c 6 is disjoint with the extent of c 4 ; thus, in line <ref> [10] </ref>, the partition p 00 = fc 2 ; c 6 g [ fc 4 g is formed. p 00 is added to the set of partitions and to the worklist in line [12] and line [13]. <p> ; do [5] remove some p from W [6] for each c 2 p [7] for each c 0 2 covs (c) [8] p 0 p subs (c 0 ) [9] if ( p 0 ) " c 0 = ; // if p 0 and c 0 are disjoint <ref> [10] </ref> p 00 p 0 [ fc 0 g [12] P P [ fp 00 g [14] endif [15] endif [16] endfor [17] endfor [18] endwhile subdivide the seed sets). <p> Canfora et al. discuss two types of links that cause undesirable clustering of functions [2]. The first type, "coincidental links", caused by routines that im 36 plement more than one function, can be overcome by program slicing <ref> [22, 10] </ref>. The second type, "spurious links", is caused by functions that access supporting data structures of more than one object type. In most of the approaches mentioned above, spurious links arise from a function that accesses several global variables of different types.
Reference: [11] <author> David H. Hutchens and Victor R. Basili. </author> <title> System structure analysis: Clustering with data bindings. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-11(8):749-757, </volume> <month> August </month> <year> 1985. </year>
Reference-contexts: A similar effect can be achieved via concept analysis by introducing one attribute for each actual parameter. There has been a certain amount of work involving the use of cluster analysis to identify potential modules (e.g., <ref> [11, 1, 12, 2] </ref>). This work (implicitly or explicitly) involves the identification of potential modules by determining a similarity measure among pairs of functions.
Reference: [12] <author> Thomas Kunz. </author> <title> Evaluating process clusters to support automatic program understanding. </title> <booktitle> In Fourth Workshop on Program Comprehension, </booktitle> <pages> pages 198-207, </pages> <year> 1996. </year>
Reference-contexts: c 2 and c 6 is disjoint with the extent of c 4 ; thus, in line [10], the partition p 00 = fc 2 ; c 6 g [ fc 4 g is formed. p 00 is added to the set of partitions and to the worklist in line <ref> [12] </ref> and line [13]. In the worst case, the number of partitions can be exponential in the number of concepts. Furthermore, the techniques for making contexts well-formed, discussed in Section 4.1, only exacerbate the problem: More precise means of distinguishing sets of objects translates to more concepts. <p> for each c 2 p [7] for each c 0 2 covs (c) [8] p 0 p subs (c 0 ) [9] if ( p 0 ) " c 0 = ; // if p 0 and c 0 are disjoint [10] p 00 p 0 [ fc 0 g <ref> [12] </ref> P P [ fp 00 g [14] endif [15] endif [16] endfor [17] endfor [18] endwhile subdivide the seed sets). <p> A similar effect can be achieved via concept analysis by introducing one attribute for each actual parameter. There has been a certain amount of work involving the use of cluster analysis to identify potential modules (e.g., <ref> [11, 1, 12, 2] </ref>). This work (implicitly or explicitly) involves the identification of potential modules by determining a similarity measure among pairs of functions.
Reference: [13] <author> Christian Lindig and Gregor Snelting. </author> <title> Assessing modular structure of legacy code based on mathematical concept analysis. </title> <booktitle> In Proceedings of the 19th International Conference on Software Engineering, </booktitle> <pages> pages 349-359, </pages> <year> 1997. </year>
Reference-contexts: Other possibilities for attributes include the following: * Variable-usage information: Related functions can sometimes be identified by their use of common global variables. An attribute capturing this information might be of the form "uses global variable x" <ref> [13, 18] </ref>. * Dataflow and slicing information can be useful in identifying modules. <p> c 6 is disjoint with the extent of c 4 ; thus, in line [10], the partition p 00 = fc 2 ; c 6 g [ fc 4 g is formed. p 00 is added to the set of partitions and to the worklist in line [12] and line <ref> [13] </ref>. In the worst case, the number of partitions can be exponential in the number of concepts. Furthermore, the techniques for making contexts well-formed, discussed in Section 4.1, only exacerbate the problem: More precise means of distinguishing sets of objects translates to more concepts. <p> Concept analysis has been applied to many kinds of problems. Concept analysis was first applied to software engineering in the NORA/RECS tool, where it was used to identify conflicts in software-configuration information [21]. Contemporaneously with our own work, Lindig and Snelting <ref> [13] </ref> and Sahraoui et al. [18] independently explored the idea of applying concept analysis to the modularization problem. In both of these studies, the context relations used for concept analysis relate each function of the program to the global variables accessed by the function.
Reference: [14] <author> Sying-Syang Liu and Norman Wilde. </author> <title> Identifying objects in a conventional procedural language: An example of data design recovery. </title> <booktitle> In Conference on Software Maintenance, </booktitle> <pages> pages 266-271. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> November </month> <year> 1990. </year>
Reference-contexts: each c 0 2 covs (c) [8] p 0 p subs (c 0 ) [9] if ( p 0 ) " c 0 = ; // if p 0 and c 0 are disjoint [10] p 00 p 0 [ fc 0 g [12] P P [ fp 00 g <ref> [14] </ref> endif [15] endif [16] endfor [17] endfor [18] endwhile subdivide the seed sets). A proof of the correctness of the algorithm can be found in Appendix A. 5 Implementation and Results We have implemented a prototype tool that employs concept analysis to discover potential modularizations of C programs. <p> Given that some user interaction will be required, the concept-analysis approach offers certain advantages over other previously proposed techniques (e.g., <ref> [14, 5, 16, 15, 2] </ref>), namely, the ability to "stay within the system" (as opposed to applying ad hoc methods) when the user judges that the modularization that the system suggests is unsatisfactory. <p> The reader is referred to [2, pp. 27-32] for an extensive discussion of the literature on the modularization problem. In the remainder of this section, we discuss only the work that is most relevant to the approach we have taken. Liu and Wilde <ref> [14] </ref> make use of a table that is very much like the object-attribute relation of a context. However, whereas our work uses concept analysis to analyze such tables, Liu and Wilde propose a less powerful analysis. <p> The second type, "spurious links", is caused by functions that access supporting data structures of more than one object type. In most of the approaches mentioned above, spurious links arise from a function that accesses several global variables of different types. The work described in <ref> [14, 5, 15, 24, 2] </ref> will all stumble on examples that exhibit spurious links. In our approach, an analogous kind of spurious link arises due to functions that access internal fields of more than one struct.
Reference: [15] <author> Panos E. Livadas and Theodore Johnson. </author> <title> A new approach to finding objects in programs. Software Maintenance: </title> <journal> Research and Practice, </journal> <volume> 6 </volume> <pages> 249-260, </pages> <year> 1994. </year>
Reference-contexts: 0 2 covs (c) [8] p 0 p subs (c 0 ) [9] if ( p 0 ) " c 0 = ; // if p 0 and c 0 are disjoint [10] p 00 p 0 [ fc 0 g [12] P P [ fp 00 g [14] endif <ref> [15] </ref> endif [16] endfor [17] endfor [18] endwhile subdivide the seed sets). A proof of the correctness of the algorithm can be found in Appendix A. 5 Implementation and Results We have implemented a prototype tool that employs concept analysis to discover potential modularizations of C programs. <p> Given that some user interaction will be required, the concept-analysis approach offers certain advantages over other previously proposed techniques (e.g., <ref> [14, 5, 16, 15, 2] </ref>), namely, the ability to "stay within the system" (as opposed to applying ad hoc methods) when the user judges that the modularization that the system suggests is unsatisfactory. <p> The second type, "spurious links", is caused by functions that access supporting data structures of more than one object type. In most of the approaches mentioned above, spurious links arise from a function that accesses several global variables of different types. The work described in <ref> [14, 5, 15, 24, 2] </ref> will all stumble on examples that exhibit spurious links. In our approach, an analogous kind of spurious link arises due to functions that access internal fields of more than one struct.
Reference: [16] <author> Philip Newcomb. </author> <title> Reengineering procedural into object-oriented systems. </title> <booktitle> In Second Working Conference on Reverse Engineering, </booktitle> <pages> pages 237-249, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: covs (c) [8] p 0 p subs (c 0 ) [9] if ( p 0 ) " c 0 = ; // if p 0 and c 0 are disjoint [10] p 00 p 0 [ fc 0 g [12] P P [ fp 00 g [14] endif [15] endif <ref> [16] </ref> endfor [17] endfor [18] endwhile subdivide the seed sets). A proof of the correctness of the algorithm can be found in Appendix A. 5 Implementation and Results We have implemented a prototype tool that employs concept analysis to discover potential modularizations of C programs. <p> Given that some user interaction will be required, the concept-analysis approach offers certain advantages over other previously proposed techniques (e.g., <ref> [14, 5, 16, 15, 2] </ref>), namely, the ability to "stay within the system" (as opposed to applying ad hoc methods) when the user judges that the modularization that the system suggests is unsatisfactory.
Reference: [17] <author> Robert O'Callahan and Daniel Jackson. </author> <title> Practical program understanding with type inference. </title> <type> Technical Report CMU-CS-96-130, </type> <institution> Carnegie Mellon University, </institution> <month> May </month> <year> 1996. </year>
Reference-contexts: Attributes capturing this information might be of the form "may use a value that flows from statement s" or "is part of the slice with respect to statement s". * Information obtained from type inferencing: Type inference can be used to uncover distinctions between seemingly identical types (see <ref> [19, 17] </ref>). For example, if f is a function declared to be of type int fi int ! bool, type inference might discover that f 's most general type is of the form ff fi fi ! bool. <p> [8] p 0 p subs (c 0 ) [9] if ( p 0 ) " c 0 = ; // if p 0 and c 0 are disjoint [10] p 00 p 0 [ fc 0 g [12] P P [ fp 00 g [14] endif [15] endif [16] endfor <ref> [17] </ref> endfor [18] endwhile subdivide the seed sets). A proof of the correctness of the algorithm can be found in Appendix A. 5 Implementation and Results We have implemented a prototype tool that employs concept analysis to discover potential modularizations of C programs.
Reference: [18] <author> Houari A. Sahraoui, Walcelio Melo, Hakim Lounis, and Fran~cois Dumont. </author> <title> Applying concept formation methods to object identification in procedural code. </title> <type> Technical Report CRIM-97/05-77, </type> <institution> CRIM, </institution> <year> 1997. </year>
Reference-contexts: Other possibilities for attributes include the following: * Variable-usage information: Related functions can sometimes be identified by their use of common global variables. An attribute capturing this information might be of the form "uses global variable x" <ref> [13, 18] </ref>. * Dataflow and slicing information can be useful in identifying modules. <p> 0 p subs (c 0 ) [9] if ( p 0 ) " c 0 = ; // if p 0 and c 0 are disjoint [10] p 00 p 0 [ fc 0 g [12] P P [ fp 00 g [14] endif [15] endif [16] endfor [17] endfor <ref> [18] </ref> endwhile subdivide the seed sets). A proof of the correctness of the algorithm can be found in Appendix A. 5 Implementation and Results We have implemented a prototype tool that employs concept analysis to discover potential modularizations of C programs. <p> Concept analysis has been applied to many kinds of problems. Concept analysis was first applied to software engineering in the NORA/RECS tool, where it was used to identify conflicts in software-configuration information [21]. Contemporaneously with our own work, Lindig and Snelting [13] and Sahraoui et al. <ref> [18] </ref> independently explored the idea of applying concept analysis to the modularization problem. In both of these studies, the context relations used for concept analysis relate each function of the program to the global variables accessed by the function.
Reference: [19] <author> Michael Siff and Thomas Reps. </author> <title> Program generalization for software reuse: From C to C++. </title> <booktitle> In Fourth ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 135-146, </pages> <address> San Francisco, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: Attributes capturing this information might be of the form "may use a value that flows from statement s" or "is part of the slice with respect to statement s". * Information obtained from type inferencing: Type inference can be used to uncover distinctions between seemingly identical types (see <ref> [19, 17] </ref>). For example, if f is a function declared to be of type int fi int ! bool, type inference might discover that f 's most general type is of the form ff fi fi ! bool.
Reference: [20] <author> Michael Siff and Thomas Reps. </author> <title> Identifying modules via concept analysis. </title> <booktitle> In International Conference on Software Maintenance, </booktitle> <pages> pages 170-179, </pages> <address> Bari, Italy, </address> <month> October </month> <year> 1997. </year>
Reference-contexts: A major difficulty with software modularization is the accurate identification of potential modules and classes. This paper describes how a technique known fl A preliminary version of this paper appeared in the Proceedings of the International Conference on Software Maintenance <ref> [20] </ref>. Part of this research was done while Siff was a summer intern at Lucent Technologies.
Reference: [21] <author> Gregor Snelting. </author> <title> Reengineering of configurations based on mathematical concept analysis. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 5(2) </volume> <pages> 146-189, </pages> <month> April </month> <year> 1996. </year> <month> 39 </month>
Reference-contexts: An example of the application of the fundamental theorem is shown in Figure 4. There are several algorithms for computing the concept lattice for a given context <ref> [9, 21] </ref>. We describe a simple bottom-up algorithm here. An important fact about concepts and contexts used in the algorithm is that, given a set of objects X, the smallest concept with extent containing X is (t ((X)); (X)). <p> Concept analysis has been applied to many kinds of problems. Concept analysis was first applied to software engineering in the NORA/RECS tool, where it was used to identify conflicts in software-configuration information <ref> [21] </ref>. Contemporaneously with our own work, Lindig and Snelting [13] and Sahraoui et al. [18] independently explored the idea of applying concept analysis to the modularization problem.
Reference: [22] <author> Mark Weiser. </author> <title> Program slicing. </title> <journal> IEEE Transactions on Software Engineer--ing, </journal> <volume> SE-10(4):352-357, </volume> <month> July </month> <year> 1984. </year>
Reference-contexts: In such cases, it may be preferable to have objects correspond to slices <ref> [22, 10] </ref> rather than functions. 19 In practice, programs to be modularized will be much larger. <p> Canfora et al. discuss two types of links that cause undesirable clustering of functions [2]. The first type, "coincidental links", caused by routines that im 36 plement more than one function, can be overcome by program slicing <ref> [22, 10] </ref>. The second type, "spurious links", is caused by functions that access supporting data structures of more than one object type. In most of the approaches mentioned above, spurious links arise from a function that accesses several global variables of different types.
Reference: [23] <author> Rudolf Wille. </author> <title> Restructuring lattice theory: An approach based on hierarchies of concepts. </title> <editor> In Ivan Rival, editor, </editor> <booktitle> Ordered Sets, </booktitle> <pages> pages 445-470. </pages> <institution> NATO Advanced Study Institute, </institution> <month> September </month> <year> 1981. </year>
Reference-contexts: Section 5 discusses the implementation. Section 6 concerns related work. 2 A Concept-Analysis Primer Concept analysis provides a way to identify sensible groupings of objects that have common attributes <ref> [23] </ref>. To illustrate concept analysis, we consider the example of a crude classification of a group of mammals: cats, gibbons, dogs, dolphins, humans, and whales. Suppose we consider five attributes: four-legged, hair-covered, intelligent, marine, and thumbed. Table 1 shows which animals are considered to have which attributes. <p> The subconcept relation forms a complete partial order (the concept lattice) over the set of concepts. The concept lattice for the mammal example is shown in extent and intent of each concept is shown in Table 2. The fundamental theorem for concept lattices <ref> [23] </ref> relates subconcepts and superconcepts as follows: G (X i ; Y i ) = t " Y i ; i2I ! The significance of the theorem is that the least common superconcept of a set of concepts can be computed by intersecting their intents, and by finding the common objects <p> This work (implicitly or explicitly) involves the identification of potential modules by determining a similarity measure among pairs of functions. We are currently investigating the link between concept analysis and cluster analysis. [6] offers background on lattice theory and an introduction to concept analysis. <ref> [23] </ref> formalizes the notions of concept analysis and provides a proof of the fundamental theorem. Concept analysis has been applied to many kinds of problems. Concept analysis was first applied to software engineering in the NORA/RECS tool, where it was used to identify conflicts in software-configuration information [21].
Reference: [24] <author> Alexander Yeh, David R. Harris, and Howard B. Reubenstein. </author> <title> Recovering abstract data types and object instances from a conventional procedural language. </title> <booktitle> In Second Working Conference on Reverse Engineering, </booktitle> <pages> pages 227-236, </pages> <year> 1995. </year>
Reference-contexts: Although other modularization algorithms are able to identify the same decomposition <ref> [3, 24] </ref>, they are unable to handle a variant of this example in which stacks and queues are more tightly intertwined (see Section 3.2). In Section 3.2, we show that concept analysis is able to group the code from the latter example into separate queue and stack modules. <p> It is relatively straightforward to separate the code shown in Figure 1 into two modules, and techniques such as those described in <ref> [3, 24] </ref> will also create the same grouping. We now show that concept analysis offers the possibility to go beyond previously defined methods: It offers the ability to tease apart code that is, in some sense, more "tangled". <p> The second type, "spurious links", is caused by functions that access supporting data structures of more than one object type. In most of the approaches mentioned above, spurious links arise from a function that accesses several global variables of different types. The work described in <ref> [14, 5, 15, 24, 2] </ref> will all stumble on examples that exhibit spurious links. In our approach, an analogous kind of spurious link arises due to functions that access internal fields of more than one struct.
References-found: 24

