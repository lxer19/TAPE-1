URL: http://www.cs.wisc.edu/paradise/papers/extended.spjoin.ps
Refering-URL: http://www.cs.wisc.edu/paradise/paradise.papers.html
Root-URL: 
Email: fjignesh, dewittg@cs.wisc.edu  
Title: Partition Based Spatial-Merge Join  
Author: Jignesh M. Patel David J. DeWitt 
Address: Wisconsin, Madison  
Affiliation: Computer Sciences Department, University of  
Abstract: This paper describes PBSM (Partition Based Spatial-Merge), a new algorithm for performing spatial join operation. This algorithm is especially effective when neither of the inputs to the join have an index on the joining attribute. Such a situation could arise if both inputs to the join are intermediate results in a complex query, or in a parallel environment where the inputs must be dynamically redistributed. The PBSM algorithm partitions the inputs into manageable chunks, and joins them using a computational geometry based plane-sweeping technique. This paper also presents a performance study comparing the the traditional indexed nested loops join algorithm, a spatial join algorithm based on joining spatial indices, and the PBSM algorithm. These comparisons are based on complete implementations of these algorithms in Paradise, a database system for handling GIS applications. Using real data sets, the performance study examines the behavior of these spatial join algorithms in a variety of situations, including the cases when both, one, or none of the inputs to the join have an suitable index. The study also examines the effect of clustering the join inputs on the performance of these join algorithms. The performance comparisons demonstrates the feasibility, and applicability of the PBSM join algorithm.
Abstract-found: 1
Intro-found: 1
Reference: [Arc95] <author> ESRI, Redlands, </author> <title> CA. ARC/INFO: The World's GIS. An ESRI White Paper, </title> <month> March </month> <year> 1995. </year>
Reference-contexts: Increasingly, a database system has been employed to meet these requirements. Examples of commercial database systems that have been used for these applications are ARC/INFO <ref> [Arc95] </ref>, Intergraph's MGE [Cor95], and Illustra [Ube94]). Data stored in these spatial database systems includes simple geometric types like points, lines, polygons, and surfaces, and more complex types like swiss-cheese-polygons (which are polygons with holes) that are derived from the simpler geometric types. <p> To the best of our knowledge, most commercial spatial database systems do not transform the approximations of spatial objects into another domain (for example, ARC/INFO <ref> [Arc95] </ref>, and Illustra [Ube94]). The remainder of this section is organized as follows. First the index nested loops and the R-tree based join algorithms are described.
Reference: [Ben75] <author> J. L. Bentley. </author> <title> Multidimensional Binary Search Trees Used for Associative Searching. </title> <journal> In Communication of the ACM, </journal> <volume> volume 18(9), </volume> <month> September </month> <year> 1975. </year>
Reference-contexts: The algorithm for building the spatial join index requires grid files for indexing the spatial data, and uses these grid files to compute the spatial join index. Grid files [NHS84] and kd-trees <ref> [Ben75, Ben79] </ref> have also been employed for evaluating multi-attribute joins in the relational domain [KHT89, HNKT90, BHF93]. These methods can also be used for evaluating the filter step by storing the bounding box of the spatial objects as points in a higher dimension [BHF93].
Reference: [Ben79] <author> J. L. Bentley. </author> <title> Multidimensional Binary Search Trees in Database Applications. </title> <journal> In IEEE Transactions on Software Engineering, </journal> <volume> volume 5(4), </volume> <year> 1979. </year>
Reference-contexts: The algorithm for building the spatial join index requires grid files for indexing the spatial data, and uses these grid files to compute the spatial join index. Grid files [NHS84] and kd-trees <ref> [Ben75, Ben79] </ref> have also been employed for evaluating multi-attribute joins in the relational domain [KHT89, HNKT90, BHF93]. These methods can also be used for evaluating the filter step by storing the bounding box of the spatial objects as points in a higher dimension [BHF93].
Reference: [BHF93] <author> L. Becker, K. Hinrichs, and U. Finke. </author> <title> A New Algorithm for Computing Joins With Grid Files. </title> <journal> In IEEE Transactions on Knowledge and Data Engineering, </journal> <year> 1993. </year>
Reference-contexts: Numerous algorithms have been proposed to execute the filter step of a spatial join. Many of the earlier algorithms are based on transforming an approximation of a spatial object into another domain (e.g. a 1-dimensional domain), and performing the filter step in the new domain <ref> [OM88, Ore86, BHF93] </ref>. The drawback of this approach is that in the new domain some spatial proximity information is lost, making the algorithms complex and less efficient. <p> The algorithm for building the spatial join index requires grid files for indexing the spatial data, and uses these grid files to compute the spatial join index. Grid files [NHS84] and kd-trees [Ben75, Ben79] have also been employed for evaluating multi-attribute joins in the relational domain <ref> [KHT89, HNKT90, BHF93] </ref>. These methods can also be used for evaluating the filter step by storing the bounding box of the spatial objects as points in a higher dimension [BHF93]. <p> Grid files [NHS84] and kd-trees [Ben75, Ben79] have also been employed for evaluating multi-attribute joins in the relational domain [KHT89, HNKT90, BHF93]. These methods can also be used for evaluating the filter step by storing the bounding box of the spatial objects as points in a higher dimension <ref> [BHF93] </ref>. Recently, spatial index structures like R-trees [Gut84], R+-trees [CFR87], R*-trees [BKSS90], and PMR quad trees [NS86] have been used to speed up the evaluation of the spatial join. <p> To summarize, we can classify all these algorithms as shown in Table 1. Require Use of an Index Operate without an Index Transform the * Z-values [OM84], * Join Indices [Rot91] approximation into * Grid Files <ref> [HNKT90, BHF93] </ref> * Z-values [Ore86, OM88] another dimension * kd-trees [KHT89, HNKT90] Use the approximation * Synchronized Tree * External VLSI algo [GS87] directly in the Traversal [BKS93, G un93, HS95] * PBSM two dimensional space * Build 1 or 2 indices before joining [LR94, LR95] * Spatial Hash Join [LR96]
Reference: [BKS93] <author> T. Brinkhoff, H. P. Kriegel, and B. Seeger. </author> <title> Efficient Processing of Spatial Joins Using R-trees. </title> <booktitle> In Proceedings of the 1993 ACM-SIGMOD Conference, </booktitle> <address> Washington, DC, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: The drawback of this approach is that in the new domain some spatial proximity information is lost, making the algorithms complex and less efficient. Most of the newer algorithms are based on using spatial indices for performing the filter step of the spatial join <ref> [BKS93, G un93, HS95] </ref>, and require a spatial index on both the join inputs. These tree join algorithms can be described as synchronized depth-first searches of both indices, with the two depth-first searches being guided by hints from each other. <p> This study concludes that for low join selectivities, join indices usually provide the best join performance, but for higher join selectivities generalization trees are more efficient. The proposed join algorithm using the generalization trees, is similar to the join algorithm on R-trees proposed by Brinkhoff, Kriegel and Seeger <ref> [BKS93] </ref>. This algorithm can be used only if an R-tree index exists on both the join inputs, and can be described as a synchronized depth-first search of both indices, with the two depth-first searches being guided by hints from each other. <p> The algorithm for constructing the seeded tree uses the existing index on one of the two inputs as a starting point, and tries to minimize the number of random I/Os incurred during the tree construction. The two indices are then joined using the tree join algorithm described in <ref> [BKS93] </ref>. In [LR95], Lo and Ravishankar extend this work to handle the case when neither of the inputs have an index. In this approach, spatial sampling techniques are used for constructing seeded trees on both inputs, and the seeded trees are joined using the tree join algorithm of [BKS93]. <p> described in <ref> [BKS93] </ref>. In [LR95], Lo and Ravishankar extend this work to handle the case when neither of the inputs have an index. In this approach, spatial sampling techniques are used for constructing seeded trees on both inputs, and the seeded trees are joined using the tree join algorithm of [BKS93]. The problem of finding pairwise intersection between two sets of rectangles has been extensively studied in the VLSI domain [MC80], and numerous solutions exist for the case when both the input set of rectangles fit in mem 3 ory [PS88]. <p> Require Use of an Index Operate without an Index Transform the * Z-values [OM84], * Join Indices [Rot91] approximation into * Grid Files [HNKT90, BHF93] * Z-values [Ore86, OM88] another dimension * kd-trees [KHT89, HNKT90] Use the approximation * Synchronized Tree * External VLSI algo [GS87] directly in the Traversal <ref> [BKS93, G un93, HS95] </ref> * PBSM two dimensional space * Build 1 or 2 indices before joining [LR94, LR95] * Spatial Hash Join [LR96] Table 1: Classification of Various Spatial Join Algorithms 3 Partition Based Spatial-Merge Join This section describes a new algorithm, called the Partition Based Spatial-Merge (PBSM) join, for <p> This technique, which was also used in <ref> [BKS93] </ref> for joining the entries of two R*-tree nodes, can be thought of as the spatial equivalent of the sort-merge algorithm. The details of the algorithm for merging the partitions R kp kp i are as follows. <p> The first algorithm is based on the traditional indexed nested loops algorithm and the other is based on the R-tree join algorithm <ref> [BKS93] </ref>. These algorithms use spatial indices, and were chosen because most spatial databases support some form of spatial indexing (for example, R-trees in Illustra [Ube94]). Such systems can easily use these index based join algorithms. <p> The two indices are then joined using the R-tree join algorithm proposed in <ref> [BKS93] </ref>. The R-tree join algorithm performs a synchronous depth-first traversal of the two trees. The traversal starts with the roots of the two R-trees, and moves down the levels of the two trees in tandem until the leaf nodes are reached. <p> Joining two nodes requires finding all bounding boxes in the first node that intersect with some bounding box in the other node. The child pointers corresponding to such matching bounding boxes are then traversed (resulting in a depth-first traversal). The R-tree join algorithm of <ref> [BKS93] </ref> only performs the filter step of the spatial join, and produces a set of candidate OID pairs corresponding to the objects whose MBRs intersect. The objects corresponding to these OIDs then have to be fetched and checked to determine if the join predicate is actually satisfied.
Reference: [BKSS90] <author> N. Beckmann, H. P. Kriegel, R. Schneider, and B. Seeger. </author> <title> The R*-tree: An Efficient and Robust Access Method for Points and Rectangles. </title> <booktitle> In Proceedings of the 1990 ACM-SIGMOD Conference, </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: These methods can also be used for evaluating the filter step by storing the bounding box of the spatial objects as points in a higher dimension [BHF93]. Recently, spatial index structures like R-trees [Gut84], R+-trees [CFR87], R*-trees <ref> [BKSS90] </ref>, and PMR quad trees [NS86] have been used to speed up the evaluation of the spatial join.
Reference: [BKSS94] <author> T. Brinkhoff, H. P. Kriegel, R. Schneider, and B. Seeger. </author> <title> Multi-step Processing of Spatial Joins. </title> <booktitle> In Proceedings of the 1994 ACM-SIGMOD Conference, </booktitle> <address> Minneapolis, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: This check for containment is currently implemented in Paradise using a naive O (n 2 ) algorithm (n is the number of points in a polygon). There are a number of techniques for reducing the cost of this part of the join <ref> [BKSS94] </ref> (by an order of magnitude in many cases). These techniques rely on using as a filter in the refinement step, extra information that is precom-puted and stored along with each spatial feature.
Reference: [Bur86] <author> P. A. Burrough. </author> <title> Principles of Geographic Information Systems for Land Resources Assessment. </title> <publisher> Oxford University Press, </publisher> <year> 1986. </year>
Reference-contexts: Spatial database users frequently need to combine two spatial inputs based on some spatial relationship between the objects in the two inputs. For example, map overlap, which requires combining two maps to produce a third, is an important operation in a spatial database <ref> [Bur86, MGR91] </ref>. This operation of combining two inputs based on their spatial relationship is called a spatial join. Spatial joins, just like their counterparts in a relational system, are an expensive operation. Consequently, efficient spatial join algorithms are a critical component of any spatial database system.
Reference: [CDF + 94] <author> M. J. Carey, D. J. DeWitt, M. J. Franklin, N. E. Hall, M. McAuliffe, J. F. Naughton, D. T. Schuh, M. H. Solomon, C. K. Tan, O. Tsatalos, S. White, and M. J. Zwilling. </author> <title> Shoring up Persistent Applications. </title> <booktitle> In Proceedings of the 1994 ACM-SIGMOD Conference, </booktitle> <address> Minneapolis, Minnesota, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: Paradise is a database system that handles GIS type of applications. Paradise supports storing, browsing, and querying of geographic data sets. It uses an extended-relational data model and supports an extension of SQL as its query language. Paradise uses SHORE <ref> [CDF + 94] </ref> as its storage manager for persistent objects. The machine used for the study was a Sun SPARC-10/51 with 64 MBytes of memory, running SunOS Release 4.1.3. One Seagate 2GByte disk (3.5 SCSI, model # ST 12400N) was used as a raw device to hold the database.
Reference: [CFR87] <author> T. Sellis C. Faloutsos and N. Roussopoulos. </author> <title> Analysis of Object Oriented Spatial Access Methods. </title> <booktitle> In Proceedings of the 1987 ACM-SIGMOD Conference, </booktitle> <address> San Francisco, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: These methods can also be used for evaluating the filter step by storing the bounding box of the spatial objects as points in a higher dimension [BHF93]. Recently, spatial index structures like R-trees [Gut84], R+-trees <ref> [CFR87] </ref>, R*-trees [BKSS90], and PMR quad trees [NS86] have been used to speed up the evaluation of the spatial join.
Reference: [Cor95] <author> Intergraph Corporation. </author> <note> GIS/AM/FM Information. http://www.intergraph.com/utilmap.shtml, 1995. </note>
Reference-contexts: Increasingly, a database system has been employed to meet these requirements. Examples of commercial database systems that have been used for these applications are ARC/INFO [Arc95], Intergraph's MGE <ref> [Cor95] </ref>, and Illustra [Ube94]). Data stored in these spatial database systems includes simple geometric types like points, lines, polygons, and surfaces, and more complex types like swiss-cheese-polygons (which are polygons with holes) that are derived from the simpler geometric types.
Reference: [DKL + 94] <author> D. J. DeWitt, N. Kabra, J. Luo, J. M. Patel, and J. Yu. </author> <title> Client-Server Paradise. </title> <booktitle> In Proceedings of the 20th VLDB Conf., </booktitle> <address> Santiago, Chile, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: Second, it includes the results of a comprehensive performance study of three spatial join algorithms: a simple indexed nested loops based join algorithm, an R-tree based join algorithm, and the PBSM algorithm. The performance study is based on actual implementations of the three algorithms in Paradise <ref> [DKL + 94] </ref>, which is an experimental GIS database system. <p> This sorting brings together key-pointers whose joining attributes are spatially close. The spatial index, which in our case is a R*-tree, is then built in a bottom up fashion <ref> [DKL + 94] </ref>. After building the index on the join attribute of R, a scan is started on S. Each tuple of S is used to probe the index on R. The result of the probe is a set of (possibly empty) OIDs of R. <p> For this, we use the same technique that was used in the PBSM join algorithm (refer to Section 3.2). 4.3 Methodology For the performance comparison, we implemented each of these algorithms, namely, indexed nested loops join, R-tree based join and the PBSM join in Paradise <ref> [DKL + 94] </ref>. Paradise is a database system that handles GIS type of applications. Paradise supports storing, browsing, and querying of geographic data sets. It uses an extended-relational data model and supports an extension of SQL as its query language. <p> Parallelizing PBSM, would require a strategy for declustering spatial objects. The spatial partitioning function that is used by PBSM for partitioning large inputs, can also be used for declustering spatial data. We are currently examining these issues in the broader context of extending Paradise <ref> [DKL + 94] </ref> to run on shared-nothing architectures [Sto86]. Parallel spatial databases are emerging as an attractive solution for storing and manipulating large volumes of spatial data [DLPY93], and some techniques for declustering spatial data have recently been proposed [TY95].
Reference: [DLPY93] <author> D. J. DeWitt, J. Luo, J. M. Patel, and J. Yu. </author> <title> Paradise A Parallel Geographic Information System. </title> <booktitle> In Proceedings of the ACM Workshop on Advances in Geographic Information Systems, </booktitle> <address> Arlington, Virginia, </address> <month> November </month> <year> 1993. </year>
Reference-contexts: We are currently examining these issues in the broader context of extending Paradise [DKL + 94] to run on shared-nothing architectures [Sto86]. Parallel spatial databases are emerging as an attractive solution for storing and manipulating large volumes of spatial data <ref> [DLPY93] </ref>, and some techniques for declustering spatial data have recently been proposed [TY95]. However, unless the spatial data is uniformly distributed, these techniques can result in unbalanced partitions.
Reference: [DNSS92] <author> D. J. DeWitt, J. F. Naughton, D. A. Schneider, and S. Seshadri. </author> <title> Practical Skew Handling in Parallel Joins. </title> <booktitle> In Proceedings of the 19th VLDB Conf., </booktitle> <month> August </month> <year> 1992. </year>
Reference-contexts: Consequently, the key-pointer element for the object shown in Figure 4, will be inserted to partitions 0, 1 and 2. The spatial partitioning function just described is the spatial analog of virtual processor round robin partitioning for handling skews in parallel relational joins <ref> [DNSS92] </ref>. <p> However, unless the spatial data is uniformly distributed, these techniques can result in unbalanced partitions. We feel that our spatial partitioning function using tiling, which is the spatial equivalent of virtual processor partitioning in a parallel relational system <ref> [DNSS92] </ref>, would probably adapt better to different data distributions.
Reference: [GS87] <author> R. H. G uting and W. Shilling. </author> <title> A Practical Divide-and-Conquer Algorithm for the Rectangle Intersection Problem. </title> <journal> In Information Sciences, </journal> <volume> volume 42, </volume> <year> 1987. </year>
Reference-contexts: Another solution to this problem comes from the VLSI domain where one needs to compute the pairwise intersection between two potentially large sets of rectangles that don't fit entirely in main memory <ref> [GS87] </ref>. However, the VLSI algorithms are generally not very efficient with respect to the number of disk I/Os. This paper makes two contributions. First, it presents a new spatial join algorithm, called the Partition Based Spatial-Merge (PBSM) Join, that does not require indices on either of its inputs. <p> The problem of finding pairwise intersection between two sets of rectangles has been extensively studied in the VLSI domain [MC80], and numerous solutions exist for the case when both the input set of rectangles fit in mem 3 ory [PS88]. In <ref> [GS87] </ref>, G uting and Shilling examine the rectangle intersection problem when the inputs are too large to fit in memory, and analyze the time and space complexity of two algorithms that are based on external computational geometry algorithms. <p> Require Use of an Index Operate without an Index Transform the * Z-values [OM84], * Join Indices [Rot91] approximation into * Grid Files [HNKT90, BHF93] * Z-values [Ore86, OM88] another dimension * kd-trees [KHT89, HNKT90] Use the approximation * Synchronized Tree * External VLSI algo <ref> [GS87] </ref> directly in the Traversal [BKS93, G un93, HS95] * PBSM two dimensional space * Build 1 or 2 indices before joining [LR94, LR95] * Spatial Hash Join [LR96] Table 1: Classification of Various Spatial Join Algorithms 3 Partition Based Spatial-Merge Join This section describes a new algorithm, called the Partition
Reference: [G un93] <author> O. G unther. </author> <title> Efficient Computation of Spatial Joins. </title> <journal> In IEEE Transactions on Knowledge and Data Engineering, </journal> <year> 1993. </year>
Reference-contexts: The drawback of this approach is that in the new domain some spatial proximity information is lost, making the algorithms complex and less efficient. Most of the newer algorithms are based on using spatial indices for performing the filter step of the spatial join <ref> [BKS93, G un93, HS95] </ref>, and require a spatial index on both the join inputs. These tree join algorithms can be described as synchronized depth-first searches of both indices, with the two depth-first searches being guided by hints from each other. <p> Using analytical models, G unther compares join algorithms that use generalization trees (which is a class of tree structures that includes the R-tree, R*-tree and R+tree) with the nested loops join and join indices <ref> [G un93] </ref>. This study concludes that for low join selectivities, join indices usually provide the best join performance, but for higher join selectivities generalization trees are more efficient. <p> Require Use of an Index Operate without an Index Transform the * Z-values [OM84], * Join Indices [Rot91] approximation into * Grid Files [HNKT90, BHF93] * Z-values [Ore86, OM88] another dimension * kd-trees [KHT89, HNKT90] Use the approximation * Synchronized Tree * External VLSI algo [GS87] directly in the Traversal <ref> [BKS93, G un93, HS95] </ref> * PBSM two dimensional space * Build 1 or 2 indices before joining [LR94, LR95] * Spatial Hash Join [LR96] Table 1: Classification of Various Spatial Join Algorithms 3 Partition Based Spatial-Merge Join This section describes a new algorithm, called the Partition Based Spatial-Merge (PBSM) join, for
Reference: [Gut84] <author> A. Gutman. R-trees: </author> <title> A Dynamic Index Structure for Spatial Searching. </title> <booktitle> In Proceedings of the 1984 ACM-SIGMOD Conference, </booktitle> <address> Boston, Mass, </address> <month> June </month> <year> 1984. </year>
Reference-contexts: These methods can also be used for evaluating the filter step by storing the bounding box of the spatial objects as points in a higher dimension [BHF93]. Recently, spatial index structures like R-trees <ref> [Gut84] </ref>, R+-trees [CFR87], R*-trees [BKSS90], and PMR quad trees [NS86] have been used to speed up the evaluation of the spatial join.
Reference: [HNKT90] <author> L. Harada, M. Nakano, M. Kitsuregawa, and M. Takagi. </author> <title> Query Processing Methods for Multi-Attribute Clustered Relations. </title> <booktitle> In Proceedings of the 16th VLDB Conf., </booktitle> <address> Brisbane, Australia, </address> <year> 1990. </year>
Reference-contexts: The algorithm for building the spatial join index requires grid files for indexing the spatial data, and uses these grid files to compute the spatial join index. Grid files [NHS84] and kd-trees [Ben75, Ben79] have also been employed for evaluating multi-attribute joins in the relational domain <ref> [KHT89, HNKT90, BHF93] </ref>. These methods can also be used for evaluating the filter step by storing the bounding box of the spatial objects as points in a higher dimension [BHF93]. <p> To summarize, we can classify all these algorithms as shown in Table 1. Require Use of an Index Operate without an Index Transform the * Z-values [OM84], * Join Indices [Rot91] approximation into * Grid Files <ref> [HNKT90, BHF93] </ref> * Z-values [Ore86, OM88] another dimension * kd-trees [KHT89, HNKT90] Use the approximation * Synchronized Tree * External VLSI algo [GS87] directly in the Traversal [BKS93, G un93, HS95] * PBSM two dimensional space * Build 1 or 2 indices before joining [LR94, LR95] * Spatial Hash Join [LR96] <p> To summarize, we can classify all these algorithms as shown in Table 1. Require Use of an Index Operate without an Index Transform the * Z-values [OM84], * Join Indices [Rot91] approximation into * Grid Files [HNKT90, BHF93] * Z-values [Ore86, OM88] another dimension * kd-trees <ref> [KHT89, HNKT90] </ref> Use the approximation * Synchronized Tree * External VLSI algo [GS87] directly in the Traversal [BKS93, G un93, HS95] * PBSM two dimensional space * Build 1 or 2 indices before joining [LR94, LR95] * Spatial Hash Join [LR96] Table 1: Classification of Various Spatial Join Algorithms 3 Partition
Reference: [HS95] <author> E. G. Hoel and H. Samet. </author> <title> Benchmarking Spatial Join Operations with Spatial Output. </title> <booktitle> In Proceedings of the 21st VLDB Conf., </booktitle> <address> Zurich, Switzerland, </address> <month> September </month> <year> 1995. </year>
Reference-contexts: The drawback of this approach is that in the new domain some spatial proximity information is lost, making the algorithms complex and less efficient. Most of the newer algorithms are based on using spatial indices for performing the filter step of the spatial join <ref> [BKS93, G un93, HS95] </ref>, and require a spatial index on both the join inputs. These tree join algorithms can be described as synchronized depth-first searches of both indices, with the two depth-first searches being guided by hints from each other. <p> The study also investigates the effect of clustering the join inputs. Many of the tree-based join algorithms that have been considered in earlier performance studies, use multiple inserts to build an index <ref> [HS95, LR94] </ref>. It is a well known fact that bulk loading an index is much more efficient than performing multiple inserts to construct it. <p> Similar tree joins have been proposed for other data structures. In <ref> [HS95] </ref>, Hoel and Samet propose a tree join algorithm for the PMR quad tree, and compare the efficiency of variants of the PMR quad tree with variants of the R-tree [HS95]. <p> Similar tree joins have been proposed for other data structures. In <ref> [HS95] </ref>, Hoel and Samet propose a tree join algorithm for the PMR quad tree, and compare the efficiency of variants of the PMR quad tree with variants of the R-tree [HS95]. When one of the inputs to the spatial join does not have a spatial index, Lo and Ravishankar [LR94] propose building a seeded tree index on that input. A seeded tree is a R-tree that is allowed to be height unbalanced. <p> Require Use of an Index Operate without an Index Transform the * Z-values [OM84], * Join Indices [Rot91] approximation into * Grid Files [HNKT90, BHF93] * Z-values [Ore86, OM88] another dimension * kd-trees [KHT89, HNKT90] Use the approximation * Synchronized Tree * External VLSI algo [GS87] directly in the Traversal <ref> [BKS93, G un93, HS95] </ref> * PBSM two dimensional space * Build 1 or 2 indices before joining [LR94, LR95] * Spatial Hash Join [LR96] Table 1: Classification of Various Spatial Join Algorithms 3 Partition Based Spatial-Merge Join This section describes a new algorithm, called the Partition Based Spatial-Merge (PBSM) join, for
Reference: [KHT89] <author> M. Kitsuregawa, L. Harada, and M. Takagi. </author> <title> Join Strategies on KD-Tree Indexed Relations. </title> <journal> In IEEE Transactions on Knowledge and Data Engineering, </journal> <year> 1989. </year>
Reference-contexts: The algorithm for building the spatial join index requires grid files for indexing the spatial data, and uses these grid files to compute the spatial join index. Grid files [NHS84] and kd-trees [Ben75, Ben79] have also been employed for evaluating multi-attribute joins in the relational domain <ref> [KHT89, HNKT90, BHF93] </ref>. These methods can also be used for evaluating the filter step by storing the bounding box of the spatial objects as points in a higher dimension [BHF93]. <p> To summarize, we can classify all these algorithms as shown in Table 1. Require Use of an Index Operate without an Index Transform the * Z-values [OM84], * Join Indices [Rot91] approximation into * Grid Files [HNKT90, BHF93] * Z-values [Ore86, OM88] another dimension * kd-trees <ref> [KHT89, HNKT90] </ref> Use the approximation * Synchronized Tree * External VLSI algo [GS87] directly in the Traversal [BKS93, G un93, HS95] * PBSM two dimensional space * Build 1 or 2 indices before joining [LR94, LR95] * Spatial Hash Join [LR96] Table 1: Classification of Various Spatial Join Algorithms 3 Partition
Reference: [LR94] <author> M. L. Lo and C. V. Ravishankar. </author> <title> Spatial Joins Using Seeded Trees. </title> <booktitle> In Proceedings of the 1994 ACM-SIGMOD Conference, </booktitle> <address> Minneapolis, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: The study also investigates the effect of clustering the join inputs. Many of the tree-based join algorithms that have been considered in earlier performance studies, use multiple inserts to build an index <ref> [HS95, LR94] </ref>. It is a well known fact that bulk loading an index is much more efficient than performing multiple inserts to construct it. <p> When one of the inputs to the spatial join does not have a spatial index, Lo and Ravishankar <ref> [LR94] </ref> propose building a seeded tree index on that input. A seeded tree is a R-tree that is allowed to be height unbalanced. <p> [Rot91] approximation into * Grid Files [HNKT90, BHF93] * Z-values [Ore86, OM88] another dimension * kd-trees [KHT89, HNKT90] Use the approximation * Synchronized Tree * External VLSI algo [GS87] directly in the Traversal [BKS93, G un93, HS95] * PBSM two dimensional space * Build 1 or 2 indices before joining <ref> [LR94, LR95] </ref> * Spatial Hash Join [LR96] Table 1: Classification of Various Spatial Join Algorithms 3 Partition Based Spatial-Merge Join This section describes a new algorithm, called the Partition Based Spatial-Merge (PBSM) join, for evaluating a spatial join.
Reference: [LR95] <author> M. L. Lo and C. V. Ravishankar. </author> <title> Generating Seeded Trees From Data Sets. </title> <booktitle> In Proceedings of the Fourth International Symposium on Large Spatial Databases, </booktitle> <address> Portland, ME, </address> <month> August </month> <year> 1995. </year>
Reference-contexts: A spatial DBMS must evaluate these joins efficiently. One solution to this problem is to build a spatial index on both inputs and then use a tree join algorithm <ref> [LR95] </ref>. Another solution to this problem comes from the VLSI domain where one needs to compute the pairwise intersection between two potentially large sets of rectangles that don't fit entirely in main memory [GS87]. <p> The two indices are then joined using the tree join algorithm described in [BKS93]. In <ref> [LR95] </ref>, Lo and Ravishankar extend this work to handle the case when neither of the inputs have an index. In this approach, spatial sampling techniques are used for constructing seeded trees on both inputs, and the seeded trees are joined using the tree join algorithm of [BKS93]. <p> [Rot91] approximation into * Grid Files [HNKT90, BHF93] * Z-values [Ore86, OM88] another dimension * kd-trees [KHT89, HNKT90] Use the approximation * Synchronized Tree * External VLSI algo [GS87] directly in the Traversal [BKS93, G un93, HS95] * PBSM two dimensional space * Build 1 or 2 indices before joining <ref> [LR94, LR95] </ref> * Spatial Hash Join [LR96] Table 1: Classification of Various Spatial Join Algorithms 3 Partition Based Spatial-Merge Join This section describes a new algorithm, called the Partition Based Spatial-Merge (PBSM) join, for evaluating a spatial join.
Reference: [LR96] <author> M. L. Lo and C. V. Ravishankar. </author> <title> Spatial Hash-Joins. </title> <booktitle> In Proceedings of the 1996 ACM-SIGMOD Conference, </booktitle> <address> Montreal, Canada, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: However, these algorithms are not very efficient with respect to the number of disk I/Os, and in some cases require logarithmic number of passes over the input. Concurrent with our work on PBSM, Lo and Ravishankar have proposed a spatial hash join algorithm <ref> [LR96] </ref> that is, in many aspects, similar to PBSM. The spatial hash algorithm first partitions both the inputs, and then joins each of the partitions. Upper levels of a seeded tree are used for the partition function, and a filtering technique is employed during the partitioning phase. <p> Upper levels of a seeded tree are used for the partition function, and a filtering technique is employed during the partitioning phase. A performance study, based on counting the number of disk I/Os, is also presented in <ref> [LR96] </ref>. [LR96] ignores the very expensive refinement step. To summarize, we can classify all these algorithms as shown in Table 1. <p> Upper levels of a seeded tree are used for the partition function, and a filtering technique is employed during the partitioning phase. A performance study, based on counting the number of disk I/Os, is also presented in <ref> [LR96] </ref>. [LR96] ignores the very expensive refinement step. To summarize, we can classify all these algorithms as shown in Table 1. <p> [HNKT90, BHF93] * Z-values [Ore86, OM88] another dimension * kd-trees [KHT89, HNKT90] Use the approximation * Synchronized Tree * External VLSI algo [GS87] directly in the Traversal [BKS93, G un93, HS95] * PBSM two dimensional space * Build 1 or 2 indices before joining [LR94, LR95] * Spatial Hash Join <ref> [LR96] </ref> Table 1: Classification of Various Spatial Join Algorithms 3 Partition Based Spatial-Merge Join This section describes a new algorithm, called the Partition Based Spatial-Merge (PBSM) join, for evaluating a spatial join. For the sake of concreteness, let R and S denote the two inputs to the join.
Reference: [MC80] <author> C. Mead and L. Conway. </author> <title> Introduction to VLSI Systems. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1980. </year>
Reference-contexts: In this approach, spatial sampling techniques are used for constructing seeded trees on both inputs, and the seeded trees are joined using the tree join algorithm of [BKS93]. The problem of finding pairwise intersection between two sets of rectangles has been extensively studied in the VLSI domain <ref> [MC80] </ref>, and numerous solutions exist for the case when both the input set of rectangles fit in mem 3 ory [PS88].
Reference: [MGR91] <author> D. J. Maguire, M. F. Goodchild, and D. W. </author> <title> Rhind. </title> <journal> Geographic Information Systems, </journal> <volume> volume 1. </volume> <publisher> Longman Scientific & Technical, copublished in the US with John Wiley & Sons, Inc. </publisher> <address> New York, </address> <year> 1991. </year>
Reference-contexts: Spatial database users frequently need to combine two spatial inputs based on some spatial relationship between the objects in the two inputs. For example, map overlap, which requires combining two maps to produce a third, is an important operation in a spatial database <ref> [Bur86, MGR91] </ref>. This operation of combining two inputs based on their spatial relationship is called a spatial join. Spatial joins, just like their counterparts in a relational system, are an expensive operation. Consequently, efficient spatial join algorithms are a critical component of any spatial database system.
Reference: [NHS84] <author> J. Nievergelt, H. Hinterberger, and K. C. Sevcik. </author> <title> The Grid File: An Adaptable, Symmetric Multikey File Structure. </title> <journal> ACM Transactions on Database Systems, </journal> <month> March </month> <year> 1984. </year>
Reference-contexts: The algorithm for building the spatial join index requires grid files for indexing the spatial data, and uses these grid files to compute the spatial join index. Grid files <ref> [NHS84] </ref> and kd-trees [Ben75, Ben79] have also been employed for evaluating multi-attribute joins in the relational domain [KHT89, HNKT90, BHF93]. These methods can also be used for evaluating the filter step by storing the bounding box of the spatial objects as points in a higher dimension [BHF93].
Reference: [NS86] <author> R. C. Nelson and H. Samet. </author> <title> A Consistent Hierarchical Representation for Vector Data. </title> <journal> In Computer Graphics, </journal> <volume> volume 20(4), </volume> <month> August </month> <year> 1986. </year>
Reference-contexts: These methods can also be used for evaluating the filter step by storing the bounding box of the spatial objects as points in a higher dimension [BHF93]. Recently, spatial index structures like R-trees [Gut84], R+-trees [CFR87], R*-trees [BKSS90], and PMR quad trees <ref> [NS86] </ref> have been used to speed up the evaluation of the spatial join. Using analytical models, G unther compares join algorithms that use generalization trees (which is a class of tree structures that includes the R-tree, R*-tree and R+tree) with the nested loops join and join indices [G un93].
Reference: [OM84] <author> J. A. Orenstein and T. H. Merrett. </author> <title> A Class of Data Structures for Associative Searching. </title> <booktitle> In Proceedings of the 3rd ACM SIGACT-SIGMOD Symposium on Principles of Database Systems, </booktitle> <year> 1984. </year>
Reference-contexts: The transformed values, which are called z-values, are then used in a spatial join algorithm that merges two sequences of z-values. The z-values, being 1-dimensional values, can be stored in traditional indexing structures like a B-tree <ref> [OM84] </ref>. The performance of the spatial join algorithm using z-values was found to be sensitive to the choice of the grid [Ore89]. <p> A performance study, based on counting the number of disk I/Os, is also presented in [LR96]. [LR96] ignores the very expensive refinement step. To summarize, we can classify all these algorithms as shown in Table 1. Require Use of an Index Operate without an Index Transform the * Z-values <ref> [OM84] </ref>, * Join Indices [Rot91] approximation into * Grid Files [HNKT90, BHF93] * Z-values [Ore86, OM88] another dimension * kd-trees [KHT89, HNKT90] Use the approximation * Synchronized Tree * External VLSI algo [GS87] directly in the Traversal [BKS93, G un93, HS95] * PBSM two dimensional space * Build 1 or 2
Reference: [OM88] <author> J. A. Orenstein and F. A. Manola. </author> <title> PROBE Spatial Data Modeling and Query Processing in an Image Database Application. </title> <journal> In IEEE Transactions on Software Engineering, </journal> <volume> volume 14(5), </volume> <month> May </month> <year> 1988. </year>
Reference-contexts: Numerous algorithms have been proposed to execute the filter step of a spatial join. Many of the earlier algorithms are based on transforming an approximation of a spatial object into another domain (e.g. a 1-dimensional domain), and performing the filter step in the new domain <ref> [OM88, Ore86, BHF93] </ref>. The drawback of this approach is that in the new domain some spatial proximity information is lost, making the algorithms complex and less efficient. <p> Most of the spatial join algorithms that have been proposed previously only solve the filter step. In this section, we summarize relevant work in this area. Throughout this section, we use the term spatial join to refer to the filter step of the spatial join. In <ref> [Ore86, OM88] </ref>, Orenstein proposes an approach based on approximate geometry, wherein the universe of the spatial data is regularly decomposed by superimposing a grid on it. Each element of the grid is called a pixel, and spatial objects are approximated by pixels that overlap them. <p> To summarize, we can classify all these algorithms as shown in Table 1. Require Use of an Index Operate without an Index Transform the * Z-values [OM84], * Join Indices [Rot91] approximation into * Grid Files [HNKT90, BHF93] * Z-values <ref> [Ore86, OM88] </ref> another dimension * kd-trees [KHT89, HNKT90] Use the approximation * Synchronized Tree * External VLSI algo [GS87] directly in the Traversal [BKS93, G un93, HS95] * PBSM two dimensional space * Build 1 or 2 indices before joining [LR94, LR95] * Spatial Hash Join [LR96] Table 1: Classification of
Reference: [Ore86] <author> J. A. Orenstein. </author> <title> Spatial Query Processing in an Object-Oriented Database System. </title> <booktitle> In Proceedings of the 1986 ACM-SIGMOD Conference, </booktitle> <year> 1986. </year>
Reference-contexts: Numerous algorithms have been proposed to execute the filter step of a spatial join. Many of the earlier algorithms are based on transforming an approximation of a spatial object into another domain (e.g. a 1-dimensional domain), and performing the filter step in the new domain <ref> [OM88, Ore86, BHF93] </ref>. The drawback of this approach is that in the new domain some spatial proximity information is lost, making the algorithms complex and less efficient. <p> Most of the spatial join algorithms that have been proposed previously only solve the filter step. In this section, we summarize relevant work in this area. Throughout this section, we use the term spatial join to refer to the filter step of the spatial join. In <ref> [Ore86, OM88] </ref>, Orenstein proposes an approach based on approximate geometry, wherein the universe of the spatial data is regularly decomposed by superimposing a grid on it. Each element of the grid is called a pixel, and spatial objects are approximated by pixels that overlap them. <p> To summarize, we can classify all these algorithms as shown in Table 1. Require Use of an Index Operate without an Index Transform the * Z-values [OM84], * Join Indices [Rot91] approximation into * Grid Files [HNKT90, BHF93] * Z-values <ref> [Ore86, OM88] </ref> another dimension * kd-trees [KHT89, HNKT90] Use the approximation * Synchronized Tree * External VLSI algo [GS87] directly in the Traversal [BKS93, G un93, HS95] * PBSM two dimensional space * Build 1 or 2 indices before joining [LR94, LR95] * Spatial Hash Join [LR96] Table 1: Classification of
Reference: [Ore89] <author> J. A. Orenstein. </author> <title> Redundancy in Spatial Databases. </title> <booktitle> In Proceedings of the 1989 ACM-SIGMOD Conference, </booktitle> <year> 1989. </year>
Reference-contexts: The z-values, being 1-dimensional values, can be stored in traditional indexing structures like a B-tree [OM84]. The performance of the spatial join algorithm using z-values was found to be sensitive to the choice of the grid <ref> [Ore89] </ref>. Choosing a fine grid increases the efficiency of the filtering technique, but it also increases the space requirement since a larger number of z-values are required to approximate an object.
Reference: [Ore90] <author> J. A. Orenstein. </author> <title> A Comparison of Spatial Query Processing Techniques for Native and Parameter Spaces. </title> <booktitle> In Proceedings of the 1990 ACM-SIGMOD Conference, </booktitle> <year> 1990. </year>
Reference-contexts: Since the representation of a spatial object can be very large (for example, a spatial object representing a swiss-cheese-polygon might require thousands of points to represent the exact geometric shape), spatial operations, including the spatial join, typically operate in two steps <ref> [Ore90] </ref>: fl This work was partially supported by NASA Contracts #USRA-5555-17, #NAGW-3895, and #NAGW-4229, and by an IBM Research Initiation Grant.
Reference: [PS88] <author> F. P. Preparata and M. I. Shamos, </author> <title> editors. Computational Geometry. </title> <publisher> Springer, </publisher> <year> 1988. </year>
Reference-contexts: The problem of finding pairwise intersection between two sets of rectangles has been extensively studied in the VLSI domain [MC80], and numerous solutions exist for the case when both the input set of rectangles fit in mem 3 ory <ref> [PS88] </ref>. In [GS87], G uting and Shilling examine the rectangle intersection problem when the inputs are too large to fit in memory, and analyze the time and space complexity of two algorithms that are based on external computational geometry algorithms. <p> The problem then simplifies to finding all M BRs in R kp that intersect with some M BR in S kp . Rectangle intersection (the M BRs are rectangles) has been extensively studied in the computational geometry field <ref> [PS88] </ref>. Given two sets of rectangles, such that both the sets fit entirely in main memory, efficient computational geometry algorithms, based on plane-sweeping techniques, exist for reporting all pairs of intersecting rectangles between the two sets. <p> For example, the key-pointer element for the object shown in Figure 1, will be inserted into partitions 0 and 2. 5 After both the inputs R and S have been partitioned, the algorithm joins the partitions using a computational geometry based plane-sweeping technique <ref> [PS88] </ref>. This technique, which was also used in [BKS93] for joining the entries of two R*-tree nodes, can be thought of as the spatial equivalent of the sort-merge algorithm. The details of the algorithm for merging the partitions R kp kp i are as follows. <p> The S tuples 1 This check for overlap can be speeded up by organizing the MBRs of S kp i that overlap with r along the x-axis in an interval-tree <ref> [PS88] </ref>. 6 are then read sequentially into memory, and the join attributes of the R and the S tuple are checked to determine whether they satisfy the join condition. 3.3 Determining the Number of Partitions The number of partitions for the PBSM algorithm can be estimated as follow.
Reference: [Rot91] <author> D. Rotem. </author> <title> Spatial Join Indices. </title> <journal> In IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> Kobe, </volume> <month> April </month> <year> 1991. </year>
Reference-contexts: In the relational domain, [Val87] proposed the use of join indices to improve the performance of the relational join operator. Drawing an analogy from this, Rotem <ref> [Rot91] </ref> proposed a spatial join index that partially precomputes the results of a spatial join. The algorithm for building the spatial join index requires grid files for indexing the spatial data, and uses these grid files to compute the spatial join index. <p> To summarize, we can classify all these algorithms as shown in Table 1. Require Use of an Index Operate without an Index Transform the * Z-values [OM84], * Join Indices <ref> [Rot91] </ref> approximation into * Grid Files [HNKT90, BHF93] * Z-values [Ore86, OM88] another dimension * kd-trees [KHT89, HNKT90] Use the approximation * Synchronized Tree * External VLSI algo [GS87] directly in the Traversal [BKS93, G un93, HS95] * PBSM two dimensional space * Build 1 or 2 indices before joining [LR94,
Reference: [SFGM93] <author> M. Stonebraker, J. Frew, K. Gardels, and J. Meredith. </author> <title> The SEQUOIA 2000 Storage Benchmark. </title> <booktitle> In Proceedings of the 1993 ACM-SIGMOD Conference, </booktitle> <address> Washington, D.C., </address> <month> May </month> <year> 1993. </year>
Reference-contexts: The performance study is based on actual implementations of the three algorithms in Paradise [DKL + 94], which is an experimental GIS database system. Using real data from the TIGER [Tig] and the Sequoia <ref> [SFGM93] </ref> data sets, the study examines the behavior of the algorithms in a variety of situations, including the cases when none, one, or both the inputs to the join have a suitable index. The study also investigates the effect of clustering the join inputs. <p> The first data set is derived from the TIGER/Line files [Tig], and represents roads in the state of Wisconsin. This data set is 62.4MB in size, and contains 456,613 tuples. The second data set contains the polygon data from the Sequoia benchmark <ref> [SFGM93] </ref>. This data set contains 58,115 polygons and is 21.9MB in size. First, we explore the design space of the spatial partitioning function using the Tiger data. Figure 5 shows the effect of increasing the number of tiles, and choosing different tile-to-partition mapping schemes. <p> For the third collection, the islands and polygon data sets from the Sequoia 2000 Storage Benchmark <ref> [SFGM93] </ref> were used. The polygon data set represents regions of homogeneous landuse characteristics in the State of Cal-ifornia and Nevada, while the island data set represents holes in the polygon data (example, a lake in a park).
Reference: [Sto86] <author> M. Stonebraker. </author> <title> The Case for Shared Nothing. </title> <journal> Database Engineering, </journal> <volume> 9(1), </volume> <year> 1986. </year>
Reference-contexts: The spatial partitioning function that is used by PBSM for partitioning large inputs, can also be used for declustering spatial data. We are currently examining these issues in the broader context of extending Paradise [DKL + 94] to run on shared-nothing architectures <ref> [Sto86] </ref>. Parallel spatial databases are emerging as an attractive solution for storing and manipulating large volumes of spatial data [DLPY93], and some techniques for declustering spatial data have recently been proposed [TY95]. However, unless the spatial data is uniformly distributed, these techniques can result in unbalanced partitions.
Reference: [Tig] <author> U. S. </author> <title> Bureau of the Census, </title> <address> Washington, DC. TIGER/Line Files(TM), </address> <note> 1992 Technical Documentation. </note>
Reference-contexts: The performance study is based on actual implementations of the three algorithms in Paradise [DKL + 94], which is an experimental GIS database system. Using real data from the TIGER <ref> [Tig] </ref> and the Sequoia [SFGM93] data sets, the study examines the behavior of the algorithms in a variety of situations, including the cases when none, one, or both the inputs to the join have a suitable index. The study also investigates the effect of clustering the join inputs. <p> For the tile-to-partition mapping scheme, one could use either round robin or hashing on the tile number. To explore these alternatives, we have chosen two data sets. The first data set is derived from the TIGER/Line files <ref> [Tig] </ref>, and represents roads in the state of Wisconsin. This data set is 62.4MB in size, and contains 456,613 tuples. The second data set contains the polygon data from the Sequoia benchmark [SFGM93]. This data set contains 58,115 polygons and is 21.9MB in size. <p> Both parts of the study used three collections of data sets. The first collection was derived from the TIGER/Line files <ref> [Tig] </ref> for the State of Wisconsin. The TIGER data is developed and distributed by the U.S. Bureau of the Census, and contains detailed geographic and cartographic information for the United States. From the TIGER files, three data sets were extracted (see Table 2).
Reference: [TY95] <author> K. L. Tan and J. X. Yu. </author> <title> A Performance Study of Declustering Strategies for Parallel Spatial Databases. </title> <booktitle> In The 6th International Conference on Database and Expert Systems Applications (DEXA), </booktitle> <address> London, United Kingdom, </address> <month> September </month> <year> 1995. </year>
Reference-contexts: The spatial partitioning function just described is the spatial analog of virtual processor round robin partitioning for handling skews in parallel relational joins [DNSS92]. A similar partitioning function has been independently proposed for redundancy-based declustering of spatial objects in a parallel spatial database <ref> [TY95] </ref>, but in that proposal the number of tiles always equals the number of partitions. 7 The design space for choosing the spatial partitioning function has two axes: the number of tiles used in the partitioning function, and the tile-to-partition mapping scheme. <p> Parallel spatial databases are emerging as an attractive solution for storing and manipulating large volumes of spatial data [DLPY93], and some techniques for declustering spatial data have recently been proposed <ref> [TY95] </ref>. However, unless the spatial data is uniformly distributed, these techniques can result in unbalanced partitions. We feel that our spatial partitioning function using tiling, which is the spatial equivalent of virtual processor partitioning in a parallel relational system [DNSS92], would probably adapt better to different data distributions. <p> Since the spatial partitioning function might map an input object to multiple outputs, one could either replicate such objects entirely, or replicate just the spatial approximation (like the minimum bounding rectangle). If the object is not replicated in its entirety (as in <ref> [TY95] </ref>), then remote fetches might be required, whereas if the object is fully replicated, remote fetches can be avoided at the expense of an increase in the amount of storage.
Reference: [Ube94] <author> M. Ubell. </author> <title> The Montage Extensible DataBlade Architecture. </title> <booktitle> In Proceedings of the 1994 ACM-SIGMOD Conference, </booktitle> <month> May </month> <year> 1994. </year>
Reference-contexts: Increasingly, a database system has been employed to meet these requirements. Examples of commercial database systems that have been used for these applications are ARC/INFO [Arc95], Intergraph's MGE [Cor95], and Illustra <ref> [Ube94] </ref>). Data stored in these spatial database systems includes simple geometric types like points, lines, polygons, and surfaces, and more complex types like swiss-cheese-polygons (which are polygons with holes) that are derived from the simpler geometric types. A spatial database system must support queries on these spatial objects efficiently. <p> The first algorithm is based on the traditional indexed nested loops algorithm and the other is based on the R-tree join algorithm [BKS93]. These algorithms use spatial indices, and were chosen because most spatial databases support some form of spatial indexing (for example, R-trees in Illustra <ref> [Ube94] </ref>). Such systems can easily use these index based join algorithms. This study, is not a meant to be a comprehensive performance study of all possible spatial join algorithms (refer to Table 1 for a classification of spatial join algorithms). <p> To the best of our knowledge, most commercial spatial database systems do not transform the approximations of spatial objects into another domain (for example, ARC/INFO [Arc95], and Illustra <ref> [Ube94] </ref>). The remainder of this section is organized as follows. First the index nested loops and the R-tree based join algorithms are described.
Reference: [Val87] <author> P. Valduriez. </author> <title> Join Indices. </title> <journal> In ACM TODS, </journal> <volume> volume 12(2), </volume> <year> 1987. </year>
Reference-contexts: Choosing a fine grid increases the efficiency of the filtering technique, but it also increases the space requirement since a larger number of z-values are required to approximate an object. In the relational domain, <ref> [Val87] </ref> proposed the use of join indices to improve the performance of the relational join operator. Drawing an analogy from this, Rotem [Rot91] proposed a spatial join index that partially precomputes the results of a spatial join. <p> The refinement step eliminates these duplicates, and examines the actual R and S tuples to determine if the attributes actually satisfy the join condition. To avoid random seeks in fetching the R and S tuples, a strategy similar to that used in <ref> [Val87] </ref> is employed. First, the OID pairs are sorted using OID R as the primary sort key and OID S as the secondary sort key. Duplicates entries are eliminated during this sort.
Reference: [ZG90] <author> H. Zeller and J. Gray. </author> <title> An Adaptive Hash Join Algorithm for Multiuser Environments. </title> <booktitle> In Proceedings of the 16th VLDB Conf., </booktitle> <address> Brisbane, Australia, </address> <year> 1990. </year> <month> 20 </month>
Reference-contexts: One possible way to handle this would be to dynamically repartition the overflown partition pair. Another alternative is to increase the number of partitions (limited to M ) and using schemes similar to those used by the Adaptive Hash join algorithm <ref> [ZG90] </ref>. However, the current implementation of PBSM does not incorporate any of these techniques. 4 Performance Evaluation In this section, we compare the PBSM join algorithm with two other spatial join algorithms.
References-found: 41

