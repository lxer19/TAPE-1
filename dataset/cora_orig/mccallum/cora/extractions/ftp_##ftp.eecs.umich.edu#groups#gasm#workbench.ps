URL: ftp://ftp.eecs.umich.edu/groups/gasm/workbench.ps
Refering-URL: http://www.eecs.umich.edu/gasm/papers.html
Root-URL: http://www.eecs.umich.edu
Title: The ASM Workbench: an Open and Extensible Tool Environment for Abstract State Machines  
Author: Giuseppe Del Castillo giusp@uni-paderborn.de 
Address: Furstenallee 11, 33102 Paderborn, Germany  
Affiliation: Heinz Nixdorf Institut, Universitat-GH Paderborn  
Abstract: Appropriate tool support is an essential factor for an effective application of formal methods to real-life specification and modelling tasks. However, the current state of the art of tool support for Abstract State Machines is not considered very satisfactory by practitioners. After discussing some possible reasons for this, we report about the ASM Workbench, an open and extensible tool environment developed in response to this situation. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> M. Anlauff, P. Kutter, and A. Pierantonio. </author> <title> Formal Aspects of and Development Environments for Montages. </title> <editor> In M. Sellink, editor, </editor> <booktitle> 2nd International Workshop on the Theory and Practice of Algebraic Specifications, Workshops in Computing, </booktitle> <address> Amsterdam, 1997. </address> <publisher> Springer. </publisher>
Reference-contexts: Most functional and object-oriented programming languages come with contructs for dealing with such structures (e.g. Haskell, ML, Pizza) or at least dispose of libraries containing generic implementations of them, e.g. the C++ Standard Template Library (STL) or the JGL library for Java. semantics <ref> [1] </ref>, which is based on a specialized version of ASMs, where the under-lying data model is constituted essentially by data- and control-flow diagrams.
Reference: 2. <author> B. Beckert and J. Posegga. </author> <title> leanEA: A Lean Evolving Algebra Compiler. </title> <editor> In H. Kleine Buning, editor, </editor> <booktitle> Computer Science Logic (Proc. of CSL'95), volume 1092 of LNCS, </booktitle> <pages> pages 64-85. </pages> <publisher> Springer, </publisher> <year> 1996. </year>
Reference-contexts: On one hand, there are several ASM interpreters <ref> [2, 10, 12] </ref>, which are incompatible with each other, do not support any kind of formal analysis, transformation or reasoning, and apparently can not be easily combined with other tools (e.g., verification tools); on the other hand, there have been some successful attempts to formally verify properties of systems specified by <p> In Sect. 3 we outline the ASM Workbench architecture, with particular emphasis on its extensibility and integrability with other tools, and describe the already developed tool components. Finally, we make some concluding remarks. 1 Prolog in leanEA <ref> [2] </ref>, Scheme in Dag Diesen's ASM interpreter [10], C in the Michigan ASM Interpreter [12]. 2 The ASM-SL Notation As a source language for writing ASM specifications to be processed by the tools of the ASM Workbench, we developed the ASM-SL notation 2 , which extends the basic language of Abstract <p> A significant example is given by the Montages technique for defining programming language 5 For instance, all the existing ASM interpreters rely on the underlying implementation language|C, Prolog, or Scheme|to define the data model <ref> [2, 10, ?] </ref>. In the context of formal verification, many researchers combined ASMs with their preferred verification tools (e.g., the theorem provers PVS [17] and KIV [14]). 6 Free types for short. 7 Most theorem provers, for instance, come with predefined theories for mathematical structures such as those mentioned above.
Reference: 3. <author> A. Blass, Y. Gurevich, and S. Shelah. </author> <title> Choiceless Polynomial Time. </title> <type> Technical Report CSE-TR-338-97, </type> <institution> EECS Dept., University of Michigan, </institution> <year> 1997. </year>
Reference-contexts: to include in the language a set of predefined types (e.g., booleans, integers, strings), generic mathematical structures (e.g., tuples, lists, sets) and a few simple but powerful constructions (freely generated types 6 , case distinction, recursion, and the framework of hereditarily finite sets introduced by Blass, Gurevich and Shelah in <ref> [3] </ref>), which prove to be particularly useful in software specification. <p> A natural first choice consists in adapting the well-known type system of Standard ML [13], based on parametric polymorphism, to ASMs (see [7] for details). 8 In ASM-SL, this type system has been combined with the framework of hereditarily finite sets (defined, untyped, in <ref> [3] </ref>). Finite sets over a type T are values of a predefined type SET (T ), where the type T of the elements of the set may be any ASM-SL type 9 . <p> We seriously consider to include this feature in the next version of ASM-SL as it is essential for computer-assisted verification of ASM-SL specifications. Note that such integrity constraints could also be used by a simulator to perform additional run-time checks on the values of 11 As in <ref> [3] </ref>, dynamic functions are always finite in ASM-SL (i.e., they yield undef everywhere, except on a finite number of points). 12 ASM-SL follows the definition of [3], where the range of forall rules is identified by set elements, and not by unary relations as in [11]. 13 External function are notoriously <p> Note that such integrity constraints could also be used by a simulator to perform additional run-time checks on the values of 11 As in <ref> [3] </ref>, dynamic functions are always finite in ASM-SL (i.e., they yield undef everywhere, except on a finite number of points). 12 ASM-SL follows the definition of [3], where the range of forall rules is identified by set elements, and not by unary relations as in [11]. 13 External function are notoriously the main expressive means to model environmental influences in ASM specifications.
Reference: 4. <author> E. Borger and J. Huggins. </author> <title> Abstract State Machines 1988-1998: Commented ASM Bibliography. </title> <note> Available in electronic form at http://www.eecs.umich.edu/gasm and http://www.uni-paderborn.de/cs/asm.html. </note>
Reference-contexts: Looking at the existing literature <ref> [4] </ref> it is easy to recognize that, in the case of Abstract State Machines (ASMs), the use of tools belonging to any of the above classes may result useful in applications: this applies to tools specifically developed to deal with ASM specifications|called ASM tools in the following| as well as to <p> Unfortunately, in spite of many years of successful application of Abstract State Machines in different domains <ref> [4] </ref> and of the availability of several ASM tools (developed independently by different researchers in the last few years), the tool support for ASMs is not yet very satisfactory.
Reference: 5. <author> G. Del Castillo. ASM-SL, </author> <title> a Specification Language based on Gurevich's Abstract State Machines: Introduction and Tutorial. </title> <note> Technical report (to appear), Univer-sitat-GH Paderborn, </note> <year> 1998. </year>
Reference-contexts: ae p contains the variables bound by p). 10 8 Extensions of this type system (e.g., the introduction of type classes) are also being considered. 9 Including, of course, SET (T 0 ) for any type T 0 . 10 Similar typing rules|covering all the ASM-SL constructs|can be found in <ref> [5] </ref>. For pragmatical reasons, ASM-SL also provides a predefined type of finite maps MAP (T 1 ; T 2 ) with the corresponding operations, as well as map comprehension terms (defined similarly as set comprehension terms).
Reference: 6. <author> G. Del Castillo and U. Glasser. </author> <title> Machine-supported execution and validation of high-level abstract state machine models. </title> <editor> In R. Berghammer and Y. Lakhnech, editors, </editor> <booktitle> Preliminary proceedings of the TOOLS'98 Workshop, Bericht Nr. 9803, </booktitle> <address> Christian-Albrechts-Universitat Kiel, </address> <month> June </month> <year> 1998. </year> <title> Fig. 1. The ASM Workbench's Graphical User Interface </title>
Reference-contexts: Obviously, the validation of ground models can only be done informally, by means of observation and experimentation. Thus, it is very useful to have executable specifications (see <ref> [6] </ref> for a more extensive discussion of this subject). 2.1 Definition of the Data Model The issue of specifying the data structures used within ASM computations (what we concisely refer to as the data model in this paper) is not considered in [11].
Reference: 7. <author> G. Del Castillo, Y. Gurevich, and K. Stroetmann. </author> <title> Typed abstract state machines. </title> <note> Submitted to Journal of Universal Computer Science, </note> <year> 1998. </year>
Reference-contexts: The requirement for a concise specification notation naturally leads to the selection of a type system which allows type inference. A natural first choice consists in adapting the well-known type system of Standard ML [13], based on parametric polymorphism, to ASMs (see <ref> [7] </ref> for details). 8 In ASM-SL, this type system has been combined with the framework of hereditarily finite sets (defined, untyped, in [3]).
Reference: 8. <author> G. Del Castillo and W. Hardt. </author> <title> Fast Dynamic Analysis of Complex HW/SW-Systems based on Abstract State Machine Models. </title> <booktitle> In Proc. of CODES/CASHE '98, </booktitle> <year> 1998. </year>
Reference-contexts: Both the language and the tool seem to be appropriate to model and simulate systems and languages at quite different levels of abstraction (compare, for instance, the while-language example of this paper and the instruction set model presented in <ref> [8] </ref>). Of course, tool support for ASMs should go much further than simple type-checking and simulation, and include static analysis, interfaces to verification tools, generation of efficient code, visualization of states in a graphical form.
Reference: 9. <author> L. Damas and R. Milner. </author> <title> Principal type schemes for functional programs. </title> <booktitle> In Proceedings of the 9th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 207-212, </pages> <year> 1982. </year>
Reference-contexts: Its core is an efficient implementation of the well-known unification-based type inference algorithm <ref> [9] </ref>, and can be used|even independently from the ASM interpreter|to check that ASMs are well-typed resp. to infer their signatures (signatures also include the named transition rules defined by ASM-SL transition definitions, e.g. ExecuteSeq : [STMT] or ExecuteWhile : TERM * STMT in the example).
Reference: 10. <author> D. Diesen. </author> <title> Specifying Algorithms Using Evolving Algebra. Implementation of Functional Programming Languages. Dr. scient. </title> <type> degree thesis, </type> <institution> University of Oslo, </institution> <month> March </month> <year> 1995. </year>
Reference-contexts: On one hand, there are several ASM interpreters <ref> [2, 10, 12] </ref>, which are incompatible with each other, do not support any kind of formal analysis, transformation or reasoning, and apparently can not be easily combined with other tools (e.g., verification tools); on the other hand, there have been some successful attempts to formally verify properties of systems specified by <p> In Sect. 3 we outline the ASM Workbench architecture, with particular emphasis on its extensibility and integrability with other tools, and describe the already developed tool components. Finally, we make some concluding remarks. 1 Prolog in leanEA [2], Scheme in Dag Diesen's ASM interpreter <ref> [10] </ref>, C in the Michigan ASM Interpreter [12]. 2 The ASM-SL Notation As a source language for writing ASM specifications to be processed by the tools of the ASM Workbench, we developed the ASM-SL notation 2 , which extends the basic language of Abstract State Machines defined in [11] by a <p> A significant example is given by the Montages technique for defining programming language 5 For instance, all the existing ASM interpreters rely on the underlying implementation language|C, Prolog, or Scheme|to define the data model <ref> [2, 10, ?] </ref>. In the context of formal verification, many researchers combined ASMs with their preferred verification tools (e.g., the theorem provers PVS [17] and KIV [14]). 6 Free types for short. 7 Most theorem provers, for instance, come with predefined theories for mathematical structures such as those mentioned above.
Reference: 11. <author> Y. Gurevich. </author> <title> Evolving Algebras 1993: Lipari Guide. </title> <editor> In E. Borger, editor, </editor> <booktitle> Specification and Validation Methods, </booktitle> <pages> pages 9-36. </pages> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference-contexts: Most of the available ASM tools rely on a host language|usually the implementation language 1 |in order to describe aspects of ASM specifications (e.g., the definition of static functions) which are not part of the basic ASM language defined in <ref> [11] </ref>. As a consequence, tools relying on different host languages (or even on different dialects or implementations of the same language) are not compatible with each other. <p> ASM interpreter [10], C in the Michigan ASM Interpreter [12]. 2 The ASM-SL Notation As a source language for writing ASM specifications to be processed by the tools of the ASM Workbench, we developed the ASM-SL notation 2 , which extends the basic language of Abstract State Machines defined in <ref> [11] </ref> by a few additional constructs, addressing pragmatical issues which arise in applications. <p> is very useful to have executable specifications (see [6] for a more extensive discussion of this subject). 2.1 Definition of the Data Model The issue of specifying the data structures used within ASM computations (what we concisely refer to as the data model in this paper) is not considered in <ref> [11] </ref>. In fact, one could use any of the existing approaches (algebraic or model-based specification, functional programming); the so specified data model can then be easily combined with a behavioural model of the system specified by ASM rules, thanks to the abstraction of states as algebras. <p> ASM-SL (and the ASM Workbench) with other ASM-based languages (and the corresponding tools): this objective could be achieved by defining a common ASM interchange format and then by implementing, for each particular ASM tool, the corresponding interface to the interchange format. 2.2 Type System Abstract State Machines, as defined in <ref> [11] </ref>, are untyped, but the following pragmatic considerations motivate the introduction of a (statically checkable) type system: (i) types provide a considerable help in clarifying and exposing the structure of the data model; (ii) mechanized type-checking detects many trivial errors and inconsistencies in a very early stage, before undertaking any simulation <p> values of 11 As in [3], dynamic functions are always finite in ASM-SL (i.e., they yield undef everywhere, except on a finite number of points). 12 ASM-SL follows the definition of [3], where the range of forall rules is identified by set elements, and not by unary relations as in <ref> [11] </ref>. 13 External function are notoriously the main expressive means to model environmental influences in ASM specifications. <p> while-language, simulating the following while-program (whose AST, a value of type STMT, is shown in Table 3): 22 The necessary interfaces have not been implemented yet, but substantial difficulties are not expected. 23 Essentially, the evaluator implements the denotational semantics of terms and rules. 24 A location is defined in <ref> [11] </ref> as a pair (f; x), where f is a n-ary function name and x is a n-tuple of values. 25 The output of the simulator has been somewhat modified, for obvious reasons of presentation.
Reference: 12. <author> J. Huggins and R. Mani. </author> <title> The Evolving Algebra Interpreter Version 2.0. </title> <note> Available electronically at ftp://ftp.eecs.umich.edu/groups/Ealgebras/interp2.tar.Z. </note>
Reference-contexts: On one hand, there are several ASM interpreters <ref> [2, 10, 12] </ref>, which are incompatible with each other, do not support any kind of formal analysis, transformation or reasoning, and apparently can not be easily combined with other tools (e.g., verification tools); on the other hand, there have been some successful attempts to formally verify properties of systems specified by <p> Finally, we make some concluding remarks. 1 Prolog in leanEA [2], Scheme in Dag Diesen's ASM interpreter [10], C in the Michigan ASM Interpreter <ref> [12] </ref>. 2 The ASM-SL Notation As a source language for writing ASM specifications to be processed by the tools of the ASM Workbench, we developed the ASM-SL notation 2 , which extends the basic language of Abstract State Machines defined in [11] by a few additional constructs, addressing pragmatical issues which
Reference: 13. <author> R. Milner, M. Tofte, and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: The requirement for a concise specification notation naturally leads to the selection of a type system which allows type inference. A natural first choice consists in adapting the well-known type system of Standard ML <ref> [13] </ref>, based on parametric polymorphism, to ASMs (see [7] for details). 8 In ASM-SL, this type system has been combined with the framework of hereditarily finite sets (defined, untyped, in [3]).
Reference: 14. <author> G. Schellhorn and W. Ahrendt. </author> <title> Reasoning about Abstract State Machines: The WAM Case Study. </title> <journal> Journal of Universal Computer Science, </journal> <volume> 3(4) </volume> <pages> 377-413, </pages> <year> 1997. </year>
Reference-contexts: each other, do not support any kind of formal analysis, transformation or reasoning, and apparently can not be easily combined with other tools (e.g., verification tools); on the other hand, there have been some successful attempts to formally verify properties of systems specified by means of ASMs using verification tools <ref> [14, 16, 17] </ref>, but they all rely on ad hoc techniques and mappings, which have not been automated (one reason being probably the lack of an appropriate tool framework for ASMs). <p> In the context of formal verification, many researchers combined ASMs with their preferred verification tools (e.g., the theorem provers PVS [17] and KIV <ref> [14] </ref>). 6 Free types for short. 7 Most theorem provers, for instance, come with predefined theories for mathematical structures such as those mentioned above. Most functional and object-oriented programming languages come with contructs for dealing with such structures (e.g.
Reference: 15. <author> D. Schmidt. </author> <title> The Structure of Typed Programming Languages. </title> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference: 16. <author> K. Winter. </author> <title> Model Checking for Abstract State Machines. </title> <journal> Journal of Universal Computer Science, </journal> <volume> 3(5) </volume> <pages> 689-701, </pages> <year> 1997. </year>
Reference-contexts: each other, do not support any kind of formal analysis, transformation or reasoning, and apparently can not be easily combined with other tools (e.g., verification tools); on the other hand, there have been some successful attempts to formally verify properties of systems specified by means of ASMs using verification tools <ref> [14, 16, 17] </ref>, but they all rely on ad hoc techniques and mappings, which have not been automated (one reason being probably the lack of an appropriate tool framework for ASMs).
Reference: 17. <author> W. Zimmerman and T. Gaul. </author> <title> On the Construction of Correct Compiler Back-Ends: An ASM Approach. </title> <journal> Journal of Universal Computer Science, </journal> <volume> 3(5) </volume> <pages> 504-567, </pages> <year> 1997. </year>
Reference-contexts: each other, do not support any kind of formal analysis, transformation or reasoning, and apparently can not be easily combined with other tools (e.g., verification tools); on the other hand, there have been some successful attempts to formally verify properties of systems specified by means of ASMs using verification tools <ref> [14, 16, 17] </ref>, but they all rely on ad hoc techniques and mappings, which have not been automated (one reason being probably the lack of an appropriate tool framework for ASMs). <p> In the context of formal verification, many researchers combined ASMs with their preferred verification tools (e.g., the theorem provers PVS <ref> [17] </ref> and KIV [14]). 6 Free types for short. 7 Most theorem provers, for instance, come with predefined theories for mathematical structures such as those mentioned above. Most functional and object-oriented programming languages come with contructs for dealing with such structures (e.g.
References-found: 17

