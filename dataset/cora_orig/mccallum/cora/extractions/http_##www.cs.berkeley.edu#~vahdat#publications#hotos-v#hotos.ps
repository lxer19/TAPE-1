URL: http://www.cs.berkeley.edu/~vahdat/publications/hotos-v/hotos.ps
Refering-URL: http://now.cs.berkeley.edu/Glunix/glunix.html
Root-URL: 
Title: Efficient, Portable, and Robust Extension of Operating System Functionality  
Author: Amin Vahdat, Douglas Ghormley, and Thomas Anderson 
Date: December 5, 1994  
Address: UC Berkeley  
Affiliation: Computer Science Division  
Abstract: Currently, operating systems are not chosen for underlying system features, but rather for the performance of the underlying hardware, available application programs, and system stability. Consequently, operating system vendors are reluctant to incorporate new operating system functionality since they risk both increased development time and decreased system stability. Previous efforts to make it easier for operating systems to incorporate new features have enjoyed only limited success because of performance bottlenecks or limited support for existing applications. This paper outlines a portable, efficient, and robust method for extending operating system functionality. Specifically, we propose building operating systems entirely as a library linked with every application using software-based fault isolation for protection. In order to demonstrate the validity of this technique, we are building an operating system which will provide global resource allocation in a network of workstations. 
Abstract-found: 1
Intro-found: 1
Reference: [Accetta et al. 1986] <author> Accetta, M., Baron, R., Bolosky, W., Golub, D., Rashid, R., Tevanian, A., and Young, M. </author> <title> Mach: A New Kernel Foundation For UNIX Development. </title> <booktitle> In Proceedings of the 1986 USENIX Summer Conference, </booktitle> <pages> pp. 93-112, </pages> <month> June </month> <year> 1986. </year>
Reference: [Anderson 1992] <author> Anderson, T. </author> <title> The Case for Application-Specific Operating Systems. </title> <booktitle> In Proceeding of the Third Workshop on Workstation Operating Systems, </booktitle> <pages> pp. 92-94, </pages> <month> April </month> <year> 1992. </year>
Reference: [Anderson et al. 1994] <author> Anderson, T. E., Culler, D. E., and Patterson, D. A. </author> <title> A Case for NOW (Networks of Workstations). </title> <journal> IEEE Micro, </journal> <note> 1994. To appear in special issue. </note>
Reference-contexts: et al. 1985, Douglis & Ousterhout 1991], shared file system/virtual memory cache [Nelson et al. 1988], shared virtual memory [Li & Hudak 1989], multi-threading, fast user-level communication primitives [Bershad et al. 1990, von Eicken et al. 1992], upcalls [Clark 1985], network paging [Iftode et al. 1993], and parallel program support <ref> [Anderson et al. 1994] </ref>. Researchers have spent years speculating about why these ideas go largely ignored by industry. One possible explanation is that the ideas are not useful in the first place, so no one wants the features in their operating system.
Reference: [Arpaci et al. 1994] <author> Arpaci, R., Dusseau, A., Vahdat, A., Liu, L., Anderson, T., and Patterson, D. </author> <title> The Interaction of Parallel and Sequential Workload on a Network of Workstations. </title> <type> Technical Report CSD-94-838, </type> <institution> U.C. Berkeley, </institution> <month> October </month> <year> 1994. </year> <note> Also submitted for publication. </note>
Reference-contexts: Thus, all of the idle processing power, memory, network capacity, and disk bandwidth in the network should be made available in a fair manner for both sequential and parallel applications. To provide such functionality, GLUnix must support coscheduling of parallel programs [Ousterhout 1982], idle resource detection <ref> [Mutka & Livny 1991, Arpaci et al. 1994] </ref>, process migration [Theimer et al. 1985, Douglis & Ousterhout 1991], fast user-level communication [von Eicken et al. 1992, Martin 1994], remote paging [Iftode et al. 1993], and fault-tolerance [Borg et al. 1989]. Many of the features in GLUnix are not particularly novel.
Reference: [Bershad et al. 1990] <author> Bershad, B., Anderson, T., Lazowska, E., and Levy, H. </author> <title> Lightweight Remote Procedure Calls. </title> <journal> In ACM Transactions on Computer Systems, </journal> <pages> pp. 37-54, </pages> <month> February </month> <year> 1990. </year>
Reference-contexts: A very limited sample of recent topics include: load sharing [Zhou et al. 1992], process migration [Theimer et al. 1985, Douglis & Ousterhout 1991], shared file system/virtual memory cache [Nelson et al. 1988], shared virtual memory [Li & Hudak 1989], multi-threading, fast user-level communication primitives <ref> [Bershad et al. 1990, von Eicken et al. 1992] </ref>, upcalls [Clark 1985], network paging [Iftode et al. 1993], and parallel program support [Anderson et al. 1994]. Researchers have spent years speculating about why these ideas go largely ignored by industry.
Reference: [Bershad et al. 1994] <author> Bershad, B. N., Chambers, C., Eggers, S., Maeda, C., McNamee, D., Pardyak, P., Savage, S., and Sirer, E. G. </author> <title> SPIN|An Extensible Microkernel for Application-Specific Operating System Services. </title> <type> Technical report, </type> <institution> University of Washingtion, </institution> <year> 1994. </year>
Reference: [Borg et al. 1989] <author> Borg, A., Blau, W., Graetsch, W., Heermann, F., and Oberle, W. </author> <title> Fault tolerance under unix. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 7(1) </volume> <pages> 1-23, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: such functionality, GLUnix must support coscheduling of parallel programs [Ousterhout 1982], idle resource detection [Mutka & Livny 1991, Arpaci et al. 1994], process migration [Theimer et al. 1985, Douglis & Ousterhout 1991], fast user-level communication [von Eicken et al. 1992, Martin 1994], remote paging [Iftode et al. 1993], and fault-tolerance <ref> [Borg et al. 1989] </ref>. Many of the features in GLUnix are not particularly novel. However, they have never been successfully implemented together in a coherent, usable system. GLUnix will enable efficient execution of parallel programs and improve the performance of memory or I/O intensive applications without requiring kernel modifications.
Reference: [Cheriton 1988] <author> Cheriton, D. R. </author> <title> The V Distributed System. </title> <booktitle> In Communications of the ACM, </booktitle> <pages> pp. 314-333, </pages> <month> March </month> <year> 1988. </year>
Reference: [Clark 1985] <author> Clark, D. D. </author> <title> The Structuring of Systems Using Upcalls. </title> <booktitle> In Proceedings of the 10th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pp. 171-180, </pages> <month> December 1-4 </month> <year> 1985. </year>
Reference-contexts: recent topics include: load sharing [Zhou et al. 1992], process migration [Theimer et al. 1985, Douglis & Ousterhout 1991], shared file system/virtual memory cache [Nelson et al. 1988], shared virtual memory [Li & Hudak 1989], multi-threading, fast user-level communication primitives [Bershad et al. 1990, von Eicken et al. 1992], upcalls <ref> [Clark 1985] </ref>, network paging [Iftode et al. 1993], and parallel program support [Anderson et al. 1994]. Researchers have spent years speculating about why these ideas go largely ignored by industry.
Reference: [Douglis & Ousterhout 1991] <author> Douglis, F. and Ousterhout, J. </author> <title> Transparent Process Migration: Design Alternatives and the Sprite Implementation. </title> <journal> Software Practice and Experience, </journal> <volume> 21(8) </volume> <pages> 757-85, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: Examples abound of operating system innovations which have gone largely ignored by commercial systems. A very limited sample of recent topics include: load sharing [Zhou et al. 1992], process migration <ref> [Theimer et al. 1985, Douglis & Ousterhout 1991] </ref>, shared file system/virtual memory cache [Nelson et al. 1988], shared virtual memory [Li & Hudak 1989], multi-threading, fast user-level communication primitives [Bershad et al. 1990, von Eicken et al. 1992], upcalls [Clark 1985], network paging [Iftode et al. 1993], and parallel program support <p> To provide such functionality, GLUnix must support coscheduling of parallel programs [Ousterhout 1982], idle resource detection [Mutka & Livny 1991, Arpaci et al. 1994], process migration <ref> [Theimer et al. 1985, Douglis & Ousterhout 1991] </ref>, fast user-level communication [von Eicken et al. 1992, Martin 1994], remote paging [Iftode et al. 1993], and fault-tolerance [Borg et al. 1989]. Many of the features in GLUnix are not particularly novel.
Reference: [Engler et al. 1994] <author> Engler, D. R., Kaashoek, M. F., and O'Toole, J. W. </author> <title> The Operating System Kernel as a Secure Programmable Machine. </title> <type> MIT Technical Report, </type> <year> 1994. </year>
Reference: [Iftode et al. 1993] <author> Iftode, L., Li, K., and Petersen, K. </author> <title> Memory Servers for Multicomputers. </title> <booktitle> In COMPCON, </booktitle> <month> February </month> <year> 1993. </year> <month> 4 </month>
Reference-contexts: sharing [Zhou et al. 1992], process migration [Theimer et al. 1985, Douglis & Ousterhout 1991], shared file system/virtual memory cache [Nelson et al. 1988], shared virtual memory [Li & Hudak 1989], multi-threading, fast user-level communication primitives [Bershad et al. 1990, von Eicken et al. 1992], upcalls [Clark 1985], network paging <ref> [Iftode et al. 1993] </ref>, and parallel program support [Anderson et al. 1994]. Researchers have spent years speculating about why these ideas go largely ignored by industry. One possible explanation is that the ideas are not useful in the first place, so no one wants the features in their operating system. <p> To provide such functionality, GLUnix must support coscheduling of parallel programs [Ousterhout 1982], idle resource detection [Mutka & Livny 1991, Arpaci et al. 1994], process migration [Theimer et al. 1985, Douglis & Ousterhout 1991], fast user-level communication [von Eicken et al. 1992, Martin 1994], remote paging <ref> [Iftode et al. 1993] </ref>, and fault-tolerance [Borg et al. 1989]. Many of the features in GLUnix are not particularly novel. However, they have never been successfully implemented together in a coherent, usable system.
Reference: [Jones 1993] <author> Jones, M. B. </author> <title> Interposition Agents: Transparently Interposng User Code at the System Interface. </title> <booktitle> In Proceedings of the 14th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pp. 80-93, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: Using SFI, we are able to build protected operating system functionality entirely at the user-level by dynamically linking the operating system library to each application. All system calls are redirected to procedure calls in the operating system library <ref> [Jones 1993] </ref>. Thus, a user-level virtual operating system layer is built using the underlying commercial system as a building block.
Reference: [Lazowska et al. 1981] <author> Lazowska, E. D., Levy, H. M., Almes, G. T., Fischer, M., Fowler, R., and Vestal, S. </author> <title> The Architecture of the Eden System. </title> <booktitle> In Proceedings of the 8th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pp. 148|159, </pages> <month> December </month> <year> 1981. </year>
Reference-contexts: To achieve more rapid development time and greater portability, a number of operating systems have been built as user-level servers or libraries on top of commercial operating systems. Unfortunately, systems such as Eden <ref> [Lazowska et al. 1981] </ref>, Condor [Mutka & Livny 1991], and PVM [Sunderam 1990] only provide partial solutions. Though some allow the execution of standard UNIX applications, they cannot do general purpose resource allocation without suffering the same inefficiencies found in microkernel systems.
Reference: [Li & Hudak 1989] <author> Li, K. and Hudak, P. </author> <title> Memory Coherence in Shared Virtual Memory Systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 7(4) </volume> <pages> 321-359, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: A very limited sample of recent topics include: load sharing [Zhou et al. 1992], process migration [Theimer et al. 1985, Douglis & Ousterhout 1991], shared file system/virtual memory cache [Nelson et al. 1988], shared virtual memory <ref> [Li & Hudak 1989] </ref>, multi-threading, fast user-level communication primitives [Bershad et al. 1990, von Eicken et al. 1992], upcalls [Clark 1985], network paging [Iftode et al. 1993], and parallel program support [Anderson et al. 1994]. Researchers have spent years speculating about why these ideas go largely ignored by industry.
Reference: [Lucco 1994] <author> Lucco, S. </author> <type> Personal communication, </type> <month> June </month> <year> 1994. </year>
Reference-contexts: Aggressive compiler optimization techniques reduce the overhead of these software checks to 3-7% on several contemporary RISC processors. Unrecompiled binary files can also be fault isolated, though the overhead is currently 20-25% <ref> [Lucco 1994] </ref>. In summary, SFI allows privileged operating system resource allocation code to execute in the application's address space with relatively low overhead. Using SFI, we are able to build protected operating system functionality entirely at the user-level by dynamically linking the operating system library to each application.
Reference: [Martin 1994] <author> Martin, R. P. HPAM: </author> <title> An Active Message Layer for a Network of Workstations. </title> <booktitle> In Proceedings of the 2nd Hot Interconnects Conference, </booktitle> <month> July </month> <year> 1994. </year> <note> Submitted for publication. </note>
Reference-contexts: To provide such functionality, GLUnix must support coscheduling of parallel programs [Ousterhout 1982], idle resource detection [Mutka & Livny 1991, Arpaci et al. 1994], process migration [Theimer et al. 1985, Douglis & Ousterhout 1991], fast user-level communication <ref> [von Eicken et al. 1992, Martin 1994] </ref>, remote paging [Iftode et al. 1993], and fault-tolerance [Borg et al. 1989]. Many of the features in GLUnix are not particularly novel. However, they have never been successfully implemented together in a coherent, usable system.
Reference: [Mullender et al. 1990] <author> Mullender, S. J., van Rossum, G., Tanenbaum, A. S., van Renesse, R., and van Staveren, H. </author> <title> Amoeba: A Distributed Operating System for the 1990s. </title> <journal> IEEE Computer Magazine, </journal> <volume> 23(5) </volume> <pages> 44-54, </pages> <month> May </month> <year> 1990. </year>
Reference: [Mutka & Livny 1991] <author> Mutka, M. M. and Livny, M. </author> <title> The Available Capacity of a Privately Owned Workstation Environment. Performance Evaluation, </title> <booktitle> 12(4) </booktitle> <pages> 269-84, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: To achieve more rapid development time and greater portability, a number of operating systems have been built as user-level servers or libraries on top of commercial operating systems. Unfortunately, systems such as Eden [Lazowska et al. 1981], Condor <ref> [Mutka & Livny 1991] </ref>, and PVM [Sunderam 1990] only provide partial solutions. Though some allow the execution of standard UNIX applications, they cannot do general purpose resource allocation without suffering the same inefficiencies found in microkernel systems. <p> Thus, all of the idle processing power, memory, network capacity, and disk bandwidth in the network should be made available in a fair manner for both sequential and parallel applications. To provide such functionality, GLUnix must support coscheduling of parallel programs [Ousterhout 1982], idle resource detection <ref> [Mutka & Livny 1991, Arpaci et al. 1994] </ref>, process migration [Theimer et al. 1985, Douglis & Ousterhout 1991], fast user-level communication [von Eicken et al. 1992, Martin 1994], remote paging [Iftode et al. 1993], and fault-tolerance [Borg et al. 1989]. Many of the features in GLUnix are not particularly novel.
Reference: [Nelson et al. 1988] <author> Nelson, M., Welch, B., and Ousterhout, J. </author> <title> Caching in the Sprite Network File System. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1) </volume> <pages> 134-154, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: Examples abound of operating system innovations which have gone largely ignored by commercial systems. A very limited sample of recent topics include: load sharing [Zhou et al. 1992], process migration [Theimer et al. 1985, Douglis & Ousterhout 1991], shared file system/virtual memory cache <ref> [Nelson et al. 1988] </ref>, shared virtual memory [Li & Hudak 1989], multi-threading, fast user-level communication primitives [Bershad et al. 1990, von Eicken et al. 1992], upcalls [Clark 1985], network paging [Iftode et al. 1993], and parallel program support [Anderson et al. 1994]. <p> Unless an innovation provides significantly better application performance, enables the creation of application programs which were not previously feasible, or makes the system more robust, it is likely to be ignored. Even a fairly simple, effective idea such as the split virtual memory/file cache <ref> [Nelson et al. 1988] </ref> has only recently been added to commercial systems. New functionality can compromise both operating system functionality and robustness, and vendors are well aware that a delay in the introduction of an operating system can cost millions in lost hardware sales.
Reference: [Ousterhout 1982] <author> Ousterhout, J. K. </author> <title> Scheduling Techniques for Concurrent Systems. </title> <booktitle> In Third International Conference on Distributed Computing Systems, </booktitle> <pages> pp. 22-30, </pages> <month> May </month> <year> 1982. </year>
Reference-contexts: Thus, all of the idle processing power, memory, network capacity, and disk bandwidth in the network should be made available in a fair manner for both sequential and parallel applications. To provide such functionality, GLUnix must support coscheduling of parallel programs <ref> [Ousterhout 1982] </ref>, idle resource detection [Mutka & Livny 1991, Arpaci et al. 1994], process migration [Theimer et al. 1985, Douglis & Ousterhout 1991], fast user-level communication [von Eicken et al. 1992, Martin 1994], remote paging [Iftode et al. 1993], and fault-tolerance [Borg et al. 1989].
Reference: [Sunderam 1990] <author> Sunderam, V. </author> <title> PVM: A Framework for Parallel Distributed Computing. </title> <journal> Concurrency: Practice and Experience, </journal> <volume> 2(4) </volume> <pages> 315-339, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: To achieve more rapid development time and greater portability, a number of operating systems have been built as user-level servers or libraries on top of commercial operating systems. Unfortunately, systems such as Eden [Lazowska et al. 1981], Condor [Mutka & Livny 1991], and PVM <ref> [Sunderam 1990] </ref> only provide partial solutions. Though some allow the execution of standard UNIX applications, they cannot do general purpose resource allocation without suffering the same inefficiencies found in microkernel systems. The resource allocator's code and data must be protected as a separate server requiring inter-process communication and context switches.
Reference: [Theimer et al. 1985] <author> Theimer, M., Landtz, K., and Cheriton, D. </author> <title> Preemptable Remote Execution Facilities for the V System. </title> <booktitle> In Proceedings of the 10th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pp. 2-12, </pages> <note> December 1985. </note> <author> [von Eicken et al. 1992] von Eicken, T., Culler, D. E., Goldstein, S. C., and Schauser, K. E. </author> <title> Active Messages: a Mechanism for Integrated Communication and Computation. </title> <booktitle> In Proc. of the 19th Int'l Symposium on Computer Architecture, </booktitle> <address> Gold Coast, Australia, </address> <month> May </month> <year> 1992. </year> <note> (Also available as Technical Report UCB/CSD 92/675, </note> <institution> CS Div., University of California at Berkeley). </institution>
Reference-contexts: Examples abound of operating system innovations which have gone largely ignored by commercial systems. A very limited sample of recent topics include: load sharing [Zhou et al. 1992], process migration <ref> [Theimer et al. 1985, Douglis & Ousterhout 1991] </ref>, shared file system/virtual memory cache [Nelson et al. 1988], shared virtual memory [Li & Hudak 1989], multi-threading, fast user-level communication primitives [Bershad et al. 1990, von Eicken et al. 1992], upcalls [Clark 1985], network paging [Iftode et al. 1993], and parallel program support <p> To provide such functionality, GLUnix must support coscheduling of parallel programs [Ousterhout 1982], idle resource detection [Mutka & Livny 1991, Arpaci et al. 1994], process migration <ref> [Theimer et al. 1985, Douglis & Ousterhout 1991] </ref>, fast user-level communication [von Eicken et al. 1992, Martin 1994], remote paging [Iftode et al. 1993], and fault-tolerance [Borg et al. 1989]. Many of the features in GLUnix are not particularly novel.
Reference: [Wahbe et al. 1993] <author> Wahbe, R., Lucco, S., and Anderson, T. </author> <title> Efficent software-based fault isolation. </title> <booktitle> In Proceedings of the 14th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pp. 203-216, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: The key enabling technology for such a system organization is software-based fault isolation (SFI) <ref> [Wahbe et al. 1993] </ref>. Traditional hardware protection can be efficiently implemented in software in a language-independent fashion by modifying the object code to insert checks before each store and indirect branch operation to catch addressing errors.
Reference: [Wulf et al. 1974] <author> Wulf, W., Cohen, E., Corwin, W., Jones, A., Levin, R., Pierson, C., and Pollack, F. HYDRA: </author> <title> The Kernel of a Multiprocessor Operating System. </title> <journal> Communications of the ACM, </journal> <volume> 17(6) </volume> <pages> 337-344, </pages> <month> June </month> <year> 1974. </year>
Reference: [Yokote 1992] <author> Yokote, Y. </author> <title> The Apertos Reflective Operating System: The Concept and Its Implementation. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming: Systems, Languages, and Applications, </booktitle> <pages> pp. 414-434. </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1992. </year>
Reference: [Young et al. 1987] <author> Young, M., Tevanian, A., Rashid, R., Golub, D., Eppinger, J., Chew, J., Bolosky, W., Black, D., and Baron, R. </author> <title> The Duality of Memory and Communication in the Implementation of a Multiprocessor Operating System. </title> <booktitle> In Proceedings of the 11th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pp. 63-76, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: Some of the earliest efforts were microkernel designs [Wulf et al. 1974, Accetta et al. 1986, Cheriton 1988, Mullender et al. 1990] which allow for user-level emulation of different operating systems. Despite efforts to make microkernel systems portable to different hardware platforms <ref> [Young et al. 1987] </ref>, the required effort is still non-trivial. More importantly, the performance of such systems is limited by the costs of context switching, crossing protection boundaries, and inter-process communication.
Reference: [Zhou et al. 1992] <author> Zhou, S., Wang, J., Zheng, X., and Delisle, P. </author> <title> Utopia: A Load Sharing Facility for Large, Heterogeneous Distributed Computing Systems. </title> <type> Technical Report CSRI-257, </type> <institution> University of Toronto, </institution> <year> 1992. </year> <month> 5 </month>
Reference-contexts: Examples abound of operating system innovations which have gone largely ignored by commercial systems. A very limited sample of recent topics include: load sharing <ref> [Zhou et al. 1992] </ref>, process migration [Theimer et al. 1985, Douglis & Ousterhout 1991], shared file system/virtual memory cache [Nelson et al. 1988], shared virtual memory [Li & Hudak 1989], multi-threading, fast user-level communication primitives [Bershad et al. 1990, von Eicken et al. 1992], upcalls [Clark 1985], network paging [Iftode et
References-found: 28

