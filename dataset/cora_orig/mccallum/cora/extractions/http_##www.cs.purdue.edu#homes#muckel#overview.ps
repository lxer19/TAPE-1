URL: http://www.cs.purdue.edu/homes/muckel/overview.ps
Refering-URL: http://www.cs.purdue.edu/people/muckel/
Root-URL: http://www.cs.purdue.edu
Email: fmuckel|russog@cs.purdue.edu  
Title: Draft: Structural Subtyping in a Distributed Object System  
Author: Patrick A. Muckelbauer and Vincent F. Russo 
Address: West Lafayette, IN 47907  
Affiliation: Department of Computer Sciences Purdue University  
Abstract: This paper describes an interface description language and runtime support system for a distributed object system that uses structural subtyping for conformance checking rather than traditional inheritance subtyping. It is shown from both a theoretical and practical perspective that structural subtyping leads to less coupled components in a distributed system. Reducing coupling between components decreases their interdependencies and makes them easier to separate and understand. Furthermore, decreased interdependencies resulting from reduced coupling make a system easier to maintain by helping to minimize the effect that changes in components have on their interoperability.
Abstract-found: 1
Intro-found: 1
Reference: [A + 86] <author> Mike Accetta et al. </author> <title> Mach: A New Kernel Foundation for UNIX Development. </title> <booktitle> In Proceedings of the USENIX Conference, </booktitle> <pages> pages 93-111, </pages> <year> 1986. </year>
Reference-contexts: Clients in message-based systems such as V [Che88], Mach <ref> [A + 86] </ref>, and Chorus [RAN88] acquire system services from servers by explicitly formatting and sending messages to communication end points (e.g., ports or processes).
Reference: [AC90] <author> Roberto Amadio and Luca Cardelli. </author> <title> Subtyping Recursive Types. </title> <type> Technical Report 62, </type> <institution> DEC SRC, </institution> <year> 1990. </year>
Reference-contexts: For example: type LinkedList = record of value : Integer; next : optional LinkedList; end record; The conformance rules are recursive and when applied to recursive types equate to testing whether the infinite expansions of the types structurally conform <ref> [AC90] </ref>. The recursive nature of the conformance rules is evident in the recursive calls to the algorithm in step 3.
Reference: [Ame90] <author> Pierre America. </author> <title> A Parallel Object-Oriented Language with Inheritance and Subtyping. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 161-168, </pages> <year> 1990. </year>
Reference-contexts: Semantic attributes are simply named identifiers (for example, sorted or FIFO) used to describe the semantics of an object and are similar in function to brands in Modula-3 [CDG + 89] or properties in POOL <ref> [Ame90] </ref>. 4 Contravariance of arguments and covariance of results further complicate matters and will be discussed later. 5 A hierarchical naming scheme can be used to help manage the name space and make it easier to extend type hierarchies. 8 2.3 Claim To help build more scalable and maintainable distributed systems <p> For non-object types, Modula-3 uses structural equivalence with a limited form of structural sub-typing (for example, with sub-ranges). However, for object types, Modula-3 uses named-based conformance. Similarly, remote object types are checked using name-based conformance in Network Objects. Emerald [JLHB87] and POOL <ref> [Ame90] </ref> are distributed object-oriented programming languages that use structural subtyping. In addition to restricting the programmer to a single implementation language, these systems are not designed for a wide-area, heterogeneous distributed environment. <p> While structural subtyping has been used in several distributed distributed programming languages such as Emerald [JLHB87] and POOL <ref> [Ame90] </ref>, such systems restrict the programmer to a single implementation language for building interoperating components and have been limited in scale. <p> Semantic attributes are simply named identifiers (for example, sorted or FIFO) used to describe the semantics of an object and are similar in function to brands in Modula-3 [CDG + 89] or properties in POOL <ref> [Ame90] </ref>. In addition to supplying an interface when narrowing an object reference, a client can supply a list of semantic attributes for checking semantic conformance. For example, a client's expected interface for a file object might contain read and write methods.
Reference: [Ben87] <author> John Bennett. </author> <title> The Design and Implementation of Distributed Smalltalk. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 318-330, </pages> <year> 1987. </year>
Reference-contexts: Runtime type errors are generated when clients access server values in an inconsistent manner. This form of checking is referred to as dynamic type 1 The kinds of values that can be referenced remotely depend on the particular distributed system. 4 checking [Set89a]. For example, in Distributed Smalltalk <ref> [Ben87] </ref>, a dynamically typed-checked distributed object system, a client can invoke the method m on a remote object and if the method is not in the remote object's interface the exception "message not understood " is raised.
Reference: [Ber93] <author> Edward Berard. </author> <booktitle> Essays on Object-Oriented Software Engineering, </booktitle> <volume> volume 1. </volume> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1993. </year>
Reference-contexts: Object-oriented programming is one such technique <ref> [GJM91, Ber93] </ref>. Object-oriented programming increases program modularity and data abstraction by supporting encapsulation through narrow, rigidly defined, and strongly enforced interfaces to objects [Ber93]. This paper uses the definition for object-oriented programming as defined in [Weg87]. <p> Object-oriented programming is one such technique [GJM91, Ber93]. Object-oriented programming increases program modularity and data abstraction by supporting encapsulation through narrow, rigidly defined, and strongly enforced interfaces to objects <ref> [Ber93] </ref>. This paper uses the definition for object-oriented programming as defined in [Weg87]. An object consists of an encapsulated state and a set of operations, or methods, that modify or access the state. The interface of an object is defined by the collection of all its methods.
Reference: [BHJ + 87] <author> Andrew Black, Norman Hutchinson, Eric Jul, Henry Levy, and Larry Carter. </author> <title> Distribution and Abstract Types in Emerald. </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pages 65-76, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: Support for typed references has several software engineering advantages: they catch errors earlier (during narrowing), they guarantee a sense of correctness to the system by not allowing clients and servers to interact in an inconsistent manner, and they allow better performance to be achieved for remote accesses <ref> [CW85, BHJ + 87] </ref>. For these reasons, this paper is restricted to distributed systems that support typed references.
Reference: [BHJL86] <author> Andrew Black, Norman Hutchinson, Eric Jul, and Henry Levy. </author> <title> Object Structure in the Emerald System. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 78-86, </pages> <year> 1986. </year>
Reference-contexts: For example, a data value can be passed by reference by encapsulating it in an object and passing the object by reference. 3.2.5 Conformance Rules The conformance rules define the structural subtype relationship between types and are based on the conformance rules in the Emerald <ref> [BHJL86] </ref> and Amber [Car85] programming languages. Briefly, the conformance rules are type equivalence for primitive types, recursive subtyping for optional and sequence types, recursive subtyping of field subsets for record and case types, and recursive subtyping of method subsets for interfaces.
Reference: [BN84] <author> Andrew Birrell and Bruce Nelson. </author> <title> Implementing Remote Procedure Calls. </title> <journal> ACM Transactions on Computer Systems, </journal> <pages> pages 39-59, </pages> <month> February </month> <year> 1984. </year>
Reference-contexts: For example, procedure calls can be used to model the interactions between distributed components <ref> [BN84] </ref>. Using this model, clients access servers by calling procedures that are implemented by servers (i.e., clients make remote procedure calls). Remote procedure calls (RPCs) are made transparent by providing local client procedure calls to stub routines that forward requests to servers using the low-level communication protocol. <p> While the servers in such systems can be considered objects and message sending analogous to remote method invocations, such systems do not provide a runtime representation for types and, consequently, cannot type-check servers at bind time. All type checking must be done dynamically at message sending time. RPC-based systems <ref> [BN84] </ref> improve upon message-based systems by hidding many of the communication details behind procedure call interfaces. RPC-based systems model the interactions between clients and servers as client procedure calls that are implemented by servers. RPCs are made transparent by providing local stub procedures that forward requests to servers.
Reference: [BNOW94] <author> Andrew Birrell, Greg Nelson, Susan Owicki, and Edward Wobber. </author> <title> Network Objects. </title> <type> Technical Report 115, </type> <institution> DEC SRC, </institution> <year> 1994. </year>
Reference-contexts: The focus of our work is on providing flexible rules for conformance in a multilingual, heterogeneous distributed system. Several distributed programming languages base conformance to some extent on the structure of types. Network Objects <ref> [BNOW94] </ref> is an extension of Modula-3 [CDG + 89] for supporting accessing of remote objects. Modula-3 uses a combination of structural-based and named-based conformance. For non-object types, Modula-3 uses structural equivalence with a limited form of structural sub-typing (for example, with sub-ranges). However, for object types, Modula-3 uses named-based conformance.
Reference: [BR95] <author> Gerald Baumgartner and Vincent Russo. </author> <title> Signatures: a Language Extension for Improving Type Abstractions and Subtype Polymorphism in C++. </title> <journal> Software Practice and Experience, </journal> <pages> pages 863-889, </pages> <month> August </month> <year> 1995. </year> <title> 8 Primavera is a native operating system implemented as a Renaissance component. </title> <type> 31 </type>
Reference-contexts: A C ++ translator for Lingua Franca has been built which maps Lingua Franca types into C ++ types. C ++ was chosen due to its availability and the previous work on integrating the signature concept into the language <ref> [GR91, BR95] </ref>. The support libraries for C ++ applications have been designed and built. The libraries provide runtime conformance checking and remote method invocation using a shared memory transport module (when possible) or a UDP-based transport module.
Reference: [Car85] <author> Luca Cardelli. </author> <title> Amber, </title> <booktitle> Combinators and Functional Programming Languages. In Pro--ceedings of the 13th Summer School of the LITP, </booktitle> <address> Le Val D'Ajol, Vosges (France), </address> <year> 1985. </year>
Reference-contexts: For example, a data value can be passed by reference by encapsulating it in an object and passing the object by reference. 3.2.5 Conformance Rules The conformance rules define the structural subtype relationship between types and are based on the conformance rules in the Emerald [BHJL86] and Amber <ref> [Car85] </ref> programming languages. Briefly, the conformance rules are type equivalence for primitive types, recursive subtyping for optional and sequence types, recursive subtyping of field subsets for record and case types, and recursive subtyping of method subsets for interfaces.
Reference: [CDG + 89] <author> Luca Cardelli, James Donahue, Lucille Glassman, Mick Jordan, Bill Kalsow, and Greg Nelson. </author> <note> Modula-3 Report (revised). Technical Report 52, DEC SRC, </note> <year> 1989. </year>
Reference-contexts: This problem is addressed in Section 4.2.3 by extending Lingua Franca to support semantic attributes. Semantic attributes are simply named identifiers (for example, sorted or FIFO) used to describe the semantics of an object and are similar in function to brands in Modula-3 <ref> [CDG + 89] </ref> or properties in POOL [Ame90]. 4 Contravariance of arguments and covariance of results further complicate matters and will be discussed later. 5 A hierarchical naming scheme can be used to help manage the name space and make it easier to extend type hierarchies. 8 2.3 Claim To help <p> The focus of our work is on providing flexible rules for conformance in a multilingual, heterogeneous distributed system. Several distributed programming languages base conformance to some extent on the structure of types. Network Objects [BNOW94] is an extension of Modula-3 <ref> [CDG + 89] </ref> for supporting accessing of remote objects. Modula-3 uses a combination of structural-based and named-based conformance. For non-object types, Modula-3 uses structural equivalence with a limited form of structural sub-typing (for example, with sub-ranges). However, for object types, Modula-3 uses named-based conformance. <p> One solution is to extend Lingua Franca to support the augmentation of objects with semantic attributes. Semantic attributes are simply named identifiers (for example, sorted or FIFO) used to describe the semantics of an object and are similar in function to brands in Modula-3 <ref> [CDG + 89] </ref> or properties in POOL [Ame90]. In addition to supplying an interface when narrowing an object reference, a client can supply a list of semantic attributes for checking semantic conformance. For example, a client's expected interface for a file object might contain read and write methods.
Reference: [Che88] <author> David Cheriton. </author> <title> The V Distributed System. </title> <journal> Communications of the ACM, </journal> <pages> pages 314-333, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: Clients in message-based systems such as V <ref> [Che88] </ref>, Mach [A + 86], and Chorus [RAN88] acquire system services from servers by explicitly formatting and sending messages to communication end points (e.g., ports or processes).
Reference: [Con90] <author> Richard Connor. </author> <title> Types and Polymorphism in Persistent Programming Languages. </title> <type> PhD thesis, </type> <institution> University of St Andrews, </institution> <year> 1990. </year>
Reference-contexts: When building persistent systems, as with distributed systems, there is a potentially large number of programmers developing components independently and sharing external values. Builders of such systems are concerned with reducing coupling between components to help maintain the systems. Napier88 <ref> [Con90] </ref> is a persistent programming language that uses structural equivalence for conformance.
Reference: [CS93] <author> Douglas Comer and David Stevens. </author> <title> Internetworking with TCP/IP Volume III: Client Server Programming and Applications. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1993. </year>
Reference-contexts: The kinds of components in a distributed system depend on the tools provided by the system for building components. This paper considers systems that model the interactions between components with the client/server paradigm <ref> [CS93] </ref>. A component providing services to other components is termed a server and a component using those services is termed a client of the server. Typical services found in distributed systems include mail, news, printing, and file system access. User-defined application-specific services are also possible.
Reference: [CW85] <author> Luca Cardelli and Peter Wegner. </author> <title> On Understanding Types, Data Abstraction, and Polymorphism. </title> <journal> ACM Computing Surveys, </journal> <pages> pages 471-522, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: Support for typed references has several software engineering advantages: they catch errors earlier (during narrowing), they guarantee a sense of correctness to the system by not allowing clients and servers to interact in an inconsistent manner, and they allow better performance to be achieved for remote accesses <ref> [CW85, BHJ + 87] </ref>. For these reasons, this paper is restricted to distributed systems that support typed references. <p> Subtyping is a relationship on types defining when a type ff can be asserted to be at least a type fi and, consequently, values of type ff can be correctly substituted for values of type fi <ref> [CW85] </ref>. The subtyping relationship is defined by a programming language's conformance rules. If ff conforms to fi then ff is said to be a subtype of fi and fi is said to be a supertype of ff.
Reference: [GJM91] <author> Carlo Ghezzi, Mehdi Jazayeri, and Dino Mandrioli. </author> <title> Fundamentals of Software Engineering. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1991. </year>
Reference-contexts: Dynamically evolving systems should minimize the degree of coupling between interacting components in order to help maintain component compatibility during their evolution. Reducing coupling between components decreases their interdependencies and makes them easier to separate and understand <ref> [GJM91] </ref>. Furthermore, decreased interdependencies resulting from reduced coupling make a system easier to maintain by helping to minimize the effect that changes in components have on their interoperability. <p> Object-oriented programming is one such technique <ref> [GJM91, Ber93] </ref>. Object-oriented programming increases program modularity and data abstraction by supporting encapsulation through narrow, rigidly defined, and strongly enforced interfaces to objects [Ber93]. This paper uses the definition for object-oriented programming as defined in [Weg87].
Reference: [GM95] <author> James Gosling and Henry McGilton. </author> <title> The JAVA Language Environment: </title> <note> A White Paper. Available from http://www.javasoft.com/whitePaper, 1995. </note>
Reference: [GR91] <author> Elana Granston and Vincent Russo. </author> <title> Signature-Based Polymorphism for C++. </title> <booktitle> In Proceedings of the USENIX C ++ Conference, </booktitle> <year> 1991. </year>
Reference-contexts: A C ++ translator for Lingua Franca has been built which maps Lingua Franca types into C ++ types. C ++ was chosen due to its availability and the previous work on integrating the signature concept into the language <ref> [GR91, BR95] </ref>. The support libraries for C ++ applications have been designed and built. The libraries provide runtime conformance checking and remote method invocation using a shared memory transport module (when possible) or a UDP-based transport module.
Reference: [HO87] <author> Daniel Halbert and Patrick O'Brien. </author> <title> Using Types and Inheritance in Object-Oriented Programming. </title> <journal> IEEE Software, </journal> <pages> pages 71-79, </pages> <month> September </month> <year> 1987. </year>
Reference-contexts: These new implementations only affect instances of the subclass. The parent's implementations are still used when the methods are invoked on instances of the parent classes. Inheritance is useful for code and interface sharing, for factoring code into common places, and for incremental development and documentation <ref> [HO87, Sny86, JF88, Mey87] </ref>. Inheritance is so useful in the context of class construction that it is viewed by many as an essential feature of object-oriented programming [Weg87].
Reference: [HPM93] <author> Graham Hamilton, Michael Powell, and James Mitchell. Subcontract: </author> <title> A Flexible Base for Distributed Programming. </title> <booktitle> In Proceedings of the ACM Symposium on Operating System Principles, </booktitle> <pages> pages 69-79, </pages> <year> 1993. </year>
Reference-contexts: Conformance checking is simply a matter of testing whether a server's program number equals the number expected by a client. Most closely related to the work in this paper are distributed object systems such as OMG's CORBA [OMG91], Sun's Spring System <ref> [HPM93, MGH + 94] </ref>, Microsoft's OLE-II [Mic94], and IBM's SOM/DSOM [IBM93]. These systems use IDLs to describe objects and provide tools for 9 mapping these descriptions into target programming languages.
Reference: [HR94] <author> Graham Hamilton and Sanjay Radia. </author> <title> Using Interface Inheritance to Address Problems in System Software Evolution. </title> <booktitle> In Proceedings of the ACM Workshop on Interface Definition Languages, </booktitle> <pages> pages 119-128, </pages> <year> 1994. </year>
Reference-contexts: For example, consider the recursive interface type Directory which includes methods for retrieving the contents of a directory and opening sub-directories and files. type Directory = interface of 7 The Spring System uses the names of types to help manage their versions <ref> [HR94] </ref>. Changes to types are categorized into two kinds: major revisions which break compatibility with clients and minor revisions which do not break compatibility.
Reference: [IBM93] <institution> IBM. </institution> <note> SOMobjects Developer Toolkit Users Guide Version 2.0, </note> <year> 1993. </year>
Reference-contexts: Section 4 argues that basing compatibility on the structure of specifications leads to less coupled components than basing compatibility on the names of specifications [Mic94] or hierarchies of names <ref> [OMG91, IBM93] </ref>. The remainder of this paper is organized as follows. Section 2 provides necessary background material and defines terms used throughout the rest of this paper. <p> Most closely related to the work in this paper are distributed object systems such as OMG's CORBA [OMG91], Sun's Spring System [HPM93, MGH + 94], Microsoft's OLE-II [Mic94], and IBM's SOM/DSOM <ref> [IBM93] </ref>. These systems use IDLs to describe objects and provide tools for 9 mapping these descriptions into target programming languages. Distributed object systems have improved upon RPC-based systems by introducing a notion of first class remote references and by introducing a notion of subtyping for conformance checking.
Reference: [JF88] <author> Ralph Johnson and Brian Foote. </author> <title> Designing Reusable Classes. </title> <journal> The Journal of Object-Oriented Programming, </journal> <pages> pages 22-35, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: These new implementations only affect instances of the subclass. The parent's implementations are still used when the methods are invoked on instances of the parent classes. Inheritance is useful for code and interface sharing, for factoring code into common places, and for incremental development and documentation <ref> [HO87, Sny86, JF88, Mey87] </ref>. Inheritance is so useful in the context of class construction that it is viewed by many as an essential feature of object-oriented programming [Weg87].
Reference: [JLHB87] <author> Eric Jul, Henry Levy, Norman Hutchinson, and Andrew Black. </author> <title> Fine-Grained Mobility in the Emerald System. </title> <booktitle> In Proceedings of the ACM Symposium on Operating System Principles, </booktitle> <pages> pages 62-74, </pages> <year> 1987. </year> <month> 32 </month>
Reference-contexts: While such languages by definition restrict the programmer to a single implementation language for building interoperating components, many provide additional features such as replication, mobility, and/or fault tolerance for building distributed applications. For example, Argus [Lis88] provides atomic transactions and Emerald <ref> [JLHB87] </ref> provides object mobility. While such features are useful, they are orthogonal to the choice of conformance and, consequently, outside the scope of this paper. The focus of our work is on providing flexible rules for conformance in a multilingual, heterogeneous distributed system. <p> Modula-3 uses a combination of structural-based and named-based conformance. For non-object types, Modula-3 uses structural equivalence with a limited form of structural sub-typing (for example, with sub-ranges). However, for object types, Modula-3 uses named-based conformance. Similarly, remote object types are checked using name-based conformance in Network Objects. Emerald <ref> [JLHB87] </ref> and POOL [Ame90] are distributed object-oriented programming languages that use structural subtyping. In addition to restricting the programmer to a single implementation language, these systems are not designed for a wide-area, heterogeneous distributed environment. <p> While structural subtyping has been used in several distributed distributed programming languages such as Emerald <ref> [JLHB87] </ref> and POOL [Ame90], such systems restrict the programmer to a single implementation language for building interoperating components and have been limited in scale.
Reference: [JR86] <author> Michael Jones and Richard Rashid. </author> <title> Mach and Matchmaker: Kernel and Language Support for Object-Oriented Distributed Systems. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 67-86, </pages> <year> 1986. </year>
Reference-contexts: Unfortunately, object-oriented mechanisms are usually only accessible and enforced through programming language support. Relying on programming language support would severely limit the degree to which disjoint, unrelated components can interact in a multilingual, loosely coupled distributed system. The use of a high-level interface description language (IDL) <ref> [JR86] </ref> solves this problem by providing a mechanism for specifying an object's interface independently of the programming languages used to implement or access the object. A translator maps these specifications into a target language's notion of objects and interfaces (for most object-oriented languages, a class).
Reference: [Lis88] <author> Barbara Liskov. </author> <title> Distributed Programming in Argus. </title> <journal> Communications of the ACM, </journal> <pages> pages 300-312, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: While such languages by definition restrict the programmer to a single implementation language for building interoperating components, many provide additional features such as replication, mobility, and/or fault tolerance for building distributed applications. For example, Argus <ref> [Lis88] </ref> provides atomic transactions and Emerald [JLHB87] provides object mobility. While such features are useful, they are orthogonal to the choice of conformance and, consequently, outside the scope of this paper. The focus of our work is on providing flexible rules for conformance in a multilingual, heterogeneous distributed system.
Reference: [Mey87] <author> Bertrand Meyer. </author> <title> Reusability: The Case for Object-Oriented Design. </title> <journal> IEEE Software, </journal> <pages> pages 50-64, </pages> <month> March </month> <year> 1987. </year>
Reference-contexts: These new implementations only affect instances of the subclass. The parent's implementations are still used when the methods are invoked on instances of the parent classes. Inheritance is useful for code and interface sharing, for factoring code into common places, and for incremental development and documentation <ref> [HO87, Sny86, JF88, Mey87] </ref>. Inheritance is so useful in the context of class construction that it is viewed by many as an essential feature of object-oriented programming [Weg87].
Reference: [MGH + 94] <author> James Mitchell, Jonathan Gibbons, Graham Hamilton, Peter Kessler, Yousef Khalidi, Panos Kougiouris, Peter Madany, Michael Nelson, Michael Powell, and Sanjay Radia. </author> <title> An Overview of the Spring System. </title> <booktitle> In Proceedings of Compcon Spring 1994, </booktitle> <year> 1994. </year>
Reference-contexts: Conformance checking is simply a matter of testing whether a server's program number equals the number expected by a client. Most closely related to the work in this paper are distributed object systems such as OMG's CORBA [OMG91], Sun's Spring System <ref> [HPM93, MGH + 94] </ref>, Microsoft's OLE-II [Mic94], and IBM's SOM/DSOM [IBM93]. These systems use IDLs to describe objects and provide tools for 9 mapping these descriptions into target programming languages. <p> These features increase the expressiveness of inheritance subtyping and lead to less coupled components. For example, without method re-definition a subtype of an interface cannot change the argument or result types of the methods of that interface without breaking compatibility. Consider the Spring Distributed Object System <ref> [MGH + 94] </ref> which is an inheritance-typed distributed object system modeled after CORBA [OMG91]. The rules for conformance in CORBA do not support subtyping of non-interface types or method re-definition. The following example, taken from the Spring System and rewritten in Lingua Franca, illustrates the problem.
Reference: [Mic94] <author> Microsoft Corporation. </author> <title> OLE2 Programmer's Reference, volume 2. </title> <publisher> Microsoft Press, </publisher> <year> 1994. </year>
Reference-contexts: Section 4 argues that basing compatibility on the structure of specifications leads to less coupled components than basing compatibility on the names of specifications <ref> [Mic94] </ref> or hierarchies of names [OMG91, IBM93]. The remainder of this paper is organized as follows. Section 2 provides necessary background material and defines terms used throughout the rest of this paper. <p> Conformance checking is simply a matter of testing whether a server's program number equals the number expected by a client. Most closely related to the work in this paper are distributed object systems such as OMG's CORBA [OMG91], Sun's Spring System [HPM93, MGH + 94], Microsoft's OLE-II <ref> [Mic94] </ref>, and IBM's SOM/DSOM [IBM93]. These systems use IDLs to describe objects and provide tools for 9 mapping these descriptions into target programming languages.
Reference: [Mor79] <author> R. Morrison. </author> <title> On the Development of Algol. </title> <type> PhD thesis, </type> <institution> University of St Andrews, </institution> <year> 1979. </year>
Reference: [MTH90] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> The MIT Press, </publisher> <year> 1990. </year>
Reference: [Muc96] <author> Patrick A. Muckelbauer. </author> <title> Structural Subtyping in a Distributed Object System. </title> <type> PhD thesis, </type> <institution> Department of Computer Sciences, Purdue University, </institution> <year> 1996. </year>
Reference-contexts: Current technology is to use inheritance subtyping in multilingual, heterogeneous distributed systems. However, structural subtyping is more expressive than inheritance subtyping and leads to less coupled components. Furthermore, as shown in <ref> [Muc96] </ref>, structurally-typed distributed object system can be efficiently implemented. 2.4 Related Work 2.4.1 Multilingual, Heterogeneous Distributed Systems Multilingual, heterogeneous distributed systems have evolved over the years from primitive message-based systems, to RPC-based systems, to present day distributed object systems. <p> These extensions would provide programmers added functionality to select an appropriate set of semantics based on the requirements of a program. In practice, however, these extensions have not been necessary because, as is shown in <ref> [Muc96] </ref>, many of the value passing semantics for data values can be simulated. <p> of ff conforms to the result type of fi 9. fi is type Anything (i.e., 8ff; ff Anything) 3.2.6 Implementation and Performance of Structural Subtyping For a complete discussion of the conformance algorithm used in Lingua Franca including its implementation, a worst case cost analysis, and actual measured performance, see <ref> [Muc96] </ref>. Briefly, the runtime type information used during narrowing consists of directed graphs (referred to as type graphs) where each node represents a type and the edges are pointers to types used in the source type's construction. Let x be the type corresponding to node n x . <p> It can be shown, however, that there are types in Lingua Franca with an infinite number of distinct structural supertypes. For such types, it is impossible to construct finite type hierarchies to model their structural subtyping relationships. In <ref> [Muc96] </ref>, a root set of types with an infinite number of distinct structural supertypes is identified. All other types with an infinite number of distinct structural supertypes are constructed from types in this set. <p> The client need only provide what the object expects but can provide additional data in the record as well. Finally, consider recursive types in Lingua Franca. A complete proof that all recursive types have an infinite number of distinct structural supertypes is discussed in detail in <ref> [Muc96] </ref>. Intuitively, however, a recursive type is an infinitely expanding tree where each node represents a type and the edges are pointers to types used in the source node's construction.
Reference: [MW88] <author> J. Eliot Moss and Alexander Wolf. </author> <title> Toward Principles of Inheritance and Subtyping in Programming Languages. </title> <type> Technical Report COINS 88-95, </type> <institution> University of Massachusetts, </institution> <year> 1988. </year>
Reference-contexts: The subtyping relationship varies from language to language depending on the conformance rules used. However, there are two common approaches to conformance in object-oriented programming languages <ref> [MW88, Sny86] </ref>: name-based conformance and structural-based conformance.
Reference: [OMG91] <author> Object Managment Group, </author> <title> Framingham, MA. The Common Object Request Broker: Architecture and Specification (Revision 2.0), </title> <month> July </month> <year> 1991. </year>
Reference-contexts: Section 4 argues that basing compatibility on the structure of specifications leads to less coupled components than basing compatibility on the names of specifications [Mic94] or hierarchies of names <ref> [OMG91, IBM93] </ref>. The remainder of this paper is organized as follows. Section 2 provides necessary background material and defines terms used throughout the rest of this paper. <p> For example, a client needing read-only 3 The sharing of interfaces and their meaning is typically accomplished by sharing specifications for the interfaces via either files or an interface repository <ref> [OMG91] </ref>. 7 files can specify this as an interface containing only the method read and any object supporting the method read can interoperate with the client including read-write and read-only objects. <p> Conformance checking is simply a matter of testing whether a server's program number equals the number expected by a client. Most closely related to the work in this paper are distributed object systems such as OMG's CORBA <ref> [OMG91] </ref>, Sun's Spring System [HPM93, MGH + 94], Microsoft's OLE-II [Mic94], and IBM's SOM/DSOM [IBM93]. These systems use IDLs to describe objects and provide tools for 9 mapping these descriptions into target programming languages. <p> For C ++ applications, only an additional 140 lines of code in the C ++ support libraries was necessary to implement the dispatch routine and support dynamically typed method invocations. Inheritance-typed systems modeled after CORBA <ref> [OMG91] </ref> also support dynamically typed method invocations. These systems rely on an interface repository for providing type information about an object's interface. This information is necessary to properly generate and process request messages and is similar to the information contained in signature objects. <p> Except for multiple inheritance these requirements are not met in CORBA <ref> [OMG91] </ref> and other similar inheritance-typed distributed systems. However, for the sake of argument, these assumptions are made. Given that a type hierarchy must comprise a finite set of named types, at most a finite number of distinct structural supertypes of a type can be modeled with a type hierarchy. <p> For example, without method re-definition a subtype of an interface cannot change the argument or result types of the methods of that interface without breaking compatibility. Consider the Spring Distributed Object System [MGH + 94] which is an inheritance-typed distributed object system modeled after CORBA <ref> [OMG91] </ref>. The rules for conformance in CORBA do not support subtyping of non-interface types or method re-definition. The following example, taken from the Spring System and rewritten in Lingua Franca, illustrates the problem. The original interface for file objects in the system was file 1 0.
Reference: [RAN88] <author> M. Rozier, V. Abrossimov, and W. Neuhauser. </author> <title> CHORUS-V3 Kernel Specification and Interface. </title> <type> Technical Report CS/TN-87-25.10, </type> <institution> CHORUS Systems, </institution> <year> 1988. </year>
Reference-contexts: Clients in message-based systems such as V [Che88], Mach [A + 86], and Chorus <ref> [RAN88] </ref> acquire system services from servers by explicitly formatting and sending messages to communication end points (e.g., ports or processes).
Reference: [RTL + 91] <author> Rajendra Raj, Ewan Tempero, Henry Levy, Andrew Black, Norman Hutchison, and Eric Jul. </author> <title> Emerald: A General-Purpose Programming Language. </title> <journal> Software Practice and Experience, </journal> <pages> pages 91-118, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Semantic attributes are not necessary and can be implemented as empty methods added to clients' interfaces describing semantic requirements and to interfaces of objects specified to possess them <ref> [RTL + 91] </ref>. For example, the method I Am A FIFO for the semantic attribute FIFO.
Reference: [Set89a] <author> Ravi Sethi. </author> <title> Programming Languages: Concepts and Constructs. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, Massachusetts, </address> <year> 1989. </year>
Reference-contexts: Runtime type errors are generated when clients access server values in an inconsistent manner. This form of checking is referred to as dynamic type 1 The kinds of values that can be referenced remotely depend on the particular distributed system. 4 checking <ref> [Set89a] </ref>. For example, in Distributed Smalltalk [Ben87], a dynamically typed-checked distributed object system, a client can invoke the method m on a remote object and if the method is not in the remote object's interface the exception "message not understood " is raised.
Reference: [Set89b] <author> Ravi Sethi. </author> <title> Programming Languages: Concepts and Constructs, </title> <booktitle> chapter 1, </booktitle> <pages> pages 16-19. </pages> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, Massachusetts, </address> <year> 1989. </year>
Reference: [Sha86] <author> Marc Shapiro. </author> <title> Structure and Encapsulation in Distributed Systems: The Proxy Principle. </title> <booktitle> In Proceedings of the Sixth International Conference on Distributed Computer Systems, </booktitle> <year> 1986. </year> <month> 33 </month>
Reference-contexts: A translator maps these specifications into a target language's notion of objects and interfaces (for most object-oriented languages, a class). The generated language-specific modules are used by programmers to implement objects and/or to generate typed references to remote objects via proxy objects <ref> [Sha86] </ref>. 2 Some languages force recompilation in this situation. 6 2.2.3 Conformance Rules The conformance rules used in object-oriented programming languages are based on the notion of subtyping. <p> This results in an O (Edges) anticipated-case complexity for the algorithm. 3.3 The Support Libraries In the Renaissance System, all remote method invocations occur indirectly through local invocations on proxy objects <ref> [Sha86] </ref>. As shown in Figure 2, a proxy is a local representation of a remote object and maps the language's notion of procedure call or method invocation transparently into a remote method invocation.
Reference: [Sny86] <author> Alan Snyder. </author> <title> Encapsulation and Inheritance in Object-Oriented Programming Lan--guages. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 38-45, </pages> <year> 1986. </year>
Reference-contexts: These new implementations only affect instances of the subclass. The parent's implementations are still used when the methods are invoked on instances of the parent classes. Inheritance is useful for code and interface sharing, for factoring code into common places, and for incremental development and documentation <ref> [HO87, Sny86, JF88, Mey87] </ref>. Inheritance is so useful in the context of class construction that it is viewed by many as an essential feature of object-oriented programming [Weg87]. <p> The subtyping relationship varies from language to language depending on the conformance rules used. However, there are two common approaches to conformance in object-oriented programming languages <ref> [MW88, Sny86] </ref>: name-based conformance and structural-based conformance.
Reference: [Sto94] <author> Alexander Stoyenko. SUPRA-RPC: </author> <title> SUbprogram PaRAmeters in Remote Procedure Calls. </title> <journal> Software Practice and Experience, </journal> <pages> pages 27-49, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: This program is analogous to an object with a set of methods. However, most RPC-based systems do not support programs (or procedures) as first class values and, therefore, unlike objects, programs cannot be passed as arguments or returned as results. The SUPRA-RPC System <ref> [Sto94] </ref> relaxes this restriction and supports first class procedural values. RPC-based systems where the first systems to introduce a notion of type and conformance to distributed systems. However, RPC-based systems have traditionally used name equivalence for type conformance.
Reference: [Str86] <author> Bjarne Stroustrup. </author> <title> The C ++ Programming Language. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, Massachusetts, </address> <year> 1986. </year>
Reference: [Sun85] <author> Sun Microsystems. </author> <title> Networking on the SUN Workstation, </title> <year> 1985. </year>
Reference-contexts: The SUPRA-RPC System [Sto94] relaxes this restriction and supports first class procedural values. RPC-based systems where the first systems to introduce a notion of type and conformance to distributed systems. However, RPC-based systems have traditionally used name equivalence for type conformance. In Sun RPC <ref> [Sun85] </ref>, for example, types are specified as program numbers where each number represents a well defined and agreed upon set of procedures (i.e., the program's exported procedures). Conformance checking is simply a matter of testing whether a server's program number equals the number expected by a client.
Reference: [Weg87] <author> Peter Wegner. </author> <title> Dimensions of Object-Based Language Design. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 168-182, </pages> <year> 1987. </year>
Reference-contexts: Object-oriented programming is one such technique [GJM91, Ber93]. Object-oriented programming increases program modularity and data abstraction by supporting encapsulation through narrow, rigidly defined, and strongly enforced interfaces to objects [Ber93]. This paper uses the definition for object-oriented programming as defined in <ref> [Weg87] </ref>. An object consists of an encapsulated state and a set of operations, or methods, that modify or access the state. The interface of an object is defined by the collection of all its methods. <p> Inheritance is useful for code and interface sharing, for factoring code into common places, and for incremental development and documentation [HO87, Sny86, JF88, Mey87]. Inheritance is so useful in the context of class construction that it is viewed by many as an essential feature of object-oriented programming <ref> [Weg87] </ref>. A distributed object system is a distributed system where all interactions between clients and servers are viewed as method invocations on objects in separate components. That is, clients access servers by invoking methods on objects in server components via remote references.
References-found: 45

