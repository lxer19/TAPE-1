URL: http://choices.cs.uiuc.edu/sane/oostate.ps.gz
Refering-URL: http://choices.cs.uiuc.edu/sane/home.html
Root-URL: http://www.cs.uiuc.edu
Email: email: fsane,royg@cs.uiuc.edu  
Title: Object-Oriented State Machines: Subclassing, Composition, Delegation, and Genericity  
Author: Aamod Sane and Roy Campbell 
Web: www: http://choices.cs.uiuc.edu/sane/home.html  
Address: 1304 W. Springfield Avenue, Urbana, IL 61801  
Affiliation: University of Illinois at Urbana-Champaign Department of Computer Science  
Note: (To appear in OOPSLA'95)  
Abstract: Software specification and implementation techniques based on state machines simplify design, coding, and validation. However, large systems require complex state machines. Incremental construction techniques can control this complexity. In this paper, we present a construction technique that permits derivation of complex state machines from simpler state machines. The technique uses subclassing, composition, delegation, and genericity to incrementally modify and combine simpler machines. In addition, we present a novel implementation technique that uses exactly one table-lookup and one addition to dispatch events on derived state machines, no matter the depth of the derivation. As an example, we describe the derivation of a complicated distributed virtual memory scheme from a simple paging virtual memory scheme. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. J. Bach. </author> <title> The Design of the UNIX operating system. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1986. </year>
Reference-contexts: We motivate the use of subclassing by considering a simple virtual memory (VM) paging scheme (Figure 1) that is enhanced to support copy-on-write (COW) <ref> [1] </ref> (Figure 2). In Figure 1, a virtual memory page may be mapped into physical memory so that it is accessible. The page may be unmapped to store it on backing store and release physical memory for other use 1 . The state machine in Figure 2 supports copy-on-write.
Reference: [2] <author> Grady Booch. </author> <title> Object-oriented Analysis and Design with Applications. </title> <address> Benjamin/Cummings, California, </address> <year> 1994. </year>
Reference-contexts: 1 Introduction Many designers advocate the use of state machines to specify and implement software systems. For example, reactive system designs [10] and object-oriented analysis and design <ref> [26, 2, 5] </ref> use state machines. However, large systems require complex state machines. In this paper, we introduce object-oriented techniques that permit the design of complex state fl Supported by CNRI contract CNRI GIGABIT/UILL. machines by incrementally modifying and combining other independently designed machines.
Reference: [3] <author> R.H. Campbell. </author> <title> The Specification of process synchronization by Path-Expressions. </title> <booktitle> In Lecture Notes in Computer Science, </booktitle> <pages> pages 89-102, </pages> <year> 1974. </year>
Reference-contexts: For instance, we have found simple solutions to the so-called inheritance anomaly [17] based on state machine inheritance. Our notion of Self seems to lead naturally to recursively typed extensions of Nierstrasz's regular types [19] and inheritance in path expressions <ref> [3] </ref>. State machines are used in specifying interfaces [29], so subclassing or composition of interfaces might be investigated using our definitions. It may be possible to apply our notion of Self to frameworks, where objects are interrelated by relationships other than BECOMES-A.
Reference: [4] <author> Craig Chambers. </author> <title> Predicate classes. </title> <booktitle> In Proceedings of the European Conference on Object-Oriented Programming, </booktitle> <month> July </month> <year> 1993. </year>
Reference-contexts: The relation between states and classes is explored in [20]. A discussion similar to that in Section 2 is found in [18]. Taival-saari [27] suggests that objects have modes, and transitions between modes are governed by a transition function. Chambers' predicate classes <ref> [4] </ref> are similar to modes or states but more dynamic. Our implementation technique can be extended to predicate classes using methods that automatically select the next state. In particular, our definitions of subclassing, composition, etc., can be applied with predicate classes, and easily admit more dynamic implementations.
Reference: [5] <author> Derek Coleman, Fiona Hayes, and Stephen Bear. </author> <title> Introducing Objectcharts or how to use State-charts in object-oriented design. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(1) </volume> <pages> 9-18, </pages> <month> Jan-uary </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Many designers advocate the use of state machines to specify and implement software systems. For example, reactive system designs [10] and object-oriented analysis and design <ref> [26, 2, 5] </ref> use state machines. However, large systems require complex state machines. In this paper, we introduce object-oriented techniques that permit the design of complex state fl Supported by CNRI contract CNRI GIGABIT/UILL. machines by incrementally modifying and combining other independently designed machines. <p> In particular, our definitions of subclassing, composition, etc., can be applied with predicate classes, and easily admit more dynamic implementations. An early version of subclassable state machines was described in [23]. Our object-oriented constructions extend Harel's StateCharts [10]. Other object-oriented extensions include ObjectCharts <ref> [5] </ref>, ROOMCharts [25], DisCo [12], ObjCharts [9], etc. In ObjectCharts, ROOM-Charts and ObjCharts, state machines are inherited by adding new states and actions, or by refining existing actions. Substitutability is achieved essentially by requiring that the subtype traces should extend the be-havior of the parent.
Reference: [6] <author> Stephen R. Davis. </author> <title> C++ objects that change their types. </title> <journal> The Journal of Object-Oriented Programming, </journal> <pages> pages 27-32, </pages> <month> July/August </month> <year> 1992. </year>
Reference-contexts: We are also developing a graphical version of the generator. 7 Related Work The reification technique (RT) has been invented many times <ref> [16, 6, 14, 13] </ref>, usually for the purpose of changing the class of an object. Behavior abstractions [14] and Enabled sets [28] introduce become and replace constructions that hint at our general concept of em-beddings. Johnson and Zweig [13] and Liu [16] have applied RT program network protocols.
Reference: [7] <author> Margaret Ellis and Bjarne Stroustrup. </author> <title> The C ++ Annotated Reference Manual. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: Derived machines are then constructed by systematic modification of StateMaps, and base state methods are inherited without change. A StateMap is similar to a C ++ VTable <ref> [7] </ref>: C ++ virtual functions are dispatched using the VTable, so that derived classes can replace virtual functions of the base class with their own versions. <p> Also, some space is saved due to code reuse. 5.5 Limitations As we have seen, the StateMap technique cannot completely eliminate method redefinition for non-deterministic transitions. A more pragmatic limitation is that for our C ++ like <ref> [7] </ref> implementation, the structure of state machines must be statically declared. Of course, a more dynamic Smalltalk like implementation is straightforward to build. 6 Miscellaneous topics: subtyping, nested sta tes, and generators This section summarizes some issues that are not discussed in detail due to space restrictions.
Reference: [8] <author> Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. </author> <title> Design Patterns: Elements of Object-Oriented Software Architecture. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, Massachusetts, </address> <year> 1994. </year>
Reference-contexts: In addition, we present a novel, highly efficient technique for implementing state machines that extends object-oriented approaches such as the reification technique (RT) <ref> [13, 8] </ref>. Our technique facilitates incremental derivation of state machines using subclassing, composition, delegation, and genericity (henceforth called object-oriented-techniques (OOT)), and improves upon the reuse afforded by RT. <p> We first show that standard techniques such as RT <ref> [13, 8] </ref> block certain kinds of reuse. Then we observe that this is not an artifact of any particular implementation technique. <p> In Figure 3, pages are instances of the class Page. PageState is the abstract class that declares the methods for each state of a page, while the classes 3 We build on RT. For comparisons between RT and other techniques see <ref> [8] </ref>. Page pageOut () pageAccess () PageState pageOut () pageAccess () state-&gt;pageOut () state-&gt;pageAccess () Mapped pageOut () pageAccess () Unmapped pageOut () pageAccess () state Legend: inheritance, instance variables, method implementation. Mapped and Unmapped represent the concrete states of a page.
Reference: [9] <author> Dipayan Gangopadhyay and Subrata Mitra. Ob-jChart: </author> <title> Tangible specification of reactive object behavior. </title> <booktitle> In Proceedings of the Euro pean Conference on Object-Oriented Program--ming, number 707 in Lecture Notes in Computer Science, </booktitle> <pages> pages 432-457. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1993. </year>
Reference-contexts: In particular, our definitions of subclassing, composition, etc., can be applied with predicate classes, and easily admit more dynamic implementations. An early version of subclassable state machines was described in [23]. Our object-oriented constructions extend Harel's StateCharts [10]. Other object-oriented extensions include ObjectCharts [5], ROOMCharts [25], DisCo [12], ObjCharts <ref> [9] </ref>, etc. In ObjectCharts, ROOM-Charts and ObjCharts, state machines are inherited by adding new states and actions, or by refining existing actions. Substitutability is achieved essentially by requiring that the subtype traces should extend the be-havior of the parent. In DisCo, inheritance is defined as importing class definitions.
Reference: [10] <author> David Harel. Statecharts: </author> <title> A visual formalism for complex systems. </title> <booktitle> Science of Computer Programming, </booktitle> <pages> pages 231-274, </pages> <month> August </month> <year> 1987. </year>
Reference-contexts: 1 Introduction Many designers advocate the use of state machines to specify and implement software systems. For example, reactive system designs <ref> [10] </ref> and object-oriented analysis and design [26, 2, 5] use state machines. However, large systems require complex state machines. In this paper, we introduce object-oriented techniques that permit the design of complex state fl Supported by CNRI contract CNRI GIGABIT/UILL. machines by incrementally modifying and combining other independently designed machines. <p> This technique can be extended for composition to show that the DVM machine IS-A VM machine. Nested States The implementation technique from Section 5 can be extended to program nested states as in StateCharts <ref> [10] </ref>. Essentially, superstates with nested states can be treated as a collection of states. Thus, each state in the collection is represented using tables as in Section 5, and the tables are switched at run-time to represent nested state transitions. <p> In particular, our definitions of subclassing, composition, etc., can be applied with predicate classes, and easily admit more dynamic implementations. An early version of subclassable state machines was described in [23]. Our object-oriented constructions extend Harel's StateCharts <ref> [10] </ref>. Other object-oriented extensions include ObjectCharts [5], ROOMCharts [25], DisCo [12], ObjCharts [9], etc. In ObjectCharts, ROOM-Charts and ObjCharts, state machines are inherited by adding new states and actions, or by refining existing actions.
Reference: [11] <author> John E. Hopcroft and Jeffrey D. Ullman. </author> <title> Introduction to Automata Theory, Languages and Computation. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, Massachusetts, </address> <year> 1988. </year>
Reference-contexts: Analysis based on embeddings suggests a fast implementation involving a single indexed table lookup (Section 5), regardless of the height of the subclassing, composition, or delegation hierarchy. A space-efficient implementation of generics requires one more lookup, but the lookup 2 We use Mealy machines <ref> [11] </ref>, but since actions may be associated with either source or destination state objects, our technique also applies to Moore machines [11]. can be eliminated if necessary. Section 6 summarizes topics such as subtyping and nested states that are not discussed in detail due to space restrictions. <p> A space-efficient implementation of generics requires one more lookup, but the lookup 2 We use Mealy machines <ref> [11] </ref>, but since actions may be associated with either source or destination state objects, our technique also applies to Moore machines [11]. can be eliminated if necessary. Section 6 summarizes topics such as subtyping and nested states that are not discussed in detail due to space restrictions. <p> Therefore, we define subclassing, composition, etc., in terms of mappings between triples of source state, event, destination state. Such triples are called transitions, and mappings between transitions are called embeddings. More formally, using the standard <ref> [11] </ref> definition of state machines, define two state machines B (base) pageWrite () pageOut () RMapped ffi RUnmapped pageRead () pageOut () WMapped ffi WUnmapped pageRead/Write () makeCopy () pageOut () CMapped ffi CUnmapped pageAccess () fl DVM-VM Machine fl DVM-NET Machine fl DVM Machine fl DVM-VM-COPY Machine fl DVM-NET-MULTICAST Machine
Reference: [12] <author> Hannu-Matti J arvinen and Reino Kurki-Suonio. </author> <title> DisCo specification language: Marriage of actions and objects. </title> <booktitle> In International Conference on Distributed Computing Systems, </booktitle> <pages> pages 142-157, </pages> <year> 1991. </year>
Reference-contexts: In particular, our definitions of subclassing, composition, etc., can be applied with predicate classes, and easily admit more dynamic implementations. An early version of subclassable state machines was described in [23]. Our object-oriented constructions extend Harel's StateCharts [10]. Other object-oriented extensions include ObjectCharts [5], ROOMCharts [25], DisCo <ref> [12] </ref>, ObjCharts [9], etc. In ObjectCharts, ROOM-Charts and ObjCharts, state machines are inherited by adding new states and actions, or by refining existing actions. Substitutability is achieved essentially by requiring that the subtype traces should extend the be-havior of the parent. In DisCo, inheritance is defined as importing class definitions.
Reference: [13] <author> Ralph E. Johnson and Jonathan M. Zweig. </author> <booktitle> Delegation in C ++ . The Journal of Object-Oriented Programming, </booktitle> <pages> pages 31-34, </pages> <month> Nov/Dec </month> <year> 1991. </year>
Reference-contexts: In addition, we present a novel, highly efficient technique for implementing state machines that extends object-oriented approaches such as the reification technique (RT) <ref> [13, 8] </ref>. Our technique facilitates incremental derivation of state machines using subclassing, composition, delegation, and genericity (henceforth called object-oriented-techniques (OOT)), and improves upon the reuse afforded by RT. <p> We first show that standard techniques such as RT <ref> [13, 8] </ref> block certain kinds of reuse. Then we observe that this is not an artifact of any particular implementation technique. <p> In turn, ackPage () when invoked from SendN, returns RemoteQ instead of Quiescent. RemoteQ later gets used as a VM state. 3.2 Delegation Delegation can be programmed using state machines <ref> [13] </ref>, and in turn state machines may delegate behavior to other machines. For instance, Figure 3 might be considered a description of how instances of Page delegate their behavior to the page classes MappedPage and UnmappedPage (see also [20]). <p> We are also developing a graphical version of the generator. 7 Related Work The reification technique (RT) has been invented many times <ref> [16, 6, 14, 13] </ref>, usually for the purpose of changing the class of an object. Behavior abstractions [14] and Enabled sets [28] introduce become and replace constructions that hint at our general concept of em-beddings. Johnson and Zweig [13] and Liu [16] have applied RT program network protocols. <p> Behavior abstractions [14] and Enabled sets [28] introduce become and replace constructions that hint at our general concept of em-beddings. Johnson and Zweig <ref> [13] </ref> and Liu [16] have applied RT program network protocols. Liu also suggests the use of a CVTable. The relation between states and classes is explored in [20]. A discussion similar to that in Section 2 is found in [18].
Reference: [14] <author> Dennis G. Kafura and Keung Hae Lee. </author> <title> Inheritance in actor based concurrent object oriented languages. </title> <booktitle> In Proceedings of the Euro-pean Conference on Object-Oriented Programming (ECOOP'89), </booktitle> <pages> pages 131-145. </pages> <publisher> Cambridge University Press, </publisher> <year> 1989. </year>
Reference-contexts: We are also developing a graphical version of the generator. 7 Related Work The reification technique (RT) has been invented many times <ref> [16, 6, 14, 13] </ref>, usually for the purpose of changing the class of an object. Behavior abstractions [14] and Enabled sets [28] introduce become and replace constructions that hint at our general concept of em-beddings. Johnson and Zweig [13] and Liu [16] have applied RT program network protocols. <p> We are also developing a graphical version of the generator. 7 Related Work The reification technique (RT) has been invented many times [16, 6, 14, 13], usually for the purpose of changing the class of an object. Behavior abstractions <ref> [14] </ref> and Enabled sets [28] introduce become and replace constructions that hint at our general concept of em-beddings. Johnson and Zweig [13] and Liu [16] have applied RT program network protocols. Liu also suggests the use of a CVTable. The relation between states and classes is explored in [20].
Reference: [15] <author> Barbara Liskov and Jeanette M. Wing. </author> <title> A behavioral notion of subtyping. </title> <note> ACM Transactions on Programming Languages and Systems (to appear), 1994. Available from http://www.cs.cmu.edu:8001/afs/cs/user/ wing/www/home.html. </note>
Reference-contexts: More details may be found in [22]. Subtyping and Substitutability The definitions from Section 4.1 enforce structural similarities, but we consider behavioral similarities separately using the Liskov-Wing behavioral subtyping <ref> [15] </ref> approach (LWA). Briefly, the idea behind LWA is to specify state invariants, method pre-and-post conditions and history properties of state transitions, and show that derived machines respect the properties of the base machine.
Reference: [16] <author> Chung-Syan Liu. </author> <title> An object-based approach to protocol software implementation. </title> <booktitle> In Symposium on Communications Architectures and Protocols (SIGCOMM), </booktitle> <pages> pages 307-316, </pages> <year> 1994. </year>
Reference-contexts: We are also developing a graphical version of the generator. 7 Related Work The reification technique (RT) has been invented many times <ref> [16, 6, 14, 13] </ref>, usually for the purpose of changing the class of an object. Behavior abstractions [14] and Enabled sets [28] introduce become and replace constructions that hint at our general concept of em-beddings. Johnson and Zweig [13] and Liu [16] have applied RT program network protocols. <p> Behavior abstractions [14] and Enabled sets [28] introduce become and replace constructions that hint at our general concept of em-beddings. Johnson and Zweig [13] and Liu <ref> [16] </ref> have applied RT program network protocols. Liu also suggests the use of a CVTable. The relation between states and classes is explored in [20]. A discussion similar to that in Section 2 is found in [18].
Reference: [17] <author> Satoshi Matsuoka, Kenjiro Taura, and Akinori Yonezawa. </author> <title> Highly efficient and encapsulated re-use of synchronization code in concurrent object-oriented languages. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages and Applications (OOP-SLA'93), volume 28 of SIGPLAN Notices, </booktitle> <pages> pages 109-126. </pages> <publisher> ACM Press, </publisher> <month> October </month> <year> 1993. </year>
Reference-contexts: Event dispatch with our approach is only slightly more expensive than a C ++ virtual function dispatch. The techniques presented in this paper open further avenues of investigation. For instance, we have found simple solutions to the so-called inheritance anomaly <ref> [17] </ref> based on state machine inheritance. Our notion of Self seems to lead naturally to recursively typed extensions of Nierstrasz's regular types [19] and inheritance in path expressions [3]. State machines are used in specifying interfaces [29], so subclassing or composition of interfaces might be investigated using our definitions.
Reference: [18] <author> John D. McGregor and Douglas M. Dyer. </author> <title> A note on inheritance and state machines. </title> <booktitle> ACM Sigsoft Notes, </booktitle> <year> 1994. </year>
Reference-contexts: Johnson and Zweig [13] and Liu [16] have applied RT program network protocols. Liu also suggests the use of a CVTable. The relation between states and classes is explored in [20]. A discussion similar to that in Section 2 is found in <ref> [18] </ref>. Taival-saari [27] suggests that objects have modes, and transitions between modes are governed by a transition function. Chambers' predicate classes [4] are similar to modes or states but more dynamic. Our implementation technique can be extended to predicate classes using methods that automatically select the next state.
Reference: [19] <author> Oscar Nierstrasz. </author> <title> Regular types for active objects. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA'93), volume 28 of SIGPLAN Notices, </booktitle> <pages> pages 1-15. </pages> <publisher> ACM Press, </publisher> <month> October </month> <year> 1993. </year>
Reference-contexts: The techniques presented in this paper open further avenues of investigation. For instance, we have found simple solutions to the so-called inheritance anomaly [17] based on state machine inheritance. Our notion of Self seems to lead naturally to recursively typed extensions of Nierstrasz's regular types <ref> [19] </ref> and inheritance in path expressions [3]. State machines are used in specifying interfaces [29], so subclassing or composition of interfaces might be investigated using our definitions. It may be possible to apply our notion of Self to frameworks, where objects are interrelated by relationships other than BECOMES-A.
Reference: [20] <author> Alexander S. Ran. </author> <title> Modelling states as classes. </title> <booktitle> In Proceedings of the Technology of Object-Oriented Languages and Systems Conference, </booktitle> <year> 1994. </year>
Reference-contexts: For instance, Figure 3 might be considered a description of how instances of Page delegate their behavior to the page classes MappedPage and UnmappedPage (see also <ref> [20] </ref>). The class of a Page object changes when it changes states, effectively changing the delegatee. Similarly, state machines may delegate their behavior to other state machines, and the delegatees can be changed at run-time, much as individual states are changed in ordinary state machines. <p> Johnson and Zweig [13] and Liu [16] have applied RT program network protocols. Liu also suggests the use of a CVTable. The relation between states and classes is explored in <ref> [20] </ref>. A discussion similar to that in Section 2 is found in [18]. Taival-saari [27] suggests that objects have modes, and transitions between modes are governed by a transition function. Chambers' predicate classes [4] are similar to modes or states but more dynamic.
Reference: [21] <author> James Rumbaugh, Michael Blaha, William Pre-merlani, Frederick Eddy, and William Lorensen. </author> <title> Object-Oriented Modeling and Design. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1991. </year>
Reference-contexts: Hence, a general solution requires a redefinition of the notion of Self that accounts for both relationships. Reuse restrictions in RT Figure 3 shows an implementation (in OMT-like notation <ref> [21] </ref>) of the VM state machine (Figure 1) using RT 3 , where states are reified as objects, and method calls implement state transitions. In Figure 3, pages are instances of the class Page.
Reference: [22] <author> Aamod Sane. </author> <title> Object-Oriented State Machines: Subclassing, Composition, Delegation, and Genericity. </title> <type> Technical report, </type> <institution> Department of Computer Science, University of Illinois at Urbana-Champaign, </institution> <year> 1994. </year> <note> See http://choices.cs.uiuc.edu/sane/home.html. </note>
Reference-contexts: Of course, a more dynamic Smalltalk like implementation is straightforward to build. 6 Miscellaneous topics: subtyping, nested sta tes, and generators This section summarizes some issues that are not discussed in detail due to space restrictions. More details may be found in <ref> [22] </ref>. Subtyping and Substitutability The definitions from Section 4.1 enforce structural similarities, but we consider behavioral similarities separately using the Liskov-Wing behavioral subtyping [15] approach (LWA).
Reference: [23] <author> Aamod Sane and Roy Campbell. </author> <title> Subclassing state machines. </title> <type> Technical Report UIUCDCS-R-92-1773, </type> <institution> Department of Computer Science, University of Illinois at Urbana-Champaign, </institution> <year> 1992. </year>
Reference-contexts: Our implementation technique can be extended to predicate classes using methods that automatically select the next state. In particular, our definitions of subclassing, composition, etc., can be applied with predicate classes, and easily admit more dynamic implementations. An early version of subclassable state machines was described in <ref> [23] </ref>. Our object-oriented constructions extend Harel's StateCharts [10]. Other object-oriented extensions include ObjectCharts [5], ROOMCharts [25], DisCo [12], ObjCharts [9], etc. In ObjectCharts, ROOM-Charts and ObjCharts, state machines are inherited by adding new states and actions, or by refining existing actions.
Reference: [24] <author> Aamod Sane, Ken MacGregor, and Roy Camp-bell. </author> <title> Distributed virtual memory consistency protocols: Design and performance. </title> <booktitle> In Second IEEE workshop on Experimental Distributed Systems, </booktitle> <year> 1990. </year>
Reference-contexts: We demonstrate composition by constructing a distributed virtual memory (DVM) protocol machine (Figure 8) out of a virtual memory machine (Figure 6) and a networking machine (Figure 7). DVM <ref> [24] </ref> provides the illusion of a global shared address space over networks of workstations, whose local memories are used as caches of the global address space. The caches have to be kept consistent: a simple approach allows only one machine to access a shared page at a time.
Reference: [25] <author> Bran Selic. </author> <title> An efficient object-oriented variation of the Statecharts formalism for distributed real-time systems. </title> <booktitle> In CHDL'93 IFIP Conference on Hardware Description Languages and Their applications, </booktitle> <pages> pages 26-28, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: In particular, our definitions of subclassing, composition, etc., can be applied with predicate classes, and easily admit more dynamic implementations. An early version of subclassable state machines was described in [23]. Our object-oriented constructions extend Harel's StateCharts [10]. Other object-oriented extensions include ObjectCharts [5], ROOMCharts <ref> [25] </ref>, DisCo [12], ObjCharts [9], etc. In ObjectCharts, ROOM-Charts and ObjCharts, state machines are inherited by adding new states and actions, or by refining existing actions. Substitutability is achieved essentially by requiring that the subtype traces should extend the be-havior of the parent.
Reference: [26] <author> Sally Shlaer and Stephen J. Mellor. </author> <title> Object Life-cycles: Modeling the World in States. </title> <publisher> Yourdon Press Computing Series. Yourdon Press (Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey), </address> <year> 1992. </year>
Reference-contexts: 1 Introduction Many designers advocate the use of state machines to specify and implement software systems. For example, reactive system designs [10] and object-oriented analysis and design <ref> [26, 2, 5] </ref> use state machines. However, large systems require complex state machines. In this paper, we introduce object-oriented techniques that permit the design of complex state fl Supported by CNRI contract CNRI GIGABIT/UILL. machines by incrementally modifying and combining other independently designed machines.
Reference: [27] <author> Antero Taivalsaari. </author> <title> Object-oriented program-ming with modes. </title> <journal> The Journal of Object-Oriented Programming, </journal> <pages> pages 25-32, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Johnson and Zweig [13] and Liu [16] have applied RT program network protocols. Liu also suggests the use of a CVTable. The relation between states and classes is explored in [20]. A discussion similar to that in Section 2 is found in [18]. Taival-saari <ref> [27] </ref> suggests that objects have modes, and transitions between modes are governed by a transition function. Chambers' predicate classes [4] are similar to modes or states but more dynamic. Our implementation technique can be extended to predicate classes using methods that automatically select the next state.
Reference: [28] <author> Chris Tomlinson and Vineet Singh. </author> <title> Inheritance and synchronization with enabled-sets. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA'89), SIGPLAN Notices, </booktitle> <pages> pages 103-112. </pages> <publisher> Association for Computing Machinery, ACM Press, </publisher> <month> October </month> <year> 1989. </year>
Reference-contexts: We are also developing a graphical version of the generator. 7 Related Work The reification technique (RT) has been invented many times [16, 6, 14, 13], usually for the purpose of changing the class of an object. Behavior abstractions [14] and Enabled sets <ref> [28] </ref> introduce become and replace constructions that hint at our general concept of em-beddings. Johnson and Zweig [13] and Liu [16] have applied RT program network protocols. Liu also suggests the use of a CVTable. The relation between states and classes is explored in [20].
Reference: [29] <author> Daniel M. Yellin and Robert E. Strom. </author> <title> Interfaces, protocols, and the semi-automatic construction of software adaptors. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages and Applications 94, </booktitle> <pages> pages 176-190, </pages> <year> 1994. </year>
Reference-contexts: For instance, we have found simple solutions to the so-called inheritance anomaly [17] based on state machine inheritance. Our notion of Self seems to lead naturally to recursively typed extensions of Nierstrasz's regular types [19] and inheritance in path expressions [3]. State machines are used in specifying interfaces <ref> [29] </ref>, so subclassing or composition of interfaces might be investigated using our definitions. It may be possible to apply our notion of Self to frameworks, where objects are interrelated by relationships other than BECOMES-A.
References-found: 29

