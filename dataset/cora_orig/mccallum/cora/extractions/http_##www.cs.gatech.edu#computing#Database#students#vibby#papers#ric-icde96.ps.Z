URL: http://www.cs.gatech.edu/computing/Database/students/vibby/papers/ric-icde96.ps.Z
Refering-URL: http://www.cs.gatech.edu/computing/Database/students/vibby/vibby.html
Root-URL: 
Title: Relaxed Index Consistency for a Client-Server Database  
Author: Vibby Gottemukkala Edward Omiecinski Umakishore Ramachandran 
Address: Yorktown Heights, NY 10598  Atlanta, GA 30332  
Affiliation: IBM T.J.Watson Research Center College of Computing  Georgia Institute of Technology,  
Abstract: Client-Server systems cache data in client buffers to deliver good performance. Several efficient protocols have been proposed to maintain the coherence of the cached data. However, none of the protocols distinguish between index pages and data pages. We propose a new coherence protocol, called Relaxed Index Consistency, that exploits the inherent differences in the coherence and concurrency-control (C&CC) requirements for index and data pages. The key idea is to incur a small increase in computation time at the clients to gain a significant reduction in the number of messages exchanged between the clients and the servers. The protocol uses the concurrency control on data pages to maintain coherence of index pages. A performance-conscious implementation of the protocol that makes judicious use of version numbers is proposed. We show, through both qualitative and quantitative analysis, the performance benefits of making the distinction between index pages and data pages for the purposes of C&CC. Our simulation studies show that the Relaxed Index Consistency protocol improves system throughput by as much as 15% to 88%, based on the workload. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. J. Carey, M. J. Franklin, M. Livny, and E. J. Shekita. </author> <title> Data Caching Tradeoffs in Client-Server DBMS Architectures. </title> <booktitle> In Proceedings of the 1991 ACM SIGMOD Conference, </booktitle> <pages> pages 357-366, </pages> <year> 1991. </year>
Reference-contexts: of an index when an index item is locked using data-only locking thus combining coherence actions on index pages with C&CC of data pages. 2.4 Related Work There is an extremely large body of work in the literature regarding coherence and consistency maintenance of data in various data sharing environments <ref> [3, 22, 20, 1, 17] </ref>. However, this entire body of work treats all the data uniformly, i.e., the same protocol is used for both data and non-data pages, which leads to unnecessary inter-node interactions in the case of non-data pages. <p> These workloads are based on the workloads described in <ref> [1, 2] </ref>. The experiments test the performance of the coherence protocols as the need for coherence changes by varying the percentage of write accesses to the database. In the following we discuss each workload and discuss the relevant results.
Reference: [2] <author> M.J. Carey, M.J. Franklin, and M. Zaharioudakis. </author> <title> Fine-Grained Sharing in a Page Server OODBMS. </title> <booktitle> In Proceedings of the 1994 ACM SIGMOD Conference, </booktitle> <pages> pages 359-370, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: We compare the RIC protocol with the Callback Locking (CBL) protocol because of the general acceptance of the performance advantages of the CBL protocol in the literature and its implementation in systems <ref> [4, 11, 2] </ref>. <p> These workloads are based on the workloads described in <ref> [1, 2] </ref>. The experiments test the performance of the coherence protocols as the need for coherence changes by varying the percentage of write accesses to the database. In the following we discuss each workload and discuss the relevant results. <p> In our future work we would also like to explore the usage of multiple-writer semantics, and fine-granularity locking, as suggested in <ref> [2] </ref>, in the RIC protocol, and their impact on the throughput and scalability of the system. [6] contains a longer version of this paper.
Reference: [3] <author> D. M. Dias, B. R. Iyer, J. T. Robinson, and P. S. Yu. </author> <title> Integrated Concurrency-Coherency Controls for Multisystem Data Sharing. </title> <journal> IEEE Transaction on Software Engineering, </journal> <volume> 15(4) </volume> <pages> 437-448, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: of an index when an index item is locked using data-only locking thus combining coherence actions on index pages with C&CC of data pages. 2.4 Related Work There is an extremely large body of work in the literature regarding coherence and consistency maintenance of data in various data sharing environments <ref> [3, 22, 20, 1, 17] </ref>. However, this entire body of work treats all the data uniformly, i.e., the same protocol is used for both data and non-data pages, which leads to unnecessary inter-node interactions in the case of non-data pages.
Reference: [4] <author> M. Franklin and M. Carey. </author> <title> Client-Server Caching Revisited. </title> <booktitle> In Proceedings of the International Workshop on Distributed Object Management, </booktitle> <month> August </month> <year> 1992. </year>
Reference-contexts: In fact, the server does not even keep track of clients that cache index pages in shared mode. As for data pages, the server uses an enhanced Callback Locking (CBL) protocol <ref> [4, 20] </ref> to grant a client's page request. The CBL protocol is enhanced for RIC so that the server, in addition to granting the requested data page, sends coherence information for the indexes relevant to the requested data page (see the grant request step in Fig ure 1). <p> The Callback Locking protocol used for data locking in RIC was originally proposed for file caching in AFS [8]. This protocol was enhanced and adapted for caching in transactional systems in <ref> [11, 20, 4] </ref>. <p> We compare the RIC protocol with the Callback Locking (CBL) protocol because of the general acceptance of the performance advantages of the CBL protocol in the literature and its implementation in systems <ref> [4, 11, 2] </ref>.
Reference: [5] <author> M. Franklin, M. Zwilling, C. K. Tan, M. Carey, and D. DeWitt. </author> <title> Crash Recovery in Client-Server EXODUS. </title> <booktitle> In Proceeding of the 1992 ACM SIGMOD Conference, </booktitle> <pages> pages 165-174, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: However, the server follows a no-force policy, i.e., the server does not have to write back the dirty pages to disk at commit time <ref> [5] </ref>. Furthermore, we assume that index operations release physical locks acquired on index pages as soon as the operation is done using the page. 4.2.2 Results In our experiments we used different workloads (Hot-Cold, Uniform, and PrivateUpdate) to evaluate the performance of the RIC protocol and compare it with CBL. <p> We have shown qualitatively and through simulation studies the performance benefits of the RIC protocol both in terms of throughput and scalability. In this paper, we have not considered the recovery implications of RIC. However, we expect that recovery protocols, such as those described in <ref> [5, 18] </ref>, would be adequate because all writes under RIC are serialized and no transactions are aborted or rolled back due to inconsistent index accesses. In the RIC protocol, the unit of index coherence is a segment, and in this paper we have only considered segments that represent whole indexes.
Reference: [6] <author> V. Gottemukkala, E. Omiecinski, and U. Ramachandran. </author> <title> Relaxed Index Consistency for a Client-Server Database. </title> <type> Technical Report GIT-CC-95-33, </type> <institution> College of Computing, Georgia Institute of Technology, </institution> <address> Atlanta, GA, </address> <year> 1995. </year>
Reference-contexts: Detection and recovery of inconsistencies in other index operation cases is discussed in <ref> [6] </ref>. From the discussion we can see that the RIC protocol eliminates multi-point communication for index page coherence at the risk of extra processing for scan repositioning. <p> The reasons for these requirements are discussed in detail in <ref> [6] </ref>. In light of these requirements, a straightforward implementation of RIC would be that at each SP the coherence information exchanged contains the SCIS of all the index segments related to the data on which the lock is acquired. <p> Thus far we have assumed that all the transactions execute at Isolation Level 4 which ensures that index operations satisfy the two constraints for correct execution under RIC. In <ref> [6] </ref> we discuss how transactions executing at lower level of isolation can operate correctly under RIC. <p> In our future work we would also like to explore the usage of multiple-writer semantics, and fine-granularity locking, as suggested in [2], in the RIC protocol, and their impact on the throughput and scalability of the system. <ref> [6] </ref> contains a longer version of this paper.
Reference: [7] <author> J. Gray and A. Reuter. </author> <title> Transaction Processing: Concepts and Techniques. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1993. </year>
Reference-contexts: We assume, for the sake of this discussion, that the transactions execute at Isolation Level 4 (`Serializable') as specified in the SQL-92 standard [12] which requires index operations to support repeatable reads (RR) and avoid phantoms <ref> [7, 13] </ref>. Index operations typically meet this requirement by using key-range locking which involves, besides locking all the relevant index items, locking an item adjacent (previous-key or next-key) to the relevant index items. We assume that previous-key locking is used. Furthermore, we assume that a B+-Tree index is used.
Reference: [8] <author> J. Howard et al. </author> <title> Scale and Performance in a Distributed File System. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1), </volume> <month> February </month> <year> 1988. </year>
Reference-contexts: The Callback Locking protocol used for data locking in RIC was originally proposed for file caching in AFS <ref> [8] </ref>. This protocol was enhanced and adapted for caching in transactional systems in [11, 20, 4].
Reference: [9] <author> T. Johnson and A. Colbrook. </author> <title> A Distributed Data-balanced Dictionary based on the B-link Tree. </title> <booktitle> In Proceedings of the International Parallel Processing Symposium, </booktitle> <pages> pages 319-325, </pages> <year> 1992. </year>
Reference-contexts: Furthermore, explicit locks have to be obtained on each of the leaf nodes. Both these restrictions are eliminated in our scheme where we exploit the semantics of the concurrency control operations that are used to enforce transaction consistency. In <ref> [9, 10] </ref> the authors propose index maintenance schemes in a distributed memory environment.
Reference: [10] <author> T. Johnson and P. Krishna. </author> <title> Lazy Updates for Distributed Search Structure. </title> <booktitle> In Proceedings of the 1993 ACM SIGMOD Conference, </booktitle> <pages> pages 337-346, </pages> <year> 1993. </year>
Reference-contexts: Furthermore, explicit locks have to be obtained on each of the leaf nodes. Both these restrictions are eliminated in our scheme where we exploit the semantics of the concurrency control operations that are used to enforce transaction consistency. In <ref> [9, 10] </ref> the authors propose index maintenance schemes in a distributed memory environment.
Reference: [11] <author> C. Lamb, G. Landis, J. Orenstein, and D. Weinreb. </author> <title> The Ob-jectStore Database System. </title> <journal> Communications of the ACM, </journal> <volume> 34(10) </volume> <pages> 50-63, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: The Callback Locking protocol used for data locking in RIC was originally proposed for file caching in AFS [8]. This protocol was enhanced and adapted for caching in transactional systems in <ref> [11, 20, 4] </ref>. <p> We compare the RIC protocol with the Callback Locking (CBL) protocol because of the general acceptance of the performance advantages of the CBL protocol in the literature and its implementation in systems <ref> [4, 11, 2] </ref>.
Reference: [12] <author> J. Melton and A. R. Simon. </author> <title> Understanding the New SQL: A Complete Guide. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1993. </year>
Reference-contexts: We assume, for the sake of this discussion, that the transactions execute at Isolation Level 4 (`Serializable') as specified in the SQL-92 standard <ref> [12] </ref> which requires index operations to support repeatable reads (RR) and avoid phantoms [7, 13]. Index operations typically meet this requirement by using key-range locking which involves, besides locking all the relevant index items, locking an item adjacent (previous-key or next-key) to the relevant index items.
Reference: [13] <author> C. Mohan. ARIES/KVL: </author> <title> A Key-Value Locking Method for Con-currency Control of Multiaction Transactions Operation on B-Tree Indexes. </title> <booktitle> In Proceedings of the 16th VLDB Conference, </booktitle> <month> August </month> <year> 1990. </year>
Reference-contexts: We assume, for the sake of this discussion, that the transactions execute at Isolation Level 4 (`Serializable') as specified in the SQL-92 standard [12] which requires index operations to support repeatable reads (RR) and avoid phantoms <ref> [7, 13] </ref>. Index operations typically meet this requirement by using key-range locking which involves, besides locking all the relevant index items, locking an item adjacent (previous-key or next-key) to the relevant index items. We assume that previous-key locking is used. Furthermore, we assume that a B+-Tree index is used.
Reference: [14] <author> C. Mohan. </author> <title> Interactions Between Query Optimization and Con-currency Control. </title> <booktitle> In Proceedings of the International Workshop on Research Issues on Data Engineering: Transaction and Query Processing, </booktitle> <pages> pages 26-35, </pages> <month> February </month> <year> 1992. </year>
Reference-contexts: Data-only locking implies that when an index item is locked, the lock is actually acquired on the referred-to data item (page or record lock based on lock granularity). Data-only locking significantly reduces the actual number of locks that have to be acquired by a transaction <ref> [14] </ref> which directly contributes to a reduction in the number of messages in the system. Our objective is to use data-only locking for concur-rency control and at the same time take advantage of the potential to relax the coherence maintenance for index pages.
Reference: [15] <author> C. Mohan. </author> <title> Less Optimism About Optimistic Concurrency Control. </title> <editor> In P. S. Yu, editor, </editor> <booktitle> Proceedings of the International Workshop on Research Issues on Data Engineering: Transaction and Query Processing, </booktitle> <pages> pages 199-204. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> February </month> <year> 1992. </year>
Reference-contexts: In the following, we outline our approach to satisfying these guidelines. 2.1 Consistency requirements C&CC protocols can be broadly classified into optimistic and pessimistic protocols. As pointed out in <ref> [15] </ref>, there are several practical problems in implementing optimistic protocols, such as space management, access path maintenance.
Reference: [16] <author> C. Mohan and I. Narang. </author> <title> Recovery and Coherency-Control Protocols for Fast Intersystem Page Transfer and Fine-Granularity Locking in a Shared Disks Transaction Environment. </title> <booktitle> In Proceedings of the 17th VLDB Conference, </booktitle> <month> September </month> <year> 1991. </year>
Reference-contexts: Furthermore, the algorithms present the index page access in isolation from the data page access and hence do not consider the possibility of the integration of C&CC as our scheme does. In <ref> [16] </ref> C&CC protocols that allow multiple readers and a single writer simultaneously are presented, but these protocols do not distinguish between index pages and data pages. The coherence of a page is enforced when a logical lock on an item in that page is acquired.
Reference: [17] <author> C. Mohan and I. Narang. </author> <title> Efficient Locking and Caching of Data in the Multisystem Shared Disks Transactions Environment. </title> <booktitle> In Proceedings of the 3rd International Conference on Extending Database Technology, </booktitle> <pages> pages 453-468, </pages> <year> 1992. </year>
Reference-contexts: of an index when an index item is locked using data-only locking thus combining coherence actions on index pages with C&CC of data pages. 2.4 Related Work There is an extremely large body of work in the literature regarding coherence and consistency maintenance of data in various data sharing environments <ref> [3, 22, 20, 1, 17] </ref>. However, this entire body of work treats all the data uniformly, i.e., the same protocol is used for both data and non-data pages, which leads to unnecessary inter-node interactions in the case of non-data pages.
Reference: [18] <author> C. Mohan and I. Narang. ARIES/CSA: </author> <title> A Method for Database Recovery in Client-Server Architectures. </title> <booktitle> In Proceedings of the 1994 SIGMOD Conference, </booktitle> <pages> pages 55-66, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: We have shown qualitatively and through simulation studies the performance benefits of the RIC protocol both in terms of throughput and scalability. In this paper, we have not considered the recovery implications of RIC. However, we expect that recovery protocols, such as those described in <ref> [5, 18] </ref>, would be adequate because all writes under RIC are serialized and no transactions are aborted or rolled back due to inconsistent index accesses. In the RIC protocol, the unit of index coherence is a segment, and in this paper we have only considered segments that represent whole indexes.
Reference: [19] <author> H. Schwetman. </author> <title> CSIM Users' Guide, </title> <month> March </month> <year> 1990. </year>
Reference-contexts: message sizes (index coherence information), additional local computation (index consistency checks), and state information (per node SCIS). 4.2 Quantitative analysis 4.2.1 Simulation model In order to quantitatively study the performance characteristics of relaxed index consistency and compare it with callback locking, we developed a process-oriented simulation model based on CSIM <ref> [19] </ref>.
Reference: [20] <author> Y. Wang and L. A. Rowe. </author> <title> Cache Consistency and Concurrency Control in a Client/Server DBMS Architecture. </title> <booktitle> In Proceedings of the 1991 ACM SIGMOD Conference, </booktitle> <year> 1991. </year>
Reference-contexts: In fact, the server does not even keep track of clients that cache index pages in shared mode. As for data pages, the server uses an enhanced Callback Locking (CBL) protocol <ref> [4, 20] </ref> to grant a client's page request. The CBL protocol is enhanced for RIC so that the server, in addition to granting the requested data page, sends coherence information for the indexes relevant to the requested data page (see the grant request step in Fig ure 1). <p> of an index when an index item is locked using data-only locking thus combining coherence actions on index pages with C&CC of data pages. 2.4 Related Work There is an extremely large body of work in the literature regarding coherence and consistency maintenance of data in various data sharing environments <ref> [3, 22, 20, 1, 17] </ref>. However, this entire body of work treats all the data uniformly, i.e., the same protocol is used for both data and non-data pages, which leads to unnecessary inter-node interactions in the case of non-data pages. <p> The Callback Locking protocol used for data locking in RIC was originally proposed for file caching in AFS [8]. This protocol was enhanced and adapted for caching in transactional systems in <ref> [11, 20, 4] </ref>.
Reference: [21] <author> W. E. Weihl and P. Wang. </author> <title> Multi-Version Memory: Software Cache Management for Concurrent B-Trees. </title> <booktitle> In Proceedings of the IEEE Symposium on Parallel and Distributed Processing, </booktitle> <pages> pages 650-655, </pages> <year> 1990. </year>
Reference-contexts: There is also a large body of work regarding coherence and consistency maintenance of indexes in a distributed setting. In <ref> [21] </ref> the general dictionary lookup/maintenance algorithm for coherent shared memory is transformed to run on a software cache coherence scheme called multi-version memory which provides weaker semantics than coherent shared memory.
Reference: [22] <author> K. Wilkinson and M-A. Neimat. </author> <title> Maintaining Consistency of Client-Cached Data. </title> <booktitle> In Proceedings of the 16th VLDB Conference, </booktitle> <pages> pages 122-133, </pages> <year> 1990. </year>
Reference-contexts: of an index when an index item is locked using data-only locking thus combining coherence actions on index pages with C&CC of data pages. 2.4 Related Work There is an extremely large body of work in the literature regarding coherence and consistency maintenance of data in various data sharing environments <ref> [3, 22, 20, 1, 17] </ref>. However, this entire body of work treats all the data uniformly, i.e., the same protocol is used for both data and non-data pages, which leads to unnecessary inter-node interactions in the case of non-data pages.
References-found: 22

