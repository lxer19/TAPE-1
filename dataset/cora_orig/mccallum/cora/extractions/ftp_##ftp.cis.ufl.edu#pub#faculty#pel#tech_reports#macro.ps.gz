URL: ftp://ftp.cis.ufl.edu/pub/faculty/pel/tech_reports/macro.ps.gz
Refering-URL: http://www.cis.ufl.edu/~pel/Ghinsu/gghinsu.html
Root-URL: http://www.cis.ufl.edu
Title: Understanding Code Containing Preprocessor Constructs  
Author: Panos E. Livadas David T. Small 
Date: May 23, 1994  
Address: Gainesville, FL 32611  
Affiliation: Computer and Information Sciences Department University of Florida  
Abstract: Understanding, debugging, and maintaining software is a costly and difficult task. The difficulties are exacerbated in programs written to take advantage of preprocessing facilities. This paper examines problems associated with source code containing preprocessor constructs|i.e., included files, conditional compilation, and macros. We define the useful mappings from tokens in the preprocessor's output to the source file(s), and propose that by capturing these correspondences an internal program representation can be built which will allow for the use of maintenance techniques including program slicing, ripple analysis, and dicing. The method presented is generic; to illustrate that the technique is feasible, we discuss ANSI C preprocessor constructs|in particular, macro substitution|and explain the modus developed to handle them in Ghinsu|an integrated maintenance environment for ANSI C programs.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Badger, L., and Weiser, M. </author> <title> Minimizing communications for synchronizing parallel dataflow programs. </title> <booktitle> In Proceedings of the 1988 International Conference on Parallel Processing (University Park, </booktitle> <address> PA., </address> <month> August </month> <year> 1988), </year> <institution> Penn State University Press. </institution>
Reference-contexts: In addition, slicing can aide in program understanding by decomposing a program into meaningful smaller components. Moreover, Horwitz [5] has used the concepts of slicing in integrating program variants and Badger <ref> [1] </ref> has demonstrated how slicing can be used for automatic parallelization. Furthermore, slicing assists with code resuability. <p> Several references will be made to the following code fragment which we will call main.c: <ref> [1] </ref> #define ONE 1 [2] #define CPLUSONE ( c + ONE ) [3] #define DPLUS (X) ( d + X ) [4] [5] f = DPLUS ( DPLUS ( CPLUSONE ) ); It would be expanded by a normal preprocessor to: f = ( d + ( d + ( c
Reference: [2] <author> Boehm, B. </author> <title> The high cost of software. In Practical Strategies for Developing Large Software Systems, </title> <editor> E. Horowitz, Ed. </editor> <publisher> Addison-Wesley, </publisher> <address> Reading, MA., </address> <year> 1975. </year>
Reference-contexts: Several references will be made to the following code fragment which we will call main.c: [1] #define ONE 1 <ref> [2] </ref> #define CPLUSONE ( c + ONE ) [3] #define DPLUS (X) ( d + X ) [4] [5] f = DPLUS ( DPLUS ( CPLUSONE ) ); It would be expanded by a normal preprocessor to: f = ( d + ( d + ( c + 1 ) )
Reference: [3] <author> Brian W, K., and Ritchie, D. M. </author> <title> The C Programming Language, second ed. </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: Several references will be made to the following code fragment which we will call main.c: [1] #define ONE 1 [2] #define CPLUSONE ( c + ONE ) <ref> [3] </ref> #define DPLUS (X) ( d + X ) [4] [5] f = DPLUS ( DPLUS ( CPLUSONE ) ); It would be expanded by a normal preprocessor to: f = ( d + ( d + ( c + 1 ) ) ); GPP's output, shown in figure 4, retains
Reference: [4] <author> Croll, S. </author> <title> Towards an internal program representation: The ghinsu core. </title> <type> Master's thesis, </type> <institution> University of Florida, </institution> <year> 1994. </year>
Reference-contexts: Additionally, ripple analysis may help the maintainer estimate the time and resources needed to effect a program modification based on the size and/or configuration of the resultant ripple. 3 The Internal Program Representation In <ref> [9, 8, 4] </ref> we describe an internal program representation which is a parse tree based system dependence graph (SDG)|an extension of the statement based SDG proposed in [6]. Informally, the SDG is a labeled, directed, multigraph where each vertex represents a program construct|e.g., declarations, assignment statements, control predicates, and tokens. <p> Several references will be made to the following code fragment which we will call main.c: [1] #define ONE 1 [2] #define CPLUSONE ( c + ONE ) [3] #define DPLUS (X) ( d + X ) <ref> [4] </ref> [5] f = DPLUS ( DPLUS ( CPLUSONE ) ); It would be expanded by a normal preprocessor to: f = ( d + ( d + ( c + 1 ) ) ); GPP's output, shown in figure 4, retains the ff, fi, fl, and *-mappings, and is consequently
Reference: [5] <author> Horwitz, S., Prins, J., and Reps, T. </author> <title> Integrating non-interfering versions of programs. </title> <booktitle> In 15th ACM Symposium on Principles of Programming Languages (New York, 1988), </booktitle> <publisher> ACM Press. </publisher>
Reference-contexts: By obtaining a slice of v at n, we may extract a significantly smaller piece of code to examine, and thus allowing us to more readily locate the bug. In addition, slicing can aide in program understanding by decomposing a program into meaningful smaller components. Moreover, Horwitz <ref> [5] </ref> has used the concepts of slicing in integrating program variants and Badger [1] has demonstrated how slicing can be used for automatic parallelization. Furthermore, slicing assists with code resuability. <p> Several references will be made to the following code fragment which we will call main.c: [1] #define ONE 1 [2] #define CPLUSONE ( c + ONE ) [3] #define DPLUS (X) ( d + X ) [4] <ref> [5] </ref> f = DPLUS ( DPLUS ( CPLUSONE ) ); It would be expanded by a normal preprocessor to: f = ( d + ( d + ( c + 1 ) ) ); GPP's output, shown in figure 4, retains the ff, fi, fl, and *-mappings, and is consequently verbose.
Reference: [6] <author> Horwitz, S., Reps, T., and Binkley, D. </author> <title> Interprocedural slicing using dependence graphs. </title> <journal> ACM Transactions on Programming Languages and Systems 12, </journal> <month> 1 (January </month> <year> 1990). </year>
Reference-contexts: This definition is less general than the one given in [12]; but, it is sufficient <ref> [6] </ref>. An example of a program slice was shown in figure 1. Program slices can be used in a variety of ways to aid in several software engineering activities such as the ones that are briefly discussed below. Empirical studies have show that programmers use slices when debugging. <p> resources needed to effect a program modification based on the size and/or configuration of the resultant ripple. 3 The Internal Program Representation In [9, 8, 4] we describe an internal program representation which is a parse tree based system dependence graph (SDG)|an extension of the statement based SDG proposed in <ref> [6] </ref>. Informally, the SDG is a labeled, directed, multigraph where each vertex represents a program construct|e.g., declarations, assignment statements, control predicates, and tokens. Edges are labeled to distinguish which of the several kinds of dependencies between connected vertices is represented.
Reference: [7] <author> Lientz, B., and Swanson, E. </author> <title> Software Maintenance Management. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA., </address> <year> 1980. </year>
Reference-contexts: 1 Introduction Software maintenance is an expensive, demanding, and ongoing process. Lientz and Swanson <ref> [7] </ref> report that large organizations typically devote 50% of their total programming effort to maintenance.
Reference: [8] <author> Livadas, P. E., and Croll, S. </author> <title> System dependence graphs based on parse trees and their use in software maintenance. </title> <journal> Journal of Information Sciences 76, </journal> <month> 3/4 (February </month> <year> 1994). </year>
Reference-contexts: Additionally, ripple analysis may help the maintainer estimate the time and resources needed to effect a program modification based on the size and/or configuration of the resultant ripple. 3 The Internal Program Representation In <ref> [9, 8, 4] </ref> we describe an internal program representation which is a parse tree based system dependence graph (SDG)|an extension of the statement based SDG proposed in [6]. Informally, the SDG is a labeled, directed, multigraph where each vertex represents a program construct|e.g., declarations, assignment statements, control predicates, and tokens.
Reference: [9] <author> Livadas, P. E., and Croll, S. </author> <title> A new algorithm for the calculation of transitive dependences. </title> <note> Journal of Software Maintenance ((accepted)). </note>
Reference-contexts: Additionally, ripple analysis may help the maintainer estimate the time and resources needed to effect a program modification based on the size and/or configuration of the resultant ripple. 3 The Internal Program Representation In <ref> [9, 8, 4] </ref> we describe an internal program representation which is a parse tree based system dependence graph (SDG)|an extension of the statement based SDG proposed in [6]. Informally, the SDG is a labeled, directed, multigraph where each vertex represents a program construct|e.g., declarations, assignment statements, control predicates, and tokens.
Reference: [10] <author> Lyle, J., and Weiser, M. </author> <title> Automatic program bug location by program slicing. </title> <booktitle> In 2nd International Conference on Computers and Applications (1987). </booktitle>
Reference-contexts: Also, a number of metrics based on program slicing have been proposed [12] which include coverage, component overlap, functional clustering, parallelism, and tightness. Dicing, a tool based on slicing, can be used to aid in debugging by automatically locating certain errors <ref> [10] </ref>. Dicing is a powerful heuristic which can further reduce the amount of code on which the programmer must concentrate. <p> Dicing can therefore be used iteratively to locate a program bug <ref> [10] </ref>. Another analysis tool called the ripple analyzer can be thought of as a "forward" slicer. It finds all statements that are dependent upon a given statement. This tool can be used to visualize the statements that will be affected by a change made at any given statement.
Reference: [11] <author> Platoff, M., Wagner, M., and Camaratta, J. </author> <title> An integrated program presentation and toolkit for the maintenance of c programs. </title> <booktitle> In Proceedings of Conference on Software Maintenance (1991). </booktitle>
Reference-contexts: However, without a preprocessor, Ghinsu was unable to accept real world programs|i.e., those with #include-ed files, macros, and conditional compilation directives. Support for file inclusion and conditional compilation could be implemented easily; the difficulty lies in macro substitutions. Were we to generalize macros as pseudo-identifiers and pseudo-functions|as in <ref> [11] </ref>| we would be unable to account for many of their uses. 3 Having eliminated that approach, we are faced with the laborious process of relating each token produced by the preprocessor to appropriate points in the source code.
Reference: [12] <author> Weiser, M. </author> <title> Programmers use slices when debugging. </title> <journal> Communications ACM 25, </journal> <month> 7 (July </month> <year> 1982). </year> <month> 16 </month>
Reference-contexts: A static slice of P relative to the slicing criterion hp; vi is defined as the set of all statements and predicates of P that might affect the value of the variable v at point p. This definition is less general than the one given in <ref> [12] </ref>; but, it is sufficient [6]. An example of a program slice was shown in figure 1. Program slices can be used in a variety of ways to aid in several software engineering activities such as the ones that are briefly discussed below. <p> Also, a number of metrics based on program slicing have been proposed <ref> [12] </ref> which include coverage, component overlap, functional clustering, parallelism, and tightness. Dicing, a tool based on slicing, can be used to aid in debugging by automatically locating certain errors [10]. Dicing is a powerful heuristic which can further reduce the amount of code on which the programmer must concentrate.
References-found: 12

