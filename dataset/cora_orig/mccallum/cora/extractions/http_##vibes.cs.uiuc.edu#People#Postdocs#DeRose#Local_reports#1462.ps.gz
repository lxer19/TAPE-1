URL: http://vibes.cs.uiuc.edu/People/Postdocs/DeRose/Local_reports/1462.ps.gz
Refering-URL: http://vibes.cs.uiuc.edu/People/Postdocs/DeRose/falcon_publications.html
Root-URL: http://www.cs.uiuc.edu
Title: A MATLAB to Fortran 90 Translator and its Effectiveness  
Author: Luiz De Rose and David Padua 
Affiliation: Center for Supercomputing Research and Development University of Illinois at Urbana-Champaign  
Date: May 1996  March 1996  
Address: Philadelphia, PA,  1308 West Main Street Urbana, Illinois 61801  
Note: in the Proceedings of the 10th ACM International Conference on Supercomputing ICS'96. pages 309-316.  
Pubnum: CSRD Report No. 1462  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> AHO, A., SETHI, R., AND ULLMAN, J. </author> <booktitle> Compilers: Principles, Techniques and Tools. </booktitle> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1985. </year>
Reference-contexts: INTEGER, REAL, COMPLEX, or LOGICAL); rank (i.e. SCALAR, VECTOR, or MATRIX); and shape (i.e. size of each dimension). These variable properties are estimated using a forward/backward propagation strategy <ref> [1] </ref>. Our inference mechanism extracts the initial type information from four sources: program constants whose intrinsic type, rank, and shape are statically known; input files; operators; and functions.
Reference: [2] <author> BARRETT, R., BERRY, M., CHAN, T., DEMMEL, J., DONATO, J., DONGARRA, J., EIJKHOUT, V., POZO, R., ROMINE, C., AND VAN DER VORST, H. </author> <title> Templates for the Solution of Linear Systems: Building Blocks for Iterative Methods. </title> <publisher> SIAM, </publisher> <year> 1993. </year>
Reference-contexts: Simpson's rule (AQ) a 1 Dim. (7) Conjugate Gradient method (CG) b 420 fi 420 Generation of a 3D-surface (3D) c 41fi21fi11 Dirichlet Method for Laplace's Equation (Di) a 40 fi 40 Finite difference solution to the wave equation (FD) a 451 fi 451 Sources: a From [17]; b From <ref> [2] </ref>; c Colleagues Table 4: Test programs. 4 Experimental Results To measure both the effectiveness of the internal phases of the inference mechanism and the overall effectiveness of the compiler, we performed two sets of experiments. <p> b 420 fi 420 Quasi-Minimal Residual method (QMR) b 420 fi 420 Crank-Nicholson solution to the heat equation (CN) a 321 fi 321 Two body problem using 4th order Runge-Kutta (RK) d 3200 steps Two body problem using Euler-Cromer method (EC) d 6240 steps Sources: a From [17]; b From <ref> [2] </ref>; d From [11] Table 6: Additional test programs. in parenthesis. with the Sun Fortran 77 compiler using the optimization flag O3. The MEX-files generated by MCC were compiled with the GNU C compiler using the optimization flag O3.
Reference: [3] <author> BLUME, W., AND EIGENMANN, R. </author> <title> The Range Test: A Dependence Test for Symbolic, Non-linear Expressions. </title> <booktitle> In Proceedings of Supercomputing '94 (November 1994), </booktitle> <pages> pp. 528-537. </pages>
Reference-contexts: To determine whether there is definition coverage we use a dimension propagation algorithm with symbolic capabilities. This algorithm is similar to the range propagation algorithm used by Blume and Eigenmann for the Range Test <ref> [3] </ref>. Since all matrices in MATLAB have lower dimensions set to 1, our problem is simplified to determining whether the maximum value that an array index will reach is larger than the corresponding dimension in the previous assignment of the variable.
Reference: [4] <author> BLUME, W., EIGENMANN, R., FAIGIN, K., GROUT, J., HOE-FLINGER, J., PADUA, D., PETERSEN, P., POTTENGER, B., RAUCHWERGER, L., TU, P., AND WEATHERFORD, S. </author> <title> Polaris: Improving the Effectiveness of Parallelizing Compilers. In Languages and Compilers for Parallel Computing (August 1994), </title> <editor> K. Pingali, U. Banerjee, D. Gelernter, A. Nicolau, and D. Padua, Eds., </editor> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> vol. 892, </volume> <publisher> Springer-Verlag, </publisher> <pages> pp. 141-154. </pages> <booktitle> 7th International Workshop, </booktitle> <address> Ithaca, NY, USA. </address>
Reference-contexts: This work is not necessarily representative of the positions or policies of the Army or the Government. 1 MATLAB is a trademark of The MathWorks, Inc. tiveness. Our ultimate goal is to generate parallel code by integrating FALCON with Polaris <ref> [4] </ref>, a parallelizing compiler developed at Illinois. In this paper, we focus exclusively on the techniques we use to generate effective sequential code.
Reference: [5] <author> BUDD, T. </author> <title> An APL Compiler. </title> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: Type inference algorithms, including some developed for languages that are quite similar to MATLAB such as SETL [19] and APL <ref> [5, 6] </ref>, have been developed in the past. In the work reported here, we apply these type inference techniques with extensions from approaches that were originally developed to analyze and represent array accesses in Fortran [20].
Reference: [6] <author> CHING, W.-M. </author> <title> Program Analysis and Code Generation in an APL/370 Compiler. </title> <journal> IBM Journal of Research and Development 30:6 (November 1986), </journal> <pages> 594-602. </pages>
Reference-contexts: Type inference algorithms, including some developed for languages that are quite similar to MATLAB such as SETL [19] and APL <ref> [5, 6] </ref>, have been developed in the past. In the work reported here, we apply these type inference techniques with extensions from approaches that were originally developed to analyze and represent array accesses in Fortran [20].
Reference: [7] <author> CYTRON, R., FERRANTE, J., ROSEN, B. K., WEGMAN, M. N., AND ZADECK, F. K. </author> <title> Efficiently Computing Static Single Assignment Form and the Control Dependence Graph. </title> <journal> ACM Transactions on Programming Language and Systems 13, </journal> <month> 4 (October </month> <year> 1991), </year> <pages> 451-490. </pages>
Reference-contexts: An example of an identifier of the kind Multiple is i in Figure 1. 2.2 Internal Representation Our static inference algorithms are applied to a Static Single Assignment (SSA) representation <ref> [7] </ref> of the MATLAB program. In the SSA representation, each variable is assigned a value by at most one statement. <p> In situations like this, we use the standard approach and transform indexed assignments of the form A (R) = ...;, where R is an arbitrary range, into A i+1 = ff (A i , R, RHS); The ff function we use is similar to the Update function described in <ref> [7] </ref>, but extended for assignments to a matrix range. In the case of MATLAB, an ff function may return an array with dimensions larger than that of the parameter array.
Reference: [8] <author> DEROSE, L., GALLIVAN, K., GALLOPOULOS, E., MARSOLF, B., AND PADUA, D. </author> <title> FALCON: A MATLAB Interactive Restructuring Compiler. In Languages and Compilers for Parallel Computing (August 1995), </title> <editor> C.-H. Huang, P. Sadayap-pan, U. Banerjee, D. Gelernter, A. Nicolau, and D. Padua, Eds., </editor> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> vol. 1033, </volume> <publisher> Springer-Verlag, </publisher> <pages> pp. 269-288. </pages> <booktitle> 8th International Workshop, </booktitle> <address> Columbus, Ohio. </address>
Reference-contexts: 1 Introduction The development of software for scientific computation on high performance computers is a difficult and time-consuming task. We are studying strategies to facilitate this process, and are implementing them in FALCON <ref> [8, 9] </ref>, a programming environment for the development of scientific libraries and applications. Program development in FALCON starts with a prototype and proceeds with a sequence of automatic and interactive transformations until an effective program or routine is obtained.
Reference: [9] <author> DEROSE, L., GALLIVAN, K., GALLOPOULOS, E., MARSOLF, B., AND PADUA, D. </author> <title> FALCON: An Environment for the Development of Scientific Libraries and Applications. </title> <booktitle> In Proc. of the KBUP95: First international workshop on Knowledge-Based systems for the (re)Use of Program libraries (Sophia Antipolis, </booktitle> <address> France, </address> <month> November </month> <year> 1995). </year>
Reference-contexts: 1 Introduction The development of software for scientific computation on high performance computers is a difficult and time-consuming task. We are studying strategies to facilitate this process, and are implementing them in FALCON <ref> [8, 9] </ref>, a programming environment for the development of scientific libraries and applications. Program development in FALCON starts with a prototype and proceeds with a sequence of automatic and interactive transformations until an effective program or routine is obtained.
Reference: [10] <author> DRAKENBERG, P., JACOBSON, P., AND KAGSTROM, B. </author> <title> A CON-LAB Compiler for a Distributed Memory Multicomputer. </title> <booktitle> In Proceedings of the 6th SIAM Conference on Parallel Processing for Scientific Computing, </booktitle> <address> Norfolk Va (March 1993). </address>
Reference-contexts: CONLAB [13] is an interactive environment for developing algorithms for parallel computer architectures. It uses a subset of the MATLAB language, with extensions for expressing parallelism, synchronization, and communication. A translator from CONLAB to C was developed by Drakenberg et al. <ref> [10] </ref>. Some sort of type inference system is alluded to by the authors in their papers, but it is not described. A simple approach for the translation of MATLAB programs into C++ is presented in [14].
Reference: [11] <author> GARCIA, A. L. </author> <title> Numerical Methods for Physics. </title> <publisher> Prentice Hall, </publisher> <year> 1994. </year>
Reference-contexts: 420 Quasi-Minimal Residual method (QMR) b 420 fi 420 Crank-Nicholson solution to the heat equation (CN) a 321 fi 321 Two body problem using 4th order Runge-Kutta (RK) d 3200 steps Two body problem using Euler-Cromer method (EC) d 6240 steps Sources: a From [17]; b From [2]; d From <ref> [11] </ref> Table 6: Additional test programs. in parenthesis. with the Sun Fortran 77 compiler using the optimization flag O3. The MEX-files generated by MCC were compiled with the GNU C compiler using the optimization flag O3.
Reference: [12] <author> GILMAN, L., AND ROSE, A. </author> <title> APL : An Interactive Approach. </title> <publisher> Wiley, </publisher> <year> 1984. </year>
Reference-contexts: The prototype and intermediate versions of the code are represented in the MATLAB language [15]; we chose MATLAB over other interactive array languages, such as APL <ref> [12] </ref>, because of its popularity and its clean, well-structured design. MATLAB does not require variable declarations which, in the opinion of some, simplifies the programmer's task.
Reference: [13] <author> JACOBSON, P., KAGSTROM, B., AND RANNAR, M. </author> <title> Algorithm Development for Distributed Memory Multicomputers Using CONLAB. </title> <booktitle> Scientific Programming 1 (1992), </booktitle> <pages> 185-203. </pages>
Reference-contexts: These approaches range from research projects to commercial products. CONLAB <ref> [13] </ref> is an interactive environment for developing algorithms for parallel computer architectures. It uses a subset of the MATLAB language, with extensions for expressing parallelism, synchronization, and communication. A translator from CONLAB to C was developed by Drakenberg et al. [10].
Reference: [14] <author> KEREN, Y. MATCOM: </author> <title> A MATLAB to C++ Translator and Support Libraries. </title> <institution> Technion, Israel Institute of Technology, </institution> <year> 1995. </year>
Reference-contexts: A translator from CONLAB to C was developed by Drakenberg et al. [10]. Some sort of type inference system is alluded to by the authors in their papers, but it is not described. A simple approach for the translation of MATLAB programs into C++ is presented in <ref> [14] </ref>. In this work, a matrix class was created to take care of all type and shape inference decisions during execution time. This class is then utilized by the generated C++. Effectively, the control structure is compiled, but all the mathematical operations are still interpreted within this matrix class.
Reference: [15] <author> THE MATH WORKS, INC. </author> <title> MATLAB, High-Performance Numeric Computation and Visualization Software. User's Guide, </title> <year> 1992. </year>
Reference-contexts: Program development in FALCON starts with a prototype and proceeds with a sequence of automatic and interactive transformations until an effective program or routine is obtained. The prototype and intermediate versions of the code are represented in the MATLAB language <ref> [15] </ref>; we chose MATLAB over other interactive array languages, such as APL [12], because of its popularity and its clean, well-structured design. MATLAB does not require variable declarations which, in the opinion of some, simplifies the programmer's task.
Reference: [16] <institution> THE MATH WORKS, INC. MATLAB Compiler, </institution> <year> 1995. </year>
Reference-contexts: This class is then utilized by the generated C++. Effectively, the control structure is compiled, but all the mathematical operations are still interpreted within this matrix class. Recently, MathWorks released MCC, a MATLAB compiler <ref> [16] </ref> that translates MATLAB programs into C for stand-alone external applications, or into C MEX-files 9 , which are called within the MATLAB environment. From [16], it appears that MCC performs only simple inference and relies upon user-provided flags, pragmas, and assertions, that specify the type or rank of variables, to <p> Recently, MathWorks released MCC, a MATLAB compiler <ref> [16] </ref> that translates MATLAB programs into C for stand-alone external applications, or into C MEX-files 9 , which are called within the MATLAB environment. From [16], it appears that MCC performs only simple inference and relies upon user-provided flags, pragmas, and assertions, that specify the type or rank of variables, to optimize the generated code.
Reference: [17] <author> MATHEWS, J. H. </author> <title> Numerical Methods for Mathematics, </title> <booktitle> Science and Engineering, 2nd ed. </booktitle> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: Adaptive Quadrature using Simpson's rule (AQ) a 1 Dim. (7) Conjugate Gradient method (CG) b 420 fi 420 Generation of a 3D-surface (3D) c 41fi21fi11 Dirichlet Method for Laplace's Equation (Di) a 40 fi 40 Finite difference solution to the wave equation (FD) a 451 fi 451 Sources: a From <ref> [17] </ref>; b From [2]; c Colleagues Table 4: Test programs. 4 Experimental Results To measure both the effectiveness of the internal phases of the inference mechanism and the overall effectiveness of the compiler, we performed two sets of experiments. <p> Overrelaxation method (SOR) b 420 fi 420 Quasi-Minimal Residual method (QMR) b 420 fi 420 Crank-Nicholson solution to the heat equation (CN) a 321 fi 321 Two body problem using 4th order Runge-Kutta (RK) d 3200 steps Two body problem using Euler-Cromer method (EC) d 6240 steps Sources: a From <ref> [17] </ref>; b From [2]; d From [11] Table 6: Additional test programs. in parenthesis. with the Sun Fortran 77 compiler using the optimization flag O3. The MEX-files generated by MCC were compiled with the GNU C compiler using the optimization flag O3.
Reference: [18] <author> PACIFIC-SIERRA RESEARCH CORPORATION. </author> <title> VAST-90 Fortran 90 Language System: User guide, </title> <editor> 2.1 ed., </editor> <year> 1993. </year>
Reference-contexts: Due to the lack of a native Fortran 90 compiler on our SPARCstation, the Fortran 90 programs were first translated to Fortran 77 with the use of VAST-90 <ref> [18] </ref>, and then compiled 9 MEX-files are MATLAB-callable C or Fortran dynamically linked subroutines that are built with a special interface module. 10 At this time we have only the MathWorks compiler available on a SPARCstation.
Reference: [19] <author> SCHWARTZ, J. T. </author> <title> Automatic Data Structure Choice in a Language of a Very High Level. </title> <booktitle> Communications of the ACM 18 (1975), </booktitle> <pages> 722-728. </pages>
Reference-contexts: Type inference algorithms, including some developed for languages that are quite similar to MATLAB such as SETL <ref> [19] </ref> and APL [5, 6], have been developed in the past. In the work reported here, we apply these type inference techniques with extensions from approaches that were originally developed to analyze and represent array accesses in Fortran [20]. <p> That is, it considers all Fortran 90 intrinsic data types except for CHARACTER. The static intrinsic type inference mechanism propagates types through expressions using a type algebra similar to that described in <ref> [19] </ref> for SETL. Tables containing for each operation the type of the result as a function of the type of the operands are used to implement this algebra. In some cases, the type of an expression 5 All matrices in MATLAB have lower dimension 1.
Reference: [20] <author> TU, P., AND PADUA, D. </author> <title> Gated SSA-Based Demand-Driven Symbolic Analysis for Parallelizing Compilers. </title> <booktitle> In Proceedings of the 9th ACM International Conference on Supercomputing (Barcelona, </booktitle> <address> Spain, </address> <month> July </month> <year> 1995), </year> <pages> pp. 414-423. </pages>
Reference-contexts: In the work reported here, we apply these type inference techniques with extensions from approaches that were originally developed to analyze and represent array accesses in Fortran <ref> [20] </ref>. These extensions are useful in the case of MATLAB, where arrays are often built using Fortran-like loops and where different sections of an array may be built in different program regions. In contrast, the techniques developed for APL assume that arrays are usually built by a single array operation. <p> Therefore, it is not necessary to generate dynamic allocation tests for these statements. All this information is obtained by tracing the indices of P to their previous definitions in the SSA representation of the program, following an on-demand approach similar to that introduced in <ref> [20] </ref>. In some situations (such as non-scalar indices or indirections), this symbolic inference is unable to determine the maximum value. In this case, the compiler sets the corresponding information as UNKNOWN, and dynamic allocation is required.
References-found: 20

