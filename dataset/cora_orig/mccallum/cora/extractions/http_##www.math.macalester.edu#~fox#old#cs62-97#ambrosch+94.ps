URL: http://www.math.macalester.edu/~fox/old/cs62-97/ambrosch+94.ps
Refering-URL: http://www.math.macalester.edu/~fox/old/cs62-97/page.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: fanton,fbeer,andig@mips.complang.tuwien.ac.at  
Phone: Tel.: (+43-1) 58801 f4459,3036,4462g  
Title: Dependence-Conscious Global Register Allocation  
Author: Wolfgang Ambrosch M. Anton Ertl Felix Beer Andreas Krall 
Address: Argentinierstrae 8, A-1040 Wien  
Affiliation: Institut fur Computersprachen Technische Universitat Wien  
Abstract: Register allocation and instruction scheduling are antagonistic optimizations: Whichever is applied first, it will impede the other. To solve this problem, we propose dependence-conscious colouring, a register allocation method that takes the dependence graph used by the instruction schedu-ler into consideration. Dependence-conscious colouring consists of two parts: First, the interference graph is built by analysing the dependence graphs, resulting in fewer interference edges and less spilling than the conventional preordering approach. Second, during colouring the register selection keeps dependence paths short, ensuring good scheduling. Dependence-conscious co-louring reduces the number of interference edges by 7%-24% and antidepen dences by 46%-100%.
Abstract-found: 1
Intro-found: 1
Reference: [AH82] <author> Marc Auslander and Martin Hopkins. </author> <title> An overview of the PL.8 compiler. </title> <booktitle> In SIGPLAN '82 [SIG82], </booktitle> <pages> pages 22-31. </pages>
Reference-contexts: Unfortunately we do not have speedup numbers, since the compiler back end was still under development and did not produce fully functional code. 7 Related Work The standard approach to the problem is to more or less ignore it. Scheduling is performed either before register allocation (prepass, <ref> [AH82] </ref>) or afterwards (postpass, [HG83]). With the prepass approach, scheduling has to be repeated after register allocation to schedule spill code. Prepass schedulers usually employ a register-saving heuristic, but only as low-priority secondary heuristic. Our approach is postpass scheduling, but our register allocator takes scheduling into consideration.
Reference: [BCKT89] <author> Preston Briggs, Keith D. Cooper, Ken Kennedy, and Linda Torczon. </author> <title> Coloring heuristics for register allocation. </title> <booktitle> In SIGPLAN '89 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 275-284, </pages> <year> 1989. </year>
Reference-contexts: The task of register allocation is to map these live ranges onto a finite register set. The standard approach to register allocation is graph colouring <ref> [CAC + 81, Cha82, BCKT89, CH90, Bri92b] </ref>. As the basis for dependence-conscious colouring, we used the algorithm presented in [BCKT89]. Figure 2 presents the phases of a graph colouring register allocator. Fig. 2. <p> The task of register allocation is to map these live ranges onto a finite register set. The standard approach to register allocation is graph colouring [CAC + 81, Cha82, BCKT89, CH90, Bri92b]. As the basis for dependence-conscious colouring, we used the algorithm presented in <ref> [BCKT89] </ref>. Figure 2 presents the phases of a graph colouring register allocator. Fig. 2. Conventional graph colouring and dependence-conscious colouring 3.1 The Interference Graph The basic data structure used by graph colouring register allocators is the interference graph. Every live range is represented by a node. <p> Note that Chaitins original algorithm cannot handle adding interference edges during colouring, because it performs spill decisions before colouring. However, Briggs' modification <ref> [BCKT89] </ref> can handle it. 5 Dependence-Conscious Register Selection For register allocation, it makes little difference, which of the available registers is selected [Bri92a]. But for the instruction scheduler the difference is important: Antidependences introduced by colouring can produce long dependence paths, which result in bad scheduling. <p> The costs of selecting a register for p3 This selection process may seem to be expensive. But graph colouring register allocation is dominated by the time for building the interference graph (e.g., 90% of the register allocation time in <ref> [BCKT89] </ref>), so making the colouring slower does not make much of a difference for the whole algorithm. Register selection is independent of the interference graph building method described in Section 4. <p> We compared a conventional colouring register allocator (<ref> [BCKT89] </ref>) to dependence-conscious colouring (DCC). In both cases the compiler schedules after the register allocation (postpass scheduling). The programs consist of several procedures that are compiled one at a time. The presented data is cumulated. program FFT Dhry register allocator [BCKT89] DCC [BCKT89] DCC initial interference edges 1024 948 1383 968 additional interference edges 0 81 all antidependences 407 0 713 382 redundant antidependences 0 23 Table 1. Results As expected, dependence-conscious colouring produces fewer interference edges while building the interference graph (initial interference edges). <p> We compared a conventional colouring register allocator (<ref> [BCKT89] </ref>) to dependence-conscious colouring (DCC). In both cases the compiler schedules after the register allocation (postpass scheduling). The programs consist of several procedures that are compiled one at a time. The presented data is cumulated. program FFT Dhry register allocator [BCKT89] DCC [BCKT89] DCC initial interference edges 1024 948 1383 968 additional interference edges 0 81 all antidependences 407 0 713 382 redundant antidependences 0 23 Table 1. Results As expected, dependence-conscious colouring produces fewer interference edges while building the interference graph (initial interference edges).
Reference: [BEH91] <author> David G. Bradlee, Susan J. Eggers, and Robert R. Henry. </author> <title> Integrating register allocation and instruction scheduling for RISCs. </title> <booktitle> In Architectural Support for Programming Languages and Operating Systems (ASPLOS-IV), </booktitle> <pages> pages 122-131, </pages> <year> 1991. </year>
Reference-contexts: DAG-driven register allocation tries to avoid introducing long paths into the dependence graph. The performance of both methods is about equal, with DAG-driven register allocation being simpler. Dependence-conscious colouring can be seen as the global version of DAG-driven register allocation. <ref> [BEH91] </ref> presents integrated prepass scheduling in a global register allocation setting and introduces register allocation with schedule estimates (RASE). In RASE, the global register allocator leaves a number of registers to the local allocator, which also performs instruction scheduling.
Reference: [Beu92] <author> Paul Beusterien. </author> <type> Personal communication, </type> <year> 1992. </year>
Reference-contexts: Prepass schedulers usually employ a register-saving heuristic, but only as low-priority secondary heuristic. Our approach is postpass scheduling, but our register allocator takes scheduling into consideration. The Harris C compiler uses postpass scheduling, but reallocates registers during scheduling to remove harmful dependences <ref> [Beu92] </ref>. In contrast, our register allocator tries to do it right the first time. In [GH88] two techniques for integrating local register allocation and instruction scheduling are introduced: Integrated prepass scheduling switches between scheduling for pipelining and scheduling for register allocation based on the number of available registers.
Reference: [Bri92a] <author> Preston Briggs. </author> <type> Personal communication, </type> <year> 1992. </year>
Reference-contexts: What register is given to the live range? For register allocation purposes, it does not make much of a difference, which of the legal registers is selected for colouring a node <ref> [Bri92a] </ref>. However, for scheduling it makes a big difference (see Section 5). What happens if there is no register available for a live range? The live range has to be spilled into memory. <p> Note that Chaitins original algorithm cannot handle adding interference edges during colouring, because it performs spill decisions before colouring. However, Briggs' modification [BCKT89] can handle it. 5 Dependence-Conscious Register Selection For register allocation, it makes little difference, which of the available registers is selected <ref> [Bri92a] </ref>. But for the instruction scheduler the difference is important: Antidependences introduced by colouring can produce long dependence paths, which result in bad scheduling. Therefore, dependence-conscious colouring carefully selects the registers. Colou-ring a live range with a register should introduce no antidependences or only redundant ones.
Reference: [Bri92b] <author> Preston Briggs. </author> <title> Register Allocation via Graph Coloring. </title> <type> PhD thesis, </type> <institution> Rice University, Houston, </institution> <year> 1992. </year>
Reference-contexts: The task of register allocation is to map these live ranges onto a finite register set. The standard approach to register allocation is graph colouring <ref> [CAC + 81, Cha82, BCKT89, CH90, Bri92b] </ref>. As the basis for dependence-conscious colouring, we used the algorithm presented in [BCKT89]. Figure 2 presents the phases of a graph colouring register allocator. Fig. 2.
Reference: [CAC + 81] <author> Gregory J. Chaitin, Marc A. Auslander, Ashok K. Chandra, John Cocke, Martin E. Hopkins, and Peter W. Markstein. </author> <title> Register allocation via coloring. </title> <journal> Computer Languages, </journal> <volume> 6(1) </volume> <pages> 45-57, </pages> <year> 1981. </year> <note> Reprinted in [Sta90]. </note>
Reference-contexts: The task of register allocation is to map these live ranges onto a finite register set. The standard approach to register allocation is graph colouring <ref> [CAC + 81, Cha82, BCKT89, CH90, Bri92b] </ref>. As the basis for dependence-conscious colouring, we used the algorithm presented in [BCKT89]. Figure 2 presents the phases of a graph colouring register allocator. Fig. 2.
Reference: [CH90] <author> Fred C. Chow and John L. Hennessy. </author> <title> The priority-based coloring approach to register allocation. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(4) </volume> <pages> 501-536, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: The task of register allocation is to map these live ranges onto a finite register set. The standard approach to register allocation is graph colouring <ref> [CAC + 81, Cha82, BCKT89, CH90, Bri92b] </ref>. As the basis for dependence-conscious colouring, we used the algorithm presented in [BCKT89]. Figure 2 presents the phases of a graph colouring register allocator. Fig. 2.
Reference: [Cha82] <author> G. J. Chaitin. </author> <title> Register allocation & spilling via graph coloring. </title> <booktitle> In SIGPLAN '82 [SIG82], </booktitle> <pages> pages 98-105. </pages>
Reference-contexts: The task of register allocation is to map these live ranges onto a finite register set. The standard approach to register allocation is graph colouring <ref> [CAC + 81, Cha82, BCKT89, CH90, Bri92b] </ref>. As the basis for dependence-conscious colouring, we used the algorithm presented in [BCKT89]. Figure 2 presents the phases of a graph colouring register allocator. Fig. 2.
Reference: [FR91] <author> Stefan M. Freudenberger and John C. Ruttenberg. </author> <title> Phase ordering of register allocation and instruction scheduling. </title> <editor> In Robert Giegerich and Susan L. Graham, editors, </editor> <title> Code Generation | Concepts, Tools, Techniques, </title> <booktitle> Workshops in Computing, </booktitle> <pages> pages 146-170. </pages> <publisher> Springer, </publisher> <year> 1991. </year>
Reference-contexts: I.e., no unary operators, no constants or register variables, no common subexpression elimination and the algorithm is restricted to one expression. In contrast, dependence-conscious colouring does not have these restrictions and performs global register allocation. In <ref> [FR91] </ref> instruction scheduling and register allocation are performed tracewise 3 , starting with the most frequently executed trace. This approach is similar to coagulation [Mor91].
Reference: [GH88] <author> James R. Goodman and Wei-Chung Hsu. </author> <title> Code scheduling and register allocation in large basic blocks. </title> <booktitle> In International Conference on Supercomputing, </booktitle> <pages> pages 442-452, </pages> <year> 1988. </year>
Reference-contexts: Scheduling before allocation uses more than the four available registers (the other registers hold global values) and causes spilling to memory. To solve this dilemma, Goodman and Hsu developed DAG-driven register allocation, a local register allocation algorithm that avoids introducing additional dependences if possible <ref> [GH88] </ref>. Inspired by DAG-driven register allocation, we created dependence-conscious colouring, a global register allocator that takes its effect on Fig. 1. Postpass scheduling vs. dependence-conscious colouring vs. prepass schedul- ing scheduling into account. <p> For non-redundant dependences we use the following cost function: cost (d) = max ( path-length (d) expected-time ; path-length (d) expected-time) path-length (d) is the length of the longest path containing the dependence d. It can be computed in constant time, if the earliest issue and finish times <ref> [GH88] </ref> are precomputed. expected-time is the expected execution time of the basic block before adding the dependence: expected-time = max (cycles; critical-path-length) where cycles is the number of cycles the basic block would need if its instructions were independent (i.e., the naive expected execution time), and critical-path-length is the critical path <p> Our approach is postpass scheduling, but our register allocator takes scheduling into consideration. The Harris C compiler uses postpass scheduling, but reallocates registers during scheduling to remove harmful dependences [Beu92]. In contrast, our register allocator tries to do it right the first time. In <ref> [GH88] </ref> two techniques for integrating local register allocation and instruction scheduling are introduced: Integrated prepass scheduling switches between scheduling for pipelining and scheduling for register allocation based on the number of available registers. DAG-driven register allocation tries to avoid introducing long paths into the dependence graph.
Reference: [GM86] <author> Phillip B. Gibbons and Steve S. Muchnick. </author> <title> Efficient instruction scheduling for a pipelined architecture. </title> <booktitle> In SIGPLAN '86 Symposium on Compiler Construction, </booktitle> <pages> pages 11-16, </pages> <year> 1986. </year>
Reference-contexts: The problem of arranging the instructions in a way that reduces the number of wait cycles is known as instruction scheduling. In this paper we consider only instruction scheduling within basic blocks. The basic data structure for instruction scheduling is the dependence graph <ref> [GM86] </ref>. Figure 1 shows (several variations of) a dependence graph. An edge from instruction a to instruction b indicates that a must be executed before b to preserve the correctness of the overall program.
Reference: [HG83] <author> John Hennessy and Thomas Gross. </author> <title> Postpass code optimization of pipeline cons-traints. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(3) </volume> <pages> 422-448, </pages> <month> July </month> <year> 1983. </year>
Reference-contexts: Scheduling is performed either before register allocation (prepass, [AH82]) or afterwards (postpass, <ref> [HG83] </ref>). With the prepass approach, scheduling has to be repeated after register allocation to schedule spill code. Prepass schedulers usually employ a register-saving heuristic, but only as low-priority secondary heuristic. Our approach is postpass scheduling, but our register allocator takes scheduling into consideration.
Reference: [Mor91] <author> W. G. Morris. CCG: </author> <title> A prototype coagulating code generator. </title> <booktitle> In SIGPLAN '91 [SIG91], </booktitle> <pages> pages 45-58. </pages>
Reference-contexts: In contrast, dependence-conscious colouring does not have these restrictions and performs global register allocation. In [FR91] instruction scheduling and register allocation are performed tracewise 3 , starting with the most frequently executed trace. This approach is similar to coagulation <ref> [Mor91] </ref>. In contrast to dependence-conscious colouring, the first phase does not consider the needs of the second; instead, the phases are interleaved, so possible problems are pushed into low-frequency code. [RLTS92] discusses register allocation for globally scheduled loops.
Reference: [PF91] <author> Todd A. Proebsting and Charles N. Fischer. </author> <title> Linear-time, optimal code scheduling for delayed-load architectures. </title> <booktitle> In SIGPLAN '91 [SIG91], </booktitle> <pages> pages 256-267. </pages>
Reference-contexts: Pinter proposes heuristics for removing edges from that interference graph to avoid excessive spilling, but does not give results. In contrast, dependence-conscious colouring uses a minimal interference graph to minimize spilling and preserves scheduling freedom through its register selection heuristics. <ref> [PF91] </ref> gives an optimal algorithm. Unfortunately it solves a very limited and unrealistic problem: scheduling and stupid register allocation for binary expression trees with single-delay-slot loads at the leaves. I.e., no unary operators, no constants or register variables, no common subexpression elimination and the algorithm is restricted to one expression.
Reference: [Pin93] <author> Shlomit S. Pinter. </author> <title> Register allocation with instruction scheduling: A new approach. </title> <booktitle> In SIGPLAN '93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 248-257, </pages> <year> 1993. </year> <journal> SIGPLAN Notices 28(6). </journal>
Reference-contexts: Like RASE, dependence-conscious colouring makes the register allocator aware of scheduling. But dependence-conscious colouring does all of the register allocation, including local allocation. It directly sees the data dependence graphs and the effects of allocation decisions on it instead of just heeding a register limit. <ref> [Pin93] </ref> proposes using postpass scheduling with a modified register allocator. The register allocator uses an interference graph that contains all interference edges that could be introduced by scheduling. I.e., even more interference edges and more spilling than in a prepass scheduling approach.
Reference: [RLTS92] <author> B. R. Rau, M. Lee, P. P. Tirumalai, and M. S. Schlansker. </author> <title> Register allocation for software pipelined loops. </title> <booktitle> In SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 283-299, </pages> <year> 1992. </year>
Reference-contexts: This approach is similar to coagulation [Mor91]. In contrast to dependence-conscious colouring, the first phase does not consider the needs of the second; instead, the phases are interleaved, so possible problems are pushed into low-frequency code. <ref> [RLTS92] </ref> discusses register allocation for globally scheduled loops. In contrast, dependence-conscious register allocation can handle general control structures, but is restricted to basic block instruction scheduling. 8 Conclusion Dependence-conscious colouring is a global register allocation method based on graph colouring, that takes the needs of instruction scheduling into account.
Reference: [SIG82] <institution> SIGPLAN '82 Symposium on Compiler Construction, </institution> <year> 1982. </year>
Reference: [SIG91] <institution> SIGPLAN '91 Conference on Programming Language Design and Implementation, </institution> <year> 1991. </year>
Reference: [Sta90] <author> William Stallings, </author> <title> editor. Reduced Instruction Set Computers. </title> <publisher> IEEE Computer Society Press, </publisher> <address> second edition, </address> <year> 1990. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
References-found: 20

