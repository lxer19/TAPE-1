URL: http://seclab.cs.ucdavis.edu/arpa/LaSCO/papers/LaSCO-DCCA-7-submit.ps
Refering-URL: http://seclab.cs.ucdavis.edu/arpa/LaSCO/welcome.html
Root-URL: http://www.cs.ucdavis.edu
Email: -hoagland,pandey,levitt-@cs.ucdavis.edu  
Title: A Graph-based Language for Specifying Security Policies Security forms a core component of many systems.
Author: James A. Hoagland, Raju Pandey, Karl N. Levitt 
Keyword: computer security, security policies, access control, formal policy specification  
Note: 1.0 Introduction  is meant by security has been formally described  university, or a  
Address: Davis  
Affiliation: Department of Computer Science University of California,  
Abstract: A security policy states the acceptable actions of an information system, as the actions bear on security. There is a pressing need for organizations to declare their security policies, even informal statements would be better than the current practice. But, formal policy statements are preferable to support (1) reasoning about policies, e.g., for consistency and completeness, (2) automated enforcement of the policy, and (3) other formal operations on policies, e.g., the composition of policies. We present LaSCO, the Language for Security Constraints on Objects, in which a policy and a system description are independently specified. LaSCO policies are specified as expressions in a quantifier-free logic, but also, to provide visualization, as directed graphs. Formal semantics have been defined. LaS-CO can be used for policy requirements that conform to its very general object-based system model. The implementation of LaSCO is in Java, and automatically generates wrappers to check Java program executions with respect to a policy. 1. We gratefully acknowledge the support for this research by DARPA under contract XXX-XXX and the Intel 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Anderson, J.P., </author> <title> Computer Security Technology Planning Study, ESD-TR-73-51, Vols. I and II, USAF Electronic Systems Division, </title> <address> Bedford, Mass., </address> <month> October </month> <year> 1972. </year>
Reference-contexts: A Graph-based Language for Specifying Security Policies 3 policies may be compiled into a program, used by a reference monitor <ref> [1] </ref> or wrapper to mediate access to system objects, or to check an audit trail off-line. We can state policies that apply whenever a certain pattern of accesses is encountered.
Reference: [2] <author> Bell, D.E. and L.J. LaPadula, </author> <title> Secure Computer Systems: Mathematical Foundations and Model, </title> <institution> M74-244, The MITRE Corp., Bedford, </institution> <address> Mass., </address> <month> May </month> <year> 1973. </year>
Reference-contexts: A security policy is stated by asserting that if a part of the system is in a specific state, the events and objects in that part must satisfy a set of properties. The simple (access control) security property of Bell-LaPadula <ref> [2] </ref> specifies that if a user is reading a file, the security level of the user must be at least as great at that of the file.
Reference: [3] <author> Brewer, D.F.C., and M.J. Nash, </author> <title> The Chinese Wall Security Policy, </title> <booktitle> In Proceedings of the 1989 IEEE Symposium on Security and Privacy, </booktitle> <address> Oakland, CA, USA: </address> <publisher> IEEE Press, </publisher> <year> 1989. </year>
Reference-contexts: We can also state policies where we need to check a requirement when we have multiple events seen together in a certain pattern through LaSCO policies with multiple edges. Consider the Chinese Wall policy <ref> [3] </ref>. The idea behind the Chinese Wall policy is to prevent conict of interest situations by consultants that may be employed by a number of parties with competing interests.
Reference: [4] <author> Cholvy, Laurence and Frederic Cuppens, </author> <title> Analyzing Consistency of Security Policies. </title> <booktitle> In Proceedings of the 1997 IEEE Symposium on Security and Privacy. </booktitle> <address> Oakland, CA, USA: </address> <publisher> IEEE Press, </publisher> <year> 1997. </year> <pages> p. 103-112. </pages>
Reference-contexts: The goal with this is to enforce varying security policies without changing the security server. This more structured approach towards overall site policies than LaSCO currently defines is useful in certain situations. A Graph-based Language for Specifying Security Policies 15 Cholvy and Cuppens <ref> [4] </ref> express the policies on a site in terms of deontic logic, which states what is obliged to occur, what is permitted to occur, and what is forbidden to occur and how to deal with inconsistencies.
Reference: [5] <author> Denning, Dorothy, </author> <title> Cryptography and Data Security. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass. </address> <year> 1982. </year>
Reference-contexts: Policies involving just a single event and its associated objects correspond to a LaSCO policy graph containing a single edge and adjacent nodes. One example of this was the simple security property in Figure 2. Access control lists (see <ref> [5] </ref>) and access control matrices [11] can be represented in LaSCO with one or more single-edge policies. <p> Mir can only express allowable states (a snapshot of a dynamic system), whereas LaSCO is more exible. Also, LaSCO can be applied to systems other than file systems and has simpler semantics. Access matrices [11] and the related access control lists and capabilities (see <ref> [5] </ref>) are a traditional means of specifying security permissions. LaSCO can represent this type of security constraint, but overcomes some of its limitations.
Reference: [6] <author> Edjlali, Guy, Anurag Acharya, and Vipin Chaudhary, </author> <title> "History-based Access-control for Mobile Code." </title> <booktitle> To appear in Proceedings of the Fifth ACM Conference on Computer and Communications Security. </booktitle> <address> San Francisco, CA, USA. </address> <month> November </month> <year> 1998. </year>
Reference-contexts: We believe LaSCO can express any Adage policy, but offers the additional benefits of application to different kinds of systems, direct linking to an application program, and formal semantics. Deeds, developed by Edjlali, Acharya, and Chaudhary <ref> [6] </ref>, is a history-based access control mechanism for Java whose goal is to mediate accesses to critical resources by mobile code. LaSCO can also be used for this purpose. As we plan to do, they insert code into Java programs.
Reference: [7] <author> Jajodia, Sushil, Pierangela Samarati, </author> <title> and V.S. Subrahmanian, A Logical Language for Expressing Authorizations. </title> <booktitle> In Proceedings of the 1997 IEEE Symposium on Security and Privacy. </booktitle> <address> Oakland, CA, USA: </address> <publisher> IEEE Press, </publisher> <year> 1997. </year> <pages> p. 31-42. </pages>
Reference-contexts: When making decisions, BEE cannot make reference to other events that have occurred. A goal BEE shares with LaSCO is to allow users to think at a policy level when implementing restrictions. The Authorization Specification Language is a similar approach <ref> [7] </ref> that expresses the desired authorizations regarding user access to objects in logic and has conict resolution rules defined in the language. The goal with this is to enforce varying security policies without changing the security server.
Reference: [8] <author> Harel, David, </author> <title> On Visual Formalisms. </title> <journal> Communications of the ACM, </journal> <volume> 31(5) </volume> <pages> 514-530, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: Mir consists of two languages, an instance language and a constraint language [9], both of which are based on Harels hierarchical graphs <ref> [8] </ref>. The instance languages formal semantics is defined in [12] and is analogous to our graphical depiction of the system that we formally define in [10]. It describes a file system access control matrix.
Reference: [9] <author> Heydon, Allan, Mark W. Maimone, J.D Tygar, Jeannette M. Wing, and Amy Moormann Zar-emski, Mir: </author> <title> Visual Specification of Security. </title> <journal> In IEEE Transactions on Software Engineer ing, </journal> <volume> 6(10) </volume> <pages> 1185-1197, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: Mir consists of two languages, an instance language and a constraint language <ref> [9] </ref>, both of which are based on Harels hierarchical graphs [8]. The instance languages formal semantics is defined in [12] and is analogous to our graphical depiction of the system that we formally define in [10]. It describes a file system access control matrix.
Reference: [10] <author> Hoagland, James, Raju Pandey, and Karl Levitt, </author> <title> Security Policy Specification Using a Graphical Approach. </title> <type> Technical report CSE-98-3, </type> <institution> The University of California, Davis Department of Computer Science. </institution> <month> July </month> <year> 1998. </year>
Reference-contexts: In this section, we discuss the syntax of LaSCO and its informal semantics. For a formal treatment of the language, including its formal semantics in first order logic, see <ref> [10] </ref>. 4.1 Predicates The text annotations we introduced in Section 2.2 are termed predicates. <p> The result of applying a policy to the system will return how the system violates policy; the implementation entity doing this checking may use this knowledge as appropriate for its situation. 4.6 Policy composition and operations We have defined some operations on policies in <ref> [10] </ref>, which we summarize here. Policies can be composed through conjunction. Each constraint policy must be upheld for the composed policy to be upheld. If any of the policies are violated in the system, the set of policies has been violated. <p> While LaSCO policies state what a policy violation is, they do not state the response to take when a policy violation occurs. This might be an important part of enforcing the policy. We have considered several extensions to LaSCO to address these limitations <ref> [10] </ref>. 8.0 Comparisons with other work The work of this paper most closely resembles the Mir work of Heydon, Tygar, Wing, et. al. at Carnegie Mellon University. Mir consists of two languages, an instance language and a constraint language [9], both of which are based on Harels hierarchical graphs [8]. <p> Mir consists of two languages, an instance language and a constraint language [9], both of which are based on Harels hierarchical graphs [8]. The instance languages formal semantics is defined in [12] and is analogous to our graphical depiction of the system that we formally define in <ref> [10] </ref>. It describes a file system access control matrix. The constraint language, which describes security constraints on the file system, contains a domain part (called an antecedent) and a requirement part (called a consequent) and has a predicate on nodes which is similar to LaSCOs predicates. <p> Its visual basis might make it easier for users to specify policies in LaSCO. Though we have omitted the details from this paper due to space considerations, we have developed a formal semantics of LaSCO and operations on policies <ref> [10] </ref>. We are implementing LaSCO in Java programs through instrumenting the pro grams with policy statements checked at run time. In this environment, we can take advantage of restrictions on classes of objects and on the particular event that is involved for the policy.
Reference: [11] <author> Lampson, B.W., </author> <title> Protection, </title> <booktitle> In Proceedings of the 5th Symposium on Information Sciences and Systems, </booktitle> <address> Princeton University, </address> <month> March </month> <year> 1971. </year>
Reference-contexts: Policies involving just a single event and its associated objects correspond to a LaSCO policy graph containing a single edge and adjacent nodes. One example of this was the simple security property in Figure 2. Access control lists (see [5]) and access control matrices <ref> [11] </ref> can be represented in LaSCO with one or more single-edge policies. For example, Figure 6 depicts the following policy: if subject sam is accessing an object in category 4, then the access must be a read. type=object && catagory=4 method=read type=subject && name=sam 10 James A. <p> Mir can only express allowable states (a snapshot of a dynamic system), whereas LaSCO is more exible. Also, LaSCO can be applied to systems other than file systems and has simpler semantics. Access matrices <ref> [11] </ref> and the related access control lists and capabilities (see [5]) are a traditional means of specifying security permissions. LaSCO can represent this type of security constraint, but overcomes some of its limitations.
Reference: [12] <author> Maimone, M.W., J.D. Tygar, and J.M. Wing, </author> <title> Mir Semantics for Security. </title> <booktitle> In Proceedings of the 1988 Workshop on Visual Languages, </booktitle> <month> Oct </month> <year> 1988. </year> <pages> pp. 45-51. </pages>
Reference-contexts: Mir consists of two languages, an instance language and a constraint language [9], both of which are based on Harels hierarchical graphs [8]. The instance languages formal semantics is defined in <ref> [12] </ref> and is analogous to our graphical depiction of the system that we formally define in [10]. It describes a file system access control matrix.
Reference: [13] <author> Miller, D.V. and R.W. Baldwin, </author> <title> Access control by Boolean Expression Evaluation. </title> <booktitle> In Pro ceedings Fifth Annual Computer Security Applications Conference. </booktitle> <address> Tucson, AZ, USA: </address> <publisher> IEEE Computer Society Press, </publisher> <year> 1990. </year> <month> p.131-139. </month>
Reference-contexts: Other approaches based on access matrices aim to overcome some of its limitations. TAM [15] introduces safety properties into an access control matrix through the use of object typing and defined sets of operations to execute under different conditions. BEE <ref> [13] </ref> is an access control mechanism where decisions are based on the result of a boolean expression evaluation for an access right. When making decisions, BEE cannot make reference to other events that have occurred.
Reference: [14] <author> Sandhu, R.S., E.J. Coyne, H.L. Feinstein, and C.E. Youman, </author> <title> Role-based access control: a multi-dimensional view. </title> <booktitle> In Proceedings of the 10th Annual Computer Security Applications </booktitle>
Reference-contexts: For example, Figure 6 depicts the following policy: if subject sam is accessing an object in category 4, then the access must be a read. type=object && catagory=4 method=read type=subject && name=sam 10 James A. Hoagland, Raju Pandey, Karl N. Levitt Role-based access control (RBAC) (Sandhu, et.al. <ref> [14] </ref>) can also be represented in LasCO, as it is similar in form to access matrix constraints, with the main difference being that the subject is a role and not a user.
References-found: 14

