URL: http://wwwis.win.tue.nl/~wsinwa/inheritpn.ps
Refering-URL: http://wwwis.win.tue.nl/~wsinwa/publications.html
Root-URL: http://www.win.tue.nl
Email: email: fwsinwa,tbasteng@win.tue.nl  
Title: Life-Cycle Inheritance A Petri-Net-Based Approach  
Author: W.M.P. van der Aalst and T. Basten 
Keyword: Object orientation, Petri nets, Inheritance, Object life cycle.  
Address: Netherlands  
Affiliation: Department of Mathematics and Computing Science Eindhoven University of Technology, The  
Abstract: Inheritance is one of the key issues of object-orientation. The inheritance mechanism allows for the definition of a subclass which inherits the features of a specific superclass. This means that methods and attributes defined for the superclass, are also available for objects of the subclass. Existing methods for object-oriented modeling and design, abstract from the dynamic behavior of objects when defining inheritance. Nevertheless, it would be useful to have a mechanism which allows for the inheritance of dynamic behavior. This paper describes a Petri-net-based approach to the formal specification and verification of this type of inheritance. We use Petri nets to specify the dynamics of an object class. The Petri-net formalism allows for a graphical representation of the life cycle of objects which belong to a specific object class. Four possible inheritance relations are defined. These inheritance relations can be verified automatically. Moreover, four powerful transformation rules which preserve specific inheritance relations are given. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> W.M.P. van der Aalst. </author> <title> A Class of Petri Nets for Modeling and Analyzing Business Processes. </title> <institution> Computing Science Reports 95/26, Eindhoven University of Technology, Eindhoven, </institution> <address> The Netherlands, </address> <year> 1995. </year>
Reference-contexts: It is possible to terminate successfully from s 0 , i.e., .N; s 0 / [fli .N; 0/. If we restrict ourselves to free-choice Petri nets, then there is a polynomial-time algorithm to verify the requirements in Definition 3.1 <ref> [1] </ref>. Moreover, for most object life cycles it is easy to see whether these requirements hold. Petri nets satisfying the requirements stated in Definition 3.1 have a number of nice properties. One of them is boundedness, i.e., the number of reachable states is finite. Property 3.2. <p> For people not familiar with free-choice Petri nets, requirement iii/ may be hard to swallow. Using the rich theory of free-choice Petri nets ([6]) it is easy to prove that [ p fl ] is a so-called home marking of .N 0 r ; [ p fl ]/, see <ref> [1] </ref>. This implies that eventually every token consumed from place p fl by N r is returned. If we abstract from the methods added by N r , then the replacement of the arc between t fl and p fl by N r does not change the external behavior.
Reference: 2. <editor> G. Agha et al. </editor> <booktitle> Panel discussion at the workshop on Object-Oriented Programming and Models of Con-currency. 16th. International Conference on the Application and Theory of Petri Nets, </booktitle> <address> Torino, Italy, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: Inheritance is one of the key issues in object-orientation. Unfortunately, inheritance is often limited to sharing attributes and methods among object classes. Until now, a good concept for life-cycle inheritance was lacking (See for example <ref> [2] </ref>). Existing object-oriented methodologies such as OMT [13] and OOD [5] do not give a clear definition of inheritance with respect to the dynamics of an object class.
Reference: 3. <author> T. Basten. </author> <note> Branching Bisimilarity is an Equivalence indeed! To appear in Information Processing Letters. </note>
Reference-contexts: Also note that the definition given here differs from the original definition given in [8]. In fact, it is the definition of semi branching bisimulation, which was first defined in [9], but formulated as it appears in <ref> [3] </ref>. It can be shown that the two notions are equivalent [9, 3]. <p> Also note that the definition given here differs from the original definition given in [8]. In fact, it is the definition of semi branching bisimulation, which was first defined in [9], but formulated as it appears in [3]. It can be shown that the two notions are equivalent <ref> [9, 3] </ref>. The reason for using the alternative definition is that it is more concise and more intuitive than the original definition. 3 Object Life Cycles Using Petri nets for the specification of object life cycles allows us to specify a partial ordering of methods. <p> Property 4.2. Branching bisimulation, b , is a congruence for encapsulation and abstraction. Proof. It is straightforward to verify that branching bisimulation, b , is an equivalence relation <ref> [3] </ref>.
Reference: 4. <author> T. Basten and W.M.P. van der Aalst. </author> <title> A Process-Algebraic Approach to Life-Cycle Inheritance: Inheritance = encapsulation + abstraction. </title> <institution> Computing Science Reports 96/05, Eindhoven University of Technology, Eindhoven, </institution> <address> The Netherlands, </address> <year> 1996. </year>
Reference-contexts: In that paper, it is shown that encapsulation and abstraction turn out to be important con-cepts for the characterization of life-cycle inheritance. Based on these concepts, four inheritance relations have been defined. The process-algebraic characterization of life-cycle inheritance in <ref> [4] </ref> is rather straightforward because encapsulation and abstraction are well investigated and, in contrast to state-transition diagrams and Petri nets, states are not represented explicitly. Using the rich theory of ACP it is quite easy to show that each of the four inheritance relations has a number of desirable properties. <p> Petri nets provide a graphical formalism which is much closer to existing methodologies such as OMT and OOD. In this paper, we show that it is possible to formalize the four inheritance relations in a Petri-net context. Moreover, we extend some of the results presented in <ref> [4] </ref>. For example, in contrast to the approach in [4], we are able to handle object life cycles with recursion. Although we allow recursion, it is possible to verify each of the four inheritance relations automatically. Moreover, a number of transformation rules which preserve specific forms of inheritance are presented. <p> In this paper, we show that it is possible to formalize the four inheritance relations in a Petri-net context. Moreover, we extend some of the results presented in <ref> [4] </ref>. For example, in contrast to the approach in [4], we are able to handle object life cycles with recursion. Although we allow recursion, it is possible to verify each of the four inheritance relations automatically. Moreover, a number of transformation rules which preserve specific forms of inheritance are presented. <p> Inspired by process-algebraic concepts like encapsulation and abstraction, two basic forms of inheritance seem to be appropriate <ref> [4] </ref>. The first basic form of inheritance corresponds to encapsulation. Let .N 0 ; [i]/ and .N 1 ; [i]/ be two object life cycles. <p> This means that if the new methods added to the subclass are blocked or the environment is not willing to use the new methods, then the superclass and the subclass behave equivalently. As shown in <ref> [4] </ref> this corresponds to the encapsulation operator known from ACP (@ H ) which translates actions in H to deadlock ffi. This form of inheritance is referred to as protocol inheritance because the subclass inherits the protocol of the superclass. <p> It is also easy to see that .N 1 ; [i]/ in Figure 1 is a subclass of .N 0 ; [i]/ with respect to projection inheritance. If we hide the method birthday, then the observable behaviors are identical. Analogously to <ref> [4] </ref>, we define two other forms of inheritance by combining the two basic forms just presented. But first, we define the encapsulation operator @ H and the abstraction operator o I for Petri nets. <p> In Life-cycle inheritance is the weakest form of inheritance. If an object life cycle is a subclass with respect to any of the four forms of inheritance, then it is also a subclass with respect to life-cycle inheritance. In <ref> [4] </ref> it is shown that the inclusion relations in Figure 3 are strict and that there are no inclusion relations between protocol inheritance and projection inheritance. 5 a 5 ab 0 4 5 a b 1 b 0 Example 4.4. <p> Moreover, it is possible to choose H; H 0 ; I; and I 0 such that .H [ I / " .H 0 [ I 0 / D (see <ref> [4] </ref>). <p> Hence, lc is also transitive. 2 Analogously to the result in <ref> [4] </ref> we can also show that subclass equivalence coincides with branching-bisimulation equivalence, i.e., given two object life cycles and one of the four inheritance relations, if the first life cycle is a subclass of the second life cycle and vice versa, then the two life cycles are branching bisimilar. <p> We can also apply this rule to show that .N 1 ; [i]/ in Figure 1 is a subclass of .N 0 ; [i]/. The transformation rule described by Theorem 5.1 is inspired by an axiom presented in <ref> [4] </ref>. To show the relation between the inheritance-preserving transformation rules presented in this paper and some of the algebraic rules in [4], we give an intermezzo for those familiar with process algebra. Intermezzo 5.2. In [4] we presented an algebraic theory PA o ffiae for studying life-cycle inheritance. <p> The transformation rule described by Theorem 5.1 is inspired by an axiom presented in <ref> [4] </ref>. To show the relation between the inheritance-preserving transformation rules presented in this paper and some of the algebraic rules in [4], we give an intermezzo for those familiar with process algebra. Intermezzo 5.2. In [4] we presented an algebraic theory PA o ffiae for studying life-cycle inheritance. PA o ffiae is an ACP-like process algebra with deadlock, internal actions and renaming. <p> The transformation rule described by Theorem 5.1 is inspired by an axiom presented in <ref> [4] </ref>. To show the relation between the inheritance-preserving transformation rules presented in this paper and some of the algebraic rules in [4], we give an intermezzo for those familiar with process algebra. Intermezzo 5.2. In [4] we presented an algebraic theory PA o ffiae for studying life-cycle inheritance. PA o ffiae is an ACP-like process algebra with deadlock, internal actions and renaming. In this context, an object life cycle is defined to be a closed PA o term starting with the object-creation action 5. <p> Based on this theory, we have defined four forms of inheritance analogous to Definition 4.3. For example, for any two object life cycles p and q, p pt q if and only if PA o ffiae ` @ H . p/ D q. In <ref> [4] </ref>, we also presented a number of rules which illustrate under what conditions inheritance is preserved. In the remainder of this intermezzo, we concentrate on these rules. L, L s and ff are defined analogous to the definitions in this paper. <p> The transformation rule described in Conjecture 5.6 shows that under protocol/projection inheritance it is allowed to postpone part of the life cycle. Note that, in contrast to the rules presented in <ref> [4] </ref>, the four transformation rules presented in this paper are also applicable to object life cycles with recursion. In fact, it is easy to see that the application of the last transformation rule introduces recursion. The four transformation rules give a good characterization of the various forms of inheritance. <p> In fact, it is easy to see that the application of the last transformation rule introduces recursion. The four transformation rules give a good characterization of the various forms of inheritance. In contrast to <ref> [4] </ref>, we did not provide rules for the preservation of life-cycle inheritance, because these rules are combinations of the rules for protocol and projection inheritance (See Example 5.5). The fact that the rules in [4] correspond to elegant transformation rules in a Petri-net context is encouraging. <p> In contrast to <ref> [4] </ref>, we did not provide rules for the preservation of life-cycle inheritance, because these rules are combinations of the rules for protocol and projection inheritance (See Example 5.5). The fact that the rules in [4] correspond to elegant transformation rules in a Petri-net context is encouraging. It appears that the inheritance concepts used in this paper are quite universal and transcend the two formalisms. 16 6 Concluding Remarks A framework for the specification and verification of life-cycle inheritance has been presented. <p> The framework is based on Petri nets and, therefore, close to the professional experience of people engaged in object-oriented design. The four inheritance relations presented in this paper have been inspired by the process-algebraic concepts of encapsulation and abstraction <ref> [4] </ref>. It has been shown that these inheritance relations can be checked automatically. Moreover, a number of powerful inheritance-preserving transformation rules have been presented. These transformation rules show how an object life cycle may be extended while preserving certain dynamical properties. Acknowledgements.
Reference: 5. <author> G. Booch. </author> <title> Object-Oriented Analysis and Design: With Applications. </title> <address> Benjamin/Cummings, Redwood City, CA, USA, </address> <year> 1994. </year>
Reference-contexts: 1 Introduction Although object-oriented design is a relatively young practice, it is considered to be the most promising approach to software development. Within a few years the two leading object-oriented methodologies, OMT [13] and OOD <ref> [5] </ref>, have conquered the world of software engineering. Both methodologies use state-transition diagrams for specifying the dynamic behavior of objects. Typically, for each object class, one state-transition diagram is specified. <p> Inheritance is one of the key issues in object-orientation. Unfortunately, inheritance is often limited to sharing attributes and methods among object classes. Until now, a good concept for life-cycle inheritance was lacking (See for example [2]). Existing object-oriented methodologies such as OMT [13] and OOD <ref> [5] </ref> do not give a clear definition of inheritance with respect to the dynamics of an object class. In this paper, we tackle the problem of deciding whether the object life cycle of one class inherits the life cycle of another class.
Reference: 6. <author> J. Desel and J. Esparza. </author> <title> Free Choice Petri Nets, </title> <booktitle> volume 40 of Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <address> Cambridge, </address> <year> 1995. </year>
Reference: 7. <author> R.J. van Glabbeek. </author> <title> What is Branching Time Semantics and Why to Use It? In Bulletin of the EATCS, </title> <booktitle> number 53, </booktitle> <pages> pages 191-198. </pages> <institution> European Association for Theoretical Computer Science, </institution> <month> June </month> <year> 1994. </year>
Reference-contexts: In addition, Petri nets with the same external behavior, but with possibly different internal behavior must be considered equal. Given these two requirements, branching bisimulation seems to be a suitable equivalence <ref> [7] </ref>. Let N be the set of marked A-labeled Petri nets where A is equal to A [ fo g. Recall that a o - labeled transition corresponds to an internal method.
Reference: 8. <author> R.J. van Glabbeek and W.P. Weijland. </author> <title> Branching Time and Abstraction in Bisimulation Semantics (extended abstract). </title> <editor> In G.X. Ritter, editor, </editor> <booktitle> Information Processing 89: Proceedings of the IFIP 11th. World Computer Congress, </booktitle> <pages> pages 613-618, </pages> <address> San Fransisco, CA, USA, August/September 1989. </address> <publisher> Elsevier Science Publishers B.V., North-Holland, </publisher> <year> 1989. </year>
Reference-contexts: Figure 2 shows the essence of branching bisimulation. Note that for any ff 2 A, the relation [ffi is depicted by an ff-labeled arrow, whereas the relation [ ii is depicted by a double-headed arrow. Also note that the definition given here differs from the original definition given in <ref> [8] </ref>. In fact, it is the definition of semi branching bisimulation, which was first defined in [9], but formulated as it appears in [3]. It can be shown that the two notions are equivalent [9, 3].
Reference: 9. <author> R.J. van Glabbeek and W.P. Weijland. </author> <title> Branching Time and Abstraction in Bisimulation Semantics. </title> <type> Report CS-R9120, </type> <institution> Centre for Mathematics and Computer Science, CWI, </institution> <address> Amsterdam, The Netherlands, </address> <year> 1991. </year> <note> A revised version will appear in Journal of the ACM. </note>
Reference-contexts: Also note that the definition given here differs from the original definition given in [8]. In fact, it is the definition of semi branching bisimulation, which was first defined in <ref> [9] </ref>, but formulated as it appears in [3]. It can be shown that the two notions are equivalent [9, 3]. <p> Also note that the definition given here differs from the original definition given in [8]. In fact, it is the definition of semi branching bisimulation, which was first defined in [9], but formulated as it appears in [3]. It can be shown that the two notions are equivalent <ref> [9, 3] </ref>. The reason for using the alternative definition is that it is more concise and more intuitive than the original definition. 3 Object Life Cycles Using Petri nets for the specification of object life cycles allows us to specify a partial ordering of methods.
Reference: 10. <author> K.M. van Hee. </author> <title> Information System Engineering: a Formal Approach. </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, UK, </address> <year> 1994. </year> <month> 17 </month>
Reference-contexts: Second, parallelism, con-currency and synchronization are easy to model in terms of a Petri net. Third, many techniques and software tools are available for the analysis of Petri nets. Finally, Petri nets have been extended with color, time and hierarchy <ref> [10, 11] </ref>. The extension with color allows for the modeling of object attributes and methods. The extension with time allows for the quantification of the dynamic behavior of an object. The hierarchy concept can be used to structure the dynamics of an object class.
Reference: 11. <author> K. Jensen. </author> <title> Coloured Petri Nets. Basic concepts, analysis methods and practical use. </title> <booktitle> EATCS Mono--graphs on Theoretical Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: Second, parallelism, con-currency and synchronization are easy to model in terms of a Petri net. Third, many techniques and software tools are available for the analysis of Petri nets. Finally, Petri nets have been extended with color, time and hierarchy <ref> [10, 11] </ref>. The extension with color allows for the modeling of object attributes and methods. The extension with time allows for the quantification of the dynamic behavior of an object. The hierarchy concept can be used to structure the dynamics of an object class.
Reference: 12. <author> W. Reisig. </author> <title> Petri Nets: An Introduction, </title> <booktitle> volume 4 of Monographs in Theoretical Computer Science : An EATCS Series. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1985. </year>
Reference-contexts: Typically, for each object class, one state-transition diagram is specified. Such a state-transition diagram shows the state space of a class and the methods that cause a transition from one state to another. In this paper, we use Petri nets (See for example <ref> [12] </ref>) for specifying the dynamics of an object class. There are several reasons for using Petri nets. First of all, Petri nets provide a graphical description technique which is easy to understand and close to state-transition diagrams.
Reference: 13. <author> J. Rumbaugh, M. Blaha, W. Premerlani, F. Eddy, and W. Lorensen. </author> <title> Object-Oriented Modeling and Design. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, USA, </address> <year> 1991. </year> <month> 18 </month>
Reference-contexts: 1 Introduction Although object-oriented design is a relatively young practice, it is considered to be the most promising approach to software development. Within a few years the two leading object-oriented methodologies, OMT <ref> [13] </ref> and OOD [5], have conquered the world of software engineering. Both methodologies use state-transition diagrams for specifying the dynamic behavior of objects. Typically, for each object class, one state-transition diagram is specified. <p> Inheritance is one of the key issues in object-orientation. Unfortunately, inheritance is often limited to sharing attributes and methods among object classes. Until now, a good concept for life-cycle inheritance was lacking (See for example [2]). Existing object-oriented methodologies such as OMT <ref> [13] </ref> and OOD [5] do not give a clear definition of inheritance with respect to the dynamics of an object class. In this paper, we tackle the problem of deciding whether the object life cycle of one class inherits the life cycle of another class.
References-found: 13

