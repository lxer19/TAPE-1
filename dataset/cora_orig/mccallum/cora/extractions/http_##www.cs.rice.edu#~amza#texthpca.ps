URL: http://www.cs.rice.edu/~amza/texthpca.ps
Refering-URL: http://www.cs.rice.edu/~amza/
Root-URL: 
Email: willyg@cs.rice.edu  sandhya@cs.rochester.edu  
Title: Software DSM Protocols that Adapt between Single Writer and Multiple Writer  
Author: Cristiana Amza Alan L. Cox Sandhya Dwarkadas and Willy Zwaenepoel 
Note: This work is supported in part by the National Science Foundation under Grants CCR-9410457, BIR-9408503, CCR-9457770, CCR-9502500, CCR-9521735, CDA-9502791, and MIP-9521386, by the Texas TATP program under Grant 003604-017, and by grants from IBM Corporation and from Tech-Sym, Inc.  
Address: famza, alc,  Rochester  
Affiliation: Department of Computer Science Rice University  Department of Computer Science University of  
Abstract: We present two software DSM protocols that dynamically adapt between a single writer (SW) and a multiple writer (MW) protocol based on the application's sharing patterns. The first protocol (WFS) adapts based on write-write false sharing; the second (WFS+WG) based on a combination of write-write false sharing and write granularity. The adaptation is automatic. No user or compiler information is needed. The choice between SW and MW is made on a per-page basis. We measured the performance of our adaptive protocols on an 8-node SPARC cluster connected by a 155 Mbps ATM network. We used eight applications, covering a broad spectrum in terms of write-write false sharing and write granularity. We compare our adaptive protocols against the MW-only and the SW-only approach. Adaptation to write-write false sharing proves to be the critical performance factor, while adaptation to write granularity plays only a secondary role in our environment and for the applications considered. Each of the two adaptive protocols matches or exceeds the performance of the best of MW and SW in seven out of the eight applications. For these applications, speedup improvements over SW range from 1.02 to 2.7. The largest improvements over SW occur for applications with high write-write false sharing. Compared to MW, speedups improve by a factor of 1.02 to 1.6, with the largest improvements occurring for applications with little or no write-write false sharing. Both WFS and WFS+WG speedups fall below the best of MW and SW for one application, but only by a factor of 1.09 and 1.06. In addition, memory usage is reduced considerably compared to MW, in some cases making the memory overhead all but negligible. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S.V. Adve, A.L. Cox, S. Dwarkadas, R. Rajamony, and W. Zwaenepoel. </author> <title> A comparison of entry consistency and lazy release consistency implementations. </title> <booktitle> In Proceedings of the Second High Performance Computer Architecture Symposium, </booktitle> <pages> pages 26-37, </pages> <month> February </month> <year> 1996. </year>
Reference-contexts: Various techniques have been proposed to replace diffing by cheaper alternatives [15, 22] or to o*oad diffing to a communication coprocessor [5, 23]. This work is orthogonal to ours, in that we could incorporate these techniques into our adaptive protocols. Using per-word timestamps <ref> [1, 15, 22] </ref> addresses the problem of diff accumulation directly. The problem is alleviated in our system because we switch to using whole pages whenever the diffs are large. Cox and Fowler, and Stenstrom and Brorsson [7, 20] describe hardware cache-coherence protocols that adapt to migratory sharing patterns.
Reference: [2] <author> S.V. Adve and M.D. Hill. </author> <title> A unified formalization of four shared-memory models. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 4(6) </volume> <pages> 613-624, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: The Lazy Release Consistency (LRC) algorithm [14] delays the propagation of modifications to a processor until that processor executes an acquire. To do so, LRC uses the happened-before-1 partial order <ref> [2] </ref>. The happened-before-1 partial order is the union of the total processor order of the memory accesses on each individual processor and the partial order of release-acquire pairs. Vector timestamps are used to represent the partial order [14].
Reference: [3] <author> C. Amza, A.L. Cox, S. Dwarkadas, P. Keleher, H. Lu, R. Rajamony, and W. Zwaenepoel. TreadMarks: </author> <title> Shared memory computing on networks of workstations. </title> <journal> IEEE Computer, </journal> <volume> 29(2) </volume> <pages> 18-28, </pages> <month> February </month> <year> 1996. </year>
Reference-contexts: Furthermore, there is a significant memory overhead for recording the modifications. The memory costs can be bounded by garbage collection, but frequent garbage collection results in added execution time. CVM [13] uses a SW protocol, while TreadMarks <ref> [3] </ref> uses a MW protocol (see the work of Keleher [13] for a study of the tradeoffs). Other systems (such as Munin [6]) allow multiple protocols to be used, but require user annotation to choose between them. In this paper we take an alternative approach. <p> The second adaptive protocol (WFS+WG), in addition, takes into account write granularity, and uses diffs for pages with small write granularity, even if they do not exhibit write-write false sharing. The adaptive protocols were implemented in Tread-Marks <ref> [3] </ref>.
Reference: [4] <author> D. Bailey, J. Barton, T. Lasinski, and H. Simon. </author> <title> The NAS parallel benchmarks. </title> <type> Technical Report TR RNR-91-002, </type> <institution> NASA Ames, </institution> <month> August </month> <year> 1991. </year>
Reference-contexts: The adaptive protocols were implemented in Tread-Marks [3]. Eight applications were used to demonstrate the performance: Red-Black SOR and TSP are small kernels; Barnes-Hut and Water are from the Splash benchmarks suite [19]; IS and 3D-FFT are from the NAS benchmark suite <ref> [4] </ref>; Shallow is a small weather modeling code from NCAR [18]; and ILINK is a production computational genetics code [11]. These applications cover a wide spectrum in terms of write-write false sharing and write granularity. We present performance results on a 155Mbps ATM network connecting 8 SPARC-20 model 61 workstations. <p> This led us to a conservative threshold value of 3KB to switch from MW to SW in WFS+WG. 5 Applications We use 8 applications in this study: Red-Black SOR and TSP; Water and Barnes-Hut from the SPLASH benchmark suite [19]; IS and 3D-FFT from the NAS benchmark suite <ref> [4] </ref>; Shallow from NCAR [18] and ILINK, a large computational genetics code [11]. The applications and input sets vary considerably in terms of the amount of write-write false sharing and the write granularity. Tables 1 and 2 summarize the relevant characteristics of the applications.
Reference: [5] <author> R. Bianchini, L.I. Kontothanassis, R. Pinto, M. De Maria, M. Abud, and C.L. Amorim. </author> <title> Hiding communication latency and coherence overhead in software dsms. </title> <booktitle> In Proceedings of the 7th Symposium on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 198-209, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: We show that under LRC the benefits of MW and SW protocols can be combined into one adaptive algorithm that uses the appropriate protocol on a per-page basis. Various techniques have been proposed to replace diffing by cheaper alternatives [15, 22] or to o*oad diffing to a communication coprocessor <ref> [5, 23] </ref>. This work is orthogonal to ours, in that we could incorporate these techniques into our adaptive protocols. Using per-word timestamps [1, 15, 22] addresses the problem of diff accumulation directly.
Reference: [6] <author> J.B. Carter, J.K. Bennett, and W. Zwaenepoel. </author> <title> Techniques for reducing consistency-related information in distributed shared memory systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 13(3) </volume> <pages> 205-243, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: 1 Introduction This paper focuses on protocols for implementing lazy release-consistent (LRC) [14] software distributed shared memory (DSM) [16] on commodity hardware. Both single writer (SW) [13] and multiple writer (MW) <ref> [6] </ref> protocols have been used to implement LRC. SW protocols allow only a single writable copy of a page at any given time. Furthermore, they always transfer a whole page to satisfy an access miss. With MW protocols, several writable copies of a page may co-exist. <p> The memory costs can be bounded by garbage collection, but frequent garbage collection results in added execution time. CVM [13] uses a SW protocol, while TreadMarks [3] uses a MW protocol (see the work of Keleher [13] for a study of the tradeoffs). Other systems (such as Munin <ref> [6] </ref>) allow multiple protocols to be used, but require user annotation to choose between them. In this paper we take an alternative approach. We observe that for some applications a MW protocol is preferred while for others a SW protocol is more desirable. <p> Our adaptive protocols could be extended to automatically detect migratory data access and optimize the ownership acquisition accordingly. Munin <ref> [6] </ref> uses multiple protocols to handle data with different access characteristics. The innovation in our work is that it chooses automatically between SW and MW protocols. In Munin, the choice of protocol is based on somewhat burdensome user annotations.
Reference: [7] <author> A.L. Cox and R.J. Fowler. </author> <title> Adaptive cache coherency for detecting migratory shared data. </title> <booktitle> In Proceedings of the 20th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 98-108, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Using per-word timestamps [1, 15, 22] addresses the problem of diff accumulation directly. The problem is alleviated in our system because we switch to using whole pages whenever the diffs are large. Cox and Fowler, and Stenstrom and Brorsson <ref> [7, 20] </ref> describe hardware cache-coherence protocols that adapt to migratory sharing patterns. Migratory cache blocks are detected automatically.
Reference: [8] <author> B. Fleisch and G. Popek. </author> <title> Mirage: A coherent distributed shared memory design. </title> <booktitle> In Proceedings of the 12th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 211-223, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: However, on write faults, the last version of the page needs to migrate to the new owner, thus the exact location of the last owner needs to be determined. In our implementation of SW, as in the CVM protocol and Mirage <ref> [8] </ref>, we address the ping-pong problem by guaranteeing a processor ownership for a newly obtained page for a minimum quantum of time before it can be taken away by another processor. We use a fixed 1 millisecond quantum.
Reference: [9] <author> V.W. Freeh and G.R. Andrews. </author> <title> Dynamically controlling false sharing in distributed shared memory. </title> <booktitle> In Proceedings of the Fifth Symposium on High-Performance Distributed Computing, </booktitle> <year> 1996. </year>
Reference-contexts: In contrast, our adaptive protocols avoid twinning and diff-ing overhead without using a fixed home node. This avoids unnecessary message traffic if the home node is poorly chosen. False sharing has also been addressed by compile-time analysis [12], remapping of data within the address space <ref> [9] </ref>, and by using objects as a smaller consistency unit [22]. All of these techniques seek to eliminate rather than tolerate false sharing.
Reference: [10] <author> K. Gharachorloo, D. Lenoski, J. Laudon, P. Gibbons, A. Gupta, and J. Hennessy. </author> <title> Memory consistency and event ordering in scalable shared-memory multiprocessors. </title> <booktitle> In Proceedings of the 17th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 15-26, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: Section 7 discusses related work. Section 8 presents our conclusions. 2 Background In the following, we introduce LRC, the Tread-Marks MW protocol, and our implementation of the CVM SW protocol. 2.1 Lazy Release Consistency Release consistency (RC) is a relaxed memory consistency model <ref> [10] </ref>. In RC, ordinary shared memory accesses are distinguished from synchronization accesses, with the latter category subdivided into acquire and release accesses. Acquire and release accesses correspond roughly to the conventional synchronization operations on a lock, but other synchronization mechanisms can be built on this model as well.
Reference: [11] <author> S.K. Gupta, A.A. Schaffer, A.L. Cox, S. Dwarkadas, and W. Zwaenepoel. </author> <title> Integrating parallelization strategies for linkage analysis. </title> <journal> Computers and Biomedical Research, </journal> <volume> 28 </volume> <pages> 116-139, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: used to demonstrate the performance: Red-Black SOR and TSP are small kernels; Barnes-Hut and Water are from the Splash benchmarks suite [19]; IS and 3D-FFT are from the NAS benchmark suite [4]; Shallow is a small weather modeling code from NCAR [18]; and ILINK is a production computational genetics code <ref> [11] </ref>. These applications cover a wide spectrum in terms of write-write false sharing and write granularity. We present performance results on a 155Mbps ATM network connecting 8 SPARC-20 model 61 workstations. <p> to switch from MW to SW in WFS+WG. 5 Applications We use 8 applications in this study: Red-Black SOR and TSP; Water and Barnes-Hut from the SPLASH benchmark suite [19]; IS and 3D-FFT from the NAS benchmark suite [4]; Shallow from NCAR [18] and ILINK, a large computational genetics code <ref> [11] </ref>. The applications and input sets vary considerably in terms of the amount of write-write false sharing and the write granularity. Tables 1 and 2 summarize the relevant characteristics of the applications.
Reference: [12] <author> T.E. Jeremiassen and S. Eggers. </author> <title> Reducing false sharing on shared memory multiprocessors through compile time data transformations. </title> <booktitle> In Proceedings of the 5th ACM Symposium on the Principles and Practice of Parallel Programming, </booktitle> <month> July </month> <year> 1995. </year>
Reference-contexts: In contrast, our adaptive protocols avoid twinning and diff-ing overhead without using a fixed home node. This avoids unnecessary message traffic if the home node is poorly chosen. False sharing has also been addressed by compile-time analysis <ref> [12] </ref>, remapping of data within the address space [9], and by using objects as a smaller consistency unit [22]. All of these techniques seek to eliminate rather than tolerate false sharing.
Reference: [13] <author> P. Keleher. </author> <title> The relative importance of concurrent writers and weak consistency models. </title> <booktitle> In Proceedings of the 16th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 91-98, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: 1 Introduction This paper focuses on protocols for implementing lazy release-consistent (LRC) [14] software distributed shared memory (DSM) [16] on commodity hardware. Both single writer (SW) <ref> [13] </ref> and multiple writer (MW) [6] protocols have been used to implement LRC. SW protocols allow only a single writable copy of a page at any given time. Furthermore, they always transfer a whole page to satisfy an access miss. <p> Furthermore, there is a significant memory overhead for recording the modifications. The memory costs can be bounded by garbage collection, but frequent garbage collection results in added execution time. CVM <ref> [13] </ref> uses a SW protocol, while TreadMarks [3] uses a MW protocol (see the work of Keleher [13] for a study of the tradeoffs). Other systems (such as Munin [6]) allow multiple protocols to be used, but require user annotation to choose between them. <p> Furthermore, there is a significant memory overhead for recording the modifications. The memory costs can be bounded by garbage collection, but frequent garbage collection results in added execution time. CVM <ref> [13] </ref> uses a SW protocol, while TreadMarks [3] uses a MW protocol (see the work of Keleher [13] for a study of the tradeoffs). Other systems (such as Munin [6]) allow multiple protocols to be used, but require user annotation to choose between them. In this paper we take an alternative approach. <p> The biggest differences in favor of MW occur for Barnes and ILINK where MW has a speedup of 3.7 and 5.1, respectively, compared to 1.4 and 2.8 for SW. These results are similar to those of Keleher <ref> [13] </ref>, allowing for some differences in platform and applications. Comparing the adaptive to the non-adaptive protocols, we see from Figure 2 that, for all but 3D-FFT and TSP, both adaptive protocols match or exceed the speedup of the best of the non-adaptive protocols. <p> On the other hand, the ownership request messages in the adaptive protocols may cause some increase in the total number of messages. 7 Related Work The SW protocol we use is based on the work of Keleher <ref> [13] </ref>. His work demonstrates that the performance benefits resulting from using LRC rather than sequential consistency (SC) are considerably larger than those resulting from allowing multiple writers.
Reference: [14] <author> P. Keleher, A. L. Cox, and W. Zwaenepoel. </author> <title> Lazy release consistency for software distributed shared memory. </title> <booktitle> In Proceedings of the 19th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 13-21, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: 1 Introduction This paper focuses on protocols for implementing lazy release-consistent (LRC) <ref> [14] </ref> software distributed shared memory (DSM) [16] on commodity hardware. Both single writer (SW) [13] and multiple writer (MW) [6] protocols have been used to implement LRC. SW protocols allow only a single writable copy of a page at any given time. <p> Essentially, RC allows the effects of ordinary shared memory accesses to be delayed until a subsequent release by the same processor is performed. The Lazy Release Consistency (LRC) algorithm <ref> [14] </ref> delays the propagation of modifications to a processor until that processor executes an acquire. To do so, LRC uses the happened-before-1 partial order [2]. <p> To do so, LRC uses the happened-before-1 partial order [2]. The happened-before-1 partial order is the union of the total processor order of the memory accesses on each individual processor and the partial order of release-acquire pairs. Vector timestamps are used to represent the partial order <ref> [14] </ref>. When a processor executes an acquire, it sends its current vector timestamp in the acquire message. The last releaser then piggybacks on its response a set of write notices. These write notices describe the shared data modifications that precede the acquire according to the partial order.
Reference: [15] <author> P.T. Koch, R.J. Fowler, and E. </author> <month> Jul. </month> <title> Write ranges: A technique for improving capture and propagation of writes in software DSMs. </title> <note> Submitted for publication. </note>
Reference-contexts: We show that under LRC the benefits of MW and SW protocols can be combined into one adaptive algorithm that uses the appropriate protocol on a per-page basis. Various techniques have been proposed to replace diffing by cheaper alternatives <ref> [15, 22] </ref> or to o*oad diffing to a communication coprocessor [5, 23]. This work is orthogonal to ours, in that we could incorporate these techniques into our adaptive protocols. Using per-word timestamps [1, 15, 22] addresses the problem of diff accumulation directly. <p> Various techniques have been proposed to replace diffing by cheaper alternatives [15, 22] or to o*oad diffing to a communication coprocessor [5, 23]. This work is orthogonal to ours, in that we could incorporate these techniques into our adaptive protocols. Using per-word timestamps <ref> [1, 15, 22] </ref> addresses the problem of diff accumulation directly. The problem is alleviated in our system because we switch to using whole pages whenever the diffs are large. Cox and Fowler, and Stenstrom and Brorsson [7, 20] describe hardware cache-coherence protocols that adapt to migratory sharing patterns.
Reference: [16] <author> K. Li and P. Hudak. </author> <title> Memory coherence in shared virtual memory systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 7(4) </volume> <pages> 321-359, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: 1 Introduction This paper focuses on protocols for implementing lazy release-consistent (LRC) [14] software distributed shared memory (DSM) <ref> [16] </ref> on commodity hardware. Both single writer (SW) [13] and multiple writer (MW) [6] protocols have been used to implement LRC. SW protocols allow only a single writable copy of a page at any given time. Furthermore, they always transfer a whole page to satisfy an access miss.
Reference: [17] <author> H. Lu, S. Dwarkadas, A.L. Cox, and W. Zwaenepoel. </author> <title> Message passing versus distributed shared memory on networks of workstations. </title> <booktitle> In Proceedings SuperComputing '95, </booktitle> <month> December </month> <year> 1995. </year>
Reference-contexts: Adapting to write granularity also alleviates the diff accumulation problem <ref> [17] </ref> that occurs in the MW protocol. Diff accumulation occurs in connection with migratory data where a sequence of synchronizing processors write the same data one after another. <p> WFS keeps all these pages in SW mode during the entire execution. WFS+WG switches to SW mode for all pages after the first iteration. Although the adaptive protocols send more messages than MW due to ownership requests, diffing overhead and diff accumulation <ref> [17] </ref> in MW result in poorer performance relative to the adaptive protocols. The small improvement of WFS over SW is due to the extra messages in SW for forwarding ownership requests. 3D-FFT solves a differential equation using 3D forward and inverse FFT's.
Reference: [18] <author> R. Sadourny. </author> <title> The dynamics of finite-difference models of the shallow-water equations. </title> <journal> Journal of Atmospheric Sciences, </journal> <volume> 32(4), </volume> <month> April </month> <year> 1975. </year>
Reference-contexts: Eight applications were used to demonstrate the performance: Red-Black SOR and TSP are small kernels; Barnes-Hut and Water are from the Splash benchmarks suite [19]; IS and 3D-FFT are from the NAS benchmark suite [4]; Shallow is a small weather modeling code from NCAR <ref> [18] </ref>; and ILINK is a production computational genetics code [11]. These applications cover a wide spectrum in terms of write-write false sharing and write granularity. We present performance results on a 155Mbps ATM network connecting 8 SPARC-20 model 61 workstations. <p> us to a conservative threshold value of 3KB to switch from MW to SW in WFS+WG. 5 Applications We use 8 applications in this study: Red-Black SOR and TSP; Water and Barnes-Hut from the SPLASH benchmark suite [19]; IS and 3D-FFT from the NAS benchmark suite [4]; Shallow from NCAR <ref> [18] </ref> and ILINK, a large computational genetics code [11]. The applications and input sets vary considerably in terms of the amount of write-write false sharing and the write granularity. Tables 1 and 2 summarize the relevant characteristics of the applications.
Reference: [19] <author> J.P. Singh, W.-D. Weber, and A. Gupta. </author> <title> SPLASH: Stanford parallel applications for shared-memory. </title> <type> Technical Report CSL-TR-91-469, </type> <institution> Stanford University, </institution> <month> April </month> <year> 1991. </year>
Reference-contexts: The adaptive protocols were implemented in Tread-Marks [3]. Eight applications were used to demonstrate the performance: Red-Black SOR and TSP are small kernels; Barnes-Hut and Water are from the Splash benchmarks suite <ref> [19] </ref>; IS and 3D-FFT are from the NAS benchmark suite [4]; Shallow is a small weather modeling code from NCAR [18]; and ILINK is a production computational genetics code [11]. These applications cover a wide spectrum in terms of write-write false sharing and write granularity. <p> This led us to a conservative threshold value of 3KB to switch from MW to SW in WFS+WG. 5 Applications We use 8 applications in this study: Red-Black SOR and TSP; Water and Barnes-Hut from the SPLASH benchmark suite <ref> [19] </ref>; IS and 3D-FFT from the NAS benchmark suite [4]; Shallow from NCAR [18] and ILINK, a large computational genetics code [11]. The applications and input sets vary considerably in terms of the amount of write-write false sharing and the write granularity.
Reference: [20] <author> P. Stenstrom, M. Brorsson, and L. Sandberg. </author> <title> An adaptive cache coherence protocol optimized for migratory sharing. </title> <booktitle> In Proceedings of the 20th Annual International Symposium on Computer Architecture, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: Using per-word timestamps [1, 15, 22] addresses the problem of diff accumulation directly. The problem is alleviated in our system because we switch to using whole pages whenever the diffs are large. Cox and Fowler, and Stenstrom and Brorsson <ref> [7, 20] </ref> describe hardware cache-coherence protocols that adapt to migratory sharing patterns. Migratory cache blocks are detected automatically.
Reference: [21] <author> D. Yeung, J. Kubiatowicz, and A. Agarwal. MGS: </author> <title> A multigrain shared memory system. </title> <booktitle> In Proceedings of the 23th Annual International Symposium on Computer Architecture, </booktitle> <month> May </month> <year> 1996. </year>
Reference-contexts: Munin [6] uses multiple protocols to handle data with different access characteristics. The innovation in our work is that it chooses automatically between SW and MW protocols. In Munin, the choice of protocol is based on somewhat burdensome user annotations. MGS <ref> [21] </ref>, a DSM system for distributed SMPs, uses a base protocol similar to Munin. Their protocol employs a single writer optimization that avoids diffing overhead when there is only one writable copy.
Reference: [22] <author> M.J. Zekauskas, </author> <title> W.A. Sawdon, and B.N. Bershad. Software write detection for distributed shared memory. </title> <booktitle> In Proceedings of the First USENIX Symposium on Operating System Design and Implementation, </booktitle> <pages> pages 87-100, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: We show that under LRC the benefits of MW and SW protocols can be combined into one adaptive algorithm that uses the appropriate protocol on a per-page basis. Various techniques have been proposed to replace diffing by cheaper alternatives <ref> [15, 22] </ref> or to o*oad diffing to a communication coprocessor [5, 23]. This work is orthogonal to ours, in that we could incorporate these techniques into our adaptive protocols. Using per-word timestamps [1, 15, 22] addresses the problem of diff accumulation directly. <p> Various techniques have been proposed to replace diffing by cheaper alternatives [15, 22] or to o*oad diffing to a communication coprocessor [5, 23]. This work is orthogonal to ours, in that we could incorporate these techniques into our adaptive protocols. Using per-word timestamps <ref> [1, 15, 22] </ref> addresses the problem of diff accumulation directly. The problem is alleviated in our system because we switch to using whole pages whenever the diffs are large. Cox and Fowler, and Stenstrom and Brorsson [7, 20] describe hardware cache-coherence protocols that adapt to migratory sharing patterns. <p> This avoids unnecessary message traffic if the home node is poorly chosen. False sharing has also been addressed by compile-time analysis [12], remapping of data within the address space [9], and by using objects as a smaller consistency unit <ref> [22] </ref>. All of these techniques seek to eliminate rather than tolerate false sharing.
Reference: [23] <author> Y. Zhou, L. Iftode, and K. Li. </author> <title> Performance evaluation of two home-based lazy release consistency protocols for shared virtual memory systems. </title> <booktitle> In Proceedings of the Second USENIX Symposium on Operating System Design and Implementation, </booktitle> <pages> pages 75-88, </pages> <month> November </month> <year> 1996. </year>
Reference-contexts: We show that under LRC the benefits of MW and SW protocols can be combined into one adaptive algorithm that uses the appropriate protocol on a per-page basis. Various techniques have been proposed to replace diffing by cheaper alternatives [15, 22] or to o*oad diffing to a communication coprocessor <ref> [5, 23] </ref>. This work is orthogonal to ours, in that we could incorporate these techniques into our adaptive protocols. Using per-word timestamps [1, 15, 22] addresses the problem of diff accumulation directly. <p> Their protocol employs a single writer optimization that avoids diffing overhead when there is only one writable copy. Although the twin is still made, the entire page is sent to the home instead of computing a diff. The work of Zhou et. al <ref> [23] </ref> also avoids diffing when the home node is in fact the single writer for the page. In contrast, our adaptive protocols avoid twinning and diff-ing overhead without using a fixed home node. This avoids unnecessary message traffic if the home node is poorly chosen.
References-found: 23

