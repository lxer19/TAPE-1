URL: ftp://ftp.cs.washington.edu/tr/1994/09/UW-CSE-94-09-02.PS.Z
Refering-URL: http://www.cs.washington.edu/research/tr/tr-by-title.html
Root-URL: 
Title: Optimizing Static Calendar Queues where b is the time to process an empty bucket and
Author: K. Bruce Erickson Richard E. Ladner Anthony LaMarca p 
Keyword: of the infinite bucket calendar queue.  
Note: 2b  
Date: September 13, 1994  
Address: Seattle, WA 98195  
Affiliation: University of Washington  
Abstract: The calendar queue is an important implementation of a priority queue which is particularly useful in discrete event simulators. In this paper we present an analysis of the static calendar queue which maintains N active events. A step of the discrete event simulator removes and processes the event with the smallest associated time and inserts a new event whose associated time is the time of the removed event plus a random increment with mean . We demonstrate that for the infinite bucket calendar queue the optimal bucket width is approximately 2bc + d, where d is the fixed time to process an event. We show that choosing the number of buckets to be O(N ) yields a calendar queue with performance equal to or almost equal to the performance ffi opt =
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M.R. Brown. </author> <title> Implementation and analysis of binomial queue algorithms. </title> <journal> SIAM Journal on Computing, </journal> <volume> Vol. 7, </volume> <pages> pp. 298-319, </pages> <year> 1978. </year>
Reference-contexts: The simulation of Figure 2 uses the optimal bucket width for N = 1; 000 for the infinite bucket calendar queue, then varying the number of buckets. 1.3 Related Results There are a large number of implementations of priorities queues <ref> [1, 5, 7, 9, 10, 11] </ref>. An interesting empirical comparison of eleven popular implementations is provided by Jones [6].
Reference: [2] <author> R. Brown. </author> <title> Calendar Queues: A fast O(1) priority queue implementation for the simulation event set problem. </title> <journal> Communications of the ACM, </journal> <volume> Vol. 31, </volume> <pages> pp. 1120-1227, </pages> <year> 1988. </year>
Reference-contexts: 1 Introduction The calendar queue data structure, as described by Brown <ref> [2] </ref>, is an important implementation of a priority queue which is useful as the event queue in a discrete event simulator. <p> In this case, each event corresponds to execution of a segment of code by one of the processors. Thus, if there are N processors, then there are exactly N active events in the priority queue. In many situations the calendar queue significantly outperforms traditional priority queue data structures. Brown <ref> [2] </ref> has given empirical evidence that the calendar queue, with its parameters properly set, achieves expected constant time per event processed. <p> Most of the popular implementations have expected time per event performance O (log N ), which can be excessive for discrete event 3 simulation with very large N and a large number of simulation steps. As mentioned earlier Brown did an empirical study of the dynamic calendar queue <ref> [2] </ref>. In the empirical study, Brown's main emphasis was on techniques for changing the bucket width and number of buckets dynamically as N changed. He did not seek to find the optimal bucket width for a given N , just one which would give good performance.
Reference: [3] <author> DECchip 21064-AA Microprocessor, </author> <title> Hardware Reference Manual. Digital Equipment Corporation. Order Number: </title> <address> EC-N0079-72. </address> <year> 1992. </year>
Reference-contexts: In addition, we have shown that the number of buckets M can be chosen to be O (N ) so as to achieve minimal or almost minimal expected time per event. We implemented our calendar queue in C ++ for execution on a DEC alpha <ref> [3] </ref>. Because the DEC alpha has a two-level cache architecture the values of the "constants" b, c, and d actually depend on N , M and even on properties the jump probability density f other than its mean.
Reference: [4] <author> W. Feller. </author> <title> An Introduction to Probability Theory and Its Applications, Vol. II. </title> <publisher> John Wiley and Sons, </publisher> <address> New York, </address> <year> 1971. </year>
Reference: [5] <author> J. Francon, G Viennot, and J. Vuillemin. </author> <title> Description and Analysis of an efficient priority queue representation. </title> <booktitle> Proceedings of the 19th Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pp. 1-7, </pages> <year> 1978. </year>
Reference-contexts: The simulation of Figure 2 uses the optimal bucket width for N = 1; 000 for the infinite bucket calendar queue, then varying the number of buckets. 1.3 Related Results There are a large number of implementations of priorities queues <ref> [1, 5, 7, 9, 10, 11] </ref>. An interesting empirical comparison of eleven popular implementations is provided by Jones [6].
Reference: [6] <author> D.S. Jones. </author> <title> An empirical comparison of priority-queue and event-set implementations. </title> <journal> Communications of the ACM, </journal> <volume> Vol. 29, </volume> <pages> pp. 300-310, </pages> <year> 1986. </year>
Reference-contexts: An interesting empirical comparison of eleven popular implementations is provided by Jones <ref> [6] </ref>. Most of the popular implementations have expected time per event performance O (log N ), which can be excessive for discrete event 3 simulation with very large N and a large number of simulation steps. As mentioned earlier Brown did an empirical study of the dynamic calendar queue [2].
Reference: [7] <author> D.E. Knuth. </author> <booktitle> The Art of Computer Programming, </booktitle> <volume> Vol. </volume> <month> 3, </month> <title> Sorting and Searching. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1973. </year>
Reference-contexts: The simulation of Figure 2 uses the optimal bucket width for N = 1; 000 for the infinite bucket calendar queue, then varying the number of buckets. 1.3 Related Results There are a large number of implementations of priorities queues <ref> [1, 5, 7, 9, 10, 11] </ref>. An interesting empirical comparison of eleven popular implementations is provided by Jones [6].
Reference: [8] <author> D. Revuz. </author> <title> Markov Chains. </title> <publisher> North-Holland, </publisher> <address> New York. </address> <year> 1984. </year>
Reference: [9] <author> D.D. Sleator and R.E. Tarjan. </author> <title> Self-adjusting binary search trees. </title> <journal> Journal of the ACM, </journal> <volume> Vol. 32, </volume> <pages> pp. 652-686. </pages> <year> 1985. </year>
Reference-contexts: The simulation of Figure 2 uses the optimal bucket width for N = 1; 000 for the infinite bucket calendar queue, then varying the number of buckets. 1.3 Related Results There are a large number of implementations of priorities queues <ref> [1, 5, 7, 9, 10, 11] </ref>. An interesting empirical comparison of eleven popular implementations is provided by Jones [6].
Reference: [10] <author> D.D. Sleator and R.E. Tarjan. </author> <title> Self-adjusting heaps. </title> <journal> SIAM Journal on Computing, </journal> <volume> Vol. 15, </volume> <pages> pp. 52-69, </pages> <year> 1986. </year>
Reference-contexts: The simulation of Figure 2 uses the optimal bucket width for N = 1; 000 for the infinite bucket calendar queue, then varying the number of buckets. 1.3 Related Results There are a large number of implementations of priorities queues <ref> [1, 5, 7, 9, 10, 11] </ref>. An interesting empirical comparison of eleven popular implementations is provided by Jones [6].
Reference: [11] <author> J. Vuillemin. </author> <title> A data structure for manipulating priority queues. </title> <journal> Communications of the ACM, </journal> <volume> Vol. 21, </volume> <pages> pp. 309-315, </pages> <year> 1978. </year> <month> 7 </month>
Reference-contexts: The simulation of Figure 2 uses the optimal bucket width for N = 1; 000 for the infinite bucket calendar queue, then varying the number of buckets. 1.3 Related Results There are a large number of implementations of priorities queues <ref> [1, 5, 7, 9, 10, 11] </ref>. An interesting empirical comparison of eleven popular implementations is provided by Jones [6].
References-found: 11

