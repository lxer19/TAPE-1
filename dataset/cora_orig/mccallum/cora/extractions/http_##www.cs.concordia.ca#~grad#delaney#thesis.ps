URL: http://www.cs.concordia.ca/~grad/delaney/thesis.ps
Refering-URL: http://www.cs.concordia.ca/~grad/delaney/
Root-URL: http://www.cs.concordia.ca
Title: REVERSE ENGINEERING AND OPTIMISATION OF THE BLASTP PROGRAM  
Author: Shawn Delaney 
Degree: A thesis in The Department of Computer Science Presented in Partial Fulfillment of the Requirements For the Degree of Master of Computer Science  
Note: c Shawn Delaney, 1998  
Date: September 1998  
Address: Montr eal, Qu ebec, Canada  
Affiliation: Concordia University  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Altschul SF, Gish W, Miller W, </author> <title> Myers EW, and Lipman DJ. Basic local alignment search tool. </title> <journal> J Mol Biol, </journal> <volume> 215(3) </volume> <pages> 403-410, </pages> <month> Oct </month> <year> 1990. </year>
Reference-contexts: Introduction 1.1 Motivation For Thesis The BLAST (Basic Local Alignment Search Tool) suite of programs <ref> [1] </ref> is arguably the best tool currently available for searching molecular sequence databases. BLASTP is the particular program that looks for similarities between a query protein sequence and those in a protein sequence database. <p> First an unknown protein is compared to a sequence database to find the set of known sequences to which it is similar. The BLASTP <ref> [1] </ref> or FASTA [11] programs are appropriate tools for this step since they perform searches quickly with an acceptable compromise in sensitivity. In addition, both programs provide a statistical measure of significance for each match that contributes greatly to the assessment of the biological significance of a match. <p> They are the methods of choice for database searching because of their relatively low computational requirements. Needleman-Wunsch [24] and Smith-Waterman [25] algorithms form the basis for most dynamic programming methods. FASTA [11] and BLASTP <ref> [1] </ref> are the most popular algorithms for protein database searching. These algorithms either report a measure of similarity based on a comparison of two sequences over their entire lengths (global) or among one or more aligned sub-segments (local). <p> These anomalies are described fully in subsection 4.3.4. These anomalies mean that an HSP may not be locally maximal as described in <ref> [1] </ref>. However, such deviations could be corrected by post-processing the HSP set or by adjusting the X parameter or may be accepted as a reasonable compromise to obtain the performance speed-up. two-hit The two-hit optimisation provides the greatest performance enhancement at 67%.
Reference: [2] <author> James Peter. </author> <title> Breakthroughs and Views Of Genomes and Proteomes. </title> <journal> Biochemical and Biophysical Research Communications, </journal> <volume> 231 </volume> <pages> 1-6, </pages> <year> 1997. </year>
Reference-contexts: BLASTP is the particular program that looks for similarities between a query protein sequence and those in a protein sequence database. Search speed is a critical issue in scanning sequence databases whose sizes continue to grow as the sequence data from large-scale genome sequencing efforts is produced <ref> [2] </ref>. As the size of the search space increases, the performance of search programs such as BLAST decreases. There are two solutions to this problem: (1) Develop faster algorithms for scanning sequence databases and (2) Reduce the search space by grouping similar database sequences.
Reference: [3] <author> Benson Dennis, Boguski Mark, Lipman David J., and Ostell James. </author> <title> The National Center for Biotechnology Information Program Description, http://www.ncbi.nlm.nih.gov/. Genome, </title> <booktitle> 6 </booktitle> <pages> 389-391, </pages> <year> 1990. </year>
Reference-contexts: A faster program reduces the likelihood that analysis with BLASTP is a rate-limiting step in the work-flow and (2) BLAST servers, such as the one at NCBI <ref> [3] </ref>, would require less time to perform BLASTP searches providing better service to clients. 1 further investigation. In this example work-flow, the genome sequence (1) is scanned to identify protein coding regions or ORFs (open reading frames) (2). <p> To ensure that an unknown is compared to all known sequences, an investigator should search all databases. This cumbersome task is simplified by searching a non-redundant database which merges sequences that are similar in amino acid composition. For example, NCBI <ref> [3] </ref> maintains the protein NRDB (non-redundant database) [21] which is constructed from Swiss-Prot, PIR-International, GenPept and the PDB. The criteria for membership in a non-redundant database is generally quite low; the database may contain sequences that differ in composition by less than ten percent or even by only one residue.
Reference: [4] <institution> National Center for Biotechnology Information. BLAST UNIX System V Manual Page, </institution> <month> Oct. 23, </month> <year> 1994. </year> <note> Version 1.4. </note>
Reference-contexts: This is described in Figure 12. gij129937j spjP27644jPGLR AGRTU POLYGALACTURONASE (PECTINASE) (PGL) gij95113j pirjjA40364 picA protein - Agrobacterium tumefaciens gij142256 (M62814) PGL ORF [Agrobacterium tumefaciens] &gt;MALATRATGGAGRRKPVRARCARGLHLVSCHKTQLLGFTIRNAASWTIHPQGCEDL TAAASTIIAPHDSPNTDGFNPESCRNVMISGVRFSVGDDCIAVKAGKRGPDGEDDH LAETRGITVRHCLMQPGHGGLVIGSEMSGGVHDVTVEDCDMIGTDRGLRLKTGARS GGGMVGNITMRRVLLDGVQTALSANAHYHCDADGHDDWVQSRNPAPVNDGTPFVDG ITVEDVEIRNLAHAAGVFLGLPDVPSATSLSATSPIVSHDPSAVATPPIMADRVRP MRMRLVFEQADVVCDDPALLNDAPVSISSYFD The program has several command line options which are listed in <ref> [4] </ref>. Those options that a typical user may specify are: (1) -matrix, which specifies the residue pair score matrix, and (2) W, T or X, which may be adjusted to control the sensitivity of the search. The default matrix used is BLOSUM62. <p> These parameters are fully explained in section 2.3. For a more complete discussion of all possible input parameters see <ref> [4] </ref>. 4 1.2.0.2 Program Output The output of the program consists of five parts: (1) Program introduction, (2) Histogram of expectations if one is requested, (3) List of one-line summaries for each matching database sequence, (4) List of alignments or HSPs (high scoring segment pairs) and (5) Parameters used and search <p> Parts three and four are of general interest to users and are further described here. For a description of the remaining parts see <ref> [4] </ref>. The one-line summary list (Figure 2) facilitates the comparison of the scores and statistical significance of individual matches to that of the set. <p> A program implementing the modified algorithm uses 48% less CPU cycles. There is an equivalent savings in CPU time. However, this savings is not realized in wall clock time, reported by the program as real time <ref> [4] </ref>, page 17, which may vary between runs depending on the availability of the CPU for the BLASTP process. However, the times reported from different runs consistently show longer wall clock times for the residue-doublet program. <p> The program using the two-hit algorithm uses approximately 63% less CPU cycles than the program using the unmodified algorithm. There is a corresponding decrease in CPU time. The savings in wall clock time is approximately 61%. Wall clock time is the time reported by the program as real time <ref> [4] </ref>, page 17 whose values may vary between runs depending on the availability of the CPU for the BLASTP process. Procedure CPU cycles x 10 10 CPU time (s) BlastWordExtend (two-hit) 0:6 19.4 BlastWordExtend (unmodified) 2:0 68.5 Table 11: Comparison of BlastWordExtend Procedure Time.
Reference: [5] <author> Patterson David A. and Hennessy John L. </author> <title> Computer Architecture, A Quantitative Approach. </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> San Francisco, California, </address> <year> 1996. </year>
Reference-contexts: Reverse Engineering of the BLASTP Program This work uses a reverse engineering approach to identify those parts of the program that, if optimised, would give the largest CPU speed-up. This is an application of Amdahl's Law <ref> [5] </ref> the largest speed-up is obtained by optimising those parts that use the most CPU cycles. <p> Furthermore, the profile reveals that the line of code that accesses the residue pair score matrix is the most expensive, accounting for greater than 63 percent of the execution time (Table 2). Amdahl's Law <ref> [5] </ref> states that the greatest savings in execution time stands to be gained by optimising the most time expensive part of the program. Clearly the extension procedure should be the focus of optimisation.
Reference: [6] <author> Stryer Lubert. </author> <title> Biochemistry. W.H. </title> <publisher> Freeman and Company, </publisher> <address> New York, third edition, </address> <year> 1988. </year>
Reference-contexts: It is the interaction among the protein's amino acids both locally and globally that provides the structural integrity required for a protein to perform its biological function. "The information needed to specify the complex three-dimensional structure of a protein is contained in its amino acid sequence sequence specifies conformation" <ref> [6] </ref>, page 33. 11 Two proteins are homologous if they share a common ancestor [7]; i.e. they are related in an evolutionary context.
Reference: [7] <author> Pearson William R. </author> <title> Effective Protein Sequence Comparison. </title> <booktitle> Methods in Enzymology, </booktitle> <volume> 266 </volume> <pages> 227-258, </pages> <year> 1996. </year>
Reference-contexts: that provides the structural integrity required for a protein to perform its biological function. "The information needed to specify the complex three-dimensional structure of a protein is contained in its amino acid sequence sequence specifies conformation" [6], page 33. 11 Two proteins are homologous if they share a common ancestor <ref> [7] </ref>; i.e. they are related in an evolutionary context. Homologous proteins always share a common three-dimensional folding structure and often share active sites or binding domains [8]. 2.2 Protein Sequence Comparison 2.2.1 Inferring Homology Comparing one protein to another is one of the most informative computational activities in biology. <p> A search that produces matches that are 80% identical is essentially producing matches to the same sequence. Non-redundant databases are larger than necessary and expectation values calculated from them are artificially high and may be less significant <ref> [7] </ref>. However, these databases provide the benefit of a 50% reduction in search space over the set of independent databases. "More sophisticated methods for creating derived, composite views of protein and DNA sequences data provide even further reductions [9]. <p> A natural question is: what is the probability that an alignment could occur by chance alone? Such measures reduce the likelihood that an investigator will call sequences homologous when they are not <ref> [7] </ref>. In searching protein sequence databases, avoiding high similarity scores with unrelated sequences can be just as important as calculating high scores for related sequences [8]. This subsection describes the statistical measures used in the BLASTP program to assess the significance of scores.
Reference: [8] <author> Pearson William R. </author> <title> Protein Sequence Comparison and Protein Evolution, </title> <booktitle> 1998. Conference on Intelligent Systems for Molecular Biology Tutorial Series, </booktitle> <address> Sunday June 28, Montreal, Quebec, Canada. </address>
Reference-contexts: Homologous proteins always share a common three-dimensional folding structure and often share active sites or binding domains <ref> [8] </ref>. 2.2 Protein Sequence Comparison 2.2.1 Inferring Homology Comparing one protein to another is one of the most informative computational activities in biology. Sequence comparison is used as a method to infer homology and is most informative when it detects homologous proteins. <p> In searching protein sequence databases, avoiding high similarity scores with unrelated sequences can be just as important as calculating high scores for related sequences <ref> [8] </ref>. This subsection describes the statistical measures used in the BLASTP program to assess the significance of scores. The statistics of local similarity scores for alignments without gaps have been described by Karlin and Altschul [22]. With each HSP (high scoring segment pair), an Expect and P-value is reported.
Reference: [9] <author> Altschul Stephen F., Boguski Mark S., Gish Warren, and Wootton John C. </author> <title> Issues in searching molecular sequence databases. </title> <journal> Nature Genetics, </journal> <volume> 6 </volume> <pages> 119-129, </pages> <month> Feb </month> <year> 1994. </year> <month> 86 </month>
Reference-contexts: The process of inferring homology consists of several sequential steps each of which builds on facts gathered in the previous one to build a case for homology <ref> [9] </ref> [10]. First an unknown protein is compared to a sequence database to find the set of known sequences to which it is similar. The BLASTP [1] or FASTA [11] programs are appropriate tools for this step since they perform searches quickly with an acceptable compromise in sensitivity. <p> However, these databases provide the benefit of a 50% reduction in search space over the set of independent databases. "More sophisticated methods for creating derived, composite views of protein and DNA sequences data provide even further reductions <ref> [9] </ref>. One promising method is to cluster sequences into groups based on percent compositional similarity and select a representative member to which a query is compared.
Reference: [10] <author> Barton G J. </author> <title> Protein Sequence Alignment and Database Scanning. This article will appear in: Protein Structure prediction a practical approach, Edited by M.J.E.Sternberg, </title> <address> http://barton.ebi.ac.uk/barton/papers/rev93 1/rev93 1.html. </address>
Reference-contexts: The process of inferring homology consists of several sequential steps each of which builds on facts gathered in the previous one to build a case for homology [9] <ref> [10] </ref>. First an unknown protein is compared to a sequence database to find the set of known sequences to which it is similar. The BLASTP [1] or FASTA [11] programs are appropriate tools for this step since they perform searches quickly with an acceptable compromise in sensitivity.
Reference: [11] <author> Pearson William R. and Lipman David J. </author> <title> Improved tools for biological sequence comparison. </title> <booktitle> Proceedings of the National Academy of Sciences, </booktitle> <volume> 85 </volume> <pages> 2444-2448, </pages> <year> 1988. </year>
Reference-contexts: First an unknown protein is compared to a sequence database to find the set of known sequences to which it is similar. The BLASTP [1] or FASTA <ref> [11] </ref> programs are appropriate tools for this step since they perform searches quickly with an acceptable compromise in sensitivity. In addition, both programs provide a statistical measure of significance for each match that contributes greatly to the assessment of the biological significance of a match. <p> They are the methods of choice for database searching because of their relatively low computational requirements. Needleman-Wunsch [24] and Smith-Waterman [25] algorithms form the basis for most dynamic programming methods. FASTA <ref> [11] </ref> and BLASTP [1] are the most popular algorithms for protein database searching. These algorithms either report a measure of similarity based on a comparison of two sequences over their entire lengths (global) or among one or more aligned sub-segments (local). <p> Then, neighboring entries are filled or calculated until the score of an extended aligned segment is maximised. The complexity of the heuristic algorithms remains on the order of O (N x M), but the number of computations based on residue-residue comparisons is greatly reduced. The FASTA algorithm <ref> [11] </ref> is an improvement over the initial FASTP algorithm [27] [28]. It operates in four steps: (1) Exact matches of length one or two are identified, (2) Segments that contain identity matches are re-scored using a score matrix.
Reference: [12] <author> Dodge C, Schneider R, and Sander C. </author> <title> The HSSP database of protein structure-sequence alignments and family profiles. </title> <journal> Nucleic Acids Research, </journal> <volume> 26(1) </volume> <pages> 313-315, </pages> <year> 1998. </year>
Reference-contexts: Matches that have a borderline score or ambiguous significance can be compared again using more rigorous, but computationally expensive, programs that implement dynamic programming algorithms. Subsequently, possible homologues identified by these techniques can be compared to structural databases such as HSSP <ref> [12] </ref> or FSSP [13] which may give further evidence of homology based on similarity of secondary or tertiary structure. 12 The context of this work is the first step of this process in which an unknown is compared to a sequence database.
Reference: [13] <author> Holm L and Sander C. </author> <title> Touring protein fold space with Dali/FSSP. </title> <journal> Nucleic Acids Research, </journal> <volume> 26(1) </volume> <pages> 316-319, </pages> <year> 1998. </year>
Reference-contexts: Matches that have a borderline score or ambiguous significance can be compared again using more rigorous, but computationally expensive, programs that implement dynamic programming algorithms. Subsequently, possible homologues identified by these techniques can be compared to structural databases such as HSSP [12] or FSSP <ref> [13] </ref> which may give further evidence of homology based on similarity of secondary or tertiary structure. 12 The context of this work is the first step of this process in which an unknown is compared to a sequence database.
Reference: [14] <author> Dayhoff M.O., Schwartz R.M., and Orcutt B.C. </author> <title> A Model of Evolutionary Change in Proteins. Atlas of Protein Sequence and Structure, </title> <booktitle> 5(3) </booktitle> <pages> 345-352, </pages> <year> 1978. </year>
Reference-contexts: The following subsections provide a brief introduction to each of these issues. 2.2.2 Score Matrices One of the most frequently used matrices is that of Dayhoff <ref> [14] </ref> who counted the number of point-accepted mutations (PAMs) in 71 groups of closely related proteins (85% similarity). An accepted point mutation is defined as "a replacement of one amino acid by another, accepted by natural selection".
Reference: [15] <author> Henikoff Steven and Henikoff Jorja G. </author> <title> Amino acid substitution matrices from protein blocks. </title> <booktitle> In Proceedings of the National Academy of Science, </booktitle> <volume> volume 89, </volume> <pages> pages 10915-10919, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: Dayhoff et al.[14] have found that the log odds matrix for 250 PAMs (PAM250) is an effective scoring matrix for detecting distant relationships. The BLOSUM series of matrices, Henikoff and Henikoff <ref> [15] </ref>, are also constructed using replacement or substitution frequencies, but from over 2000 sets of similar segments or blocks. A single block can be considered as representing a conserved region of protein family. <p> For example, 13 a BLOSUM62 matrix is derived from a block whose members are 62% similar. To detect similarity between more distantly related proteins one would use, for example, a BLOSUM matrix constructed from a block whose members differ by less than 62%. Henikoff and Henikoff <ref> [15] </ref> have found that matrices derived from blocks, the BLO-SUM series, perform better in alignments and homology searches than those based on accepted mutations in closely related groups as in the PAM series. 2.2.3 Protein Sequence Databases When comparing an unknown protein to a database, it is of vital importance that
Reference: [16] <author> Baxevanis Andreas D., Boguski Mark S., and Ouellette B.F. Francis. </author> <title> Genome Analysis: A Laboratory Manual. </title> <note> To be published by Cold Spring Harbor Laboratory Press, http://www.cshl.org/books/g a/bk1ch7/. </note>
Reference-contexts: BLO-SUM series, perform better in alignments and homology searches than those based on accepted mutations in closely related groups as in the PAM series. 2.2.3 Protein Sequence Databases When comparing an unknown protein to a database, it is of vital importance that the database contain the most recent sequence information <ref> [16] </ref>. "Sequence relationships critical to important discoveries have on occasion been missed because old or incomplete databases were employed"[9]. There are several independently maintained protein sequence databases; Swiss-Prot [17], PIR-International [18], GenPept [19] and the PDB [20].
Reference: [17] <author> Bairoch A and Apweiler R. </author> <title> The SWISS-PROT protein sequence data bank and its supplement TrEMBL in 1998. </title> <journal> Nucleic Acids Research, </journal> <volume> 26(1) </volume> <pages> 38-42, </pages> <year> 1998. </year>
Reference-contexts: There are several independently maintained protein sequence databases; Swiss-Prot <ref> [17] </ref>, PIR-International [18], GenPept [19] and the PDB [20]. The curators of these databases use different strategies for updates, a consequence of which is that one database may contain sequences that others do not.
Reference: [18] <author> Barker WC, Garavelli JS, Haft DH, Hunt LT, Marzec CR, Orcutt BC, Srini-vasarao GY, Yeh LSL, Ledley RS, Mewes HW, Pfeiffer F, and Tsugita A. </author> <title> The PIR-International Protein Sequence Database. </title> <journal> Nucleic Acids Research, </journal> <volume> 26(1) </volume> <pages> 27-32, </pages> <year> 1998. </year>
Reference-contexts: There are several independently maintained protein sequence databases; Swiss-Prot [17], PIR-International <ref> [18] </ref>, GenPept [19] and the PDB [20]. The curators of these databases use different strategies for updates, a consequence of which is that one database may contain sequences that others do not. To ensure that an unknown is compared to all known sequences, an investigator should search all databases.
Reference: [19] <author> Benson DA, </author> <title> Boguski MS, Lipman DJ, Ostell J, and Ouellette BF. </title> <journal> Genbank. Nucleic Acids Research, </journal> <volume> 26(1) </volume> <pages> 1-7, </pages> <year> 1998. </year>
Reference-contexts: There are several independently maintained protein sequence databases; Swiss-Prot [17], PIR-International [18], GenPept <ref> [19] </ref> and the PDB [20]. The curators of these databases use different strategies for updates, a consequence of which is that one database may contain sequences that others do not. To ensure that an unknown is compared to all known sequences, an investigator should search all databases.
Reference: [20] <author> Bernstein FC, Koetzle TF, Williams GJ, Meyer EE Jr, Brice MD, Rodgers JR, Kennard O, Shimanouchi T, and Tasumi M. </author> <title> The Protein Data Bank: 87 a computer-based archival file for macromolecular structures. </title> <journal> J Mol Biol, </journal> <volume> 112(3) </volume> <pages> 535-542, </pages> <year> 1977. </year>
Reference-contexts: There are several independently maintained protein sequence databases; Swiss-Prot [17], PIR-International [18], GenPept [19] and the PDB <ref> [20] </ref>. The curators of these databases use different strategies for updates, a consequence of which is that one database may contain sequences that others do not. To ensure that an unknown is compared to all known sequences, an investigator should search all databases.
Reference: [21] <institution> National Center for Biotechnology Information. The Protein Non-redundant Database (NRDB). ftp://ncbi.nlm.nih.gov/blast/db/nr.Z. </institution>
Reference-contexts: To ensure that an unknown is compared to all known sequences, an investigator should search all databases. This cumbersome task is simplified by searching a non-redundant database which merges sequences that are similar in amino acid composition. For example, NCBI [3] maintains the protein NRDB (non-redundant database) <ref> [21] </ref> which is constructed from Swiss-Prot, PIR-International, GenPept and the PDB. The criteria for membership in a non-redundant database is generally quite low; the database may contain sequences that differ in composition by less than ten percent or even by only one residue. <p> The search program is BLASTP, version 1.4 [32]; the default values for all parameters are used. The database is the protein NRDB (non-redundant database) <ref> [21] </ref>, a conglomerate of several protein sequence databases in which identical sequences are merged into one entry. The database contains 252,307 entries. The query sequence (length = 312 residues) is given in Box 1, section 1.2. The average length of database sequence is 283 residues.
Reference: [22] <author> Karlin Samuel and Altschul Stephen F. </author> <title> Methods for assessing the statistical significance of molecular sequence features by using general scoring schemes. </title> <booktitle> Proceedings of the National Academy of Sciences, </booktitle> <volume> 87 </volume> <pages> 2264-2268, </pages> <year> 1990. </year>
Reference-contexts: This subsection describes the statistical measures used in the BLASTP program to assess the significance of scores. The statistics of local similarity scores for alignments without gaps have been described by Karlin and Altschul <ref> [22] </ref>. With each HSP (high scoring segment pair), an Expect and P-value is reported. The Expect value is the number of times one might expect to observe the occurrence of an HSP having score S by chance alone. The P-value is the probability of this occurrence in the range 0-1.
Reference: [23] <institution> National Center for Biotechnology Information. </institution> <note> Blast Help Page. Version 1.4. </note>
Reference-contexts: The Expect value is the number of times one might expect to observe the occurrence of an HSP having score S by chance alone. The P-value is the probability of this occurrence in the range 0-1. These values are dependent on several factors <ref> [23] </ref>: (1) the scoring system, (2) the residue composition of the query, (3) an assumed residue composition for a typical database sequence, (4) the length of the query sequence and (5) the total length of the database. In certain cases, multiple HSPs are found between two sequences.
Reference: [24] <author> Needleman S. and Wunsch C. </author> <title> A general method applicable to the search for similarities in the amino acid sequences of two proteins. </title> <journal> Journal of Molecular Biology, </journal> <volume> 48 </volume> <pages> 444-453, </pages> <year> 1970. </year>
Reference-contexts: Heuristic algorithms are less computationally expensive, but may miss borderline regions of similarity; i.e. regions in which the similarity measure exceeds a preset threshold only slightly. They are the methods of choice for database searching because of their relatively low computational requirements. Needleman-Wunsch <ref> [24] </ref> and Smith-Waterman [25] algorithms form the basis for most dynamic programming methods. FASTA [11] and BLASTP [1] are the most popular algorithms for protein database searching. <p> Therefore, when comparing an unknown protein to a database, local alignment algorithms are better than global alignment algorithms at detecting distantly-related similarity. 16 Dynamic programming algorithms have been successfully applied to biological se-quence comparison problems. The two algorithms that form the basis of most methods are those of Needleman-Wunsch <ref> [24] </ref> and Smith-Waterman [25]. The former finds the best alignment of two sequences over their entire lengths; the latter, the best local or sub-alignment. A variant of the Needleman-Wunsch algorithm is shown in Box 2, while the Smith-Waterman algorithm is shown in Box 3.
Reference: [25] <author> Smith T.F. </author> <title> and Waterman M.S. Identification of common molecular subsequences. </title> <journal> Journal of Molecular Biology, </journal> <volume> 147 </volume> <pages> 195-197, </pages> <year> 1981. </year>
Reference-contexts: Heuristic algorithms are less computationally expensive, but may miss borderline regions of similarity; i.e. regions in which the similarity measure exceeds a preset threshold only slightly. They are the methods of choice for database searching because of their relatively low computational requirements. Needleman-Wunsch [24] and Smith-Waterman <ref> [25] </ref> algorithms form the basis for most dynamic programming methods. FASTA [11] and BLASTP [1] are the most popular algorithms for protein database searching. <p> The two algorithms that form the basis of most methods are those of Needleman-Wunsch [24] and Smith-Waterman <ref> [25] </ref>. The former finds the best alignment of two sequences over their entire lengths; the latter, the best local or sub-alignment. A variant of the Needleman-Wunsch algorithm is shown in Box 2, while the Smith-Waterman algorithm is shown in Box 3. Both algorithms compute a score for the best alignment.
Reference: [26] <author> Pearson William R. and Miller Webb. </author> <title> Dynamic programming algorithms for biological sequence comparison. </title> <booktitle> Methods in Enzymology, </booktitle> <volume> 210 </volume> <pages> 575-601, </pages> <year> 1992. </year>
Reference-contexts: S (i , 0) &lt;- S (i-1 , 0) + (oe [ a i 6. for j &lt;- 1 to N do b j ]), S (i-1, j) + (oe [ a i b j ]) g A Variant of the Needleman-Wunsch Algorithm <ref> [26] </ref> The similarity matrix, S, stores the scores of all sub-alignments [ a 0 :::a i b 0 :::b j ]. Each entry is initialised to zero (1). The algorithm traverses the matrix from left to right (4) and from top to bottom (6). <p> S (i , 0) &lt;- S (i-1 , 0) + (oe [ a i 6. for j &lt;- 1 to N do b j ]), S (i-1 , j) + (oe [ a i b j ]) g 8. best &lt;-max f S (i,j), best The Smith-Waterman Algorithm <ref> [26] </ref> This algorithm is similar to that of Needleman-Wunsch except that the score of a particular sub-alignment, S (i,j), is at least 0 (7). This allows the local alignment, S (i,j), to re-start at any aligned pair.
Reference: [27] <author> Wilbur W.J. and Lipman David J. </author> <title> Rapid similarity searches of nucleic acid and protein data banks. </title> <booktitle> Proceedings of the National Academy of Sciences, </booktitle> <volume> 80 </volume> <pages> 726-730, </pages> <year> 1983. </year>
Reference-contexts: The complexity of the heuristic algorithms remains on the order of O (N x M), but the number of computations based on residue-residue comparisons is greatly reduced. The FASTA algorithm [11] is an improvement over the initial FASTP algorithm <ref> [27] </ref> [28]. It operates in four steps: (1) Exact matches of length one or two are identified, (2) Segments that contain identity matches are re-scored using a score matrix.
Reference: [28] <author> Lipman David J. and Pearson William R. </author> <title> Rapid and Sensitive Protein Similarity Searches. </title> <journal> Science, </journal> <volume> 227 </volume> <pages> 1435-1441, </pages> <year> 1985. </year>
Reference-contexts: The complexity of the heuristic algorithms remains on the order of O (N x M), but the number of computations based on residue-residue comparisons is greatly reduced. The FASTA algorithm [11] is an improvement over the initial FASTP algorithm [27] <ref> [28] </ref>. It operates in four steps: (1) Exact matches of length one or two are identified, (2) Segments that contain identity matches are re-scored using a score matrix.
Reference: [29] <author> Altschul Stephen F., Madden Thomas L., Scaeffer Alejandro A., Zhang Jinghui, Zhang Zheng, Miller Webb, and Lipman David J. Gapped BLAST and PSI-BLAST: </author> <title> a new generation of protein database search programs. </title> <journal> Nucleic Acids Research, </journal> <volume> 25(17) </volume> <pages> 3389-3402, </pages> <year> 1997. </year>
Reference-contexts: This improves search time, but is detrimental to the detection of similarity between distantly related proteins which are likely to contain insertions and deletions. Recently, the BLAST algorithm has been enhanced with the ability to produce gapped alignments <ref> [29] </ref>. 19 2.3 The BLASTP Algorithm This section provides a parameterised description of the BLASTP program and each of the three steps of the algorithm. <p> Again, this optimisation increases the heuristic character of the algorithm. Those cases where a single hit is extended into and HSP will be missed. However, these cases may be detected by lowering the threshold score for neighborhood words, T <ref> [29] </ref>, which essentially increases the probability of having two hits on the alignment. 78 5.2 Contributions of this Thesis This work makes three valuable contributions to the fields of bioinformatics and software engineering: (1) An optimised BLASTP algorithm (2) A parametrised description of the algorithm and (3) A case study in <p> This experiment was later extrapolated over the entire database, the results of which are shown in Figure 37. However, this thesis makes no claims of original discovery of this optimisation since it is implemented in the BLAST version 2.0 program <ref> [29] </ref>. This thesis provides a parameterised description of the BLASTP algorithm. Descriptions of the algorithm that exist in the literature provide only general textual and diagrammatic descriptions of each of the three steps of the algorithm from which a direct implementation is not possible.
Reference: [30] <institution> UNIX. prof. </institution> <note> Manual Page osf1-4.0B. </note>
Reference-contexts: Each sub-step is a potential focus for optimisation. using execution profilers and studying the source code to construct a program model that describes the sub-architecture of the program that accounts for a large proportion of the overall execution time. The profiler prof <ref> [30] </ref> was used to obtain a list of procedures and lines of code ordered according to execution time (1). This data indicated which parts of the program, if optimised, would give the largest speed-up. The prof data also provided a starting point for reading the source code (2). <p> The graph is sorted by the sum of the time for the procedure itself plus the time inherited from its descendants. This work uses the profilers prof <ref> [30] </ref> and gprof [33] [31] as reverse engineering tools to analyse the test search (subsection 3.2.1). The prof profiler with the -pixie [34] option provided a flat profile which gave a quick overview of the procedures used and showed which ones account for large fractions of the overall execution time.
Reference: [31] <author> Graham Susan L., Kessler Peter B., and McKusick Marshall K. </author> <title> gprof: a Call Graph Execution Profiler. </title> <booktitle> In Proceedings of the SIGPLAN '82 Symposium on Compiler Construction, </booktitle> <volume> volume 17, </volume> <pages> pages 120-126. </pages> <booktitle> SIGPLAN Notices, </booktitle> <month> June </month> <year> 1982. </year>
Reference-contexts: The model was expanded by linking already studied code to related code using the call trace provided by the gprof profiler <ref> [31] </ref> (8,9). 25 3.2 Methodology 3.2.1 Test Search A single test search is used as a standard. The search program is BLASTP, version 1.4 [32]; the default values for all parameters are used. <p> The graph is sorted by the sum of the time for the procedure itself plus the time inherited from its descendants. This work uses the profilers prof [30] and gprof [33] <ref> [31] </ref> as reverse engineering tools to analyse the test search (subsection 3.2.1). The prof profiler with the -pixie [34] option provided a flat profile which gave a quick overview of the procedures used and showed which ones account for large fractions of the overall execution time.
Reference: [32] <institution> National Center for Biotechnology Information. </institution> <note> BLAST Source Code Version 1.4. ftp://ncbi.nlm.nih.gov/blast/old1.4. </note>
Reference-contexts: The model was expanded by linking already studied code to related code using the call trace provided by the gprof profiler [31] (8,9). 25 3.2 Methodology 3.2.1 Test Search A single test search is used as a standard. The search program is BLASTP, version 1.4 <ref> [32] </ref>; the default values for all parameters are used. The database is the protein NRDB (non-redundant database) [21], a conglomerate of several protein sequence databases in which identical sequences are merged into one entry. The database contains 252,307 entries. <p> The value of current inc is added to current qoff to uniquely lo-calise that offset to a particular subject scan. This permits the re-use of the HitsDiag array, thus avoiding the time consuming re-initialisation of the array for each scan. This idea is borrowed from <ref> [32] </ref>. The scanning procedure, WordFinder, was augmented with a local variable current qoff which stores the query offset of the current word hit.
Reference: [33] <institution> UNIX. </institution> <note> gprof. Manual Page osf1-4.0B. </note>
Reference-contexts: The graph is sorted by the sum of the time for the procedure itself plus the time inherited from its descendants. This work uses the profilers prof [30] and gprof <ref> [33] </ref> [31] as reverse engineering tools to analyse the test search (subsection 3.2.1). The prof profiler with the -pixie [34] option provided a flat profile which gave a quick overview of the procedures used and showed which ones account for large fractions of the overall execution time.
Reference: [34] <institution> UNIX. pixie. </institution> <note> Manual Page osf1-4.0B. </note>
Reference-contexts: The graph is sorted by the sum of the time for the procedure itself plus the time inherited from its descendants. This work uses the profilers prof [30] and gprof [33] [31] as reverse engineering tools to analyse the test search (subsection 3.2.1). The prof profiler with the -pixie <ref> [34] </ref> option provided a flat profile which gave a quick overview of the procedures used and showed which ones account for large fractions of the overall execution time. The gprof profiler provided a dynamic call graph which was used to deduce the program's architecture; i.e. control flow and structures.
Reference: [35] <author> Rumbaugh James, Blaha Michael, Premerlane William, Eddy Frederick, and Lorenson William. </author> <title> Object-Oriented Modelling and Design. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: step of the algorithm and the event loop, which first fetches a database sequence then invokes the algorithm, were constructed with this approach. 27 3.2.3 Modelling of Program Architecture The sub-architectures reverse engineered using the process described in subsection 3.2.2 are modelled using elements of the Object Modelling Technique (OMT) <ref> [35] </ref> and the Unified Modelling Language (UML) [36]. These techniques provide established models and notations through which the relationships among a program's entities can be effectively communicated. Although BLASTP is a procedural program written in the C programming language, its design can be accurately described using these object-oriented models. <p> A reverse engineering approach is used to obtain the set of program sub-architectures that implement the algorithm. Class diagrams <ref> [35] </ref> are used to communicate the program's design. An overview of the architecture that was reverse engineered from the source code is given in Figure 9. <p> In addition, this work demonstrates the use of modelling techniques to describe the design of a reverse engineered program. 79 Appendix A Summary of Ob ject-Oriented Concepts and Notation A.1 OMT Concepts and Notation This work uses concepts and notation from both OMT <ref> [35] </ref> and UML [36]. Class diagrams are part of the object model. Classes group attributes and operations, coupling a part of a program's state with its functionality. Attributes are data that are contained within the class while operations are functions or transformations that may be applied to these data.
Reference: [36] <author> Rational Software Corporation. </author> <title> The Unified Modelling Language, Notation Guide. </title> <address> http://www.rational.com/uml/html/notation/. </address>
Reference-contexts: loop, which first fetches a database sequence then invokes the algorithm, were constructed with this approach. 27 3.2.3 Modelling of Program Architecture The sub-architectures reverse engineered using the process described in subsection 3.2.2 are modelled using elements of the Object Modelling Technique (OMT) [35] and the Unified Modelling Language (UML) <ref> [36] </ref>. These techniques provide established models and notations through which the relationships among a program's entities can be effectively communicated. Although BLASTP is a procedural program written in the C programming language, its design can be accurately described using these object-oriented models. <p> In addition, this work demonstrates the use of modelling techniques to describe the design of a reverse engineered program. 79 Appendix A Summary of Ob ject-Oriented Concepts and Notation A.1 OMT Concepts and Notation This work uses concepts and notation from both OMT [35] and UML <ref> [36] </ref>. Class diagrams are part of the object model. Classes group attributes and operations, coupling a part of a program's state with its functionality. Attributes are data that are contained within the class while operations are functions or transformations that may be applied to these data.
Reference: [37] <author> Kernighan Brian W. and Ritchie Dennis M. </author> <title> The C Programming Language. </title> <publisher> Prentice Hall Software Series, </publisher> <address> 2nd edition, </address> <year> 1991. </year>
Reference-contexts: For a discussion on which modelling concepts and notations are used in this work, consult appendix A. The representation of C programming constructs with object-oriented modelling elements is exemplified in Figure 7. The user-defined struct type of C or structure <ref> [37] </ref> [38] is modelled well as a class (Figure 7-A). Procedures that contain, within its parameter list, a reference to a structure are modelled as operations of the class that represents that structure. The members of the structure are modelled as the attributes of that class.
Reference: [38] <author> Darnell Peter A. and Margolis Philip E. </author> <title> C A Software Engineering Approach. </title> <publisher> Springer-Verlag, </publisher> <address> 2nd edition, </address> <year> 1991. </year>
Reference-contexts: For a discussion on which modelling concepts and notations are used in this work, consult appendix A. The representation of C programming constructs with object-oriented modelling elements is exemplified in Figure 7. The user-defined struct type of C or structure [37] <ref> [38] </ref> is modelled well as a class (Figure 7-A). Procedures that contain, within its parameter list, a reference to a structure are modelled as operations of the class that represents that structure. The members of the structure are modelled as the attributes of that class.
Reference: [39] <author> Gish Warren. </author> <title> DFA Library UNIX Manual Page BLAST Version 1.4, </title> <month> July </month> <year> 1992. </year>
Reference-contexts: An automata is a network of states and transitions. The program employs a Mealy machine implementation wherein output activity is linked to state transitions (accepting transitions), rather than in association with the states themselves (accepting states) as in a Moore machine <ref> [39] </ref> [40]. Each state is an array of pointers to states. Its size is N; the size of the residue symbol alphabet. Thus, each state contains a pointer to a next state for each symbol. A transition is taken by dereferencing a pointer.
Reference: [40] <author> Hopcroft J.E. and Ullman J.D. </author> <title> Introduction to Automata Theory , Languages, and Computation. </title> <publisher> Addison-Wesley, </publisher> <year> 1979. </year> <month> 89 </month>
Reference-contexts: An automata is a network of states and transitions. The program employs a Mealy machine implementation wherein output activity is linked to state transitions (accepting transitions), rather than in association with the states themselves (accepting states) as in a Moore machine [39] <ref> [40] </ref>. Each state is an array of pointers to states. Its size is N; the size of the residue symbol alphabet. Thus, each state contains a pointer to a next state for each symbol. A transition is taken by dereferencing a pointer.
References-found: 40

