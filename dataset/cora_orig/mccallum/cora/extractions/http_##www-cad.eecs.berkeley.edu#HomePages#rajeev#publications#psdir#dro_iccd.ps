URL: http://www-cad.eecs.berkeley.edu/HomePages/rajeev/publications/psdir/dro_iccd.ps
Refering-URL: http://www-cad.eecs.berkeley.edu/HomePages/rajeev/publications/publications.html
Root-URL: http://www.cs.berkeley.edu
Email: email :frajeev,wilsin,brayton,albertog@ic.eecs.berkeley.edu  
Title: Dynamic Reordering in a Breadth-First Manipulation Based BDD Package: Challenges and Solutions  
Author: Rajeev K. Ranjan Wilsin Gosti Robert K. Brayton Alberto Sangiovanni-Vincentelli 
Address: Berkeley  
Affiliation: Dept. of EECS, University of California at  
Abstract: The breadth-first manipulation technique has proven effective in dealing with very large sized BDDs. However, till now the lack of dynamic variable reordering has remained an obstacle in its acceptance. The goal of this work is to provide efficient techniques to address this issue. After identifying the problems with implementing variable swapping (the core operation in dynamic reordering) in breadth-first based packages, we propose techniques to handle the computational and memory overheads. We feel that combining dynamic reordering with the powerful manipulation algorithms of a breadth-first based scheme can significantly enhance the performance of BDD based algorithms. The efficiency of the proposed techniques is demonstrated on a range of examples. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. S. Brace, R. L. Rudell, and R. E. Bryant, </author> <title> "Efficient implementation of a BDD package," </title> <booktitle> in Proc. of the Design Automation Conf., </booktitle> <pages> pp. 40-45, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Breadth-first manipulation [4] techniques preserve the locality of reference and exploit memory hierar 1 In this paper by BDD, we mean Reduced Ordered Binary Decision Diagram. For various terminologies on theory and implementation of a BDD package refer to <ref> [1, 2] </ref>. chy in a computer system to efficiently manipulate very large BDDs that do not fit in the main memory.
Reference: [2] <author> R. Bryant, </author> <title> "Graph-based Algorithms for Boolean Function Manipulation," </title> <journal> IEEE Trans. Computers, </journal> <volume> vol. C-35, </volume> <pages> pp. 677-691, </pages> <month> Aug. </month> <year> 1986. </year>
Reference-contexts: Breadth-first manipulation [4] techniques preserve the locality of reference and exploit memory hierar 1 In this paper by BDD, we mean Reduced Ordered Binary Decision Diagram. For various terminologies on theory and implementation of a BDD package refer to <ref> [1, 2] </ref>. chy in a computer system to efficiently manipulate very large BDDs that do not fit in the main memory.
Reference: [3] <author> R. Rudell, </author> <title> "Dynamic Variable Ordering for Binary Decision Diagrams," </title> <booktitle> in Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pp. 42-47, </pages> <month> Nov. </month> <year> 1993. </year>
Reference-contexts: While for a given variable ordering, BDD's represent Boolean functions canonically, the ordering plays a significant role in determining the size of BDDs, which is crucial for their efficient manipulation. Recently, dynamic ordering <ref> [3] </ref> has come up as a popular technique to obtain optimal variable orderings. In fact, dynamic ordering is established as a critical component for any BDD package to be used for practical-sized problems. <p> Using Shannon cofactor expansion, (x i ; F 1 ; F 0 ) = (x i+1 ; (x i ; F 11 ; F 01 ); (x i ; F 10 ; F 00 ))(1) In <ref> [3] </ref>, Rudell proposed a scheme which forms the key idea for efficient variable swapping. The success of his technique lies in the ability to overwrite the contents of a node to maintain its functionality. This is illustrated in the Figure 1.
Reference: [4] <author> J. V. Sanghavi, R. K. Ranjan, R. K. Brayton, and A. Sangiovanni-Vincentelli, </author> <title> "High Performance BDD Package Based on Exploiting Memory Hierarchy," </title> <booktitle> in Proc. of the Design Automation Conf., </booktitle> <month> June </month> <year> 1996. </year>
Reference-contexts: Recently, dynamic ordering [3] has come up as a popular technique to obtain optimal variable orderings. In fact, dynamic ordering is established as a critical component for any BDD package to be used for practical-sized problems. Breadth-first manipulation <ref> [4] </ref> techniques preserve the locality of reference and exploit memory hierar 1 In this paper by BDD, we mean Reduced Ordered Binary Decision Diagram. <p> This breaks down the approach given in [6]. In addition, arbitrarily overwriting a node destroys their locality. Next we look at the breadth-first implementation in CAL <ref> [4] </ref>. In this approach, a node is represented by an fid, nodeg pair. Also, the node contains the id as well as the address of its cofactor nodes. This data structure avoids the need for cofactor fetching or for looking up any table to determine the cofactor indices. <p> However, in the current implementation we simply duplicate the final set of nodes into new memory locations, freeing the old space later on. This results in temporary memory overhead. 5 Experimental Results We implemented our reordering scheme into the CAL BDD package <ref> [4] </ref>. This package has been chosen for three main reasons: (i) in [4], it has been clearly shown to outperform other breadth-first based implementations, (ii) CAL is integrated with the synthesis tool SIS and verification tool VIS, making it easier to perform benchmarking, and (iii) as opposed to other implementations, CAL <p> This results in temporary memory overhead. 5 Experimental Results We implemented our reordering scheme into the CAL BDD package <ref> [4] </ref>. This package has been chosen for three main reasons: (i) in [4], it has been clearly shown to outperform other breadth-first based implementations, (ii) CAL is integrated with the synthesis tool SIS and verification tool VIS, making it easier to perform benchmarking, and (iii) as opposed to other implementations, CAL provides a comprehensive set of high performance BDD algorithms.
Reference: [5] <author> H. Ochi, K. Yasuoka, and S. Yajima, </author> <title> "Breadth-First Manipulation of Very Large Binary-Decision Diagrams," </title> <booktitle> in Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pp. 48-55, </pages> <month> Nov. </month> <year> 1993. </year>
Reference: [6] <author> P. Ashar and M. Cheong, </author> <title> "Efficient Breadth-First Manipulation of Binary Decision Diagrams," </title> <booktitle> in Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pp. 622-627, </pages> <month> Nov. </month> <year> 1994. </year>
Reference-contexts: The first implementation of breadth-first manipulation ([5]) used padding nodes to overcome the cofactor index determination problem. Their algorithm manipulated quasi-reduced BDDs and indices of cofactors were always one more than the indices of the corresponding nodes. As reported in <ref> [6] </ref>, this approach has significant memory and computational overheads. Moreover, an arbitrary overwriting of nodes during variable swapping would result in the loss of locality (nodes of an index would belong to the several different pages in the memory, sharing the pages with nodes of other indices). The approach in [6] <p> <ref> [6] </ref>, this approach has significant memory and computational overheads. Moreover, an arbitrary overwriting of nodes during variable swapping would result in the loss of locality (nodes of an index would belong to the several different pages in the memory, sharing the pages with nodes of other indices). The approach in [6] uses a table which maps the page address of a node to its index, i.e., each page address is uniquely associated to an index. This mapping breaks down if we arbitrarily overwrite the content of an address during variable swapping. <p> This breaks down the approach given in <ref> [6] </ref>. In addition, arbitrarily overwriting a node destroys their locality. Next we look at the breadth-first implementation in CAL [4]. In this approach, a node is represented by an fid, nodeg pair. Also, the node contains the id as well as the address of its cofactor nodes. <p> This avoids the nonlocal computation involved in updating the cofactors We delay the cofactor updating by overwriting the node 2 F 00 x i+1 x i x i x i F 1 1 F 0 x i+1 F 0 F 0 F 0 x i+1 x i+1 x i+1 al. <ref> [6] </ref> with a "forwarding address" to the new node at an appropriate location and with proper functionality. Since the original node contains a forwarded address we call it a forwarding node.
Reference: [7] <author> D. E. </author> <title> Long, "BDD Manipulation Library," </title> <month> June </month> <year> 1993. </year> <month> ftp://emc.cs.cmu.edu/pub/bdd/bddlib.tar.Z. </month>
Reference-contexts: For comparison purposes we have used CMU package developed 4 x i+2 x i+2 F x i F 0 F 00 F 0 x i F are created in swapping x i+1 x i+1 x i x i x i+2 5 by David Long <ref> [7] </ref> and CUDD package [8] developed at University of Colorado at Boulder. Both of these packages are publicly available and are being widely used in industry and academia. We have used the standard ISCAS and MCNC benchmark examples for our experiments.

References-found: 7

