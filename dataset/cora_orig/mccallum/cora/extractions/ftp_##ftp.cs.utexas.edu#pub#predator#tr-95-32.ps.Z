URL: ftp://ftp.cs.utexas.edu/pub/predator/tr-95-32.ps.Z
Refering-URL: http://www.cs.utexas.edu/users/schwartz/pub.htm
Root-URL: http://www.cs.utexas.edu
Title: Subjectivity and Software System Generators  
Author: Don Batory 
Address: Austin, Texas 78712  
Affiliation: Department of Computer Sciences The University of Texas  
Abstract: The tenet of subjectivity is that no single interface can adequately describe any object; interfaces to the same object will vary among different applications. Thus, objects with standardized interfaces seems too brittle a concept to meet the demands of a wide variety of applications. Yet, objects with standardized interfaces is a central idea in domain modeling. Domain models are the basis for generators that synthesize high-performance, domain-specific software systems with customized interfaces. In this paper, we reconcile this apparent contradiction by showing that objects (i.e., components) of generator libraries are not typical software modules; their interfaces (and bodies) actually mutate upon instantiation to a standard that is application-dependent.
Abstract-found: 1
Intro-found: 1
Reference: [Bac86] <author> M.J. Bach, </author> <title> The Design of the UNIX Operating System, </title> <publisher> Prentice Hall, </publisher> <year> 1986. </year>
Reference: [Bat92b] <author> D. Batory and S. OMalley, </author> <title> The Design and Implementation of Hierarchical Software Systems with Reusable Components, </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <month> October </month> <year> 1992. </year>
Reference-contexts: To guarantee exact match interfaces would require libraries to be of exponential size. That is, if all features are orthogonal, there would be O (2 k ) unique views. A growing community of researchers believes that domain-specific software generators hold the greatest potential for producing view-specific software economically <ref> [Bla91, Bat92b, Bax92, Gom94, Gra92, Gri94, Lei94, Nin94] </ref>. Two practical approaches are currently used in generators to produce view-specific software. <p> First, features can have widely-varying implementations. Thus, one can customize object implementations easier by selecting both features and their implementations together. Second, the order in which components are composed does make a difference in the resulting object implementation <ref> [Bat92b] </ref>. Thus, a greater variety of implementations can be generated. Third, factored libraries tend to scale better: it is easier to maintain large groups of features if they are implemented as separate components rather than as a single structured object that contains all possible feature combinations. <p> In this paper, we explore the fundamental relationship of subjectivity to generators with factored libraries. Specifically, we examine the role of subjectivity in the definition of standard interfaces that are used in the GenVoca model of software generation <ref> [Bat92b] </ref>. We show that typical module interfaces (i.e., ones that are cast-in-concrete and that do not change upon instantiation) are far too rigid to be practical; GenVoca components have interfaces that enlarge automatically upon instantiation and hence are subjective (i.e., application-dependent). <p> We begin with a brief review of GenVoca. 2 GenVoca GenVoca is a model of software construction that underlies generators for a variety of different domains (e.g., avionics, network protocols, file systems, database systems <ref> [Bat92b, Cog93, Hei93] </ref>). Among the tenets of GenVoca is that by standardizing the fundamental abstractions of a domain and their programming interfaces, it is possible to design and build plug-compatible, interoperable, and interchangeable building blocks called components. <p> It is this perspective that one should keep in mind when reviewing the following generator implementations. Genesis. Genesis was the first GenVoca generator; it demonstrated that customized database management systems (in excess of 50,000 lines of code) could be assembled from prefabricated components <ref> [Bat92b] </ref>. Genesis relied on a rather rigid (and in hindsight) inexible way of accommodating subjectivity; realm interfaces evolved as new components were written. <p> Automatic design rule checking was needed to validate component compositions [Bat95]. Avoca. Avoca/x-kernel demonstrated that highly layered communications protocols could be more efficient and more extensible than monolithic protocols <ref> [Hut91, Bat92b] </ref>. Avoca realm interfaces were rigid (i.e., cast-in-concrete) sets of operations. Microprotocols, the name given to Avoca components, implemented a fixed-set of core operations for transmitting messages and opening and closing sessions. However, there was one additional operation control (), whose function was much like the Unix ioctl ()[Bac86].
Reference: [Bat93] <author> D. Batory, V. Singhal, M. Sirkin, and J. Thomas, </author> <title> Scalable Software Libraries, </title> <booktitle> ACM SIGSOFT 1993. </booktitle>
Reference-contexts: When this approach can be applied, it works extremely well [McI68, Gom94, Coh95]. The second approach is to build a factored library, where library components implement individual and (largely) orthogonal features <ref> [Big94, Bat93] </ref>. Views of objects are generated by composing components that implement desired features. When there is a choice between a subsetting or factored approach, factoring has several advantages. First, features can have widely-varying implementations. Thus, one can customize object implementations easier by selecting both features and their implementations together. <p> One is scalability: a small number of components can define vast families of systems (i.e., distinct type equations) <ref> [Big94, Bat93] </ref>. Another advantage is that it is possible to reason about a software system in terms of its constituent components [Bat95]. 2.1 The Myth of Standardized Interfaces GenVoca components are composable because they export and import standardized interfaces.
Reference: [Bat94a] <author> D. Batory, J. Thomas, and M. Sirkin, </author> <title> Re-engineering a Complex Application Using a Scalable Data Structure Compiler, </title> <booktitle> ACM SIGSOFT 1994. </booktitle>
Reference: [Bat94b] <author> D. Batory, V. Singhal, J. Thomas, S. Dasari, B. Geraci, and M. Sirkin, </author> <title> The GenVoca Model of Software-System Generators, </title> <journal> IEEE Software, </journal> <month> September </month> <year> 1994. </year>
Reference-contexts: In this section, we propose a model of these mechanisms as extensions to P++, a prototype language that is being built at the University of Texas <ref> [Sin93, Bat94b] </ref>. P++ is a superset of C++ that is specifically designed to support the GenVoca model. Among its linguistic extensions are declarations for realms, components, and parameters.
Reference: [Bat95] <author> D. Batory and B.J. Geraci, </author> <title> Validating Component Compositions in Software System Generators, </title> <institution> Dept. Computer Sciences, TR-95-03, University of Texas at Austin, </institution> <year> 1995. </year>
Reference-contexts: One is scalability: a small number of components can define vast families of systems (i.e., distinct type equations) [Big94, Bat93]. Another advantage is that it is possible to reason about a software system in terms of its constituent components <ref> [Bat95] </ref>. 2.1 The Myth of Standardized Interfaces GenVoca components are composable because they export and import standardized interfaces. As we noted in Section 1, no single interface captures all views of an abstraction. <p> The constraints on using components in type equations i.e., their compatibility or incompatibility with other components is directly encoded as composition rules (a.k.a. design rules) in the generators domain model <ref> [Bat95] </ref>. However, recognizing composition constraints and adding these constraints to the domain model is the responsibility of domain analysts and component implementors. There is no tool support or automatic way of recognizing the compatibilities and incompatibilities of components; deep domain knowledge is required. <p> This meant that not all components of R were interchangeable and thus not all syntactically correct compositions of Genesis components were semantically correct. Automatic design rule checking was needed to validate component compositions <ref> [Bat95] </ref>. Avoca. Avoca/x-kernel demonstrated that highly layered communications protocols could be more efficient and more extensible than monolithic protocols [Hut91, Bat92b]. Avoca realm interfaces were rigid (i.e., cast-in-concrete) sets of operations. <p> This means that the size_of component cannot be composed with L to yield a valid type equation. Such a constraint can be expressed using design rules <ref> [Bat95] </ref>. Alternatively, size_of could be made compatible with L if it defines rewrites for all element insertion and deletion operations of L.
Reference: [Bax92] <author> I. Baxter, </author> <title> Design Maintenance Systems, </title> <journal> CACM, </journal> <month> April </month> <year> 1992, </year> <pages> 73-89. </pages>
Reference-contexts: To guarantee exact match interfaces would require libraries to be of exponential size. That is, if all features are orthogonal, there would be O (2 k ) unique views. A growing community of researchers believes that domain-specific software generators hold the greatest potential for producing view-specific software economically <ref> [Bla91, Bat92b, Bax92, Gom94, Gra92, Gri94, Lei94, Nin94] </ref>. Two practical approaches are currently used in generators to produce view-specific software.
Reference: [Bla91] <author> L. Blaine and A. Goldberg, </author> <title> DTRE - A Semi-Automatic Transformation System, in Constructing Programs from Specifications, </title> <publisher> Elsevier Science Publishers, </publisher> <year> 1991. </year>
Reference-contexts: To guarantee exact match interfaces would require libraries to be of exponential size. That is, if all features are orthogonal, there would be O (2 k ) unique views. A growing community of researchers believes that domain-specific software generators hold the greatest potential for producing view-specific software economically <ref> [Bla91, Bat92b, Bax92, Gom94, Gra92, Gri94, Lei94, Nin94] </ref>. Two practical approaches are currently used in generators to produce view-specific software.
Reference: [Big94] <author> T. Biggerstaff. </author> <title> The Library Scaling Problem and the Limits of Concrete Component Reuse, </title> <booktitle> IEEE International Conference on Software Reuse, </booktitle> <month> November </month> <year> 1994. </year>
Reference-contexts: When this approach can be applied, it works extremely well [McI68, Gom94, Coh95]. The second approach is to build a factored library, where library components implement individual and (largely) orthogonal features <ref> [Big94, Bat93] </ref>. Views of objects are generated by composing components that implement desired features. When there is a choice between a subsetting or factored approach, factoring has several advantages. First, features can have widely-varying implementations. Thus, one can customize object implementations easier by selecting both features and their implementations together. <p> One is scalability: a small number of components can define vast families of systems (i.e., distinct type equations) <ref> [Big94, Bat93] </ref>. Another advantage is that it is possible to reason about a software system in terms of its constituent components [Bat95]. 2.1 The Myth of Standardized Interfaces GenVoca components are composable because they export and import standardized interfaces.
Reference: [Cha94] <author> C. Chambers and G.T. Leavens, </author> <title> Typechecking and Modules for Multi-Methods, </title> <booktitle> OOPSLA 1994. </booktitle>
Reference-contexts: Understanding the run-time extensions needed by compilers and executables to support such extensions will be both important and challenging to the development and evolution of software system generators. Also, it is important that the ideas of subjectivity (and subjective interfaces) be formalized (e.g. <ref> [Cha94, Nen95] </ref>); formalization may offer greater clarity of the concepts identified in this paper and may simplify the design of future programming environments that support generators. Acknowledgments.
Reference: [Cog93] <author> L. Coglianese and R. Szymanski, </author> <title> DSSA-ADAGE: An Environment for Architecture-based Avionics Development, </title> <booktitle> Proc. </booktitle> <address> AGARD, </address> <year> 1993. </year>
Reference-contexts: We begin with a brief review of GenVoca. 2 GenVoca GenVoca is a model of software construction that underlies generators for a variety of different domains (e.g., avionics, network protocols, file systems, database systems <ref> [Bat92b, Cog93, Hei93] </ref>). Among the tenets of GenVoca is that by standardizing the fundamental abstractions of a domain and their programming interfaces, it is possible to design and build plug-compatible, interoperable, and interchangeable building blocks called components.
Reference: [Coh95] <author> S. Cohen, R. Krut, S. Peterson, and J. Withey, </author> <title> Models for Domains and Architectures: A Prescription for Systematic Software Reuse, </title> <booktitle> 10th AIAA Computing in Aerospace, </booktitle> <year> 1995. </year> <month> 16 </month>
Reference-contexts: A particular view is created by subsetting (also called SYSGEN [McI68]), i.e., choosing the features to retain and eliminating the operations (and code) of unneeded features. When this approach can be applied, it works extremely well <ref> [McI68, Gom94, Coh95] </ref>. The second approach is to build a factored library, where library components implement individual and (largely) orthogonal features [Big94, Bat93]. Views of objects are generated by composing components that implement desired features. When there is a choice between a subsetting or factored approach, factoring has several advantages.
Reference: [Elm89] <author> R. Elmasri and S.B. Navathe, </author> <title> Fundamentals of Database Systems, </title> <address> Benjamin/Cummings, </address> <year> 1989. </year>
Reference-contexts: Design integration is very similar to view integration of database schema designs. The goal is to produce a single conceptual relation by integrating different views/projections of that relation that are needed by different applications. A specific relational view should be derivable from the conceptual relation <ref> [Elm89] </ref>. Too-based integration deals with the integration of previously written software components using views. PIE used a view mechanism called layers [Gol81]. A layer is an object that provides a customized interface to another object. Layers can be composed to offer different views of objects.
Reference: [Gam94] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Patterns: Elements of Reusable Object Oriented Software, </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: Structural design patterns, such as adaptor and facade, also achieve the effects of presenting alternative interfaces or subsetting views of an object <ref> [Gam94] </ref>. Parameterized Programming. Goguen argued that views, parameterization, composition, and program transformations are fundamental to software reuse [Gog86].
Reference: [Gar95] <author> D. Garlan, R. Allen, J. Ockerbloom, </author> <title> Architectural Mismatch or Why Its Hard to Build Systems out of Existing Parts, </title> <booktitle> Proc. ICSE 1995, Seattle, </booktitle> <pages> 179-185. </pages>
Reference-contexts: The appropriate interface for an abstraction is application-dependent (or subjective). Successful and economical software development critically depends on reusing components that implement desired views. Garlan noted that one of the difficulties of off-the-shelf software reuse is that available components typically do not provide such views <ref> [Gar95] </ref>. To modify components often requires deep knowledge of their implementation; it can be a slow, ad hoc, time-consuming, and costly process. Furthermore, good performance of the resulting code is not guaranteed.
Reference: [Gog86] <author> J.A. Goguen, </author> <title> Reusing and Interconnecting Software Components, </title> <booktitle> Computer, </booktitle> <month> February </month> <year> 1986, </year> <pages> 16-28. </pages>
Reference-contexts: Structural design patterns, such as adaptor and facade, also achieve the effects of presenting alternative interfaces or subsetting views of an object [Gam94]. Parameterized Programming. Goguen argued that views, parameterization, composition, and program transformations are fundamental to software reuse <ref> [Gog86] </ref>. Goguens basic model of software construction relied on theories (which are interfaces), modules (which encapsulate an interface with an implementation), and views (a mapping between the types and operations of a theory to the types and operations of a module).
Reference: [Gol81] <author> P. Goldstein and D.G. Bobrow, </author> <title> An Experimental Description-Based Programming Environment: Four Reports, </title> <type> TR CSL-81-3, </type> <institution> Xerox Palo Alto Research Center, </institution> <month> March </month> <year> 1981. </year>
Reference-contexts: A specific relational view should be derivable from the conceptual relation [Elm89]. Too-based integration deals with the integration of previously written software components using views. PIE used a view mechanism called layers <ref> [Gol81] </ref>. A layer is an object that provides a customized interface to another object. Layers can be composed to offer different views of objects. Tool environments, such as OOTIS [Har92], help integrate separately-written tools that share data using views.
Reference: [Gom94] <author> H. Gomaa, L. Kerschberg, V. Sugumaran, C. Bosch, and I. Tavakoi, </author> <title> A Prototype Domain Modeling Environment for reusable Software Architectures, </title> <booktitle> IEEE International Conference on Software Reuse, </booktitle> <address> Rio de Janeiro, </address> <month> November </month> <year> 1994. </year>
Reference-contexts: To guarantee exact match interfaces would require libraries to be of exponential size. That is, if all features are orthogonal, there would be O (2 k ) unique views. A growing community of researchers believes that domain-specific software generators hold the greatest potential for producing view-specific software economically <ref> [Bla91, Bat92b, Bax92, Gom94, Gra92, Gri94, Lei94, Nin94] </ref>. Two practical approaches are currently used in generators to produce view-specific software. <p> A particular view is created by subsetting (also called SYSGEN [McI68]), i.e., choosing the features to retain and eliminating the operations (and code) of unneeded features. When this approach can be applied, it works extremely well <ref> [McI68, Gom94, Coh95] </ref>. The second approach is to build a factored library, where library components implement individual and (largely) orthogonal features [Big94, Bat93]. Views of objects are generated by composing components that implement desired features. When there is a choice between a subsetting or factored approach, factoring has several advantages.
Reference: [Gra92] <author> M. Graham and E. Mettala, </author> <title> The Domain-Specific Software Architecture Program, </title> <booktitle> Proceedings of DARPA Software Technology Conference, </booktitle> <year> 1992. </year> <note> Also, in Crosstalk: The Journal of Defense Software Engineering, </note> <month> October </month> <year> 1992. </year>
Reference-contexts: To guarantee exact match interfaces would require libraries to be of exponential size. That is, if all features are orthogonal, there would be O (2 k ) unique views. A growing community of researchers believes that domain-specific software generators hold the greatest potential for producing view-specific software economically <ref> [Bla91, Bat92b, Bax92, Gom94, Gra92, Gri94, Lei94, Nin94] </ref>. Two practical approaches are currently used in generators to produce view-specific software.
Reference: [Gri94] <author> M.L. Griss and K.D. Wentzel, </author> <title> Hybrid Domain-Specific Kits for a Flexible Software Factory, </title> <booktitle> Proceedings of SAC94, ACM, </booktitle> <month> March </month> <year> 1994. </year>
Reference-contexts: To guarantee exact match interfaces would require libraries to be of exponential size. That is, if all features are orthogonal, there would be O (2 k ) unique views. A growing community of researchers believes that domain-specific software generators hold the greatest potential for producing view-specific software economically <ref> [Bla91, Bat92b, Bax92, Gom94, Gra92, Gri94, Lei94, Nin94] </ref>. Two practical approaches are currently used in generators to produce view-specific software.
Reference: [Hai90] <author> B. Hailpern and H. Ossher, </author> <title> Extending Objects to Support Multiple Interfaces and Access Control, </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> November </month> <year> 1990. </year>
Reference-contexts: introduce layer-specific classes as well as layer-specific operators to a standardized interface. publication copies_sold textbook price (a) Extension S (b) X = P X S = S X P publication date publisher textbook price copies_sold publication title author textbook grade_level date publisher copies_sold price (c) PT X X 14 trolled <ref> [Hai90] </ref>. Structural design patterns, such as adaptor and facade, also achieve the effects of presenting alternative interfaces or subsetting views of an object [Gam94]. Parameterized Programming. Goguen argued that views, parameterization, composition, and program transformations are fundamental to software reuse [Gog86].
Reference: [Har92] <author> W. Harrison, M. Kavianpour, and H. Ossher, </author> <title> Integrating Coarse-grained and Fine-Grained Tool Integration, </title> <booktitle> Proc. 5th Workshop on Computer-Aided Software Engineering, </booktitle> <month> July </month> <year> 1992. </year>
Reference-contexts: Too-based integration deals with the integration of previously written software components using views. PIE used a view mechanism called layers [Gol81]. A layer is an object that provides a customized interface to another object. Layers can be composed to offer different views of objects. Tool environments, such as OOTIS <ref> [Har92] </ref>, help integrate separately-written tools that share data using views. Each view manipulates essentially the same set of objects, but deals with different subjective aspects. Another motivating reason for tool-based integration is that it simplifies programming abstractions (e.g., views emphasize relevant aspects and hide irrelevant details [Shi89]).
Reference: [Har93] <author> W. Harrison and H. Ossher, </author> <title> Subject-Oriented Programming (A Critique of Pure Objects), </title> <booktitle> OOPSLA 1993. </booktitle>
Reference-contexts: Because both encapsulate orthogonal features, their composition is commutative (i.e., P X S = S X P). The result of composing these extensions to the base lattice is shown in Figure 7c. An implementation of these ideas and a discussion of related work is given in <ref> [Oss92-95, Har93] </ref>. In Appendix II, we sketch a GenVoca model of extensions in terms of realms and components. Ossher and Harrison motivated extensions for non-reuse reasons [Har95]. First, they wanted to avoid the intergroup communication bottleneck that results from having centralized ownership of class definitions. <p> Subjectivity is a relatively new topic in object-oriented systems [Har94]. Consequently, the basic concepts and research issues have not fully crystallized. It is evident though that view integration is a basic technique for addressing subjectivity (i.e., abstractions having multiple interfaces). There are proposals for integrating application views automatically <ref> [Har93, Oss95] </ref>. However since view integration requires fairly deep domain knowledge, most approaches to date have dealt with manual (sometimes computer aided) integration. View integration arises in two different contexts. Design integration occurs during software design and prior to writing software components.
Reference: [Har94] <author> W. Harrison, H. Ossher, R.B. Smith, and D. Ungar, </author> <booktitle> Subjectivity in Object-Oriented Systems: Workshop Summary, Addendum to OOPSLA 1994, </booktitle> <pages> 131-136. </pages>
Reference-contexts: Subjectivity is a relatively new topic in object-oriented systems <ref> [Har94] </ref>. Consequently, the basic concepts and research issues have not fully crystallized. It is evident though that view integration is a basic technique for addressing subjectivity (i.e., abstractions having multiple interfaces). There are proposals for integrating application views automatically [Har93, Oss95].
Reference: [Har95] <author> W. Harrison, </author> <title> email correspondence, </title> <year> 1995. </year>
Reference-contexts: An implementation of these ideas and a discussion of related work is given in [Oss92-95, Har93]. In Appendix II, we sketch a GenVoca model of extensions in terms of realms and components. Ossher and Harrison motivated extensions for non-reuse reasons <ref> [Har95] </ref>. First, they wanted to avoid the intergroup communication bottleneck that results from having centralized ownership of class definitions. Moreover, they felt that extensions offered a way around the lack of prescient system architects that could envision all current and projected application uses of an object.
Reference: [Hei93] <author> J. Heidemann and G. Popek, </author> <title> File System Development with Stackable Layers, </title> <journal> ACM Transactions on Computer Systems, </journal> <month> March </month> <year> 1993. </year>
Reference-contexts: We begin with a brief review of GenVoca. 2 GenVoca GenVoca is a model of software construction that underlies generators for a variety of different domains (e.g., avionics, network protocols, file systems, database systems <ref> [Bat92b, Cog93, Hei93] </ref>). Among the tenets of GenVoca is that by standardizing the fundamental abstractions of a domain and their programming interfaces, it is possible to design and build plug-compatible, interoperable, and interchangeable building blocks called components. <p> Calling a control function requires polling each component of a type equation to test if it could process the function. Control functions were not called frequently enough in Avoca for their inefficiencies to be problematic. Ficus. Ficus builds customized file systems from a single realm of components <ref> [Hei93] </ref>. All Ficus layers support the same set of core operations plus any number of layer-specific operations. The reliance of Ficus on the Unix vnode facility encouraged a uniform treatment of core and layer-specific operations. It also 4.
Reference: [Hei95] <author> J. Heidemann, </author> <title> email correspondence, </title> <year> 1995. </year>
Reference: [Hut91] <author> N. Hutchinson and L. Peterson, </author> <title> The x-kernel: An Architecture for Implementing Network Protocols, </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> January </month> <year> 1991. </year>
Reference-contexts: Automatic design rule checking was needed to validate component compositions [Bat95]. Avoca. Avoca/x-kernel demonstrated that highly layered communications protocols could be more efficient and more extensible than monolithic protocols <ref> [Hut91, Bat92b] </ref>. Avoca realm interfaces were rigid (i.e., cast-in-concrete) sets of operations. Microprotocols, the name given to Avoca components, implemented a fixed-set of core operations for transmitting messages and opening and closing sessions. However, there was one additional operation control (), whose function was much like the Unix ioctl ()[Bac86].
Reference: [Joh88] <author> R.E. Johnson and B. Foote, </author> <title> Designing Reusable Classes, </title> <journal> Journal of Object-Oriented Programming, </journal> <month> June/July </month> <year> 1988. </year>
Reference-contexts: Coding function calls via switch statements and marshalling arguments are well-known to be obscure ways of programming <ref> [Joh88] </ref>. Moreover, there can be a considerable performance overhead in processing control operations. Calling a control function requires polling each component of a type equation to test if it could process the function. Control functions were not called frequently enough in Avoca for their inefficiencies to be problematic. Ficus.
Reference: [Kic91] <author> G. Kiczales, J. des Rivieres, and D.G. Bobrow, </author> <title> The Art of the Metaobject Protocol, </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: Type Equations. Components are composed in P++ via typedef declarations. Suppose the array and avl components implement the DS interface and do not export layer-specific operations. The following declarations (type equations) would generate systems that export the DS_size interface: 6. Note that CLOS offers before and after methods <ref> [Kic91] </ref> and Symbolics Lisp had whoppers and wrappers [Sym84] that are similar, but not identical, to the bypass methods described here. <p> Reective Languages. Reective languages give programmers access to the metadata objects and methods (or metaobject protocol) of the underlying compiler. This offers tremendous power for language extensibility, e.g., one can define a version of the language which supports CLOS inheritance, and another that supports FLAVORS inheritance <ref> [Kic91] </ref>. Components with subjective interfaces can be realized in reec-tive languages because it is possible to query an object for the set of operations that it supports and to be able to modify, at run-time, its operations and methods.
Reference: [Lei94] <author> J.C.S. do Prado Leite, M. SantAnna, and F.G. de Freitas, Draco-PUC: </author> <title> A Technology Assembly for Domain-Oriented Software Development, </title> <booktitle> IEEE International Conference on Software Reuse, </booktitle> <address> Rio de Janeiro, </address> <month> November </month> <year> 1994. </year>
Reference-contexts: To guarantee exact match interfaces would require libraries to be of exponential size. That is, if all features are orthogonal, there would be O (2 k ) unique views. A growing community of researchers believes that domain-specific software generators hold the greatest potential for producing view-specific software economically <ref> [Bla91, Bat92b, Bax92, Gom94, Gra92, Gri94, Lei94, Nin94] </ref>. Two practical approaches are currently used in generators to produce view-specific software.
Reference: [McI68] <author> D. McIlroy, </author> <title> Mass Produced Software Components, </title> <booktitle> Software Engineering: Report on a Conference by the Nato Science Committee, </booktitle> <month> Oct </month> <year> 1968, </year> <editor> P. Naur and B. Randell, eds. </editor> <month> 138-150. </month>
Reference-contexts: A particular view is created by subsetting (also called SYSGEN <ref> [McI68] </ref>), i.e., choosing the features to retain and eliminating the operations (and code) of unneeded features. When this approach can be applied, it works extremely well [McI68, Gom94, Coh95]. The second approach is to build a factored library, where library components implement individual and (largely) orthogonal features [Big94, Bat93]. <p> A particular view is created by subsetting (also called SYSGEN [McI68]), i.e., choosing the features to retain and eliminating the operations (and code) of unneeded features. When this approach can be applied, it works extremely well <ref> [McI68, Gom94, Coh95] </ref>. The second approach is to build a factored library, where library components implement individual and (largely) orthogonal features [Big94, Bat93]. Views of objects are generated by composing components that implement desired features. When there is a choice between a subsetting or factored approach, factoring has several advantages.
Reference: [Mic95] <author> Microsoft, </author> <title> The Component Object Model Specification, </title> <year> 1995. </year>
Reference-contexts: Client objects access server objects through predefined interfaces; thus if the interface of a server enlarges, clients are insulated from these changes. This is accomplished by binding communicating objects at run-time using the QueryInterface mechanism to establish type compatibility <ref> [Mic95] </ref>. Reective Languages. Reective languages give programmers access to the metadata objects and methods (or metaobject protocol) of the underlying compiler. This offers tremendous power for language extensibility, e.g., one can define a version of the language which supports CLOS inheritance, and another that supports FLAVORS inheritance [Kic91].
Reference: [Nen95] <author> M. Nenninger and F. Nickl, </author> <title> Implementing Data Structures by Composition of Reusable Components: </title>
Reference-contexts: Understanding the run-time extensions needed by compilers and executables to support such extensions will be both important and challenging to the development and evolution of software system generators. Also, it is important that the ideas of subjectivity (and subjective interfaces) be formalized (e.g. <ref> [Cha94, Nen95] </ref>); formalization may offer greater clarity of the concepts identified in this paper and may simplify the design of future programming environments that support generators. Acknowledgments.
References-found: 34

