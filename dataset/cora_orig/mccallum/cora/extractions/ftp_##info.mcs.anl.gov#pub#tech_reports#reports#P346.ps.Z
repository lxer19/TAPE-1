URL: ftp://info.mcs.anl.gov/pub/tech_reports/reports/P346.ps.Z
Refering-URL: http://www.mcs.anl.gov/publications/abstracts/abstracts93.htm
Root-URL: http://www.mcs.anl.gov
Email: mani@vlsi.cs.caltech.edu  itf@mcs.anl.gov  
Title: A Deterministic Notation for Cooperating Processes  
Author: K. Mani Chandy Ian T. Foster 
Date: October 1993.  
Address: Argonne, Ill.,  Pasadena, California 91125  9700 South Cass Avenue Argonne, Illinois 60439  
Affiliation: Mathematics and Computer Science Division, Argonne National Laboratory,  California Institute of Technology, 256-80  Mathematics and Computer Science Division Argonne National Laboratory  
Note: Preprint MCS-P346-0193,  
Abstract: This paper proposes extensions of sequential programming languages for parallel programming that have the following features: 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Bagrodia, R., and S. Mathur, </author> <title> "Efficient Implementation of High-Level Parallel Programs," </title> <booktitle> Proc. </booktitle> <address> ASPLOS-IV, </address> <month> April, </month> <year> 1991. </year>
Reference-contexts: Nondeterministic constructs can be included, if required. A comparison of Fortran M with data-parallel languages <ref> [22, 12, 1] </ref> and high-level languages [4] highlights some of the weaknesses and strengths of Fortran M. Fortran M employs processes explicitly, and uses explicit exchange of tokens between processes. Care must be taken by the Fortran M programmer to avoid starvation: processes waiting for tokens that never arrive.
Reference: [2] <author> Bagrodia, R. and W. Liao, </author> <title> "Maisie User Manual," </title> <type> Tech. Report, </type> <institution> Computer Science, UCLA, Los Angeles, Calif., </institution> <year> 1990. </year>
Reference-contexts: Subtle race conditions can occur in processes communicating using message libraries, and replay requires recording every resolution of a potential race condition in a computation. A major difference between Fortran M and actor-based languages <ref> [19, 2] </ref> is the Fortran M focus on separating deterministic and nondeterministic constructs. An implementation of Fortran M (with channels but without shared variables) is available from anonymous ftp server info.mcs.anl.gov (directory /pub/fortran-m) at Argonne National Laboratories.
Reference: [3] <author> Boyle, J., R. Butler, T. Disz, B. Glickfeld, E. Lusk, R. Overbeek, J. Patterson, and R. Stevens, </author> <title> Portable Programs for Parallel Processors, </title> <publisher> Holt, Rinehart and Winston, </publisher> <year> 1987. </year>
Reference-contexts: Since Fortran M compiles to Fortran, powerful Fortran optimizing compilers available on most platforms can be used to advantage. Furthermore, the central ideas of this paper can be used with other sequential imperative languages. A comparison of Fortran M with parallel programs using message-passing libraries such as P4 <ref> [3] </ref> or PVM [21] is also instructive. A focus of Fortran M is the development of reliable programs by (i) separating deterministic and nondeterministic components (and allowing simpler reasoning and debugging for the deterministic parts) and (ii) type-checking messages (since channels are typed).
Reference: [4] <author> Cann, D. C., J. T. Feo, and T. M. DeBoni, </author> <title> "Sisal 1,2: High Performance Applicative Computing," </title> <booktitle> Proc. Symp. Parallel and Distributed Processing, </booktitle> <publisher> IEEE CS Press, Los Alamitos, </publisher> <address> Calif., </address> <year> 1990, </year> <pages> pp. 612-616. </pages>
Reference-contexts: The theory of such languages is based, in part, on the Church-Rosser theorem [18]. A great deal of work has also been carried out on capabilities [8, 15, 14], message-passing using channels [13], shared-memory programming models on distributed-memory machines [16], and single-assignment variables <ref> [4, 11, 5] </ref>. <p> A reader token r0 is duplicated to obtain a duplicate r1 as follows: DUPLICATE (r0,r1) The proof that these constructs are deterministic is straightforward. We do not give examples of single-assignment programs. There are several languages that use single-assignment and execute on distributed-memory machines such as Sisal <ref> [4] </ref>, Strand [11], and PCN [5]. 7 Nondeterminism A programmer may want to allow potential nondeterminism to improve efficiency or to make programs simpler. For instance, a programmer may want to design a process p to 16 accept messages from either process q or process r, in arbitrary order. <p> Nondeterministic constructs can be included, if required. A comparison of Fortran M with data-parallel languages [22, 12, 1] and high-level languages <ref> [4] </ref> highlights some of the weaknesses and strengths of Fortran M. Fortran M employs processes explicitly, and uses explicit exchange of tokens between processes. Care must be taken by the Fortran M programmer to avoid starvation: processes waiting for tokens that never arrive. <p> Some of this work could be handled automatically by a compiler using data-flow technology. Data-parallel languages [22, 12] and applicative languages <ref> [4] </ref> do not require the programmer to deal with processes, messages or tokens. Applications such as multidisciplinary design require task-parallel coupling of data-parallel programs. Fortran M can be used to provide such coupling. Data-parallel communications on arrays of channels provide a simple mechanism for coupling multiple data-parallel programs.
Reference: [5] <author> Chandy, K. M. and S. Taylor, </author> <title> An Introduction to Parallel Programming, </title> <editor> Jones and Bartlett, </editor> <year> 1991. </year>
Reference-contexts: The theory of such languages is based, in part, on the Church-Rosser theorem [18]. A great deal of work has also been carried out on capabilities [8, 15, 14], message-passing using channels [13], shared-memory programming models on distributed-memory machines [16], and single-assignment variables <ref> [4, 11, 5] </ref>. <p> We do not give examples of single-assignment programs. There are several languages that use single-assignment and execute on distributed-memory machines such as Sisal [4], Strand [11], and PCN <ref> [5] </ref>. 7 Nondeterminism A programmer may want to allow potential nondeterminism to improve efficiency or to make programs simpler. For instance, a programmer may want to design a process p to 16 accept messages from either process q or process r, in arbitrary order.
Reference: [6] <author> Church, A. and J. B. Rosser, </author> <title> Some Properties of Conversion, </title> <journal> Trans. American Math. Soc., </journal> <volume> 39, </volume> <year> 1936, </year> <pages> pp. 472-482. </pages>
Reference-contexts: Dept. of Energy, under DOE Contract W-31-109-Eng-38 1 derived from the Church-Rosser theorem about systems that obey the diamond property <ref> [6, 18] </ref> and from the concept of capabilities in operating systems [8, 7]. <p> earlier work into a simple extension of Fortran 77 to allow developers of parallel scientific applications to benefit from the earlier work while using languages and tools with which they are familiar. 2 The Central Idea First, we review the central idea of the diamond property and the Church-Rosser theorem <ref> [6, 18] </ref>, and later use the idea to develop constructs for a parallel extension of Fortran 77. 2.1 Theory Let G be a labeled directed graph, where each edge of the graph has a single label, and for each vertex v and each label l there is at most one edge <p> Proof: A proof, see <ref> [6, 18] </ref>, is as follows. Let P be a finite path from v that ends in a terminal state w, and let R be any maximal path from v. Let P have n edges.
Reference: [7] <author> Cohen, E. and D. Jefferson, </author> <title> "Protection in the Hydra Operating System," </title> <booktitle> Proc. 5th Symp. Operating Systems Principles, ACM, </booktitle> <year> 1975, </year> <pages> pp. 141-150. </pages>
Reference-contexts: Dept. of Energy, under DOE Contract W-31-109-Eng-38 1 derived from the Church-Rosser theorem about systems that obey the diamond property [6, 18] and from the concept of capabilities in operating systems <ref> [8, 7] </ref>.
Reference: [8] <author> Dennis, J. B., and E. C. Van Horn, </author> <title> "Programming Semantics for Multiprogrammed Computations," </title> <journal> Comm. ACM, </journal> <volume> 9, </volume> <month> Mar. </month> <year> 1993, </year> <pages> pp. 143-155. </pages>
Reference-contexts: Dept. of Energy, under DOE Contract W-31-109-Eng-38 1 derived from the Church-Rosser theorem about systems that obey the diamond property [6, 18] and from the concept of capabilities in operating systems <ref> [8, 7] </ref>. <p> See the descriptions of Id, Haskell, Sisal and Scheme in [9], for example. The theory of such languages is based, in part, on the Church-Rosser theorem [18]. A great deal of work has also been carried out on capabilities <ref> [8, 15, 14] </ref>, message-passing using channels [13], shared-memory programming models on distributed-memory machines [16], and single-assignment variables [4, 11, 5].
Reference: [9] <author> Feo, J. T. ed., </author> <title> A Comparative Study of Parallel Programming Languages: The Salishan Problems, </title> <booktitle> Special Topics in Supercomputing, </booktitle> <volume> Vol. 6, </volume> <publisher> Elsevier Science Publishers B.V., </publisher> <address> The Netherlands. </address>
Reference-contexts: A great deal of work has been carried out on functional (equational and applicative) languages that guarantee that the output of a program is a function of its input. See the descriptions of Id, Haskell, Sisal and Scheme in <ref> [9] </ref>, for example. The theory of such languages is based, in part, on the Church-Rosser theorem [18]. A great deal of work has also been carried out on capabilities [8, 15, 14], message-passing using channels [13], shared-memory programming models on distributed-memory machines [16], and single-assignment variables [4, 11, 5].
Reference: [10] <author> Foster, I. and K. M. Chandy, </author> <title> "Fortran M: A Language for Modular Parallel Programming," </title> <type> Preprint MCS-P327-0992, </type> <institution> Mathematics and Computer Science Division, Argonne National Laboratory, Argonne Ill. </institution> <month> 60439, </month> <year> 1992. </year> <month> 19 </month>
Reference-contexts: Next, we describe the communication mechanisms in detail in the context of Fortran M <ref> [10] </ref>.
Reference: [11] <author> Foster, I. and S. Taylor, Strand: </author> <title> New Concepts in Parallel Programming, </title> <publisher> Prentice-Hall, </publisher> <year> 1989. </year>
Reference-contexts: The theory of such languages is based, in part, on the Church-Rosser theorem [18]. A great deal of work has also been carried out on capabilities [8, 15, 14], message-passing using channels [13], shared-memory programming models on distributed-memory machines [16], and single-assignment variables <ref> [4, 11, 5] </ref>. <p> A reader token r0 is duplicated to obtain a duplicate r1 as follows: DUPLICATE (r0,r1) The proof that these constructs are deterministic is straightforward. We do not give examples of single-assignment programs. There are several languages that use single-assignment and execute on distributed-memory machines such as Sisal [4], Strand <ref> [11] </ref>, and PCN [5]. 7 Nondeterminism A programmer may want to allow potential nondeterminism to improve efficiency or to make programs simpler. For instance, a programmer may want to design a process p to 16 accept messages from either process q or process r, in arbitrary order.
Reference: [12] <author> Fox, G., S. Hiranandani, K. Kennedy, C. Koelbel, U. Kremer, C. Tseng, M. Wu, </author> <title> "Fortran D Language Specification," </title> <type> Technical Report TR90-141, </type> <institution> Computer Science, Rice Univ., Houston, Tex., </institution> <year> 1990. </year>
Reference-contexts: Nondeterministic constructs can be included, if required. A comparison of Fortran M with data-parallel languages <ref> [22, 12, 1] </ref> and high-level languages [4] highlights some of the weaknesses and strengths of Fortran M. Fortran M employs processes explicitly, and uses explicit exchange of tokens between processes. Care must be taken by the Fortran M programmer to avoid starvation: processes waiting for tokens that never arrive. <p> Some of this work could be handled automatically by a compiler using data-flow technology. Data-parallel languages <ref> [22, 12] </ref> and applicative languages [4] do not require the programmer to deal with processes, messages or tokens. Applications such as multidisciplinary design require task-parallel coupling of data-parallel programs. Fortran M can be used to provide such coupling.
Reference: [13] <author> Hoare, C. A. R., </author> <title> Communicating Sequential Processes, </title> <journal> CACM, </journal> <volume> 21(8), </volume> <year> 1969, </year> <pages> pp. 666-677. </pages>
Reference-contexts: See the descriptions of Id, Haskell, Sisal and Scheme in [9], for example. The theory of such languages is based, in part, on the Church-Rosser theorem [18]. A great deal of work has also been carried out on capabilities [8, 15, 14], message-passing using channels <ref> [13] </ref>, shared-memory programming models on distributed-memory machines [16], and single-assignment variables [4, 11, 5].
Reference: [14] <author> Jones, A. K., </author> <title> "Protection in Programmed Systems," </title> <type> Ph.D. Thesis, </type> <institution> Computer Science, Carnegie-Mellon University, </institution> <year> 1973. </year>
Reference-contexts: See the descriptions of Id, Haskell, Sisal and Scheme in [9], for example. The theory of such languages is based, in part, on the Church-Rosser theorem [18]. A great deal of work has also been carried out on capabilities <ref> [8, 15, 14] </ref>, message-passing using channels [13], shared-memory programming models on distributed-memory machines [16], and single-assignment variables [4, 11, 5].
Reference: [15] <author> Lampson, B. W., </author> <title> "Protection," </title> <booktitle> Proc. 5th Annual Princeton Conf. on Information Science Systems, </booktitle> <year> 1971, </year> <pages> pp. 437-443. </pages>
Reference-contexts: See the descriptions of Id, Haskell, Sisal and Scheme in [9], for example. The theory of such languages is based, in part, on the Church-Rosser theorem [18]. A great deal of work has also been carried out on capabilities <ref> [8, 15, 14] </ref>, message-passing using channels [13], shared-memory programming models on distributed-memory machines [16], and single-assignment variables [4, 11, 5].
Reference: [16] <author> Li, K., and P. Hudak, </author> <title> "Memory Coherence in Shared Virtual Memory Systems," </title> <journal> ACM Trans. Comp. Systems, </journal> <volume> 7(4), </volume> <month> Nov. </month> <year> 1989, </year> <pages> pp. 321-359. </pages>
Reference-contexts: The theory of such languages is based, in part, on the Church-Rosser theorem [18]. A great deal of work has also been carried out on capabilities [8, 15, 14], message-passing using channels [13], shared-memory programming models on distributed-memory machines <ref> [16] </ref>, and single-assignment variables [4, 11, 5].
Reference: [17] <author> Martin, A. J., </author> <title> "The Probe: An Addition to Communication Primitives," </title> <journal> Information Processing Letters, </journal> <volume> 20, </volume> <month> April </month> <year> 1985, </year> <pages> pp. 125-130. </pages>
Reference-contexts: PROBE The command: PROBE (PORT = ip, EMPTY = v) where ip is an input port, and v is a boolean variable, sets v to false only if there is a message in the channel corresponding to input port ip <ref> [17] </ref>. Variable v can be set to true by the command, even if there is a message in the channel (because the message is still in transit and has not yet arrived at the input port ip).
Reference: [18] <author> McLennan, B. J., </author> <title> Functional Programming: Practice and Theory, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1990. </year>
Reference-contexts: Dept. of Energy, under DOE Contract W-31-109-Eng-38 1 derived from the Church-Rosser theorem about systems that obey the diamond property <ref> [6, 18] </ref> and from the concept of capabilities in operating systems [8, 7]. <p> See the descriptions of Id, Haskell, Sisal and Scheme in [9], for example. The theory of such languages is based, in part, on the Church-Rosser theorem <ref> [18] </ref>. A great deal of work has also been carried out on capabilities [8, 15, 14], message-passing using channels [13], shared-memory programming models on distributed-memory machines [16], and single-assignment variables [4, 11, 5]. <p> earlier work into a simple extension of Fortran 77 to allow developers of parallel scientific applications to benefit from the earlier work while using languages and tools with which they are familiar. 2 The Central Idea First, we review the central idea of the diamond property and the Church-Rosser theorem <ref> [6, 18] </ref>, and later use the idea to develop constructs for a parallel extension of Fortran 77. 2.1 Theory Let G be a labeled directed graph, where each edge of the graph has a single label, and for each vertex v and each label l there is at most one edge <p> Proof: A proof, see <ref> [6, 18] </ref>, is as follows. Let P be a finite path from v that ends in a terminal state w, and let R be any maximal path from v. Let P have n edges.
Reference: [19] <author> Seitz, C. L., </author> <title> "Multicomputers," in Developments in Concurrency and Communication, </title> <editor> ed. C. A. R. Hoare, </editor> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1991. </year>
Reference-contexts: Subtle race conditions can occur in processes communicating using message libraries, and replay requires recording every resolution of a potential race condition in a computation. A major difference between Fortran M and actor-based languages <ref> [19, 2] </ref> is the Fortran M focus on separating deterministic and nondeterministic constructs. An implementation of Fortran M (with channels but without shared variables) is available from anonymous ftp server info.mcs.anl.gov (directory /pub/fortran-m) at Argonne National Laboratories.
Reference: [20] <author> Silberschatz, A., J. Peterson and P. Galvin, </author> <title> Operating Systems Concepts, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1991. </year>
Reference-contexts: Likewise, a process can receive a message from a channel if and only if it holds the receiver token for the channel. Thus the sender and receiver tokens are capabilities that confer certain rights to the holder of the tokens <ref> [20] </ref>. The send command is nonblocking, and the receive command is blocking. The state of a channel is a queue of messages. Sending a message m on a channel appends m to the tail of the queue of messages in the channel.
Reference: [21] <author> Sunderam, V., </author> <title> "PVM: A Framework for Parallel Distributed Computing," </title> <journal> Concurrency Practice and Experience, </journal> <volume> 2, </volume> <year> 1990, </year> <pages> pp. 315-339. </pages>
Reference-contexts: Furthermore, the central ideas of this paper can be used with other sequential imperative languages. A comparison of Fortran M with parallel programs using message-passing libraries such as P4 [3] or PVM <ref> [21] </ref> is also instructive. A focus of Fortran M is the development of reliable programs by (i) separating deterministic and nondeterministic components (and allowing simpler reasoning and debugging for the deterministic parts) and (ii) type-checking messages (since channels are typed).
Reference: [22] <author> Thinking Machines Corporation, </author> <title> CM Fortran Reference Manual, Thinking Machines, </title> <address> Cambridge, Mass., </address> <year> 1989. </year> <month> 20 </month>
Reference-contexts: Nondeterministic constructs can be included, if required. A comparison of Fortran M with data-parallel languages <ref> [22, 12, 1] </ref> and high-level languages [4] highlights some of the weaknesses and strengths of Fortran M. Fortran M employs processes explicitly, and uses explicit exchange of tokens between processes. Care must be taken by the Fortran M programmer to avoid starvation: processes waiting for tokens that never arrive. <p> Some of this work could be handled automatically by a compiler using data-flow technology. Data-parallel languages <ref> [22, 12] </ref> and applicative languages [4] do not require the programmer to deal with processes, messages or tokens. Applications such as multidisciplinary design require task-parallel coupling of data-parallel programs. Fortran M can be used to provide such coupling.
References-found: 22

