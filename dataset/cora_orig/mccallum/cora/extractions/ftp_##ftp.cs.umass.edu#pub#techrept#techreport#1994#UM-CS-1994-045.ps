URL: ftp://ftp.cs.umass.edu/pub/techrept/techreport/1994/UM-CS-1994-045.ps
Refering-URL: http://laser.cs.umass.edu/abstracts/94-045.html
Root-URL: 
Title: Data Flow Analysis for Verifying Properties of Concurrent Programs  
Author: Matthew B. Dwyer Lori A. Clarke 
Address: Amherst, MA 01003  
Affiliation: Department of Computer Science University of Massachusetts  
Abstract: In this paper we present an approach, based on data flow analysis, that can provide cost-effective analysis of concurrent programs with respect to explicitly stated correctness properties. Using this approach, a developer specifies a property of a concurrent program as a pattern of selected program events and asks the analysis to verify that all or no program executions satisfy the given property. We have developed a family of polynomial-time, conservative data flow analysis algorithms that support reasoning about these questions. To overcome the traditional inaccuracies of static analysis, we have also developed a range of techniques for improving the accuracy of the analysis results. One strength of our approach is the flexibility allowed in choosing and combining these techniques so as to increase accuracy without making analysis time impractical. We have implemented a prototype toolset that automates the analysis for programs with explicit tasking and rendezvous style communication. We present preliminary experimental results using this toolset. 
Abstract-found: 1
Intro-found: 1
Reference: [ABC + 91] <author> G.S. Avrunin, U.A. Buy, J.C. Corbett, L.K. Dillon, and J.C. Wileden. </author> <title> Automated analysis of concurrent systems with the constrained expression toolset. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(11) </volume> <pages> 1204-1222, </pages> <month> November </month> <year> 1991. </year>
Reference-contexts: In contrast, sufficient conditions of this form can be used to reason about whether some program execution satisfies a property. Researchers have used linear programming techniques to encode necessary <ref> [ABC + 91] </ref> and sufficient [MSS89] conditions. Although, in the worst case, the cost of the linear programming technique is exponential, it has been successfully applied to a number of examples and allows for practical analysis of very large versions of those examples. <p> The state propagation analysis described in Section 3.3 is a polynomial-time, conservative test to determine language containment for finite state automata. A number of formalisms have been developed to express properties of programs, such as temporal logics [Pnu85] and regular expression based formalisms <ref> [ABC + 91, Kur85, OO90] </ref>. Unfortunately, reasoning using the most general of these formalisms can be inef 2 ficient. <p> The algorithms that are not automated were applied manually for the experiments discussed in this section. Empirical Results We consider three examples: the simple example in Figure 2, the controller task from a readers/writers problem <ref> [ABC + 91] </ref>, and a simple protocol [Cor92]. We measure the cost of executing the state propagation algorithm, described in Section 3.3, in terms of the number of TFG edges taken off of the worklist and the number of calls to ffi, the CPA transition function.
Reference: [BCM + 90] <author> J.R. Burch, E.M. Clarke, K.L. McMillan, D.L. Dill, and L.J. Hwang. </author> <title> Symbolic model checking : 10 20 states and beyond. </title> <booktitle> In Proceedings of the Fifth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 428-439, </pages> <year> 1990. </year>
Reference-contexts: To address the need for scaling reachability analysis to large programs, researchers have investigated three techniques: reducing the state space based on the property being analyzed [DBDS93, GW91, Val90], building and analyzing the state space compositionally [CPS93, YY91], and using a symbolic representation of the state space <ref> [BCM + 90] </ref>. Although, in general, the costs of these techniques exhibit exponential growth, each has been successful in verifying properties of example programs. An alternate analysis approach is to reason using necessary or sufficient conditions about a specified property.
Reference: [CES86] <author> E.M. Clarke, </author> <title> E.A. Emerson, and A.P. Sistla. Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: Data flow analysis of concurrent programs requires 1 The question do all executions satisfy the property? is the dual of is it false that no executions satisfy the negation of the property?. that inter-task communication be represented. Early model checking approaches <ref> [CES86] </ref> are essentially data flow analyses that use the program data and control state reachability graph as a flow graph; performance suffered from the impractical size of this graph, however.
Reference: [CK93] <author> S.C. Cheung and J. Kramer. </author> <title> Tractable flow analysis for anomaly detection in distributed programs. </title> <booktitle> In Proceedings of the 4th European Software Engineering Conference, </booktitle> <pages> pages 283-300, </pages> <address> Germany, </address> <year> 1993. </year> <note> published in Lecture Notes in Computer Science 717, Springer-Verlag. </note>
Reference-contexts: More typically, data flow analyses either represent potential communication with edges in the flow graph [CKS90, GS93, MR91] or label nodes representing communication statements so that they can be matched during analysis <ref> [CK93, Mer92] </ref>. The former approach is appropriate if we view the flow graph as a repository of information about possible program executions that is refined over time by a variety of analyses [MR93], although the resulting flow graphs are invariably irreducible.
Reference: [CKS90] <author> D. Callahan, K. Kennedy, and J. Subhlok. </author> <title> Analysis of event synchronization in a parallel programming tool. </title> <booktitle> In Proceedings of the Second ACM SIGPLAN Symposion on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 21-30, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: Early model checking approaches [CES86] are essentially data flow analyses that use the program data and control state reachability graph as a flow graph; performance suffered from the impractical size of this graph, however. More typically, data flow analyses either represent potential communication with edges in the flow graph <ref> [CKS90, GS93, MR91] </ref> or label nodes representing communication statements so that they can be matched during analysis [CK93, Mer92].
Reference: [Cor92] <author> J.C. Corbett. </author> <title> Verifying general safety and liveness properties with integer programming. </title> <booktitle> In Computer Aided Verification, 4th International Workshop, </booktitle> <pages> pages 357-369, </pages> <address> Canada, </address> <month> July </month> <year> 1992. </year> <note> published in Lecture Notes in Computer Science 663, Springer-Verlag. </note>
Reference-contexts: The idea of intervals that require and exclude events is derived from Corbett's !-starless expressions <ref> [Cor92] </ref>. Data races, mutual exclusion, general forms of invariance, response and precedence properties have been specified with this form of QRE. As an example consider an event based formulation of a response property. <p> The algorithms that are not automated were applied manually for the experiments discussed in this section. Empirical Results We consider three examples: the simple example in Figure 2, the controller task from a readers/writers problem [ABC + 91], and a simple protocol <ref> [Cor92] </ref>. We measure the cost of executing the state propagation algorithm, described in Section 3.3, in terms of the number of TFG edges taken off of the worklist and the number of calls to ffi, the CPA transition function. Figure 8 summarizes data for the experiments discussed below 4 .
Reference: [CPS93] <author> R. Cleaveland, J. Parrow, and B. Steffen. </author> <title> The concurrency workbench: A semantics based tool for the verification of concurrent systems. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 36-72, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: To address the need for scaling reachability analysis to large programs, researchers have investigated three techniques: reducing the state space based on the property being analyzed [DBDS93, GW91, Val90], building and analyzing the state space compositionally <ref> [CPS93, YY91] </ref>, and using a symbolic representation of the state space [BCM + 90]. Although, in general, the costs of these techniques exhibit exponential growth, each has been successful in verifying properties of example programs.
Reference: [DBDS93] <author> S. Duri, U. Buy, R. Devarapalli, </author> <title> and S.M. Shatz. Using state space methods for deadlock analysis in Ada tasking. </title> <booktitle> In Proceedings of the 1993 International Symposium on Software Testing and Analysis, </booktitle> <pages> pages 51-60, </pages> <month> July </month> <year> 1993. </year> <note> published in ACM Software Engineering Notes, 18(3). </note>
Reference-contexts: To address the need for scaling reachability analysis to large programs, researchers have investigated three techniques: reducing the state space based on the property being analyzed <ref> [DBDS93, GW91, Val90] </ref>, building and analyzing the state space compositionally [CPS93, YY91], and using a symbolic representation of the state space [BCM + 90]. Although, in general, the costs of these techniques exhibit exponential growth, each has been successful in verifying properties of example programs.
Reference: [GS93] <author> D. Grunwald and H. Srinivasan. </author> <title> Efficient computation of precedence information in parallel programs. </title> <booktitle> In Sixth Annual Workshop on Languages and Compilers for Parallel Computing, </booktitle> <address> Portland, OR, </address> <month> aug </month> <year> 1993. </year>
Reference-contexts: Early model checking approaches [CES86] are essentially data flow analyses that use the program data and control state reachability graph as a flow graph; performance suffered from the impractical size of this graph, however. More typically, data flow analyses either represent potential communication with edges in the flow graph <ref> [CKS90, GS93, MR91] </ref> or label nodes representing communication statements so that they can be matched during analysis [CK93, Mer92].
Reference: [GW91] <author> P. Godefroid and P. Wolper. </author> <title> Using partial orders for the efficient verification of deadlock freedom and safety properties. </title> <booktitle> In Proceedings of the Third Workshop on Computer Aided Verification, </booktitle> <pages> pages 417-428, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: To address the need for scaling reachability analysis to large programs, researchers have investigated three techniques: reducing the state space based on the property being analyzed <ref> [DBDS93, GW91, Val90] </ref>, building and analyzing the state space compositionally [CPS93, YY91], and using a symbolic representation of the state space [BCM + 90]. Although, in general, the costs of these techniques exhibit exponential growth, each has been successful in verifying properties of example programs. <p> We note that our analysis is applicable to sequential programs without modification. A number of analyses represent programs and properties of interest as formal automata <ref> [GW91, Kur85, OO90] </ref>. At a high level, the set of executable program paths are represented as strings accepted by a program automaton and the set of program paths that satisfy the property are strings accepted by a property automaton.
Reference: [Hec77] <author> M.S. Hecht. </author> <title> Flow Analysis of Computer Programs. The Computer Science Library Programming Language Series. </title> <publisher> North-Holland, </publisher> <year> 1977. </year>
Reference-contexts: Our analysis collapses event traces that lead to the same PA state into a single value and thus greatly reduces the amount of work required to analyze QREs. This can be implemented by a data flow analysis algorithm. We use a standard iterative worklist algorithm <ref> [Hec77] </ref> with modifications to enforce conditions related to the semantics of TFG edges. The main data structures are a worklist of TFG edges and States, the set of PA states for each TFG node. Figure 5 gives a high level description of the algorithm.
Reference: [Hol88] <author> G.J. Holzmann. </author> <title> An improved reachability analysis technique. </title> <journal> Software: Practice and Experience, </journal> <volume> 18(2) </volume> <pages> 137-161, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: State reachability approaches have been successfully applied to analyzing concurrent programs <ref> [Hol88, SMBT90, YTL + 92] </ref>. Complexity results for reachabil-ity analysis [Tay83] imply that, in general, the size of the program state space and consequently the cost of analysis increases exponentially with program size.
Reference: [Kur85] <author> R.P. Kurshan. </author> <title> Modeling concurrent processes. </title> <booktitle> In Computers and Communications, volume 31 of Proceedings of Symposia in Applied Mathematics, </booktitle> <pages> pages 45-57, </pages> <year> 1985. </year> <month> 12 </month>
Reference-contexts: We note that our analysis is applicable to sequential programs without modification. A number of analyses represent programs and properties of interest as formal automata <ref> [GW91, Kur85, OO90] </ref>. At a high level, the set of executable program paths are represented as strings accepted by a program automaton and the set of program paths that satisfy the property are strings accepted by a property automaton. <p> The state propagation analysis described in Section 3.3 is a polynomial-time, conservative test to determine language containment for finite state automata. A number of formalisms have been developed to express properties of programs, such as temporal logics [Pnu85] and regular expression based formalisms <ref> [ABC + 91, Kur85, OO90] </ref>. Unfortunately, reasoning using the most general of these formalisms can be inef 2 ficient.
Reference: [Mer92] <author> N. Mercouroff. </author> <title> An algorithm for analyzing communicating processes. </title> <booktitle> In Proceedings of Mathematical Foundation of Programming Semantics '91, </booktitle> <address> Pittsburgh, PA, </address> <month> March </month> <year> 1992. </year> <note> published in Lecture Notes in Computer Science 598, Springer-Verlag. </note>
Reference-contexts: More typically, data flow analyses either represent potential communication with edges in the flow graph [CKS90, GS93, MR91] or label nodes representing communication statements so that they can be matched during analysis <ref> [CK93, Mer92] </ref>. The former approach is appropriate if we view the flow graph as a repository of information about possible program executions that is refined over time by a variety of analyses [MR93], although the resulting flow graphs are invariably irreducible.
Reference: [MR90] <author> T.J. Marlowe and B.G. Ryder. </author> <title> Properties of data flow frameworks. </title> <journal> Acta Informatica, </journal> <volume> 28 </volume> <pages> 121-163, </pages> <year> 1990. </year>
Reference-contexts: Conceptually, data flow analysis involves a fix point computation over a flow graph of a pre-defined relation, which encodes the analysis question. In theory the class of relations that can be computed is very large; polynomial-time algorithms exist for a smaller but very useful class of relations <ref> [MR90] </ref>. For data flow analysis of sequential programs, the flow graph is often reducible and specialized algorithms can be applied that improve the execution time of analysis.
Reference: [MR91] <author> S.P. Masticola and B.G. Ryder. </author> <title> A model of Ada programs for static deadlock detection in polynomial time. </title> <booktitle> In Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 91-102, </pages> <month> May </month> <year> 1991. </year> <journal> published in ACM SIGPLAN Notices, </journal> <volume> 26(12). </volume>
Reference-contexts: Early model checking approaches [CES86] are essentially data flow analyses that use the program data and control state reachability graph as a flow graph; performance suffered from the impractical size of this graph, however. More typically, data flow analyses either represent potential communication with edges in the flow graph <ref> [CKS90, GS93, MR91] </ref> or label nodes representing communication statements so that they can be matched during analysis [CK93, Mer92]. <p> Our approach also employs a flow graph that represents communication explicitly. Masticola and Ryder <ref> [MR91] </ref> describe an analysis approach for checking deadlock freedom in Ada tasking programs that uses data flow analyses [MR93] to improve the accuracy of the analysis results. These data flow analyses are in the spirit of the refinements described in Section 4.1.
Reference: [MR93] <author> S.P. Masticola and B.G. Ryder. </author> <title> Non-concurrency analysis. </title> <booktitle> In Proceedings of the 4th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 129-138, </pages> <month> May </month> <year> 1993. </year> <journal> published in ACM SIGPLAN Notices, </journal> <volume> 28(7). </volume>
Reference-contexts: The former approach is appropriate if we view the flow graph as a repository of information about possible program executions that is refined over time by a variety of analyses <ref> [MR93] </ref>, although the resulting flow graphs are invariably irreducible. Our approach also employs a flow graph that represents communication explicitly. Masticola and Ryder [MR91] describe an analysis approach for checking deadlock freedom in Ada tasking programs that uses data flow analyses [MR93] to improve the accuracy of the analysis results. <p> is refined over time by a variety of analyses <ref> [MR93] </ref>, although the resulting flow graphs are invariably irreducible. Our approach also employs a flow graph that represents communication explicitly. Masticola and Ryder [MR91] describe an analysis approach for checking deadlock freedom in Ada tasking programs that uses data flow analyses [MR93] to improve the accuracy of the analysis results. These data flow analyses are in the spirit of the refinements described in Section 4.1. <p> We will see in Section 5 that this refinement can have a great effect on the size of the TFG and the cost and accuracy of state propagation analysis. We note that communication interval refinement can be viewed as a generalization of Masticola and Ryder's critical section analysis <ref> [MR93] </ref>. from Figure 4. The rows are presented in the order that they are taken off of the worklist in line 4 of the algorithm. Note that the computation of the current source States value is dependent on the edge kind.
Reference: [MSS89] <author> T. Murata, B. Schenker, </author> <title> and S.M. Shatz. Detection of Ada static deadlocks using Petri net invariants. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 15(3) </volume> <pages> 314-326, </pages> <month> March </month> <year> 1989. </year>
Reference-contexts: In contrast, sufficient conditions of this form can be used to reason about whether some program execution satisfies a property. Researchers have used linear programming techniques to encode necessary [ABC + 91] and sufficient <ref> [MSS89] </ref> conditions. Although, in the worst case, the cost of the linear programming technique is exponential, it has been successfully applied to a number of examples and allows for practical analysis of very large versions of those examples.
Reference: [OO90] <author> K.M. Olender and L.J. Osterweil. Ce-cil: </author> <title> A sequencing constraint language for automatic static analysis generation. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(3) </volume> <pages> 268-280, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: We note that our analysis is applicable to sequential programs without modification. A number of analyses represent programs and properties of interest as formal automata <ref> [GW91, Kur85, OO90] </ref>. At a high level, the set of executable program paths are represented as strings accepted by a program automaton and the set of program paths that satisfy the property are strings accepted by a property automaton. <p> The state propagation analysis described in Section 3.3 is a polynomial-time, conservative test to determine language containment for finite state automata. A number of formalisms have been developed to express properties of programs, such as temporal logics [Pnu85] and regular expression based formalisms <ref> [ABC + 91, Kur85, OO90] </ref>. Unfortunately, reasoning using the most general of these formalisms can be inef 2 ficient. <p> That is, b and b will now be treated as b in our example. 3.2 Property Representation To specify properties, we use a part of the Ce-cil formalism <ref> [OO90] </ref> called quantified regular expressions. QREs have three components: a property alphabet property , a quantifier Q, and a regular expression R. Syntactically, QREs look like f property gQR, where property , Q 2 f8; 9g, and R is a regular expression over property .
Reference: [OO92] <author> K.M. Olender and L.J. Osterweil. </author> <title> Interpro-cedural static analysis of sequencing constraints. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 1(1) </volume> <pages> 21-52, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: Olender and Osterweil <ref> [OO92] </ref> developed an analysis for sequential programs, based on necessary conditions, that uses a simple version of the state propagation algorithm described in Section 3.3.
Reference: [Pnu85] <author> A. Pnueli. </author> <title> Applications of temporal logic to the specification and verification of reactive systems: a survey of curent trends. </title> <booktitle> In Current Trends in Concurrency, </booktitle> <volume> volume 224, </volume> <pages> pages 510-584, </pages> <year> 1985. </year> <note> published in Lecture Notes in Computer Science 224, Springer-Verlag. </note>
Reference-contexts: The state propagation analysis described in Section 3.3 is a polynomial-time, conservative test to determine language containment for finite state automata. A number of formalisms have been developed to express properties of programs, such as temporal logics <ref> [Pnu85] </ref> and regular expression based formalisms [ABC + 91, Kur85, OO90]. Unfortunately, reasoning using the most general of these formalisms can be inef 2 ficient.
Reference: [SMBT90] <author> S.M. Shatz, K. Mai, C. Black, and S. Tu. </author> <title> Design and implementation of a Petri net based toolkit for Ada tasking analysis. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(4) </volume> <pages> 424-441, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: State reachability approaches have been successfully applied to analyzing concurrent programs <ref> [Hol88, SMBT90, YTL + 92] </ref>. Complexity results for reachabil-ity analysis [Tay83] imply that, in general, the size of the program state space and consequently the cost of analysis increases exponentially with program size.
Reference: [Tay83] <author> R.N. Taylor. </author> <title> Complexity of analyzing the synchronization structure of concurrent programs. </title> <journal> Acta Informatica, </journal> <volume> 19 </volume> <pages> 57-84, </pages> <year> 1983. </year>
Reference-contexts: State reachability approaches have been successfully applied to analyzing concurrent programs [Hol88, SMBT90, YTL + 92]. Complexity results for reachabil-ity analysis <ref> [Tay83] </ref> imply that, in general, the size of the program state space and consequently the cost of analysis increases exponentially with program size.
Reference: [Val90] <author> A. Valmari. </author> <title> A stubborn attack on state explosion. </title> <booktitle> In Computer Aided Verification '90, volume 3 of DIMACS Series in Discrete Mathematics and Theoretical Computer Science, </booktitle> <pages> pages 25-41, </pages> <address> Providence, RI, 1990. </address> <publisher> American Mathematical Society. </publisher>
Reference-contexts: To address the need for scaling reachability analysis to large programs, researchers have investigated three techniques: reducing the state space based on the property being analyzed <ref> [DBDS93, GW91, Val90] </ref>, building and analyzing the state space compositionally [CPS93, YY91], and using a symbolic representation of the state space [BCM + 90]. Although, in general, the costs of these techniques exhibit exponential growth, each has been successful in verifying properties of example programs.
Reference: [YTL + 92] <author> M. Young, R.N. Taylor, D.L. Levine, K. Forester, and D. Brodbeck. </author> <title> A concur-rency analysis tool suite: Rationale, design, and preliminary experience. </title> <type> SERC Technical Report TR-128-P, </type> <institution> Purdue University, </institution> <month> October </month> <year> 1992. </year>
Reference-contexts: State reachability approaches have been successfully applied to analyzing concurrent programs <ref> [Hol88, SMBT90, YTL + 92] </ref>. Complexity results for reachabil-ity analysis [Tay83] imply that, in general, the size of the program state space and consequently the cost of analysis increases exponentially with program size.
Reference: [YY91] <author> W.J. Yeh and M. Young. </author> <title> Compositional reachability analysis using process algebra. </title> <booktitle> In Proceedings of the ACM SIGSOFT Symposium on Testing, Analysis and Verification, </booktitle> <pages> pages 49-59, </pages> <address> Victoria, Canada, Octo-ber 1991. </address> <publisher> ACM Press. </publisher>
Reference-contexts: To address the need for scaling reachability analysis to large programs, researchers have investigated three techniques: reducing the state space based on the property being analyzed [DBDS93, GW91, Val90], building and analyzing the state space compositionally <ref> [CPS93, YY91] </ref>, and using a symbolic representation of the state space [BCM + 90]. Although, in general, the costs of these techniques exhibit exponential growth, each has been successful in verifying properties of example programs.
References-found: 26

