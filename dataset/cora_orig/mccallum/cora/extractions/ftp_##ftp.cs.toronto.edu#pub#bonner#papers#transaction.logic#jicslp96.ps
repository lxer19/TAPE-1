URL: ftp://ftp.cs.toronto.edu/pub/bonner/papers/transaction.logic/jicslp96.ps
Refering-URL: http://www.cs.toronto.edu/DB/people/bonner/papers.html
Root-URL: 
Email: bonner@db.toronto.edu  kifer@cs.sunysb.edu  
Title: Concurrency and Communication in Transaction Logic  
Author: Anthony J. Bonner Michael Kifer 
Web: http://db.toronto.edu:8020/transaction-logic.html  
Note: Appears in Proceedings of the Joint International Conference and Symposium on Logic Programming (JICSLP), September 2-6 1996 Bonn, Germany, pages 142-156. MIT Press. This and related papers and software are available at the following web page:  Work supported in part by an Operating Grant from the Natural Sciences and Engineering Research Council of Canada. Supported in part by the NSF Grant IRI-9404629.  
Address: Toronto, Ontario M5S 1A4, Canada  NY 11794-4400, U.S.A.  
Affiliation: Department of Computer Science University of Toronto  Department of Computer Science SUNY at Stony Brook Stony Brook,  
Abstract: In previous work, we developed Transaction Logic (or T R), which deals with state changes in deductive databases. T R provides a logical framework in which elementary database updates and queries can be combined into complex database transactions. T R accounts not only for the updates themselves, but also for important related problems, such as the order of update operations, non-determinism, and transaction failure and rollback. In the present paper, we propose Concurrent Transaction Logic (or CT R), which extends Transaction Logic with connectives for modeling the concurrent execution of complex processes. Concurrent processes in CT R execute in an interleaved fashion and can communicate and synchronize themselves. Like classical logic, CT R has a "Horn" fragment that has both a procedural and a declarative semantics, in which users can program and execute database transactions. CT R is thus a deductive database language that integrates concurrency, communication, and updates. All this is accomplished in a completely logical framework, including a natural model theory and a proof theory. Moreover, this framework is flexible enough to accommodate many different semantics for updates and deductive databases. For instance, not only can updates insert and delete tuples, they can also insert and delete null values, rules, or arbitrary logical formulas. Likewise, not only can databases have a classical semantics, they can also have the well-founded semantics, the stable-model semantics, etc. Finally, the proof theory for CT R has an efficient SLD-style proof procedure. As in the sequential version of the logic, this proof procedure not only finds proofs, it also executes concurrent transactions, finds their execution schedules, and updates the database. A main result is that the proof theory is sound and complete for the model theory. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J.-M. Andreoli and R. Pareschi. </author> <title> Linear objects: Logical processes with built-in inheritance. </title> <journal> New Generation Computing, </journal> <volume> 9(4) </volume> <pages> 445-473, </pages> <year> 1991. </year>
Reference-contexts: Also, the programming paradigm that might arise from such an encoding seems to imitate the behavior of 15 -calculus, which is quite different from the programming style of CT R, which draws on deductive databases and logic programming. Linear Objects is another concurrent formalism based on Linear Logic <ref> [1] </ref>. Processes are represented via atomic formulas and their execution corresponds to branches in the proof tree. The semantics is provided via a mapping into Linear Logic, although, strictly speaking, this does not yet provide a model-theoretic account of concurrency.
Reference: [2] <author> P.A. Bernstein, V. Hadzilacos, and N. Goodman. </author> <title> Concurrency Control and Recovery in Databases. </title> <publisher> Addison Wesley, </publisher> <year> 1987. </year>
Reference-contexts: The oracles come with a set of database states, upon which they operate. In practice, we expect that each database state will be a set of data items, as in the theory of transaction management <ref> [2] </ref>. Intuitively, a data item can be any kind of persistent object, such as a tuple, a disk page, an email queue, or a logical formula. Formally, however, a database state has no structure, and our only access to it is through the two oracles. Both oracles are mappings.
Reference: [3] <author> H.A. Blair and V.S. Subrahmanian. </author> <title> Paraconsistent logic programming. </title> <journal> Theoretical Computer Science, </journal> <volume> 68 </volume> <pages> 135-154, </pages> <year> 1989. </year>
Reference-contexts: CT R is not yet-another-logic unrelated and isolated from other extensions. It is an idea that is orthogonal to several other recent proposals, such as F-logic [17] (structural object-orientation), HiLog [12] (higher-order logic programming), and Annotated Logic <ref> [3, 18, 19] </ref> (reasoning with uncertainty), and it can be easily integrated with them to endow these static formalisms with the ability to capture database dynamics in a clean, logical fashion (cf., e.g., [16]). The communication paradigm within CT R is inspired by the -calculus [26, 27].
Reference: [4] <author> A. Bonner, A. Shrufi, and S. Rozen. LabFlow-1: </author> <title> a database benchmark for high-throughput workflow management. </title> <booktitle> In Intl. Conference on Extending Database Technology, number 1057 in Lecture Notes in Computer Science, </booktitle> <pages> pages 463-478, </pages> <address> Avignon, France, March 25-29 1996. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: In database applications, SQL statements are the basic building blocks. In scientific and engineering programs, basic operations include Fourier transforms, matrix inversion, least-squares fitting, and operations on DNA sequences [14, 20]. In workflow management systems, elementary operations can include any number of application programs and legacy systems <ref> [4] </ref>. In all cases, the elementary operations are building blocks from which larger programs and software systems are built. Although elementary operations vary dramatically, the logic for combining them does not. In fact, the same control features arise over-and-over again.
Reference: [5] <author> A.J. Bonner. </author> <title> Hypothetical Datalog: Complexity and expressibility. </title> <journal> Theoretical Computer Science, </journal> <volume> 76 </volume> <pages> 3-51, </pages> <year> 1990. </year>
Reference-contexts: The version developed in [29] is very different from CT R. It is modeled on the kind of concurrency found in alternating Turing machines, which does not allow for communication between concurrent processes. A deductive-database analogue of this version of CDL is Hypothetical Datalog <ref> [5] </ref>, in which hypothetical databases represent the states of the various (non-communicating) concurrent processes in an alternating computation. The version of CDL developed in [28] does allow for communication, but only after adding considerable complexity to the semantics.
Reference: [6] <author> A.J. Bonner and M. Kifer. </author> <title> Transaction logic programming. </title> <booktitle> In Intl. Conference on Logic Programming, </booktitle> <pages> pages 257-282, </pages> <address> Budapest, Hungary, June 1993. </address> <publisher> MIT Press. </publisher>
Reference-contexts: Unfortunately, updates are not accounted for by the classical Horn semantics of deductive databases. To fill this theoretical gap, we developed Transaction Logic (or T R), an extension of first-order classical logic that provides a clean, logical account for state changes in databases and logic programs <ref> [8, 6, 9] </ref>. Like classical logic, T R has a "Horn" fragment that has both a procedural and a declarative semantics, in which users can program and execute database transactions. <p> for a message and consuming it is done atomically, preventing other processes from interposing their actions between the test channel (Ch; M sg) and the update channel:del (Ch; M sg). 6 3 Model Theory The semantics of the sequential Transaction Logic is based on sequences of database states, called paths <ref> [9, 8, 6] </ref>. Concurrent Transaction Logic extends this idea to sequences of paths, called multi-paths, or m-paths. Multi-paths provide the basis for a logical semantics of concurrent conjunction. <p> For example, the transaction = a.ins b.ins c.ins takes the database from an initial state, D, through the intermediate states D + fag and D + fa; bg, to the final state D + fa; b; cg. In sequential Transaction Logic <ref> [9, 6] </ref>, a finite sequence of states is called a path, and transactions are true on paths. For example, transaction is true on the path hfg fag fa; bg fa; b; cgi, in which the initial state is the empty database. <p> Intuitively, a formula that is true on an m-path represents an action that takes place along the m-path. Multi-path structures generalize the path structures of sequential Transaction Logic. Many subtle points about path structures apply equally well to multi-path structures, and the reader is referred to <ref> [9, 8, 6] </ref> for a thorough discussion. The main novelties of m-path structures are the m-paths themselves, the interleaving operation, and reduction, which account for concurrent and atomic processes. <p> of the transaction p j q in which atoms are inserted into the empty database in the order c; e; f; d. 2 5 Model theoretically, "( )" is a transaction that is true on every m-path of the form hDi, i:e:, on any m-path corresponding to a single database <ref> [9, 6] </ref>. 12 long Sequent Inf. <p> Since we are interested in the execution of a particular transaction, we introduce the more specialized notion of executional deduction, which|without sacrificing completeness|defines a narrower range of deductions. The notion of executional deduction needed here is exactly the same as that developed for sequential Transaction Logic in <ref> [9, 6] </ref>. It also leads naturally to a proof-theoretic notion of execution path. It remains only to show that executional deduction in concurrent Transaction Logic is sound and complete for the model theory of Section 3. This is established by the following theorem.
Reference: [7] <author> A.J. Bonner and M. Kifer. </author> <title> Applications of transaction logic to knowledge representation. </title> <booktitle> In Proceedings of the International Conference on Temporal Logic, number 827 in Lecture Notes in Artificial Inteligence, </booktitle> <pages> pages 67-81, </pages> <address> Bonn, Germany, July 1994. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: We also say that hfg fag fa; bg fa; b; cgi is an execution path of . Execution paths allow us to model a wide range of dynamic constraints <ref> [9, 7, 11] </ref>. To model concurrent processes, we generalize the notion of path to multi-path, or m-path. An m-path records the execution history of a process. Intuitively, it represents periods of continuous execution, separated by periods of suspended execution (during which other processes may execute).
Reference: [8] <author> A.J. Bonner and M. Kifer. </author> <title> An overview of transaction logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 133 </volume> <pages> 205-265, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: Unfortunately, updates are not accounted for by the classical Horn semantics of deductive databases. To fill this theoretical gap, we developed Transaction Logic (or T R), an extension of first-order classical logic that provides a clean, logical account for state changes in databases and logic programs <ref> [8, 6, 9] </ref>. Like classical logic, T R has a "Horn" fragment that has both a procedural and a declarative semantics, in which users can program and execute database transactions. <p> for a message and consuming it is done atomically, preventing other processes from interposing their actions between the test channel (Ch; M sg) and the update channel:del (Ch; M sg). 6 3 Model Theory The semantics of the sequential Transaction Logic is based on sequences of database states, called paths <ref> [9, 8, 6] </ref>. Concurrent Transaction Logic extends this idea to sequences of paths, called multi-paths, or m-paths. Multi-paths provide the basis for a logical semantics of concurrent conjunction. <p> Intuitively, a formula that is true on an m-path represents an action that takes place along the m-path. Multi-path structures generalize the path structures of sequential Transaction Logic. Many subtle points about path structures apply equally well to multi-path structures, and the reader is referred to <ref> [9, 8, 6] </ref> for a thorough discussion. The main novelties of m-path structures are the m-paths themselves, the interleaving operation, and reduction, which account for concurrent and atomic processes.
Reference: [9] <author> A.J. Bonner and M. Kifer. </author> <title> Transaction logic programming (or a logic of declarative and procedural knowledge). </title> <type> Technical Report CSRI-323, </type> <institution> University of Toronto, </institution> <month> November </month> <year> 1995. </year> <note> http:// www.cs.toronto.edu/~bonner/transaction-logic.html. </note>
Reference-contexts: Unfortunately, updates are not accounted for by the classical Horn semantics of deductive databases. To fill this theoretical gap, we developed Transaction Logic (or T R), an extension of first-order classical logic that provides a clean, logical account for state changes in databases and logic programs <ref> [8, 6, 9] </ref>. Like classical logic, T R has a "Horn" fragment that has both a procedural and a declarative semantics, in which users can program and execute database transactions. <p> Unfortunately, classical logic is stateless. One way to get around this problem is to represent states as terms, as in the situation calculus [21, 31]. However, this approach has not taken roots in logic programming for many reasons, including the complexity of dealing with the frame problem <ref> [9] </ref>. In Prolog, efficient techniques have been developed where states are represented as lists or terms, which do not require frame axioms. However, these techniques rely heavily on Prolog's control strategy, cuts, or on other non-logical features. <p> As in classical logic, we introduce convenient abbreviations for complex formulas. For instance, is an abbreviation for _ : . Likewise, _ is an abbreviation for :(: ^ : ), and 9 is an abbreviation for :8:. Other useful abbreviations are developed in <ref> [9] </ref>. <p> Likewise, p.del (x) 2 O t (D 1 ; D 2 ) iff D 2 = D 1 fp (x)g. SQL-style bulk updates can also be defined by the transition oracle <ref> [9] </ref>, as can primitives for creating new constant symbols. 2 Ground atomic formulas are required for simplicity. 3 * Horn Oracles: A state D is a set of Horn rules and O d (D) is the minimal Herbrand model of D. <p> This latter mechanism would not be available to ordinary programmers. For this reason, we assume in this paper that the data and transition oracles are fixed. A more complete discussion of data and transition oracles can be found in <ref> [9] </ref>. 2.3 Examples This section gives some simple examples of Concurrent Transaction Logic programs, or transaction bases. A transaction base is a finite set of transaction formulas. In this paper, all examples of transaction bases use so-called concurrent Horn rules, which are defined formally in Section 4. <p> for a message and consuming it is done atomically, preventing other processes from interposing their actions between the test channel (Ch; M sg) and the update channel:del (Ch; M sg). 6 3 Model Theory The semantics of the sequential Transaction Logic is based on sequences of database states, called paths <ref> [9, 8, 6] </ref>. Concurrent Transaction Logic extends this idea to sequences of paths, called multi-paths, or m-paths. Multi-paths provide the basis for a logical semantics of concurrent conjunction. <p> For example, the transaction = a.ins b.ins c.ins takes the database from an initial state, D, through the intermediate states D + fag and D + fa; bg, to the final state D + fa; b; cg. In sequential Transaction Logic <ref> [9, 6] </ref>, a finite sequence of states is called a path, and transactions are true on paths. For example, transaction is true on the path hfg fag fa; bg fa; b; cgi, in which the initial state is the empty database. <p> We also say that hfg fag fa; bg fa; b; cgi is an execution path of . Execution paths allow us to model a wide range of dynamic constraints <ref> [9, 7, 11] </ref>. To model concurrent processes, we generalize the notion of path to multi-path, or m-path. An m-path records the execution history of a process. Intuitively, it represents periods of continuous execution, separated by periods of suspended execution (during which other processes may execute). <p> Intuitively, a formula that is true on an m-path represents an action that takes place along the m-path. Multi-path structures generalize the path structures of sequential Transaction Logic. Many subtle points about path structures apply equally well to multi-path structures, and the reader is referred to <ref> [9, 8, 6] </ref> for a thorough discussion. The main novelties of m-path structures are the m-paths themselves, the interleaving operation, and reduction, which account for concurrent and atomic processes. <p> of the transaction p j q in which atoms are inserted into the empty database in the order c; e; f; d. 2 5 Model theoretically, "( )" is a transaction that is true on every m-path of the form hDi, i:e:, on any m-path corresponding to a single database <ref> [9, 6] </ref>. 12 long Sequent Inf. <p> Since we are interested in the execution of a particular transaction, we introduce the more specialized notion of executional deduction, which|without sacrificing completeness|defines a narrower range of deductions. The notion of executional deduction needed here is exactly the same as that developed for sequential Transaction Logic in <ref> [9, 6] </ref>. It also leads naturally to a proof-theoretic notion of execution path. It remains only to show that executional deduction in concurrent Transaction Logic is sound and complete for the model theory of Section 3. This is established by the following theorem. <p> The predicate newChannel (Ch) is an atomic process that creates a private channel and returns its name, Ch. The predicate delChannel (Ch) is an atomic process that destroys channel Ch. newChannel and delChannel are easily defined via the transition oracle or the transaction base <ref> [9] </ref>. A client process client (Id) first generates a new channel, Ch. It then connects to the server via the public channel, passing it the new channel name. The server then spawns a subprocess servClient (Ch) to deal with the client.
Reference: [10] <author> A.J. Bonner and M. Kifer. </author> <title> Concurrent Transaction Datalog: Complexity and expressibility. </title> <note> In preparation, </note> <year> 1996. </year>
Reference-contexts: For instance, many such languages do not support subtransactions, transaction failure, or transaction rollback. Moreover, whereas most database transaction languages express all the database transactions computable in PSPACE, T R expresses all the transactions computable in EXPTIME (in the function-free case) <ref> [10] </ref>. In this paper, we extend Transaction Logic by allowing updates to be combined concurrently , as well as serially. We call the resulting logical system Concurrent Transaction Logic (or CT R). <p> It does not have to delay process execution because of an artificially-imposed linear order. Finally, power is increased since the logic can now express any computable database transaction <ref> [10] </ref>, i:e:, concurrency increases expressibility from EXPTIME to RE (in the function-free case). Although there has been considerable research on concurrency in databases, logic programming, and elsewhere, CT R is the only deductive database language that integrates concurrency, communication, and database updates in a completely logical framework.
Reference: [11] <author> A.J. Bonner, M. Kifer, and M. Consens. </author> <title> Database programming in transaction logic. </title> <editor> In A. Ohori C. Beeri and D.E. Shasha, editors, </editor> <booktitle> Proceedings of the International Workshop on Database Programming Languages, Workshops in Computing, </booktitle> <pages> pages 309-337. </pages> <publisher> Springer-Verlag, </publisher> <month> February </month> <year> 1994. </year> <booktitle> Workshop held on Aug 30-Sept 1, 1993, </booktitle> <address> New York City, NY. </address>
Reference-contexts: We also say that hfg fag fa; bg fa; b; cgi is an execution path of . Execution paths allow us to model a wide range of dynamic constraints <ref> [9, 7, 11] </ref>. To model concurrent processes, we generalize the notion of path to multi-path, or m-path. An m-path records the execution history of a process. Intuitively, it represents periods of continuous execution, separated by periods of suspended execution (during which other processes may execute).
Reference: [12] <author> W. Chen, M. Kifer, and D.S. Warren. HiLog: </author> <title> A foundation for higher-order logic programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 15(3) </volume> <pages> 187-230, </pages> <month> February </month> <year> 1993. </year>
Reference-contexts: Process names can then be sent and received like other messages, and executed like other processes. Another way to do this is to extend CT R in the direction of HiLog <ref> [12] </ref>, a well-known higher-order extension of classical logic. In a nutshell, HiLog allows variables over functions, predicate symbols, and even over atomic formulas. <p> In a nutshell, HiLog allows variables over functions, predicate symbols, and even over atomic formulas. Moreover, the distinction between atomic formulas and terms is completely erased, and arbitrary (even non-ground) terms can serve as predicate names in HiLog, which provides a convenient way of defining generic logical procedures <ref> [12] </ref>. For instance, A (X; Y )(Z)(V; W ) is a well-formed term in HiLog. As a concrete example, the rules below define a predicate f act (N )(A) that computes the factorial function. <p> CT R is not yet-another-logic unrelated and isolated from other extensions. It is an idea that is orthogonal to several other recent proposals, such as F-logic [17] (structural object-orientation), HiLog <ref> [12] </ref> (higher-order logic programming), and Annotated Logic [3, 18, 19] (reasoning with uncertainty), and it can be easily integrated with them to endow these static formalisms with the ability to capture database dynamics in a clean, logical fashion (cf., e.g., [16]). <p> Like the -calculus, CT R can send and receive messages and channels, and it can reconfigure the communication topology dynamically. To a large extent, CT R processes can create private communication channels, a la -calculus. With a simple extension in the direction of HiLog <ref> [12] </ref>, CT R can pass transactions between processes for remote execution. In a recent work, Miller [25] has shown that most of the -calculus can be encoded in Linear Logic [13]. The reduction process of the -calculus is simulated via the proof theory of Linear Logic.
Reference: [13] <author> J.-Y. Girard. </author> <title> Linear logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 50 </volume> <pages> 1-102, </pages> <year> 1987. </year>
Reference-contexts: With a simple extension in the direction of HiLog [12], CT R can pass transactions between processes for remote execution. In a recent work, Miller [25] has shown that most of the -calculus can be encoded in Linear Logic <ref> [13] </ref>. The reduction process of the -calculus is simulated via the proof theory of Linear Logic. However, the semantics of Linear Logic does not give direct meaning to execution and communication, unlike CT R.
Reference: [14] <author> Nathan Goodman, Steve Rozen, and Lincoln Stein. </author> <title> Requirements for a deductive query language in the MapBase genome-mapping database. </title> <editor> In Raghu Ramakrishnan, editor, </editor> <booktitle> Applications of Logic Databases, </booktitle> <pages> pages 259-278. </pages> <publisher> Kluwer, </publisher> <year> 1994. ftp://genome.wi.mit.edu/pub/papers/Y1994/requirements.ps. </year>
Reference-contexts: In Prolog, asserting or retracting a clause is elementary. In database applications, SQL statements are the basic building blocks. In scientific and engineering programs, basic operations include Fourier transforms, matrix inversion, least-squares fitting, and operations on DNA sequences <ref> [14, 20] </ref>. In workflow management systems, elementary operations can include any number of application programs and legacy systems [4]. In all cases, the elementary operations are building blocks from which larger programs and software systems are built. Although elementary operations vary dramatically, the logic for combining them does not.
Reference: [15] <author> D. Harel, D. Kozen, and R. Parikh. </author> <title> Process Logic: Expressiveness, decidability, completeness. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 25(2) </volume> <pages> 144-170, </pages> <month> October </month> <year> 1982. </year>
Reference-contexts: In contrast, CDL worries about internal states of executing programs, while the notion of a database state is entirely missing. It is also worth noting that these statements equally apply to another related logic, Process Logic <ref> [15] </ref>, although we are not aware of any extensions of Process Logic that allow concurrency and communication. Acknowledgments. Anthony Bonner's work was supported in part by an Operating Grant from the Natural Sciences and Engineering Research Council of Canada. Michael Kifer was supported in part by the NSF Grant IRI-9404629.
Reference: [16] <author> M. Kifer. </author> <title> Deductive and object-oriented data languages: A quest for integration. </title> <booktitle> In Intl. Conference on Deductive and Object-Oriented Databases, volume 1013 of Lecture Notes in Computer Science, </booktitle> <pages> pages 187-212, </pages> <address> Singapore, </address> <month> December </month> <year> 1995. </year> <title> Springer-Verlag. Keynote address at the 3d Intl. </title> <booktitle> Conference on Deductive and Object-Oriented databases. </booktitle>
Reference-contexts: other recent proposals, such as F-logic [17] (structural object-orientation), HiLog [12] (higher-order logic programming), and Annotated Logic [3, 18, 19] (reasoning with uncertainty), and it can be easily integrated with them to endow these static formalisms with the ability to capture database dynamics in a clean, logical fashion (cf., e.g., <ref> [16] </ref>). The communication paradigm within CT R is inspired by the -calculus [26, 27]. However, CT R is a programming logic, while -calculus is an algebra used for specifying and verifying finite-state concurrent systems (which databases and logic programs are not).
Reference: [17] <author> M. Kifer, G. Lausen, and J. Wu. </author> <title> Logical foundations of object-oriented and frame-based languages. </title> <journal> Journal of ACM, </journal> <pages> pages 741-843, </pages> <month> July </month> <year> 1995. </year> <month> 17 </month>
Reference-contexts: CT R is not yet-another-logic unrelated and isolated from other extensions. It is an idea that is orthogonal to several other recent proposals, such as F-logic <ref> [17] </ref> (structural object-orientation), HiLog [12] (higher-order logic programming), and Annotated Logic [3, 18, 19] (reasoning with uncertainty), and it can be easily integrated with them to endow these static formalisms with the ability to capture database dynamics in a clean, logical fashion (cf., e.g., [16]).
Reference: [18] <author> M. Kifer and E.L. Lozinskii. </author> <title> A logic for reasoning with inconsistency. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 9(2) </volume> <pages> 179-215, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: CT R is not yet-another-logic unrelated and isolated from other extensions. It is an idea that is orthogonal to several other recent proposals, such as F-logic [17] (structural object-orientation), HiLog [12] (higher-order logic programming), and Annotated Logic <ref> [3, 18, 19] </ref> (reasoning with uncertainty), and it can be easily integrated with them to endow these static formalisms with the ability to capture database dynamics in a clean, logical fashion (cf., e.g., [16]). The communication paradigm within CT R is inspired by the -calculus [26, 27].
Reference: [19] <author> M. Kifer and V.S. Subrahmanian. </author> <title> Theory of generalized annotated logic programming and its applications. </title> <journal> Journal of Logic Programming, </journal> <volume> 12(4) </volume> <pages> 335-368, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: CT R is not yet-another-logic unrelated and isolated from other extensions. It is an idea that is orthogonal to several other recent proposals, such as F-logic [17] (structural object-orientation), HiLog [12] (higher-order logic programming), and Annotated Logic <ref> [3, 18, 19] </ref> (reasoning with uncertainty), and it can be easily integrated with them to endow these static formalisms with the ability to capture database dynamics in a clean, logical fashion (cf., e.g., [16]). The communication paradigm within CT R is inspired by the -calculus [26, 27].
Reference: [20] <author> J.N. Maksym, A.J. Bonner, C.A. Dent, and G.L. Hemphill. </author> <title> Machine Analysis of Acoustical Signals. </title> <journal> Pattern Recognition, </journal> <volume> 16(6) </volume> <pages> 615-625, </pages> <year> 1983. </year> <booktitle> Also appears in Proceedings of the Workshop on Issues in Acoustic Signal/Image Processing and Recognition, </booktitle> <address> San Miniato, Italy, </address> <month> August 5-9 </month> <year> 1982. </year>
Reference-contexts: In Prolog, asserting or retracting a clause is elementary. In database applications, SQL statements are the basic building blocks. In scientific and engineering programs, basic operations include Fourier transforms, matrix inversion, least-squares fitting, and operations on DNA sequences <ref> [14, 20] </ref>. In workflow management systems, elementary operations can include any number of application programs and legacy systems [4]. In all cases, the elementary operations are building blocks from which larger programs and software systems are built. Although elementary operations vary dramatically, the logic for combining them does not.
Reference: [21] <author> J.M. McCarthy and P.J. Hayes. </author> <title> Some philosophical problems from the standpoint of artificial intelligence. </title> <editor> In B. Meltzer and D. Michie, editors, </editor> <booktitle> Machine Intelligence, </booktitle> <volume> volume 4, </volume> <pages> pages 463-502. </pages> <publisher> Edinburgh University Press, </publisher> <year> 1969. </year> <note> Reprinted in Readings in Artificial Intelligence, </note> <year> 1981, </year> <title> Tioga Publ. </title> <publisher> Co. </publisher>
Reference-contexts: Programming with states is very common, and the practice of logic programming shows that it is also unavoidable. Unfortunately, classical logic is stateless. One way to get around this problem is to represent states as terms, as in the situation calculus <ref> [21, 31] </ref>. However, this approach has not taken roots in logic programming for many reasons, including the complexity of dealing with the frame problem [9]. In Prolog, efficient techniques have been developed where states are represented as lists or terms, which do not require frame axioms.
Reference: [22] <author> J. Meseguer. </author> <title> Conditional rewriting logic as a unified model of concurrency. </title> <journal> Theoretical Computer Science, </journal> <volume> 96(1) </volume> <pages> 73-155, </pages> <year> 1992. </year>
Reference-contexts: There is also no programming language for specifying how processes evolve. Instead, one must list all the operations performed by a process (and its subprocesses) before execution begins. Another related formalism, rewriting logic <ref> [22] </ref>, is a general framework for specifying executable concurrent systems. In fact, it is so general that classical logic, Linear Logic, the -calculus, and CT R can all be encoded as particular theories within this logic.
Reference: [23] <author> J. Meseguer. </author> <title> Multiparadigm logic programming. In Algebraic and Logic Specifications, </title> <booktitle> number 632 in Lecture Notes in Computer Science, </booktitle> <pages> pages 158-200. </pages> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1992. </year>
Reference-contexts: In the first capacity, we believe that an embedding of CT R into rewriting logic may prove useful for clarifying the relationship between CT R and other concurrent formalisms. In the second capacity, rewriting logic has been used to design languages for object-oriented programming <ref> [23, 24] </ref>, and equational programming [23]. However, the programming paradigm of CT R is fundamentally different from these other languages. Some of the earliest attempts at adding concurrency to logic programming were PARLOG, Concurrent Prolog, GHC, and related languages (see [32] for a survey). <p> In the first capacity, we believe that an embedding of CT R into rewriting logic may prove useful for clarifying the relationship between CT R and other concurrent formalisms. In the second capacity, rewriting logic has been used to design languages for object-oriented programming [23, 24], and equational programming <ref> [23] </ref>. However, the programming paradigm of CT R is fundamentally different from these other languages. Some of the earliest attempts at adding concurrency to logic programming were PARLOG, Concurrent Prolog, GHC, and related languages (see [32] for a survey).
Reference: [24] <author> J. Meseguer. </author> <title> A logic theory of concurrent objects and its realization in the Maude language. </title> <editor> In G. Agha, P. Wegner, and A. Yonezawa, editors, </editor> <booktitle> Research Directions in Object-Based Concurrency. </booktitle> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: In the first capacity, we believe that an embedding of CT R into rewriting logic may prove useful for clarifying the relationship between CT R and other concurrent formalisms. In the second capacity, rewriting logic has been used to design languages for object-oriented programming <ref> [23, 24] </ref>, and equational programming [23]. However, the programming paradigm of CT R is fundamentally different from these other languages. Some of the earliest attempts at adding concurrency to logic programming were PARLOG, Concurrent Prolog, GHC, and related languages (see [32] for a survey).
Reference: [25] <author> D. Miller. </author> <title> The -calculus as a theory in linear logic: Preliminary results. </title> <booktitle> In Proceedings of the Workshop on Extensions to Logic Programming, Lecture Notes in Computer Science, </booktitle> <pages> pages 242-265. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: To a large extent, CT R processes can create private communication channels, a la -calculus. With a simple extension in the direction of HiLog [12], CT R can pass transactions between processes for remote execution. In a recent work, Miller <ref> [25] </ref> has shown that most of the -calculus can be encoded in Linear Logic [13]. The reduction process of the -calculus is simulated via the proof theory of Linear Logic. However, the semantics of Linear Logic does not give direct meaning to execution and communication, unlike CT R.
Reference: [26] <author> R. Milner, J. Parrow, and D. Walker. </author> <title> A calculus of mobile processes, I. </title> <journal> Information and Computation, </journal> <volume> 100(1) </volume> <pages> 1-40, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: In that sense, CT R supports pattern-directed communication. Patterns (which in our case are function terms representing channels) can be arranged in various ways to achieve point-to-point, broadcast, blackboard, and other forms of communication, with bounded or unbounded buffers. Dynamic Communication Topology: As in the -calculus <ref> [26] </ref>, CT R processes can send channel names to each other, through which they can communicate later, thereby changing the communication topology. To 13 illustrate, the program below simulates a simple server that responds to client requests. Intuitively, the predicate client (Id) represents a client process with identifier Id. <p> The communication paradigm within CT R is inspired by the -calculus <ref> [26, 27] </ref>. However, CT R is a programming logic, while -calculus is an algebra used for specifying and verifying finite-state concurrent systems (which databases and logic programs are not).
Reference: [27] <author> R. Milner, J. Parrow, and D. Walker. </author> <title> A calculus of mobile processes, II. </title> <journal> Information and Computation, </journal> <volume> 100(1) </volume> <pages> 41-77, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: The communication paradigm within CT R is inspired by the -calculus <ref> [26, 27] </ref>. However, CT R is a programming logic, while -calculus is an algebra used for specifying and verifying finite-state concurrent systems (which databases and logic programs are not).
Reference: [28] <author> D. Peleg. </author> <title> Communication in concurrent dynamic logic. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 35(1) </volume> <pages> 23-58, </pages> <month> August </month> <year> 1987. </year>
Reference-contexts: Finally, a comparison of CT R with Concurrent Dynamic Logic (CDL) <ref> [29, 28] </ref> is in order. There are two versions of CDL. The version developed in [29] is very different from CT R. It is modeled on the kind of concurrency found in alternating Turing machines, which does not allow for communication between concurrent processes. <p> A deductive-database analogue of this version of CDL is Hypothetical Datalog [5], in which hypothetical databases represent the states of the various (non-communicating) concurrent processes in an alternating computation. The version of CDL developed in <ref> [28] </ref> does allow for communication, but only after adding considerable complexity to the semantics. In both versions of CDL, the meaning and intent of dynamic formulas is fundamentally different from that of transaction formulas in CT R.
Reference: [29] <author> D. </author> <title> Peleg. </title> <journal> Concurrent-dynamic logic. Journal of ACM, </journal> <volume> 34(2):450 - 479, </volume> <month> March </month> <year> 1987. </year>
Reference-contexts: Finally, a comparison of CT R with Concurrent Dynamic Logic (CDL) <ref> [29, 28] </ref> is in order. There are two versions of CDL. The version developed in [29] is very different from CT R. It is modeled on the kind of concurrency found in alternating Turing machines, which does not allow for communication between concurrent processes. <p> Finally, a comparison of CT R with Concurrent Dynamic Logic (CDL) [29, 28] is in order. There are two versions of CDL. The version developed in <ref> [29] </ref> is very different from CT R. It is modeled on the kind of concurrency found in alternating Turing machines, which does not allow for communication between concurrent processes.
Reference: [30] <author> B. Pierce. </author> <title> Programming in the -calculus|An experiment in concurrent language design. PICT Version 3.4c tutorial. </title> <address> ftp://ftp.dcs.ed.ac.uk/pub/bcp/pict.tar.Z, </address> <month> March </month> <year> 1994. </year>
Reference-contexts: However, CT R is a programming logic, while -calculus is an algebra used for specifying and verifying finite-state concurrent systems (which databases and logic programs are not). Although there is growing interest in designing programming languages based on -calculus (e.g., PICT <ref> [30] </ref>), the application domain of such languages seems very different from CT R. These languages have a functional flavor, and their ability to express data-driven non-determinism is limited. Once a process is committed to a certain execution path, there is no possibility for failure.
Reference: [31] <author> R. Reiter. </author> <title> Formalizing database evolution in the situation calculus. </title> <booktitle> In Conference on Fifth Generation Computer Systems, </booktitle> <year> 1992. </year>
Reference-contexts: Programming with states is very common, and the practice of logic programming shows that it is also unavoidable. Unfortunately, classical logic is stateless. One way to get around this problem is to represent states as terms, as in the situation calculus <ref> [21, 31] </ref>. However, this approach has not taken roots in logic programming for many reasons, including the complexity of dealing with the frame problem [9]. In Prolog, efficient techniques have been developed where states are represented as lists or terms, which do not require frame axioms.
Reference: [32] <author> E. Shapiro. </author> <title> A family of concurrent logic programming languages. </title> <journal> ACM Computing Surveys, </journal> <volume> 21(3), </volume> <year> 1989. </year>
Reference-contexts: This form of communication leads to a programming style that is very different from that of existing concurrent logic programming (CLP) languages, as illustrated in this paper. In CLP languages <ref> [32] </ref>, concurrent processes communicate via shared variables and unification. This kind of communication is orthogonal to communication via the database. Both are possible in CT R. Implementations of CT R may therefore adopt many of the techniques of shared-variable communication developed for CLP. <p> Likewise, these problems are not addressed by existing concurrent logic programming languages <ref> [32] </ref>. In fact, the problems of updates are even more complex in a concurrent environment. Concurrent Transaction Logic provides a general solution to the aforementioned limitations, both of Prolog and of concurrent logic programming languages. <p> rocess; Ans) send (Ch; P rocess) receive (Ch; Ans) proc2 (Ch) receive (Ch; P rocess) P rocess (Ans) send (Ch; Ans) fact (0)(1) fact (N )(N fl A) f act (N 1)(A) (3) Guarded Clauses: Finally, a remark on the relationship between CT R and concurrent logic programming (CLP) languages <ref> [32] </ref> is in order. Since the semantics of these languages has eluded capture in logic, we will not pretend that CT R can simulate these languages faithfully. However, some analogies can be made. <p> In contrast, CT R offers a different paradigm, one with clean, logical model and proof theories and several ways of controlling non-determinism via synchronization. Non-determinism has entirely different nature here ("don't know" rather than "don't care" <ref> [32] </ref>), and it is deeply rooted in the model theory. 6 Conclusions and Discussion We presented Concurrent Transaction Logic ( CT R), a logic that can declaratively specify and procedurally execute concurrent communicating database processes involving queries, updates, or combinations of both. <p> However, the programming paradigm of CT R is fundamentally different from these other languages. Some of the earliest attempts at adding concurrency to logic programming were PARLOG, Concurrent Prolog, GHC, and related languages (see <ref> [32] </ref> for a survey). We discussed possible connections between CT R and concurrent logic programming earlier in this paper.
References-found: 32

