URL: http://www.ags.uni-sb.de/~melis/Pub/ArmandoMelis98.ps.gz
Refering-URL: http://jswww.cs.uni-sb.de/~melis/
Root-URL: 
Phone: 2  
Title: Constraint Solving in Logic Programming and in Automated Deduction: a Comparison  
Author: Alessandro Armando Erica Melis and Silvio Ranise 
Address: Genova, Viale Causa, 13 16145 Genova, Italy  D-66041 Saarbrucken, Germany  
Affiliation: 1 DIST, Universita di  Universitat des Saarlandes, FB Informatik  
Abstract: Constraint solving has been successfully employed in diverse areas such as Operation Research, Planning, Logic Programming, and Automated Deduction. This has led to the development of a number of specialised approaches as well as to the adoption of different integration schemes and methodologies. In this paper we introduce an approach to incorporate constraint solving in term rewriting and we compare it with the Constraint Logic Programming scheme. We compare the two approaches both at the theoretical and at the implementational level and discuss potentials for cross-fertilisation.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A. Armando and S. Ranise. </author> <title> From Integrated Reasoning Specialists to "Plug-and-Play" Reasoning Components. </title> <booktitle> In Fourth International Conference on Artificial Intelligence and Symbolic Computation (AISC98). </booktitle> <address> Plattsburgh, NY, USA. </address> <month> September 16-18, </month> <year> 1998. </year>
Reference-contexts: An abstract description of nqthm's simplifier is depicted in Fig. 2 (borrowed from <ref> [1] </ref>). The SIMPLIFIER starts by sending the 2 For our purposes it suffices to know that the method simplifies the constraint store by linearly combining the available constraints and then eliminating the parent constraints. The exhaustive application of the method yields a constraint store whose (in)consistency can be easily checked.
Reference: 2. <author> A. Bouhoula and M. Rusinowitch. SPIKE: </author> <title> A system for automatic inductive proofs. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> 936, </volume> <year> 1995. </year>
Reference-contexts: Several extensions have been investigated to make term rewriting techniques applicable in complex applications. Contextual rewriting <ref> [20, 2, 8] </ref> is an extension to conditional rewriting [11] whereby the context surrounding the term being rewritten is used to relieve the conditions of conditional rewrites. (For instance, if the current focus of rewriting is a sub-term of lit in the clause flitg [ E, then the set of the <p> is a sub-term of lit in the clause flitg [ E, then the set of the negations of the literals in E can be taken as the context of rewriting.) Contextual rewriting, apparently first introduced in NQTHM [4], is now widely employed, for instance, in the provers RRL [12], SPIKE <ref> [2] </ref>, and STeP [15]. Here we focus on constraint contextual rewriting (CCR) which generalises contextual rewriting by incorporating the functionalities provided by a decision procedure. For a different approach to integrating constraint solving with term rewriting see, e.g., [13].
Reference: 3. <author> R. S. Boyer and J S. Moore. </author> <title> Integrating Decision Procedures into Heuristic Theorem Provers: A Case Study of Linear Arithmetic. </title> <journal> Machine Intelligence (Logic and the Acquisition of Knowledge), </journal> <volume> 11 </volume> <pages> 83-124, </pages> <year> 1988. </year>
Reference-contexts: Although CCR is inspired by the simplification mechanism of nqthm, the abstract characterisation we give in Sect. 4 is new and provides a neat characterisation of the interplay between the constraint solver and the simplification mechanism. This contrasts with the presentation given in <ref> [3] </ref> where no abstract description is provided. In Sect. 5 we carry out a comparative analysis of the two approaches and explore the potentials for cross-fertilisation.
Reference: 4. <author> R.S. Boyer and J.S. Moore. </author> <title> A Computational Logic. </title> <publisher> Academic Press, </publisher> <address> 1979. </address> <publisher> ACM monograph series. </publisher>
Reference-contexts: the conditions of conditional rewrites. (For instance, if the current focus of rewriting is a sub-term of lit in the clause flitg [ E, then the set of the negations of the literals in E can be taken as the context of rewriting.) Contextual rewriting, apparently first introduced in NQTHM <ref> [4] </ref>, is now widely employed, for instance, in the provers RRL [12], SPIKE [2], and STeP [15]. Here we focus on constraint contextual rewriting (CCR) which generalises contextual rewriting by incorporating the functionalities provided by a decision procedure.
Reference: 5. <author> R.S. Boyer and J.S. Moore. </author> <title> Integrating Decision Procedures into Heuristic Theorem Provers: A Case Study of Linear Arithmetic. </title> <journal> Machine Intelligence, </journal> <volume> 11 </volume> <pages> 83-124, </pages> <year> 1988. </year>
Reference-contexts: s ! C t then R; CR j= D C ! (s ~ t), where "~" is "=" if s and t are literals and "~" is "$" if s and t are terms. 4.2 The Simplifier of NQTHM: an Architectural View CCR is inspired by the simplifier of nqthm <ref> [5] </ref> which incorporates a decision procedure for linear arithmetics. An abstract description of nqthm's simplifier is depicted in Fig. 2 (borrowed from [1]).
Reference: 6. <editor> N. Dershowitz and J.P. Jouannaud. </editor> <booktitle> Rewriting systems. In Handbook of Theoretical Computer Science, </booktitle> <pages> pages 243-320. </pages> <publisher> Elsevier Publishers, </publisher> <address> Amsterdam, </address> <year> 1990. </year>
Reference-contexts: To this end a variant of the Fourier's variable-elimination method is used (see, e.g., [18]). 4 Constraint Solving in Automated Deduction Term rewriting is a fundamental and thoroughly studied technique in automated deduction (see <ref> [6] </ref> for a survey). Several extensions have been investigated to make term rewriting techniques applicable in complex applications.
Reference: 7. <author> T. Fruehwirth. </author> <title> Constraint handling rules. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> 910, </volume> <year> 1995. </year>
Reference-contexts: User-Defined Constraints. Constraint solvers are usually "built in" to the host system. There are several proposals to extend CLP languages to allow the user to define new constraints. For instance, in <ref> [7] </ref> new constraints are predicates and a set of guarded rules (called constraint simplification rules) specify how the constraint store is to be simplified. The constraint store is then kept closed under the application of the constraint simplification rules.
Reference: 8. <author> Harald Ganzinger. </author> <title> A completion procedure for conditional equations. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 11(1-2):51-81, </volume> <month> January-February </month> <year> 1991. </year>
Reference-contexts: Several extensions have been investigated to make term rewriting techniques applicable in complex applications. Contextual rewriting <ref> [20, 2, 8] </ref> is an extension to conditional rewriting [11] whereby the context surrounding the term being rewritten is used to relieve the conditions of conditional rewrites. (For instance, if the current focus of rewriting is a sub-term of lit in the clause flitg [ E, then the set of the
Reference: 9. <author> J. Jaffar and M.J. Maher. </author> <title> Constraint logic programming: A survey. </title> <journal> Journal of Logic Programming, </journal> (19/20):503-581, 1994. 
Reference-contexts: It is assumed that c " p = ;. 3.1 Operational Semantics of CLP Programs The operational semantics of CLP programs provides an abstract characterisa-tion of SLD-resolution [14] enhanced with constraint solving. Following <ref> [9] </ref>, the operational semantics is given by means of a transition system whose transitions are ! r (resolution), ! c (constraint introduction), ! i (inference/propagation), and ! s (solution) and whose states are triples of the form hA; C; Si, where A is a multiset of ( j ; j ; <p> Since constraint rules may be conditional, the AUGMENT module may in turn invoke the REWRITER to relieve the conditions of the constraint rules (rule (augment ). The REWRITER, the LA-SOLVER, and the AUGMENT module are thus mutually interfaced. 5 A Comparative Analysis As pointed out in <ref> [9] </ref>, the crucial feature of the CLP scheme is that it provides a logic programming language whose operational and declarative semantics as well as the relationship between them can be parametrised by the domain of com-putation and constraints.
Reference: 10. <author> Joxan Jaffar, Spiro Michaylov, Peter J. Stuckey, and Roland H. C. Yap. </author> <title> The CLP(R) language and system. </title> <journal> TOPLAS, </journal> <volume> 14(3) </volume> <pages> 339-395, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: To this end the constraint solving capabilities of the CLP (R) system are distributed among a set of sub-solvers. The sub-solvers are specialised to tackle constraints of increasing complexity and are hierarchically organised as depicted in Fig. 1 <ref> [10] </ref>. The lower a module is in the hierarchy the stronger (but also computationally more expensive) are the corresponding solving capabilities. Fig. 1.
Reference: 11. <author> S. Kaplan. </author> <title> Conditional rewrite rules. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 33(2-3):175-193, </address> <month> October </month> <year> 1984. </year>
Reference-contexts: Several extensions have been investigated to make term rewriting techniques applicable in complex applications. Contextual rewriting [20, 2, 8] is an extension to conditional rewriting <ref> [11] </ref> whereby the context surrounding the term being rewritten is used to relieve the conditions of conditional rewrites. (For instance, if the current focus of rewriting is a sub-term of lit in the clause flitg [ E, then the set of the negations of the literals in E can be taken
Reference: 12. <author> Deepak Kapur and Hantao Zhang. RRL: </author> <title> A rewrite rule laboratory. </title> <editor> In E. Lusk; R. Overbeek, editor, </editor> <booktitle> Proceedings on the 9th International Conference on Automated Deduction, volume 310 of LNCS, </booktitle> <pages> pages 768-769, </pages> <address> Berlin, May 1988. </address> <publisher> Springer. </publisher>
Reference-contexts: of rewriting is a sub-term of lit in the clause flitg [ E, then the set of the negations of the literals in E can be taken as the context of rewriting.) Contextual rewriting, apparently first introduced in NQTHM [4], is now widely employed, for instance, in the provers RRL <ref> [12] </ref>, SPIKE [2], and STeP [15]. Here we focus on constraint contextual rewriting (CCR) which generalises contextual rewriting by incorporating the functionalities provided by a decision procedure. For a different approach to integrating constraint solving with term rewriting see, e.g., [13].
Reference: 13. <author> H. Kirchner. </author> <title> On the use of constraints in automated deduction. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <address> 910:128-??, </address> <year> 1995. </year>
Reference-contexts: Here we focus on constraint contextual rewriting (CCR) which generalises contextual rewriting by incorporating the functionalities provided by a decision procedure. For a different approach to integrating constraint solving with term rewriting see, e.g., <ref> [13] </ref>. In what follows E and E 0 are ground clauses, i.e. finite sets of ( j ; j )- literals. 1 The disjointness of p and c is not required, instead it is assumed that c p = j .
Reference: 14. <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: It is assumed that c " p = ;. 3.1 Operational Semantics of CLP Programs The operational semantics of CLP programs provides an abstract characterisa-tion of SLD-resolution <ref> [14] </ref> enhanced with constraint solving.
Reference: 15. <author> Z. Manna, A. Anuchitanukul, N. Bjorner, A. Browne, E. Chang, M. Colon, L. de Al-faro, H. Devarajan, H. Sipma, and T. Uribe. </author> <title> STeP: The stanford temporal prover. </title> <type> Technical Report CS-TR-94-1518, </type> <institution> Stanford University, </institution> <month> June </month> <year> 1994. </year>
Reference-contexts: of lit in the clause flitg [ E, then the set of the negations of the literals in E can be taken as the context of rewriting.) Contextual rewriting, apparently first introduced in NQTHM [4], is now widely employed, for instance, in the provers RRL [12], SPIKE [2], and STeP <ref> [15] </ref>. Here we focus on constraint contextual rewriting (CCR) which generalises contextual rewriting by incorporating the functionalities provided by a decision procedure. For a different approach to integrating constraint solving with term rewriting see, e.g., [13].
Reference: 16. <author> G. Nelson and D.C. Oppen. </author> <title> Simplification by Cooperating Decision Procedures. </title> <type> Technical Report STAN-CS-78-652, </type> <institution> Stanford Computer Science Department, </institution> <month> April </month> <year> 1978. </year>
Reference-contexts: While it is important to develop constraint solving techniques in the domain of interest, it is equally important to compare solutions developed in different settings and to look for opportunities of cross-fertilisation. For instance, [19] describes how Nelson and Oppen's approach to combining decision procedures <ref> [16] </ref> developed in the context of Automated Deduction can be lifted to a technique for building composite constraint solvers to be used in Constraint Logic Programming (CLP). In this paper we compare the CLP scheme with a form of term rewriting, called Constraint Contextual Rewriting (CCR), which incorporates constraint solving.
Reference: 17. <author> Michael J. O'Donnell. </author> <title> Equational logic programming. </title> <editor> In C. J. Hogger D. M. Gab-bay and J. A. Robinson, editors, </editor> <booktitle> Handbook of Logic in Artificial Intelligence and Logic Programming, volume 5, Logic Programming, chapter 3. </booktitle> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference-contexts: Furthermore, since Fourier's elimination works in the constraint domain of the rationals numbers and in our example the multiplicands are integers, it is sound to translate the constraint X &lt; 1 + Y into the literal X Y . rewriting where logic variables are allowed, e.g. in equational logic programming <ref> [17] </ref>, implementations of the CCR Schema could benefit from the techniques devised in the CLP setting. Interpreted Function Symbols. The CCR technique of augmenting the constraint store by means of constraint rules encoding knowledge about interpreted symbols can be employed in the CLP scheme too.
Reference: 18. <author> A. Schrijver. </author> <title> Theory of Linear and Integer Programming. A Wiley-Interscience publication. </title> <publisher> Wiley, </publisher> <address> Chichester, New York, </address> <year> 1986. </year>
Reference-contexts: The Equality Solver keeps the equalities in parametric solved form using a refinement of the Gaussian elimination method. The Inequality Solver keeps the inequalities in a solved form using an incremental version of Phase I of the Two-Phase Simplex Method (see, e.g., <ref> [18] </ref>). It is capable of detecting inconsistency (when no solution can be found) as well as implicit equalities, i.e. equalities entailed by the constraint store. Finally the Nonlinear Handler stores nonlinear constraints for later use as passive constraints. <p> Task of the Output Module is to translate the content of the constraint store into a logically equivalent formula containing only variables occurring in the input goal. To this end a variant of the Fourier's variable-elimination method is used (see, e.g., <ref> [18] </ref>). 4 Constraint Solving in Automated Deduction Term rewriting is a fundamental and thoroughly studied technique in automated deduction (see [6] for a survey). Several extensions have been investigated to make term rewriting techniques applicable in complex applications.
Reference: 19. <author> Cesare Tinelli and Mehdi Harandi. </author> <title> Constraint logic programming over unions of constraint theories. </title> <journal> Journal of Logic and Functional Programming, </journal> <note> 1998. (to appear). </note>
Reference-contexts: While it is important to develop constraint solving techniques in the domain of interest, it is equally important to compare solutions developed in different settings and to look for opportunities of cross-fertilisation. For instance, <ref> [19] </ref> describes how Nelson and Oppen's approach to combining decision procedures [16] developed in the context of Automated Deduction can be lifted to a technique for building composite constraint solvers to be used in Constraint Logic Programming (CLP).
Reference: 20. <author> H. Zhang and J. L. Remy. </author> <title> Contextual rewriting. </title> <editor> In Jean-Pierre Jouannaud, editor, </editor> <booktitle> Proceedings of the 1st International Conference on Rewriting Techniques and Applications, volume 202 of LNCS, </booktitle> <pages> pages 46-62, </pages> <address> Dijon, France, May 1985. </address> <publisher> Springer. </publisher>
Reference-contexts: Several extensions have been investigated to make term rewriting techniques applicable in complex applications. Contextual rewriting <ref> [20, 2, 8] </ref> is an extension to conditional rewriting [11] whereby the context surrounding the term being rewritten is used to relieve the conditions of conditional rewrites. (For instance, if the current focus of rewriting is a sub-term of lit in the clause flitg [ E, then the set of the
References-found: 20

