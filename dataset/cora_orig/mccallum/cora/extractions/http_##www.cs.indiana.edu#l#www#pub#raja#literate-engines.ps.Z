URL: http://www.cs.indiana.edu/l/www/pub/raja/literate-engines.ps.Z
Refering-URL: http://www.cs.indiana.edu/l/www/pub/raja/
Root-URL: http://www.cs.indiana.edu
Email: Email: raja@cs.indiana.edu  
Phone: Phone: 812-855-8702  
Title: Literate Engines in Lisp  
Author: Raja Sooriamurthi 
Address: Lindley Hall, 215  Bloomington, IN 47405  
Affiliation: Computer Science Department,  Indiana University,  
Note: Earlier version appears in: Proceedings of the Fifth International Lisp Users and Vendors Conference, Boston, MA, 1995.  
Abstract: Civilization advances by extending the number of important operations which we can perform without thinking about them. Abstract An engine is a programming language abstraction that implements timed preemption. Engines form a useful mechanism where bounded computation is needed. We describe an implementation of engines in Common Lisp and illustrate its functionality. We conclude with a discussion on how engines are being used in an ongoing project about goal-driven explanation. This paper is also an exercise in writing a literate program in Lisp.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Daniel G. Bobrow, Linda G. DeMichiel, Richard P. Gabriel, Sonya E Keene, Gregor Kiczales, and David A. Moon. </author> <title> Common lisp object system specification. </title> <type> Technical Report Document 88-002R, X3J13, </type> <year> 1988. </year> <note> Also appears in Lisp and Symbolic Computation 1 3/4, January, 1989 245-394 and as Chapter 28 of [18], 770-864. </note>
Reference-contexts: It is an object-oriented system written in CLOS <ref> [1, 9] </ref>. The system consists of a planner functioning in a simple simulated world and a case-based explainer [15] integrated across a blackboard.
Reference: [2] <institution> Computer Science Laboratory, Texas Instruments Inc., Dallas, Texas. </institution> <note> TI Scheme language reference manual, 1986. (TI Scheme was also released as PC-Scheme.). </note>
Reference-contexts: They also provide the ability to resume a suspended computation on demand. Engines were first introduced as an extension to the Scheme-84 interpreter [5]. Since then they have also been available in other Scheme systems (e.g., Chez scheme [3] and PC-scheme <ref> [2] </ref>). The Scheme implementations of engines are built upon the fact that in Scheme continuations are first-class objects and the programmer has access to the current continuation at any point by means of the reification procedure call-with-current-continuation (also called call/cc). Common Lisp does not directly support first class continuations.
Reference: [3] <author> R. Kent Dybvig. </author> <title> The Scheme Programming Language. </title> <publisher> Prentice Hall, </publisher> <year> 1987. </year> <note> (Second edition in preparation. Expected in October 1995.). </note>
Reference-contexts: They also provide the ability to resume a suspended computation on demand. Engines were first introduced as an extension to the Scheme-84 interpreter [5]. Since then they have also been available in other Scheme systems (e.g., Chez scheme <ref> [3] </ref> and PC-scheme [2]). The Scheme implementations of engines are built upon the fact that in Scheme continuations are first-class objects and the programmer has access to the current continuation at any point by means of the reification procedure call-with-current-continuation (also called call/cc).
Reference: [4] <author> R. Kent Dybvig and Hieb Robert. </author> <title> Engines from continuations. </title> <type> Technical Report 254, </type> <institution> Indiana University, Computer Science Department, </institution> <month> July </month> <year> 1988. </year>
Reference-contexts: Hence a Scheme style implementation of engines in terms of continuations is not directly possible. However we could convert the Lisp code to Continuation Passing Style (CPS) [6] thereby explicitly creating and manipulating continuations. The engine implementation could then parallel that of Dybvig & Hieb <ref> [4] </ref>. In this paper we show how engines can be implemented in Common Lisp on top of a multitasking facility. Though multitasking is not part of ANSI Common Lisp most Lisp systems provide some version.
Reference: [5] <author> Daniel P Friedman, Christopher T. Haynes, Eugene Kohlbecker, and Mitchell Wand. </author> <title> The scheme 84 interim reference manual. </title> <type> Technical Report 153, </type> <institution> Indiana University, Computer Science Department, </institution> <month> June </month> <year> 1985. </year>
Reference-contexts: Engines allow a process to be preempted after a prespecified amount of computation has occurred. They also provide the ability to resume a suspended computation on demand. Engines were first introduced as an extension to the Scheme-84 interpreter <ref> [5] </ref>. Since then they have also been available in other Scheme systems (e.g., Chez scheme [3] and PC-scheme [2]).
Reference: [6] <author> Daniel P. Friedman, Mitchell Wand, and Christopher T. Haynes. </author> <title> Essentials of Programming Languages. </title> <publisher> MIT Press / McGraw Hill Press, </publisher> <year> 1992. </year>
Reference-contexts: Common Lisp does not directly support first class continuations. Hence a Scheme style implementation of engines in terms of continuations is not directly possible. However we could convert the Lisp code to Continuation Passing Style (CPS) <ref> [6] </ref> thereby explicitly creating and manipulating continuations. The engine implementation could then parallel that of Dybvig & Hieb [4]. In this paper we show how engines can be implemented in Common Lisp on top of a multitasking facility.
Reference: [7] <author> Christopher T. Haynes and Daniel P. Friedman. </author> <title> Engines build process abstractions. </title> <booktitle> Proceedings of the 1984 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 18-24, </pages> <year> 1984. </year>
Reference-contexts: Primarily the ability to preempt a process from running and to be able to resume that process at a later time have been capabilities relegated to an operating system. In 1984 Haynes and Friedman <ref> [7, 8] </ref> introduced a programming language abstraction termed engines 1 for timed preemption. Engines allow a process to be preempted after a prespecified amount of computation has occurred. They also provide the ability to resume a suspended computation on demand.
Reference: [8] <author> Christopher T Haynes and Daniel P. Friedman. </author> <title> Abstracting timed preemption with engines. </title> <journal> Journal of Computer Languages, </journal> <volume> 12(2) </volume> <pages> 109-121, </pages> <year> 1987. </year>
Reference-contexts: Primarily the ability to preempt a process from running and to be able to resume that process at a later time have been capabilities relegated to an operating system. In 1984 Haynes and Friedman <ref> [7, 8] </ref> introduced a programming language abstraction termed engines 1 for timed preemption. Engines allow a process to be preempted after a prespecified amount of computation has occurred. They also provide the ability to resume a suspended computation on demand.
Reference: [9] <author> Sonya E. Keene. </author> <title> Object-Oriented Programming in Common Lisp. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1989. </year>
Reference-contexts: It is an object-oriented system written in CLOS <ref> [1, 9] </ref>. The system consists of a planner functioning in a simple simulated world and a case-based explainer [15] integrated across a blackboard.
Reference: [10] <author> Donald E. Knuth. </author> <title> Literate Programming. </title> <type> CSLI, </type> <institution> Stanford University, Stanford, </institution> <address> CA, </address> <year> 1992. </year>
Reference-contexts: Literate programming is a methodology introduced by Knuth in trying to attain his goal that programs should be works of literature and fun to read <ref> [10] </ref>. Figure-1 outlines the process of literate programming. A literate programmer combines both the documentation and code of a program into a single unit known as a web. Knuth's T E X and METAFONT are perhaps the best (and largest) known examples of this style of programming.
Reference: [11] <author> Janet Kolodner. </author> <title> Case-Based reasoning. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1994. </year>
Reference-contexts: It is an object-oriented system written in CLOS [1, 9]. The system consists of a planner functioning in a simple simulated world and a case-based explainer [15] integrated across a blackboard. Case-based explanation applies the problem solving paradigm of case-based reasoning <ref> [11] </ref> to the problem of formulating explanations: new explanations are formed by adapting explanations that had been applied to similar prior problems. The schematic representation of the system is given in Figure-4.
Reference: [12] <author> David B. Leake. </author> <title> Issues in goal-driven explanation. </title> <editor> In Mariie desJardins and Ashwin Ram, editors, </editor> <booktitle> Working notes of the AAAI Spring Symposium in goal-driven learning, </booktitle> <pages> pages 72-79, </pages> <year> 1994. </year>
Reference-contexts: In this section we describe the proposed use of engines in an ongoing project for goal-driven explanation, gobie 3 . (Further details about gobie and the motivations behind the project may be found in <ref> [17, 12] </ref>.) gobie is a system for performing explanation in a dynamic goal-driven manner. It is an object-oriented system written in CLOS [1, 9]. The system consists of a planner functioning in a simple simulated world and a case-based explainer [15] integrated across a blackboard. <p> The schematic representation of the system is given in Figure-4. In gobie the explanation process is shaped by ongoing and strategic decisions as the explainer interacts with its environment (the simulated world). Our model of explanation, termed goal-driven interactive explanation (GDIE) <ref> [12] </ref> allows incremental information obtained by interaction with the environment to influence the explainer's goals and dynamically re-focus the explanation process. Given a goal the planner comes up with a collection of plans that may achieve the goal. gobie is a utility-based system.
Reference: [13] <author> Lucid Inc. </author> <title> Lucid Common Lisp: Advanced User's Guide, </title> <booktitle> 2nd edition, </booktitle> <month> September </month> <year> 1991. </year>
Reference-contexts: Though multitasking is not part of ANSI Common Lisp most Lisp systems provide some version. To make things concrete we show our implementation of engines on top of the multitasking facility in Lucid Common Lisp <ref> [13] </ref>. We first discuss the functionality of engines and what is required to implement them. This is followed by a description of our implementation of engines in Lucid Common Lisp. This implementation can easily be translated to any other Lisp system supporting multitasking. <p> Lucid Common Lisp (and other Common Lisps) provides a multitasking facility <ref> [13] </ref>. Using this facility a group of processes can be created. Each of the processes are then run in a prioritized round robin fashion for a specified amount of time. A process that is either waiting to run or is running is termed an active process.
Reference: [14] <author> Norman Ramsey. </author> <title> Literate programming simplified. </title> <journal> IEEE Software, </journal> <volume> 11(5) </volume> <pages> 97-105, </pages> <month> Sept </month> <year> 1994. </year>
Reference-contexts: the prevalence of multi-tasking systems in most versions of Common Lisp. 1 Eugene Kohlbecker is credited with coining the term engines for this abstraction. c fl 1995 Raja Sooriamurthi 2 Literate Programming in Lisp The programs in this paper have been written in a literary style using Norman Ramsey's noweb <ref> [14] </ref>. Literate programming is a methodology introduced by Knuth in trying to attain his goal that programs should be works of literature and fun to read [10]. Figure-1 outlines the process of literate programming.
Reference: [15] <author> Roger C. Schank, Alex Kass, and Christopher K. Riesbeck. </author> <title> Inside Case-Based Explanation. </title> <publisher> Lawrence Erlbaum Associates, Inc., </publisher> <address> Hillsdale, New Jersey, </address> <year> 1994. </year>
Reference-contexts: It is an object-oriented system written in CLOS [1, 9]. The system consists of a planner functioning in a simple simulated world and a case-based explainer <ref> [15] </ref> integrated across a blackboard. Case-based explanation applies the problem solving paradigm of case-based reasoning [11] to the problem of formulating explanations: new explanations are formed by adapting explanations that had been applied to similar prior problems. The schematic representation of the system is given in Figure-4.
Reference: [16] <author> Raja Sooriamurthi. </author> <title> A scheme word count program | a tutorial introduction to literate programming in scheme. Unpublished tutorial handout, </title> <month> September </month> <year> 1995. </year>
Reference-contexts: This paper and the Lisp code for our engine system have both been derived from the same noweb file. The interactive nature of Lisp combined with the support of the noweb-mode Emacs mode by Thorsten Ohl makes Lisp programming under Emacs an effective literary programming environment <ref> [16] </ref>.
Reference: [17] <author> Raja Sooriamurthi and David B. Leake. </author> <title> An architecture for goal-driven explanation. </title> <editor> In John H. Stewman, editor, </editor> <booktitle> Proceedings of the eigth Florida Artificial Intelligence Research Symposium, </booktitle> <pages> pages 218-222. </pages> <booktitle> Florida Artificial Intelligence Research Symposium, </booktitle> <month> April </month> <year> 1995. </year>
Reference-contexts: In this section we describe the proposed use of engines in an ongoing project for goal-driven explanation, gobie 3 . (Further details about gobie and the motivations behind the project may be found in <ref> [17, 12] </ref>.) gobie is a system for performing explanation in a dynamic goal-driven manner. It is an object-oriented system written in CLOS [1, 9]. The system consists of a planner functioning in a simple simulated world and a case-based explainer [15] integrated across a blackboard.
Reference: [18] <author> Guy L. Steele Jr. </author> <title> Common Lisp the language. </title> <publisher> Digital Press, </publisher> <address> 2nd edition, </address> <year> 1990. </year> <note> Also available online from the CMU AI repository at http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/cltl2.html. 9 </note>
References-found: 18

