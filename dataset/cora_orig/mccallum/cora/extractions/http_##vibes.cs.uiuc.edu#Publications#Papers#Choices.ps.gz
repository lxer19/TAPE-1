URL: http://vibes.cs.uiuc.edu/Publications/Papers/Choices.ps.gz
Refering-URL: http://vibes.cs.uiuc.edu/Publications/publications.htm
Root-URL: http://www.cs.uiuc.edu
Title: The Performance of An Object-Oriented, Parallel Operating System  
Author: David R. Kohr, Jr. Xingbin Zhang Daniel A. Reed Mustafizur Rahman 
Address: Urbana, Illinois 61801  Amherst, Massachusetts 01003  
Affiliation: Department of Computer Science University of Illinois  Department of Computer Science University of Massachusetts at Amherst  
Abstract: The nascent and rapidly evolving state of parallel systems often leaves parallel application developers at the mercy of inefficient, inflexible operating system software. Given the relatively primitive state of parallel systems software, maximizing the performance of parallel applications not only requires judicious tuning of the application software, but occasionally, the replacement of specific system software modules with others that can more readily respond to the imposed pattern of resource demands. To assess the feasibility of application and performance tuning via malleable system software and to understand the performance penalties for detailed operating system performance data capture, we describe a set of performance instrumentation techniques for parallel, object-oriented operating systems and a set of performance experiments with Choices, an experimental, object-oriented operating system designed for use with parallel systems. These performance experiments show that (a) the performance overhead for operating system data capture is modest, (b) the penalty for malleable, object-oriented operating systems is negligible, but (c) techniques are needed to strictly enforce adherence of implementation to design if operating system modules are to be replaced.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Campbell, R., and Islam, N. </author> <title> A Parallel Ob ject-Oriented Operating System. In Research Directions in Concurrent Object-Oriented Programming (1992), </title> <editor> G. Agha, P. Wegner, and A. Yonezawa, Eds., </editor> <publisher> MIT Press. </publisher>
Reference-contexts: Instead, a building block approach is needed that allows one to assemble operating system modules in a variety of ways to accommodate specific application needs. In this paper, we describe a set of performance experiments with Choices <ref> [1] </ref>, an experimental, object-oriented operating system designed for use with parallel systems. <p> Later, the focus shifted to the logical organization of single processor operating systems (e.g., kernels, modularization, and process hierarchies) and then to distributed system models (e.g., remote procedure calls and client/server models). Choices <ref> [1] </ref> is a research operating system, designed to promote experimentation with new operating system design mechanisms and with new resource management policies. By separating mechanism and policy, Choices was designed to encourage experimentation with both. Mechanisms permit reconfiguration of operating system components to support new parallel architectures and applications.
Reference: [2] <author> Campbell, R. H., Islam, N., Johnson, R., Kougiouris, P., and Madany, P. </author> <title> Choices, Frameworks and Refinement. </title> <booktitle> In Object-Orientation in Operating Systems (Palo Alto, </booktitle> <address> CA, </address> <month> Oct. </month> <year> 1991), </year> <editor> Luis-Felipe Cabrera and Vincent Russo, and Marc Shapiro, Ed., </editor> <publisher> IEEE Computer Society Press, </publisher> <pages> pp. 9-15. </pages>
Reference-contexts: The object-oriented application interface has a name server that implements inheritance and polymorphism and provides access to system services, local and remote servers, and persistent objects. In the Choices design, a conceptual framework subsumes the conventional organization of an operating system as a group of layers <ref> [2] </ref>. The framework for the system provides generalized components and constraints to which the specialized subframeworks must conform.
Reference: [3] <author> Intel. </author> <title> Application Tool User's Guide. </title> <institution> Intel Supercomputer Systems Division, Beaverton, Oregon, </institution> <month> Oct. </month> <year> 1993. </year> <month> 22 </month>
Reference-contexts: The belief is based on our implementation of similar instrumentation on systems with tens to hundreds of processors [8] and the use of these techniques on other massively parallel systems <ref> [3] </ref> that have hundreds of processors. 6 Experimental Data Analysis Using the native Choices operating system instrumentation and the portable application instrumentation, we instrumented members of the SPLASH benchmark suite to assess the performance of both Choices and Umax, Encore's parallel Unix, on a two processor Encore Multimax 320.
Reference: [4] <author> Lehr, T., Black, D., Segall, Z., and Vrsalovic, D. </author> <title> Visualizing Context-Switches of Parallel Programs Using PIE and the Mach Kernel Monitor. </title> <booktitle> In Proceedings of the 1990 International Conference on Parallel Processing (Aug. </booktitle> <year> 1990), </year> <pages> pp. 298-299. </pages>
Reference-contexts: only 2 To avoid potential effects of compiler differences, we also used the C++ versions of the SPLASH codes for our Unix performance experiments. 9 a subset of the Choices modules. 3 Given constraints on the number of possible operating system instrumentation points, context switch instrumentation provides the most information <ref> [4] </ref> | it exposes not only the decisions of the task scheduler, but also the interactions of application tasks and the execution patterns of service daemons.
Reference: [5] <author> Malony, A. D. </author> <title> Performance Observability. </title> <type> PhD thesis, </type> <institution> University of Illinois at Urbana-Champaign, Department of Computer Science, </institution> <month> Aug. </month> <year> 1990. </year>
Reference-contexts: However, collection of detailed performance data using software instrumentation is not without price: instrumentation perturbs the measured system and may result in observed behavior and event orders that would not be feasible in a system without instrumentation <ref> [5] </ref>. <p> Indirect perturbations are more pernicious, and in the worst case may require a complete system simulation to recover the event order that would have occurred had instrumentation not been present <ref> [5] </ref>. For example, if the events have differing priorities (e.g., system and user task resource requests), or are time dependent (e.g., scheduler time slice interrupts), software instrumentation may change the event order or even alter the number of events.
Reference: [6] <author> Malony, A. D., Reed, D. A., and Wijshoff, H. </author> <title> Performance Measurement Intrusion and Perturbation Analysis. </title> <journal> IEEE Transactions on Parallel and Distributed Systems 3, </journal> <month> 4 (July </month> <year> 1992), </year> <pages> 433-450. </pages>
Reference-contexts: Unfortunately, data volume and accuracy are antithetic; most instrumentation and data capture techniques induce some perturbation (e.g., by modifying code or by interrupting a processor to record data) <ref> [6, 9] </ref>. Operating system performance instrumentation imposes particularly thorny problems because operating systems are, by their nature, reactive, responding to external stimuli. Changing the operating system response time for requests often will also change the pattern of requests. <p> To maximize flexibility, the Choices instrumentation supports combinations of inherited and customized instrumentation. Based on these issues, and our instrumentation experiences, both with Choices and with other systems <ref> [6, 9] </ref> we believe that parallel operating system instrumentation must be general-purpose, supporting instrumentation and data capture from a variety of operating system modules using a common interface, isolated, with minimal dependence on operating system services, dynamic, with triggers to dynamically enable and disable performance data capture based on data volume <p> Hence, the perturbation induced on each processor is identical, and there is no skewing of the tasks on different processors. By recording the total time needed to dump all data buffers, we can postprocess the performance data and adjust the observed event times to eliminate these costs <ref> [6] </ref>. <p> Under constrained conditions, the effects of direct perturbations can be removed by post-processing the captured performance data to adjust the observed event times <ref> [6] </ref>. 4 More generally, inserted software instrumentation has more subtle effects (e.g., displacing data values from the cache or causing pipeline stalls), the exact cost of each instrumentation point is not known, and exact compensation for instrumentation effects is not possible.
Reference: [7] <author> Rahman, M. </author> <title> Choices Instrumentation Support. </title> <type> Tech. rep., </type> <institution> University of Illinois at Urbana-Champaign, Department of Computer Science, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: Each type of instrumentation object can be used to capture either application or operating system performance data. relationships. Although each is discussed briefly below, space limitations preclude a complete description; see <ref> [7] </ref> for details. The classes for event tracing, counting, and timing are all derived from the abstract Instrument base class. This base class provides methods to temporarily suspend (and later resume) data recording, as well as to reset the instrumentation object.
Reference: [8] <author> Reed, D. A., Aydt, R. A., Noe, R. J., Roth, P. C., Shields, K. A., Schwartz, B. W., and Tavera, L. F. </author> <title> Scalable Performance Analysis: The Pablo Performance Analysis Environment. </title> <booktitle> In Proceedings of the Scalable Parallel Libraries Conference, </booktitle> <editor> A. Skjellum, Ed. </editor> <publisher> IEEE Computer Society, </publisher> <year> 1993. </year>
Reference-contexts: Although resource limitations did not allow us to conduct experiments with larger numbers of processors, we are confident that this approach scales to substantial numbers of processors. The belief is based on our implementation of similar instrumentation on systems with tens to hundreds of processors <ref> [8] </ref> and the use of these techniques on other massively parallel systems [3] that have hundreds of processors. 6 Experimental Data Analysis Using the native Choices operating system instrumentation and the portable application instrumentation, we instrumented members of the SPLASH benchmark suite to assess the performance of both Choices and Umax,
Reference: [9] <author> Reed, D. A., and Rudolph, D. C. </author> <title> Experiences with Hypercube Operating System Instrumentation. </title> <note> International Journal of High-Speed Computing (Dec. </note> <year> 1989), </year> <pages> 517-542. </pages>
Reference-contexts: Unfortunately, data volume and accuracy are antithetic; most instrumentation and data capture techniques induce some perturbation (e.g., by modifying code or by interrupting a processor to record data) <ref> [6, 9] </ref>. Operating system performance instrumentation imposes particularly thorny problems because operating systems are, by their nature, reactive, responding to external stimuli. Changing the operating system response time for requests often will also change the pattern of requests. <p> To maximize flexibility, the Choices instrumentation supports combinations of inherited and customized instrumentation. Based on these issues, and our instrumentation experiences, both with Choices and with other systems <ref> [6, 9] </ref> we believe that parallel operating system instrumentation must be general-purpose, supporting instrumentation and data capture from a variety of operating system modules using a common interface, isolated, with minimal dependence on operating system services, dynamic, with triggers to dynamically enable and disable performance data capture based on data volume
Reference: [10] <author> Russo, V. F. </author> <title> An Object-Oriented Operating System. </title> <type> PhD thesis, </type> <institution> University of Illinois at Urbana-Champaign, Department of Computer Science, </institution> <month> Oct. </month> <year> 1990. </year>
Reference-contexts: Generic components are customized through object-oriented inheritance and specialization to match the specific concurrency requirements of applications. 2.1 Design Philosophy Choices has, as its kernel, a dynamic collection of C++ objects. System resources, mechanisms, and policies are represented as objects that belong to a class hierarchy <ref> [10] </ref>. The object-oriented application interface has a name server that implements inheritance and polymorphism and provides access to system services, local and remote servers, and persistent objects. In the Choices design, a conceptual framework subsumes the conventional organization of an operating system as a group of layers [2]. <p> First, the Choices application programming interface does not support system calls in the traditional sense; instead, the system supports requests for operating system services via proxies <ref> [10, 12] </ref>, C++ interfaces to the system software that allow interaction with objects that are not in the same protection domain. <p> Except for performance penalties attributable to process emulation or untuned system services (e.g., disk input/output), the performance of applications on Choices is competitive with Unix. This is a system-level confirmation of the micro-scale measurements reported earlier <ref> [10] </ref>. 7 Operating System Malleability The last of our research goals was to assess the feasibility of application performance tuning by adapting the operating system resource management policies to better match application resource demands. In this we were unsuccessful.
Reference: [11] <author> Russo, V. F., Madany, P. W., and Campbell, R. H. </author> <title> C++ and Operating Systems Performance: A Case Study. </title> <booktitle> In Proceedings of the 1990 USENIX C++ Conference (San Francisco, </booktitle> <address> California, </address> <year> 1990), </year> <pages> pp. 103-114. </pages>
Reference-contexts: Finally, because all processing is suspended during buffer dumping, the instrumentation system does not contend with application processes for access to disks. 7 4 Performance Analysis Methodology Earlier Choices performance measurements <ref> [11] </ref> focused on the cost of individual system operations (e.g., system calls) and the costs of virtual function table lookups imposed by a C++ implementation. <p> Except for performance penalties attributable to process emulation or untuned system services (e.g., disk input/output), the performance of applications on Choices is competitive with Unix. This is a system-level confirmation of the micro-scale measurements reported earlier <ref> [11] </ref>. We also observed that detailed operating system performance data could be obtained at modest cost via a flexible, general-purpose instrumentation infrastructure based on ob ject-oriented design principles. Central to efficient performance data capture is a high resolution, low access latency, memory-mapped hardware clock.
Reference: [12] <author> Shapiro, M. </author> <title> Structure and Encapsulation in Distributed Systems: The Proxy Principle. </title> <booktitle> In Proceedings of the Sixth International Conference on Distributed Systems (1986). </booktitle>
Reference-contexts: First, the Choices application programming interface does not support system calls in the traditional sense; instead, the system supports requests for operating system services via proxies <ref> [10, 12] </ref>, C++ interfaces to the system software that allow interaction with objects that are not in the same protection domain.

References-found: 12

