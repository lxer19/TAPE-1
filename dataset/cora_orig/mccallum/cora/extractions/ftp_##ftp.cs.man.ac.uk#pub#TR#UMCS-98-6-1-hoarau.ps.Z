URL: ftp://ftp.cs.man.ac.uk/pub/TR/UMCS-98-6-1-hoarau.ps.Z
Refering-URL: ftp://ftp.cs.man.ac.uk/pub/TR/UMCS-98-6-1.html
Root-URL: http://www.cs.man.ac.uk
Email: E-mail fSebastien.Hoarau, fredg@univ-reunion.fr  
Title: Inferring and Compiling Termination for Constraint Logic Programs  
Author: Sebastien Hoarau, Fred Mesnard 
Web: URL www.univ-reunion.fr/gcc  
Address: BP 7151 97715 Saint-Denis Messag. Cedex 9, FRANCE  
Affiliation: IREMIA, Universite de La Reunion  
Abstract: This paper presents an automated method that deals with termination of constraint logic programs in two steps. First, the method infers a set of potentially terminating classes (using approximation techniques and boolean mu-calculus). By "potentially", we mean that for each of these classes, one can find a static order over the literals of the clauses of the program to ensure termination. Then, given a terminating class among those computed at the first step, the second step consists of a "compilation" of the original program to another one by reordering literals. For this new program, the universal left-termination of any query of the considered class is guaranteed. The method has been implemented. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K.R. Apt and D. Pedreschi. </author> <title> Studies in pure Prolog: termination. </title> <booktitle> In Proceedings Esprit symposium on computational logic, </booktitle> <pages> pages 150-176. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference: [2] <author> S. Colin, F. Mesnard, and A. Rauzy. </author> <title> Constraint logic programming and mu-calculus. </title> <booktitle> ERCIM/COMPULOG Workshop on Constraints, </booktitle> <year> 1997. </year>
Reference-contexts: Note that the above system of boolean formulae can be used not only to check that some relations P re p 's are correct left-termination conditions but also to compute the P re p 's by means of boolean mu-calculus <ref> [2] </ref>. Example 3.7 Let us consider the CLP (N ) program, power-4, of the introduction. We compute: fl s (x; y) = x _ y, P ost s (x; y) = x ^ y, fl p (x; y) = 1 and P ost p (x; y) = x ^ y.
Reference: [3] <author> D. De Schreye and S. Decorte. </author> <title> Termination of logic programs : the never-ending story. </title> <journal> The Journal of Logic Programming, </journal> <volume> 12 </volume> <pages> 1-66, </pages> <year> 1993. </year>
Reference-contexts: 1 Introduction Many research works have been devoted to termination analysis of (constraint) logic programs in recent years, as shown by the survey <ref> [3] </ref>. For most researchers, the main problem is universal left-termination of a given class of queries. This is a somehow restricted view of logic programming. In [7], we addressed a broader question: find the classes of queries for which universal left-termination is guaranteed. <p> We note P ost p the boolean model of a predicate p because of the obvious link with the post condition of De Schreye and Decorte <ref> [3] </ref>.
Reference: [4] <author> M. Gabbrielli and G. Levi. </author> <title> Modelling answer constraints in constraint logic programs. </title> <publisher> In MIT Press, </publisher> <editor> editor, </editor> <booktitle> Proc. of ICLP'91, </booktitle> <pages> pages 238-252, </pages> <year> 1991. </year>
Reference-contexts: Let A O be an approximation, P be a CLP (O) program and S O P its semantics <ref> [4] </ref>.
Reference: [5] <author> J. Jaffar and M.J. Maher. </author> <title> Constraint logic programming: a survey. </title> <journal> J. Logic Programming, </journal> <volume> 19 </volume> <pages> 503-581, </pages> <year> 1994. </year>
Reference-contexts: Implementation issues are slightly discussed in section 6. 2 Preliminaries 2.1 CLP (O) Let us remind some notations and conventions about CLP introduced in <ref> [5] </ref>. For concision, we simplify the notations when we consider there is no ambiguity. Moreover, in concrete program examples, we use the Edinburgh syntax. In the following, we consider ideal CLP systems 2 without limit element. ~ t (resp. ~x) represents a sequence of terms (resp. distinct variables).
Reference: [6] <author> N. Lindenstrauss and Y. Sagiv. </author> <title> Automatic termination analysis of logic programs. </title> <booktitle> Proc. of the 14th ICLP, </booktitle> <pages> pages 63-77, </pages> <year> 1997. </year> <note> 4 in the full version of [6] available at: www.cs.huji.ac.il/naomil. 8 </note>
Reference-contexts: We cannot expect the timings given by <ref> [6] </ref> or [9] but we address a much more general problem. Note also that there is room for trying to optimize the control of a given logic with respect to a given terminating class of queries.
Reference: [7] <author> F. Mesnard. </author> <title> Inferring left-terminating classes of queries for constraint logic programs by means of approximations. </title> <booktitle> In Proc. of JICSLP'96, </booktitle> <pages> pages 7-21. </pages> <publisher> MIT Press, </publisher> <year> 1996. </year>
Reference-contexts: 1 Introduction Many research works have been devoted to termination analysis of (constraint) logic programs in recent years, as shown by the survey [3]. For most researchers, the main problem is universal left-termination of a given class of queries. This is a somehow restricted view of logic programming. In <ref> [7] </ref>, we addressed a broader question: find the classes of queries for which universal left-termination is guaranteed. Here we go one step further: automatically infer (larger) classes of queries such that there exists a static reordering of the bodies of the clauses which insures universal left-termination. <p> us consider the following CLP (N ) program: rule r 1 : p (X; Y) : s (X; Z); s (Z; Y): rule r 2 : s (0; 0): rule r 3 : s (X + 1; Y + 2X + 1) : s (X; Y): The method described in <ref> [7] </ref> can infer that " X bounded; p (X; Y )" is a left-terminating query. Nevertheless, the resolution of the query Y 16; p (X; Y ) could terminate, if in the clause defining the predicate p, we prove Y 16; s (Z; Y ) before s (X; Z). <p> A predicate p is recursive if it is either directly recursive or mutually recursive. Otherwise p is non-recursive. 2.2 From CLP (O) to CLP (Bool) An approximation A O from O to consists in a pair of functions hA sx ; A sm i with some properties (see <ref> [7] </ref> for details). The main approximation we use is A B O which turns CLP (O) entities into boolean entities and which is the composition of two approximations: 1. <p> Let A O be an approximation, P be a CLP (O) program and S O P its semantics [4]. Then, the image of the semantics of P is included in the semantics of the image of P : Theorem 2.2 <ref> [7] </ref> A O O (P ) Here is a very useful property about the boolean approximation A B N : Proposition 2.3 (see [7] for details and examples) Let c 1 be a N -constraint, c 2 a B-cons traint s.t. <p> Then, the image of the semantics of P is included in the semantics of the image of P : Theorem 2.2 <ref> [7] </ref> A O O (P ) Here is a very useful property about the boolean approximation A B N : Proposition 2.3 (see [7] for details and examples) Let c 1 be a N -constraint, c 2 a B-cons traint s.t. A B N (c 1 ) ! B c 2 and t j _ j2J (^ i2I j x i ) a boolean term. <p> For another structure, we switch to CLP (N ) by an appropriated approximation. For any numerical constraint c, we write c B its boolean version. 3 3 Inferring left-termination conditions: the previous approach In <ref> [7] </ref>, for each predicate symbol p of a program P , a boolean term P re p is computed. <p> This procedure can be adapted to compute the coefficients of . Definition 3.3 Let P be a CLP (N ) program. Let p 2 p be a recursive predicate. Its set of maximal measures is always finite (see <ref> [7] </ref>). We write q p the number of maximal measures for a predicate p and p = f j p jp 2 p; 1 j q p g the set of associated maximal linear measures for p. <p> In other words, we can produce a Prolog program such that for any query of this class, universal left-termination is guaranteed. The approach described in <ref> [7] </ref> is now completely implemented in SICStus Prolog. For the work presented here, we have implemented the computation of fP re p g p2p as defined in the point 1 of the method of section 4. In the following table, we present some results on program tests found in N.
Reference: [8] <author> K. Sohn and A. Van Gelder. </author> <title> Termination detection in logic programs using argument sizes. </title> <booktitle> Proc. of PODS'91, </booktitle> <pages> pages 216-226, </pages> <year> 1991. </year>
Reference-contexts: Example 3.2 If we consider the CLP (N ) version of append program then, 1 (x; y; z) = x and 2 (x; y; z) = z are two linear measures. / The work of K. Sohn and A. Van Gelder <ref> [8] </ref> shows that there exists a complete procedure for deciding the existence of a linear measure. This procedure can be adapted to compute the coefficients of . Definition 3.3 Let P be a CLP (N ) program. Let p 2 p be a recursive predicate.
Reference: [9] <author> C. Speirs, Z. Somogyi, and H. Sondergaard. </author> <title> Termination analysis for Mercury. </title> <booktitle> Proc. of SAS'97, </booktitle> <year> 1997. </year> <month> 9 </month>
Reference-contexts: We cannot expect the timings given by [6] or <ref> [9] </ref> but we address a much more general problem. Note also that there is room for trying to optimize the control of a given logic with respect to a given terminating class of queries.
References-found: 9

