URL: ftp://ftp.eecs.umich.edu/people/aprakash/softeng/icsm94.ps.Z
Refering-URL: http://www.eecs.umich.edu/~aprakash/csrg_pub.html
Root-URL: http://www.cs.umich.edu
Title: Querying Source Code using an Algebraic Query Language a formal data model for source code,
Author: Santanu Paul Atul Prakash 
Note: SCA provides  
Address: Ann Arbor, MI-48105  
Affiliation: Dept. of Electrical Engineering and Computer Science University of Michigan,  
Abstract: Querying and analyzing source code interactively is a critical task in reverse engineering and program understanding. Current source code query systems lack sufficient formalism and offer limited query capabilities. In this paper, we introduce the formal framework of Source Code Algebra (SCA), and outline a source code query system based on it. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Al-Zoubi and A. Prakash. </author> <title> Software Change Analysis via Attributed Dependency Graphs. </title> <type> Technical Report CSE-TR-95-91, </type> <institution> Dept. of EECS, University of Michigan, </institution> <month> May </month> <year> 1991. </year> <note> Also in Software Maintenance, to appear. </note>
Reference-contexts: More sophisticated representation models include graphs or abstract syntax trees used in Rigi [16] and SCAN <ref> [1] </ref>, and the object-based representation used in Software Refinery 1 [21]. However, these models suffer from the lack of a non-procedural query language with well-defined operators, and lead to systems with little or no formal basis, limited querying power, and practically no scope for query optimization.
Reference: [2] <author> T. Biggerstaff, B.G. Mitbander, and D. Webster. </author> <title> The Concept Assignment Problem in Program Understanding. </title> <booktitle> In Proc. of the 15th International Conference on Software Engineering, </booktitle> <pages> pages 482-498, </pages> <year> 1993. </year>
Reference-contexts: Recovering the design of a such a system will necessarily involve close and careful scrutiny of its source code. The need for source code query tools has been articulated by Biggerstaff in terms of a "conceptual grep" <ref> [2] </ref>. The purpose of a source code querying tool is to help human reverse engineers indulge in plausible reasoning [2] or domain bridging [3] | an iterative process of guesswork and verification that leads them to a better understanding of what the source code is doing. <p> The need for source code query tools has been articulated by Biggerstaff in terms of a "conceptual grep" <ref> [2] </ref>. The purpose of a source code querying tool is to help human reverse engineers indulge in plausible reasoning [2] or domain bridging [3] | an iterative process of guesswork and verification that leads them to a better understanding of what the source code is doing. A reverse engineer may pose queries pertaining to different views of the source code. One view is based on composition relationships.
Reference: [3] <author> R. Brooks. </author> <title> Towards a Theory of Comprehension of Computer Programs. </title> <journal> International Journal of Man Machine Studies, </journal> <volume> 18 </volume> <pages> 543-554, </pages> <year> 1983. </year>
Reference-contexts: The need for source code query tools has been articulated by Biggerstaff in terms of a "conceptual grep" [2]. The purpose of a source code querying tool is to help human reverse engineers indulge in plausible reasoning [2] or domain bridging <ref> [3] </ref> | an iterative process of guesswork and verification that leads them to a better understanding of what the source code is doing. A reverse engineer may pose queries pertaining to different views of the source code. One view is based on composition relationships.
Reference: [4] <author> K. Bruce and P. Wegner. </author> <title> An Algebraic Model of Subtype and Inheritance. </title> <editor> In F. Bancilhon and P. Bune-man, editors, </editor> <booktitle> Advances in Database Programming Languages, chapter 5. </booktitle> <publisher> ACM Press, </publisher> <year> 1990. </year>
Reference-contexts: Bruce and Wegner have extended many-sorted algebras to generalized order-sorted algebras to incorporate subtypes <ref> [4] </ref>. Essentially, a type is a subtype of another if the former is behaviorally compatible with (i.e., can be substituted for) the latter. A generalized order-sorted algebra is thus a many-sorted algebra with a partial order defined on its sorts.
Reference: [5] <author> Y. Chen, M.Y. Nishimoto, and C.V. Ramamoor-thy. </author> <title> The C Information Abstraction System. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(3) </volume> <pages> 325-334, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: Support for source code querying has so far been limited to rudimentary, string searching tools like grep, awk, etc. (which are capable of handling only trivial queries), or to general-purpose database approaches that have limited querying power for the source code domain <ref> [5, 6, 14] </ref>. A fundamental problem in designing source code querying systems is the lack of adequate models that can be used to represent source code information and express queries. <p> A fundamental problem in designing source code querying systems is the lack of adequate models that can be used to represent source code information and express queries. The relational model, as used in several systems such as OMEGA [14], CIA <ref> [5] </ref>, and CIA++ [10], provides a formal query language but is too weak to model the detailed structural and flow information that arise in source code. <p> High-level queries in the appropriate form (e.g., graphical, commandline, relational, or pattern-based) will be translated into equivalent SCA expressions. For example, queries expressible in systems such as CIA <ref> [5] </ref>, SCRUPLE [18], Rigi [16], etc. can be mapped into equivalent SCA expressions. SCA expressions can then be evaluated using a standard SCA evaluator, which will serve as a common query processing engine. The analogy from relational database systems is the translation of SQL to expressions based on relational algebra.
Reference: [6] <author> L. Cleveland. </author> <title> A Program Understanding Support Environment. </title> <journal> IBM Systems Journal, </journal> <volume> 28(2) </volume> <pages> 324-344, </pages> <year> 1989. </year>
Reference-contexts: Support for source code querying has so far been limited to rudimentary, string searching tools like grep, awk, etc. (which are capable of handling only trivial queries), or to general-purpose database approaches that have limited querying power for the source code domain <ref> [5, 6, 14] </ref>. A fundamental problem in designing source code querying systems is the lack of adequate models that can be used to represent source code information and express queries.
Reference: [7] <author> E.F. Codd. </author> <title> A relational model for large shared data banks. </title> <journal> Communications of the ACM, </journal> <volume> 13(6) </volume> <pages> 377-387, </pages> <year> 1970. </year>
Reference-contexts: An algebra defines a model for representing source code information and gives a well-defined set of operators that can be used to make queries on the information. The analogy is the use of relational algebra <ref> [7] </ref> as the foundation for relational database systems. Algebras have also been used in the design of general-purpose query languages for the relational data model [7], the nested relational model [12], the extended relational model [25], the object model [15, 17], and also in the design of a domain-specific query language <p> The analogy is the use of relational algebra <ref> [7] </ref> as the foundation for relational database systems. Algebras have also been used in the design of general-purpose query languages for the relational data model [7], the nested relational model [12], the extended relational model [25], the object model [15, 17], and also in the design of a domain-specific query language for structured office documents [11].
Reference: [8] <author> T.A. Corbi. </author> <title> Program Understanding: Challenge for the 1990s. </title> <journal> IBM Systems Journal, </journal> <volume> 28(2) </volume> <pages> 294-306, </pages> <year> 1989. </year>
Reference-contexts: An early conclusion in this area of study is that a complete automation of the reverse engineering process is not feasible <ref> [8] </ref>. It is felt that the reverse engineering of real systems must involve substantial human participation. This acceptance, in turn, leads to a critical need for software tools that can assist or support the human reverse engineers in their task.
Reference: [9] <author> J.A. Goguen, J.W. Thatcher, and E.G. Wagner. </author> <title> An Initial Algebra Approach to the specification, correctness, and implementation of abstract data types. In R.T. Yeh, editor, </title> <booktitle> Current Trends in Programming Methodology, Vol:IV, chapter 5. </booktitle> <publisher> Prentice-Hall, </publisher> <address> Engle-wood Cliffs, N.J., </address> <year> 1978. </year>
Reference-contexts: relational algebra because it must 1. support a wide variety of atomic and composite data types 2. incorporate the notion of a type hierarchy within the algebra itself The first condition can be satisfied if, instead of using the class of one-sorted algebras, we use the class of many-sorted algebras <ref> [9] </ref> to model SCA. Unlike one-sorted algebras that model a single data type, many-sorted algebras can model a variety of atomic and composite data types and the operations on those types within a single algebraic framework.
Reference: [10] <author> J.E. Grass. </author> <title> Object-Oriented Design Archaeology with CIA++. </title> <journal> Computing Systems: The Journal of the USENIX Association, </journal> <volume> 5(1) </volume> <pages> 5-67, </pages> <month> Winter </month> <year> 1992. </year>
Reference-contexts: A fundamental problem in designing source code querying systems is the lack of adequate models that can be used to represent source code information and express queries. The relational model, as used in several systems such as OMEGA [14], CIA [5], and CIA++ <ref> [10] </ref>, provides a formal query language but is too weak to model the detailed structural and flow information that arise in source code. More sophisticated representation models include graphs or abstract syntax trees used in Rigi [16] and SCAN [1], and the object-based representation used in Software Refinery 1 [21].
Reference: [11] <author> R.H. Guting, R. Zicari, </author> <title> and D.M. Choy. An Algebra for Structured Office Documents. </title> <journal> ACM Transactions on Office Information Systems, </journal> <volume> 7(4) </volume> <pages> 123-157, </pages> <year> 1989. </year>
Reference-contexts: Algebras have also been used in the design of general-purpose query languages for the relational data model [7], the nested relational model [12], the extended relational model [25], the object model [15, 17], and also in the design of a domain-specific query language for structured office documents <ref> [11] </ref>. The benefits of using an algebra as the basis for a query language include the ability to provide formal specifications for query language constructs, the ability to use the algebra itself as a powerful low-level query language, and opportunities for query optimization.
Reference: [12] <author> G. Jaeschke. </author> <title> Recursive Algebra for relations with relation-valued attributes. </title> <type> Technical Report TR 85.03.002, </type> <institution> IBM Heidelberg Scientific Center, Heidel-berg, Germany, </institution> <year> 1985. </year>
Reference-contexts: The analogy is the use of relational algebra [7] as the foundation for relational database systems. Algebras have also been used in the design of general-purpose query languages for the relational data model [7], the nested relational model <ref> [12] </ref>, the extended relational model [25], the object model [15, 17], and also in the design of a domain-specific query language for structured office documents [11].
Reference: [13] <author> K. Kennedy. </author> <title> Program Flow Analysis: theory and applications, chapter 1. </title> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: Methods are a standard feature of object-oriented data models and can be used to introduce complex and specialized algorithms into the data model. For example, efficient algorithms for data flow analysis such as live variable analysis, available expression analysis, etc. <ref> [13] </ref> can be used to compute the attributes such as "live" (see STATEMENT in Figure 2), which computes the set of live variables for a given statement, and their respective next statements in the "uses" chain.
Reference: [14] <author> M.A. Linton. </author> <title> Implementing Relational Views of Programs. </title> <booktitle> In Proc. of ACM SIGSOFT/SIGPLAN Software Engineering Symposium, </booktitle> <month> May </month> <year> 1984. </year> <title> Practical Software Development Environment. </title>
Reference-contexts: Support for source code querying has so far been limited to rudimentary, string searching tools like grep, awk, etc. (which are capable of handling only trivial queries), or to general-purpose database approaches that have limited querying power for the source code domain <ref> [5, 6, 14] </ref>. A fundamental problem in designing source code querying systems is the lack of adequate models that can be used to represent source code information and express queries. <p> A fundamental problem in designing source code querying systems is the lack of adequate models that can be used to represent source code information and express queries. The relational model, as used in several systems such as OMEGA <ref> [14] </ref>, CIA [5], and CIA++ [10], provides a formal query language but is too weak to model the detailed structural and flow information that arise in source code.
Reference: [15] <author> F. Manola and U. Dayal. PDM: </author> <title> an Object-oriented Data Model. </title> <booktitle> In Proc. of Intl. Workshop on Object-oriented Database Systems, </booktitle> <pages> pages 18-25, </pages> <month> September </month> <year> 1986. </year>
Reference-contexts: The analogy is the use of relational algebra [7] as the foundation for relational database systems. Algebras have also been used in the design of general-purpose query languages for the relational data model [7], the nested relational model [12], the extended relational model [25], the object model <ref> [15, 17] </ref>, and also in the design of a domain-specific query language for structured office documents [11].
Reference: [16] <author> H.A. Muller, M.A Orgun, S.R. Tilley, and J.S. </author> <note> Uhl. </note>
Reference-contexts: More sophisticated representation models include graphs or abstract syntax trees used in Rigi <ref> [16] </ref> and SCAN [1], and the object-based representation used in Software Refinery 1 [21]. However, these models suffer from the lack of a non-procedural query language with well-defined operators, and lead to systems with little or no formal basis, limited querying power, and practically no scope for query optimization. <p> High-level queries in the appropriate form (e.g., graphical, commandline, relational, or pattern-based) will be translated into equivalent SCA expressions. For example, queries expressible in systems such as CIA [5], SCRUPLE [18], Rigi <ref> [16] </ref>, etc. can be mapped into equivalent SCA expressions. SCA expressions can then be evaluated using a standard SCA evaluator, which will serve as a common query processing engine. The analogy from relational database systems is the translation of SQL to expressions based on relational algebra.
References-found: 16

