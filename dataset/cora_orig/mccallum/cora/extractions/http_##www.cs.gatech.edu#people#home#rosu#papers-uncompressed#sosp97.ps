URL: http://www.cs.gatech.edu/people/home/rosu/papers-uncompressed/sosp97.ps
Refering-URL: http://www.cs.gatech.edu/people/home/rosu/cv/cv.html
Root-URL: 
Email: mbj@microsoft.com,  daniela@cc.gatech.edu, rosu@cc.gatech.edu  
Title: CPU Reservations and Time Constraints: Efficient, Predictable Scheduling of Independent Activities CPU Reservations, which are
Author: Michael B. Jones Daniela Rou, Marcel-Ctlin Rou 
Note: Reservations,  this work.  
Web: http://research.microsoft.com/~mbj  
Address: One Microsoft Way, Building 9s/1 Redmond, WA 98052  Atlanta, GA 30332-0280  
Affiliation: Microsoft Research, Microsoft Corporation  College of Computing, Georgia Institute of Technology  
Abstract: Workstations and personal computers are increasingly being used for applications with real-time characteristics such as speech understanding and synthesis, media computations and I/O, and animation, often concurrently executed with traditional non-real-time workloads. This paper presents a system that can schedule multiple independent activities so that: activities can obtain minimum guaranteed execution rates with applicationspecified reservation granularities via CPU 
Abstract-found: 1
Intro-found: 1
Reference: [Anderson et al. 90] <author> David P. Anderson, ShinYuan Tzou, Robert Wahbe, Ramesh Govindan, and Martin Andrews. </author> <title> Support for Continuous Media in the DASH System, </title> <booktitle> In Proceedings of the 10th International Conference on Distributed Computing Systems, </booktitle> <address> Paris, France, </address> <month> May </month> <year> 1990. </year> <pages> pp. 54-61. </pages>
Reference-contexts: Nemesis [Leslie et al. 95] and DASH <ref> [Anderson et al. 90] </ref> use an earliest-deadline-first scheduler to implement periodic CPU reservations. However, in these systems one task can cause another to miss its deadlines something our system was designed to prevent.
Reference: [Anderson et al. 91] <author> Thomas E. Anderson, Brian N. Bershad, Edward D. Lazowska and, Henry M. Levy. </author> <title> Scheduler Activations: Effective Kernel Support for the User-Level Management of Parallelism. </title> <booktitle> In Proceedings of the 13 ACM Symposium on Operating Systems Principles, Asilomar, </booktitle> <address> CA, </address> <pages> pp. 95-109, </pages> <month> Oct. </month> <year> 1991. </year>
Reference-contexts: Applications could even be given interfaces by which they could directly influence the construction of their portions of the graph, exposing as much mechanism as possible, perhaps in a manner analogous to Scheduler Activations <ref> [Anderson et al. 91] </ref>. Another possibility is refining the scheduling graph construction algorithm. While we built a workable, efficient algorithm, it can doubtless be improved upon in numerous ways that provide benefit to applications. Finally, there is always more to be learned by continuing to run real applications. 9.
Reference: [Bollela & Jeffay 95] <author> Gregory Bollela and Kevin Jeffay. </author> <title> Support For Real-Time Computing Within General Purpose Operating Systems: Supporting CoResident Operating Systems. </title> <booktitle> In Proceedings of the IEEE Real-Time Technology and Applications Symposium, </booktitle> <address> Chicago, IL, </address> <pages> pp. 4-14, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: Even if no application is blocked, one or both kernel activities will usually be, giving a typical minimum timesharing share of 15%. [Deng et al. 96] uses fixed percentage CPU reservations to ensure constant execution rates for real-time applications. Similarly, <ref> [Bollela & Jeffay 95] </ref> partitions time between timesharing and real-time operating systems, periodically switching between them. While starvation of non-real-time tasks is eliminated, a drawback of these systems is that tasks in one time partition can not take advantage of any free time in others.
Reference: [Bolosky et al. 96] <author> William J. Bolosky, Joseph S. Barrera, III, Richard P. Draves, Robert P. Fitzgerald, Garth A. Gibson, Michael B. Jones, Steven P. Levi, Nathan P. Myhrvold, Richard F. Rashid. </author> <title> The Tiger Video Fileserver. </title> <booktitle> In Proceedings of the Sixth International Workshop on Network and Operating System Support for Digital Audio and Video, </booktitle> <address> Zushi, Japan. </address> <publisher> IEEE Computer Society, </publisher> <month> Apr. </month> <year> 1996. </year>
Reference-contexts: In this case, the application is a software-only AVI (Audio Video Interleaved) video player playing a 3 minute, 45 second music video stored at 15 frames per second (one frame every 66.7ms), delivered from a Tiger video server <ref> [Bolosky et al. 96, Bolosky et al. 97] </ref> over an Ethernet network at a rate of 2Mbits/s to a set-top box. The application was designed to operate with 100% of the CPU.
Reference: [Bolosky et al. 97] <author> William J. Bolosky, Robert P. Fitzgerald, and John R. Douceur. </author> <title> Distributed Schedule Management in the Tiger Video Fileserver. </title> <booktitle> In Proceedings of the 16 th ACM Symposium on Operating Systems Principles, </booktitle> <address> Saint-Malo, France, </address> <month> Oct. </month> <year> 1997. </year>
Reference-contexts: In this case, the application is a software-only AVI (Audio Video Interleaved) video player playing a 3 minute, 45 second music video stored at 15 frames per second (one frame every 66.7ms), delivered from a Tiger video server <ref> [Bolosky et al. 96, Bolosky et al. 97] </ref> over an Ethernet network at a rate of 2Mbits/s to a set-top box. The application was designed to operate with 100% of the CPU.
Reference: [Clark et al. 92] <author> David D. Clark, Scott Shenker, and Lixia Zhang. </author> <title> Supporting Real-Time Applications in an Integrated Services Packet Network: Architecture and Mechanism. </title> <booktitle> In ACM SIGCOMM 1992, </booktitle> <pages> pp. 14-26. </pages>
Reference-contexts: Some systems supporting mixed timesharing and real-time workloads provide timely execution of real-time applications through proportional share CPU allocation mechanisms [Goyal et al. 96, Waldspurger 95] based on weighted fair queuing <ref> [Clark et al. 92] </ref> or through fixed share CPU allocation [Mercer et al. 94]. <p> The scheduling mechanisms in these systems are derived from or are very similar to the weighted fair queuing technique <ref> [Clark et al. 92] </ref> used for real-time communication services.
Reference: [Compton & Tennenhouse 93] <author> Charles L. Compton and David L. Tennenhouse. </author> <title> Collaborative Load Shedding. </title> <booktitle> In Proceedings of the Workshop on the Role of Real-Time in Multimedia/Interactive Computing Systems, </booktitle> <address> Raleigh Durham, NC. </address> <publisher> IEEE Computer Society, </publisher> <month> Nov. </month> <year> 1993. </year>
Reference-contexts: Rialto gives the user this control, as opposed to some other systems that let the applications slug it out for resources <ref> [Compton & Tennenhouse 93] </ref>. The Rialto framework for resource reservation and negotiation has already been presented in [Jones et al. 95] and is beyond the scope of this paper. The focus of this paper is on mechanisms for scheduling the CPU Resource.
Reference: [Custer 92] <author> Helen Custer. </author> <title> Inside Windows NT. </title> <publisher> Microsoft Press, </publisher> <year> 1992. </year>
Reference-contexts: Constraints could steal time in our earlier work [Jones et al. 96] as well. In our present system, we wanted to provide stronger application independence guarantees. Finally, many commercial systems have provided fixed-priority scheduling for real-time tasks <ref> [Khanna et al. 92, Custer 92] </ref> in addition to round-robin scheduling for timesharing, often with the drawback of the possibility of starving timesharing tasks [Nieh et al. 93], while still providing no guarantees for real-time tasks unless they are executed at the highest priority. 1.4 Motivation and Application Examples Rialto is
Reference: [Deng et al. 96] <author> Z. Deng, J.W.-S. Liu, and J. Sun. </author> <title> Dynamic Scheduling of Hard Real-Time Applications in Open System Environment. </title> <booktitle> In Proceedings of the Real-Time Systems Symposium, </booktitle> <address> Washington, DC, </address> <month> Dec. </month> <year> 1996. </year>
Reference-contexts: Even if no application is blocked, one or both kernel activities will usually be, giving a typical minimum timesharing share of 15%. <ref> [Deng et al. 96] </ref> uses fixed percentage CPU reservations to ensure constant execution rates for real-time applications. Similarly, [Bollela & Jeffay 95] partitions time between timesharing and real-time operating systems, periodically switching between them.
Reference: [Ford & Lepreau 94] <author> Bryan Ford and Jay Lepreau. </author> <title> Evolving Mach 3.0 to a Migrating Thread Model. </title> <booktitle> In Proceedings of the Winter 1994 USENIX Conference, </booktitle> <address> San Francisco, CA, </address> <pages> pp. 97-114. </pages> <publisher> USENIX Association, </publisher> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: Activities may span address spaces and machines and may have multiple threads of control associated with them. Each executing thread has an associated activity object. When threads execute, any resources used are charged against their activity. Threads making RPCs are treated similarly to migrating threads <ref> [Ford & Lepreau 94] </ref> in that the server thread runs under the same activity as the client thread. CPU Reservations are made by activities to ensure a minimum guaranteed execution rate and granularity. <p> The service thread is reclaimed upon return. While running on behalf of the calling thread, the service thread inherits all scheduling attributes of the caller. For scheduling purposes, this is equivalent to a migrating threads model <ref> [Ford & Lepreau 94] </ref>. 4.3 Critical vs. NonCritical Time Constraints The constraint criticality value is used during constraint feasibility analysis as follows. If a critical time constraint request is made and the normal feasibility analysis determines that the requested constraint is infeasible, then logically, the feasibility analysis is performed again.
Reference: [Ford & Susarla 96] <author> Bryan Ford and Sai Susarla. </author> <title> CPU Inheritance Scheduling. </title> <booktitle> In Proceedings of the Second Symposium on Operating Systems Design and Implementation, </booktitle> <address> Seattle, WA, </address> <pages> pp. 91-105. </pages> <publisher> USENIX Association, </publisher> <month> Oct. </month> <year> 1996. </year>
Reference-contexts: A different approach to supporting concurrent execution of real-time and non-real-time applications is based on hierarchical scheduling with several scheduling classes and with each application being assigned to one of these classes for the entire duration of its execution. <ref> [Sommer & Potter 96, Ford & Susarla 96, Golub 94] </ref> present hierarchical scheduling frameworks where the real-time applications always have priority over the non-real-time ones and system-level mechanisms ensure that the most urgent thread in the system is executed first.
Reference: [Golub 94] <author> David B. Golub. </author> <title> Operating System Support for Coexistence of Real-Time and Conventional Scheduling. </title> <type> Technical Report CMU-CS-94-212, </type> <institution> Carnegie Mellon University, </institution> <year> 1994. </year>
Reference-contexts: A different approach to supporting concurrent execution of real-time and non-real-time applications is based on hierarchical scheduling with several scheduling classes and with each application being assigned to one of these classes for the entire duration of its execution. <ref> [Sommer & Potter 96, Ford & Susarla 96, Golub 94] </ref> present hierarchical scheduling frameworks where the real-time applications always have priority over the non-real-time ones and system-level mechanisms ensure that the most urgent thread in the system is executed first.
Reference: [Goyal et al. 96] <author> Pawan Goyal, Xingang Guo, Harrick. M. </author> <note> Vin. </note>
Reference-contexts: While a number of systems have explored mixing timesharing and real-time workloads a number of problems with them led us to design and build a new scheduler. Some systems supporting mixed timesharing and real-time workloads provide timely execution of real-time applications through proportional share CPU allocation mechanisms <ref> [Goyal et al. 96, Waldspurger 95] </ref> based on weighted fair queuing [Clark et al. 92] or through fixed share CPU allocation [Mercer et al. 94]. <p> Related Work Increasing numbers of systems support concurrent execution of real-time and non-real-time applications. This section reviews several of these systems, focusing on their support for executing code subject to time constraints with accurate feasibility analysis and on their response time for non-real-time applications. In many systems <ref> [Goyal et al. 96, Stoica et al. 96, Waldspurger 95] </ref>, the support for real-time applications is restricted to providing for proportional-share CPU allocation: each application receives a CPU share which, on average, corresponds to a userspecified weight or percentage.
References-found: 13

