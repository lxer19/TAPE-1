URL: http://www.cs.umr.edu/techreports/91-17.ps
Refering-URL: http://www.cs.umr.edu/techreports/
Root-URL: 
Email: ff@cs.umr.edu  
Title: FORMAL METHODS OF REAL-TIME SYSTEMS  
Author: Sumei Tsai and Bruce McMillin 
Note: This work was supported in part by the National Science Foundation under Grant Numbers MIP-8909749 and CDA-8820714, and in part by the AMOCO Faculty Development Program.  
Address: Rolla, Missouri 65401  
Affiliation: Department of Computer Science University of Missouri at Rolla  
Date: August 6, 1991  
Pubnum: CSC-91-17  
Abstract-found: 0
Intro-found: 1
Reference: [AaNa88] <author> Aaby, A. A. and Narayana, K.T. </author> <title> ``Propositional temporal interval logic is PSpace complete,'' </title> <booktitle> 9th International Conference on Automated Deduction(CADE), </booktitle> <month> May, </month> <year> 1988. </year>
Reference-contexts: Although temporal logic is adequate for the behavioral description of concurrent systems, their low level nature incurs an unnecessary amount of detail about states [ScMe83]. In order to have more degree of abstraction, <ref> [AaNa88] </ref> and [ScMe83] support Temporal interval logic as a framework for reasoning about concurrent systems. In general, qualitative description of system behaviors is not enough for real-time systems.
Reference: [BeHa81] <author> Bernstein, A. and Harter, P. K. </author> <booktitle> ``Proving Real-Time properties of programs with temporal logic In 8th ACM symposium on Operating System Principles, </booktitle> <address> Pacific Grove, California, </address> <pages> pp. 1-11, </pages> <year> 1981. </year>
Reference-contexts: As far as formula itself concerns, PRTIL formulas are propositional predicates; the formulas of RTL are boolean combinations of equality and inequality predicates; RTTL formulas consists of temporal formulas, augmented with the notion of data variables. In <ref> [BeHa81] </ref> and [RoKo83], RTTL were rejected as an assertion language because of the difficulty in knowing when to update the clock variable [Ostr89c]. The interval formula in PRTIL can only express the time an event occurs via related events (i.e. express how fast an event reacts to a cause).
Reference: [BlHi80] <author> Bledsoe, W. W. and Hines, L. M. </author> <title> ``Variable elimination and chaining in a resolution-based prover for inequalities,'' </title> <booktitle> in Proc. 5th Conf. Automated Deduction: Lecture Notes Comput. Sci., </booktitle> <editor> W. Bibel and R. Kowalski, Eds. </editor> <address> New York, </address> <publisher> Springer-Verlag, </publisher> <pages> pp. 70-87, </pages> <year> 1980. </year>
Reference-contexts: These two procedures include: a resolution-based inequality prover <ref> [BlHi80] </ref>, and a decision procedure for quantifier-free Presburger arithmetic having uninterpreted functions [Shos79]. However, these methods may be impractical for large and complex real-time systems, since a mechanical procedure for Presburger arithmetic is at least double exponential and Presburger arithmetic with even a single uninterpreted function is undecidable [JaMo87].
Reference: [ClEm83] <author> Clarke, E. M., Emerson, E. A. and Sistla, A. P. </author> <title> ``Automatic verification of finite state concurrent systems using temporal logic specification: a practical approach,'' </title> <booktitle> In Proc. 10th ACM PoPL, </booktitle> <address> pp.117-126, Austin, Texas, </address> <year> 1983. </year>
Reference: [ClEm86] <author> Clarke, E. M., Emerson, E. A. and Sistla, A. P. </author> <title> ``Automatic verification of finite state concurrent systems using temporal logic specification,'' </title> <journal> ACM Transactions on Programming Language and Systems, </journal> <volume> Vol. 8(2) pp.244-263, </volume> <month> Apr. </month> <year> 1986. </year>
Reference-contexts: Over the past several years, there has been attention on construction and implementation of algorithms for automatic verification of finite state programs. Examples are <ref> [ClEm86] </ref> and [LiPn84]. Several technical areas address the predictability and reliability of real-time systems such as real-time operating systems, real-time architecture and hardware, fault tolerance for real-time systems, languages for real-time systems as well as specification and verification of real-time systems [StRa88]. <p> Absolute: relating events and states variables to the moment of their occurrences (e.g. real-time logic). This allows time as a parameter in computa tions. Over the past several years, many mathematical logics have been proposed for the assertion languages of real-time systems including computation tree logic ([ClEm83], <ref> [ClEm86] </ref>), interval logic [ScMe83], probabilistic computation tree logic [HaJo89], global temporal logic and quantized temporal logic [PnHa88], real-time temporal interval logic [NaAa88], real-time temporal logic ([Ostr89a], [Ostr89b], [OsWo87]) and real-time logic ([JaMo86], [JaMo87], [JaSt88], [Jaha89]). <p> On the other hand, there are substantial results for concurrent systems via non real-time temporal logic. Temporal logic model checking came from Clarke, Emerson and others ([EmLe85], <ref> [ClEm86] </ref>, [EmHa86]). In 1981, Clarke created a polynomial time algorithm for model checking, and Emerson extended the ability to handle fairness constraints. This algorithm was called Computation Tree Logic (CTL) model checking procedure, which are applicable to temporal specifications of finite state programs.
Reference: [Dasa85] <author> B. </author> <title> Dasarathy ``Timing constraints of real-time systems: constructs for expressing them, methods of validating them,'' </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. 11(1), </volume> <pages> pp. 80-86, </pages> <month> Jan. </month> <year> 1985. </year>
Reference-contexts: Petri nets can reduce state space and represent concurrent activities adequately. However, the key problem of Petri nets as a formal specification scheme is that numerous dummy states are generated during transition delays to maintain the feature of instaneous firings [Gabr90]. 2.4 Extended state machine Dasarathy <ref> [Dasa85] </ref> examines the timing properties of real-time systems. His approach to specification and analysis is to model systems by finite state machines where the system's response is determined by its input and the current state of the system.
Reference: [EmHa86] <author> Emerson, E. A. and Halpern, J. Y. </author> <title> ``Sometimes'' and ``not never'' revisted: On branching versus linear time temporal logic. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> Vol. 33(1), </volume> <pages> pp. 151-178, </pages> <month> Jan. </month> <year> 1986. </year>
Reference-contexts: On the other hand, there are substantial results for concurrent systems via non real-time temporal logic. Temporal logic model checking came from Clarke, Emerson and others ([EmLe85], [ClEm86], <ref> [EmHa86] </ref>). In 1981, Clarke created a polynomial time algorithm for model checking, and Emerson extended the ability to handle fairness constraints. This algorithm was called Computation Tree Logic (CTL) model checking procedure, which are applicable to temporal specifications of finite state programs.
Reference: [EmLe85] <author> Emerson, E. M. and Lei, C., </author> <title> ``Modalities for model checking branching time strikes back,'' </title> <booktitle> In 12th ACM Symposium on Principles of Programming Languages, </booktitle> <address> New Orleans, </address> <publisher> Louisiana, </publisher> <pages> pp. 84-96, </pages> <month> Jan. </month> <year> 1985. </year>
Reference: [EsHa81] <author> Eswaran, K., Hamacher, V.C. and Shedler, G.S., </author> <title> ``Collision-free access control for communication bus networks,'' </title> <journal> IEEE Trans. on Software Eng., </journal> <volume> Vol. SE-7, pp.574-582, </volume> <month> Nov. </month> <year> 1981. </year>
Reference: [FiTo84] <author> Fine, M. and Tobagi, F., </author> <title> ``Demand assignment multiple access schemes in broadcast bus local area networks,'' </title> <journal> IEEE Trans. on Computers, </journal> <volume> Vol. C-33, pp.1130-1159, </volume> <month> Dec. </month> <year> 1984. </year>
Reference-contexts: For example, if the element = t ( t) is on the left (right) of fi or , then we are quantitatively speaking about the event I (J). Example: This example is from the class of Demand-Assigned Multiple-Access (DAMA) protocols ([EsHa81], <ref> [FiTo84] </ref>) for high speed local area broadcast bus network.
Reference: [FrGa89] <author> Franklin, M. K. and Gabrielian, A. </author> <title> ``A transformational method for verifying safety properties in real-time systems,'' </title> <booktitle> IEEE Real-Time Systems Symposium, </booktitle> <pages> pp. 112-123, </pages> <year> 1989. </year>
Reference-contexts: the exponential blow-up of states by relaxing the requirement that all states have to be shown explicitly (e.g. combine two states having the same structure into one single state with parameters). 2.7 Hierarchical multi-state machine Hierarchical multi-state machine (HMS) is another technique for specification of complex real-time software ([GaFr90], [GaFr88], <ref> [FrGa89] </ref>). This HMS machine is the generalization of finite-state automata, in which multiple states can be active at any time, multiple transitions can occur simultaneously, and states can be decomposed hierarchically into lower-level HMS machines. <p> In such cases, decision procedures provide an alternative to the verification problem. For finite state systems, the verification problem becomes decidable and mechanized procedures or tools for automatic verification are supported in [Ostr89a], [JaSt88], [Jaha89], [GaFr88], <ref> [FrGa89] </ref>, and [Ostr89b]. These procedures will be presented in the next section. V. DECISION PROCEDURES Real-time distributed systems occur in many safety critical applications. Mechanical or automatic procedures for the verification of safe real-time environments is therefore desirable. Nevertheless, the literature on mechanized verification of real-time properties is scarce. <p> The following is an overview of those decision procedures, which explicitly deal with hard real-time properties, and which are based on the analysis of constraint graphs [JaMo86], computation graphs ([JaSt88], [Jaha89], [Stua90]), or reachability graphs ([Ostr89a], [Ostr89b], <ref> [FrGa89] </ref>, [GaFr88]). 5.1 Constraint graphs In [JaMo86], two existing procedures are suggested for performing safety analysis of real-time systems. These two procedures include: a resolution-based inequality prover [BlHi80], and a decision procedure for quantifier-free Presburger arithmetic having uninterpreted functions [Shos79]. <p> Then, if the maximum time taken among all paths to reach the goal predicate y is less than u, the quantitative property is proven. <ref> [FrGa89] </ref> and [GaFr88] also make use of the reachability graph for verifying a safety property is consistent with an HMS specification of a system. Here, a transformational method is applied for the formal verification of system properties.
Reference: [GaFr88] <author> Gabrielian, A. and Franklin, M. K. </author> <title> ``State-based specification of complex real-time systems,'' </title> <booktitle> IEEE Real-Time Systems Symposium, </booktitle> <pages> pp. 2-11, </pages> <year> 1988. </year>
Reference-contexts: solve the exponential blow-up of states by relaxing the requirement that all states have to be shown explicitly (e.g. combine two states having the same structure into one single state with parameters). 2.7 Hierarchical multi-state machine Hierarchical multi-state machine (HMS) is another technique for specification of complex real-time software ([GaFr90], <ref> [GaFr88] </ref>, [FrGa89]). This HMS machine is the generalization of finite-state automata, in which multiple states can be active at any time, multiple transitions can occur simultaneously, and states can be decomposed hierarchically into lower-level HMS machines. <p> In such cases, decision procedures provide an alternative to the verification problem. For finite state systems, the verification problem becomes decidable and mechanized procedures or tools for automatic verification are supported in [Ostr89a], [JaSt88], [Jaha89], <ref> [GaFr88] </ref>, [FrGa89], and [Ostr89b]. These procedures will be presented in the next section. V. DECISION PROCEDURES Real-time distributed systems occur in many safety critical applications. Mechanical or automatic procedures for the verification of safe real-time environments is therefore desirable. Nevertheless, the literature on mechanized verification of real-time properties is scarce. <p> The following is an overview of those decision procedures, which explicitly deal with hard real-time properties, and which are based on the analysis of constraint graphs [JaMo86], computation graphs ([JaSt88], [Jaha89], [Stua90]), or reachability graphs ([Ostr89a], [Ostr89b], [FrGa89], <ref> [GaFr88] </ref>). 5.1 Constraint graphs In [JaMo86], two existing procedures are suggested for performing safety analysis of real-time systems. These two procedures include: a resolution-based inequality prover [BlHi80], and a decision procedure for quantifier-free Presburger arithmetic having uninterpreted functions [Shos79]. <p> Then, if the maximum time taken among all paths to reach the goal predicate y is less than u, the quantitative property is proven. [FrGa89] and <ref> [GaFr88] </ref> also make use of the reachability graph for verifying a safety property is consistent with an HMS specification of a system. Here, a transformational method is applied for the formal verification of system properties.
Reference: [GaFr90] <author> Armen Gabrielian and Matthew K. </author> <title> Franklin ``Multi-level specification and verification of real-time software,'' </title> <booktitle> 1990 IEEE 12th International Conference on Software Engineering, </booktitle> <pages> pp. 52-62, </pages> <year> 1990. </year>
Reference: [GaPn80] <author> Gabbay, D., Pnueli, A., Shelah, S. and Stavi, J. </author> <title> ``The temporal analysis of fairness,'' </title> <booktitle> Proceedings 7th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 163-173, </pages> <address> Las Vegas, </address> <month> Jan. </month> <year> 1980. </year>
Reference: [GaSt87] <author> Gabrielian, A. and Stickney, M. E. </author> <title> ``Hierarchical representation of causal knowledge,'' </title> <booktitle> Proc. WESTEX-87 IEEE Expert Systems Conference, </booktitle> <pages> pp. 82-89, </pages> <month> Jun. </month> <year> 1988. </year>
Reference-contexts: For Statecharts, Modecharts and HMS machines, the major differences are in the form of transition controls, the notion of time, the execution rule (transition firing) and the graphic notation <ref> [GaSt87] </ref>. On the surface, the HMS machine model seems to be more powerful than the others as a specification tool for the dynamics of complex real-time systems, in that interactions among states and hard deadlines can be defined formally.
Reference: [Gogu81] <author> Goguen, J.A., </author> <title> ``More thoughts on specification and verification,'' </title> <booktitle> ACM SIGSOFT, </booktitle> <volume> 6(3), </volume> <pages> pp. 38-41, </pages> <year> 1981. </year>
Reference: [HaJo89] <author> Hansson, H. and Johnsson, B. </author> <title> ``A framework for reasoning about time and reliability,'' </title> <booktitle> IEEE Real-Time Systems Symposium, </booktitle> <pages> pp. 102-111, </pages> <year> 1989. </year>
Reference-contexts: This allows time as a parameter in computa tions. Over the past several years, many mathematical logics have been proposed for the assertion languages of real-time systems including computation tree logic ([ClEm83], [ClEm86]), interval logic [ScMe83], probabilistic computation tree logic <ref> [HaJo89] </ref>, global temporal logic and quantized temporal logic [PnHa88], real-time temporal interval logic [NaAa88], real-time temporal logic ([Ostr89a], [Ostr89b], [OsWo87]) and real-time logic ([JaMo86], [JaMo87], [JaSt88], [Jaha89]).
Reference: [Hare87] <author> Harel, D., ``Statecharts: </author> <title> A Visual Formalism for Complex Systems,'' </title> <booktitle> Science of Computer Programming, </booktitle> <volume> Vol. 8, </volume> <pages> pp. 231-274, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: Most techniques that use invariance rely on transition systems as their computational models. Transition systems generally depend on interleaving to model concurrency, hence they may not be appropriate for reasoning about real-time properties [JaMo86]. 2.6 Statecharts Statecharts are the extension of conventional state machines and state diagrams <ref> [Hare87] </ref>. Encapsulation is used to express hierarchy among boxes which denote states in Statechart specification; a number of related states is grouped into a superstate; decomposition of a state is accomplished by the splitting of a box or state into several components. <p> The representation problem Most of the representation languages described in Section 2 are based on state machine model. They suffer from the same drawbacks as state machine does. However, <ref> [Hare87] </ref> introduces several notions for the representation languages in order to beat the combinatorial explosion of states and they include: Superstate: to group related states into a single one. Orthogonality: to describe concurrency and communication.
Reference: [Hoar85] <author> C. A. R. Hoare, </author> <title> Communicating Sequential Processes, </title> <publisher> Prentice Hall, </publisher> <year> 1985. </year>
Reference-contexts: Here, spontaneous events represent unpredictable changes and forced or guarded events describe non-deterministic behavior. In addition, the modelling of plants and controllers via extended state machines that have guarded local, shared and communicating events are applied in a way similar to CSP <ref> [Hoar85] </ref>. 2.5 Modecharts A graphical specification language, called Modechart, is employed to specify real-time systems in [JaSt88] and [Jaha89]. The computation is considered to be sets of event occurrences in order. The modes constructed via Modechart language can be viewed as control information that impose structure on the system operation.
Reference: [Jaha89] <author> Jahanian, F. </author> <title> ``Verifying properties of systems with variable timing constraints,'' </title> <booktitle> IEEE Real-Time Systems Symposium, </booktitle> <pages> pp. 319-328, </pages> <year> 1989. </year>
Reference-contexts: In addition, the modelling of plants and controllers via extended state machines that have guarded local, shared and communicating events are applied in a way similar to CSP [Hoar85]. 2.5 Modecharts A graphical specification language, called Modechart, is employed to specify real-time systems in [JaSt88] and <ref> [Jaha89] </ref>. The computation is considered to be sets of event occurrences in order. The modes constructed via Modechart language can be viewed as control information that impose structure on the system operation. Modes are arranged hierarchically; the occurrence of a transition represents a change of control information between two modes. <p> These formal approaches include extensions of temporal logic for quantitative reasoning about time, reachability analysis for timed Petri nets, real-time logic and the algebraic approach of the timed traced model of concurrent processes <ref> [Jaha89] </ref>. The challenge of creating an appropriate specification language for real-time systems is to incorporate a time metric [Ostr89c]. According to the role of time, three classes of temporal relationships can be defined [KoKu89]: Qualitative: expressing order in time (e.g. temporal logic). However, this is not enough for real-time. <p> logics have been proposed for the assertion languages of real-time systems including computation tree logic ([ClEm83], [ClEm86]), interval logic [ScMe83], probabilistic computation tree logic [HaJo89], global temporal logic and quantized temporal logic [PnHa88], real-time temporal interval logic [NaAa88], real-time temporal logic ([Ostr89a], [Ostr89b], [OsWo87]) and real-time logic ([JaMo86], [JaMo87], [JaSt88], <ref> [Jaha89] </ref>). However, most of them having no absolute time notion are not suitable for quantitative reasoning of real-time properties except real-time logic, real-time temporal logic, and real-time temporal interval logic. This section reviews these three logics that can be employed as assertion languages of real-time systems. <p> In such cases, decision procedures provide an alternative to the verification problem. For finite state systems, the verification problem becomes decidable and mechanized procedures or tools for automatic verification are supported in [Ostr89a], [JaSt88], <ref> [Jaha89] </ref>, [GaFr88], [FrGa89], and [Ostr89b]. These procedures will be presented in the next section. V. DECISION PROCEDURES Real-time distributed systems occur in many safety critical applications. Mechanical or automatic procedures for the verification of safe real-time environments is therefore desirable. <p> The following is an overview of those decision procedures, which explicitly deal with hard real-time properties, and which are based on the analysis of constraint graphs [JaMo86], computation graphs ([JaSt88], <ref> [Jaha89] </ref>, [Stua90]), or reachability graphs ([Ostr89a], [Ostr89b], [FrGa89], [GaFr88]). 5.1 Constraint graphs In [JaMo86], two existing procedures are suggested for performing safety analysis of real-time systems. These two procedures include: a resolution-based inequality prover [BlHi80], and a decision procedure for quantifier-free Presburger arithmetic having uninterpreted functions [Shos79]. <p> After a graph G is generated from the formula F, an analysis procedure is applied to show the unsatisfiability of F as positive cycles are detected in the graph G. 5.2 Computation graphs In <ref> [Jaha89] </ref>, [JaSt88] and [Stua90], Modechart and real-time logic are employed as the specification language and the logic for the dynamics of real-time systems. To verify properties of a system, a decision procedure which makes use of a computation graph is applied to determine the satisfiability of a RTL formula. <p> In other words, if the number of potential corresponding nodes for each node is not finite or the number of edges between corresponding nodes is not finite, then the algorithm will not terminate [JaSt88]. The procedure is presented in [JaSt88]. <ref> [Jaha89] </ref> extends the work, in which some of the timing constraints may be variables, and the undecidability of verifying arbitrary RTL formulas for a given Modechart system is also proven. <p> As a consequence, the goal of finding decision procedures for arbitrary properties may be impossible. It follows that an area of future work is to find more properties in which the constructions of finite graphs are possible <ref> [Jaha89] </ref>. The search of suitable decomposition and refinement techniques for compositional verification is under investigation of [Pnue86] and [Ostr89b]. Their suggestion is based on the ground that if a system can be decomposed into small modules, then decision procedures may be helpful in verifying parts of the system.
Reference: [JaMo86] <author> Jahanian, F. and Mok, </author> <title> A.K. ``Safety analysis of timing properties in Real-Time Systems,'' </title> <journal> IEEE Transactions on Software Engineering, SE-12(9), </journal> <volume> pp.890-904, </volume> <month> Sep. </month> <year> 1986. </year>
Reference-contexts: Software engineering is one of the two major areas addressing software reliability. It promotes adherence to programming principles to reduce the complexity of large software systems. The other is formal verification methods which attempt to prove the consistency of safety requirements with the system specification <ref> [JaMo86] </ref>. The focus of this paper is on the latter part. The specification and verification of real-time systems is based on the extension to existing formalism for concurrent systems. Most of current literature on real-time systems has been based on the finite state machine, Petri nets and first order logic. <p> The following is an overview of computational models, which are mostly based on interleaving. 2.1 Event-action model Johanian and Mok <ref> [JaMo86] </ref> modelled the system of interest via event-action model which captures the data dependence and temporal ordering of actions. State predicates are used to describe system states; actions are taken in response to events, which are divided into start and stop events, transition events as well as external events. <p> This is a high price and the argument goes like this. Most techniques that use invariance rely on transition systems as their computational models. Transition systems generally depend on interleaving to model concurrency, hence they may not be appropriate for reasoning about real-time properties <ref> [JaMo86] </ref>. 2.6 Statecharts Statecharts are the extension of conventional state machines and state diagrams [Hare87]. <p> Example 1: "/ - i@(WBUTTON1, i) &lt; @ (-SAMPLE, i) / " @(flSAMPLE, i) @(WBUTTON1, i) + 20 Action SAMPLE is executed only after button number 1 is pressed, and every execution of SAMPLE must complete within 20 time units following the press of button number 1 <ref> [JaMo86] </ref>. 3.5 Summary Among those three logics mentioned above, RTL is the one that can state timing properties more compactly than the other two because of the classification of events and the occurrence function. <p> The following is an overview of those decision procedures, which explicitly deal with hard real-time properties, and which are based on the analysis of constraint graphs <ref> [JaMo86] </ref>, computation graphs ([JaSt88], [Jaha89], [Stua90]), or reachability graphs ([Ostr89a], [Ostr89b], [FrGa89], [GaFr88]). 5.1 Constraint graphs In [JaMo86], two existing procedures are suggested for performing safety analysis of real-time systems. <p> The following is an overview of those decision procedures, which explicitly deal with hard real-time properties, and which are based on the analysis of constraint graphs <ref> [JaMo86] </ref>, computation graphs ([JaSt88], [Jaha89], [Stua90]), or reachability graphs ([Ostr89a], [Ostr89b], [FrGa89], [GaFr88]). 5.1 Constraint graphs In [JaMo86], two existing procedures are suggested for performing safety analysis of real-time systems. These two procedures include: a resolution-based inequality prover [BlHi80], and a decision procedure for quantifier-free Presburger arithmetic having uninterpreted functions [Shos79].
Reference: [JaMo87] <author> Jahanian, F. and Mok, </author> <title> A.K. ``A g raph-theoretic approach for timing analysis and its implementation,'' </title> <journal> IEEE Transactions on Computers, C-36(8), </journal> <volume> pp.961-975, </volume> <year> 1987. </year>
Reference-contexts: many mathematical logics have been proposed for the assertion languages of real-time systems including computation tree logic ([ClEm83], [ClEm86]), interval logic [ScMe83], probabilistic computation tree logic [HaJo89], global temporal logic and quantized temporal logic [PnHa88], real-time temporal interval logic [NaAa88], real-time temporal logic ([Ostr89a], [Ostr89b], [OsWo87]) and real-time logic ([JaMo86], <ref> [JaMo87] </ref>, [JaSt88], [Jaha89]). However, most of them having no absolute time notion are not suitable for quantitative reasoning of real-time properties except real-time logic, real-time temporal logic, and real-time temporal interval logic. This section reviews these three logics that can be employed as assertion languages of real-time systems. <p> ( p)fi ] busy LR ( p) / " busy RL ( p) The external event talk ( p) cause the bus busy in either direction. 3.3 Real time logic Real time logic (RTL) is a first order logic developed primarily for reasoning about timing properties of real-time systems ([JaMo86], <ref> [JaMo87] </ref>). The logic views the computations of a system as sets of event occurrences in order. Each event occurrence is associated with a type and a time. The type indicates which event it is an occurrence, and the time represents the absolute time of an event occurrence. <p> However, these methods may be impractical for large and complex real-time systems, since a mechanical procedure for Presburger arithmetic is at least double exponential and Presburger arithmetic with even a single uninterpreted function is undecidable <ref> [JaMo87] </ref>. In many cases, the RTL formulas describing timing properties consist of arithmetic inequalities with the form x i a ij x j so that a graph-theoretic approach is employed for the safety analysis.
Reference: [JaSt88] <author> Jahanian, F. and Stuart, D. F. </author> ` <title> `A method for verifying properties of Modechart specifications,'' </title> <booktitle> In Proceedings of 9th IEEE Real-Time Systems Symposium, </booktitle> <pages> pp. 12-21, </pages> <month> Dec. </month> <year> 1988. </year>
Reference-contexts: In addition, the modelling of plants and controllers via extended state machines that have guarded local, shared and communicating events are applied in a way similar to CSP [Hoar85]. 2.5 Modecharts A graphical specification language, called Modechart, is employed to specify real-time systems in <ref> [JaSt88] </ref> and [Jaha89]. The computation is considered to be sets of event occurrences in order. The modes constructed via Modechart language can be viewed as control information that impose structure on the system operation. <p> mathematical logics have been proposed for the assertion languages of real-time systems including computation tree logic ([ClEm83], [ClEm86]), interval logic [ScMe83], probabilistic computation tree logic [HaJo89], global temporal logic and quantized temporal logic [PnHa88], real-time temporal interval logic [NaAa88], real-time temporal logic ([Ostr89a], [Ostr89b], [OsWo87]) and real-time logic ([JaMo86], [JaMo87], <ref> [JaSt88] </ref>, [Jaha89]). However, most of them having no absolute time notion are not suitable for quantitative reasoning of real-time properties except real-time logic, real-time temporal logic, and real-time temporal interval logic. This section reviews these three logics that can be employed as assertion languages of real-time systems. <p> Thus, after t has occurred, the clock will still show T ticks. In other words, the clock is only updated after the tick event. Below is some temporal specifications in RTTL formulas for the train-gate example. delim Train-gate example: The railroad crossing example is based on [LeSt87] and <ref> [JaSt88] </ref>. The gate at a guarded railroad crossing is software controlled, and since the gate cannot control the train, a real-time solution is needed. A warning signal for the approaching of a train will be given to the gate controller at a distance from the crossing. <p> RTL uses the occurrence function to capture the notion of events and real time. However, the use of arbitrary quantification and the uninterpreted functions in RTL formulas causes a problem in obtaining decidability <ref> [JaSt88] </ref>. Moreover, there are no verification methods provided by PRTIL. Therefore, at this time it is still not clear whether RTL and RTTL will become suitable for not only specifying but also verifying time-critical properties of real-time systems. IV. <p> In such cases, decision procedures provide an alternative to the verification problem. For finite state systems, the verification problem becomes decidable and mechanized procedures or tools for automatic verification are supported in [Ostr89a], <ref> [JaSt88] </ref>, [Jaha89], [GaFr88], [FrGa89], and [Ostr89b]. These procedures will be presented in the next section. V. DECISION PROCEDURES Real-time distributed systems occur in many safety critical applications. Mechanical or automatic procedures for the verification of safe real-time environments is therefore desirable. <p> After a graph G is generated from the formula F, an analysis procedure is applied to show the unsatisfiability of F as positive cycles are detected in the graph G. 5.2 Computation graphs In [Jaha89], <ref> [JaSt88] </ref> and [Stua90], Modechart and real-time logic are employed as the specification language and the logic for the dynamics of real-time systems. To verify properties of a system, a decision procedure which makes use of a computation graph is applied to determine the satisfiability of a RTL formula. <p> To verify properties of a system, a decision procedure which makes use of a computation graph is applied to determine the satisfiability of a RTL formula. Computation graph generation <ref> [JaSt88] </ref> develops computation graphs by applying the idea of reachability graph into the real-time systems specified in Modechart specification. The computations of a system given by Modechart are defined as a directed tree, together with a set of timing requirements representing the lower/upper bounds on pairs of events. <p> If no equivalent node is found, the current node is marked as traversed, and its successors are added to the graph as unexplored nodes. Decidable timing properties Two types of formulas for which finite computation graphs can be constructed are identified in <ref> [JaSt88] </ref> and [Stua90]. The following definitions are needed before the formulas can be introduced. An endpoint is denoted by an occurrence function of the form @(E, i), where E is an event constant and i is an integer variable. Two endpoints are related if they have the same variables. <p> However, this approach can work only if the number of corresponding nodes is finite. In other words, if the number of potential corresponding nodes for each node is not finite or the number of edges between corresponding nodes is not finite, then the algorithm will not terminate <ref> [JaSt88] </ref>. The procedure is presented in [JaSt88]. [Jaha89] extends the work, in which some of the timing constraints may be variables, and the undecidability of verifying arbitrary RTL formulas for a given Modechart system is also proven. <p> In other words, if the number of potential corresponding nodes for each node is not finite or the number of edges between corresponding nodes is not finite, then the algorithm will not terminate <ref> [JaSt88] </ref>. The procedure is presented in [JaSt88]. [Jaha89] extends the work, in which some of the timing constraints may be variables, and the undecidability of verifying arbitrary RTL formulas for a given Modechart system is also proven.
Reference: [KoKu89] <institution> Ron Koymans and Ruurd Kuiper ``Paradigm for real-time systems,'' </institution> <note> In J.W. </note> <editor> De Bakker, W.P. de Roever, and G. Rozenburg, editors, </editor> <title> Models of concurrency: linear, branching and partial orders, </title> <publisher> LNCS354, Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: The challenge of creating an appropriate specification language for real-time systems is to incorporate a time metric [Ostr89c]. According to the role of time, three classes of temporal relationships can be defined <ref> [KoKu89] </ref>: Qualitative: expressing order in time (e.g. temporal logic). However, this is not enough for real-time. Relative: expressing order and distance in time (e.g. temporal interval logic). This allows for expressing how fast a system reacts to a cause.
Reference: [Lamp83] <author> Lamport, L., </author> <title> ``What good is temporal logic?'' In R.E.A. Manson, editor, </title> <booktitle> Proc. IFIP Inform Processing 83, </booktitle> <address> Amsterdam, The Netherland: </address> <publisher> North-Holland, </publisher> <pages> pp. 657-668, </pages> <year> 1983. </year>
Reference: [LeSt87] <author> Leveson, N. and Stolzy, J. </author> <title> ``Safety analysis using Petri nets,'' </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. SE-13(3), </volume> <pages> pp. 386-397, </pages> <month> Mar. </month> <year> 1987. </year>
Reference-contexts: This mod-elling of delays and timeouts is achieved by that, once a transition becomes enabled, it must occur within the lower and upper time bounds, unless it is preempted by the occurrence of some other transitions. 2.3 Extended Petri net model <ref> [LeSt87] </ref> describes real-time systems in terms of Petri nets. The authors are interested in safety of real-time systems, i.e. the effects of failures and hazards. <p> The arcs connect transitions to places and places to transitions. The state of a Petri net is defined as the number of tokens in each place. P1 P3 T2 Fig. 2.1 Petri net In <ref> [LeSt87] </ref>, each transition is associated with two values, Min and Max times to define the range of delays for each transition. Tokens remain in the input places during the transition delay so that the model retains the instantaneous firing feature of the Petri net model. <p> Thus, after t has occurred, the clock will still show T ticks. In other words, the clock is only updated after the tick event. Below is some temporal specifications in RTTL formulas for the train-gate example. delim Train-gate example: The railroad crossing example is based on <ref> [LeSt87] </ref> and [JaSt88]. The gate at a guarded railroad crossing is software controlled, and since the gate cannot control the train, a real-time solution is needed. A warning signal for the approaching of a train will be given to the gate controller at a distance from the crossing. <p> V. DECISION PROCEDURES Real-time distributed systems occur in many safety critical applications. Mechanical or automatic procedures for the verification of safe real-time environments is therefore desirable. Nevertheless, the literature on mechanized verification of real-time properties is scarce. The analysis of timed Petri nets ([Ramc74], <ref> [LeSt87] </ref>) is one active research area. For finite state systems, reachability graphs are constructed ([Zube80], [RaPh84]). However, their emphasis is on performance evaluation, hence there is no assertion language for specifying hard real-time properties to be established.
Reference: [LiPn84] <author> O. Lichtenstien and A. </author> <title> Pnueli ``Checking that finite state concurrent programs satisfy their linear specification,'' </title> <booktitle> Proceeding of 10th ACM symposium on Principles of Programming Languages, </booktitle> <year> 1984, </year> <month> pp.97-107. </month>
Reference-contexts: Over the past several years, there has been attention on construction and implementation of algorithms for automatic verification of finite state programs. Examples are [ClEm86] and <ref> [LiPn84] </ref>. Several technical areas address the predictability and reliability of real-time systems such as real-time operating systems, real-time architecture and hardware, fault tolerance for real-time systems, languages for real-time systems as well as specification and verification of real-time systems [StRa88]. <p> In 1981, Clarke created a polynomial time algorithm for model checking, and Emerson extended the ability to handle fairness constraints. This algorithm was called Computation Tree Logic (CTL) model checking procedure, which are applicable to temporal specifications of finite state programs. In <ref> [LiPn84] </ref> and [MaPn83], algorithms are developed for checking the satisfiability of an arbitrary temporal formula against a finite state concurrent program. The complexity of the algorithms are exponential in the size of the specification formula, but quadratic in the size of the program.
Reference: [MaPn81] <author> Manna, Z. and Pnueli, A. </author> <title> ``Verification of concurrent programs: The temporal framework,'' In R.S. </title> <editor> Boyer and J.S. Moore, editors, </editor> <booktitle> The Correctness Problem in Computer Science, </booktitle> <address> pp.215-273, </address> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1981. </year>
Reference-contexts: The representation language is an executable programming language R, which is prescriptive and algorithmic in nature. The other language is the specification or assertion language S, which is descriptive and expressive enough to describe program requirements [Ostr89c]. In the work of Manna and Pnueli ([Pnue77], <ref> [MaPn81] </ref>, [MaPn83], [Pnue86]), a fair transition system plays the role of representation language R, and temporal logic is the assertion (or specification) language.
Reference: [MaPn82] <author> Manna, Z. and Pnueli, </author> <title> A ``Verification of concurrent programs: the temporal proof principles,'' </title> <booktitle> in LNCS 131, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1982. </year>
Reference-contexts: This logic has modalities to qualitatively express the present, the next time in the future, sometime in the feature and always in the future. A variety of properties such as safety property, live-ness property and precedence property <ref> [MaPn82] </ref> can be described by temporal logic [NaAa88]. Although temporal logic is adequate for the behavioral description of concurrent systems, their low level nature incurs an unnecessary amount of detail about states [ScMe83].
Reference: [MaPn83] <author> Manna, Z. and Pnueli, A. </author> <title> ``Verification of concurrent programs: a temporal proof systems,'' </title> <type> Technical Report, </type> <institution> Dept. of Computer Science, Stanford University, </institution> <month> June </month> <year> 1983. </year> <institution> See also Foundations of Computer Science VI, </institution> <address> Amsterdam, </address> <publisher> Mathematical Center Tracts, </publisher> <pages> pp. 163-225, </pages> <year> 1983. </year>
Reference-contexts: The representation language is an executable programming language R, which is prescriptive and algorithmic in nature. The other language is the specification or assertion language S, which is descriptive and expressive enough to describe program requirements [Ostr89c]. In the work of Manna and Pnueli ([Pnue77], [MaPn81], <ref> [MaPn83] </ref>, [Pnue86]), a fair transition system plays the role of representation language R, and temporal logic is the assertion (or specification) language. <p> We begin by introducing temporal logic, which is the framework of real-time temporal logic and real-time temporal interval logic. Temporal logic We provide a brief summary to Manna-Pnueli temporal logic, which can be used to define the notion of real-time temporal formulas. The readers may refer to <ref> [MaPn83] </ref>, [MaPn89], and [Ostr89c] for more details. In temporal logic, two basic operators, (next) and U (until), are used to define many useful operators such as (henceforth), &lt;&gt;(eventually), U (unless), and P (precedes). The variables are partitioned into local variables and global variables; quantification is allowed over global variables only. <p> In 1981, Clarke created a polynomial time algorithm for model checking, and Emerson extended the ability to handle fairness constraints. This algorithm was called Computation Tree Logic (CTL) model checking procedure, which are applicable to temporal specifications of finite state programs. In [LiPn84] and <ref> [MaPn83] </ref>, algorithms are developed for checking the satisfiability of an arbitrary temporal formula against a finite state concurrent program. The complexity of the algorithms are exponential in the size of the specification formula, but quadratic in the size of the program.
Reference: [MaPn89] <author> Manna, Z. and Pnueli, A. </author> <title> ``The anchored version of the temporal framework,'' </title> <editor> In J.W. de Bakker, W.P. de Roever, and G. Rozenburg, editors, </editor> <title> Models of concurrency: linear, branching and partial orders, </title> <publisher> LNCS354, Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: these formal approaches attempt to answer this question: Given a system specification, does the specification conform to the safety properties of the system [StRa88]? 1.4 Basic components in formal verification In general, the formal methodology for the specification, verification and development of real-time systems consists of several elements as follows <ref> [MaPn89] </ref>. A computational model, which provides a uniform representation of the relevant phenomena of a system, leads to a formalism for convenient reasoning about the properties which we wish to establish. For example, the computational model in [MaPn89] is called fair transition system. <p> specification, verification and development of real-time systems consists of several elements as follows <ref> [MaPn89] </ref>. A computational model, which provides a uniform representation of the relevant phenomena of a system, leads to a formalism for convenient reasoning about the properties which we wish to establish. For example, the computational model in [MaPn89] is called fair transition system. Here, a set of computation sequences can be used to describe the system behaviors where each computation represents an execution sequence or a sequence of states denoting the operational semantics of a system [MaPn89]. <p> For example, the computational model in <ref> [MaPn89] </ref> is called fair transition system. Here, a set of computation sequences can be used to describe the system behaviors where each computation represents an execution sequence or a sequence of states denoting the operational semantics of a system [MaPn89]. A Specification language, which specifies a property that must be guaranteed to avoid a possible failure. In general, the assertion or formula to be analyzed is denoted by mathematical logic, such as real-time logic, temporal interval logic or propositional temporal logic. <p> This model is an extension of the fair transition system with an addition of a time metric, thus it inherits all features of fair transition systems <ref> [MaPn89] </ref>. Moreover, there is an external clock which is assumed to tick infinitely often. Each transition is associated with an enabling condition, a transformation function and lower and upper time bounds. <p> We begin by introducing temporal logic, which is the framework of real-time temporal logic and real-time temporal interval logic. Temporal logic We provide a brief summary to Manna-Pnueli temporal logic, which can be used to define the notion of real-time temporal formulas. The readers may refer to [MaPn83], <ref> [MaPn89] </ref>, and [Ostr89c] for more details. In temporal logic, two basic operators, (next) and U (until), are used to define many useful operators such as (henceforth), &lt;&gt;(eventually), U (unless), and P (precedes). The variables are partitioned into local variables and global variables; quantification is allowed over global variables only.
Reference: [Mena85] <author> Menasche, M., </author> <title> ``PAREDE:An automated tool for the analysis of time(d) Petri nets,'' </title> <booktitle> In International workshop on timed Petri nets, IEEE Computer Society, </booktitle> <pages> pp. 162-169, </pages> <month> June, </month> <year> 1985. </year>
Reference-contexts: For finite state systems, reachability graphs are constructed ([Zube80], [RaPh84]). However, their emphasis is on performance evaluation, hence there is no assertion language for specifying hard real-time properties to be established. Where the real-time properties are treated <ref> [Mena85] </ref>, there are usually restrictions (e.g. states are not allowed for multi-enabled transitions) on the class of Petri nets that can be checked automatically ([Ostr89a], [Ostr89c]). On the other hand, there are substantial results for concurrent systems via non real-time temporal logic.
Reference: [NaAa88] <author> Narayana, K. T. and Aaby, A. A. </author> <title> ``Specification of real-time systems in real-time temporal interval logic,'' </title> <booktitle> In Proceedings Real-Time Systems Symposium, IEEE Computer Society, </booktitle> <pages> pp. 86-95, </pages> <month> Dec. </month> <year> 1988. </year>
Reference-contexts: Over the past several years, many mathematical logics have been proposed for the assertion languages of real-time systems including computation tree logic ([ClEm83], [ClEm86]), interval logic [ScMe83], probabilistic computation tree logic [HaJo89], global temporal logic and quantized temporal logic [PnHa88], real-time temporal interval logic <ref> [NaAa88] </ref>, real-time temporal logic ([Ostr89a], [Ostr89b], [OsWo87]) and real-time logic ([JaMo86], [JaMo87], [JaSt88], [Jaha89]). However, most of them having no absolute time notion are not suitable for quantitative reasoning of real-time properties except real-time logic, real-time temporal logic, and real-time temporal interval logic. <p> This logic has modalities to qualitatively express the present, the next time in the future, sometime in the feature and always in the future. A variety of properties such as safety property, live-ness property and precedence property [MaPn82] can be described by temporal logic <ref> [NaAa88] </ref>. Although temporal logic is adequate for the behavioral description of concurrent systems, their low level nature incurs an unnecessary amount of detail about states [ScMe83]. In order to have more degree of abstraction, [AaNa88] and [ScMe83] support Temporal interval logic as a framework for reasoning about concurrent systems. <p> In other words, within the framework of logic we must be able to specify the relationship between events and their times of occurrences. We begin by introducing the syntax and the informal semantics of PRTIL, and then give an example of a time-constrained broadcast bus protocol by PRTIL specification. <ref> [NaAa88] </ref> may be referenced for more detail. <p> We are given a network, which consists of a bidirectional bus, a unidirectional control wire that runs in parallel to the bus, and a set of stations attaching to the bus and the control wire <ref> [NaAa88] </ref>. the length of a segment capturing propagation delay b (D) of the bus (or the control wire). Moreover, there are at most one station attached to each segment, which is numbered from 0 to N and left to right.
Reference: [Ostr86] <author> Ostroff, J., </author> <title> ``Real-time computer control of discrete event systems modelled by extended state machines: a temporal logic approach,'' </title> <type> Tech. Rep. 8618, </type> <institution> Systems Control Group, Dept. of Electrical Engineering, University of Toronto, </institution> <month> Sep. </month> <year> 1986. </year> <note> Preliminary draft of Ph.D. thesis-final version presented Jan. </note> <year> 1987. </year>
Reference-contexts: The RTTL proof system is designed for extended state machine and real-time temporal logic (ESM/RTTL) framework, which is developed in <ref> [Ostr86] </ref> and can be used to verify properties that satisfies all legal trajectories or computations of a system. Moreover, the proof system is proven sound in [Ostr89c], i.e. any deduction made from the proof system must be valid. <p> Moreover, the proof system is proven sound in [Ostr89c], i.e. any deduction made from the proof system must be valid. For the example of RTTL proof system, we provide a proof outline for the verification of the train-gate specifications given in Section 3.1, and refer the reader to <ref> [Ostr86] </ref>, [OsWo87], and [Ostr89c] for the proof of soundness and more detail.(See Section 3.1 for the RTTL notation.) The following notation is necessary: f , f 0 , f 1 , ... represent state-formulas, which contain no temporal operators. <p> In <ref> [Ostr86] </ref> and [Ostr89c], heuristic guidelines are provided that facilitate the search for correct proofs. A proof diagram, which is a state transition graph, was then constructed for the invariance property. Therefore, if we can show the S M -validity of then S1 will be S M -valid.
Reference: [Ostr89a] <author> Ostroff, J. </author> <title> ``Verifying finite state real-time discrete event processes,'' </title> <booktitle> Proc. 9th International Conference of Distributed Computing Systems, </booktitle> <pages> pp. 207-216, </pages> <year> 1989. </year>
Reference-contexts: At next step, we check whether the safety assertion is derivable from a set of formulas which are essentially the behavior description of the system. If so, the system is considered safe. 2.2 Timed transition model Timed transition model (TTM) is used to represent real-time discrete event processes in <ref> [Ostr89a] </ref> and [Ostr89b]. This model is an extension of the fair transition system with an addition of a time metric, thus it inherits all features of fair transition systems [MaPn89]. Moreover, there is an external clock which is assumed to tick infinitely often. <p> In such cases, decision procedures provide an alternative to the verification problem. For finite state systems, the verification problem becomes decidable and mechanized procedures or tools for automatic verification are supported in <ref> [Ostr89a] </ref>, [JaSt88], [Jaha89], [GaFr88], [FrGa89], and [Ostr89b]. These procedures will be presented in the next section. V. DECISION PROCEDURES Real-time distributed systems occur in many safety critical applications. Mechanical or automatic procedures for the verification of safe real-time environments is therefore desirable. <p> In addition, [Stua90] implements the method of determining whether a computation graph preserves a RTL formula. 5.3 Reachability graphs In <ref> [Ostr89a] </ref> and [Ostr89b], a timed transition model (TTM) is provided as a generic computational model for real-time systems. Real-time temporal logic (RTTL) is used for expressing the properties to be established. Also a set of decision procedures are developed for verifying a certain class of properties for finite state TTMs. <p> All decision procedures perform reasoning on the reach-ability graph G M . Finite state reachability graphs Two algorithms (RG1 and RG2) are supported in <ref> [Ostr89a] </ref> and [Ostr89b] for computing reachability graphs. RG1 is applied to those TTMs whose transitions have a lower time bound equal to zero, i.e. The TTMs can not model delays [Ostr89a]. <p> Finite state reachability graphs Two algorithms (RG1 and RG2) are supported in <ref> [Ostr89a] </ref> and [Ostr89b] for computing reachability graphs. RG1 is applied to those TTMs whose transitions have a lower time bound equal to zero, i.e. The TTMs can not model delays [Ostr89a]. RG2 is applied when some transitions have non-zero lower time bounds, and hence can be used for any finite state TTM [Ostr89b]. For transitions with non-zero lower bounds, a history must be maintained of when the transition is enable and when the transition becomes eligible for execution. <p> We now present decision procedures for invariance, unless, and eventuality. The detail is in <ref> [Ostr89a] </ref> and [Ostr89b], and it can be seen that the validity of these properties can be checked with linear complexity in the size of reachability graph G M . Invariance procedure It is straightforward to decide an invariance property, which can specify various safety properties (e.g. mutual exclusion). <p> In <ref> [Ostr89a] </ref>, [Ostr89b] and [Ostr89c], two procedures (y -liveness test and y 0 fi &lt;&gt;y ) are developed for checking eventualities properties.
Reference: [Ostr89b] <author> Ostroff, J. </author> <title> ``Real-time temporal logic decision procedures,'' </title> <booktitle> IEEE Real-Time Systems Symposium, </booktitle> <pages> pp. 92-101, </pages> <year> 1989. </year>
Reference-contexts: If so, the system is considered safe. 2.2 Timed transition model Timed transition model (TTM) is used to represent real-time discrete event processes in [Ostr89a] and <ref> [Ostr89b] </ref>. This model is an extension of the fair transition system with an addition of a time metric, thus it inherits all features of fair transition systems [MaPn89]. Moreover, there is an external clock which is assumed to tick infinitely often. <p> Over the past several years, many mathematical logics have been proposed for the assertion languages of real-time systems including computation tree logic ([ClEm83], [ClEm86]), interval logic [ScMe83], probabilistic computation tree logic [HaJo89], global temporal logic and quantized temporal logic [PnHa88], real-time temporal interval logic [NaAa88], real-time temporal logic ([Ostr89a], <ref> [Ostr89b] </ref>, [OsWo87]) and real-time logic ([JaMo86], [JaMo87], [JaSt88], [Jaha89]). However, most of them having no absolute time notion are not suitable for quantitative reasoning of real-time properties except real-time logic, real-time temporal logic, and real-time temporal interval logic. <p> In such cases, decision procedures provide an alternative to the verification problem. For finite state systems, the verification problem becomes decidable and mechanized procedures or tools for automatic verification are supported in [Ostr89a], [JaSt88], [Jaha89], [GaFr88], [FrGa89], and <ref> [Ostr89b] </ref>. These procedures will be presented in the next section. V. DECISION PROCEDURES Real-time distributed systems occur in many safety critical applications. Mechanical or automatic procedures for the verification of safe real-time environments is therefore desirable. Nevertheless, the literature on mechanized verification of real-time properties is scarce. <p> The complexity of the algorithms are exponential in the size of the specification formula, but quadratic in the size of the program. Because many safety and liveness properties can be represented by temporal formulas of small size, it turns out that the proposed algorithms are efficient ([Ostr89a], <ref> [Ostr89b] </ref>, [Ostr89c]). The following is an overview of those decision procedures, which explicitly deal with hard real-time properties, and which are based on the analysis of constraint graphs [JaMo86], computation graphs ([JaSt88], [Jaha89], [Stua90]), or reachability graphs ([Ostr89a], [Ostr89b], [FrGa89], [GaFr88]). 5.1 Constraint graphs In [JaMo86], two existing procedures are suggested <p> small size, it turns out that the proposed algorithms are efficient ([Ostr89a], <ref> [Ostr89b] </ref>, [Ostr89c]). The following is an overview of those decision procedures, which explicitly deal with hard real-time properties, and which are based on the analysis of constraint graphs [JaMo86], computation graphs ([JaSt88], [Jaha89], [Stua90]), or reachability graphs ([Ostr89a], [Ostr89b], [FrGa89], [GaFr88]). 5.1 Constraint graphs In [JaMo86], two existing procedures are suggested for performing safety analysis of real-time systems. These two procedures include: a resolution-based inequality prover [BlHi80], and a decision procedure for quantifier-free Presburger arithmetic having uninterpreted functions [Shos79]. <p> In addition, [Stua90] implements the method of determining whether a computation graph preserves a RTL formula. 5.3 Reachability graphs In [Ostr89a] and <ref> [Ostr89b] </ref>, a timed transition model (TTM) is provided as a generic computational model for real-time systems. Real-time temporal logic (RTTL) is used for expressing the properties to be established. Also a set of decision procedures are developed for verifying a certain class of properties for finite state TTMs. <p> All decision procedures perform reasoning on the reach-ability graph G M . Finite state reachability graphs Two algorithms (RG1 and RG2) are supported in [Ostr89a] and <ref> [Ostr89b] </ref> for computing reachability graphs. RG1 is applied to those TTMs whose transitions have a lower time bound equal to zero, i.e. The TTMs can not model delays [Ostr89a]. RG2 is applied when some transitions have non-zero lower time bounds, and hence can be used for any finite state TTM [Ostr89b]. <p> <ref> [Ostr89b] </ref> for computing reachability graphs. RG1 is applied to those TTMs whose transitions have a lower time bound equal to zero, i.e. The TTMs can not model delays [Ostr89a]. RG2 is applied when some transitions have non-zero lower time bounds, and hence can be used for any finite state TTM [Ostr89b]. For transitions with non-zero lower bounds, a history must be maintained of when the transition is enable and when the transition becomes eligible for execution. To keep track of eligibility, new nodes must be added to the RG2 graph. Therefore, RG2 graph is usually much greater than RG1 graph. <p> We now present decision procedures for invariance, unless, and eventuality. The detail is in [Ostr89a] and <ref> [Ostr89b] </ref>, and it can be seen that the validity of these properties can be checked with linear complexity in the size of reachability graph G M . Invariance procedure It is straightforward to decide an invariance property, which can specify various safety properties (e.g. mutual exclusion). <p> In [Ostr89a], <ref> [Ostr89b] </ref> and [Ostr89c], two procedures (y -liveness test and y 0 fi &lt;&gt;y ) are developed for checking eventualities properties. <p> It follows that an area of future work is to find more properties in which the constructions of finite graphs are possible [Jaha89]. The search of suitable decomposition and refinement techniques for compositional verification is under investigation of [Pnue86] and <ref> [Ostr89b] </ref>. Their suggestion is based on the ground that if a system can be decomposed into small modules, then decision procedures may be helpful in verifying parts of the system.
Reference: [Ostr89c] <author> Ostroff, J. </author> <title> Temporal Logic for Real-Time Systems. </title> <booktitle> Advanced Software Development Series. </booktitle> <publisher> Research Studies Press Limited, </publisher> <year> 1989. </year>
Reference-contexts: In most cases, these two languages are different, hence double-language approach is employed. The representation language is an executable programming language R, which is prescriptive and algorithmic in nature. The other language is the specification or assertion language S, which is descriptive and expressive enough to describe program requirements <ref> [Ostr89c] </ref>. In the work of Manna and Pnueli ([Pnue77], [MaPn81], [MaPn83], [Pnue86]), a fair transition system plays the role of representation language R, and temporal logic is the assertion (or specification) language. <p> The challenge of creating an appropriate specification language for real-time systems is to incorporate a time metric <ref> [Ostr89c] </ref>. According to the role of time, three classes of temporal relationships can be defined [KoKu89]: Qualitative: expressing order in time (e.g. temporal logic). However, this is not enough for real-time. Relative: expressing order and distance in time (e.g. temporal interval logic). <p> Temporal logic We provide a brief summary to Manna-Pnueli temporal logic, which can be used to define the notion of real-time temporal formulas. The readers may refer to [MaPn83], [MaPn89], and <ref> [Ostr89c] </ref> for more details. In temporal logic, two basic operators, (next) and U (until), are used to define many useful operators such as (henceforth), &lt;&gt;(eventually), U (unless), and P (precedes). The variables are partitioned into local variables and global variables; quantification is allowed over global variables only. <p> Some examples of RTTL formulas are given below <ref> [Ostr89c] </ref>. <p> For example, the formula w given by ``x 2 = up; y = approaching'' can describe those states s that satisfies w in the train-gate example (i.e., s (w) = true) <ref> [Ostr89c] </ref>. This is the main idea behind assertional reasoning. 3.2 Propositional Real-time Interval Logic Temporal logic has been advocated by Pnueli [Pnue77] as a suitable language for the behavioral description of concurrent systems. <p> In [BeHa81] and [RoKo83], RTTL were rejected as an assertion language because of the difficulty in knowing when to update the clock variable <ref> [Ostr89c] </ref>. The interval formula in PRTIL can only express the time an event occurs via related events (i.e. express how fast an event reacts to a cause). RTL uses the occurrence function to capture the notion of events and real time. <p> The RTTL proof system is designed for extended state machine and real-time temporal logic (ESM/RTTL) framework, which is developed in [Ostr86] and can be used to verify properties that satisfies all legal trajectories or computations of a system. Moreover, the proof system is proven sound in <ref> [Ostr89c] </ref>, i.e. any deduction made from the proof system must be valid. For the example of RTTL proof system, we provide a proof outline for the verification of the train-gate specifications given in Section 3.1, and refer the reader to [Ostr86], [OsWo87], and [Ostr89c] for the proof of soundness and more <p> the proof system is proven sound in <ref> [Ostr89c] </ref>, i.e. any deduction made from the proof system must be valid. For the example of RTTL proof system, we provide a proof outline for the verification of the train-gate specifications given in Section 3.1, and refer the reader to [Ostr86], [OsWo87], and [Ostr89c] for the proof of soundness and more detail.(See Section 3.1 for the RTTL notation.) The following notation is necessary: f , f 0 , f 1 , ... represent state-formulas, which contain no temporal operators. <p> For all state-formulas f, not containing any occurrence of next transi tion n, (n = t / " f v Verification of S1 We provide a proof outline of S1 (safety) verification from the train-gate exam ple in Section 3.1. <ref> [Ostr89c] </ref> and [OsWo87] may be referred for verifying that the train-gate controller satisfies safety, precedence and real-time liveness properties. S1 (safety): (x 1 = ingate / " x 2 = up) To prove specification S1, we need two properties, which may be obtained from the Succession Axiom AS. <p> In [Ostr86] and <ref> [Ostr89c] </ref>, heuristic guidelines are provided that facilitate the search for correct proofs. A proof diagram, which is a state transition graph, was then constructed for the invariance property. Therefore, if we can show the S M -validity of then S1 will be S M -valid. <p> The verification of a formula by RTTL proof system usually requires the construction of a proof diagram in search for correctness proofs. In addition, the state transition graph can be very large, for example, the size of state space in the train-gate example is about 10 15 states <ref> [Ostr89c] </ref>. In such cases, decision procedures provide an alternative to the verification problem. For finite state systems, the verification problem becomes decidable and mechanized procedures or tools for automatic verification are supported in [Ostr89a], [JaSt88], [Jaha89], [GaFr88], [FrGa89], and [Ostr89b]. These procedures will be presented in the next section. V. <p> Where the real-time properties are treated [Mena85], there are usually restrictions (e.g. states are not allowed for multi-enabled transitions) on the class of Petri nets that can be checked automatically ([Ostr89a], <ref> [Ostr89c] </ref>). On the other hand, there are substantial results for concurrent systems via non real-time temporal logic. Temporal logic model checking came from Clarke, Emerson and others ([EmLe85], [ClEm86], [EmHa86]). In 1981, Clarke created a polynomial time algorithm for model checking, and Emerson extended the ability to handle fairness constraints. <p> The complexity of the algorithms are exponential in the size of the specification formula, but quadratic in the size of the program. Because many safety and liveness properties can be represented by temporal formulas of small size, it turns out that the proposed algorithms are efficient ([Ostr89a], [Ostr89b], <ref> [Ostr89c] </ref>). <p> In [Ostr89a], [Ostr89b] and <ref> [Ostr89c] </ref>, two procedures (y -liveness test and y 0 fi &lt;&gt;y ) are developed for checking eventualities properties. <p> A proof system or decision procedures, which provide us tools to formally prove that a system specification meets its desired safety requirements. In some cases, the system is finite and decision procedures may be applied for automatic verification of system properties <ref> [Ostr89c] </ref>. However, when the state space is large or infinite, the mechanical procedures may not be practical and we have to resort to the proof system. The representation problem Most of the representation languages described in Section 2 are based on state machine model. <p> Decomposition of states: to break down a transition at one level into several transitions at a lower level. The verification problem The RTTL proof system allows for the verification of real-time properties of a finite or infinite system. The proof system is proven sound <ref> [Ostr89c] </ref>, and more work is still needed for a complete and sound RTTL proof system. As far as automatic verification concerns, the applications are usually limited to those cases of finite states, hence there is only a subset of formulas to which the analysis proce-dures can apply.
Reference: [OsWo87] <author> Ostroff, J. and Wonham, W. </author> <title> ``Modelling, Specifying and verifying real-time embedded computer systems,'' </title> <booktitle> Proc. IEEE Real-Time Systems Symposium, </booktitle> <address> San Jose, </address> <pages> pp. 124-132, </pages> <month> Dec. </month> <year> 1987. </year>
Reference-contexts: In the paper of Ostroff and Wonham, extended state machines with time bounded events are employed to describe the real-time discrete event system which consists of processes in the plants and controllers <ref> [OsWo87] </ref>. A global clock and time bounds on the events are used to distinguish between spontaneous and forced events. Here, spontaneous events represent unpredictable changes and forced or guarded events describe non-deterministic behavior. <p> Over the past several years, many mathematical logics have been proposed for the assertion languages of real-time systems including computation tree logic ([ClEm83], [ClEm86]), interval logic [ScMe83], probabilistic computation tree logic [HaJo89], global temporal logic and quantized temporal logic [PnHa88], real-time temporal interval logic [NaAa88], real-time temporal logic ([Ostr89a], [Ostr89b], <ref> [OsWo87] </ref>) and real-time logic ([JaMo86], [JaMo87], [JaSt88], [Jaha89]). However, most of them having no absolute time notion are not suitable for quantitative reasoning of real-time properties except real-time logic, real-time temporal logic, and real-time temporal interval logic. <p> Moreover, the proof system is proven sound in [Ostr89c], i.e. any deduction made from the proof system must be valid. For the example of RTTL proof system, we provide a proof outline for the verification of the train-gate specifications given in Section 3.1, and refer the reader to [Ostr86], <ref> [OsWo87] </ref>, and [Ostr89c] for the proof of soundness and more detail.(See Section 3.1 for the RTTL notation.) The following notation is necessary: f , f 0 , f 1 , ... represent state-formulas, which contain no temporal operators. <p> For all state-formulas f, not containing any occurrence of next transi tion n, (n = t / " f v Verification of S1 We provide a proof outline of S1 (safety) verification from the train-gate exam ple in Section 3.1. [Ostr89c] and <ref> [OsWo87] </ref> may be referred for verifying that the train-gate controller satisfies safety, precedence and real-time liveness properties. S1 (safety): (x 1 = ingate / " x 2 = up) To prove specification S1, we need two properties, which may be obtained from the Succession Axiom AS.
Reference: [PnHa88] <author> Pnueli, A. and Harel, E. </author> <title> ``Applications of temporal logic to the specification of real time systems,'' </title> <publisher> LNCS 331, </publisher> <pages> pp. 84-98, </pages> <year> 1988. </year>
Reference-contexts: In addition, we usually assume that each step takes the same length of time, and thus measure time in steps rather than in real time. In the interleaving model, only one single transition, chosen from one of a set of processes, gets executed at each step <ref> [PnHa88] </ref>. The advantage which interleaving enjoys is that the number of possibilities that have to be considered in each step is much smaller than the first model. Hence interleaving is widely chosen as the representation of parallelism. <p> On the other hand, for the quantitative case, the notion of the neglect of an enabled process can be precisely quantified by demanding that no process can be enabled for more than a maximal period of time without actually completing a transition <ref> [PnHa88] </ref>. The following is an overview of computational models, which are mostly based on interleaving. 2.1 Event-action model Johanian and Mok [JaMo86] modelled the system of interest via event-action model which captures the data dependence and temporal ordering of actions. <p> This allows time as a parameter in computa tions. Over the past several years, many mathematical logics have been proposed for the assertion languages of real-time systems including computation tree logic ([ClEm83], [ClEm86]), interval logic [ScMe83], probabilistic computation tree logic [HaJo89], global temporal logic and quantized temporal logic <ref> [PnHa88] </ref>, real-time temporal interval logic [NaAa88], real-time temporal logic ([Ostr89a], [Ostr89b], [OsWo87]) and real-time logic ([JaMo86], [JaMo87], [JaSt88], [Jaha89]). However, most of them having no absolute time notion are not suitable for quantitative reasoning of real-time properties except real-time logic, real-time temporal logic, and real-time temporal interval logic.
Reference: [Pnue77] <author> Pnueli, A. </author> <title> ``The temporal logic of programs,'' </title> <booktitle> Proc. 18th IEEE Symposium on Foundations of Computer Science, </booktitle> <publisher> Providence, </publisher> <editor> R. I., pp.46-57, </editor> <year> 1977. </year>
Reference-contexts: This is the main idea behind assertional reasoning. 3.2 Propositional Real-time Interval Logic Temporal logic has been advocated by Pnueli <ref> [Pnue77] </ref> as a suitable language for the behavioral description of concurrent systems. This logic has modalities to qualitatively express the present, the next time in the future, sometime in the feature and always in the future.
Reference: [Pnue86] <author> Pnueli, A. </author> <title> ``Applications of temporal logic to the specification and verification of reactive systems: a survey of current trend,'' </title> <editor> In J. de Bakker, W.P. de Roever, and G. Rozenburg, editors, </editor> <booktitle> Current trends in concurrency, </booktitle> <publisher> LNCS 244, Springer-Verlag, </publisher> <year> 1986. </year>
Reference-contexts: The representation language is an executable programming language R, which is prescriptive and algorithmic in nature. The other language is the specification or assertion language S, which is descriptive and expressive enough to describe program requirements [Ostr89c]. In the work of Manna and Pnueli ([Pnue77], [MaPn81], [MaPn83], <ref> [Pnue86] </ref>), a fair transition system plays the role of representation language R, and temporal logic is the assertion (or specification) language. <p> It follows that an area of future work is to find more properties in which the constructions of finite graphs are possible [Jaha89]. The search of suitable decomposition and refinement techniques for compositional verification is under investigation of <ref> [Pnue86] </ref> and [Ostr89b]. Their suggestion is based on the ground that if a system can be decomposed into small modules, then decision procedures may be helpful in verifying parts of the system.
Reference: [Quir85] <author> Quirk, W. J. </author> ` <title> `Verification and Validation of Real-Time Software,'' </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1985. </year>
Reference-contexts: Much research effort has been devoted to develop and apply techniques to improve the reliability of real-time software so that the frequency and consequence of failure are reduced to a level that is reasonably achievable and acceptable <ref> [Quir85] </ref>. Software engineering is one of the two major areas addressing software reliability. It promotes adherence to programming principles to reduce the complexity of large software systems. The other is formal verification methods which attempt to prove the consistency of safety requirements with the system specification [JaMo86].
Reference: [Ramc74] <author> Ramchamdani, C., </author> <title> ``Analysis of asynchronous concurrent systems by timed Petri nets,'' </title> <type> Technical Report MAC TR 120, </type> <institution> MIT, </institution> <month> Feb. </month> <year> 1974. </year>
Reference: [RaPh84] <author> Razouk, R. R. and Phelps, C. V. </author> <title> ``Performance analysis of timed petri nets models,'' </title> <booktitle> Proc. 4th IFIP Int. Workshop on Protocol Specification, Verification and Testing, </booktitle> <pages> pp. 126-129, </pages> <publisher> North Holland, </publisher> <month> Jun. </month> <year> 1984. </year>
Reference-contexts: Mechanical or automatic procedures for the verification of safe real-time environments is therefore desirable. Nevertheless, the literature on mechanized verification of real-time properties is scarce. The analysis of timed Petri nets ([Ramc74], [LeSt87]) is one active research area. For finite state systems, reachability graphs are constructed ([Zube80], <ref> [RaPh84] </ref>). However, their emphasis is on performance evaluation, hence there is no assertion language for specifying hard real-time properties to be established.
Reference: [RoKo83] <author> DeRoever, W. P., Koymans, R. and Vytopil, J. </author> <title> ``Real-Time programming and asynchronous message passing,'' </title> <booktitle> 2nd ACM Symp. on Principles of Distributed Programming, Montreal, </booktitle> <pages> pp. 187-197, </pages> <month> Aug. </month> <year> 1983. </year>
Reference-contexts: As far as formula itself concerns, PRTIL formulas are propositional predicates; the formulas of RTL are boolean combinations of equality and inequality predicates; RTTL formulas consists of temporal formulas, augmented with the notion of data variables. In [BeHa81] and <ref> [RoKo83] </ref>, RTTL were rejected as an assertion language because of the difficulty in knowing when to update the clock variable [Ostr89c]. The interval formula in PRTIL can only express the time an event occurs via related events (i.e. express how fast an event reacts to a cause).
Reference: [ScMe83] <author> Schwartz, R. L., Melliar-Smith, P. M. and Vogt, F. H. </author> <title> ``An interval-based temporal logic,'' </title> <publisher> LNCS 164, </publisher> <pages> pp. 443-457, </pages> <year> 1983. </year>
Reference-contexts: This allows time as a parameter in computa tions. Over the past several years, many mathematical logics have been proposed for the assertion languages of real-time systems including computation tree logic ([ClEm83], [ClEm86]), interval logic <ref> [ScMe83] </ref>, probabilistic computation tree logic [HaJo89], global temporal logic and quantized temporal logic [PnHa88], real-time temporal interval logic [NaAa88], real-time temporal logic ([Ostr89a], [Ostr89b], [OsWo87]) and real-time logic ([JaMo86], [JaMo87], [JaSt88], [Jaha89]). <p> A variety of properties such as safety property, live-ness property and precedence property [MaPn82] can be described by temporal logic [NaAa88]. Although temporal logic is adequate for the behavioral description of concurrent systems, their low level nature incurs an unnecessary amount of detail about states <ref> [ScMe83] </ref>. In order to have more degree of abstraction, [AaNa88] and [ScMe83] support Temporal interval logic as a framework for reasoning about concurrent systems. In general, qualitative description of system behaviors is not enough for real-time systems. <p> Although temporal logic is adequate for the behavioral description of concurrent systems, their low level nature incurs an unnecessary amount of detail about states <ref> [ScMe83] </ref>. In order to have more degree of abstraction, [AaNa88] and [ScMe83] support Temporal interval logic as a framework for reasoning about concurrent systems. In general, qualitative description of system behaviors is not enough for real-time systems. <p> Since these systems often have to deal with stringent timing constraints, the formalism chosen must be capable of expressing hard real-time constraints and facilitate the reasoning about properties of the system. PRTIL is a variant of Propositional temporal interval logic (PRTIL) from <ref> [ScMe83] </ref> with capabilities of expressing qualitative and quantitative aspects of real-time behaviors. In other words, within the framework of logic we must be able to specify the relationship between events and their times of occurrences. <p> On the other hand, when no quantitative aspects ( t or = t) are involved in the interval term I, the construction of the context is the same as that in <ref> [ScMe83] </ref>. [I] f true if the event I does not occur at the given interval &lt; i, j &gt;, or I occurs at some time &lt; t 1 , t 2 &gt; in the interval &lt; i, j &gt; and f is also satis fied in that interval of the event.
Reference: [Shos79] <author> Shostak, R.E. </author> <title> ``A practical decision procedure for arithmetic with function symbols,'' </title> <journal> J. Ass. Comput. Mach., </journal> <volume> vol. 26, </volume> <pages> pp. 351-360, </pages> <month> Apr. </month> <year> 1979. </year>
Reference-contexts: These two procedures include: a resolution-based inequality prover [BlHi80], and a decision procedure for quantifier-free Presburger arithmetic having uninterpreted functions <ref> [Shos79] </ref>. However, these methods may be impractical for large and complex real-time systems, since a mechanical procedure for Presburger arithmetic is at least double exponential and Presburger arithmetic with even a single uninterpreted function is undecidable [JaMo87].
Reference: [StRa88] <author> Stankovic, J.A. and Ramamrithan K. </author> <title> Tutorial Hard Real-Time systems, </title> <address> pp.1-11, </address> <year> 1988. </year>
Reference-contexts: The characteristics of these systems are that severe consequences will result if the logical and physical timing properties of the systems are not met. For example, a real-time system that controls a nuclear power plant or a missile will cause catastrophic consequences on missing timing constraints <ref> [StRa88] </ref>. Thus, these time-critical systems, in general, needs to be predictable and reliable. The predictability of real-time system means that when a task is activated it should be possible to determine whether the deadline can be met. <p> The predictability of real-time system means that when a task is activated it should be possible to determine whether the deadline can be met. On the other hand, real-time constraints can not be achieved if system components are not reliable <ref> [StRa88] </ref>. The reliability is a prerequisite for real-time systems. 1.2 Embedded systems Most of the real-time computer systems are special-purpose and complex, require a high degree of fault tolerance, and are typically ``embedded'' in a large system. <p> Most of current literature on real-time systems has been based on the finite state machine, Petri nets and first order logic. All of these formal approaches attempt to answer this question: Given a system specification, does the specification conform to the safety properties of the system <ref> [StRa88] </ref>? 1.4 Basic components in formal verification In general, the formal methodology for the specification, verification and development of real-time systems consists of several elements as follows [MaPn89]. <p> However, when it comes to real-time systems, the timeliness property, which is essentially one kind of liveness property, is of much importance. The reason is that, in many real-time applications, an appropriate action not taken on time can cause catastrophic effects <ref> [StRa88] </ref>. A proof system, which provides us tools to formally prove that a given program satisfies a given specification. Such a system can be partitioned into three parts: The general part. <p> Examples are [ClEm86] and [LiPn84]. Several technical areas address the predictability and reliability of real-time systems such as real-time operating systems, real-time architecture and hardware, fault tolerance for real-time systems, languages for real-time systems as well as specification and verification of real-time systems <ref> [StRa88] </ref>. This survey deals with the currently available approaches for specification and verification of real-time systems. This paper is organized as follows. Section II presents several computational models that has been proposed for modelling real-time systems. <p> The extension to finite state machines to make them applicable to real-time systems is done as follows. Timing aspects are incorporated via an alarm, an artificial stimulus that arrives if the stimulus needed for a transition does not happen within a specified time <ref> [StRa88] </ref>. In the paper of Ostroff and Wonham, extended state machines with time bounded events are employed to describe the real-time discrete event system which consists of processes in the plants and controllers [OsWo87].
Reference: [Stua90] <author> Stuart, D.A., </author> <title> ``Implementing a verifier for real-time systems,'' </title> <booktitle> IEEE Real-Time Systems Symposium, </booktitle> <pages> pp. 62-71, </pages> <year> 1990. </year>
Reference-contexts: The following is an overview of those decision procedures, which explicitly deal with hard real-time properties, and which are based on the analysis of constraint graphs [JaMo86], computation graphs ([JaSt88], [Jaha89], <ref> [Stua90] </ref>), or reachability graphs ([Ostr89a], [Ostr89b], [FrGa89], [GaFr88]). 5.1 Constraint graphs In [JaMo86], two existing procedures are suggested for performing safety analysis of real-time systems. These two procedures include: a resolution-based inequality prover [BlHi80], and a decision procedure for quantifier-free Presburger arithmetic having uninterpreted functions [Shos79]. <p> After a graph G is generated from the formula F, an analysis procedure is applied to show the unsatisfiability of F as positive cycles are detected in the graph G. 5.2 Computation graphs In [Jaha89], [JaSt88] and <ref> [Stua90] </ref>, Modechart and real-time logic are employed as the specification language and the logic for the dynamics of real-time systems. To verify properties of a system, a decision procedure which makes use of a computation graph is applied to determine the satisfiability of a RTL formula. <p> If no equivalent node is found, the current node is marked as traversed, and its successors are added to the graph as unexplored nodes. Decidable timing properties Two types of formulas for which finite computation graphs can be constructed are identified in [JaSt88] and <ref> [Stua90] </ref>. The following definitions are needed before the formulas can be introduced. An endpoint is denoted by an occurrence function of the form @(E, i), where E is an event constant and i is an integer variable. Two endpoints are related if they have the same variables. <p> The procedure is presented in [JaSt88]. [Jaha89] extends the work, in which some of the timing constraints may be variables, and the undecidability of verifying arbitrary RTL formulas for a given Modechart system is also proven. In addition, <ref> [Stua90] </ref> implements the method of determining whether a computation graph preserves a RTL formula. 5.3 Reachability graphs In [Ostr89a] and [Ostr89b], a timed transition model (TTM) is provided as a generic computational model for real-time systems. Real-time temporal logic (RTTL) is used for expressing the properties to be established.
Reference: [Zave82] <author> Zave, P., </author> <title> ``An operational approach to requirement specification for embedded systems,'' </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. SE-8, No. 3, </volume> <pages> pp. 250-269, </pages> <month> May </month> <year> 1982. </year>
Reference-contexts: The term ``real-time'' is roughly equivalent to ``embedded'' which is widely used by the U.S. Department of Defense in conjunction with its Ada language development project <ref> [Zave82] </ref>. The common practice of real-time systems is to provide continual feedback to an unintelligent environment. This scenario is easily recognized in ight-guidance systems and switching systems. <p> This scenario is easily recognized in ight-guidance systems and switching systems. Due to continual demands of an unintelligent environment, these systems have rigid and urgent performance requirements, such as real-time response requirements and ``fail-safe'' reliability requirements <ref> [Zave82] </ref>. It seems that the emphasis of performance requirements is what characterized real-time systems from other types of systems. 1.3 Formal approaches and real-time software For systems development, methods and languages based on formal theories becoming increasingly popular.
Reference: [Zube80] <author> Zuberek, W.M., </author> <title> ``Timed Petri nets and preliminary evaluation,'' </title> <booktitle> 7th Annual Symposium on Computer Architecture, </booktitle> <pages> pp. 88-96, </pages> <year> 1980. </year>
References-found: 51

