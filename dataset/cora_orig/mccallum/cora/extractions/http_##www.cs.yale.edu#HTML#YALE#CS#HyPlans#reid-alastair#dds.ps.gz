URL: http://www.cs.yale.edu/HTML/YALE/CS/HyPlans/reid-alastair/dds.ps.gz
Refering-URL: http://www.cs.yale.edu/HTML/YALE/CS/HyPlans/reid-alastair/
Root-URL: http://www.cs.yale.edu
Title: Designing Data Structures  
Author: Alastair Reid 
Abstract: The design (as opposed to the choice and use) of data structures has been the subject of relatively little study in the context of formal methods. In this paper, we introduce our ideas on how data structures are designed. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Mary E. d'Imperio, </author> <title> Data Structures and their Representation in Storage, </title> <editor> in Halpern, Shaw (editors), </editor> <booktitle> Annual Review in Automatic Programming, </booktitle> <volume> Volume 5, </volume> <pages> pp. 1-76, </pages> <booktitle> International Tracts in Computer Science and Technology and Their Applications, </booktitle> <publisher> Pergamon Press Ltd., </publisher> <year> 1969. </year>
Reference-contexts: Unfortunately, very little has been written about how these new data structures may be designed | <ref> [1] </ref>, [2] and [3] being the most notable exceptions. This paper is an introduction to the way we think about the design of efficient data structures. We shall be concerned mostly with time efficiency although we recognise that space efficiency is also important.
Reference: [2] <author> Muffy H. Thomas, </author> <title> Implementing Algebraically Specified Abstract Data Types in an Imperative Programming Language, </title> <booktitle> in TAPSOFT '87, Pisa, Italy, Lecture Notes in Computer Science, </booktitle> <volume> Volume 250, </volume> <publisher> Springer Verlag, </publisher> <year> 1987. </year>
Reference-contexts: Unfortunately, very little has been written about how these new data structures may be designed | [1], <ref> [2] </ref> and [3] being the most notable exceptions. This paper is an introduction to the way we think about the design of efficient data structures. We shall be concerned mostly with time efficiency although we recognise that space efficiency is also important. <p> However, this solution is not entirely satisfactory since the information required to make a good (i.e. efficiency inducing) choice of how to strengthen the implementation is not available until implementation has begun. 5 Acknowledgements This work was strongly motivated by and based on work reported in <ref> [2] </ref> and [3]. It was financially supported by an SERC Research Studentship.
Reference: [3] <author> Muffy H. Thomas, </author> <title> The Imperative Implementation of Algebraic Data Types, </title> <institution> Research Report CSC/88/R4, Computing Science Department, University of Glasgow, 1987 (also, </institution> <type> Ph.D. thesis, </type> <institution> University of St. Andrews, </institution> <year> 1987.) </year>
Reference-contexts: Unfortunately, very little has been written about how these new data structures may be designed | [1], [2] and <ref> [3] </ref> being the most notable exceptions. This paper is an introduction to the way we think about the design of efficient data structures. We shall be concerned mostly with time efficiency although we recognise that space efficiency is also important. We begin by briefly describing our notation and semantics. <p> However, this solution is not entirely satisfactory since the information required to make a good (i.e. efficiency inducing) choice of how to strengthen the implementation is not available until implementation has begun. 5 Acknowledgements This work was strongly motivated by and based on work reported in [2] and <ref> [3] </ref>. It was financially supported by an SERC Research Studentship.
Reference: [4] <author> Richard J. Bird and Philip Wadler, </author> <title> An introduction to Functional Programming, </title> <publisher> Prentice-Hall, </publisher> <year> 1988. </year>
Reference-contexts: Finally, we discuss some of the problems with our approach. 2 Definitions Miranda is used for our example specification. We give a brief overview of Miranda notation below. Further details may be found in <ref> [4] </ref>. * [A] is the set of all lists [a 1 ; : : : a m ] with elements drawn from A and m 2 IN. * f :: A ! B states that f is a (Miranda) function with source type A and target type B. * (++) ::
Reference: [5] <author> Aho, Hopcroft, Ullman, </author> <title> The Design and Analysis of Computer Algorithms, </title> <publisher> Addison Wesley, </publisher> <year> 1974. </year>
Reference-contexts: Figure 5 shows the representation used by the example implementation using the traditional style of data structure diagram <ref> [5, pp. 44-45] </ref>. b - - ? front ? rear - link ? entry point - data cell 6 link cell Key Each node contains a number of labelled link cells (e.g. prev and next) and labelled data cells (e.g. item).
Reference: [6] <author> Donald Erwin Knuth, </author> <title> The Art Of Computer Programming, Volume 3, Sorting and Searching, </title> <publisher> Addison Wesley, </publisher> <year> 1973. </year>
Reference-contexts: Since the cost of this reduction in space is relatively high, this optimisation would probably not be justifiable purely in terms of the time-space tradeoff it represents. However, in examples like a priority queue <ref> [6, pp. 150-151] </ref> (or almost any other problem which is usually solved using some form of search) the cost of having an entry point at every cell where the implementation of a modifier may make a change is quite considerable e.g. every ADD (x) in a priority queue could require access
References-found: 6

