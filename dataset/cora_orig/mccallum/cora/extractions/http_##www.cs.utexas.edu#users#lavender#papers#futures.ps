URL: http://www.cs.utexas.edu/users/lavender/papers/futures.ps
Refering-URL: http://www.cs.utexas.edu/users/lavender/papers/index.html
Root-URL: 
Email: g.lavender@isode.com kafura@cs.vt.edu  
Title: A Polymorphic Future and First-class Function Type for Concurrent Object-Oriented Programming  
Author: R. Greg Lavender Dennis G. Kafura 
Note: To be submitted to the Journal of Object-Oriented Systems  
Address: 8920 Business Park Dr. 562 McBryde Hall, Virginia Tech Austin, Texas 78759 Blacksburg, Virginia 24061  
Affiliation: ISODE Consortium Department of Computer Science  
Abstract: A "future" is a typed synchronization mechanism used to represent a value that will come into existence at some point in time after the creation of the future. In this paper, a polymorphic future type is introduced that differs from previous mechanisms in that it provides a first-class, extensible facility for expressing synchronized access to the typed result value of a concurrent computation. The proposed mechanism requires write-once/read-many synchronization, which is implemented in terms of common thread synchronization primitives, thereby ensuring a high-degree of efficiency. The type definition and type specialization features of C++ are used to illustrate how one would implement a polymorphic future type in a strongly typed object-oriented language supporting polymorphic type definitions.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Brian N. Bershad. </author> <title> The PRESTO user's manual. </title> <type> Technical Report 88-01-04, </type> <institution> University of Wash-ington, Department of Computer Science, </institution> <year> 1988. </year>
Reference-contexts: believe that the polymorphic future type can be used with a wide range of existing threads facilities such as: the C threads library provided with Mach [5], the Lightweight Process (LWP) library provided with SunOS or Solaris [23, 24], the POSIX threads library [12, 19], and the Presto threads package <ref> [1, 2] </ref>. In Section 2, the structure of a general future mechanism is described, the condition synchronization issues are discussed, and an implementation in C++ is then presented.
Reference: [2] <author> Brian N. Bershad, Edward D. Lazowska, and Henry M. Levy. </author> <title> PRESTO: A system for object-oriented parallel programming. </title> <journal> Software|Practice and Experience, </journal> <volume> 18(8) </volume> <pages> 713-732, </pages> <month> August </month> <year> 1988. </year> <title> 8 The forthcoming Ada-9X definition does define an inheritance mechanism. </title> <type> 17 </type>
Reference-contexts: believe that the polymorphic future type can be used with a wide range of existing threads facilities such as: the C threads library provided with Mach [5], the Lightweight Process (LWP) library provided with SunOS or Solaris [23, 24], the POSIX threads library [12, 19], and the Presto threads package <ref> [1, 2] </ref>. In Section 2, the structure of a general future mechanism is described, the condition synchronization issues are discussed, and an implementation in C++ is then presented.
Reference: [3] <author> Brian N. Bershad, David D. Redell, and John R. Ellis. </author> <title> Fast mutual exclusion for uniprocessors. </title> <booktitle> In Fifth ACM Symposium on Architectural Support for Programming Languages and Operating Systems (ASPLOS), </booktitle> <pages> pages 223-233, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: As previously demonstrated, the conflict arises because the synchronization conditions are too tightly bound to the monitor operations. The solution outlined previously implements condition synchronization constraints as "virtual" synchronization predicates that are defined independently of 1 Recent work by Bershad <ref> [3] </ref> has shown that mutual exclusion in support of multi-threading on uniprocessor RISC architectures can be made highly efficient even in the absence of explicit hardware support. 5 template&lt;class T&gt; class Capsule : private RWSync f private: T* value; =* generic value binding *= 5 public: inline Capsule () f value
Reference: [4] <author> William Clinger and Jonathan Rees. </author> <title> Revised Report on the Algorithmic Language Scheme, </title> <note> 1992. Version 4. </note>
Reference-contexts: Futures are similar in concept to the delay and force constructs that together support lazy evaluation in sequential Scheme <ref> [4] </ref>.
Reference: [5] <author> Eric C. Cooper and Richard P. Draves. </author> <title> C threads. </title> <type> Technical Report CMU-CS-88-54, </type> <institution> Carnegie Mellon University, School of Computer Science, </institution> <month> September </month> <year> 1990. </year>
Reference-contexts: makes very fl This work was supported in part by National Science Foundation grant CCR-9104013. 1 modest assumptions about the underlying synchronization mechanisms, we believe that the polymorphic future type can be used with a wide range of existing threads facilities such as: the C threads library provided with Mach <ref> [5] </ref>, the Lightweight Process (LWP) library provided with SunOS or Solaris [23, 24], the POSIX threads library [12, 19], and the Presto threads package [1, 2].
Reference: [6] <author> Jack W. Davidson and Anne M. Holler. </author> <title> Subprogram inlining: A study of its effects on program execution time. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-18(2):89-102, </volume> <month> February </month> <year> 1992. </year>
Reference-contexts: Method inlining results in faster code only if the compiler also performs efficient machine register allocation when replacing a procedure call with inlined code. Davidson and Holler <ref> [6] </ref> offer convincing empirical evidence that inlining improves performance more often than not, particularly for small procedures like those defined by the Future&lt;T&gt; template class.
Reference: [7] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: for this operation is as follows: FutureRef operator-&gt;()(int id, int len, ...); The arguments are a method identifier, the length of the argument vector, and an arbitrary argument vector. 6 Interestingly, the semantics given to this operator in ES-Kit are not consistent with the semantics defined by the C++ language <ref> [7] </ref>. The method call operator has no equivalent in standard C++. The ES-Kit method call operator is a combination of the standard C++ unary member access operator "-&gt;" and the binary function call operator "()".
Reference: [8] <author> Andrew S. Grimshaw. </author> <title> Easy-to-use object-oriented parallel processingwith Mentat. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 39-51, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Hence the future functor in CML is more a demonstration of what can be acheived using the features of CML than a useful programming construct. 4.5 Return-to-Future in Mentat Mentat uses asynchronous invocations and a vaule-based return form, which is similar to a future <ref> [8] </ref>. The key characteristic of the Mentat return-to-future (rtf) is that the future object in mentat is implicit. The programmer simply declares the invocation and names the variable to receive the result value. Since the invocation is asynchronous, the value of the return variable is initially undefined.
Reference: [9] <author> Robert H. Halstead, Jr. </author> <title> Multilisp: A language for concurrent symbolic computation. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(4) </volume> <pages> 501-538, </pages> <month> October </month> <year> 1985. </year>
Reference-contexts: in MultiLisp, the promise type in Argus, the Cbox in Concurrent Smalltalk, the future functor in Concurrent ML, the return-to-future mechanism in Mentat, and the future ref in ES-Kit. 4.1 Futures in MultiLisp Halstead introduced the concept of a future as a control abstraction in MultiLisp, a concurrent Scheme implementation <ref> [9] </ref>. Futures are similar in concept to the delay and force constructs that together support lazy evaluation in sequential Scheme [4].
Reference: [10] <author> Christopher T. Haynes, Daniel P. Friedman, and Mitchell Wand. </author> <title> Obtaining coroutines with continuations. </title> <journal> Computer Languages, </journal> 11(3/4):143-153, 1986. 
Reference-contexts: A more theoretical avenue of research is to explore the semantics of polymorphic future types from a denotational perspective. Continuations have mostly been explored in a sequential language setting, primarily in the context of Scheme. Continuations have been used to implement coroutine semantics <ref> [10] </ref>, which is a more limited form of concurrency than assumed by future types. Given the close relationship between continuations and futures in asynchronous invocation semantics, there is the potential for achieving some useful theoretical results relating type conversion and synchronization in the context of polymorphic future types.
Reference: [11] <author> Richard L. Hudson, J. Eliot B. Moss, Amer Diwan, and Christopher F. </author> <title> Weight. A language independent garbage collector toolkit. </title> <note> To appear, </note> <year> 1991. </year>
Reference-contexts: C++ front-end to the GNU gcc 2.x compiler [21] performs efficient method inlining and generates optimized native machine code on a wide range of architectures. 3 A future version of the GNU C++ compiler will employ some support for a generation-scavenging garbage collector, based on work by Moss et al. <ref> [11] </ref>. 7 controlled construction and destruction of Future&lt;T&gt; objects is adopted. This scheme is based on the ability to restrict Future&lt;T&gt; objects so that it is not possible to obtain a pointer to a future object.
Reference: [12] <institution> IEEE Technical Committee on Operating Systems. Threads Extension for Portable Operating Systems, </institution> <month> February </month> <year> 1992. </year> <note> POSIX P1003.4a/D6. </note>
Reference-contexts: assumptions about the underlying synchronization mechanisms, we believe that the polymorphic future type can be used with a wide range of existing threads facilities such as: the C threads library provided with Mach [5], the Lightweight Process (LWP) library provided with SunOS or Solaris [23, 24], the POSIX threads library <ref> [12, 19] </ref>, and the Presto threads package [1, 2]. In Section 2, the structure of a general future mechanism is described, the condition synchronization issues are discussed, and an implementation in C++ is then presented.
Reference: [13] <author> Bill Leddy and Kim Smith. </author> <title> The design of the experimental systems kernel. </title> <booktitle> In Proceedings of the Conference on Hypercube and Concurrent Computer Applications, </booktitle> <address> Monterey, CA, </address> <year> 1989. </year>
Reference-contexts: the result value to all objects awaiting the value. 4.6 Future References in ES-Kit An interesting application of the concept of futures in an imperative setting is the future ref used in the Experimental Systems Kit (ES-Kit), a distributed kernel and run-time system for distributed and parallel programming in C++ <ref> [13] </ref>. 5 A future ref in an ES-Kit application is an instance of a system defined FutureRef class; hence, a future ref object is a first-class type.
Reference: [14] <author> Barbara Liskov. </author> <title> Distributed programming in Argus. </title> <journal> Communications of the ACM, </journal> <volume> 31(3) </volume> <pages> 300-312, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: Argus is a language and a run-time system for programming distributed applications <ref> [14, 15] </ref>. The language is a direct descendant of Clu [16], both in its syntax and semantics. Unlike the dynamically typed MultiLisp, Argus is statically typed; hence, promises are strongly typed.
Reference: [15] <author> Barbara Liskov, Dorothy Curtis, Paul Johnson, and Robert Scheifler. </author> <title> Implementation of Argus. </title> <booktitle> In Eleventh ACM Symposium on Operating System Principles, </booktitle> <pages> pages 111-122, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: Argus is a language and a run-time system for programming distributed applications <ref> [14, 15] </ref>. The language is a direct descendant of Clu [16], both in its syntax and semantics. Unlike the dynamically typed MultiLisp, Argus is statically typed; hence, promises are strongly typed.
Reference: [16] <author> Barbara Liskov and et al. </author> <title> CLU Reference Manual. </title> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: Argus is a language and a run-time system for programming distributed applications [14, 15]. The language is a direct descendant of Clu <ref> [16] </ref>, both in its syntax and semantics. Unlike the dynamically typed MultiLisp, Argus is statically typed; hence, promises are strongly typed. A call-stream is an abstraction that combines the semantics of remote procedure call and message sending by allowing non-blocking procedure invocations.
Reference: [17] <author> Barbara Liskov and John Guttag. </author> <title> Abstraction and Specification in Program Development. </title> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: MCC as part of the Experimental Systems Project in an effort to make C++ usable for distributed and parallel programming. 6 The method identifier corresponds to an entry in the method dispatch table for the object to which the operator is applied (i.e., the vtable). 15 of an iteration abstraction <ref> [17] </ref>. To obtain the binary method call operator, the ES-Kit environment requires a modified compiler; hence, the language is technically a semantic extension of C++.
Reference: [18] <author> Barbara Liskov and Luiba Shrira. </author> <title> Promises: Linguistic support for efficient asynchronous procedure calls in distributed systems. </title> <booktitle> In Proceedings of the SIGPLAN'88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 260-267, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: permit the treatment of a future as an abstract data type allowing the specification of operations (e.g., cancel) on futures themselves and not the values they denote. 13 4.2 Promises in Argus Futures in MultiLisp motivated Liskov to introduce the concept of a promise in conjunction with call-streams in Argus <ref> [18] </ref>. Argus is a language and a run-time system for programming distributed applications [14, 15]. The language is a direct descendant of Clu [16], both in its syntax and semantics. Unlike the dynamically typed MultiLisp, Argus is statically typed; hence, promises are strongly typed.
Reference: [19] <author> Frank Mueller. </author> <title> A library implementation of POSIX threads under Unix. </title> <booktitle> In Proceedings of the 1993 USENIX Winter Conference, </booktitle> <pages> pages 29-41, </pages> <month> January </month> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: assumptions about the underlying synchronization mechanisms, we believe that the polymorphic future type can be used with a wide range of existing threads facilities such as: the C threads library provided with Mach [5], the Lightweight Process (LWP) library provided with SunOS or Solaris [23, 24], the POSIX threads library <ref> [12, 19] </ref>, and the Presto threads package [1, 2]. In Section 2, the structure of a general future mechanism is described, the condition synchronization issues are discussed, and an implementation in C++ is then presented.
Reference: [20] <author> John H. Reppy. </author> <title> Concurrent Programming with Events: The Concurrent ML Manual. </title> <institution> AT&T Bell Laboratories, </institution> <month> February </month> <year> 1993. </year> <note> version 0.9.8. </note>
Reference-contexts: of the Cboxes in the collection to have result values pending using various and/or-synchronization messages (e.g., receiveAnd: and receiveOr:) sent to a Cbox instance representing the collection. 4.4 Future Functors in CML A polymorphic future may be defined in Concurrent ML using either synchronous channels directly, or write-once condition variables <ref> [20] </ref>. The utility of a future in CML is questionable since communication is primarily synchronous. The advantage of a future mechanism arises when there is asynchronous communication.
Reference: [21] <author> Richard M. Stallman. </author> <title> Using and Porting GNU CC. Free Software Foundation, </title> <note> 1992. Version 2.2. </note>
Reference-contexts: However, C++ does not currently provide automatic garbage collection of objects. 3 As an alternative, a simple and efficient reference counting scheme based on the 2 The C++ front-end to the GNU gcc 2.x compiler <ref> [21] </ref> performs efficient method inlining and generates optimized native machine code on a wide range of architectures. 3 A future version of the GNU C++ compiler will employ some support for a generation-scavenging garbage collector, based on work by Moss et al. [11]. 7 controlled construction and destruction of Future&lt;T&gt; objects
Reference: [22] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> second edition, </address> <year> 1986. </year> <month> 18 </month>
Reference-contexts: The method call operator has no equivalent in standard C++. The ES-Kit method call operator is a combination of the standard C++ unary member access operator "-&gt;" and the binary function call operator "()". The access operator is most often used to implement "smart pointers" <ref> [22] </ref>; whereas, the function call operator is often used to implement an iterator as part 5 The GNU C++ compiler [25] was begun by Tiemann at MCC as part of the Experimental Systems Project in an effort to make C++ usable for distributed and parallel programming. 6 The method identifier corresponds
Reference: [23] <author> Sun Microsystems. </author> <title> Sun Release 4.0 Programmer's Reference Manual, </title> <month> March </month> <year> 1990. </year> <title> Section 3L: Lightweight Processes Library. </title>
Reference-contexts: Science Foundation grant CCR-9104013. 1 modest assumptions about the underlying synchronization mechanisms, we believe that the polymorphic future type can be used with a wide range of existing threads facilities such as: the C threads library provided with Mach [5], the Lightweight Process (LWP) library provided with SunOS or Solaris <ref> [23, 24] </ref>, the POSIX threads library [12, 19], and the Presto threads package [1, 2]. In Section 2, the structure of a general future mechanism is described, the condition synchronization issues are discussed, and an implementation in C++ is then presented.
Reference: [24] <author> Sun Microsystems. </author> <title> Sun System Overview, </title> <month> March </month> <year> 1990. </year> <title> Lightweight Processes. </title>
Reference-contexts: Science Foundation grant CCR-9104013. 1 modest assumptions about the underlying synchronization mechanisms, we believe that the polymorphic future type can be used with a wide range of existing threads facilities such as: the C threads library provided with Mach [5], the Lightweight Process (LWP) library provided with SunOS or Solaris <ref> [23, 24] </ref>, the POSIX threads library [12, 19], and the Presto threads package [1, 2]. In Section 2, the structure of a general future mechanism is described, the condition synchronization issues are discussed, and an implementation in C++ is then presented.
Reference: [25] <author> Michael D. Tiemann. </author> <title> User's Guide to GNU C++. Free Software Foundation, </title> <year> 1992. </year>
Reference-contexts: The access operator is most often used to implement "smart pointers" [22]; whereas, the function call operator is often used to implement an iterator as part 5 The GNU C++ compiler <ref> [25] </ref> was begun by Tiemann at MCC as part of the Experimental Systems Project in an effort to make C++ usable for distributed and parallel programming. 6 The method identifier corresponds to an entry in the method dispatch table for the object to which the operator is applied (i.e., the vtable).
Reference: [26] <author> Yasuhiko Yokote. </author> <title> The Design and Implementation of Concurrent Smalltalk. </title> <publisher> World Scientific, </publisher> <year> 1990. </year> <month> 19 </month>
Reference-contexts: If an exception is raised, the exception handling code for type overflow is automatically invoked. 4.3 Cboxes in Concurrent Smalltalk Concurrent Smalltalk, a concurrent extension of sequential Smalltalk, employs a Cbox class to facilitate asynchronous method invocation <ref> [26] </ref>. Method invocation in Concurrent Smalltalk is expressed using a messaging paradigm where messages denoting methods defined in a class definition are sent to instances of the class to effect computation.
References-found: 26

