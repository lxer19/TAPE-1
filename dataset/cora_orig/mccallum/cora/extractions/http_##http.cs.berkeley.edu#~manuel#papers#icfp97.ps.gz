URL: http://http.cs.berkeley.edu/~manuel/papers/icfp97.ps.gz
Refering-URL: http://http.cs.berkeley.edu/~manuel/publications.html
Root-URL: 
Title: Statically Checkable Pattern Abstractions  
Author: Manuel Fahndrich John Boyland 
Address: Berkeley, CA 94720-1776  5000 Forbes Avenue Pittsburgh, PA 15213-3891  
Affiliation: Computer Science Division Department of Electrical Engineering and Computer Science University of California, Berkeley  Computer Science Department Carnegie Mellon University  
Abstract: Pattern abstractions increase the expressiveness of pattern matching, enabling the programmer to describe a broader class of regular forests with patterns. Furthermore, pattern abstractions support code reuse and code factoring, features that facilitate maintenance and evolution of code. Past research on pattern abstractions has generally ignored the aspect of compile-time checks for exhaustiveness and redundancy. In this paper we propose a class of expressive patterns that admits these compile-time checks. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> William E. Aitken and John H. Reppy. </author> <title> Abstract value constructors. </title> <booktitle> In ACM SIGPLAN Workshop on ML and its Applications, </booktitle> <pages> pages 1-11. </pages> <year> 1992. </year>
Reference-contexts: All these extensions match recognizable forests, but do not address pattern abstraction per se. Aitken and Reppy's abstract value constructors (AVC) <ref> [1] </ref> form a subclass of our named patterns without alternation, recursion or node creation. But unlike our patterns, some AVCs can also be used as values. The authors do not address static checking of AVCs. Wadler's views [14] define alternative, free data types that are isomorphic to the underlying representation.
Reference: [2] <author> John Boyland, Charles Farnum, and Susan L. Graham. </author> <title> Attributed transformational code generation for dynamic compilers. </title> <editor> In R. Giegerich and S. L. Graham, editors, </editor> <title> Code Generation Concepts, Tools, Techniques. </title> <booktitle> Workshops in Computer Science, </booktitle> <pages> pages 227-254. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: A pattern compares only a syntactically fixed number of initial nodes of each tree. Second, patterns cannot be used with abstract data types. Third, patterns cannot be named and reused. All problems hamper program development, maintenance, and evolution. A number of proposals have addressed the first problem <ref> [8, 2, 6, 12] </ref>, but without addressing the second one. fl Effort partially sponsored by the Defense Advanced Research Projects Agency, and Rome Laboratory, Air Force Materiel Command, USAF, under agreement number F30602-97-2-0241. The U.S. <p> : r] [[let x 1 = s 1 and : : : and x n = s n in e]] 7 Related Work A class of work extends Hoffman and O'Donnell's [9] simple matchers with complex operations such as the subtree operator of Trafola [8], the vertical iterator of Dora <ref> [2, 6] </ref>, and Queinnec and Geffroy's recursive tree operator [12]. All these extensions match recognizable forests, but do not address pattern abstraction per se. Aitken and Reppy's abstract value constructors (AVC) [1] form a subclass of our named patterns without alternation, recursion or node creation.
Reference: [3] <author> John Tang Boyland. </author> <title> Descriptional Composition of Compiler Components. </title> <type> PhD thesis, </type> <institution> University of Cal-ifornia, Berkeley, </institution> <year> 1996. </year> <note> Available as technical report UCB//CSD-96-916. 7 </note>
Reference-contexts: However, their implementation requires translation via the in function from the underlying data type to the view before matching can be performed. Such a translation is not necessary in our framework. Palao Gostanza et al [11] propose pattern abstractions that completely separate patterns from data types, Boy-land <ref> [3] </ref> implements named patterns with recursion using first-match semantics, and Erwig has a proposal for active patterns [5] in which patterns are parameterized by values as well as patterns.
Reference: [4] <author> F. Warren Burton and Robert D. Cameron. </author> <title> Pattern matching with abstract data types. </title> <journal> Journal of Functional Programming, </journal> <volume> 3(2) </volume> <pages> 171-190, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: The isomorphism is described using in and out functions with general computation. Views naturally admit exhaustiveness and redundancy checks, but whether something constitutes a view can in general not be checked by the compiler. In contrast to our patterns, views can also be used as values. Burton and Cameron <ref> [4] </ref> drop views as values and obtain a system similar to ours. However, their implementation requires translation via the in function from the underlying data type to the view before matching can be performed. Such a translation is not necessary in our framework.
Reference: [5] <author> Martin Erwig. </author> <title> Active patterns. </title> <booktitle> In 8th International Workshop on the Implementation of Function Languages. </booktitle> <year> 1996. </year>
Reference-contexts: Such a translation is not necessary in our framework. Palao Gostanza et al [11] propose pattern abstractions that completely separate patterns from data types, Boy-land [3] implements named patterns with recursion using first-match semantics, and Erwig has a proposal for active patterns <ref> [5] </ref> in which patterns are parameterized by values as well as patterns. All of these mechanisms permit arbitrary computation in patterns and thus cannot be statically analyzed. 8 Conclusions We have described an extension to ML: pattern abstractions with recursion, alternation, and node creation.
Reference: [6] <author> Charles Farnum. </author> <title> Pattern-based languages for prototyp-ing compiler optimizers. </title> <type> PhD thesis, </type> <institution> Computer Science Division|EECS, University of California, Berke-ley, </institution> <month> December </month> <year> 1990. </year> <note> Available as technical report UCB//CSD-90-608. </note>
Reference-contexts: A pattern compares only a syntactically fixed number of initial nodes of each tree. Second, patterns cannot be used with abstract data types. Third, patterns cannot be named and reused. All problems hamper program development, maintenance, and evolution. A number of proposals have addressed the first problem <ref> [8, 2, 6, 12] </ref>, but without addressing the second one. fl Effort partially sponsored by the Defense Advanced Research Projects Agency, and Rome Laboratory, Air Force Materiel Command, USAF, under agreement number F30602-97-2-0241. The U.S. <p> : r] [[let x 1 = s 1 and : : : and x n = s n in e]] 7 Related Work A class of work extends Hoffman and O'Donnell's [9] simple matchers with complex operations such as the subtree operator of Trafola [8], the vertical iterator of Dora <ref> [2, 6] </ref>, and Queinnec and Geffroy's recursive tree operator [12]. All these extensions match recognizable forests, but do not address pattern abstraction per se. Aitken and Reppy's abstract value constructors (AVC) [1] form a subclass of our named patterns without alternation, recursion or node creation.
Reference: [7] <author> Ferenc Gecseg and Magnus Steinby. </author> <title> Tree Automata. </title> <publisher> Akademiai Kiado, </publisher> <address> Budapest, </address> <year> 1984. </year>
Reference-contexts: In this paper we propose a new class of expressive patterns that solve problems one and three. Patterns in this class can be modeled by finite-state tree recognizers. Hence, static checking reduces to the problem of containment between tree recognizers, a property which is decidable <ref> [7] </ref>. A forthcoming technical report will address problem two on integrating our patterns with abstract datatypes. The paper is organized as follows. Section 2 motivates our approach with examples and identifies two syntactic restrictions that are sufficient to guarantee that patterns correspond to finite state tree recognizers. <p> If we restrict patterns to match recognizable forests, compile-time checks 2 are decidable. Recognizable forests are defined to be the forests for which there exist finite-state bottom-up tree rec-ognizers <ref> [7] </ref>. Below we give examples of two classes of patterns that match non-recognizable forests. It turns out that if we syntactically restrict our patterns to avoid these classes, then we can always construct finite tree recognizers for them, which in turn enables the desired compile-time checks. <p> For redundancy, one can test whether p S i p i holds, in which case p is redun dant w.r.t. (p i ). With the transformation to deterministic bottom-up tree automata in Appendix B, these relations are all decidable <ref> [7] </ref>.
Reference: [8] <author> Reinhold Heckmann. </author> <title> A functional language for the specification of complex tree transformations. </title> <editor> In Har-ald Ganzinger, editor, </editor> <booktitle> European Symposium on Programming (ESOP '88), volume 300 of Lecture Notes in Computer Science, </booktitle> <pages> pages 175-190. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1988. </year>
Reference-contexts: A pattern compares only a syntactically fixed number of initial nodes of each tree. Second, patterns cannot be used with abstract data types. Third, patterns cannot be named and reused. All problems hamper program development, maintenance, and evolution. A number of proposals have addressed the first problem <ref> [8, 2, 6, 12] </ref>, but without addressing the second one. fl Effort partially sponsored by the Defense Advanced Research Projects Agency, and Rome Laboratory, Air Force Materiel Command, USAF, under agreement number F30602-97-2-0241. The U.S. <p> e = T p [(p; v) : r] [[let x 1 = s 1 and : : : and x n = s n in e]] 7 Related Work A class of work extends Hoffman and O'Donnell's [9] simple matchers with complex operations such as the subtree operator of Trafola <ref> [8] </ref>, the vertical iterator of Dora [2, 6], and Queinnec and Geffroy's recursive tree operator [12]. All these extensions match recognizable forests, but do not address pattern abstraction per se.
Reference: [9] <author> Christoph M. Hoffmann and Michael J. O'Donnell. </author> <title> Pattern matching in trees. </title> <journal> Journal of the ACM, </journal> <volume> 29(1) </volume> <pages> 68-95, </pages> <month> January </month> <year> 1982. </year>
Reference-contexts: : : : and x n = s n ; v) : r] e = T p [(p; v) : r] [[let x 1 = s 1 and : : : and x n = s n in e]] 7 Related Work A class of work extends Hoffman and O'Donnell's <ref> [9] </ref> simple matchers with complex operations such as the subtree operator of Trafola [8], the vertical iterator of Dora [2, 6], and Queinnec and Geffroy's recursive tree operator [12]. All these extensions match recognizable forests, but do not address pattern abstraction per se.
Reference: [10] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1990. </year>
Reference-contexts: They furthermore break the correspondence between the operational meaning of a patterns and its tree recognizer. 3.2 Static Semantics We give a set of typing rules that extend ML's type system <ref> [10] </ref> for patterns and declarations. The type rules use type environments TE which are finite maps from variables Vars to types t , and pattern environments F , which are finite maps from pattern names Funcs to types t .
Reference: [11] <author> Pedro Palao Gostanza, Ricardo Pe~na, and Manuel Nu~nez. </author> <title> A new look at pattern matching in abstract data types. </title> <booktitle> In Proceedings of the ACM SIGPLAN Inter-nation Conference on Functional Programming (ICFP '96), ACM SIGPLAN Notices, </booktitle> <volume> 31(6) </volume> <pages> 110-121, </pages> <year> 1996. </year>
Reference-contexts: Wadler's views [14] elegantly solve the second problem. However, whether something constitutes a view can in general not be checked by the compiler. Recently a very general solution to all three problems has been proposed by Palao Gostanza et al <ref> [11] </ref>. However, their patterns do not admit compile-time checking. In this paper we propose a new class of expressive patterns that solve problems one and three. Patterns in this class can be modeled by finite-state tree recognizers. <p> Global match only commits to a branch if it matches the input tree w.r.t. the given argument patterns. Local matching enables a simple implementation without backtracking. This choice of semantics is used in Palao Gostanza et al 's active destructors <ref> [11] </ref>. However, as we describe in Sections 4 and 6, the more powerful global match semantics can also be efficiently implemented. Hence, since global match is more expressive and may be more intuitive, we chose global match semantics for our patterns. <p> However, their implementation requires translation via the in function from the underlying data type to the view before matching can be performed. Such a translation is not necessary in our framework. Palao Gostanza et al <ref> [11] </ref> propose pattern abstractions that completely separate patterns from data types, Boy-land [3] implements named patterns with recursion using first-match semantics, and Erwig has a proposal for active patterns [5] in which patterns are parameterized by values as well as patterns.
Reference: [12] <author> Christian Queinnec and Jean-Marie Geffroy. </author> <title> Partial evaluation applied to symbolic pattern matching with intelligent backtrack. In Workshop for Static Analysis. </title> <month> October </month> <year> 1992. </year>
Reference-contexts: A pattern compares only a syntactically fixed number of initial nodes of each tree. Second, patterns cannot be used with abstract data types. Third, patterns cannot be named and reused. All problems hamper program development, maintenance, and evolution. A number of proposals have addressed the first problem <ref> [8, 2, 6, 12] </ref>, but without addressing the second one. fl Effort partially sponsored by the Defense Advanced Research Projects Agency, and Rome Laboratory, Air Force Materiel Command, USAF, under agreement number F30602-97-2-0241. The U.S. <p> : : : and x n = s n in e]] 7 Related Work A class of work extends Hoffman and O'Donnell's [9] simple matchers with complex operations such as the subtree operator of Trafola [8], the vertical iterator of Dora [2, 6], and Queinnec and Geffroy's recursive tree operator <ref> [12] </ref>. All these extensions match recognizable forests, but do not address pattern abstraction per se. Aitken and Reppy's abstract value constructors (AVC) [1] form a subclass of our named patterns without alternation, recursion or node creation. But unlike our patterns, some AVCs can also be used as values.
Reference: [13] <author> P. Sestoft. </author> <title> ML pattern match compilation and partial evaluation. </title> <editor> In O. Danvy, R. Gluck, and P. Thiemann, editors, </editor> <title> Partial Evaluation. </title> <booktitle> International Seminar. Selected Papers, </booktitle> <pages> pages 446-464. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <month> February </month> <year> 1996. </year>
Reference-contexts: Fail =&gt; (T p [(p n ; v)] e n ) handle Fail =&gt; raise Match The simple translation given here does not make use of the many sophisticated techniques for improving the efficiency of pattern-matching, such as jump tables, or Ses-toft's technique for using information known from previous matches <ref> [13] </ref>.
Reference: [14] <author> Philip Wadler. </author> <title> Views: A way for pattern matching to cohabit with data abstraction. </title> <booktitle> In Conference Record of the Fourteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 307-313. </pages> <publisher> ACM Press, </publisher> <address> New York, </address> <month> January </month> <year> 1987. </year>
Reference-contexts: Government. To appear in the 1997 ACM SIGPLAN International Conference on Functional Programming, June 9-11 1997, Amsterdam, Netherlands. Wadler's views <ref> [14] </ref> elegantly solve the second problem. However, whether something constitutes a view can in general not be checked by the compiler. Recently a very general solution to all three problems has been proposed by Palao Gostanza et al [11]. However, their patterns do not admit compile-time checking. <p> Aitken and Reppy's abstract value constructors (AVC) [1] form a subclass of our named patterns without alternation, recursion or node creation. But unlike our patterns, some AVCs can also be used as values. The authors do not address static checking of AVCs. Wadler's views <ref> [14] </ref> define alternative, free data types that are isomorphic to the underlying representation. The isomorphism is described using in and out functions with general computation. Views naturally admit exhaustiveness and redundancy checks, but whether something constitutes a view can in general not be checked by the compiler.
References-found: 14

