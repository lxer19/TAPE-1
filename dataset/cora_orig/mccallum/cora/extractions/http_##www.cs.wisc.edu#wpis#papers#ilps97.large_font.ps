URL: http://www.cs.wisc.edu/wpis/papers/ilps97.large_font.ps
Refering-URL: http://www.cs.wisc.edu/~reps/
Root-URL: 
Email: reps@cs.wisc.edu  
Title: Program Analysis via Graph Reachability  
Author: Thomas Reps 
Web: http://www.cs.wisc.edu/reps/  
Address: 1210 West Dayton Street Madison, WI 53706, USA  
Affiliation: Computer Sciences Department University of Wisconsin  
Abstract: This paper describes how a number of program-analysis problems can be solved by transforming them to graph-reachability problems. Some of the program-analysis problems that are amenable to this treatment include program slicing, certain dataflow-analysis problems, and the problem of approximating the possible shapes that heap-allocated structures in a program can take on. Relationships between graph reachability and other approaches to program analysis are described. Some techniques that go beyond pure graph reachability are also discussed. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Babich, W.A. and Jazayeri, M., </author> <title> The method of attributes for data flow analysis: Part II. Demand analysis, </title> <journal> Acta Inf. </journal> <pages> 10(3) pp. </pages> <month> 265-272 (Oct. </month> <year> 1978). </year>
Reference: 2. <author> Bancilhon, F., Maier, D., Sagiv, Y., and Ullman, J., </author> <title> Magic sets and other strange ways to implement logic programs, pp. </title> <booktitle> 1-15 in Proc. of the Fifth ACM Symp. on Princ. of Database Syst., </booktitle> <address> (Cambridge, MA, </address> <month> Mar. </month> <year> 1986), (1986). </year>
Reference: 3. <author> Banning, J.P., </author> <title> An efficient way to find the side effects of procedure calls and the aliases of variables, pp. </title> <booktitle> 29-41 in Conf. Rec. of the Sixth ACM Symp. on Princ. of Prog. </booktitle> <address> Lang., (San Antonio, TX, </address> <month> Jan. </month> <pages> 29-31, </pages> <address> 1979), </address> <publisher> ACM, </publisher> <address> New York, NY (1979). </address>
Reference-contexts: For example, the MayMod problem determines, for each call site, which variables may be modified during the call. This problem can be decomposed into two phases: computing side effects disregarding aliases (the so-called DMod problem), and computing alias information <ref> [3] </ref>.
Reference: 4. <author> Beeri, C. and Ramakrishnan, R., </author> <title> On the power of magic, pp. </title> <booktitle> 269-293 in Proc. of the Sixth ACM Symp. on Princ. of Database Syst., </booktitle> <address> (San Diego, CA, </address> <month> Mar. </month> <year> 1987), (1987). </year>

Reference: 6. <author> Cousot, P. and Cousot, R., </author> <title> Abstract interpretation: A unified lattice model for static analysis of pro-grams by construction or approximation of fixpoints, pp. </title> <booktitle> 238-252 in Conf. Rec. of the Fourth ACM Symp. on Princ. of Prog. </booktitle> <address> Lang., (Los Angeles, CA, </address> <month> Jan. </month> <pages> 17-19, </pages> <address> 1977), </address> <publisher> ACM, </publisher> <address> New York, NY (1977). </address>
Reference-contexts: Program-analysis frameworks abstract on the common characteristics of some class of program-analysis problems. Examples of analysis frameworks range from the gen/kill dataflow-analysis problems described in many compiler textbooks to much more elaborate frameworks <ref> [6] </ref>. Typically, there is an analysis engine that can find solutions to all problems that can be specified within the framework.
Reference: 7. <author> Duesterwald, E., Gupta, R., and Soffa, </author> <title> M.L., Demand-driven computation of interprocedural data flow, pp. </title> <booktitle> 37-48 in Conf. Rec. of the Twenty-Second ACM Symp. on Princ. of Prog. </booktitle> <address> Lang., (San Fran-cisco, CA, </address> <month> Jan. </month> <pages> 23-25, </pages> <address> 1995), </address> <publisher> ACM, </publisher> <address> New York, NY (1995). </address>
Reference: 8. <author> Ferrante, J., Ottenstein, K., and Warren, J., </author> <title> The program dependence graph and its use in optimization, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 9(3) pp. </pages> <month> 319-349 (July </month> <year> 1987). </year>
Reference: 9. <author> Fischer, C.N. and LeBlanc, </author> <title> R.J., Crafting a Compiler, </title> <publisher> Benjamin/Cummings Publishing Company, Inc., </publisher> <address> Menlo Park, CA (1988). </address>
Reference-contexts: The IFDS problems include, but are not limited to, the classical gen/kill problems (also known as the bit-vector or separable problems), e.g., reaching definitions, available expressions, and live variables. In addition, the IFDS problems include many non-gen/kill problems, including possibly-uninitialized variables, truly-live variables [10], and copy-constant propagation <ref> [9, pp. 660] </ref>. Expressing a problem so that it falls within the IFDS framework may, in some cases, involve a loss of precision. For example, there may be a loss of precision involved in formulating an IFDS version of a problem that must account for aliasing.
Reference: 10. <author> Giegerich, R., Mo .. ncke, U., and Wilhelm, R., </author> <title> Invariance of approximative semantics with respect to program transformation, pp. </title> <booktitle> 1-10 in GI 81: 11th GI Conf., Inf.-Fach. </booktitle> <volume> 50, </volume> <publisher> Springer-Verlag, </publisher> <address> New York, NY (1981). </address>
Reference-contexts: The IFDS problems include, but are not limited to, the classical gen/kill problems (also known as the bit-vector or separable problems), e.g., reaching definitions, available expressions, and live variables. In addition, the IFDS problems include many non-gen/kill problems, including possibly-uninitialized variables, truly-live variables <ref> [10] </ref>, and copy-constant propagation [9, pp. 660]. Expressing a problem so that it falls within the IFDS framework may, in some cases, involve a loss of precision. For example, there may be a loss of precision involved in formulating an IFDS version of a problem that must account for aliasing.
Reference: 11. <author> Grove, D. and Torczon, L., </author> <title> Interprocedural constant propagation: A study of jump function implementation, pp. </title> <booktitle> 90-99 in Proc. of the ACM SIGPLAN 93 Conf. on Prog. Lang. Design and Implementation, </booktitle> <address> (Albuquerque, NM, June 23-25, 1993), </address> <publisher> ACM, </publisher> <address> New York, NY (June 1993). </address>
Reference-contexts: An experiment was carried out in which the exhaustive and demand algorithms were used to perform constant propagation on 38 C programs, which ranged in size from 300 lines to 6,000 lines. The experiment found that g In contrast to previous results for numeric Fortran programs <ref> [11] </ref>, linear-constant propagation found more constants than copy-constant propagation in 6 of the 38 programs. g The demand algorithm, when used to demand values for all uses of scalar integer variables, was faster than the exhaustive algorithm by a factor ranging from 1.14 to about 6.
Reference: 12. <author> Horwitz, S., Reps, T., and Binkley, D., </author> <title> Interprocedural slicing using dependence graphs, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 12(1) pp. </pages> <month> 26-60 (Jan. </month> <year> 1990). </year>
Reference-contexts: The problem of interprocedural slicing concerns how to determine a slice of an entire program, where the slice crosses the boundaries of procedure calls. For this purpose, it is convenient to use system dependence graphs (SDGs), which are a variant of PDGs extended to handle multiple procedures <ref> [12] </ref>. An SDG consists of a collection of procedure dependence graphs (which we will refer to as PDGs)one for each procedure, including the main procedure.
Reference: 13. <author> Horwitz, S., Reps, T., and Sagiv, M., </author> <title> Demand interprocedural dataflow analysis, </title> <institution> TR-1283, Comp. Sci. Dept., Univ. of Wisconsin, Madison, </institution> <address> WI (Aug. </address> <year> 1995). </year>
Reference: 14. <author> Horwitz, S., Reps, T., and Sagiv, M., </author> <title> Demand interprocedural dataflow analysis, </title> <booktitle> SIGSOFT 95: Proc. of the Third ACM SIGSOFT Symp. on the Found. of Softw. </booktitle> <address> Eng., (Wash., DC, </address> <month> Oct. </month> <pages> 10-13, </pages> <year> 1995), </year> <journal> ACM SIGSOFT Softw. Eng. </journal> <note> Notes 20(4) pp. </note> <month> 104-115 </month> <year> (1995). </year>
Reference-contexts: For program-analysis problems that can be expressed as CFL-reachability problems, demand algorithms are typically obtained by solving single-target CFL-reachability problems <ref> [14] </ref>. g The graph-reachability approach provides insight into the prospects for creating parallel program-analysis algorithms.
Reference: 15. <editor> Jones, N.D. and Muchnick, S.S., </editor> <title> Flow analysis and optimization of Lisp-like structures, pp. 102-131 in Program Flow Analysis: Theory and Applications, </title> <editor> ed. S.S. Muchnick and N.D. Jones,Prentice-Hall, </editor> <address> Englewood Cliffs, NJ (1981). </address>
Reference-contexts: two tree grammars: (i) v r,A fi cons (v p,B , v p,C ) | cons (v q,D , v q,E ) (ii) v r,A fi cons (v p,B | v q,D , v p,C | v q,E ) Grammar (i) uses multiple cons right-hand sides for a given nonterminal <ref> [15] </ref>. In grammar (ii), the link between branches in different cons alternatives is broken, and a single cons right-hand side is formed with a collection of alternative nonterminals in each arm [23].
Reference: 16. <author> Kildall, G., </author> <title> A unified approach to global program optimization, pp. </title> <booktitle> 194-206 in Conf. Rec. of the First ACM Symp. on Princ. of Prog. Lang., ACM, </booktitle> <address> New York, NY (1973). </address>
Reference-contexts: of q; the goal is to determine, for each node n, the meet-over-all-paths solution: MOP n = q Paths (start, n) c dd c pf q ( i c i ), where Paths (start, n) denotes the set of paths in the control-flow graph from the start node to n <ref> [16] </ref>. 2 MOP n represents a summary of the possible execution states that can arise at n; i c i V is a special value that represents the execution state at the beginning of the program; pf q ( i c i ) represents the contribution of path q to the
Reference: 17. <author> Knoop, J. and Steffen, B., </author> <title> The interprocedural coincidence theorem, pp. </title> <booktitle> 125-140 in Proc. of the Fourth Int. Conf. on Comp. Construct., (Paderborn, </booktitle> <address> FRG, </address> <month> Oct. </month> <pages> 5-7, </pages> <year> 1992), </year> <title> Lec. </title> <booktitle> Notes in Comp. Sci., </booktitle> <volume> Vol. 641, </volume> <editor> ed. U. Kastens and P. Pfahler,Springer-Verlag, </editor> <address> New York, NY (1992). </address>
Reference: 18. <author> Kuck, D.J., Kuhn, R.H., Leasure, B., Padua, D.A., and Wolfe, M., </author> <title> Dependence graphs and compiler optimizations, pp. </title> <booktitle> 207-218 in Conf. Rec. of the Eighth ACM Symp. on Princ. of Prog. </booktitle> <address> Lang., (Willi-amsburg, VA, </address> <month> Jan. </month> <pages> 26-28, </pages> <address> 1981), </address> <publisher> ACM, </publisher> <address> New York, NY (1981). </address>
Reference: 19. <author> Landi, W. and Ryder, B.G., </author> <title> Pointer-induced aliasing: A problem classification, pp. </title> <booktitle> 93-103 in Conf. Rec. of the Eighteenth ACM Symp. on Princ. of Prog. </booktitle> <address> Lang., (Orlando, FL, </address> <month> Jan. </month> <year> 1991), </year> <booktitle> ACM, </booktitle> <address> New York, NY (1991). </address>
Reference: 20. <author> Masinter, L.M., </author> <title> Global program analysis in an interactive environment, </title> <type> Tech. Rep. </type> <institution> SSL-80-1, Xerox Palo Alto Res. Cent., </institution> <address> Palo Alto, CA (Jan. </address> <year> 1980). </year>
Reference-contexts: It is desirable to have program-development tools in which the user can ask questions interactively about various aspects of a program <ref> [20] </ref>. Such tools are particularly useful when debugging, when trying to understand complicated code, or when trying to transform a program to execute efficiently on a parallel machine.
Reference: 21. <author> McCarthy, J., </author> <title> A basis for a mathematical theory of computation, </title> <note> pp. 33-70 in Computer Programming and Formal Systems, </note> <editor> ed. Braffort and Hershberg,North-Holland, </editor> <address> Amsterdam (1963). </address>
Reference-contexts: Thus, the second and third rules of the L 1 grammar are the grammar-theoretic analogs of McCarthy's rules: car (cons (x, y)) = x and cdr (cons (x, y)) = y <ref> [21] </ref>. Invited paper, 1997 Int. Logic Prog.
Reference: 22. <author> Melski, D. and Reps, T., </author> <title> Interconvertibility of set constraints and context-free language reachability, pp. </title> <booktitle> 74-89 in Proc. of the ACM SIGPLAN Symp. on Part. Eval. and Sem.-Based Prog. </booktitle> <address> Manip. (PEPM 97), (Amsterdam, The Netherlands, June 12-13, 1997), </address> <publisher> ACM, </publisher> <address> New York, NY (1997). </address>
Reference-contexts: That is, there are other program-analysis problems that can be solved by expressing them as L-path problems, where L is a context-free language that is something other than a language of partially balanced parentheses <ref> [22] </ref>. 3.1. Interprocedural Dataflow Analysis Dataflow analysis is concerned with determining an appropriate dataflow value to associate with each point p in a program to summarize (safely) some aspect of the execution state that holds when control reaches p. <p> The solution is obtained from the edges labeled with the grammar's root symbol. When an appropriate worklist algorithm is used, the running time of this algorithm is cubic in the number of nodes in the graph <ref> [22] </ref>. (This algorithm can be thought of as a generalization of the CYK algorithm for CFL-recognition [38].) Although all CFL-reachability problems can be solved in time cubic in the number of graph nodes, one can sometimes do asymptotically better than this by taking advantage of the structure of the graph that
Reference: 23. <author> Mogensen, T., </author> <title> Separating binding times in language specifications, pp. </title> <booktitle> 12-25 in Fourth Int. Conf. on Func. Prog. and Comp. Arch., </booktitle> <address> (London, UK, </address> <month> Sept. </month> <pages> 11-13, </pages> <address> 1989), </address> <publisher> ACM, </publisher> <address> New York, NY (1989). </address>
Reference-contexts: In our work, however, we use an alternative approach: The value of each dataflow variable is a single Shape (i.e., a single set of root-to-leaf paths), and the join operation is union <ref> [23] </ref>. Functions cons, car, and cdr are functions from Shape to Shape. <p> In grammar (ii), the link between branches in different cons alternatives is broken, and a single cons right-hand side is formed with a collection of alternative nonterminals in each arm <ref> [23] </ref>. The shape descriptions are sharper with grammars of type (i): With grammar (i), nonterminals v p,B and v q,E can never occur simultaneously as children of v r,A , whereas grammar (ii) associates nonterminal v r,A with trees of the form cons (v p,B , v q,E ).
Reference: 24. <author> Ottenstein, K.J. and Ottenstein, L.M., </author> <title> The program dependence graph in a software development environment, </title> <journal> Proc. of the ACM SIGSOFT/SIGPLAN Softw. Eng. Symp. on Practical Softw. </journal> <pages> Develop. </pages> <address> Env., (Pittsburgh, PA, </address> <month> Apr. </month> <pages> 23-25, </pages> <year> 1984), </year> <journal> SIGPLAN Not. </journal> <pages> 19(5) pp. </pages> <month> 177-184 (May </month> <year> 1984). </year>
Reference-contexts: Consequently, a slice can be obtained by following chains of dependences in the directly-affects relation. This observation is due to Ottenstein and Ottenstein <ref> [24] </ref>, who noted that program dependence graphs (PDGs), which were originally devised for use in parallelizing and vectorizing compilers, are a convenient data structure for slicing. The PDG for a program is a directed graph whose nodes are connected by several kinds of edges.
Reference: 25. <author> Reps, T., Sagiv, M., and Horwitz, S., </author> <title> Interprocedural dataflow analysis via graph reachability, </title> <type> TR 94-14, </type> <institution> Datalogisk Institut, Univ. of Copenhagen, Copenhagen, Denmark (Apr. </institution> <year> 1994). </year>
Reference-contexts: those that correspond to realizable paths in G * ; these are exactly the realizable paths in G # . (For a proof that a dataflow fact d is in MRP n iff there is a realizable path in G # from node start main ,L to node n,d, see <ref> [25] </ref>.) Example. The exploded supergraph that corresponds to the instance of the possibly-uninitialized variables problem shown in Fig. 1 is shown in Fig. 3. The dataflow functions are replaced by their representation relations. In Fig. 3, closed circles represent nodes that are reachable along realizable paths from start main ,L.
Reference: 26. <author> Reps, T., Horwitz, S., Sagiv, M., and Rosay, G., </author> <title> Speeding up slicing, </title> <booktitle> SIGSOFT 94: Proc. of the Second ACM SIGSOFT Symp. on the Found. of Softw. </booktitle> <address> Eng., (New Orleans, LA, </address> <month> Dec. </month> <pages> 7-9, </pages> <year> 1994), </year> <journal> ACM SIGSOFT Softw. Eng. </journal> <note> Notes 19(5) pp. 11-20 (Dec. </note> <year> 1994). </year>
Reference-contexts: A similar improvement over the general-case time bound can be obtained for interprocedural slicing, as well <ref> [26] </ref>. 5. Solving Demand Versions of Program-Analysis Problems An exhaustive dataflow-analysis algorithm associates with each point in a program a set of dataflow facts that are guaranteed to hold whenever that point is reached during program execution. <p> There are no more than CallSites Params 2 summary edges, and the task of identifying all summary edges can be performed in time O ((P E Params) + (CallSites Params 3 )) <ref> [26] </ref>. By the augmented SDG, we mean the SDG after all appropriate summary edges have been added to it. The second, demand-driven, stage involves only regular-reachability problems on the augmented SDG.
Reference: 27. <author> Reps, T., </author> <title> Demand interprocedural program analysis using logic databases, </title> <note> pp. 163-196 in Applications of Logic Databases, </note> <editor> ed. R. </editor> <publisher> Ramakrishnan,Kluwer Academic Publishers, </publisher> <address> Boston, MA (1994). </address> <note> Invited paper, 1997 Int. Logic Prog. Symp., (Port Jefferson, </note> <institution> NY, </institution> <month> Oct. </month> <pages> 12-17, </pages> <year> 1997) </year>
Reference-contexts: For instance, algorithms for demand versions of program-analysis problems can be obtained from their exhaustive counterparts essentially for free by specifying the problem with Horn clauses and then applying the Magic-sets transformation <ref> [27] </ref>. <p> fact that CFL-reachability problems are related to chain programs, together with the fact that chain programs are just a special case of the logic programs to which tabulation and transformation techniques apply, suggests that more powerful program-analysis algorithms can be obtained by going outside the class of pure chain programs <ref> [27] </ref>. A different way to generalize the CFL-reachability approach so as to bring more powerful techniques to bear on interprocedural dataflow analysis was presented in [31].
Reference: 28. <author> Reps, T., Horwitz, S., and Sagiv, M., </author> <title> Precise interprocedural dataflow analysis via graph reachabil--ity, pp. </title> <booktitle> 49-61 in Conf. Rec. of the Twenty-Second ACM Symp. on Princ. of Prog. </booktitle> <address> Lang., (San Fran-cisco, CA, </address> <month> Jan. </month> <pages> 23-25, </pages> <address> 1995), </address> <publisher> ACM, </publisher> <address> New York, NY (1995). </address>
Reference: 29. <author> Reps, T., </author> <title> On the sequential nature of interprocedural program-analysis problems, </title> <journal> Acta Inf. </journal> <pages> 33 pp. </pages> <month> 739-757 </month> <year> (1996). </year>
Reference-contexts: The connection between program analysis and CFL-reachability has been used to establish a number of results that very likely imply that there are limitations on the ability to create efficient parallel algorithms for interprocedural slicing and interprocedural dataflow analysis <ref> [29] </ref>. Specifically, it was shown that - Interprocedural slicing is log-space complete for P. - Interprocedural dataflow analysis is P-hard. - Interprocedural dataflow-analysis problems that involve finite sets of dataflow facts (such as the clas sical gen/kill problems) are log-space complete for P.
Reference: 30. <author> Reynolds, </author> <title> J.C., Automatic computation of data set definitions, pp. </title> <booktitle> 456-461 in Information Processing 68: Proc. of the IFIP Congress 68, </booktitle> <publisher> North-Holland, </publisher> <address> New York, NY (1968). </address>
Reference-contexts: This indirect information can be viewed as a simplified set of equations <ref> [30] </ref>, or, equivalently, as a regular-tree grammar [15,23]. The use of domain Shape in place of 2 Shape does involve some loss of precision.
Reference: 31. <author> Sagiv, M., Reps, T., and Horwitz, S., </author> <title> Precise interprocedural dataflow analysis with applications to constant propagation, </title> <journal> Theor. Comp. Sci. </journal> <pages> 167 pp. </pages> <month> 131-170 </month> <year> (1996). </year>
Reference-contexts: A different way to generalize the CFL-reachability approach so as to bring more powerful techniques to bear on interprocedural dataflow analysis was presented in <ref> [31] </ref>. This method applies to problems in which the dataflow information at a program point is represented by a finite environment (i.e., a mapping from a finite set of symbols to a finite-height domain of values), and the effect of a program operation is captured by a distributive environment-transformer function. <p> transformation similar to the one utilized in Section 3.1, an interprocedural distributive-environment-transformer problem can be transformed from a meet-over-all-realizable-paths problem on a program's supergraph to a meet-over-all-realizable-paths problem on a graph that is larger, but in which every edge is labeled with a much simpler edge function (a so-called micro-function) <ref> [31] </ref>. Each micro-function on an edge d 1 fi d 2 captures the effect that the value of symbol d 1 in the argument Invited paper, 1997 Int. Logic Prog. Symp., (Port Jefferson, NY, Oct. 12-17, 1997) environment has on the value of symbol d 2 in the result environment. <p> exploded supergraph can be used to find the meet-over-all-realizable-paths solution to the original problem: An exhaustive algorithm can be used to find the values for all symbols at all program points; a demand algorithm can be used to find the value for an individual symbol at a particular program point <ref> [31] </ref>. An experiment was carried out in which the exhaustive and demand algorithms were used to perform constant propagation on 38 C programs, which ranged in size from 300 lines to 6,000 lines.
Reference: 32. <author> Sharir, M. and Pnueli, A., </author> <title> Two approaches to interprocedural data flow analysis, pp. 189-233 in Program Flow Analysis: Theory and Applications, </title> <editor> ed. S.S. Muchnick and N.D. Jones,Prentice-Hall, </editor> <address> Englewood Cliffs, NJ (1981). </address>
Reference: 33. <author> Tip, F., </author> <title> A survey of program slicing techniques, </title> <editor> J. </editor> <booktitle> Program. Lang. </booktitle> <pages> 3 pp. </pages> <month> 121-181 </month> <year> (1995). </year>
Reference-contexts: Slicing, and subsequent manipulation of slices, has applications in many software-engineering tools, including tools for program understanding, maintenance, debugging, testing, differencing, specialization, reuse, and merging. (See <ref> [33] </ref> for references to the literature.) There are two kinds of slices: a backward slice of a program with respect to a set of program elements S is the set of all program elements that might affect (either directly or transitively) the values of the variables used at members of S;
Reference: 34. <author> Valiant, L.G., </author> <title> General context-free recognition in less than cubic time, </title> <journal> J. Comp. Syst. Sci. </journal> <pages> 10(2) pp. </pages> <month> 308-315 (Apr. </month> <year> 1975). </year>
Reference-contexts: the general case relates to the special cases of ordinary reachability and CFL-recognition: g A single-source ordinary reachability problem can be solved in time linear in the size of the graph (nodes plus edges) using depth-first search. g Valiant showed that CFL-recognition can be performed in less than cubic time <ref> [34] </ref>. Unfortunately, the algorithm does not seem to generalize to arbitrary CFL-reachability problems. From the standpoint of program analysis, the CFL-reachability constraint is a tool that can be employed to filter out paths that are irrelevant to the solution of an analysis problem.
Reference: 35. <author> Warren, </author> <title> D.S., Memoing for logic programs, </title> <journal> Commun. ACM 35(3) pp. </journal> <month> 93-111 (Mar. </month> <year> 1992). </year>
Reference-contexts: A CFL-reachability problem can be solved using bottom-up semi-naive evaluation of the chain program [37]. This observation provides a way for program-analysis tools to take advantage of the methods developed in the logic-programming and deductive-database communities for the efficient evaluation of recursive queries in deductive databases, such as tabulation <ref> [35] </ref> and the Magic-sets transformation [2,4]. For instance, algorithms for demand versions of program-analysis problems can be obtained from their exhaustive counterparts essentially for free by specifying the problem with Horn clauses and then applying the Magic-sets transformation [27].
Reference: 36. <author> Weiser, M., </author> <title> Program slicing, </title> <journal> IEEE Trans. on Softw. Eng. SE-10(4) pp. </journal> <month> 352-357 (July </month> <year> 1984). </year>
Reference-contexts: In the dependence graph, the edges shown in boldface are the edges in the slice. left. One algorithm for interprocedural slicing was presented in Weiser's original paper on slicing <ref> [36] </ref>. This algorithm is equivalent to solving an ordinary reachability problem on the SDG. However, Weiser's algorithm is imprecise in the sense that it may report effects that are transmitted through paths that have mismatched calls and returns (and hence do not represent feasible execution paths).
Reference: 37. <author> Yannakakis, M., </author> <booktitle> Graph-theoretic methods in database theory, </booktitle> <pages> pp. </pages> <booktitle> 230-242 in Proc. of the Ninth ACM Symp. on Princ. of Database Syst., </booktitle> <year> (1990). </year>
Reference-contexts: There is an L-path from s to t iff w L <ref> [37] </ref>. There is a general result that all CFL-reachability problems can be solved in time cubic in the number of nodes in the graph (see Section 4). This method provides the analysis engine for our program-analysis framework. <p> A CFL-reachability problem can be solved using bottom-up semi-naive evaluation of the chain program <ref> [37] </ref>. This observation provides a way for program-analysis tools to take advantage of the methods developed in the logic-programming and deductive-database communities for the efficient evaluation of recursive queries in deductive databases, such as tabulation [35] and the Magic-sets transformation [2,4].
Reference: 38. <author> Younger, D.H., </author> <title> Recognition and parsing of context-free languages in time n**3, </title> <journal> Inf. and Cont. </journal> <pages> 10 pp. </pages> <month> 189-208 </month> <year> (1967). </year>
Reference-contexts: When an appropriate worklist algorithm is used, the running time of this algorithm is cubic in the number of nodes in the graph [22]. (This algorithm can be thought of as a generalization of the CYK algorithm for CFL-recognition <ref> [38] </ref>.) Although all CFL-reachability problems can be solved in time cubic in the number of graph nodes, one can sometimes do asymptotically better than this by taking advantage of the structure of the graph that arises in a program-analysis problem.
Reference: 39. <author> Zadeck, F.K., </author> <title> Incremental data flow analysis in a structured program editor, </title> <booktitle> Proc. of the SIGPLAN 84 Symp. on Comp. Construct., </booktitle> <address> (Montreal, Can., </address> <month> June 20-22, </month> <year> 1984), </year> <journal> SIGPLAN Not. </journal> <pages> 19(6) pp. </pages> <month> 132-143 (June </month> <year> 1984). </year> <title> Invited paper, </title> <booktitle> 1997 Int. Logic Prog. Symp., (Port Jefferson, </booktitle> <address> NY, </address> <month> Oct. </month> <pages> 12-17, </pages> <year> 1997) </year>
References-found: 38

