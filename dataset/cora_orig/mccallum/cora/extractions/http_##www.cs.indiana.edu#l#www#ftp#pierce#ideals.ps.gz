URL: http://www.cs.indiana.edu/l/www/ftp/pierce/ideals.ps.gz
Refering-URL: http://www.cs.indiana.edu/l/www/ftp/pierce/
Root-URL: http://www.cs.indiana.edu
Title: FAITHFUL IDEAL MODELS FOR RECURSIVE POLYMORPHIC TYPES  
Author: MART IN ABADI BENJAMIN PIERCE GORDON PLOTKIN 
Keyword: Polymorphism, recursive types, full abstraction, ideals, metric models.  
Address: 130 Lytton Avenue Palo Alto, CA 94301, USA  5000 Forbes Avenue Pittsburgh, PA 15213, USA  King's Building  Edinburgh, EH9 3JZ, UK  
Affiliation: Digital Equipment Corporation Systems Research Center  School of Computer Science Carnegie Mellon University  Department of Computer Science  University of Edinburgh  
Abstract: We explore ideal models for a programming language with recursive polymorphic types, variants of the model studied by MacQueen, Plotkin, and Sethi. The use of suitable ideals yields a close fit between models and programming language. Two of our semantics of type expressions are faithful, in the sense that programs that behave identically in all contexts have exactly the same types. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Robin Milner. </author> <title> Fully abstract models of typed -calculi. </title> <journal> Theoretical Computer Science, </journal> <volume> 4 </volume> <pages> 1-22, </pages> <year> 1977. </year>
Reference-contexts: 1. Introduction Often, a formal semantics assigns different values to programs that behave identically in all contexts <ref> [1, 2, 3] </ref>. In other words, the semantics of programming-language expressions is not fully abstract. This mismatch between model and programming language elicits diverse reactions. Some propose extensions to the programming language, while others prefer modifying the semantics. Both of these attitudes have suggested fruitful lines of research. <p> At any rate, we use cases only for writing a limited family of expressions. It is common to assume that similar expressions are definable <ref> [1] </ref>, and we include cases only to make their definition straightforward. 2.2. <p> In this notation, the refined definition of full abstraction simply says that &lt; ~ and v are identical on denotable elements. Note that, in either case, as in <ref> [1] </ref>, full abstraction is a purely semantic criterion and does not refer to a particular operational semantics. This is a convenient way to consider the full-abstraction property as an intrinsic feature of a semantics.
Reference: [2] <author> Gordon Plotkin. </author> <title> LCF considered as a programming language. </title> <journal> Theoretical Computer Science, </journal> <volume> 5 </volume> <pages> 223-256, </pages> <year> 1977. </year>
Reference-contexts: 1. Introduction Often, a formal semantics assigns different values to programs that behave identically in all contexts <ref> [1, 2, 3] </ref>. In other words, the semantics of programming-language expressions is not fully abstract. This mismatch between model and programming language elicits diverse reactions. Some propose extensions to the programming language, while others prefer modifying the semantics. Both of these attitudes have suggested fruitful lines of research. <p> In these models, explode-jj-or returns wrong with a binary boolean function as input, and hence it seems ill-typed. On the other hand, it is well-known that the parallel-or function cannot be expressed in the usual lambda calculus, as studied by Plotkin <ref> [2] </ref>. Therefore, whenever explode-jj-or is applied to an expression in the language that represents a binary boolean function, explode-jj-or returns true if it terminates.
Reference: [3] <author> Allen Stoughton. </author> <title> Fully Abstract Models of Programming Languages. </title> <booktitle> Pitman/Wiley, 1988. Research Notes in Theoretical Computer Science. </booktitle>
Reference-contexts: 1. Introduction Often, a formal semantics assigns different values to programs that behave identically in all contexts <ref> [1, 2, 3] </ref>. In other words, the semantics of programming-language expressions is not fully abstract. This mismatch between model and programming language elicits diverse reactions. Some propose extensions to the programming language, while others prefer modifying the semantics. Both of these attitudes have suggested fruitful lines of research.
Reference: [4] <author> Albert Meyer. </author> <title> Semantical paradigms: </title> <booktitle> notes for an invited lecture. In Proceedings of the Third Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 236-253, </pages> <month> July </month> <year> 1988. </year> <title> With two appendices by Stavros S. </title> <type> Cosmadakis. </type>
Reference-contexts: Both of these attitudes have suggested fruitful lines of research. Yet others point out that the semantics still serves its purposes fairly well, for example in proving the safety of evaluation schemes. At any rate, full abstraction is one of the main criteria in assessing programming-language semantics <ref> [4] </ref>. A similar situation commonly arises in the semantics of type systems. In its simplest form, a semantics for a type system maps each type expression to a reasonable subset of the domain of values. Let us call these subsets types. <p> Other notions of observation are also justifiable; for instance, we might care about the set of contexts C such that [[C [e]]] is a boolean value. Fortunately, many reasonable kinds of observation are equivalent to the one we choose (see <ref> [4] </ref> for an informal discussion of this point). Thus, full abstraction requires that, for all e and e', whenever [[C [e]]] =? if and only if [[C [e']]] =? for all contexts C, it must also be the case that [[e]] = [[e']]. <p> Proving that these definitions do coincide, however, may pose a hard adequacy problem; see <ref> [4, 9] </ref> for a discussion of adequacy. For instance, one has to show that [[e]] 2 T if and only if e ) e' implies e' 2 ftrue; falseg, and similarly that [[e]] 2 (V!V) if and only if e ) e' implies e' 2 F.
Reference: [5] <author> Robin Milner. </author> <title> A proposal for Standard ML. </title> <booktitle> In Proceedings of the 1984 ACM Symposium on Lisp and Functional Programming, </booktitle> <pages> pages 184-197, </pages> <month> August </month> <year> 1984. </year>
Reference-contexts: The converse is false, however, and it seems intriguing (and perhaps easier) to study faithfulness in isolation from full abstraction. In this paper, we give semantics for a language with recursive polymorphic types, like Standard ML <ref> [5] </ref>. Imitating MacQueen, Plotkin, and Sethi, we adopt and extend the ideal model [6]. In the ideal model, type expressions are interpreted as ideals, certain subsets of the universe of values. We place new restrictions on ideals, defining the classes of generated ideals, coarse ideals, and abstract ideals.
Reference: [6] <author> David MacQueen, Gordon Plotkin, and Ravi Sethi. </author> <title> An ideal model for recursive polymorphic types. </title> <journal> Information and Control, </journal> <volume> 71 </volume> <pages> 95-130, </pages> <year> 1986. </year>
Reference-contexts: The converse is false, however, and it seems intriguing (and perhaps easier) to study faithfulness in isolation from full abstraction. In this paper, we give semantics for a language with recursive polymorphic types, like Standard ML [5]. Imitating MacQueen, Plotkin, and Sethi, we adopt and extend the ideal model <ref> [6] </ref>. In the ideal model, type expressions are interpreted as ideals, certain subsets of the universe of values. We place new restrictions on ideals, defining the classes of generated ideals, coarse ideals, and abstract ideals. In our variants of the model, type expressions are interpreted as ideals in these classes. <p> We also define faithfulness precisely. In Section 3 we study the generated ideals; this section contains analogues to the central results in <ref> [6] </ref>. In Section 4 we use the generated ideals to give a semantics to type expressions, and then restrict our attention to special classes of generated ideals; we prove that two semantics are faithful. Finally, in Section 5, we consider more syntactic approaches, where types are sets of terms. 2. <p> We insist on having a sufficiently rich set of constants, such as the one considered in <ref> [6] </ref>: true, false, cond, 0, z (test for zero), +1, -1, pair, 1 and 2 (for extracting pair elements), inl and inr (for forming sums), outl and outr (to recover elements from sums), and isl and isr (for distinguishing cases in sums). <p> , V 1 , : : : , where V 0 = f?g V i+1 = T + N + (V i fiV i ) + (V i + V i ) + (V i !V i ) + W: We omit the details of the construction, which are standard <ref> [7, 6] </ref>. <p> It remains to show that every Cauchy sequence converges. The proof of this is almost identical to the one for arbitrary ideals (Theorem 3 in <ref> [6] </ref>). Let hI n i be a Cauchy sequence. Let I o be the set of finite denotable mem-bers of almost all I n . <p> Theorem 3.2.6. The operations u and t are nonexpansive. The operations fi, +, and ! are contractive. Proof The general structure of the proof is taken from Proposition 6 and Theorem 7 of <ref> [6] </ref>. (A slightly more direct proof, which never mentions nondenotable elements, is easy to derive, but we prefer to imitate the previous proof in order to make similarities obvious.) Only ! requires a new argument; we omit discussion of the other operations. <p> In fact, we can even take this [[x]] to be finite, since every denot-able value is the limit of a chain of finite denotable values (by Proposition 3.1.4), application is continuous, and ideals are closed under approximations and limits. Since [[e]] must be a non-bottom function, Proposition 4 of <ref> [6] </ref> gives us [[e]] = F (a i ) b i ) for some finite, non-zero number of a i and b i . Let a = F Then a v [[x]] and [[e]](a) = [[ex]] = F fb i j a i v [[x]]g. <p> If K GIdl and f is contractive (nonexpansive) in its last n arguments then so are (8 K f ) and (9 K f ). If f is contractive (nonexpansive) then so is f . Proof The arguments are identical to those for Theorems 8 and 9 in <ref> [6] </ref>. 2 4. Semantics for Type Expressions We can use the results on the complete metric space of generated ideals and on the operations in this space to give a semantics to a large class of type expressions. This class is the same one treated in [6] and suffices as the <p> 8 and 9 in <ref> [6] </ref>. 2 4. Semantics for Type Expressions We can use the results on the complete metric space of generated ideals and on the operations in this space to give a semantics to a large class of type expressions. This class is the same one treated in [6] and suffices as the core of the type system for rich programming languages, such as Standard ML. The generated-ideal semantics of type expressions is more accurate than the usual ones. Despite the features of generated ideals, however, the semantics is not quite faithful. <p> We can prove: Theorem 4.1.3. The generated-ideal semantics is well defined. Proof The proof is straightforward, given the machinery of the previous section. It resembles the proof of Theorem 10 in <ref> [6] </ref>. 2 What is the type of the explode-jj-or function, according to this semantics? Whenever [[explode-jj-or]] is given a denotable argument in the generated ideal TfiT!T, it yields a result in T. Thus, explode-jj-or is of type (boolfibool!bool)!bool, as we originally suggested. <p> We apply the Banach Fixpoint Theorem as usual, to prove that the semantics is well defined. Theorem 4.2.2. The coarse-ideal semantics is well defined. Proof Again, the proof is straightforward, given the machinery of the previous section. It resembles the proof of Theorem 10 in <ref> [6] </ref>. 2 It remains to show that this semantics is faithful. For this purpose, we use AIdl, the class of abstract generated ideals|for short, abstract ideals. (Abstract sets were defined in Subsection 2.4.) Definition 4.2.3. AIdl is the set of abstract generated ideals.
Reference: [7] <author> Henk P. Barendregt. </author> <title> The Lambda Calculus. </title> <address> North Holland, </address> <note> Revised edition, </note> <year> 1984. </year>
Reference-contexts: , V 1 , : : : , where V 0 = f?g V i+1 = T + N + (V i fiV i ) + (V i + V i ) + (V i !V i ) + W: We omit the details of the construction, which are standard <ref> [7, 6] </ref>.
Reference: [8] <author> Stefan Banach. </author> <title> Sur les operations dans les ensembles abstraits et leurs applications aux equations integrales. </title> <journal> Fund. Math., </journal> <volume> 3 </volume> <pages> 7-33, </pages> <year> 1922. </year>
Reference-contexts: It is simple to check that all the definitions are proper, with the exception of the definition of . That the definition of is proper follows from the Banach Fixpoint Theorem <ref> [8] </ref>, stated below as Theorem 3.2.5. It is worth pointing out that our definition of I!J differs from the usual one even on denotable elements.
Reference: [9] <author> Stavros S. Cosmadakis. </author> <title> Computing with recursive types. </title> <booktitle> In Proceedings of the Fourth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 24-38, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Proving that these definitions do coincide, however, may pose a hard adequacy problem; see <ref> [4, 9] </ref> for a discussion of adequacy. For instance, one has to show that [[e]] 2 T if and only if e ) e' implies e' 2 ftrue; falseg, and similarly that [[e]] 2 (V!V) if and only if e ) e' implies e' 2 F.
References-found: 9

