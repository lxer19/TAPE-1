URL: http://www.cs.iastate.edu/tech-reports/TR90-03.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: 
Title: Reasoning About Oject-Oriented Programs That Use Subtypes TR90-03B  
Author: Gary T. Leavens 
Date: March 1990 Revised  
Abstract-found: 0
Intro-found: 1
Reference: [Ame89] <author> Pierre America. </author> <title> A behavioural approach to subtyping in object-oriented programming languages. </title> <type> Technical Report 443, </type> <institution> Philips Research Laboratories, Neder-landse Philips Bedrijven B. V., </institution> <month> January </month> <year> 1989. </year>
Reference-contexts: We can specify such deferred types, because the trait functions used to specify operations are specified independently of the operations. P. America has independently developed a definition of subtype relationships <ref> [Ame89] </ref>. Types are specified by describing the abstract values of their instances, and the post-condition of each operation relates the abstract values of the arguments to the abstract value of the result.
Reference: [ASS85] <author> Harold Abelson, Gerald Jay Sussman, and Julie Sussman. </author> <title> Structure and Interpretation of Computer Programs. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1985. </year>
Reference-contexts: As in the Common LISP Object System (CLOS) [Kee89], a dispatcher finds an operation based on the run-time types of all the actual arguments. For example, the function sqrt of Figure 2 (code adapted from <ref> [ASS85, Page 22] </ref>) is polymorphic, because the implicit method dictionary passed to sqrt is defined for the message names lt, abs, etc. used at run-time and because the relevant dispatchers are defined on tuples of types made from Fraction and its subtypes, such as Integer.
Reference: [BDMN73] <author> Graham M. Birtwistle, Ole-Johan Dahl, Bjorn Myhrhaug, and Kristen Nygaard. </author> <title> SIMULA Begin. </title> <publisher> Auerbach Publishers, </publisher> <address> Philadelphia, Penn., </address> <year> 1973. </year>
Reference-contexts: Such strong conditions also seem necessary for the soundness of modular program verification, so that one can reason about subtypes implicitly. Hence, we suggest that subtype relationships should be declared, rather than inferred on the basis of structural information such as signatures [BHJL86] or subclass (inheritance) relationships among implementations <ref> [BDMN73] </ref>. Reasoning based on subtyping and nominal type information seems to be used informally by programmers working with object-oriented languages [Sny86]. However, it is important for programmers to recognize that subtyping is a rather strong behavioral constraint that is independent of subclassing.
Reference: [BHJL86] <author> Andrew Black, Norman Hutchinson, Eric Jul, and Henry Levy. </author> <title> Object structure in the Emerald system. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(11) </volume> <pages> 78-86, </pages> <month> November </month> <year> 1986. </year> <booktitle> OOP-SLA '86 Conference Proceedings, </booktitle> <editor> Norman Meyrowitz (editor), </editor> <month> September </month> <year> 1986, </year> <institution> Port-land, Oregon. </institution>
Reference-contexts: Such strong conditions also seem necessary for the soundness of modular program verification, so that one can reason about subtypes implicitly. Hence, we suggest that subtype relationships should be declared, rather than inferred on the basis of structural information such as signatures <ref> [BHJL86] </ref> or subclass (inheritance) relationships among implementations [BDMN73]. Reasoning based on subtyping and nominal type information seems to be used informally by programmers working with object-oriented languages [Sny86]. However, it is important for programmers to recognize that subtyping is a rather strong behavioral constraint that is independent of subclassing.
Reference: [BJ82] <author> Dines Bjorner and Cliff B. Jones. </author> <title> Formal Specification and Software Development. </title> <booktitle> Prentice-Hall International, </booktitle> <address> London, </address> <year> 1982. </year>
Reference-contexts: The requires clause describes the pre-condition of sqrt. Such a specification is a two-tiered [Win87] or abstract-model style <ref> [BJ82] </ref> specification. In such specifications, the characteristics, or abstract values, of objects are described mathematically, and the vocabulary of abstract values is used to specify functions and the operations of abstract types. Following Wing we describe the abstract values of types using Larch traits [GH86b].
Reference: [BW87] <author> Kim B. Bruce and Peter Wegner. </author> <title> An algebraic model of subtype and inheritance. </title> <note> To appear in Database Programming Languages, </note> <editor> Francois Bancilhon and Peter Buneman (editors), </editor> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <month> August </month> <year> 1987. </year>
Reference-contexts: The construction of R ensures other desirable properties. Bruce and Wegner have stated a similar list of properties for their coercer functions <ref> [BW87] </ref>, as does Reynolds [Rey80]. The semantics constraints on require that the specified family R is a simulation relation. If R is a simulation relation, then the substitution property holds not just for single trait functions and operations, but also for assertions and programs. <p> However, our notion of subtypes is based on type specifications, and thus can handle arbitrary immutable abstract types. Bruce and Wegner <ref> [BW87] </ref> use coercion functions with a substitution property, which are like our simulation relations, to give a definition of subtype relations. However, they do not discuss reasoning about object-oriented programs.
Reference: [Car84] <author> Luca Cardelli. </author> <title> A semantics of multiple inheritance. </title> <editor> In D. B. MacQueen G. Kahn and G. Plotkin, editors, </editor> <booktitle> Semantics of Data Types: International Symposium, Sophia-Antipolis, France, volume 173 of Lecture Notes in Computer Science, </booktitle> <pages> pages 51-66. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <month> June </month> <year> 1984. </year> <note> A revised version of this paper appears in Information and Computation, </note> <institution> volume 76, </institution> <type> numbers 2/3, </type> <pages> pages 138-164, </pages> <month> February/March </month> <year> 1988. </year>
Reference-contexts: Cardelli was the first to formally describe subtype relationships and type checking for a fixed set of types <ref> [Car84] </ref>. Our work generalizes Cardelli's to abstract data types. That is, given appropriate specifications of the types Cardelli discusses, the subtype relationships Cardelli describes for immutable record and variant types are also subtype relationships in our sense [Lea90].
Reference: [CW85] <author> Luca Cardelli and Peter Wegner. </author> <title> On understanding types, data abstraction and polymorphism. </title> <journal> ACM Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <month> December </month> <year> 1985. </year>
Reference: [GH86a] <author> J. V. Guttag and J. J. Horning. </author> <title> A Larch shared language handbook. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 6 </volume> <pages> 135-157, </pages> <year> 1986. </year>
Reference-contexts: Trait functions can be used in assertions but not in programs. In the trait IntAndRat, the included traits Integer and Rational are found in <ref> [GH86a] </ref>. The names and signatures of additional trait functions are described after the keyword introduces. The constrains section is an equational specification of the trait functions. The terms in the exempts section are undefined.
Reference: [GH86b] <author> J. V. Guttag and J. J. Horning. </author> <title> Report on the Larch shared language. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 6 </volume> <pages> 103-134, </pages> <year> 1986. </year>
Reference-contexts: In such specifications, the characteristics, or abstract values, of objects are described mathematically, and the vocabulary of abstract values is used to specify functions and the operations of abstract types. Following Wing we describe the abstract values of types using Larch traits <ref> [GH86b] </ref>. The symbols "", "j j", "*", "-", and "/" used in the pre- and post-condition are the names of trait functions and are described in the trait IntAndRat (Figure 5). Trait functions can be used in assertions but not in programs.
Reference: [GM87] <author> Joseph A. Goguen and Jose Meseguer. </author> <title> Order-sorted algebra solves the constructor-selector, multiple representation and coercion problems. </title> <type> Technical Report CSLI-87-92, </type> <institution> Center for the Study of Language and Information, </institution> <month> March </month> <year> 1987. </year>
Reference-contexts: It is hoped that in the future the mixed mode trait functions can be specified more succinctly, perhaps by using order-sorted algebra <ref> [GM87] </ref>. One can always define them by first coercing all arguments to the supertype.
Reference: [Gog84] <author> Joseph A. Goguen. </author> <title> Parameterized programming. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(5):528-543, </volume> <month> September </month> <year> 1984. </year>
Reference-contexts: For example, the traditional, parameterized specification of sqrt would have as parameters a type T, an object x of type T, and functions lt, abs, sub, mul, and div that would allow the square root to be computed. (See, for example, [Gut80, Page 21], [Win83, Section 4.2.3], and <ref> [Gog84, Page 537] </ref>.) The functions lt, abs, etc. can be grouped into a single parameter: a method dictionary. It is necessary to specify the behavior of the functions in this method dictionary, since otherwise one cannot prove that the implementation of sqrt is correct.
Reference: [GR83] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80, The Language and its Implementation. </title> <publisher> Addison-Wesley Publishing Co., </publisher> <address> Reading, Mass., </address> <year> 1983. </year>
Reference-contexts: 1 Introduction The message-passing mechanism of an object-oriented language such as Smalltalk-80 <ref> [GR83] </ref> allows one to write polymorphic code; i.e., code that works for objects of many types.
Reference: [Gut80] <author> John Guttag. </author> <title> Notes on type abstractions (version 2). </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-6(1):13-23, </volume> <month> January </month> <year> 1980. </year> <title> Version 1 in Proceedings Specifications of Reliable Software, </title> <address> Cambridge, Mass., </address> <publisher> IEEE, </publisher> <month> April, </month> <year> 1979. </year>
Reference-contexts: For example, the traditional, parameterized specification of sqrt would have as parameters a type T, an object x of type T, and functions lt, abs, sub, mul, and div that would allow the square root to be computed. (See, for example, <ref> [Gut80, Page 21] </ref>, [Win83, Section 4.2.3], and [Gog84, Page 537].) The functions lt, abs, etc. can be grouped into a single parameter: a method dictionary.
Reference: [Kee89] <author> Sonya E. Keene. </author> <title> Object-Oriented Programming in Common Lisp. </title> <publisher> Addison Wes-ley, </publisher> <address> Reading, Mass., </address> <year> 1989. </year>
Reference-contexts: Our language has a more complex form of dynamic overloading, in which method dictionaries map message names to dispatchers, which are mappings from tuples of types to operations specific to a combination of argument types. As in the Common LISP Object System (CLOS) <ref> [Kee89] </ref>, a dispatcher finds an operation based on the run-time types of all the actual arguments. <p> On the other hand, if a denotes a Fraction, then the result of add (a,b) is determined by the specification of the add operation of Fraction. (The semantic restrictions on subtype relationships ensure that these behaviors are related.) Such specifications would be well suited for the specification of CLOS programs <ref> [Kee89] </ref>, where generic operations can be defined for various combina tions of argument types. The pre- and post-conditions of operations must not use equality (=), except between terms of visible type | built-in types for which no subtypes are allowed, such as Boolean and Integer.
Reference: [Lea89] <author> Gary Todd Leavens. </author> <title> Verifying object-oriented programs that use subtypes. </title> <type> Technical Report 439, </type> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, </institution> <month> February </month> <year> 1989. </year> <title> The author's Ph.D. </title> <type> thesis. </type>
Reference-contexts: That is, one reasons about expressions as if they denoted objects of their nominal types. The key to the soundness of our method is the semantic requirements on subtype relationships [Lea90]. The method has been refined from <ref> [Lea89] </ref>. The rest of this paper is organized as follows. In Section 2 we describe the programming language used in this paper. Next, in Section 3 we present some background. In Section 4 we describe the problem in more detail. <p> of a type specification the operations are divided into class and instance operations; class operations are typically used to create new instances of a type, and instance operations are called by sending 1 The meaning of a specification is not given by coercing the abstract values of arguments, as in <ref> [Lea89] </ref>. <p> Indeed, the relationships are preserved 3 even if functions and operations are per mitted to be nondeterministic [Lea90]. 7 Related Work Ours is the first formal verification technique for object-oriented programs that use message-passing that has been proven to be sound <ref> [Lea89] </ref> [Lea90]. Cardelli was the first to formally describe subtype relationships and type checking for a fixed set of types [Car84]. Our work generalizes Cardelli's to abstract data types.
Reference: [Lea90] <author> Gary T. Leavens. </author> <title> Modular verification of object-oriented programs with subtypes. </title> <type> Technical Report 90-09, </type> <institution> Department of Computer Science, Iowa State University, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: That is, one reasons about expressions as if they denoted objects of their nominal types. The key to the soundness of our method is the semantic requirements on subtype relationships <ref> [Lea90] </ref>. The method has been refined from [Lea89]. The rest of this paper is organized as follows. In Section 2 we describe the programming language used in this paper. Next, in Section 3 we present some background. In Section 4 we describe the problem in more detail. <p> subtype, because of the semantic restrictions on subtype relations. (Termination of recursive functions must be verified separately.) 6 Soundness of the Method The soundness of the verification method discussed above rests on the syntactic restrictions on ResType and , the semantic restrictions on and R and the following technical results <ref> [Lea90] </ref>: * Each expression of nominal type T can only denote objects of a type S T. <p> Disciplined use of subtypes cannot lead to surprising program behavior, because the substitution property also holds for program expressions and recursively defined program functions. Indeed, the relationships are preserved 3 even if functions and operations are per mitted to be nondeterministic <ref> [Lea90] </ref>. 7 Related Work Ours is the first formal verification technique for object-oriented programs that use message-passing that has been proven to be sound [Lea89] [Lea90]. Cardelli was the first to formally describe subtype relationships and type checking for a fixed set of types [Car84]. <p> Indeed, the relationships are preserved 3 even if functions and operations are per mitted to be nondeterministic <ref> [Lea90] </ref>. 7 Related Work Ours is the first formal verification technique for object-oriented programs that use message-passing that has been proven to be sound [Lea89] [Lea90]. Cardelli was the first to formally describe subtype relationships and type checking for a fixed set of types [Car84]. Our work generalizes Cardelli's to abstract data types. <p> Our work generalizes Cardelli's to abstract data types. That is, given appropriate specifications of the types Cardelli discusses, the subtype relationships Cardelli describes for immutable record and variant types are also subtype relationships in our sense <ref> [Lea90] </ref>. However, our notion of subtypes is based on type specifications, and thus can handle arbitrary immutable abstract types. Bruce and Wegner [BW87] use coercion functions with a substitution property, which are like our simulation relations, to give a definition of subtype relations. <p> However, they do not discuss reasoning about object-oriented programs. Using relations instead of functions allows us to handle an abstract type whose space of abstract values is not reduced (in the sense that objects with two distinct abstract values may behave the same). Examples can be found in <ref> [Lea90] </ref>. Bruce and Wegner also do not handle operations that may fail to terminate.
Reference: [Mey88] <author> Bertrand Meyer. </author> <title> Object-oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <address> New York, N.Y., </address> <year> 1988. </year>
Reference-contexts: Examples can be found in [Lea90]. Bruce and Wegner also do not handle operations that may fail to terminate. For the language Eiffel <ref> [Mey88] </ref>, Meyer requires that the pre-condition of an instance operations of a su-perclass T must imply the pre-condition of the instance operation of the instance operation of each subclass of T with the same name; furthermore, the post-condition of the subclass's operation must imply the post-condition of T's operation.
Reference: [Mit86] <author> John C. Mitchell. </author> <title> Representation inde-pendence and data abstraction (preliminary version). </title> <booktitle> In Conference Record of the Thirteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> St. Petersburg Beach, Florida, </address> <pages> pages 263-276. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1986. </year>
Reference-contexts: If R is a simulation relation, then the substitution property holds not just for single trait functions and operations, but also for assertions and programs. In the study of the lambda calculus, this kind of theorem is known as the fundamental theorem (of logical relations) [Sta85] <ref> [Mit86] </ref>. Showing that the substitution property holds for assertions is crucial to proving the soundness of the verification system. Disciplined use of subtypes cannot lead to surprising program behavior, because the substitution property also holds for program expressions and recursively defined program functions.
Reference: [Rey80] <author> John C. Reynolds. </author> <title> Using category theory to design implicit conversions and generic operators. </title> <editor> In Neil D. Jones, editor, </editor> <booktitle> Semantics-Directed Compiler Generation, Proceedings of a Workshop, Aarhus, Den-mark, volume 94 of Lecture Notes in Computer Science, </booktitle> <pages> pages 211-258. </pages> <publisher> Springer-Verlag, </publisher> <month> January </month> <year> 1980. </year>
Reference-contexts: Function identifiers are statically bound to functions; message names are dynamically bound as described below. Type checking for this language is based on sub-typing, using techniques from Reynolds's category sorted algebras <ref> [Rey80] </ref> [Rey85]. Each expression is statically assigned a nominal type, determined from the information given in type specifications and program declarations. <p> The construction of R ensures other desirable properties. Bruce and Wegner have stated a similar list of properties for their coercer functions [BW87], as does Reynolds <ref> [Rey80] </ref>. The semantics constraints on require that the specified family R is a simulation relation. If R is a simulation relation, then the substitution property holds not just for single trait functions and operations, but also for assertions and programs.
Reference: [Rey85] <author> John C. Reynolds. </author> <title> Three approaches to type structure. </title> <editor> In Hartmut Ehrig, Chris-tiane Floyd, Maurice Nivat, and James Thatcher, editors, </editor> <booktitle> Mathematical Foundations of Software Development, Proceedings of the International Joint Conference on Theory and Practice of Software Development (TAPSOFT), Berlin. Volume 1: Colloquium on Trees in Algebra and Programming (CAAP '85), volume 185 of Lecture Notes in Computer Science, </booktitle> <pages> pages 97-138. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <month> March </month> <year> 1985. </year>
Reference-contexts: Function identifiers are statically bound to functions; message names are dynamically bound as described below. Type checking for this language is based on sub-typing, using techniques from Reynolds's category sorted algebras [Rey80] <ref> [Rey85] </ref>. Each expression is statically assigned a nominal type, determined from the information given in type specifications and program declarations.
Reference: [Sny86] <author> Alan Snyder. </author> <title> Encapsulation and inheritance in object-oriented programming languages. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(11) </volume> <pages> 38-45, </pages> <month> November </month> <year> 1986. </year> <booktitle> OOPSLA '86 Conference Proceedings, </booktitle> <editor> Norman Mey-rowitz (editor), </editor> <month> September </month> <year> 1986, </year> <institution> Portland, Oregon. </institution>
Reference-contexts: Hence, we suggest that subtype relationships should be declared, rather than inferred on the basis of structural information such as signatures [BHJL86] or subclass (inheritance) relationships among implementations [BDMN73]. Reasoning based on subtyping and nominal type information seems to be used informally by programmers working with object-oriented languages <ref> [Sny86] </ref>. However, it is important for programmers to recognize that subtyping is a rather strong behavioral constraint that is independent of subclassing. The principal advantage of our approach is that it allows modular reasoning.
Reference: [Sta85] <author> R. Statman. </author> <title> Logical relations and the typed -calculus. </title> <journal> Information and Control, </journal> 65(2/3):85-97, May/June 1985. 
Reference-contexts: If R is a simulation relation, then the substitution property holds not just for single trait functions and operations, but also for assertions and programs. In the study of the lambda calculus, this kind of theorem is known as the fundamental theorem (of logical relations) <ref> [Sta85] </ref> [Mit86]. Showing that the substitution property holds for assertions is crucial to proving the soundness of the verification system. Disciplined use of subtypes cannot lead to surprising program behavior, because the substitution property also holds for program expressions and recursively defined program functions.
Reference: [WB89] <author> Philip Wadler and Stephen Blott. </author> <title> How to make ad-hoc polymorphism less ad hoc. </title> <booktitle> In Conference Record of the Sixteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 60-76. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1989. </year>
Reference-contexts: Wadler and Blott's method dictionaries provides a good explanation of this style of message passing <ref> [WB89] </ref>. A method dictionary is a map from the names of overloaded operators to the operations specific to a given type.
Reference: [Win83] <author> Jeannette Marie Wing. </author> <title> A two-tiered approach to specifying programs. </title> <type> Technical Report TR-299, </type> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, </institution> <year> 1983. </year>
Reference-contexts: For example, the traditional, parameterized specification of sqrt would have as parameters a type T, an object x of type T, and functions lt, abs, sub, mul, and div that would allow the square root to be computed. (See, for example, [Gut80, Page 21], <ref> [Win83, Section 4.2.3] </ref>, and [Gog84, Page 537].) The functions lt, abs, etc. can be grouped into a single parameter: a method dictionary. It is necessary to specify the behavior of the functions in this method dictionary, since otherwise one cannot prove that the implementation of sqrt is correct.
Reference: [Win87] <author> Jeannette M. Wing. </author> <title> Writing Larch interface language specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(1) </volume> <pages> 1-24, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: The ensures clause (i.e., the post-condition) of sqrt in Figure 4 states how the value of the result is related to the values of the argument, assuming that it is of type Fraction. The requires clause describes the pre-condition of sqrt. Such a specification is a two-tiered <ref> [Win87] </ref> or abstract-model style [BJ82] specification. In such specifications, the characteristics, or abstract values, of objects are described mathematically, and the vocabulary of abstract values is used to specify functions and the operations of abstract types. Following Wing we describe the abstract values of types using Larch traits [GH86b].
References-found: 26

