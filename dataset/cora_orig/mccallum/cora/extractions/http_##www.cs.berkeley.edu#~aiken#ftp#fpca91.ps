URL: http://www.cs.berkeley.edu/~aiken/ftp/fpca91.ps
Refering-URL: http://www.cs.berkeley.edu/~aiken/pubs.html
Root-URL: 
Email: aiken@ibm.com  brm@cs.stanford.edu  
Title: Implementing Regular Tree Expressions  
Author: Alexander Aiken Brian R. Murphy 
Address: 650 Harry Rd. San Jose, CA 95120  Stanford, CA 94305  
Affiliation: IBM Almaden Research Center  Computer Science Department Stanford University  
Abstract: Regular tree expressions are a natural formalism for describing the sets of tree-structured values that commonly arise in programs; thus, they are well-suited to applications in program analysis. We describe an implementation of regular tree expressions and our experience with that implementation in the context of the FL type system. A combination of algorithms, optimizations, and fast heuristics for computa-tionally difficult problems yields an implementation efficient enough for practical use.
Abstract-found: 1
Intro-found: 1
Reference: [AM91] <author> A. Aiken and B. Murphy. </author> <title> Static type inference in a dynamically typed language. </title> <booktitle> In Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 279-290, </pages> <address> Orlando, </address> <year> 1991. </year>
Reference-contexts: 1 Introduction Regular tree expressions are a natural formalism for describing the sets of tree-structured values that commonly arise in programs. As such, several researchers have proposed using (variations on) regular tree expressions in type inference and program analysis algorithms <ref> [JM79, Mis84, MR85, HJ90, 1 HJ91, AM91] </ref>. We are not aware of any implementations based on regular tree expressions, however, except for our own work on type analysis for the functional language FL [B + 89]. <p> A previous paper described the theoretical basis for our FL type inference system, in which types are represented by regular tree expressions <ref> [AM91] </ref>. This paper describes an implementation of regular tree expressions and our experience with that implementation in the context of the FL type system. Implementing regular tree expressions efficiently is challenging, because some of the basic operations have exponential time complexity [Sei89]. <p> A more general method to determine the results of recursive functions involves the solution of inclusion constraints on regular tree expressions <ref> [AM91] </ref>. In the sections that follow, we describe a high-level implementation of these operations with considerable attention to efficiency. As a rule, we state results needed to justify our algorithms, but omit the proofs for brevity. <p> Testing emptiness is useful for two reasons. First, it can be an important part of the application. For example, in our type inference algorithm for FL, proving that a function is type-safe is reduced to proving that a regular tree expression is empty <ref> [AM91] </ref>. Second, emptiness testing is important for the efficiency of the system. It is wasteful, both of time and space, to build and maintain expressions of the form c (Y; X) or Y ^ X where Y is empty. <p> The second predicate arises in analyzing recursive functions, when it becomes necessary to solve constraints to assign types to recursive functions <ref> [AM91] </ref> (in this case, it is necessary to actually compute a substitution that satisfies the constraints). A fast algorithm for containment has a third application: it can dramatically increase the performance 16 of the other regular tree operations (see Section 7).
Reference: [AW91] <author> A. Aiken and E. Wimmers. </author> <title> A decision problem for set constraints. </title> <type> Research Report Forthcoming RJ, </type> <institution> IBM, </institution> <year> 1991. </year>
Reference-contexts: In the sections that follow, we describe a high-level implementation of these operations with considerable attention to efficiency. As a rule, we state results needed to justify our algorithms, but omit the proofs for brevity. Many of these results may be found in the literature <ref> [GS84, MR85, HJ90, AW91] </ref>. 3 Systems of Equations Regular tree expressions are easy to understand, but are not well suited to the implementation of some algorithms. <p> These are systems of equations with conjunction and disjunction operators syntactically restricted. A syntax and semantics for leaf-linear systems is given in Figure 2. The following theorem shows that the semantics is well-defined <ref> [AW91] </ref>. Theorem 3.3 Let S be a leaf-linear system. Then for any substitution for variables Free (S), there is exactly one substitution 0 for variables Vars (S) such that 0 extends and 0 2 S (S). <p> Given the importance of testing inclusion, the following result is discouraging. Theorem 6.1 Evaluating the predicates 8 S (E 1 ; ) S (E 2 ; ) is exponential-time hard <ref> [AW91] </ref>. For the first predicate, 8 S (E 1 ; ) S (E 2 ; ), a decision procedure is known with the restrictions upon negation used here [Mur90]. This algorithm proved impractical in an implementation. <p> This algorithm proved impractical in an implementation. The predicate 9 S (E 1 ; ) S (E 2 ; ) is computable in general, and in fact it is possible to compute all substitutions that make the inclusion relationship true <ref> [AW91] </ref>. Unfortunately, this algorithm runs in non-deterministic exponential time. In this section, we present a single mechanism implementing a conservative heuristic for both inclusion tests. As we discuss below, this heuristic has worked very well in our implementation. <p> i _ (fi i ^ U i ) Then 8 S 0 (x i ; ) S 0 (x j ; ). 20 A [ fff E 1 ; ff E 2 g A [ fff E 1 ^ E 2 g The proof of this theorem is difficult; see <ref> [AW91] </ref>. The intuition behind the construction is that the free variable fi i allows the actual value of ff i to be anything "in between" the lower and upper bounds L i and U i .
Reference: [B + 89] <author> J. Backus et al. </author> <title> FL language manual, parts 1 and 2. </title> <type> Research Report RJ 7100, </type> <institution> IBM, </institution> <year> 1989. </year>
Reference-contexts: We are not aware of any implementations based on regular tree expressions, however, except for our own work on type analysis for the functional language FL <ref> [B + 89] </ref>. A previous paper described the theoretical basis for our FL type inference system, in which types are represented by regular tree expressions [AM91]. This paper describes an implementation of regular tree expressions and our experience with that implementation in the context of the FL type system.
Reference: [Cou83] <author> B. Courcelle. </author> <title> Fundamental properties of infinite trees. </title> <journal> Theoretical Computer Science, </journal> <volume> 25 </volume> <pages> 95-169, </pages> <year> 1983. </year>
Reference-contexts: It is worth explaining our choice of the term "regular tree expression". In [MR85], a regular tree is what we term a regular tree expression. We use a different name because the term "regular tree" is usually a finite or infinite tree with a finite number of subtrees <ref> [Cou83] </ref>. Using this definition, a regular tree expression together with a substitution denotes a set of regular trees.
Reference: [GS84] <author> F. Gecseg and M. Steinby. </author> <title> Tree Automata. </title> <address> Academei Kaido, Bu-dapest, </address> <year> 1984. </year>
Reference-contexts: We begin in Section 2 with a straightforward definition of regular tree expressions; we use this representation to illustrate their usefulness. In Section 3, we introduce the representation used in our system: leaf-linear systems of equations <ref> [GS84, MR85] </ref>. We discuss why leaf-linear systems are better suited to implementation than the representation of Section 2. Section 4 outlines an incremental algorithm to test whether a leaf-linear system is empty. The next several sections describe, at a high level, implementations of the operations on regular tree expressions. <p> In the sections that follow, we describe a high-level implementation of these operations with considerable attention to efficiency. As a rule, we state results needed to justify our algorithms, but omit the proofs for brevity. Many of these results may be found in the literature <ref> [GS84, MR85, HJ90, AW91] </ref>. 3 Systems of Equations Regular tree expressions are easy to understand, but are not well suited to the implementation of some algorithms. <p> set of variables if their solutions are the same over those variables: S 1 S 2 , f " j 2 S (S 1 )g = f " j 2 S (S 2 )g The inputs and outputs of our algorithms are leaf-linear systems of equations [MR85] or regular X-grammars <ref> [GS84] </ref>. These are systems of equations with conjunction and disjunction operators syntactically restricted. A syntax and semantics for leaf-linear systems is given in Figure 2. The following theorem shows that the semantics is well-defined [AW91]. Theorem 3.3 Let S be a leaf-linear system. <p> for any leaf-linear system of equations S there is a regular tree expression R such that 8 (R; ) = S (x 1 ; ) Thus far, we have treated a leaf-linear system as a system of equations; however, a leaf-linear system also can be viewed as a tree automaton <ref> [GS84] </ref>. We occasionally adopt this view to make use of results from automata theory. When a leaf-linear system is viewed as a tree automaton, an equation represents a state and the transition function for that state. By convention, x 1 is the initial state. <p> Then 8 S (E; ) = ; , S (E; t ) = 0 To test whether S (x i ; t ) = ;, we use the function S defined in Figure 3. This definition is a straightforward adaptation of algorithms for reachability and emptiness for finite automata <ref> [HU79, GS84] </ref>. Lemma 4.2 Let S = fx 1 = Rhs 1 ; : : : ; x k = Rhs k g be a leaf-linear system, and let S be defined as in Figure 3. <p> &gt; or S (E 2 ) = &gt; ? otherwise S (ff) = &gt; if ff 2 Free (S) To finish the proof, we observe that the language of a tree automaton of k states is non-empty if and only if it accepts a term of height at most k <ref> [GS84] </ref>. 2 Let n be the total number of symbols appearing in a leaf-linear system S. The function S is computable for every equation in the system in O (n 2 ) time using a standard fixed-point computation.
Reference: [HJ90] <author> N. Heintze and J. Jaffar. </author> <title> A finite presentation theorem for approximating logic programs. </title> <booktitle> In Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 197-209, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Regular tree expressions are a natural formalism for describing the sets of tree-structured values that commonly arise in programs. As such, several researchers have proposed using (variations on) regular tree expressions in type inference and program analysis algorithms <ref> [JM79, Mis84, MR85, HJ90, 1 HJ91, AM91] </ref>. We are not aware of any implementations based on regular tree expressions, however, except for our own work on type analysis for the functional language FL [B + 89]. <p> For example, Mishra and Reddy restrict the use of disjunction in a type inference algorithm for a statically typed functional language [MR85], and Heintze and Jaffar use projection functions in a program analysis for logic programs <ref> [HJ90] </ref>. Almost all of our implementation design would apply to these other systems with little or no modification. The following examples illustrate the usefulness of regular tree expressions. Let c be a binary constructor and let b be a zero-ary constructor. <p> In the sections that follow, we describe a high-level implementation of these operations with considerable attention to efficiency. As a rule, we state results needed to justify our algorithms, but omit the proofs for brevity. Many of these results may be found in the literature <ref> [GS84, MR85, HJ90, AW91] </ref>. 3 Systems of Equations Regular tree expressions are easy to understand, but are not well suited to the implementation of some algorithms.
Reference: [HJ91] <author> N. Heintze and J. Jaffar. </author> <title> Set-based program analysis. </title> <type> Draft manuscript, </type> <year> 1991. </year>
Reference: [HU79] <author> J. E. Hopcroft and J. D. Ullman. </author> <title> Introduction to Automata Theory, Languages, and Computation. </title> <publisher> Addison-Wesley, </publisher> <year> 1979. </year>
Reference-contexts: Then 8 S (E; ) = ; , S (E; t ) = 0 To test whether S (x i ; t ) = ;, we use the function S defined in Figure 3. This definition is a straightforward adaptation of algorithms for reachability and emptiness for finite automata <ref> [HU79, GS84] </ref>. Lemma 4.2 Let S = fx 1 = Rhs 1 ; : : : ; x k = Rhs k g be a leaf-linear system, and let S be defined as in Figure 3.
Reference: [JM79] <author> N. D. Jones and S. S. Muchnick. </author> <title> Flow analysis and optimization of LISP-like structures. </title> <booktitle> In Sixth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 244-256, </pages> <month> January </month> <year> 1979. </year>
Reference-contexts: 1 Introduction Regular tree expressions are a natural formalism for describing the sets of tree-structured values that commonly arise in programs. As such, several researchers have proposed using (variations on) regular tree expressions in type inference and program analysis algorithms <ref> [JM79, Mis84, MR85, HJ90, 1 HJ91, AM91] </ref>. We are not aware of any implementations based on regular tree expressions, however, except for our own work on type analysis for the functional language FL [B + 89].
Reference: [Mic68] <author> D. Michie. </author> <title> `Memo' functions and machine learning. </title> <journal> Nature, </journal> (218):19-22, April 1968. 
Reference-contexts: If it is known that A B, then we can save time and space by not computing A " B but just returning A. Applying similar ideas uniformly dramatically improves performance. The second optimization is to use memoization to record and reuse the results of operations <ref> [Mic68] </ref>. While the usefulness of this optimization depends on the particular application, in our system it is very common for the same operations to be performed again and again. The performance of the system with these two optimizations is more than two orders of magnitude faster than without them. <p> Analyzing the actual sequence of intersections, negations, and inclusion tests performed reveals part of the problem: many of the operations are being computed over and over again. Memoization is a simple optimization that caches and reuses the results of computations <ref> [Mic68] </ref>. We have already used something quite like memoization in the auxiliary systems of equations used for computing intersection and negation in Section 5. If fact, instead of discarding those auxiliary equations, they can be retained and reused if the same computations are performed again.
Reference: [Mis84] <author> P. Mishra. </author> <title> Towards a theory of types in PROLOG. </title> <booktitle> In Proceedings of the First IEEE Symposium in Logic Programming, </booktitle> <pages> pages 289-298, </pages> <year> 1984. </year>
Reference-contexts: 1 Introduction Regular tree expressions are a natural formalism for describing the sets of tree-structured values that commonly arise in programs. As such, several researchers have proposed using (variations on) regular tree expressions in type inference and program analysis algorithms <ref> [JM79, Mis84, MR85, HJ90, 1 HJ91, AM91] </ref>. We are not aware of any implementations based on regular tree expressions, however, except for our own work on type analysis for the functional language FL [B + 89].
Reference: [MR85] <author> P. Mishra and U. Reddy. </author> <title> Declaration-free type checking. </title> <booktitle> In Pro--ceedings of the Twelfth Annual ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 7-21, </pages> <year> 1985. </year>
Reference-contexts: 1 Introduction Regular tree expressions are a natural formalism for describing the sets of tree-structured values that commonly arise in programs. As such, several researchers have proposed using (variations on) regular tree expressions in type inference and program analysis algorithms <ref> [JM79, Mis84, MR85, HJ90, 1 HJ91, AM91] </ref>. We are not aware of any implementations based on regular tree expressions, however, except for our own work on type analysis for the functional language FL [B + 89]. <p> We begin in Section 2 with a straightforward definition of regular tree expressions; we use this representation to illustrate their usefulness. In Section 3, we introduce the representation used in our system: leaf-linear systems of equations <ref> [GS84, MR85] </ref>. We discuss why leaf-linear systems are better suited to implementation than the representation of Section 2. Section 4 outlines an incremental algorithm to test whether a leaf-linear system is empty. The next several sections describe, at a high level, implementations of the operations on regular tree expressions. <p> The performance of the system with these two optimizations is more than two orders of magnitude faster than without them. Measurements and discussion of the system's performance are also presented in Section 7. It is worth explaining our choice of the term "regular tree expression". In <ref> [MR85] </ref>, a regular tree is what we term a regular tree expression. We use a different name because the term "regular tree" is usually a finite or infinite tree with a finite number of subtrees [Cou83]. <p> Other proposals for program analysis systems based on regular tree expressions adopt slightly different definitions, depending upon the application. For example, Mishra and Reddy restrict the use of disjunction in a type inference algorithm for a statically typed functional language <ref> [MR85] </ref>, and Heintze and Jaffar use projection functions in a program analysis for logic programs [HJ90]. Almost all of our implementation design would apply to these other systems with little or no modification. The following examples illustrate the usefulness of regular tree expressions. <p> In the sections that follow, we describe a high-level implementation of these operations with considerable attention to efficiency. As a rule, we state results needed to justify our algorithms, but omit the proofs for brevity. Many of these results may be found in the literature <ref> [GS84, MR85, HJ90, AW91] </ref>. 3 Systems of Equations Regular tree expressions are easy to understand, but are not well suited to the implementation of some algorithms. <p> are equivalent over a set of variables if their solutions are the same over those variables: S 1 S 2 , f " j 2 S (S 1 )g = f " j 2 S (S 2 )g The inputs and outputs of our algorithms are leaf-linear systems of equations <ref> [MR85] </ref> or regular X-grammars [GS84]. These are systems of equations with conjunction and disjunction operators syntactically restricted. A syntax and semantics for leaf-linear systems is given in Figure 2. The following theorem shows that the semantics is well-defined [AW91]. Theorem 3.3 Let S be a leaf-linear system. <p> In other words, each substitution for the free variables determines a substitution for the bound variables. Regular tree expressions and leaf-linear systems are equivalent in a strong sense <ref> [MR85] </ref>: 6 Theorem 3.4 For any regular tree expression R there is a leaf-linear system of equations S, and for any leaf-linear system of equations S there is a regular tree expression R such that 8 (R; ) = S (x 1 ; ) Thus far, we have treated a leaf-linear <p> a leaf-linear system with an equation representing x 1 ^ x 2 , we may add all equations of the form x i ^ x j = Simp (Rhs i ^ Rhs j ) and then replace conjunctions of bound variables x i ^ x j by new variable names <ref> [MR85] </ref>. This is wasteful, however, because many of these equations may not be required to express the desired intersection, and this algorithm always uses fi (n 2 ) time and space.
Reference: [Mur90] <author> B. R. Murphy. </author> <title> A type inference system for FL. </title> <type> Master's thesis, </type> <institution> MIT, </institution> <year> 1990. </year>
Reference-contexts: Theorem 6.1 Evaluating the predicates 8 S (E 1 ; ) S (E 2 ; ) is exponential-time hard [AW91]. For the first predicate, 8 S (E 1 ; ) S (E 2 ; ), a decision procedure is known with the restrictions upon negation used here <ref> [Mur90] </ref>. This algorithm proved impractical in an implementation. The predicate 9 S (E 1 ; ) S (E 2 ; ) is computable in general, and in fact it is possible to compute all substitutions that make the inclusion relationship true [AW91]. Unfortunately, this algorithm runs in non-deterministic exponential time. <p> Consider the following lemma. Lemma 6.4 Let S be a subset of f1; : : : ; ng and let S be f1; : : : ; ng S. c (x; y) 1in _ x j ) _ (y j2S See <ref> [Mur90] </ref> for a generalization to constructors of arbitrary arity. The problem with an inference rule based on Lemma 6.4 is that it consumes exponential time and space, since it generates exponentially many new regular tree expressions.
Reference: [Sei89] <author> H. Seidl. </author> <title> Deciding equivalence of finite tree automata. </title> <booktitle> In 6th Annual Symposium on Theoretical Aspects of Computer Science. Lecture Notes in Computer Science, </booktitle> <month> February </month> <year> 1989. </year> <month> 27 </month>
Reference-contexts: This paper describes an implementation of regular tree expressions and our experience with that implementation in the context of the FL type system. Implementing regular tree expressions efficiently is challenging, because some of the basic operations have exponential time complexity <ref> [Sei89] </ref>. Even some operations with polynomial time algorithms perform poorly in practice. The fundamental operations on regular tree expressions are: computing fixed points, union, intersection, negation, and testing inclusion (including solving sets of inclusion constraints). Of these, both negation and inclusion require exponential time in general.
References-found: 14

