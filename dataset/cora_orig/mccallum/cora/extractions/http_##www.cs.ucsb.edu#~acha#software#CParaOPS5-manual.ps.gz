URL: http://www.cs.ucsb.edu/~acha/software/CParaOPS5-manual.ps.gz
Refering-URL: http://www.cs.ucsb.edu/~acha/software.html
Root-URL: http://www.cs.ucsb.edu
Title: Parallel OPS5 User's Manual  The Production System Machine  
Author:  Dirk Kalp, Milind Tambe, Anoop Gupta Charles Forgy, Allen Newell, Anurag Acharya, Brian Milnes, Kathy Swedlow 
Date: 13 November 1988  
Address: Pittsburgh, Pennsylvania 15213-3890  
Affiliation: Department of Computer Science Carnegie Mellon University  
Pubnum: Project  
Abstract: This document is a reference manual for ParaOPS5, a parallel version of the OPS5 production system language. ParaOPS5 is implemented in C, and runs on shared memory multiprocessors. While it is intended for use on shared memory multiprocessors, it is also suitable for uniprocessor machines. ParaOPS5 does not change the computational model or the functionality of OPS5. Instead, it exploits parallelism in the match phase of OPS5. Exploiting parallelism at a very fine granularity in the match phase has allowed ParaOPS5 to achieve significant speed-ups. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Brownston, L., Farrell, R., Kant, E., and Martin, N. </author> <title> Programming Expert Systems in OPS5: An introduction to rule-based programming. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1985. </year>
Reference-contexts: 1. Introduction The goal of the production system machine (PSM) project at Carnegie Mellon University is to create software and hardware technology for parallel rule-based systems. This document is a reference manual of our parallel implementation of the OPS5 production system language <ref> [1, 2] </ref>, called ParaOPS5. ParaOPS5 is based on the parallel implementation proposed in [5]. ParaOPS5 does not change the computational model or the functionality of OPS5. Therefore, OPS5 programs can be run on this system without any changes. ParaOPS5 exploits parallelism in the match phase of OPS5. <p> Background This section is intended to provide a very brief review of OPS5, the Rete matching algorithm, and our ParaOPS5 implementation. In addition, this section introduces terminology which will be used in the rest of this document. PARALLEL OPS5 2 2.1. OPS5 An OPS5 <ref> [1] </ref> production system is composed of a set of if-then rules, called productions, that make up the production memory, and a database of temporary assertions, called the working memory. The individual assertions are called working memory elements (WMEs), and are lists of attribute-value pairs.
Reference: [2] <author> Forgy, C. L. </author> <title> OPS5 User's Manual. </title> <type> Technical Report CMU-CS-81-135, </type> <institution> Computer Science Department, Carnegie Mellon University, </institution> <month> July, </month> <year> 1981. </year>
Reference-contexts: 1. Introduction The goal of the production system machine (PSM) project at Carnegie Mellon University is to create software and hardware technology for parallel rule-based systems. This document is a reference manual of our parallel implementation of the OPS5 production system language <ref> [1, 2] </ref>, called ParaOPS5. ParaOPS5 is based on the parallel implementation proposed in [5]. ParaOPS5 does not change the computational model or the functionality of OPS5. Therefore, OPS5 programs can be run on this system without any changes. ParaOPS5 exploits parallelism in the match phase of OPS5. <p> We are also investigating the implementation of ParaOPS5 on message passing computers (MPCs). Our analysis [6] indicates that MPCs are quite suitable for production systems. We expect you, the readers of this document, to be familiar with the OPS5. In fact, for reading this document, the OPS5 User's Manual <ref> [2] </ref> is an essential reference. Familiarity with the implementation proposed in [5] may be helpful, but is not necessary. For the interested reader, the ParaOPS5 implementation is described in detail in some other papers related to the PSM project [7, 8]. Section 2 provides some background information. <p> Please specify the tape density required with your request. Besides this document, the OPS5 User's Manual <ref> [2] </ref> is an essential reference. It describes the OPS5 language and the basic production system architecture and should be used in conjunction with this document. Additional references and papers related to the PSM project are listed at the end of this document. <p> The default is n=0 which prints no watch information. The other watch levels are described in the OPS5 User's Manual <ref> [2] </ref>. 4.5. The Interactive Command Interface The ParaOPS5 interactive command interface corresponds to the top level interface described in Section 8 of the OPS5 User's Manual [2]. This section describes the differences between the OPS5 top level interface and the ParaOPS5 command interface. <p> The default is n=0 which prints no watch information. The other watch levels are described in the OPS5 User's Manual <ref> [2] </ref>. 4.5. The Interactive Command Interface The ParaOPS5 interactive command interface corresponds to the top level interface described in Section 8 of the OPS5 User's Manual [2]. This section describes the differences between the OPS5 top level interface and the ParaOPS5 command interface. As indicated in Section 4.4, the ParaOPS5 command interface is invoked by specifying the -c switch when your program is run. <p> Except for back, excise, and pm, ParaOPS5 supports all the OPS5 top level commands. These commands are, call make remove closefile matches run cs openfile strategy default pbreak watch exit ppwm wm All the commands are implemented as described in the OPS5 User's Manual <ref> [2] </ref> except for the strategy command. The strategy command differs only in that the default conflict resolution strategy is mea instead of lex. Unlike the OPS5 top level interface, commands are given without enclosing parentheses and commands are terminated by the end of line character. <p> System Features, Limitations and Differences with OPS5 This section points out the differences between ParaOPS5 and the Lisp-based OPS5 described in the OPS5 User's Manual <ref> [2] </ref>. Some of the differences related to the top level user interface have already been discussed in Section 4 and will not be repeated here. Also discussed here are some of the features, limitations, and weaknesses of the ParaOPS5 system. 5.1. <p> ParaOPS5 does not do case-folding. Thus the symbolic atom p is different from the atom P. Also, unlike standard OPS5, ParaOPS5 does not support floating point numbers. ParaOPS5 supports only integers which the OPS5 User's Manual <ref> [2] </ref> refers to as fixed point numbers. They consist of an optional sign followed by one or more decimal digits and an optional point. Some legal examples are 3, 3., -3., and +3. 5.2. Call Actions and User Defined Functions Section 7 of the OPS5 User's Manual [2] describes the relationship <p> OPS5 User's Manual <ref> [2] </ref> refers to as fixed point numbers. They consist of an optional sign followed by one or more decimal digits and an optional point. Some legal examples are 3, 3., -3., and +3. 5.2. Call Actions and User Defined Functions Section 7 of the OPS5 User's Manual [2] describes the relationship between OPS5 and external routines that can be accessed through the OPS5 call action or the user defined function call. OPS5 provides a mechanism to pass parameters and results between it and external routines. <p> The headers show the type specifications for parameters and return values and give a brief summary of the function performed. The Appendix should be used in conjunction with Section 7 of the OPS5 User's Manual <ref> [2] </ref>. ParaOPS5 also restricts user defined function calls to a maximum of 50 parameters. Another difference is that dollar_litbind will return the number 0 when its argument is not a symbolic atom that has been bound by Literal or Literalize. OPS5 would return the argument unchanged in this case. <p> The routine headers show the type specification for parameters and return values and give a brief summary of the function performed. The interface routines are discussed in Section 7 of the OPS5 User's Manual <ref> [2] </ref> and in Section 5.2 of this document. #define TRUE 1 #define FALSE 0 typedef long OpsVal; int dollar_eql (atom1, atom2) OpsVal atom1, atom2; /*--------------------------------------------------------------------------- * Abstract: * Test if 2 atoms are the same. * * Parameters: * atom1, atom2 - the atoms to test. * * Environment: * This
Reference: [3] <author> Forgy, C. L. </author> <title> Rete: A fast algorithm for the many pattern/many object pattern match problem. </title> <booktitle> Artificial Intelligence 19(1) </booktitle> <pages> 17-37, </pages> <year> 1982. </year>
Reference-contexts: Match 2. Conflict-resolution 3. Act The matching procedure determines the set of satisfied productions, the conflict-resolution procedure selects the highest priority instantiation, and the act procedure executes its RHS. These three steps are collectively called the recognize-act cycle. 2.2. Rete Rete <ref> [3] </ref> is a highly efficient match algorithm that is also suitable for parallel implementations [5]. Rete gains its efficiency from two optimizations.
Reference: [4] <author> Forgy, C. L. </author> <title> The OPS83 Report. </title> <type> Technical Report CMU-CS-84-133, </type> <institution> Computer Science Department, Carnegie Mellon University, </institution> <month> May, </month> <year> 1984. </year>
Reference-contexts: It produces a machine coded version of the Rete data-flow network. Before starting a run, the ParaOPS5 compiler generates a tree structured representation of the Rete network for the current set of productions. This data structure is used to generate OPS83 <ref> [4] </ref> style assembly code for the network. The system then uses the assembling, linking and loading facilities provided by the operating system to create the executable image. This process is explained in detail in later PARALLEL OPS5 4 sections.
Reference: [5] <author> Gupta, A. </author> <title> Parallelism in Production Systems. </title> <type> PhD thesis, </type> <institution> Computer Science Department, Carnegie Mellon University, </institution> <month> March, </month> <year> 1986. </year>
Reference-contexts: This document is a reference manual of our parallel implementation of the OPS5 production system language [1, 2], called ParaOPS5. ParaOPS5 is based on the parallel implementation proposed in <ref> [5] </ref>. ParaOPS5 does not change the computational model or the functionality of OPS5. Therefore, OPS5 programs can be run on this system without any changes. ParaOPS5 exploits parallelism in the match phase of OPS5. <p> Our analysis [6] indicates that MPCs are quite suitable for production systems. We expect you, the readers of this document, to be familiar with the OPS5. In fact, for reading this document, the OPS5 User's Manual [2] is an essential reference. Familiarity with the implementation proposed in <ref> [5] </ref> may be helpful, but is not necessary. For the interested reader, the ParaOPS5 implementation is described in detail in some other papers related to the PSM project [7, 8]. Section 2 provides some background information. Section 3 presents information about installation and system requirements for ParaOPS5. <p> These three steps are collectively called the recognize-act cycle. 2.2. Rete Rete [3] is a highly efficient match algorithm that is also suitable for parallel implementations <ref> [5] </ref>. Rete gains its efficiency from two optimizations. First, it exploits the fact that only a small fraction of working memory changes each cycle by storing results of match from previous cycles and using them in subsequent cycles. <p> ParaOPS5 exploits parallelism at the granularity of node activations. Previous work has demonstrated that to achieve significant speed-ups via parallelism in production systems, it is necessary to exploit parallelism at a very fine granularity <ref> [5] </ref>. A node activation consists of the address of the code for a node in the Rete network and an input token for that node. These node activations are called tasks and are held in one or more shared task queues. <p> This implies favoring productions that have a larger number of RHS actions to affect working memory or that have RHS actions that affect a greater number of other productions. 2. Long Chains: Productions with a large number of CEs can be a bottleneck due to the long chain effect <ref> [5] </ref>. The long chain effect is due to a long chain of dependent node activations in which a node activation causes an activation of its successor node which in turn causes an activation of its successor node, and so on.
Reference: [6] <author> Gupta, A. and Tambe, M. </author> <title> Suitability of message passing computers for implementing production systems. </title> <booktitle> In Proceedings of the National Conference on Artificial Intelligence, </booktitle> <pages> pages 687-692. </pages> <month> August, </month> <year> 1988. </year>
Reference-contexts: However, it is also suitable for use on uniprocessor machines as well since the implementation technology used provides it with considerable speed-ups over the serial Lisp-based versions of OPS5. We are also investigating the implementation of ParaOPS5 on message passing computers (MPCs). Our analysis <ref> [6] </ref> indicates that MPCs are quite suitable for production systems. We expect you, the readers of this document, to be familiar with the OPS5. In fact, for reading this document, the OPS5 User's Manual [2] is an essential reference.
Reference: [7] <author> Gupta, A., Forgy, C. L., Kalp, D., Newell, A., and Tambe, M. </author> <booktitle> Parallel OPS5 on the Encore Multimax. In Proceedings of the International Conference on Parallel Processing, </booktitle> <pages> pages 271-280. </pages> <month> August, </month> <year> 1988. </year>
Reference-contexts: In fact, for reading this document, the OPS5 User's Manual [2] is an essential reference. Familiarity with the implementation proposed in [5] may be helpful, but is not necessary. For the interested reader, the ParaOPS5 implementation is described in detail in some other papers related to the PSM project <ref> [7, 8] </ref>. Section 2 provides some background information. Section 3 presents information about installation and system requirements for ParaOPS5. Section 4 describes how to use the system and presents an overview of ParaOPS5, its command interface and run-time options. <p> A single task queue can become a bottleneck when several match processes are contending for the lock on the queue in order to deposit or remove tasks to or from the queue. Multiple task queues reduces this contention. The effect of using multiple task queues is reported in <ref> [7, 8] </ref>. 10. -r This switch has an effect only when multiple task queues are used. It instructs the PSM control process to deposit root node activations of the Rete network in a round-robin fashion among the task queues.

References-found: 7

