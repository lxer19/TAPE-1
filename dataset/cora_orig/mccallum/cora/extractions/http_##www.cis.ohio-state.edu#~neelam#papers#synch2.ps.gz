URL: http://www.cis.ohio-state.edu/~neelam/papers/synch2.ps.gz
Refering-URL: http://www.cis.ohio-state.edu/~neelam/papers/research.html
Root-URL: 
Email: e-mail: neelam@cis.ohio-state.edu  
Title: On the Specification, Inheritance, and Verification of Synchronization Constraints  
Author: Neelam Soundarajan 
Keyword: Key phrases: Specification and verification; Synchronization constraints; Inheritance anomaly.  
Address: Columbus, OH 43210 USA  
Affiliation: Computer and Information Science The Ohio State University  
Abstract: Object-orientation and distributed systems are a natural match. Objects correspond to processes in a distributed program; the invocation of a method of one object by another object corresponds naturally to a message being passed between the corresponding processes in the distributed program. Despite this close correspondence, progress in developing an OO approach to concurrency has been limited. One important problem has been the so-called inheritance anomaly which is concerned with how and how easily synchronization constraints specified in a base class may be modified in a derived class. Our concern in the current paper is slightly different. We are interested in developing ways to abstractly specify these synchronization constraints, and ways to verify them. In other words we are interested in what these synchronization constraints do, and this is, of course, the critical question from the point of view of the users of these objects. We use the mechanism of acceptance sets in our specifications. We develop a proof method to verify that (base as well as derived) classes meet their specifications. We also consider the question of what kinds of modifications of synchronization constraints in the derived classes are easy for the clients of the class to deal with. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> S. Frolund, </author> <title> Inheritance of synchronization constraints, </title> <booktitle> Proceedings of ECOOP '92, </booktitle> <pages> pp. 185-196. 14 </pages>
Reference-contexts: Thus in the third section we consider two different approaches (those of <ref> [1] </ref> and [Kafura]) to using inheritance in conjunction with concurrency and consider how our specification and verification method may be applied in each case. <p> Frlund <ref> [1] </ref> proposes a natural approach to expressing synchronization code in classes. His proposal is to use method guards to express synchronization conditions. A method guard specifies a condition that disables a particular operation.
Reference: 2. <author> Y. Ishikawa, </author> <title> Communication mechanisms on autonomous objects, </title> <booktitle> OOP SLA 1992, </booktitle> <pages> pp. 303-314. </pages>
Reference-contexts: So far we have been able to ignore the programming language notation in which these method bodies and synchronization code is written but now we must take account of this notation. The interesting question here is how the various notations that have been proposed in the literature <ref> [such as those of 1, 3, 2, 5] </ref> for specifying the synchronization conditions, may be handled. 5 We will consider, in turn, two of 5 We will assume that the non-synchronization portion of the individual methods are written using a standard collection of constructs and will omit discussion of them. 9
Reference: 3. <author> D. Kafura, K. Lee, </author> <title> Inheritance in Actor based languages, </title> <booktitle> Proceedings of ECOOP '89, </booktitle> <pages> pp. 131-145. </pages>
Reference-contexts: So far we have been able to ignore the programming language notation in which these method bodies and synchronization code is written but now we must take account of this notation. The interesting question here is how the various notations that have been proposed in the literature <ref> [such as those of 1, 3, 2, 5] </ref> for specifying the synchronization conditions, may be handled. 5 We will consider, in turn, two of 5 We will assume that the non-synchronization portion of the individual methods are written using a standard collection of constructs and will omit discussion of them. 9 <p> The clause corresponding to an all-except guard would then simply say that none of the method names in AllMethods less those named in the construct are not in the set CA of the class (if the specified condition is satisfied). 6 Next consider the approach of Kafura and Lee <ref> [3] </ref>. They introduce the notion of behavioral abstraction which is more or less the same concept as our acceptance set. The value of the behavioral abstraction at any point is the set of method names that are enabled at that point. <p> As we saw the details of the proof techniques do depend on the particular programming notation in question, but the basic approach seems general. We wll conclude with a brief remark about future work. Kafura and Lee's <ref> [3] </ref> system depends heavily on their idea of behavioral abstractions. In a sense, this is a second order construct. In particular, commands like `become' have a distinct `second-order-flavor' about them. Nevertheless, we were able to deal with their system using our approach.
Reference: 4. <author> B. Liskov, J. Wing, </author> <title> A behavioral notion of subtyping, </title> <journal> ACM TOPLAS, </journal> <volume> vol. 16, </volume> <pages> pp. 1811-1841, </pages> <year> 1994. </year>
Reference-contexts: In any case, if we decide that it is, we will have to write not just the concrete synchronization property, but also the abstract one as a conjunction of after g i clauses. 4 Discussion One school of OO thinking (see, for example, <ref> [4] </ref>) has argued that inheritance should be used in a very limited way, specifically that it should not be used for purely implementation purposes.
Reference: 5. <author> S. Matsuoka, A. Yonezawa, </author> <title> Analysis of inheritance anomaly in concurrent OO languages, in Research directions in concurrent OO programming, </title> <editor> ed. Agha, Wegner, Yonezawa, </editor> <year> 1993, </year> <pages> pp. 107-150. </pages>
Reference-contexts: So far we have been able to ignore the programming language notation in which these method bodies and synchronization code is written but now we must take account of this notation. The interesting question here is how the various notations that have been proposed in the literature <ref> [such as those of 1, 3, 2, 5] </ref> for specifying the synchronization conditions, may be handled. 5 We will consider, in turn, two of 5 We will assume that the non-synchronization portion of the individual methods are written using a standard collection of constructs and will omit discussion of them. 9 <p> That is not to say that we could deal with arbitrary second order operations on functions, but there is no need to do that. All we need to be able to do is to handle the types of opertaions that seem useful in building OO systems. Matsuoka and Yonezawa <ref> [5] </ref> also remark on the importance of such limited second-order capabilities in building powerful systems. But it is not enough to build the systems. We need to be able to reason about them; that is why we believe our approach will prove useful.
Reference: 6. <author> B. Meyer, </author> <title> Object oriented software construction, </title> <publisher> Prentice-Hall, </publisher> <year> 1988. </year>
Reference-contexts: Inheritance is one of the cornerstones of the object-oriented approach. It not only allows us to create classes in an incremental manner from existing classes, without having to repeat what the base class already provides. Although some authors have criticized inheritance, others like Meyer <ref> [6] </ref> have presented persuasive arguments in its favor. One of the problems in applying OO ideas to concurrent programming is the inheritance anomaly [MandY]. To see the problem, consider the standard example of a bounded-buffer class.
Reference: 7. <author> J. Misra, KM. Chandy, </author> <title> Proofs of networks of processes, </title> <journal> IEEE TSE, </journal> <year> 1981. </year>
Reference-contexts: We will not consider this formalism in the current paper. It should be possible to design such a formalism along the lines of existing systems such as <ref> [8, 7] </ref> that are applicable in the absence of user defined classes. 3 the derived class designer does not need to look into the actual code of the base class operation. The formalism we develop in the current paper is a natural extension of that in [9].
Reference: 8. <author> N. Soundarajan, </author> <title> Axiomatic semantics of CSP, </title> <journal> ACM TOPLAS, </journal> <year> 1984. </year>
Reference-contexts: We will not consider this formalism in the current paper. It should be possible to design such a formalism along the lines of existing systems such as <ref> [8, 7] </ref> that are applicable in the absence of user defined classes. 3 the derived class designer does not need to look into the actual code of the base class operation. The formalism we develop in the current paper is a natural extension of that in [9].
Reference: 9. <author> N. Soundarajan, S. Fridella, </author> <title> Inheriting and modifying behavior, </title> <note> submitted to ECOOP 1997 (available at URL: http//www.cis.ohio-state.edu/~neelam). 15 </note>
Reference-contexts: As a result, the derived class designer may be forced to reverify all of the base class operations, including those that are not redefined in the derived class, since these operations also use the same variables. We have developed a formal approach in <ref> [9] </ref> to simplify this task in the sequential case. The key idea behind the approach in [9] is to have two formal models of the (base) class. The first is the usual, abstract model for use by the client of the class. <p> We have developed a formal approach in <ref> [9] </ref> to simplify this task in the sequential case. The key idea behind the approach in [9] is to have two formal models of the (base) class. The first is the usual, abstract model for use by the client of the class. <p> The formalism we develop in the current paper is a natural extension of that in <ref> [9] </ref>. Each class will have two specifications associated with it, an abstract specification for use by a client of the class, and a concrete specification for use by a derived class designer. <p> As in <ref> [9] </ref>, the abstract specification will be in terms of an abstract mathematical model, whereas the concrete specification will be in terms of the actual data structures used in the class. We should note that we are not proposing a solution to the inheritance anomaly. <p> We will term these pre- and post-conditions and the synchronization property `concrete' in order to distinguish from their counterparts in the abstract specification. In addition, as in <ref> [9] </ref>, the concrete specification should include an invariant on the data members of the class; since our interest in this paper is on synchronization issues, we will generally ignore this invariant. <p> Recall that private variables would not be accessible even in the derived class. In <ref> [9] </ref> we explain how we can deal with both kinds of variables. 7 Thus the concrete pre- and post-conditions of these operations are: f true g put ( k ) f in = #in 1 ^ Elems = #Elems [#in t] g f true g get ( ) f value = <p> ) c:pre f (!) (1a) c:post f (!) ) a:post f ("(!))) (1b) CSP (!) ) ASP ("(!)) (2) These implications simply represent the fact that the abstract and concrete specifications are directly related via the mapping function ". (1a) and (1b) are simplified versions of the corresponding rules in <ref> [9] </ref>; the rules in [9] take account of the concrete invariant. <p> (1a) c:post f (!) ) a:post f ("(!))) (1b) CSP (!) ) ASP ("(!)) (2) These implications simply represent the fact that the abstract and concrete specifications are directly related via the mapping function ". (1a) and (1b) are simplified versions of the corresponding rules in <ref> [9] </ref>; the rules in [9] take account of the concrete invariant. <p> This is hardly surprising, given that these two groups of users need to know different things about the class. We applied this idea to the sequential case in <ref> [9] </ref>, and have tried to extend to concurrent languages in the current paper. For this purpose we had to associate with each class an abstract and a concrete synchronization property in addition to pre- and post-condition specifications of the various operations of the class.
References-found: 9

