URL: http://www.cs.princeton.edu/~erez/KiPeRa.ps
Refering-URL: http://www.cs.princeton.edu/~erez/publications.html
Root-URL: http://www.cs.princeton.edu
Title: Lower Bounds for Zero Knowledge on the Internet  
Author: Joe Kilian Erez Petrank Charles Rackoff 
Abstract: We consider zero knowledge interactive proofs in a richer, more realistic communication environment. In this setting, one may simultaneously engage in many interactive proofs, and these proofs may take place in an asynchronous fashion. It is known that zero-knowledge is not necessarily preserved in such an environment; we show that for a large class of protocols, it cannot be preserved. Any 4 round (computational) zero-knowledge interactive proof (or argument) for a non-trivial language L is not black-box simulat-able in the asynchronous setting. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> C. Brassard, C. Crepeau and M. Yung, </author> <title> Constant-Round Perfect Zero-Knowledge Computationally Convincing Protocols, </title> <journal> Theoretical Computer Science, </journal> <volume> Vol. 84, </volume> <year> 1991, </year> <pages> pp. 23-52. </pages>
Reference-contexts: Thus, for example, unless Graph Isomorphism is in BPP, the protocol of [13] for Graph Isomorphism does not remain zero knowledge when run many times in parallel. Several papers have dealt with this problem, usually by letting the verifier commit on it's (non-adaptive) questions in advance <ref> [1, 3, 11, 8] </ref>. Our initial feeling was that the protocols that keep their zero knowledge property when run in parallel should also remain zero knowledge even in a multi-session asynchronous environment. However, in this paper, we give some indications that this is not always the case.
Reference: [2] <author> M. Bellare, R. Impagliazzo, and M. Naor. </author> <title> Does Parallel Repetition Lower the Error in Computationally Sound Protocols? In Proceedings of 38th Annual Symposium on Foundations of Computer Science, </title> <publisher> IEEE, </publisher> <year> 1997. </year>
Reference-contexts: This gives a simpler proof of our theorem for this case, and can be used to extend the theorem to work for 5 message interactive proofs [18]. Unfortunately, in the argument model, parallel amplification doesn't always work <ref> [2] </ref>, so we can't use this trick to obtain a general theorem. 3.4. Splicing in the proof Let us first state more explicitly how the splicing operation works. In the proof system, V flips coins to generate R, and generates an initial challenge q = q (x; R).
Reference: [3] <author> M. Bellare, S. Micali, and R. Ostrovsky. </author> <title> Perfect zero-knowledge in constant rounds. </title> <booktitle> In Proc. 22nd Ann. ACM Symp. on Theory of Computing, </booktitle> <pages> pages 482493, </pages> <year> 1990. </year>
Reference-contexts: Thus, for example, unless Graph Isomorphism is in BPP, the protocol of [13] for Graph Isomorphism does not remain zero knowledge when run many times in parallel. Several papers have dealt with this problem, usually by letting the verifier commit on it's (non-adaptive) questions in advance <ref> [1, 3, 11, 8] </ref>. Our initial feeling was that the protocols that keep their zero knowledge property when run in parallel should also remain zero knowledge even in a multi-session asynchronous environment. However, in this paper, we give some indications that this is not always the case.
Reference: [4] <author> T. Beth and Y. Desmedt. </author> <title> Identification tokens or: Solving the chess grandmaster problem. </title> <editor> In A. J. Menezes and S. A. Vanstone, editors, </editor> <booktitle> Proc. CRYPTO 90, </booktitle> <pages> pages 169177. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year> <note> Lecture Notes in Computer Science No. 537. </note>
Reference-contexts: We consider black box zero knowledge as defined by Goldreich and Oren [19, 14], and refined in [12]. 1.1. Related work There is a vast literature in the distributed computing community dealing with asynchronicity. Within the cryptology community, Beth and Desmedt <ref> [4] </ref> discuss such asynchronous attacks in the context of identification protocols, and proposed timing methods to defend against such attacks.
Reference: [5] <author> I. L. Carter and M. N. Wegman. </author> <title> Universal classes of hash functions. </title> <booktitle> In Conference Record of the Ninth Annual ACM Symposium on Theory of Computing: Papers Presented at the Symposium, </booktitle> <address> Boulder, Col-orado, </address> <month> May 24, </month> <year> 1977, </year> <pages> pages 106112, </pages> <address> New York, NY 10036, USA, 1977. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Pedantically, we can view H as a family fH m;n g of hash functions; we suppress these subscripts for clarity. As in [12], we will think of H as being randomly chosen from a family of hash functions <ref> [5] </ref>. And as in [12] we do not use the standard pairwise independent family. Instead we use families of hash functions that achieve p (n)- independence, for some sufficiently large polynomial p.
Reference: [6] <author> C. Dwork, M. Naor and A. Sahai. </author> <title> Concurrent Zero-Knowledge. </title> <booktitle> Proceedings,30th Symposium on Theory of Computing, </booktitle> <pages> pp. 409428, </pages> <year> 1998. </year>
Reference-contexts: Dwork, Naor and Sahai <ref> [6] </ref> consider the role of asynchronous attacks on zero-knowledge protocols. <p> Creating an efficient prover To prove our main theorem, we construct a particular malicious verifier (pedantically a family of closely related malicious verifiers), with a fixed scheduling strategy (a very similar strategy is used in <ref> [6] </ref>). We show that a simulator that successfully simulates the multi-conversation on input x with high probability can be converted to a probabilistic polynomial prover P S for the original protocol. This prover will cause V to accept x with probability strictly greater than 1=2.
Reference: [7] <author> C. Dwork and A. Sahai. </author> <title> Concurrent Zero-Knowledge: Reducing the Need for Timing Constraints. </title> <booktitle> Proceedings, Advances in Cryptology Crypto '98. </booktitle>
Reference-contexts: Dwork and Sahai <ref> [7] </ref> reduce (but do not eliminate) the timing constraints required by their defense. Our result is complementary to theirs, illustrating why it is difficult to achieve zero-knowledge in the asynchronous setting without using such an augmented model.
Reference: [8] <author> U. Feige and A. Shamir, </author> <title> Zero Knowledge Proofs of Knowledge in Two Rounds, </title> <booktitle> Advances in Cryptology Crypto 89 proceedings, </booktitle> <pages> pp. 526-544, </pages> <year> 1990. </year>
Reference-contexts: Thus, for example, unless Graph Isomorphism is in BPP, the protocol of [13] for Graph Isomorphism does not remain zero knowledge when run many times in parallel. Several papers have dealt with this problem, usually by letting the verifier commit on it's (non-adaptive) questions in advance <ref> [1, 3, 11, 8] </ref>. Our initial feeling was that the protocols that keep their zero knowledge property when run in parallel should also remain zero knowledge even in a multi-session asynchronous environment. However, in this paper, we give some indications that this is not always the case. <p> Note that we get a separation between protocols that remain zero knowledge even under parallel repetition and protocols that remain zero knowledge in an asynchronous setting. Assuming the existence of one-to-one one-way functions, there exist 4-message (computational) zero knowledge arguments for all NP languages <ref> [8] </ref>. However, there there are no 4-message zero knowledge arguments for languages outside of BPP that are black box simulatable in the asynchronous setting. Some words on the terminology we are using.
Reference: [9] <author> U. Feige and A. Shamir. </author> <title> Witness indistinguishable and witness hiding protocols. </title> <editor> In Baruch Awerbuch, editor, </editor> <booktitle> Proceedings of the 22nd Annual ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 416426, </pages> <address> Baltimore, MY, May 1990. </address> <publisher> ACM Press. </publisher>
Reference-contexts: In another complementary result, Richardson and Kilian [20] show how to construct arguments with polyno-mially many rounds which are asynchronously simulatable against polynomially many simultaneous runs. Feige and Shamir showed that witness indistinguishability is preserved also in the asynchronous setting <ref> [9] </ref>. The basic framework of our proof uses the ideas developed by Goldreich and Krawczyk [12].
Reference: [10] <author> O. Goldreich, S. Goldwasser, and S. Micali. </author> <title> How to construct random functions. </title> <booktitle> In 25th Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 464 479, </pages> <address> Los Angeles, Ca., USA, October 1984. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference: [11] <author> O. Goldreich and A. Kahan, </author> <title> How to Construct Constant-Round Zero-Knowledge Proof Systems for NP, </title> <journal> Journal of Cryptology, </journal> <volume> Vol. 9, No. 2, </volume> <year> 1996, </year> <pages> pp. 167189. </pages>
Reference-contexts: Thus, for example, unless Graph Isomorphism is in BPP, the protocol of [13] for Graph Isomorphism does not remain zero knowledge when run many times in parallel. Several papers have dealt with this problem, usually by letting the verifier commit on it's (non-adaptive) questions in advance <ref> [1, 3, 11, 8] </ref>. Our initial feeling was that the protocols that keep their zero knowledge property when run in parallel should also remain zero knowledge even in a multi-session asynchronous environment. However, in this paper, we give some indications that this is not always the case.
Reference: [12] <author> O. Goldreich, H. Krawczyk. </author> <title> On the Composition of Zero-Knowledge Proof Systems. </title> <journal> SIAM J. on Computing, </journal> <volume> Vol. 25, No.1, </volume> <pages> pp. 169-192, </pages> <year> 1996 </year>
Reference-contexts: Email: erezp@haifa.vnet.ibm.com. z Dept. of Computer Science, University of Toronto, Toronto, Ontario, Canada M5B 3g4. Email: rackoff@cs.toronto.edu. and is considered inefficient. It had been noted by several researchers that even in the parallel repetitions case the zero knowledge property does not necessarily hold. Goldreich and Krawczyk <ref> [12] </ref> proved a general lower bound: Any language that has a three round (black-box) zero-knowledge interactive proof with a negligible error probability (as can be obtained by parallel repetitions) is in BPP. <p> The prover may be infinitely powerful (i.e., an interactive proof) or it may be computationally bounded (i.e., an argument). We consider black box zero knowledge as defined by Goldreich and Oren [19, 14], and refined in <ref> [12] </ref>. 1.1. Related work There is a vast literature in the distributed computing community dealing with asynchronicity. Within the cryptology community, Beth and Desmedt [4] discuss such asynchronous attacks in the context of identification protocols, and proposed timing methods to defend against such attacks. <p> Feige and Shamir showed that witness indistinguishability is preserved also in the asynchronous setting [9]. The basic framework of our proof uses the ideas developed by Goldreich and Krawczyk <ref> [12] </ref>. Following their technique, we use a good simulator S of an interactive proof (or argument) (P; V ) for a language L to create an efficient prover P S that causes V to accept reasonably often on in puts in L. 1.2. <p> For statistical and perfect zero knowledge, we allow for unbounded distinguisher; equivalently, we require that the statistical difference between the distribution be negligible (less than 1=jxj c for any c). In our paper, as in <ref> [12] </ref>, we only consider deterministic ^ V ; for this class of adversaries, the above definition requires the existence of a single universal simulator, S. At first glance, the limitations on S may seem to force S to be as powerful as a prover. <p> However, these techniques do not seem applicable to more standard classes of verifiers. 2.2. Black-box verifiers with private random func tions Following <ref> [12] </ref>, we consider verifiers ^ V that have access to a private random hash function H , that is wired into them and is not directly accessible to the simulator (note that ^ V is deterministic in that it doesn't use an external source of randomness; its construction is randomized). <p> In practice, H will be defined for big enough n and m, and its inputs (if short) will be padded to fit the length of H's inputs. Pedantically, we can view H as a family fH m;n g of hash functions; we suppress these subscripts for clarity. As in <ref> [12] </ref>, we will think of H as being randomly chosen from a family of hash functions [5]. And as in [12] we do not use the standard pairwise independent family. Instead we use families of hash functions that achieve p (n)- independence, for some sufficiently large polynomial p. <p> Pedantically, we can view H as a family fH m;n g of hash functions; we suppress these subscripts for clarity. As in <ref> [12] </ref>, we will think of H as being randomly chosen from a family of hash functions [5]. And as in [12] we do not use the standard pairwise independent family. Instead we use families of hash functions that achieve p (n)- independence, for some sufficiently large polynomial p.
Reference: [13] <author> O. Goldreich, S. Micali, and A. Wigderson, </author> <title> Proofs that Yield Nothing But their Validity or All Languages in NP Have Zero-Knowledge proof Systems, </title> <journal> Jour. of ACM., </journal> <volume> Vol. 38, </volume> <year> 1991, </year> <pages> pp. 691729. </pages>
Reference-contexts: Goldreich and Krawczyk [12] proved a general lower bound: Any language that has a three round (black-box) zero-knowledge interactive proof with a negligible error probability (as can be obtained by parallel repetitions) is in BPP. Thus, for example, unless Graph Isomorphism is in BPP, the protocol of <ref> [13] </ref> for Graph Isomorphism does not remain zero knowledge when run many times in parallel. Several papers have dealt with this problem, usually by letting the verifier commit on it's (non-adaptive) questions in advance [1, 3, 11, 8].
Reference: [14] <author> Oded Goldreich and Yair Oren. </author> <title> Definitions and properties of zero-knowledge proof systems. </title> <journal> Journal of Cryptology, </journal> <volume> 7(1):132, </volume> <month> Winter </month> <year> 1994. </year>
Reference-contexts: The prover may be infinitely powerful (i.e., an interactive proof) or it may be computationally bounded (i.e., an argument). We consider black box zero knowledge as defined by Goldreich and Oren <ref> [19, 14] </ref>, and refined in [12]. 1.1. Related work There is a vast literature in the distributed computing community dealing with asynchronicity. Within the cryptology community, Beth and Desmedt [4] discuss such asynchronous attacks in the context of identification protocols, and proposed timing methods to defend against such attacks. <p> In Section 6 we describe how to eliminate this restriction. 2. Preliminaries 2.1. Black-Box Zero-Knowledge The initial definition of zero-knowledge [15] required that for any probabilistic polynomial time verifier ^ V , a simulator S ^ V exists that could simulate ^ V 's view. Goldreich and Oren <ref> [19, 14] </ref> propose a seemingly stronger, better behaved notion of zero-knowledge, known as black-box zero-knowledge. <p> More formally, Goldreich and Krawczyk give the following version of this definition (notation changed for compat ibility with our own), which avoids certain trivial problems in the original expositions. Definition 1 ([12], following <ref> [19, 14] </ref>) An interactive proof hP; V i is called black-box simulation zero-knowledge if for every polynomial p, there exists a probabilistic expected polynomial time oracle machine S p such that for any poly nomial size verifier ^ V that uses at most p (n) random coins on inputs of length
Reference: [15] <author> S. Goldwasser, S. Micali, C. Rackoff. </author> <title> The Knowledge Complexity of Interactive Proofs. </title> <booktitle> Proc. 17th STOC, </booktitle> <year> 1985, </year> <pages> pp. 291-304. </pages>
Reference-contexts: These sections assume a slightly restricted verifier: the verifier can decide whether or not to accept based on the conversation thus far, and not on its random coins. In Section 6 we describe how to eliminate this restriction. 2. Preliminaries 2.1. Black-Box Zero-Knowledge The initial definition of zero-knowledge <ref> [15] </ref> required that for any probabilistic polynomial time verifier ^ V , a simulator S ^ V exists that could simulate ^ V 's view. Goldreich and Oren [19, 14] propose a seemingly stronger, better behaved notion of zero-knowledge, known as black-box zero-knowledge.
Reference: [16] <author> S. Goldwasser, S. Micali, and C. Rackoff. </author> <title> The Knowledge Complexity of Interactive Proof Systems, </title> <journal> SIAM J. Comput., </journal> <volume> 18 (1):186208, </volume> <year> 1989. </year>
Reference-contexts: 1. Introduction Zero knowledge <ref> [16] </ref> turned out to be a useful tool for many cryptographic applications. Many works have studied the numerous uses of zero knowledge proofs, and many other works have suggested how to improve the efficiency of these proofs.
Reference: [17] <author> J. Kilian. </author> <title> Zero-Knowledge with Log-Space Verifiers Proceedings, </title> <booktitle> 29 th annual IEEE Symposium on the Foundations of Computer Science. </booktitle>
Reference-contexts: customize simulators based on the description of ^ V other than by using it as a black box. 1 Thus, given the current state of the art, an impossibility result for black-box zero-knowledge seems to preclude a positive result for the older definitions of zero-knowledge. 1 As one slight exception, <ref> [17] </ref> proves security against space-bounded verifiers by considering the internal state of the verifiers. However, these techniques do not seem applicable to more standard classes of verifiers. 2.2.
Reference: [18] <author> J. Kilian and E. Petrank. </author> <note> Manuscript in preparation. </note>
Reference-contexts: Given an interactive proof with error bounded away from 1, one can run it in parallel to obtain a proof with negligible error. This gives a simpler proof of our theorem for this case, and can be used to extend the theorem to work for 5 message interactive proofs <ref> [18] </ref>. Unfortunately, in the argument model, parallel amplification doesn't always work [2], so we can't use this trick to obtain a general theorem. 3.4. Splicing in the proof Let us first state more explicitly how the splicing operation works.
Reference: [19] <author> Y. Oren. </author> <title> On the cunning powers of cheating verifiers: Some observations about zero knowledge proofs. </title> <editor> In Ashok K. Chandra, editor, </editor> <booktitle> Proceedings of the 28th Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 462471, </pages> <address> Los Angeles, CA, October 1987. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: The prover may be infinitely powerful (i.e., an interactive proof) or it may be computationally bounded (i.e., an argument). We consider black box zero knowledge as defined by Goldreich and Oren <ref> [19, 14] </ref>, and refined in [12]. 1.1. Related work There is a vast literature in the distributed computing community dealing with asynchronicity. Within the cryptology community, Beth and Desmedt [4] discuss such asynchronous attacks in the context of identification protocols, and proposed timing methods to defend against such attacks. <p> In Section 6 we describe how to eliminate this restriction. 2. Preliminaries 2.1. Black-Box Zero-Knowledge The initial definition of zero-knowledge [15] required that for any probabilistic polynomial time verifier ^ V , a simulator S ^ V exists that could simulate ^ V 's view. Goldreich and Oren <ref> [19, 14] </ref> propose a seemingly stronger, better behaved notion of zero-knowledge, known as black-box zero-knowledge. <p> More formally, Goldreich and Krawczyk give the following version of this definition (notation changed for compat ibility with our own), which avoids certain trivial problems in the original expositions. Definition 1 ([12], following <ref> [19, 14] </ref>) An interactive proof hP; V i is called black-box simulation zero-knowledge if for every polynomial p, there exists a probabilistic expected polynomial time oracle machine S p such that for any poly nomial size verifier ^ V that uses at most p (n) random coins on inputs of length
Reference: [20] <author> R. Ransom and J. Kilian. </author> <title> Non-Synchronized Composition of Zero-Knowledge Proofs. </title> <type> Manuscript. </type>
Reference-contexts: Dwork and Sahai [7] reduce (but do not eliminate) the timing constraints required by their defense. Our result is complementary to theirs, illustrating why it is difficult to achieve zero-knowledge in the asynchronous setting without using such an augmented model. In another complementary result, Richardson and Kilian <ref> [20] </ref> show how to construct arguments with polyno-mially many rounds which are asynchronously simulatable against polynomially many simultaneous runs. Feige and Shamir showed that witness indistinguishability is preserved also in the asynchronous setting [9]. The basic framework of our proof uses the ideas developed by Goldreich and Krawczyk [12].
References-found: 20

