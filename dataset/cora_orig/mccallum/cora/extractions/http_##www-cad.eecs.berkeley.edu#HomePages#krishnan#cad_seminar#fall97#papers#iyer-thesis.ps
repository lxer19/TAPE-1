URL: http://www-cad.eecs.berkeley.edu/HomePages/krishnan/cad_seminar/fall97/papers/iyer-thesis.ps
Refering-URL: http://www-cad.eecs.berkeley.edu/HomePages/krishnan/cad_seminar/fall97/abstract/iyer.html
Root-URL: http://www.cs.berkeley.edu
Title: ON REDUNDANCY AND UNTESTABILITY IN SEQUENTIAL CIRCUITS  
Author: BY MAHESH ANANTHARAMAN IYER 
Degree: Submitted in partial fulfillment of the requirements for the degree of Doctor of Philosophy in Electrical Engineering in the Graduate School of the  Approved Thesis Advisor Academic Advisor  
Date: July, 1995  
Affiliation: Illinois Institute of Technology  Chicago, Illinois  
Abstract-found: 0
Intro-found: 1
Reference: [Abramovici and Breuer 1979] <author> M. Abramovici and M. A. Breuer, </author> <title> "On Redundancy and Fault Detection in Sequential Circuits." </title> <journal> IEEE Trans. on Computers, </journal> <volume> vol. C-28, no. 11, </volume> <pages> pp. 864-865, </pages> <month> November </month> <year> 1979. </year>
Reference-contexts: Also, redundancies identified using low-cost techniques can be useful in synthesis for circuit simplification. Unlike combinational circuits, an untestable fault in a sequential circuit is not necessarily redundant <ref> [Abramovici and Breuer 1979] </ref>. Typically, such faults affect the initialization of the circuit. In a sequential circuit, redundant faults form a subset of the untestable faults. Identifying sequential redundancy using ATG has the added complexity of verifying whether an untestable fault is indeed redundant. <p> Irredundant Untestable Faults Untestable Faults Testable Faults Partially Testable Faults Redundant Faults A more restrictive definition of redundancy that was used in <ref> [Abramovici and Breuer 1979, Moondanos and Abraham 1992] </ref> is as follows. <p> In sequential circuits, untestability and redundancy are not equivalent concepts. One class of sequentially untestable but irredundant faults consists of faults that prevent initialization (FPIs) <ref> [Abramovici and Breuer 1979] </ref>. A method to identify untestable FPIs was introduced in 20 [Abramovici and Parikh 1992]. We now present an example of an untestable FPI that is irredundant. <p> The redundancies found were not restricted to any particular classes of faults. 3.2 Sequential RID and Removal In sequential circuits, untestability and redundancy are not equivalent concepts <ref> [Abramovici and Breuer 1979] </ref>. Typically, irredundant faults that are sequentially untestable affect the initialization of the circuit. Several solutions have been proposed in the literature to identify (and remove) sequential redundancy. <p> Also, a subset of lines in the circuit that need to be analyzed for this purpose were identified. A sequentially untestable fault is not necessarily redundant <ref> [Abramovici and Breuer 1979] </ref>. Chapter 2 also illustrated some examples of irredundant sequentially untestable faults. Chapter 3 reviewed all the previous work to identify sequential redundancy and it was shown that no practical solution exists to solve this problem.
Reference: [Abramovici et al. 1990] <author> M. Abramovici, M. A. Breuer, and A. D. Friedman, </author> <title> Digital Systems Testing and Testable Design. </title> <publisher> Computer Science Press, </publisher> <address> New York, NY, </address> <year> 1990. </year>
Reference-contexts: The second, called the multiple observation time strategy [Pomeranz and Reddy 1992], is based on the concept of strong detection <ref> [Abramovici et al. 1990] </ref>, which relies on finding a sequence for a fault by making the fault-free circuit starting at state S 1 and the faulty circuit starting at state S 2 exhibit different output responses at some vector (not necessarily the same), for all ( S 1 , S 2 <p> It is well known that because of the pessimism involved in the use of the unknown logic value, a test generator may report as untestable, a fault for which a test sequence in fact exists 10 <ref> [Abramovici et al. 1990] </ref>. While in ATG this pessimism may only lead to fewer faults being tested, it has serious implications when identifying redundancy, because removing the region associated with an irredundant fault results in a circuit whose behavior is different from that of the original circuit. <p> Once a combinational redundancy is identified, the procedure to determine (and remove) the redundant logic for that fault is conceptually straightforward <ref> [Abramovici et al. 1990, Abramovici and Iyer 1992, Iyer 1991] </ref>. On identifying a redundant fault the maximum redundant region for this fault is determined by forward propagating the stuck value of the redundant fault. <p> This increase is due to the gates internal to the FF models. The number of faults are those obtained after functional fault equivalence collapsing <ref> [Abramovici et al. 1990] </ref>. Faults internal to FF models are however ignored.
Reference: [Abramovici and Iyer 1992] <author> M. Abramovici and M. A. Iyer, </author> <title> "One-Pass Redundancy Identification and Removal." </title> <booktitle> Proc. Intn'l. Test Conf., </booktitle> <pages> pp. 807-815, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: Once a combinational redundancy is identified, the procedure to determine (and remove) the redundant logic for that fault is conceptually straightforward <ref> [Abramovici et al. 1990, Abramovici and Iyer 1992, Iyer 1991] </ref>. On identifying a redundant fault the maximum redundant region for this fault is determined by forward propagating the stuck value of the redundant fault. <p> In essence, most of these techniques require large amounts of wasted computations. An initial contribution of this research was a novel algorithm for redundancy identification and removal in combinational circuits that uses only a single pass of test generation and fault simulation <ref> [Iyer 1991, Abramovici and Iyer 1992] </ref>. The important contribution was the development of a novel dynamic RID technique that identifies newly created redundancies that appear as a result of a redundancy removal. <p> during ATG, but identify a large number of redundant or untestable faults. 37 CHAPTER IV FAULT-INDEPENDENT REDUNDANCY IDENTIFICATION IN COMBINATIONAL CIRCUITS An initial contribution of this research was a novel algorithm for RID and removal in combinational circuits that uses only a single pass of test generation and fault simulation <ref> [Iyer 1991, Abramovici and Iyer 1992] </ref>. The important contribution was the development of a novel dynamic RID technique that identifies newly created redundancies that appear as a result of a redundancy removal. <p> A redundancy removal procedure using FIRES will have to reanalyze the stems that were already analyzed before the current redundancy removal. Alternatively, this procedure may be used in conjunction with the fault-independent procedure to identify newly created redundancies after a redundancy removal, that was proposed in <ref> [Abramovici and Iyer 1992, Iyer 1991] </ref>. Redundancy removal using FIRES is currently under investigation. The entire concept of processing possible conflicts and illegal states of the the fault-free circuit and finding faults that require them as necessary conditions for detection has important applications in delay testing.
Reference: [Abramovici et al. 1986] <author> M. Abramovici, J. J. Kulikowski, P. R. Menon, and D. T. Miller, </author> <title> "SMART and FAST: Test Generation for VLSI scan-design circuits." </title> <booktitle> IEEE Design and Test of Computers, </booktitle> <pages> pp. 43-54, </pages> <month> August </month> <year> 1986. </year>
Reference-contexts: Their method relies on exploring a reduced ATG search space, by learning previously 26 encountered equivalent search states. Other existing RID techniques are based on controllability/observability analysis [Ratiu et al. 1982] or on structural transformations of the circuit <ref> [Abramovici et al. 1986] </ref>. As stated earlier, redundancy removal has the additional complication that new redundancies may appear as a result of a redundancy removal. It is imperative that any algorithm for redundancy removal identify these redundancies as well. <p> Faults internal to FF models are however ignored. For all the sequential benchmark circuits, a clock PI and both its faults are also included. 50 To compare the savings in computations for FIRE with respect to a fault-oriented approach for RID, the LTG test generation/ fault simulation package <ref> [Abramovici et al. 1986] </ref> was used Faults proved redundant by FIRE were passed as targets to LTG with a backtrack limit of 100. LTG also has the advantage of dynamic RID techniques [Abramovici et al. 1992].
Reference: [Abramovici et al. 1991] <author> M. Abramovici, J. J. Kulikowski, and R. K. Roy, </author> <title> "The Best Flip-Flops to Scan," </title> <booktitle> Proc. Intn'l Test Conf., </booktitle> <pages> pp. 166-173, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: The faults in S X become untestable when X cannot assume value a (or when X is uncontrollable for value a). These faults are found using the uncontrollability and unobservability analysis introduced in <ref> [Abramovici et al. 1991] </ref>. Controllability is the ability to establish a specific signal value at each node in a circuit by setting values on the circuit's inputs.
Reference: [Abramovici et al. 1992] <author> M. Abramovici, D. T. Miller, and R. K. Roy, </author> <title> "Dynamic Redundancy Identification in Automatic Test Generation." </title> <journal> IEEE Trans. on CAD, </journal> <pages> pp. 404-407, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: Also, an explicit analysis of dominators is required to claim that a fault is undetectable. A detailed example is shown in Chapter 4 to illustrate their method. A dynamic RID technique was proposed in <ref> [Abramovici et al. 1992] </ref> that relies on test covering relations among faults and allows the identification of additional redundant faults after the test generator fails to generate a test for a target fault. Their techniques extend beyond fanout-free regions, which are regions without fanouts. <p> LTG also has the advantage of dynamic RID techniques <ref> [Abramovici et al. 1992] </ref>. It is true that in a free run, LTG would, in general, identify more redundancies than FIRE. However, the purpose of these experiments is to testify how much time LTG would save by not targeting the faults proved redundant by FIRE. Table 6.
Reference: [Abramovici and Parikh 1992] <author> M. Abramovici and P. S. Parikh, </author> <title> "Warning: 100% Fault Coverage May Be Misleading!!." </title> <booktitle> Proc. Intn'l. Test Conf., </booktitle> <pages> pp. 662-668, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: In sequential circuits, untestability and redundancy are not equivalent concepts. One class of sequentially untestable but irredundant faults consists of faults that prevent initialization (FPIs) [Abramovici and Breuer 1979]. A method to identify untestable FPIs was introduced in 20 <ref> [Abramovici and Parikh 1992] </ref>. We now present an example of an untestable FPI that is irredundant. Z b d f Q1 D2Q2 _ __ X h Example 4: Consider the circuit in Figure 6 and the fault c sa-0.
Reference: [Agrawal and Chakradhar 1993] <author> V. D. Agrawal and S. T. Chakradhar, </author> <title> "Combinational ATPG Theorems for Identifying Untestable Faults in Sequential Circuits." </title> <booktitle> Proc. European Test Conf., </booktitle> <pages> pp. 249-253, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: The above example illustrates that this is not necessarily true with respect to redundancy. 36 c2 d D Q a c1 f1 D Q CLK 3.2.2.6 The Combinational ATPG Theorems of Agrawal and Chakradhar <ref> [Agrawal and Chakradhar 1993] </ref>. Agrawal and Chakradhar [Agrawal and Chakradhar 1993] proposed two theorems to identify sequentially untestable faults using less complex combinational techniques. Their method uses combinational ATG to target certain faults in an iterative array of finite length derived from a sequential circuit. <p> The above example illustrates that this is not necessarily true with respect to redundancy. 36 c2 d D Q a c1 f1 D Q CLK 3.2.2.6 The Combinational ATPG Theorems of Agrawal and Chakradhar <ref> [Agrawal and Chakradhar 1993] </ref>. Agrawal and Chakradhar [Agrawal and Chakradhar 1993] proposed two theorems to identify sequentially untestable faults using less complex combinational techniques. Their method uses combinational ATG to target certain faults in an iterative array of finite length derived from a sequential circuit. <p> An intermediate result of this research was an algorithm to Find sequentially UNTESTable faults (FUNTEST) without search [Iyer and Abramovici 1994c], that extended the concept of FIRE to sequential circuits using the single-fault theorem in <ref> [Agrawal and Chakradhar 1993] </ref>. However, the use of the single-fault theorem precludes FUNTEST from identifying sequential redundancy. Even though FIRES uses an implication mechanism similar to FUNTEST, it is significantly different. FIRES identifies c-cycle redundancies, whereas FUNTEST can identify only sequentially 55 untestable faults. <p> FIRES identifies c-cycle redundancies, whereas FUNTEST can identify only sequentially 55 untestable faults. The theoretical basis for FIRES is different from that of FUNTEST; FIRES is based on conflict analysis whereas FUNTEST is based on the single-fault theorem of <ref> [Agrawal and Chakradhar 1993] </ref>. It will also be shown that FIRES can identify faults that are beyond the scope of the combinational ATPG theorems in [Agrawal and Chakradhar 1993]. 5.1 c-Cycle Redundancy In this section, the concept of a c-cycle redundancy is introduced. c-cycle redundancy is a generalization of the conventional <p> theoretical basis for FIRES is different from that of FUNTEST; FIRES is based on conflict analysis whereas FUNTEST is based on the single-fault theorem of <ref> [Agrawal and Chakradhar 1993] </ref>. It will also be shown that FIRES can identify faults that are beyond the scope of the combinational ATPG theorems in [Agrawal and Chakradhar 1993]. 5.1 c-Cycle Redundancy In this section, the concept of a c-cycle redundancy is introduced. c-cycle redundancy is a generalization of the conventional notion of sequential redundancy. Consider any arbitrary input sequence I. <p> It is emphasized that the c-cycle redundant faults found by FIRES are not restricted to any particular classes of faults as in [Cheng 1991b, Cheng 1993], or to just faults that cannot be detected in the time frame that they are first activated as was addressed by the single-fault theorem <ref> [Agrawal and Chakradhar 1993] </ref>, or to just faults that cannot be activated and propagated in a finite number of time frames as was addressed by the multi-fault theorem [Agrawal and Chakradhar 1993]. <p> just faults that cannot be detected in the time frame that they are first activated as was addressed by the single-fault theorem <ref> [Agrawal and Chakradhar 1993] </ref>, or to just faults that cannot be activated and propagated in a finite number of time frames as was addressed by the multi-fault theorem [Agrawal and Chakradhar 1993]. The following example shows how FIRES can find a fault that is beyond the scope of the combinational ATPG theorems [Agrawal and Chakradhar 1993]. Example 19: Consider the circuit in Figure 27. <p> Chakradhar 1993], or to just faults that cannot be activated and propagated in a finite number of time frames as was addressed by the multi-fault theorem <ref> [Agrawal and Chakradhar 1993] </ref>. The following example shows how FIRES can find a fault that is beyond the scope of the combinational ATPG theorems [Agrawal and Chakradhar 1993]. Example 19: Consider the circuit in Figure 27. Independent of the number of time frames used, based on the combinational ATPG theorems [Agrawal and Chakradhar 1993] we will never find the faults e sa-1, a sa-0, and b sa-0 as untestable, because these faults can always be <p> <ref> [Agrawal and Chakradhar 1993] </ref>. The following example shows how FIRES can find a fault that is beyond the scope of the combinational ATPG theorems [Agrawal and Chakradhar 1993]. Example 19: Consider the circuit in Figure 27. Independent of the number of time frames used, based on the combinational ATPG theorems [Agrawal and Chakradhar 1993] we will never find the faults e sa-1, a sa-0, and b sa-0 as untestable, because these faults can always be detected at a state variable in the rightmost time frame of a finite time frame model. <p> The results of [Cheng 1991a, Cheng 1991b, Cheng 1993, Cho et al. 1993c, Pomeranz and Reddy 1994b] are for redundancy removal, those of [Cho et al. 1993c] are not relevant for the original benchmark circuits without a global reset, those 66 of <ref> [Agrawal and Chakradhar 1993] </ref> are only for untestability, those of [Moondanos and Abraham 1992] deal with a restricted definition of redundancy, those of [Cheng 1991a, Cheng 1991b, Cheng 1993, Entrena and Cheng 1993] are based on incorrect theoretical results, and those of [Pomeranz and Reddy 1994a, Pomeranz and Reddy 1994b] do <p> In general, all these algorithms identify different sets of faults. Unlike ATG, FUNI is fault-independent and does not rely on exhaustive search; rather, it uses an implication procedure similar to FIRES. (Other work to identify sequentially untestable faults without using sequential ATG <ref> [Agrawal and Chakradhar 1993] </ref> is based on combinational ATG which still requires exhaustive search.) 6.1 Review of the FILL Algorithm [Long et al. 1995] FILL computes illegal states in a sequential circuit without assuming a reset state and without having to compute an initialization sequence. <p> 1.8 51 20911.3 S9234 93 94.7 165 14.1 257 108.8 524 2793.6 S15850 629 96.4 234 17.6 816 114.0 448 4197.5 S38417 303 334.9 99 38.5 381 373.4 391 6995.5 78 Table 17 also presents a comparison with the untestable faults that were identified by using the single-fault theorem (SFT) <ref> [Agrawal and Chakradhar 1993] </ref> and the TRAN combinational test generator [Chakradhar et al. 1993]. These are unpublished results and were recently obtained [Chakradhar 1994]. Since the results of [SFT + TRAN] include all the combinational redundancies in these circuits, we compare it with [FUNI + FIRE]. <p> However, even though FUNI finds untestable faults without search, the following example shows that it can find a fault that can never be found by [SFT + TRAN] even with exhaustive search. Example 23: The combinational ATPG theorems <ref> [Agrawal and Chakradhar 1993] </ref> will never find the fault a sa-0 in the circuit of Figure 32 as untestable. FUNI identifies this fault as untestable; its detection requires the illegal state - f = 1 , h = 0 - (for fault propagation).
Reference: [Breuer 1978] <author> M. A. Breuer, </author> <title> "New Concepts in Automated Testing of Digital Circuits," </title> <booktitle> Proc. EEC Symp. on CAD of Digital Electronic Circuits and Systems, </booktitle> <pages> pp. 69-92, </pages> <publisher> North-Holland Publishing Co., </publisher> <month> Nov. </month> <year> 1978. </year>
Reference-contexts: Simulation is then performed till a stable condition is reached; i.e. the inputs and outputs have the same values for each FF. Then FFs with U value are identified as uninitializable. This is similar to infinity values 31 in controllability cost computations <ref> [Rutman 1972, Breuer 1978] </ref>. The simulation also identifies uncontrollable lines. The following example shows that the method of Liang et al. may identify even a testable fault as redundant. Example 10: Consider the circuit in Figure 12.
Reference: [Brglez et al. 1989] <author> F. Brglez, D. Bryan, and K. Kozminski, </author> <title> "Combinational profiles of sequential benchmark circuits", </title> <booktitle> Proc. 1989 Intn'l. Symposium on Circuits and Systems, </booktitle> <pages> pp. 1929-1934, </pages> <month> May </month> <year> 1989. </year>
Reference-contexts: a fault has to be shown as untestable at each of its dominators for it to be redundant. 4.4 Experimental Results FIRE was implemented in C and was run on the ISCAS85 combinational benchmark circuits [Brglez and Fujiwara 1985] and on the full-scan versions of the ISCAS89 sequential benchmark circuits <ref> [Brglez et al. 1989] </ref>. The production version of FIRE uses special models for FFs in a circuit. Table 5 summarizes the characteristics of the benchmark circuits after expansion of the FF models. <p> Note that redundant faults found in the new circuit are also redundant in the original circuit. FIRES was used to identify redundancies in the ISCAS89 sequential benchmark circuits <ref> [Brglez et al. 1989] </ref>. FIRES performs the validation step outlined in Section 5.2.2 as an option. Note that faults found by FIRES without the validation step are untestable, and those found with the validation step are c-cycle redundant. In general, without validation, FIRES runs faster and finds more faults. <p> FUNI was used to identify untestable faults in the ISCAS89 sequential benchmark circuits <ref> [Brglez et al. 1989] </ref>. Faults identified as untestable by FUNI were passed as the only targets for a conventional state-of-the-art 76 Table 16.
Reference: [Brglez and Fujiwara 1985] <author> F. Brglez and H. Fujiwara, </author> <title> "Neutral netlist of ten combinational benchmark circuits and a target translator in FORTRAN," </title> <booktitle> Proc. IEEE Intn'l. Symposium on Circuits and Systems, </booktitle> <month> June </month> <year> 1985. </year>
Reference-contexts: is because every reconvergent gate of every stem is analyzed explicitly for cv paths and a fault has to be shown as untestable at each of its dominators for it to be redundant. 4.4 Experimental Results FIRE was implemented in C and was run on the ISCAS85 combinational benchmark circuits <ref> [Brglez and Fujiwara 1985] </ref> and on the full-scan versions of the ISCAS89 sequential benchmark circuits [Brglez et al. 1989]. The production version of FIRE uses special models for FFs in a circuit. Table 5 summarizes the characteristics of the benchmark circuits after expansion of the FF models.
Reference: [Bryan et al. 1989] <author> D. Bryan, F. Brglez, and R. Lisanke, </author> <title> "Redundancy Identification and Removal." </title> <booktitle> Proc. MCNC Workshop on Logic Synthesis, </booktitle> <year> 1989. </year>
Reference-contexts: It is imperative that any algorithm for redundancy removal identify these redundancies as well. Various techniques have been proposed in the literature to solve the combinational redundancy removal problem. The method proposed in <ref> [Bryan et al. 1989] </ref> is a "brute-force" method and works as follows. After a test generator completes its task, one of the faults identified as redundant is selected and the circuit is simplified.
Reference: [Bryant 1986] <author> R. E. Bryant, </author> <title> "Graph-based Algorithms for Boolean Function Manipulation," </title> <journal> IEEE Trans. on Computers, </journal> <volume> vol. C-35, no. 8, </volume> <pages> pp. 677-691, </pages> <month> August </month> <year> 1986. </year> <month> 106 </month>
Reference-contexts: Clearly, determining illegal states by an efficient technique as a preprocessing step to ATG would significantly reduce its computational complexity. In this chapter, we first review a recently proposed algorithm to Find ILLegal states (FILL) [Long et al. 1995] using implicit state enumeration based on binary decision diagrams (BDDs) <ref> [Bryant 1986] </ref>. Other techniques [Coudert et al. 1989, Coudert and Madre 1991, Lin et al. 1990, Touati et al. 1990, Cho et al. 1993b, Cho et al. 1993c] require the unrealistic assumption of a (fault-free) reset state.
Reference: [Chakraborty et al. 1991] <author> T. J. Chakraborty, S. Davidson, and B. Bencivenga, "GENTEST: </author> <title> The Architecture of Sequential Circuit Test Generator," </title> <booktitle> Proc. Custom Integrated Circuits Conf., </booktitle> <month> May </month> <year> 1991. </year>
Reference-contexts: However, the test generator cannot identify these faults as redundant. We now show that state-of-the-art sequential test generators can have difficulty even in proving that the faults found by FIRES are untestable. We used two sequential test generators, GENTEST <ref> [Chakraborty et al. 1991] </ref> and HITEC [Niermann and Patel 1991]. In this experiment, the faults found by FIRES (without validation) were passed as the only targets to the test generators. <p> 9 6 1660.0 2767 S5378 15 398 30.1 8.8 38.9 16 382 1412.9 36 S13207 10 617 80.9 52.2 133.1 604 13 1297.8 10 S35932 0 0 96.4 0.0 96.4 - - - - S38584 5 671 219.7 45.9 265.6 453 218 2011.1 8 _ ________________________________________________________________________ sequential test generator (GENTEST <ref> [Chakraborty et al. 1991] </ref>). In Table 16, #Fr. is the number of time frames which FUNI processed, #Unt. is the number of identified untestable faults, and #Abo. is the number of targets aborted by GENTEST. CPU times are in seconds for a SUN sparc10. <p> The union of the faults identified by FIRES and FUNI were passed as the only targets to a conventional state-of-the-art sequential test generator (GENTEST <ref> [Chakraborty et al. 1991] </ref>). Table 18. Comparison of [FIRES+FUNI] With GENTEST _ ___________________________________________________________________________________________________ _ ___________________________________________________________________________________________________ Circuit FIRE FIRES FUNI [FIRES+FUNI] GENTEST Speed-up _ ________________________________________________________________________________ Name # CPU # CPU # CPU # CPU # # CPU ratio Red. secs. Unt. secs. Unt. secs. Unt. secs. Unt. <p> Thus, [FIRES+FUNI] can be used as a preprocessing step to any state-of-the-art sequential test generator to obtain significant savings in computation time and to increase the detectable fault coverage. It is currently being integrated as a preprocessor to GENTEST <ref> [Chakraborty et al. 1991] </ref> 8.1 Future Work Though FIRES provides an efficient solution to identify c-cycle redundancies, a few more problems remain unsolved with respect to redundancy removal. Every redundant fault identified by FIRES has a c associated with it.
Reference: [Chakradhar 1994] <author> S. T. Chakradhar, </author> <type> Personal Communication, </type> <month> October </month> <year> 1994. </year>
Reference-contexts: These are unpublished results and were recently obtained <ref> [Chakradhar 1994] </ref>. Since the results of [SFT + TRAN] include all the combinational redundancies in these circuits, we compare it with [FUNI + FIRE]. We show the number of redundant faults identified by FIRE alone.
Reference: [Chakradhar et al. 1993] <author> S. T. Chakradhar, V. D. Agrawal and S. G. Rothweiler, </author> <title> "A Transitive Closure Algorithm for Test Generation." </title> <journal> IEEE Trans. on CAD, </journal> <volume> vol. 12, no. 7, </volume> <pages> pp. 1015-1028, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: FIRE performed much better than LTG for all the circuits. A speed-up ratio of up to 37 was achieved for these circuits. Table 9 shows the percentage of redundancies identified by FIRE in the benchmark circuits. Since TRAN <ref> [Chakradhar et al. 1993] </ref> is a state-of-the-art combinational test generator that reports all the single-fault redundant faults in the benchmark circuits, it was used for comparisons. The TRAN CPU times are also for a SUN sparc2 and include times for random test generation, transitive closure algorithm and fault simulation. <p> 524 2793.6 S15850 629 96.4 234 17.6 816 114.0 448 4197.5 S38417 303 334.9 99 38.5 381 373.4 391 6995.5 78 Table 17 also presents a comparison with the untestable faults that were identified by using the single-fault theorem (SFT) [Agrawal and Chakradhar 1993] and the TRAN combinational test generator <ref> [Chakradhar et al. 1993] </ref>. These are unpublished results and were recently obtained [Chakradhar 1994]. Since the results of [SFT + TRAN] include all the combinational redundancies in these circuits, we compare it with [FUNI + FIRE]. We show the number of redundant faults identified by FIRE alone. <p> This is because there could be redundant faults that cannot be detected due to conflicts on multiple stems. Moreover, the implications performed are not guaranteed to be complete and pessimistic heuristics are used to decide when multiple-path sensitization is precluded. The use of improved implication procedures <ref> [Chakradhar et al. 1993, Kunz and Pradhan 90 1992] </ref> is likely to increase the number of redundancies that can be identified using FIRES at the cost of additional CPU time. Logic synthesis procedures for redundancy removal are very time-consuming if they rely on ATG for RID.
Reference: [Chakradhar et al. 1995] <author> S. T. Chakradhar, S. G. Rothweiler, and V. D. Agrawal, </author> <title> "Redundancy Removal and Test Generation for Circuits with Non-Boolean Primitives." </title> <booktitle> 13th. IEEE VLSI Test Symp., </booktitle> <pages> pp. 12-19, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: This represents removal of only a subset of redundancies. The remaining redundancies are removed by using repeated runs of test generation and fault simulation. 27 More recently, Chakradhar et al. <ref> [Chakradhar et al. 1995] </ref> have proposed a redundancy removal procedure for combinational circuits with non-boolean primitives. Their method separates the function of a non-boolean primitive into boolean and non-boolean components. Only the boolean component is used by an energy-minimization-based test generation algorithm.
Reference: [Cheng 1991a] <author> K. T. Cheng, </author> <title> "On Removing Redundancy in Sequential Circuits." </title> <booktitle> Proc. 28th. ACM/IEEE Design Automation Conf., </booktitle> <pages> pp. 164-169, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: exists for the faulty circuit. (c) State Assignment Q1 Q2 01 C 00 A B A x/0 1/1 1/0 (a) Fault-free STG A (b) Faulty STG 0/1 x/0 B State Cheng conjectured that partial detection may be possible when the fault-free and the faulty circuits are initialized by different sequences <ref> [Cheng 1991a, Cheng 1993] </ref>. The following example is the first known example to confirm that this conjecture is indeed true and shows that the untestable faults which exhibit this behavior form a new class of untestable but irredundant faults. These are the partially testable faults that modify initialization (FMIs). <p> The entire sequential region that is bound by the highest level lines to which the redundant stuck-value propagated can be removed from the circuit. Unlike the combinational case, this region could include FFs. A detailed description of the sequential redundancy removal procedure can be found in <ref> [Cheng 1991a, Cheng 1993] </ref>. 25 CHAPTER III REVIEW OF PREVIOUS WORK In this chapter, the existing methods for identifying untestable and redundant faults in logic circuits are reviewed. In sequential circuits, redundant faults form a subset of the sequentially untestable faults. However, combinationally redundant faults are also sequentially redundant. <p> This is also a fault that will be incorrectly reported as untestable by any test generator using a single unknown logic value. c 2 b a g c CLK 3.2.2 Limitations of Other Solutions to Identify Sequential Redundancy and Untestability 3.2.2.1 The Method of Cheng <ref> [Cheng 1991a, Cheng 1993] </ref>. Cheng addressed the problem of identifying and removing sequential redundancies without assuming a global reset mechanism. He proposed a procedure to identify a subset of 32 sequential redundancies (called feedback-free sequential redundancies). <p> Reddy 1994b] are for redundancy removal, those of [Cho et al. 1993c] are not relevant for the original benchmark circuits without a global reset, those 66 of [Agrawal and Chakradhar 1993] are only for untestability, those of [Moondanos and Abraham 1992] deal with a restricted definition of redundancy, those of <ref> [Cheng 1991a, Cheng 1991b, Cheng 1993, Entrena and Cheng 1993] </ref> are based on incorrect theoretical results, and those of [Pomeranz and Reddy 1994a, Pomeranz and Reddy 1994b] do not deal with benchmark circuits. Table 12.
Reference: [Cheng 1991b] <author> K. T. Cheng, </author> <title> "An ATPG-Based Approach to Sequential Logic Optimization." </title> <booktitle> Proc. Intn'l. Conf. on Computer Aided Design, </booktitle> <pages> pp. 372-375, </pages> <month> November </month> <year> 1991. </year>
Reference-contexts: In the following sections these solutions are analyzed and it is shown that some of these solutions are based on incorrect theoretical results. 28 3.2.1 Incorrect Solutions to Identify Sequential Redundancy 3.2.1.1 The Method of Cheng <ref> [Cheng 1991b, Cheng 1993] </ref>. Cheng addressed the problem of identifying and removing sequential redundancies without assuming a global reset mechanism. He proposed methods to identify special classes of untestable faults that are guaranteed to be redundant. <p> He proposed methods to identify special classes of untestable faults that are guaranteed to be redundant. He showed that in a balanced pipeline circuit, every untestable fault is redundant, and that in a general sequential circuit, unactivatable and unpropagatable faults are redundant <ref> [Cheng 1991b, Cheng 1993] </ref>. (A balanced pipeline circuit is a feedback-free circuit such that, for any signal s in the circuit, every path from any primary input to s has the same number of FFs.) He devised special procedures to identify these subsets of redundant faults. <p> Hence this fault is an unactivatable fault and c always assumes the value 0 after initialization. (This is often referred to as a constant function.) However, as shown in Example 4 and Figure 7 (Chapter 2), the fault is partially testable and irredundant. Cheng's method <ref> [Cheng 1991b, Cheng 1993] </ref> will classify this fault as redundant and remove its region from the circuit. But this changes the behavior of the circuit, since the new circuit is uninitializable. The next example shows that an untestable fault in a balanced pipeline circuit is not necessarily redundant. <p> Proof: See Appendix A. It is emphasized that the c-cycle redundant faults found by FIRES are not restricted to any particular classes of faults as in <ref> [Cheng 1991b, Cheng 1993] </ref>, or to just faults that cannot be detected in the time frame that they are first activated as was addressed by the single-fault theorem [Agrawal and Chakradhar 1993], or to just faults that cannot be activated and propagated in a finite number of time frames as was <p> Reddy 1994b] are for redundancy removal, those of [Cho et al. 1993c] are not relevant for the original benchmark circuits without a global reset, those 66 of [Agrawal and Chakradhar 1993] are only for untestability, those of [Moondanos and Abraham 1992] deal with a restricted definition of redundancy, those of <ref> [Cheng 1991a, Cheng 1991b, Cheng 1993, Entrena and Cheng 1993] </ref> are based on incorrect theoretical results, and those of [Pomeranz and Reddy 1994a, Pomeranz and Reddy 1994b] do not deal with benchmark circuits. Table 12.
Reference: [Cheng 1993] <author> K. T. Cheng, </author> <title> "Redundancy Removal for Sequential Circuits Without Reset States," </title> <journal> IEEE Trans. on CAD, </journal> <volume> vol. 12, no. 1, </volume> <pages> pp. 13-24, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: exists for the faulty circuit. (c) State Assignment Q1 Q2 01 C 00 A B A x/0 1/1 1/0 (a) Fault-free STG A (b) Faulty STG 0/1 x/0 B State Cheng conjectured that partial detection may be possible when the fault-free and the faulty circuits are initialized by different sequences <ref> [Cheng 1991a, Cheng 1993] </ref>. The following example is the first known example to confirm that this conjecture is indeed true and shows that the untestable faults which exhibit this behavior form a new class of untestable but irredundant faults. These are the partially testable faults that modify initialization (FMIs). <p> The entire sequential region that is bound by the highest level lines to which the redundant stuck-value propagated can be removed from the circuit. Unlike the combinational case, this region could include FFs. A detailed description of the sequential redundancy removal procedure can be found in <ref> [Cheng 1991a, Cheng 1993] </ref>. 25 CHAPTER III REVIEW OF PREVIOUS WORK In this chapter, the existing methods for identifying untestable and redundant faults in logic circuits are reviewed. In sequential circuits, redundant faults form a subset of the sequentially untestable faults. However, combinationally redundant faults are also sequentially redundant. <p> In the following sections these solutions are analyzed and it is shown that some of these solutions are based on incorrect theoretical results. 28 3.2.1 Incorrect Solutions to Identify Sequential Redundancy 3.2.1.1 The Method of Cheng <ref> [Cheng 1991b, Cheng 1993] </ref>. Cheng addressed the problem of identifying and removing sequential redundancies without assuming a global reset mechanism. He proposed methods to identify special classes of untestable faults that are guaranteed to be redundant. <p> He proposed methods to identify special classes of untestable faults that are guaranteed to be redundant. He showed that in a balanced pipeline circuit, every untestable fault is redundant, and that in a general sequential circuit, unactivatable and unpropagatable faults are redundant <ref> [Cheng 1991b, Cheng 1993] </ref>. (A balanced pipeline circuit is a feedback-free circuit such that, for any signal s in the circuit, every path from any primary input to s has the same number of FFs.) He devised special procedures to identify these subsets of redundant faults. <p> Hence this fault is an unactivatable fault and c always assumes the value 0 after initialization. (This is often referred to as a constant function.) However, as shown in Example 4 and Figure 7 (Chapter 2), the fault is partially testable and irredundant. Cheng's method <ref> [Cheng 1991b, Cheng 1993] </ref> will classify this fault as redundant and remove its region from the circuit. But this changes the behavior of the circuit, since the new circuit is uninitializable. The next example shows that an untestable fault in a balanced pipeline circuit is not necessarily redundant. <p> This is also a fault that will be incorrectly reported as untestable by any test generator using a single unknown logic value. c 2 b a g c CLK 3.2.2 Limitations of Other Solutions to Identify Sequential Redundancy and Untestability 3.2.2.1 The Method of Cheng <ref> [Cheng 1991a, Cheng 1993] </ref>. Cheng addressed the problem of identifying and removing sequential redundancies without assuming a global reset mechanism. He proposed a procedure to identify a subset of 32 sequential redundancies (called feedback-free sequential redundancies). <p> Proof: See Appendix A. It is emphasized that the c-cycle redundant faults found by FIRES are not restricted to any particular classes of faults as in <ref> [Cheng 1991b, Cheng 1993] </ref>, or to just faults that cannot be detected in the time frame that they are first activated as was addressed by the single-fault theorem [Agrawal and Chakradhar 1993], or to just faults that cannot be activated and propagated in a finite number of time frames as was <p> Reddy 1994b] are for redundancy removal, those of [Cho et al. 1993c] are not relevant for the original benchmark circuits without a global reset, those 66 of [Agrawal and Chakradhar 1993] are only for untestability, those of [Moondanos and Abraham 1992] deal with a restricted definition of redundancy, those of <ref> [Cheng 1991a, Cheng 1991b, Cheng 1993, Entrena and Cheng 1993] </ref> are based on incorrect theoretical results, and those of [Pomeranz and Reddy 1994a, Pomeranz and Reddy 1994b] do not deal with benchmark circuits. Table 12.
Reference: [Cho et al. 1993b] <author> H. Cho, G. D. Hachtel, E. Macii, B. Plessier, and F. Somenzi, </author> <title> "Algorithms for Approximate FSM Traversal," </title> <booktitle> Proc. 30th. ACM/IEEE Design Automation Conf., </booktitle> <pages> pp. 25-30, </pages> <month> June </month> <year> 1993. </year>
Reference: [Cho et al. 1993c] <author> H. Cho, G. D. Hachtel, and F. Somenzi, </author> <title> "Redundancy Identification/Removal and Test Generation for Sequential Circuits Using Implicit State Enumeration." </title> <journal> IEEE Trans. on CAD, </journal> <volume> vol. 12, no. 7, </volume> <pages> pp. 935-945, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: However, the procedure used to verify whether an untestable faults is indeed redundant was highly complex and not applicable to large circuits. 3.2.2.2 The Assumption of a Fault-Free Global Reset Mechanism. Cho et al. proposed a sequential RID technique based on implicit state enumeration <ref> [Cho et al. 1993c] </ref>. The method relies on the simplifying assumption that the circuit has a fault-free global reset mechanism. The algorithm uses an implicit representation of the STG and determines states that are not reachable from the reset state. <p> This information is used by an ATG algorithm to identify sequential redundancies. The approach uses binary decision diagrams (BDDs) as a platform to deal with the reachability information of sequential circuits. Although this procedure is attractive for small circuits, it cannot handle large circuits. The methods of <ref> [Cho et al. 1993c, Devadas et al. 1990] </ref> assume a fault-free global reset mechanism. Using this assumption, all untestable faults are considered redundant. We now show that this assumption is incomplete. Example 11: Consider again the circuit and fault c sa-0 in Figure 6 (Chapter 2). <p> Hence the fault is still irredundant under Definition 12. The results of <ref> [Cho et al. 1993c] </ref> with respect to RID will be correct only if it is also assumed that the operation of the circuit will always be started by activating the global reset. Adding a global reset mechanism to a circuit improves its controllability. <p> Example 11 also illustrates that this is not necessarily true. Thus, adding a global reset mechanism can create a redundancy. More importantly, the method of <ref> [Cho et al. 1993c] </ref> or any other method that identifies sequential redundancies by assuming a fault-free global reset mechanism (which is always used to start the operation of the circuit), cannot be used to identify redundancies in a circuit without a fault-free global reset mechanism. 3.2.2.3 The Methods of Pomeranz and <p> Hence columns 13 and 14 have "-". Unfortunately, these results cannot be compared with any of the previously published ones. The results of [Cheng 1991a, Cheng 1991b, Cheng 1993, Cho et al. 1993c, Pomeranz and Reddy 1994b] are for redundancy removal, those of <ref> [Cho et al. 1993c] </ref> are not relevant for the original benchmark circuits without a global reset, those 66 of [Agrawal and Chakradhar 1993] are only for untestability, those of [Moondanos and Abraham 1992] deal with a restricted definition of redundancy, those of [Cheng 1991a, Cheng 1991b, Cheng 1993, Entrena and Cheng
Reference: [Cho et al. 1993a] <author> H. Cho, S. W. Jeong, F. Somenzi, and C. </author> <title> Pixley "Synchronizing Sequences and Symbolic Traversal Techniques in Test Generation," </title> <journal> Journal Of Electronic Testing (JETTA): Theory and Applications, </journal> <volume> vol. 4, </volume> <pages> pp. 19-31, </pages> <month> February </month> <year> 1993 </year>
Reference-contexts: These techniques compute a set of legal states using a forward search; but if this step is not completed because of excessive memory or run-time requirements, then no illegal states are found. The sequential test generator described in <ref> [Cho et al. 1993a] </ref> does not assume a reset state but computes an initialization sequence and performs a forward search from the computed set of reset states. However, it has limited application because it cannot handle large circuits.
Reference: [Coudert et al. 1989] <author> O. Coudert, C. Berthet, and J. C. Madre, </author> <title> "Verification of Synchronous Sequential Machines Based on Symbolic Execution," </title> <booktitle> Proc. of the 1989 Intn'l Workshop on Automatic Verification Methods for Finite State Systems, Grenoble, France, vol. 407 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1989. </year>
Reference: [Coudert and Madre 1989] <author> O. Coudert and J. C. Madre, </author> <title> "Symbolic Computation of the Valid States of a Sequential Machine: Algorithms and Discussion," </title> <booktitle> Proc. of the 1991 Intn'l Workshop on Formal Methods in VLSI Design, </booktitle> <month> January </month> <year> 1991. </year>
Reference: [Davidson 1994] <author> S. Davidson, </author> <title> "Is I DDQ Yield Loss Inevitable ?" Proc. </title> <booktitle> Intn'l. Test Conf., </booktitle> <pages> pp. 572-579, </pages> <month> Oct. </month> <year> 1994. </year>
Reference-contexts: A redundant circuit can always be simplified by removing at least one gate or gate input. Moreover, redundancy identification (RID) is important if the desired fault coverage is to be achieved. Another detrimental effect of redundancy is that it may unnecessarily reduce the yield of the IC manufacturing process <ref> [Davidson 1994] </ref>. For example, many sequentially redundant faults become detectable with full-scan testing, and many sequentially and combinationally redundant faults become detectable with I DDQ testing.
Reference: [Devadas et al. 1990] <author> S. Devadas, H. K. T. Ma, and A. R. </author> <title> Newton, "Redundancies and Don't Cares in Sequential Logic Synthesis." </title> <journal> J. Electronic Testing: Theory and Application (JETTA), </journal> <volume> vol. </volume> <pages> 1-1, pp. 15-30, </pages> <month> February </month> <year> 1990. </year> <month> 107 </month>
Reference-contexts: This information is used by an ATG algorithm to identify sequential redundancies. The approach uses binary decision diagrams (BDDs) as a platform to deal with the reachability information of sequential circuits. Although this procedure is attractive for small circuits, it cannot handle large circuits. The methods of <ref> [Cho et al. 1993c, Devadas et al. 1990] </ref> assume a fault-free global reset mechanism. Using this assumption, all untestable faults are considered redundant. We now show that this assumption is incomplete. Example 11: Consider again the circuit and fault c sa-0 in Figure 6 (Chapter 2).
Reference: [Dey and Chakradhar 1994] <author> S. Dey and S. T. Chakradhar, </author> <title> "Retiming Sequential Circuits to Enhance Testability," </title> <booktitle> 12th. IEEE VLSI Test Symp., </booktitle> <pages> pp. 28-33, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: Circuit retiming [Leiserson and Saxe 1991] consists of changing the position of FFs in the circuit. Dey and Chakradhar observed that retiming can be used to convert sequential reconvergences to combinational reconvergences, and that in the process sequentially redundant faults become combinationally redundant <ref> [Dey and Chakradhar 1994] </ref>. In the following example, we show that retiming can also transform some irredundant sequentially untestable faults into combinationally redundant faults; in other words, retiming synchronous circuitry can create redundancies. Example 13: Consider again the circuit in Figure 5 (Chapter 2) and the fault c 2 sa-1.
Reference: [El-Maleh et al. 1994] <author> A. El-Maleh, T. E. Marchok, J. Rajski, and W. Maly, </author> <title> ``Behavior and Testability Preservation Under the Retiming Transformation,'' </title> <institution> McGill University Technical Report #94-R3, </institution> <month> December </month> <year> 1994. </year>
Reference-contexts: The fault c 2 sa-1 then becomes combinationally redundant in the retimed circuit. c f CLK sa-1 a D Q b e g h Recently, it has been shown that retiming preserves testability <ref> [Marchok et al. 1994, El-Maleh et al. 1994] </ref>. Thus an untestable fault in a retimed circuit will also be untestable in the original circuit.
Reference: [Entrena and Cheng 1993] <author> L. Entrena and K. T. Cheng, </author> <title> "Sequential Logic Optimization By Redundancy Addition and Removal," </title> <booktitle> Proc. Intn'l. Conf. on CAD, </booktitle> <pages> pp. 310-315, </pages> <month> November. </month> <year> 1993. </year>
Reference-contexts: Hence b 2 sa-1 is partially testable and irredundant. a1 CLK b2 D Q CLK a e1 D Q CLK 3.2.1.2 The Method of Entrena and Cheng <ref> [Entrena and Cheng 1993] </ref>. The sequential optimization method of Entrena and Cheng [Entrena and Cheng 1993] identifies a redundant fault when the mandatory assignments required to detect it cannot be consistently justified. <p> Hence b 2 sa-1 is partially testable and irredundant. a1 CLK b2 D Q CLK a e1 D Q CLK 3.2.1.2 The Method of Entrena and Cheng <ref> [Entrena and Cheng 1993] </ref>. The sequential optimization method of Entrena and Cheng [Entrena and Cheng 1993] identifies a redundant fault when the mandatory assignments required to detect it cannot be consistently justified. <p> Example 8: Consider the circuit in Figure 11 and the fault f 2 sa-0. The fault is untestable because the requirements in the fault-free circuit to detect it lead to a conflict on stem a. Hence the method of Entrena and Cheng <ref> [Entrena and Cheng 1993] </ref> will claim this fault as redundant. However, f 2 sa-0 is irredundant under either test strategy 30 for the following reason. An initialization vector of the fault-free circuit is - a , b - = - 0 , 1 -. <p> As shown by the fault-free STG in Figure 7 (Chapter 2), state A in the fault-free circuit can only be justified by reaching state A. Clearly the fault is untestable. The method of Entrena and Cheng <ref> [Entrena and Cheng 1993] </ref> will claim it as redundant because the state justification procedure in the fault-free circuit starts looping over the previously unjustified state A. However, as shown in Example 4, the fault is partially testable and irredundant. <p> Reddy 1994b] are for redundancy removal, those of [Cho et al. 1993c] are not relevant for the original benchmark circuits without a global reset, those 66 of [Agrawal and Chakradhar 1993] are only for untestability, those of [Moondanos and Abraham 1992] deal with a restricted definition of redundancy, those of <ref> [Cheng 1991a, Cheng 1991b, Cheng 1993, Entrena and Cheng 1993] </ref> are based on incorrect theoretical results, and those of [Pomeranz and Reddy 1994a, Pomeranz and Reddy 1994b] do not deal with benchmark circuits. Table 12.
Reference: [Friedman 1967] <author> A. D. Friedman, </author> " <title> Fault Detection in Redundant Circuits." </title> <journal> IEEE Trans. on Electronic Computers, </journal> <volume> vol. EC-16, </volume> <pages> pp. 99-100, </pages> <month> February </month> <year> 1967. </year>
Reference-contexts: The goal of ATG is to generate a complete detection test set, which is a set of tests that detect any detectable fault. However, Friedman <ref> [Friedman 1967] </ref> has shown that a complete detection test set may not be sufficient to detect all detectable faults if an untestable one is present in the circuit. 1.3.1 Combinational ATG. The test generation problem for combinational circuits belongs to the class of NP-complete problems [Ibarra and Sahni 1975]. <p> Replacing these string of inverters by a single line (with or without inversion as the case may be) also yields the same function. The presence of a redundant fault may invalidate a complete detection test set. Other problems that can arise in redundant circuits include the following <ref> [Friedman 1967] </ref>: If f is a detectable SSF and g is an untestable SSF, then f may become untestable in the presence of g. Such a fault f is called a second-generation redundant fault. Two untestable single faults f and g may become detectable if simultaneously present in the circuit.
Reference: [Giraldi and Bushnell 1991] <author> J. Giraldi and M. L. Bushnell, </author> <title> "Search State Equivalence for Redundancy Identification and Test Generation." </title> <booktitle> Proc. Intn'l. Test Conf., </booktitle> <pages> pp. 184-193, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Their techniques extend beyond fanout-free regions, which are regions without fanouts. Accelerated RID using ATG has been proposed in <ref> [Giraldi and Bushnell 1991] </ref>. Their method relies on exploring a reduced ATG search space, by learning previously 26 encountered equivalent search states. Other existing RID techniques are based on controllability/observability analysis [Ratiu et al. 1982] or on structural transformations of the circuit [Abramovici et al. 1986].
Reference: [Harihara and Menon 1989] <author> M. Harihara and P. R. Menon, </author> <title> "Identification of Undetectable Faults in Combinational Circuits." </title> <booktitle> Proc. Intn'l. Conf. on Computer Design, </booktitle> <pages> pp. 290-293, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: Static and dynamic RID techniques are direct RID techniques that do not involve ATG-type search. Static RID techniques work as a preprocessing step to ATG, whereas dynamic RID techniques work during ATG. Static RID techniques based on an analysis of reconvergent fanout structures have been proposed in <ref> [Harihara and Menon 1989, Menon and Ahuja 1992] </ref>. Their analysis requires the repeated computation of controlling value (c-v) paths associated with every reconvergent gate of every stem in the circuit. Also, an explicit analysis of dominators is required to claim that a fault is undetectable. <p> However, FIRE is not guaranteed to find all the redundancies in the circuit. The experimental results reported in Section 4.4 attest the efficiency of the algorithm. 4.3 A Complete Example Consider the circuit in Figure 23 <ref> [Harihara and Menon 1989] </ref>. It has one reconvergent stem, d and three reconvergent inputs h, k and l 1. FIRE will process each of these lines in turn for both 0 and 1 values. <p> It can be verified that processing lines h, k and l for conflicts do not find any more redundancies. The following paragraphs illustrate how these redundancies would be found using the method proposed in <ref> [Harihara and Menon 1989, Menon and Ahuja 1992] </ref>. To describe their method, a few definitions are reviewed.
Reference: [Hayes 1976] <author> J. P. Hayes, </author> <title> "On the Properties of Irredundant Logic Networks." </title> <journal> IEEE Trans. on Computers, </journal> <volume> vol. C-25, No. 9, </volume> <pages> pp. 884-892, </pages> <month> September </month> <year> 1976. </year>
Reference-contexts: Typically, this fault is referred to as a redundant fault. The general concept of redundancy is broader than the particular one related to the existence of untestable stuck faults, and it denotes a circuit that can be simplified. A general type of redundancy <ref> [Hayes 1976] </ref> exists in a circuit when it is possible to cut a set of r lines and to connect q r of the cut lines to some other signals in the circuit without changing its function.
Reference: [Ibarra and Sahni 1975] <author> O. H. Ibarra and S. K. Sahni, </author> <title> "Polynomially Complete Fault Detection Problems." </title> <journal> IEEE Trans. on Computers, </journal> <volume> vol. C-24, </volume> <pages> pp. 242-249, </pages> <month> March </month> <year> 1975. </year>
Reference-contexts: However, Friedman [Friedman 1967] has shown that a complete detection test set may not be sufficient to detect all detectable faults if an untestable one is present in the circuit. 1.3.1 Combinational ATG. The test generation problem for combinational circuits belongs to the class of NP-complete problems <ref> [Ibarra and Sahni 1975] </ref>. Several algorithms have been proposed in the literature for deterministic combinational ATG. Most of these algorithms are fault-oriented and are branch-and-bound type of algorithms. If given enough time, they are guaranteed to find a test for a fault, if one exists. <p> Any deterministic TG algorithm can identify all the single redundant faults in a combinational circuit, if given enough time. However, as is commonly recognized, TG for combinational circuits is an NP-complete problem <ref> [Ibarra and Sahni 1975] </ref>. The search process of TG involves decision processes at various levels. An inconsistent decision, in its pursuit to find a solution, leads to a contradiction or conflict which is 9 solved by initiating a backtracking strategy. <p> Its key advantages are that RID can be accomplished without any search and several redundant faults may be identified by analyzing the same conflict. FIRE has provably polynomial-time complexity. However, since the RID problem is NP-complete <ref> [Ibarra and Sahni 1975] </ref>, FIRE is not guaranteed to identify all redundancies in the circuit. <p> Therefore the worst-case situation never occurs in practice. Thus, in practice, FIRE finds redundancies with time complexity much lower than O ( n 2 ) and this is very important, considering that the RID problem is NP-complete <ref> [Ibarra and Sahni 1975] </ref>. However, FIRE is not guaranteed to find all the redundancies in the circuit. The experimental results reported in Section 4.4 attest the efficiency of the algorithm. 4.3 A Complete Example Consider the circuit in Figure 23 [Harihara and Menon 1989].
Reference: [Iyer 1991] <author> M. A. Iyer, </author> <title> "One-Pass Redundancy Identification and Removal in Combinational Circuits." </title> <type> MS Thesis, </type> <institution> Dept. of Electrical and Computer Engineering, Illinois Institute of Technology, Chicago, IL, </institution> <month> December </month> <year> 1991. </year>
Reference-contexts: Once a combinational redundancy is identified, the procedure to determine (and remove) the redundant logic for that fault is conceptually straightforward <ref> [Abramovici et al. 1990, Abramovici and Iyer 1992, Iyer 1991] </ref>. On identifying a redundant fault the maximum redundant region for this fault is determined by forward propagating the stuck value of the redundant fault. <p> In essence, most of these techniques require large amounts of wasted computations. An initial contribution of this research was a novel algorithm for redundancy identification and removal in combinational circuits that uses only a single pass of test generation and fault simulation <ref> [Iyer 1991, Abramovici and Iyer 1992] </ref>. The important contribution was the development of a novel dynamic RID technique that identifies newly created redundancies that appear as a result of a redundancy removal. <p> during ATG, but identify a large number of redundant or untestable faults. 37 CHAPTER IV FAULT-INDEPENDENT REDUNDANCY IDENTIFICATION IN COMBINATIONAL CIRCUITS An initial contribution of this research was a novel algorithm for RID and removal in combinational circuits that uses only a single pass of test generation and fault simulation <ref> [Iyer 1991, Abramovici and Iyer 1992] </ref>. The important contribution was the development of a novel dynamic RID technique that identifies newly created redundancies that appear as a result of a redundancy removal. <p> A redundancy removal procedure using FIRES will have to reanalyze the stems that were already analyzed before the current redundancy removal. Alternatively, this procedure may be used in conjunction with the fault-independent procedure to identify newly created redundancies after a redundancy removal, that was proposed in <ref> [Abramovici and Iyer 1992, Iyer 1991] </ref>. Redundancy removal using FIRES is currently under investigation. The entire concept of processing possible conflicts and illegal states of the the fault-free circuit and finding faults that require them as necessary conditions for detection has important applications in delay testing.
Reference: [Iyer and Abramovici 1994a] <author> M. A. Iyer and M. Abramovici, </author> <title> "Low-Cost Redundancy Identification for Combinational Circuits," </title> <booktitle> Proc. 7th. Intn'l. Conf. on VLSI Design, India, </booktitle> <pages> pp. 315-318, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: A general method was proposed to find faults for which a given combination of values (on a set of lines) is a necessary condition for their detection. This chapter presents a novel Fault-Independent algorithm for REdundancy identification (FIRE) in combinational circuits <ref> [Iyer and Abramovici 1994a, Iyer and Abramovici 1994b] </ref>. FIRE assumes combinational circuits with AND, NAND, OR, NOR and NOT gates as primitives and identifies redundant faults for which a conflict on a single line in the circuit is necessary for their detection.
Reference: [Iyer and Abramovici 1994b] <author> M. A. Iyer and M. Abramovici, </author> <title> "FIRE: A Fault-Independent Redundancy Identification Algorithm for Combinational Circuits," </title> <journal> IEEE Trans. on VLSI Systems, </journal> <note> (first revision under review). </note>
Reference-contexts: A general method was proposed to find faults for which a given combination of values (on a set of lines) is a necessary condition for their detection. This chapter presents a novel Fault-Independent algorithm for REdundancy identification (FIRE) in combinational circuits <ref> [Iyer and Abramovici 1994a, Iyer and Abramovici 1994b] </ref>. FIRE assumes combinational circuits with AND, NAND, OR, NOR and NOT gates as primitives and identifies redundant faults for which a conflict on a single line in the circuit is necessary for their detection.
Reference: [Iyer and Abramovici 1994c] <author> M. A. Iyer and M. Abramovici, </author> <title> "Sequentially Untestable Faults Identified Without Search (Simple Implications Beat Exhaustive Search!)," </title> <booktitle> Proc. Intn'l. Test Conf., </booktitle> <pages> pp. 259-266, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: The sequential FIRE algorithm (FIRES) also identifies the value of c for every c-cycle redundancy it identifies. An intermediate result of this research was an algorithm to Find sequentially UNTESTable faults (FUNTEST) without search <ref> [Iyer and Abramovici 1994c] </ref>, that extended the concept of FIRE to sequential circuits using the single-fault theorem in [Agrawal and Chakradhar 1993]. However, the use of the single-fault theorem precludes FUNTEST from identifying sequential redundancy. Even though FIRES uses an implication mechanism similar to FUNTEST, it is significantly different. <p> By the rules of computing c f , all the faults except g 0 are 0-cycle redundant. Fault g 0 is 1-cycle redundant. Among the seven redundant faults identified by FIRES in the above example, the FUNTEST algorithm <ref> [Iyer and Abramovici 1994c] </ref> will report only one (g 0 ) as untestable. 5.3 Implementation and Experimental Results FIRES was implemented in C++ and productized under a new object-oriented framework that supports circuits with wired structures, tristate devices, bidirectionals, busses, multiple clocks and asynchronous loops. <p> Next, an algorithm to Find UNtestable faults for which Illegal states are necessary for detection (FUNI) is presented. FUNI uses the illegal states computed by FILL. This is more general than the FUNTEST algorithm <ref> [Iyer and Abramovici 1994c] </ref>, which processes conflicts on stems to identify untestable faults. A conflict is a special case of an illegal combination of values, which assigns opposite values to the same line.
Reference: [Iyer et al. 1995] <author> M. A. Iyer, D. E. Long, and M. Abramovici, </author> <title> "Identifying Sequential Redundancies Without Search," </title> <note> To be published (hopefully, sometime in the near future). </note>
Reference-contexts: the response of the fault-free circuit to I starting from S, Z ( I , S ), is different from the response of the faulty circuit starting from S f f f ). (This definition differs slightly from that in [Pomeranz and Reddy 1993], in that it includes testable faults <ref> [Iyer et al. 1995] </ref>. <p> Chapter 2 also illustrated some examples of irredundant sequentially untestable faults. Chapter 3 reviewed all the previous work to identify sequential redundancy and it was shown that no practical solution exists to solve this problem. This chapter introduces the concept of a c-cycle sequential redundancy <ref> [Iyer et al. 1995] </ref>.
Reference: [Iyer et al. 1996] <author> M. A. Iyer, D. E. Long, and M. Abramovici, </author> <title> "Surprises in Sequential Redundancy Identification," </title> <booktitle> 9th. Intn'l. Conf. on VLSI Design, </booktitle> <address> India, </address> <note> January 1996 (submitted). 108 </note>
Reference-contexts: In general, techniques developed for RID and removal in combinational circuits cannot be applied for sequential circuits and hence they are dealt with separately in the following sections. It is shown that some of the solutions for sequential RID are in fact based on incorrect theoretical results <ref> [Iyer et al. 1996] </ref>. 3.1 Combinational RID and Removal RID using ATG is an indirect process. Static and dynamic RID techniques are direct RID techniques that do not involve ATG-type search. Static RID techniques work as a preprocessing step to ATG, whereas dynamic RID techniques work during ATG.
Reference: [Kajihara et al. 1992] <author> S. Kajihara, H. Shiba and K. Kinoshita, </author> <title> "Removal of Redundancy in Logic Circuits under Classification of Undetectable Faults." </title> <booktitle> Proc. 22nd Fault-Tolerant Computing Symposium, </booktitle> <pages> pp. 263-270, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: Their techniques use the analysis of reconvergent fanout structures to identify newly redundant faults after the removal of a particular redundant fault. However, they do not guarantee an irredundant circuit. Combinational RID and removal based on ATG was proposed in <ref> [Kajihara et al. 1992] </ref>. Their method relies on classification of faults and removing redundancies of only particular classes that are guaranteed not to create new redundancies. This represents removal of only a subset of redundancies.
Reference: [Kunz and Pradhan 1992] <author> W. Kunz and D. K. Pradhan, </author> <title> "Recursive Learning: An Attractive Alternative to the Decision Tree for Test Generation in Digital Circuits." </title> <booktitle> Proc. Intn'l. Test Conf., </booktitle> <pages> pp. 816-825, </pages> <month> September </month> <year> 1992. </year>
Reference: [Leiserson and Saxe 1991] <author> C. E. Leiserson and J. B. Saxe, </author> <title> "Retiming Synchronous Circuitry," </title> <journal> Algorithmica, </journal> <volume> vol. 6, </volume> <pages> pp. 5-35, </pages> <year> 1991. </year>
Reference-contexts: This definition of sequential redundancy is rather restrictive. Though their work is of theoretical importance, it is not practical for large circuits, because it relies on building the STGs for the fault-free and faulty circuits for each modeled fault. 35 3.2.2.5 Retiming and Redundancy. Circuit retiming <ref> [Leiserson and Saxe 1991] </ref> consists of changing the position of FFs in the circuit. Dey and Chakradhar observed that retiming can be used to convert sequential reconvergences to combinational reconvergences, and that in the process sequentially redundant faults become combinationally redundant [Dey and Chakradhar 1994]. <p> In fact, other sequential optimizations may require the same sort of delay before initialization. For example, in recent work, Singhal et al. [Singhal et al. 1995a] have shown that forward retiming <ref> [Leiserson and Saxe 1991] </ref> has this same property. Using the terminology of [Singhal et al. 1995b], it can be said that removing a c-cycle redundancy from a circuit creates a c-cycle delayed replacement for the original circuit. The notion of c-cycle redundancy also has the nice property of being compositional.
Reference: [Liang et al. 1994] <author> H.-C Liang, C. L. Lee, and J. E. Chen, </author> <title> "A Sequential Redundant Fault Identification Scheme and Its Application to Test Generation," </title> <booktitle> Proc. Asian Test Symp., </booktitle> <pages> pp. 57-62, </pages> <year> 1994. </year>
Reference-contexts: However, as shown in Example 4, the fault is partially testable and irredundant. The faulty circuit is uninitializable. 3.2.1.3 The Method of Liang et al. <ref> [Liang et al. 1994] </ref>. Recently, Liang et al. [Liang et al. 1994] have proposed a method to identify sequentially redundant faults. Their method relies on identifying FFs that cannot be initialized and circuit lines that are uncontrollable. <p> However, as shown in Example 4, the fault is partially testable and irredundant. The faulty circuit is uninitializable. 3.2.1.3 The Method of Liang et al. <ref> [Liang et al. 1994] </ref>. Recently, Liang et al. [Liang et al. 1994] have proposed a method to identify sequentially redundant faults. Their method relies on identifying FFs that cannot be initialized and circuit lines that are uncontrollable. However, their method relies on three-valued logic simulation and this may lead to erroneous results. <p> The simulation also identifies uncontrollable lines. The following example shows that the method of Liang et al. may identify even a testable fault as redundant. Example 10: Consider the circuit in Figure 12. The method in <ref> [Liang et al. 1994] </ref> will erroneously identify the fault g sa-0 as redundant, when in fact this fault is testable.
Reference: [Lin et al. 1990] <author> B. Lin, H. J. Touati, and A. R. </author> <title> Newton, "Don't Care Minimization of Multi-Level Sequential Logic Networks," </title> <booktitle> Proc. Intn'l Conf. on Computer-Aided Design, </booktitle> <pages> pp. 414-417, </pages> <month> November </month> <year> 1990. </year>
Reference: [Long et al. 1995] <author> D. E. Long, M. A. Iyer and M. Abramovici, </author> <title> "Identifying Sequentially Untestable Faults Using Illegal States," </title> <booktitle> Proc. 13th. IEEE VLSI Test Symp., </booktitle> <pages> pp. 4-11, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: Clearly, determining illegal states by an efficient technique as a preprocessing step to ATG would significantly reduce its computational complexity. In this chapter, we first review a recently proposed algorithm to Find ILLegal states (FILL) <ref> [Long et al. 1995] </ref> using implicit state enumeration based on binary decision diagrams (BDDs) [Bryant 1986]. <p> FUNI is fault-independent and does not rely on exhaustive search; rather, it uses an implication procedure similar to FIRES. (Other work to identify sequentially untestable faults without using sequential ATG [Agrawal and Chakradhar 1993] is based on combinational ATG which still requires exhaustive search.) 6.1 Review of the FILL Algorithm <ref> [Long et al. 1995] </ref> FILL computes illegal states in a sequential circuit without assuming a reset state and without having to compute an initialization sequence. <p> Pixley's ``outer envelope'' computation [Pixley 1990] uses the same basic approach of eliminating states that must be illegal, though in general it may find fewer illegal states than FILL. FILL functionally partitions large circuits to simplify the analysis. The Approach Used By FILL <ref> [Long et al. 1995] </ref> FILL does not require reset information because of the following observation. If a circuit is initializable, then all the terminal SCCs in its STG are equivalent. All the states in these terminal SCCs are legal states. <p> In fact, it will not identify illegal states that form a cycle of length two or more, so in Figure 28, it will not find the illegal states C and D. ILLEGAL STATES B D C LEGAL STATES S The reader is referred to <ref> [Long et al. 1995] </ref> for a detailed description of FILL. 6.2 Using Illegal States to Identify Sequentially Untestable Faults Section 4.1 reviewed our previously proposed algorithm to identify redundant faults in a combinational circuit for which an illegal combination of values is a necessary condition for detection. <p> Hence FIRES is expected to perform better than any ATG-based approach for redundancy removal. This thesis also introduced FUNI, an algorithm to identify untestable faults using illegal states. FUNI uses the illegal states of the fault-free circuit computed by FILL <ref> [Long et al. 1995] </ref> and identifies faults for which these illegal states are necessary for detection. The results presented show that the untestable faults found by FUNI are not easy targets for a conventional state-of-the-art sequential test generator.
Reference: [Marchok et al. 1994] <author> T. E. Marchok, A. El-Maleh, W. Maly, and J. Rajski, </author> <title> "Complexity of Sequential ATPG," </title> <booktitle> European Design and Test Conf., </booktitle> <year> 1994. </year>
Reference-contexts: The fault c 2 sa-1 then becomes combinationally redundant in the retimed circuit. c f CLK sa-1 a D Q b e g h Recently, it has been shown that retiming preserves testability <ref> [Marchok et al. 1994, El-Maleh et al. 1994] </ref>. Thus an untestable fault in a retimed circuit will also be untestable in the original circuit.
Reference: [Menon and Ahuja 1992] <author> P. R. Menon and H. Ahuja, </author> <title> "Redundancy Removal and Simplification of Combinational Circuits." </title> <booktitle> Digest of Papers, IEEE VLSI Test Symposium, </booktitle> <pages> pp. 268-273, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: Static and dynamic RID techniques are direct RID techniques that do not involve ATG-type search. Static RID techniques work as a preprocessing step to ATG, whereas dynamic RID techniques work during ATG. Static RID techniques based on an analysis of reconvergent fanout structures have been proposed in <ref> [Harihara and Menon 1989, Menon and Ahuja 1992] </ref>. Their analysis requires the repeated computation of controlling value (c-v) paths associated with every reconvergent gate of every stem in the circuit. Also, an explicit analysis of dominators is required to claim that a fault is undetectable. <p> The entire process is repeated until no more redundancies are found. This approach is inefficient, as it repeats the entire fault simulation/test generation job every time the circuit is simplified, causing many faults to be repeatedly targeted. Another method for combinational RID and removal has been proposed in <ref> [Menon and Ahuja 1992] </ref>. Their approach does not use ATG to identify redundancies and they remove a redundant region as soon as it is identified. Their techniques use the analysis of reconvergent fanout structures to identify newly redundant faults after the removal of a particular redundant fault. <p> It can be verified that processing lines h, k and l for conflicts do not find any more redundancies. The following paragraphs illustrate how these redundancies would be found using the method proposed in <ref> [Harihara and Menon 1989, Menon and Ahuja 1992] </ref>. To describe their method, a few definitions are reviewed.
Reference: [Moondanos and Abraham 1992] <author> J. Moondanos and J. A. Abraham, </author> <title> "Sequential Redundancy Identification Using Verification Techniques." </title> <booktitle> Proc. Intn'l. Test Conf., </booktitle> <pages> pp. 197-205, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: Irredundant Untestable Faults Untestable Faults Testable Faults Partially Testable Faults Redundant Faults A more restrictive definition of redundancy that was used in <ref> [Abramovici and Breuer 1979, Moondanos and Abraham 1992] </ref> is as follows. <p> It was shown in <ref> [Moondanos and Abraham 1992] </ref> that redundant faults under Definition 13 form a subset of redundant faults under Definition 12. <p> Thus, checking that the subcircuit still has an initialization sequence is not sufficient. 3.2.2.4 Sequential RID Using Verification. Formal verification techniques were used for sequential RID in <ref> [Moondanos and Abraham 1992] </ref>. Their method uses Definition 13 and relies on verifying that the fault-free and the faulty circuit (for a redundant fault) have equivalent state tables. This definition of sequential redundancy is rather restrictive. <p> of [Cheng 1991a, Cheng 1991b, Cheng 1993, Cho et al. 1993c, Pomeranz and Reddy 1994b] are for redundancy removal, those of [Cho et al. 1993c] are not relevant for the original benchmark circuits without a global reset, those 66 of [Agrawal and Chakradhar 1993] are only for untestability, those of <ref> [Moondanos and Abraham 1992] </ref> deal with a restricted definition of redundancy, those of [Cheng 1991a, Cheng 1991b, Cheng 1993, Entrena and Cheng 1993] are based on incorrect theoretical results, and those of [Pomeranz and Reddy 1994a, Pomeranz and Reddy 1994b] do not deal with benchmark circuits. Table 12.
Reference: [Niermann and Patel 1991] <author> T. Niermann and J. H. Patel, "HITEC: </author> <title> A Test Generation Package for Sequential Circuits," </title> <booktitle> Proc. European Conf. on Design Automation, </booktitle> <pages> pp. 214-218, </pages> <year> 1991. </year>
Reference-contexts: However, the test generator cannot identify these faults as redundant. We now show that state-of-the-art sequential test generators can have difficulty even in proving that the faults found by FIRES are untestable. We used two sequential test generators, GENTEST [Chakraborty et al. 1991] and HITEC <ref> [Niermann and Patel 1991] </ref>. In this experiment, the faults found by FIRES (without validation) were passed as the only targets to the test generators. For S5378, GENTEST, allowed to spend up to 100 seconds per fault, aborted 95 % of the untestable faults found by FIRES.
Reference: [Pixley 1990] <author> C. Pixley, </author> <title> "A Computational Theory and Implementation of Sequential Hardware Equivalence," Computer-Aided Verification, </title> <editor> E. M. Clarke and R. P. Kurshan, </editor> <booktitle> editors, </booktitle> <pages> pp. 293-320, </pages> <year> 1990. </year>
Reference-contexts: However, it has limited application because it cannot handle large circuits. In contrast, FILL does not assume a reset state, does not compute an initialization sequence, and builds up illegal states incrementally, allowing it to at least obtain partial solutions. Pixley's method <ref> [Pixley 1990] </ref> is similar to FILL, though it will in general 70 find fewer illegal states. A new functional partitioning method allows FILL to handle large circuits. <p> FILL does not require reset information, and it builds up illegal states directly, so if the procedure must be terminated it still returns partial information. However, it is not guaranteed to find all the illegal states in the circuit. Pixley's ``outer envelope'' computation <ref> [Pixley 1990] </ref> uses the same basic approach of eliminating states that must be illegal, though in general it may find fewer illegal states than FILL. FILL functionally partitions large circuits to simplify the analysis.
Reference: [Pomeranz and Reddy 1992] <author> I. Pomeranz and S. M. Reddy, </author> <title> "The Multiple Observation Time Test Strategy." </title> <journal> IEEE Trans. on Computers, </journal> <volume> vol. 41, no. 5, </volume> <pages> pp. 627-637, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: The second, called the multiple observation time strategy <ref> [Pomeranz and Reddy 1992] </ref>, is based on the concept of strong detection [Abramovici et al. 1990], which relies on finding a sequence for a fault by making the fault-free circuit starting at state S 1 and the faulty circuit starting at state S 2 exhibit different output responses at some vector
Reference: [Pomeranz and Reddy 1993] <author> I. Pomeranz and S. M. Reddy, </author> <title> "Classification of Faults in Synchronous Sequential Circuits," </title> <journal> IEEE Trans. on Computers, </journal> <volume> vol. 42, </volume> <pages> pp. 1066-1077, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: As was stated in Chapter 1, the multiple observation time test strategy is more general than the single observation time test strategy. Faults that are untestable under single observation may have tests under multiple observation. The following definitions from <ref> [Pomeranz and Reddy 1993] </ref> assume the multiple observation time test strategy. <p> sequence I such that for every fault-free initial state S, the response of the fault-free circuit to I starting from S, Z ( I , S ), is different from the response of the faulty circuit starting from S f f f ). (This definition differs slightly from that in <ref> [Pomeranz and Reddy 1993] </ref>, in that it includes testable faults [Iyer et al. 1995].
Reference: [Pomeranz and Reddy 1994a] <author> I. Pomeranz and S. M. Reddy, </author> <title> "On Identifying Undetectable and Redundant Faults in Synchronous Sequential Circuits," </title> <booktitle> 12th. IEEE VLSI Test Symp., </booktitle> <pages> pp. 8-14, </pages> <month> April </month> <year> 1994. </year> <month> 109 </month>
Reference-contexts: al. 1993c] or any other method that identifies sequential redundancies by assuming a fault-free global reset mechanism (which is always used to start the operation of the circuit), cannot be used to identify redundancies in a circuit without a fault-free global reset mechanism. 3.2.2.3 The Methods of Pomeranz and Reddy <ref> [Pomeranz and Reddy 1994a, Pomeranz and Reddy 1994b] </ref>. Pomeranz and Reddy have proposed a method to identify sequential redundancy, based on combinational ATG for multiple faults, which is not practical for large circuits [Pomeranz and Reddy 1994a]. <p> Pomeranz and Reddy have proposed a method to identify sequential redundancy, based on combinational ATG for multiple faults, which is not practical for large circuits <ref> [Pomeranz and Reddy 1994a] </ref>. More recently, they proposed a method to determine whether a sequentially untestable fault prevents the initialization of the circuit [Pomeranz and Reddy 1994b]. They argue that faults which do not exhibit this behavior can be considered as redundant and the circuit simplified accordingly. <p> Their first (second) theorem, called the single-fault (multi-fault) theorem targets single (multiple) faults in an iterative array model of finite length derived from the sequential circuit. Their method, however, still requires exhaustive search to identify untestability. It was later shown in <ref> [Pomeranz and Reddy 1994a] </ref> that untestable faults found using the single-fault theorem are not necessarily redundant. They also showed that all the faults identified using the multi-fault theorem are redundant. However, this procedure requires combinational ATG for multiple faults, which is not practical for large circuits. <p> circuits without a global reset, those 66 of [Agrawal and Chakradhar 1993] are only for untestability, those of [Moondanos and Abraham 1992] deal with a restricted definition of redundancy, those of [Cheng 1991a, Cheng 1991b, Cheng 1993, Entrena and Cheng 1993] are based on incorrect theoretical results, and those of <ref> [Pomeranz and Reddy 1994a, Pomeranz and Reddy 1994b] </ref> do not deal with benchmark circuits. Table 12.
Reference: [Pomeranz and Reddy 1994b] <author> I. Pomeranz and S. M. Reddy, </author> <title> "On Achieving Complete Testability of Synchronous Sequential Circuits with Synchronizing Sequences," </title> <booktitle> Proc. Intn'l. Test Conf., </booktitle> <pages> pp. 1007-1016, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: It will now be shown that both these claims are incorrect. It was also shown in <ref> [Pomeranz and Reddy 1994b] </ref> that the second claim is incorrect. Example 8: Consider the circuit in Figure 11 and the fault f 2 sa-0. The fault is untestable because the requirements in the fault-free circuit to detect it lead to a conflict on stem a. <p> al. 1993c] or any other method that identifies sequential redundancies by assuming a fault-free global reset mechanism (which is always used to start the operation of the circuit), cannot be used to identify redundancies in a circuit without a fault-free global reset mechanism. 3.2.2.3 The Methods of Pomeranz and Reddy <ref> [Pomeranz and Reddy 1994a, Pomeranz and Reddy 1994b] </ref>. Pomeranz and Reddy have proposed a method to identify sequential redundancy, based on combinational ATG for multiple faults, which is not practical for large circuits [Pomeranz and Reddy 1994a]. <p> Pomeranz and Reddy have proposed a method to identify sequential redundancy, based on combinational ATG for multiple faults, which is not practical for large circuits [Pomeranz and Reddy 1994a]. More recently, they proposed a method to determine whether a sequentially untestable fault prevents the initialization of the circuit <ref> [Pomeranz and Reddy 1994b] </ref>. They argue that faults which do not exhibit this behavior can be considered as redundant and the circuit simplified accordingly. <p> We illustrate this with an example. Example 12: Consider again the circuit, fault and STGs in Figures 8 and 9 (Chapter 2). The fault was shown to be a partially testable FMI in Example 5. The method of Pomeranz and Reddy <ref> [Pomeranz and Reddy 1994b] </ref> will consider this fault as redundant and remove its region from the circuit. The original (fault-free) circuit required only one initialization vector - a = 0 -. This vector will not initialize the new (simplified) circuit. <p> A circuit with a c-cycle redundant fault can be simplified by removing the redundant region 56 associated with that fault. A c-cycle redundant fault is not the same as an untestable fault that is not an FPI <ref> [Pomeranz and Reddy 1994b] </ref>. Removing a c-cycle redundant fault only requires the application of c arbitrary input vectors before the existing initialization sequence. In contrast, removing a fault from the latter category [Pomeranz and Reddy 1994b] requires the computation of a new initialization sequence. <p> A c-cycle redundant fault is not the same as an untestable fault that is not an FPI <ref> [Pomeranz and Reddy 1994b] </ref>. Removing a c-cycle redundant fault only requires the application of c arbitrary input vectors before the existing initialization sequence. In contrast, removing a fault from the latter category [Pomeranz and Reddy 1994b] requires the computation of a new initialization sequence. It is reasonable to remove c-cycle redundant faults since it is easy to have the circuit clocked a few times before the initialization sequence is applied. <p> Hence, removing a c-cycle redundant fault in a subcircuit can be done without examining the larger circuit; we just have to clock the entire system c times before applying its usual initialization sequence. In contrast, with methods such as <ref> [Pomeranz and Reddy 1994b] </ref>, it is not safe to remove a fault in a subcircuit without first analyzing the full circuit to see whether the whole system will still have a reset sequence. <p> circuits without a global reset, those 66 of [Agrawal and Chakradhar 1993] are only for untestability, those of [Moondanos and Abraham 1992] deal with a restricted definition of redundancy, those of [Cheng 1991a, Cheng 1991b, Cheng 1993, Entrena and Cheng 1993] are based on incorrect theoretical results, and those of <ref> [Pomeranz and Reddy 1994a, Pomeranz and Reddy 1994b] </ref> do not deal with benchmark circuits. Table 12.
Reference: [Pomeranz et al. 1993] <author> I. Pomeranz, S. M. Reddy and J. H. Patel, </author> <title> "Theory and Practice of Sequential Machine Testing and Testability." </title> <booktitle> Proc. 22nd. Fault-Tolerant Computing Symposium, </booktitle> <pages> pp. 1-8, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: It was shown in [Moondanos and Abraham 1992] that redundant faults under Definition 13 form a subset of redundant faults under Definition 12. More recently, Pomeranz et al. <ref> [Pomeranz et al. 1993] </ref> have also shown that there could be redundant faults that do not require the fault-free and the faulty circuits to have equivalent state tables. 2.3.3 Unrestricted and Restricted Test Strategies. The operation of a sequential circuit begins with an initialization sequence.
Reference: [Ratiu et al. 1982] <author> I. M. Ratiu, A. Sangiovanni-Vincentelli, and D. O. Pederson, "VICTOR: </author> <title> a fast VLSI testability analysis program." </title> <booktitle> Proc. 1982 Intn'l. Test Conf., </booktitle> <pages> pp. 397-401, </pages> <month> November </month> <year> 1982. </year>
Reference-contexts: Accelerated RID using ATG has been proposed in [Giraldi and Bushnell 1991]. Their method relies on exploring a reduced ATG search space, by learning previously 26 encountered equivalent search states. Other existing RID techniques are based on controllability/observability analysis <ref> [Ratiu et al. 1982] </ref> or on structural transformations of the circuit [Abramovici et al. 1986]. As stated earlier, redundancy removal has the additional complication that new redundancies may appear as a result of a redundancy removal. It is imperative that any algorithm for redundancy removal identify these redundancies as well.
Reference: [Rutman 1972] <author> R. A. Rutman, </author> <title> "Fault Detection Test Generation for Sequential Logic by Heuristic Tree Search," </title> <journal> IEEE Computer Group Repository, </journal> <note> Paper No. R-72-187, </note> <year> 1972. </year>
Reference-contexts: Simulation is then performed till a stable condition is reached; i.e. the inputs and outputs have the same values for each FF. Then FFs with U value are identified as uninitializable. This is similar to infinity values 31 in controllability cost computations <ref> [Rutman 1972, Breuer 1978] </ref>. The simulation also identifies uncontrollable lines. The following example shows that the method of Liang et al. may identify even a testable fault as redundant. Example 10: Consider the circuit in Figure 12.
Reference: [Singhal et al. 1995b] <author> V. Singhal, C. Pixley, A. Aziz and R. K. Brayton, </author> <title> "Delaying Safeness for More Flexibility," </title> <institution> Unpublished Technical Report from the University of California at Berkeley, </institution> <month> January 17, </month> <year> 1995. </year>
Reference-contexts: In fact, other sequential optimizations may require the same sort of delay before initialization. For example, in recent work, Singhal et al. [Singhal et al. 1995a] have shown that forward retiming [Leiserson and Saxe 1991] has this same property. Using the terminology of <ref> [Singhal et al. 1995b] </ref>, it can be said that removing a c-cycle redundancy from a circuit creates a c-cycle delayed replacement for the original circuit. The notion of c-cycle redundancy also has the nice property of being compositional.
Reference: [Singhal et al. 1995a] <author> V. Singhal, C. Pixley, R. L. Rudell and R. K. Brayton, </author> <title> "The Validity of Retiming Sequential Circuits," </title> <booktitle> Proc. Design Automation Conf., </booktitle> <month> June. </month> <note> 1995 (to appear). </note>
Reference-contexts: It is reasonable to remove c-cycle redundant faults since it is easy to have the circuit clocked a few times before the initialization sequence is applied. In fact, other sequential optimizations may require the same sort of delay before initialization. For example, in recent work, Singhal et al. <ref> [Singhal et al. 1995a] </ref> have shown that forward retiming [Leiserson and Saxe 1991] has this same property. Using the terminology of [Singhal et al. 1995b], it can be said that removing a c-cycle redundancy from a circuit creates a c-cycle delayed replacement for the original circuit.
Reference: [Touati et al. 1990] <author> H. Touati, H. Savoj, B. Lin, R. K. Brayton, and A. </author> <title> Sangiovanni-Vincentelli "Implicit State Enumeration of Finite State Machines Using BDD's," </title> <booktitle> Proc. Intn'l Conf. on Computer-Aided Design, </booktitle> <pages> pp. 130-133, </pages> <month> November </month> <year> 1990. </year>
References-found: 62

