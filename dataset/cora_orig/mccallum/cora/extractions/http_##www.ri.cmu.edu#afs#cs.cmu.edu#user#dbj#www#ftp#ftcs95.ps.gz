URL: http://www.ri.cmu.edu/afs/cs.cmu.edu/user/dbj/www/ftp/ftcs95.ps.gz
Refering-URL: http://www.ri.cmu.edu/afs/cs.cmu.edu/user/dbj/www/ft.html
Root-URL: 
Title: Completely Asynchronous Optimistic Recovery with Minimal Rollbacks  
Author: Sean W. Smith David B. Johnson, and J. D. Tygar 
Address: Pittsburgh, PA 15213-3891 USA  
Affiliation: Computer Science Department Carnegie Mellon University  
Abstract: Consider the problem of transparently recovering an asynchronous distributed computation when one or more processes fail. Basing rollback recovery on optimistic message logging and replay is desirable for several reasons, including not requiring synchronization between processes during failure-free operation. However, previous optimistic rollback recovery protocols either have required synchronization during recovery, or have permitted a failure at one process to potentially trigger an exponential number of process rollbacks. In this paper, we present an optimistic rollback recovery protocol that provides completely asynchronous recovery, while also reducing the number of times a process must roll back in response to a failure to at most one. This protocol is based on comparing timestamp vectors across multiple levels of partial order time. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B. Bhargava and S. Lian. </author> <title> Independent Checkpointing and Concurrent Rollback Recovery for Distributed Systems An Optimistic Approach. </title> <booktitle> Seventh Symposium on Reliable Distributed Systems. </booktitle> <pages> 3-12. </pages> <publisher> IEEE, </publisher> <year> 1988. </year>
Reference-contexts: The message logging approach allows states of a process in addition to those saved in a checkpoint to be recovered. Recovery protocols based instead on checkpointing without message logging (e.g., <ref> [1, 5, 6, 7, 8, 15, 16, 17, 31] </ref>) can recover only process states that have been checkpointed, often forcing processes to roll back further than otherwise required after a failure.
Reference: [2] <author> K. Birman, A. Schiper, and P. Stephenson. </author> <title> Lightweight Causal and Atomic Group Multicast. </title> <journal> ACM Transactions on Computer Systems. </journal> <volume> 9: </volume> <pages> 272-314. </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: is a recovery line, checkpointing-based recovery will force surviving processes to roll back computation that does not depend on the computation lost due to failure One approach to avoiding the exponential rollback of Strom and Yemini is to enforce that all messages are delivered in causal order, as in ISIS <ref> [2] </ref>. Another approach is to have each process piggyback all received failure messages on each outgoing message and thus restrict enforced causal delivery to failure announcements. Essentially, our protocol optimizes these approaches. The system timestamp vector concisely expresses the information processes would deduce via causal delivery of failure announcements.
Reference: [3] <author> A. Borg, J. Baumbach and S. Glazer. </author> <title> A Message System Supporting Fault Tolerance. </title> <booktitle> Ninth ACM Symposium on Operating Systems Principles. </booktitle> <pages> 90-99. </pages> <year> 1983. </year>
Reference-contexts: Optimistic message logging protocols (e.g., [12, 13, 14, 20, 25, 30]) buffer received messages in volatile storage and log them to stable storage asynchronously in order to avoid blocking the process due to logging. Unlike pessimistic message logging protocols (e.g., <ref> [3, 4, 9, 11, 21] </ref>), optimistic protocols allow a process to receive a message and to continue execution before the message is logged to stable storage.
Reference: [4] <author> A. Borg, W. Blau, W. Graetsch, F. Herrmann, and W. Oberle. </author> <title> Fault Tolerance Under UNIX. </title> <journal> ACM Transactions on Computer Systems. </journal> <volume> 7 (1): </volume> <pages> 1-24. </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: Optimistic message logging protocols (e.g., [12, 13, 14, 20, 25, 30]) buffer received messages in volatile storage and log them to stable storage asynchronously in order to avoid blocking the process due to logging. Unlike pessimistic message logging protocols (e.g., <ref> [3, 4, 9, 11, 21] </ref>), optimistic protocols allow a process to receive a message and to continue execution before the message is logged to stable storage.
Reference: [5] <author> D. Briatico, A. Ciuffoletti, and L. Simoncini. </author> <title> A Distributed Domino Effect Free Recovery Algorithm. </title> <booktitle> IEEE Symposium on Reliability in Distributed Software and Database Systems. </booktitle> <pages> 207-215. </pages> <month> October </month> <year> 1984. </year>
Reference-contexts: The message logging approach allows states of a process in addition to those saved in a checkpoint to be recovered. Recovery protocols based instead on checkpointing without message logging (e.g., <ref> [1, 5, 6, 7, 8, 15, 16, 17, 31] </ref>) can recover only process states that have been checkpointed, often forcing processes to roll back further than otherwise required after a failure. <p> Recovery protocols based on checkpointing without message logging restore the system to a recovery line composed of local checkpoints. Organizing recovery lines into an increasing sequence (e.g., <ref> [5, 7] </ref>) may allow asynchronous recovery and may tolerate concurrent failures.
Reference: [6] <author> K. M. Chandy and L. Lamport. </author> <title> Distributed Snapshots: Determining Global States of Distributed Systems. </title> <journal> ACM Transactions on Computer Systems. </journal> <volume> 3: </volume> <pages> 63-75. </pages> <month> February </month> <year> 1985. </year>
Reference-contexts: The message logging approach allows states of a process in addition to those saved in a checkpoint to be recovered. Recovery protocols based instead on checkpointing without message logging (e.g., <ref> [1, 5, 6, 7, 8, 15, 16, 17, 31] </ref>) can recover only process states that have been checkpointed, often forcing processes to roll back further than otherwise required after a failure.
Reference: [7] <editor> A. Ciuffoelleti. La Coordinazione Delle Attivita Di Ripristino Nei Sistemi Distribuiti. A.I.C.A. </editor> <booktitle> Annual Conference Proceedings. </booktitle> <month> October </month> <year> 1989. </year>
Reference-contexts: The message logging approach allows states of a process in addition to those saved in a checkpoint to be recovered. Recovery protocols based instead on checkpointing without message logging (e.g., <ref> [1, 5, 6, 7, 8, 15, 16, 17, 31] </ref>) can recover only process states that have been checkpointed, often forcing processes to roll back further than otherwise required after a failure. <p> Recovery protocols based on checkpointing without message logging restore the system to a recovery line composed of local checkpoints. Organizing recovery lines into an increasing sequence (e.g., <ref> [5, 7] </ref>) may allow asynchronous recovery and may tolerate concurrent failures.
Reference: [8] <author> E. N. Elnozahy, D. B. Johnson and W. Zwaenepoel. </author> <title> The Performance of Consistent Checkpointing. </title> <booktitle> Eleventh IEEE Symposium on Reliable Distributed Systems. </booktitle> <pages> 39-47. </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: The message logging approach allows states of a process in addition to those saved in a checkpoint to be recovered. Recovery protocols based instead on checkpointing without message logging (e.g., <ref> [1, 5, 6, 7, 8, 15, 16, 17, 31] </ref>) can recover only process states that have been checkpointed, often forcing processes to roll back further than otherwise required after a failure. <p> Although optimism thus complicates recovery, optimistic rollback protocols are potentially cheaper during failure-free operation due to their asynchronous operation. By also using asynchronous checkpointing techniques <ref> [8, 17] </ref>, all causes of process blocking due to fault tolerance during failure-free operation may be avoided. 1.3.
Reference: [9] <author> E. N. Elnozahy and W. Zwaenepoel. Manetho: </author> <title> Transparent Rollback-Recovery with Low Overhead, Limited Rollback and Fast Output Commit. </title> <journal> IEEE Transactions on Computers. </journal> <volume> 41 (5): </volume> <pages> 526-531. </pages> <month> May </month> <year> 1992 </year>
Reference-contexts: After receiving a message, a process performs a sequence of deterministic state transitions, some of which may involve sending messages to other processes. The process then attempts to receive another message, and blocks until one is available. nondeterminism <ref> [9, 14] </ref> by treating each nondeterministic influence as a message, logging it and replaying it during recovery. The message logging approach allows states of a process in addition to those saved in a checkpoint to be recovered. <p> Optimistic message logging protocols (e.g., [12, 13, 14, 20, 25, 30]) buffer received messages in volatile storage and log them to stable storage asynchronously in order to avoid blocking the process due to logging. Unlike pessimistic message logging protocols (e.g., <ref> [3, 4, 9, 11, 21] </ref>), optimistic protocols allow a process to receive a message and to continue execution before the message is logged to stable storage.
Reference: [10] <author> C. J. Fidge. </author> <title> Timestamps in Message-Passing Systems That Preserve the Partial Ordering. </title> <booktitle> Eleventh Australian Computer Science Conference. </booktitle> <pages> 56-67. </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: Our Results In this paper, we present a new protocol for optimistic rollback recovery. Much previous work in optimistic recovery has modeled the application program with partial order time, and used the standard technique of timestamp vectors <ref> [10, 18, 30] </ref> to track causal dependency. Our work exploits the insight that the transparent recovery protocol itself is also an asynchronous distributed computation. This recovery computation can also modeled by a partial order but one that differs from the partial order for the user application computation. <p> For example, consider Figure 2; any user state interval D U (at any process) that satisfied B U ! D U and C U ! D U would not be valid. Timestamp Vectors Timestamp vectors <ref> [10, 18] </ref> are a well-known technique for tracking partial order time relations. The timestamp vector for a state interval A consists of, for each process q, the maximal interval at q that precedes or equals A in the partial order.
Reference: [11] <author> D. B. Johnson and W. Zwaenepoel. </author> <title> Sender-Based Message Logging. </title> <booktitle> Seventeenth Annual International Symposium on Fault-Tolerant Computing. </booktitle> <pages> 14-19. </pages> <year> 1987. </year>
Reference-contexts: Optimistic message logging protocols (e.g., [12, 13, 14, 20, 25, 30]) buffer received messages in volatile storage and log them to stable storage asynchronously in order to avoid blocking the process due to logging. Unlike pessimistic message logging protocols (e.g., <ref> [3, 4, 9, 11, 21] </ref>), optimistic protocols allow a process to receive a message and to continue execution before the message is logged to stable storage.
Reference: [12] <author> D. B. Johnson. </author> <title> Distributed System Fault Tolerance Using Message Logging and Checkpointing. </title> <type> Ph.D. thesis, </type> <institution> Rice University, </institution> <year> 1989. </year>
Reference-contexts: Message logging allows each process to be checkpointed less frequently, and may in general reduce failure-free overhead since logging a message is less expensive than recording a checkpoint. Message logging also avoids the need for process synchronization during checkpointing. Optimistic message logging protocols (e.g., <ref> [12, 13, 14, 20, 25, 30] </ref>) buffer received messages in volatile storage and log them to stable storage asynchronously in order to avoid blocking the process due to logging. <p> Johnson and Zwaenepoel <ref> [12, 13] </ref> developed a general model for optimistic rollback recovery. They used state lattices from partial order time to show that a maximal recoverable system state exists, and presented synchronized protocols to recover this state even without reliable message delivery.
Reference: [13] <author> D. B. Johnson and W. Zwaenepoel. </author> <title> Recovery in Distributed Systems Using Optimistic Message Logging and Check-pointing. </title> <journal> Journal of Algorithms. </journal> <volume> 11: </volume> <pages> 462-491. </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: Message logging allows each process to be checkpointed less frequently, and may in general reduce failure-free overhead since logging a message is less expensive than recording a checkpoint. Message logging also avoids the need for process synchronization during checkpointing. Optimistic message logging protocols (e.g., <ref> [12, 13, 14, 20, 25, 30] </ref>) buffer received messages in volatile storage and log them to stable storage asynchronously in order to avoid blocking the process due to logging. <p> log V S to stable storage /* check if p is an orphan */ if V U 6 fl V S then ROLL BACK return (q; M S ) 3 Old logged messages and checkpoints may also be discarded when no longer necessary for recovery from any possible future failure <ref> [13, 30] </ref>. /* process p rolls back to most recent non-orphan */ procedure ROLL BACK /* restore maximal non-orphan user state */ find most recent checkpoint (C; X U ) with X U fl V S discard the checkpoints that follow this one restore the user state to C find first <p> Johnson and Zwaenepoel <ref> [12, 13] </ref> developed a general model for optimistic rollback recovery. They used state lattices from partial order time to show that a maximal recoverable system state exists, and presented synchronized protocols to recover this state even without reliable message delivery.
Reference: [14] <author> D. B. Johnson. </author> <title> Efficient Transparent Optimistic Rollback Recovery for Distributed Application Programs. </title> <booktitle> Twelfth IEEE Symposium on Reliable Distributed Systems. </booktitle> <pages> 86-95. </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: After receiving a message, a process performs a sequence of deterministic state transitions, some of which may involve sending messages to other processes. The process then attempts to receive another message, and blocks until one is available. nondeterminism <ref> [9, 14] </ref> by treating each nondeterministic influence as a message, logging it and replaying it during recovery. The message logging approach allows states of a process in addition to those saved in a checkpoint to be recovered. <p> Message logging allows each process to be checkpointed less frequently, and may in general reduce failure-free overhead since logging a message is less expensive than recording a checkpoint. Message logging also avoids the need for process synchronization during checkpointing. Optimistic message logging protocols (e.g., <ref> [12, 13, 14, 20, 25, 30] </ref>) buffer received messages in volatile storage and log them to stable storage asynchronously in order to avoid blocking the process due to logging.
Reference: [15] <author> R. Koo and S. Toueg. </author> <title> Checkpointing and Rollback-Recovery for Distributed Systems. </title> <journal> IEEE Transactions on Software Engineering. </journal> <volume> 13 (1): </volume> <pages> 23-31. </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: The message logging approach allows states of a process in addition to those saved in a checkpoint to be recovered. Recovery protocols based instead on checkpointing without message logging (e.g., <ref> [1, 5, 6, 7, 8, 15, 16, 17, 31] </ref>) can recover only process states that have been checkpointed, often forcing processes to roll back further than otherwise required after a failure.
Reference: [16] <author> P. Leu and B. Bhargava. </author> <title> Concurrent Robust Checkpointing and Recovery in Distributed Systems. </title> <booktitle> Fourth International Conference on Data Engineering. </booktitle> <pages> 154-163. </pages> <year> 1988. </year>
Reference-contexts: The message logging approach allows states of a process in addition to those saved in a checkpoint to be recovered. Recovery protocols based instead on checkpointing without message logging (e.g., <ref> [1, 5, 6, 7, 8, 15, 16, 17, 31] </ref>) can recover only process states that have been checkpointed, often forcing processes to roll back further than otherwise required after a failure.
Reference: [17] <author> K. Li, J. F. Naughton and J. S. Plank. </author> <title> Real-Time, Concurrent Checkpointing for Parallel Programs. </title> <booktitle> Second ACM SIGPLAN Symposium on Principles and Practices of Parallel Programming. </booktitle> <pages> 79-88. </pages> <year> 1990. </year>
Reference-contexts: The message logging approach allows states of a process in addition to those saved in a checkpoint to be recovered. Recovery protocols based instead on checkpointing without message logging (e.g., <ref> [1, 5, 6, 7, 8, 15, 16, 17, 31] </ref>) can recover only process states that have been checkpointed, often forcing processes to roll back further than otherwise required after a failure. <p> Although optimism thus complicates recovery, optimistic rollback protocols are potentially cheaper during failure-free operation due to their asynchronous operation. By also using asynchronous checkpointing techniques <ref> [8, 17] </ref>, all causes of process blocking due to fault tolerance during failure-free operation may be avoided. 1.3.
Reference: [18] <author> F. Mattern. </author> <title> Virtual Time and Global States of Distributed Systems. </title> <editor> In Cosnard, et al, ed., </editor> <booktitle> Parallel and Distributed Algorithms. </booktitle> <address> Amsterdam: </address> <publisher> North-Holland, </publisher> <year> 1989. </year> <pages> 215-226. </pages>
Reference-contexts: Our Results In this paper, we present a new protocol for optimistic rollback recovery. Much previous work in optimistic recovery has modeled the application program with partial order time, and used the standard technique of timestamp vectors <ref> [10, 18, 30] </ref> to track causal dependency. Our work exploits the insight that the transparent recovery protocol itself is also an asynchronous distributed computation. This recovery computation can also modeled by a partial order but one that differs from the partial order for the user application computation. <p> For example, consider Figure 2; any user state interval D U (at any process) that satisfied B U ! D U and C U ! D U would not be valid. Timestamp Vectors Timestamp vectors <ref> [10, 18] </ref> are a well-known technique for tracking partial order time relations. The timestamp vector for a state interval A consists of, for each process q, the maximal interval at q that precedes or equals A in the partial order.
Reference: [19] <author> P. M. Merlin and B. Randell. </author> <title> State Restoration in Distributed Systems. </title> <booktitle> International Symposium on Fault-Tolerant Computing. </booktitle> <month> June </month> <year> 1978. </year>
Reference-contexts: These false negatives make it possible for a single failure at one process to cause another process to roll back an 5 In some sense, Merlin and Randell <ref> [19] </ref> foreshadowedStrom and Yemini's work by presenting a protocol based on a representation similar to Petri Nets; this protocol could be transformed and optimized into one similar to Strom and Yemini's. exponential number of times, since the unfortunate process never rolls back far enough (until the last time).
Reference: [20] <author> S. L. Peterson and P. Kearns. </author> <title> Rollback Based on Vector Time. </title> <booktitle> Twelfth IEEE Symposium on Reliable Distributed Systems. </booktitle> <pages> 68-77. </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: Message logging allows each process to be checkpointed less frequently, and may in general reduce failure-free overhead since logging a message is less expensive than recording a checkpoint. Message logging also avoids the need for process synchronization during checkpointing. Optimistic message logging protocols (e.g., <ref> [12, 13, 14, 20, 25, 30] </ref>) buffer received messages in volatile storage and log them to stable storage asynchronously in order to avoid blocking the process due to logging. <p> Sistla and Welch [25] presented two protocols for optimistic recovery that avoid the exponential worst case by using synchronization between processes during recovery; like Strom and Yemini, Sistla and Welch require reliable FIFO message channels. Peterson and Kearns <ref> [20] </ref> recently presented a recovery protocol using vector clocks that synchronizes during recovery by passing tokens. However, we improve even on the explicit vector time work of Peter-son and Kearns by truly using the full power of temporal abstraction.
Reference: [21] <author> M. L. Powell and D. L. Presotto. </author> <title> Publishing: A Reliable Broadcast Communication Mechanism. </title> <booktitle> Ninth ACM Symposium on Operating Systems Principles. </booktitle> <pages> 100-109. </pages> <year> 1983. </year>
Reference-contexts: Optimistic message logging protocols (e.g., [12, 13, 14, 20, 25, 30]) buffer received messages in volatile storage and log them to stable storage asynchronously in order to avoid blocking the process due to logging. Unlike pessimistic message logging protocols (e.g., <ref> [3, 4, 9, 11, 21] </ref>), optimistic protocols allow a process to receive a message and to continue execution before the message is logged to stable storage.
Reference: [22] <author> B. Randell. </author> <title> System Structure for Fault Tolerance. </title> <journal> IEEE Transactions on Software Engineering. </journal> <volume> SE-1: </volume> <pages> 220-232, </pages> <year> 1975. </year>
Reference-contexts: rollback, such as the number of surviving processes that must roll back, the number of times each process must roll back, or the amount of rolled-back computation beyond that which causally depends on the computation lost due the failure; an extreme case of such wasted computation is the domino effect <ref> [22, 24] </ref>. A third desirable property is minimizing the overhead incurred by the protocol, both during failure-free execution and during recovery. During failure-free execution, synchronization between processes slows down the application program; during recovery, synchronization between processes slows down recovery and may prevent recovery from concurrent failures from proceeding concurrently.
Reference: [23] <author> M. Reiter and L. Gong. </author> <title> Preventing Denial and Forgery of Causal Relationships in Distributed Systems. </title> <booktitle> IEEE Symposium on Research in Security and Privacy. </booktitle> <year> 1993. </year>
Reference-contexts: the protocol restores the maximum recoverable system state. (In particular, two processes that each need to roll back due to two failures do not need to react to the failures in the same order.) This protocol arose out of research into the security and privacy aspects of partial order time <ref> [28, 23] </ref>. Coupling this protocol with a fully secure implementation of partial order clocks [29] would yield a recovery protocol that tolerates not only faults, but also malicious acts of espionage and sabotage. 5. Comparison to Related Work Strom and Yemini [30] initiated the area of optimistic rollback recovery.
Reference: [24] <author> D. L. Russell. </author> <title> State Restoration in Systems of Communicating Processes. </title> <journal> IEEE Transactions on Software Engineering. </journal> <volume> 6 (2): </volume> <pages> 183-194. </pages> <month> March </month> <year> 1980. </year>
Reference-contexts: rollback, such as the number of surviving processes that must roll back, the number of times each process must roll back, or the amount of rolled-back computation beyond that which causally depends on the computation lost due the failure; an extreme case of such wasted computation is the domino effect <ref> [22, 24] </ref>. A third desirable property is minimizing the overhead incurred by the protocol, both during failure-free execution and during recovery. During failure-free execution, synchronization between processes slows down the application program; during recovery, synchronization between processes slows down recovery and may prevent recovery from concurrent failures from proceeding concurrently.
Reference: [25] <author> A. P. Sistla and J. L. Welch. </author> <title> Efficient Distributed Recovery Using Message Logging. </title> <booktitle> Eighth ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> 223-238. </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: Message logging allows each process to be checkpointed less frequently, and may in general reduce failure-free overhead since logging a message is less expensive than recording a checkpoint. Message logging also avoids the need for process synchronization during checkpointing. Optimistic message logging protocols (e.g., <ref> [12, 13, 14, 20, 25, 30] </ref>) buffer received messages in volatile storage and log them to stable storage asynchronously in order to avoid blocking the process due to logging. <p> Figure 1 shows a simple scenario in which process r rolls back twice in response to a single failure at process p. Sistla and Welch <ref> [25] </ref> claim an upper bound of O (2 n ) rollbacks in the worst case for the Strom and Yemini protocol, where n is the number of processes in the system. <p> Johnson and Zwaenepoel [12, 13] developed a general model for optimistic rollback recovery. They used state lattices from partial order time to show that a maximal recoverable system state exists, and presented synchronized protocols to recover this state even without reliable message delivery. Sistla and Welch <ref> [25] </ref> presented two protocols for optimistic recovery that avoid the exponential worst case by using synchronization between processes during recovery; like Strom and Yemini, Sistla and Welch require reliable FIFO message channels.
Reference: [26] <author> S. W. Smith. </author> <title> A Theory of Distributed Time. </title> <institution> Computer Science Technical Report CMU-CS-93-231, Carnegie Mellon University. </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: Consequently, D S ! B S , and hence KNOWABLE ORPHAN (A U ; B S ). 3. The Protocol Our protocol tests for orphans by comparing timestamp vectors across two levels of partial order time <ref> [26, 27] </ref>. Section 3.1 presents our protocol in terms of system and user state interval indices, functions to compare them, and functions to generate new indices. Section 3.2 presents some approaches to implementing these functions. 3.1.
Reference: [27] <author> S. W. Smith. </author> <title> Secure Distributed Time for Secure Distributed Protocols. </title> <type> Ph.D. thesis. </type> <institution> Computer Science Technical Report CMU-CS-94-177, Carnegie Mellon University. </institution> <month> September </month> <year> 1994. </year>
Reference-contexts: Sistla and Welch [25] claim an upper bound of O (2 n ) rollbacks in the worst case for the Strom and Yemini protocol, where n is the number of processes in the system. In <ref> [27] </ref>, we construct an explicit example showing 2 n 1 rollbacks, and thus establish a tight bound Q (2 n ) for the worst case. 1.4. Our Results In this paper, we present a new protocol for optimistic rollback recovery. <p> Consequently, D S ! B S , and hence KNOWABLE ORPHAN (A U ; B S ). 3. The Protocol Our protocol tests for orphans by comparing timestamp vectors across two levels of partial order time <ref> [26, 27] </ref>. Section 3.1 presents our protocol in terms of system and user state interval indices, functions to compare them, and functions to generate new indices. Section 3.2 presents some approaches to implementing these functions. 3.1.
Reference: [28] <author> S. W. Smith and J. D. Tygar. </author> <title> Signed Vector Timestamps: A Secure Protocol for Partial Order Time. </title> <institution> Computer Science Technical Report CMU-CS-93-116, Carnegie Mellon University. </institution> <note> October 1991; version of February 1993. </note>
Reference-contexts: the protocol restores the maximum recoverable system state. (In particular, two processes that each need to roll back due to two failures do not need to react to the failures in the same order.) This protocol arose out of research into the security and privacy aspects of partial order time <ref> [28, 23] </ref>. Coupling this protocol with a fully secure implementation of partial order clocks [29] would yield a recovery protocol that tolerates not only faults, but also malicious acts of espionage and sabotage. 5. Comparison to Related Work Strom and Yemini [30] initiated the area of optimistic rollback recovery.
Reference: [29] <author> S. W. Smith and J. D. Tygar. </author> <title> Security and Privacy for Partial Order Time. </title> <booktitle> Seventh ISCA International Conference on Parallel and Distributed Computing Systems. </booktitle> <month> October </month> <year> 1994. </year>
Reference-contexts: Coupling this protocol with a fully secure implementation of partial order clocks <ref> [29] </ref> would yield a recovery protocol that tolerates not only faults, but also malicious acts of espionage and sabotage. 5. Comparison to Related Work Strom and Yemini [30] initiated the area of optimistic rollback recovery.
Reference: [30] <author> R. Strom and S. Yemini. </author> <title> Optimistic Recovery in Distributed Systems. </title> <journal> ACM Transactions on Computer Systems. </journal> <volume> 3: </volume> <pages> 204-226. </pages> <month> August </month> <year> 1985. </year>
Reference-contexts: A process may recover to any past state by restarting from an earlier checkpoint and then replaying from the log the sequence of messages it originally received after that checkpoint. Message logging assumes that the execution of each process is piecewise deterministic 1 <ref> [30] </ref> This scheme can also be extended to handle some 1 That is, execution between successive received messages is completely determined by the process state before the first of these messages is received and by contents of that message. <p> Message logging allows each process to be checkpointed less frequently, and may in general reduce failure-free overhead since logging a message is less expensive than recording a checkpoint. Message logging also avoids the need for process synchronization during checkpointing. Optimistic message logging protocols (e.g., <ref> [12, 13, 14, 20, 25, 30] </ref>) buffer received messages in volatile storage and log them to stable storage asynchronously in order to avoid blocking the process due to logging. <p> Strom and Yemini <ref> [30] </ref> initiated the area of optimistic rollback recovery and presented the most asynchronous protocol prior to the completely asynchronous protocol that we present in this paper. In the Strom and Yemini protocol, processes use timestamp vectors to track dependency. <p> Our Results In this paper, we present a new protocol for optimistic rollback recovery. Much previous work in optimistic recovery has modeled the application program with partial order time, and used the standard technique of timestamp vectors <ref> [10, 18, 30] </ref> to track causal dependency. Our work exploits the insight that the transparent recovery protocol itself is also an asynchronous distributed computation. This recovery computation can also modeled by a partial order but one that differs from the partial order for the user application computation. <p> log V S to stable storage /* check if p is an orphan */ if V U 6 fl V S then ROLL BACK return (q; M S ) 3 Old logged messages and checkpoints may also be discarded when no longer necessary for recovery from any possible future failure <ref> [13, 30] </ref>. /* process p rolls back to most recent non-orphan */ procedure ROLL BACK /* restore maximal non-orphan user state */ find most recent checkpoint (C; X U ) with X U fl V S discard the checkpoints that follow this one restore the user state to C find first <p> System Indices The system state interval indices should reflect the timeline structure of the system state intervals, but must also take into account the fact that a failed process may lose all state. The system index should also indicate the index of the corresponding user state interval. Following <ref> [30] </ref>, we say that each rollback of a process begins a new incarnation of that process. We represent the index for system state interval A S as a triple (k; m; A U ). <p> Coupling this protocol with a fully secure implementation of partial order clocks [29] would yield a recovery protocol that tolerates not only faults, but also malicious acts of espionage and sabotage. 5. Comparison to Related Work Strom and Yemini <ref> [30] </ref> initiated the area of optimistic rollback recovery. They presented optimistic techniques for surviving processes to ensure complete recoverability, and a rollback protocol 5 that allows processes to recover mostly asynchronously, although delayed transmission of incarnation start information may cause blocking.
Reference: [31] <author> Y.-M. Wang and W. K. Fuchs. </author> <title> Lazy Checkpoint Coordination for Bounding Rollback Propagation. </title> <booktitle> Twelfth IEEE Symposium on Reliable Distributed Systems. </booktitle> <pages> 78-85. </pages> <month> Octo-ber </month> <year> 1993. </year>
Reference-contexts: The message logging approach allows states of a process in addition to those saved in a checkpoint to be recovered. Recovery protocols based instead on checkpointing without message logging (e.g., <ref> [1, 5, 6, 7, 8, 15, 16, 17, 31] </ref>) can recover only process states that have been checkpointed, often forcing processes to roll back further than otherwise required after a failure.
References-found: 31

