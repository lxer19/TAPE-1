URL: ftp://ftp.cs.utexas.edu/pub/predator/adage-arch.ps
Refering-URL: http://www.cs.utexas.edu/users/schwartz/pub.htm
Root-URL: 
Title: Abstract ADAGE is a project to define and build a domain-specific software architecture (DSSA) environment
Abstract: In this paper, we present the ADAGE component-based model (or reference architecture) for avionics software synthesis. We explain the modeling procedures used, review our initial goals, show how component reuse is achieved, and examine what we were (and were not) able to accomplish. The contributions of our paper are the avionics reference architecture and the lessons that we learned; both may be beneficial to others in future modeling efforts. 
Abstract-found: 1
Intro-found: 1
Reference: [Ara93] <author> Guillermo Arango. </author> <title> Domain analysis methods. In Software Reusability, </title> <editor> W. Schafer and R.Prieto-Diaz, editors, </editor> <publisher> Ellis Horwood Publishers, </publisher> <year> 1993. </year>
Reference-contexts: A product of domain analysis, called a reference architecture, is a blueprint for an avionics software system generator. A critical step in creating a DSSA is the definition of a reference architecture. Domain analysis techniques are still immature <ref> [Ara93, War92] </ref>; there are no commonly accepted modeling processes or meta-modeling constructs that are used to define reference architectures. Of critical importance is that whatever constructs or processes are chosen must be domain-independent; repeatability across multiple domains is an essential requirement of a successful DSSA methodology.
Reference: [Bat88] <author> D. Batory, </author> <title> Concepts for a Database System Synthesizer, </title> <booktitle> Proc. ACM Principles of Database Systems, </booktitle> <year> 1988. </year>
Reference-contexts: Overall, we feel this decomposition approach worked quite well. Exemplar systems. Reference architecture modeling requires access to information on multiple systems in a domain in order to discern their similarities and differences. In previous modeling efforts, over ten different systems were analyzed in creating a reference architecture <ref> [Bat88] </ref>. We faced a different situation where we had access to detailed knowledge on only two, but very different, avionics systems: a special operations helicopter and a fixed-wing transport. The lack of exemplar systems was offset by a considerable expertise at Loral Federal Systems Company on avionics software sys tems. <p> Dont look at code. Our domain model concentrated on components and their compositions. There is nothing in our model that addressed the internal construction/organization of a components software. From our experience in building and validating several reference architectures <ref> [Bat88, Sir93, Bat93b-94] </ref>, we know that the similarity of components within a realm is considerable. Exploiting this similarity is important in creating a software system generator.
Reference: [Bat92a] <author> D. Batory and S. OMalley, </author> <title> The Design and Implementation of Hierarchical Software Systems with Reusable Components, </title> <journal> ACM Trans. Software Engineering and Methodology, </journal> <month> October </month> <year> 1992. </year>
Reference-contexts: Of critical importance is that whatever constructs or processes are chosen must be domain-independent; repeatability across multiple domains is an essential requirement of a successful DSSA methodology. We have chosen to develop the ADAGE reference architecture in terms of the GenVoca model <ref> [Bat92a] </ref>. This model is suited for software system generation; it relies on a particular style of organizing hierarchical software systems in terms of standardized sets of parameterized, plug-compatible, and reusable layers called components. Using components and rules for their composition, large families of software systems can be defined. <p> To explain how components fit together to form scalable avionics systems and subsystems. 3. To explain variations in avionics software as dif ferent combinations of components. 4. To outline features of a plausible avionics system generator (i.e., factory). The GenVoca model <ref> [Bat92a] </ref> was instrumental in formulating our reference architecture (points #1-#3). This model, which we review in the next section, relies on hierarchical decompositions of avionics software systems into layers that import and export standardized interfaces. <p> GenVoca is the distillation of the designs of two independently-conceived software system generators for the domains of databases and communications protocols <ref> [Bat92a] </ref>. Other recent software system generators, such as Ficus (distributed file systems [Hei90]), Predator (data structures [Sir93, Bat93b-94]), and Starburst (database systems [Haa90]), can also be recognized as examples of Gen-Voca organizations.
Reference: [Bat92b] <author> D. Batory and J. Barnett, DaTE: </author> <title> The Genesis DBMS Software Layout Editor, in Conceptual Modeling, Databases, and CASE: An Integrated View of Information Systems Development, </title> <editor> P. Loucopoulos and R. Zicari, editors, </editor> <publisher> Wiley, </publisher> <year> 1992. </year>
Reference-contexts: Additional domain-specific constraints called design rules are needed to preclude illegal component combinations. Attribute grammars appear to be a unifying formalism that can be used to define realms, their components, and design rules <ref> [Bat92b, McA93, Bat95] </ref>. Symmetry. Just as recursion is fundamental to grammars, recursion in the form of symmetric components is fundamental to GenVoca. Symmetric components have the unusual property that they can be composed in arbitrary ways.
Reference: [Bat93a] <author> D. Batory and S. Shafer, </author> <title> A Domain Model for Avionics Software, </title> <journal> IBM Owego T.R. </journal> <volume> ADAGE-UT-93-03, </volume> <month> May </month> <year> 1993. </year>
Reference-contexts: In the following sections, we explain a portion of the model that we have developed. The full model is discussed in <ref> [Bat93a] </ref>. Here, we concentrate on explaining how specific features and designs of avionics software can be expressed in terms of components and type equations.
Reference: [Bat93b] <author> D. Batory, V. Singhal, M. Sirkin, and J. Thomas, </author> <title> Scalable Software Libraries, </title> <booktitle> Proceedings of ACM SIGSOFT 1993. </booktitle>
Reference: [Bat94] <author> D. Batory, J. Thomas, and M. Sirkin, </author> <title> Reengineering a Complex Application Using a Scalable Data Structure Compiler, </title> <booktitle> Proceedings of ACM SIGSOFT 1994. </booktitle>
Reference: [Bat95] <author> D. Batory and B. Geraci, </author> <title> Validating Component Compositions in Software System Generators, </title> <institution> Dept. Computer Sciences, University of Texas at Austin, TR-95-03. </institution>
Reference-contexts: Additional domain-specific constraints called design rules are needed to preclude illegal component combinations. Attribute grammars appear to be a unifying formalism that can be used to define realms, their components, and design rules <ref> [Bat92b, McA93, Bat95] </ref>. Symmetry. Just as recursion is fundamental to grammars, recursion in the form of symmetric components is fundamental to GenVoca. Symmetric components have the unusual property that they can be composed in arbitrary ways.
Reference: [Bri81] <author> K.H. Britton, R.A. Parker, and D.L. </author> <note> Parnas, </note>
Reference-contexts: Instead, proposing a standard virtual machine interface for all adc sensors, another interface for all gps sensors, etc. was much easier and more readily acceptable by avionics engineers <ref> [Bri81] </ref>. This decision led to a realm of components for each distinct DSO type. <p> Interface design. During the initial phases of modeling, it is sufficient to know approximately what operations would define a virtual machine interface (and that system engineers are confident that a standard could be realized). Defining a standardized virtual machine requires building lots of components for that particular realm <ref> [Bri81] </ref>. Each time a new component is added, the standard may evolve to accommodate its particular features (without exposing implementation detail). Time and experience will eventually lead to a steady-state virtual machine interface for that realm.
References-found: 9

