URL: ftp://ftp.cs.caltech.edu/tr/cs-tr-95-13.ps.Z
Refering-URL: ftp://ftp.cs.caltech.edu/tr/INDEX.html
Root-URL: http://www.cs.caltech.edu
Title: A Practical Approach to Dynamic Load Balancing  
Author: Jerrell Watts 
Degree: In Partial Fulfillment of the Requirements for the Degree of Master of Science  
Date: October 4, 1995  
Address: Pasadena, California 91125  
Affiliation: Scalable Concurrent Programming Laboratory California Institute of Technology  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> W. Ames. </author> <title> Numerical Methods for Partial Differential Equations. </title> <publisher> 3rd ed., Academic Press, </publisher> <year> 1992. </year>
Reference-contexts: METHODOLOGY Derivation. The heat equation in three dimensions is: u t = r 2 u = u xx + u yy + u zz (2.1) A common method of solving (2.1) is by using finite differencing schemes <ref> [1, 4, 23, 34] </ref>. Let ffi 2 x denote the discrete Laplacian operator in the x dimension: ffi 2 Define ffi 2 y and ffi 2 z similarly. Since the spatial discretization is arbitrary, take it to be one. <p> This leaves: ff (n+1) (n+1) ff (n) (n) Proof of Consistency, Stability and Convergence. The consistency of the Crank-Nicholson differencing scheme is demonstrated in the following derivation, modified from that of von Neu mann <ref> [1] </ref>: (u xx + u yy + u zz ) j n+1=2 = 2 = 2 x + ffi 2 z )(u i;j;k + u i;j;k ) = ff (n+1) (n) 12 CHAPTER 2. METHODOLOGY Rearranging (2.11) gives us the familiar form in (2.4) above. <p> As shown in equation (2.6), the Crank-Nicholson scheme is equivalent to the repeated multiplication of the original vector u (0) by the matrix A 1 B. If the eigenvalues of A 1 B are all less than one in absolute value, then the iteration (2.6) is stable <ref> [1, 11] </ref>. The proof of upper bound on these eigenvalues for the three-dimensional case follows in a manner similar to that for the one-dimensional case given in [1]. <p> If the eigenvalues of A 1 B are all less than one in absolute value, then the iteration (2.6) is stable [1, 11]. The proof of upper bound on these eigenvalues for the three-dimensional case follows in a manner similar to that for the one-dimensional case given in <ref> [1] </ref>. First, note that A and B can be rewritten as follows: A = I + ffC (2.12) where C is a matrix with 3's along the diagonal and six off-diagonal 1 2 's in each row/column. Let represent an eigenvalue of A 1 B, and x the corresponding eigenvector. <p> Hence, the method is stable. Given that the Crank-Nicholson differencing scheme (2.4) is consistent and stable, then it is also convergent, by the Lax equivalence theorem <ref> [1] </ref>. 2.3. WORK TRANSFER VECTOR CALCULATION 13 2.3.2 Gradient Methods Gradient load balancing methods have been explored extensively in the literature [20, 22, 32].
Reference: [2] <author> S. Barnard and H. Simon. </author> <title> A Fast Multilevel Implementation of Recursive Spectral Bisection for Partitioning Unstructured Problems. </title> <journal> Concurrency: Pract. and Exp., </journal> <volume> 6 </volume> <pages> 101-117, </pages> <year> 1994. </year>
Reference-contexts: METHODOLOGY formance under certain circumstances. Recursive Bisection Methods. Recursive bisection methods operate by recursively partitioning the problem domain to achieve load balance and to reduce communication costs. Most presentations of these techniques appear in the context of static load balancing <ref> [2, 33] </ref>, although formulations appropriate for dynamic domain repartitioning do exist [30, 31]. While many methods exist for repartitioning a computation, including various geometrically based techniques, the most interesting methods utilize the spectral properties of a matrix encapsulating the adjacency in the computation.
Reference: [3] <author> R. Blufome, et al.. Cilk: </author> <title> An Efficient Multithreaded Runtime System. </title> <booktitle> Proc. Fifth ACM SIGPLAN Sym. on Princ. & Pract. of Parallel Prog., </booktitle> <pages> pp. 207-216, </pages> <publisher> ACM Press, </publisher> <year> 1995. </year>
Reference-contexts: Cilk provides a multithreaded environment with integrated load balancing <ref> [3] </ref>. In many respects, the programming model is similar to that in MDC and the Graph Library. Because of 45 46 CHAPTER 5. ALTERNATIVE METHODOLOGIES certain design decisions, it is best applied to tree-structured computations, however, and does not fit the SPMD style typical of scientific applications.
Reference: [4] <author> G. Carrier and C. Pearson. </author> <title> Partial Differential Equations: Theory and Technique. 2nd ed., </title> <publisher> Academic Press, </publisher> <year> 1988. </year>
Reference-contexts: METHODOLOGY Derivation. The heat equation in three dimensions is: u t = r 2 u = u xx + u yy + u zz (2.1) A common method of solving (2.1) is by using finite differencing schemes <ref> [1, 4, 23, 34] </ref>. Let ffi 2 x denote the discrete Laplacian operator in the x dimension: ffi 2 Define ffi 2 y and ffi 2 z similarly. Since the spatial discretization is arbitrary, take it to be one.
Reference: [5] <author> J. Casas, et. al.. </author> <title> Adaptive Load Migration Systems for PVM. </title> <booktitle> Proc. of Supercomputing `94, </booktitle> <pages> pp. 390-399, </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1994. </year>
Reference-contexts: Unfortunately, the programming models supported by both of these libraries have severe limitations with regard to providing a reasonable framework for adaption and load balancing. PVM provides facilities for task creation and destruction and can be augmented to support task movement and load leveling <ref> [5] </ref>. These capabilities are implemented via a task identifier which abstracts the mapping of tasks to computers. Because PVM does not incorporate the idea of a communication graph, the library cannot easily determine the extent to which information regarding task creation, destruction and movement must be propagated.
Reference: [6] <author> T. Cormen, C. Leiserson and R. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> MIT Press/MacGraw-Hill, </publisher> <year> 1990. </year>
Reference-contexts: If only a few tasks are located at each computer, exchanges will likely be necessary when the transfer vectors are small. 2.4.2 Task Selection Algorithms The problem of selecting which tasks to move is NP-complete, since it is simply the subset sum problem <ref> [6] </ref>. Thus, exhaustive searches are necessary to decide the optimal solution, but much cheaper approximation algorithms can often be used to great efficacy. In general, exhaustive searches offer a large benefit only when the number of tasks is relatively small (less than 10 per computer). <p> This algorithm requires O (M N ) time, where M is the number of tasks on the computer from which work is being transferred, and N is the number of tasks on the computer to which work is being transferred. Subset Trimming. The authors of <ref> [6] </ref> present a polynomial time approximation algorithm for the subset sum problem. As given, the method can only be applied to one-way transfers and not exchanges. Essentially what the algorithm does is build up a list of possible candidates for 16 CHAPTER 2.
Reference: [7] <author> G. Cybenko. </author> <title> Dynamic Load Balancing for Distributed Memory Multiprocessors. </title> <journal> J. Parallel and Distributed Comp., </journal> <volume> 7 </volume> <pages> 279-301, </pages> <year> 1989. </year>
Reference-contexts: Diffusion was first presented as a method for load balancing in <ref> [7] </ref>. This work had certain limitations, as pointed out in [13]. Diffusion was also explored in [32] and was found to be superior to other load balancing strategies. A more general diffusive strategy is given in [13, 14]. <p> Most of the load balancing work in the literature considers only the subproblem that is defined as work transfer vector calculation in this thesis, ignoring the other issues such as load measurement and task selection. Such work includes gradient methods [20, 22], hierarchical algorithms [16] and early diffusive techniques <ref> [7] </ref>. Techniques appropriate to specific problem regimes include recursive bisection algorithms [30, 31, 33] and particle simulation methods [9, 19].
Reference: [8] <author> D. Evans and W. Butt. </author> <title> Dynamic Load Balancing Using Task-Transfer Probabilities. </title> <journal> Parallel Comp., </journal> <volume> 19 </volume> <pages> 897-916, </pages> <year> 1993. </year>
Reference-contexts: Techniques appropriate to specific problem regimes include recursive bisection algorithms [30, 31, 33] and particle simulation methods [9, 19]. Other task-based approaches to load balancing include a scalable task pool [15], a heuristic for transferring tasks between computers based on probability vectors <ref> [8] </ref> and a scalable, iterative bidding model [27]. All of these techniques make assumptions, such as that of complete task independence or task load uniformity, that are not applicable in the context of this thesis.
Reference: [9] <author> R. Ferraro, P. Liewer and V. Decyk. </author> <title> Dynamic Load Balancing for a 2D Concurrent Plasma PIC Code. </title> <type> Technical Report, </type> <institution> Center for Research on Parallel Computing, CRPC-91-6, </institution> <year> 1991. </year>
Reference-contexts: The combination of these limitations makes such techniques unsuitable for use in a general purpose load balancing framework. Strip Methods. Heuristics for load balancing particle simulations (relevant to this thesis because of the two applications targeted in Chapter 4) are presented in <ref> [9, 19] </ref>. Both of these methods partition the physical problem domain in one dimension, then dynamically adjust the partition boundaries to track changes in particle density. The algorithm in [9] uses a global particle count to determine how many particles each computer should have for good load balance. <p> Both of these methods partition the physical problem domain in one dimension, then dynamically adjust the partition boundaries to track changes in particle density. The algorithm in <ref> [9] </ref> uses a global particle count to determine how many particles each computer should have for good load balance. In some sense, the algorithm is little different from the hierarchical methods presented above. In [19], a method which very coarsely approximates diffusion is used. <p> Such work includes gradient methods [20, 22], hierarchical algorithms [16] and early diffusive techniques [7]. Techniques appropriate to specific problem regimes include recursive bisection algorithms [30, 31, 33] and particle simulation methods <ref> [9, 19] </ref>. Other task-based approaches to load balancing include a scalable task pool [15], a heuristic for transferring tasks between computers based on probability vectors [8] and a scalable, iterative bidding model [27].
Reference: [10] <author> A. Geist, et al.. </author> <title> PVM: Parallel Virtual Machine. </title> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: The Graph Library eliminates the explicit mapping of work to processors found in prevalent concurrent programming systems such as PVM and MPI <ref> [10, 12] </ref>. 1 Under the Graph Library, the computational entities are called nodes, which can be thought of as contexts of execution. Low-latency remote procedure calls (RPC's) are made over unidirectional channels from one node to another. <p> Recall that alternatives to the components of the final algorithm have already been discussed in detail in Chapter 2. Two message passing libraries that provide levels of portability similar to the Graph Library are the Parallel Virtual Machine (PVM) and the Message Passing Interface (MPI) <ref> [10, 12] </ref>. Unfortunately, the programming models supported by both of these libraries have severe limitations with regard to providing a reasonable framework for adaption and load balancing. PVM provides facilities for task creation and destruction and can be augmented to support task movement and load leveling [5].
Reference: [11] <author> G. Golub and C. Van Loan. </author> <title> Matrix Computations. 2nd ed., </title> <publisher> The Johns Hopkins University Press, </publisher> <year> 1989. </year>
Reference-contexts: As shown in equation (2.6), the Crank-Nicholson scheme is equivalent to the repeated multiplication of the original vector u (0) by the matrix A 1 B. If the eigenvalues of A 1 B are all less than one in absolute value, then the iteration (2.6) is stable <ref> [1, 11] </ref>. The proof of upper bound on these eigenvalues for the three-dimensional case follows in a manner similar to that for the one-dimensional case given in [1].
Reference: [12] <author> W. Gropp, E. Lusk and A. Skjellum. </author> <title> Using MPI. </title> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: The Graph Library eliminates the explicit mapping of work to processors found in prevalent concurrent programming systems such as PVM and MPI <ref> [10, 12] </ref>. 1 Under the Graph Library, the computational entities are called nodes, which can be thought of as contexts of execution. Low-latency remote procedure calls (RPC's) are made over unidirectional channels from one node to another. <p> Recall that alternatives to the components of the final algorithm have already been discussed in detail in Chapter 2. Two message passing libraries that provide levels of portability similar to the Graph Library are the Parallel Virtual Machine (PVM) and the Message Passing Interface (MPI) <ref> [10, 12] </ref>. Unfortunately, the programming models supported by both of these libraries have severe limitations with regard to providing a reasonable framework for adaption and load balancing. PVM provides facilities for task creation and destruction and can be augmented to support task movement and load leveling [5].
Reference: [13] <author> A. Heirich. </author> <title> Scalable Load Balancing by Diffusion. </title> <type> Masters Thesis, </type> <institution> Caltech Computer Science Department, Caltech-CS-TR-94-04, </institution> <year> 1994. </year> <note> 49 50 BIBLIOGRAPHY </note>
Reference-contexts: The strategies used in this thesis can be applied to everything from highly synchronous physics simulations, where load evolves in a relatively smooth manner, to highly asynchronous transaction processing systems and operating systems, where load injection occurs randomly <ref> [13, 14] </ref>. 1.2 Problem Statement The abstract goal of load balancing can be stated as follows: Given a collection of tasks comprising a computation and a set of computers on which these tasks may be executed, find the mapping of tasks to computers that results in each computer having an approximately <p> Diffusion was first presented as a method for load balancing in [7]. This work had certain limitations, as pointed out in <ref> [13] </ref>. Diffusion was also explored in [32] and was found to be superior to other load balancing strategies. A more general diffusive strategy is given in [13, 14]. This method uses a fully implicit differencing scheme to solve the heat equation on a multi-dimensional mesh to a specified accuracy. Algorithm. <p> Diffusion was first presented as a method for load balancing in [7]. This work had certain limitations, as pointed out in [13]. Diffusion was also explored in [32] and was found to be superior to other load balancing strategies. A more general diffusive strategy is given in <ref> [13, 14] </ref>. This method uses a fully implicit differencing scheme to solve the heat equation on a multi-dimensional mesh to a specified accuracy. Algorithm. The basic diffusion algorithm presented in [13, 14] is given in Figure 2.2. <p> A more general diffusive strategy is given in <ref> [13, 14] </ref>. This method uses a fully implicit differencing scheme to solve the heat equation on a multi-dimensional mesh to a specified accuracy. Algorithm. The basic diffusion algorithm presented in [13, 14] is given in Figure 2.2. This method has a number of weaknesses in terms of its compatibility with the methodology of this thesis as well as its performance relative to the desired accuracy. <p> The disadvantage is that (2.3) involves the solution of a system of equations. This task can be accomplished via a Jacobi iteration, as was done in Algorithm 1. As shown in <ref> [13, 14] </ref>, the number of iterations required is bounded by a small constant. Unfortunately, the temporal discretization error in (2.3) is O (ff) (i.e., the scheme is first order accurate in time).
Reference: [14] <author> A. Heirich and S. Taylor. </author> <title> A Parabolic Load Balancing Algorithm. </title> <type> Technical Report, </type> <institution> Cal-tech Computer Science Department, Caltech-CS-TR-94-13, </institution> <year> 1994. </year>
Reference-contexts: The strategies used in this thesis can be applied to everything from highly synchronous physics simulations, where load evolves in a relatively smooth manner, to highly asynchronous transaction processing systems and operating systems, where load injection occurs randomly <ref> [13, 14] </ref>. 1.2 Problem Statement The abstract goal of load balancing can be stated as follows: Given a collection of tasks comprising a computation and a set of computers on which these tasks may be executed, find the mapping of tasks to computers that results in each computer having an approximately <p> Diffusion was first presented as a method for load balancing in [7]. This work had certain limitations, as pointed out in [13]. Diffusion was also explored in [32] and was found to be superior to other load balancing strategies. A more general diffusive strategy is given in <ref> [13, 14] </ref>. This method uses a fully implicit differencing scheme to solve the heat equation on a multi-dimensional mesh to a specified accuracy. Algorithm. The basic diffusion algorithm presented in [13, 14] is given in Figure 2.2. <p> A more general diffusive strategy is given in <ref> [13, 14] </ref>. This method uses a fully implicit differencing scheme to solve the heat equation on a multi-dimensional mesh to a specified accuracy. Algorithm. The basic diffusion algorithm presented in [13, 14] is given in Figure 2.2. This method has a number of weaknesses in terms of its compatibility with the methodology of this thesis as well as its performance relative to the desired accuracy. <p> The disadvantage is that (2.3) involves the solution of a system of equations. This task can be accomplished via a Jacobi iteration, as was done in Algorithm 1. As shown in <ref> [13, 14] </ref>, the number of iterations required is bounded by a small constant. Unfortunately, the temporal discretization error in (2.3) is O (ff) (i.e., the scheme is first order accurate in time).
Reference: [15] <author> H. Hofstee, J. Lukkien and J. van de Snepscheut. </author> <title> A Distributed Implementation of a Task Pool. Research Directions in High Level Parallel Progamming Languages, </title> <editor> J. Banatre and D. Le Metayer, eds., </editor> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Such work includes gradient methods [20, 22], hierarchical algorithms [16] and early diffusive techniques [7]. Techniques appropriate to specific problem regimes include recursive bisection algorithms [30, 31, 33] and particle simulation methods [9, 19]. Other task-based approaches to load balancing include a scalable task pool <ref> [15] </ref>, a heuristic for transferring tasks between computers based on probability vectors [8] and a scalable, iterative bidding model [27]. All of these techniques make assumptions, such as that of complete task independence or task load uniformity, that are not applicable in the context of this thesis.
Reference: [16] <author> G. Horton. </author> <title> A Multi-Level Diffusion Method for Dynamic Load Balancing. </title> <journal> Parallel Comp., </journal> <volume> 19 </volume> <pages> 209-218, </pages> <year> 1993. </year>
Reference-contexts: These groups are then recursively divided and load balanced. (The loads of the groups at each level are first determined by having the computers group themselves recursively, summing the total loads of the subgroups to get the load of the new group they comprise.) Hierarchical techniques are explored in <ref> [16, 32] </ref>. 2 The hierarchical method does achieve effective load balance, and it does so in a number of steps logarithmic in the number of computers. However, the algorithm inherently neglects to attempt to minimize the distance and volume of work transferred to achieve load balance. <p> While these methods certainly lack the generality of the techniques above, they may offer better per 2 The algorithm presented in <ref> [16] </ref> is referred to as a new, diffusive method, when in fact it is neither. The same algorithm is presented in [32], and neither presentation bears any resemblance to a diffusive technique such as that given above. 14 CHAPTER 2. METHODOLOGY formance under certain circumstances. Recursive Bisection Methods. <p> Most of the load balancing work in the literature considers only the subproblem that is defined as work transfer vector calculation in this thesis, ignoring the other issues such as load measurement and task selection. Such work includes gradient methods [20, 22], hierarchical algorithms <ref> [16] </ref> and early diffusive techniques [7]. Techniques appropriate to specific problem regimes include recursive bisection algorithms [30, 31, 33] and particle simulation methods [9, 19].
Reference: [17] <author> Y.-S. Hwang, et al.. </author> <title> Runtime and Language Support for Compiling Adaptive Irregular Problems on Distributed-Memory Machines. </title> <journal> Software: Pract. and Exp., </journal> <volume> 25 </volume> <pages> 597-621, </pages> <year> 1995. </year>
Reference-contexts: Two libraries that provide support for parallel programming similar to that of the Graph Library are particularly interesting. CHAOS provides a framework for data and control decomposition of irregular, adaptive array-based codes via index translation and communication scheduling <ref> [17] </ref>.
Reference: [18] <author> E. Isaacson and H. Keller. </author> <title> Analysis of Numerical Methods. </title> <publisher> John Wiley and Sons, </publisher> <year> 1966. </year>
Reference-contexts: i;j;k = 2 x + ffi 2 z )(u i;j;k + u i;j;k ) (2.4) This scheme is unconditionally stable in the same manner as (2.3), but since the scheme is centered at n+1=2, its truncation error is O (ff 2 ) (i.e., it is second order accurate in time) <ref> [18] </ref>. Thus, we can increase our time step to ff = p ff, for the same accuracy as a first-order scheme.
Reference: [19] <author> G. Kohring. </author> <title> Dynamic Load Balancing for Parallelized Particle Simulations on MIMD Computers. </title> <journal> Parallel Comp., </journal> <volume> 21 </volume> <pages> 683-693, </pages> <year> 1995. </year>
Reference-contexts: The combination of these limitations makes such techniques unsuitable for use in a general purpose load balancing framework. Strip Methods. Heuristics for load balancing particle simulations (relevant to this thesis because of the two applications targeted in Chapter 4) are presented in <ref> [9, 19] </ref>. Both of these methods partition the physical problem domain in one dimension, then dynamically adjust the partition boundaries to track changes in particle density. The algorithm in [9] uses a global particle count to determine how many particles each computer should have for good load balance. <p> The algorithm in [9] uses a global particle count to determine how many particles each computer should have for good load balance. In some sense, the algorithm is little different from the hierarchical methods presented above. In <ref> [19] </ref>, a method which very coarsely approximates diffusion is used. Basically, computers repeatedly transfer fixed, small amounts of work to underloaded neighbors until a balanced state is reached. <p> Such work includes gradient methods [20, 22], hierarchical algorithms [16] and early diffusive techniques [7]. Techniques appropriate to specific problem regimes include recursive bisection algorithms [30, 31, 33] and particle simulation methods <ref> [9, 19] </ref>. Other task-based approaches to load balancing include a scalable task pool [15], a heuristic for transferring tasks between computers based on probability vectors [8] and a scalable, iterative bidding model [27].
Reference: [20] <author> F. Lin and R. Keller. </author> <title> The Gradient Model Load Balancing Method. </title> <journal> IEEE Trans. Soft. Eng., </journal> <volume> 1 </volume> <pages> 32-38, </pages> <year> 1987. </year>
Reference-contexts: Hence, the method is stable. Given that the Crank-Nicholson differencing scheme (2.4) is consistent and stable, then it is also convergent, by the Lax equivalence theorem [1]. 2.3. WORK TRANSFER VECTOR CALCULATION 13 2.3.2 Gradient Methods Gradient load balancing methods have been explored extensively in the literature <ref> [20, 22, 32] </ref>. The basic idea is that each computer classifies itself to be either lightly loaded, properly loaded or heavily loaded by comparing its load to predetermined thresholds, called low and high water marks. Lightly loaded computers inform their neighbors of their status. <p> Most of the load balancing work in the literature considers only the subproblem that is defined as work transfer vector calculation in this thesis, ignoring the other issues such as load measurement and task selection. Such work includes gradient methods <ref> [20, 22] </ref>, hierarchical algorithms [16] and early diffusive techniques [7]. Techniques appropriate to specific problem regimes include recursive bisection algorithms [30, 31, 33] and particle simulation methods [9, 19].
Reference: [21] <author> D. Maskit and S. Taylor. </author> <title> A Message-Driven Programming System for Fine-Grain Multi-computers. </title> <journal> Software: Pract. and Exp., </journal> <volume> 24 </volume> <pages> 953-980, </pages> <year> 1994. </year>
Reference-contexts: presented in the previous chapter as well as implementation specifics for the Graph Library that motivate the associated design decisions. 3.2.1 Low-Latency RPC Mechanism As discussed in Section 3.1, the Graph Library itself is an abstraction of a low-latency, RPC-based programming model found in programming systems such Message-Driven C (MDC) <ref> [21] </ref>. 3.2. IMPLEMENTATION SPECIFICS 27 The RPC model used in the Graph Library allows the user to invoke a function with arguments on a remote computer: * f (len, args)@comp: This statement causes the remote invocation of the function f with arguments args of length len on computer c.
Reference: [22] <author> F. Muniz and E. Zaluska. </author> <title> Parallel Load-Balancing: An Extension to the Gradient Model. </title> <journal> Parallel Comp., </journal> <volume> 21 </volume> <pages> 287-301, </pages> <year> 1995. </year>
Reference-contexts: Hence, the method is stable. Given that the Crank-Nicholson differencing scheme (2.4) is consistent and stable, then it is also convergent, by the Lax equivalence theorem [1]. 2.3. WORK TRANSFER VECTOR CALCULATION 13 2.3.2 Gradient Methods Gradient load balancing methods have been explored extensively in the literature <ref> [20, 22, 32] </ref>. The basic idea is that each computer classifies itself to be either lightly loaded, properly loaded or heavily loaded by comparing its load to predetermined thresholds, called low and high water marks. Lightly loaded computers inform their neighbors of their status. <p> Lightly loaded computers inform their neighbors of their status. This information is propagated to any overloaded computers within a fixed radius (typically the dimensions of the network). Once propagated, a gradient map is constructed to route work from overloaded to underloaded computers. As pointed out in <ref> [22, 32] </ref>, this model may result in over- or undertrans-fers of work to lightly loaded processors. Transferring too much work is a very serious problem. For example, if a computer has twice the average workload of the other computers, the computation can have a maximum efficiency of fifty percent. <p> On the other hand, if a computer has half as much work as the average, the efficiency can still be as high as (P 1 2 )=P , where P is the number of processors. The authors of <ref> [22] </ref> present a workaround in which computers check that an underloaded processor is still underloaded before committing to the transfer, which is then conducted directly from the overloaded to underloaded processor. This has the advantage of eliminating much of the cost of transferring load via intermediate computers. <p> Most of the load balancing work in the literature considers only the subproblem that is defined as work transfer vector calculation in this thesis, ignoring the other issues such as load measurement and task selection. Such work includes gradient methods <ref> [20, 22] </ref>, hierarchical algorithms [16] and early diffusive techniques [7]. Techniques appropriate to specific problem regimes include recursive bisection algorithms [30, 31, 33] and particle simulation methods [9, 19].
Reference: [23] <author> W. Press, S. Teukolsky, W. Vetterling and B. Flannery. </author> <title> Numerical Recipes in C: </title> <booktitle> The Art of Scientific Computing. 2nd ed., </booktitle> <publisher> Cambridge Univ. Press, </publisher> <year> 1992. </year>
Reference-contexts: METHODOLOGY Derivation. The heat equation in three dimensions is: u t = r 2 u = u xx + u yy + u zz (2.1) A common method of solving (2.1) is by using finite differencing schemes <ref> [1, 4, 23, 34] </ref>. Let ffi 2 x denote the discrete Laplacian operator in the x dimension: ffi 2 Define ffi 2 y and ffi 2 z similarly. Since the spatial discretization is arbitrary, take it to be one. <p> In this context, greedy strategies such as first fit cool the problem too quickly. By more slowly and thoroughly exploring the available options, a better solution can often be found. The fundamental algorithm in simulated annealing is the Metropolis algorithm <ref> [23] </ref>. Applying this technique to the subset sum problem requires that the following be provided: * Current Configuration: Let C be the set of tasks which have been selected for transfer/exchange.
Reference: [24] <author> M. Rieffel. </author> <title> Concurrent Simulations of Plasma Reactors for VLSI Manufacturing. </title> <type> MS Thesis, </type> <institution> Caltech Computer Science Department, </institution> <year> 1995. </year>
Reference-contexts: It also provides performance numbers before and after load balancing, demonstrating the practical efficacy of the algorithm given in the previous chapter. 4.1 Direct Simulation Monte Carlo Application Direct Simulation Monte Carlo (DSMC) is a technique for the simulation of collisional plasmas and rarefied gases <ref> [24] </ref>. It is applied to particle flows where the Knudsen number 1 is too high for continuum methods such as the Euler or Navier-Stokes equations and too low for collision-less methods such as Particle-in-Cell. <p> Based on particle distribution functions, macroscopic properties such as pressure, temperature and species concentration can be calculated. 4.1.1 Description Hawk is a three-dimensional concurrent DSMC application based on techniques developed by Bird <ref> [24, 29] </ref>. It was written by Marc Rieffel of the Scalable Concurrent Programming Laboratory in conjunction with researchers from the Intel Corporation and the Philips Laboratory at Edwards Air Force Base. Hawk was developed with great care for software engineering.
Reference: [25] <author> R. Samanta Roy. </author> <title> Numerical Simulation of Ion Thruster Plume Backflow for Spacecraft Contamination Assessment. </title> <type> PhD Dissertation, </type> <institution> MIT Aeronautics and Astronautics Department, </institution> <year> 1995. </year>
Reference: [26] <author> R. Samanta Roy, D. Hastings and S. Taylor. </author> <title> Three-Dimensional Plasma Paricle-in-Cell Calculations of Ion Thruster Backflow Contamination. </title> <note> Submitted to the Journal of Computational Physics, </note> <year> 1995. </year>
Reference: [27] <author> J. Song. </author> <title> A Partially Asynchronous and Iterative Algorithm for Distributed Load Balancing. </title> <journal> Parallel Computing, </journal> <volume> 20 </volume> <pages> 853-868, </pages> <year> 1994. </year>
Reference-contexts: Techniques appropriate to specific problem regimes include recursive bisection algorithms [30, 31, 33] and particle simulation methods [9, 19]. Other task-based approaches to load balancing include a scalable task pool [15], a heuristic for transferring tasks between computers based on probability vectors [8] and a scalable, iterative bidding model <ref> [27] </ref>. All of these techniques make assumptions, such as that of complete task independence or task load uniformity, that are not applicable in the context of this thesis. One paper which does address the entire load balancing problem and explores a broad range of options to its solution is [32].
Reference: [28] <author> J. Stoer and R. Bulrisch. </author> <title> Introduction to Numerical Analysis. 2nd ed., </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <note> BIBLIOGRAPHY 51 </note>
Reference-contexts: The sum of the entries in each row/column of D 1 T is thus 3ff 1+3ff . Given that, the Gersgorin disk theorem implies that the eigenvalues of D 1 T are bounded by 3ff 1+3ff , and a theorem due to Hirsch gives the spectral radius <ref> [28] </ref>: D 1 T = 1 + 3 ff The accuracy of the Jacobi iteration is a function of the spectral radius [28]: - = ff (2.9) (2.8) and (2.9) imply that an accuracy of ff will be achieved in a number of iterations specified by: ~ ln 3ff Finally, to <p> the Gersgorin disk theorem implies that the eigenvalues of D 1 T are bounded by 3ff 1+3ff , and a theorem due to Hirsch gives the spectral radius <ref> [28] </ref>: D 1 T = 1 + 3 ff The accuracy of the Jacobi iteration is a function of the spectral radius [28]: - = ff (2.9) (2.8) and (2.9) imply that an accuracy of ff will be achieved in a number of iterations specified by: ~ ln 3ff Finally, to calculate the change in the transfer vectors to/from each neighboring computer, simply substitute u i;j;k for the load u i 0 ;j
Reference: [29] <author> S. Taylor, J. Watts, M. Rieffel and M. Palmer. </author> <title> `The Concurrent Graph: Basic Technology for Irregular Problems. </title> <note> Submitted to IEEE Journal of Computational Science, </note> <year> 1995. </year>
Reference-contexts: Chapter 3 Implementation This chapter presents an implementation of load balancing based on the methodology given in Chapter 2. The techniques were implemented in the context of the Concurrent Graph Library, an applications framework which has been successfully applied to a number of large-scale irregular problems <ref> [29] </ref>. <p> Based on particle distribution functions, macroscopic properties such as pressure, temperature and species concentration can be calculated. 4.1.1 Description Hawk is a three-dimensional concurrent DSMC application based on techniques developed by Bird <ref> [24, 29] </ref>. It was written by Marc Rieffel of the Scalable Concurrent Programming Laboratory in conjunction with researchers from the Intel Corporation and the Philips Laboratory at Edwards Air Force Base. Hawk was developed with great care for software engineering.
Reference: [30] <author> R. Van Driessche and D. Roose. </author> <title> An Improved Spectral Bisection Algorithm and Its Application to Dynamic Load Balancing. </title> <journal> Parallel Comp., </journal> <volume> 21 </volume> <pages> 29-48, </pages> <year> 1995. </year>
Reference-contexts: Recursive Bisection Methods. Recursive bisection methods operate by recursively partitioning the problem domain to achieve load balance and to reduce communication costs. Most presentations of these techniques appear in the context of static load balancing [2, 33], although formulations appropriate for dynamic domain repartitioning do exist <ref> [30, 31] </ref>. While many methods exist for repartitioning a computation, including various geometrically based techniques, the most interesting methods utilize the spectral properties of a matrix encapsulating the adjacency in the computation. Unfortunately, these methods have a fairly high computational cost. <p> Such work includes gradient methods [20, 22], hierarchical algorithms [16] and early diffusive techniques [7]. Techniques appropriate to specific problem regimes include recursive bisection algorithms <ref> [30, 31, 33] </ref> and particle simulation methods [9, 19]. Other task-based approaches to load balancing include a scalable task pool [15], a heuristic for transferring tasks between computers based on probability vectors [8] and a scalable, iterative bidding model [27].
Reference: [31] <author> C. Walshaw and M. Berzins. </author> <title> Dynamic Load-Balancing for PDE Solvers on Adaptive Unstructured Meshes,. </title> <journal> Concurrency: Practice and Experience, </journal> <volume> 7 </volume> <pages> 17-28, </pages> <year> 1995. </year>
Reference-contexts: Recursive Bisection Methods. Recursive bisection methods operate by recursively partitioning the problem domain to achieve load balance and to reduce communication costs. Most presentations of these techniques appear in the context of static load balancing [2, 33], although formulations appropriate for dynamic domain repartitioning do exist <ref> [30, 31] </ref>. While many methods exist for repartitioning a computation, including various geometrically based techniques, the most interesting methods utilize the spectral properties of a matrix encapsulating the adjacency in the computation. Unfortunately, these methods have a fairly high computational cost. <p> Such work includes gradient methods [20, 22], hierarchical algorithms [16] and early diffusive techniques [7]. Techniques appropriate to specific problem regimes include recursive bisection algorithms <ref> [30, 31, 33] </ref> and particle simulation methods [9, 19]. Other task-based approaches to load balancing include a scalable task pool [15], a heuristic for transferring tasks between computers based on probability vectors [8] and a scalable, iterative bidding model [27].
Reference: [32] <author> M. Willebeek-LeMair and A. Reeves. </author> <title> Strategies for Dynamic Load Balancing on Highly Parallel Computers. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 4 </volume> <pages> 979-993, </pages> <year> 1993. </year>
Reference-contexts: For these applications the mapping of tasks to computers must change dynamically, at runtime. 1.3. APPROACH 3 1.3 Approach A practical solution of the dynamic load balancing problem involves five distinct phases <ref> [32] </ref>: 1 1) Load Evaluation: Some estimate of a computer's load must be provided to first determine that a load imbalance exists. <p> In the process, the work exposes a deficiency in all current load balancing strategies, motivating further work in this area. 1.5 Assumptions and Notational Conventions This thesis makes the following assumptions regarding the architecture to which the techniques herein are applied: 1 Actually, the authors of <ref> [32] </ref> divided the problem into four phases, merging task selection and task migration into a single step. 4 CHAPTER 1. INTRODUCTION 1) The interconnect topology is a d-dimensional mesh with M 0 ; M 1 ; : : : ; M d1 nodes in each dimension, respectively. <p> Diffusion was first presented as a method for load balancing in [7]. This work had certain limitations, as pointed out in [13]. Diffusion was also explored in <ref> [32] </ref> and was found to be superior to other load balancing strategies. A more general diffusive strategy is given in [13, 14]. This method uses a fully implicit differencing scheme to solve the heat equation on a multi-dimensional mesh to a specified accuracy. Algorithm. <p> Hence, the method is stable. Given that the Crank-Nicholson differencing scheme (2.4) is consistent and stable, then it is also convergent, by the Lax equivalence theorem [1]. 2.3. WORK TRANSFER VECTOR CALCULATION 13 2.3.2 Gradient Methods Gradient load balancing methods have been explored extensively in the literature <ref> [20, 22, 32] </ref>. The basic idea is that each computer classifies itself to be either lightly loaded, properly loaded or heavily loaded by comparing its load to predetermined thresholds, called low and high water marks. Lightly loaded computers inform their neighbors of their status. <p> Lightly loaded computers inform their neighbors of their status. This information is propagated to any overloaded computers within a fixed radius (typically the dimensions of the network). Once propagated, a gradient map is constructed to route work from overloaded to underloaded computers. As pointed out in <ref> [22, 32] </ref>, this model may result in over- or undertrans-fers of work to lightly loaded processors. Transferring too much work is a very serious problem. For example, if a computer has twice the average workload of the other computers, the computation can have a maximum efficiency of fifty percent. <p> Despite these improvements, the gradient model is still fundamentally flawed. At best, it is little more than a heuristic. At worst, it can lead to very undesirable behavior. And while it does have the scala bility of diffusive strategies, it has been shown to be inferior in its performance <ref> [32] </ref>. 2.3.3 Hierarchical Methods In hierarchical or multi-level techniques, computers are initially organized into (two) large groups which are balanced between one another. <p> These groups are then recursively divided and load balanced. (The loads of the groups at each level are first determined by having the computers group themselves recursively, summing the total loads of the subgroups to get the load of the new group they comprise.) Hierarchical techniques are explored in <ref> [16, 32] </ref>. 2 The hierarchical method does achieve effective load balance, and it does so in a number of steps logarithmic in the number of computers. However, the algorithm inherently neglects to attempt to minimize the distance and volume of work transferred to achieve load balance. <p> In such situations, the diffusive strategy better preserves existing communication locality. Even when communication is not an issue, the diffusive strategy has been shown to perform as well, with less work transfer <ref> [32] </ref>. 2.3.4 Domain-Specific Methods The literature contains a number of load balancing methods for specific problem areas. <p> While these methods certainly lack the generality of the techniques above, they may offer better per 2 The algorithm presented in [16] is referred to as a new, diffusive method, when in fact it is neither. The same algorithm is presented in <ref> [32] </ref>, and neither presentation bears any resemblance to a diffusive technique such as that given above. 14 CHAPTER 2. METHODOLOGY formance under certain circumstances. Recursive Bisection Methods. Recursive bisection methods operate by recursively partitioning the problem domain to achieve load balance and to reduce communication costs. <p> All of these techniques make assumptions, such as that of complete task independence or task load uniformity, that are not applicable in the context of this thesis. One paper which does address the entire load balancing problem and explores a broad range of options to its solution is <ref> [32] </ref>. The authors of this paper also conclude that diffusive techniques are superior on the basis of performance, scalability and efficiency.
Reference: [33] <author> R. Williams. </author> <title> Performance of Dynamic Load balancing Algorithms for Unstructured Mesh Calculations. </title> <journal> Concurrency: Pract. and Exp., </journal> <volume> 3 </volume> <pages> 457-481, </pages> <year> 1991. </year>
Reference-contexts: METHODOLOGY formance under certain circumstances. Recursive Bisection Methods. Recursive bisection methods operate by recursively partitioning the problem domain to achieve load balance and to reduce communication costs. Most presentations of these techniques appear in the context of static load balancing <ref> [2, 33] </ref>, although formulations appropriate for dynamic domain repartitioning do exist [30, 31]. While many methods exist for repartitioning a computation, including various geometrically based techniques, the most interesting methods utilize the spectral properties of a matrix encapsulating the adjacency in the computation. <p> Such work includes gradient methods [20, 22], hierarchical algorithms [16] and early diffusive techniques [7]. Techniques appropriate to specific problem regimes include recursive bisection algorithms <ref> [30, 31, 33] </ref> and particle simulation methods [9, 19]. Other task-based approaches to load balancing include a scalable task pool [15], a heuristic for transferring tasks between computers based on probability vectors [8] and a scalable, iterative bidding model [27].
Reference: [34] <author> D. Young and R. Gregory. </author> <title> A Survery of Numerical Mathematics. </title> <journal> Vol. </journal> <volume> 2, </volume> <publisher> Addison-Wesley, 1973 (republished by Dover, </publisher> <year> 1988). </year>
Reference-contexts: METHODOLOGY Derivation. The heat equation in three dimensions is: u t = r 2 u = u xx + u yy + u zz (2.1) A common method of solving (2.1) is by using finite differencing schemes <ref> [1, 4, 23, 34] </ref>. Let ffi 2 x denote the discrete Laplacian operator in the x dimension: ffi 2 Define ffi 2 y and ffi 2 z similarly. Since the spatial discretization is arbitrary, take it to be one. <p> the eigenvalues of A 1 B are finally obtained: i;j;k = M 0 M 1 M 2 1 + 2 ff sin 2 i + sin 2 j + sin 2 k (2.16) (Note that this result is similar to that obtained by Fourier analysis of the two-dimensional case in <ref> [34] </ref>.) From (2.16), one can see that for any i;j;k and all ff = p ff &gt; 0, j i;j;k j 1. Hence, the method is stable. Given that the Crank-Nicholson differencing scheme (2.4) is consistent and stable, then it is also convergent, by the Lax equivalence theorem [1]. 2.3.
References-found: 34

