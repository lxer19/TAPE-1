URL: ftp://ftp.cs.umd.edu/pub/papers/papers/3310/3310.ps.Z
Refering-URL: http://www.cs.umd.edu/TRs/TR.html
Root-URL: 
Email: vadik@cs.umd.edu  
Title: Global Value Propagation Through Value Flow Graph and Its Use in Dependence Analysis  
Author: Vadim Maslov 
Note: This work is supported by an NSF PYI grant CCR-9157384 and by a Packard Fellowship.  
Address: College Park, MD 20742  
Affiliation: Institute for Advanced Computer Studies Department of Computer Science University of Maryland,  
Date: July, 1994  
Pubnum: UMIACS-TR-94-80  CS-TR-3310  
Abstract: As recent studies show, state-of-the-art parallelizing compilers produce no noticeable speedup for 9 out of 12 PERFECT benchmark codes, while the speedup that was reached by manually applying certain automatable techniques ranges from 10 to 50. In this paper we introduce the Global Value Propagation algorithm that unifies several of these techniques. Global propagation is performed using program abstraction called Value Flow Graph (VFG). VFG is an acyclic graph in which vertices and arcs are parametrically specified using F-relations. The distinctive features of our propagation algorithm are: (1) It propagates not only values carried by scalar variables, but also values carried by individual array elements. (2) We do not have to transform a program in order to use propagation results in program analysis. In this paper we focus on use of the VFG and global value propagation in array dataflow analysis. F-relations are used to represent values produced by uninterpreted function symbols that appear in dependence problems for non-affine program fragments. Global value propagation helps us to discover that some of these functions are in fact affine. 
Abstract-found: 1
Intro-found: 1
Reference: [B + 89] <author> M. Berry et al. </author> <title> The PERFECT Club benchmarks: Effective performance evaluation of supercomputers. </title> <journal> International Journal of Supercomputing Applications, </journal> <volume> 3(3) </volume> <pages> 5-40, </pages> <month> March </month> <year> 1989. </year>
Reference-contexts: This makes dependence problem affine and therefore increases precision of dependence analysis for non-affine program fragments. In the remaining part of introduction we consider examples of the real Fortran programs from the PERFECT benchmark suite <ref> [B + 89] </ref> and show how use of F-relations and value propagation makes it possible to compute exact dependence information for them. 1.1 Propagating values of scalar variables In the program fragment in Figure 1 the variables Lmin and Lmax are assigned within the k loop.
Reference: [BE94] <author> William Blume and Rudolf Eigenmann. </author> <title> Symbolic analysis techniques needed for effective par-allelization of the Perfect benchmarks. </title> <type> Technical Report 1332, </type> <institution> Univ. of Illinois at Urbana-Champaign, Center for Supercomputing Res. & Dev., </institution> <year> 1994. </year>
Reference-contexts: 1 Introduction Automatic parallelization of the real Fortran programs does not live up to user expectations yet. As the recent studies <ref> [Blu92, BE94] </ref> show, state-of-the-art parallelizing compilers produce no noticeable speedup for 9 out of 12 PERFECT benchmark codes, while the speedup that was reached by manually applying certain automatable techniques (techniques that can be implemented in a compiler) ranges from 10 to 50.
Reference: [Blu92] <author> William Joseph Blume. </author> <title> Success and limitations in automatic parallelization of the Perfect benchmarks TM programs. </title> <type> Master's thesis, </type> <institution> Dept. of Computer Science, U. of Illinois at Urbana-Champaign, </institution> <year> 1992. </year>
Reference-contexts: 1 Introduction Automatic parallelization of the real Fortran programs does not live up to user expectations yet. As the recent studies <ref> [Blu92, BE94] </ref> show, state-of-the-art parallelizing compilers produce no noticeable speedup for 9 out of 12 PERFECT benchmark codes, while the speedup that was reached by manually applying certain automatable techniques (techniques that can be implemented in a compiler) ranges from 10 to 50.
Reference: [BMO90] <author> R. A. Ballance, A. B. Maccabe, and K. J. Ottenstein. </author> <title> The program dependence Web. </title> <booktitle> Proc. SIG-PLAN'90 Symp. on Compiler Construction, </booktitle> <pages> pages 257-271, </pages> <month> June </month> <year> 1990. </year> <journal> Published as SIGPLAN Notices Vol. </journal> <volume> 25, No. </volume> <pages> 6. </pages>
Reference-contexts: In recent years there has been a flurry of research activity in graph program representations. Static Single Assignment (SSA) form [CFR + 91] and Program Dependence Graph (PDG) [FOW87] were introduced. They were followed by Program Dependence Web <ref> [BMO90] </ref>, Dependence Flow Graph [JP93] and Value Dependence Graph [WCES94]. We call these graphs scalar program abstractions, because they are oriented towards representing data flow carried by scalar variables in program fragments without loops.
Reference: [CFR + 91] <author> R. Cytron, J. Ferrante, B.K. Rosen, M.N. Wegman, and F. K. Zadeck. </author> <title> Efficiently computing static single assignment form and the control dependence graph. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 13(4) </volume> <pages> 451-490, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: In this case we do not perform propagation, we just compute affine approximation of the source function. 6 Related Work Scalar program graph representations. In recent years there has been a flurry of research activity in graph program representations. Static Single Assignment (SSA) form <ref> [CFR + 91] </ref> and Program Dependence Graph (PDG) [FOW87] were introduced. They were followed by Program Dependence Web [BMO90], Dependence Flow Graph [JP93] and Value Dependence Graph [WCES94].
Reference: [Fea91] <author> Paul Feautrier. </author> <title> Dataflow analysis of array and scalar references. </title> <journal> International Journal of Parallel Programming, </journal> <volume> 20(1), </volume> <month> February </month> <year> 1991. </year>
Reference-contexts: Exact array dataflow analysis techniques. The concept of F-relation is based on a concept of dependence relation introduced in [Pug91]. The most difficult part of computing VFG is computing exact value-based dependence relations between statements. This part is done by array dataflow dependence analysis algorithms <ref> [Fea91, PW93, Mas94] </ref>. 13 2 4 R 2 : S 1 [i] = F (S 1 [iN ])j N+1 i 2N (17) 2 4 ( F (S 1 [iN ]) j N+1 i 2N (18) Voevodins work.
Reference: [FOW87] <author> J. Ferrante, K. J. Ottenstein, and J. D. Warren. </author> <title> The program dependence graph and its use in optimization. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 9(3) </volume> <pages> 319-349, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: In recent years there has been a flurry of research activity in graph program representations. Static Single Assignment (SSA) form [CFR + 91] and Program Dependence Graph (PDG) <ref> [FOW87] </ref> were introduced. They were followed by Program Dependence Web [BMO90], Dependence Flow Graph [JP93] and Value Dependence Graph [WCES94]. We call these graphs scalar program abstractions, because they are oriented towards representing data flow carried by scalar variables in program fragments without loops.
Reference: [HP92] <author> M. Haghighat and C. Polychronopoulos. </author> <title> Symbolic program analysis and optimization for parallel compilers. </title> <type> Technical Report 1237, </type> <institution> CSRD, Univ. of Illinois, </institution> <month> August </month> <year> 1992. </year> <booktitle> Presented at the 5th Annual Workshop on Languages and Compilers for Parallel Computing, </booktitle> <address> New Haven, CT, </address> <month> August 3-5, </month> <year> 1992. </year>
Reference-contexts: Substituting these functions to the non-affine set of constraints (3) that describes execution conditions for the statement S 4 , we discover that these constraints become affine constraints (4). Having affine execution conditions we can parallelize loop l if other criteria are satisfied. The generalized induction variable recognition techniques <ref> [Wol92, HP92] </ref> can recognize that Lmin and Lmax are wrap-around variables. However, the existing systems have to transform the program in order to use this information in dependence analysis. In this example they have to peel off the first iteration of loop k. <p> However, using F-relations (5) and (6) that describe values of I1 and I2 as affine functions of l we can compute exact F-relation (7) for statement S 3 . So we use techniques <ref> [Wol92, HP92] </ref> to compute closed form of generalized scalar induction variables. However, we do not substitute these closed forms to the places in program where these variables are used. Instead we substitute F-relation that expresses their closed form to the dependence problem involving references to these variables.
Reference: [JP93] <author> Richard Johnson and Keshav Pingali. </author> <title> Dependence-based program analysis. </title> <booktitle> In ACM '93 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 78-89, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: In recent years there has been a flurry of research activity in graph program representations. Static Single Assignment (SSA) form [CFR + 91] and Program Dependence Graph (PDG) [FOW87] were introduced. They were followed by Program Dependence Web [BMO90], Dependence Flow Graph <ref> [JP93] </ref> and Value Dependence Graph [WCES94]. We call these graphs scalar program abstractions, because they are oriented towards representing data flow carried by scalar variables in program fragments without loops.
Reference: [Mas94] <author> Vadim Maslov. </author> <title> Lazy array data-flow dependence analysis. </title> <booktitle> In ACM '94 Conf. on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1994. </year>
Reference-contexts: In this paper we focus on use of F-relations and global value propagation in array dataflow analysis. In Section 5 we introduce an extension of the Lazy Array Dataflow Analysis Algorithm <ref> [Mas94] </ref> that uses F-relations to represent values produced by uninterpreted function symbols that appear in dependence problems for non-affine program fragments. Global value propagation helps us to discover that many of these uninterpreted functions are in fact affine functions of loop variables. <p> Compute exact value-based dependences for each read reference using algorithm <ref> [Mas94] </ref>. These dependences are expressed as dependence relations [Pug91]: S x [w] ! S i l [v] j p (w; v) Convert each dependence relation to equivalent F-relation: S i l [v] = S x [w] j p (w; v) 3. <p> Finally we get F-relation (14) which is simpler than the original F-relation (11). 5 Array dataflow dependence analysis using VFG In Figure 10 we present an extension of Lazy Array Dataflow Dependence Analysis Algorithm <ref> [Mas94] </ref>. The basic idea of this extension is to substitute to non-affine constraint values of non-affine references obtained by global value propagation. This substitution often makes the constraint affine, and therefore we stay in domain of exact dependence analysis. <p> This substitution often makes the constraint affine, and therefore we stay in domain of exact dependence analysis. The numbered lines of algorithm constitute the extension proposed in this paper and details of the rest of the algorithm are given in <ref> [Mas94] </ref>. So, let's imagine that we build a dependence problem DepProb that has references to scalar and array references a 1 ; :::; a q and these references are not explicit affine functions of loop variables and symbolic constants (line 10). <p> Compute its affine approximation. 18: EndIf Relation Cmax := RelMax1 t (W [w] ! R:A [r] j DepProb (w; r)) DepRel := DepRel [ Cmax NotCovered := NotCovered ^ :Range (Cmax ) ... And so on, see <ref> [Mas94] </ref> ... <p> Exact array dataflow analysis techniques. The concept of F-relation is based on a concept of dependence relation introduced in [Pug91]. The most difficult part of computing VFG is computing exact value-based dependence relations between statements. This part is done by array dataflow dependence analysis algorithms <ref> [Fea91, PW93, Mas94] </ref>. 13 2 4 R 2 : S 1 [i] = F (S 1 [iN ])j N+1 i 2N (17) 2 4 ( F (S 1 [iN ]) j N+1 i 2N (18) Voevodins work. <p> Systems of Linear Recurrence Equations (SLRE) [RF93] are close to F-relations. However many important details in definitions and algorithms differ. First, [RF93] uses Quasi-Affine Search Trees (quasts) to represent SLREs while we use F-relations to represent VFGs. We refer reader to comparison of dependence relations and quasts in <ref> [PW93, Mas94] </ref>, because this comparison is appropriate for F-relations and SLREs.
Reference: [Pug91] <author> William Pugh. </author> <title> Uniform techniques for loop optimization. </title> <booktitle> In 1991 International Conference on Supercomputing, </booktitle> <pages> pages 341-352, </pages> <address> Cologne, Germany, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: Therefore we call assignment statement instances simply "statement instances". F-relations. Functional relation (or F-relation) is an extension of the concept of dependence relation introduced in <ref> [Pug91] </ref>. F-relation is a union of one or more simple F-relations. <p> Compute exact value-based dependences for each read reference using algorithm [Mas94]. These dependences are expressed as dependence relations <ref> [Pug91] </ref>: S x [w] ! S i l [v] j p (w; v) Convert each dependence relation to equivalent F-relation: S i l [v] = S x [w] j p (w; v) 3. <p> Contrary to the scalar program abstractions, VFG has only one type of arcs, it does not have cycles, and it does not use memory for storing intermediate results. Exact array dataflow analysis techniques. The concept of F-relation is based on a concept of dependence relation introduced in <ref> [Pug91] </ref>. The most difficult part of computing VFG is computing exact value-based dependence relations between statements.
Reference: [Pug92] <author> William Pugh. </author> <title> The Omega test: a fast and practical integer programming algorithm for dependence analysis. </title> <journal> Communications of the ACM, </journal> <volume> 8 </volume> <pages> 102-114, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: These operations produce Presburger arithmetic formulas. We simplify these formulas to Disjunctive Normal Form (DNF) using the Omega test <ref> [Pug92, PW93] </ref>. 6 Often instead of 9 we use more convenient projection operator introduced in [Pug92]: v (P (v; w)) = 9 w s:t: P (v; w) 3 Computing VFG for affine fragments In this section we present algorithm to compute Value Flow Graph for a given affine program fragment: 1. <p> These operations produce Presburger arithmetic formulas. We simplify these formulas to Disjunctive Normal Form (DNF) using the Omega test [Pug92, PW93]. 6 Often instead of 9 we use more convenient projection operator introduced in <ref> [Pug92] </ref>: v (P (v; w)) = 9 w s:t: P (v; w) 3 Computing VFG for affine fragments In this section we present algorithm to compute Value Flow Graph for a given affine program fragment: 1.
Reference: [PW93] <author> William Pugh and David Wonnacott. </author> <title> An evaluation of exact methods for analysis of value-based array data dependences. </title> <booktitle> In Sixth Annual Workshop on Programming Languages and Compilers for Parallel Computing, </booktitle> <address> Portland, OR, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: These operations produce Presburger arithmetic formulas. We simplify these formulas to Disjunctive Normal Form (DNF) using the Omega test <ref> [Pug92, PW93] </ref>. 6 Often instead of 9 we use more convenient projection operator introduced in [Pug92]: v (P (v; w)) = 9 w s:t: P (v; w) 3 Computing VFG for affine fragments In this section we present algorithm to compute Value Flow Graph for a given affine program fragment: 1. <p> Exact array dataflow analysis techniques. The concept of F-relation is based on a concept of dependence relation introduced in [Pug91]. The most difficult part of computing VFG is computing exact value-based dependence relations between statements. This part is done by array dataflow dependence analysis algorithms <ref> [Fea91, PW93, Mas94] </ref>. 13 2 4 R 2 : S 1 [i] = F (S 1 [iN ])j N+1 i 2N (17) 2 4 ( F (S 1 [iN ]) j N+1 i 2N (18) Voevodins work. <p> Systems of Linear Recurrence Equations (SLRE) [RF93] are close to F-relations. However many important details in definitions and algorithms differ. First, [RF93] uses Quasi-Affine Search Trees (quasts) to represent SLREs while we use F-relations to represent VFGs. We refer reader to comparison of dependence relations and quasts in <ref> [PW93, Mas94] </ref>, because this comparison is appropriate for F-relations and SLREs.
Reference: [RF93] <author> Xavier Redon and Paul Feautrier. </author> <title> Detection of recurrences in sequential programs with loops. </title> <editor> In Arndt Bode, Mike Reeve, and Gottfried Wolf, editors, </editor> <booktitle> Proceedings of the 5th International Parallel Architectures and Languages Europe, </booktitle> <pages> pages 132-145, </pages> <month> June </month> <year> 1993. </year> <month> 15 </month>
Reference-contexts: Instead we substitute F-relation that expresses their closed form to the dependence problem involving references to these variables. To compute closed form of array references we need to employ more general techniques of <ref> [RF93] </ref>. However, none of the benchmark studies yet claimed that recognizing array reductions may be useful for dependence analysis. So we restrict us to recognizing scalar reductions only. 1.2 Propagating values of array elements Consider a program fragment in Figure 3. <p> This simple algorithm just translates dependence relations computed for affine program fragments to F-relations. The more sophisticated dependence analysis algorithm introduced in Section 5 uses global propagation to compute exact dependence information for certain non-affine programs. For example, for program in Figure 5 <ref> [RF93] </ref> F-relation (11) is computed. 4 Global Value Propagation 4.1 Characteristic Graph Since number of vertices in Value Flow Graph is not known at compile time, regular graph manipulation techniques do not readily apply to VFGs 1 . <p> We think that the heuristic algorithm should not be used in dependence analysis, but it is suitable for applications that require "deep" propagation. For instance, it can be used in generalized recurrences recognition <ref> [RF93] </ref>. Heuristic Propagation example. The heuristic algorithm performs the following steps when working on program in Figure 5. First, in (11) we try safe propagations: we propagate R 1 to R 4 :S 1 [1] and R 2 to R 4 :S 2 [1]. <p> What's interesting, they mention review by Yershov [Yer73] in which he writes about Program Implementation Dataflow Graph, not discussing, however, its properties and applications. This graph seems to be equivalent to both VFG and AG. Feautrier and Redon work. Systems of Linear Recurrence Equations (SLRE) <ref> [RF93] </ref> are close to F-relations. However many important details in definitions and algorithms differ. First, [RF93] uses Quasi-Affine Search Trees (quasts) to represent SLREs while we use F-relations to represent VFGs. <p> This graph seems to be equivalent to both VFG and AG. Feautrier and Redon work. Systems of Linear Recurrence Equations (SLRE) <ref> [RF93] </ref> are close to F-relations. However many important details in definitions and algorithms differ. First, [RF93] uses Quasi-Affine Search Trees (quasts) to represent SLREs while we use F-relations to represent VFGs. We refer reader to comparison of dependence relations and quasts in [PW93, Mas94], because this comparison is appropriate for F-relations and SLREs. Second, in [RF93] the system graph that is analogue of our characteristic graph <p> First, <ref> [RF93] </ref> uses Quasi-Affine Search Trees (quasts) to represent SLREs while we use F-relations to represent VFGs. We refer reader to comparison of dependence relations and quasts in [PW93, Mas94], because this comparison is appropriate for F-relations and SLREs. Second, in [RF93] the system graph that is analogue of our characteristic graph has an arc (R 1 ; R 2 ) if some reference x appears both in the left hand side of R 1 and in the right hand side of R 2 , while we also require transfer set Transfer <p> This additional requirement makes our characteristic graph more precise. Our characteristic graph is more refined than system graph of <ref> [RF93] </ref> in other respects too. Consider example in Figure 12. <p> We have more refined characteristic graph that allows deeper propagation, because we require conditions at the simple F-relation to be single conjunct, while in <ref> [RF93] </ref> conditions at one SLRE equation can be arbitrary disjunction of conjuncts. Third, we think that [RF93] propagation algorithm is excessively cautious, because they do not allow splintering of the system graph nodes at all and their propagation condition (SLRE to be propagated should be used only in one other SLRE) <p> We have more refined characteristic graph that allows deeper propagation, because we require conditions at the simple F-relation to be single conjunct, while in <ref> [RF93] </ref> conditions at one SLRE equation can be arbitrary disjunction of conjuncts. Third, we think that [RF93] propagation algorithm is excessively cautious, because they do not allow splintering of the system graph nodes at all and their propagation condition (SLRE to be propagated should be used only in one other SLRE) is too stringent. <p> As even a relatively small set of our examples (Figures 1, 2, 3) shows, in dependence analysis we need to perform propagation even if SLRE is used in two or more places, and <ref> [RF93] </ref> cannot do it. 7 Conclusion In this paper we introduced Value Flow Graph that exactly represents flow of values in affine program fragment. <p> We believe that Value Flow Graph can be used not only for enhancing dependence analysis, but also for (1) generalized recurrence recognition a la <ref> [RF93] </ref>, (2) global dead code elimination, (3) global common subexpression elimination. Also we think that more experimentation is needed to measure the performance of the algorithms introduced in this paper and to find new areas of their applicability.
Reference: [Tar72] <author> R. E. Tarjan. </author> <title> Depth first search and linear graph algorithms. </title> <journal> SIAM J. Computing, </journal> <volume> 1(2) </volume> <pages> 146-160, </pages> <year> 1972. </year>
Reference-contexts: The safe algorithm can be used in any application, however it can miss some important propagations. 9 ConstantPropagation (F-relation R) Begin Find Strongly Connected Components (SCCs) in CG using Tarjan algorithm <ref> [Tar72] </ref> For (component C in SCCs of characteristic graph in topological order) If (C is a single vertex x such that no (x; x) self-arcs exist) then For (y in immediate successors of x) If (y is not involved in a cycle) Propagate (x; y) EndFor EndIf EndFor End HeuristicPropagation (F-relation
Reference: [Voe92a] <author> Valentin V. Voevodin. </author> <booktitle> Mathematical Foundations of Parallel Computing. </booktitle> <publisher> World Scientific Publishers, </publisher> <year> 1992. </year> <booktitle> World Scientific Series in Computer Science, </booktitle> <volume> vol. </volume> <pages> 33. </pages>
Reference-contexts: Valentine and Vladimir Voevodin <ref> [Voe92a, Voe92b] </ref> use Algorithm Graph (AG) to represent data flow in affine programs. The Algorithm Graph is essentially equivalent to VFG and notation used for specifying Algorithm Graphs seems to be close to F-relations. However, authors do not formalize their notation.
Reference: [Voe92b] <author> Vladimir V. Voevodin. </author> <title> Theory and practice of parallelism detection in sequential programs. </title> <journal> Programming and Computer Software (Programmirovaniye), </journal> <volume> 18(3), </volume> <month> May </month> <year> 1992. </year>
Reference-contexts: Valentine and Vladimir Voevodin <ref> [Voe92a, Voe92b] </ref> use Algorithm Graph (AG) to represent data flow in affine programs. The Algorithm Graph is essentially equivalent to VFG and notation used for specifying Algorithm Graphs seems to be close to F-relations. However, authors do not formalize their notation.
Reference: [WCES94] <author> Daniel Weise, Roger Crew, Michael Ernst, and Bjarne Steensgaard. </author> <title> Value dependence graphs: Representation without taxation. </title> <booktitle> In ACM '94 Conf. on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1994. </year>
Reference-contexts: In recent years there has been a flurry of research activity in graph program representations. Static Single Assignment (SSA) form [CFR + 91] and Program Dependence Graph (PDG) [FOW87] were introduced. They were followed by Program Dependence Web [BMO90], Dependence Flow Graph [JP93] and Value Dependence Graph <ref> [WCES94] </ref>. We call these graphs scalar program abstractions, because they are oriented towards representing data flow carried by scalar variables in program fragments without loops.
Reference: [Wol92] <author> Michael Wolfe. </author> <title> Beyond induction variables. </title> <booktitle> In SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <address> San Francisco, California, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Substituting these functions to the non-affine set of constraints (3) that describes execution conditions for the statement S 4 , we discover that these constraints become affine constraints (4). Having affine execution conditions we can parallelize loop l if other criteria are satisfied. The generalized induction variable recognition techniques <ref> [Wol92, HP92] </ref> can recognize that Lmin and Lmax are wrap-around variables. However, the existing systems have to transform the program in order to use this information in dependence analysis. In this example they have to peel off the first iteration of loop k. <p> However, using F-relations (5) and (6) that describe values of I1 and I2 as affine functions of l we can compute exact F-relation (7) for statement S 3 . So we use techniques <ref> [Wol92, HP92] </ref> to compute closed form of generalized scalar induction variables. However, we do not substitute these closed forms to the places in program where these variables are used. Instead we substitute F-relation that expresses their closed form to the dependence problem involving references to these variables.
Reference: [Yer73] <author> A. P. Yershov. </author> <title> Current state of program schemes theory. </title> <booktitle> Problems of Cybernetics (in Russian), </booktitle> <volume> 27 </volume> <pages> 87-110, </pages> <year> 1973. </year>
Reference-contexts: The Algorithm Graph is essentially equivalent to VFG and notation used for specifying Algorithm Graphs seems to be close to F-relations. However, authors do not formalize their notation. Also they do not discuss using the Algorithm Graph for global value propagation. What's interesting, they mention review by Yershov <ref> [Yer73] </ref> in which he writes about Program Implementation Dataflow Graph, not discussing, however, its properties and applications. This graph seems to be equivalent to both VFG and AG. Feautrier and Redon work. Systems of Linear Recurrence Equations (SLRE) [RF93] are close to F-relations.
References-found: 20

