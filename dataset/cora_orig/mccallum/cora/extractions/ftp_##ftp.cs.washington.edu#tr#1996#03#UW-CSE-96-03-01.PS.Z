URL: ftp://ftp.cs.washington.edu/tr/1996/03/UW-CSE-96-03-01.PS.Z
Refering-URL: http://www.cs.washington.edu/research/tr/tr-by-title.html
Root-URL: 
Title: Semi-automatic Update of Applications in Response to Library Changes  
Author: Kingsum Chow and David Notkin 
Keyword: Software evolution, software maintenance, software libraries, asynchronous software evolution, asynchronous software maintenance, program restructuring.  
Address: Box 352350 Seattle, WA 98195-2350, USA  
Affiliation: Department of Computer Science Engineering University of Washington  
Pubnum: Technical Report UW-CSE  
Email: -kingsum,notkin-@cs.washington.edu  
Date: 96-03-01  
Abstract: Software libraries provide leverage in large part because they are used by many applications. As Parnas, Lampson and others have noted, stable interfaces to libraries isolate the application from changes in the libraries. That is, as long as there is no change in a librarys syntax or semantics, applications can use updated libraries simply by importing and linking the new version. However, libraries are indeed changed from time to time and the tedious work of adapting the application source to the library interface changes becomes a burden to multitudes of programmers. This paper introduces an approach and a toolset intended to reduce these costs. Specifically, in our approach a library maintainer annotates changed functions with rules that are used to generate tools that will update the applications that use the updated libraries. Thus, in exchange for a small added amount of work by the library maintainers, costs to each application maintainer can be reduced. We present the basic approach, describe the tools that support the approach, and discuss the strengths and limitations of the approach. 
Abstract-found: 1
Intro-found: 1
Reference: [Bergstein 1991] <author> Paul L. </author> <title> Bergstein, </title> <booktitle> Object-preserving Class Transformations Proceedings of OOPSLA '91, </booktitle> <pages> pp. </pages> <month> 299-313 </month> <year> (1991). </year>
Reference-contexts: Second, some structural changes in the restructuring approach need not be dealt with by our change adaptation tool because they do not result in interface changes. In fact, there are a number of researchers [Johnson & Opdyke 1993], [Casais 1992], <ref> [Bergstein 1991] </ref> and [Lieberherr & Xiao 1993] working along the same line as [Griswold & Notkin 1993] i.e., maintaining changes in various different ways, not merely interface changes, within a program. However, in this kind of closed system, it is indeed required that all source code is accessible and modifiable.
Reference: [Borland 1993a] <institution> Borlands README file for release 4.0. </institution>
Reference-contexts: Section 6 discusses other benefits of our approach. Section 7 summarizes our work and suggests future research areas. 2 An example of an interface change To clarify why handling changes to libraries is hard for applications, well use a simple example taken from a commercial library <ref> [Borland 1993a] </ref>. 1 The example illustrates some interface changes involving overloaded functions and default arguments.
Reference: [Borland 1993b] <institution> Borland ObjectWindows for C++ Programmers Guide 2.0. </institution> <year> 1993. </year>
Reference-contexts: Typically, the programmer and the maintainer are the same person in a closed system. In the industry, however, some sort of a script is sometimes provided for people that deal with interface changes, e.g. Borlands ObjectWindows Library converter <ref> [Borland 1993b] </ref> and Microsofts migrate [Microsoft 1994]. In general, they are based on lexical analysis 16 and they also make more assumptions about the source and thus make themselves very restrictive and will work only in a narrow domain.
Reference: [Casais 1992] <author> Eduardo Casais, </author> <title> An Incremental Class Reorganization Approach Proceedings of ECOOP '92, </title> <journal> pp. </journal> <month> 114-132 (June </month> <year> 1992). </year>
Reference-contexts: Second, some structural changes in the restructuring approach need not be dealt with by our change adaptation tool because they do not result in interface changes. In fact, there are a number of researchers [Johnson & Opdyke 1993], <ref> [Casais 1992] </ref>, [Bergstein 1991] and [Lieberherr & Xiao 1993] working along the same line as [Griswold & Notkin 1993] i.e., maintaining changes in various different ways, not merely interface changes, within a program.
Reference: [Chow 1995] <author> Kingsum Chow, </author> <title> Program Transformation for Asynchronous Software Maintenance, Proceedings of ICSE-17 Workshop on Program Transformation for Software Evolution, </title> <editor> William Griswold, editor, </editor> <booktitle> The 17th International Conference on Software Engineering, </booktitle> <address> April 24-28, 1995, Seattle, Washington, USA. </address> <note> Also published as Technical Report Number CS95-418, </note> <institution> Computer Science and Engineering, University of California, </institution> <address> San Diego. </address>
Reference-contexts: A classification of these problems and general guidelines to library maintainers in terms of writing change specification would be useful. In summary, we regard adapting source code to library interface changes as one of the biggest activity in asynchronous software evolution <ref> [Chow 1995] </ref>. In future, we will look at other areas of asynchronous software evolution [Chow & Notkin 1996]. 19
Reference: [Chow 1996] <author> Kingsum Chow, </author> <type> Ph.D. </type> <note> dissertation in preparation, </note> <institution> Department of Computer Science and Engineering, University of Washington, </institution> <address> Seattle, Washington, USA (1996). </address>
Reference-contexts: As we show in the next section, the specific syntax is motivated by the language processing system that we used to implement our toolset. Details of the specification are found elsewhere <ref> [Chow 1996] </ref>. /* * _ASE_BEGIN_ * FNAME = assign * PATTERN = #(fc:FCALL_assign id:ID lp:L_PAREN arg1:gen_expr co1:COMMA arg2:gen_expr co2:COMMA arg3:gen_expr rp:R_PAREN) * ACTION = #gen_logical_expr = #(#fc, #id, #lp, #arg1, #co, #arg2, #co, 0, #co2, #arg3, #rp); */ 11 Sometimes, the change may even depend on the actual value of an <p> Table 1 summarizes the various classes of changes that can be handled using our approach. A more detailed study of patterns of interface changes can be found in <ref> [Chow 1996] </ref>. In our prototype system, the library maintainer needs to provide a standard release of the language grammar and transformation grammar. Of course, the interface specification changes must also be provided in the include files. <p> We propose the model of our approach and give a reasonable implementation that works with real life examples. Within the area of library interface changes, we have done a study on the pattern of library changes <ref> [Chow 1996] </ref> to gain confidence in the usefulness of our tool. Future work will be required to evaluate the effectiveness of our model and implementation. For example, some of the process may not require a complete syntax parsing of the program.
Reference: [Chow & Notkin 1986] <author> Kingsum Chow and David Notkin, </author> <booktitle> Asynchronous Software Evolution Asia-Pacific Workshop on Software Engineering Research, </booktitle> <address> March 21, 1996, Hong Kong. </address>
Reference: [Collofello & Buck 1987] <author> Collofello, J. S., and Buck, J. </author> <title> J, </title> <booktitle> Software quality assurance for maintenance IEEE Computer. </booktitle> <month> (Sept. </month> <year> 1987), </year> <pages> 46-51. </pages>
Reference-contexts: Reducing the number of locations that must be updated manually will necessarily reduce the number of additional errors introduced during maintenance <ref> [Collofello & Buck 1987] </ref>. The next section sketches the basic approach we take, which is intended to satisfy these properties.
Reference: [Griswold & Notkin 1993] <author> William G. Griswold and David Notkin, </author> <booktitle> Automated Assistance for Program Restructuring ACM Transactions on Software Engineering and Methodology. </booktitle> <pages> 2(3) pp. </pages> <month> 228-269 (July </month> <year> 1993). </year>
Reference-contexts: It also provides technical details about the languages and tools we use to help automate such changes. 3 The design of our approach One approach taken to similar problems is, roughly, to change the application automatically when the library is updated <ref> [Griswold & Notkin 1993] </ref>[Opdyke 1992]. This approach requires that the full source code for the library and application be available at one time and on one computer, so that the needed changes can be propagated from the library to the application. <p> In fact, there are a number of researchers [Johnson & Opdyke 1993], [Casais 1992], [Bergstein 1991] and [Lieberherr & Xiao 1993] working along the same line as <ref> [Griswold & Notkin 1993] </ref> i.e., maintaining changes in various different ways, not merely interface changes, within a program. However, in this kind of closed system, it is indeed required that all source code is accessible and modifiable.
Reference: [Johnson 1975] <author> S. C. Johnson, </author> <note> Yacc - Yet Another Compiler-Compiler Computer Science Technical Report 32, </note> <institution> AT&T Bell Labs, </institution> <address> Murray Hill, NJ, USA (1975). </address>
Reference-contexts: PCCTS is similar to a more popular tool set, lex [Lesk & Schmidt 1975] and yacc <ref> [Johnson 1975] </ref> but we are using PCCTS for the following reasons: 1. PCCTS generates C++ code, 2. PCCTS coordinates very well with Sorcerer, a tree parser transformer, and 3. PCCTS provides nice error messages. A comparison between PCCTS and lex/yacc is beyond the scope of this paper, however.
Reference: [Johnson & Opdyke 1993] <author> Ralph E. Johnson and William F. </author> <title> Opdyke. </title> <booktitle> Refactoring and Aggregation Proceedings of the First JSSST International Symposium on Object Technologies for Advanced Software, </booktitle> <editor> S. Nishio and A. Yonezawa (editors), pp. </editor> <month> 264-278 (November </month> <year> 1993). </year>
Reference-contexts: Second, some structural changes in the restructuring approach need not be dealt with by our change adaptation tool because they do not result in interface changes. In fact, there are a number of researchers <ref> [Johnson & Opdyke 1993] </ref>, [Casais 1992], [Bergstein 1991] and [Lieberherr & Xiao 1993] working along the same line as [Griswold & Notkin 1993] i.e., maintaining changes in various different ways, not merely interface changes, within a program.
Reference: [Lampson 1984] <author> Butler W. Lampson, </author> <title> Hints for Computer System Design IEEE Software pp. </title> <month> 11-28 (Janu-ary </month> <year> 1984). </year>
Reference-contexts: 1 Introduction Libraries provide leverage in large part because they are used by many applications. As Parnas [Parnas 1972 & 1979], Lampson <ref> [Lampson 1984] </ref>, and others have noted, stable interfaces to libraries isolate the application from changes in the libraries. That is, as long as there is no change in a librarys syntax or semantics, applications can use updated libraries simply by importing and linking the new version.
Reference: [Lehman 1980] <author> M. M. Lehman, </author> <title> On understanding laws, evolution and conservation in the large-program life cycle J. </title> <journal> Syst. Softw. </journal> <volume> 1, </volume> <month> 3 </month> <year> (1980). </year>
Reference: [Lesk & Schmidt 1975] <author> M. E. Lesk and E. Schmidt, </author> <title> Lex - A Lexical Analyser Generator Computer Science Technical Report 39, </title> <institution> AT&T Bell Labs, </institution> <address> Murray Hill, NJ, USA (1975). </address>
Reference-contexts: PCCTS is similar to a more popular tool set, lex <ref> [Lesk & Schmidt 1975] </ref> and yacc [Johnson 1975] but we are using PCCTS for the following reasons: 1. PCCTS generates C++ code, 2. PCCTS coordinates very well with Sorcerer, a tree parser transformer, and 3. PCCTS provides nice error messages.
Reference: [Lieberherr & Xiao 1993] <author> Karl J. Lieberherr and Cun Xiao, </author> <booktitle> Object-oriented Software Evolution IEEE Transactions on Software Engineering 19, </booktitle> <pages> 4 pp. </pages> <month> 313-343 (April </month> <year> 1993). </year>
Reference-contexts: Second, some structural changes in the restructuring approach need not be dealt with by our change adaptation tool because they do not result in interface changes. In fact, there are a number of researchers [Johnson & Opdyke 1993], [Casais 1992], [Bergstein 1991] and <ref> [Lieberherr & Xiao 1993] </ref> working along the same line as [Griswold & Notkin 1993] i.e., maintaining changes in various different ways, not merely interface changes, within a program. However, in this kind of closed system, it is indeed required that all source code is accessible and modifiable.
Reference: [Meyer 1992] <author> Meyer, Bertrand. </author> <title> Eiffel: the language. </title> <publisher> Prentice Hall (1992). </publisher>
Reference-contexts: In some sense our model is similar to Eiffel <ref> [Meyer 1992] </ref>. The Eiffel keyword obsolete can be used to indicate something is obsolete.
Reference: [Microsoft 1994] <editor> MFC Migration Guide. </editor> <year> 1994. </year>
Reference-contexts: Typically, the programmer and the maintainer are the same person in a closed system. In the industry, however, some sort of a script is sometimes provided for people that deal with interface changes, e.g. Borlands ObjectWindows Library converter [Borland 1993b] and Microsofts migrate <ref> [Microsoft 1994] </ref>. In general, they are based on lexical analysis 16 and they also make more assumptions about the source and thus make themselves very restrictive and will work only in a narrow domain.
Reference: [Microsoft 1994] <author> Microsoft Foundation Classes 3.0: </author> <title> C++ Application Framework for Microsoft Windows (Technical White Paper), </title> <month> July </month> <year> 1994. </year>
Reference-contexts: Typically, the programmer and the maintainer are the same person in a closed system. In the industry, however, some sort of a script is sometimes provided for people that deal with interface changes, e.g. Borlands ObjectWindows Library converter [Borland 1993b] and Microsofts migrate <ref> [Microsoft 1994] </ref>. In general, they are based on lexical analysis 16 and they also make more assumptions about the source and thus make themselves very restrictive and will work only in a narrow domain.
Reference: [Murphy & Notkin 1995] <author> Gail C. Murphy and David Notkin, </author> <booktitle> Lightweight Source Model Extraction In Proceedings of the Third ACM Symposium on the Foundations of Software Engineering (FSE 95). </booktitle> <pages> 20 </pages>
Reference-contexts: Future work will be required to evaluate the effectiveness of our model and implementation. For example, some of the process may not require a complete syntax parsing of the program. Light weight lexical approaches <ref> [Murphy & Notkin 1995] </ref> can be applied when appropriate, for example. Also, the syntax of the change specification may need to be more friendly and versatile. As discussed earlier, future work should also include handling certain language features that make automatic change propagation difficult.
Reference: [Opdyke 1992] <author> William F. </author> <title> Opdyke, </title> <type> Refactoring Object-Oriented Frameworks Ph.D. Thesis. </type> <institution> University of Illinois at Urbana-Champaign (1992). </institution>
Reference: [Pancake 1995] <author> Cherri M. Pancake, </author> <title> The Promise and the Cost of Object Technology: </title> <journal> A Five-Year Forecast Communications of the ACM 38, </journal> <pages> 10 pp. </pages> <month> 33-49 (October </month> <year> 1995). </year>
Reference-contexts: The problem of how to manage such changes has not been solved, particularly if components are in use across a number of organizations or if the components have been modified or built upon in any significant way <ref> [Pancake 1995, p. 35] </ref> There are many application maintainers---since there are many applications---and (logically) only one library maintainer---since there is only one library. We require the library maintainer to annotate any changes they make to indicate what changes must be made to update the applications to accommodate the updated library.
Reference: [Parnas 1972] <author> D. L. Parnas, </author> <title> On the Criteria To Be Used in Decomposing System into Modules Communications of the ACM pp. </title> <month> 1053-1058 (December </month> <year> 1972). </year>
Reference: [Parnas 1979] <author> David L. </author> <title> Parnas, </title> <journal> Designing Software for Ease of Extension and Contraction IEEE Transactions on Software Engineering. </journal> <pages> 5(2) pp. </pages> <month> 128-138 (March </month> <year> 1979). </year>
Reference: [Parr 1994] <author> Terence J. Parr, </author> <title> An Overview of SORCERER: A Simple Tree-Parser Generator International Conference on Compiler Construction (April 1994). </title>
Reference-contexts: This allows the library maintainer to gain confidence about the interface changes by simply using existing test programs. 3.2 The implementation of our semi-automatic tool For our current prototype implementation, we use the readily available language processing tools, the Purdue Compiler Construction Tool Set (PCCTS) [Parr 1995] and Sorcerer <ref> [Parr 1994] </ref>, text processing tools such as perl [Wall & Schwartz 1990], and a collection of our C++ [Stroustrup 1991] programs that work with PCCTS and Sorcerer. The file dependency extractor, the change specification extractor, the grammar modifier, and the syntax tree transformation specification modifier are all implemented in perl.
Reference: [Parr 1995] <author> Terence J. Parr, </author> <title> Language Translation Using PCCTS and C++ (A Reference Guide). </title>
Reference-contexts: This allows the library maintainer to gain confidence about the interface changes by simply using existing test programs. 3.2 The implementation of our semi-automatic tool For our current prototype implementation, we use the readily available language processing tools, the Purdue Compiler Construction Tool Set (PCCTS) <ref> [Parr 1995] </ref> and Sorcerer [Parr 1994], text processing tools such as perl [Wall & Schwartz 1990], and a collection of our C++ [Stroustrup 1991] programs that work with PCCTS and Sorcerer.
Reference: [Stroustrup 1991] <author> Bjarne Stroustrup, </author> <title> The C++ Programming Language 2/ed. </title> <publisher> Addison-Wesley Publishing Company. </publisher> <year> (1991). </year>
Reference-contexts: programs. 3.2 The implementation of our semi-automatic tool For our current prototype implementation, we use the readily available language processing tools, the Purdue Compiler Construction Tool Set (PCCTS) [Parr 1995] and Sorcerer [Parr 1994], text processing tools such as perl [Wall & Schwartz 1990], and a collection of our C++ <ref> [Stroustrup 1991] </ref> programs that work with PCCTS and Sorcerer. The file dependency extractor, the change specification extractor, the grammar modifier, and the syntax tree transformation specification modifier are all implemented in perl. Perl scripts are very convenient here because are very portable and versatile.
Reference: [USDoD 1980] <institution> United States Department of Defense, </institution> <note> Ada Programming Language MIL-STD-1815. </note>
Reference-contexts: Our approach requires a library maintainer to specify interface changes and how existing application code can be transformed to adapt to those changes. These are specified in the interface files (e.g. .h files for C/C++ or .spc files for Ada <ref> [USDoD 1980] </ref>) that are dis tributed as part of a library. The specification of the library interface changes as well as the specification for the transformation are then extracted by a process on the application maintainers side.
Reference: [Wall & Schwartz 1990] <author> Larry Wall and Randal L. Schwartz. </author> <title> Programming perl. </title> <publisher> OReilly & Associates (1990). </publisher>
Reference-contexts: confidence about the interface changes by simply using existing test programs. 3.2 The implementation of our semi-automatic tool For our current prototype implementation, we use the readily available language processing tools, the Purdue Compiler Construction Tool Set (PCCTS) [Parr 1995] and Sorcerer [Parr 1994], text processing tools such as perl <ref> [Wall & Schwartz 1990] </ref>, and a collection of our C++ [Stroustrup 1991] programs that work with PCCTS and Sorcerer. The file dependency extractor, the change specification extractor, the grammar modifier, and the syntax tree transformation specification modifier are all implemented in perl.
References-found: 28

