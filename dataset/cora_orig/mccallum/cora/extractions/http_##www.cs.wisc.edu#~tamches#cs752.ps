URL: http://www.cs.wisc.edu/~tamches/cs752.ps
Refering-URL: 
Root-URL: 
Title: Analysis of RISC Instruction Set Enhancement  
Author: Subramanian Muralidhar Chandrasekaran Sashikanth Ariel Tamches 
Date: December 20, 1993  
Abstract: Instruction set measurements help architects design and implement better architectures. This paper analyzes the potential effect of instruction set enhancements to a conventional RISC architecture, in particular, the effects of adding floating point multiply-add and update mode addressing to the MIPS instruction set. By analyzing basic blocks of floating point benchmark programs to calculate potential enhanced instruction frequency and by profiling the program, an estimate of potential profitability is derived. For the SPECFP '92 benchmarks, overall speedups from between 3% and 22% were calculated, varying widely depending on the individual program and the compiler's optimization setting.
Abstract-found: 1
Intro-found: 1
Reference: [ASU86] <author> Alfred Aho, Ravi Sethi, and Jeffrey D. Ullman. </author> <booktitle> Compilers: Principles, Techniques and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: found in pages A-87 and B-28 of [Kan89]; they will not be discussed further. 8 General-purpose (integer) register, floating point register, floating point control register. 9 5 The DAG representation of basic blocks Directed acyclic dependence graphs, or DAGs, are useful data structures for implementing transformations and analyzing basic blocks <ref> [ASU86] </ref>. A DAG gives a precise picture of the data dependencies in the block. Constructing a DAG from three-address statements (in our case, assembly instructions) is a good way of determining the order of operations that are performed in the basic block, along with their operands. <p> Rather we append the destination operand to the list of names for the "current" value of the source operand. Some instructions like neg and abs are one operand instructions and those nodes have only a left child. For more details of this algorithm, the reader is referred to <ref> [ASU86] </ref>.
Reference: [Kan89] <author> Gerry Kane. </author> <title> MIPS RISC Architecture. </title> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: Disappointed readers can take heart that our measurements show update-mode addressing to be very useful on average; much more so than FMA. 1.3 Problem Description Our project analyzes floating point update-mode addressing and multiply-add instructions potential in the MIPS instruction set <ref> [Kan89] </ref>. Both static and dynamic measurements were considered; but, in understanding performance benefits, static measurements are of little interest. <p> The only surprise in these routines was in MakeInstr; for a RISC architecture, the MIPS instruction set is relatively difficult to parse. Details can be found in pages A-87 and B-28 of <ref> [Kan89] </ref>; they will not be discussed further. 8 General-purpose (integer) register, floating point register, floating point control register. 9 5 The DAG representation of basic blocks Directed acyclic dependence graphs, or DAGs, are useful data structures for implementing transformations and analyzing basic blocks [ASU86].
Reference: [Lar93] <author> James Larus. xspim, </author> <month> August 23 </month> <year> 1993. </year> <title> Unix manual page. </title>
Reference-contexts: This causes the program to trap on every instruction execution, allowing a measurement program to collect data [TZ89]. * Build an interpreter for the architecture <ref> [Shu78, Lar93] </ref>. * Instrument the object module, producing a monitoring file used to produce detailed exe cution statistics. Unfortunately, all these methods are of little use in performing static or dynamic measurements of the usage of non-existing instructions.
Reference: [LB92] <author> James Larus and Thomas Ball. </author> <title> Rewriting executable files to measure program behavior. </title> <type> Technical Report Number 1083, </type> <institution> University of Wisconsin Computer Sciences Department, </institution> <month> March </month> <year> 1992. </year> <month> 19 </month>
Reference-contexts: Section 3 briefly introduces why QPT <ref> [LB92] </ref>, a program profiler which rewrites executable files, is the ideal basis for performing an instruction set analysis on executable files. Section 4 briefly discusses techniques used to parse MIPS machine instructions, extracting opcode, registers used, and so on in an abstract manner. <p> As it turns out, performing our analysis on existing binaries is the best method. Such an approach is compiler-independent, source-language independent, and does not erroneously exclude linked-in code. The existence of QPT <ref> [LB92] </ref> greatly aided the inherently complex task of parsing executable files, enabling us to focus more effort on construction and analysis of our dependence dag for calculating instruction set savings. 5 2.1 Algorithm Overview A basic block is a sequence of consecutive statements in which control flow enters at the beginning <p> On the flip side, source code analysis would require building the better part of two custom compilers (for FORTRAN and C), an impractical proposition for a semester project. For many reasons, analyzing executable code turns out to be the most attractive option. First and foremost, an existing tool, QPT <ref> [LB92] </ref>, handles much of the mundane parsing and analysis of executable files.
Reference: [Shu78] <author> L. J. Shustek. </author> <title> Analysis and Performance of Computer Instruction Sets. </title> <type> PhD thesis, </type> <institution> Stanford Univ., </institution> <year> 1978. </year>
Reference-contexts: This causes the program to trap on every instruction execution, allowing a measurement program to collect data [TZ89]. * Build an interpreter for the architecture <ref> [Shu78, Lar93] </ref>. * Instrument the object module, producing a monitoring file used to produce detailed exe cution statistics. Unfortunately, all these methods are of little use in performing static or dynamic measurements of the usage of non-existing instructions.
Reference: [Soh93] <author> Gurindar Sohi, </author> <month> November 4 </month> <year> 1993. </year> <title> EMail correspondence. "The IBM RS/6000 papers have some discussion of load-update and multiply-add. Other than that, there are no papers that are published [regarding instruction set enhancements]". </title>
Reference-contexts: At a high-level, these measurements are background data used by computer architects every day, helping eliminate expensive, infrequently used instructions and addressing modes in favor of optimized, commonly-used ones. Yet notwithstanding the importance of the instruction set in computer architectures, there is still a dearth of published studies <ref> [Soh93] </ref>, which this paper attempts to address. 1 1.1 Recent Instruction Set Enhancements Recently, some of the conventional thinking related to pure RISC architectures has been challenged.
Reference: [TZ89] <author> Adams T. and R. Zimmerman. </author> <title> An analysis of 8086 instruction set usage in ms-dos programs. </title> <booktitle> Proc. Third Symposium on Architectural Support for Programming Languages and Systems, </booktitle> <pages> pages 152-161, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: This causes the program to trap on every instruction execution, allowing a measurement program to collect data <ref> [TZ89] </ref>. * Build an interpreter for the architecture [Shu78, Lar93]. * Instrument the object module, producing a monitoring file used to produce detailed exe cution statistics. Unfortunately, all these methods are of little use in performing static or dynamic measurements of the usage of non-existing instructions.
Reference: [WD93] <author> Steven White and Sudhir Dhawan. Power2: </author> <title> Next generation of the risc system/6000 family. </title> <journal> IBM RISC System/6000 Technology, </journal> <volume> 2 </volume> <pages> 2-12, </pages> <month> September </month> <year> 1993. </year> <month> 20 </month>
Reference-contexts: Several recent architectures, notably IBM RS/6000 and Dec Alpha AXP, have successfully included a few such enhancements. 1 1.1.1 The RS/6000 Architecture The IBM RS/6000 <ref> [WD93] </ref> is an example of a RISC architecture which includes several instruction set enhancements. Two of these are 1) Floating-Point Multiply-Add (FMA), and 2) Update forms of storage references. <p> There are certainly specialized programs where FMA frequency can be higher (and the RS/6000 papers <ref> [WD93] </ref> go to great lengths to show them), but as a general rule, adding FMA was a mistake if it added more than ~ 4% to the cycle time 4 .
References-found: 8

