URL: ftp://ftp.cs.man.ac.uk/pub/TR/UMCS-98-6-1-gluck.ps.Z
Refering-URL: ftp://ftp.cs.man.ac.uk/pub/TR/UMCS-98-6-1.html
Root-URL: http://www.cs.man.ac.uk
Title: Generalization in Hierarchies of Online Program Specialization Systems (Extended Abstract)  
Author: Robert Gluck John Hatcliff Jesper Jorgensen 
Abstract: In recent work, we proposed a simple functional language S-graph-n to study meta-programming aspects of self-applicable online program specialization. The primitives of the language provide support for multiple encodings of programs. An important component of online program specialization is the termination strategy. In this paper we show that such a representation has the great advantage of simplifying generalization of multiply encoded data. We extend two basic methods to multiply encoded data: most specific generalization and the homeomorphic embedding relation. Examples illustrate their working in hierarchies of programs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Alpuente, M. Falaschi, and G. Vidal. </author> <title> Narrowing-driven partial evaluation of functional logic programs. </title> <editor> In H.R. Nielson, editor, </editor> <booktitle> European Symposium on Programming, Lecture Notes in Computer Science, </booktitle> <pages> pages 46-61. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: The encoding of programs as data is called metacoding [18]. For example, (CONS 2 (ATOM 2 a) (ATOM 2 b)) (1) is an expression encoded twice. The area of online program specialization (partial deduction, supercompilation) has seen a recent flurry of activity on generalization and termination properties <ref> [1, 4, 13, 14, 18, 19] </ref>. Two popular methods used in single-level systems are: most specific generalization and the homeomorphic embedding relation. <p> First we give an example that introduces the notation, then we illustrate a case of self-application. The specializer has two arguments: tree and def where tree is the initial expression (metacoded once) and def contains the definitions of the program to be specialized. argument is known (the list <ref> [1, 2] </ref>) and the accumulator (a) is unknown (a metavariable on level 0 with elevation 0). A multi-level example We now turn to a multi-level example. <p> Variants of this relation are used in termination proofs for term rewrite systems [6] and for ensuring local termination of partial deduction [4]. After it was taken up in [14], it has inspired more recent work <ref> [1, 13, 19, 18] </ref>. 9 7 Conclusion Our goal was to clarify foundational issues of generalization and termination in hierarchies of programs with multiple encoded data. We examined two popular methods, most specific generalization and the homeomorphic embedding relation, proved their properties and illustrated their working with simple examples.
Reference: [2] <author> K. Apt and F. </author> <title> Turini Meta-Logics and Logic Programming, </title> <publisher> MIT Press, </publisher> <year> 1995. </year>
Reference-contexts: Program p 1 may be manipulating another program p 2 , and so on. A metasystem hierarchy can be illustrated using a metasystem transition scheme as in Figure 1 [18]. The representation of programs and data has been discussed especially in the context of logic programming <ref> [2] </ref>. The present work addresses these open issues in the context of S-graph-n | a simple functional language which provides primitives for manipulating metacode and metavariables. <p> First we give an example that introduces the notation, then we illustrate a case of self-application. The specializer has two arguments: tree and def where tree is the initial expression (metacoded once) and def contains the definitions of the program to be specialized. argument is known (the list <ref> [1, 2] </ref>) and the accumulator (a) is unknown (a metavariable on level 0 with elevation 0). A multi-level example We now turn to a multi-level example.
Reference: [3] <author> J. Barklund. </author> <title> A basis for a multilevel metalogic programming language. </title> <type> Technical Report 81, </type> <institution> Uppsala University, Dept. of Computing Science, </institution> <year> 1994. </year>
Reference-contexts: Multi-level metaprogramming languages that support this style of metaprogramming have been advocated, e.g. <ref> [3, 16] </ref>. They are a key ingredient in the design and implementation of generative software, e.g. [7]. In recent work [10], we proposed a simple language S-graph-n to study meta-programming aspects of self-applicable online program specialization. <p> In recent work [10], we proposed a simple language S-graph-n to study meta-programming aspects of self-applicable online program specialization. MetaML, a statically typed multi-level language for hand-writing multi-level generating extensions was introduced in [16]. Another multi-level programming language is Alloy <ref> [3] </ref>, a logic language which provides facilities for deductions at different meta-levels and a proof system for interleaving computations at different metalevels. A program generator for multi-level specialization [9] uses a functional language extended with multiple-binding times as representation of multi-level generating extensions.
Reference: [4] <author> R. Bol. </author> <title> Loop checking in partial deduction. </title> <journal> J of Logic Programming, </journal> 16(1&2):25-46, 1993. 
Reference-contexts: The encoding of programs as data is called metacoding [18]. For example, (CONS 2 (ATOM 2 a) (ATOM 2 b)) (1) is an expression encoded twice. The area of online program specialization (partial deduction, supercompilation) has seen a recent flurry of activity on generalization and termination properties <ref> [1, 4, 13, 14, 18, 19] </ref>. Two popular methods used in single-level systems are: most specific generalization and the homeomorphic embedding relation. <p> They allow the design and implementation of generative software [7]. Most specific generalization and the homeomorphic embedding relation are known from term algebra [6]. Variants of this relation are used in termination proofs for term rewrite systems [6] and for ensuring local termination of partial deduction <ref> [4] </ref>. After it was taken up in [14], it has inspired more recent work [1, 13, 19, 18]. 9 7 Conclusion Our goal was to clarify foundational issues of generalization and termination in hierarchies of programs with multiple encoded data.
Reference: [5] <author> O. Danvy, R. Gluck, and P. Thiemann, </author> <title> editors. Partial Evaluation, </title> <booktitle> volume 1110 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference: [6] <author> N. Dershowitz and J.-P. Jouannaud. </author> <title> Rewrite systems. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <pages> pages 244-320. </pages> <publisher> Elsevier, </publisher> <year> 1992. </year>
Reference-contexts: [DIVE-R] msg 2 ((CONS 3 Y 2 2 Y 2 2 ); (CONS 3 Z 3 2 Z 3 2 )) = ((CONS 3 X 2 0 X 2 0 := Y 2 0 := Z 3 4 Embedding of Configuration Values The homeomorphic embedding relation known from term algebra <ref> [6] </ref> can be used to ensure that unfolding during a specialization process does not proceed infinitely. <p> A program generator for multi-level specialization [9] uses a functional language extended with multiple-binding times as representation of multi-level generating extensions. They allow the design and implementation of generative software [7]. Most specific generalization and the homeomorphic embedding relation are known from term algebra <ref> [6] </ref>. Variants of this relation are used in termination proofs for term rewrite systems [6] and for ensuring local termination of partial deduction [4]. <p> They allow the design and implementation of generative software [7]. Most specific generalization and the homeomorphic embedding relation are known from term algebra <ref> [6] </ref>. Variants of this relation are used in termination proofs for term rewrite systems [6] and for ensuring local termination of partial deduction [4]. After it was taken up in [14], it has inspired more recent work [1, 13, 19, 18]. 9 7 Conclusion Our goal was to clarify foundational issues of generalization and termination in hierarchies of programs with multiple encoded data.
Reference: [7] <author> U. Eisenecker. </author> <title> Generative programming with C++. </title> <editor> In H. Mossenbock, editor, </editor> <booktitle> Modular Programming Languages, volume 1204 of Lecture Notes in Computer Science, </booktitle> <pages> pages 351-365. </pages> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: Multi-level metaprogramming languages that support this style of metaprogramming have been advocated, e.g. [3, 16]. They are a key ingredient in the design and implementation of generative software, e.g. <ref> [7] </ref>. In recent work [10], we proposed a simple language S-graph-n to study meta-programming aspects of self-applicable online program specialization. The primitives of the language provide support for multiple encodings of programs and the use of metavariables to track unknown values. <p> A program generator for multi-level specialization [9] uses a functional language extended with multiple-binding times as representation of multi-level generating extensions. They allow the design and implementation of generative software <ref> [7] </ref>. Most specific generalization and the homeomorphic embedding relation are known from term algebra [6]. Variants of this relation are used in termination proofs for term rewrite systems [6] and for ensuring local termination of partial deduction [4].
Reference: [8] <author> R. Gluck. </author> <title> On the mechanics of metasystem hierarchies in program transformation. </title> <editor> In M. Proietti, editor, </editor> <title> Logic Program Synthesis and Transformation (LoPSTr'95), </title> <booktitle> volume 1048 of Lecture Notes in Computer Science, </booktitle> <pages> pages 234-251. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: (CONS 2 (ATOM 3 a) (ATOM 3 a)); : : : ; (CONS 2 (ATOM 3 a) (ATOM 2 b)); (CONS 2 (ATOM 3 a) (ATOM 3 b)); : : : ; g 1 The reader should be warned that our definition of metavariable degree differs slightly from other work <ref> [8, 20] </ref>. In those works, our metavariable of degree n has degree n + 1. 4 Most specific domain index Clearly, for every cval n there exists an i such that [[cval n ]] n domain (X n i ) (one can always take i = 0). <p> Subsequently, these concepts have been formalized <ref> [8] </ref> and studied in different contexts, e.g. [18].
Reference: [9] <author> R. Gluck and J. Jorgensen. </author> <title> An automatic program generator for multi-level specialization. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 10(2) </volume> <pages> 113-158, </pages> <year> 1997. </year>
Reference-contexts: MetaML, a statically typed multi-level language for hand-writing multi-level generating extensions was introduced in [16]. Another multi-level programming language is Alloy [3], a logic language which provides facilities for deductions at different meta-levels and a proof system for interleaving computations at different metalevels. A program generator for multi-level specialization <ref> [9] </ref> uses a functional language extended with multiple-binding times as representation of multi-level generating extensions. They allow the design and implementation of generative software [7]. Most specific generalization and the homeomorphic embedding relation are known from term algebra [6].
Reference: [10] <author> J. Hatcliff and R. Gluck. </author> <title> Reasoning about hierarchies of online specialization systems. </title> <editor> In Danvy et al. </editor> <volume> [5]. </volume>
Reference-contexts: Multi-level metaprogramming languages that support this style of metaprogramming have been advocated, e.g. [3, 16]. They are a key ingredient in the design and implementation of generative software, e.g. [7]. In recent work <ref> [10] </ref>, we proposed a simple language S-graph-n to study meta-programming aspects of self-applicable online program specialization. The primitives of the language provide support for multiple encodings of programs and the use of metavariables to track unknown values. <p> Our goal is to clarify issues of generalization and termination across multi-level hierarchies of programs. 2 S-Graph-n In this section we present the language S-Graph-n and its meta-programming concepts. The full language is given in <ref> [10] </ref>; here we only consider a language fragment. 2.1 Syntax restricted to tail-recursion. <p> The components CONS n and ATOM n are the usual constructors for S-expressions, MV n is a constructor for metavariables (their use will be explained later). The full language <ref> [10] </ref> includes indexed components for each construct of the language (e.g., IF n , LET n , etc.). The test cntr in a conditional may update the environment. <p> There is even the risk that naive generalization of structures containing multiply encoded data such as those above will destroy some encoding structures. Level indexed data is conceptually simpler and easier to reason about <ref> [10] </ref>. 3 Metacoding The indexed constructs of S-Graph-n provide a concise and natural representa-tion of programs as data. A program component is metacoded by simply increasing its numerical index. <p> = 2 (6) msdi 3 ((CONS 5 (ATOM 6 a) (ATOM 4 b))) = 0 (7) 3 Generalization of Configuration Values The explicit identification of the hierarchical position of values given by configuration values is a key component of the strategy for successful self-application of online specializers given in e.g., <ref> [20, 10] </ref>. This work describes how configuration values and metavariables are used to propagate information during specialization. An equally important component is the termination strategy: avoiding an infinite sequence of specialization states by folding back to some previously encountered specialization state. <p> Representing and reasoning about object level theories is an important field in logic and artificial intelligence (e.g. different encodings have been discussed in [11]) and has led to the development of logic languages that support declarative metaprogramming (e.g. the programming language Godel [12]). In recent work <ref> [10] </ref>, we proposed a simple language S-graph-n to study meta-programming aspects of self-applicable online program specialization. MetaML, a statically typed multi-level language for hand-writing multi-level generating extensions was introduced in [16].
Reference: [11] <author> P. Hill and J. Gallagher. </author> <title> Meta-programming in logic programming. </title> <type> Technical Report 94.22, </type> <institution> School of Computer Studies, University of Leeds, </institution> <year> 1994. </year>
Reference-contexts: Subsequently, these concepts have been formalized [8] and studied in different contexts, e.g. [18]. Representing and reasoning about object level theories is an important field in logic and artificial intelligence (e.g. different encodings have been discussed in <ref> [11] </ref>) and has led to the development of logic languages that support declarative metaprogramming (e.g. the programming language Godel [12]). In recent work [10], we proposed a simple language S-graph-n to study meta-programming aspects of self-applicable online program specialization.
Reference: [12] <author> P. Hill and J.W. Lloyd. </author> <title> The Godel Programming Language. </title> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: Representing and reasoning about object level theories is an important field in logic and artificial intelligence (e.g. different encodings have been discussed in [11]) and has led to the development of logic languages that support declarative metaprogramming (e.g. the programming language Godel <ref> [12] </ref>). In recent work [10], we proposed a simple language S-graph-n to study meta-programming aspects of self-applicable online program specialization. MetaML, a statically typed multi-level language for hand-writing multi-level generating extensions was introduced in [16].
Reference: [13] <author> M. Leuschel and B. Martens. </author> <title> Global control for partial deduction through characteristic atoms and global trees. </title> <editor> In Danvy et al. </editor> <volume> [5], </volume> <pages> pages 263-283. </pages>
Reference-contexts: The encoding of programs as data is called metacoding [18]. For example, (CONS 2 (ATOM 2 a) (ATOM 2 b)) (1) is an expression encoded twice. The area of online program specialization (partial deduction, supercompilation) has seen a recent flurry of activity on generalization and termination properties <ref> [1, 4, 13, 14, 18, 19] </ref>. Two popular methods used in single-level systems are: most specific generalization and the homeomorphic embedding relation. <p> Variants of this relation are used in termination proofs for term rewriting systems and for ensuring termination of partial deduction and supercompilation, e.g. in <ref> [13, 14, 18] </ref>. In our setting, the embedding relation works on specialization states described by configuration values. <p> Variants of this relation are used in termination proofs for term rewrite systems [6] and for ensuring local termination of partial deduction [4]. After it was taken up in [14], it has inspired more recent work <ref> [1, 13, 19, 18] </ref>. 9 7 Conclusion Our goal was to clarify foundational issues of generalization and termination in hierarchies of programs with multiple encoded data. We examined two popular methods, most specific generalization and the homeomorphic embedding relation, proved their properties and illustrated their working with simple examples.
Reference: [14] <author> M.H. Sorensen, R. Gluck, and N.D. Jones. </author> <title> A positive supercompiler. </title> <journal> Journal of Functional Programming, </journal> <volume> 6(6) </volume> <pages> 811-838, </pages> <year> 1996. </year>
Reference-contexts: The encoding of programs as data is called metacoding [18]. For example, (CONS 2 (ATOM 2 a) (ATOM 2 b)) (1) is an expression encoded twice. The area of online program specialization (partial deduction, supercompilation) has seen a recent flurry of activity on generalization and termination properties <ref> [1, 4, 13, 14, 18, 19] </ref>. Two popular methods used in single-level systems are: most specific generalization and the homeomorphic embedding relation. <p> Variants of this relation are used in termination proofs for term rewriting systems and for ensuring termination of partial deduction and supercompilation, e.g. in <ref> [13, 14, 18] </ref>. In our setting, the embedding relation works on specialization states described by configuration values. <p> Most specific generalization and the homeomorphic embedding relation are known from term algebra [6]. Variants of this relation are used in termination proofs for term rewrite systems [6] and for ensuring local termination of partial deduction [4]. After it was taken up in <ref> [14] </ref>, it has inspired more recent work [1, 13, 19, 18]. 9 7 Conclusion Our goal was to clarify foundational issues of generalization and termination in hierarchies of programs with multiple encoded data.
Reference: [15] <author> M.H. Sorensen and R. Gluck. </author> <title> An algorithm of generalization in positive supercompilation. </title> <editor> In J.W. Lloyd, editor, </editor> <booktitle> Logic Programming: Proceedings of the 1995 International Symposium, </booktitle> <pages> pages 465-479. </pages> <publisher> MIT Press, </publisher> <year> 1995. </year>
Reference-contexts: In other words, the least loss of information occurs. These concepts can be formalized by extending familiar concepts of most-specific generalization, as applied previously to program specialization in e.g., <ref> [15] </ref>, to level-index constructors and elevated metavariables. A binding X n h := cval is a metavariable/configuration value pair. A binding is elevation compatible when h msdi n (cval). Note that this ensures [[cval]] n domain (X n h ).
Reference: [16] <author> W. Taha and T. Sheard. </author> <title> Multi-stage programming with explicit annotations. </title> <booktitle> In Symposium on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <pages> pages 203-217, </pages> <year> 1997. </year>
Reference-contexts: Multi-level metaprogramming languages that support this style of metaprogramming have been advocated, e.g. <ref> [3, 16] </ref>. They are a key ingredient in the design and implementation of generative software, e.g. [7]. In recent work [10], we proposed a simple language S-graph-n to study meta-programming aspects of self-applicable online program specialization. <p> In recent work [10], we proposed a simple language S-graph-n to study meta-programming aspects of self-applicable online program specialization. MetaML, a statically typed multi-level language for hand-writing multi-level generating extensions was introduced in <ref> [16] </ref>. Another multi-level programming language is Alloy [3], a logic language which provides facilities for deductions at different meta-levels and a proof system for interleaving computations at different metalevels. A program generator for multi-level specialization [9] uses a functional language extended with multiple-binding times as representation of multi-level generating extensions.
Reference: [17] <author> V.F. Turchin. </author> <title> The concept of a supercompiler. </title> <journal> Transactions on Programming Languages and Systems, </journal> <volume> 8(3) </volume> <pages> 292-325, </pages> <year> 1986. </year>
Reference-contexts: The full language [10] includes indexed components for each construct of the language (e.g., IF n , LET n , etc.). The test cntr in a conditional may update the environment. We excerpt two illustrative contractions <ref> [17] </ref> from the full language: * (EQA? arg 1 arg 2 ) | tests the equality of two atoms arg 1 , arg 2 of degree 0. <p> For our example Figure 7 shows the msg of (1) and (2) that is obtained by the the method shown in Figure 4. 6 Related Work The ideas present in this paper have been heavily influenced by three concepts present in Turchin's work <ref> [17] </ref>: metacoding, metavariables, and metasystem transition. Subsequently, these concepts have been formalized [8] and studied in different contexts, e.g. [18].
Reference: [18] <editor> V.F. Turchin. Metacomputation: Metacomputation: metasystem transitions plus supercompilation. In Danvy et al. </editor> <volume> [5]. </volume>
Reference-contexts: Program p 1 may be manipulating another program p 2 , and so on. A metasystem hierarchy can be illustrated using a metasystem transition scheme as in Figure 1 <ref> [18] </ref>. The representation of programs and data has been discussed especially in the context of logic programming [2]. The present work addresses these open issues in the context of S-graph-n | a simple functional language which provides primitives for manipulating metacode and metavariables. <p> The encoding of programs as data is called metacoding <ref> [18] </ref>. For example, (CONS 2 (ATOM 2 a) (ATOM 2 b)) (1) is an expression encoded twice. The area of online program specialization (partial deduction, supercompilation) has seen a recent flurry of activity on generalization and termination properties [1, 4, 13, 14, 18, 19]. <p> The encoding of programs as data is called metacoding [18]. For example, (CONS 2 (ATOM 2 a) (ATOM 2 b)) (1) is an expression encoded twice. The area of online program specialization (partial deduction, supercompilation) has seen a recent flurry of activity on generalization and termination properties <ref> [1, 4, 13, 14, 18, 19] </ref>. Two popular methods used in single-level systems are: most specific generalization and the homeomorphic embedding relation. <p> In a metasystem hierarchy, such as displayed in Figure 1, programs may be metacoded many times. For example, program p n of Figure 1 must be metacoded (directly or indirectly) n times, since n systems lie above it in the hierarchy. Metasystem hierarchies are a cornerstone of Turchin's approach <ref> [18] </ref>: the construction of hierarchies of arbitrary height is taken as the basis for program analysis and transformation (in contrast to logics and mathematics which usually deal with two-level hierarchies). <p> Variants of this relation are used in termination proofs for term rewriting systems and for ensuring termination of partial deduction and supercompilation, e.g. in <ref> [13, 14, 18] </ref>. In our setting, the embedding relation works on specialization states described by configuration values. <p> Subsequently, these concepts have been formalized [8] and studied in different contexts, e.g. <ref> [18] </ref>. Representing and reasoning about object level theories is an important field in logic and artificial intelligence (e.g. different encodings have been discussed in [11]) and has led to the development of logic languages that support declarative metaprogramming (e.g. the programming language Godel [12]). <p> Variants of this relation are used in termination proofs for term rewrite systems [6] and for ensuring local termination of partial deduction [4]. After it was taken up in [14], it has inspired more recent work <ref> [1, 13, 19, 18] </ref>. 9 7 Conclusion Our goal was to clarify foundational issues of generalization and termination in hierarchies of programs with multiple encoded data. We examined two popular methods, most specific generalization and the homeomorphic embedding relation, proved their properties and illustrated their working with simple examples.
Reference: [19] <author> V.F. Turchin. </author> <title> On generalization of lists and strings in supercompilation. </title> <type> Technical Report CSc. TR 96-002, </type> <institution> City College of the City University of New York, </institution> <year> 1996. </year>
Reference-contexts: The encoding of programs as data is called metacoding [18]. For example, (CONS 2 (ATOM 2 a) (ATOM 2 b)) (1) is an expression encoded twice. The area of online program specialization (partial deduction, supercompilation) has seen a recent flurry of activity on generalization and termination properties <ref> [1, 4, 13, 14, 18, 19] </ref>. Two popular methods used in single-level systems are: most specific generalization and the homeomorphic embedding relation. <p> Variants of this relation are used in termination proofs for term rewrite systems [6] and for ensuring local termination of partial deduction [4]. After it was taken up in [14], it has inspired more recent work <ref> [1, 13, 19, 18] </ref>. 9 7 Conclusion Our goal was to clarify foundational issues of generalization and termination in hierarchies of programs with multiple encoded data. We examined two popular methods, most specific generalization and the homeomorphic embedding relation, proved their properties and illustrated their working with simple examples.
Reference: [20] <author> V.F. Turchin and A.P. Nemytykh. Metavariables: </author> <title> their implementation and use in program transformation. </title> <type> CSc. TR 95-012, </type> <institution> City College of the City University of New York, </institution> <year> 1995. </year> <month> 10 </month>
Reference-contexts: (CONS 2 (ATOM 3 a) (ATOM 3 a)); : : : ; (CONS 2 (ATOM 3 a) (ATOM 2 b)); (CONS 2 (ATOM 3 a) (ATOM 3 b)); : : : ; g 1 The reader should be warned that our definition of metavariable degree differs slightly from other work <ref> [8, 20] </ref>. In those works, our metavariable of degree n has degree n + 1. 4 Most specific domain index Clearly, for every cval n there exists an i such that [[cval n ]] n domain (X n i ) (one can always take i = 0). <p> = 2 (6) msdi 3 ((CONS 5 (ATOM 6 a) (ATOM 4 b))) = 0 (7) 3 Generalization of Configuration Values The explicit identification of the hierarchical position of values given by configuration values is a key component of the strategy for successful self-application of online specializers given in e.g., <ref> [20, 10] </ref>. This work describes how configuration values and metavariables are used to propagate information during specialization. An equally important component is the termination strategy: avoiding an infinite sequence of specialization states by folding back to some previously encountered specialization state.
References-found: 20

