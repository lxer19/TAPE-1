URL: http://www.cs.utexas.edu/users/markus/diss/diss.ps.Z
Refering-URL: http://www.cs.utexas.edu/users/markus/diss.html
Root-URL: http://www.cs.utexas.edu
Title: by  
Author: Markus Kaltenbach 
Date: 1996  
Note: Copyright  
Abstract-found: 0
Intro-found: 1
Reference: [Ada95] <author> W. Adams. </author> <title> Concurrent programming witha single thread of control. </title> <type> PhD dissertation proposal, </type> <institution> The University of Texas at Austin, </institution> <month> April </month> <year> 1995. </year>
Reference: [AS85] <author> B. Alpern and F. B. Schneider. </author> <title> Defining liveness. </title> <journal> Information Processing Letters, </journal> <volume> 21 </volume> <pages> 181-185, </pages> <year> 1985. </year>
Reference-contexts: Different from safety properties, which are informally described as expressing that "nothing bad ever happens ", progress properties inherently refer to infinite program executions in that finite prefixes of program executions do not suffice to characterize them <ref> [AS85] </ref>. Automatic Checking of Progress Properties is Difficult in Practice In chapter 3 we have seen how checking safety properties of UNITY programs can be reduced to checking certain local conditions and to finding suitably strong invariants.
Reference: [Bak92] <author> H. G. Baker. </author> <title> The treadmill: Real-time garbage collection without motion sickness. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 27(3), </volume> <month> March </month> <year> 1992. </year>
Reference-contexts: Finally the OBDD package and its memory management (including a non-incremental version of a treadmill garbage collector <ref> [Bak92] </ref>) have been developed as part of the system in order to facilitate a seamless interaction with the other system components while retaining the possibility of modifying the system as part of future research.
Reference: [BBR90] <author> K. S. Brace, R. E. Bryant, and R. L. Rudell. </author> <title> Efficient implementation of a BDD package. </title> <booktitle> In Proceedings of the 27th ACM/IEEE Design Automation Conference, </booktitle> <year> 1990. </year>
Reference-contexts: Nonetheless, it was important to provide an efficient implementation of the low-level symbolic representation structures and manipulation operations documented in the literature. The techniques and methods currently implemented include the use of reduced OBDDs as described in <ref> [BBR90] </ref>, of a combined and-exists operation in computing relational products ([McM93], of quantification ordering in synchronous transitions similar to those described in [BCM91], of restriction [CM90], and generalized cofactoring [TSL + 90].
Reference: [BC95] <author> R. E. Bryant and Y.-A. Chen. </author> <title> Verification of arithmetic functions with binary moment diagrams. </title> <booktitle> In Design Automation conference, </booktitle> <pages> pages 535-541, </pages> <year> 1995. </year>
Reference-contexts: Moreover, some programs that do not have an efficient encoding using OBDDs (e.g. multiplier circuits) have been successfully verified using extensions of OBBDs. By encoding word-level operations (instead of bit-level operations as done with OBDDs), data structures such as binary moment diagrams <ref> [BC95] </ref> made it possible to solve previously intractable problems [CZ96]. Altogether, model checking has become a very powerful verification technique, that can be easily used in practice (at least compared with approaches based on theorem proving), due to its mostly automated nature.
Reference: [BCM91] <author> J. R. Burch, E. M. Clarke, and K. M. McMillan. </author> <title> Representing circuits more efficiently in symbolic model checking. </title> <booktitle> In Proccedings of the 28th Design Automation Conference 1991, </booktitle> <pages> pages 403-407, </pages> <year> 1991. </year>
Reference-contexts: This form of partitioning is long known to result in a significant increase of the applicability of BDD-based symbolic computations <ref> [BCM91] </ref>, and can be directly derived from a given UNITY program at no extra cost. <p> The techniques and methods currently implemented include the use of reduced OBDDs as described in [BBR90], of a combined and-exists operation in computing relational products ([McM93], of quantification ordering in synchronous transitions similar to those described in <ref> [BCM91] </ref>, of restriction [CM90], and generalized cofactoring [TSL + 90].
Reference: [Bra93] <author> J. C. Bradfield. </author> <title> Verifying Temporal properties of Systems. </title> <booktitle> Progress in Temporal Computer Science. </booktitle> <publisher> Birkhauser, </publisher> <year> 1993. </year> <month> 261 </month>
Reference-contexts: However, some model checking algorithms have been extended to unbounded or some restricted infinite state spaces, and some procedures have been developed typically based on the local paradigm to deal with infinite state spaces in general <ref> [Bra93] </ref>. A feature of model checking algorithms that is essential for their use in industrial environments is their ability to generate counterexamples from failed model checking attempts. In large scale applications it is often a serious problem to model programs in the context of insufficiently specified environments. <p> On the theoretical side it will be interesting to explore the relationship of our theory to automata-theoretic approaches [Kur94], to deductive systems based on linear temporal logic [M + 94], or on the propositional mu-calculus <ref> [Koz83, Bra93] </ref>. It will be worthwhile to investigate to which extent the ideas of formalizing hints and of incorporating design knowledge at various levels of detail could be exploited by these other approaches.
Reference: [Bro93] <author> M. Broy. </author> <title> Program Design Calculi, chapter (Inter-)Action Refinement: The Easy Way. </title> <publisher> Springer Verlag, </publisher> <year> 1993. </year>
Reference-contexts: For every game g we denote by g the run obtained by concatenating all rounds of g in order. Formally, hi = hi g = g:0 ++ tail :g if jgj &gt; 0 Note that g is well defined also for infinite g (cf. <ref> [Sto81, Bro93] </ref>). Next we will define the notion of a strategy of F for regular expressions W in R F .
Reference: [Bry86] <author> R. E. Bryant. </author> <title> Graph-based algorithms for Boolean function manipulation. </title> <journal> IEEE Transactions on Computing, </journal> <volume> (6), </volume> <year> 1986. </year>
Reference-contexts: A practical breakthrough in the application of model checking techniques to large programs was accomplished through the introduction of ordered binary decision diagrams (OBDDs) <ref> [Bry86] </ref> and their incorporation into model checking algorithms [McM92, Pix90, CBM89]. The idea behind OBDDs is to encode sets of states and transition relations that are relevant for the calculations of a symbolic model checking algorithm by boolean functions over the state space of the program. <p> Efficient Symbolic Representation: expressions and formulae used to represent various parts of the programs and properties under consideration are encoded and represented by ordered binary decision diagrams (OBDDs, <ref> [Bry86] </ref>), and can, therefore, often be stored and manipulated very efficiently.
Reference: [Car94] <author> A. Carruth. </author> <title> Real-time UNITY. </title> <type> Technical Report TR94-10, </type> <institution> University of Texas at Austin, Austin, Texas, </institution> <month> April </month> <year> 1994. </year>
Reference-contexts: Since its introduction in [CM88] the UNITY theory has been thoroughly investigated [M + 90] and simplified [Mis95b], it has been applied to a variety of interesting problems [Sta92], and been used as a foundation for other theories and formalisms <ref> [Car94, CWB94, CR90] </ref>. UNITY is Suitable for Program Design and Verification There are several reasons why UNITY is an interesting formalism for designing, reasoning about, and verifying concurrent systems.
Reference: [CBM89] <author> O. Coudert, C. Berthet, and J. C. Madre. </author> <title> Verification of synchronous sequential machines based on symbolic execution. In Proceedings of the Workshop on Automatic Verification Methods for Finite State Systems, </title> <month> June </month> <year> 1989. </year>
Reference-contexts: A practical breakthrough in the application of model checking techniques to large programs was accomplished through the introduction of ordered binary decision diagrams (OBDDs) [Bry86] and their incorporation into model checking algorithms <ref> [McM92, Pix90, CBM89] </ref>. The idea behind OBDDs is to encode sets of states and transition relations that are relevant for the calculations of a symbolic model checking algorithm by boolean functions over the state space of the program.
Reference: [CE81] <author> E. M. Clarke and E. A. Emerson. </author> <title> Synthesis of synchronization skeletons for branching time temporal logic. In Logic of Programs: </title> <booktitle> Workshop, volume 131 of Lecture Notes in Computer Sience, </booktitle> <month> May </month> <year> 1981. </year>
Reference-contexts: Although, in general, progress properties are not compositional, recent research has provided methods for establishing some progress properties of programs from properties of their components [Coh93, CK93, Rao95, Pra95]. 2.3 Model Checking Model checking <ref> [CE81, QS82, CES86] </ref> has become one of the most successful techniques for verifying and analyzing certain classes of finite-state programs.
Reference: [CES86] <author> E. M. Clarke, E. A. Emerson, and A. P. Sistla. </author> <title> Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> (2), </volume> <year> 1986. </year>
Reference-contexts: We also give a brief overview of two of the main ideas our work is built on: the temporal logic and programming notation UNITY [CM88] is summarized in section 2.2, and the verification technique of model checking [CE81](cf. <ref> [QS82, CES86] </ref>) is introduced in section 2.3. 2.1 Notation and Terminology In the following we introduce some notation and collect some basic results that are used throughout this thesis. <p> Although, in general, progress properties are not compositional, recent research has provided methods for establishing some progress properties of programs from properties of their components [Coh93, CK93, Rao95, Pra95]. 2.3 Model Checking Model checking <ref> [CE81, QS82, CES86] </ref> has become one of the most successful techniques for verifying and analyzing certain classes of finite-state programs. <p> 3.1 Verification Conditions for UNITY The most interesting challenge in designing a model checking algorithm for UNITY logic is to determine how one can take advantage of the simplicity of the logic in order to improve its efficiency compared to model checking algorithms for more general logics such as CTL <ref> [CES86] </ref>. The starting point for a derivation of a model checking method that takes advantage of the deductive structure of UNITY is the UNITY proof system, presented in section 2.2. As suggested by the substitution axiom, invariants play an important role in proving properties of programs.
Reference: [CGL94] <author> E. M. Clarke, O. Grumberg, and D. E. </author> <title> Long. Model checking and abstraction. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> (5), </volume> <year> 1994. </year>
Reference-contexts: As a result some systems with more than 10 1000 states can be handled today <ref> [CGL94] </ref>. Some of the inherent limitations of OBBDs have also been successfully tackled for many practical applications.
Reference: [CK93] <author> P. Collette and E. Knapp. </author> <title> A compositional proof system for UNITY based on rely/guarantee conditions. </title> <booktitle> Submitted to the IFIP Workshop on Programming Concepts, Methods and Calculi, </booktitle> <month> November </month> <year> 1993. </year>
Reference-contexts: These compatibility constraints have the form of syntactic link constraints, restricting the access to certain program variables according to their interface characterizations. Although, in general, progress properties are not compositional, recent research has provided methods for establishing some progress properties of programs from properties of their components <ref> [Coh93, CK93, Rao95, Pra95] </ref>. 2.3 Model Checking Model checking [CE81, QS82, CES86] has become one of the most successful techniques for verifying and analyzing certain classes of finite-state programs. <p> This work may lead to a simplification of the rely/guarantee style of reasoning <ref> [Col93, CK93, McM92] </ref>. Any results obtained in this direction will also be usable in 195 the context of the hierarchically structured program model of Seuss.
Reference: [CM88] <author> K. M. Chandy and J. Misra. </author> <title> Parallel Program Design, A Foundation. </title> <publisher> Addison Wesley, </publisher> <year> 1988. </year> <month> 262 </month>
Reference-contexts: We also give a brief overview of two of the main ideas our work is built on: the temporal logic and programming notation UNITY <ref> [CM88] </ref> is summarized in section 2.2, and the verification technique of model checking [CE81](cf. [QS82, CES86]) is introduced in section 2.3. 2.1 Notation and Terminology In the following we introduce some notation and collect some basic results that are used throughout this thesis. <p> A more thorough and detailed introduction can be found in <ref> [CM88] </ref>, while some more recent developments are described in [Mis95b, Mis95a]. 2.2.1 Programming Notation The computational model for UNITY is that of deterministic, total, labeled state transition systems (TDLSTS) described earlier. <p> Moreover, these rules can be used to derive properties of programs, as well as when applied in reverse order to guide the designer of a program who has to meet certain specifications, by suggesting program refinements corresponding to the structure of the rules <ref> [CM88, Kna92] </ref>. In the following we introduce the UNITY operators and some rules for reasoning with them to the extent needed for this work. Proofs of most rules are straightforward and can be found in [Mis95b, Mis95a]. <p> as the transitive, disjunctive closure of the ensures relation, i.e., as the strongest relation satisfying the following three conditions: 28 p ensures q p 7! q p 7! r h9w : w 2 W : p:wi 7! q The UNITY programming theory provides many laws for reasoning about progress properties <ref> [CM88] </ref>. <p> UNITY defines two forms of program composition: the symmetric program union combines two programs with compatible state spaces and initial conditions by forming the union of their actions. The union theorem <ref> [CM88] </ref> makes it possible to derive safety and basic progress properties of the composed program from its components. In program superposition, an underlying program is augmented by superimposed variables, additional actions, and restricted synchronous extensions to existing actions. <p> Since its introduction in <ref> [CM88] </ref> the UNITY theory has been thoroughly investigated [M + 90] and simplified [Mis95b], it has been applied to a variety of interesting problems [Sta92], and been used as a foundation for other theories and formalisms [Car94, CWB94, CR90]. <p> By (LhsStr) and (RhsWeak) the generalized leads-to relation is weakening in its right and strengthening in its left argument. Finally,(GenDisj), (Impossible) and (Cancel) are generalizations of the general disjunction, impossibility and cancellation theorems of the ordinary leads-to relation (cf. <ref> [CM88] </ref>). Proof of Theorem 13. <p> using the regular expression hint [u2]([v2][v3][v4][v5])[u3], which captures the transition of process u from requesting to critical with the possibly necessary pass of process v through its critical section. 7.2 Resource Allocation: Dining Philosophers The dining philosophers program presented here is based on the distributed dining philosophers algorithm found in <ref> [CM88] </ref>. It implements a ring topology in which two neighboring processes share a fork. Each process is in one of three states, thinking, hungry, or eating. <p> These variables encode both the ordering between the processes and their respective states. For a detailed description of this encoding and the derivation of the algorithm, the reader is referred to <ref> [CM88] </ref>. In the following we show the program and several relevant properties written in the extended UV input language. The syntactic parameter N is instantiated to yield ring topologies of varying sizes. <p> system, in particular of the symbolic representation by OBDDs, the application of our methods to larger examples, and the investigation of how our methods can be adapted to other logics and formalisms including the combination of our theory with fairness assumptions other than the unconditional fairness of traditional UNITY logic <ref> [CM88, Rao95, Fra86] </ref>. In the following, we briefly discuss some additional topics for future research that can build on our work presented here.
Reference: [CM90] <author> O. Coudert and J. C. Madre. </author> <title> A unified framework for the formal verifica-tion of sequential circuits. </title> <booktitle> In IEEE Int. Conference on CAD, </booktitle> <month> November </month> <year> 1990. </year>
Reference-contexts: The techniques and methods currently implemented include the use of reduced OBDDs as described in [BBR90], of a combined and-exists operation in computing relational products ([McM93], of quantification ordering in synchronous transitions similar to those described in [BCM91], of restriction <ref> [CM90] </ref>, and generalized cofactoring [TSL + 90]. In addition to provisions for taking advantage of the monotonicity of predicate transformers in early termination of fixpoint computations, the current implementation also uses a special second level cache for memoizing certain and-exists computations in addition to the standard if-then-else (ITE) cache ([BBR90].
Reference: [Coh93] <author> E. Cohen. </author> <title> Modular Progress Proofs of Asynchronous Programs. </title> <type> PhD thesis, </type> <institution> The University of Texas at Austin, </institution> <year> 1993. </year>
Reference-contexts: These compatibility constraints have the form of syntactic link constraints, restricting the access to certain program variables according to their interface characterizations. Although, in general, progress properties are not compositional, recent research has provided methods for establishing some progress properties of programs from properties of their components <ref> [Coh93, CK93, Rao95, Pra95] </ref>. 2.3 Model Checking Model checking [CE81, QS82, CES86] has become one of the most successful techniques for verifying and analyzing certain classes of finite-state programs.
Reference: [Coh96] <author> E. Cohen. </author> <type> Personal communications. </type> <year> 1996. </year>
Reference-contexts: The following example due to Cohen <ref> [Coh96] </ref> exhibits such regular expressions U and V , thereby establishing that R F is not left-handed.
Reference: [Col93] <author> P. Collette. </author> <title> Application of the composition principle to UNITY-like specifications. </title> <booktitle> In Theory and Practice of Software Development, volume 668 of Lecture Notes in Computer Sience. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1993. </year>
Reference-contexts: This work may lead to a simplification of the rely/guarantee style of reasoning <ref> [Col93, CK93, McM92] </ref>. Any results obtained in this direction will also be usable in 195 the context of the hierarchically structured program model of Seuss.
Reference: [Con71] <author> J. H. Conway. </author> <title> Regular algebra and finite machines. </title> <publisher> Chapman and Hall, </publisher> <address> London, </address> <year> 1971. </year>
Reference-contexts: We define regular expressions over a finite alphabet A as the free universal algebra <ref> [Wec92, Jac80, Con71] </ref> with the nullary constructors ;, " and ff for each ff 2 A, the unary constructor fl (repetition), and the binary constructors + (alternation) and (sequencing). We write + and as infix operators and fl as a postfix operator.
Reference: [Coo78] <author> S. Cook. </author> <title> Soundness and completeness of an axiom system for program verification. </title> <journal> SIAM Journal of Computing, </journal> <volume> 7(1) </volume> <pages> 70-90, </pages> <year> 1978. </year>
Reference-contexts: This notion of completeness was first investigated by Cook <ref> [Coo78] </ref>, a detailed 117 discussion of some of the issues involved can be found in [Rao95].
Reference: [CR90] <author> H. C. Cunningham and G.-C. Roman. </author> <title> A UNITY-style programming logic for a shared dataspace language. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(3), </volume> <year> 1990. </year>
Reference-contexts: Since its introduction in [CM88] the UNITY theory has been thoroughly investigated [M + 90] and simplified [Mis95b], it has been applied to a variety of interesting problems [Sta92], and been used as a foundation for other theories and formalisms <ref> [Car94, CWB94, CR90] </ref>. UNITY is Suitable for Program Design and Verification There are several reasons why UNITY is an interesting formalism for designing, reasoning about, and verifying concurrent systems.
Reference: [CWB94] <author> J. Cuellar, I. Wildgruber, and D. Barnard. </author> <title> The temporal logic of transitions. </title> <booktitle> In Formal Methods Europe (Barcelona, </booktitle> <address> Spain), </address> <year> 1994. </year>
Reference-contexts: Since its introduction in [CM88] the UNITY theory has been thoroughly investigated [M + 90] and simplified [Mis95b], it has been applied to a variety of interesting problems [Sta92], and been used as a foundation for other theories and formalisms <ref> [Car94, CWB94, CR90] </ref>. UNITY is Suitable for Program Design and Verification There are several reasons why UNITY is an interesting formalism for designing, reasoning about, and verifying concurrent systems. <p> Such an example is the following elevator control program, which has been motivated by similar programs of this kind discussed in the literature (e.g. <ref> [CWB94] </ref>). In the following, we describe the program in section 5.3.1 and state some of its properties in section 5.3.2.
Reference: [CZ96] <author> E. M. Clarke and X. Zhao. </author> <title> Word-level symbolic model checking anew approach for verifying arithmetic circuits. </title> <note> to be published, </note> <year> 1996. </year>
Reference-contexts: By encoding word-level operations (instead of bit-level operations as done with OBDDs), data structures such as binary moment diagrams [BC95] made it possible to solve previously intractable problems <ref> [CZ96] </ref>. Altogether, model checking has become a very powerful verification technique, that can be easily used in practice (at least compared with approaches based on theorem proving), due to its mostly automated nature.
Reference: [DF90] <author> A. Dappert-Farquhar. </author> <title> A correction on "a family of 2-process mutual exclusion algorithms: </title> <booktitle> Notes on UNITY: </booktitle> <pages> 13-90". </pages> <booktitle> Notes on UNITY, </booktitle> <volume> (22), </volume> <year> 1990. </year>
Reference-contexts: Important properties of the algorithm, like mutual exclusion and absence of starvation, are established along with the manual. Although these properties can be established, some of the intermediate invariant proofs in the paper were indeed not correct. Some of these errors had been discovered independently <ref> [DF90] </ref>, but they were all discovered automatically by the UV system. The mutual exclusion algorithm for two processes U and V is based on an encoding of a shared queue by three boolean variables u, v, and p.
Reference: [Dij75] <author> E. W. Dijkstra. </author> <title> Guarded commands, nondeterminacy, and the formal derivation of programs. </title> <journal> Communications of the ACM, </journal> <volume> 8 </volume> <pages> 453-457, </pages> <year> 1975. </year> <month> 263 </month>
Reference-contexts: junctive and its noun form to stand for either conjunctive or disjunctive. 5 A set of predicates is called linear if its elements can be arranged in a monotonic (strengthening or weakening) denumerable sequence. 16 In the following, we make use of three predicate transformers characterizing the semantics of actions <ref> [Dij75] </ref>. These are Weakest Precondition (wp): For an action ff and a state predicate q, wp :ff:q characterizes precisely those initial states beginning in which each execution of ff terminates in a state satisfying q.
Reference: [Dij76] <author> E. W. Dijkstra. </author> <title> A Discipline of Programming. </title> <publisher> Prentice-Hall, </publisher> <year> 1976. </year>
Reference: [Dij95] <author> R. M. Dijkstra. </author> <title> DUALITY: A simple formalism for the analysis of UNITY. </title> <journal> Formal Aspects of Computing, </journal> <volume> 7(4) </volume> <pages> 353-388, </pages> <year> 1995. </year>
Reference-contexts: We base our presentation of an operational semantics for generalized progress properties on a certain notion of games, inspired by <ref> [Dij95] </ref>, where games are used as a model for the DUALITY calculus. A game takes place between two players, called the progressor and the opponent, engaging in a series of game rounds.
Reference: [DS90] <author> E. W. Dijkstra and C. S. Scholten. </author> <title> Predicate Calculus and Program Semantics. </title> <booktitle> Text and Monographs in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Some definitions and notation concerning regular expressions, in section 2.1.6, conclude the presentation of notation and terminology. 8 2.1.1 Notational Conventions We use formulae of propositional and predicate calculus following the conventions laid out in <ref> [DS90] </ref>; in particular, the infix "." is used for denoting function application. As usual, function application is left-associative. <p> Following <ref> [DS90] </ref> we use the everywhere operator, a unary operator that has all the properties of universal quantification over a non-empty range 2 . <p> In particular, for manipulating formulae of the predicate calculus we use a proof format that was proposed by Dijkstra, Feijen, and others, which greatly facilitates this kind of reasoning (for a thorough discussion of this format, see <ref> [DS90] </ref>). In this format a proof is a sequence of formulae related by (equivales ), ) (implies ), or ( (follows-from), interspersed with hints justifying the transformation from one formula to the next. <p> We assume a certain familiarity with the predicate calculus (e.g. as presented in <ref> [DS90] </ref>) and will justify many common transformations based on predicate or propositional calculus with the hint predicate calculus. 15 2.1.4 Predicate Transformers A predicate transformer for a program F is a mapping 3 from P n F to P F for some n in N. <p> It is well known that conjunctivity and disjunctivity over all non-empty, finite, and linear sets S are the same and coincide with the traditional notion of monotonicity of t . A complete discussion of various junctivity properties can be found in <ref> [DS90] </ref>. 3 As usual, P n F denotes the n-times Cartesian product of P F . 4 We use the term junctive and its noun form to stand for either conjunctive or disjunctive. 5 A set of predicates is called linear if its elements can be arranged in a monotonic (strengthening <p> Since the actions we consider are total and deterministic, these predicate transformers satisfy the following conditions. Proofs of these theorems can be found in <ref> [DS90] </ref>: 1. Since actions always terminate, we have for all actions ff: [[wp :ff wlp :ff]]. Henceforth, we will use wp only. 2. For every action ff, the predicate transformer wp :ff is universally conjunctive (again due to actions being total). 3. <p> Furthermore, the strongest solution is the same as the strongest solution of the equation Z : [[Z ( f:Z]] and the weakest solution is the same as the weakest solution of the equation Z : [[Z ) f:Z]] The following very useful theorem from <ref> [DS90] </ref> shows that certain junctivity properties are inherited by the extreme solutions of equations from the functions defining them: Theorem 2 For monotonic f , denote the strongest solution of Z : [[f:(X; Z) Z]] by g:X and the weakest solution by h:X. <p> V + V 0 f (PrAlg0), (PrAlg1)g (U + V ) + (U 0 + V 0 ) = V + V 0 fU + V = V , U 0 + V 0 = V 0 from assumptiong true 1 This is an instance of the Little Theory in <ref> [DS90] </ref>, stating that a relation defined in terms of a binary operator + is reflexive if + is idempotent, is antisymmetric if + is commutative, and is transitive if + is associative. 238 U U 0 V V 0 fU + V = V , U 0 + V 0 =
Reference: [EL85] <author> E. A. Emerson and C. L. Lei. </author> <title> Modalities for model checking: Branching time strikes back. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1985. </year>
Reference: [EN95] <author> E. A. Emerson and K. Namjoshi. </author> <title> Reasoning about rings. </title> <booktitle> In Proceedings of the 22th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1995. </year>
Reference-contexts: Several ideas for dealing with parameterized systems have been investigated in the literature. On one hand, one can try to eliminate the parameterization altogether without the use of induction <ref> [EN95] </ref>; on the other hand, methods for eliminating induction in certain cases have been proposed by either choosing a canonical parameterized representation [GF93], or by reducing the parameterized checking problem to a few finite model checking problems of fixed size [KM89, McM92, MCB89].
Reference: [Fil94] <author> T. Filkorn. </author> <type> Personal communications. </type> <year> 1994. </year>
Reference-contexts: We observed, in particular, that in the presence of relatively small deterministic multiple assignments, typical of many UNITY programs, a hit-rate of above 30% was achieved for the and-exists cache, resulting in a significant gain in performance. The and-exists caching technique has been used in other systems as well <ref> [Fil94] </ref>, where somewhat smaller performance improvements on large examples have been observed. 148 6.2 The UV Input Language A user of the UV system describes most entities that play a role in a verification session by using the UV input language.
Reference: [Fra86] <author> N. Francez. </author> <title> Fairness. </title> <publisher> Springer Verlag, </publisher> <address> New York, </address> <year> 1986. </year>
Reference-contexts: system, in particular of the symbolic representation by OBDDs, the application of our methods to larger examples, and the investigation of how our methods can be adapted to other logics and formalisms including the combination of our theory with fairness assumptions other than the unconditional fairness of traditional UNITY logic <ref> [CM88, Rao95, Fra86] </ref>. In the following, we briefly discuss some additional topics for future research that can build on our work presented here.
Reference: [GF93] <author> A. Gupta and A. L. Fisher. </author> <title> Parametric circuit representation using inductive boolean functions. </title> <booktitle> In Proceedings of the 5th Conference on Computer Aided Verification. LNCS 697, </booktitle> <year> 1993. </year>
Reference-contexts: On one hand, one can try to eliminate the parameterization altogether without the use of induction [EN95]; on the other hand, methods for eliminating induction in certain cases have been proposed by either choosing a canonical parameterized representation <ref> [GF93] </ref>, or by reducing the parameterized checking problem to a few finite model checking problems of fixed size [KM89, McM92, MCB89]. Common to these approaches to reducing parameterized systems is their linear structure, i.e., the constant difference (by some measure) of the structures of successive instantiations of the parameterized system.
Reference: [GL94] <author> O. Grumberg and D. E. </author> <title> Long. Model checking and modular verification. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(3), </volume> <month> May </month> <year> 1994. </year>
Reference-contexts: Composition and Closure The importance of compositional reasoning as a means for dealing with large systems is well understood, and several approaches have been proposed to exploit compositional techniques for model checking (e.g. <ref> [GL94] </ref>). The performance gains observed in checking safety and basic progress properties with the UV system are closely related to the inherent compositionality of UNITY logic.
Reference: [GM93] <author> M. J. C. Gordon and T. F. Melham. </author> <title> Introduction to HOL. </title> <publisher> Cambridge University Press, </publisher> <year> 1993. </year>
Reference-contexts: However, it is important to point out, that there is no inherent restriction of the theory of generalized progress properties to neither finite-state systems, or to model checking as a verification technique. In particular the integration with theorem provers <ref> [Gol92, OSR93, GM93] </ref> and with infinite state-space model checking approaches, as well as the extension to the compositional structure of UNITY logic [Mis] and to compositional verification in general are of great interest. 119 Chapter 5 Checking Progress Properties In this chapter we show how we can improve the model checking
Reference: [Gol92] <author> D. M. Goldschlag. </author> <title> Mechanically verifying concurrent programs. </title> <type> PhD thesis, </type> <institution> The University of Texas at Austin, </institution> <year> 1992. </year> <month> 264 </month>
Reference-contexts: However, it is important to point out, that there is no inherent restriction of the theory of generalized progress properties to neither finite-state systems, or to model checking as a verification technique. In particular the integration with theorem provers <ref> [Gol92, OSR93, GM93] </ref> and with infinite state-space model checking approaches, as well as the extension to the compositional structure of UNITY logic [Mis] and to compositional verification in general are of great interest. 119 Chapter 5 Checking Progress Properties In this chapter we show how we can improve the model checking
Reference: [Gro94] <author> H. D. Group. HSIS: </author> <title> a BDD-based environment for formal verification. </title> <type> Technical report, </type> <institution> University of California at Berkeley, </institution> <year> 1994. </year>
Reference-contexts: Some of the inherent limitations of OBBDs have also been successfully tackled for many practical applications. In particular, the effects of the strong dependence of OBDDs sizes on variable orderings and the difficulty of finding good orderings reliably, have been partially overcome by domain-specific ordering heuristics <ref> [Gro94] </ref> and by dynamic reordering algorithms [Rud93]. Moreover, some programs that do not have an efficient encoding using OBDDs (e.g. multiplier circuits) have been successfully verified using extensions of OBBDs.
Reference: [HD93] <author> A. J. Hu and D. L. Dill. </author> <title> Efficient verification with BDDs using implicitely conjoined invariants. </title> <booktitle> In Proceedings of the 5th Conference on Computer Aided Verification, </booktitle> <year> 1993. </year>
Reference-contexts: They can be divided into the following three groups: Symbolic Representation: several well established techniques for improving the OBDD performance need to be implemented, such as dynamic variable re ordering [Rud93] and partitioned OBDD representations <ref> [HD93, Jai96] </ref>; UV Language: quantified statements and formulae need to be introduced in order to improve the ease of expression of the input language; support for regular expression hints as separate objects and for performing algebraic operations on them could simplify working with progress properties; User Interface: a better presentation of
Reference: [Hel92] <author> D. Heller. </author> <title> Motif Programming Manual, volume 6 of The Definitive Guides to the X Window System. </title> <publisher> O'Reilly & Associates, Inc., </publisher> <year> 1992. </year>
Reference-contexts: In the first version of the UV system, we had written an interface based on the Motif <ref> [Hel92] </ref> toolkit, that not only took up more than 30% of the entire code, but also was more difficult to modify and adjust to the changing requirements of a system that is used as an experimental platform for research.
Reference: [HU79] <author> J. E. Hopcroft and J. D. Ullman. </author> <title> Introduction to Automata Theory, Languages, and Computation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1979. </year>
Reference-contexts: For infinite state spaces and recursively enumerable (r.e.) sets of initial states, the set of reachable states is r.e. but not necessarily decidable as can be seen by reduction from the Halting Problem (for the definitions see for instance <ref> [HU79] </ref>): a deterministic universal Turing machine can be modeled as a TDLSTS, hence it cannot be decided whether a final state is reachable.
Reference: [Hun93] <author> H. Hungar. </author> <title> Combining model checking and theorem proving to verify parallel processes. </title> <booktitle> In Computer Aided Verification, 5th International Conference, </booktitle> <year> 1993. </year>
Reference: [ID93] <author> C. N. Ip and D. L. Dill. </author> <title> Better verification through symmetry. </title> <booktitle> In International Conference on Computer Hardware Description Languages, </booktitle> <pages> pages 87-100, </pages> <year> 1993. </year>
Reference: [Jac80] <author> N. Jacobson. </author> <title> Basic Algebra II. </title> <publisher> Freeman, </publisher> <year> 1980. </year>
Reference-contexts: We define regular expressions over a finite alphabet A as the free universal algebra <ref> [Wec92, Jac80, Con71] </ref> with the nullary constructors ;, " and ff for each ff 2 A, the unary constructor fl (repetition), and the binary constructors + (alternation) and (sequencing). We write + and as infix operators and fl as a postfix operator.
Reference: [Jai96] <author> J. Jain. </author> <type> Personal communications. </type> <year> 1996. </year>
Reference-contexts: They can be divided into the following three groups: Symbolic Representation: several well established techniques for improving the OBDD performance need to be implemented, such as dynamic variable re ordering [Rud93] and partitioned OBDD representations <ref> [HD93, Jai96] </ref>; UV Language: quantified statements and formulae need to be introduced in order to improve the ease of expression of the input language; support for regular expression hints as separate objects and for performing algebraic operations on them could simplify working with progress properties; User Interface: a better presentation of
Reference: [JKR89] <author> C. S. Jutla, E. Knapp, and J. R. Rao. </author> <title> A predicate transformer approach to semantics of parallel programs. </title> <booktitle> In Proceedings of the 8th ACM Symposium on Principles of Distributed Computing, </booktitle> <year> 1989. </year>
Reference-contexts: Dealing with leads-to We can, however, express an equivalence involving leads-to by using the predicate transformer wlt (weakest leads-to) from <ref> [JKR89] </ref>: for a state predicate q, the predicate wlt :q characterizes all states with the property that any unconditionally fair execution starting from such a state eventually reaches a state in which q holds. <p> In section 4.2.2, we investigate the junctivity properties of the wltr predicate transformers. In section 4.2.3 we establish the close connection between the wltr predicate transformers and the wlt predicate transformer (for weakest leads-to, <ref> [JKR89] </ref>) characterizing the ordinary leads-to properties of UNITY logic. 4.2.1 Predicate Transformers for Generalized Progress We begin the formal treatment of the semantics of generalized progress properties by defining a family of predicate transformers wltr :W for any W in R F inductively over the structure of W : 68 Definition <p> In order to prove these results we recall a few properties of the wlt predicate transformer, either taken from <ref> [JKR89] </ref> or being simple consequences of results found there. <p> The result is analogous to the one relating the ordinary leads-to relation to the wlt predicate transformer in <ref> [JKR89, Kna92] </ref> and is stated in the following theorem: Theorem 12 For any W in R F and state predicates p and q in P F : [p ) wltr :W:q] p W Proof . <p> The soundness and completeness result given below is an immediate corollary of theorems 9 and 12 and the following connection between the ordinary leads-to relation and the wlt predicate transformer (cf. <ref> [JKR89] </ref>): Put together we obtain the following Corollary 14 For any W in R F , and state predicates p and q in P F : (p 7! q) ) (p 7! q) (Sound) (p 7! q) ) h9W : W 2 R F : p 7! qi (Compl) In summary,
Reference: [Kal94] <author> M. Kaltenbach. </author> <title> Model checking for UNITY. </title> <type> Technical Report TR94-31, </type> <institution> The University of Texas at Austin, </institution> <month> December </month> <year> 1994. </year>
Reference-contexts: The first version of the UV system was made publicly available in December 1994 <ref> [Kal94, Kal95b] </ref>. After a redesign and clean-up of the system architecture that had grown over a period of two years, the second and current version of the UV system was released in October 1995.
Reference: [Kal95a] <author> M. Kaltenbach. </author> <title> An interactive formal system for concurrent program design. </title> <type> PhD dissertation proposal, </type> <institution> The University of Texas at Austin, </institution> <month> April </month> <year> 1995. </year> <month> 265 </month>
Reference-contexts: In the following, we present some performance measurements for checking different properties. Milner's Cycler has been used as a benchmark in the literature in order to compare different verification methods and systems. Preliminary results in <ref> [Kal95a] </ref> demonstrated the advantages of using design invariants for checking safety properties.
Reference: [Kal95b] <author> M. Kaltenbach. </author> <title> The UV System, </title> <note> User's Manual, February 1995. Revision 1.18. </note>
Reference-contexts: The first version of the UV system was made publicly available in December 1994 <ref> [Kal94, Kal95b] </ref>. After a redesign and clean-up of the system architecture that had grown over a period of two years, the second and current version of the UV system was released in October 1995.
Reference: [KM89] <author> R. P. Kurshan and K. L. McMillan. </author> <title> A structural induction theorem for processes. </title> <booktitle> In Proceedings of the 8th ACM Symposium on Distributed Computing, </booktitle> <year> 1989. </year>
Reference-contexts: to eliminate the parameterization altogether without the use of induction [EN95]; on the other hand, methods for eliminating induction in certain cases have been proposed by either choosing a canonical parameterized representation [GF93], or by reducing the parameterized checking problem to a few finite model checking problems of fixed size <ref> [KM89, McM92, MCB89] </ref>. Common to these approaches to reducing parameterized systems is their linear structure, i.e., the constant difference (by some measure) of the structures of successive instantiations of the parameterized system.
Reference: [Kna92] <author> E. Knapp. </author> <title> Refinement as a Basis for Concurrent Program Design. </title> <type> PhD thesis, </type> <institution> The University of Texas at Austin, </institution> <year> 1992. </year>
Reference-contexts: UNITY programs with non-trivial initial sets, where a complete axiomatization requires the so-called substitution axiom that corresponds to limiting observations of the program behavior to only its reachable set of states (for a detailed discussion of the substitution axiom and completeness of UNITY logic, the reader is invited to consult <ref> [San91, Kna92] </ref>). As a consequence, we use two variations of the everywhere operator: we surround a predicate by square brackets [ ] to denote quantification over the reachable part of the state space, and by double square brackets [[ ]] to denote quantification over the full syntactic state space. <p> Moreover, these rules can be used to derive properties of programs, as well as when applied in reverse order to guide the designer of a program who has to meet certain specifications, by suggesting program refinements corresponding to the structure of the rules <ref> [CM88, Kna92] </ref>. In the following we introduce the UNITY operators and some rules for reasoning with them to the extent needed for this work. Proofs of most rules are straightforward and can be found in [Mis95b, Mis95a]. <p> Together with the 38 soundness and completeness of the UNITY logic <ref> [Kna92] </ref> we obtain a verification condition for F and the property stable p . <p> The result is analogous to the one relating the ordinary leads-to relation to the wlt predicate transformer in <ref> [JKR89, Kna92] </ref> and is stated in the following theorem: Theorem 12 For any W in R F and state predicates p and q in P F : [p ) wltr :W:q] p W Proof .
Reference: [Koz83] <author> D. Kozen. </author> <title> Results on the propositional mu-calculus. </title> <booktitle> Theoretical Computer Science, </booktitle> <pages> pages 333-354, </pages> <year> 1983. </year>
Reference-contexts: On the theoretical side it will be interesting to explore the relationship of our theory to automata-theoretic approaches [Kur94], to deductive systems based on linear temporal logic [M + 94], or on the propositional mu-calculus <ref> [Koz83, Bra93] </ref>. It will be worthwhile to investigate to which extent the ideas of formalizing hints and of incorporating design knowledge at various levels of detail could be exploited by these other approaches.
Reference: [Koz90] <author> D. Kozen. </author> <title> On Kleene algebras and closed semirings. </title> <booktitle> In Proceedings, Math. Found. of Comput. Sci., volume 452 of Lecture Notes in Computer Sience, </booktitle> <pages> pages 26-47. </pages> <publisher> Springer Verlag, </publisher> <year> 1990. </year>
Reference-contexts: family directly, but the introduction of a special algebra for doing so provides a layer of abstraction that makes it possible to separate algebraic issues from the details of the fixpoint characterizations of the predicate transformers, and to compare the proposed algebraic structure to other familiar structures like Kleene algebras <ref> [Koz90] </ref>. The characterization of the algebraic structure of wltr is done in two parts: first, in section 4.4.1, we define the notion of progress algebras and establish a few properties of such algebras. <p> First we define the equational Horn theory for R F , then we show that R F bears many similarities to the well known Kleene algebras and to the algebra of regular events. In the following we use the familiar formalism and terminology of Kleene algebras <ref> [Koz90] </ref> where appropriate. We start with the definition of progress algebra in which the binary relation (pronounced subsumed by) is defined by U V U + V = V .
Reference: [Kur94] <author> R. P. Kurshan. </author> <title> Computer-Aided Verification of Coordinating Processes. </title> <booktitle> Princeton Series in Computer Science. </booktitle> <publisher> Princeton Uiversity Press, </publisher> <year> 1994. </year>
Reference-contexts: On the theoretical side it will be interesting to explore the relationship of our theory to automata-theoretic approaches <ref> [Kur94] </ref>, to deductive systems based on linear temporal logic [M + 94], or on the propositional mu-calculus [Koz83, Bra93]. It will be worthwhile to investigate to which extent the ideas of formalizing hints and of incorporating design knowledge at various levels of detail could be exploited by these other approaches.
Reference: [Lam77] <author> L. Lamport. </author> <title> Proving the correctness of multiprocess programs. </title> <journal> IEEE Transactions of Software Engineering, </journal> <volume> 3(2) </volume> <pages> 125-143, </pages> <year> 1977. </year>
Reference-contexts: Informally characterized as expressing that "something good will happen" <ref> [Lam77] </ref>, progress properties are used for specifying or asserting important achievements of concurrent systems such as guarantee of response to service requests, convergence, or absence of starvation.
Reference: [M + 90] <editor> J. Misra et al. </editor> <booktitle> Notes on UNITY, </booktitle> <year> 1990. </year>
Reference-contexts: Since its introduction in [CM88] the UNITY theory has been thoroughly investigated <ref> [M + 90] </ref> and simplified [Mis95b], it has been applied to a variety of interesting problems [Sta92], and been used as a foundation for other theories and formalisms [Car94, CWB94, CR90].
Reference: [M + 94] <author> Z. Manna et al. </author> <title> STeP: the Stanford Temporal Prover. </title> <type> Technical Report STAN-CS-TR-94-1518, </type> <institution> Stanford University, </institution> <year> 1994. </year>
Reference-contexts: Other invariants can be derived for variables on which only a restricted set of operations is performed, e.g. integer variables which are incremented or decremented only by some fixed constant. More elaborate techniques analyze certain dependencies of sets of variables; e.g. the linear invariants of <ref> [M + 94, MP95] </ref> are obtained by determining linear dependencies between certain program variables. 3.2.3 User Supplied Invariants In most of the interesting cases automatically generated invariants do not suffice to prove the desired properties of a given program. <p> On the theoretical side it will be interesting to explore the relationship of our theory to automata-theoretic approaches [Kur94], to deductive systems based on linear temporal logic <ref> [M + 94] </ref>, or on the propositional mu-calculus [Koz83, Bra93]. It will be worthwhile to investigate to which extent the ideas of formalizing hints and of incorporating design knowledge at various levels of detail could be exploited by these other approaches.
Reference: [MCB89] <author> O. G. M. C. Brown, E. C. Clarke. </author> <title> Reasoning about networks with many identical finite state processes. </title> <journal> Information and Computation, </journal> <volume> 81(1), </volume> <month> April </month> <year> 1989. </year>
Reference-contexts: to eliminate the parameterization altogether without the use of induction [EN95]; on the other hand, methods for eliminating induction in certain cases have been proposed by either choosing a canonical parameterized representation [GF93], or by reducing the parameterized checking problem to a few finite model checking problems of fixed size <ref> [KM89, McM92, MCB89] </ref>. Common to these approaches to reducing parameterized systems is their linear structure, i.e., the constant difference (by some measure) of the structures of successive instantiations of the parameterized system.
Reference: [McM92] <author> K. L. McMillan. </author> <title> Symbolic Model Checking. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1992. </year> <month> 266 </month>
Reference-contexts: A practical breakthrough in the application of model checking techniques to large programs was accomplished through the introduction of ordered binary decision diagrams (OBDDs) [Bry86] and their incorporation into model checking algorithms <ref> [McM92, Pix90, CBM89] </ref>. The idea behind OBDDs is to encode sets of states and transition relations that are relevant for the calculations of a symbolic model checking algorithm by boolean functions over the state space of the program. <p> In fact, there might be no such trace, because the stability may be verifiable with respect to a stronger invariant. For generating full traces non-local methods have to be used (cf. <ref> [McM92] </ref>). 3.3.3 Limitations The proposed method for model checking UNITY programs has the potential to improve the efficiency of verification tasks significantly. <p> This work may lead to a simplification of the rely/guarantee style of reasoning <ref> [Col93, CK93, McM92] </ref>. Any results obtained in this direction will also be usable in 195 the context of the hierarchically structured program model of Seuss. <p> to eliminate the parameterization altogether without the use of induction [EN95]; on the other hand, methods for eliminating induction in certain cases have been proposed by either choosing a canonical parameterized representation [GF93], or by reducing the parameterized checking problem to a few finite model checking problems of fixed size <ref> [KM89, McM92, MCB89] </ref>. Common to these approaches to reducing parameterized systems is their linear structure, i.e., the constant difference (by some measure) of the structures of successive instantiations of the parameterized system.
Reference: [McM93] <author> K. L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer, </publisher> <year> 1993. </year>
Reference: [Mil89] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: An Example As an example of a UNITY program we consider the scheduling problem known as Milner's cycler <ref> [Mil89] </ref>. A cycler of size N consists of a cyclic arrangement of N processes P 0 through P N 1 in which each process receives a signal as input from its one neighbor, sends a signal to its other neighbor, and performs some further observable actions. <p> The first two differences account for the fact, that progress algebras do not have a ring structure. Whereas the omission of a unit element for + is somewhat arbitrary, the lack of left distributivity of over + is essential. This lack is a well known property of process algebras <ref> [Mil89] </ref>, which, however, are substantially different due to their lack of any law corresponding to (PrAlg8). In the following we list some important properties of progress algebras that can be derived from the above axioms. The proofs can be found in appendix D.2.
Reference: [Mis] <author> J. Misra. </author> <title> Closure properties. </title> <type> unpublished manuscript. </type>
Reference-contexts: Another way of dealing with program composition is by defining a notion of closure properties <ref> [Mis] </ref> as a generalization of the ordinary UNITY properties. A program F is said to have a certain closure property, if the corresponding ordinary property is enjoyed by any union of F with a program G that satisfies certain compatibility constraints with respect to F . <p> In particular the integration with theorem provers [Gol92, OSR93, GM93] and with infinite state-space model checking approaches, as well as the extension to the compositional structure of UNITY logic <ref> [Mis] </ref> and to compositional verification in general are of great interest. 119 Chapter 5 Checking Progress Properties In this chapter we show how we can improve the model checking procedure for UNITY logic, presented in chapter 3, by employing the theory of generalized progress developed in the previous chapter. <p> The performance gains observed in checking safety and basic progress properties with the UV system are closely related to the inherent compositionality of UNITY logic. However, there is an even richer theory of compositionality of UNITY related to closure properties <ref> [Mis] </ref>, that should be explored for its applicability to model checking.
Reference: [Mis90a] <author> J. Misra. </author> <title> A family of 2-process mutual exclusion algorithms. </title> <booktitle> Notes on UNITY, </booktitle> <volume> (13), </volume> <year> 1990. </year>
Reference-contexts: All examples were run on a SPARC-20 workstation with about 20 MB of main memory allocated to the model checker. 7.1 Two-Process Mutual Exclusion The following two-process mutual exclusion algorithm is taken from <ref> [Mis90a] </ref>, where it is derived by refinement from a set of properties. Important properties of the algorithm, like mutual exclusion and absence of starvation, are established along with the manual. Although these properties can be established, some of the intermediate invariant proofs in the paper were indeed not correct.
Reference: [Mis90b] <author> J. Misra. </author> <title> Soundness of the substitution axiom. </title> <booktitle> Notes on UNITY, </booktitle> <volume> (14), </volume> <year> 1990. </year>
Reference-contexts: We call a property of a program F directly provable if it can be proved in the UNITY proof system for F without using the substitution axiom. The importance of direct provability is emphasized by the theorem about normal forms of proofs due to Misra <ref> [Mis90b] </ref>: 36 Theorem 4 For any property of a program F there is an invariant J such that () J is directly provable.
Reference: [Mis94] <author> J. Misra. </author> <title> A discipline of multiprogramming. In Specification of Parallel Algorithms, </title> <journal> volume 18 of DIMACS. American Mathematical Society, </journal> <month> May </month> <year> 1994. </year>
Reference-contexts: In the following, we briefly discuss some additional topics for future research that can build on our work presented here. Verification for Seuss Recently, Misra has proposed a new discipline for multiprogramming <ref> [Mis94] </ref> called Seuss that is aimed at addressing both the need to reason about complex concurrent systems, and the requirement for efficient execution of the designed systems.
Reference: [Mis95a] <author> J. Misra. </author> <title> A logic for concurrent programming: Progress. </title> <journal> Journal of Computer and Software Engineering, </journal> <volume> 3(2) </volume> <pages> 273-300, </pages> <year> 1995. </year>
Reference-contexts: A more thorough and detailed introduction can be found in [CM88], while some more recent developments are described in <ref> [Mis95b, Mis95a] </ref>. 2.2.1 Programming Notation The computational model for UNITY is that of deterministic, total, labeled state transition systems (TDLSTS) described earlier. The TDLSTS model is well suited for describing many common classes of systems (e.g. hardware circuits or protocols), and is familiar to many designers of such systems. <p> In the following we introduce the UNITY operators and some rules for reasoning with them to the extent needed for this work. Proofs of most rules are straightforward and can be found in <ref> [Mis95b, Mis95a] </ref>. Safety The most fundamental safety property of UNITY logic is the constrains property, or co property for short. <p> Before we can present such a method for full UNITY logic we need to address the fact that we do not have a local verification condition for leads-to properties. 44 Even though for finite state programs the disjunctivity rule (disj) is subsumed by the transitivity rule (trans) <ref> [Mis95a] </ref>, it is still not possible to define an equivalence that directly relates leads-to properties to state or transition predicates 1 .
Reference: [Mis95b] <author> J. Misra. </author> <title> A logic for concurrent programming: Safety. </title> <journal> Journal of Computer and Software Engineering, </journal> <volume> 3(2) </volume> <pages> 239-272, </pages> <year> 1995. </year>
Reference-contexts: A more thorough and detailed introduction can be found in [CM88], while some more recent developments are described in <ref> [Mis95b, Mis95a] </ref>. 2.2.1 Programming Notation The computational model for UNITY is that of deterministic, total, labeled state transition systems (TDLSTS) described earlier. The TDLSTS model is well suited for describing many common classes of systems (e.g. hardware circuits or protocols), and is familiar to many designers of such systems. <p> In the following we introduce the UNITY operators and some rules for reasoning with them to the extent needed for this work. Proofs of most rules are straightforward and can be found in <ref> [Mis95b, Mis95a] </ref>. Safety The most fundamental safety property of UNITY logic is the constrains property, or co property for short. <p> Since its introduction in [CM88] the UNITY theory has been thoroughly investigated [M + 90] and simplified <ref> [Mis95b] </ref>, it has been applied to a variety of interesting problems [Sta92], and been used as a foundation for other theories and formalisms [Car94, CWB94, CR90].
Reference: [Mis96] <author> J. Misra. </author> <title> A discipline of multiprogramming, work in progress, </title> <note> ftp access at ftp://ftp.cs.utexas.edu/pub/psp/seuss/discipline.ps.Z, </note> <year> 1996. </year>
Reference: [MP95] <author> Z. Manna and A. Pnueli. </author> <title> Temporal Verification of Reactive Systems, Safety. </title> <publisher> Springer Verlag, </publisher> <address> New York, </address> <year> 1995. </year>
Reference-contexts: Therefore, it is not required to find the strongest invariant, but any sufficiently strong invariant. In the following we describe different ways for finding such invariants. A presentation of different techniques in the context of linear temporal logic can be found in <ref> [MP95] </ref>. 3.2.1 The Strongest Invariant As mentioned before, the strongest invariant of F , si :F , is sufficient for proving any property of F . The main problem with si :F is, however, that it may not be possible to be computed for a given program F . <p> Other invariants can be derived for variables on which only a restricted set of operations is performed, e.g. integer variables which are incremented or decremented only by some fixed constant. More elaborate techniques analyze certain dependencies of sets of variables; e.g. the linear invariants of <ref> [M + 94, MP95] </ref> are obtained by determining linear dependencies between certain program variables. 3.2.3 User Supplied Invariants In most of the interesting cases automatically generated invariants do not suffice to prove the desired properties of a given program.
Reference: [OSR93] <author> S. Owre, N. Shankar, and J. M. Rushby. </author> <title> User Guide for the PVS Specification and Verification System (Beta Release). </title> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> Feb </month> <year> 1993. </year> <title> Three volumes: Language, System, and Prover Reference Manuals. </title> <type> 267 </type>
Reference-contexts: However, it is important to point out, that there is no inherent restriction of the theory of generalized progress properties to neither finite-state systems, or to model checking as a verification technique. In particular the integration with theorem provers <ref> [Gol92, OSR93, GM93] </ref> and with infinite state-space model checking approaches, as well as the extension to the compositional structure of UNITY logic [Mis] and to compositional verification in general are of great interest. 119 Chapter 5 Checking Progress Properties In this chapter we show how we can improve the model checking
Reference: [Ous94] <author> J. K. Ousterhout. </author> <title> Tcl and the Tk toolkit. Professional Computing Series. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference: [Pix90] <author> C. Pixley. </author> <title> A computational theory and implementation of sequential hardware equivalence. </title> <editor> In R. Kurshan and E. Clarke, editors, </editor> <booktitle> CAV'90 DIMACS Series. ACM, </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: A practical breakthrough in the application of model checking techniques to large programs was accomplished through the introduction of ordered binary decision diagrams (OBDDs) [Bry86] and their incorporation into model checking algorithms <ref> [McM92, Pix90, CBM89] </ref>. The idea behind OBDDs is to encode sets of states and transition relations that are relevant for the calculations of a symbolic model checking algorithm by boolean functions over the state space of the program.
Reference: [Pra88] <author> V. Pratt. </author> <title> Dynamic algebras as a well-behaved fragment of relation algebras. </title> <editor> In D. Pigozzi, editor, </editor> <booktitle> Conference on Algebra and Computer Science, </booktitle> <publisher> LNCS. Springer Verlag, </publisher> <month> June </month> <year> 1988. </year>
Reference-contexts: Furthermore, as in Kleene algebras <ref> [Pra88] </ref>, (PrAlg17) is equivalent to (PrAlg11), and (PrAlg18) is equivalent to (PrAlg12).
Reference: [Pra95] <author> W. Prasetya. </author> <title> Mechanically Supported Design of Self-Stabilizing Algorithms. </title> <type> PhD thesis, </type> <institution> Rijksuniversiteit Utrecht, </institution> <year> 1995. </year>
Reference-contexts: These compatibility constraints have the form of syntactic link constraints, restricting the access to certain program variables according to their interface characterizations. Although, in general, progress properties are not compositional, recent research has provided methods for establishing some progress properties of programs from properties of their components <ref> [Coh93, CK93, Rao95, Pra95] </ref>. 2.3 Model Checking Model checking [CE81, QS82, CES86] has become one of the most successful techniques for verifying and analyzing certain classes of finite-state programs.
Reference: [QS82] <author> J. P. Quielle and J. Sifakis. </author> <title> Specification and verification of concurrent systems in CESAR. </title> <booktitle> In 5th International Symposium on Programming, volume 137 of LNCS. </booktitle> <publisher> Springer Verlag, </publisher> <month> April </month> <year> 1982. </year>
Reference-contexts: We also give a brief overview of two of the main ideas our work is built on: the temporal logic and programming notation UNITY [CM88] is summarized in section 2.2, and the verification technique of model checking [CE81](cf. <ref> [QS82, CES86] </ref>) is introduced in section 2.3. 2.1 Notation and Terminology In the following we introduce some notation and collect some basic results that are used throughout this thesis. <p> Although, in general, progress properties are not compositional, recent research has provided methods for establishing some progress properties of programs from properties of their components [Coh93, CK93, Rao95, Pra95]. 2.3 Model Checking Model checking <ref> [CE81, QS82, CES86] </ref> has become one of the most successful techniques for verifying and analyzing certain classes of finite-state programs.
Reference: [Rao95] <author> J. R. Rao. </author> <title> Extensions of the UNITY Methodology. </title> <publisher> Springer, </publisher> <year> 1995. </year>
Reference-contexts: These compatibility constraints have the form of syntactic link constraints, restricting the access to certain program variables according to their interface characterizations. Although, in general, progress properties are not compositional, recent research has provided methods for establishing some progress properties of programs from properties of their components <ref> [Coh93, CK93, Rao95, Pra95] </ref>. 2.3 Model Checking Model checking [CE81, QS82, CES86] has become one of the most successful techniques for verifying and analyzing certain classes of finite-state programs. <p> This notion of completeness was first investigated by Cook [Coo78], a detailed 117 discussion of some of the issues involved can be found in <ref> [Rao95] </ref>. <p> system, in particular of the symbolic representation by OBDDs, the application of our methods to larger examples, and the investigation of how our methods can be adapted to other logics and formalisms including the combination of our theory with fairness assumptions other than the unconditional fairness of traditional UNITY logic <ref> [CM88, Rao95, Fra86] </ref>. In the following, we briefly discuss some additional topics for future research that can build on our work presented here.
Reference: [RC86] <editor> J. Rees and W. Clinger. </editor> <title> The revised 3 report on the algorithmic language Scheme. </title> <type> AI Memo 848a, </type> <institution> Massachusetts Institute of Technology, Cambridge, Massachusetts, </institution> <month> September </month> <year> 1986. </year>
Reference-contexts: the user interface display and checking the variables mentioned above. 6.4 Implementation Summary and Extensions The UV system in its current form is the result of a research and implementation effort that began in 1992 as an experimental OBDD based model checker for UNITY programs, which was written in Scheme <ref> [RC86] </ref>, and ran on a Macintosh computer. Since then, many significant improvements to the symbolic representation have been made, the system has been written in C ++ under UNIX and the X Windows system, and the theory of incorporating design knowledge has been developed.
Reference: [RSS95] <author> S. Rajan, N. Shankar, and M. K. Srivas. </author> <title> An integration of model checking with automated proof checking. </title> <booktitle> In Computer Aided Verification, CAV'95, volume 939 of LNCS, </booktitle> <pages> pages 84-97, </pages> <month> June </month> <year> 1995. </year>
Reference: [Rud93] <author> R. Rudell. </author> <title> Dynamic variable ordering for ordered binary decision diagrams. </title> <booktitle> In IEEE/ACM Intenational Conference of Computer Aided Design, </booktitle> <year> 1993. </year>
Reference-contexts: In particular, the effects of the strong dependence of OBDDs sizes on variable orderings and the difficulty of finding good orderings reliably, have been partially overcome by domain-specific ordering heuristics [Gro94] and by dynamic reordering algorithms <ref> [Rud93] </ref>. Moreover, some programs that do not have an efficient encoding using OBDDs (e.g. multiplier circuits) have been successfully verified using extensions of OBBDs. <p> They can be divided into the following three groups: Symbolic Representation: several well established techniques for improving the OBDD performance need to be implemented, such as dynamic variable re ordering <ref> [Rud93] </ref> and partitioned OBDD representations [HD93, Jai96]; UV Language: quantified statements and formulae need to be introduced in order to improve the ease of expression of the input language; support for regular expression hints as separate objects and for performing algebraic operations on them could simplify working with progress properties; User
Reference: [San91] <author> B. A. Sanders. </author> <title> Eliminating the substitution axiom from UNITY logic. </title> <journal> Formal Aspects of Computing, </journal> <volume> 3, </volume> <year> 1991. </year> <month> 268 </month>
Reference-contexts: UNITY programs with non-trivial initial sets, where a complete axiomatization requires the so-called substitution axiom that corresponds to limiting observations of the program behavior to only its reachable set of states (for a detailed discussion of the substitution axiom and completeness of UNITY logic, the reader is invited to consult <ref> [San91, Kna92] </ref>). As a consequence, we use two variations of the everywhere operator: we surround a predicate by square brackets [ ] to denote quantification over the reachable part of the state space, and by double square brackets [[ ]] to denote quantification over the full syntactic state space. <p> The idea of tagging properties with a restricting invariant is similar to the treatment of invariants in <ref> [San91] </ref>. We call a property of a program F directly provable if it can be proved in the UNITY proof system for F without using the substitution axiom.
Reference: [Sta92] <author> M. G. Staskauskas. </author> <title> Specification and verification of large-scale reactive programs. </title> <type> Technical report, </type> <institution> The University of Texas at Austin, </institution> <year> 1992. </year>
Reference-contexts: Since its introduction in [CM88] the UNITY theory has been thoroughly investigated [M + 90] and simplified [Mis95b], it has been applied to a variety of interesting problems <ref> [Sta92] </ref>, and been used as a foundation for other theories and formalisms [Car94, CWB94, CR90]. UNITY is Suitable for Program Design and Verification There are several reasons why UNITY is an interesting formalism for designing, reasoning about, and verifying concurrent systems.
Reference: [Sto81] <author> J. E. Stoy. </author> <title> Denotational Semantics: The Scott-Strachey Approach to Programming Language Theory. </title> <publisher> MIT Press, </publisher> <year> 1981. </year>
Reference-contexts: For every game g we denote by g the run obtained by concatenating all rounds of g in order. Formally, hi = hi g = g:0 ++ tail :g if jgj &gt; 0 Note that g is well defined also for infinite g (cf. <ref> [Sto81, Bro93] </ref>). Next we will define the notion of a strategy of F for regular expressions W in R F .
Reference: [Tar55] <author> A. Tarski. </author> <title> A lattice-theoretical fixpoint theorem and its application. </title> <journal> Pacific Journal of Mathematics, </journal> <volume> 5 </volume> <pages> 285-309, </pages> <year> 1955. </year>
Reference-contexts: Similarly, we denote by h-Z :: f:Zi the weakest solution of Z : [[Z f:Z]] and call it the greatest fixpoint of f . Existence of such solutions is established by the well known theorem of Knaster-Tarski <ref> [Tar55] </ref>: Theorem 1 (Knaster-Tarski) For a monotonic function f , the equation 18 Z : [[Z f:Z]] has a weakest and a strongest solution.
Reference: [TSL + 90] <author> H. J. Touti, H. Savoj, B. Lin, R. K. Brayton, and A. Sangiovanni-Vincentelli. </author> <title> Implicit enumeration of finite state machines using bdd's. </title> <booktitle> In IEEE Int. Conference on CAD, </booktitle> <month> November </month> <year> 1990. </year>
Reference-contexts: The techniques and methods currently implemented include the use of reduced OBDDs as described in [BBR90], of a combined and-exists operation in computing relational products ([McM93], of quantification ordering in synchronous transitions similar to those described in [BCM91], of restriction [CM90], and generalized cofactoring <ref> [TSL + 90] </ref>. In addition to provisions for taking advantage of the monotonicity of predicate transformers in early termination of fixpoint computations, the current implementation also uses a special second level cache for memoizing certain and-exists computations in addition to the standard if-then-else (ITE) cache ([BBR90].
Reference: [Wec92] <author> W. Wechler. </author> <title> Universal Algebra for Computer Scientists, </title> <booktitle> volume 25 of WATCS Monographs on Theoretical Computer Science. </booktitle> <publisher> Springer, </publisher> <year> 1992. </year> <month> 269 </month>
Reference-contexts: We define regular expressions over a finite alphabet A as the free universal algebra <ref> [Wec92, Jac80, Con71] </ref> with the nullary constructors ;, " and ff for each ff 2 A, the unary constructor fl (repetition), and the binary constructors + (alternation) and (sequencing). We write + and as infix operators and fl as a postfix operator.
References-found: 86

