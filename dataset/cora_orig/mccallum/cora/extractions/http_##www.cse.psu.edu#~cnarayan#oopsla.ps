URL: http://www.cse.psu.edu/~cnarayan/oopsla.ps
Refering-URL: http://www.cse.psu.edu/~cnarayan/mainpart.html
Root-URL: http://www.cse.psu.edu
Email: fkasbekar,cnarayan,dasg@cse.psu.edu  
Title: Using Reflection for Checkpointing Object Oriented Programs  
Author: Mangesh Kasbekar Chandramouli Narayanan Chita R Das 
Address: Park, PA 16802.  
Affiliation: Department of Computer Science Engineering The Pennsylvania State University University  
Abstract: This paper presents a reflective approach to checkpointing object oriented programs. We describe a checkpointing and rollback library (called libooft) for multithreaded programs written in C++. We demonstrate some of the unique features offered by this library, such as selective checkpointing and selective rollbacks of threads of processes that are achievable only through the use of reflection. And finally we evaluate the cost of run-time reflection of this library for multithreaded applications. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. S. Plank, M. Beck, G. Kingsley, and K. Li, Libckpt: </author> <title> Transparent checkpointing under unix, </title> <booktitle> in Conference Proceedings, Usenix Winter 1995 Technical Conference, </booktitle> <address> (New Orleans, LA,), </address> <month> January </month> <year> 1995. </year>
Reference-contexts: Checkpointing a running program involves saving enough state information of the program on stable storage, so that it can be restarted from the saved state if the program crashes, instead of restarting it from the beginning. Libraries <ref> [1, 2, 3, 4] </ref> provide checkpointing facility but they do not take multithreaded or object oriented nature of the software system into consideration. Reflection, as a method for separating fault-tolerance mechanism from application, has been used in software fault-tolerance.
Reference: [2] <author> The Condor Team, </author> <title> Various technical documents. The Condor Project, </title> <institution> University of Wisconsin-Madison. </institution>
Reference-contexts: Checkpointing a running program involves saving enough state information of the program on stable storage, so that it can be restarted from the saved state if the program crashes, instead of restarting it from the beginning. Libraries <ref> [1, 2, 3, 4] </ref> provide checkpointing facility but they do not take multithreaded or object oriented nature of the software system into consideration. Reflection, as a method for separating fault-tolerance mechanism from application, has been used in software fault-tolerance.
Reference: [3] <author> Y. Huang and C. M. R. Kintala, </author> <title> Software implemented fault tolerance: Technologies and experience, </title> <booktitle> in Proceedings of Intl. Symposium on Fault-Tolerant Computing, (Toulouse, France), </booktitle> <pages> pp. 29, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Checkpointing a running program involves saving enough state information of the program on stable storage, so that it can be restarted from the saved state if the program crashes, instead of restarting it from the beginning. Libraries <ref> [1, 2, 3, 4] </ref> provide checkpointing facility but they do not take multithreaded or object oriented nature of the software system into consideration. Reflection, as a method for separating fault-tolerance mechanism from application, has been used in software fault-tolerance.
Reference: [4] <author> H. chang Nam, J. Kim, S. Hong, and S. Lee, </author> <title> Probabilistic checkpointing, </title> <booktitle> in Proceedings of Intl. Symposium on Fault-Tolerant Computing, </booktitle> <year> 1997. </year>
Reference-contexts: Checkpointing a running program involves saving enough state information of the program on stable storage, so that it can be restarted from the saved state if the program crashes, instead of restarting it from the beginning. Libraries <ref> [1, 2, 3, 4] </ref> provide checkpointing facility but they do not take multithreaded or object oriented nature of the software system into consideration. Reflection, as a method for separating fault-tolerance mechanism from application, has been used in software fault-tolerance.
Reference: [5] <author> J. Xu, B. Randell, and A. F. Zorzo, </author> <title> Implementing software-fault tolerance in c++ and openc++:an object oriented and reflective approach, </title> <booktitle> in Proceedings of International Workshop on Computer Aided Design,Test, and Evaluation for Dependability, </booktitle> <pages> pp. 224229, </pages> <month> July </month> <year> 1996. </year>
Reference-contexts: Reflection, as a method for separating fault-tolerance mechanism from application, has been used in software fault-tolerance. But these systems assume a non-concurrent software model and implement fault tolerance through N-version programming and recovery blocks <ref> [5] </ref> or server replication [6]. Cocurrent object oriented software systems are known to have transient faults [7]. In this paper we demonstrate the use of reflection for building a prototype checkpointing and recovery library, libooft [8], which addresses the transient faults in concurrent object oriented systems.
Reference: [6] <author> J.-C. Fabre and T. Perennou, </author> <title> A metaobject architecture for fault tolerant distributed systems:the friends approach, </title> <journal> in IEEE Transactions on Computers, </journal> <pages> pp. 7895, </pages> <month> January </month> <year> 1998. </year>
Reference-contexts: Reflection, as a method for separating fault-tolerance mechanism from application, has been used in software fault-tolerance. But these systems assume a non-concurrent software model and implement fault tolerance through N-version programming and recovery blocks [5] or server replication <ref> [6] </ref>. Cocurrent object oriented software systems are known to have transient faults [7]. In this paper we demonstrate the use of reflection for building a prototype checkpointing and recovery library, libooft [8], which addresses the transient faults in concurrent object oriented systems.
Reference: [7] <author> B. J. Xu, Randell, A. Romanovsky, C. M, F. Rubira, R. Stroud, and Z. Wu, </author> <title> Fault tolerance in concurrent object-oriented software through coordinated error recovery, </title> <booktitle> in Proceedings of the 25th IEEE International Symposium on Fault-Tolerant Computing (FTCS-25), </booktitle> <pages> pp. 499508, </pages> <year> 1995. </year>
Reference-contexts: But these systems assume a non-concurrent software model and implement fault tolerance through N-version programming and recovery blocks [5] or server replication [6]. Cocurrent object oriented software systems are known to have transient faults <ref> [7] </ref>. In this paper we demonstrate the use of reflection for building a prototype checkpointing and recovery library, libooft [8], which addresses the transient faults in concurrent object oriented systems. The conventional methods of checkpointing are completely non-object-oriented in nature. They treat all data of the program at page level.
Reference: [8] <author> M. Kasbekar, C. R. Das, and A. Sivasubramaniam, </author> <title> An object oriented approach to checkpointing. </title> <institution> The Pennsyl-vania State University, University Park. </institution>
Reference-contexts: Cocurrent object oriented software systems are known to have transient faults [7]. In this paper we demonstrate the use of reflection for building a prototype checkpointing and recovery library, libooft <ref> [8] </ref>, which addresses the transient faults in concurrent object oriented systems. The conventional methods of checkpointing are completely non-object-oriented in nature. They treat all data of the program at page level. <p> The blocking schemes require all threads to be suspended while either 2 checkpointing or rollback is in progress. In case of nonblocking schemes, some threads may continue their execution while others are involved in checkpointing or rollbacks <ref> [8] </ref>. <p> 3 7.2 1.3 Workload2 (b) 2371 2403 3 10.6 1.3 Workload3 (a) 8160 8257 10 9.7 1.18 Workload3 (b) 9533 9662 11 11.72 1.3 Workload4 2072 2101 6 4.83 1.44 Table 1: Checkpointing Overhead For the interested readers, the details about the performance of selective recovery can be found in <ref> [8] </ref>. 6 Conclusions and Future Work Using metainformation for checkpointing of threads and objects has a run-time overhead, but its cost is only a small part of functional cost of object themselves.
Reference: [9] <author> G. Deconinck, J. Vounckx, R. Cuyvers, and R. Lauwereins, </author> <title> Survey of checkpointing and rollback techniques, </title> <type> Tech. Rep. </type> <institution> O3.1.8 and 3.1.12, ESAT-ACCA Laboratory, Katholieke Universiteit Leuven, Belgium, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: This assumption allows us to develop many interesting and unique options for checkpointing and rollback in addition to the conventional ones <ref> [9, 10] </ref>, especially for concurrent programs. The prominent features presented in this paper are ,firstly , the ability to roll back some threads of a process to their previous checkpoint while allowing others to continue unaffected from these rollbacks.
Reference: [10] <author> E. Elnozahy, D. Johnson, and Y. Wang, </author> <title> A survey of rollback-recovery protocols in message passing systems, </title> <type> Tech. Rep. </type> <institution> CMU-CS-96-144, Department of Computer Science, Carnegie Mellon University, </institution> <month> August </month> <year> 1996. </year>
Reference-contexts: This assumption allows us to develop many interesting and unique options for checkpointing and rollback in addition to the conventional ones <ref> [9, 10] </ref>, especially for concurrent programs. The prominent features presented in this paper are ,firstly , the ability to roll back some threads of a process to their previous checkpoint while allowing others to continue unaffected from these rollbacks.
Reference: [11] <author> S. Chiba, </author> <title> A metaobject protocol for c++, </title> <booktitle> in Proceedings of the ACM Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA), </booktitle> <pages> pp. 285299, </pages> <month> October </month> <year> 1995. </year>
Reference-contexts: Use of run-time reflection can also enable optimizations during the checkpointing phase by identifying and limiting the number of objects that are required to be included in a checkpoint. In order to keep the runtime monitoring transparent from application programmer, we use MOP provided by OpenC++ <ref> [11] </ref> to analyze and translate user programs and insert the runtime support code in them. When applied to software fault tolerance, this scheme is useful to tolerate thread-level failures and limit the number of threads affected by failure of other threads in the program.
Reference: [12] <author> J. Eliot B. Moss, </author> <title> Working with persistent objects: To swizzle or not to swizzle, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 18, </volume> <pages> pp. 657673, </pages> <month> August </month> <year> 1992. </year> <month> 7 </month>
Reference-contexts: To transition from synthetic workload to a realistic workload, libooft will have to handle dynamic allocation by and of objects. This entails either swizzling of pointers <ref> [12] </ref> or deferring the deletion of allocated objects to consistent checkpoint times. Further, reinstatement of threads blocked on synchronization objects, like mutexes and condition variables, at recovery is a necessary enhancement.
References-found: 12

