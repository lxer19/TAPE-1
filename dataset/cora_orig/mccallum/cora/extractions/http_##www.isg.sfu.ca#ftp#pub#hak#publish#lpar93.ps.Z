URL: http://www.isg.sfu.ca/ftp/pub/hak/publish/lpar93.ps.Z
Refering-URL: http://www.isg.sfu.ca/life/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: fhak,podelskig@prl.dec.com  
Title: Entailment and Disentailment of Order-Sorted Feature Constraints  
Author: Hassan At-Kaci and Andreas Podelski 
Address: 85, avenue Victor Hugo, 92500 Rueil-Malmaison, France  
Affiliation: Digital Equipment Corporation, Paris Research Laboratory  
Abstract: LIFE uses matching on order-sorted feature structures for passing arguments to functions. As opposed to unification which amounts to normalizing a conjunction of constraints, solving a matching problem consists of deciding whether a constraint (guard) or its negation are entailed by the context. We give a complete and consistent set of rules for entailment and disentailment of order-sorted feature constraints. These rules are directly usable for relative simplification, a general proof-theoretic method for proving guards in concurrent constraint logic languages using guarded rules. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Hassan At-Kaci. </author> <title> An algebraic semantics approach to the effective resolution of type equations. </title> <journal> Theoretical Computer Science, </journal> <volume> 45 </volume> <month> 293-351 </month> <year> (1986). </year>
Reference-contexts: The first extension is based on -terms which are attributed partially-ordered sorts denoting sets of objects <ref> [1, 2] </ref>. In particular, -terms generalize first-order constructor terms in their role as data structures in that they are endowed with a unification operation denoting type intersection.
Reference: 2. <author> Hassan At-Kaci and Roger Nasr. </author> <title> LOGIN: A logic programming language with built-in inheritance. </title> <journal> Journal of Logic Programming, </journal> <volume> 3 </volume> <month> 185-215 </month> <year> (1986). </year>
Reference-contexts: The first extension is based on -terms which are attributed partially-ordered sorts denoting sets of objects <ref> [1, 2] </ref>. In particular, -terms generalize first-order constructor terms in their role as data structures in that they are endowed with a unification operation denoting type intersection.
Reference: 3. <author> Hassan At-Kaci and Roger Nasr. </author> <title> Integrating logic and functional programming. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 2 </volume> <month> 51-89 </month> <year> (1989). </year>
Reference-contexts: In particular, if an equation involves a functional expression whose arguments are not sufficiently instantiated to match a definiens of the function in question, it is simply left untouched. Resolution may proceed until the arguments are proven to match a definition from the accumulated constraints in the context <ref> [3] </ref>. This simple idea turns out invaluable in practice. This technique|delaying reduction and enforcing determinism by allowing only equivalence reductions|is called residuation [3]. It does not have to be limited to functions. Therefore, we explain it for the general case of relations. <p> Resolution may proceed until the arguments are proven to match a definition from the accumulated constraints in the context <ref> [3] </ref>. This simple idea turns out invaluable in practice. This technique|delaying reduction and enforcing determinism by allowing only equivalence reductions|is called residuation [3]. It does not have to be limited to functions. Therefore, we explain it for the general case of relations. Intuitively, the arguments of a relation which are constrained by the guard are its input parameters and correspond to the arguments of a function.
Reference: 4. <author> Hassan At-Kaci and Andreas Podelski. </author> <title> Functions as passive constraints in LIFE. </title> <type> PRL Research Report 13, </type> <institution> Digital Equipment Corporation, Paris Research Laboratory, </institution> <address> Rueil-Malmaison, France (June 1991). </address> <note> (Revised, </note> <month> November </month> <year> 1992). </year>
Reference-contexts: One outcome of the results presented in this paper is that it is possible to build such a test; namely, an algorithm deciding simultaneously two problems in an incremental manner|entailment and disentailment. The technique that we have devised to do that is called relative simplification of constraints <ref> [4] </ref>. We have organized this paper as follows. In Section 2, we review background on our OSF formalism. This is for the sake of staying self-contained since its technical notation and terminology is pervasive in this paper's presentation. <p> One motivation for this system is parameter-passing for functions in LIFE, but it is general and relevant to all concurrent constraint languages. We used a technique of relative simplification <ref> [4] </ref> which amounts to normalizing a constraint in the context of another. This yields an incremental system with the additional benefit of enjoying independence of negated constraints.
Reference: 5. <author> Hassan At-Kaci and Andreas Podelski. </author> <title> Towards a meaning of LIFE. </title> <type> PRL Research Report 11, </type> <institution> Digital Equipment Corporation, Paris Research Laboratory, Rueil-Malmaison, France (1991). </institution> <note> (Revised, October 1992; to appear in the Journal of Logic Programming). </note>
Reference-contexts: 1 Introduction LIFE <ref> [5] </ref> extends the computational paradigm of Logic Programming in two essential ways: * using a data structure richer than that provided by first-order constructor terms; and, * allowing interpretable functional expressions as bona fide terms. <p> An incremental test for entailment and disentailment between constraints is needed for advanced control mechanisms such as delaying, coroutining, synchronization, committed choice, and deep constraint propagation. LIFE is formally an instance of this scheme, namely a CLP language using a constraint system based on order-sorted feature (OSF) structures <ref> [5] </ref>. It employs a related, but limited, suspension strategy to enforce deterministic functional application. Roughly, these systems are concurrent thanks to a new effective discipline for procedure parameter-passing that can be described as "call-by-constraint-entailment" (as opposed to Prolog's call-by-unification). <p> Section 6 establishes the property of independence of negated OSF constraints. Finally, we conclude in Section 7. 2 OSF Formalism We introduce briefly the OSF formalism terminology and notation that we use. For a thorough investigation of these notions, the reader is referred to <ref> [5] </ref>. 2.1 OSF algebras and OSF constraints The building blocks of OSF algebras are sorts and features. <p> * at most one sort constraint of the form X : s, with ? &lt; s; * at most one feature constraint of the form X:` : = Y for each `; and, * no other occurrence of the variable X if it contains the equality constraint X : In <ref> [5] </ref>, we show that an OSF constraint in solved form is always satisfiable. Now, by Definition 3, the OSF constraint obtained as the dissolved form of any -term is de facto in solved form. 3 Hence, such a constraint is always satisfiable. <p> Note also, that the restriction of fl to the set of nodes defines a variable binding; it corresponds to the notion of a matching substitution for first-order terms. The following fact was established in <ref> [5] </ref>. Proposition 7 -Terms as Filters. <p> In fact, it is sufficient to limit the above statement to the OSF algebra only; i.e., [[ ]] [[ 0 ]] . The next and last ordering is a logical ordering on -terms. We state it here in less general terms than in <ref> [5] </ref>. Definition 9 -Term Entailment. <p> Rules extending basic simplification Lemma 13. The extended basic-simplification rules (B.1)-(B.5), (X.1)-(X.3) define equivalence transformations; furthermore, they are terminating. Proof. The first statement is clear. The proof of the second statement is an extension of the termination proof of the basic simplification rules (B.1)-(B.5) from <ref> [5] </ref>: (X.1) can be applied only a finite number of times, since the number of equivalence classes partitioning the finite set of variables occurring in the constraint which is to be simplified decreases by 1 with each application. (X.2) and (X.3) can be applied only a finite number of times, since <p> Corollary 21. If the normal form of & U : = X relatively to is not ?, then & & U = X is satisfiable. Proof. In <ref> [5] </ref> we showed that a constraint is satisfiable if and only if it has a solved-form; that is, its basic normal form is different from ?. The statement then follows from Proposition 20. Theorem 22 Disentailment.
Reference: 6. <author> Hassan At-Kaci, Andreas Podelski, and Gert Smolka. </author> <title> A feature-based constraint system for logic programming with entailment. </title> <booktitle> In Proceedings of the 5th International Conference on Fifth Generation Computer Systems, </booktitle> <pages> pages 1012-1022, </pages> <address> Tokyo, Japan (June 1992). </address> <note> ICOT. (Full paper to appear in Theoretical Computer Science). </note>
Reference-contexts: If normalizes to the false constraint, then the two -terms are non-unifiable. Otherwise, the resulting solved OSF constraint is a 2 T is essentially the feature tree structure of <ref> [6] </ref> and [7, 13]. The difference lies in our using partially-ordered sorts and total, as opposed to partial, features. 3 More precisely, this is true if we forget superfluous trivial sort constraints of the form X : &gt;. conjunction of equality constraints and of the dissolved form of some -term.
Reference: 7. <author> Rolf Backofen and Gert Smolka. </author> <title> A complete and decidable feature theory. </title> <note> DFKI Research Report RR-30-92, German Research Center for Artificial Intelligence, Saarbrucken, Germany (1992). </note>
Reference-contexts: If normalizes to the false constraint, then the two -terms are non-unifiable. Otherwise, the resulting solved OSF constraint is a 2 T is essentially the feature tree structure of [6] and <ref> [7, 13] </ref>. The difference lies in our using partially-ordered sorts and total, as opposed to partial, features. 3 More precisely, this is true if we forget superfluous trivial sort constraints of the form X : &gt;. conjunction of equality constraints and of the dissolved form of some -term.
Reference: 8. <author> Bruno Courcelle. </author> <title> Fundamental properties of infinite trees. </title> <journal> Theoretical Computer Science, </journal> <volume> 25 </volume> <month> 95-169 </month> <year> (1983). </year>
Reference-contexts: A tree unfolding is obtained from a -term by associating a unique node to every feature path. It is well known that a rooted directed graph represents a unique rational tree <ref> [8] </ref>. In our case, we obtain trees whose nodes are labeled by sorts and whose edges are labeled by features. We call these 1 If an OSF constraint is satisfiable in some interpretation, then it is also satisfiable in all canonical interpretations. (rational) OSF trees.
Reference: 9. <author> Seif Haridi and Sverker Janson. </author> <title> Kernel Andorra Prolog and its computation model. </title> <editor> In David H. D. Warren and Peter Szeredi, editors, </editor> <booktitle> Logic Programming, Proceedings of the 7th International Conference, </booktitle> <pages> pages 31-46, </pages> <address> Cambridge, MA (1990). </address> <publisher> MIT Press. </publisher>
Reference-contexts: This has been used as an implicit control mechanism in general concurrent constraint logic programming schemes; e.g., the logic of guarded Horn-clauses studied by Maher [11], Concurrent Constraint Programming (CCP) [12], and Kernel Andorra Prolog (KAP) <ref> [9] </ref>. These schemes are parameterized with respect to an abstract class of constraint systems. An incremental test for entailment and disentailment between constraints is needed for advanced control mechanisms such as delaying, coroutining, synchronization, committed choice, and deep constraint propagation.
Reference: 10. <author> Jean-Louis Lassez, Michael Maher, and Kimball Mariott. </author> <title> Unification revisited. </title> <editor> In Jack Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, chapter 15, </booktitle> <pages> pages 587-625. </pages> <publisher> Morgan-Kaufmann, </publisher> <address> Los Altos, CA (1988). </address>
Reference-contexts: This is an immediate consequence of Theorem 24 and Proposition 20. 6 Independence The following theorem states that the OSF constraint system has the independence property <ref> [10] </ref>. It is well-known that in any constraint system with this property it is possible to solve constraints which are conjunctions of constraints and negated constraints by testing entailment.
Reference: 11. <author> Michael Maher. </author> <title> Logic semantics for a class of committed-choice programs. </title> <editor> In Jean-Louis Lassez, editor, </editor> <booktitle> Logic Programming, Proceedings of the Fourth International Conference, </booktitle> <pages> pages 858-876, </pages> <address> Cambridge, MA (1987). </address> <publisher> MIT Press. </publisher>
Reference-contexts: Intuitively, the arguments of a relation which are constrained by the guard are its input parameters and correspond to the arguments of a function. This has been used as an implicit control mechanism in general concurrent constraint logic programming schemes; e.g., the logic of guarded Horn-clauses studied by Maher <ref> [11] </ref>, Concurrent Constraint Programming (CCP) [12], and Kernel Andorra Prolog (KAP) [9]. These schemes are parameterized with respect to an abstract class of constraint systems.
Reference: 12. <author> Vijay Saraswat and Martin Rinard. </author> <title> Concurrent constraint programming. </title> <booktitle> In Proceedings of the 7th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 232-245. </pages> <note> ACM (January 1990). </note>
Reference-contexts: This has been used as an implicit control mechanism in general concurrent constraint logic programming schemes; e.g., the logic of guarded Horn-clauses studied by Maher [11], Concurrent Constraint Programming (CCP) <ref> [12] </ref>, and Kernel Andorra Prolog (KAP) [9]. These schemes are parameterized with respect to an abstract class of constraint systems. An incremental test for entailment and disentailment between constraints is needed for advanced control mechanisms such as delaying, coroutining, synchronization, committed choice, and deep constraint propagation.
Reference: 13. <author> Gert Smolka and Ralf Treinen. </author> <title> Records for logic programming. </title> <editor> In Krzysztof Apt, editor, </editor> <booktitle> Logic Programming, Proceedings of the Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 240-254, </pages> <address> Cambridge, </address> <month> MA </month> <year> (1992). </year> <title> MIT Press. This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: If normalizes to the false constraint, then the two -terms are non-unifiable. Otherwise, the resulting solved OSF constraint is a 2 T is essentially the feature tree structure of [6] and <ref> [7, 13] </ref>. The difference lies in our using partially-ordered sorts and total, as opposed to partial, features. 3 More precisely, this is true if we forget superfluous trivial sort constraints of the form X : &gt;. conjunction of equality constraints and of the dissolved form of some -term.
References-found: 13

