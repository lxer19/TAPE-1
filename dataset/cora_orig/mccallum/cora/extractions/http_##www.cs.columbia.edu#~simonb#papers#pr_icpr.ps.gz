URL: http://www.cs.columbia.edu/~simonb/papers/pr_icpr.ps.gz
Refering-URL: http://www.cs.columbia.edu/~simonb/pub.html
Root-URL: http://www.cs.columbia.edu
Title: Algorithms for Pattern Rejection  
Author: Simon Baker and Shree K. Nayar 
Address: New York, USA  
Affiliation: Department of Computer Science, Columbia University,  
Date: 1996  
Note: Appeared in the Proceedings of the 13th International Conference on Pattern Recognition, Vienna,  
Abstract: The efficiency of pattern recognition is particularly crucial in two situations; whenever there are a large number of classes to discriminate, and, whenever recognition must be performed a large number of times. We develop a number of algorithms to cope with the demands of these difficult conditions. The algorithms achieve high efficiency by using pattern rejectors. A pattern rejector is a generalization of a classifier that quickly eliminates a large fraction of the candidate classes or inputs. After applying a rejector, the recognition algorithms can concentrate their computational efforts on verifying the small number of remaining possibilities. The generality of our algorithms is established through a close relationship with the Karhunen-Loeve expansion. We experimented on two representative applications, namely, object recognition and feature detection. The results demonstrate substantial efficiency improvements over existing approaches, most notably Fisher's discriminant analysis. 
Abstract-found: 1
Intro-found: 1
Reference: [Baker and Nayar 96] <author> S. Baker and S.K. Nayar, </author> <title> "Pattern Rejection," </title> <booktitle> In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, </booktitle> <address> San Fran-cisco, </address> <year> 1996. </year>
Reference-contexts: This is the case in local feature detection [Nayar et al. 96], where the feature detector must be applied at every pixel in an image. We develop efficient pattern recognition algorithms to deal with both of the scenarios described above. The algorithms achieve high performance by using pattern rejectors <ref> [Baker and Nayar 96] </ref>. A rejector is an algorithm that very quickly eliminates a large fraction of the candidate classes (i.e. objects in recognition) or inputs (i.e. local image brightness values in feature detection). The theory of pattern rejection, as developed in [Baker and Nayar 96], first defines the notion of <p> algorithms achieve high performance by using pattern rejectors <ref> [Baker and Nayar 96] </ref>. A rejector is an algorithm that very quickly eliminates a large fraction of the candidate classes (i.e. objects in recognition) or inputs (i.e. local image brightness values in feature detection). The theory of pattern rejection, as developed in [Baker and Nayar 96], first defines the notion of a rejector and then shows how a collection of simple rejectors can be combined to yield a much more effective composite rejector. <p> In this paper we propose a collection of general-purpose algorithms for the implementation of simple rejectors sat fl This research was supported in parts by ARPA Contract DACA-76-92-C-007, by DOD/ONR MURI Grant N00014-95-1-0601, and by an NSF National Young Investigator Award. isfying the design criteria derived in <ref> [Baker and Nayar 96] </ref>. Using our algorithms in the individual rejectors of a composite rejector then allows the construction of efficient pattern recognition algorithms. The derivation of our algorithms is based upon a single assumption about the underlying pattern classes, namely, the class assumption. <p> The result is a very efficient method of preprocessing an image to identify pixels that truly deserve the application of a full-fledged feature detector, such as the one proposed in [Nayar et al. 96]. 2 Background: Pattern Rejection We begin by briefly summarizing pattern rejection as developed in <ref> [Baker and Nayar 96] </ref>. After stating the assumptions and definitions, we present the design criteria for the individual component rejectors of a composite rejector. 2.1 Assumptions and Definitions A pattern recognition problem is based upon a finite set of measurements of an underlying physical process.
Reference: [Baker and Nayar 95] <author> S. Baker and S.K. Nayar, </author> <title> "A Theory of Pattern Rejection," </title> <institution> Columbia University Technical Report, CUCS-013-95, </institution> <year> 1995. </year>
Reference-contexts: There are various methods that could be used to do this. Here we present the method which we used in our object recognition example in Section 5.1. (Other methods, including the technique used for our feature detection experiments in Section 5.2, are provided in <ref> [Baker and Nayar 95] </ref>.) It was found empirically (see Figure 2) that the projected class distributions for all the ob jects closely resemble normal distributions. <p> The reason for the difference is that here there is only one pattern class corresponding to the one feature being detected. The details of the algorithms used may be found in <ref> [Baker and Nayar 95] </ref>.) The output of the composite rejector is used as input to the feature detector, and consists of pixels at which further processing is deemed worthwhile.
Reference: [Duda and Hart 73] <author> R.O. Duda and P.E. Hart, </author> <title> Pattern Classification and Scene Analysis, </title> <publisher> John Wiley & Sons, </publisher> <year> 1973. </year>
Reference-contexts: Using the same image database, we compared the performance of the composite rejector against that of Fisher's discriminant analysis [Fisher 36]. Again, we followed the same test procedure, namely, setting aside half of the data, and using the other half to construct the classifier. We constructed Fisher spaces <ref> [Duda and Hart 73] </ref> of different dimensionality. In Fisher space the classes consist of tight clusters, which we modeled as multivariate normal distributions. We computed the mean and covariance matrix of each of these distributions. <p> Although the technique is applicable to general parametric features, we only have space to display our results (see Figure 7) for edge detection. 6 Discussion There is a relationship between our algorithm for choosing the rejection vector in Section 4.2 and Fisher's discriminant analysis <ref> [Duda and Hart 73] </ref>. In particular, Algorithm 2 tends to choose a vector that maximizes between-class scatter, while keeping within-class scatter fixed at a low level. The difference between our algorithm and discriminant analysis is that discriminant analysis is presented as a single level of processing.
Reference: [Fisher 36] <author> R.A. Fisher, </author> <title> "The use of multiple measurements in taxonomic problems," </title> <journal> Annals of Eugenics, </journal> <volume> 7 </volume> <pages> 179-188, </pages> <year> 1939. </year>
Reference-contexts: Their implementation required 20 inner products, followed by a sophisticated search procedure. Using the same image database, we compared the performance of the composite rejector against that of Fisher's discriminant analysis <ref> [Fisher 36] </ref>. Again, we followed the same test procedure, namely, setting aside half of the data, and using the other half to construct the classifier. We constructed Fisher spaces [Duda and Hart 73] of different dimensionality.
Reference: [Fukunaga 90] <author> K. Fukunaga, </author> <title> Statistical Pattern Recognition, </title> <publisher> Academic Press, </publisher> <year> 1990. </year>
Reference-contexts: The derivation of our algorithms is based upon a single assumption about the underlying pattern classes, namely, the class assumption. The generality of the class assumption (and hence the algorithms) is established through a close connection with the Karhunen-Loeve (K-L) expansion <ref> [Fukunaga 90] </ref>. We demonstrate the performance of our algorithms by experimenting on two applications: object recognition using appearance matching [Murase and Nayar 95] and local feature detection [Nayar et al. 96]. We first construct a composite rejector for a widely-used image database of 20 objects.
Reference: [Murakami and Kumar 82] <author> H. Murakami and V. Kumar, </author> <title> "Efficient calculation of primary images from a set of images," </title> <journal> IEEE Transactions on Pattern Analysis and Machine Intelligence, </journal> <volume> 4 </volume> <pages> 511-515, </pages> <year> 1982. </year>
Reference-contexts: Compute the eigenvectors, e j i ; and their corresponding eigenvalues, j i , of the covariance matrix, defined by: M i = 1 P m (i) j j (If m (i) t d; the Singular Value Decomposition (SVD) should be used <ref> [Murakami and Kumar 82] </ref>.) 3. Set L i to be the subspace spanned by fe j j The choice of an appropriate value for the threshold, t, is application dependent. We suggest trying several different alternatives until an acceptable value is found.
Reference: [Murase and Nayar 95] <author> H. Murase and S.K. Nayar, </author> <title> "Visual Learning and Recognition of 3D Objects from Appearance," </title> <journal> International Journal of Computer Vision, </journal> <volume> 14 </volume> <pages> 5-24, </pages> <year> 1995. </year>
Reference-contexts: 1 Introduction The efficiency of a pattern recognition algorithm becomes increasingly important as the number of pattern classes grows. Object recognition using appearance matching <ref> [Murase and Nayar 95] </ref> is one example application where the computational dependence upon the number of classes (objects) is the key to a real time solution. High efficiency also proves critical whenever the recognition algorithm must be applied a large number of times. <p> The generality of the class assumption (and hence the algorithms) is established through a close connection with the Karhunen-Loeve (K-L) expansion [Fukunaga 90]. We demonstrate the performance of our algorithms by experimenting on two applications: object recognition using appearance matching <ref> [Murase and Nayar 95] </ref> and local feature detection [Nayar et al. 96]. We first construct a composite rejector for a widely-used image database of 20 objects. Each object appears in a large number of poses and constitutes a single pattern class. <p> Compute the projection, hx; ri. 2. Perform a binary search on the array of buckets to find the bucket, b j , containing hx; ri. 3. Return classes (b j ): 872 image pairs separated by 5 ffi of pose. The data set is that used in <ref> [Murase and Nayar 95] </ref>. 4.6 Construction of a Composite Rejector Component rejectors may be reached by more than one path in the composite rejector. <p> These problems were selected as they can, under certain assumptions, be cast as classical pattern recognition problems. Furthermore, both problems often need to be solved with high efficiency. 5.1 3D Object Recognition We follow the appearance matching approach, first described in <ref> [Murase and Nayar 95] </ref>. Object recognition is reduced to pattern recognition by first segmenting the object and then scale normalizing it to an image of size 128 fi 128 pixels. <p> Since the time taken at each node is essentially the cost of one inner product (convolution), the efficiency compares very favorably with the results obtained by Murase and Nayar <ref> [Murase and Nayar 95] </ref>. Their implementation required 20 inner products, followed by a sophisticated search procedure. Using the same image database, we compared the performance of the composite rejector against that of Fisher's discriminant analysis [Fisher 36].
Reference: [Nayar et al. 96] <author> S.K. Nayar, S. Baker, and H. Murase, </author> <title> "Parametric Feature Detection," </title> <booktitle> In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, </booktitle> <address> San Francisco, </address> <year> 1996. </year> <month> 874 </month>
Reference-contexts: High efficiency also proves critical whenever the recognition algorithm must be applied a large number of times. This is the case in local feature detection <ref> [Nayar et al. 96] </ref>, where the feature detector must be applied at every pixel in an image. We develop efficient pattern recognition algorithms to deal with both of the scenarios described above. The algorithms achieve high performance by using pattern rejectors [Baker and Nayar 96]. <p> The generality of the class assumption (and hence the algorithms) is established through a close connection with the Karhunen-Loeve (K-L) expansion [Fukunaga 90]. We demonstrate the performance of our algorithms by experimenting on two applications: object recognition using appearance matching [Murase and Nayar 95] and local feature detection <ref> [Nayar et al. 96] </ref>. We first construct a composite rejector for a widely-used image database of 20 objects. Each object appears in a large number of poses and constitutes a single pattern class. <p> Next, we constructed a composite rejector for the task of feature detection. The result is a very efficient method of preprocessing an image to identify pixels that truly deserve the application of a full-fledged feature detector, such as the one proposed in <ref> [Nayar et al. 96] </ref>. 2 Background: Pattern Rejection We begin by briefly summarizing pattern rejection as developed in [Baker and Nayar 96]. <p> This compares poorly with the 100% classification obtained by the composite rejector, using an average of just 6.43 rejection vectors. 5.2 Local Feature Detection We constructed a composite rejector for a feature detector of the type proposed in <ref> [Nayar et al. 96] </ref>. (The algorithms used in this case are slightly different to those presented in Section 4. The reason for the difference is that here there is only one pattern class corresponding to the one feature being detected.
References-found: 8

