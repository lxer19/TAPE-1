URL: http://www.cs.man.ac.uk/~kung-kiu/pub/cocl98.ps.gz
Refering-URL: http://www.cs.man.ac.uk/~kung-kiu/pub/
Root-URL: http://www.cs.man.ac.uk
Email: kung-kiu@cs.man.ac.uk ornaghi@dsi.unimi.it  
Title: On Specification and Correctness of OOD Frameworks in Computational Logic  
Author: Kung-Kiu Lau Mario Ornaghi 
Address: Manchester M13 9PL, UK Via Comelico 39/41, 20135 Milano, Italy  
Affiliation: Department of Computer Science Dipartimento di Scienze dell'Informazione University of Manchester Universita' degli studi di Milano  
Abstract: In current component-based software development (CBD), it is widely recognised that the distribution of tasks between objects and the contracts between them are key to effective design. In composing designs from reusable parts, increasingly the parts are Object-oriented Design (OOD) frameworks, namely descriptions of the interactive relationships between objects which participate in the interactions. Designs are then built by composing these frameworks, and any object in the final design will play (various) roles from several frameworks. In this paper, we discuss our preliminary efforts to define a formal semantics in computational logic for the specification and correctness of OOD frameworks, and briefly illustrate it with frameworks in the CBD methodology Catalysis. The novelty of our approach is a priori correctness for OOD frameworks (and components in general) and their composition, in contrast to current development methods which are mainly in the style of posit-and-prove, whereby proof of correctness is done by a posteriori verification. For component-based software development, we argue that a priori correctness is a better approach than a posteriori correctness. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J.R. </author> <title> Abrial. The B-Book: Assigning Programs to Meanings. </title> <publisher> Cambridge University Press, </publisher> <year> 1996. </year>
Reference-contexts: A conditional specification is thus like a pre-post-condition style of specification as in VDM [9], Z [21], and B <ref> [1] </ref>, except that it is declarative. Thus without local state, we can specify operations by pre-post-conditions in a declarative manner. This will be useful in the specification of OOD frameworks, as we will see later.
Reference: [2] <author> R.H. Bourdeau and B.H.C. Cheng. </author> <title> A formal semantics for object model diagrams. </title> <journal> IEEE Trans. Soft. Eng., </journal> <volume> 21(10) </volume> <pages> 799-821, </pages> <year> 1995. </year>
Reference-contexts: Thus without local state, we can specify operations by pre-post-conditions in a declarative manner. This will be useful in the specification of OOD frameworks, as we will see later. If we want to add state, we could do so by adding a sort, together with (updating) functions, see e.g. <ref> [2] </ref>. We actually prefer a more abstract approach involving (state) axioms that can evolve (see [12]). In our approach, there is a clear distinction between frameworks and specifications. The latter introduce new symbols and assume their proper meaning only in the context of the framework.
Reference: [3] <author> D. Coleman, P. Arnold, S. Bodoff, C. Dollin, H. Gilchrist, F. Hayes, and P. Jeremaes. </author> <title> Object-Oriented Development: The Fusion Method. </title> <publisher> Prentice-Hall, </publisher> <year> 1994. </year>
Reference-contexts: 1 Introduction At present, component-based software development (CBD) exists in the form of object-oriented software development, based on Object-Oriented Design (OOD) methods. Most of the existing formal OOD methods such as Fusion <ref> [3, 5] </ref> and Syntropy [4] use classes or objects as the basic unit of design. However, it is increasingly recognised that classes are not the best focus for design (see e.g. [8, 6]), and frameworks (see e.g. [18]) are becoming widely used as the basic unit of reuse.
Reference: [4] <author> S. Cook and J. Daniels. </author> <title> Designing Object Systems. </title> <publisher> Prentice-Hall, </publisher> <year> 1994. </year>
Reference-contexts: 1 Introduction At present, component-based software development (CBD) exists in the form of object-oriented software development, based on Object-Oriented Design (OOD) methods. Most of the existing formal OOD methods such as Fusion [3, 5] and Syntropy <ref> [4] </ref> use classes or objects as the basic unit of design. However, it is increasingly recognised that classes are not the best focus for design (see e.g. [8, 6]), and frameworks (see e.g. [18]) are becoming widely used as the basic unit of reuse.
Reference: [5] <author> D.F. D'Souza and A.C. Wills. </author> <title> Extending Fusion: practical rigor and refinement. </title> <editor> In R. Malan et al, editors, </editor> <booktitle> Object-Oriented Development at Work. Prentice-Hall 1996. </booktitle>
Reference-contexts: 1 Introduction At present, component-based software development (CBD) exists in the form of object-oriented software development, based on Object-Oriented Design (OOD) methods. Most of the existing formal OOD methods such as Fusion <ref> [3, 5] </ref> and Syntropy [4] use classes or objects as the basic unit of design. However, it is increasingly recognised that classes are not the best focus for design (see e.g. [8, 6]), and frameworks (see e.g. [18]) are becoming widely used as the basic unit of reuse.
Reference: [6] <author> D.F. D'Souza and A.C. Wills. Catalysis: </author> <title> Components, Objects and Frameworks in UML. </title> <publisher> Addison-Wesley, </publisher> <month> October </month> <year> 1998. </year> <note> Draft available at http://www.trireme.com/catalysis/book. </note>
Reference-contexts: Most of the existing formal OOD methods such as Fusion [3, 5] and Syntropy [4] use classes or objects as the basic unit of design. However, it is increasingly recognised that classes are not the best focus for design (see e.g. <ref> [8, 6] </ref>), and frameworks (see e.g. [18]) are becoming widely used as the basic unit of reuse. <p> In this paper, we discuss our preliminary efforts to use our previous research on frameworks in computational logic as a background to define a formal semantics (in computational logic) for the specification and correctness of OOD frameworks, and briefly illustrate it with OOD frameworks in the CBD methodology Catalysis <ref> [6] </ref>. We will first explain our view of frameworks in computational logic, and then consider the possibility of applying their formalisation to OOD frameworks. Frameworks provide the basis for our approach to program development in computational logic, with the novelty of a priori correctness for components and their composition. <p> frameworks, since they have proper specifications, and contain specifications for its programs. 6 Correct OOD Frameworks in Catalysis In the rest of the paper we will try to demonstrate that the formal semantics introduced in the previous sections is suitable for specifying OOD frameworks used in the CBD methodology Catalysis <ref> [6] </ref>. However, in our work we have only introduced states recently (see [12]), and we do not yet have a notion of steadfastness for methods that modify the state of an object. Therefore, we can only analyse the static aspects of class diagrams and their instances.
Reference: [7] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissades. </author> <title> Design Patterns Elements of Reusable Object-Oriented Design. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: Typical design artefacts are rarely just about one object, but about groups of objects and the way they interact. In OOD, the term frameworks is used for descriptions of groups of objects, their relationships, division of responsibilities, and interactions. Most of the design patterns discussed in books (e.g. <ref> [7] </ref>) and discussion groups are based around frameworks: for example, the `observer' pattern which keeps many views up to date with one subject; or `proxy', which provides a local representative of a remote object; or any of the more specialised design-ideas that are fitted together to make any system.
Reference: [8] <author> R. Helm, I.M. Holland, and D. Gangopadhay. </author> <title> Contracts Specifying behavioural compositions in OO systems. </title> <journal> Sigplan Notices 25(10) (Proc. </journal> <volume> ECOOP/OOPSLA 90). </volume>
Reference-contexts: Most of the existing formal OOD methods such as Fusion [3, 5] and Syntropy [4] use classes or objects as the basic unit of design. However, it is increasingly recognised that classes are not the best focus for design (see e.g. <ref> [8, 6] </ref>), and frameworks (see e.g. [18]) are becoming widely used as the basic unit of reuse.
Reference: [9] <author> C.B. Jones. </author> <title> Systematic Software Development Using VDM. </title> <publisher> Prentice Hall, </publisher> <address> 2nd edition, </address> <year> 1990. </year>
Reference-contexts: A conditional specification is thus like a pre-post-condition style of specification as in VDM <ref> [9] </ref>, Z [21], and B [1], except that it is declarative. Thus without local state, we can specify operations by pre-post-conditions in a declarative manner. This will be useful in the specification of OOD frameworks, as we will see later.
Reference: [10] <author> K.-K. Lau, C.D.M. Moss and M. Ornaghi. </author> <title> Formal development of correct classes in computational logic. In D.J. Duke and A.S. </title> <editor> Evans, editors, </editor> <booktitle> Proc. BCS-FACS Northern Formal Methods Workshop, Electronic Workshops in Computing Series. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: Definition 5.3 A class is correct if its framework is adequate and its programs are correct (in the frame- work) with respect to their specifications. A first study of the formal development of correct classes can be found in <ref> [10] </ref>. Pictorially, a generic class can be depicted as in Figure 5, using the three-tier formalism in Figure 1 in Section 2.
Reference: [11] <author> K.-K. Lau and M. Ornaghi. </author> <title> Forms of logic specifications: A preliminary study. </title> <editor> In J. Gallagher, editor, </editor> <booktitle> Proc. LOPSTR'96, </booktitle> <pages> pages 295312, </pages> <publisher> LNCS 1207, Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: An open program P r () has a signature + r, where 2 Without loss of generality, we choose the sorting example because it is concise (and familiar). 3 This is an example of a selector specification, another form of non-strict specification (see <ref> [11] </ref>). contains the open predicates and the (possible) function and constant symbols of P r ().
Reference: [12] <author> K.-K. Lau and M. Ornaghi. </author> <title> OOD Frameworks in Component-based Software Development in Computational Logic. </title> <editor> In P. Flener and K.-K. Lau, editors, </editor> <title> Pre-Proceedings of LOPSTR'98, </title> <type> Technical Report UMCS-98-6-1, </type> <institution> Dept of Computer Science, University of Manchester, </institution> <address> pages 172179, </address> <month> June </month> <year> 1998. </year>
Reference-contexts: If we want to add state, we could do so by adding a sort, together with (updating) functions, see e.g. [2]. We actually prefer a more abstract approach involving (state) axioms that can evolve (see <ref> [12] </ref>). In our approach, there is a clear distinction between frameworks and specifications. The latter introduce new symbols and assume their proper meaning only in the context of the framework. <p> Rather it corresponds to a set of (interacting) classes in OMT. Therefore, our classes are declarative counterparts of OOD frameworks. Furthermore, their instances can be made into OOD frameworks if we introduce objects with states <ref> [12] </ref>. In this case, open specifications in a class are interfaces for partial or open objects, which become closed objects in closed instances of (i.e. compositions involving) the class. In this paper, we have not considered objects and states (for a discussion see [12]), so our frameworks can (partially) model only <p> frameworks if we introduce objects with states <ref> [12] </ref>. In this case, open specifications in a class are interfaces for partial or open objects, which become closed objects in closed instances of (i.e. compositions involving) the class. In this paper, we have not considered objects and states (for a discussion see [12]), so our frameworks can (partially) model only the static level (i.e. the class diagram level) of OOD frameworks (see Section 6 later). <p> However, in our work we have only introduced states recently (see <ref> [12] </ref>), and we do not yet have a notion of steadfastness for methods that modify the state of an object. Therefore, we can only analyse the static aspects of class diagrams and their instances. <p> This corresponds, in our example, to the fact that our spider object only knows (i.e., has constants for) itself and its driver. Using isoinitial semantics, we will require that the local isoinitial model (corresponding to the local knowledge) is isomorphically embedded into the global system-model (for more details, see <ref> [12] </ref>). In general, attributes in type diagrams correspond to constants in frameworks, associations correspond to functions mapping (sets of) individuals into (sets of) individuals according to their multiplicity, operations to relations, and invariants to axioms.
Reference: [13] <author> K.-K. Lau, M. Ornaghi, and S.- A. </author> <title> Tarnlund. Steadfast logic programs. </title> <editor> J. </editor> <booktitle> Logic Programming 38(3) </booktitle> <pages> 259-294, </pages> <month> March </month> <year> 1999. </year>
Reference-contexts: However, we cannot use minimum Herbrand models to define the correctness of open programs, because in Herbrand models, open relations are assumed to be empty, and therefore cannot play the role of parameters. So in <ref> [13] </ref> we introduced minimum j-models, together with the notion of steadfastness, to serve as the basis for a model and proof theory of the correctness of open programs. Here we first recall the definition of steadfastness informally, and then define correctness of open programs, and give its relevant properties. <p> In this definiton, I is any class of models. In <ref> [13] </ref>, we have introduced some proof-methods for correctness, which hold under suitable termination conditions. Since termination requires finite ground terms, we have to consider the class of -reachable 4 models.
Reference: [14] <author> K.-K. Lau, M. Ornaghi, and A. Wills. </author> <title> Frameworks in Catalysis: Pictorial Notation and Formal Semantics. </title> <editor> In M. Hinchey and S. Liu, editors, </editor> <booktitle> Proc. 1st IEEE Int. Conf. on Formal Engineering Methods, </booktitle> <pages> pages 213-220, </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1997. </year>
Reference-contexts: Typically, a specification framework is a composite, i.e., it contains many parts, useful for speaking about various aspects of a problem domain. In this sense, it is a (declarative) counterpart of an OOD framework used in current OOD methods <ref> [14] </ref>. This will be discussed later in Section 6. 4 Specification and Correctness of Programs Specification frameworks are similar to what are called specifications in algebraic ADTs (and therefore they correspond to object models in OMT [19]). The difference is that a specification framework typically has a richer, specification-oriented language. <p> In summary, our classes are declarative counterparts of frameworks used in current OOD methods <ref> [14] </ref>, but with the advantage of having an associated notion of correctness. <p> So, here we present only a first step in the direction of OOD frameworks. Since OOD frameworks are typically complex combinations of classes (objects), their description is more intuitive via a diagrammatic notation. We shall therefore use such a notation <ref> [14] </ref> and we will give some insights into the way diagrams representing OOD frameworks can be interpreted as specification frameworks (see also [14]). <p> Since OOD frameworks are typically complex combinations of classes (objects), their description is more intuitive via a diagrammatic notation. We shall therefore use such a notation <ref> [14] </ref> and we will give some insights into the way diagrams representing OOD frameworks can be interpreted as specification frameworks (see also [14]). The double use of the term framework for both specification framework and OOD modelling framework is deliberate, since we use the former as a formalisation of the latter. To distinguish them, we shall use framework for the former and OOD framework for the latter. <p> an open OOD framework in Catalysis consists of (type diagrams of) interacting objects that correspond to (instances of) our generic classes, and invariants that correspond to axioms in our (speci fication) frameworks. 6.3 Composite Catalysis Frameworks An open OOD framework can be instantiated by a renaming of its signature (see <ref> [14] </ref>), and its instances can be composed. Such a composite framework would look like its constituent frameworks, with invariants that are simply the conjunction of those in the latter.
Reference: [15] <author> K.-K. Lau, S. Liu, M. Ornaghi, and A. Wills. </author> <title> Interacting Frameworks in Catalysis. </title> <editor> In J. Staples, M. Hinchey and S. Liu, editors, </editor> <booktitle> Proc. 2nd IEEE Int. Conf. on Formal Engineering Methods, </booktitle> <pages> pages 110-119, </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1998. </year>
Reference: [16] <author> P. Lindsay and D. Hemer. </author> <title> Using CARE to construct verified software. </title> <editor> In M. Hinchey and S. Liu, editors, </editor> <booktitle> Proc. 1st IEEE Int. Conf. on Formal Engineering Methods, </booktitle> <pages> pages 122-131, </pages> <publisher> IEEE Computer Society, </publisher> <year> 1997. </year>
Reference-contexts: Nevertheless we believe that our preliminary results on frameworks are interesting, and should provide the basis for a priori correctness for OOD. By contrast, current formal OO development methods, e.g. CARE <ref> [16] </ref>, are mainly in the style of posit-and-prove. That is, proof of correctness is done by a posteriori verification.
Reference: [17] <author> J.W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> 2nd edition, </address> <year> 1987. </year>
Reference-contexts: b L) = nocc (a; L) + 1; :a = b ! nocc (a; b L) = nocc (a; L); PAXIOMS: (total ordering axioms for ) x y ^ y x $ x = y; x y _ y x: where C-AXS (nil ; ) contains Clark's Equality Theory (see <ref> [17] </ref>) for the list constructors and nil , and the first-order induction schema H (nil ) ^ (8a; J : H (J ) ! H (a J )) ! 8L : H (L); the function nocc (a; L) gives the number of occurrences of a in L, and elemi (L; i;
Reference: [18] <author> R. Mauth. </author> <title> A better foundation: development frameworks let you build an application with reusable objects. </title> <address> BYTE 21(9):40IS 10-13, </address> <month> September </month> <year> 1996. </year>
Reference-contexts: Most of the existing formal OOD methods such as Fusion [3, 5] and Syntropy [4] use classes or objects as the basic unit of design. However, it is increasingly recognised that classes are not the best focus for design (see e.g. [8, 6]), and frameworks (see e.g. <ref> [18] </ref>) are becoming widely used as the basic unit of reuse.
Reference: [19] <author> J. Rumbaugh, M. Blaha, W. Premerlani, F. Eddy, and W. Sorenson. </author> <title> Object-Oriented Modeling and Design. </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: This will be discussed later in Section 6. 4 Specification and Correctness of Programs Specification frameworks are similar to what are called specifications in algebraic ADTs (and therefore they correspond to object models in OMT <ref> [19] </ref>). The difference is that a specification framework typically has a richer, specification-oriented language. What we call specifications in a framework are program specifications, i.e. we maintain a strict distinction between specification frameworks and (program) specifications.
Reference: [20] <author> D. Sannella and A. Tarlecki. </author> <title> Essential concepts of algebraic specification and program development. </title> <journal> Formal Aspects of Computing, </journal> <volume> 9 </volume> <pages> 229-269, </pages> <year> 1997. </year>
Reference-contexts: However, our main interest is not in operations on frameworks, like composition or instantiation, where more general techniques could be imported from the algebraic tradition (see, e.g., the use of pushouts <ref> [20, 22] </ref>). The novelty of our approach is in the introduction of specifications and a priori correctness. To concentrate on the new aspects, without introducing further technicalities, we will use our simpler Definition 3.3.
Reference: [21] <author> J.M. Spivey. </author> <title> The Z Notation. </title> <publisher> Prentice Hall, </publisher> <address> 2nd edition, </address> <year> 1992. </year>
Reference-contexts: A conditional specification is thus like a pre-post-condition style of specification as in VDM [9], Z <ref> [21] </ref>, and B [1], except that it is declarative. Thus without local state, we can specify operations by pre-post-conditions in a declarative manner. This will be useful in the specification of OOD frameworks, as we will see later.
Reference: [22] <author> M. Wirsing. </author> <title> Algebraic specification. </title> <editor> In J. Van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <pages> pages 675788. </pages> <publisher> Elsevier, </publisher> <year> 1990. </year>
Reference-contexts: However, our main interest is not in operations on frameworks, like composition or instantiation, where more general techniques could be imported from the algebraic tradition (see, e.g., the use of pushouts <ref> [20, 22] </ref>). The novelty of our approach is in the introduction of specifications and a priori correctness. To concentrate on the new aspects, without introducing further technicalities, we will use our simpler Definition 3.3.
References-found: 22

