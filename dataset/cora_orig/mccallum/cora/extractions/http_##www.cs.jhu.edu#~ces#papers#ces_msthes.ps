URL: http://www.cs.jhu.edu/~ces/papers/ces_msthes.ps
Refering-URL: http://www.cs.jhu.edu/~ces/
Root-URL: http://www.cs.jhu.edu
Title: Some Decision Problems for ML Refinement Types  
Author: Christian Skalka 
Degree: Department of Philosophy  Submitted in partial fulfillment of the requirements for the degree of Master of  
Date: January 9, 1998  
Note: Science in Logic and Computation  
Affiliation: Carnegie Mellon University  
Abstract-found: 0
Intro-found: 1
Reference: [DP97] <author> Rowan Davies and Frank Pfenning. </author> <title> Practical Refinement-Type Checking. </title> <type> Unpublished manuscript, </type> <year> 1997. </year>
Reference-contexts: The datasort declaration provided by the refinement type system for ML, described by Pfenning and Freeman in [FP91] and more recently by Davies and Pfenning in <ref> [DP97] </ref>, introduces just this sort of subtyping mechanism into the language. <p> and singleton lists, can be defined: datasort 0 a nonempty = CONS of 0 a fl 0 a list datasort 0 a empty = NIL datasort 0 a singleton = CONS of 0 a fl 0 a empty Then, with the addition of the refinement type checking algorithm given in <ref> [DP97] </ref>, the function lastcons can be given the refinement type 0 a nonempty ! 0 a singleton by the programmer, which will be verified at compile-time; spurious warnings will be eliminated, and applications 2 such as lastcons NIL will cause a compile-time error, rather than a run-time exception, alerting the programmer <p> The refinement type checking algorithm performs "abstract interpretation over a programmer-specified finite lattice of refinements of each ML type" [FP91]. Thus, the algorithm requires that the subtype relationship be decided for the set of refinements of a given ML type. Also, the abstract interpretation described in <ref> [DP97] </ref> requires that the principal type of datatype constructors be specified, and the principal type is expressed as an intersection type in this scheme. <p> Note also that a declaration with an empty list of clauses can be inferred to refine a number of different types; because of this uncertainty, the "empty declaration" is disallowed in the intended ML refinement type syntax (see <ref> [DP97] </ref>). However, it is allowed in the present language, since in this thesis context will always make clear the intended type for refinement. <p> = [fi (s 1 )] S " [fi (s 2 )] S , so the theorem holds. 2 7 Conclusion, future work This thesis can be summarized as follows: first, a refinement type language was defined, which is an analogue of the ML refinement type language described in [Fre94] and <ref> [DP97] </ref>. Sort substitutions were introduced, and for any ground sort generated by the application of a substitution to a sort, a method for obtaining a grammar associated with that ground sort was described. <p> Given the approriate termination and correctness results, these algorithms demonstrate that the emptiness and intersection problems for sorts are decidable. Since the refinement type checking algorithm requires the definition of subset and intersection algorithms for the purposes of inferring a complete sort lattice <ref> [DP97] </ref>, it is hoped that the intersection algorithm given in this thesis will contribute to the implementation of the refinement type-checking algorithm, or at least to a justification of its correctness.
Reference: [FP91] <author> Tim Freeman and Frank Pfenning. </author> <title> Refinement Types for ML. </title> <booktitle> Proceedings of the SIG-PLAN '91 Symposium on Language Design, </booktitle> <pages> pages 268-277. </pages> <publisher> ACM press, </publisher> <address> Toronto, On-tario, </address> <year> 1991. </year>
Reference-contexts: The datasort declaration provided by the refinement type system for ML, described by Pfenning and Freeman in <ref> [FP91] </ref> and more recently by Davies and Pfenning in [DP97], introduces just this sort of subtyping mechanism into the language. <p> The refinement type checking algorithm performs "abstract interpretation over a programmer-specified finite lattice of refinements of each ML type" <ref> [FP91] </ref>. Thus, the algorithm requires that the subtype relationship be decided for the set of refinements of a given ML type. <p> Clearly, this constraint alleviates many of the decidability problems normally associated with polymorphic types. Refer to <ref> [FP91] </ref> for a more complete consideration of these issues. 2.3 Type and sort declarations Type and sort declarations, as in the case of Standard ML, specify constants and value constructors which are associated with the type or sort being declared.
Reference: [Fre94] <author> Tim Freeman. </author> <title> Refinement Types for ML. </title> <type> Technical Report CMU-CS-94-110, </type> <institution> Department of Computer Science, Carnegie Mellon University, Pittsburgh, Pennsylvania, </institution> <year> 1994. </year>
Reference-contexts: S 0 = [fi (s 1 )] S " [fi (s 2 )] S , so the theorem holds. 2 7 Conclusion, future work This thesis can be summarized as follows: first, a refinement type language was defined, which is an analogue of the ML refinement type language described in <ref> [Fre94] </ref> and [DP97]. Sort substitutions were introduced, and for any ground sort generated by the application of a substitution to a sort, a method for obtaining a grammar associated with that ground sort was described.
Reference: [GS84] <author> Ferenc Gecseg and Magnus Steinby. </author> <title> Tree Automata. </title> <publisher> Akademiai Kiado, </publisher> <address> Budapest, </address> <year> 1984. </year>
Reference-contexts: The refinement type language described here has much in common with the regular tree grammars described in <ref> [GS84] </ref> and the regular term grammars described in [DZ92]. In both of these texts, algorithms were given for the emptiness, intersection and subset problems for these regular terms. <p> As shall be shown, certain restrictions on the language allow refinement types to be manipulated and compared in a manner similar to that described in <ref> [GS84] </ref> and also [DZ92], the polymorphic nature of refinement types notwithstanding. <p> Results like theorem 3.20 and proposition 6.21, and especially the very idea of "co-derivations", are clumsy workarounds, testament to the subtlety that is lost by describing tree-structured objects in a linear fashion. Gecseg and Steinby in <ref> [GS84] </ref> take an approach that is much more in keeping with the non-linear structure of regular terms, and future theoretical considerations of sorts, and decision procedures for sorts, would most likely benefit from a similar approach.
Reference: [DZ92] <author> Philip W. Dart and Justin Zobel. </author> <title> A Regular Type Language for Logic Programs. </title> <editor> In Frank Pfenning, editor, </editor> <booktitle> Types in Logic Programming, </booktitle> <pages> pages 157-188. </pages> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1992. </year>
Reference-contexts: The refinement type language described here has much in common with the regular tree grammars described in [GS84] and the regular term grammars described in <ref> [DZ92] </ref>. In both of these texts, algorithms were given for the emptiness, intersection and subset problems for these regular terms. However, these languages were not polymorphic; indeed, Dart and Zobel in [DZ92] remark, "It is not clear how such types might be manipulated or compared, and this problem has not been <p> has much in common with the regular tree grammars described in [GS84] and the regular term grammars described in <ref> [DZ92] </ref>. In both of these texts, algorithms were given for the emptiness, intersection and subset problems for these regular terms. However, these languages were not polymorphic; indeed, Dart and Zobel in [DZ92] remark, "It is not clear how such types might be manipulated or compared, and this problem has not been well investigated". As shall be shown, certain restrictions on the language allow refinement types to be manipulated and compared in a manner similar to that described in [GS84] and also [DZ92], <p> <ref> [DZ92] </ref> remark, "It is not clear how such types might be manipulated or compared, and this problem has not been well investigated". As shall be shown, certain restrictions on the language allow refinement types to be manipulated and compared in a manner similar to that described in [GS84] and also [DZ92], the polymorphic nature of refinement types notwithstanding. <p> As discovered through research done for this thesis, the decidability issues we're concerned with are intimately related to these questions. In this thesis, the strategy for solving these questions involves a consideration of sort declarations; thus, the approach is similar to that adopted in <ref> [DZ92] </ref>, where the algorithms given for deciding intersection, emptiness and subtyping for types function by "unrolling" and comparing declarations associated with types. But it is not enough to simply examine uninstantiated declarations in the case of sorts. <p> The use of intermediate sorts allow the empty algorithm to be fairly simple, and relatively easy to prove correct. Indeed, comparison will reveal that the empty algorithm is almost identical to the algorithm given in <ref> [DZ92] </ref> for computing emptiness of non-parametric types, the polymorphic nature of intermediate sorts notwithstanding. The empty algorithm works by essentially following the different possible derivation paths from a given sort, returning false if some path can constitute a simple derivation, a term defined in section 5.2. The desired result follows.
Reference: [MTH90] <author> Robin Milner, Mads Tofte and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: 1 Introduction Standard ML <ref> [MTH90] </ref> is a functional programming language with polymorphic types, and provides a system of type inference that ensures well-typedness of every expression at compile-time.
Reference: [Pau96] <author> Lawrence C. Paulson. </author> <title> ML for the Working Programmer. </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, </address> <year> 1996. </year>
Reference: [CW85] <author> Luca Cardelli and Peter Wegner. </author> <title> On Understanding types, data abstraction and poly-morphism. </title> <journal> ACM Computing Surveys, </journal> <volume> 17 </volume> <pages> 471-522, </pages> <year> 1985. </year>
Reference: [Llo84] <author> John W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1984. </year>
References-found: 9

