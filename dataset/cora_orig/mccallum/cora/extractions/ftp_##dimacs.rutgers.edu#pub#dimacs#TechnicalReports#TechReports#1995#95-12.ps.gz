URL: ftp://dimacs.rutgers.edu/pub/dimacs/TechnicalReports/TechReports/1995/95-12.ps.gz
Refering-URL: http://dimacs.rutgers.edu/TechnicalReports/1995.html
Root-URL: http://www.cs.rutgers.edu
Email: mthorup@diku.dk  
Keyword: Equivalence between sorting and priority queues  
Address: Universitetsparken 1 2100 Kbh. Denmark  
Affiliation: Dept. of Computer Science University of Copenhagen  
Note: (extended abstract) by Mikkel Thorup 1  DIMACS is a cooperative project of Rutgers University, Princeton University, AT&T Bell Laboratories and Bellcore. DIMACS is an NSF Science and Technology Center, funded under contract STC-91-19999; and also receives support from the New Jersey Commission on Science and Technology.  
Abstract: DIMACS Technical Report 95-12 May 1995 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Ajtai, M. Fredman, and J. </author> <title> Koml os, Hash functions for priority queues, </title> <journal> Inf. Contr. </journal> <volume> 63 (1984), </volume> <pages> 217-225. </pages>
Reference: [2] <author> A. Andersson, T. Hagerup, S. Nilsson, and R. Raman, </author> <note> Sorting in linear time? To appear at STOC'95. </note>
Reference-contexts: Each key passing through the priority queue participates in at most one sorting, and when we sort a set of keys, they are all contained in the current queue. Applying Theorem 1 to the recent sorting results from <ref> [2] </ref>, we get Corollary 2 There is a RAM priority queue supporting find-min in constant time and insert and delete in a) O (log log n) amortized time. b) constant amortized time if (log n) 2+" w for some " &gt; 0. <p> It should be mentioned that our bounds generalize to integers occupying any constant number of words (if there is no bound on the number of words per integer, we need to add the time it takes to read the distinguishing prefixes [4]). As discussed in <ref> [2] </ref>, multiple word integers are not an exotic special case. For example, the IEEE 754 floating-point standard is designed so that the ordering of floating point numbers can be deduced by perceiving their representations as multiple word integers [11].
Reference: [3] <author> S. Albers and T. Hagerup, </author> <title> Improved parallel integer sorting without concurrent writing, </title> <booktitle> in "Proc. 3rd SODA," </booktitle> <pages> pp. 463-472, </pages> <year> 1992. </year> <month> - 7 </month> - 
Reference-contexts: This completes the proof of Theorem 1, assuming the atomic priority queue from (iii), to be described in the next section. 3 An atomic priority queue for small integers From <ref> [3] </ref>, we have the following result: Proposition 6 We can merge two sorted lists, each of at most k keys stored in a single word, into a single sorted list stored in two words in time O (log k). <p> Corollary 7 For n k, given two lists of n (w=k)-bit keys, spread over dn=ke words, we can merge them into d2n=ke words in time O (n=k log k). Corollary 7 is implicit in <ref> [3] </ref> in a parallel setting (see [14] for a simple sequential derivation). As in the previous section, we fix k = log n log log n.
Reference: [4] <author> A. Andersson and S. Nilsson, </author> <title> A new efficient radix sort , in "Proc. </title> <booktitle> 35th FOCS," </booktitle> <pages> pp. 714-731, </pages> <year> 1994. </year>
Reference-contexts: It should be mentioned that our bounds generalize to integers occupying any constant number of words (if there is no bound on the number of words per integer, we need to add the time it takes to read the distinguishing prefixes <ref> [4] </ref>). As discussed in [2], multiple word integers are not an exotic special case. For example, the IEEE 754 floating-point standard is designed so that the ordering of floating point numbers can be deduced by perceiving their representations as multiple word integers [11].
Reference: [5] <author> P. Beame and J. H -astad, </author> <title> Optimal bounds on the decision problems on the CRCW PRAM, </title> <editor> J. </editor> <booktitle> ACM 36 (1989), </booktitle> <pages> 643-670. </pages>
Reference-contexts: Also, the priority queue from [14] only requires AC 0 operations, and it is simple enough to be of practical relevance. Our reduction to sorting uses the "atomic" priority queue from [10, x2.3] which is complicated and uses operations like multiplication that are not in AC 0 <ref> [5] </ref>. By an atomic priority queue we mean a priority queue where all the above operations are done in constant amortized time, as in Corollary 2b).
Reference: [6] <author> A.M. Ben-Amram and Z. Galil, </author> <title> When can we sort in o(n log n) time?, </title> <booktitle> in "Proc. 34th FOCS," </booktitle> <pages> pp. 538-546, </pages> <year> 1993. </year>
Reference: [7] <author> J.L. Carter and M.N. Wegman, </author> <title> Universal classes of hash functions, </title> <journal> J. Comp. Syst. Sci. </journal> <volume> 18 (1979), </volume> <pages> 143-154. </pages>
Reference-contexts: Fix k = log n log log n. We will assume: (i) Universal tables, either by hashing <ref> [7] </ref> in linear space with expected constant look-up time, or for any " &gt; 0, in space O (u " ) doing look-up by 1=" comparisons (see discussion in [14, x4]). (ii) Atomic priority queues for up to k keys.
Reference: [8] <author> M.L. Fredman and R.E. Tarjan, </author> <title> Fibonacci heaps and their uses in improved network optimization algorithms, </title> <journal> J. </journal> <note> ACM 34 (1987) 596-615. See also FOCS'84. </note>
Reference-contexts: Here decrease-key (x; d) sets x := x d. - 2 - Plain priority queue With constant decrease-key O (log n) Williams '64 [15] O (log n) Fredman & Tarjan '84 <ref> [8] </ref> O ( log n) Fredman & Willard '90 [9] O (log n= log log n) Fredman & Willard '90 [10] O (log log n) Thorup '95 [14] O ( p 1+" ) This paper Proof: A constructive proof is provided in [10, x2.2], setting B = f (n)= log n.
Reference: [9] <author> M.L. Fredman and D.E. Willard, </author> <title> Surpassing the information theoretic bound with fusion trees, </title> <journal> J. Comp. Syst. Sc. </journal> <note> 47 (1993) 424-436. See also STOC'90. </note>
Reference-contexts: Here decrease-key (x; d) sets x := x d. - 2 - Plain priority queue With constant decrease-key O (log n) Williams '64 [15] O (log n) Fredman & Tarjan '84 [8] O ( log n) Fredman & Willard '90 <ref> [9] </ref> O (log n= log log n) Fredman & Willard '90 [10] O (log log n) Thorup '95 [14] O ( p 1+" ) This paper Proof: A constructive proof is provided in [10, x2.2], setting B = f (n)= log n.
Reference: [10] <author> M.L. Fredman and D.E. Willard, </author> <title> Trans-dichotomous algorithms for minimum spanning trees and shortest paths, </title> <journal> J. Comp. Syst. Sc. </journal> <note> 48 (1994) 533-551. See also FOCS'90. </note>
Reference-contexts: Also, the priority queue from [14] only requires AC 0 operations, and it is simple enough to be of practical relevance. Our reduction to sorting uses the "atomic" priority queue from <ref> [10, x2.3] </ref> which is complicated and uses operations like multiplication that are not in AC 0 [5]. By an atomic priority queue we mean a priority queue where all the above operations are done in constant amortized time, as in Corollary 2b). <p> By an atomic priority queue we mean a priority queue where all the above operations are done in constant amortized time, as in Corollary 2b). From <ref> [10] </ref>, essentially we have the following result: Lemma 3 Provided atomic priority queues for up to f (n) keys, there is a priority queue with capacity n, supporting find-min, insert, and decrease-key in constant amortized time, and supporting delete in time O (log n= log f (n)) time. <p> decrease-key (x; d) sets x := x d. - 2 - Plain priority queue With constant decrease-key O (log n) Williams '64 [15] O (log n) Fredman & Tarjan '84 [8] O ( log n) Fredman & Willard '90 [9] O (log n= log log n) Fredman & Willard '90 <ref> [10] </ref> O (log log n) Thorup '95 [14] O ( p 1+" ) This paper Proof: A constructive proof is provided in [10, x2.2], setting B = f (n)= log n. <p> [15] O (log n) Fredman & Tarjan '84 [8] O ( log n) Fredman & Willard '90 [9] O (log n= log log n) Fredman & Willard '90 [10] O (log log n) Thorup '95 [14] O ( p 1+" ) This paper Proof: A constructive proof is provided in <ref> [10, x2.2] </ref>, setting B = f (n)= log n. Then the construction gives delete in time O (log n= log B), but from [10, x2.3], we know that f (n) = ((log n) 2 ), so O (log n= log B) = O (log n= log f (n)). <p> Then the construction gives delete in time O (log n= log B), but from <ref> [10, x2.3] </ref>, we know that f (n) = ((log n) 2 ), so O (log n= log B) = O (log n= log f (n)). <p> Then the construction gives delete in time O (log n= log B), but from [10, x2.3], we know that f (n) = ((log n) 2 ), so O (log n= log B) = O (log n= log f (n)). The insertions from <ref> [10, x2.2] </ref> do not immediately respect monotonicity, but they all fall in two groups: * During the "ripple" operation, a minimum x is deleted and a replaced by a larger element y. <p> Here we initiate the queue with a dummy 0 min X, which we remove after inserting the elements from X. With these minor modifications, the construction from <ref> [10, x2.2] </ref> proves the lemma. In [10, x2.3] they provide an atomic priority queue with capacity (log n) 2 , giving delete in O (log n= log log n) amortized time. <p> Here we initiate the queue with a dummy 0 min X, which we remove after inserting the elements from X. With these minor modifications, the construction from [10, x2.2] proves the lemma. In <ref> [10, x2.3] </ref> they provide an atomic priority queue with capacity (log n) 2 , giving delete in O (log n= log log n) amortized time. If w log n, we can implement all our operations in amortized constant time by simple bucketing, so we may assume w log n. <p> &gt; 0, we can solve the single source shortest path problem on a graph with n nodes and m edges in time O (n p 1+" 0 The previous best bound linear in m was O (n log n= log log n + m), based on the priority queues from <ref> [10] </ref>. For small m, we have the complementing O (n + m log log m) bound from [14]. <p> In <ref> [10] </ref> such queues are provided, which, in fact, take up to (log n) 2 keys. They require O (n) preprocessing time and space. (iii) Atomic priority queues for (w=k)-bit keys. Such queues will be presented in the next section. (iv) Your favorite sorting algorithm sort. <p> While L i 6= ; do D.3.1. Merge L 0 and L i into L 0 . D.3.2. L i := ;. D.4. L i := L 0 . In order to support find-min and delete-min, we use the atomic priority queue from <ref> [10] </ref> to keep track of which of the at most log n lists that has the smallest first element. Let L i be the list with the smallest first element x. Then find-min just returns x. To implement delete-min, we first delete x from L i .
Reference: [11] <author> J.L. Hennessy and D.A. Patterson, </author> <title> Computer Organization and Design: the Hardware/Software Interface, </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1994. </year>
Reference-contexts: As discussed in [2], multiple word integers are not an exotic special case. For example, the IEEE 754 floating-point standard is designed so that the ordering of floating point numbers can be deduced by perceiving their representations as multiple word integers <ref> [11] </ref>. Finally, it should be mentioned that we do not need to know n in advance.
Reference: [12] <author> P.B. Miltersen, </author> <title> Lower bounds for union-split-find related problems on random access machines, </title> <booktitle> in "Proc. 26th STOC," </booktitle> <pages> pp. 625-634, </pages> <year> 1994. </year>
Reference: [13] <author> P.B. Miltersen, N. Nisan, S. Safra, and A. Wigderson, </author> <title> On data structures and asymmetric communication complexity. </title> <note> To appear at STOC'95. </note>
Reference: [14] <author> M. </author> <title> Thorup, An O(log log n) priority queue, </title> <type> Technical Report DIKU-TR-95-5, </type> <institution> Department of Computer Science, University of Copehagen, </institution> <year> 1995. </year>
Reference-contexts: Above b) is a new result while a) is already known from <ref> [14] </ref>. In fact, the result from [14] is stronger for several reasons. For example, the priority queue from [14] works in O (log log n) worst case time, and it does not have the restriction on insert (x) that x min X. Also, the priority queue from [14] only requires AC <p> Above b) is a new result while a) is already known from <ref> [14] </ref>. In fact, the result from [14] is stronger for several reasons. For example, the priority queue from [14] works in O (log log n) worst case time, and it does not have the restriction on insert (x) that x min X. Also, the priority queue from [14] only requires AC 0 operations, and it is simple <p> Above b) is a new result while a) is already known from <ref> [14] </ref>. In fact, the result from [14] is stronger for several reasons. For example, the priority queue from [14] works in O (log log n) worst case time, and it does not have the restriction on insert (x) that x min X. Also, the priority queue from [14] only requires AC 0 operations, and it is simple enough to be of practical relevance. <p> already known from <ref> [14] </ref>. In fact, the result from [14] is stronger for several reasons. For example, the priority queue from [14] works in O (log log n) worst case time, and it does not have the restriction on insert (x) that x min X. Also, the priority queue from [14] only requires AC 0 operations, and it is simple enough to be of practical relevance. Our reduction to sorting uses the "atomic" priority queue from [10, x2.3] which is complicated and uses operations like multiplication that are not in AC 0 [5]. <p> d. - 2 - Plain priority queue With constant decrease-key O (log n) Williams '64 [15] O (log n) Fredman & Tarjan '84 [8] O ( log n) Fredman & Willard '90 [9] O (log n= log log n) Fredman & Willard '90 [10] O (log log n) Thorup '95 <ref> [14] </ref> O ( p 1+" ) This paper Proof: A constructive proof is provided in [10, x2.2], setting B = f (n)= log n. <p> For small m, we have the complementing O (n + m log log m) bound from <ref> [14] </ref>. It should be mentioned that our bounds generalize to integers occupying any constant number of words (if there is no bound on the number of words per integer, we need to add the time it takes to read the distinguishing prefixes [4]). <p> For example, the IEEE 754 floating-point standard is designed so that the ordering of floating point numbers can be deduced by perceiving their representations as multiple word integers [11]. Finally, it should be mentioned that we do not need to know n in advance. In <ref> [14, Proof of Theorem 4] </ref>, based on standard doubling techniques, the details are given on how to dynamically increase/decrease the capacity of priority queues. - 3 - 2 The general reduction This section is devoted to the general proof of Theorem 1. Fix k = log n log log n. <p> Fix k = log n log log n. We will assume: (i) Universal tables, either by hashing [7] in linear space with expected constant look-up time, or for any " &gt; 0, in space O (u " ) doing look-up by 1=" comparisons (see discussion in <ref> [14, x4] </ref>). (ii) Atomic priority queues for up to k keys. In [10] such queues are provided, which, in fact, take up to (log n) 2 keys. They require O (n) preprocessing time and space. (iii) Atomic priority queues for (w=k)-bit keys. <p> Corollary 7 For n k, given two lists of n (w=k)-bit keys, spread over dn=ke words, we can merge them into d2n=ke words in time O (n=k log k). Corollary 7 is implicit in [3] in a parallel setting (see <ref> [14] </ref> for a simple sequential derivation). As in the previous section, we fix k = log n log log n. <p> Our construction has some similarities to the one used in <ref> [14, x2] </ref>. The keys will be stored in sorted lists L 0 ; : : : ; L log n where either L i = ;, or 2 i1 &lt; jL i j 2 i .
Reference: [15] <author> J.W.J. Williams, </author> <title> Heapsort, </title> <journal> Commun. ACM 7, </journal> <volume> 5 (1964), </volume> <pages> 347-348. </pages>
Reference-contexts: Here decrease-key (x; d) sets x := x d. - 2 - Plain priority queue With constant decrease-key O (log n) Williams '64 <ref> [15] </ref> O (log n) Fredman & Tarjan '84 [8] O ( log n) Fredman & Willard '90 [9] O (log n= log log n) Fredman & Willard '90 [10] O (log log n) Thorup '95 [14] O ( p 1+" ) This paper Proof: A constructive proof is provided in [10,
References-found: 15

