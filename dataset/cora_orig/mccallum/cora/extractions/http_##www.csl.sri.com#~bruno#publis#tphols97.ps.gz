URL: http://www.csl.sri.com/~bruno/publis/tphols97.ps.gz
Refering-URL: http://www.csl.sri.com/~bruno/publis.html
Root-URL: 
Phone: 2  
Title: Using a PVS Embedding of CSP to Verify Authentication Protocols  
Author: Bruno Dutertre and Steve Schneider 
Affiliation: 1 Department of Computer Science, Queen Mary and Westfield College, University of  Department of Computer Science, Royal Holloway, University of  
Address: Murray Hill, New Jersey, USA  London, London E14NS, UK  London, Egham, Surrey TW20 0EX, UK  
Note: To be presented at TPHOLs'97, Bell Labs,  
Abstract: This paper presents an application of PVS to the verification of security protocols. The objective is to provide mechanical support for a verification method described in [14]. The PVS formalization consists of a semantic embedding of CSP and of a collection of theorems and proof rules for reasoning about authentication properties. We present an application to the Needham-Schroeder public key protocol.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> S. H. Brackin. </author> <title> Deciding Cryptographic Protocol Adequacy with HOL: </title> <booktitle> The Implementation. In TPHOLs'96. </booktitle> <publisher> Springer-Verlag, LNCS 1125, </publisher> <year> 1996. </year>
Reference-contexts: Our main contribution compared with these works is the application to the specific problem of authentication and the development of PVS theories for this purpose. In the analysis of security protocols, tools exist which support various belief logics <ref> [3, 1] </ref>. Closer to our approach are methods based on modelling protocols as collections of rules for transforming and reducing messages. Tool support in this area [9, 8] is mostly based on analysis for reachability of an insecure state which corresponds to the existence of an attack.
Reference: 2. <author> J. Bryans and S. Schneider. </author> <title> Mechanical Verification of the full Needham-Schroeder public key protocol. </title> <type> Technical report, </type> <institution> Royal Holloway, University of London, </institution> <year> 1997. </year>
Reference-contexts: PVS has found many errors in our own manual proofs of authentication properties. The proofs we performed generalise the results presented in [9] to more complex variants of the Needham Schroeder protocol. In recent works, larger protocols have been verified <ref> [2] </ref>. The basis of our mechanisation is a semantics embedding of CSP and PVS is adequate for this purpose. Camilleri [4] and Thayer [17] present similar embed-dings in HOL and IMPS.
Reference: 3. <author> M. Burrows, M. Abadi, and R. Needham. </author> <title> A Logic of Authentication. </title> <type> Technical Report 39, </type> <institution> Digital Equipment Corporation, System Research Center, </institution> <year> 1989. </year>
Reference-contexts: Designing such protocols is notoriously error-prone and attacks can often exploit weaknesses or subtle flaws. Validating authentication protocols requires a rigorous analysis and several formal approaches have been advocated for this purpose <ref> [3, 16, 12, 9] </ref>. In [14], Schneider presents such a method based on CSP [7]. The approach relies on a general network model which includes legitimate protocol participants, the users, and an intruder, the enemy. <p> Our main contribution compared with these works is the application to the specific problem of authentication and the development of PVS theories for this purpose. In the analysis of security protocols, tools exist which support various belief logics <ref> [3, 1] </ref>. Closer to our approach are methods based on modelling protocols as collections of rules for transforming and reducing messages. Tool support in this area [9, 8] is mostly based on analysis for reachability of an insecure state which corresponds to the existence of an attack.
Reference: 4. <author> A. J. Camilleri. </author> <title> Mechanizing CSP trace theory in higher order logic. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(9) </volume> <pages> 993-1004, </pages> <year> 1990. </year>
Reference-contexts: Such a formalization is classic and similar to Camilleri's HOL embedding of CSP <ref> [4] </ref>. The main differences are the representation of events and processes, and the variant of CSP considered. In [4], events are considered as atomic symbols and are represented by strings. Our formalisation is more general and uses parametric types. <p> Such a formalization is classic and similar to Camilleri's HOL embedding of CSP <ref> [4] </ref>. The main differences are the representation of events and processes, and the variant of CSP considered. In [4], events are considered as atomic symbols and are represented by strings. Our formalisation is more general and uses parametric types. Given any type T, trace [T] and process [T] represent traces and processes with events of type T. <p> The proofs we performed generalise the results presented in [9] to more complex variants of the Needham Schroeder protocol. In recent works, larger protocols have been verified [2]. The basis of our mechanisation is a semantics embedding of CSP and PVS is adequate for this purpose. Camilleri <ref> [4] </ref> and Thayer [17] present similar embed-dings in HOL and IMPS. Our main contribution compared with these works is the application to the specific problem of authentication and the development of PVS theories for this purpose.
Reference: 5. <author> J. Crow, S. Owre, J. Rushby, N. Shankar, and M. Srivas. </author> <title> A tutorial introduction to PVS. </title> <booktitle> In Workshop on Industrial-Strength Formal Specification Techniques, </booktitle> <year> 1995. </year>
Reference-contexts: An important benefit of the technique is to decompose an authentication property a global property of a network into local properties of the protocol participants. This paper shows how the PVS theorem prover <ref> [5] </ref> can provide effective mechanical support to the above method. Using a semantics embedding of CSP, we specify the general network model in PVS and derive the important theorems about authentication and rank functions. We then define specialised PVS rewrite rules and proof commands to facilitate the verifications.
Reference: 6. <author> B. Dutertre and S. Schneider. </author> <title> Embedding CSP in PVS. An Application to Authentication Protocols. </title> <type> Technical report, </type> <institution> Royal Holloway, CSD-TR-97-12. </institution>
Reference-contexts: A process is any set of traces which contains the empty trace null and which is prefix-closed. All general results about sets or sets of traces apply then immediately to processes. The CSP primitives are easily defined <ref> [6] </ref>. It is also convenient to generalise the two parallel composition operators to arbitrary (non-empty) families of processes. This non-standard extension of CSP does not pose any theoretical problem in the trace model and generalises the results presented in Sec. 2. <p> A simpler form is available for the non-parametric case. The preceding elements allow us to define CSP processes in PVS. In order to reason about such processes, we provide various lemmas such as the associativity of choice and parallel composition <ref> [6] </ref>. For specifying properties of processes we imitiate the sat operator. Properties are predicates on traces, that is, sets of traces, and the satisfaction relation is |&gt;(P, E): bool = subset?(P, E). <p> For example, we can translate the statement P sat trD = hi to P |&gt; f tr | proj (tr, D) = null g. Various rules about satisfaction and induction theorems for reasoning about fixed points are provided <ref> [6] </ref>. 6 4 The Authentication Model in PVS 4.1 Network It is routine to specify the network. <p> It is easy to experiment with various rank functions and most of the proofs remain unchanged. 5 Applications We have experimented the PVS mechanization on two versions of the Need-ham Schroeder public key protocol [10]. All the properties examined in [14] have been mechanically verified <ref> [6] </ref>. In the sequel, we consider the following variant proposed by Lowe [9] 4 : A ! B : fN a ; Ag K b A ! B : fN b g K b : 5.1 Encryption The first step in the analysis is to model public key encryption. <p> On the remaining goals, we use the predefined strategy (grind) which expands the definitions of rho and R and applies the decision procedures. This is often enough to solve the goals but sometimes the extensionality axioms for the message data type are needed (see <ref> [6] </ref> for details). For example, the proof script of rank user a is (INIT-CSP "Identity" "message") (EXPAND "userA") (CHOICE3) (PREFIX) (("1" (DELETE 2) (GRIND)) ("2" (PREFIX) (PREFIX) (DELETE 3 4) (GRIND) (CASE "x_user (y_conc (conc (conc (....)))) = b") (("1" (APPLY (REPEAT (APPLY-EXTENSIONALITY)))) ("2" (REPLACE -2) (ASSERT)))))).
Reference: 7. <author> C. A .R. Hoare. </author> <title> Communicating Sequential Processes. </title> <booktitle> Prentice-Hall International, </booktitle> <year> 1985. </year>
Reference-contexts: Designing such protocols is notoriously error-prone and attacks can often exploit weaknesses or subtle flaws. Validating authentication protocols requires a rigorous analysis and several formal approaches have been advocated for this purpose [3, 16, 12, 9]. In [14], Schneider presents such a method based on CSP <ref> [7] </ref>. The approach relies on a general network model which includes legitimate protocol participants, the users, and an intruder, the enemy. Both the users and the enemy are specified as CSP processes and authentication properties are expressed as constraints on the sequences of messages the whole network can produce. <p> Finally, we discuss and compare our developments with other mechanisations of CSP and with other verification methods for security protocols. 2 Authentication Protocols in CSP 2.1 CSP Notation CSP is an abstract language for describing concurrent systems which interact through message passing <ref> [7] </ref>. Systems are modelled in terms of the events they can perform, each event corresponding to a potential communication between a system and its environment. <p> Our formalisation is more general and uses parametric types. Given any type T, trace [T] and process [T] represent traces and processes with events of type T. The CSP dialect considered by Camilleri is Hoare's original definition of deterministic processes <ref> [7] </ref>. In this model, a process has two components, a set of traces and an alphabet of events representing the interface. Due to this interface, there are restrictions on certain CSP operators. For our purpose, it is better to follow [14] and use the CSP variant presented previously.
Reference: 8. <author> R. Kemmerer, C. Meadows, and Millen J. </author> <title> Three systems for cryptographic analysis. </title> <journal> Journal of Cryptology, </journal> <volume> 7(2), </volume> <year> 1994. </year>
Reference-contexts: In the analysis of security protocols, tools exist which support various belief logics [3, 1]. Closer to our approach are methods based on modelling protocols as collections of rules for transforming and reducing messages. Tool support in this area <ref> [9, 8] </ref> is mostly based on analysis for reachability of an insecure state which corresponds to the existence of an attack. This usually requires finitary models and the inability to find an attack does not in itself guarantee correctness of the full-scale protocol.
Reference: 9. <author> G. Lowe. </author> <title> Breaking and Fixing the Needham-Schroeder Public-Key Protocol Using FDR. </title> <booktitle> In Proc. of TACAS'96. </booktitle> <publisher> Springer-Verlag, LNCS 1055, </publisher> <year> 1996. </year>
Reference-contexts: Designing such protocols is notoriously error-prone and attacks can often exploit weaknesses or subtle flaws. Validating authentication protocols requires a rigorous analysis and several formal approaches have been advocated for this purpose <ref> [3, 16, 12, 9] </ref>. In [14], Schneider presents such a method based on CSP [7]. The approach relies on a general network model which includes legitimate protocol participants, the users, and an intruder, the enemy. <p> All the properties examined in [14] have been mechanically verified [6]. In the sequel, we consider the following variant proposed by Lowe <ref> [9] </ref> 4 : A ! B : fN a ; Ag K b A ! B : fN b g K b : 5.1 Encryption The first step in the analysis is to model public key encryption. <p> As shown in <ref> [9] </ref>, this property does not hold for the original Needham-Schroeder protocol; reception of fN b g K b still ensures that A sent the message but to a user which may be different from B. <p> The usefulness of the mechanisation is clear. In our experience, manual verification of the constraints on rank functions simply does not work. PVS has found many errors in our own manual proofs of authentication properties. The proofs we performed generalise the results presented in <ref> [9] </ref> to more complex variants of the Needham Schroeder protocol. In recent works, larger protocols have been verified [2]. The basis of our mechanisation is a semantics embedding of CSP and PVS is adequate for this purpose. Camilleri [4] and Thayer [17] present similar embed-dings in HOL and IMPS. <p> In the analysis of security protocols, tools exist which support various belief logics [3, 1]. Closer to our approach are methods based on modelling protocols as collections of rules for transforming and reducing messages. Tool support in this area <ref> [9, 8] </ref> is mostly based on analysis for reachability of an insecure state which corresponds to the existence of an attack. This usually requires finitary models and the inability to find an attack does not in itself guarantee correctness of the full-scale protocol.
Reference: 10. <author> R. M. Needham and M. D. Schroeder. </author> <title> Using Encryption for Authentication in Large Networks of Computers. </title> <journal> Comm. of the ACM, </journal> <volume> 21(12) </volume> <pages> 993-999, </pages> <year> 1978. </year>
Reference-contexts: We then describe the formalization of the network model and of the verification method in PVS. We give a simple example of application to the Needham Schroeder public key protocol <ref> [10] </ref>. Finally, we discuss and compare our developments with other mechanisations of CSP and with other verification methods for security protocols. 2 Authentication Protocols in CSP 2.1 CSP Notation CSP is an abstract language for describing concurrent systems which interact through message passing [7]. <p> It is easy to experiment with various rank functions and most of the proofs remain unchanged. 5 Applications We have experimented the PVS mechanization on two versions of the Need-ham Schroeder public key protocol <ref> [10] </ref>. All the properties examined in [14] have been mechanically verified [6].
Reference: 11. <author> S. Owre, N. Shankar, and J. M. Rushby. </author> <title> The PVS Specification Language. </title> <institution> Computer Science Lab., SRI International, </institution> <year> 1993. </year>
Reference-contexts: For such a definition to be sound, PVS requires us to show that F is monotonic by generating a proof obligation (TCC) <ref> [11] </ref>. Users can be arbitrary processes provided they satisfy the interface con straints.
Reference: 12. <author> L. Paulson. </author> <title> Proving Properties of Security Protocols by Induction. </title> <type> Technical Report TR409, </type> <institution> Computer Laboratory, University of Cambridge, </institution> <year> 1996. </year>
Reference-contexts: Designing such protocols is notoriously error-prone and attacks can often exploit weaknesses or subtle flaws. Validating authentication protocols requires a rigorous analysis and several formal approaches have been advocated for this purpose <ref> [3, 16, 12, 9] </ref>. In [14], Schneider presents such a method based on CSP [7]. The approach relies on a general network model which includes legitimate protocol participants, the users, and an intruder, the enemy. <p> This usually requires finitary models and the inability to find an attack does not in itself guarantee correctness of the full-scale protocol. Our verification approach is then a useful complement to these state exploration techniques. Paulson <ref> [12] </ref> investigates the application of Isabelle/HOL to proving security properties of protocols by induction. He specifies protocols in terms of traces and rules about how traces can be augmented. This is clearly very close to the CSP trace model but gives no control over when rules may apply.
Reference: 13. <author> S. Schneider. </author> <title> Security Properties and CSP. </title> <booktitle> In IEEE Symposium on Security and Privacy, </booktitle> <year> 1996. </year>
Reference-contexts: NET = ( jjj i USER (i) ) j [trans; rec]j ENEMY (INIT): The users do not communicate directly with each other but the enemy and the composition of users synchronize on all transmission and reception events. 2.3 Checking Authentication Properties The specification of various security properties is discussed in <ref> [13] </ref>. Authentication involves two disjoint sets of events T and R; a process P satisfies the property T authenticates R if occurrence of any event of T in a trace of P is preceded by occurrence of some element of R.
Reference: 14. <author> S. Schneider. </author> <title> Using CSP for protocol analysis: the Needham-Schroeder Public Key Protocol. </title> <type> Technical Report CSD-TR-96-14, </type> <institution> Royal Holloway, </institution> <year> 1996. </year>
Reference-contexts: Designing such protocols is notoriously error-prone and attacks can often exploit weaknesses or subtle flaws. Validating authentication protocols requires a rigorous analysis and several formal approaches have been advocated for this purpose [3, 16, 12, 9]. In <ref> [14] </ref>, Schneider presents such a method based on CSP [7]. The approach relies on a general network model which includes legitimate protocol participants, the users, and an intruder, the enemy. <p> This is denoted by P sat T authenticates R: (1) Examples in <ref> [14] </ref> illustrate how this relates concretely to authentication. Formally, T authenticates R is an abbreviation for the trace predicate trR = hi ) trT = hi; (2) where denotes projection 3 and hi is the empty trace. <p> It can be seen that this condition is equivalent to NET j [R]j Stop sat trT = hi: (3) This equivalence is the basis of the proof strategy described in <ref> [14] </ref>. The idea is to assign to every message m an integer value (m) called its rank in such a way that messages occurring in events of T have non-positive rank while only messages of positive rank can be produced by NET j [R]j Stop. <p> Given such a function, we denote by + the set of messages of positive rank and by M (tr) the set of messages which occur in a trace tr. From the definition of NET and ENEMY, one can derive the following key theorem <ref> [14] </ref>. 3 trR is the maximal subsequence of tr all of whose elements belong to R. 4 Theorem 1. <p> In this model, a process has two components, a set of traces and an alphabet of events representing the interface. Due to this interface, there are restrictions on certain CSP operators. For our purpose, it is better to follow <ref> [14] </ref> and use the CSP variant presented previously. Our definition of processes relies on PVS subtyping; process [T] is a subtype of set [trace [T]] defined as follows: S: VAR set [trace [T]] process: TYPE = f S | S (null) AND prefix closed (S) g. <p> It is easy to experiment with various rank functions and most of the proofs remain unchanged. 5 Applications We have experimented the PVS mechanization on two versions of the Need-ham Schroeder public key protocol [10]. All the properties examined in <ref> [14] </ref> have been mechanically verified [6]. <p> We follow <ref> [14] </ref> and represent messages by an abstract data type: message: DATATYPE WITH SUBTYPES key, nonkey BEGIN text (x text: Text) : text? : nonkey nonce (x nonce: Nonce) : nonce? : nonkey user (x user: Identity) : user? : nonkey public (x public: Identity) : public? : key secret (x secret: <p> The property holds for Lowe's variant, provided the ENEMY does not know N b or the secret keys of A and B. The rank function we use for the property above is defined in <ref> [14] </ref>. It satisfies the essential property below: 13 rho (pub (i, m)) = IF i=a AND (EXISTS x: m=conc3 (x, Nb, user (b))) THEN 1 ELSE rho (m) ENDIF. <p> The use of a PVS data type implies that messages constructed in different ways are different. Algebraic properties (such as the associativity of concatenation or the fact that public-key and private-key encryption are inverse of each other) cannot be introduced as equations. The approach of <ref> [14] </ref> remains valid even in the presence of more complex equational properties. This can be implemented with PVS but requires extra developments, such as a quotient construction for data types.
Reference: 15. <author> J. U. Skakkebk and N. Shankar. </author> <title> Towards a duration calculus proof assistant in PVS. In Formal Techniques in Real-Time and Fault-Tolerant Systems. </title> <publisher> Springer-Verlag, LNCS 863, </publisher> <month> September </month> <year> 1994. </year>
Reference: 16. <author> P. Syverson and P. van Oorschot. </author> <title> On Unifying Some Cryptographic Protocol Logics. </title> <booktitle> In Proc. of the 1994 IEEE Symp. on Research in Security and Privacy, </booktitle> <year> 1994. </year>
Reference-contexts: Designing such protocols is notoriously error-prone and attacks can often exploit weaknesses or subtle flaws. Validating authentication protocols requires a rigorous analysis and several formal approaches have been advocated for this purpose <ref> [3, 16, 12, 9] </ref>. In [14], Schneider presents such a method based on CSP [7]. The approach relies on a general network model which includes legitimate protocol participants, the users, and an intruder, the enemy.
Reference: 17. <author> F. J. Thayer. </author> <title> An approach to process algebra using imps. </title> <type> Technical Report MP-94B193, </type> <institution> The mitre Corporation, </institution> <year> 1994. </year> <title> This article was processed using the L A T E X macro package with LLNCS style 16 </title>
Reference-contexts: In recent works, larger protocols have been verified [2]. The basis of our mechanisation is a semantics embedding of CSP and PVS is adequate for this purpose. Camilleri [4] and Thayer <ref> [17] </ref> present similar embed-dings in HOL and IMPS. Our main contribution compared with these works is the application to the specific problem of authentication and the development of PVS theories for this purpose. In the analysis of security protocols, tools exist which support various belief logics [3, 1].
References-found: 17

