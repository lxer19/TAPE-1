URL: http://www.isi.edu/acal/tech-reports/1993/tr-93-14.ps.Z
Refering-URL: http://www.isi.edu/acal/tech-reports/index.html
Root-URL: http://www.isi.edu
Title: Branch With Masked Squashing in Superpipelined Processors  
Author: Ching-Long Su, Alvin M. Despain 
Keyword: Micro-processor, Branch Scheme, and Superpipeline  
Note: April 15, 1994  
Address: ACAL-TR-94-02  
Affiliation: Advanced Computer Architecture Laboratory  
Abstract: The performance of a superpipeline processor heavily relies on its branch performance. Traditional branch strategies used in pipelined processors are delayed branches and branch with squashing. Delayed branches use safe instructions to fill delay slots. However, for a deeply pipelined processor, a compiler may not be able to find sufficient safe instructions to fill the branch delay slots. Branch with squashing takes advantage of using instructions in target basic blocks to fill the branch delay slots. However, the penalty of branch misprediction is large in superpipelined processors. In this paper, we proposed a novel branch scheme, named branch with masked squashing, which takes advantage of both delayed branch and branch with squashing. The basic idea is to fill delay slots with safe instructions which may come from above or after the branch. For the remaining unfilled delay slots, we fill with instructions from the predicted target path. In the case of mispre-diction, only unsafe instructions are annulled. The safe instructions in branch delay slots are always executed. Simulation results show that this branch strategy performs better than traditional delayed branch and branch with squashing. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. Chaw, M. Horowitz, </author> <booktitle> Architectural Trade-offs in the Design of MIPS-X, in Proceedings of the 14th Annual International Symposium on Computer Architecture, </booktitle> <month> May </month> <year> 1987. </year>
Reference-contexts: In this paper, we investigate several branch strategies implemented in superpipelined processors. We con Branch With Masked Squashing in Superpipelined Processors Ching-Long Su and Alvin M. Despain sidered two design goals simultaneously: high performance and code compaction. The branch strategies studied include traditional delayed branch and branch with squashing <ref> [1, 2, 3, 5, 8, 10, 11, 13] </ref>. We proposed a novel branch strategy, named branch with mask squashing, which allow the compiler to fill the delay slots with useful instructions as much as possible and fill predicted target instructions in the remaining delay slots.
Reference: [2] <author> J. DeRosa, H. Levy, </author> <title> An Evaluation of Branch Architectures, </title> <booktitle> in Proceedings of the 14th Annual International Symposium on Computer Architecture, </booktitle> <month> May </month> <year> 1987. </year>
Reference-contexts: In this paper, we investigate several branch strategies implemented in superpipelined processors. We con Branch With Masked Squashing in Superpipelined Processors Ching-Long Su and Alvin M. Despain sidered two design goals simultaneously: high performance and code compaction. The branch strategies studied include traditional delayed branch and branch with squashing <ref> [1, 2, 3, 5, 8, 10, 11, 13] </ref>. We proposed a novel branch strategy, named branch with mask squashing, which allow the compiler to fill the delay slots with useful instructions as much as possible and fill predicted target instructions in the remaining delay slots.
Reference: [3] <author> P.K. Dubey and M.J. Flynn, </author> <title> Branch Strategies: Modeling and Organization, </title> <journal> in IEEE Transactions on Computers, </journal> <volume> vol. 40, No. 10, </volume> <year> 1991. </year>
Reference-contexts: In this paper, we investigate several branch strategies implemented in superpipelined processors. We con Branch With Masked Squashing in Superpipelined Processors Ching-Long Su and Alvin M. Despain sidered two design goals simultaneously: high performance and code compaction. The branch strategies studied include traditional delayed branch and branch with squashing <ref> [1, 2, 3, 5, 8, 10, 11, 13] </ref>. We proposed a novel branch strategy, named branch with mask squashing, which allow the compiler to fill the delay slots with useful instructions as much as possible and fill predicted target instructions in the remaining delay slots.
Reference: [4] <author> J.A. Fisher and JS.M. Freudenberger, </author> <title> Predicting Conditional Branch Directions From Previous Runs of a Program, </title> <booktitle> in Proceedings of the 5th International Conference on Architectural Support for Programming Languages and Operating System, </booktitle> <year> 1991. </year>
Reference-contexts: This branch prediction strategy has been successfully used in RISC processors. More advanced static branch prediction relies on run-time profiling. Profile information from previous runs can be very helpful for the next run, although the data sets used in the runs are different <ref> [4] </ref>. We experiment with the branch with squashing strategy on our superpipelined processor. For a correct branch prediction, the cost of a branch is only one cycle.
Reference: [5] <author> T. Gross, J. Hennessy, </author> <title> Reducing the Cost of Branches, </title> <booktitle> in Proceedings of the 13th Annual International Symposium on Computer Architecture, </booktitle> <month> May </month> <year> 1986. </year>
Reference-contexts: In this paper, we investigate several branch strategies implemented in superpipelined processors. We con Branch With Masked Squashing in Superpipelined Processors Ching-Long Su and Alvin M. Despain sidered two design goals simultaneously: high performance and code compaction. The branch strategies studied include traditional delayed branch and branch with squashing <ref> [1, 2, 3, 5, 8, 10, 11, 13] </ref>. We proposed a novel branch strategy, named branch with mask squashing, which allow the compiler to fill the delay slots with useful instructions as much as possible and fill predicted target instructions in the remaining delay slots.
Reference: [6] <author> R. Haygood, </author> <title> A Prolog Benchmark Suite for Aquarius, </title> <type> Technical Report, </type> <institution> Computer Science Department, University of California, </institution> <address> UCB/CSD 89/509, </address> <year> 1989. </year>
Reference-contexts: These benchmark programs are selected from the Aquarius benchmark suite <ref> [6] </ref>. Execution cycles for these benchmark programs ranges from thousands to millions of cycles. Applications of these benchmark programs includes list manipulation, data base queries, theorem provers, and computer language parsers. these benchmark programs. The dynamic instruction mix is defined as the instruction mix from the execution trace.
Reference: [7] <author> B. Holmer, B. Sano, M. Carlton, P. Van Roy, R. Haygood, W. Bush, and A. Despain. </author> <title> Fast Prolog with an Extended General Purpose Architecture, </title> <booktitle> in Proceedings of the 17th Annual International Symposium on Computer Architecture, </booktitle> <month> May </month> <year> 1990. </year>
Reference-contexts: If there are not sufficient instructions that can be found by compiler to fill branch delay slots, NOPs are inserted into these unfilled branch delay slots. Delayed branches have been used successfully on several RISC machines. These machines, including the IBM-801, MIPS [12], and VLSI-BAM <ref> [7] </ref>, have typically a one-cycle branch delay. The cost of delayed branch ranges from 1.3 to 1.5 cycles. Table 2 shows the branch performance and static code size of delayed branch with three-cycle branch delays. We assume the compare and branch operations are separate instructions.
Reference: [8] <author> W. Hwu, T. Conte, P. Chang, </author> <title> Comparing Software and Hardware Schemes of Reducing the Cost of Branches, </title> <booktitle> in Proceeding of the 16th Annual International Symposium of Computer Architecture, </booktitle> <month> May </month> <year> 1989. </year>
Reference-contexts: In this paper, we investigate several branch strategies implemented in superpipelined processors. We con Branch With Masked Squashing in Superpipelined Processors Ching-Long Su and Alvin M. Despain sidered two design goals simultaneously: high performance and code compaction. The branch strategies studied include traditional delayed branch and branch with squashing <ref> [1, 2, 3, 5, 8, 10, 11, 13] </ref>. We proposed a novel branch strategy, named branch with mask squashing, which allow the compiler to fill the delay slots with useful instructions as much as possible and fill predicted target instructions in the remaining delay slots.
Reference: [9] <author> N.P. Jouppi, and D.W. Wall. </author> <title> Available Instruction-Level Parallelism for Superscalar and Superpipelined Machines, </title> <booktitle> in Proceedings of the 3rd International Conference on Architectural Support for Programming Languages and Operating System, </booktitle> <year> 1989. </year>
Reference-contexts: 1 Introduction The performance of a superpipelined processor <ref> [9] </ref> depends critically on its branch performance. A deep pipeline design can potentially create extremely high throughput since the each pipeline stage is short. However, during program execution, several factors may break the pipeline ow. This results in less throughput than expected.
Reference: [10] <author> J.K.F. Lee and A.J. Smith, </author> <title> Branch Prediction Strategies and Branch Target Buffer Design, </title> <booktitle> Computer, </booktitle> <month> Jan. </month> <year> 1984. </year>
Reference-contexts: In this paper, we investigate several branch strategies implemented in superpipelined processors. We con Branch With Masked Squashing in Superpipelined Processors Ching-Long Su and Alvin M. Despain sidered two design goals simultaneously: high performance and code compaction. The branch strategies studied include traditional delayed branch and branch with squashing <ref> [1, 2, 3, 5, 8, 10, 11, 13] </ref>. We proposed a novel branch strategy, named branch with mask squashing, which allow the compiler to fill the delay slots with useful instructions as much as possible and fill predicted target instructions in the remaining delay slots.
Reference: [11] <author> S. Mcfarling, J. Hennssy, </author> <title> Reducing the Cost of Branches, </title> <booktitle> in Proceeding of the 13th Annual International Symposium of Computer Architecture, </booktitle> <month> May </month> <year> 1986. </year>
Reference-contexts: In this paper, we investigate several branch strategies implemented in superpipelined processors. We con Branch With Masked Squashing in Superpipelined Processors Ching-Long Su and Alvin M. Despain sidered two design goals simultaneously: high performance and code compaction. The branch strategies studied include traditional delayed branch and branch with squashing <ref> [1, 2, 3, 5, 8, 10, 11, 13] </ref>. We proposed a novel branch strategy, named branch with mask squashing, which allow the compiler to fill the delay slots with useful instructions as much as possible and fill predicted target instructions in the remaining delay slots.
Reference: [12] <institution> MIPS language programmers guide, MIPS Computer Systems, Inc., </institution> <year> 1986 </year>
Reference-contexts: If there are not sufficient instructions that can be found by compiler to fill branch delay slots, NOPs are inserted into these unfilled branch delay slots. Delayed branches have been used successfully on several RISC machines. These machines, including the IBM-801, MIPS <ref> [12] </ref>, and VLSI-BAM [7], have typically a one-cycle branch delay. The cost of delayed branch ranges from 1.3 to 1.5 cycles. Table 2 shows the branch performance and static code size of delayed branch with three-cycle branch delays. We assume the compare and branch operations are separate instructions.
Reference: [13] <author> J.E. Smith, </author> <title> A Study of Branch Prediction Strategies, </title> <booktitle> in Proceedings of the 8th Annul International Symposium on Computer Architecture, </booktitle> <month> May, </month> <year> 1981. </year>
Reference-contexts: In this paper, we investigate several branch strategies implemented in superpipelined processors. We con Branch With Masked Squashing in Superpipelined Processors Ching-Long Su and Alvin M. Despain sidered two design goals simultaneously: high performance and code compaction. The branch strategies studied include traditional delayed branch and branch with squashing <ref> [1, 2, 3, 5, 8, 10, 11, 13] </ref>. We proposed a novel branch strategy, named branch with mask squashing, which allow the compiler to fill the delay slots with useful instructions as much as possible and fill predicted target instructions in the remaining delay slots.
Reference: [14] <author> A. Srivastava and A.M. Depain, </author> <title> Prophetic Branches: A Branch Architecture for Code Compaction and Efficient Execution, </title> <booktitle> in Proceeding of MICRO-26, </booktitle> <year> 1993. </year>
Reference-contexts: We first briey discuss traditional branch strategies for reducing the cost of branch delays used in contemporary pipeline microprocessors. These branch strategies include delayed branch, branch with squash, and prophetic branch <ref> [14] </ref>. We then introduce a new branch strategy, called branch with masked squash, which is designed especially for achieving our design goals. <p> code size in the P_BWS_DB strategy, which is 2.23 IPB, comes from the code duplication of target instructions to fill delay slots for some forward branches guided by profile information. 4.4 Prophetic Branch Prophetic branch is a new method for implementing branches by predicting branch taken without inlining target instructions <ref> [14] </ref>. Branch delay slots in prophetic branch are always filled by instructions above the branch, including instructions which evaluate a branch condition (e.g. compare instructions). The basic idea is to specify the likely conditional branch before its condition evaluation.
Reference: [15] <author> C-L Su, </author> <title> An instruction Scheduler and Register Allocator for Prolog Parallel Microprocessors, </title> <booktitle> in Proceeding of International Computer Symposium, </booktitle> <year> 1992 </year>
Reference-contexts: The instruction set of the BAM code is designed in a way such that a Prolog program can be optimally compiled by the Aquarius Prolog compiler front-end, and platform for a new target machine can easily be generated. The Aquarius optimizing backend <ref> [15] </ref> performs further code translation, register allocation, instruction scheduling, peephole optimization, and assembly for a benchmark program in BAM code. The output of the Aquarius optimizing backend is object code of the target machine. In this paper, we will use the Aquarius optimizing backend for generating the SLAM object code.
Reference: [16] <author> P. Van Roy and A. M. Despain, </author> <title> High-Performance Logic Programming with the Aquarius Prolog Compiler, </title> <booktitle> Computer, </booktitle> <month> January </month> <year> 1992. </year>
Reference-contexts: The benchmark programs are compiled through the Aquarius Prolog compiler front-end into an intermediate representation (BAM code) <ref> [16] </ref>. The instruction set of the BAM code is designed in a way such that a Prolog program can be optimally compiled by the Aquarius Prolog compiler front-end, and platform for a new target machine can easily be generated.
References-found: 16

