URL: ftp://ftp.ai.univie.ac.at/papers/oefai-tr-92-27.ps.Z
Refering-URL: http://www.ai.univie.ac.at/clpqr/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: email: christian@ai.univie.ac.at  
Title: Attributed Equivalence Classes in Prolog Implementations of CLP Languages  
Author: Christian Holzbaur 
Web: TR-92-27  
Address: Freyung 6, A-1010 Vienna, Austria  
Affiliation: Austrian Research Institute for Artificial Intelligence, and Department of Medical Cybernetics and Artificial Intelligence University of Vienna  
Abstract: We introduce attributed equivalence classes as an explicit abstract data type for the representation and manipulation of general equation systems where the decision algorithm is based on quantifier elimination. The partition of quantifiers into equivalence classes results very naturally from a simple abstraction that separates the equation solving process in the object domain from global manipulation of equation systems. We propose and report on an implementation of a linear complexity equivalence relation maintenance algorithm within the framework of logic programming, based on extensible unification. The explicit representation of global aspects of equation systems leads to an object oriented approach to equation solving.
Abstract-found: 1
Intro-found: 1
Reference: [Aho et al. 83] <author> Aho A.V., Hopcroft J.E., Ullman J.D.: </author> <title> Data Structures and Algorithms, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1983. </year> <note> 3 It is available via ftp 7 </note>
Reference-contexts: If one or more quantifiers are related through an equation on the object domain, we combine the corresponding equation systems into one. The maintainance of equivalence relations is of O (n) complexity if we apply the well known union-find algorithm <ref> [Aho et al. 83] </ref>. Given this optimal way to maintain the equivalence relation, we can enhance the data structures that encode the equivalence relation with additional attributes that facilitate the process of equation solving on the object domain.
Reference: [Batut et al. 91] <author> Batut C., Bernardi H., Cohen H., Olivier M.: </author> <title> User's Guide to PARI-GP, </title> <institution> UFR de Mathematiques et Informatique, Universite Bordeaux, </institution> <year> 1991. </year>
Reference: [Boole 47] <author> Boole G.: </author> <title> The Mathematical Analysis of Logic, </title> <publisher> Macmillan, </publisher> <year> 1947. </year>
Reference-contexts: The algebraic structures whose introduction and treatment constitutes the extension of a given unification-based language governs the selection of the decision procedures used by the constraint satisfaction mechanism. In the case of Real Closed Fields and Booleans the decision procedures rest upon quantifier elimination <ref> [Boole 47, Tarski 48] </ref>. In the CLP context we deal with systems of equations over the algebraic domain expressions. A system of equations is a conjunction of 1 equations that share quantifiers, i.e. variables 1 in LP terminology.
Reference: [Cohen 90] <author> Cohen J.: </author> <title> Constraint Logic Programming Languages, </title> <journal> Communications of the ACM, </journal> <volume> 33(7), </volume> <pages> 52-68, </pages> <year> 1990. </year>
Reference-contexts: 1 Introduction Constraint Logic Programming (CLP) languages extend unification by a more general operation called constraint satisfaction <ref> [Cohen 90] </ref>. Theoretical foundations of CLP languages are provided by [Jaffar et al. 86] and [Colmerauer 90]. The algebraic structures whose introduction and treatment constitutes the extension of a given unification-based language governs the selection of the decision procedures used by the constraint satisfaction mechanism.
Reference: [Colmerauer 90] <author> Colmerauer A.: </author> <title> An Introduction to Prolog III, </title> <journal> Communications of the ACM, </journal> <volume> 33(7), </volume> <pages> 69-90, </pages> <year> 1990. </year>
Reference-contexts: 1 Introduction Constraint Logic Programming (CLP) languages extend unification by a more general operation called constraint satisfaction [Cohen 90]. Theoretical foundations of CLP languages are provided by [Jaffar et al. 86] and <ref> [Colmerauer 90] </ref>. The algebraic structures whose introduction and treatment constitutes the extension of a given unification-based language governs the selection of the decision procedures used by the constraint satisfaction mechanism. In the case of Real Closed Fields and Booleans the decision procedures rest upon quantifier elimination [Boole 47, Tarski 48].
Reference: [Dantzig 63] <author> Dantzig G.B.: </author> <title> Linear Programming and Extensions, </title> <publisher> Princeton University Press, </publisher> <address> Princeton, NJ, </address> <year> 1963. </year>
Reference-contexts: This is because there is a solved form for systems of inequalities. The solved form is produced through the application of the Simplex algorithm <ref> [Dantzig 63] </ref>. The basic steps of the algorithm, the replacement of a dependent quantifier (a basic variable in linear programming terminology) by an independent quantifier (the pivot operation), is again nothing but what we called back substitution step above.
Reference: [Heintze et al. 87] <author> Heintze N., Michaylov S., Stuckey P.: </author> <title> CLP(R) and Some Electrical Engineering Problems, </title> <editor> in Lassez J.L.(ed.), </editor> <booktitle> Logic Programming Proceedings of the 4th International Conference Volume 2, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1987. </year>
Reference: [Heintze et al. 91] <author> Heintze N., Jaffar J., Michaylov S., Stuckey P., Yap R.: </author> <title> The CLP(R) Programmer's Manual, </title> <type> Version 1.1, </type> <institution> IBM Research Division, T.J.Watson Research Center, </institution> <address> Yorktown Heights, N.Y. 10598, </address> <year> 1991. </year>
Reference-contexts: Having abandoned the notion of a global matrix, we are left with the problem of how to perform back substitutions. The next two sections describe two principal means to perform back substitution in sparse matrices. The former is the scheme employed by <ref> [Heintze et al. 91] </ref> which is more suitable for procedural implementations because it involves structure mutation and explicit memory management. <p> One suitable data structure to cope with this situation are hash tables, yielding O (n) complexity for n update operations. Existing implementations, like <ref> [Heintze et al. 91] </ref>, use unordered, linked lists with O (n 2 ) complexity. 2.2 Abstraction towards an object oriented representation of equation systems If we consider individual quantifiers as trivial equation systems in solved form, we can abstract the process of equation solving from the object domain into a space
Reference: [Holzbaur 90] <author> Holzbaur C.: </author> <title> Specification of Constraint Based Inference Mechanisms through Extended Unification, </title> <institution> Dept. of Medical Cybernetics & Artificial Intelligence, University of Vienna, Dissertation, </institution> <year> 1990. </year>
Reference-contexts: The behavior of metastructures during unifications can be specified precisely through a Prolog meta interpreter which makes unification explicit. A comparison of the data types with regard to CLP language implementations can be found in [Holzbaur 92]. In <ref> [Holzbaur 90] </ref>, the traversal of the update chains has been made transparent by moving it into the specification of metastructures and their treatment during unification. In particular, the permanent compression of the chains, as opposed to compression at garbage collection time only [Hoitouze 90], was suggested and implemented. <p> The only dependent quantifier of this class is X. Following the specification from <ref> [Holzbaur 90] </ref>, unification of equivalence classes would be implemented as: meta_meta_unify ( e ( X, A, At, ...), e ( X, B, Bt, ...)) :- At = B, % append lists of dep. quants X = e ( _, A, Bt, ...). % new equivalence class 4 Summary Explicit equivalence classes
Reference: [Holzbaur 92] <author> Holzbaur C.: </author> <title> Metastructures vs. Attributed Variables in the Context of Extensible Unification, </title> <journal> Oesterreichisches Forschungsinstitut fuer Artificial Intelligence, Wien, </journal> <volume> TR-92-??, </volume> <year> 1992. </year>
Reference-contexts: The behavior of metastructures during unifications can be specified precisely through a Prolog meta interpreter which makes unification explicit. A comparison of the data types with regard to CLP language implementations can be found in <ref> [Holzbaur 92] </ref>. In [Holzbaur 90], the traversal of the update chains has been made transparent by moving it into the specification of metastructures and their treatment during unification.
Reference: [Hoitouze 90] <author> Huitouze S.le: </author> <title> A new data structure for implementing extensions to Prolog, </title> <editor> in Deransart P. and Maluszunski J.(eds.), </editor> <booktitle> Programming Language Implementation and Logic Programming, </booktitle> <publisher> Springer, Heidelberg, </publisher> <pages> 136-150, </pages> <year> 1990. </year>
Reference-contexts: Therefore, sequences of modifications lead to chains of structures. The current 'value' of an object is to be found at the end of the chain. This idea carries over to metastructures [Neumerkel 90] and attributed variables <ref> [Hoitouze 90] </ref>, two data types that aim at the extension of logic programming languages. Metastructures are ordinary, non-variable Prolog terms with the sole difference that they can be detected as members of this special sort. <p> In [Holzbaur 90], the traversal of the update chains has been made transparent by moving it into the specification of metastructures and their treatment during unification. In particular, the permanent compression of the chains, as opposed to compression at garbage collection time only <ref> [Hoitouze 90] </ref>, was suggested and implemented. In an extended Prolog system following this specification, the maintainance of attributed equivalence classes is logically sound, declarative, and operationally efficient.
Reference: [Jaffar et al. 86] <author> Jaffar J., Lassez J.L., Maher M.: </author> <title> A Logic Programming Language Scheme, </title> <editor> in Groot D.de and Lindstrom G.(eds.): </editor> <title> Logic Programming: Relations, Functions and Equations, </title> <publisher> Prentice Hall, </publisher> <address> pp.441-468, </address> <year> 1986. </year>
Reference-contexts: 1 Introduction Constraint Logic Programming (CLP) languages extend unification by a more general operation called constraint satisfaction [Cohen 90]. Theoretical foundations of CLP languages are provided by <ref> [Jaffar et al. 86] </ref> and [Colmerauer 90]. The algebraic structures whose introduction and treatment constitutes the extension of a given unification-based language governs the selection of the decision procedures used by the constraint satisfaction mechanism.
Reference: [Jaffar et al. 91] <author> Jaffar J., Michaylov S., Yap R.: </author> <title> A Methodology for Managing Hard Constraints in CLP Systems, </title> <booktitle> in Proceedings of the ACM SIGPLAN Symposium on Programming Language Design and Implementation, </booktitle> <address> Toronto, Canada, </address> <year> 1991. </year>
Reference-contexts: Existing implementations are complete for linear (in)equations only. This restriction is motivated by the doubly exponential complexity of the decision algorithm for the general case. Nonlinear equations are delayed until they get linear, or sufficiently simple to be solved at last <ref> [Jaffar et al. 91] </ref>. 2 Maintaining the solved form Traditional procedural implementations of numerical linear equation solvers operate on the coefficient matrix of an equation system of given dimension.
Reference: [Neumerkel 90] <author> Neumerkel U.: </author> <title> Extensible Unification by Metastructures, </title> <booktitle> Proc. </booktitle> <address> META90, </address> <year> 1990. </year>
Reference-contexts: Therefore, sequences of modifications lead to chains of structures. The current 'value' of an object is to be found at the end of the chain. This idea carries over to metastructures <ref> [Neumerkel 90] </ref> and attributed variables [Hoitouze 90], two data types that aim at the extension of logic programming languages. Metastructures are ordinary, non-variable Prolog terms with the sole difference that they can be detected as members of this special sort.
Reference: [Sterling & Shapiro 86] <author> Sterling L., Shapiro E.: </author> <title> The Art of Prolog, </title> <publisher> MIT Press, </publisher> <address> Cam-bridge, MA, </address> <year> 1986. </year>
Reference-contexts: As outlined in 6 an earlier section, in order to retain the linear complexity of the equivalence class maintainace algorithm, combining attributes of equivalence classes must be of O (1). This is why we use difference lists <ref> [Sterling & Shapiro 86] </ref> to encode the set of dependent quantifiers in an equivalence class.
Reference: [Tarski 48] <author> Tarski A.: </author> <title> A Decision Method for Elementary Algebra and Geometry, </title> <publisher> University of California Press, </publisher> <address> Berkeley, CA, </address> <year> 1948. </year>
Reference-contexts: The algebraic structures whose introduction and treatment constitutes the extension of a given unification-based language governs the selection of the decision procedures used by the constraint satisfaction mechanism. In the case of Real Closed Fields and Booleans the decision procedures rest upon quantifier elimination <ref> [Boole 47, Tarski 48] </ref>. In the CLP context we deal with systems of equations over the algebraic domain expressions. A system of equations is a conjunction of 1 equations that share quantifiers, i.e. variables 1 in LP terminology.
Reference: [Taylor 91] <author> Taylor A.: </author> <title> High Performance Prolog on a RISC, </title> <booktitle> in Special Issue: Selected Papers from the Seventh International Conference on Logic Programming, New Generation Computing, </booktitle> <address> 9(3,4), </address> <year> 1991. </year>
References-found: 17

