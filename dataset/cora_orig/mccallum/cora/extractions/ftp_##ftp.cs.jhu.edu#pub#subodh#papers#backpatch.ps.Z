URL: ftp://ftp.cs.jhu.edu/pub/subodh/papers/backpatch.ps.Z
Refering-URL: http://www.cs.jhu.edu/~subodh/research/abs.vis.html
Root-URL: http://www.cs.jhu.edu
Title: Hierarchical Visibility Culling for Spline Models  
Author: Subodh Kumar Dinesh Manocha 
Keyword: NURBS rendering, Visibility, Back-patch, CAGD, ONE-tree.  
Address: Chapel Hill, NC 27599-3175, USA  
Affiliation: University of North Carolina  
Email: Email: fkumar,manochag@cs.unc.edu  
Phone: Ph: (919) 962-1943. Fax: (919) 962-1799.  
Web: WWW: http://www.cs.unc.edu/~fkumar,manochag  
Abstract: We present hierarchical algorithms for visibility culling of spline models. This includes back-patch culling, a generalization of back-face culling for polygons to splines. These algorithms are extended to trimmed surfaces as well. We propose different spatial approximations for enclosing the normals of a spline surface and compare them for efficiency and effectiveness on different graphics systems. We extend the culling algorithms using hierarchical techniques to collection of surface patches and combine them with view-frustum culling to formulate a ON E (Object-Normal Exclusion)-tree for a given model. The algorithm traverses the ON E-tree at run time and culls away portions of the model not visible from the current viewpoint. These algorithms have been implemented and applied to a number of large models. In practice, we are able to speed-up the overall spline rendering algorithms by about 20 30% based on back-patch culling only and by more than 50% using ON E-trees. 
Abstract-found: 1
Intro-found: 1
Reference: [AES91] <author> S.S. Abi-Ezzi and L.A. Shirman. </author> <title> Tessellation of curved surfaces under highly varying transformations. </title> <booktitle> Proceedings of Eurographics, </booktitle> <pages> pages 385-397, </pages> <year> 1991. </year>
Reference-contexts: Many techniques based on ray-tracing, scan-line conversion, pixel-level subdivision and polygoniza-tion have been proposed for rendering parametric spline models [Cat74, NSK90, LCWB80]. However, polygonization based approaches are able to make efficient use of the hardware capabilities of the current graphics systems and are significantly faster than the rest <ref> [AES93, Dea89, LC93, SC88, FK90, RHD89, AES91, KML95] </ref>. The resulting algorithms use uniform or adaptive subdivision of spline surfaces to compute polygonal approximation. The approximation is a function of the current viewing direction and is typically, re-computed at each frame.
Reference: [AES93] <author> S.S. Abi-Ezzi and L.A. Shirman. </author> <title> The scaling behavior of viewing transformations. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 13(3) </volume> <pages> 48-54, </pages> <year> 1993. </year>
Reference-contexts: Many techniques based on ray-tracing, scan-line conversion, pixel-level subdivision and polygoniza-tion have been proposed for rendering parametric spline models [Cat74, NSK90, LCWB80]. However, polygonization based approaches are able to make efficient use of the hardware capabilities of the current graphics systems and are significantly faster than the rest <ref> [AES93, Dea89, LC93, SC88, FK90, RHD89, AES91, KML95] </ref>. The resulting algorithms use uniform or adaptive subdivision of spline surfaces to compute polygonal approximation. The approximation is a function of the current viewing direction and is typically, re-computed at each frame.
Reference: [BKSS90] <author> N. Beckmann, P. Kriegel, R. Schneider, and B. Seeger. </author> <title> R* tree: An efficient and robust access method for points and rectangles. </title> <booktitle> In International Conference on Management of Data, </booktitle> <pages> pages 322-331, </pages> <year> 1990. </year>
Reference-contexts: We refer to this as the normal space hierarchy, as opposed to object space hierarchy, which is used for view frustum culling. In our application, we use an approach similar to R-Trees <ref> [BKSS90] </ref>. In essence, we maintain a hierarchy of bounding boxes. This method greatly simplifies the merging of the normal and object space hierarchies into one structure. Thus we have to store and traverse only one tree. The objects space hierarchy is constructed based on object space adjacency.
Reference: [Cat74] <author> E. Catmull. </author> <title> A subdivision algorithm for computer display of curved surfaces. </title> <type> PhD thesis, </type> <institution> University of Utah, </institution> <year> 1974. </year>
Reference-contexts: Approved by ARPA for public release distribution unlimited. tems are not able to achieve real-time frame rates for applications involving virtual worlds, walkthroughs and immersive design. Many techniques based on ray-tracing, scan-line conversion, pixel-level subdivision and polygoniza-tion have been proposed for rendering parametric spline models <ref> [Cat74, NSK90, LCWB80] </ref>. However, polygonization based approaches are able to make efficient use of the hardware capabilities of the current graphics systems and are significantly faster than the rest [AES93, Dea89, LC93, SC88, FK90, RHD89, AES91, KML95].
Reference: [Cla76] <author> J. H. Clark. </author> <title> Hierarchical geometric models for visible surface algorithms. </title> <journal> Communications of ACM, </journal> 19(10) 547-554, 1976. 
Reference-contexts: If the number of un-merged sub-patches is large; merge the closest ones recursively. 3 Hierarchical Visibility For large databases, the number of primitives is quite large. There is a substantial overhead of performing tests for each primitive per frame. On the other hand we can hierarchically group <ref> [Cla76] </ref> primitives together and use smaller number of tests to eliminate invisible primitives. A wide variety of space partitioning methods e.g. R-Trees, Quad trees, BSP, Oct trees, etc. for view-frustum culling have been proposed in the literature. Different methods are suited for different applications.
Reference: [Dea89] <author> T. DeRose and M. Bailey et al. Apex: </author> <title> two architectures for generating parametric curves and surfaces. </title> <journal> The Visual Computer, </journal> <volume> 5(5) </volume> <pages> 264-276, </pages> <year> 1989. </year>
Reference-contexts: Many techniques based on ray-tracing, scan-line conversion, pixel-level subdivision and polygoniza-tion have been proposed for rendering parametric spline models [Cat74, NSK90, LCWB80]. However, polygonization based approaches are able to make efficient use of the hardware capabilities of the current graphics systems and are significantly faster than the rest <ref> [AES93, Dea89, LC93, SC88, FK90, RHD89, AES91, KML95] </ref>. The resulting algorithms use uniform or adaptive subdivision of spline surfaces to compute polygonal approximation. The approximation is a function of the current viewing direction and is typically, re-computed at each frame.
Reference: [Far93] <author> G. Farin. </author> <title> Curves and Surfaces for Computer Aided Geometric Design: A Practical Guide. </title> <publisher> Academic Press Inc., </publisher> <year> 1993. </year>
Reference-contexts: In the rest of the paper, we will demonstrate these algorithms on Bezier surfaces. A Bezier surface, F (u; v)= W (u;v) ; Y (u;v) W (u;v) ; is specified using control points and is a linear combination of Bernstein functions <ref> [Far93] </ref>. Moreover, the entire patch is contained in the convex hull of the control points. <p> The new patch is obtained by subdividing the original patch at u = u m ; u = u M ; v = v m and v = v M <ref> [Far93] </ref>. Unfortunately, for many trimmed patches this does not result in a good bound. Such patches are subdivided as follows: 1. Choose points on the curve, that decompose it into `rectangle like' sub-curves.
Reference: [FK90] <author> D.R. Forsey and V. Klassen. </author> <title> An adaptive subdivision algorithm for crack prevention in the display of parametric surfaces. </title> <booktitle> In Proceedings of Graphics Interface, </booktitle> <pages> pages 1-8, </pages> <year> 1990. </year>
Reference-contexts: Many techniques based on ray-tracing, scan-line conversion, pixel-level subdivision and polygoniza-tion have been proposed for rendering parametric spline models [Cat74, NSK90, LCWB80]. However, polygonization based approaches are able to make efficient use of the hardware capabilities of the current graphics systems and are significantly faster than the rest <ref> [AES93, Dea89, LC93, SC88, FK90, RHD89, AES91, KML95] </ref>. The resulting algorithms use uniform or adaptive subdivision of spline surfaces to compute polygonal approximation. The approximation is a function of the current viewing direction and is typically, re-computed at each frame.
Reference: [FVFH93] <author> J. Foley, A. VanDam, S. Feiner, and J. Hughes. </author> <title> Computer Graphics principles and practice. </title> <publisher> Addison Wesley, </publisher> <address> Menlo Park, California, </address> <year> 1993. </year>
Reference-contexts: The techniques for polygonal models include view-frustum culling, obscuration culling and back-face culling. * View-frustum culling methods use spatial data structures like octrees and hierarchical traversals of such structures to cull out portions of the model not visible <ref> [FVFH93] </ref>. These have been extended to spline models using bounding boxes and convex hulls of control polytopes. * Obscuration culling techniques utilize algorithms for hidden-surface removal and occlusion culling [FVFH93]. <p> use spatial data structures like octrees and hierarchical traversals of such structures to cull out portions of the model not visible <ref> [FVFH93] </ref>. These have been extended to spline models using bounding boxes and convex hulls of control polytopes. * Obscuration culling techniques utilize algorithms for hidden-surface removal and occlusion culling [FVFH93]. However, most of the algorithms for polygonal models are non-trivial to implement and are unable to compute the visi ble surfaces in real-time for large models. The extension of such algorithms to splines is even more difficult.
Reference: [KM94] <author> S. Krishnan and D. Manocha. </author> <title> Global visibility and hidden surface algorithms for free form surfaces. </title> <type> Technical Report TR94-063, </type> <institution> Department of Computer Science, University of North Carolina, </institution> <year> 1994. </year>
Reference-contexts: We also present an efficient tree traversal algorithm. Finally in Section 4, we discuss the implementation and performance of the algorithms. 2 Visibility Computations In general, the exact computation of the visible portions of a spline model is a non-trivial problem requiring silhouette computation and projection curves <ref> [KM94] </ref>. In this section, we show that it is relatively simple to perform an approximate visibility check to find most of the spline surfaces that are completely invisible from the current viewpoint. The algorithms presented are general and applicable to all curved and orientable surfaces with first order continuity.
Reference: [KML95] <author> S. Kumar, D. Manocha, and A. Lastra. </author> <title> Interactive display of large scale NURBS models. </title> <booktitle> In Symposium on Interactive 3D Graphics, </booktitle> <pages> pages 51-58, </pages> <address> Monterey, CA, </address> <year> 1995. </year>
Reference-contexts: Many techniques based on ray-tracing, scan-line conversion, pixel-level subdivision and polygoniza-tion have been proposed for rendering parametric spline models [Cat74, NSK90, LCWB80]. However, polygonization based approaches are able to make efficient use of the hardware capabilities of the current graphics systems and are significantly faster than the rest <ref> [AES93, Dea89, LC93, SC88, FK90, RHD89, AES91, KML95] </ref>. The resulting algorithms use uniform or adaptive subdivision of spline surfaces to compute polygonal approximation. The approximation is a function of the current viewing direction and is typically, re-computed at each frame. <p> The resulting polygons are then rendered using the standard graphics pipeline. However, the best known algorithms based on such approaches are only able to render models consisting of up to 600 700 patches at interactive frame rates on high-end commercial systems like SGI Reality Engine 2 <ref> [RHD89, KML95] </ref>. There is considerable literature on visibility preprocessing and on-line culling of polygonal data-sets. Our goal is to extend these techniques to curved and spline models. <p> Most of the high-end graphics system have an implementation of this technique as a part of the graphics pipeline. In this paper, we extend back-face culling for polygons to back-patch culling for splines. The idea of back-patch culling was introduced in <ref> [KML95, SAE93] </ref>. Our algorithm is more general, more efficient and simpler to implement. It involves efficient computation and representation of bounds on nor-mals of a patch. We present algorithms for exact back-patch culling for perspective projection. <p> If F is a tensor product m fi n polynomial surface, the pseudo-normal surface is a (2m 1) fi (2n 1) Bezier surface. If F is a rational surface, the degree of the cross-product of the partial derivative vectors is 4m fi 4n. However it can be simplified <ref> [KML95] </ref> to: f u fi f v W f u fi f W v f W u fi f v where F = f W .
Reference: [LC93] <author> W.L. Luken and Fuhua Cheng. </author> <title> Rendering trimmed NURB surfaces. </title> <institution> Computer science research report 18669(81711), IBM Research Division, </institution> <year> 1993. </year>
Reference-contexts: Many techniques based on ray-tracing, scan-line conversion, pixel-level subdivision and polygoniza-tion have been proposed for rendering parametric spline models [Cat74, NSK90, LCWB80]. However, polygonization based approaches are able to make efficient use of the hardware capabilities of the current graphics systems and are significantly faster than the rest <ref> [AES93, Dea89, LC93, SC88, FK90, RHD89, AES91, KML95] </ref>. The resulting algorithms use uniform or adaptive subdivision of spline surfaces to compute polygonal approximation. The approximation is a function of the current viewing direction and is typically, re-computed at each frame.
Reference: [LCWB80] <author> J.M. Lane, L.C. Carpenter, J. T. Whitted, and J.F. </author> <title> Blinn. Scan line methods for displaying parametrically defined surfaces. </title> <journal> Communications of ACM, </journal> <volume> 23(1) </volume> <pages> 23-34, </pages> <year> 1980. </year>
Reference-contexts: Approved by ARPA for public release distribution unlimited. tems are not able to achieve real-time frame rates for applications involving virtual worlds, walkthroughs and immersive design. Many techniques based on ray-tracing, scan-line conversion, pixel-level subdivision and polygoniza-tion have been proposed for rendering parametric spline models <ref> [Cat74, NSK90, LCWB80] </ref>. However, polygonization based approaches are able to make efficient use of the hardware capabilities of the current graphics systems and are significantly faster than the rest [AES93, Dea89, LC93, SC88, FK90, RHD89, AES91, KML95].
Reference: [Nei66] <author> B. O' Neill. </author> <title> Elementary Differential Geometry. </title> <publisher> Academic Press, </publisher> <year> 1966. </year>
Reference-contexts: At any point on the surface F (u; v), the normal direction is given by N = F u fi F v . Bezier surfaces belong to the class of surfaces called orientable surfaces such that their normals can be oriented `inside' or `outside' the surface <ref> [Nei66] </ref>. For a given model we can orient all the surfaces by reversing the order of control points such that N (u; v) points outside for each u; v for each patch. Gauss maps provide a tool to compute N. <p> is a map G : F ! S 2 , the 2-Sphere in R 3 , which takes the point F (u; v) into the translation of the vector U (u; v) to the origin, where U (u; v) is the unit vector in the direction of N (u; v) <ref> [Nei66] </ref>. The function G (u; v) can be used to compute the unit normal of the surface at the point (u; v). However, this can be relatively expensive to compute and in our application we instead use a pseudo-Gauss map we translate N instead of U.
Reference: [NSK90] <author> T. Nishita, T.W. Sederberg, and M. Kakimoto. </author> <title> Ray tracing trimmed rational surface patches. </title> <journal> ACM Computer Graphics, </journal> <volume> 24(4) </volume> <pages> 337-345, </pages> <year> 1990. </year> <note> (SIGGRAPH Proceedings). </note>
Reference-contexts: Approved by ARPA for public release distribution unlimited. tems are not able to achieve real-time frame rates for applications involving virtual worlds, walkthroughs and immersive design. Many techniques based on ray-tracing, scan-line conversion, pixel-level subdivision and polygoniza-tion have been proposed for rendering parametric spline models <ref> [Cat74, NSK90, LCWB80] </ref>. However, polygonization based approaches are able to make efficient use of the hardware capabilities of the current graphics systems and are significantly faster than the rest [AES93, Dea89, LC93, SC88, FK90, RHD89, AES91, KML95].
Reference: [RHD89] <author> A. Rockwood, K. Heaton, and T. Davis. </author> <title> Real-time rendering of trimmed surfaces. </title> <journal> ACM Computer Graphics, </journal> <volume> 23(3) </volume> <pages> 107-117, </pages> <year> 1989. </year> <note> (SIGGRAPH Proceedings). </note>
Reference-contexts: Many techniques based on ray-tracing, scan-line conversion, pixel-level subdivision and polygoniza-tion have been proposed for rendering parametric spline models [Cat74, NSK90, LCWB80]. However, polygonization based approaches are able to make efficient use of the hardware capabilities of the current graphics systems and are significantly faster than the rest <ref> [AES93, Dea89, LC93, SC88, FK90, RHD89, AES91, KML95] </ref>. The resulting algorithms use uniform or adaptive subdivision of spline surfaces to compute polygonal approximation. The approximation is a function of the current viewing direction and is typically, re-computed at each frame. <p> The resulting polygons are then rendered using the standard graphics pipeline. However, the best known algorithms based on such approaches are only able to render models consisting of up to 600 700 patches at interactive frame rates on high-end commercial systems like SGI Reality Engine 2 <ref> [RHD89, KML95] </ref>. There is considerable literature on visibility preprocessing and on-line culling of polygonal data-sets. Our goal is to extend these techniques to curved and spline models.
Reference: [SAE93] <author> L.A. Shirman and S.S. Abi-Ezzi. </author> <title> The cone of normals technique for fast processing of curved patches. </title> <booktitle> In EUROGRAPHICS, </booktitle> <pages> pages 261-272, </pages> <year> 1993. </year>
Reference-contexts: Most of the high-end graphics system have an implementation of this technique as a part of the graphics pipeline. In this paper, we extend back-face culling for polygons to back-patch culling for splines. The idea of back-patch culling was introduced in <ref> [KML95, SAE93] </ref>. Our algorithm is more general, more efficient and simpler to implement. It involves efficient computation and representation of bounds on nor-mals of a patch. We present algorithms for exact back-patch culling for perspective projection.
Reference: [SC88] <author> M. Shantz and S. Chang. </author> <title> Rendering trimmed NURBS with adaptive forward differencing. </title> <journal> ACM Computer Graphics, </journal> <volume> 22(4) </volume> <pages> 189-198, </pages> <year> 1988. </year> <note> (SIGGRAPH Proceedings). </note>
Reference-contexts: Many techniques based on ray-tracing, scan-line conversion, pixel-level subdivision and polygoniza-tion have been proposed for rendering parametric spline models [Cat74, NSK90, LCWB80]. However, polygonization based approaches are able to make efficient use of the hardware capabilities of the current graphics systems and are significantly faster than the rest <ref> [AES93, Dea89, LC93, SC88, FK90, RHD89, AES91, KML95] </ref>. The resulting algorithms use uniform or adaptive subdivision of spline surfaces to compute polygonal approximation. The approximation is a function of the current viewing direction and is typically, re-computed at each frame.
References-found: 18

