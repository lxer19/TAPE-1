URL: http://ceylon.lcs.mit.edu/6891/papers/4_cjmnrs.ps
Refering-URL: http://ceylon.lcs.mit.edu/6891/reading_list.html
Root-URL: 
Title: Profile-Driven Instruction Level Parallel Scheduling with Application to Super Blocks  
Author: C. Chekuri R. Johnson R. Motwani B. Natarajan B.R. Rau, M.Schlansker 
Address: Stanford, CA 94305  1501 Page Mill Rd Palo Alto, CA 94304  Stanford, CA 94305  1501 Page Mill Rd Palo Alto, CA 94304  
Affiliation: Dept. of Comp. Sci. Stanford Univ.  Hewlett Packard Labs  Dept. of Comp. Sci. Stanford Univ.  Hewlett Packard Labs  
Abstract: Code scheduling to exploit instruction level parallelism (ILP) is a critical problem in compiler optimization research, in light of the increased use of long-instruction-word machines. Unfortunately, optimum scheduling is com-putationally intractable, and one must resort to carefully crafted heuristics in practice. If the scope of application of a scheduling heuristic is limited to basic blocks, considerable performance loss may be incurred at block boundaries. To overcome this obstacle, basic blocks can be coalesced across branches to form larger regions such as super blocks. In the literature, these regions are typically scheduled using algorithms that are either oblivious to profile information (under the assumption that the process of forming the region has fully utilized the profile information), or use the profile information as an addendum to classical scheduling techniques. We believe that even for the simple case of linear code regions such as super blocks, additional performance improvement can be gained by utilizing the profile information in scheduling as well. We propose a general paradigm for converting any profile-insensitive list sched-uler to a profile-sensitive scheduler. Our technique is developed via a theoretical analysis of a simplified abstract model of the general problem of profile-driven scheduling over any acyclic code region, yielding a scoring measure for ranking branch instructions. The ranking digests the profile information and has the useful property that scheduling with respect to rank is provably good for minimizing the expected completion time of the region, within the limits of the abstraction. While the ranking scheme is computation-ally intractable in the most general case, it is practicable for super blocks and suggests the heuristic that we present in this paper for profile-driven scheduling of super blocks. Experiments show that our heuristic offers substantial performance improvement over prior methods on a range of integer benchmarks and several machine models. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Adolphson. </author> <title> Single machine job sequencing with precedence constraints. </title> <journal> SIAM J. on Computing, </journal> <volume> 6 </volume> <month> 40-54 </month> <year> (1977). </year>
Reference-contexts: The problem is polynomially solvable when the precedence graph is a forest [12] or a generalized series-parallel graph <ref> [1, 15] </ref>. <p> Efficient algorithms for the two cases where the precedence graph is a tree, and the precedence graph is an S-graph, can be obtained as special applications of the basic lemma. Previously, optimal sequential algorithms for weighted trees have been described in the literature <ref> [1, 8, 12] </ref>. Applying the basic lemma to general weighted graphs would cost time exponential in the number of vertices with non-zero weights, a cost that can be practical, if the number of such vertices, i.e., the number of branches is small.
Reference: [2] <author> A. Aho, R. Sethi, and J.D. Ullman. </author> <booktitle> Compilers Principles, Techniques and Tools. </booktitle> <publisher> Addison Wesley, </publisher> <address> Reading, MA (1988). </address>
Reference-contexts: As evidence, we present experimental results validating heuristics suggested by our analysis. A basic block is a program fragment that may only be entered at the top and exited at the bottom. The precedence graph of a single basic block will be a directed acyclic graph (DAG) <ref> [2] </ref>, and in practice, typically consists of fewer than 10 vertices. Scheduling small basic blocks consecutively and separately leads to underutilization of the functional units due to sequentialization effects at the block boundaries. To overcome this limitation two broad approaches have been proposed.
Reference: [3] <author> R. A. Bringmann, </author> <title> Enhancing instruction level parallelism through compiler controlled optimization. </title> <type> M.S Thesis, </type> <institution> University of Illinois, </institution> <year> 1992. </year>
Reference-contexts: For instance, super blocks are typically scheduled with heuristics that are oblivious to the profile information, although there are techniques that use profile information as an addendum to classical scheduling techniques, e.g., the speculative yield technique of <ref> [3] </ref>, following [7]. (Example 1 examines several of these techniques.) As region formation algorithms become more sophisticated and produce non-linear code regions encompassing balanced branches, they will be less effective in digesting the profile information. <p> Table 1 shows the schedule we would obtain in this case, along with the expected finish time of the schedule. Secondly, we schedule using speculative yield priorities, as in <ref> [3] </ref>. Here, the priority of a vertex is the weighted sum of its longest path length from each exit, where the weight is the probability of the exit being taken. The list of vertices sorted in descending order of priority is the list for scheduling. <p> First, we use the critical path scheduler as the profile-insensitive scheduling algorithm to drive our heuristic, and compare its performance against three algorithms: (1) critical path scheduling from the last exit; (2) speculative yield as in Example 1 and <ref> [3] </ref>; (3) successive retirement as in Example 1. Table 7 shows the improvements achieved by our heuristic over critical-path scheduling for the benchmarks studied over the various machine models. For each benchmark and machine model, we show the improvement in the total schedule length of the benchmark.
Reference: [4] <author> J.C. Dehnert and R.A. Towle, </author> <title> Compiling for the Cydra-5 J. </title> <booktitle> of Supercomputing, </booktitle> <volume> 7 </volume> <pages> 181-228, </pages> <year> (1993). </year>
Reference-contexts: To overcome this limitation two broad approaches have been proposed. One called if-conversion, eliminates the branches via hardware support for predicated execution, allowing instructions to be moved outside of their basic blocks, see <ref> [4] </ref> for instance. The other approach does not require hardware support, and involves the formation of larger code regions such as traces, [7], and super blocks, [14].
Reference: [5] <author> J. Du, J.Y.T. Leung, and G.H. Young. </author> <title> Scheduling chain structured operations to minimize makespan and mean flow time. </title> <journal> Information and Computation, </journal> <volume> 92 </volume> <month> 219-236 </month> <year> (1991). </year>
Reference-contexts: For m 1, the problem is NP-hard even without precedence constraints, unless the weights are all identical in which case it is polynomially solvable; on the other hand, the problem is strongly NP-hard even when all weights are identical and the precedence graph is a collection of chains <ref> [5] </ref>. In light of the intractable nature of the problem, we adopt the standard approach of designing approximation algorithms with a bounded performance ratio. The performance ratio of an approximation algorithm is defined as the worst-case ratio of the cost of the approximate solution and the optimal solution.
Reference: [6] <author> J. A. Fisher. </author> <title> Trace scheduling: A technique for global microcode compaction. </title> <journal> IEEE Trans. on Computers, </journal> <volume> Vol C-30:478-490. </volume>
Reference: [7] <author> J. A. Fisher. </author> <title> Global code generation for instruction level parallelism. </title> <type> Tech. Rep. </type> <institution> HPL-93-43, Hewlett Packard Labs, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: One called if-conversion, eliminates the branches via hardware support for predicated execution, allowing instructions to be moved outside of their basic blocks, see [4] for instance. The other approach does not require hardware support, and involves the formation of larger code regions such as traces, <ref> [7] </ref>, and super blocks, [14]. A super block consists of a sequence of basic blocks strung together, with conditional exits at the branch points that separate the basic blocks. Super blocks are typically formed as follows. <p> For instance, super blocks are typically scheduled with heuristics that are oblivious to the profile information, although there are techniques that use profile information as an addendum to classical scheduling techniques, e.g., the speculative yield technique of [3], following <ref> [7] </ref>. (Example 1 examines several of these techniques.) As region formation algorithms become more sophisticated and produce non-linear code regions encompassing balanced branches, they will be less effective in digesting the profile information.
Reference: [8] <author> M.R. Garey. </author> <title> Optimal task sequencing with precedence constraints. </title> <journal> Discrete Math., </journal> <volume> 4 </volume> <month> 37-56 </month> <year> (1973). </year>
Reference-contexts: Efficient algorithms for the two cases where the precedence graph is a tree, and the precedence graph is an S-graph, can be obtained as special applications of the basic lemma. Previously, optimal sequential algorithms for weighted trees have been described in the literature <ref> [1, 8, 12] </ref>. Applying the basic lemma to general weighted graphs would cost time exponential in the number of vertices with non-zero weights, a cost that can be practical, if the number of such vertices, i.e., the number of branches is small.
Reference: [9] <author> M.R. Garey and D.S. Johnson. </author> <title> Computers and Intractability. W.H. </title> <publisher> Freeman, </publisher> <address> San Francisco (1979). </address>
Reference-contexts: The general problem in which every node has a weight has been shown to be NP-hard even for m = 1 provided we permit arbitrary precedence constraints on the operations <ref> [9, 15] </ref>. The problem is polynomially solvable when the precedence graph is a forest [12] or a generalized series-parallel graph [1, 15].
Reference: [10] <author> R. Graham. </author> <title> Bounds on multiprocessor timing anomalies. </title> <journal> SIAM J. on App. Math., </journal> <volume> 17 </volume> <month> 416-429 </month> <year> (1969). </year>
Reference: [11] <author> L.A. Hall, A.S. Schulz, D.B. Shmoys and J. Wein. </author> <title> Scheduling to minimize average completion time: offline and on-line algorithms. </title> <booktitle> In Proc. of the 7th ACM-SIAM Symp. on Discrete Algorithms, </booktitle> <year> 1996, </year> <pages> 142-151. </pages>
Reference-contexts: From a theoretical point of view, the best known approximation algorithm <ref> [11] </ref> for sequential scheduling of weighted DAGS has a performance guarantee of 2; however, this algorithm is based on rounding solutions of linear programs and is impractical for the compiler setting. The following terms are defined with respect to a specific schedule S.
Reference: [12] <author> W.A. Horn. </author> <title> Single-machine job sequencing with treelike precedence ordering and linear delay penalties. </title> <journal> SIAM J. of App. Math., </journal> <volume> 23 </volume> <month> 189-202 </month> <year> (1972). </year>
Reference-contexts: The general problem in which every node has a weight has been shown to be NP-hard even for m = 1 provided we permit arbitrary precedence constraints on the operations [9, 15]. The problem is polynomially solvable when the precedence graph is a forest <ref> [12] </ref> or a generalized series-parallel graph [1, 15]. <p> Efficient algorithms for the two cases where the precedence graph is a tree, and the precedence graph is an S-graph, can be obtained as special applications of the basic lemma. Previously, optimal sequential algorithms for weighted trees have been described in the literature <ref> [1, 8, 12] </ref>. Applying the basic lemma to general weighted graphs would cost time exponential in the number of vertices with non-zero weights, a cost that can be practical, if the number of such vertices, i.e., the number of branches is small.
Reference: [13] <author> T.C. Hu. </author> <title> Parallel sequencing and assembly line problems. </title> <journal> Operations Research, </journal> <volume> 9 </volume> <month> 841-848 </month> <year> (1961). </year>
Reference: [14] <author> W.W. Hwu et al. </author> <title> The super block: An effective technique for VLIW and superscalar compilation. </title> <journal> J. of Supercomputing, </journal> <volume> 7 </volume> <month> 229-248 </month> <year> (1993). </year>
Reference-contexts: One called if-conversion, eliminates the branches via hardware support for predicated execution, allowing instructions to be moved outside of their basic blocks, see [4] for instance. The other approach does not require hardware support, and involves the formation of larger code regions such as traces, [7], and super blocks, <ref> [14] </ref>. A super block consists of a sequence of basic blocks strung together, with conditional exits at the branch points that separate the basic blocks. Super blocks are typically formed as follows. Given is a code region with branch probabilities available at each branch in the region.
Reference: [15] <author> E.L. Lawler. </author> <title> Sequencing jobs to minimize total weighted completion time. </title> <journal> Annals of Discrete Math., </journal> <volume> 2 </volume> <month> 75-90 </month> <year> (1978). </year>
Reference-contexts: The general problem in which every node has a weight has been shown to be NP-hard even for m = 1 provided we permit arbitrary precedence constraints on the operations <ref> [9, 15] </ref>. The problem is polynomially solvable when the precedence graph is a forest [12] or a generalized series-parallel graph [1, 15]. <p> The problem is polynomially solvable when the precedence graph is a forest [12] or a generalized series-parallel graph <ref> [1, 15] </ref>.
Reference: [16] <author> S. A. Mahlke. </author> <title> Exploiting Instruction Level Parallelism in the Presence of Conditional Branches. </title> <type> Ph.D Thesis, </type> <institution> U. of Illinois, Urbana, IL, </institution> <year> (1996). </year>
Reference-contexts: Experimental Results We now study the performance of the heuristic on a number of optimized super blocks generated by the Impact compiler from the SPEC benchmark programs. We restrict our attention to integer benchmarks, since broadly speaking the floating-point benchmarks yield super blocks with near-zero side-exit probabilities, <ref> [16] </ref>. We used the Impact compiler to compile these benchmarks, decomposing each program into super blocks and basic blocks only. We report our results on scheduling these blocks over two different classes of machine models, processors with uniform functional units, and processors with heterogenous functional units.
Reference: [17] <author> S.A. Mahlke et al. </author> <title> Effective compiler support for predicated execution using the hyperblock. </title> <booktitle> In Proc. 25th Int. Symp. Microarchitecture (MICRO 25), </booktitle> <month> 45-54 </month> <year> (1992) </year>
Reference: [18] <author> R. Ravi, A. Agrawal, and P. Klein. </author> <title> Ordering problems approximated: single-processor scheduling and interval graph completion. </title> <booktitle> In Proc. of ICALP (Springer-Verlag), </booktitle> <month> 751-762 </month> <year> (1991). </year>
References-found: 18

