URL: http://www.cs.cmu.edu/~jurgend/coordination97.ps.gz
Refering-URL: http://www.cs.cmu.edu/~jurgend/cv.html
Root-URL: 
Email: E-mail: jurgend@cs.cmu.edu  
Title: Approximating UNITY  
Author: Jurgen Dingel 
Address: Pittsburgh, PA 15213, USA  
Affiliation: School of Computer Science Carnegie Mellon University  
Abstract: A framework for the stepwise refinement of UNITY programs with local variables is proposed. It is centered around two preorders. The first one compares program components with respect to a given context. Aside from being context-sensitive, this order also allows the introduction of local variables. The second preorder compares program contexts with respect to their discriminating power. Using these two relations, program refinement arises as a form of assumption/commitment reasoning. An example illustrates the use of the framework and presents some proof rules. The simple syntactic and semantic structure of UNITY allows for a natural game-theoretic characterization of the preorders used in the frame work.
Abstract-found: 1
Intro-found: 1
Reference: [AJM94] <author> S. Abramsky, R. Jaghadeesan, and P. Malacaria. </author> <title> Full abstraction for PCF (extended abstract). </title> <booktitle> In TACS '94, </booktitle> <volume> volume LNCS 789, </volume> <pages> pages 1-15. </pages> <publisher> Springer Verlag, </publisher> <year> 1994. </year>
Reference: [AS82] <author> G. R. Andrews and F.B. Schneider. </author> <title> Concepts and notations for concurrent programming. </title> <type> Technical Report 82-520, </type> <institution> Cornell University, Department of Computer Science, </institution> <year> 1982. </year>
Reference: [Bro93] <author> S.D. Brookes. </author> <title> Full abstraction for a shared-variable parallel language. </title> <booktitle> In Proceedings 8th Annual IEEE Symposium on Logic in Computer Science. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> June </month> <year> 1993. </year>
Reference-contexts: X 1 stands for X fl [ X ! . Given ff; fi 2 ( fi fl fi ) 1 , let ffkfi be the set of all traces built by fairly interleaving ff and fi. Following <ref> [Bro93] </ref>, one way to define ffkfi formally is: ffkfi = ffl j (ff; fi; fl) 2 f airmergeg where f airmerge = (L fl RR fl L) ! [ (L [ R) fl A L = f (s; *; s) j s 2 fi fl fi g A = f (ff;
Reference: [CK95] <author> P. Collette and E. Knapp. </author> <title> Logical foundations for compositional verification and development of concurrent programs in UNITY. </title> <booktitle> In AMAST '95, </booktitle> <volume> LNCS 936, </volume> <pages> pages 353-367. </pages> <publisher> Springer Verlag, </publisher> <year> 1995. </year>
Reference-contexts: It would be interesting to investigate this connection further. In particular, this might be helpful for identifying additional useful rules for our proof system. Whereas our work concentrates on traces, <ref> [CK95] </ref> demonstrates how the UNITY logic can be extended using the assumption/commitment paradigm to achieve compositionality. This work also seems particularly relevant in this context. There is some hope that games might fruitfully be applied to the verification of concurrent systems.
Reference: [CM88] <author> K.M. Chandy and J. Misra. </author> <title> Parallel program design: a foundation. </title> <publisher> Addison Wesley, </publisher> <year> 1988. </year>
Reference-contexts: 1 Introduction Since its invention UNITY <ref> [CM88] </ref> has been a popular design notation for concurrent programs. It features a simple syntax and semantics and yet exhibits all the intricacies of concurrent programming. The programming notation is complemented nicely by an equally simple specification logic and proof system. <p> E [[U ]] = fff 2 C [[U ]] j ff is connectedg E [[H]] = fff 2 C [[H]] j ff is connectedg fl Note that this notion coincides with Chandy and Misra's notion of execution <ref> [CM88] </ref>. Having presented the semantics, we can now give a more precise account of the impact of labels h: : :i on the inequational theory of programs and statements. Trace inclusion between two labeled programs implies trace inclusion between their unlabeled versions.
Reference: [dBKPR91] <author> F.S. de Boer, J.N. Kok, C. Palamidessi, and J.J.M.M. Rutten. </author> <title> The failure of failures in a paradigm of asynchronous communication. </title> <booktitle> In CONCUR '91, </booktitle> <pages> pages 111-126. </pages> <publisher> Springer Verlag, </publisher> <year> 1991. </year>
Reference: [Din96] <author> J. Dingel. </author> <title> Modular verification of shared-variable concurrent programs. </title> <booktitle> In CONCUR '96, </booktitle> <pages> pages 703-718. </pages> <publisher> Springer Verlag, </publisher> <year> 1996. </year>
Reference-contexts: A small example is presented together with the necessary proof rules. Section 5 defines a suitable notion of game and shows how context-sensitive approximation can be given a natural game-theoretic characterization. Section 6 concludes and outlines further work. In <ref> [Din96] </ref>, a trace model is used for the compositional verification of the shared-variable parallel language introduced by Owicki and Gries. Most of the definitions in Sections 2 and 3 are rather straightforward adaptations of those in [Din96]. <p> Section 6 concludes and outlines further work. In <ref> [Din96] </ref>, a trace model is used for the compositional verification of the shared-variable parallel language introduced by Owicki and Gries. Most of the definitions in Sections 2 and 3 are rather straightforward adaptations of those in [Din96].
Reference: [Lar87] <author> K. G. Larsen. </author> <title> A context dependent equivalence between processes. </title> <journal> Theoretical Computer Science, </journal> <volume> 49(2) </volume> <pages> 185-216, </pages> <year> 1987. </year>
Reference-contexts: For CCS, for example, this was done in <ref> [Lar87] </ref>. The program F 1 (;; tt; Var : [tt; tt]), for instance, can do any transition at any time. The program F 2 (;; tt; inv x), however, can only do those transitions that leave the value of x unchanged. <p> Proposition 14. 1: (L; I; S) v (L 0 ; I; S) iff L 0 L 3: (L; I; S) v (L; I; S 0 ) if S C S 0 In <ref> [Lar87] </ref>, Larsen introduces a discrimination ordering on CCS contexts and presents a characterization result. Unfortunately, the fairness requirement prevented us from obtaining a similar result for our setting.
Reference: [Liu89] <author> Z. Liu. </author> <title> A semantic model for UNITY. </title> <type> Technical report, </type> <institution> Computer Science Department, University of Warwick, </institution> <year> 1989. </year>
Reference: [McC96] <author> G. McCusker. </author> <title> Games and full abstraction for FPC. </title> <booktitle> In Proceedings 11th Annual IEEE Symposium on Logic in Computer Science. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> June </month> <year> 1996. </year>
Reference: [Mor89] <author> C. Morgan. </author> <title> The specification statement. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 10(3), </volume> <month> January </month> <year> 1989. </year>
Reference-contexts: To be able to describe state changes in more general terms we extend UNITY slightly and adopt Morgan's specification statement <ref> [Mor89] </ref>. It is of the form V : [P; Q], where V is a set of variables and P and Q are assertions. It is meant to describe a single atomic transition, which transforms a state satisfying P into one satisfying Q by just changing the variables in V .
Reference: [QJ91] <author> X. Qiwen and H. Jifeng. </author> <title> A theory of state-based parallel programming: Part I. </title> <editor> In J. Morris, editor, </editor> <booktitle> 4th BCS-FACS Refinement Workshop, </booktitle> <year> 1991. </year>
Reference: [San90] <author> B.A. Sanders. </author> <title> Stepwise refinement of mixed specifications of concurrent programs. </title> <editor> In M. Broy and C.B. Jones, editors, </editor> <booktitle> Proceedings of IFIP Working Conference on Programming and Methods, </booktitle> <pages> pages 1-25. </pages> <publisher> Elsevier Science Publishers (North Holland), </publisher> <month> May </month> <year> 1990. </year>
Reference: [San91] <author> B.A. Sanders. </author> <title> Eliminating the substitution axiom from UNITY logic. </title> <journal> Formal Aspects of Computing, </journal> <volume> 3(2), </volume> <year> 1991. </year>
Reference: [Sin91] <author> A.K. Singh. </author> <title> Parallel programming: Achieving portability through abstraction. </title> <booktitle> In 11th International Conference on Distributed Computing Systems, </booktitle> <month> May </month> <year> 1991. </year>
Reference: [Ste96] <author> P. Stevens, </author> <month> December </month> <year> 1996. </year> <title> Private communication. </title>
Reference-contexts: As an example, we mention the work in progress on the Edinburgh Concurrency Workbench. Games as presented in [Sti96] are incorporated into the system to illustrate branching time temporal logic and model checking <ref> [Ste96] </ref>. There is some hope that our work might be applicable for similar purposes. Acknowledgments We thank Steve Brookes for his support and the anonymous referees for their comments.
Reference: [Sti96] <author> C. Stirling. </author> <title> Games and modal mu-calculus. In Tools and Algorithms for the Construction and Analysis of Systems. </title> <publisher> Springer Verlag, </publisher> <year> 1996. </year> <note> LNCS 1055. </note>
Reference-contexts: Recently, there has been a lot of interest in the application of game-theoretic ideas to the semantics of programming languages, e.g., [AJM94,McC96]. Most of this work is phrased in very abstract (category-theoretic) terms and it is not always clear how the concepts introduced relate to "everyday computing". In <ref> [Sti96] </ref>, Stirling bridges this gap by demonstrating how the verification of labeled transition systems with respect to mu-calculus formulae can be recast using game theory. <p> Games Our notion of games is inspired by <ref> [Sti96] </ref>. Let S and T be unlabeled statements and F be an unlabeled program. A game is a triple G (S; T; F ) for which there are two players. <p> As an example, we mention the work in progress on the Edinburgh Concurrency Workbench. Games as presented in <ref> [Sti96] </ref> are incorporated into the system to illustrate branching time temporal logic and model checking [Ste96]. There is some hope that our work might be applicable for similar purposes. Acknowledgments We thank Steve Brookes for his support and the anonymous referees for their comments.
Reference: [UK93a] <author> R.T. Udink and J.N. Kok. </author> <title> On the relation between UNITY properties and sequences of states. In Semantics: </title> <booktitle> Foundations and Applications, </booktitle> <pages> pages 594-608. </pages> <publisher> Springer Verlag, </publisher> <year> 1993. </year>
Reference-contexts: G refines F , if the traces of G are contained in those of F . Trace-based semantics for UNITY have appeared in the literature in several places [CM88,Liu89,dBKPR91,UK93a,UK93b]. Trace-based notions of refinement are proposed in [UK93a,UK93b]. In <ref> [UK93a] </ref>, it is shown that trace-based notions are strictly finer grained (less abstract) than property-based notions. However, again, none of the proposed notions are context-sensitive or support local variables. <p> In other words, hS 1 i []S 2 can be thought of as an open system whose environment is known to at least comprise S 2 . A trace is connected if we have s 0 i = s i+1 for all i 0. Following [UK93b], <ref> [UK93a] </ref>, we use the operator " to remove subsequences of finite, connected stuttering from a trace. <p> Undoing the changes to the local variables of H along ff yields a trace of H, if ff is a trace of the statement of H assuming that the local variables are properly initialized and the environment is prevented from changing them. Note that <ref> [UK93a] </ref> contains an operational, yet compositional, definition of a variant of C without account for local variables. Furthermore, no explicit definition of the fair merge operation is given. Definition 4. The executions of a program or statement are the connected tran-sition traces.
Reference: [UK93b] <author> R.T. Udink and J.N. Kok. </author> <title> Two fully abstract models for UNITY. </title> <booktitle> In CONCUR '93, </booktitle> <pages> pages 339-352. </pages> <publisher> Springer Verlag, </publisher> <year> 1993. </year>
Reference-contexts: In other words, hS 1 i []S 2 can be thought of as an open system whose environment is known to at least comprise S 2 . A trace is connected if we have s 0 i = s i+1 for all i 0. Following <ref> [UK93b] </ref>, [UK93a], we use the operator " to remove subsequences of finite, connected stuttering from a trace.
References-found: 19

