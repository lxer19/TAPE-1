URL: http://www.isg.sfu.ca/ftp/pub/hak/prl/Wild_Life.ps.Z
Refering-URL: http://www.isg.sfu.ca/life/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Author: Hassan At-Kaci Bruno Dumant Richard Meyer Andreas Podelski Peter Van Roy 
Note: The Wild LIFE Handbook (prepublication edition)  
Date: March 1994  
Affiliation: PARIS RESEARCH LABORATORY  
Abstract-found: 0
Intro-found: 1
Reference: 1. <author> Hassan At-Kaci, Robert Boyer, Patrick Lincoln, and Roger Nasr. </author> <title> Efficient implementation of lattice operations. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(1) </volume> <month> 115-146 (January </month> <year> 1989). </year>
Reference-contexts: It is invertible between the domain ]0; 1 [ and the range ]1; 1 [. * The function sin (A) returns the sine of the angle A, where A is expressed in radians. It is invertible between the domain [=2; =2] and the range <ref> [1; 1] </ref>. * The function cos (A) returns the cosine of the angle A, where A is expressed in radians. It is invertible between the domain [0; ] and the range [1; 1]. * The function tan (A) returns the tangent of the angle A, where A is expressed in radians. <p> It is invertible between the domain [=2; =2] and the range <ref> [1; 1] </ref>. * The function cos (A) returns the cosine of the angle A, where A is expressed in radians. It is invertible between the domain [0; ] and the range [1; 1]. * The function tan (A) returns the tangent of the angle A, where A is expressed in radians. <p> it may, we leave it to your taste to choose what fits you best. 13.5 Sort encoding Wild LIFE uses a special binary encoding of the declared sorts so that a glb can be quickly and efficiently calculated even if the hierarchy contains a very large number of sort definitions <ref> [1] </ref>. Each declared sort is assigned one bit vector with a value that reflects its place in the hierarchy. <p> The DCG accumulator has been optimized to allow the folding of terminals (i.e., terms to be accumulated in the DCG accumulator). A translation of: foo --&gt; bar, <ref> [1] </ref>? could be: foo (in_dcg =&gt; A,out_dcg =&gt; B) :- C = [1|B]. <p> When code is inserted for instance a cut we have to make sure that this folding does not bind variables occurring before the insertion. Consider the following clause: foo --&gt; !, <ref> [1] </ref>? This first translation of it (with folding): foo (in_dcg =&gt; [1|A],out_dcg =&gt; A) :- does not have the same behavior as this one (without folding): foo (in_dcg =&gt; A,out_dcg =&gt; B) :- A = [1|B]. The first translation is not correct w.r.t. the usual meaning of cut.
Reference: 2. <author> Hassan At-Kaci and Jacques Garrigue. </author> <title> Label-selective -calculus. </title> <type> PRL Research Report 31, </type> <institution> Digital Equipment Corporation, Paris Research Laboratory, </institution> <address> Rueil-Malmaison, France (1993). </address>
Reference-contexts: The following execution fragment shows how to couple the function map with residuation. 13 A calculus handling currying with named arguments and consumption by position is presented in <ref> [2] </ref>. March 1994 Digital PRL Wild LIFE Handbook 25 &gt; fact (0) -&gt; 1. &gt; fact (N) -&gt; N*fact (N-1). &gt; R=map (F,[4,5,6,7])? F = @, R = [@,@,@,@]. --1&gt; F=fact? *** Yes F = fact, R = [24,120,720,5040].
Reference: 3. <author> Hassan At-Kaci and Patrick Lincoln. </author> <title> LIFEA natural language for natural language. </title> <type> T.A. Informations, </type> <institution> 30(1-2):37-67 (1989). Association pour le Traitement Automatique des Langues, Paris, France. </institution>
Reference-contexts: 1 Introduction LIFE is a programming language originally conceived by Hassan At-Kaci and his colleagues at MCC, in Austin, Texas <ref> [4, 5, 3] </ref>. It is a synthesis of three different programming paradigms: logic programming, functional programming and object-oriented programming. 2 LIFE is a declarative logic-based language that can be seen as a constraint language. It derives its syntax and resolution method from Prolog. <p> The other accumulators will be expanded according to the declarations. Accumulation in the DCG may be specified either with the above notation (X + dcg), or using the standard list notation of DCGs: foo --&gt; <ref> [3] </ref>, bar? is translated into: foo (in_dcg =&gt; [3|A],out_dcg =&gt; B) :- F.3.3 Implementation notes * Folding Terminals. The DCG accumulator has been optimized to allow the folding of terminals (i.e., terms to be accumulated in the DCG accumulator).
Reference: 4. <author> Hassan At-Kaci and Roger Nasr. </author> <title> LOGIN: A logic programming language with built-in inheritance. </title> <journal> Journal of Logic Programming, </journal> <volume> 3 </volume> <month> 185-215 </month> <year> (1986). </year>
Reference-contexts: 1 Introduction LIFE is a programming language originally conceived by Hassan At-Kaci and his colleagues at MCC, in Austin, Texas <ref> [4, 5, 3] </ref>. It is a synthesis of three different programming paradigms: logic programming, functional programming and object-oriented programming. 2 LIFE is a declarative logic-based language that can be seen as a constraint language. It derives its syntax and resolution method from Prolog. <p> a -term with two attributes that are aliased together, as indicated by the tag S; * X:person (home =&gt; address (occupants =&gt; [X])), a -term with a cyclic reference, as indicated by the tag X. 4 If you substitute Prolog terms by LIFE's -terms the resulting language is called Login <ref> [4] </ref>. Research Report Draft March 1994 8 Hassan At-Kaci et al. A -term describes a set of objects, which themselves may be represented as records. Hence, the -term may be construed as a record type.
Reference: 5. <author> Hassan At-Kaci and Roger Nasr. </author> <title> Integrating logic and functional programming. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 2 </volume> <month> 51-89 </month> <year> (1989). </year>
Reference-contexts: 1 Introduction LIFE is a programming language originally conceived by Hassan At-Kaci and his colleagues at MCC, in Austin, Texas <ref> [4, 5, 3] </ref>. It is a synthesis of three different programming paradigms: logic programming, functional programming and object-oriented programming. 2 LIFE is a declarative logic-based language that can be seen as a constraint language. It derives its syntax and resolution method from Prolog.
Reference: 6. <author> Hassan At-Kaci and Andreas Podelski. </author> <title> Functions as passive constraints in LIFE. </title> <type> PRL Research Report 13, </type> <institution> Digital Equipment Corporation, Paris Research Laboratory, </institution> <address> Rueil-Malmaison, France (1991). </address>
Reference-contexts: When the function fires, the actual result will be unified with the temporary result. Therefore the temporary result may be used in further function calls as if it were the actual result. This execution mechanism corresponds to a simple formal logical specification <ref> [6] </ref>. Step (3) corresponds to testing whether F implies Head. Step (4) corresponds to testing whether F implies the negation of Head. Operationally, the residuation is attached to each of the residuation variables. <p> See Section 7.1.2 (page 30). * Constraint A constraint is a relation between variables. For example, A=B+4 is a numeric constraint between A and B, and A=person (age=&gt;B) is a structural constraint between A and B. The semantics of LIFE can be explained simply in terms of primitive constraints <ref> [6] </ref>. * Declaration See definition. * Declared sort A sort that has been defined in a :: or &lt;| declaration. This declaration corresponds to a class definition in an object-oriented language.
Reference: 7. <author> Hassan At-Kaci and Andreas Podelski. </author> <title> Towards a meaning of LIFE. </title> <type> PRL Research Report 11, </type> <institution> Digital Equipment Corporation, Paris Research Laboratory, </institution> <address> Rueil-Malmaison, France (1991). </address>
Reference-contexts: However, the addition of functions, approximation structures ( -terms) and inheritance greatly enriches the language and allows one to formulate efficient programs more easily, more concisely, andin our opinionmore naturally <ref> [7, 8] </ref>. Wild LIFE 1.02 is an interpreter for LIFE written in C. The main design goals for Wild LIFE are functionality and robustness. The interpreter implements most of the LIFE language and is robust enough to support serious program development.
Reference: 8. <author> Hassan At-Kaci and Andreas Podelski. </author> <title> Towards a meaning of LIFE. </title> <editor> In Jan Maluszy nski and Martin Wirsing, editors, </editor> <booktitle> Proceedings of the 3rd International Symposium on Programming Language Implementation and Logic Programming (Passau, Germany), </booktitle> <pages> pages 255-274. </pages> <note> Springer-Verlag, LNCS 528 (August 1991). </note>
Reference-contexts: However, the addition of functions, approximation structures ( -terms) and inheritance greatly enriches the language and allows one to formulate efficient programs more easily, more concisely, andin our opinionmore naturally <ref> [7, 8] </ref>. Wild LIFE 1.02 is an interpreter for LIFE written in C. The main design goals for Wild LIFE are functionality and robustness. The interpreter implements most of the LIFE language and is robust enough to support serious program development.
Reference: 9. <author> Hassan At-Kaci and Andreas Podelski. </author> <title> Order-sorted feature theory unification. </title> <type> PRL Research Report 32, </type> <institution> Digital Equipment Corporation, Paris Research Laboratory, </institution> <address> Rueil-Malmaison, France (May 1993). </address>
Reference-contexts: Unfortunately, the delay check mechanism is not sufficient to guarantee completeness and convergence in all cases. The LIFE compiler will have a consistent handling of recursive sorts that does not need delay check. A complete and consistent algorithm to do lazy attribute inheritance has been developed <ref> [9] </ref>. This algorithm takes an attribute constrained in a sort definition into consideration only if it appears in the resolvent. March 1994 Digital PRL Wild LIFE Handbook 33 7.3 Constrained sorts as daemons A constraint that is attached to a sort declaration is checked at run-time during unification.
Reference: 10. <author> William F. Clocksin and Christopher S. Mellish. </author> <title> Programming in Prolog. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, Germany, 2nd edition (1984). </address>
Reference-contexts: If none is found, then Wild LIFE prints the message No customizing file loaded as is done above. 3.2 Input syntax Wild LIFE uses essentially the same syntax as ISO Standard Prolog, which is very close to the Edinburgh syntax <ref> [10, 15, 19] </ref>. Unless specifically indicated to be different, the same syntactic conventions apply. In particular, variables are capitalized (or start with an underscore ) whereas everything else is not, = is the unification predicate, :- defines a clause, ! is the cut predicate, etc. <p> This is not a tutorial on Prolog, sofor information going further than the explanations given belowplease consult your local library <ref> [10, 15, 19] </ref>. Except for differences in built-ins, Prolog programs can run unaltered in LIFE if they follow the syntactic convention that each predicate and functor symbol is used with one arity only.
Reference: 11. <author> Tim Lindholm and Richard A. O'Keefe. </author> <title> Efficient implementation of a defensible semantics for dynamic Prolog code. </title> <booktitle> In Proceedings of the Fourth International Conference on Logic Programming, </booktitle> <pages> pages 21-39. </pages> <publisher> MIT Press (May 1987). </publisher>
Reference-contexts: Section 9 provides better solutions for both of these cases. It is strongly discouraged to modify a routine during that routine's execution. The current release of Wild LIFE provides for immediate update semantics in certain cases (as given below). It does not implement the defensible semantics of <ref> [11] </ref>. 11.1 Adding rules The built-in predicates assert (C) and asserta (C) add the clause C to the program. The argument C may be of two forms, (Head :- Body) or simply Head, the latter being equivalent to (Head :- succeed). The Head must be a dynamic predicate.
Reference: 12. <author> Richard Meyer. </author> <title> Compiling LIFE. </title> <type> Technical Report 8, </type> <institution> Digital Equipment Corporation, </institution> <note> Paris Research Laboratory (September 1993). March 1994 Digital PRL Wild LIFE Handbook 147 </note>
Reference-contexts: The emphasis in the compiler is twofold: efficiency and scalability. We are building a streamlined and powerful system that will make LIFE into a language that is every bit as fast and usable as the best existing implementations of Prolog <ref> [12] </ref>. To help us in this endeavor, please send us your comments and your Wild LIFE programs, so we can use them as fuel for the compiler design. Research Report Draft March 1994 102 Hassan At-Kaci et al.
Reference: 13. <author> Lee Naish. </author> <title> Negation and Control in Prolog. </title> <publisher> Springer-Verlag, LNCS 238 (1986). </publisher>
Reference-contexts: Moreover, such non-declarative heresies as the is/2 predicate in Prolog and the freeze meta-predicate in Prolog II are not needed. Arithmetic functions in Wild LIFE residuate when necessary. Functional residuation provides most of the abilities of MU-Prolog's wait declarations <ref> [13] </ref> and NU-Prolog's when declarations [14]. 6.1 Defining functions A function definition consists of one or more function rules. These are stored in the assertion base in the same order as they will be tried during execution.
Reference: 14. <author> Lee Naish. </author> <title> Negation and quantifiers in NU-Prolog. </title> <booktitle> In Proceedings of the 3rd International Symposium on Logic Programming, </booktitle> <pages> pages 624-634. </pages> <note> Springer-Verlag, LNCS 225 (July 1986). </note>
Reference-contexts: Moreover, such non-declarative heresies as the is/2 predicate in Prolog and the freeze meta-predicate in Prolog II are not needed. Arithmetic functions in Wild LIFE residuate when necessary. Functional residuation provides most of the abilities of MU-Prolog's wait declarations [13] and NU-Prolog's when declarations <ref> [14] </ref>. 6.1 Defining functions A function definition consists of one or more function rules. These are stored in the assertion base in the same order as they will be tried during execution.
Reference: 15. <author> Richard O'Keefe. </author> <title> The Craft of Prolog. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA (1990). </address>
Reference-contexts: If none is found, then Wild LIFE prints the message No customizing file loaded as is done above. 3.2 Input syntax Wild LIFE uses essentially the same syntax as ISO Standard Prolog, which is very close to the Edinburgh syntax <ref> [10, 15, 19] </ref>. Unless specifically indicated to be different, the same syntactic conventions apply. In particular, variables are capitalized (or start with an underscore ) whereas everything else is not, = is the unification predicate, :- defines a clause, ! is the cut predicate, etc. <p> This is not a tutorial on Prolog, sofor information going further than the explanations given belowplease consult your local library <ref> [10, 15, 19] </ref>. Except for differences in built-ins, Prolog programs can run unaltered in LIFE if they follow the syntactic convention that each predicate and functor symbol is used with one arity only. <p> No bindings to variables visible outside of the predicate should be done before the cut. This condition ensures that the cut does not change the predicate's semantics, i.e., it is a green cut <ref> [15] </ref>. The print list example given above contains a correct use of cut. The cut predicate is useful because it allows one to reduce the number of alternatives, especially if you know for certain that all alternatives would fail.
Reference: 16. <author> Peter Van Roy. </author> <title> A useful extension to Prolog's Definite Clause Grammar notation. </title> <journal> ACM SIGPLAN Notices, </journal> <month> pages 132-134 (November </month> <year> 1989). </year>
Reference-contexts: This is a standard technique, described in Prolog textbooks, for example in Sterling and Shapiro's Art of Prolog [19]. The Wild LIFE preprocessor replaces Prolog terms by -terms. The generalized technique, called EDCG (Extended Definite Clause Grammar), was developed and implemented for the Aquarius compiler <ref> [16, 17] </ref>. It has proven extremely useful in the development of large Prolog programs. It has been used by the authors and others to develop various compilers, simulators, analyzers and test generators.
Reference: 17. <author> Peter Van Roy. </author> <title> Can Logic Programming Execute as Fast as Imperative Programming? PhD thesis, </title> <institution> Department of Computer Science, University of California at Berkeley (De-cember 1990). </institution>
Reference-contexts: This is a standard technique, described in Prolog textbooks, for example in Sterling and Shapiro's Art of Prolog [19]. The Wild LIFE preprocessor replaces Prolog terms by -terms. The generalized technique, called EDCG (Extended Definite Clause Grammar), was developed and implemented for the Aquarius compiler <ref> [16, 17] </ref>. It has proven extremely useful in the development of large Prolog programs. It has been used by the authors and others to develop various compilers, simulators, analyzers and test generators.
Reference: 18. <author> Ehud Shapiro. </author> <title> The family of concurrent logic programming languages. </title> <journal> ACM Computing Surveys, </journal> <volume> 21(3) </volume> <month> 412-510 </month> <year> (1989). </year>
Reference-contexts: The program is transliterated from an FCP (Flat Concurrent Prolog) example in Shapiro's survey article on concurrent logic programming <ref> [18] </ref>. LIFE's function suspension mechanism (i.e., residuation) is used to communicate between functions. In the terminology of concurrency: a recursive function acts like a process. Communication between processes is done through unification of shared variables. Synchronization is done through residuation.

References-found: 18

