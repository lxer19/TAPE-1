URL: http://www.cs.duke.edu/~large/Papers/join.ps
Refering-URL: http://www.cs.duke.edu/CGC/papers.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: Email: large@cs.duke.edu.  Email: tavi@cs.duke.edu.  Email: sridhar@research.bell-labs.com.  Email: suel@research.bell-labs.com.  Email: jsv@cs.duke.edu.  
Title: Scalable Sweeping-Based Spatial Join  
Author: Lars Arge Octavian Procopiuc Sridhar Ramaswamy Torsten Suel Jeffrey Scott Vitter 
Note: 277080129. Supported in part by U.S. Army Research Office grant DAAH049610013.  277080129. Supported in part by the U.S. Army Research Office under grant DAAH049610013 and by the National Science Foundation under grant CCR9522047.  277080129. Supported in part by the U.S. Army Research Office under grant DAAH049610013 and by the National Science Foundation under grant CCR9522047. Part of this work was done while visiting Bell  
Address: Durham, NC  Durham, NC  600 Mountain Avenue, Box 636, Murray Hill, NJ 079740636.  600 Mountain Avenue, Box 636, Murray Hill, NJ 079740636.  Durham, NC  Murray Hill, NJ.  
Affiliation: Center for Geometric Computing, Department of Computer Science, Duke University,  Center for Geometric Computing, Department of Computer Science, Duke University,  Information Sciences Research Center, Bell Laboratories,  Information Sciences Research Center, Bell Laboratories,  Center for Geometric Computing, Department of Computer Science, Duke University,  Laboratories,  
Abstract: In this paper, we examine the spatial join problem. In particular, we focus on the case when neither of the inputs is indexed. We present a new algorithm, Scalable Sweep-based Spatial Join (SSSJ), that is based on the distribution-sweeping technique recently proposed in computational geometry, and that is the first to achieve theoretically optimal bounds on internal computation time as well as I/O transfers. We present experimental results based on an efficient implementation of the SSSJ algorithm, and compare it to an improved implementation of the state-of-the-art Partition-Based Spatial-Merge (PBSM) algorithm of Patel and DeWitt. Our SSSJ algorithm performs an initial sorting step along the vertical axis, after which we use the distribution-sweeping technique to partition the input into a number of vertical strips, such that the data in each strip can be efficiently processed by an internal-memory sweepline algorithm. In our experiments, we observed that on real-life two-dimensional spatial data sets of size N , the internal-memory sweepline algorithm requires only O( N ) memory space. This observation (also known as the square-root rule in the VLSI literature) implies that for real-life two-dimensional data sets, we can bypass the vertical partitioning step and directly perform the sweepline algorithm after the initial sorting step. In fact, we estimate that one would need on the order of several hundred billion rectangles in such data sets to overflow the large main memory of a modern workstation. On the other hand, in higher dimensions d, which arise with volume data or when incorporating time as a dimension, an internal-memory sweepline algorithm requires O(N (d1)=d ) memory space and can become I/O-bound for reasonable input sizes N . Unless the data is smoothly distributed, PBSM will degrade in performance while SSSJ scales gracefully. We illustrate the same effect in artificially constructed two-dimensional data. In our implementation of PBSM, the internal computation time was sped up significantly over that of Patel and DeWitt by using a theoretically near-optimal plane sweep algorithm based on interval trees, as opposed to the suboptimal algorithm used by Patel and DeWitt. p
Abstract-found: 1
Intro-found: 1
Reference: [ADADC + 97] <author> Andrea C. Arpaci-Dusseau, Remzi H. Arpaci-Dusseau, David E. Culler, Joseph M. Hellerstein, and David A. Patterson. </author> <title> High-performance sorting on networks of workstations. </title> <booktitle> In Proc. SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 243254, </pages> <month> May </month> <year> 1997. </year>
Reference-contexts: Second, it allows for a simple and fast implementation, by leveraging the performance of the highly tuned sorting routines offered by many database systems. There has been considerable work on optimized database sorts in recent years (see, e.g,, <ref> [Aga96, ADADC + 97, NBC + 94] </ref>), and it appears wise to try to draw on these results.
Reference: [Aga96] <author> Ramesh C. Agarwal. </author> <title> A super scalar sort algorithm for RISC processors. </title> <booktitle> In Proc. SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 240246, </pages> <month> June </month> <year> 1996. </year>
Reference-contexts: Second, it allows for a simple and fast implementation, by leveraging the performance of the highly tuned sorting routines offered by many database systems. There has been considerable work on optimized database sorts in recent years (see, e.g,, <ref> [Aga96, ADADC + 97, NBC + 94] </ref>), and it appears wise to try to draw on these results.
Reference: [APR + 98] <author> L. Arge, O. Procopiuc, S. Ramaswamy, T. Suel, and J. S. Vitter. </author> <title> Theory and practice of I/O-efficient algorithms for multidimensional batched searching problems. </title> <note> In Proc. ACM-SIAM Symp. on Discrete Algorithms (to appear), </note> <year> 1998. </year>
Reference-contexts: In this paper, we focus on the case in which neither of the inputs to the join is indexed. We present a promising new algorithm, called Scalable Sweep-based Spatial Join (SSSJ). It uses the distribution-sweeping paradigm recently proposed in computational geometry <ref> [APR + 98, GTVV93] </ref> and is the first algorithm to achieve theoretically optimal bounds on both internal computation time and I/O transfers. <p> This section is based on the results and theoretical framework developed in <ref> [APR + 98] </ref>. The algorithm uses the distribution-sweeping technique developed in [GTVV93]. We include a full description of the spatial join algorithm in this section for completeness. <p> Our algorithm can also be extended to handle data in three and more dimensions, as stated in the following theorem. For more details about this construction, the reader is referred to <ref> [APR + 98] </ref>. Theorem 3.4 [APR + 98] Given a list of d-dimensional rectangles from P and Q sorted by their lower boundaries in one axis, all intersections between rectangles from P and Q can be reported in O (n log (d1) m n + t) I/O operations. 10 While the <p> Our algorithm can also be extended to handle data in three and more dimensions, as stated in the following theorem. For more details about this construction, the reader is referred to <ref> [APR + 98] </ref>. Theorem 3.4 [APR + 98] Given a list of d-dimensional rectangles from P and Q sorted by their lower boundaries in one axis, all intersections between rectangles from P and Q can be reported in O (n log (d1) m n + t) I/O operations. 10 While the Rectangle Join algorithm is optimal
Reference: [ARC93] <author> ARC/INFO. </author> <title> Understanding GISthe ARC/INFO method. </title> <address> ARC/INFO, </address> <year> 1993. </year> <note> Rev. 6 for workstations. </note>
Reference-contexts: 1 Introduction and Motivation Geographic Information Systems (GISs) have generated enormous interest in the commercial and research database communities over the last decade. Several commercial products that manage spatial data are available. These include ESRI's ARC/INFO <ref> [ARC93] </ref>, InterGraph's MGE [Int97], and Informix [Ube94]. GISs typically store and manage spatial data such as points, lines, poly-lines, polygons, and surfaces. Since the amount of data that they manage is quite large, GISs typically tend to be disk-based systems.
Reference: [AV88] <author> A. Aggarwal and J. S. Vitter. </author> <title> The Input/Output complexity of sorting and related problems. </title> <journal> Communications of the ACM, </journal> <volume> 31(9):11161127, </volume> <year> 1988. </year>
Reference-contexts: We assume that at the beginning of the algorithm, P and Q have already been sorted into one list L of intervals sorted by their lower boundaries, which can be done in O (n log m n) I/O operations using, say, the optimal sorting algorithm from <ref> [AV88] </ref>. We will show that the following algorithm then completes the interval join in O (n + t) I/O operations. 1 There is, of course, a large difference between the performance of random and sequential I/O in practice. <p> We will show that the following algorithm performs O (n log m n + t) I/O operations, and thus asymptotically matches the lower bound implied by the sorting lower bound of <ref> [AV88] </ref>. (It is easy to show that the spatial join is at least as difficult as a sort.) We again assume that at the beginning of the algorithm, P and Q have already been sorted into one list L of rectangles sorted by their lower boundaries in the y-axis, which can
Reference: [Ben77] <author> J. L. Bentley. </author> <title> Algorithms for Klee's rectangle problems. </title> <institution> Dept. of Computer Science, Carnegie Mellon Univ., </institution> <note> unpublished notes, </note> <year> 1977. </year>
Reference-contexts: Many optimal and suboptimal dynamic data structures for intervals have been proposed; important examples are the interval tree [Ede83], the priority search tree [McC85], and the segment tree <ref> [Ben77] </ref>. In most common implementations of sweepline algorithms, the maximum number of rectangles from a data set that are in the data structure is determined by the maximum number of rectangles that are intersected by a single horizontal line.
Reference: [BG92] <author> Ludger Becker and Ralf H. Guting. </author> <title> Rule-based optimization and query processing in an extensible geometric database system. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 17(2):247303, </volume> <month> June </month> <year> 1992. </year>
Reference-contexts: They point out the importance of the square-root rule for this problem. They also consider the effect of I/O from an analytical standpoint, though the algorithmic bounds they obtain are slightly suboptimal in the number of I/O operations. Their algorithm was subsequently implemented in the Gral system <ref> [BG92] </ref>, an extensible database system for geometric applications. The work in [GS87, BG92] is probably the previous contribution most closely related to our approach. However, the I/O bounds we obtain are worst-case optimal, and the algorithms and implementations are different. <p> They also consider the effect of I/O from an analytical standpoint, though the algorithmic bounds they obtain are slightly suboptimal in the number of I/O operations. Their algorithm was subsequently implemented in the Gral system [BG92], an extensible database system for geometric applications. The work in <ref> [GS87, BG92] </ref> is probably the previous contribution most closely related to our approach. However, the I/O bounds we obtain are worst-case optimal, and the algorithms and implementations are different. We are not aware of any direct comparison of the algorithm in [GS87] with other approaches.
Reference: [BHF93] <author> L. Becker, K. Hinrichs, and U. Finke. </author> <title> A new algorithm for computing joins with grid files. </title> <booktitle> In International Conference on Data Engineering, pages 190198, </booktitle> <address> Los Alamitos, Ca., USA, April 1993. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Recently, two join algorithms based on spatial hashing [LR96, PD96] have been proposed for the spatial join. Other approaches to this problem are presented in <ref> [BHF93, KS97, Rot91] </ref>. In this paper, we focus on the case in which neither of the inputs to the join is indexed. We present a promising new algorithm, called Scalable Sweep-based Spatial Join (SSSJ). <p> Orenstein [Ore89] reports that the performance of the resulting algorithm is sensitive to the size of the pixels chosen. Choosing smaller pixels leads to better filtering, but increases the space needed, since the spatial objects get duplicated and stored in several pixels. In another transformational approach <ref> [BHF93] </ref>, the MBRs of spatial objects (which are rectangles in two dimensions) are transformed into points in higher dimensions. The resulting points are stored in a multi-attribute data structure such as the grid file [NHS84]. The filtering step is then performed with the data structure.
Reference: [BKS93] <author> T. Brinkhoff, H.-P. Kriegel, and B. Seeger. </author> <title> Efficient processing of spatial joins using R-trees. </title> <booktitle> In Proc. SIGMOD Intl. Conf. on Management of Data, </booktitle> <year> 1993. </year>
Reference-contexts: Early work [Ore86, OM88, Ore89] relied on representing spatial objects, which are multi-dimensional in nature, along a single dimension using space filling curves. The I/O complexity of the spatial join problem was studied in [GS87]. There has been a series of papers <ref> [BKS93, HJR97, Gun93, HS92] </ref> on using spatial indexes such as the R-tree [Gut85], R + -tree [SRF87], R fl -tree [BKSS90], and PMR quad-tree [Sam89b] to speed up the filtering step of the spatial join. <p> There has recently been much interest in using spatial index structures like the R-tree [Gut85], R + - tree [SRF87], R fl -tree [BKSS90], and PMR quad-tree [Sam89b] to speed up the filtering step of the spatial join. Brinkhoff, Kriegel, and Seeger <ref> [BKS93] </ref> propose a spatial join algorithm based on R fl -trees. Their 4 algorithm is a carefully synchronized depth-first traversal of the two trees to be joined. An improvement of this algorithm has been reported recently in [HJR97]. <p> They construct an index for that relation by using the index on the other relation as a starting point (the seed). Once the index is constructed, the tree join algorithm of <ref> [BKS93] </ref> is used to perform the actual join. In later work [LR95], Lo and Ravishankar handle the case when neither of the inputs to the join has an index available. <p> In later work [LR95], Lo and Ravishankar handle the case when neither of the inputs to the join has an index available. They build indices for the relations on the fly using spatial sampling techniques and then use the tree join algorithm of <ref> [BKS93] </ref> for computing the join. Another recent paper [KS97] proposes an algorithm based on a filter tree structure. Patel and DeWitt [PD96] and Lo and Ravishankar [LR96] both propose hash-based spatial join algorithms. <p> They both use a spatial partitioning function to break up the inputs into partitions such that each partition will fit entirely fit in memory. Patel and DeWitt then use a quadratic cost plane-sweeping algorithm proposed first in <ref> [BKS93] </ref> to perform the join within each partition, while Lo and Ravishankar use an indexed nested loop join for this purpose. G uting and Schilling [GS87] give an interesting discussion of plane-sweeping for the spatial join problem. They point out the importance of the square-root rule for this problem. <p> Then a sweepline algorithm is employed to report the intersecting rectangles. (A more detailed description of the partitioning step of PBSM is given in Section 5.1.) The sweepline algorithm employed by Patel and DeWitt is a quadratic-cost algorithm that was proposed in <ref> [BKS93] </ref>. This algorithm, which we refer to as PBSM Sweep, is shown in Figure 3. The worst-case running time of this algorithm is O (N 2 ).
Reference: [BKSS90] <author> N. Beckmann, H.-P. Kriegel, R. Schneider, and B. Seeger. </author> <title> The R*-tree: An efficient and robust access method for points and rectangles. </title> <booktitle> In Proc. SIGMOD Intl. Conf. on Management of Data, </booktitle> <year> 1990. </year>
Reference-contexts: The I/O complexity of the spatial join problem was studied in [GS87]. There has been a series of papers [BKS93, HJR97, Gun93, HS92] on using spatial indexes such as the R-tree [Gut85], R + -tree [SRF87], R fl -tree <ref> [BKSS90] </ref>, and PMR quad-tree [Sam89b] to speed up the filtering step of the spatial join. Others [LR94, LR95] have focused on the case where one or 2 both of the input relations to the spatial join do not have an index available. <p> The join index used in [Rot91] partially computes the result of the spatial join using a grid file. There has recently been much interest in using spatial index structures like the R-tree [Gut85], R + - tree [SRF87], R fl -tree <ref> [BKSS90] </ref>, and PMR quad-tree [Sam89b] to speed up the filtering step of the spatial join. Brinkhoff, Kriegel, and Seeger [BKS93] propose a spatial join algorithm based on R fl -trees. Their 4 algorithm is a carefully synchronized depth-first traversal of the two trees to be joined.
Reference: [Chi95] <author> Y.-J. Chiang. </author> <title> Experiments on the practical I/O efficiency of geometric algorithms: Distribution sweep vs. plane sweep. </title> <booktitle> In Proc. Workshop on Algorithms and Data Structures, </booktitle> <volume> LNCS 955, </volume> <pages> pages 346357, </pages> <year> 1995. </year>
Reference-contexts: This is to illustrate the effect of skewed data distributions as well as data size scaleup on the performance of the algorithms. We generated two data sets of skewed rectangles, following a procedure used in <ref> [Chi95] </ref>. Each data set contains two sets of N=2 rectangles each, placed in the [0; N ] fi [0; N ] square.
Reference: [CLR90] <author> T. H. Cormen, C. E. Leiserson, and R. L. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> The MIT Press, </publisher> <address> Cam-bridge, Mass., </address> <year> 1990. </year>
Reference-contexts: More precisely, we used a simplified dynamic version of the interval tree similar to that described in Section 15.3 and Exercise 15.34 of <ref> [CLR90] </ref>, but implemented the structure using a randomized skip list instead of a balanced tree structure. (Another, though somewhat different, structure combining interval trees and skip lists has been described in [Han91].) Our reason for using a skip list is that it allows for a fairly simple but efficient implementation while
Reference: [Ede83] <author> H. Edelsbrunner. </author> <title> A new approach to rectangle intersections, part I. </title> <journal> Int. J. Computer Mathematics, </journal> <volume> 13:209219, </volume> <year> 1983. </year>
Reference-contexts: Many optimal and suboptimal dynamic data structures for intervals have been proposed; important examples are the interval tree <ref> [Ede83] </ref>, the priority search tree [McC85], and the segment tree [Ben77]. In most common implementations of sweepline algorithms, the maximum number of rectangles from a data set that are in the data structure is determined by the maximum number of rectangles that are intersected by a single horizontal line. <p> We now describe our implementation of plane-sweeping in memory. 4.3 Our implementation of Plane-Sweeping The data structure that we used in our implementation of plane sweeping is essentially a combination of an interval tree <ref> [Ede83] </ref> and a skip list [Pug90].
Reference: [Emm97] <author> P. Emmerman. </author> <booktitle> Advanced battlefield processing. In Second CGC Workshop on Computational Geometry. </booktitle> <institution> Duke University, </institution> <month> October </month> <year> 1997. </year>
Reference-contexts: If, however, the data does not exhibit good spatial locality, or if it is extremely large (see, e.g., <ref> [Emm97] </ref>), then it is necessary to partition the input. Algorithm Rectangle Join from Section 3.2 will guarantee good performance in such a situation. A natural question in this context is how to decide if an input needs to be partitioned, or if it can be processed with a single sweepline.
Reference: [GS87] <author> R. H. Guting and W. Schilling. </author> <title> A practical divide-and-conquer algorithm for the rectangle intersection problem. </title> <journal> Information Sciences, </journal> <volume> 42:95112, </volume> <year> 1987. </year>
Reference-contexts: Early work [Ore86, OM88, Ore89] relied on representing spatial objects, which are multi-dimensional in nature, along a single dimension using space filling curves. The I/O complexity of the spatial join problem was studied in <ref> [GS87] </ref>. There has been a series of papers [BKS93, HJR97, Gun93, HS92] on using spatial indexes such as the R-tree [Gut85], R + -tree [SRF87], R fl -tree [BKSS90], and PMR quad-tree [Sam89b] to speed up the filtering step of the spatial join. <p> Patel and DeWitt then use a quadratic cost plane-sweeping algorithm proposed first in [BKS93] to perform the join within each partition, while Lo and Ravishankar use an indexed nested loop join for this purpose. G uting and Schilling <ref> [GS87] </ref> give an interesting discussion of plane-sweeping for the spatial join problem. They point out the importance of the square-root rule for this problem. They also consider the effect of I/O from an analytical standpoint, though the algorithmic bounds they obtain are slightly suboptimal in the number of I/O operations. <p> They also consider the effect of I/O from an analytical standpoint, though the algorithmic bounds they obtain are slightly suboptimal in the number of I/O operations. Their algorithm was subsequently implemented in the Gral system [BG92], an extensible database system for geometric applications. The work in <ref> [GS87, BG92] </ref> is probably the previous contribution most closely related to our approach. However, the I/O bounds we obtain are worst-case optimal, and the algorithms and implementations are different. We are not aware of any direct comparison of the algorithm in [GS87] with other approaches. <p> The work in [GS87, BG92] is probably the previous contribution most closely related to our approach. However, the I/O bounds we obtain are worst-case optimal, and the algorithms and implementations are different. We are not aware of any direct comparison of the algorithm in <ref> [GS87] </ref> with other approaches. While there are a variety of approaches in the literature, a common feature among all of them is that they do not have good worst-case bounds. (One notable exception is the work of [GS87]). <p> We are not aware of any direct comparison of the algorithm in <ref> [GS87] </ref> with other approaches. While there are a variety of approaches in the literature, a common feature among all of them is that they do not have good worst-case bounds. (One notable exception is the work of [GS87]). <p> We point out that the algorithm of G uting and Schilling <ref> [GS87] </ref> takes O (n log 2 n + t) I/O operations to solve the spatial join problem. Thus, their I/O bound is off from the optimal bound by a multiplicative factor of log 2 m (which can be on the order of 1015). <p> This number, which we will refer to as the maximum overlap of a data set, is actually significantly smaller than the total number of rectangles for most real life input data, due to the locality inherent in the data. This observation has previously been made by other researchers (see <ref> [GS87] </ref> and the references therein), and is known as the square-root rule in the VLSI literature.
Reference: [GTVV93] <author> M. T. Goodrich, J.-J. Tsay, D. E. Vengroff, and J. S. Vitter. </author> <title> External-memory computational geometry. </title> <booktitle> In Proc. IEEE Symp. on Foundations of Comp. Sci., </booktitle> <pages> pages 714723, </pages> <year> 1993. </year>
Reference-contexts: In this paper, we focus on the case in which neither of the inputs to the join is indexed. We present a promising new algorithm, called Scalable Sweep-based Spatial Join (SSSJ). It uses the distribution-sweeping paradigm recently proposed in computational geometry <ref> [APR + 98, GTVV93] </ref> and is the first algorithm to achieve theoretically optimal bounds on both internal computation time and I/O transfers. <p> This section is based on the results and theoretical framework developed in [APR + 98]. The algorithm uses the distribution-sweeping technique developed in <ref> [GTVV93] </ref>. We include a full description of the spatial join algorithm in this section for completeness. Throughout this section, we make the assumption that each access to disk transmits one disk block with B units of data, and we count this as one I/O operation 1 .
Reference: [Gun93] <author> O. Gunther. </author> <title> Efficient computation of spatial joins. </title> <booktitle> In International Conference on Data Engineering, </booktitle> <pages> pages 5060, </pages> <address> Los Alamitos, Ca., USA, April 1993. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Early work [Ore86, OM88, Ore89] relied on representing spatial objects, which are multi-dimensional in nature, along a single dimension using space filling curves. The I/O complexity of the spatial join problem was studied in [GS87]. There has been a series of papers <ref> [BKS93, HJR97, Gun93, HS92] </ref> on using spatial indexes such as the R-tree [Gut85], R + -tree [SRF87], R fl -tree [BKSS90], and PMR quad-tree [Sam89b] to speed up the filtering step of the spatial join.
Reference: [Gut85] <author> A. Guttman. R-trees: </author> <title> A dynamic index structure for spatial searching. </title> <booktitle> In Proc. ACM-SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 4757, </pages> <year> 1985. </year>
Reference-contexts: The I/O complexity of the spatial join problem was studied in [GS87]. There has been a series of papers [BKS93, HJR97, Gun93, HS92] on using spatial indexes such as the R-tree <ref> [Gut85] </ref>, R + -tree [SRF87], R fl -tree [BKSS90], and PMR quad-tree [Sam89b] to speed up the filtering step of the spatial join. Others [LR94, LR95] have focused on the case where one or 2 both of the input relations to the spatial join do not have an index available. <p> Rotem [Rot91] proposes a spatial join algorithm based on the join index of Valduriez [Val87]. The join index used in [Rot91] partially computes the result of the spatial join using a grid file. There has recently been much interest in using spatial index structures like the R-tree <ref> [Gut85] </ref>, R + - tree [SRF87], R fl -tree [BKSS90], and PMR quad-tree [Sam89b] to speed up the filtering step of the spatial join. Brinkhoff, Kriegel, and Seeger [BKS93] propose a spatial join algorithm based on R fl -trees.
Reference: [Han91] <author> E. N. Hanson. </author> <title> The interval skip list: A data structure for finding all intervals that overlap a point. </title> <booktitle> In Proceedings of Algorithms and Data Structures (WADS '91), volume 519 of LNCS, </booktitle> <pages> pages 153164. </pages> <publisher> Springer, </publisher> <month> August </month> <year> 1991. </year> <month> 23 </month>
Reference-contexts: a simplified dynamic version of the interval tree similar to that described in Section 15.3 and Exercise 15.34 of [CLR90], but implemented the structure using a randomized skip list instead of a balanced tree structure. (Another, though somewhat different, structure combining interval trees and skip lists has been described in <ref> [Han91] </ref>.) Our reason for using a skip list is that it allows for a fairly simple but efficient implementation while matching (in a probabilistic sense) the good worst-case behavior of a balanced tree. To describe how we use this data structure in our sweepline implementation, we use the following conventions.
Reference: [HJR97] <author> Y.-W. Huang, N. Jing, and E. A. Rundensteiner. </author> <title> Spatial joins using R-trees: Breadth-first traversal with global optimizations. </title> <booktitle> In Proc. IEEE International Conf. on Very Large Databases, </booktitle> <pages> pages 396405, </pages> <year> 1997. </year>
Reference-contexts: Early work [Ore86, OM88, Ore89] relied on representing spatial objects, which are multi-dimensional in nature, along a single dimension using space filling curves. The I/O complexity of the spatial join problem was studied in [GS87]. There has been a series of papers <ref> [BKS93, HJR97, Gun93, HS92] </ref> on using spatial indexes such as the R-tree [Gut85], R + -tree [SRF87], R fl -tree [BKSS90], and PMR quad-tree [Sam89b] to speed up the filtering step of the spatial join. <p> Brinkhoff, Kriegel, and Seeger [BKS93] propose a spatial join algorithm based on R fl -trees. Their 4 algorithm is a carefully synchronized depth-first traversal of the two trees to be joined. An improvement of this algorithm has been reported recently in <ref> [HJR97] </ref>. Gunther [G un93] studies the tradeoffs between using join indices and spatial indices for the spatial join. He concludes that the join index approach is better for low join selectivities. For higher join selectivities, joins using spatial indices perform better.
Reference: [HS92] <author> E. G. Hoel and H. Samet. </author> <title> A qualitative comparison study of data structures for large linear segment databases. </title> <booktitle> In Proc. ACM SIGMOD Conf., </booktitle> <pages> page 205, </pages> <address> San Diego, CA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Early work [Ore86, OM88, Ore89] relied on representing spatial objects, which are multi-dimensional in nature, along a single dimension using space filling curves. The I/O complexity of the spatial join problem was studied in [GS87]. There has been a series of papers <ref> [BKS93, HJR97, Gun93, HS92] </ref> on using spatial indexes such as the R-tree [Gut85], R + -tree [SRF87], R fl -tree [BKSS90], and PMR quad-tree [Sam89b] to speed up the filtering step of the spatial join. <p> Gunther [G un93] studies the tradeoffs between using join indices and spatial indices for the spatial join. He concludes that the join index approach is better for low join selectivities. For higher join selectivities, joins using spatial indices perform better. Hoel and Samet <ref> [HS92] </ref> study the use of PMR quad-trees for the spatial join and compare it against members of the R-tree family.
Reference: [Int97] <institution> Intergraph Corp. MGE 7.0, </institution> <note> http://www.intergraph.com/iss/products/mge/mge-7.0.htm, 1997. </note>
Reference-contexts: 1 Introduction and Motivation Geographic Information Systems (GISs) have generated enormous interest in the commercial and research database communities over the last decade. Several commercial products that manage spatial data are available. These include ESRI's ARC/INFO [ARC93], InterGraph's MGE <ref> [Int97] </ref>, and Informix [Ube94]. GISs typically store and manage spatial data such as points, lines, poly-lines, polygons, and surfaces. Since the amount of data that they manage is quite large, GISs typically tend to be disk-based systems. Efficient retrieval of spatial data from disk has been studied extensively [Sam89b, Sam89a].
Reference: [KS97] <author> N. Koudas and K. C. Sevcik. </author> <title> Size separation spatial join. </title> <booktitle> In Proc. SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 324335, </pages> <year> 1997. </year>
Reference-contexts: Recently, two join algorithms based on spatial hashing [LR96, PD96] have been proposed for the spatial join. Other approaches to this problem are presented in <ref> [BHF93, KS97, Rot91] </ref>. In this paper, we focus on the case in which neither of the inputs to the join is indexed. We present a promising new algorithm, called Scalable Sweep-based Spatial Join (SSSJ). <p> They build indices for the relations on the fly using spatial sampling techniques and then use the tree join algorithm of [BKS93] for computing the join. Another recent paper <ref> [KS97] </ref> proposes an algorithm based on a filter tree structure. Patel and DeWitt [PD96] and Lo and Ravishankar [LR96] both propose hash-based spatial join algorithms. They both use a spatial partitioning function to break up the inputs into partitions such that each partition will fit entirely fit in memory.
Reference: [LR94] <author> M.-L. Lo and C. V. Ravishankar. </author> <title> Spatial joins using seeded trees. </title> <booktitle> In Proc. SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 209220, </pages> <year> 1994. </year>
Reference-contexts: There has been a series of papers [BKS93, HJR97, Gun93, HS92] on using spatial indexes such as the R-tree [Gut85], R + -tree [SRF87], R fl -tree [BKSS90], and PMR quad-tree [Sam89b] to speed up the filtering step of the spatial join. Others <ref> [LR94, LR95] </ref> have focused on the case where one or 2 both of the input relations to the spatial join do not have an index available. Recently, two join algorithms based on spatial hashing [LR96, PD96] have been proposed for the spatial join. <p> The other major direction for research on the spatial join has focused on how to compute the join when one or both of the inputs do not have an index available. Lo and Ravishankar <ref> [LR94] </ref> discuss the case when one of the relations participating in the join does not have an index built on it. They construct an index for that relation by using the index on the other relation as a starting point (the seed).
Reference: [LR95] <author> M.-L. Lo and C. V. Ravishankar. </author> <title> Generating seeded trees from data sets. </title> <booktitle> In Proc. International Symp. on Large Spatial Databases, </booktitle> <year> 1995. </year>
Reference-contexts: There has been a series of papers [BKS93, HJR97, Gun93, HS92] on using spatial indexes such as the R-tree [Gut85], R + -tree [SRF87], R fl -tree [BKSS90], and PMR quad-tree [Sam89b] to speed up the filtering step of the spatial join. Others <ref> [LR94, LR95] </ref> have focused on the case where one or 2 both of the input relations to the spatial join do not have an index available. Recently, two join algorithms based on spatial hashing [LR96, PD96] have been proposed for the spatial join. <p> They construct an index for that relation by using the index on the other relation as a starting point (the seed). Once the index is constructed, the tree join algorithm of [BKS93] is used to perform the actual join. In later work <ref> [LR95] </ref>, Lo and Ravishankar handle the case when neither of the inputs to the join has an index available. They build indices for the relations on the fly using spatial sampling techniques and then use the tree join algorithm of [BKS93] for computing the join.
Reference: [LR96] <author> M.-L. Lo and C. V. Ravishankar. </author> <title> Spatial hash-joins. </title> <booktitle> In Proc. SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 247258, </pages> <year> 1996. </year>
Reference-contexts: Others [LR94, LR95] have focused on the case where one or 2 both of the input relations to the spatial join do not have an index available. Recently, two join algorithms based on spatial hashing <ref> [LR96, PD96] </ref> have been proposed for the spatial join. Other approaches to this problem are presented in [BHF93, KS97, Rot91]. In this paper, we focus on the case in which neither of the inputs to the join is indexed. <p> PBSM can be significantly improved by using a more sophisticated algorithm based on computational geometry plane-sweeping techniques and data structures. (Our performance comparisons of the SSSJ were made against this optimized version of PBSM!) Even though we do not include a performance comparison with Lo and Ravishankar's hash join algorithm <ref> [LR96] </ref> in this paper, we fully expect that by using our technique, the CPU time of that algorithm will be significantly improved as well. 3 In Section 2 we discuss related research in more detail. We then present the theoretically optimal solution for the spatial join problem in Section 3. <p> They build indices for the relations on the fly using spatial sampling techniques and then use the tree join algorithm of [BKS93] for computing the join. Another recent paper [KS97] proposes an algorithm based on a filter tree structure. Patel and DeWitt [PD96] and Lo and Ravishankar <ref> [LR96] </ref> both propose hash-based spatial join algorithms. They both use a spatial partitioning function to break up the inputs into partitions such that each partition will fit entirely fit in memory.
Reference: [McC85] <author> E.M. McCreight. </author> <title> Priority search trees. </title> <journal> SIAM Journal of Computing, </journal> <volume> 14(2):257276, </volume> <year> 1985. </year>
Reference-contexts: Many optimal and suboptimal dynamic data structures for intervals have been proposed; important examples are the interval tree [Ede83], the priority search tree <ref> [McC85] </ref>, and the segment tree [Ben77]. In most common implementations of sweepline algorithms, the maximum number of rectangles from a data set that are in the data structure is determined by the maximum number of rectangles that are intersected by a single horizontal line. <p> Thus, we would not expect significant improvements from more complicated, but asymptotically optimal data structures such as the priority search tree <ref> [McC85] </ref>. The access time and memory overhead of a skip list depends on a probability parameter p, which determines the height and size of the data structure (see [Pug90]).
Reference: [NBC + 94] <author> C. Nyberg, T. Barclay, Z. Cvetanovic, J. Gray, and D. Lomet. AlphaSort: </author> <title> A RISC machine sort. </title> <booktitle> In Proc. SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 233242, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: Second, it allows for a simple and fast implementation, by leveraging the performance of the highly tuned sorting routines offered by many database systems. There has been considerable work on optimized database sorts in recent years (see, e.g,, <ref> [Aga96, ADADC + 97, NBC + 94] </ref>), and it appears wise to try to draw on these results.
Reference: [NHS84] <author> J. Nievergelt, H. Hinterberger, and K.C. Sevcik. </author> <title> The grid file: An adaptable, symmetric multikey file structure. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 9(1):257276, </volume> <year> 1984. </year>
Reference-contexts: In another transformational approach [BHF93], the MBRs of spatial objects (which are rectangles in two dimensions) are transformed into points in higher dimensions. The resulting points are stored in a multi-attribute data structure such as the grid file <ref> [NHS84] </ref>. The filtering step is then performed with the data structure. Rotem [Rot91] proposes a spatial join algorithm based on the join index of Valduriez [Val87]. The join index used in [Rot91] partially computes the result of the spatial join using a grid file.
Reference: [OM88] <author> J. A. Orenstein and F. A. Manola. </author> <title> PROBE spatial data modeling and query processing in an image database application. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(5):611629, </volume> <month> May </month> <year> 1988. </year>
Reference-contexts: In the case of the window query, the objects corresponding to the MBRs retrieved by the filtering step are checked to see if they actually intersect with the query window. The filtering step of the spatial join has been studied extensively by a number of researchers. Early work <ref> [Ore86, OM88, Ore89] </ref> relied on representing spatial objects, which are multi-dimensional in nature, along a single dimension using space filling curves. The I/O complexity of the spatial join problem was studied in [GS87]. <p> This makes it possible to design sort-merge join algorithms for joining two such sets of objects. However, spatial objects, which are characterized by rectangles (or more complicated geometric entities) cannot be totally ordered. In <ref> [Ore86, OM88] </ref>, Orenstein proposes the use of a space-filling curve, called the Peano curve or z-ordering, to decompose the underlying space of the spatial objects into uniform regions called pixels. A pixel is described by a single number, namely, its position on the space filling curve.
Reference: [Ore86] <author> J. A. Orenstein. </author> <title> Spatial query processing in an object-oriented database system. </title> <editor> In Carlo Zaniolo, editor, </editor> <booktitle> Proceedings of the 1986 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 326336, </pages> <address> Washington, D.C., </address> <month> 2830 May </month> <year> 1986. </year>
Reference-contexts: In the case of the window query, the objects corresponding to the MBRs retrieved by the filtering step are checked to see if they actually intersect with the query window. The filtering step of the spatial join has been studied extensively by a number of researchers. Early work <ref> [Ore86, OM88, Ore89] </ref> relied on representing spatial objects, which are multi-dimensional in nature, along a single dimension using space filling curves. The I/O complexity of the spatial join problem was studied in [GS87]. <p> This makes it possible to design sort-merge join algorithms for joining two such sets of objects. However, spatial objects, which are characterized by rectangles (or more complicated geometric entities) cannot be totally ordered. In <ref> [Ore86, OM88] </ref>, Orenstein proposes the use of a space-filling curve, called the Peano curve or z-ordering, to decompose the underlying space of the spatial objects into uniform regions called pixels. A pixel is described by a single number, namely, its position on the space filling curve.
Reference: [Ore89] <author> J. A. Orenstein. </author> <title> Redundancy in spatial databases. </title> <booktitle> SIGMOD Record (ACM Special Interest Group on Management of Data), </booktitle> <address> 18(2):294305, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: In the case of the window query, the objects corresponding to the MBRs retrieved by the filtering step are checked to see if they actually intersect with the query window. The filtering step of the spatial join has been studied extensively by a number of researchers. Early work <ref> [Ore86, OM88, Ore89] </ref> relied on representing spatial objects, which are multi-dimensional in nature, along a single dimension using space filling curves. The I/O complexity of the spatial join problem was studied in [GS87]. <p> Each spatial object is then associated with the numbers of the pixels that it intersects. This representation transforms each spatial object into a set of one-dimensional values along the z-dimension. A spatial join can then be evaluated as a sort-merge join along the z-dimension. Orenstein <ref> [Ore89] </ref> reports that the performance of the resulting algorithm is sensitive to the size of the pixels chosen. Choosing smaller pixels leads to better filtering, but increases the space needed, since the spatial objects get duplicated and stored in several pixels.
Reference: [Ore90] <author> J. A. Orenstein. </author> <title> A comparison of spatial query processing techniques for native and parameter spaces. </title> <booktitle> SIGMOD Record (ACM Special Interest Group on Management of Data), </booktitle> <address> 19(2):343352, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: One technique is to bound each spatial object by the smallest axis-parallel rectangle that completely contains it. This rectangle is referred to as the spatial object's minimum bounding rectangle (MBR). Spatial operations can then be performed in two steps <ref> [Ore90] </ref>: * Filter Step: The spatial operation is performed on the approximate representation, such as the MBRs. For example, when joining two spatial relations, the first step is to identify all intersecting pairs of MBRs.
Reference: [PD96] <author> J. M. Patel and D. J. DeWitt. </author> <title> Partition based spatial-merge join. </title> <booktitle> In Proc. SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 259270, </pages> <year> 1996. </year>
Reference-contexts: Others [LR94, LR95] have focused on the case where one or 2 both of the input relations to the spatial join do not have an index available. Recently, two join algorithms based on spatial hashing <ref> [LR96, PD96] </ref> have been proposed for the spatial join. Other approaches to this problem are presented in [BHF93, KS97, Rot91]. In this paper, we focus on the case in which neither of the inputs to the join is indexed. <p> They build indices for the relations on the fly using spatial sampling techniques and then use the tree join algorithm of [BKS93] for computing the join. Another recent paper [KS97] proposes an algorithm based on a filter tree structure. Patel and DeWitt <ref> [PD96] </ref> and Lo and Ravishankar [LR96] both propose hash-based spatial join algorithms. They both use a spatial partitioning function to break up the inputs into partitions such that each partition will fit entirely fit in memory. <p> We implemented the SSSJ algorithm along with two versions of the PBSM algorithm: one that follows exactly the description of Patel and DeWitt <ref> [PD96] </ref> and one that replaces the internal-memory sweep-line procedure with the one used in SSSJ. We refer to the original and improved PBSMs as QPBSM and MPBSM respectively.
Reference: [PS85] <author> F. P. Preparata and M. I. Shamos. </author> <title> Computational Geometry: An Introduction. </title> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: The spatial join problem has been extensively studied in computational geometry literature <ref> [PS85] </ref>, where it is known as the rectangle intersection problem. Of course, it was assumed that the data would fit in main memory. <p> Plane sweeping is one of the most basic algorithmic paradigms in computational geometry (see, e.g., <ref> [PS85] </ref>). Simply speaking, a plane-sweeping (or sweepline) algorithm attempts to solve a geometric problem by moving a vertical or horizontal sweepline across the scene, processing objects as they are reached by the sweepline. Any pair of intersecting rectangles has a horizontal line that passes through both rectangles.
Reference: [Pug90] <author> W. Pugh. </author> <title> Skip lists: A probabilistic alternative to balanced trees. </title> <journal> Communications of the ACM, </journal> <volume> 33(6):668676, </volume> <month> June </month> <year> 1990. </year>
Reference-contexts: We now describe our implementation of plane-sweeping in memory. 4.3 Our implementation of Plane-Sweeping The data structure that we used in our implementation of plane sweeping is essentially a combination of an interval tree [Ede83] and a skip list <ref> [Pug90] </ref>. <p> Thus, we would not expect significant improvements from more complicated, but asymptotically optimal data structures such as the priority search tree [McC85]. The access time and memory overhead of a skip list depends on a probability parameter p, which determines the height and size of the data structure (see <ref> [Pug90] </ref>). In our experiments, we chose p = 1=4, which results in a memory overhead of about 8 bytes per item stored in the interval tree.
Reference: [Rot91] <author> D. Rotem. </author> <title> Spatial join indices. </title> <booktitle> In International Conference on Data Engineering, </booktitle> <pages> pages 500509, </pages> <address> Los Alamitos, Ca., USA, April 1991. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Recently, two join algorithms based on spatial hashing [LR96, PD96] have been proposed for the spatial join. Other approaches to this problem are presented in <ref> [BHF93, KS97, Rot91] </ref>. In this paper, we focus on the case in which neither of the inputs to the join is indexed. We present a promising new algorithm, called Scalable Sweep-based Spatial Join (SSSJ). <p> The resulting points are stored in a multi-attribute data structure such as the grid file [NHS84]. The filtering step is then performed with the data structure. Rotem <ref> [Rot91] </ref> proposes a spatial join algorithm based on the join index of Valduriez [Val87]. The join index used in [Rot91] partially computes the result of the spatial join using a grid file. <p> The resulting points are stored in a multi-attribute data structure such as the grid file [NHS84]. The filtering step is then performed with the data structure. Rotem <ref> [Rot91] </ref> proposes a spatial join algorithm based on the join index of Valduriez [Val87]. The join index used in [Rot91] partially computes the result of the spatial join using a grid file.
Reference: [Sam89a] <author> H. Samet. </author> <title> Applications of Spatial Data Structures: Computer Graphics, Image Processing, and GIS. </title> <publisher> Addison Wesley, </publisher> <address> MA, </address> <year> 1989. </year>
Reference-contexts: GISs typically store and manage spatial data such as points, lines, poly-lines, polygons, and surfaces. Since the amount of data that they manage is quite large, GISs typically tend to be disk-based systems. Efficient retrieval of spatial data from disk has been studied extensively <ref> [Sam89b, Sam89a] </ref>. An extremely important problem on spatial data is the spatial join, where two spatial relations are combined together based on some spatial criteria. A typical use for spatial join is the map overlay operation that combines two maps of different types of objects.
Reference: [Sam89b] <author> H. Samet. </author> <title> The Design and Analyses of Spatial Data Structures. </title> <publisher> Addison Wesley, </publisher> <address> MA, </address> <year> 1989. </year>
Reference-contexts: GISs typically store and manage spatial data such as points, lines, poly-lines, polygons, and surfaces. Since the amount of data that they manage is quite large, GISs typically tend to be disk-based systems. Efficient retrieval of spatial data from disk has been studied extensively <ref> [Sam89b, Sam89a] </ref>. An extremely important problem on spatial data is the spatial join, where two spatial relations are combined together based on some spatial criteria. A typical use for spatial join is the map overlay operation that combines two maps of different types of objects. <p> The I/O complexity of the spatial join problem was studied in [GS87]. There has been a series of papers [BKS93, HJR97, Gun93, HS92] on using spatial indexes such as the R-tree [Gut85], R + -tree [SRF87], R fl -tree [BKSS90], and PMR quad-tree <ref> [Sam89b] </ref> to speed up the filtering step of the spatial join. Others [LR94, LR95] have focused on the case where one or 2 both of the input relations to the spatial join do not have an index available. <p> The join index used in [Rot91] partially computes the result of the spatial join using a grid file. There has recently been much interest in using spatial index structures like the R-tree [Gut85], R + - tree [SRF87], R fl -tree [BKSS90], and PMR quad-tree <ref> [Sam89b] </ref> to speed up the filtering step of the spatial join. Brinkhoff, Kriegel, and Seeger [BKS93] propose a spatial join algorithm based on R fl -trees. Their 4 algorithm is a carefully synchronized depth-first traversal of the two trees to be joined.
Reference: [SRF87] <author> T. Sellis, N. Roussopoulos, and C. Faloutsos. </author> <title> The R + -tree: A dynamic index for multi-dimensional objects. </title> <booktitle> In Proc. IEEE International Conf. on Very Large Databases, </booktitle> <year> 1987. </year>
Reference-contexts: The I/O complexity of the spatial join problem was studied in [GS87]. There has been a series of papers [BKS93, HJR97, Gun93, HS92] on using spatial indexes such as the R-tree [Gut85], R + -tree <ref> [SRF87] </ref>, R fl -tree [BKSS90], and PMR quad-tree [Sam89b] to speed up the filtering step of the spatial join. Others [LR94, LR95] have focused on the case where one or 2 both of the input relations to the spatial join do not have an index available. <p> The join index used in [Rot91] partially computes the result of the spatial join using a grid file. There has recently been much interest in using spatial index structures like the R-tree [Gut85], R + - tree <ref> [SRF87] </ref>, R fl -tree [BKSS90], and PMR quad-tree [Sam89b] to speed up the filtering step of the spatial join. Brinkhoff, Kriegel, and Seeger [BKS93] propose a spatial join algorithm based on R fl -trees. Their 4 algorithm is a carefully synchronized depth-first traversal of the two trees to be joined.
Reference: [tig92] <author> Tiger/line files (tm), </author> <title> 1992 technical documentation. </title> <type> Technical report, </type> <institution> U. S. Bureau of the Census, </institution> <year> 1992. </year>
Reference-contexts: These data files were created by the US Bureau of the Census <ref> [tig92] </ref> and consist of polygonal line entities representing physical features such as rivers, roads, railroad lines, etc. We looked at the maximum number of rectangles that are intersected by a horizontal line for the road and hydrographic features of the four data sets. <p> We refer to the original and improved PBSMs as QPBSM and MPBSM respectively. We ran the three programs on data sets derived from the TIGER/Line files <ref> [tig92] </ref> as well as on artificially created data that emphasizes the worst-case behavior of the algorithms. The rest of this section is organized as follows. We begin by explaining the PBSM algorithm. Then we discuss the details of our implementation.
Reference: [Ube94] <author> M. Ubell. </author> <title> The montage extensible datablade architecture. </title> <booktitle> In Proc. SIGMOD Intl. Conf. on Management of Data, </booktitle> <year> 1994. </year> <month> 24 </month>
Reference-contexts: 1 Introduction and Motivation Geographic Information Systems (GISs) have generated enormous interest in the commercial and research database communities over the last decade. Several commercial products that manage spatial data are available. These include ESRI's ARC/INFO [ARC93], InterGraph's MGE [Int97], and Informix <ref> [Ube94] </ref>. GISs typically store and manage spatial data such as points, lines, poly-lines, polygons, and surfaces. Since the amount of data that they manage is quite large, GISs typically tend to be disk-based systems. Efficient retrieval of spatial data from disk has been studied extensively [Sam89b, Sam89a].
Reference: [Val87] <author> Patrick Valduriez. </author> <title> Join indices. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 12(2):218246, </volume> <month> June </month> <year> 1987. </year>
Reference-contexts: The resulting points are stored in a multi-attribute data structure such as the grid file [NHS84]. The filtering step is then performed with the data structure. Rotem [Rot91] proposes a spatial join algorithm based on the join index of Valduriez <ref> [Val87] </ref>. The join index used in [Rot91] partially computes the result of the spatial join using a grid file.
Reference: [Ven94] <author> D. E. Vengroff. </author> <title> A transparent parallel I/O environment. </title> <booktitle> In Proc. 1994 DAGS Symposium on Parallel Computation, </booktitle> <year> 1994. </year>
Reference-contexts: In the second step, each partition is loaded into memory and intersections between rectangles in the partition reported. This step was described in detail in Section 4.4. 5.2 Implementation details We implemented the three algorithms using the Transparent Parallel I/O Programming Environment (TPIE) system <ref> [Ven94, Venns, VV96] </ref>. TPIE is a collection of templated functions and classes to support high-level yet efficient implementations of external-memory algorithms. The basic data structure in TPIE is a 18 stream, representing a list of objects of an arbitrary type.
Reference: [Venns] <author> D. E. Vengroff. </author> <title> TPIE User Manual and Reference. </title> <institution> Duke University, </institution> <note> 1995 with subsequent revisions. Available via WWW at http://www.cs.duke.edu/TPIE. </note>
Reference-contexts: In the second step, each partition is loaded into memory and intersections between rectangles in the partition reported. This step was described in detail in Section 4.4. 5.2 Implementation details We implemented the three algorithms using the Transparent Parallel I/O Programming Environment (TPIE) system <ref> [Ven94, Venns, VV96] </ref>. TPIE is a collection of templated functions and classes to support high-level yet efficient implementations of external-memory algorithms. The basic data structure in TPIE is a 18 stream, representing a list of objects of an arbitrary type.
Reference: [VV96] <author> D. E. Vengroff and J. S. Vitter. </author> <title> I/O-efficient scientific computation using TPIE. </title> <booktitle> In Proceedings of the Goddard Conference on Mass Storage Systems and Technologies, NASA Conference Publication 3340, </booktitle> <volume> Volume II, </volume> <pages> pages 553570, </pages> <address> College Park, MD, </address> <month> September </month> <year> 1996. </year> <month> 25 </month>
Reference-contexts: In the second step, each partition is loaded into memory and intersections between rectangles in the partition reported. This step was described in detail in Section 4.4. 5.2 Implementation details We implemented the three algorithms using the Transparent Parallel I/O Programming Environment (TPIE) system <ref> [Ven94, Venns, VV96] </ref>. TPIE is a collection of templated functions and classes to support high-level yet efficient implementations of external-memory algorithms. The basic data structure in TPIE is a 18 stream, representing a list of objects of an arbitrary type.
References-found: 46

