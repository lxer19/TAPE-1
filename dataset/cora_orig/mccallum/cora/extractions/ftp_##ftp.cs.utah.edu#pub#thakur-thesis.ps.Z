URL: ftp://ftp.cs.utah.edu/pub/thakur-thesis.ps.Z
Refering-URL: http://www.cs.utah.edu/~gary/MSO-publications.html
Root-URL: 
Title: An Empirical Study of Persistent Object Stores  
Author: by Sudheer Thakur 
Degree: A thesis submitted to the faculty of The University of Utah in partial fulfillment of the requirements for the degree of Master of Science  
Date: June 1993  
Affiliation: Department of Computer Science The University of Utah  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Skarra A., Zdonik S. B., and Reiss S. P. </author> <title> An object server for an object-oriented database system. </title> <booktitle> In Proceedings of International Workshop on Object-Oriented Database Systems, </booktitle> <pages> pages 196-204, </pages> <address> Pacific Grove, Calif., 1987. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Some systems provide an OID to each and every object while some provide OIDs only to objects which exist independently and these systems have an internal way of referring to objects which exist as components of these objects. OIDs can be logical <ref> [1, 17, 21] </ref> or based on physical identifiers [15]. Physical OIDs contain information about the object location on secondary storage within themselves whereas logical OIDs do not have such information. In the case of logical OIDs, a correspondence table is needed for mapping OIDs into actual physical locations. <p> The client and server interact in terms of pages. These pages are cached at the server site as well as client site and the client performs most of the object-related work. 2.5.7 ObServer ObServer <ref> [1] </ref> was developed at Brown University. It is a general purpose object server. It provides secondary storage of arbitrarily sized objects for database transactions and facilitates cooperation between these transactions. 15 Objects in ObServer are identified by an external unique identifier (UID) represented by a 64 bit number.
Reference: [2] <author> Mike Accetta, Robert Baron, William Bolosky, David Golub, Richard Rashid, Avadis Tevanian, and Michael Young. </author> <title> Mach: A New Kernel Foundation for Unix Development. </title> <booktitle> In Proceedings of the Summer 1986 USENIX Conference, </booktitle> <pages> pages 93-112, </pages> <address> Atlanta, GA, June 9-13, 1986. </address> <publisher> Usenix Association. </publisher>
Reference-contexts: It uses Mach's external pager facility to map memory into a user's address space and provides transparent persistence. Cricket uses virtual addresses as object identifiers. It uses the memory management primitives of the Mach operating system <ref> [2] </ref> to provide the abstraction of a shared, transactional, single-level store that can be directly accessed by a user application. The client treats a database as a memory object with the Cricket server playing the role of its external pager.
Reference: [3] <author> Shamim Ahmed, Albert Wong, Duvvuru Sriram, and Robert Logcher. </author> <title> A Comparison of Object-Oriented Database Management Systems for Engineering Applications. </title> <type> Technical report, </type> <institution> Intelligent Engineering Systems Laboratory, Department of Civil Engineering, Massachusetts Institute of Technology, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: They generally proceed in distinct phases of loading large working sets, working, and saving. The relational model was not designed for such applications. Moreover, it was not designed to handle data types like voice, video, text, and images. Object-oriented databases (OODBs) <ref> [6, 10, 14, 21, 3] </ref> are designed to bring object-oriented technology into a DBMS and solve some of these problems. One of the main components of an OODB is a Persistent Object Store (POS). POSs support the creation, manipulation, storage, and retrieval of objects. <p> ObjectStore has its own query language for navigational and associative retrieval of objects. For efficient retrieval, it performs query optimization and allows indices to be built on collections of objects. 2.5.9 Ontos Ontos, <ref> [5, 3] </ref> formerly VBase, was developed by Ontologic, Inc. It provides persistence to classes and objects created in C++. It has been implemented using C++. Objects are given UIDs and there are two ways of referring to these objects, Transparent (TRef) and direct references. <p> There is one Postgres process for each active user. All these processes share the Postgres code, buffer pool and lock table but have private data segments. Postgres also supports knowledge management via rules which describe various constraints. 2.5.12 Versant Versant <ref> [3] </ref> was developed by Versant Object Technology Corporation. It provides persistence to C++ classes and objects. It is implemented in C/C++. Versant objects have a logical object identifier (LOID) (LOID is unique across multiple databases), a class identifier, and a storage object identifier containing the physical location of the object.
Reference: [4] <institution> Alpha 1 User's Manual. </institution> <type> Technical report, </type> <institution> Department of Computer Science, University of Utah, </institution> <month> June </month> <year> 1991. </year>
Reference-contexts: One 2 of the motivations of this thesis is to explore the functionality provided by various POSs for an existing Computer Aided Geometric Design (CAGD) system, Alpha 1 <ref> [4] </ref>, a spline-based geometric modeler written at the University of Utah. One of the guiding factors in this exploration will be performance. Apart from performance, the functionality provided by a POS is also important. <p> For better performance, B-tree and hash tables can be defined on class attributes. CHAPTER 3 THE ALPHA 1 SYSTEM Alpha 1 is an advanced spline-based modeler, developed at the University of Utah by the CAGD group <ref> [4] </ref>. This system consists of a language based interactive modeler and a large set of supporting programs. Alpha 1's user interface architecture is a network-based client-server model, with interactive graphical client programs talking to the central modeler.
Reference: [5] <author> Elisa Bertino and Lorenzo Martino. </author> <title> Object-Oriented Database Management Systems: Concepts and Issues. </title> <journal> IEEE Computer, </journal> <volume> 24(4) </volume> <pages> 33-47, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: As a result, two or more disk accesses are likely to be performed to load an object. This indirection through the correspondence table, however, makes moving objects with logical OIDs easier than moving objects with physical OIDs <ref> [5] </ref>. 7 2.4.3 Object Manipulation Generally two modes of access to objects are provided, i.e., access to a single object based on some object identifier or name, and access to a set of objects based on declarative queries. <p> ObjectStore has its own query language for navigational and associative retrieval of objects. For efficient retrieval, it performs query optimization and allows indices to be built on collections of objects. 2.5.9 Ontos Ontos, <ref> [5, 3] </ref> formerly VBase, was developed by Ontologic, Inc. It provides persistence to classes and objects created in C++. It has been implemented using C++. Objects are given UIDs and there are two ways of referring to these objects, Transparent (TRef) and direct references.
Reference: [6] <author> Paul Butterworth, Allen Otis, and Jacob Stein. </author> <title> The GemStone Object Database Management System. </title> <journal> Communications of the ACM, </journal> <volume> 34(10) </volume> <pages> 64-77, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: They generally proceed in distinct phases of loading large working sets, working, and saving. The relational model was not designed for such applications. Moreover, it was not designed to handle data types like voice, video, text, and images. Object-oriented databases (OODBs) <ref> [6, 10, 14, 21, 3] </ref> are designed to bring object-oriented technology into a DBMS and solve some of these problems. One of the main components of an OODB is a Persistent Object Store (POS). POSs support the creation, manipulation, storage, and retrieval of objects. <p> If there are multiple disk volumes, then a separate process manages each of them. These disk I/O processes read and write into the server's buffer pool which is in shared memory. 2.5.3 Gemstone Gemstone <ref> [6] </ref> was developed by Servio, Inc. It is one of the earliest commercial OODBMS. It supports a model of objects similar to that of Smalltalk-80. It has language interfaces to C, C++, and Smalltalk. In Gemstone, the OIDs are unique long integers called Object Oriented Pointers (OOP).
Reference: [7] <author> R.G.G. Cattell. </author> <title> Object Data Management: Object-Oriented and Extended Relational Database Systems. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1991. </year>
Reference-contexts: Apart from performance, the functionality provided by a POS is also important. However, many kinds of functionalities can be added in an application on top of a POS, but poor performance generally cannot be improved at the application level <ref> [7] </ref>. To measure the performance of OODBMSs, there already exists the Cattell benchmark [18]. It concentrates on areas where the highest performance is required e.g., inserting objects, looking up objects, and following connections between objects. It also assumes an "interactive" model for CAD applications. <p> The most profound performance improvements come from minimizing both network and disk overhead <ref> [7] </ref>. The execution capabilities on both workstation and storage server also affect the performance. In ObServer, the server handles all object operations, namely, object storage and retrieval, object locking, transaction management, and recovery. <p> In the research community, it is not clear whether "batch" or "interactive" models are more representative of future engineering applications <ref> [7] </ref>. The tests in this study measured the performance of POSs for a "batch" CAD system.
Reference: [8] <author> H-T. Chou, David J. DeWitt, Randy H. Katz, and Anthony C. Klug. </author> <title> Design and Implementation of the Wisconsin Storage System. </title> <journal> Software-Practice and Experience, </journal> <volume> 15(10) </volume> <pages> 943-962, </pages> <month> October </month> <year> 1983. </year>
Reference-contexts: It is an OODBMS with a complete development environment and a set of user interface tools. It has language interfaces to C and C++. O2 uses WiSS (Wisconsin Storage System) <ref> [8] </ref> as its storage manager. WiSS provides record structured sequential files. The WiSS record identifier (RID) has a volume identifier (2 bytes), a page identifier (4 bytes), and a slot number (2 bytes). RIDs are used as persistent identifiers for objects.
Reference: [9] <editor> In Alan Dearle, Gail M. Shaw, and Stanley B. Zdonik, editors, </editor> <title> Implementing Persistent Object Bases: </title> <booktitle> Principles and Practice. The Fourth International Workshop on Persistent Object Systems, </booktitle> <address> Martha's Vineyard, Mass., </address> <month> Sept. </month> <pages> 23-27, </pages> <year> 1990, </year> <title> 1991. </title> <publisher> Morgan Kaufmann. </publisher> <pages> 92 </pages>
Reference-contexts: systems cluster objects which refer to each other on the secondary store, and use prefetching and buffering. 2.4.6 Schema Evolution Since information in a persistent object system may exist for many years, the need to support evolution and heterogeneity is more acute than it is in a traditional programming system <ref> [9] </ref>. The problem is to allow objects to change their structure 8 and behavior and retain their usefulness. This leads to the important issue of how to propagate changes in class schema to the instances of the affected class.
Reference: [10] <author> D. H. Fishman, D. Beech, H. P. Cate, E. C. Chow, T. Connors, J. W. Davis, N. Derrett, C. G. Hoch, W. Kent, P. Lyngbaek, B. Mahbod, M. A. Neimat, T. A. Ryan, and M. C. Shan. </author> <title> Iris: An Object-Oriented Database Management System. </title> <journal> ACM Transactions on Office Information Systems, </journal> <volume> 5(1) </volume> <pages> 48-69, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: They generally proceed in distinct phases of loading large working sets, working, and saving. The relational model was not designed for such applications. Moreover, it was not designed to handle data types like voice, video, text, and images. Object-oriented databases (OODBs) <ref> [6, 10, 14, 21, 3] </ref> are designed to bring object-oriented technology into a DBMS and solve some of these problems. One of the main components of an OODB is a Persistent Object Store (POS). POSs support the creation, manipulation, storage, and retrieval of objects. <p> It uses "shadowing" for recovery. Gemstone allows queries to be performed against sets of instances of a class or against collections of objects. This collection of objects can be indexed for faster access. 2.5.4 Iris Iris <ref> [10] </ref> was developed at Hewlett-Packard Laboratories. It supports both C and LISP. Iris is built on top of Hewlett-Packard's Allbase relational DBMS. It internally represents objects in the database by logical identifiers. The Iris Storage Manager is a conventional relational storage subsystem.
Reference: [11] <author> Setrag N. Khoshafian and George P. Copeland. </author> <title> Object Identity. </title> <booktitle> OOPSLA '86 Proceedings, </booktitle> <volume> 21(11) </volume> <pages> 406-416, </pages> <month> November </month> <year> 1986. </year>
Reference-contexts: object is made or not and whether pointer swizzling is done at the time of loading or later when needed, there are a number of pointer swizzling techniques which are described in [16]. 2.4.2 Object Identity Identity is that property of an object which distinguishes each object from all others <ref> [11] </ref>. An identifier attached to an object for this purpose is called an object identifier (OID). An OID can be used to refer to an object. Providing objects with an identifier has a number of consequences. It means that an object has an existence independent of its value.
Reference: [12] <author> Won Kim. </author> <title> Introduction to Object-Oriented Databases. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts. </address>
Reference-contexts: more efficient. 5 One problem about OODBMSs is that a relatively small change in the data model may require substantial changes in the architecture of a database system, e.g., to implement metaclasses in an object-oriented data model, a number of different components of the system will have to be changed <ref> [12] </ref>. One way to address this problem is to define a storage-level subsystem (POS) as a kernel to support a large number of different object-oriented data models e.g., Mneme [17] supports both Smalltalk-80 and Modula-3.
Reference: [13] <author> Won Kim, Nat Ballou, Jay Banerjee, Hong-Tai Chou, Jorge F. Garza, and Darrell Woelk. </author> <title> Features of the Orion Object-Oriented Database System. </title> <booktitle> In The Proceedings of the 13th International VLDB Conference, </booktitle> <pages> pages 319-329, </pages> <year> 1987. </year>
Reference-contexts: Ontos has its own object SQL in which procedures can be called within a query statement and direct references in objects can be chained to any depth. These queries can be executed against the set of all instances of a class and aggregate objects. 2.5.10 Orion Orion <ref> [13] </ref> was developed by the Advanced Computer Technology Program at Microelectronics and Computer Technology Corporation. It was developed as a research vehicle for integration of object-oriented programming languages and databases for applications such as in AI, CAD/CAM, and office information system.
Reference: [14] <author> Charles Lamb, Gordon Landis, Jack Orenstein, and Dan Weinreb. </author> <title> The ObjectStore Database System. </title> <journal> Communications of the ACM, </journal> <volume> 34(10) </volume> <pages> 50-63, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: They generally proceed in distinct phases of loading large working sets, working, and saving. The relational model was not designed for such applications. Moreover, it was not designed to handle data types like voice, video, text, and images. Object-oriented databases (OODBs) <ref> [6, 10, 14, 21, 3] </ref> are designed to bring object-oriented technology into a DBMS and solve some of these problems. One of the main components of an OODB is a Persistent Object Store (POS). POSs support the creation, manipulation, storage, and retrieval of objects. <p> Most POSs recognize the need for distribution. 2.4.1 Memory Management There are two ways in which POSs provide memory management. One is through a procedural interface to the store that manages memory and the other is by mapping the memory into the application's address space <ref> [19, 14] </ref>. When an object is loaded into a process' address space from the disk, the object references inside this object must correspond to meaningful virtual memory addresses. <p> Queries can be executed against a set of instances of specified types and return a set of instances or a boolean value. ENCORE also supports indexing on data types and properties. 17 2.5.8 ObjectStore ObjectStore <ref> [14] </ref> was developed by Object Design, Inc. It provides a unified programmatic interface to both persistently allocated data and transiently allocated data, with object-access speed for persistent data usually equal to that of an in-memory dereference of a pointer to a transient data.
Reference: [15] <author> Carey M.J., Dewitt D.J., Richardson J.E., and Shekita E.J. </author> <title> Storage management for objects in EXODUS. </title> <editor> In W. Kim and F. H. Lochovsky, editors, </editor> <booktitle> Object-Oriented Concepts, Databases, and Applications, </booktitle> <address> New York, </address> <year> 1989. </year> <note> ACM Press/Addison-Wesley. </note>
Reference-contexts: OIDs can be logical [1, 17, 21] or based on physical identifiers <ref> [15] </ref>. Physical OIDs contain information about the object location on secondary storage within themselves whereas logical OIDs do not have such information. In the case of logical OIDs, a correspondence table is needed for mapping OIDs into actual physical locations. <p> As a result of Cricket's implementation as a Mach's external pager, concurrency control and recovery are also transparent to client applications. Cricket provides two-phase, page-level locking for clients. Index management, recovery, and distribution are still among the unresolved design issues. 2.5.2 Exodus Storage Manager The Exodus Storage Manager (ESM) <ref> [15] </ref> was developed at the University of Wisconsin, Madison. It provides a set of basic facilities for use across all applications.
Reference: [16] <author> J. Eliot B. Moss. </author> <title> Working with Persistent Objects: To swizzle or Not to swizzle. </title> <type> Technical report, </type> <institution> Department of Computer and Information Science, University of Massachusetts, </institution> <address> Amherst, MA 01003, </address> <year> 1989. </year>
Reference-contexts: This can 6 be achieved by introducing a level of indirection i.e., these object references are mapped through a correspondence table to derive actual object addresses. There is another technique, called "pointer swizzling" <ref> [16, 23] </ref> which some systems employ. In this scheme, the object reference is changed to a direct memory pointer in-place. <p> Depending on whether a new copy of the object is made or not and whether pointer swizzling is done at the time of loading or later when needed, there are a number of pointer swizzling techniques which are described in <ref> [16] </ref>. 2.4.2 Object Identity Identity is that property of an object which distinguishes each object from all others [11]. An identifier attached to an object for this purpose is called an object identifier (OID). An OID can be used to refer to an object.
Reference: [17] <author> J. Eliot B. Moss. </author> <title> Design of the Mneme Persistent Object Store. </title> <journal> ACM Transactions on Information Systems, </journal> <volume> 8(2) </volume> <pages> 103-139, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: There is a great deal of variation in terms of the amount of functionality supported by different POSs. One reason for this is that the demands of applications are not well understood. Because of this lack of knowledge, systems like Mneme <ref> [17] </ref> provide mechanisms, not policies, leaving these to be tuned, controlled, and extended by the application programmer. <p> One way to address this problem is to define a storage-level subsystem (POS) as a kernel to support a large number of different object-oriented data models e.g., Mneme <ref> [17] </ref> supports both Smalltalk-80 and Modula-3. Different applications can use a common POS by embedding any necessary mapping, like tranlating application object to POS object, in a separate layer or in the application itself. <p> Some systems provide an OID to each and every object while some provide OIDs only to objects which exist independently and these systems have an internal way of referring to objects which exist as components of these objects. OIDs can be logical <ref> [1, 17, 21] </ref> or based on physical identifiers [15]. Physical OIDs contain information about the object location on secondary storage within themselves whereas logical OIDs do not have such information. In the case of logical OIDs, a correspondence table is needed for mapping OIDs into actual physical locations. <p> It also has the notion of public and logically private databases. The Iris query language extends SQL in two ways: it provides direct references to objects instead of keys and allows functions to be called within WHERE and SELECT clauses. 13 2.5.5 Mneme Mneme <ref> [17] </ref> 1 is a research prototype that is being developed at the University of Massachusetts, Amherst. The Mneme store provides mechanisms whose policies can be changed and extended. This store is intended to be integrated with programming languages like Smalltalk-80 and Modula-3.
Reference: [18] <author> Cattell R.G.G. and J. Skeen. </author> <title> Object operations benchmark. </title> <journal> ACM Transactions on Database Systems. </journal>
Reference-contexts: However, many kinds of functionalities can be added in an application on top of a POS, but poor performance generally cannot be improved at the application level [7]. To measure the performance of OODBMSs, there already exists the Cattell benchmark <ref> [18] </ref>. It concentrates on areas where the highest performance is required e.g., inserting objects, looking up objects, and following connections between objects. It also assumes an "interactive" model for CAD applications. Modeling engineering OODBMS requirements in a generic way is very difficult, since every application has somewhat different requirements.
Reference: [19] <author> Eugene Shekita and Michael Zwilling. Cricket: </author> <title> A Mapped, Persistent Object Store. </title> <editor> In Alan Dearle, Gail M. Shaw, and Stanley B. Zdonik, editors, </editor> <title> Implementing Persistent Object Bases: </title> <booktitle> Principles and Practice. The Fourth International Workshop on Persistent Object Systems, </booktitle> <pages> pages 89-102, </pages> <address> Martha's Vineyard, Mass., </address> <month> Sept. </month> <pages> 23-27, </pages> <year> 1990, </year> <title> 1991. </title> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: Most POSs recognize the need for distribution. 2.4.1 Memory Management There are two ways in which POSs provide memory management. One is through a procedural interface to the store that manages memory and the other is by mapping the memory into the application's address space <ref> [19, 14] </ref>. When an object is loaded into a process' address space from the disk, the object references inside this object must correspond to meaningful virtual memory addresses. <p> Each description begins with a summary of where the system was developed and the language interfaces available. Next, support for object identity, memory management scheme, and available object manipulation mechanisms are described. Finally navigational support, schema evolution, distribution etc. are described. 9 2.5.1 Cricket Cricket <ref> [19] </ref> is a research prototype that was developed at the University of Wisconsin, Madison. It uses Mach's external pager facility to map memory into a user's address space and provides transparent persistence. Cricket uses virtual addresses as object identifiers.
Reference: [20] <author> Jacob Stein. </author> <title> OO DBMS: Object-Oriented Technologies for Complex Data-Management Systems. </title> <journal> SunWorld, </journal> <volume> 4(5) </volume> <pages> 73-84, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: An OID can be used to refer to an object. Providing objects with an identifier has a number of consequences. It means that an object has an existence independent of its value. It also enables two objects to share a common component <ref> [20] </ref>. Different systems provide different degrees of support for OIDs. Some systems provide an OID to each and every object while some provide OIDs only to objects which exist independently and these systems have an internal way of referring to objects which exist as components of these objects.
Reference: [21] <author> Michael Stonebraker. </author> <title> The Design of the Postgres Storage System. </title> <editor> In Michael Stonebraker and Lawrence A. Rowe, editors, </editor> <booktitle> The Postgres Papers, number UCB/ERL M86/85, </booktitle> <pages> pages 69-90. </pages> <institution> Electronics Research Laboratory, University of California, Berkeley, </institution> <month> June </month> <year> 1987. </year> <month> 93 </month>
Reference-contexts: They generally proceed in distinct phases of loading large working sets, working, and saving. The relational model was not designed for such applications. Moreover, it was not designed to handle data types like voice, video, text, and images. Object-oriented databases (OODBs) <ref> [6, 10, 14, 21, 3] </ref> are designed to bring object-oriented technology into a DBMS and solve some of these problems. One of the main components of an OODB is a Persistent Object Store (POS). POSs support the creation, manipulation, storage, and retrieval of objects. <p> Some systems provide an OID to each and every object while some provide OIDs only to objects which exist independently and these systems have an internal way of referring to objects which exist as components of these objects. OIDs can be logical <ref> [1, 17, 21] </ref> or based on physical identifiers [15]. Physical OIDs contain information about the object location on secondary storage within themselves whereas logical OIDs do not have such information. In the case of logical OIDs, a correspondence table is needed for mapping OIDs into actual physical locations. <p> Orion has its own query language. The scope of a query can be a private database, the shared database or both. 21 2.5.11 Postgres Postgres <ref> [21] </ref> was developed at the University of California, Berkeley. As the successor of the Ingres relational database system, Postgres extends it by adding classes, inheritance, types and functions. It is programming language neutral, i.e., it can be called from many different languages.
Reference: [22] <author> F. Velez, V. Darnis, D. Dewitt, P. Futtersack, G. Harrus, D. Mair, and M. Raoux. </author> <title> Implementing the O2 Object Manager : Some Lessons. </title> <editor> In Alan Dearle, Gail M. Shaw, and Stanley B. Zdonik, editors, </editor> <title> Implementing Persistent Object Bases: </title> <booktitle> Principles and Practice. The Fourth International Workshop on Persistent Object Systems, </booktitle> <pages> pages 131-140, </pages> <address> Martha's Vineyard, Mass., </address> <month> Sept. </month> <pages> 23-27, </pages> <year> 1990, </year> <title> 1991. </title> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: There are three different client/server architectures for POSs based on the granularity of data transfer <ref> [22] </ref>. These are object server, page server, and file server. Doing all computation on a centralized system leads to bottlenecks, whereas, distributed computation may not be able to take advantage of central indices and complex cache consistency systems may be required if there are multiple clients. <p> Notification has two aspects: registering interest in particular events and receiving notices of the events as they occur. For recovery, Mneme stores log information pertaining to a particular segment of data in the segment itself. 2.5.6 O2 O2 <ref> [22] </ref> was developed by the Altair research consortium, consisting of INRIA, Siemens-Nixdorf, Bull, the CNRS, and the University of Paris XI. It is an OODBMS with a complete development environment and a set of user interface tools. It has language interfaces to C and C++.

References-found: 22

