URL: http://www.cs.umd.edu/~hollings/dyninstAPI/rel1.0/dyninstUserGuide.ps.gz
Refering-URL: http://www.cs.umd.edu/~hollings/dyninstAPI/rel1.0/index.html
Root-URL: 
Email: hollings@cs.umd.edu  
Title: dyninstAPI 09/11/97 P a r a d n P a r a l l e
Author: Jeffrey K. Hollingsworth Bryan Buck 
Address: College Park, MD 20742  
Affiliation: Computer Science Department University of Maryland  
Date: September 1997  
Pubnum: 1.0  
Abstract-found: 0
Intro-found: 1
Reference: 1. <author> J. K. Hollingsworth and B. P. Miller, </author> <title> An Adaptive Cost Model for Parallel Program Instrumentation, </title> <booktitle> Euro Par96. </booktitle> <month> Aug, </month> <year> 1996, </year> <title> Lyon, </title> <booktitle> France, vol.I, </booktitle> <pages> pp. 88-98. </pages>
Reference-contexts: The problems with accurately estimating the cost of executing code are numerous and out of the scope of this document <ref> [1] </ref>. But, it is important to realize that the returned cost value is (at best) an estimate. The rest of the classes are derived classes of the class BPatch_snippet. BPatch_arithExpr (BPatch_binOp op, const BPatch_snippet &lOperand, const BPatch_snippet &rOperand) Perform the required binary operation. <p> #include &lt;stdio.h&gt; #include &lt;fcntl.h&gt; #include "BPatch.h" #include "BPatch_Vector.h" #include "BPatch_thread.h" BPatch bpatch; main (int argc, char *argv []) - if (argc != 4) - fprintf (stderr, "Usage: %s prog_filename pid log_filename"n",argv [0]); exit (1); - pid = atoi (argv [2]); // Attach to the program BPatch_thread *appThread = bpatch.attachProcess (argv <ref> [1] </ref>, pid); // Read the program's image and get an associated image object BPatch_image *appImage = appThread-&gt;getImage (); // Find the entry point to the procedure "write" BPatch_Vector&lt;BPatch_point *&gt; *points = appImage-&gt;findProcedurePoint ("write", BPatch_entry); if ((*points).size () == 0) - fprintf (stderr, "Unable to find entry point to ""write."""n"); exit (1);
Reference: 2. <author> J. K. Hollingsworth, B. P. Miller, and J. Cargille, </author> <title> Dynamic Program Instrumentation for Scalable Perfor m ance Tools, </title> <booktitle> 1994 Scalable High-Performance Computing Conf., Knoxville, Tenn., </booktitle> <pages> pp. 841-850. </pages>
Reference-contexts: The goal of this API is to provide a machine independent interface to permit the creation of tools and applications that use runtime code patching. This API is based on the idea of Dynamic Instrumentation described in <ref> [2] </ref>. The unique feature of this interface is that it makes it possible to insert and change instrument a-tion in a running program. This differs from other post-linker instrumentation tools [3] that permit code to be inserted into a binary before it starts to execute. <p> that output in a file without having to rerun the program. #include &lt;stdio.h&gt; #include &lt;fcntl.h&gt; #include "BPatch.h" #include "BPatch_Vector.h" #include "BPatch_thread.h" BPatch bpatch; main (int argc, char *argv []) - if (argc != 4) - fprintf (stderr, "Usage: %s prog_filename pid log_filename"n",argv [0]); exit (1); - pid = atoi (argv <ref> [2] </ref>); // Attach to the program BPatch_thread *appThread = bpatch.attachProcess (argv [1], pid); // Read the program's image and get an associated image object BPatch_image *appImage = appThread-&gt;getImage (); // Find the entry point to the procedure "write" BPatch_Vector&lt;BPatch_point *&gt; *points = appImage-&gt;findProcedurePoint ("write", BPatch_entry); if ((*points).size () == 0) -
Reference: 3. <author> J. R. Larus and E. Schnarr, EEL: </author> <title> Machine-Independent Executable Editing, </title> <booktitle> PLDI. </booktitle> <address> June 18-21, 1995, La Jolla, CA, </address> <pages> pp. 291-300. </pages>
Reference-contexts: This API is based on the idea of Dynamic Instrumentation described in [2]. The unique feature of this interface is that it makes it possible to insert and change instrument a-tion in a running program. This differs from other post-linker instrumentation tools <ref> [3] </ref> that permit code to be inserted into a binary before it starts to execute. The goal of this API is to keep the interface small and easy to understand. At the same time it needs to be sufficiently expressive to be useful for a variety of applications. <p> = appImage-&gt;findProcedurePoint ("write", BPatch_entry); if ((*points).size () == 0) - fprintf (stderr, "Unable to find entry point to ""write."""n"); exit (1); - // Create code to open a file and save the returned file descriptor // Open the file BPatch_function *openFunc = appImage-&gt;findFunction ("open"); BPatch_Vector&lt;BPatch_snippet *&gt; openArgs; BPatch_constExpr fileName (argv <ref> [3] </ref>); BPatch_constExpr fileFlags (O_WRONLY|O_CREAT); BPatch_constExpr fileMode (0666); openArgs.push_back (&fileName); openArgs.push_back (&fileFlags); openArgs.push_back (&fileMode); BPatch_funcCallExpr openCall (*openFunc, openArgs); // Save the descriptor BPatch_variableExpr *fdVar = appThread-&gt;malloc (*appImage-&gt;findType ("int")); BPatch_arithExpr openFile (BPatch_assign, *fdVar, openCall); // Generate code that opens the file the first time it is called.
References-found: 3

