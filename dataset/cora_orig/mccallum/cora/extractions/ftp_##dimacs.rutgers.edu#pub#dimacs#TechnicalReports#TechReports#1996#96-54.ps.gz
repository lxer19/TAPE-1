URL: ftp://dimacs.rutgers.edu/pub/dimacs/TechnicalReports/TechReports/1996/96-54.ps.gz
Refering-URL: http://dimacs.rutgers.edu/TechnicalReports/1996.html
Root-URL: http://www.cs.rutgers.edu
Email: Email: marek@cs.uni-bonn.de  Email:larmore@cs.unlv.edu  
Phone: 2  3  
Title: Correctness of Constructing Optimal Alphabetic Trees Revisited  
Author: by Marek Karpinski Lawrence L. Larmore Wojciech Rytter ; 
Web: CCR-9503441.  
Address: Nevada, Las Vegas, NV 89154-4019, USA.  Warsaw, 02-097 Warszawa.  
Affiliation: Science Institute, Berkeley.  Dept. of Computer Science, Princeton University.  Department of Computer Science, University of  Dept. of Computer Science, University of  
Date: 1996  
Note: December  Research partially done while visiting  Research supported by DFG Grant KA 673/4-1, and by the ESPRIT BR Grants 7097 and EC-US 030 and by DIMACS.  Partially supported by National Science Foundation grants CCR-9112067 and  Supported by the grant KBN 8T11C01208. Email:rytter@mimuw.edu.pl DIMACS is a partnership of Rutgers University, Princeton University, AT&T Research, Bellcore, and Bell Laboratories. DIMACS is an NSF Science and Technology Center, funded under contract STC-91-19999; and also receives support from the New Jersey Commission on Science and Technology.  
Abstract: DIMACS Technical Report 96-54 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. M. Garsia and M. L. Wachs, </author> <title> A new algorithm for minimal binary search trees, </title> <journal> SIAM Journal of Computing 6 (1977), </journal> <pages> pp. 622-642. </pages>
Reference-contexts: 1 Introduction Recently, there has been a renewed interest in the problem of construction of optimal alphabetic trees [6, 10, 11, 12]. The Hu-Tucker (HT) algorithm [3] is a celebrated classical algorithm for this problem, whose correctness is not widely understood. The Garsia-Wachs (GW) algorithm <ref> [1] </ref>, has a simpler but still very technical proof based on several formal claims proved simultaneously by induction. <p> This follows from the following simple observation on base 2 representations of integers: - 11 - Remark 5.2 Assume that 0 a i ; b i 1 for i 2 <ref> [1; : : : ; n] </ref> and that the sets A = fi : a i 6= 0g and B = fi : b i 6= 0g are disjoint, then n X a i (2 2ni ) &lt; i=1 Hence the rule TBR breaks ties in the same way in the
Reference: [2] <author> T. C. Hu. </author> <title> A new proof of the T-C algorithm, </title> <journal> SIAM Journal of Applied Mathematics 25 (1973), </journal> <pages> pp. 83-94. </pages>
Reference: [3] <author> T. C. Hu and A. C. Tucker, </author> <title> Optimal computer search trees and variable length alphabetic codes, </title> <journal> SIAM Journal of Applied Mathematics 21 (1971), </journal> <pages> pp. 514-532. </pages>
Reference-contexts: 1 Introduction Recently, there has been a renewed interest in the problem of construction of optimal alphabetic trees [6, 10, 11, 12]. The Hu-Tucker (HT) algorithm <ref> [3] </ref> is a celebrated classical algorithm for this problem, whose correctness is not widely understood. The Garsia-Wachs (GW) algorithm [1], has a simpler but still very technical proof based on several formal claims proved simultaneously by induction.
Reference: [4] <author> D. A. Huffman. </author> <title> A method for the constructing of minimum redundancy codes, </title> <booktitle> Proceedings of the IRE 40 (1952), </booktitle> <pages> pp. 1098-1101. </pages>
Reference: [5] <author> J. H. Kingston, </author> <title> A new proof of the Garsia-Wachs algorithm, </title> <note> Journal of Algorithms 9 (1988) pp. 129-136. </note>
Reference-contexts: This general version is also needed in our parallel implementations (see [11]). A restricted version of the GW algorithm (for rightmost minimal pairs) was considered in <ref> [5] </ref>. The aim of this paper is to provide proofs of correctness of both the HT and the GW algorithms that are more structural than those in the original papers. The simplicity of the description of both algorithms is misleading. The original correctness proofs are very intricate.
Reference: [6] <author> M. M. Klawe and B. Mumey, </author> <title> Upper and Lower Bounds on Constructing Alphabetic Binary Trees, </title> <booktitle> Proceedings of the 4 th ACM-SIAM Symposium on Discrete Algorithms (1993), </booktitle> <pages> pp. 185-193. </pages>
Reference-contexts: 1 Introduction Recently, there has been a renewed interest in the problem of construction of optimal alphabetic trees <ref> [6, 10, 11, 12] </ref>. The Hu-Tucker (HT) algorithm [3] is a celebrated classical algorithm for this problem, whose correctness is not widely understood. The Garsia-Wachs (GW) algorithm [1], has a simpler but still very technical proof based on several formal claims proved simultaneously by induction. <p> Even a minimal pair may not be siblings. Consider the weight sequence (8 7 7 8). The second and the third items are not siblings in any optimal alphabetic tree. Instead, the HT and GW algorithms, as well as the algorithms of <ref> [6, 10, 11, 12] </ref>, operate by identifying a pair of items that have the same level in the optimal tree. These items are then combined into a single "package," reducing the number of items by one.
Reference: [7] <author> D. E. Knuth, </author> <booktitle> The Art of Computer Programming, </booktitle> <publisher> Addison-Wesley (1973). </publisher>
Reference: [8] <author> D. E. Knuth, </author> <title> Optimum binary search trees, </title> <journal> Acta Informatica 1 (1971) pp. </journal> <pages> 14-25. </pages>
Reference: [9] <author> L. L. Larmore and D. S. Hirschberg, </author> <title> A fast algorithm for optimal length-limited Huffman codes, </title> <journal> Journal of the ACM 37 (1990), </journal> <pages> pp. 464-473. </pages>
Reference: [10] <author> L. L. Larmore and T. M. Przytycka, </author> <title> The optimal alphabetic tree problem revisited, </title> <booktitle> Proceedings of the 21 st International Colloquium, </booktitle> <address> ICALP'94, Jerusalem, </address> <publisher> LNCS 820, Springer-Verlag, </publisher> <year> (1994), </year> <pages> pp. 251-262. </pages>
Reference-contexts: 1 Introduction Recently, there has been a renewed interest in the problem of construction of optimal alphabetic trees <ref> [6, 10, 11, 12] </ref>. The Hu-Tucker (HT) algorithm [3] is a celebrated classical algorithm for this problem, whose correctness is not widely understood. The Garsia-Wachs (GW) algorithm [1], has a simpler but still very technical proof based on several formal claims proved simultaneously by induction. <p> Even a minimal pair may not be siblings. Consider the weight sequence (8 7 7 8). The second and the third items are not siblings in any optimal alphabetic tree. Instead, the HT and GW algorithms, as well as the algorithms of <ref> [6, 10, 11, 12] </ref>, operate by identifying a pair of items that have the same level in the optimal tree. These items are then combined into a single "package," reducing the number of items by one. <p> Then we can assume, without loss of generality, that there are no ties during execution of the GW algorithm. The method does not use infinitesimals; only additional comparisons between positions of items are involved. This is useful in many situations, see <ref> [10, 11] </ref>.
Reference: [11] <author> L. L. Larmore, T. M. Przytycka, and W. Rytter, </author> <title> Parallel construction of optimal alphabetic trees, </title> <booktitle> Proceedings of the 5 th ACM Symposium on Parallel Algorithms and Architectures (1993), </booktitle> <pages> pp. 214-223. - 13 </pages> - 
Reference-contexts: 1 Introduction Recently, there has been a renewed interest in the problem of construction of optimal alphabetic trees <ref> [6, 10, 11, 12] </ref>. The Hu-Tucker (HT) algorithm [3] is a celebrated classical algorithm for this problem, whose correctness is not widely understood. The Garsia-Wachs (GW) algorithm [1], has a simpler but still very technical proof based on several formal claims proved simultaneously by induction. <p> Our proof of correctness of the HT algorithm works by reducing to correctness of a general version of the GW algorithm in which any locally minimal pair is processed, not necessarily the rightmost one. This general version is also needed in our parallel implementations (see <ref> [11] </ref>). A restricted version of the GW algorithm (for rightmost minimal pairs) was considered in [5]. The aim of this paper is to provide proofs of correctness of both the HT and the GW algorithms that are more structural than those in the original papers. <p> Even a minimal pair may not be siblings. Consider the weight sequence (8 7 7 8). The second and the third items are not siblings in any optimal alphabetic tree. Instead, the HT and GW algorithms, as well as the algorithms of <ref> [6, 10, 11, 12] </ref>, operate by identifying a pair of items that have the same level in the optimal tree. These items are then combined into a single "package," reducing the number of items by one. <p> Then we can assume, without loss of generality, that there are no ties during execution of the GW algorithm. The method does not use infinitesimals; only additional comparisons between positions of items are involved. This is useful in many situations, see <ref> [10, 11] </ref>.
Reference: [12] <author> P. Ramanan, </author> <title> Testing the optimality of alphabetic trees, </title> <booktitle> Theoretical Computer Science 93 (1992), </booktitle> <pages> pp. 279-301. </pages>
Reference-contexts: 1 Introduction Recently, there has been a renewed interest in the problem of construction of optimal alphabetic trees <ref> [6, 10, 11, 12] </ref>. The Hu-Tucker (HT) algorithm [3] is a celebrated classical algorithm for this problem, whose correctness is not widely understood. The Garsia-Wachs (GW) algorithm [1], has a simpler but still very technical proof based on several formal claims proved simultaneously by induction. <p> Even a minimal pair may not be siblings. Consider the weight sequence (8 7 7 8). The second and the third items are not siblings in any optimal alphabetic tree. Instead, the HT and GW algorithms, as well as the algorithms of <ref> [6, 10, 11, 12] </ref>, operate by identifying a pair of items that have the same level in the optimal tree. These items are then combined into a single "package," reducing the number of items by one.
Reference: [13] <author> F. F. Yao, </author> <title> Efficient dynamic programming using quadrangle inequalities, </title> <booktitle> Proceedings of the 12 th ACM Symposium on Theory of Computing (1980), </booktitle> <pages> pp. 429-435. - 14 </pages> -
References-found: 13

