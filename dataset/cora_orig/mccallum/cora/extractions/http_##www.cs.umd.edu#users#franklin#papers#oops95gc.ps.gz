URL: http://www.cs.umd.edu/users/franklin/papers/oops95gc.ps.gz
Refering-URL: http://www.cs.umd.edu/~franklin/papers.html
Root-URL: 
Email: Laurent.Amsaleg@inria.fr  Paulo.Ferreira@inria.fr  franklin@cs.umd.edu  Marc.Shapiro@inria.fr  
Title: Evaluating Garbage Collectors for Large Persistent Stores  
Author: Laurent Amsaleg Paulo Ferreira Michael Franklin Marc Shapiro 
Address: Rocquencourt  Rocquencourt  Rocquencourt  
Affiliation: INRIA  INRIA  University of Maryland  INRIA  
Abstract: We present some results and raise some issues regarding benchmarks for evaluating garbage collection in persistent distributed stores. We believe that such issues are relevant due to increasing research activity in this domain. Therefore, defining widely accepted benchmarks to evaluate the performance and impact of garbage collection solutions is urgent. Currently, the performance of garbage collectors is measured using synthetic, often unportable and/or controversial benchmarks, making the relative evaluation of each solution almost impossible. In addition, there is a lack of knowledge on the behavior of real applications, e.g., amount of garbage, rate of death, etc. This paper outlines our experience on benchmarking our prototypes. We also report what we think is relevant to measure and which missing information we would like to obtain.
Abstract-found: 1
Intro-found: 1
Reference: [ABC + 83] <author> M. Atkinson, P. Bailey, K. Chisholm, P. Cockshott, and R. Morrison. </author> <title> An Approach to Persistent Programming. </title> <journal> Computer Journal, </journal> <volume> 26(4) </volume> <pages> 360-365, </pages> <year> 1983. </year>
Reference-contexts: The sharing of data and long-term persistence that are offered by these systems increases the potential damage caused by storage management errors, as mistakes made by one program can affect others. In addition, GC is needed to support persistence by reachability <ref> [ABC + 83, ZM90] </ref>. By traversing the objects graph starting from some persistent roots, the collector is able to distinguish reachable (live) objects from unreachable (garbage) objects which can then be safely reclaimed.
Reference: [AFG95] <author> L. Amsaleg, M. Franklin, and O. Gruber. </author> <title> Efficient Incremental Garbage Collection for Client-Server Object Database Systems. </title> <booktitle> In Proc. of the 21th VLDB Int. Conf., </booktitle> <address> Zurich, Switzerland, </address> <month> September </month> <year> 1995. </year>
Reference-contexts: In this paper, we briefly describe two GC solutions, one for Object Oriented Database Management Systems (OODBMS) and another for Persistent Distributed Shared Memory Stores. Details on these algorithms can be found in <ref> [AFG95] </ref> and [FS94, FS95]. Our main goals in designing GC algorithms was to make them unobtrusive, scalable, safe, and, as far as possible, complete. Within a persistent environment, such a goal renders traditional GC approaches incorrect (they eventually reclaim live objects) and/or inefficient. <p> In this paper, 1 we report our experiences gained from measuring our prototypes, and use this experience to identify those missing measurements that we think are relevant. 2 Garbage Collecting Client-Server OODBMS We have developed a server-based GC designed to work in the specific context of client-server OODBMS <ref> [AFG95] </ref>. We consider page servers that provide efficient and flexible features like inter-transaction caching, write-ahead-logging (WAL) based recovery, "steal-based" management of clients' buffers and 2-phase page-level locking. This flexibility, while providing opportunities for improved performance, also raises potential problems for garbage collection algorithms.
Reference: [BD90] <author> V. Benzaken and C. Delobel. </author> <title> Enhancing Performance in a Persistent Object Store: </title> <booktitle> Clustering Strategies in O 2 . In 4th Int. Workshop on Persistent Object Systems, </booktitle> <pages> pages 403-412, </pages> <address> Martha-Vineyard, Massachusetts, </address> <month> September </month> <year> 1990. </year>
Reference-contexts: Clustering has a significant impact of the performance of both the collector and the applications. However, the (re)clustering produced by a copying-based collector may be in conflict with database requirements or user-specified hints (e.g., <ref> [BD90, GA94] </ref>). For example, generational collectors tend to cluster objects based on their age. After a GC, objects must still be clustered with respect to application needs. No implemented copying-based GC follows this fundamental requirement. * Caching and Prefetching. Concurrent execution of the GC and user programs impact caching.
Reference: [CDN93] <author> M. Carey, D. DeWitt, and J. Naughton. </author> <title> The OO7 Benchmark. </title> <booktitle> In Proc. of the ACM SIGMOD Int. Conf, </booktitle> <pages> pages 12-21, </pages> <address> Washington D.C., </address> <month> May </month> <year> 1993. </year>
Reference-contexts: Consequently, some collectors are evaluated through the use of an extended version of a standard database benchmark such as 007 <ref> [CDN93] </ref>. The extension usually consists in some temporal evolution of the contents of the database, i.e., creating new objects and/or generating some garbage. However, what drives this evolution is often random values choosen in between arbitrary boundaries.
Reference: [CKWZ94] <author> J. Cook, A. Klauser, A. Wolf, and B. Zorn. </author> <title> Effectively Controlling Garbage Collection Rates in Object Databases. </title> <type> Technical Report CU-CS-758-94, </type> <institution> University of Colorado at Boulder, Boulder, Colorado, </institution> <month> October </month> <year> 1994. </year>
Reference-contexts: Rates of GC directly impact performance. Too frequent or too rare collections both have a negative effect on performance. Smart policies driven by the behavior of applications may help (e.g., <ref> [CKWZ94] </ref>). 4.2.3 How to Get these Measurements? Because we are measuring the impact of GC on applications, "real-world" benchmarks seem to be useful. Consequently, some collectors are evaluated through the use of an extended version of a standard database benchmark such as 007 [CDN93].
Reference: [CWZ94] <author> J. Cook, A. Wolf, and B. Zorn. </author> <title> Partition Selection Policies in Object Database Garbage Collection. </title> <booktitle> In Proc. of the ACM SIGMOD Int. Conf., </booktitle> <pages> pages 371-382, </pages> <address> Mineapolis, Minnesota, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: Inactive (or less inten sive) periods may be preferably used by the collector. * Choosing the Optimal Partition. Randomly choosing the partition to collect may not be a good idea. Some heuristics that evaluate the volume of garbage generated by reference updates may improve performance (e.g., <ref> [CWZ94] </ref>). * Choosing the Right Collection Frequency. Rates of GC directly impact performance. Too frequent or too rare collections both have a negative effect on performance.
Reference: [FS94] <author> P. Ferreira and M. Shapiro. </author> <title> Garbage Collection and DSM Consistency. </title> <booktitle> In Proc. of the First Symposium on Operating Systems Design and Implementation (OSDI), </booktitle> <pages> pages 229-241, </pages> <address> Monterey, California, </address> <month> November </month> <year> 1994. </year> <note> ACM. </note>
Reference-contexts: In this paper, we briefly describe two GC solutions, one for Object Oriented Database Management Systems (OODBMS) and another for Persistent Distributed Shared Memory Stores. Details on these algorithms can be found in [AFG95] and <ref> [FS94, FS95] </ref>. Our main goals in designing GC algorithms was to make them unobtrusive, scalable, safe, and, as far as possible, complete. Within a persistent environment, such a goal renders traditional GC approaches incorrect (they eventually reclaim live objects) and/or inefficient. <p> caching at clients and "steal" buffer management between clients and servers. 3 Garbage Collecting Persistent Distributed Shared Memory Sys tems In the Larchant project, we designed and implemented a distributed shared memory (DSM) with tracing garbage collection in order to provide persistence by reachability (PBR) in a large-scale distributed system <ref> [FS94, FS95] </ref>. Within a general model of DSM, we specified a distributed tracing GC algorithm that scales, collects cycles, and is orthogonal to coherence.
Reference: [FS95] <author> P. Ferreira and M. Shapiro. </author> <title> Garbage Collection in the Larchant Persistent Distributed Shared Store. </title> <booktitle> In 5th Workshop on Future Trends in Distributed Computing Systems (FTDCS '95), </booktitle> <address> Cheju Island (Korea), </address> <month> August </month> <year> 1995. </year>
Reference-contexts: In this paper, we briefly describe two GC solutions, one for Object Oriented Database Management Systems (OODBMS) and another for Persistent Distributed Shared Memory Stores. Details on these algorithms can be found in [AFG95] and <ref> [FS94, FS95] </ref>. Our main goals in designing GC algorithms was to make them unobtrusive, scalable, safe, and, as far as possible, complete. Within a persistent environment, such a goal renders traditional GC approaches incorrect (they eventually reclaim live objects) and/or inefficient. <p> caching at clients and "steal" buffer management between clients and servers. 3 Garbage Collecting Persistent Distributed Shared Memory Sys tems In the Larchant project, we designed and implemented a distributed shared memory (DSM) with tracing garbage collection in order to provide persistence by reachability (PBR) in a large-scale distributed system <ref> [FS94, FS95] </ref>. Within a general model of DSM, we specified a distributed tracing GC algorithm that scales, collects cycles, and is orthogonal to coherence.
Reference: [GA94] <author> O. Gruber and L. </author> <title> Amsaleg. </title> <booktitle> Object Grouping in Eos, </booktitle> <pages> pages 117-131. </pages> <note> In [ODV94], </note> <month> May </month> <year> 1994. </year>
Reference-contexts: Clustering has a significant impact of the performance of both the collector and the applications. However, the (re)clustering produced by a copying-based collector may be in conflict with database requirements or user-specified hints (e.g., <ref> [BD90, GA94] </ref>). For example, generational collectors tend to cluster objects based on their age. After a GC, objects must still be clustered with respect to application needs. No implemented copying-based GC follows this fundamental requirement. * Caching and Prefetching. Concurrent execution of the GC and user programs impact caching.
Reference: [Gro93] <author> EXODUS Project Group. </author> <title> EXODUS Storage Manager Architectural Overview, </title> <year> 1993. </year>
Reference-contexts: This flexibility, while providing opportunities for improved performance, also raises potential problems for garbage collection algorithms. To validate our ideas, we integrated (and measured) our scheme in the EXODUS storage manager <ref> [Gro93] </ref>. Our garbage collector has the main following characteristics: * It is based on a Mark and Sweep approach. This approach can be more efficient and easier to integrate into an existing OODBMS.
Reference: [ODV94] <author> T. Ozsu, U. Dayal, and P. Valduriez. </author> <title> Distributed Object Management. </title> <address> Morgan-Kaufman, San Mateo, California, </address> <month> May </month> <year> 1994. </year>
Reference: [Wil92] <author> P. Wilson. </author> <title> Uniprocessor Garbage Collection Techniques. </title> <booktitle> In Int. Workshop on Memory Management, volume 637 of Lecture Notes in Computer Science, </booktitle> <pages> pages 1-43, </pages> <address> St. Malo, France, </address> <month> September </month> <year> 1992. </year> <note> Springer-Verlag. </note>
Reference-contexts: 1 Introduction It has long been recognized that explicit storage management (e.g., malloc () and free ()) increases code complexity and is highly error-prone, raising the risk of memory leaks and dangling pointers. For these reasons garbage collection (GC) for programming languages has long been an active area of research <ref> [Wil92] </ref>. Persistent Distributed Stores provides further motivation for the need for GC. The sharing of data and long-term persistence that are offered by these systems increases the potential damage caused by storage management errors, as mistakes made by one program can affect others.
Reference: [ZM90] <author> S. Zdonik and D. Maier. </author> <title> Readings in Object-Oriented Database Systems. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, California, </address> <year> 1990. </year> <month> 7 </month>
Reference-contexts: The sharing of data and long-term persistence that are offered by these systems increases the potential damage caused by storage management errors, as mistakes made by one program can affect others. In addition, GC is needed to support persistence by reachability <ref> [ABC + 83, ZM90] </ref>. By traversing the objects graph starting from some persistent roots, the collector is able to distinguish reachable (live) objects from unreachable (garbage) objects which can then be safely reclaimed.
References-found: 13

