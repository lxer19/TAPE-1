URL: ftp://ftp.cs.uoregon.edu/pub/ariola/acta.ps
Refering-URL: http://www.cs.uoregon.edu/~ariola/publications.html
Root-URL: http://www.cs.uoregon.edu
Email: ariola@cs.uoregon.edu jwk@cwi.nl  
Title: Equational Term Graph Rewriting  
Author: Zena M. Ariola Jan Willem Klop 
Address: Eugene, OR 97401 Amsterdam, The Netherlands  
Affiliation: Computer Information Science Dept. Dept. of Software Technology, CWI University of Oregon Dept. of Computer Science, Free University  
Abstract: We present an equational framework for term graph rewriting with cycles. The usual notion of homomorphism is phrased in terms of the notion of bisimulation, which is well-known in process algebra and concurrency theory. Specifically, a homomorphism is a functional bisimulation. We prove that the bisimilarity class of a term graph, partially ordered by functional bisimulation, is a complete lattice. It is shown how Equational Logic induces a notion of copying and substitution on term graphs, or systems of recursion equations, and also suggests the introduction of hidden or nameless nodes in a term graph. Hidden nodes can be used only once. The general framework of term graphs with copying is compared with the more restricted copying facilities embodied in the -rule. Next, orthogonal term graph rewrite systems, also in the presence of copying and hidden nodes, are shown to be confluent.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi, L. Cardelli, P.-L. Curien, and J.-J. Levy. </author> <title> Explicit substitutions. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(1) </volume> <pages> 375-416, </pages> <year> 1991. </year> <month> 25 </month>
Reference-contexts: We are also interested in extending the framework to accommodate cyclic -graphs, an endeavor that can be seen as an extension of the work on the -calculi (-calculi with explicit substitution) <ref> [1, 17, 25, 36, 45] </ref>. However, the latter concern acyclic substitutions only, while we aim at a calculus allowing cyclic substitutions. A preliminary study appears in [5]. Furthermore, we intend to study the suitability of equational graph rewriting for expressing side-effect operations.
Reference: [2] <author> Z. M. Ariola. </author> <title> An Algebraic Approach to the Compilation and Operational Semantics of Functional Languages with I-structures. </title> <type> PhD thesis, MIT Technical Report TR-544, </type> <year> 1992. </year>
Reference-contexts: Only in the last few years a firm foundation of cyclic term graph rewriting has been given, with as a main theorem the confluence property for orthogonal term graph rewriting. Establishing confluence was not altogether trivial since it faced the need for solving the problem of cyclic collapsing terms <ref> [2, 3, 22] </ref>. Previous definitions of term graph rewriting tend to use one of two ways: (1) category-theory oriented [28, 29, 30, 44], (2) implementation-oriented [42]. <p> A functional bisimulation is what in the literature [9, 48] is called a rooted homomorphism; it collapses (compresses) the graph to a smaller one. Vice versa we say that the graph is `expanded', and this is the `copying' or `unsharing' or `unwinding' partial order appearing in <ref> [2, 3, 4] </ref>. See Figure 5, where some unwindings of the graph fff = F (ff)g are considered. We use the notation (n; m) to indicate the unwinding of this graph starting with n `acyclic steps' followed by a cycle of m steps (n 0; m 1). <p> Thus, detection of a redex boils down to matching parts of a system of recursion equa tions. If ff is the root of a redex in g we also write g C [ff = t], where C <ref> [2] </ref> is the usual notation for a context. Definition 5.9 Let (t; ff; ) be a redex occurring in g. Let t : l ! r, g C [ff = t].
Reference: [3] <author> Z. M. Ariola. </author> <title> Relating graph and term rewriting via Bohm models. </title> <editor> In C. Kirchner, editor, </editor> <booktitle> Proc. 5th International Conference on Rewriting Techniques and Applications (RTA-93), </booktitle> <address> Montreal, Canada, </address> <publisher> Springer-Verlag LNCS 690, </publisher> <pages> pages 183-197, </pages> <year> 1993. </year>
Reference-contexts: 1 Typical results are confluence, when an orthogonality restraint is imposed (rules can-not interfere badly with each other) [48], modularity for properties such as confluence and termination (the properties stay preserved in combinations of systems) [43], and adequacy (in what sense is term graph rewriting adequate for ordinary term rewriting) <ref> [3, 32] </ref>. Term graph rewriting with cycles goes one step further by admitting cyclic term graphs. These arise naturally when dealing with recursive structures. Classical is the implementation by D. Turner [49] of the fixed point combinator Y by means of a cyclic graph (Figure 1). <p> Only in the last few years a firm foundation of cyclic term graph rewriting has been given, with as a main theorem the confluence property for orthogonal term graph rewriting. Establishing confluence was not altogether trivial since it faced the need for solving the problem of cyclic collapsing terms <ref> [2, 3, 22] </ref>. Previous definitions of term graph rewriting tend to use one of two ways: (1) category-theory oriented [28, 29, 30, 44], (2) implementation-oriented [42]. <p> A functional bisimulation is what in the literature [9, 48] is called a rooted homomorphism; it collapses (compresses) the graph to a smaller one. Vice versa we say that the graph is `expanded', and this is the `copying' or `unsharing' or `unwinding' partial order appearing in <ref> [2, 3, 4] </ref>. See Figure 5, where some unwindings of the graph fff = F (ff)g are considered. We use the notation (n; m) to indicate the unwinding of this graph starting with n `acyclic steps' followed by a cycle of m steps (n 0; m 1).
Reference: [4] <author> Z. M. Ariola and Arvind. </author> <title> Graph rewriting systems for efficient compilation. </title> <editor> In M. R. Sleep, M. J. Plasmeijer, and M. C. D. J. van Eekelen, editors, </editor> <title> Term Graph Rewriting: </title> <journal> Theory and Practice, </journal> <pages> pages 77-90. </pages> <publisher> John Wiley & Sons, </publisher> <year> 1993. </year>
Reference-contexts: A functional bisimulation is what in the literature [9, 48] is called a rooted homomorphism; it collapses (compresses) the graph to a smaller one. Vice versa we say that the graph is `expanded', and this is the `copying' or `unsharing' or `unwinding' partial order appearing in <ref> [2, 3, 4] </ref>. See Figure 5, where some unwindings of the graph fff = F (ff)g are considered. We use the notation (n; m) to indicate the unwinding of this graph starting with n `acyclic steps' followed by a cycle of m steps (n 0; m 1).
Reference: [5] <author> Z. M. Ariola and J. W. Klop. </author> <title> Cyclic lambda graph rewriting. </title> <booktitle> In Proc. Ninth Symposium on Logic in Computer Science (LICS'94), Paris, France, </booktitle> <pages> pages 416-425, </pages> <year> 1994. </year>
Reference-contexts: However, the latter concern acyclic substitutions only, while we aim at a calculus allowing cyclic substitutions. A preliminary study appears in <ref> [5] </ref>. Furthermore, we intend to study the suitability of equational graph rewriting for expressing side-effect operations. To that end, an extension is needed to include both rules and terms with multiple roots.
Reference: [6] <author> Z. M. Ariola and J. W. Klop. </author> <title> Equational term graph rewriting. </title> <type> Technical report, </type> <institution> CWI, </institution> <address> Amsterdam, </address> <publisher> forthcoming. </publisher>
Reference-contexts: The observation that copying does not destroy confluence was already shown in [48] for acyclic terms. We end the paper with directions for future work. The reader may refer to <ref> [6] </ref> for the proofs omitted in this paper. 2 Term rewriting with -recursion Although we will deal mostly with rewriting of systems of recursion equations, we start with the related format of -expressions and the -rule. <p> This raises the desire of finding a calculus for term graph rewriting that combines the simplicity of term rewriting with the ability to express the different forms of sharing that arise in common implementations of functional languages (i.e., horizontal and vertical sharing). Presently we are elaborating (in <ref> [6] </ref>) a framework employing nested systems of recursion equations that seems promising in this respect. To design and understand such a framework, an analysis of fundamental operations on term graphs such as copying, substitution, flattening and hiding as in Section 4 of this paper is indispensable.
Reference: [7] <author> J. C. M. Baeten and W. P. Weijland. </author> <title> Process Algebra. </title> <publisher> Cambridge University Press, </publisher> <year> 1990. </year>
Reference-contexts: Specifically we introduce 5 the notion of bisimilarity of systems of recursion equations. This notion is well-known from the theory of processes (or `concurrency' or `communicating processes' or `process algebra') see Milner [40], Baeten & Weijland <ref> [7] </ref>.
Reference: [8] <author> H. P. Barendregt. </author> <title> The Lambda Calculus: Its Syntax and Semantics. </title> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1984. </year>
Reference-contexts: 1 Introduction Term rewriting can be divided roughly in first-order term rewriting [20, 34], where first-order terms are replaced (reduced, rewritten) according to a fixed set of rewrite rules, and higher-order term rewriting, of which the paradigm is lambda calculus <ref> [8] </ref>. The distinctive feature of the latter is the presence of bound variables. Term rewriting has become in the last decade a firmly established discipline, with applications in many areas [11] such as abstract data types, functional programming, automated theorem proving, and proof theory.
Reference: [9] <author> H. P. Barendregt, M. C. J. D. van Eekelen, J. R. W. Glauert, J. R. Kennaway, M. J. Plasmeijer, and M. R. Sleep. </author> <title> Term graph rewriting. </title> <editor> In J. W. de Bakker, A. J. Nijman, and P. C. Treleaven, editors, </editor> <booktitle> Proc. Conference on Parallel Architecture and Languages Europe (PARLE '87), </booktitle> <address> Eindhoven, The Netherlands, </address> <publisher> Springer-Verlag LNCS 259, </publisher> <pages> pages 141-158, </pages> <year> 1987. </year>
Reference-contexts: Thus we arrive at rewriting of dags (directed acyclic graphs) rather than terms (finite trees). Recent years have seen the development of the basic theory for acyclic term graph rewriting <ref> [9, 26, 43, 47] </ref>. 1 Typical results are confluence, when an orthogonality restraint is imposed (rules can-not interfere badly with each other) [48], modularity for properties such as confluence and termination (the properties stay preserved in combinations of systems) [43], and adequacy (in what sense is term graph rewriting adequate for <p> We will write: g$h. (ii) g!h if there is a functional bisimulation from g to h, i.e., a bisimulation that is a function. Remark 3.7 Bisimilarity is an equivalence relation. A functional bisimulation is what in the literature <ref> [9, 48] </ref> is called a rooted homomorphism; it collapses (compresses) the graph to a smaller one. Vice versa we say that the graph is `expanded', and this is the `copying' or `unsharing' or `unwinding' partial order appearing in [2, 3, 4].
Reference: [10] <author> E. Barendsen and J. E. W. Smetsers. </author> <title> Conventional and uniqueness typing in graph rewrite systems. </title> <type> Technical Report CSI-R9328, </type> <institution> Computing Science Institute, University of Nijmegen, </institution> <year> 1993. </year>
Reference-contexts: Barendsen and Smetsers <ref> [10] </ref> introduce explicit notations to introduce `unique types' for some node graphs, meaning that these are to be used only once, like our hidden nodes.
Reference: [11] <author> R. V. </author> <title> Book (Editor). </title> <booktitle> Proc. 4th International Conference on Rewriting Techniques and Applications (RTA-91), </booktitle> <address> Como, Italy, </address> <publisher> Springer-Verlag LNCS 488. </publisher> <year> 1991. </year>
Reference-contexts: The distinctive feature of the latter is the presence of bound variables. Term rewriting has become in the last decade a firmly established discipline, with applications in many areas <ref> [11] </ref> such as abstract data types, functional programming, automated theorem proving, and proof theory. Term graph rewriting originates with the observation that rewrite rules often ask for duplications of subterms.
Reference: [12] <author> A. Corradini. </author> <title> Term rewriting in CT . In M.-C. </title> <editor> Gaudel and J.-P. Jouannaud, editors, </editor> <booktitle> Proc. Colloquium on Trees in Algebra and Programming (CAAP '93), </booktitle> <publisher> Springer-Verlag LNCS 668, </publisher> <pages> pages 468-484, </pages> <year> 1993. </year>
Reference-contexts: For graph rewriting, it is as it were a point of singularity; we need a new constant for it to ensure confluence of orthogonal term graph rewriting, even though there is no proper term graph corresponding to it. Interestingly the same observation was made by Corradini in <ref> [12] </ref> using the cpo approach. This view is also supported by a comparison with the related system of - expressions: the new constant * is present there as ff:ff, an expression rewriting only to 2 itself: ff:ff ! ff:ff.
Reference: [13] <author> B. Courcelle. </author> <title> Infinite trees in normal form and recursive equations having a unique solution. </title> <journal> Mathematical Systems Theory, </journal> <volume> 13 </volume> <pages> 131-180, </pages> <year> 1979. </year>
Reference-contexts: proof system of Table 1 (see previous example) is finite for finite T ; or, since there are only finitely many relations on a pair of finite graphs. (ii) The study of recursion equations of course goes back a long way and several notions discussed above occur already in e.g., <ref> [13, 14, 15, 16, 18, 19, 24, 52, 51] </ref>. However, in this work systems of recursion equations are not related to term graph rewriting as we do in this paper. Specifically, [15] contains already Proposition 3.22, in a different formulation.
Reference: [14] <author> B. Courcelle. </author> <title> Recursive applicative program schemes. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> volume B, </volume> <pages> pages 461-492. </pages> <publisher> Elsevier - The MIT Press, </publisher> <year> 1990. </year> <month> 26 </month>
Reference-contexts: proof system of Table 1 (see previous example) is finite for finite T ; or, since there are only finitely many relations on a pair of finite graphs. (ii) The study of recursion equations of course goes back a long way and several notions discussed above occur already in e.g., <ref> [13, 14, 15, 16, 18, 19, 24, 52, 51] </ref>. However, in this work systems of recursion equations are not related to term graph rewriting as we do in this paper. Specifically, [15] contains already Proposition 3.22, in a different formulation.
Reference: [15] <author> B. Courcelle, G. Kahn, and J. Vuillemin. </author> <title> Algorithmes d'equivalence et de reduction a des expressions minimales dans une classe d'equations recursives simples. </title> <editor> In J. Loeckx, editor, </editor> <booktitle> Proc. 2nd Colloquium on Automata, Languages and Programming (ICALP '74), University of Saarbrucken, </booktitle> <publisher> Springer-Verlag LNCS 14, </publisher> <pages> pages 200-213, </pages> <year> 1974. </year>
Reference-contexts: proof system of Table 1 (see previous example) is finite for finite T ; or, since there are only finitely many relations on a pair of finite graphs. (ii) The study of recursion equations of course goes back a long way and several notions discussed above occur already in e.g., <ref> [13, 14, 15, 16, 18, 19, 24, 52, 51] </ref>. However, in this work systems of recursion equations are not related to term graph rewriting as we do in this paper. Specifically, [15] contains already Proposition 3.22, in a different formulation. <p> However, in this work systems of recursion equations are not related to term graph rewriting as we do in this paper. Specifically, <ref> [15] </ref> contains already Proposition 3.22, in a different formulation. The notion of equivalence in that paper coincides with the notion of bisimilarity as used here (the definition of bisimulation is not yet present in [15], though). <p> Specifically, <ref> [15] </ref> contains already Proposition 3.22, in a different formulation. The notion of equivalence in that paper coincides with the notion of bisimilarity as used here (the definition of bisimulation is not yet present in [15], though). Moreover, in our paper we analyze some basic graph transformations, in the next section. 4 Copying, substitution and flattening In this section we characterize the fundamental notions of copying, substitution, and flattening using the simple deductive system of Equational Logic.
Reference: [16] <author> B. Courcelle and J. Vuillemin. </author> <title> Completeness results for the equivalence of recursive schemas. </title> <journal> JCSS, </journal> <volume> 12 </volume> <pages> 179-197, </pages> <year> 1976. </year>
Reference-contexts: proof system of Table 1 (see previous example) is finite for finite T ; or, since there are only finitely many relations on a pair of finite graphs. (ii) The study of recursion equations of course goes back a long way and several notions discussed above occur already in e.g., <ref> [13, 14, 15, 16, 18, 19, 24, 52, 51] </ref>. However, in this work systems of recursion equations are not related to term graph rewriting as we do in this paper. Specifically, [15] contains already Proposition 3.22, in a different formulation.
Reference: [17] <author> P.-L. Curien. </author> <title> Categorical Combinators, Sequential algorithms, </title> <booktitle> and Functional Programming. Birkhauser, 2nd edition, </booktitle> <year> 1993. </year>
Reference-contexts: We are also interested in extending the framework to accommodate cyclic -graphs, an endeavor that can be seen as an extension of the work on the -calculi (-calculi with explicit substitution) <ref> [1, 17, 25, 36, 45] </ref>. However, the latter concern acyclic substitutions only, while we aim at a calculus allowing cyclic substitutions. A preliminary study appears in [5]. Furthermore, we intend to study the suitability of equational graph rewriting for expressing side-effect operations.
Reference: [18] <author> J. W. de Bakker. </author> <title> Recursive procedures. </title> <publisher> Mathematical Centre Tracts 24, Mathe-matisch Centrum, </publisher> <address> Amsterdam, </address> <year> 1971. </year>
Reference-contexts: proof system of Table 1 (see previous example) is finite for finite T ; or, since there are only finitely many relations on a pair of finite graphs. (ii) The study of recursion equations of course goes back a long way and several notions discussed above occur already in e.g., <ref> [13, 14, 15, 16, 18, 19, 24, 52, 51] </ref>. However, in this work systems of recursion equations are not related to term graph rewriting as we do in this paper. Specifically, [15] contains already Proposition 3.22, in a different formulation.
Reference: [19] <author> J. W. de Bakker. </author> <title> Mathematical Theory of Program Correctness. </title> <publisher> Prentice Hall International. Series in Computer Science, </publisher> <year> 1980. </year>
Reference-contexts: proof system of Table 1 (see previous example) is finite for finite T ; or, since there are only finitely many relations on a pair of finite graphs. (ii) The study of recursion equations of course goes back a long way and several notions discussed above occur already in e.g., <ref> [13, 14, 15, 16, 18, 19, 24, 52, 51] </ref>. However, in this work systems of recursion equations are not related to term graph rewriting as we do in this paper. Specifically, [15] contains already Proposition 3.22, in a different formulation.
Reference: [20] <author> N. Dershowitz and J. P. Jouannaud. </author> <title> Rewrite systems. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> volume B, </volume> <pages> pages 243-320. </pages> <publisher> Elsevier - The MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction Term rewriting can be divided roughly in first-order term rewriting <ref> [20, 34] </ref>, where first-order terms are replaced (reduced, rewritten) according to a fixed set of rewrite rules, and higher-order term rewriting, of which the paradigm is lambda calculus [8]. The distinctive feature of the latter is the presence of bound variables.
Reference: [21] <author> W. M. Farmer. </author> <title> A correctness proof for combinator reduction with cycles. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(1) </volume> <pages> 123-134, </pages> <year> 1990. </year>
Reference-contexts: E.g., fffi = F (*; ); * = G (ffi); = H (ffi; ffi)g is equivalent to the above system. Similar notations appear in the literature <ref> [23, 21] </ref>. E.g., fu : F (u; v); v : G (u)g in the language DACTL [23].
Reference: [22] <author> W. M. Farmer and R. J. Watro. </author> <title> Redex capturing in term graph rewriting. </title> <editor> In R. V. Book, editor, </editor> <booktitle> Proc. 4th International Conference on Rewriting Techniques and Applications (RTA-91), </booktitle> <address> Como, Italy, </address> <publisher> Springer-Verlag LNCS 488, </publisher> <pages> pages 13-24, </pages> <year> 1991. </year>
Reference-contexts: Only in the last few years a firm foundation of cyclic term graph rewriting has been given, with as a main theorem the confluence property for orthogonal term graph rewriting. Establishing confluence was not altogether trivial since it faced the need for solving the problem of cyclic collapsing terms <ref> [2, 3, 22] </ref>. Previous definitions of term graph rewriting tend to use one of two ways: (1) category-theory oriented [28, 29, 30, 44], (2) implementation-oriented [42].
Reference: [23] <author> J. R. W. Glauert, J. R. Kennaway, and M. R. Sleep. Dactl: </author> <title> An experimental graph rewriting language. </title> <booktitle> In 4th International Workshop on Graph Grammars and their Application to Computer Science, </booktitle> <address> Bremen, Germany, </address> <publisher> Springer-Verlag LNCS 532, </publisher> <pages> pages 378-395, </pages> <year> 1990. </year>
Reference-contexts: E.g., fffi = F (*; ); * = G (ffi); = H (ffi; ffi)g is equivalent to the above system. Similar notations appear in the literature <ref> [23, 21] </ref>. E.g., fu : F (u; v); v : G (u)g in the language DACTL [23]. <p> E.g., fffi = F (*; ); * = G (ffi); = H (ffi; ffi)g is equivalent to the above system. Similar notations appear in the literature [23, 21]. E.g., fu : F (u; v); v : G (u)g in the language DACTL <ref> [23] </ref>. However, we insist on an equational notation, not just for the sake of style, but because Equational Logic reasoning can fruitfully support our thinking about common term graph operations, as will become clear shortly.
Reference: [24] <author> I. </author> <title> Guessarian. Algebraic Semantics, </title> <publisher> Springer-Verlag LNCS 99. </publisher> <year> 1981. </year>
Reference-contexts: proof system of Table 1 (see previous example) is finite for finite T ; or, since there are only finitely many relations on a pair of finite graphs. (ii) The study of recursion equations of course goes back a long way and several notions discussed above occur already in e.g., <ref> [13, 14, 15, 16, 18, 19, 24, 52, 51] </ref>. However, in this work systems of recursion equations are not related to term graph rewriting as we do in this paper. Specifically, [15] contains already Proposition 3.22, in a different formulation.
Reference: [25] <author> T. Hardin and J.-J. Levy. </author> <title> A confluent calculus of substitutions. </title> <booktitle> In France-Japan Artificial Intelligence and Computer Science Symposium, </booktitle> <address> Izu, </address> <year> 1989. </year>
Reference-contexts: We are also interested in extending the framework to accommodate cyclic -graphs, an endeavor that can be seen as an extension of the work on the -calculi (-calculi with explicit substitution) <ref> [1, 17, 25, 36, 45] </ref>. However, the latter concern acyclic substitutions only, while we aim at a calculus allowing cyclic substitutions. A preliminary study appears in [5]. Furthermore, we intend to study the suitability of equational graph rewriting for expressing side-effect operations.
Reference: [26] <author> B. Hoffman and D. Plump. </author> <title> Jungle evaluation for efficient term rewriting. </title> <editor> In J. Grabowski, P. Lescanne, and W. Wechler, editors, </editor> <booktitle> Proc. International Workshop on Algebraic and Logic Programming, </booktitle> <publisher> Springer-Verlag LNCS 343, </publisher> <pages> pages 191-203, </pages> <year> 1988. </year>
Reference-contexts: Thus we arrive at rewriting of dags (directed acyclic graphs) rather than terms (finite trees). Recent years have seen the development of the basic theory for acyclic term graph rewriting <ref> [9, 26, 43, 47] </ref>. 1 Typical results are confluence, when an orthogonality restraint is imposed (rules can-not interfere badly with each other) [48], modularity for properties such as confluence and termination (the properties stay preserved in combinations of systems) [43], and adequacy (in what sense is term graph rewriting adequate for <p> So, reduction ! does not commute with bisimilarity $. Yet, many interesting facts can be established for this union !! [ c ; this has been established in work of Plump and Hofmann ("collapsed tree rewriting") <ref> [26, 43] </ref>. There, after each rewriting the graph can be maximally collapsed; this yields a gain in efficiency. Corollary 5.15 Orthogonal TGRSs are confluent with respect to ! [ ! c .
Reference: [27] <author> P. Hudak, S. Peyton Jones, P. Wadler, B. Boutel, J. Fairbairn, J. Fasel, K. Ham-mond, J. Hughes, T. Johnsson, D. Kieburtz, R. Nikhil, W. Partain, and J. Pe-terson. </author> <title> Report on the programming language Haskell. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 27(5) </volume> <pages> 1-64, </pages> <year> 1992. </year>
Reference-contexts: To that end, an extension is needed to include both rules and terms with multiple roots. We expect that a final system obtained along these lines, can be used to express the operational semantics of current functional languages extended with a notion of state <ref> [27, 41] </ref>. Acknowledgements This work was done at the Department of Software Technology of CWI, at the Department of Computer Science of the Free University, and at the Department of Computer and Information Science of the University of Oregon.
Reference: [28] <author> J. R. Kennaway. </author> <title> On graph rewriting. </title> <journal> Theoretical Computer Science, </journal> <volume> 52 </volume> <pages> 37-58, </pages> <year> 1987. </year>
Reference-contexts: Establishing confluence was not altogether trivial since it faced the need for solving the problem of cyclic collapsing terms [2, 3, 22]. Previous definitions of term graph rewriting tend to use one of two ways: (1) category-theory oriented <ref> [28, 29, 30, 44] </ref>, (2) implementation-oriented [42]. The first describes graph rewrite steps as push-outs in a category, and some papers have been devoted to analyzing whether this can be done by single or double push-out constructions [37]. The second uses notions like pointers, redirections, indirections.
Reference: [29] <author> J. R. Kennaway. </author> <title> Corrigendum on `on graph rewriting'. </title> <journal> Theoretical Computer Science, </journal> <volume> 61 </volume> <pages> 317-320, </pages> <year> 1988. </year>
Reference-contexts: Establishing confluence was not altogether trivial since it faced the need for solving the problem of cyclic collapsing terms [2, 3, 22]. Previous definitions of term graph rewriting tend to use one of two ways: (1) category-theory oriented <ref> [28, 29, 30, 44] </ref>, (2) implementation-oriented [42]. The first describes graph rewrite steps as push-outs in a category, and some papers have been devoted to analyzing whether this can be done by single or double push-out constructions [37]. The second uses notions like pointers, redirections, indirections.
Reference: [30] <author> J. R. Kennaway. </author> <title> Graph rewriting on some categories of partial morphisms. </title> <booktitle> In Proc. 4th International Workshop on Graph Grammars and their Application to Computer Science, </booktitle> <address> Bremen, Germany, </address> <publisher> Springer-Verlag LNCS 532, </publisher> <pages> pages 490-504, </pages> <year> 1990. </year>
Reference-contexts: Establishing confluence was not altogether trivial since it faced the need for solving the problem of cyclic collapsing terms [2, 3, 22]. Previous definitions of term graph rewriting tend to use one of two ways: (1) category-theory oriented <ref> [28, 29, 30, 44] </ref>, (2) implementation-oriented [42]. The first describes graph rewrite steps as push-outs in a category, and some papers have been devoted to analyzing whether this can be done by single or double push-out constructions [37]. The second uses notions like pointers, redirections, indirections.
Reference: [31] <author> J. R. Kennaway, J. W. Klop, M. R. Sleep, and F. J. de Vries. </author> <title> Transfinite reductions in orthogonal term rewriting systems. </title> <editor> In R. V. Book, editor, </editor> <booktitle> Proc. 4th International Conference on Rewriting Techniques and Applications (RTA-91), </booktitle> <address> Como, Italy, </address> <publisher> Springer-Verlag LNCS 488, </publisher> <pages> pages 1-12, </pages> <year> 1991. </year>
Reference-contexts: In terms of systems of recursion equations, * is the system fff = ffg. The same `singularity' shows up in the theory of orthogonal infinitary rewriting <ref> [31] </ref>: without more, infinitary confluence fails, but equating all infinite collapsing trees such as I ! , the infinite unwinding I (I (I (I (I ( ) ) of either the graph fff = I (ff)g or the -term ff:I (ff), infinitary confluence holds. (It should be mentioned that the `collapse
Reference: [32] <author> J. R. Kennaway, J. W. Klop, M. R. Sleep, and F. J. de Vries. </author> <title> The adequacy of term graph rewriting for simulating term rewriting. </title> <editor> In M. R. Sleep, M. J. Plasmeijer, and M. C. D. J. van Eekelen, editors, </editor> <title> Term Graph Rewriting: </title> <journal> Theory and Practice, </journal> <pages> pages 157-170. </pages> <publisher> John Wiley & Sons, </publisher> <year> 1993. </year>
Reference-contexts: 1 Typical results are confluence, when an orthogonality restraint is imposed (rules can-not interfere badly with each other) [48], modularity for properties such as confluence and termination (the properties stay preserved in combinations of systems) [43], and adequacy (in what sense is term graph rewriting adequate for ordinary term rewriting) <ref> [3, 32] </ref>. Term graph rewriting with cycles goes one step further by admitting cyclic term graphs. These arise naturally when dealing with recursive structures. Classical is the implementation by D. Turner [49] of the fixed point combinator Y by means of a cyclic graph (Figure 1). <p> As a typical example of the benefits of an equational treatment of term graph rewriting, we mention the problem of `cyclic-I', or more general of cyclic collapsing graphs. This matter has been called `a persistent technical problem' <ref> [32] </ref>, and indeed several proposals concerning the way that cyclic-I (i.e., the graph fff = I (ff)g, where I has the `collapsing' rewrite rule I (x) ! x) should be rewritten to, occur in the literature. One possibility is that cyclic-I rewrites to itself.
Reference: [33] <author> J. W. Klop. </author> <title> Combinatory Reduction Systems. </title> <type> PhD thesis, </type> <institution> Mathematical Centre Tracts 127, CWI, Amsterdam,1980. </institution>
Reference-contexts: Here we use the notation as used for `higher-order term rewriting' by means of Combinatory Reduction Systems (CRSs), as in <ref> [33, 35, 50] </ref>. Proposition 2.2 Let R be an orthogonal TRS. Then R is an orthogonal CRS, and hence confluent. Proof: It is simple to check that R is an orthogonal CRS, hence the general confluence theorem for orthogonal CRSs applies.
Reference: [34] <author> J. W. Klop. </author> <title> Term rewriting systems. </title> <editor> In S. Abramsky, D. Gabbay, and T. Maibaum, editors, </editor> <booktitle> Handbook of Logic in Computer Science, </booktitle> <volume> volume II, </volume> <pages> pages 1-116. </pages> <publisher> Oxford University Press, </publisher> <year> 1992. </year>
Reference-contexts: 1 Introduction Term rewriting can be divided roughly in first-order term rewriting <ref> [20, 34] </ref>, where first-order terms are replaced (reduced, rewritten) according to a fixed set of rewrite rules, and higher-order term rewriting, of which the paradigm is lambda calculus [8]. The distinctive feature of the latter is the presence of bound variables. <p> Instead of the congruence rule of Equational Logic we use (as in some algorithms for syntactic unification of first-order terms <ref> [34] </ref>) its reverse, the term decomposition rule. This rule says that from F (t 1 ; ; t n ) = F (s 1 ; ; s n ) we may infer t i = s i (i = 1; ; n).
Reference: [35] <author> J. W. Klop, V. van Oostrom, and F. van Raamsdonk. </author> <title> Combinatory reduction systems: Introduction and survey. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 121(1-2):279-308, </address> <year> 1993. </year> <title> A Collection of Contributions in Honour of Corrado Bohm on the Occasion of his 70th Birthday, </title> <editor> guest eds. M. Dezani-Ciancaglini, S. Ronchi Della Rocca and M. </editor> <publisher> Venturini-Zilli. </publisher>
Reference-contexts: Here we use the notation as used for `higher-order term rewriting' by means of Combinatory Reduction Systems (CRSs), as in <ref> [33, 35, 50] </ref>. Proposition 2.2 Let R be an orthogonal TRS. Then R is an orthogonal CRS, and hence confluent. Proof: It is simple to check that R is an orthogonal CRS, hence the general confluence theorem for orthogonal CRSs applies.
Reference: [36] <author> P. Lescanne. </author> <title> From to a journey through calculi of explicit substitutions. </title> <booktitle> In Proc. 21st Symposium on Principles of Programming Languages (POPL '94), Portland, Oregon, </booktitle> <pages> pages 60-69, </pages> <year> 1994. </year>
Reference-contexts: We are also interested in extending the framework to accommodate cyclic -graphs, an endeavor that can be seen as an extension of the work on the -calculi (-calculi with explicit substitution) <ref> [1, 17, 25, 36, 45] </ref>. However, the latter concern acyclic substitutions only, while we aim at a calculus allowing cyclic substitutions. A preliminary study appears in [5]. Furthermore, we intend to study the suitability of equational graph rewriting for expressing side-effect operations.
Reference: [37] <author> M. Lowe. </author> <title> Algebraic approach to single pushout graph transformation. </title> <journal> Theoretical Computer Science, </journal> <volume> 109 </volume> <pages> 181-224, </pages> <year> 1993. </year>
Reference-contexts: The first describes graph rewrite steps as push-outs in a category, and some papers have been devoted to analyzing whether this can be done by single or double push-out constructions <ref> [37] </ref>. The second uses notions like pointers, redirections, indirections. We would like to find an approach that is less `abstract' than the first, and less `concrete' than the second.
Reference: [38] <author> N. A. Lynch and F. W. Vaandrager. </author> <title> Forward and backward simulations, part i: untimed systems. </title> <type> Technical Report CS-R9313, </type> <institution> CWI, </institution> <address> Amsterdam, </address> <year> 1993. </year>
Reference-contexts: Indeed, this is the reason why (in the setting of concurrency theory) a functional bisimulation is called a history relation in Lynch & Vaandrager <ref> [38] </ref>. The tree unwinding of a graph has maximum information; it is the top of the lattice. Each node in the tree has a singleton as history set. Intermezzo 3.21 Our use of the notion of bisimulation in the present setting was suggested by process algebra (or `concurrency').
Reference: [39] <author> A. Martelli and U. Montanari. </author> <title> An efficient unification algorithm. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(2) </volume> <pages> 258-282, </pages> <year> 1982. </year>
Reference-contexts: or the cyclic graph version of Combinatory Logic with its collapsing rule Kxy ! x.) As another example of the ease that Equational Logic introduces for term graph rewriting, we mention: checking bisimilarity of two term graphs in an equational way, somewhat reminiscent to the elegant unification algorithm of Martelli-Montanari <ref> [39] </ref>. An interesting consequence of treating term graphs as systems of recursion equations, is that we are naturally invited to perform the operation of substitution on them.
Reference: [40] <author> R. Milner. </author> <title> Communication and concurrency. </title> <publisher> Prentice Hall International, </publisher> <year> 1989. </year> <month> 28 </month>
Reference-contexts: Specifically we introduce 5 the notion of bisimilarity of systems of recursion equations. This notion is well-known from the theory of processes (or `concurrency' or `communicating processes' or `process algebra') see Milner <ref> [40] </ref>, Baeten & Weijland [7].
Reference: [41] <author> R. S. Nikhil. </author> <title> Id (version 90.1) reference manual. </title> <type> Technical Report 284-2, </type> <institution> MIT Laboratory for Computer Science, 545 Technology Square, </institution> <address> Cambridge, MA 02139, </address> <year> 1991. </year>
Reference-contexts: To that end, an extension is needed to include both rules and terms with multiple roots. We expect that a final system obtained along these lines, can be used to express the operational semantics of current functional languages extended with a notion of state <ref> [27, 41] </ref>. Acknowledgements This work was done at the Department of Software Technology of CWI, at the Department of Computer Science of the Free University, and at the Department of Computer and Information Science of the University of Oregon.
Reference: [42] <author> M. J. Plasmeijer and M. C. J. D. van Eekelen. </author> <title> Functional Programming and Parallel Graph Rewriting. </title> <publisher> Addison Wesley, </publisher> <year> 1993. </year>
Reference-contexts: Establishing confluence was not altogether trivial since it faced the need for solving the problem of cyclic collapsing terms [2, 3, 22]. Previous definitions of term graph rewriting tend to use one of two ways: (1) category-theory oriented [28, 29, 30, 44], (2) implementation-oriented <ref> [42] </ref>. The first describes graph rewrite steps as push-outs in a category, and some papers have been devoted to analyzing whether this can be done by single or double push-out constructions [37]. The second uses notions like pointers, redirections, indirections.
Reference: [43] <author> D. Plump. </author> <title> Evaluation of Functional Expressions by Hypergraph Rewriting. </title> <type> PhD thesis, </type> <institution> Universitat Bremen, </institution> <year> 1993. </year>
Reference-contexts: Thus we arrive at rewriting of dags (directed acyclic graphs) rather than terms (finite trees). Recent years have seen the development of the basic theory for acyclic term graph rewriting <ref> [9, 26, 43, 47] </ref>. 1 Typical results are confluence, when an orthogonality restraint is imposed (rules can-not interfere badly with each other) [48], modularity for properties such as confluence and termination (the properties stay preserved in combinations of systems) [43], and adequacy (in what sense is term graph rewriting adequate for <p> the development of the basic theory for acyclic term graph rewriting [9, 26, 43, 47]. 1 Typical results are confluence, when an orthogonality restraint is imposed (rules can-not interfere badly with each other) [48], modularity for properties such as confluence and termination (the properties stay preserved in combinations of systems) <ref> [43] </ref>, and adequacy (in what sense is term graph rewriting adequate for ordinary term rewriting) [3, 32]. Term graph rewriting with cycles goes one step further by admitting cyclic term graphs. These arise naturally when dealing with recursive structures. Classical is the implementation by D. <p> So, reduction ! does not commute with bisimilarity $. Yet, many interesting facts can be established for this union !! [ c ; this has been established in work of Plump and Hofmann ("collapsed tree rewriting") <ref> [26, 43] </ref>. There, after each rewriting the graph can be maximally collapsed; this yields a gain in efficiency. Corollary 5.15 Orthogonal TGRSs are confluent with respect to ! [ ! c .
Reference: [44] <author> J. C. Raoult. </author> <title> On graph rewritings. </title> <journal> Theoretical Computer Science, </journal> <volume> 32 </volume> <pages> 1-24, </pages> <year> 1984. </year>
Reference-contexts: Establishing confluence was not altogether trivial since it faced the need for solving the problem of cyclic collapsing terms [2, 3, 22]. Previous definitions of term graph rewriting tend to use one of two ways: (1) category-theory oriented <ref> [28, 29, 30, 44] </ref>, (2) implementation-oriented [42]. The first describes graph rewrite steps as push-outs in a category, and some papers have been devoted to analyzing whether this can be done by single or double push-out constructions [37]. The second uses notions like pointers, redirections, indirections.
Reference: [45] <author> K. H. Rose. </author> <title> Explicit cyclic substitutions. </title> <editor> In M. Rusinowitch and J. L. Remy, editors, </editor> <booktitle> Proc. 3rd International Workshop on Conditional Term Rewriting Systems (CTRS-92), Pont-a-Mousson, </booktitle> <address> France, </address> <publisher> Springer-Verlag LNCS 656, </publisher> <pages> pages 36-50, </pages> <year> 1992. </year>
Reference-contexts: We are also interested in extending the framework to accommodate cyclic -graphs, an endeavor that can be seen as an extension of the work on the -calculi (-calculi with explicit substitution) <ref> [1, 17, 25, 36, 45] </ref>. However, the latter concern acyclic substitutions only, while we aim at a calculus allowing cyclic substitutions. A preliminary study appears in [5]. Furthermore, we intend to study the suitability of equational graph rewriting for expressing side-effect operations.
Reference: [46] <author> T. Schmidt and T. Strohlein. </author> <title> Relations and Graphs. </title> <note> EATCS Monographs on Theoretical Computer Science Springer-Verlag, </note> <year> 1993. </year>
Reference-contexts: The notion of copying is also well-known in `general' graph theory <ref> [46] </ref> under the name `graph coverings'. 15 4.1 Copying Definition 4.1 A variable substitution is a function from variables to variables.
Reference: [47] <author> M. R. Sleep, M. J. Plasmeijer, and M. C. D. J. van Eekelen, </author> <title> editors. Term Graph Rewriting: Theory and Practice. </title> <publisher> John Wiley & Sons, </publisher> <year> 1993. </year>
Reference-contexts: Thus we arrive at rewriting of dags (directed acyclic graphs) rather than terms (finite trees). Recent years have seen the development of the basic theory for acyclic term graph rewriting <ref> [9, 26, 43, 47] </ref>. 1 Typical results are confluence, when an orthogonality restraint is imposed (rules can-not interfere badly with each other) [48], modularity for properties such as confluence and termination (the properties stay preserved in combinations of systems) [43], and adequacy (in what sense is term graph rewriting adequate for
Reference: [48] <author> J. E. W. Smetsers. </author> <title> Graph Rewriting and Functional Languages. </title> <type> PhD thesis, </type> <institution> University of Nijmegen, </institution> <year> 1993. </year>
Reference-contexts: Recent years have seen the development of the basic theory for acyclic term graph rewriting [9, 26, 43, 47]. 1 Typical results are confluence, when an orthogonality restraint is imposed (rules can-not interfere badly with each other) <ref> [48] </ref>, modularity for properties such as confluence and termination (the properties stay preserved in combinations of systems) [43], and adequacy (in what sense is term graph rewriting adequate for ordinary term rewriting) [3, 32]. Term graph rewriting with cycles goes one step further by admitting cyclic term graphs. <p> A system without ambiguous rules is shown to be confluent. Moreover, if non-left-linear rules are also discarded (i.e., for orthogonal term graph rewriting) it is shown that confluence holds even if copying is admitted. The observation that copying does not destroy confluence was already shown in <ref> [48] </ref> for acyclic terms. We end the paper with directions for future work. <p> We will write: g$h. (ii) g!h if there is a functional bisimulation from g to h, i.e., a bisimulation that is a function. Remark 3.7 Bisimilarity is an equivalence relation. A functional bisimulation is what in the literature <ref> [9, 48] </ref> is called a rooted homomorphism; it collapses (compresses) the graph to a smaller one. Vice versa we say that the graph is `expanded', and this is the `copying' or `unsharing' or `unwinding' partial order appearing in [2, 3, 4]. <p> For the acyclic case, the lattice property is proved in Smetsers <ref> [48] </ref>. We expect that in maybe slightly different but related settings this is a well-known fact, but we include the following proof for completeness sake and also to demonstrate the use of the notion of bisimilarity. <p> However, we do need to restrict our attention to orthogonal TGRSs if also copying is considered, as observed in <ref> [48] </ref> for the acyclic case. Example 5.12 Consider the non-left-linear rule t : fff = F (fl; fl)g ! fff = 1g and the system g f = F (fi; fi); fi = 1g. Rule t is applicable to g.
Reference: [49] <author> D. A. Turner. </author> <title> A new implementation technique for applicative languages. </title> <journal> Software Practice and Experience, </journal> <volume> 9 </volume> <pages> 31-49, </pages> <year> 1979. </year>
Reference-contexts: Term graph rewriting with cycles goes one step further by admitting cyclic term graphs. These arise naturally when dealing with recursive structures. Classical is the implementation by D. Turner <ref> [49] </ref> of the fixed point combinator Y by means of a cyclic graph (Figure 1). Only in the last few years a firm foundation of cyclic term graph rewriting has been given, with as a main theorem the confluence property for orthogonal term graph rewriting.
Reference: [50] <editor> F. van Raamsdonk. Confluence and superdevelopments. In C. Kirchner, editor, </editor> <booktitle> Proc. 5th International Conference on Rewriting Techniques and Applications (RTA-93), </booktitle> <address> Montreal, Canada, </address> <publisher> Springer-Verlag LNCS 690, </publisher> <pages> pages 168-182, </pages> <year> 1993. </year>
Reference-contexts: Here we use the notation as used for `higher-order term rewriting' by means of Combinatory Reduction Systems (CRSs), as in <ref> [33, 35, 50] </ref>. Proposition 2.2 Let R be an orthogonal TRS. Then R is an orthogonal CRS, and hence confluent. Proof: It is simple to check that R is an orthogonal CRS, hence the general confluence theorem for orthogonal CRSs applies. <p> Proposition 2.2 Let R be an orthogonal TRS. Then R is an orthogonal CRS, and hence confluent. Proof: It is simple to check that R is an orthogonal CRS, hence the general confluence theorem for orthogonal CRSs applies. See e.g., <ref> [50] </ref>. 2 Remark 2.3 (i) Orthogonality is not necessary to guarantee confluence. In fact: Let R be a left-linear, confluent TRS. Then R is a confluent CRS. (ii) In (i) left-linearity is necessary.
Reference: [51] <author> J. E. Vuillemin. </author> <title> Proof Techniques for Recursive Programs. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <year> 1973. </year>
Reference-contexts: proof system of Table 1 (see previous example) is finite for finite T ; or, since there are only finitely many relations on a pair of finite graphs. (ii) The study of recursion equations of course goes back a long way and several notions discussed above occur already in e.g., <ref> [13, 14, 15, 16, 18, 19, 24, 52, 51] </ref>. However, in this work systems of recursion equations are not related to term graph rewriting as we do in this paper. Specifically, [15] contains already Proposition 3.22, in a different formulation.
Reference: [52] <author> J. E. Vuillemin. Syntaxe, </author> <title> Semantique et Axiomatique d'un Langage de Program-mation Simple. </title> <type> PhD thesis, </type> <institution> Universite PARIS VI, </institution> <year> 1974. </year> <month> 29 </month>
Reference-contexts: proof system of Table 1 (see previous example) is finite for finite T ; or, since there are only finitely many relations on a pair of finite graphs. (ii) The study of recursion equations of course goes back a long way and several notions discussed above occur already in e.g., <ref> [13, 14, 15, 16, 18, 19, 24, 52, 51] </ref>. However, in this work systems of recursion equations are not related to term graph rewriting as we do in this paper. Specifically, [15] contains already Proposition 3.22, in a different formulation.
References-found: 52

