URL: http://www.cs.gatech.edu/computing/Database/students/jeong/papers/COMP.ps.gz
Refering-URL: http://www.cs.gatech.edu/computing/Database/students/jeong/jeong.html
Root-URL: 
Email: E-mail jeong@cc.gatech.edu, edwardo@cc.gatech.edu  
Title: Performance Study of the Index-based Parallel Join  
Author: Byeong-Soo Jeong and Edward Omiecinski 
Date: September 1995  
Address: Atlanta, Georgia 30332 USA  
Affiliation: College of Computing Georgia Institute of Technology  
Abstract:  
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. DeWitt, J. Naughton, and J. Burger. </author> <title> Nested Loops Revisted. </title> <booktitle> In Proceedings of the International Symposium on Parallel and Distributed Information Systems, </booktitle> <year> 1993. </year>
Reference-contexts: Omiecinski proposed a load balancing join algorithm for a shared-memory multiprocessor and analyzed its performance in [4]. In [8, 9], Wolf et al. considered the performance of the parallel hash join and sort-merge join algorithms in the presence of data skew. 2 To the best of our knowledge, only <ref> [1, 6] </ref> deal with index-based join processing in a parallel database environment. In [6], Omiecinski suggested heuristic algorithms for reducing I/O costs when the buffer space is limited. His work considered the shared-memory multiprocessor architecture for a target system. <p> In [6], Omiecinski suggested heuristic algorithms for reducing I/O costs when the buffer space is limited. His work considered the shared-memory multiprocessor architecture for a target system. In <ref> [1] </ref>, DeWitt et al. presented four variants of index-based parallel join algorithms in a shared-nothing environment. They also compared the performance of four variants by analytical analysis and implementation in the Gamma parallel database system. <p> Our work could be differentiated from the above work by the following aspects. * We consider a shared-nothing environment (different from [6]). * We assume that indexes are available on each relation's attributes (different from <ref> [1] </ref>). * We consider our parallel indexing schemes (different from [1, 6]). 3 Index-based Parallel Join Algorithms In this section, we describe index-based parallel join algorithms which use the parallel index files illustrated in chapter. <p> Our work could be differentiated from the above work by the following aspects. * We consider a shared-nothing environment (different from [6]). * We assume that indexes are available on each relation's attributes (different from [1]). * We consider our parallel indexing schemes (different from <ref> [1, 6] </ref>). 3 Index-based Parallel Join Algorithms In this section, we describe index-based parallel join algorithms which use the parallel index files illustrated in chapter. As in chapter, we consider a shared nothing architecture where processing nodes are connected by a scalable interconnection network.
Reference: [2] <author> H. Lu, M. Shan, and K. Tan. </author> <title> Optimization of Multi-Way Join Queries for Parallel Execution. </title> <booktitle> In Proceedings of the 17th International Conference on Very Large Data Bases, </booktitle> <pages> pages 549-560, </pages> <year> 1991. </year>
Reference-contexts: Finally, we discuss our conclusions in section 7. 2 Previous work Because the join is the most frequently used and the most time-consuming operation in a relational database system, there have been a lot of works <ref> [2, 3, 4, 7, 8, 9] </ref> dealing with parallel join algorithms in order to develop efficient join algorithms under several multiprocessor architectures.
Reference: [3] <author> H. Lu, K. Tan, and M. Shan. </author> <title> Hash-Based Join Algorithms for Multiprocessor Computers with Shared Memory. </title> <booktitle> In Proceedings of the 16th International Conference on Very Large Data Bases, </booktitle> <pages> pages 198-209, </pages> <year> 1990. </year>
Reference-contexts: Finally, we discuss our conclusions in section 7. 2 Previous work Because the join is the most frequently used and the most time-consuming operation in a relational database system, there have been a lot of works <ref> [2, 3, 4, 7, 8, 9] </ref> dealing with parallel join algorithms in order to develop efficient join algorithms under several multiprocessor architectures.
Reference: [4] <author> E. Omiecinski. </author> <title> Performance Analysis of a Load Balancing Relational Hash Join Algorithm for a Shared-Memory Multiprocessor. </title> <booktitle> In Proceedings of the 17th VLDB Conference, </booktitle> <pages> pages 375-386, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: Finally, we discuss our conclusions in section 7. 2 Previous work Because the join is the most frequently used and the most time-consuming operation in a relational database system, there have been a lot of works <ref> [2, 3, 4, 7, 8, 9] </ref> dealing with parallel join algorithms in order to develop efficient join algorithms under several multiprocessor architectures. <p> In [7], DeWitt et al. investigated the performance of four parallel hash join algorithms while implementing them on GAMMA which is a shared-nothing parallel database machine. Omiecinski proposed a load balancing join algorithm for a shared-memory multiprocessor and analyzed its performance in <ref> [4] </ref>. In [8, 9], Wolf et al. considered the performance of the parallel hash join and sort-merge join algorithms in the presence of data skew. 2 To the best of our knowledge, only [1, 6] deal with index-based join processing in a parallel database environment.
Reference: [5] <author> E. Omiecinski and E. T. Lin. </author> <title> Hash-Based and Index-Based Join Algorithms for Cube and Ring Connected Multicomputers. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 1(3) </volume> <pages> 329-343, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: pages of B+ tree index on S.B M Number of memory pages at each node n Number of nodes in a system RID Size of RID list in pages rid Number of rid pairs in RID list, rid = JS r s JS = 10 max ( SS s ) <ref> [5] </ref> SR, SS Semijoin selectivity factors Y (k; m; n) Optimal number of page I/O's for accessing k records randomly distributed in a file of n records stored in m pages [5]. <p> of rid pairs in RID list, rid = JS r s JS = 10 max ( SS s ) <ref> [5] </ref> SR, SS Semijoin selectivity factors Y (k; m; n) Optimal number of page I/O's for accessing k records randomly distributed in a file of n records stored in m pages [5].
Reference: [6] <author> Edward Omiecinski and Ron Shonkwiler. </author> <title> Parallel Join Processing using Nonclustered Indexes for a Shared Memory Multiprocessor. </title> <booktitle> In Proceedings of the Second IEEE Symposium on Parallel and Distributed Processing, </booktitle> <pages> pages 144-151, </pages> <year> 1990. </year>
Reference-contexts: Omiecinski proposed a load balancing join algorithm for a shared-memory multiprocessor and analyzed its performance in [4]. In [8, 9], Wolf et al. considered the performance of the parallel hash join and sort-merge join algorithms in the presence of data skew. 2 To the best of our knowledge, only <ref> [1, 6] </ref> deal with index-based join processing in a parallel database environment. In [6], Omiecinski suggested heuristic algorithms for reducing I/O costs when the buffer space is limited. His work considered the shared-memory multiprocessor architecture for a target system. <p> In [8, 9], Wolf et al. considered the performance of the parallel hash join and sort-merge join algorithms in the presence of data skew. 2 To the best of our knowledge, only [1, 6] deal with index-based join processing in a parallel database environment. In <ref> [6] </ref>, Omiecinski suggested heuristic algorithms for reducing I/O costs when the buffer space is limited. His work considered the shared-memory multiprocessor architecture for a target system. In [1], DeWitt et al. presented four variants of index-based parallel join algorithms in a shared-nothing environment. <p> They also compared the performance of four variants by analytical analysis and implementation in the Gamma parallel database system. Our work could be differentiated from the above work by the following aspects. * We consider a shared-nothing environment (different from <ref> [6] </ref>). * We assume that indexes are available on each relation's attributes (different from [1]). * We consider our parallel indexing schemes (different from [1, 6]). 3 Index-based Parallel Join Algorithms In this section, we describe index-based parallel join algorithms which use the parallel index files illustrated in chapter. <p> Our work could be differentiated from the above work by the following aspects. * We consider a shared-nothing environment (different from [6]). * We assume that indexes are available on each relation's attributes (different from [1]). * We consider our parallel indexing schemes (different from <ref> [1, 6] </ref>). 3 Index-based Parallel Join Algorithms In this section, we describe index-based parallel join algorithms which use the parallel index files illustrated in chapter. As in chapter, we consider a shared nothing architecture where processing nodes are connected by a scalable interconnection network. <p> By comparing the leaves of B+ tree indexes built on the joining attributes of two relations, the RID list is generated. Then retrieval of joining tuples is performed from the RID list. At this time, the page connectivity graph model <ref> [6] </ref> can be applied for reducing I/O cost in the case of limited buffer space.
Reference: [7] <author> D. A. Schneider and D. J. DeWitt. </author> <title> A Performance Evaluation of Four Parallel Join Algorithms in a Shared-Nothing Multiprocessor Environment. </title> <booktitle> In Proceedings of ACM SIGMOD - International Conference on Management of Data, </booktitle> <pages> pages 110-121, </pages> <year> 1989. </year>
Reference-contexts: Finally, we discuss our conclusions in section 7. 2 Previous work Because the join is the most frequently used and the most time-consuming operation in a relational database system, there have been a lot of works <ref> [2, 3, 4, 7, 8, 9] </ref> dealing with parallel join algorithms in order to develop efficient join algorithms under several multiprocessor architectures. <p> Those works can be roughly divided into two groups; one group of works deals with the basic parallel join methods and their performance, and another group of works emphasizes the handling of data skew in the join operation in order to further improve the performance. In <ref> [7] </ref>, DeWitt et al. investigated the performance of four parallel hash join algorithms while implementing them on GAMMA which is a shared-nothing parallel database machine. Omiecinski proposed a load balancing join algorithm for a shared-memory multiprocessor and analyzed its performance in [4].
Reference: [8] <author> J. L. Wolf, D. M. Dias, and P. S. Yu. </author> <title> An Effective Algorithm for Parallelizing Sort-Merge Joins in the Presence of Data Skew. </title> <booktitle> In Proceedings of the Second International Symposium on Databases in Parallel and Distributed Systems, </booktitle> <pages> pages 103-115, </pages> <year> 1990. </year> <month> 20 </month>
Reference-contexts: Finally, we discuss our conclusions in section 7. 2 Previous work Because the join is the most frequently used and the most time-consuming operation in a relational database system, there have been a lot of works <ref> [2, 3, 4, 7, 8, 9] </ref> dealing with parallel join algorithms in order to develop efficient join algorithms under several multiprocessor architectures. <p> In [7], DeWitt et al. investigated the performance of four parallel hash join algorithms while implementing them on GAMMA which is a shared-nothing parallel database machine. Omiecinski proposed a load balancing join algorithm for a shared-memory multiprocessor and analyzed its performance in [4]. In <ref> [8, 9] </ref>, Wolf et al. considered the performance of the parallel hash join and sort-merge join algorithms in the presence of data skew. 2 To the best of our knowledge, only [1, 6] deal with index-based join processing in a parallel database environment.
Reference: [9] <author> J. L. Wolf, D. M. Dias, P. S. Yu, and J. Turek. </author> <title> An Effective Algorithm for Parallelizing Hash Joins in the Presence of Data Skew. </title> <booktitle> In Proceedings of the Seventh International Conference on Data Engineering, </booktitle> <pages> pages 200-209, </pages> <year> 1991. </year> <month> 21 </month>
Reference-contexts: Finally, we discuss our conclusions in section 7. 2 Previous work Because the join is the most frequently used and the most time-consuming operation in a relational database system, there have been a lot of works <ref> [2, 3, 4, 7, 8, 9] </ref> dealing with parallel join algorithms in order to develop efficient join algorithms under several multiprocessor architectures. <p> In [7], DeWitt et al. investigated the performance of four parallel hash join algorithms while implementing them on GAMMA which is a shared-nothing parallel database machine. Omiecinski proposed a load balancing join algorithm for a shared-memory multiprocessor and analyzed its performance in [4]. In <ref> [8, 9] </ref>, Wolf et al. considered the performance of the parallel hash join and sort-merge join algorithms in the presence of data skew. 2 To the best of our knowledge, only [1, 6] deal with index-based join processing in a parallel database environment.
References-found: 9

