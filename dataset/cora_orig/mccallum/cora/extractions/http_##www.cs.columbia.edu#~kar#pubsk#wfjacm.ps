URL: http://www.cs.columbia.edu/~kar/pubsk/wfjacm.ps
Refering-URL: http://www.cs.columbia.edu/~kar/pubsk/pubsk.html
Root-URL: http://www.cs.columbia.edu
Title: The Well-Founded Semantics for General Logic Programs  
Author: Allen Van Gelder Kenneth A. Ross John S. Schlipf 
Keyword: General Terms: Languages, Theory Additional Key Words and Phrases: negation as failure, well-founded models, fixpoints, unfounded sets, stable models, three-valued logic  
Date: 3, July 1991, pp.620-650  
Note: Journal of the ACM, Vol. 38, No.  
Affiliation: Univ. of Calif. at Santa Cruz  Stanford Univ.  Univ. of Cincinnati  
Abstract: A general logic program (abbreviated to "program" hereafter) is a set of rules that have both positive and negative subgoals. It is common to view a deductive database as a general logic program consisting of rules (IDB) sitting above elementary relations (EDB, facts). It is desirable to associate one Herbrand model with a program and think of that model as the "meaning of the program," or its "declarative semantics." Ideally, queries directed to the program would be answered in accordance with this model. Recent research indicates that some programs do not have a "satisfactory" total model; for such programs, the question of an appropriate partial model arises. We introduce unfounded sets and well-founded partial models, and define the well-founded semantics of a program to be its well-founded partial model. If the well-founded partial model is in fact a total model, we call it the well-founded model. We show that the class of programs possessing a total well-founded model properly includes previously studied classes of "stratified" and "locally stratified" programs. We also compare our method with other proposals in the literature, including Clark's "program completion," Fitting's and Kunen's 3-valued interpretations of it, Categories and Subject Descriptors: D.3.1 [Programming Languages]: Formal Definitions and Theory | semantics; F.4.1 [Mathematical Logic and Formal Languages]: Mathematical Logic | logic programming, model theory; I.2.3 [Artificial Intelligence]: Deduction and Theorem Proving | logic programming, nonmonotonic reasoning and belief revision and the "stable models" of Gelfond and Lifschitz.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. R. Apt, H. Blair, and A. Walker. </author> <title> Towards a theory of declarative knowledge. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 89-148. </pages> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, CA, </address> <year> 1988. </year>
Reference-contexts: a: a: 6 Stratified and Locally Stratified Programs A program is stratified if all of its predicates can be assigned a rank such that * no predicate depends positively on one of greater rank, and * no predicate depends negatively on one of equal or greater rank in any rule <ref> [4, 1, 19, 40] </ref>. In the context of an IDB and EDB, the EDB, being a set of simple facts, has rank 0. IDB predicates whose defining rules involve no negation also have rank 0.
Reference: [2] <author> K. R. Apt and M. H. Van Emden. </author> <title> Contributions to the theory of logic programming. </title> <journal> JACM, </journal> <volume> 29(3) </volume> <pages> 841-862, </pages> <year> 1982. </year>
Reference-contexts: The formal details, including handling of variables and introduction of axioms for equality, are described in several places <ref> [6, 2, 20, 9, 17] </ref>. Example 4.1.
Reference: [3] <author> F. Bry. </author> <title> Logic programming as constructiveism: a formalization and its application to databases. </title> <booktitle> In Eighth ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 34-50, </pages> <year> 1989. </year>
Reference-contexts: Unfounded sets are defined in Section 3. Since the preliminary version of this paper was presented at a conference [43], several alternative formulations of negation that appear to be equivalent to the well-founded semantics have been developed <ref> [3, 8, 32, 42] </ref>.
Reference: [4] <author> A. Chandra and D. Harel. </author> <title> Horn clause queries and generalizations. </title> <journal> Journal of Logic Programming, </journal> <volume> 2(1) </volume> <pages> 1-15, </pages> <year> 1985. </year>
Reference-contexts: a: a: 6 Stratified and Locally Stratified Programs A program is stratified if all of its predicates can be assigned a rank such that * no predicate depends positively on one of greater rank, and * no predicate depends negatively on one of equal or greater rank in any rule <ref> [4, 1, 19, 40] </ref>. In the context of an IDB and EDB, the EDB, being a set of simple facts, has rank 0. IDB predicates whose defining rules involve no negation also have rank 0.
Reference: [5] <author> Ashok Chandra and David Harel. </author> <title> Structure and complexity of relational queries. </title> <journal> JCSS, </journal> <volume> 25(1) </volume> <pages> 99-128, </pages> <year> 1982. </year>
Reference-contexts: In this section we show that the data complexity of the well-founded semantics, as defined by Vardi [44], is polynomial. From this standpoint it is competitive with other methods, such as stratified semantics, whose data complexity has been studied elsewhere <ref> [5, 44, 12, 14] </ref>, and the Fitting model (as remarked below). In this discussion of complexity we restrict attention to function-free programs, so a program's Herbrand universe is just the set of constants appearing in it. <p> This sort of argument is standard; see <ref> [5, 44, 12, 14] </ref>, etc. Similar standard arguments show that calculating T P can be done in polynomial time. So we need only show that each U P (I ff ) can be found in polynomial time. Clearly, we may restrict attention to finite ff.
Reference: [6] <author> K. L. Clark. </author> <title> Negation as failure. </title> <editor> In Gallaire and Minker, editors, </editor> <booktitle> Logic and Databases, </booktitle> <pages> pages 293-322. </pages> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: This research has proceeded in two general directions, which may be summarized as the "program completion" approach and the "canonical model" approach. 1.1 Program Completion Semantics The original "program completion" approach, due to Clark <ref> [6] </ref>, and discussed in detail by Shepherdson [37, 38], Kunen [17], and Lloyd [20], has been to define a new program, called the completed program (sometimes called the completed database). The completed program is treated simply as a first order formula (see Section 4). <p> Clark introduced the completed program as a way of formalizing the notion that facts not inferable from the rules in the program were to be regarded as false <ref> [6] </ref>. Fitting studied models of the completed program in a 3-valued logic, and showed that all such models were fixed points of a certain operator [9]. We show that the well-founded partial model is also a model in this logic, but often not the least model. <p> The formal details, including handling of variables and introduction of axioms for equality, are described in several places <ref> [6, 2, 20, 9, 17] </ref>. Example 4.1. <p> The original "logical consequence" approach essentially declares that only conclusions that are logical consequences (in the classical, 2-valued sense) of the completed program should be inferred <ref> [6, 15, 20, 37] </ref>.
Reference: [7] <author> M. A. E. Dummett. </author> <title> Elements of Intuitionism. </title> <publisher> Clarendon Press, Oxford, </publisher> <year> 1977. </year>
Reference-contexts: However, factoring possibilities in the given program do not always carry over to the completed program, and a _ :a does not simplify to true in either 3-valued logic [9, 17] or intuitionistic logic <ref> [7] </ref>. Thus caution is needed to keep a coherent system.
Reference: [8] <author> Ph. M. Dung and K. Kanchanasut. </author> <title> A natural semantics for logic programs with negation. </title> <type> Technical report, </type> <institution> Asian Institute of Technology, </institution> <address> Bankok 10501, Thailand, </address> <year> 1989. </year> <type> (manuscript). 24 </type>
Reference-contexts: Unfounded sets are defined in Section 3. Since the preliminary version of this paper was presented at a conference [43], several alternative formulations of negation that appear to be equivalent to the well-founded semantics have been developed <ref> [3, 8, 32, 42] </ref>.
Reference: [9] <author> M. </author> <title> Fitting. A Kripke-Kleene semantics for logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 2(4) </volume> <pages> 295-312, </pages> <year> 1985. </year>
Reference-contexts: Also, for some programs the completed program is inconsistent; for some others, the completed program is consistent but unintuitive. More importantly, on many natural examples it yields a surprisingly weak reasoning ability. We shall illustrate these claims with examples in Section 7. Fitting <ref> [9] </ref> and Kunen [17] gave markedly different, more uniform, semantics by interpreting the completed program in a 3-valued constructive logic, elegantly eliminating some difficulties of the Clark program completion approach. <p> Hence I 0 is a total model. Our notion of partial model is not the same as the natural notions of models used in 3-valued logics, such as in the approaches of Fitting <ref> [9] </ref> and Kunen [17]. Nevertheless, the well-founded partial model we construct will also be a model in Fitting's 3-valued sense. <p> As described more formally later, the well-founded semantics uses conditions (1) and (2) to draw negative conclusions. Essentially, it simultaneously infers all atoms in A to be false. By contrast, the semantics of <ref> [9] </ref> uses only condition (1) to draw negative conclusions. The closed sets of Ross and Topor [34] were defined only with condition (2). Example 3.1. <p> Fitting studied models of the completed program in a 3-valued logic, and showed that all such models were fixed points of a certain operator <ref> [9] </ref>. We show that the well-founded partial model is also a model in this logic, but often not the least model. <p> The formal details, including handling of variables and introduction of axioms for equality, are described in several places <ref> [6, 2, 20, 9, 17] </ref>. Example 4.1. <p> However, because the truth of each literal is based on traditional 2-valued logic, we call this the 2-valued program completion (2PC) interpretation. 9 The 3-valued interpretations were made explicit by Fitting <ref> [9] </ref> and Kunen [17], who also used 3-valued logic to evaluate formulas. Whereas (p _ :p) must be true in 2-valued logic, in 3-valued logic it may also be ?. <p> Their common part (intersection) is the same 2PC interpretation as above, f:p; qg. However, here the 2PC interpretation is not a 3-valued model . One principal result in <ref> [9] </ref> is that the completion of every program has a (unique) minimum 3-valued Herbrand model. Fitting suggests that this model be taken for the semantics of the program, and hereafter we call it the Fitting model . <p> To any partial interpretation I (in 2-valued logic) there corresponds the obvious 3-valued interpretation in which atoms missing from I are assigned the truth value ?. In this setting, our partial interpretations are the same as Fitting's basic sets <ref> [9] </ref>. In 3-valued logic literals and conjunctions are true and false in I as specified in Definition 2.4; in addition, the truth value ? may be assigned: Definition 4.1. Literal q is called undefined in I, denoted by "?", if neither q nor its complement is in I. <p> Note that N P is the portion of U P produced by condition (1) of Definition 3.1. Fitting also constructs 3-valued models with a fixed point operator <ref> [9] </ref>. For positive inferences, T P is as in Definition 3.3. For negative inferences he uses (in effect) the transformation N P (I) defined above. <p> The need for factoring arises principally from "proof by cases", and sometimes from "proof by contradiction". However, factoring possibilities in the given program do not always carry over to the completed program, and a _ :a does not simplify to true in either 3-valued logic <ref> [9, 17] </ref> or intuitionistic logic [7]. Thus caution is needed to keep a coherent system.
Reference: [10] <author> M. Gelfond. </author> <title> On stratified autoepistemic theories. </title> <booktitle> In Proc. AAAI, </booktitle> <year> 1987. </year>
Reference-contexts: Recent experience has cast doubt on this attitude (see [11] for discussion), and spurred the search for further improvements in the definition of the "canonical model." Gelfond and Lifschitz propose an elegant definition of a stable model that is closely related to our work [11]. Drawing on ideas in <ref> [10] </ref>, they define a "stable model" as one that is able to reproduce itself in a certain sense; a program may have zero, one, or many stable models. In their scheme, when a program has a unique stable model, that is is considered to be its canonical model. <p> The resulting 3-valued interpretation is recursively enumerable, but may not be a 3-valued model. Kunen's main theorem is that this interpretation characterizes the 3-valued logical consequences of the completed program. 5 Stable Models Gelfond introduced an approach to negation through stable models <ref> [10] </ref>, and motivated it by appealing to autoepistemic logic, as developed by Moore [26]. The theory has been further developed by Gelfond and Lifschitz [11], and also by Marek and Truszczynski [24, 23]. In this section we follow the definition of [11], which defines stability without reference to autoepistemic logic.
Reference: [11] <author> M. Gelfond and V. Lifschitz. </author> <title> The stable model semantics for logic programming. </title> <booktitle> In Fifth Int'l Conf. Symp. on Logic Programming, </booktitle> <pages> pages 1070-1080, </pages> <address> Seattle, </address> <year> 1988. </year>
Reference-contexts: Thus failure to have a perfect model was thought to indicate a flaw in the program rather than in the definition of perfect models. Recent experience has cast doubt on this attitude (see <ref> [11] </ref> for discussion), and spurred the search for further improvements in the definition of the "canonical model." Gelfond and Lifschitz propose an elegant definition of a stable model that is closely related to our work [11]. <p> Recent experience has cast doubt on this attitude (see <ref> [11] </ref> for discussion), and spurred the search for further improvements in the definition of the "canonical model." Gelfond and Lifschitz propose an elegant definition of a stable model that is closely related to our work [11]. Drawing on ideas in [10], they define a "stable model" as one that is able to reproduce itself in a certain sense; a program may have zero, one, or many stable models. <p> The theory has been further developed by Gelfond and Lifschitz <ref> [11] </ref>, and also by Marek and Truszczynski [24, 23]. In this section we follow the definition of [11], which defines stability without reference to autoepistemic logic. We show that if a program has a total well-founded model, that model is the unique stable model. <p> The theory has been further developed by Gelfond and Lifschitz <ref> [11] </ref>, and also by Marek and Truszczynski [24, 23]. In this section we follow the definition of [11], which defines stability without reference to autoepistemic logic. We show that if a program has a total well-founded model, that model is the unique stable model. We also discuss two programs which do not have total well-founded models but do have unique stable models. <p> We also discuss two programs which do not have total well-founded models but do have unique stable models. Whether inferring (or not inferring) the truth of these extra literals is "a bug or a feature" of either approach we leave for the reader's judgement. Gelfond and Lifschitz <ref> [11] </ref> define a stable model to be one that reproduces itself in a certain three stage transformation, which we call the stability transformation. If a program has only one stable model, that is called its unique stable model. Stable models refer to 2-valued logic. <p> A more involved example in which constraints on the EDB can be specified to guarantee that the well-founded model is total is discussed elsewhere [41]. Example 7.3. This example is essentially the same as one discussed by Gelfond and Lifschitz <ref> [11] </ref>, and is one of the examples that led to the formulation of well-founded semantics, as well as stable models.
Reference: [12] <author> Y. Gurevich and S. Shelah. </author> <title> Fixed-point extensions of first order logic. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 32 </volume> <pages> 265-280, </pages> <year> 1986. </year>
Reference-contexts: In this section we show that the data complexity of the well-founded semantics, as defined by Vardi [44], is polynomial. From this standpoint it is competitive with other methods, such as stratified semantics, whose data complexity has been studied elsewhere <ref> [5, 44, 12, 14] </ref>, and the Fitting model (as remarked below). In this discussion of complexity we restrict attention to function-free programs, so a program's Herbrand universe is just the set of constants appearing in it. <p> This sort of argument is standard; see <ref> [5, 44, 12, 14] </ref>, etc. Similar standard arguments show that calculating T P can be done in polynomial time. So we need only show that each U P (I ff ) can be found in polynomial time. Clearly, we may restrict attention to finite ff.
Reference: [13] <author> S. Hanks and D. McDermott. </author> <title> Default reasoning, nonmonotonic logics, and the frame problem. </title> <booktitle> In AAAI Conference, </booktitle> <pages> pages 328-333, </pages> <year> 1986. </year>
Reference-contexts: We present some examples to support our position that well-founded models are natural and intuitive. Example 7.1. This example is abstracted from the "Yale shootout" example due to Hanks and McDermott <ref> [13] </ref>. The program P is noise (T ) loaded (T ); shoots (T ): loaded (0). loaded (T ) succ (S; T ); loaded (S); not shoots (S): shoots (T ) triggers (T ): triggers (1). succ (0; 1). <p> shoots (1); noise (1) 17 However, an alternate minimal model exists: loaded (0); shoots (0); noise (0); :loaded (1); shoots (1); :noise (1) Since noise (1) is not true in all minimal models, the circumscription approach does not allow it to be concluded, which was a main point made in <ref> [13] </ref>. However, the well-founded model is the intended one. To compare with other approaches: The 2PC model and Fitting model are also the intended model here. The program is stratified, so the stratified semantics agrees with the well-founded semantics.
Reference: [14] <author> N. Immerman. </author> <title> Relational queries computable in polynomial time. </title> <journal> Information and Control, </journal> <volume> 68(1) </volume> <pages> 86-104, </pages> <year> 1986. </year>
Reference-contexts: Because Kunen's semantics is different from Fitting's, even on programs without function symbols (see Example A.1 in the appendix), the question of whether a "strict" program is possible in the Fitting semantics is open. Nonstrict programs in the Fitting semantics are known to exist, by the work of Immermann <ref> [14] </ref>, but are quite complicated; details are discussed elsewhere by Van Gelder [42]. As another motivational example, we consider a program that is not locally stratified, as defined in Section 6, yet has a well-founded model when the EDB relation is acyclic. <p> In this section we show that the data complexity of the well-founded semantics, as defined by Vardi [44], is polynomial. From this standpoint it is competitive with other methods, such as stratified semantics, whose data complexity has been studied elsewhere <ref> [5, 44, 12, 14] </ref>, and the Fitting model (as remarked below). In this discussion of complexity we restrict attention to function-free programs, so a program's Herbrand universe is just the set of constants appearing in it. <p> This sort of argument is standard; see <ref> [5, 44, 12, 14] </ref>, etc. Similar standard arguments show that calculating T P can be done in polynomial time. So we need only show that each U P (I ff ) can be found in polynomial time. Clearly, we may restrict attention to finite ff.
Reference: [15] <author> J. Jaffar, J.-L. Lassez, and J. Lloyd. </author> <title> Completeness of the negation-as-failure rule. </title> <booktitle> In Int'l Joint Conf. on Artificial Intelligence, </booktitle> <pages> pages 500-506, </pages> <year> 1983. </year>
Reference-contexts: Jaffar, Lassez and Lloyd showed that SLDNF was complete (in the same sense) for Horn programs with non-floundering queries consisting of a conjunction of positive and/or negative literals <ref> [15] </ref>. SLDNF was further investigated for general logic programs by Lloyd [20] (who coined the term SLDNF), Shepherdson [37, 38] (q.v. for further bibliography), and others. <p> The original "logical consequence" approach essentially declares that only conclusions that are logical consequences (in the classical, 2-valued sense) of the completed program should be inferred <ref> [6, 15, 20, 37] </ref>.
Reference: [16] <author> P. G. Kolaitis. </author> <title> The expressive power of stratified programs. </title> <journal> Information and Computation, </journal> <volume> 90(1), </volume> <year> 1991. </year>
Reference-contexts: and ? in the nodes indicate whether winning is true, false, or undefined in the well-founded (partial) model. this program turns out to be closely related to a game described by Kolaitis, and used to prove that there are queries in fixpoint logic that are not expressible by stratified programs <ref> [16] </ref>. In this respect, the program can be viewed as describing a game where one wins if the opponent has no moves, as in checkers (draughts). winning (X) move (X; Y ); not winning (Y ): Some sample move graphs are shown in Fig. 1.
Reference: [17] <author> K. Kunen. </author> <title> Negation in logic programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 4(4) </volume> <pages> 289-308, </pages> <year> 1987. </year>
Reference-contexts: This research has proceeded in two general directions, which may be summarized as the "program completion" approach and the "canonical model" approach. 1.1 Program Completion Semantics The original "program completion" approach, due to Clark [6], and discussed in detail by Shepherdson [37, 38], Kunen <ref> [17] </ref>, and Lloyd [20], has been to define a new program, called the completed program (sometimes called the completed database). The completed program is treated simply as a first order formula (see Section 4). <p> Also, for some programs the completed program is inconsistent; for some others, the completed program is consistent but unintuitive. More importantly, on many natural examples it yields a surprisingly weak reasoning ability. We shall illustrate these claims with examples in Section 7. Fitting [9] and Kunen <ref> [17] </ref> gave markedly different, more uniform, semantics by interpreting the completed program in a 3-valued constructive logic, elegantly eliminating some difficulties of the Clark program completion approach. The third truth value, ?, connotes unknown truth value and is "less information than" both true and false, which are incomparable. <p> Hence I 0 is a total model. Our notion of partial model is not the same as the natural notions of models used in 3-valued logics, such as in the approaches of Fitting [9] and Kunen <ref> [17] </ref>. Nevertheless, the well-founded partial model we construct will also be a model in Fitting's 3-valued sense. <p> The formal details, including handling of variables and introduction of axioms for equality, are described in several places <ref> [6, 2, 20, 9, 17] </ref>. Example 4.1. <p> However, because the truth of each literal is based on traditional 2-valued logic, we call this the 2-valued program completion (2PC) interpretation. 9 The 3-valued interpretations were made explicit by Fitting [9] and Kunen <ref> [17] </ref>, who also used 3-valued logic to evaluate formulas. Whereas (p _ :p) must be true in 2-valued logic, in 3-valued logic it may also be ?. <p> Kunen describes a variant that differs from Fitting's in two important ways: (1) the iteration is always stopped at !, and (2) the Herbrand universe is defined with respect to a language with an infinite set of function symbols, which properly includes those that occur in the program <ref> [17] </ref>. The resulting 3-valued interpretation is recursively enumerable, but may not be a 3-valued model. <p> The need for factoring arises principally from "proof by cases", and sometimes from "proof by contradiction". However, factoring possibilities in the given program do not always carry over to the completed program, and a _ :a does not simplify to true in either 3-valued logic <ref> [9, 17] </ref> or intuitionistic logic [7]. Thus caution is needed to keep a coherent system.
Reference: [18] <author> K. Kunen. </author> <title> Some remarks on the completed database. </title> <type> Technical Report 775, </type> <institution> Univ. of Wisconsin, Madison, WI 53706, </institution> <year> 1988. </year> <booktitle> (Abstract appeared in 5th Int'l Conf. Symp. on Logic Programming, </booktitle> <address> Seattle, </address> <month> Aug. </month> <year> 1988). </year>
Reference-contexts: In fact, Kunen has recently shown that in his 3-valued logical consequence semantics, a "strict" logic program without function symbols cannot define a predicate that is true in the transitive closure, false in its complement, and nowhere undefined <ref> [18] </ref>. Informally, a "strict" program is one in which the dependence of one predicate on another (or itself) is either through an even number of negations or through an odd number, but not both.
Reference: [19] <author> V. Lifschitz. </author> <title> On the declarative semantics of logic programs with negation. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 177-192. </pages> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, CA, </address> <year> 1988. </year>
Reference-contexts: a: a: 6 Stratified and Locally Stratified Programs A program is stratified if all of its predicates can be assigned a rank such that * no predicate depends positively on one of greater rank, and * no predicate depends negatively on one of equal or greater rank in any rule <ref> [4, 1, 19, 40] </ref>. In the context of an IDB and EDB, the EDB, being a set of simple facts, has rank 0. IDB predicates whose defining rules involve no negation also have rank 0.
Reference: [20] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> New York, 2nd edition, </address> <year> 1987. </year>
Reference-contexts: This research has proceeded in two general directions, which may be summarized as the "program completion" approach and the "canonical model" approach. 1.1 Program Completion Semantics The original "program completion" approach, due to Clark [6], and discussed in detail by Shepherdson [37, 38], Kunen [17], and Lloyd <ref> [20] </ref>, has been to define a new program, called the completed program (sometimes called the completed database). The completed program is treated simply as a first order formula (see Section 4). Then the negative literals that are logical consequences of the completed program, and only those, should be considered true. <p> Jaffar, Lassez and Lloyd showed that SLDNF was complete (in the same sense) for Horn programs with non-floundering queries consisting of a conjunction of positive and/or negative literals [15]. SLDNF was further investigated for general logic programs by Lloyd <ref> [20] </ref> (who coined the term SLDNF), Shepherdson [37, 38] (q.v. for further bibliography), and others. <p> not b (X)." A Horn rule is one with no negative subgoals, and a Horn logic program is one with only Horn rules. 3 Lloyd has recently adopted the word "normal" instead of "general" to describe rules whose bodies consist of a conjunction of literals, and programs of such rules <ref> [20] </ref>. He reserves the word "general" to allow more involved constructs, such as w (X) m (X; Y ); not (m (Y; Z); not w (Z)): where the first not applies to a conjunction rather than an atom. <p> The formal details, including handling of variables and introduction of axioms for equality, are described in several places <ref> [6, 2, 20, 9, 17] </ref>. Example 4.1. <p> The original "logical consequence" approach essentially declares that only conclusions that are logical consequences (in the classical, 2-valued sense) of the completed program should be inferred <ref> [6, 15, 20, 37] </ref>. <p> The occurrence of a free variable Y in the negative subgoal is called "unsafe" because it is not limited to any domain. This derivation is said to have floundered <ref> [20] </ref>. Finally, let us note that in the unaugmented program p (1) is false in the well-founded semantics and in the Fitting semantics, but not in the 2PC semantics or Kunen semantics.
Reference: [21] <author> J. W. Lloyd and R. W. Topor. </author> <title> Making Prolog more expressive. </title> <journal> Journal of Logic Programming, </journal> <volume> 1(3) </volume> <pages> 225-240, </pages> <year> 1984. </year>
Reference-contexts: To specify the color property in our rule syntax, we require two mutually recursive IDB relations. The interested reader can work out the equivalent rules using a single relation in a language that supports a richer syntax for rule bodies <ref> [21, 28] </ref>. * color (Obj ; Pt; C) means that the visible color of Obj at Pt is C (looking down from above). * dominated (Obj ; Pt ; O1; L1) holds when two objects that are components of the same Obj overlap at point Pt and the object O1 is
Reference: [22] <author> M. J. Maher. </author> <title> Equivalences of logic programs. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 388-402. </pages> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, CA, </address> <year> 1988. </year>
Reference-contexts: Appendix A Augmented Programs Certain programs exhibit undesirable behavior when interpreted in the Herbrand universe, due to their containing what is called unsafe negation. A simple way to remove this behavior is to augment the program, as described in this appendix. We proceed informally here, and refer to <ref> [22] </ref> for a formal discussion. Definition A.1. Any general logic program P has an associated augmented program that is formed by adding the apparently nonsensical rule: $p ($f ($c)) $p ($f ($c)): where $p, $f , and $c are symbols that do not occur elsewhere in the program.
Reference: [23] <author> A. Marek and M. Truszczynski. </author> <title> Autoepistemic logic. </title> <type> Technical report, </type> <institution> University of Kentucky, </institution> <year> 1988. </year> <type> (manuscript). </type>
Reference-contexts: The theory has been further developed by Gelfond and Lifschitz [11], and also by Marek and Truszczynski <ref> [24, 23] </ref>. In this section we follow the definition of [11], which defines stability without reference to autoepistemic logic. We show that if a program has a total well-founded model, that model is the unique stable model. <p> We remark that the Fitting model also has polynomial data complexity (for function-free programs). The proof is identical to that of Theorem 8.1 above, except that a polynomial calculation of N P (see Def. 4.2) must be exhibited; but such a calculation is routine. In contrast, Marek and Truszczynski <ref> [23] </ref> have shown that, even for propositional general logic programs P, determining whether P has a stable model at all is NP-complete. 9 The Final Frontier? The major shortcoming of the well-founded semantics that we have found concerns its inability to handle conclusions that can be reached only by using factoring
Reference: [24] <author> W. Marek. </author> <title> Stable theories in autoepistemic logic. </title> <type> Technical report, </type> <institution> University of Kentucky, </institution> <year> 1986. </year> <type> (manuscript). </type>
Reference-contexts: The theory has been further developed by Gelfond and Lifschitz [11], and also by Marek and Truszczynski <ref> [24, 23] </ref>. In this section we follow the definition of [11], which defines stability without reference to autoepistemic logic. We show that if a program has a total well-founded model, that model is the unique stable model.
Reference: [25] <author> J. Minker. </author> <title> On indefinite databases and the closed world assumption. </title> <booktitle> In Sixth Conference on Automated Deduction, </booktitle> <pages> pages 292-308, </pages> <address> New York, 1982. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: A closely related idea, the closed world assumption, was introduced in the context of deductive databases by Reiter [33]. The generalized closed world assumption was proposed by Minker to handle disjunctive databases <ref> [25] </ref> without producing the inconsistency typical of the closed world assumption; it is discussed in Example 3.1. SLDNF is applied to the original program. <p> In this context, the generalized closed world assumption concludes that p is false if there is no minimal positive disjunction p _ q 1 _ _ q k that is a (2-valued) logical consequence of the clauses <ref> [25] </ref>. Here k may be zero, so that p is simply true. Disjunctive databases are quite different from logic programs because clauses have no "direction". Thus a not b and b not a are treated alike, as a _b.
Reference: [26] <author> R. C. Moore. </author> <title> Semantical considerations on non-monotonic logic. </title> <journal> Artificial Intelligence, </journal> <volume> 28 </volume> <pages> 75-94, </pages> <year> 1985. </year>
Reference-contexts: Kunen's main theorem is that this interpretation characterizes the 3-valued logical consequences of the completed program. 5 Stable Models Gelfond introduced an approach to negation through stable models [10], and motivated it by appealing to autoepistemic logic, as developed by Moore <ref> [26] </ref>. The theory has been further developed by Gelfond and Lifschitz [11], and also by Marek and Truszczynski [24, 23]. In this section we follow the definition of [11], which defines stability without reference to autoepistemic logic.
Reference: [27] <author> K. Morris. </author> <note> Talk at Workshop XP8.3i, </note> <institution> Oregon Graduate Center, </institution> <month> July </month> <year> 1987. </year>
Reference-contexts: The next example was inspired by an informal presentation by K. Morris of Stanford University <ref> [27] </ref>. It shows how the negation issues addressed by this paper might easily arise in practical settings. Example 7.4. We imagine a logic program that might be part of a VLSI CAD system, whose function is to display a VLSI chip that has been hierarchically defined.
Reference: [28] <author> K. Morris, J. D. Ullman, and A. Van Gelder. </author> <title> Design overview of the Nail! system. </title> <booktitle> In Third Int'l Conf. on Logic Programming, </booktitle> <pages> pages 554-568, </pages> <year> 1986. </year>
Reference-contexts: To specify the color property in our rule syntax, we require two mutually recursive IDB relations. The interested reader can work out the equivalent rules using a single relation in a language that supports a richer syntax for rule bodies <ref> [21, 28] </ref>. * color (Obj ; Pt; C) means that the visible color of Obj at Pt is C (looking down from above). * dominated (Obj ; Pt ; O1; L1) holds when two objects that are components of the same Obj overlap at point Pt and the object O1 is
Reference: [29] <author> Y. N. Moschovakis. </author> <title> Elementary Induction on Abstract Structures. </title> <publisher> North-Holland, </publisher> <address> New York, </address> <year> 1974. </year>
Reference-contexts: For successor ordinal ff = fl + 1, I fl+1 = W P (I fl ) 3. Finally, define I 1 = [ I ff Following Moschovakis <ref> [29] </ref>, for any literal p in I 1 , we define the stage of p to be the least ordinal ff such that p 2 I ff . We observe that the stage is always a successor ordinal for literals in I 1 . Lemma 3.4. <p> The Herbrand base is countable, so for some countable ordinal ff, I 1 = I ff . Definition 3.5. The closure ordinal for the sequence I ff is the least ordinal ff such that I 1 = I ff (cf. <ref> [29] </ref>). Examples can be constructed where the closure ordinal is above !, but the authors believe such examples to be very rare in practical logic programming.
Reference: [30] <author> H. Przymusinska and T. C. Przymusinski. </author> <title> Weakly perfect model semantics for logic programs. </title> <booktitle> In Fifth Int'l Conf. Symp. on Logic Programming, </booktitle> <pages> pages 1106-1120, </pages> <address> Seattle, </address> <year> 1988. </year>
Reference-contexts: which winning depends negatively upon itself, as in winning (a) move (a; a); not winning (a): This also destroys the perfect model even though move (a; a) does not occur in the EDB. 4 Recently, Przymusinska and Przmusinski have defined weakly perfect models to handle programs such as this example <ref> [30] </ref>. The next example was inspired by an informal presentation by K. Morris of Stanford University [27]. It shows how the negation issues addressed by this paper might easily arise in practical settings. Example 7.4.
Reference: [31] <author> T. C. Przymusinski. </author> <title> On the declarative semantics of deductive databases and logic programs. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 193-216. </pages> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, CA, </address> <year> 1988. </year> <month> 25 </month>
Reference-contexts: The stratified class has been treated in [4, 1, 19, 1 By "interpreter," we mean any mechanism for executing the program, including a compiler. 2 40], and elsewhere. The locally stratified class, defined and studied by Przymusinski <ref> [31] </ref>, is a superset of the class of stratified programs. He defined perfect models, and showed that every locally stratified program has a unique perfect model. These classes are discussed further in Section 6. <p> a finer grain by defining a program to be locally stratified if each atom in its Herbrand base can be assigned a countable ordinal rank such that no atom depends on an atom of greater rank or depends negatively on one of equal or greater rank in any instantiated rule <ref> [31] </ref>. Note that the program is stratified if all atoms with the same predicate symbol can be assigned the same rank. The extension handles situations where the "recursive negation" is apparent, but not real. <p> A typical example is the program even (s (X)) not even (X): even (0): where each ground atom can be given a rank equal to the power of s in its argument. To give a semantics to locally stratified programs Przymusinski <ref> [31] </ref> has given a definition for perfect model .
Reference: [32] <author> T. C. Przymusinski. </author> <title> Every logic program has a natural stratification and an iterated fixed point model. </title> <booktitle> In Eighth ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 11-21, </pages> <year> 1989. </year>
Reference-contexts: Unfounded sets are defined in Section 3. Since the preliminary version of this paper was presented at a conference [43], several alternative formulations of negation that appear to be equivalent to the well-founded semantics have been developed <ref> [3, 8, 32, 42] </ref>. <p> Truth values are assigned (in the authors' judgement) in a reasonably predictable and intuitively satisfying way. Elsewhere, the expressive power of the well-founded semantics has been compared to several forms of fixpoint logic [42]. A corresponding procedural semantics has been reported for some classes of programs <ref> [35, 32] </ref>. Acknowledgements We wish to thank Jerzy Jaromczyk, Phokion Kolaitis, Vladimir Lifschitz, Wiktor Marek, Rodney Topor, and Moshe Vardi for helpful discussions and comments about this work. We also thank the anonymous referees for their careful readings of the manuscript and many useful suggestions.
Reference: [33] <author> R. Reiter. </author> <title> On closed world databases. </title> <editor> In Gallaire and Minker, editors, </editor> <booktitle> Logic and Databases, </booktitle> <pages> pages 55-76. </pages> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: A closely related idea, the closed world assumption, was introduced in the context of deductive databases by Reiter <ref> [33] </ref>. The generalized closed world assumption was proposed by Minker to handle disjunctive databases [25] without producing the inconsistency typical of the closed world assumption; it is discussed in Example 3.1. SLDNF is applied to the original program. <p> See [41] for a discussion of how the canonical model approach can benefit application development. Another motivation for concentrating on canonical models is the view, expounded by Reiter <ref> [33] </ref>, that many logic programs are appropriately thought of as having two components, an intensional database (IDB) that represents the reasoning component, and the extensional database (EDB) that represents a collection of facts.
Reference: [34] <author> K. Ross and R. W. Topor. </author> <title> Inferring negative information from disjunctive databases. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 4 </volume> <pages> 397-424, </pages> <year> 1988. </year>
Reference-contexts: The key idea in our formulation is the concept of an "unfounded set," which is an adaptation of the "closed set" developed for disjunctive databases by Ross and Topor <ref> [34] </ref>, and is essentially the same as the "securable set" in [36]. Unfounded sets are defined in Section 3. <p> We shall discuss 3-valued models in Section 4. 3 Unfounded Sets and Well-Founded Partial Models In this section we define unfounded sets, which are a variation of closed sets that were defined for disjunctive databases by Ross and Topor in <ref> [34] </ref>. Unfounded sets provide the basis for negative conclusions in the well-founded semantics. 3.1 Unfounded Sets Definition 3.1. Let a program P, its associated Herbrand base H, and a partial interpretation I be given. <p> As described more formally later, the well-founded semantics uses conditions (1) and (2) to draw negative conclusions. Essentially, it simultaneously infers all atoms in A to be false. By contrast, the semantics of [9] uses only condition (1) to draw negative conclusions. The closed sets of Ross and Topor <ref> [34] </ref> were defined only with condition (2). Example 3.1.
Reference: [35] <author> K. A. Ross. </author> <title> A procedural semantics for well-founded negation in logic programs. </title> <booktitle> In Eighth ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 22-33, </pages> <year> 1989. </year>
Reference-contexts: Truth values are assigned (in the authors' judgement) in a reasonably predictable and intuitively satisfying way. Elsewhere, the expressive power of the well-founded semantics has been compared to several forms of fixpoint logic [42]. A corresponding procedural semantics has been reported for some classes of programs <ref> [35, 32] </ref>. Acknowledgements We wish to thank Jerzy Jaromczyk, Phokion Kolaitis, Vladimir Lifschitz, Wiktor Marek, Rodney Topor, and Moshe Vardi for helpful discussions and comments about this work. We also thank the anonymous referees for their careful readings of the manuscript and many useful suggestions.
Reference: [36] <author> J. S. Schlipf. </author> <title> Negation by securable failure in logic programming. </title> <type> (manuscript), </type> <year> 1987. </year>
Reference-contexts: The key idea in our formulation is the concept of an "unfounded set," which is an adaptation of the "closed set" developed for disjunctive databases by Ross and Topor [34], and is essentially the same as the "securable set" in <ref> [36] </ref>. Unfounded sets are defined in Section 3. Since the preliminary version of this paper was presented at a conference [43], several alternative formulations of negation that appear to be equivalent to the well-founded semantics have been developed [3, 8, 32, 42].
Reference: [37] <author> J. C. Shepherdson. </author> <title> Negation as failure, II. </title> <journal> Journal of Logic Programming, </journal> <volume> 2(3) </volume> <pages> 185-202, </pages> <year> 1985. </year>
Reference-contexts: This research has proceeded in two general directions, which may be summarized as the "program completion" approach and the "canonical model" approach. 1.1 Program Completion Semantics The original "program completion" approach, due to Clark [6], and discussed in detail by Shepherdson <ref> [37, 38] </ref>, Kunen [17], and Lloyd [20], has been to define a new program, called the completed program (sometimes called the completed database). The completed program is treated simply as a first order formula (see Section 4). <p> Jaffar, Lassez and Lloyd showed that SLDNF was complete (in the same sense) for Horn programs with non-floundering queries consisting of a conjunction of positive and/or negative literals [15]. SLDNF was further investigated for general logic programs by Lloyd [20] (who coined the term SLDNF), Shepherdson <ref> [37, 38] </ref> (q.v. for further bibliography), and others. <p> The original "logical consequence" approach essentially declares that only conclusions that are logical consequences (in the classical, 2-valued sense) of the completed program should be inferred <ref> [6, 15, 20, 37] </ref>.
Reference: [38] <author> J. C. Shepherdson. </author> <title> Negation in logic programming. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 19-88. </pages> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, CA, </address> <year> 1988. </year>
Reference-contexts: This research has proceeded in two general directions, which may be summarized as the "program completion" approach and the "canonical model" approach. 1.1 Program Completion Semantics The original "program completion" approach, due to Clark [6], and discussed in detail by Shepherdson <ref> [37, 38] </ref>, Kunen [17], and Lloyd [20], has been to define a new program, called the completed program (sometimes called the completed database). The completed program is treated simply as a first order formula (see Section 4). <p> Jaffar, Lassez and Lloyd showed that SLDNF was complete (in the same sense) for Horn programs with non-floundering queries consisting of a conjunction of positive and/or negative literals [15]. SLDNF was further investigated for general logic programs by Lloyd [20] (who coined the term SLDNF), Shepherdson <ref> [37, 38] </ref> (q.v. for further bibliography), and others.
Reference: [39] <author> M. H. Van Emden and R. A. Kowalski. </author> <title> The semantics of predicate logic as a programming language. </title> <journal> JACM, </journal> <volume> 23(4) </volume> <pages> 733-742, </pages> <year> 1976. </year>
Reference-contexts: Simultaneously negating all the atoms in an unfounded set generalizes negation by failure in Horn clause programs; if H is the Herbrand base and I is the set of atoms that represents the minimum Herbrand model of a Horn clause program <ref> [39] </ref>, then H I, the set of atoms not in I, is unfounded with respect to I. 6 We now formalize the intuition of the preceding discussion. It is immediate that the union of arbitrary unfounded sets is an unfounded set. This leads naturally to: Definition 3.2. <p> Theorem 3.7. Every Horn program has a well-founded model I 1 , which is the minimum model in the sense of Van Emden and Kowalski <ref> [39] </ref>, i.e., its positive literals are contained in every Herbrand model. Proof. Let H be the Herbrand base and let Q be the set of positive literals of I 1 . Q is a fixed point of T P [39]. <p> the minimum model in the sense of Van Emden and Kowalski <ref> [39] </ref>, i.e., its positive literals are contained in every Herbrand model. Proof. Let H be the Herbrand base and let Q be the set of positive literals of I 1 . Q is a fixed point of T P [39]. In view of Theorem 3.6 it is sufficient to show that H Q U P (I 1 ). Let p be any positive literal in H Q. <p> We call P 00 the reduction of P with respect to I. 3. Since P 00 is a Horn program, we can form its minimum (2-valued) model as in the standard Van Emden and Kowalski semantics <ref> [39] </ref>. In this context, "minimum," means that the set of positive literals is minimized, and hence the set of negative literals is maximized. We define S (I) to be this minimum model of P 00 . Example 5.1.
Reference: [40] <author> A. Van Gelder. </author> <title> Negation as failure using tight derivations for general logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 6(1) </volume> <pages> 109-133, </pages> <year> 1989. </year> <note> Preliminary versions appeared in Third IEEE Symp. on Logic Programming (1986), and Foundations of Deductive Databases and Logic Programming, </note> <editor> J. Minker, ed., </editor> <publisher> Morgan Kaufmann, </publisher> <year> 1988. </year>
Reference-contexts: a: a: 6 Stratified and Locally Stratified Programs A program is stratified if all of its predicates can be assigned a rank such that * no predicate depends positively on one of greater rank, and * no predicate depends negatively on one of equal or greater rank in any rule <ref> [4, 1, 19, 40] </ref>. In the context of an IDB and EDB, the EDB, being a set of simple facts, has rank 0. IDB predicates whose defining rules involve no negation also have rank 0. <p> We shall prove a somewhat stronger result below. From another point of view, Van Gelder has shown that stratified programs that satisfy certain other conditions have a model based on "tight derivations" that coincides with the stratified model <ref> [40] </ref>.
Reference: [41] <author> A. Van Gelder. </author> <title> Modeling simultaneous events with default reasoning and tight derivations. </title> <journal> Journal of Logic Programming, </journal> <volume> 8(1) </volume> <pages> 41-52, </pages> <year> 1990. </year>
Reference-contexts: The advantage of assigning a canonical model to a program is that one now has a standard for correctness of an interpreter 1 on all goals it must conform to the canonical model, and succeed or fail appropriately. See <ref> [41] </ref> for a discussion of how the canonical model approach can benefit application development. <p> A more involved example in which constraints on the EDB can be specified to guarantee that the well-founded model is total is discussed elsewhere <ref> [41] </ref>. Example 7.3. This example is essentially the same as one discussed by Gelfond and Lifschitz [11], and is one of the examples that led to the formulation of well-founded semantics, as well as stable models.
Reference: [42] <author> A. Van Gelder. </author> <title> The alternating fixpoint of logic programs with negation. </title> <journal> Journal of Computer and System Sciences, </journal> <note> 1992. (to appear). Available as UCSC-CRL-89-39. Preliminary abstract appeared in Eighth ACM Symposium on Principles of Database Systems, </note> <year> 1989. </year>
Reference-contexts: Unfounded sets are defined in Section 3. Since the preliminary version of this paper was presented at a conference [43], several alternative formulations of negation that appear to be equivalent to the well-founded semantics have been developed <ref> [3, 8, 32, 42] </ref>. <p> Nonstrict programs in the Fitting semantics are known to exist, by the work of Immermann [14], but are quite complicated; details are discussed elsewhere by Van Gelder <ref> [42] </ref>. As another motivational example, we consider a program that is not locally stratified, as defined in Section 6, yet has a well-founded model when the EDB relation is acyclic. <p> Truth values are assigned (in the authors' judgement) in a reasonably predictable and intuitively satisfying way. Elsewhere, the expressive power of the well-founded semantics has been compared to several forms of fixpoint logic <ref> [42] </ref>. A corresponding procedural semantics has been reported for some classes of programs [35, 32]. Acknowledgements We wish to thank Jerzy Jaromczyk, Phokion Kolaitis, Vladimir Lifschitz, Wiktor Marek, Rodney Topor, and Moshe Vardi for helpful discussions and comments about this work.
Reference: [43] <author> A. Van Gelder, K. A. Ross, and J. S. Schlipf. </author> <title> Unfounded sets and well-founded semantics for general logic programs. </title> <booktitle> In ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 221-230, </pages> <year> 1988. </year>
Reference-contexts: Unfounded sets are defined in Section 3. Since the preliminary version of this paper was presented at a conference <ref> [43] </ref>, several alternative formulations of negation that appear to be equivalent to the well-founded semantics have been developed [3, 8, 32, 42].
Reference: [44] <author> Moshe Vardi. </author> <title> The complexity of relational query languages. </title> <booktitle> In 14th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 137-145, </pages> <year> 1982. </year> <month> 26 </month>
Reference-contexts: However, for function-free logic programs (a class that has come to be known as Datalog), the Herbrand universe is finite and the construction is effective. In this section we show that the data complexity of the well-founded semantics, as defined by Vardi <ref> [44] </ref>, is polynomial. From this standpoint it is competitive with other methods, such as stratified semantics, whose data complexity has been studied elsewhere [5, 44, 12, 14], and the Fitting model (as remarked below). <p> In this section we show that the data complexity of the well-founded semantics, as defined by Vardi [44], is polynomial. From this standpoint it is competitive with other methods, such as stratified semantics, whose data complexity has been studied elsewhere <ref> [5, 44, 12, 14] </ref>, and the Fitting model (as remarked below). In this discussion of complexity we restrict attention to function-free programs, so a program's Herbrand universe is just the set of constants appearing in it. <p> This sort of argument is standard; see <ref> [5, 44, 12, 14] </ref>, etc. Similar standard arguments show that calculating T P can be done in polynomial time. So we need only show that each U P (I ff ) can be found in polynomial time. Clearly, we may restrict attention to finite ff.
References-found: 44

