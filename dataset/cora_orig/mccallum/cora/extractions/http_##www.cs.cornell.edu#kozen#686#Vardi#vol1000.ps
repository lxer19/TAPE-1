URL: http://www.cs.cornell.edu/kozen/686/Vardi/vol1000.ps
Refering-URL: http://www.cs.cornell.edu/kozen/686/
Root-URL: 
Email: Email: vardi@cs.rice.edu  
Title: Alternating Automata and Program Verification  
Author: Moshe Y. Vardi 
Web: URL: http://www.cs.rice.edu/ vardi  
Address: P.O. Box 1892 Houston, TX 77251-1892, U.S.A.  
Affiliation: Rice University Department of Computer Science  
Abstract: We describe an automata-theoretic approach to the automatic verification of finite-state programs. The basic idea underlying this approach is that for any temporal formula we can construct an alternating automaton that accepts precisely the computations that satisfy the formula. For linear temporal logics the automaton runs on infinite words while for branching temporal logics the automaton runs on infinite trees. The simple combinatorial structures that emerge from the automata-theoretic approach decouple the logical and algorithmic components of finite-state-program verification and yield clear and general verification algorithms.
Abstract-found: 1
Intro-found: 1
Reference: [BL80] <author> J.A. Brzozowski and E. Leiss. </author> <title> Finite automata, and sequential networks. </title> <journal> Theoretical Computer Science, </journal> <volume> 10 </volume> <pages> 19-35, </pages> <year> 1980. </year>
Reference-contexts: Its dual gives a computing device the power of universal choice. It is therefore natural to consider computing devices that have the power of both existential choice and universal choice. Such devices are called alternating. Alternation was studied in [CKS81] in the context of Turing machines and in <ref> [BL80, CKS81] </ref> for finite automata. The alternation formalisms in [BL80] and [CKS81] are different, though equivalent. We follow here the formalism of [BL80], which was extended in [MS87] to automata on infinite structures. <p> It is therefore natural to consider computing devices that have the power of both existential choice and universal choice. Such devices are called alternating. Alternation was studied in [CKS81] in the context of Turing machines and in [BL80, CKS81] for finite automata. The alternation formalisms in <ref> [BL80] </ref> and [CKS81] are different, though equivalent. We follow here the formalism of [BL80], which was extended in [MS87] to automata on infinite structures. <p> Such devices are called alternating. Alternation was studied in [CKS81] in the context of Turing machines and in [BL80, CKS81] for finite automata. The alternation formalisms in <ref> [BL80] </ref> and [CKS81] are different, though equivalent. We follow here the formalism of [BL80], which was extended in [MS87] to automata on infinite structures. For a given set X, let B + (X) be the set of positive Boolean formulas over X (i.e., Boolean formulas built from elements in X using ^ and _), where we also allow the formulas true and false.
Reference: [BVW94] <author> O. Bernholtz, M.Y. Vardi, and P. Wolper. </author> <title> An automata-theoretic approach to branching-time model checking. </title> <editor> In D.L. Dill, editor, </editor> <booktitle> Computer Aided Verification, Proc. 6th Int. Conference, volume 818 of Lecture Notes in Computer Science, </booktitle> <pages> pages 142-155, </pages> <address> Stanford, California, 1994. </address> <publisher> Springer-Verlag, </publisher> <address> Berlin. </address> <note> full version available from authors. </note>
Reference-contexts: Thus, the automata-theoretic approach did not seem to be applicable to branching-time model checking, which in many cases can be done in linear running time [CES86, QS81, Cle93], Recently it has been shown that if one uses alternating automata rather than nondeterministic automata, then these problems can be solved <ref> [Var94, BVW94] </ref>. Alternating automata generalize the standard notion of nondeterministic automata by allowing several successor states to go down along the same word or the same branch of the tree. <p> We demonstrate this claim by showing how alternating automata can be used to derive model-checking algorithms for both linear and branching temporal logics. The key observation is that while the translation from temporal logic formulas to nondeterministic automata is exponential [VW86b, VW94], the translation to alternating automata is linear <ref> [MSS88, EJ91, Var94, BVW94] </ref>. Thus, the advantage of alternating automata is that they enable one to decouple the logic from the combinatorics. <p> The number of sets in the partition of S is defined as the depth of the automaton. It turns out that the nonemptiness problem for WAA on 1-letter alphabets is easier than nonemptiness problem for alternating Buchi automata on 1-letter alphabets. Proposition 9. <ref> [BVW94] </ref> The nonemptiness problem for weak alternating tree automata on 1-letter alphabets is decidable in linear time. As we will see, the WAA that we use have an even more special structure. <p> It turns out that the tree programs satisfying a given formula are exactly those accepted by some finite tree automaton. The following theorem establishes a very simple translation between CTL and weak alternating Buchi tree automata. Theorem 13. <ref> [MSS88, BVW94] </ref> Given a CTL formula ' and a finite set D N , one can build a limited-alternation WAA A ' = (; D; S; s 0 ; ; F ), where = 2 P rop and jSj is in O (j'j), such that T ! (A ' ) is <p> Proposition 15. A P;' is nonempty if and only if P j= '. We can now put together Propositions 9, 10, and 15 to get a model-checking algorithm for CTL. Theorem 16. <ref> [CES86, BVW94] </ref> Checking whether a finite-state program P satisfies a CTL formula ' can be done in time O (jP j j'j) or in space O (j'j log 2 jP j). Acknowledgements. I am grateful to Orna Kupferman for her careful reading of and comments on this article.
Reference: [CES86] <author> E.M. Clarke, </author> <title> E.A. Emerson, and A.P. Sistla. Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <year> 1986. </year>
Reference-contexts: One of the most significant developments in this area is the discovery of algorithmic methods for verifying temporal logic properties of finite-state programs <ref> [CES86, LP85, QS81] </ref>. This derives its significance from the fact that many synchronization and communication protocols can be modeled as finite-state programs [Liu89, Rud87]. <p> This suggests that any algorithm that uses these translations as one of its steps is going to be an exponential-time algorithm. Thus, the automata-theoretic approach did not seem to be applicable to branching-time model checking, which in many cases can be done in linear running time <ref> [CES86, QS81, Cle93] </ref>, Recently it has been shown that if one uses alternating automata rather than nondeterministic automata, then these problems can be solved [Var94, BVW94]. <p> Proposition 15. A P;' is nonempty if and only if P j= '. We can now put together Propositions 9, 10, and 15 to get a model-checking algorithm for CTL. Theorem 16. <ref> [CES86, BVW94] </ref> Checking whether a finite-state program P satisfies a CTL formula ' can be done in time O (jP j j'j) or in space O (j'j log 2 jP j). Acknowledgements. I am grateful to Orna Kupferman for her careful reading of and comments on this article.
Reference: [CG87] <author> E.M. Clarke and O. Grumberg. </author> <title> Avoiding the state explosion problem in temporal logic model-checking algorithms. </title> <booktitle> In Proc. 6th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 294-303, </pages> <address> Vancouver, British Columbia, </address> <month> August </month> <year> 1987. </year>
Reference-contexts: Hence the name model checking for the verification methods derived from this viewpoint. Surveys can be found in <ref> [CG87, Wol89, CGL93] </ref>. We distinguish between two types of temporal logics: linear and branching [Lam80]. In linear temporal logics, each moment in time has a unique possible future, while in branching temporal logics, each moment in time may split into several possible futures.
Reference: [CGL93] <author> E.M. Clarke, O. Grumberg, and D. </author> <title> Long. Verification tools for finite-state concurrent systems. </title> <booktitle> In A Decade of Concurrency Reflections and Perspectives (Proc. REX School/Symposium), volume 803 of Lecture Notes in Computer Science, </booktitle> <pages> pages 124-175. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1993. </year>
Reference-contexts: Hence the name model checking for the verification methods derived from this viewpoint. Surveys can be found in <ref> [CG87, Wol89, CGL93] </ref>. We distinguish between two types of temporal logics: linear and branching [Lam80]. In linear temporal logics, each moment in time has a unique possible future, while in branching temporal logics, each moment in time may split into several possible futures.
Reference: [Cho74] <author> Y. Choueka. </author> <title> Theories of automata on !-tapes: A simplified approach. </title> <journal> J. Computer and System Sciences, </journal> <volume> 8 </volume> <pages> 117-141, </pages> <year> 1974. </year>
Reference-contexts: The infinite word w is accepted by A if there is an accepting run of A on w. The set of infinite words accepted by A is denoted L ! (A). An important feature of nondeterministic Buchi automata is their closure under intersection. Proposition 1. <ref> [Cho74] </ref> Let A 1 and A 2 be nondeterministic B uchi automata with n 1 and n 2 states, respectively.
Reference: [CKS81] <author> A.K. Chandra, D.C. Kozen, and L.J. Stockmeyer. </author> <title> Alternation. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 28(1) </volume> <pages> 114-133, </pages> <year> 1981. </year>
Reference-contexts: Its dual gives a computing device the power of universal choice. It is therefore natural to consider computing devices that have the power of both existential choice and universal choice. Such devices are called alternating. Alternation was studied in <ref> [CKS81] </ref> in the context of Turing machines and in [BL80, CKS81] for finite automata. The alternation formalisms in [BL80] and [CKS81] are different, though equivalent. We follow here the formalism of [BL80], which was extended in [MS87] to automata on infinite structures. <p> Its dual gives a computing device the power of universal choice. It is therefore natural to consider computing devices that have the power of both existential choice and universal choice. Such devices are called alternating. Alternation was studied in [CKS81] in the context of Turing machines and in <ref> [BL80, CKS81] </ref> for finite automata. The alternation formalisms in [BL80] and [CKS81] are different, though equivalent. We follow here the formalism of [BL80], which was extended in [MS87] to automata on infinite structures. <p> It is therefore natural to consider computing devices that have the power of both existential choice and universal choice. Such devices are called alternating. Alternation was studied in <ref> [CKS81] </ref> in the context of Turing machines and in [BL80, CKS81] for finite automata. The alternation formalisms in [BL80] and [CKS81] are different, though equivalent. We follow here the formalism of [BL80], which was extended in [MS87] to automata on infinite structures.
Reference: [Cle93] <author> R. Cleaveland. </author> <title> A linear-time model-checking algorithm for the alternation-free modal -calculus. </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> 2 </volume> <pages> 121-147, </pages> <year> 1993. </year>
Reference-contexts: This suggests that any algorithm that uses these translations as one of its steps is going to be an exponential-time algorithm. Thus, the automata-theoretic approach did not seem to be applicable to branching-time model checking, which in many cases can be done in linear running time <ref> [CES86, QS81, Cle93] </ref>, Recently it has been shown that if one uses alternating automata rather than nondeterministic automata, then these problems can be solved [Var94, BVW94].
Reference: [CVWY92] <author> C. Courcoubetis, M.Y. Vardi, P. Wolper, and M. Yannakakis. </author> <title> Memory efficient algorithms for the verification of temporal properties. </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> 1 </volume> <pages> 275-288, </pages> <year> 1992. </year>
Reference-contexts: For a practical verification algorithm that is based on the automata-theoretic approach see <ref> [CVWY92] </ref>. 4.2 Branching Temporal Logic For linear temporal logic, each program may correspond to infinitely many computations. Model checking is thus reduced to checking inclusion between the set of computations allowed by the program and the language of an automaton describing the formula.
Reference: [EJ88] <author> E.A. Emerson and C. Jutla. </author> <title> The complexity of tree automata and logics of programs. </title> <booktitle> In Proceedings of the 29th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 328-337, </pages> <address> White Plains, </address> <month> October </month> <year> 1988. </year>
Reference-contexts: For linear temporal logic the structures are infinite words [WVS83, Sis83, LPZ85, Pei85, SVW87, VW94], while for branching temporal logic the structures are infinite trees <ref> [ES84, SE84, Eme85, EJ88, VW86b] </ref>. This enables the reduction of temporal logic decision problems, such as satisfiability, to known automata-theoretic problems, such as nonemptiness, yielding clean and asymptotically optimal algorithms. Initially, the translations in the literature from temporal logic formulas to automata used nondeterministic automata (cf. [VW86b, VW94]).
Reference: [EJ91] <author> E.A. Emerson and C. Jutla. </author> <title> Tree automata, mu-calculus and determinacy. </title> <booktitle> In Proceedings of the 32nd IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 368-377, </pages> <address> San Juan, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: We demonstrate this claim by showing how alternating automata can be used to derive model-checking algorithms for both linear and branching temporal logics. The key observation is that while the translation from temporal logic formulas to nondeterministic automata is exponential [VW86b, VW94], the translation to alternating automata is linear <ref> [MSS88, EJ91, Var94, BVW94] </ref>. Thus, the advantage of alternating automata is that they enable one to decouple the logic from the combinatorics.
Reference: [EL85a] <author> E.A. Emerson and C.-L. Lei. </author> <title> Modalities for model checking: Branching time logic strikes back. </title> <booktitle> In Proceedings of the Twelfth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 84-96, </pages> <address> New Orleans, </address> <month> January </month> <year> 1985. </year>
Reference-contexts: A Buchi automaton A is nonempty if L ! (A) 6= ;. The nonemptiness problem for automata is to decide, given an automaton A, whether A is nonempty. It turns out that testing nonemptiness is easy. Proposition 2. 1. <ref> [EL85b, EL85a] </ref> The nonemptiness problem for nondeterministic B uchi automata is decidable in linear time. 2. [VW94] The nonemptiness problem for nondeterministic B uchi automata of size n is decidable in space O (log 2 n). 2.3 Alternating Automata on Infinite Words Nondeterminism gives a computing device the power of existential
Reference: [EL85b] <author> E.A. Emerson and C.-L. Lei. </author> <title> Temporal model checking under generalized fairness constraints. </title> <booktitle> In Proc. 18th Hawaii International Conference on System Sciences, </booktitle> <pages> pages 277-288, </pages> <address> Hawaii, </address> <year> 1985. </year>
Reference-contexts: A Buchi automaton A is nonempty if L ! (A) 6= ;. The nonemptiness problem for automata is to decide, given an automaton A, whether A is nonempty. It turns out that testing nonemptiness is easy. Proposition 2. 1. <ref> [EL85b, EL85a] </ref> The nonemptiness problem for nondeterministic B uchi automata is decidable in linear time. 2. [VW94] The nonemptiness problem for nondeterministic B uchi automata of size n is decidable in space O (log 2 n). 2.3 Alternating Automata on Infinite Words Nondeterminism gives a computing device the power of existential
Reference: [Eme85] <author> E.A. Emerson. </author> <title> Automata, tableaux, and temporal logics. In Logic of Programs, </title> <booktitle> volume 193 of Lecture Notes in Computer Science, </booktitle> <pages> pages 79-87. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1985. </year>
Reference-contexts: For linear temporal logic the structures are infinite words [WVS83, Sis83, LPZ85, Pei85, SVW87, VW94], while for branching temporal logic the structures are infinite trees <ref> [ES84, SE84, Eme85, EJ88, VW86b] </ref>. This enables the reduction of temporal logic decision problems, such as satisfiability, to known automata-theoretic problems, such as nonemptiness, yielding clean and asymptotically optimal algorithms. Initially, the translations in the literature from temporal logic formulas to automata used nondeterministic automata (cf. [VW86b, VW94]).
Reference: [Eme90] <author> E.A. Emerson. </author> <title> Temporal and modal logic. </title> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <address> B:997-1072, </address> <year> 1990. </year>
Reference-contexts: 2 n). 3 Temporal Logics and Alternating Automata 3.1 Linear Temporal Logic Formulas of linear temporal logic (LTL) are built from a set P rop of atomic propositions and are closed under the application of Boolean connectives, the unary temporal connective X (next), and the binary temporal connective U (until) <ref> [Eme90] </ref>. LTL is interpreted over computations. A computation is a function : ! ! 2 P rop , which assigns truth values to the elements of P rop at each time instant (natural number). <p> O (j'j) , such that L ! (A ' ) is exactly the set of computations satisfying the formula '. 3.2 Branching Temporal Logic The branching temporal logic CTL (Computation Tree Logic) provides temporal con-nectives that are composed of a path quantifier immediately followed by a single linear temporal connective <ref> [Eme90] </ref>. The path quantifiers are A (for all paths) and E (for some path). The linear-time connectives are X (next time) and U (until).
Reference: [ES84] <author> E.A. Emerson and A. P. Sistla. </author> <title> Deciding branching time logic. </title> <booktitle> In Proceedings of the 16th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 14-24, </pages> <address> Washington, </address> <month> April </month> <year> 1984. </year>
Reference-contexts: For linear temporal logic the structures are infinite words [WVS83, Sis83, LPZ85, Pei85, SVW87, VW94], while for branching temporal logic the structures are infinite trees <ref> [ES84, SE84, Eme85, EJ88, VW86b] </ref>. This enables the reduction of temporal logic decision problems, such as satisfiability, to known automata-theoretic problems, such as nonemptiness, yielding clean and asymptotically optimal algorithms. Initially, the translations in the literature from temporal logic formulas to automata used nondeterministic automata (cf. [VW86b, VW94]).
Reference: [Lam80] <author> L. Lamport. </author> <title> Sometimes is sometimes not never on the temporal logic of programs. </title> <booktitle> In Proceedings of the 7th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 174-185, </pages> <month> January </month> <year> 1980. </year>
Reference-contexts: Hence the name model checking for the verification methods derived from this viewpoint. Surveys can be found in [CG87, Wol89, CGL93]. We distinguish between two types of temporal logics: linear and branching <ref> [Lam80] </ref>. In linear temporal logics, each moment in time has a unique possible future, while in branching temporal logics, each moment in time may split into several possible futures.
Reference: [Liu89] <author> M.T. Liu. </author> <title> Protocol engineering. </title> <booktitle> Advances in Computing, </booktitle> <volume> 29 </volume> <pages> 79-195, </pages> <year> 1989. </year>
Reference-contexts: One of the most significant developments in this area is the discovery of algorithmic methods for verifying temporal logic properties of finite-state programs [CES86, LP85, QS81]. This derives its significance from the fact that many synchronization and communication protocols can be modeled as finite-state programs <ref> [Liu89, Rud87] </ref>. Finite-state programs can be modeled by transition systems where each state has a bounded description, and hence can be characterized by a fixed number of Boolean atomic propositions.
Reference: [LP85] <author> O. Lichtenstein and A. Pnueli. </author> <title> Checking that finite state concurrent programs satisfy their linear specification. </title> <booktitle> In Proceedings of the Twelfth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 97-107, </pages> <address> New Orleans, </address> <month> January </month> <year> 1985. </year>
Reference-contexts: One of the most significant developments in this area is the discovery of algorithmic methods for verifying temporal logic properties of finite-state programs <ref> [CES86, LP85, QS81] </ref>. This derives its significance from the fact that many synchronization and communication protocols can be modeled as finite-state programs [Liu89, Rud87]. <p> Consequently, we can build an automaton for L ! (A P ) " L ! (A :' ) having jW j 2 O (j'j) states. We need to check this automaton for emptiness. Using Proposition 2, we get the following results. Theorem 14. <ref> [LP85, SC85, VW86a] </ref> Checking whether a finite-state program P satisfies an LTL formula ' can be done in time O (jP j2 O (j'j) ) or in space O ((j'j+log jP j) 2 ). <p> We note that a time upper bound that is polynomial in the size of the program and exponential in the size of the specification is considered here to be reasonable, since the specification is usually rather short <ref> [LP85] </ref>. For a practical verification algorithm that is based on the automata-theoretic approach see [CVWY92]. 4.2 Branching Temporal Logic For linear temporal logic, each program may correspond to infinitely many computations.
Reference: [LPZ85] <author> O. Lichtenstein, A. Pnueli, and L. Zuck. </author> <title> The glory of the past. In Logics of Programs, </title> <booktitle> volume 193 of Lecture Notes in Computer Science, </booktitle> <pages> pages 196-218, </pages> <address> Brooklyn, 1985. </address> <publisher> Springer-Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: The basic idea is to associate with ? Part of this work was done at the IBM Almaden Research Center. each temporal logic formula a finite automaton on infinite structures that accepts exactly all the computations that satisfy the formula. For linear temporal logic the structures are infinite words <ref> [WVS83, Sis83, LPZ85, Pei85, SVW87, VW94] </ref>, while for branching temporal logic the structures are infinite trees [ES84, SE84, Eme85, EJ88, VW86b]. This enables the reduction of temporal logic decision problems, such as satisfiability, to known automata-theoretic problems, such as nonemptiness, yielding clean and asymptotically optimal algorithms.
Reference: [MH84] <author> S. Miyano and T. Hayashi. </author> <title> Alternating finite automata on !-words. </title> <journal> Theoretical Computer Science, </journal> <volume> 32 </volume> <pages> 321-330, </pages> <year> 1984. </year>
Reference-contexts: It turns out that they have the same expressive power (although alternating Buchi automata are more succinct than nondeterministic Buchi automata). Proposition 3. <ref> [MH84] </ref> Let A be an alternating B uchi automaton with n states. Then there is a nondeterministic B uchi automaton A nd with 2 O (n) states such that L ! (A nd ) = L ! (A).
Reference: [Mic88] <author> M. Michel. </author> <title> Complementation is more difficult with automata on infinite words. </title> <address> CNET, Paris, </address> <year> 1988. </year>
Reference-contexts: 12, L ! (A ' ) = L ! (A :' ) and the automaton A :' has 2 O (j'j) states. (A straightforward approach, starting with the automaton A ' and then complementing it, would result in a doubly exponential blow-up, since complementation of nondeterministic Buchi automata is exponential <ref> [SVW87, Mic88, Saf88] </ref>). To get the intersection of the two automata, we use Proposition 1. Consequently, we can build an automaton for L ! (A P ) " L ! (A :' ) having jW j 2 O (j'j) states. We need to check this automaton for emptiness.
Reference: [MP92] <author> Z. Manna and A. Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems: Specification. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: 1 Introduction Temporal logics, which are modal logics geared towards the description of the temporal ordering of events, have been adopted as a powerful tool for specifying and verifying concurrent programs <ref> [Pnu77, MP92] </ref>. One of the most significant developments in this area is the discovery of algorithmic methods for verifying temporal logic properties of finite-state programs [CES86, LP85, QS81]. This derives its significance from the fact that many synchronization and communication protocols can be modeled as finite-state programs [Liu89, Rud87].
Reference: [MS87] <author> D.E. Muller and P.E. Schupp. </author> <title> Alternating automata on infinite trees. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 54,:267-276, </address> <year> 1987. </year>
Reference-contexts: Such devices are called alternating. Alternation was studied in [CKS81] in the context of Turing machines and in [BL80, CKS81] for finite automata. The alternation formalisms in [BL80] and [CKS81] are different, though equivalent. We follow here the formalism of [BL80], which was extended in <ref> [MS87] </ref> to automata on infinite structures. For a given set X, let B + (X) be the set of positive Boolean formulas over X (i.e., Boolean formulas built from elements in X using ^ and _), where we also allow the formulas true and false. Let Y X.
Reference: [MS95] <author> D.E. Muller and P.E. Schupp. </author> <title> Simulating alternating tree automata by nondeterministic automata: New results and new proofs of the theorems by Rabin, McNaughton and Safra. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 141(1-2):69-108, </address> <month> April </month> <year> 1995. </year>
Reference-contexts: As with alternating Buchi automata on words, alternating Buchi tree automata are as expressive as nondeterministic Buchi tree automata. Proposition 6. <ref> [MS95] </ref> Let A be an alternating B uchi automaton with n states. Then there is a nondeterministic B uchi automaton A n with 2 O (n log n) states such that T ! (A n ) = T ! (A).
Reference: [MSS86] <author> D.E. Muller, A. Saoudi, and P.E. Schupp. </author> <title> Alternating automata, the weak monadic theory of the tree and its complexity. </title> <editor> In L. Kott, editor, </editor> <booktitle> Automata, Languages and Programming, Proc. 13th Int. Colloquium (ICALP '86), volume 226 of Lecture Notes in Computer Science, </booktitle> <pages> pages 275-283. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1986. </year>
Reference-contexts: Proposition 8. The nonemptiness problem for alternating B uchi tree automata over 1-letter alphabets is decidable in quadratic time. As we shall see later, the alternating automata in our applications have a special structure, studied first in <ref> [MSS86] </ref>.
Reference: [MSS88] <author> D. E. Muller, A. Saoudi, and P. E. Schupp. </author> <title> Weak alternating automata give a simple explanation of why most temporal and dynamic logics are decidable in exponential time. </title> <booktitle> In Proceedings 3rd IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 422-427, </pages> <address> Edinburgh, </address> <month> July </month> <year> 1988. </year>
Reference-contexts: We demonstrate this claim by showing how alternating automata can be used to derive model-checking algorithms for both linear and branching temporal logics. The key observation is that while the translation from temporal logic formulas to nondeterministic automata is exponential [VW86b, VW94], the translation to alternating automata is linear <ref> [MSS88, EJ91, Var94, BVW94] </ref>. Thus, the advantage of alternating automata is that they enable one to decouple the logic from the combinatorics. <p> It turns out that the computations satisfying a given formula are exactly those accepted by some finite automaton on infinite words. The following theorem establishes a very simple translation between LTL and alternating Buchi automata on infinite words. Theorem 11. <ref> [MSS88, Var94] </ref> Given an LTL formula ', one can build an alternating B uchi automaton A ' = (; S; s 0 ; ; F ), where = 2 P rop and jSj is in O (j'j), such that L ! (A ' ) is exactly the set of computations satisfying <p> It turns out that the tree programs satisfying a given formula are exactly those accepted by some finite tree automaton. The following theorem establishes a very simple translation between CTL and weak alternating Buchi tree automata. Theorem 13. <ref> [MSS88, BVW94] </ref> Given a CTL formula ' and a finite set D N , one can build a limited-alternation WAA A ' = (; D; S; s 0 ; ; F ), where = 2 P rop and jSj is in O (j'j), such that T ! (A ' ) is
Reference: [Pei85] <author> R. Peikert. </author> <title> !-regular languages and propositional temporal logic. </title> <type> Technical Report 85-01, </type> <institution> ETH, </institution> <year> 1985. </year>
Reference-contexts: The basic idea is to associate with ? Part of this work was done at the IBM Almaden Research Center. each temporal logic formula a finite automaton on infinite structures that accepts exactly all the computations that satisfy the formula. For linear temporal logic the structures are infinite words <ref> [WVS83, Sis83, LPZ85, Pei85, SVW87, VW94] </ref>, while for branching temporal logic the structures are infinite trees [ES84, SE84, Eme85, EJ88, VW86b]. This enables the reduction of temporal logic decision problems, such as satisfiability, to known automata-theoretic problems, such as nonemptiness, yielding clean and asymptotically optimal algorithms.
Reference: [Pnu77] <author> A. Pnueli. </author> <title> The temporal logic of programs. </title> <booktitle> In Proc. 18th IEEE Symposium on Foundation of Computer Science, </booktitle> <pages> pages 46-57, </pages> <year> 1977. </year>
Reference-contexts: 1 Introduction Temporal logics, which are modal logics geared towards the description of the temporal ordering of events, have been adopted as a powerful tool for specifying and verifying concurrent programs <ref> [Pnu77, MP92] </ref>. One of the most significant developments in this area is the discovery of algorithmic methods for verifying temporal logic properties of finite-state programs [CES86, LP85, QS81]. This derives its significance from the fact that many synchronization and communication protocols can be modeled as finite-state programs [Liu89, Rud87].
Reference: [QS81] <author> J.P. Queille and J. Sifakis. </author> <title> Specification and verification of concurrent systems in Cesar. </title> <booktitle> In Int. Symp. on programming, Proc. 5th Int. Symposium, volume 137 of Lecture Notes in Computer Science, </booktitle> <pages> pages 337-351. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1981. </year>
Reference-contexts: One of the most significant developments in this area is the discovery of algorithmic methods for verifying temporal logic properties of finite-state programs <ref> [CES86, LP85, QS81] </ref>. This derives its significance from the fact that many synchronization and communication protocols can be modeled as finite-state programs [Liu89, Rud87]. <p> This suggests that any algorithm that uses these translations as one of its steps is going to be an exponential-time algorithm. Thus, the automata-theoretic approach did not seem to be applicable to branching-time model checking, which in many cases can be done in linear running time <ref> [CES86, QS81, Cle93] </ref>, Recently it has been shown that if one uses alternating automata rather than nondeterministic automata, then these problems can be solved [Var94, BVW94].
Reference: [Rab70] <author> M.O. Rabin. </author> <title> Weakly definable relations and special automata. </title> <editor> In Y. Bar-Hilel, editor, </editor> <booktitle> Proc. Symp. Math. Logic and Foundations of Set Theory, </booktitle> <pages> pages 1-23. </pages> <publisher> North Holland, </publisher> <year> 1970. </year>
Reference-contexts: The set of trees accepted by A is denoted T ! (A). It is easy to see that nondeterministic Buchi automata on infinite words are essentially Buchi automata on f1g-trees. Proposition 5. <ref> [Rab70] </ref> The nonemptiness problem for nondeterministic B uchi tree automata is decidable in quadratic time. 2.5 Alternating Automata on Infinite Trees An alternating B uchi tree automaton A is a tuple (; D; S; s 0 ; ; F ).
Reference: [Rud87] <author> H. </author> <title> Rudin. Network protocols and tools to help produce them. </title> <booktitle> Annual Review of Computer Science, </booktitle> <volume> 2 </volume> <pages> 291-316, </pages> <year> 1987. </year>
Reference-contexts: One of the most significant developments in this area is the discovery of algorithmic methods for verifying temporal logic properties of finite-state programs [CES86, LP85, QS81]. This derives its significance from the fact that many synchronization and communication protocols can be modeled as finite-state programs <ref> [Liu89, Rud87] </ref>. Finite-state programs can be modeled by transition systems where each state has a bounded description, and hence can be characterized by a fixed number of Boolean atomic propositions.
Reference: [Saf88] <author> S. Safra. </author> <title> On the complexity of omega-automata. </title> <booktitle> In Proceedings of the 29th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 319-327, </pages> <address> White Plains, </address> <month> October </month> <year> 1988. </year>
Reference-contexts: 12, L ! (A ' ) = L ! (A :' ) and the automaton A :' has 2 O (j'j) states. (A straightforward approach, starting with the automaton A ' and then complementing it, would result in a doubly exponential blow-up, since complementation of nondeterministic Buchi automata is exponential <ref> [SVW87, Mic88, Saf88] </ref>). To get the intersection of the two automata, we use Proposition 1. Consequently, we can build an automaton for L ! (A P ) " L ! (A :' ) having jW j 2 O (j'j) states. We need to check this automaton for emptiness.
Reference: [SC85] <author> A.P. Sistla and E.M. Clarke. </author> <title> The complexity of propositional linear temporal logic. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 32 </volume> <pages> 733-749, </pages> <year> 1985. </year>
Reference-contexts: Consequently, we can build an automaton for L ! (A P ) " L ! (A :' ) having jW j 2 O (j'j) states. We need to check this automaton for emptiness. Using Proposition 2, we get the following results. Theorem 14. <ref> [LP85, SC85, VW86a] </ref> Checking whether a finite-state program P satisfies an LTL formula ' can be done in time O (jP j2 O (j'j) ) or in space O ((j'j+log jP j) 2 ).
Reference: [SE84] <author> R. S. Streett and E. A. Emerson. </author> <title> The propositional mu-calculus is elementary. </title> <editor> In J. Paredaens, editor, </editor> <booktitle> Automata, Languages and Programming, Proc. 11th Int. Colloquium (ICALP '84), volume 172 of Lecture Notes in Computer Science, </booktitle> <pages> pages 465-472. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1984. </year>
Reference-contexts: For linear temporal logic the structures are infinite words [WVS83, Sis83, LPZ85, Pei85, SVW87, VW94], while for branching temporal logic the structures are infinite trees <ref> [ES84, SE84, Eme85, EJ88, VW86b] </ref>. This enables the reduction of temporal logic decision problems, such as satisfiability, to known automata-theoretic problems, such as nonemptiness, yielding clean and asymptotically optimal algorithms. Initially, the translations in the literature from temporal logic formulas to automata used nondeterministic automata (cf. [VW86b, VW94]).
Reference: [Sis83] <author> A.P. Sistla. </author> <title> Theoretical issues in the design and analysis of distributed systems. </title> <type> PhD thesis, </type> <institution> Harvard University, </institution> <year> 1983. </year>
Reference-contexts: The basic idea is to associate with ? Part of this work was done at the IBM Almaden Research Center. each temporal logic formula a finite automaton on infinite structures that accepts exactly all the computations that satisfy the formula. For linear temporal logic the structures are infinite words <ref> [WVS83, Sis83, LPZ85, Pei85, SVW87, VW94] </ref>, while for branching temporal logic the structures are infinite trees [ES84, SE84, Eme85, EJ88, VW86b]. This enables the reduction of temporal logic decision problems, such as satisfiability, to known automata-theoretic problems, such as nonemptiness, yielding clean and asymptotically optimal algorithms.
Reference: [SVW87] <author> A.P. Sistla, M.Y. Vardi, and P. Wolper. </author> <title> The complementation problem for Buchi automata with applications to temporal logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 49 </volume> <pages> 217-237, </pages> <year> 1987. </year>
Reference-contexts: The basic idea is to associate with ? Part of this work was done at the IBM Almaden Research Center. each temporal logic formula a finite automaton on infinite structures that accepts exactly all the computations that satisfy the formula. For linear temporal logic the structures are infinite words <ref> [WVS83, Sis83, LPZ85, Pei85, SVW87, VW94] </ref>, while for branching temporal logic the structures are infinite trees [ES84, SE84, Eme85, EJ88, VW86b]. This enables the reduction of temporal logic decision problems, such as satisfiability, to known automata-theoretic problems, such as nonemptiness, yielding clean and asymptotically optimal algorithms. <p> 12, L ! (A ' ) = L ! (A :' ) and the automaton A :' has 2 O (j'j) states. (A straightforward approach, starting with the automaton A ' and then complementing it, would result in a doubly exponential blow-up, since complementation of nondeterministic Buchi automata is exponential <ref> [SVW87, Mic88, Saf88] </ref>). To get the intersection of the two automata, we use Proposition 1. Consequently, we can build an automaton for L ! (A P ) " L ! (A :' ) having jW j 2 O (j'j) states. We need to check this automaton for emptiness.
Reference: [Var94] <author> M.Y. Vardi. </author> <title> Nontraditional applications of automata theory. </title> <booktitle> In Theoretical Aspects of Computer Software, Proc. Int. Symposium (TACS'94), volume 789 of Lecture Notes in Computer Science, </booktitle> <pages> pages 575-597. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1994. </year>
Reference-contexts: Thus, the automata-theoretic approach did not seem to be applicable to branching-time model checking, which in many cases can be done in linear running time [CES86, QS81, Cle93], Recently it has been shown that if one uses alternating automata rather than nondeterministic automata, then these problems can be solved <ref> [Var94, BVW94] </ref>. Alternating automata generalize the standard notion of nondeterministic automata by allowing several successor states to go down along the same word or the same branch of the tree. <p> We demonstrate this claim by showing how alternating automata can be used to derive model-checking algorithms for both linear and branching temporal logics. The key observation is that while the translation from temporal logic formulas to nondeterministic automata is exponential [VW86b, VW94], the translation to alternating automata is linear <ref> [MSS88, EJ91, Var94, BVW94] </ref>. Thus, the advantage of alternating automata is that they enable one to decouple the logic from the combinatorics. <p> It turns out that the computations satisfying a given formula are exactly those accepted by some finite automaton on infinite words. The following theorem establishes a very simple translation between LTL and alternating Buchi automata on infinite words. Theorem 11. <ref> [MSS88, Var94] </ref> Given an LTL formula ', one can build an alternating B uchi automaton A ' = (; S; s 0 ; ; F ), where = 2 P rop and jSj is in O (j'j), such that L ! (A ' ) is exactly the set of computations satisfying
Reference: [VW86a] <author> M.Y. Vardi and P. Wolper. </author> <title> An automata-theoretic approach to automatic program verification. </title> <booktitle> In Proceedings of the First Symposium on Logic in Computer Science, </booktitle> <pages> pages 322-331, </pages> <address> Cambridge, </address> <month> June </month> <year> 1986. </year>
Reference-contexts: Consequently, we can build an automaton for L ! (A P ) " L ! (A :' ) having jW j 2 O (j'j) states. We need to check this automaton for emptiness. Using Proposition 2, we get the following results. Theorem 14. <ref> [LP85, SC85, VW86a] </ref> Checking whether a finite-state program P satisfies an LTL formula ' can be done in time O (jP j2 O (j'j) ) or in space O ((j'j+log jP j) 2 ).
Reference: [VW86b] <author> M.Y. Vardi and P. Wolper. </author> <title> Automata-theoretic techniques for modal logics of programs. </title> <journal> Journal of Computer and System Science, </journal> <volume> 32(2) </volume> <pages> 182-21, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: For linear temporal logic the structures are infinite words [WVS83, Sis83, LPZ85, Pei85, SVW87, VW94], while for branching temporal logic the structures are infinite trees <ref> [ES84, SE84, Eme85, EJ88, VW86b] </ref>. This enables the reduction of temporal logic decision problems, such as satisfiability, to known automata-theoretic problems, such as nonemptiness, yielding clean and asymptotically optimal algorithms. Initially, the translations in the literature from temporal logic formulas to automata used nondeterministic automata (cf. [VW86b, VW94]). <p> This enables the reduction of temporal logic decision problems, such as satisfiability, to known automata-theoretic problems, such as nonemptiness, yielding clean and asymptotically optimal algorithms. Initially, the translations in the literature from temporal logic formulas to automata used nondeterministic automata (cf. <ref> [VW86b, VW94] </ref>). These translations have two disadvantages. First, the translation itself is rather nontrivial; indeed, in [VW86b, VW94] the translations go through a series of ad-hoc intermediate representations in an attempt to simplify the translation. <p> Initially, the translations in the literature from temporal logic formulas to automata used nondeterministic automata (cf. <ref> [VW86b, VW94] </ref>). These translations have two disadvantages. First, the translation itself is rather nontrivial; indeed, in [VW86b, VW94] the translations go through a series of ad-hoc intermediate representations in an attempt to simplify the translation. Second, for both linear and branching temporal logics there is an exponential blow-up involved in going from formulas to automata. <p> We demonstrate this claim by showing how alternating automata can be used to derive model-checking algorithms for both linear and branching temporal logics. The key observation is that while the translation from temporal logic formulas to nondeterministic automata is exponential <ref> [VW86b, VW94] </ref>, the translation to alternating automata is linear [MSS88, EJ91, Var94, BVW94]. Thus, the advantage of alternating automata is that they enable one to decouple the logic from the combinatorics.
Reference: [VW94] <author> M.Y. Vardi and P. Wolper. </author> <title> Reasoning about infinite computations. </title> <journal> Information and Computation, </journal> <volume> 115(1) </volume> <pages> 1-37, </pages> <year> 1994. </year>
Reference-contexts: The basic idea is to associate with ? Part of this work was done at the IBM Almaden Research Center. each temporal logic formula a finite automaton on infinite structures that accepts exactly all the computations that satisfy the formula. For linear temporal logic the structures are infinite words <ref> [WVS83, Sis83, LPZ85, Pei85, SVW87, VW94] </ref>, while for branching temporal logic the structures are infinite trees [ES84, SE84, Eme85, EJ88, VW86b]. This enables the reduction of temporal logic decision problems, such as satisfiability, to known automata-theoretic problems, such as nonemptiness, yielding clean and asymptotically optimal algorithms. <p> This enables the reduction of temporal logic decision problems, such as satisfiability, to known automata-theoretic problems, such as nonemptiness, yielding clean and asymptotically optimal algorithms. Initially, the translations in the literature from temporal logic formulas to automata used nondeterministic automata (cf. <ref> [VW86b, VW94] </ref>). These translations have two disadvantages. First, the translation itself is rather nontrivial; indeed, in [VW86b, VW94] the translations go through a series of ad-hoc intermediate representations in an attempt to simplify the translation. <p> Initially, the translations in the literature from temporal logic formulas to automata used nondeterministic automata (cf. <ref> [VW86b, VW94] </ref>). These translations have two disadvantages. First, the translation itself is rather nontrivial; indeed, in [VW86b, VW94] the translations go through a series of ad-hoc intermediate representations in an attempt to simplify the translation. Second, for both linear and branching temporal logics there is an exponential blow-up involved in going from formulas to automata. <p> We demonstrate this claim by showing how alternating automata can be used to derive model-checking algorithms for both linear and branching temporal logics. The key observation is that while the translation from temporal logic formulas to nondeterministic automata is exponential <ref> [VW86b, VW94] </ref>, the translation to alternating automata is linear [MSS88, EJ91, Var94, BVW94]. Thus, the advantage of alternating automata is that they enable one to decouple the logic from the combinatorics. <p> The nonemptiness problem for automata is to decide, given an automaton A, whether A is nonempty. It turns out that testing nonemptiness is easy. Proposition 2. 1. [EL85b, EL85a] The nonemptiness problem for nondeterministic B uchi automata is decidable in linear time. 2. <ref> [VW94] </ref> The nonemptiness problem for nondeterministic B uchi automata of size n is decidable in space O (log 2 n). 2.3 Alternating Automata on Infinite Words Nondeterminism gives a computing device the power of existential choice. Its dual gives a computing device the power of universal choice. <p> We can now define : - (p; a) = true if p 2 a, - (p; a) = false if p 62 a, - (~ ^ ; a) = (~; a) ^ ( ; a), - (X ; a) = , By applying Proposition 3, we now get: Corollary 12. <ref> [VW94] </ref> Given an LTL formula ', one can build a B uchi automaton A ' = (; S; s 0 ; ; F ), where = 2 P rop and jSj is in 2 O (j'j) , such that L ! (A ' ) is exactly the set of computations satisfying
Reference: [Wol89] <author> P. Wolper. </author> <title> On the relation of programs and computations to models of temporal logic. In Temporal Logic in Specification, </title> <booktitle> Proc., volume 398 of Lecture Notes in Computer Science, </booktitle> <pages> pages 75-123. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1989. </year>
Reference-contexts: Hence the name model checking for the verification methods derived from this viewpoint. Surveys can be found in <ref> [CG87, Wol89, CGL93] </ref>. We distinguish between two types of temporal logics: linear and branching [Lam80]. In linear temporal logics, each moment in time has a unique possible future, while in branching temporal logics, each moment in time may split into several possible futures.
Reference: [WVS83] <author> P. Wolper, M.Y. Vardi, and A.P. Sistla. </author> <title> Reasoning about infinite computation paths. </title> <booktitle> In Proc. 24th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 185-194, </pages> <address> Tucson, </address> <year> 1983. </year>
Reference-contexts: The basic idea is to associate with ? Part of this work was done at the IBM Almaden Research Center. each temporal logic formula a finite automaton on infinite structures that accepts exactly all the computations that satisfy the formula. For linear temporal logic the structures are infinite words <ref> [WVS83, Sis83, LPZ85, Pei85, SVW87, VW94] </ref>, while for branching temporal logic the structures are infinite trees [ES84, SE84, Eme85, EJ88, VW86b]. This enables the reduction of temporal logic decision problems, such as satisfiability, to known automata-theoretic problems, such as nonemptiness, yielding clean and asymptotically optimal algorithms.
References-found: 43

