URL: http://www.cs.virginia.edu/~an4m/pi/P123.ps
Refering-URL: http://www.cs.virginia.edu/~an4m/pi/
Root-URL: http://www.cs.virginia.edu
Title: ON THE RAPID COMPUTATION OF VARIOUS POLYLOGARITHMIC CONSTANTS  
Author: David Bailey, Peter Borwein and Simon Plouffe 
Note: i=0 16 i 8i 1 2 8i 5  
Abstract: We give algorithms for the computation of the d-th digit of certain transcendental numbers in various bases. These algorithms can be easily implemented (multiple precision arithmetic is not needed), require virtually no memory, and feature run times that scale nearly linearly with the order of the digit desired. They make it feasible to compute, for example, the billionth binary digit of log (2) or on a modest work station in a few hours run time. We demonstrate this technique by computing the ten billionth hexadecimal digit of , the billionth hexadecimal digits of 2 ; log(2) and log 2 (2), and the ten billionth decimal digit of log(9=10). These calculations rest on the observation that very special types of identities exist for certain numbers like , 2 , log(2) and log 2 (2). These are essentially polylogarithmic ladders in an integer base. A number of these identities that we derive in this work appear to be new, for example the critical identity for : 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> M. </author> <title> Abramowitz & I.A. Stegun, Handbook of Mathematical Functions, </title> <publisher> Dover, </publisher> <address> New York, NY, </address> <year> 1965. </year>
Reference-contexts: The following identity holds: (1:2) = i=0 16 i 8i + 1 2 8i + 5 1 This can also be written as: (1:3) = i=1 16 b i ; [p i ] = <ref> [4; 0; 0; 2; 1; 1; 0; 0] </ref> where the overbar notation indicates that the sequence is periodic. Proof. <p> 2 (1=2) 36L 2 (1=4) 12L 2 (1=8) + 6L 2 (1=64) (2:4) log 2 (2) = 4L 2 (1=2) 6L 2 (1=4) 2L 2 (1=8) + L 2 (1=64) : These can be written as (2:5) 2 = 36 i=1 2 i i 2 ; [a i ] = <ref> [1; 3; 2; 3; 1; 0] </ref> (2:6): log 2 (2) = 2 i=1 2 i i 2 ; [b i ] = [2; 10; 7; 10; 2; 1] : Here the overline notation indicates that the sequences repeat. <p> (1=4) 2L 2 (1=8) + L 2 (1=64) : These can be written as (2:5) 2 = 36 i=1 2 i i 2 ; [a i ] = [1; 3; 2; 3; 1; 0] (2:6): log 2 (2) = 2 i=1 2 i i 2 ; [b i ] = <ref> [2; 10; 7; 10; 2; 1] </ref> : Here the overline notation indicates that the sequences repeat. Thus we see that 2 and log 2 (2) are in SC fl in base 2.
Reference: 2. <author> V. Adamchik & S. Wagon, </author> <title> Pi: A 2000-year search changes direction (preprint). </title>
Reference-contexts: The following identity holds: (1:2) = i=0 16 i 8i + 1 2 8i + 5 1 This can also be written as: (1:3) = i=1 16 b i ; [p i ] = <ref> [4; 0; 0; 2; 1; 1; 0; 0] </ref> where the overbar notation indicates that the sequence is periodic. Proof. <p> One intriguing example is = i=0 16 i 8i + 1 2 + 4i + 3 1=2 4i + 6 1=4 3 which can be written more compactly as = i=0 4 i 4i + 1 2 + 4i + 3 : In <ref> [2] </ref>, this and some related identities are derived using Mathematica. <p> 2 (1=2) 36L 2 (1=4) 12L 2 (1=8) + 6L 2 (1=64) (2:4) log 2 (2) = 4L 2 (1=2) 6L 2 (1=4) 2L 2 (1=8) + L 2 (1=64) : These can be written as (2:5) 2 = 36 i=1 2 i i 2 ; [a i ] = <ref> [1; 3; 2; 3; 1; 0] </ref> (2:6): log 2 (2) = 2 i=1 2 i i 2 ; [b i ] = [2; 10; 7; 10; 2; 1] : Here the overline notation indicates that the sequences repeat. <p> (1=4) 2L 2 (1=8) + L 2 (1=64) : These can be written as (2:5) 2 = 36 i=1 2 i i 2 ; [a i ] = [1; 3; 2; 3; 1; 0] (2:6): log 2 (2) = 2 i=1 2 i i 2 ; [b i ] = <ref> [2; 10; 7; 10; 2; 1] </ref> : Here the overline notation indicates that the sequences repeat. Thus we see that 2 and log 2 (2) are in SC fl in base 2.
Reference: 3. <author> A. V. Aho, J.E. Hopcroft, & J. D. Ullman, </author> <title> The Design and Analysis of Computer Algorithms, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1974. </year>
Reference-contexts: 2 (1=2) 36L 2 (1=4) 12L 2 (1=8) + 6L 2 (1=64) (2:4) log 2 (2) = 4L 2 (1=2) 6L 2 (1=4) 2L 2 (1=8) + L 2 (1=64) : These can be written as (2:5) 2 = 36 i=1 2 i i 2 ; [a i ] = <ref> [1; 3; 2; 3; 1; 0] </ref> (2:6): log 2 (2) = 2 i=1 2 i i 2 ; [b i ] = [2; 10; 7; 10; 2; 1] : Here the overline notation indicates that the sequences repeat. <p> At present we know of no identity like (1.2) in base 10. The chances that there is such an identity are dimmed by some numerical results that we have obtained using the PSLQ integer relation algorithm <ref> [3, 12] </ref>.
Reference: 4. <author> D. H. Bailey, J. Borwein and R. Girgensohn, </author> <title> Experimental evaluation of Euler sums, </title> <booktitle> Experimental Mathematics 3 (1994), </booktitle> <pages> 17-30. </pages>
Reference-contexts: The following identity holds: (1:2) = i=0 16 i 8i + 1 2 8i + 5 1 This can also be written as: (1:3) = i=1 16 b i ; [p i ] = <ref> [4; 0; 0; 2; 1; 1; 0; 0] </ref> where the overbar notation indicates that the sequence is periodic. Proof.
Reference: 5. <author> J. Borwein, & P Borwein, </author> <title> Pi and the AGM A Study in Analytic Number Theory and Computational Complexity, </title> <publisher> Wiley, </publisher> <address> New York, NY, </address> <year> 1987. </year>
Reference: 6. <author> J. Borwein & P. Borwein, </author> <title> On the complexity of familiar functions and numbers, </title> <booktitle> SIAM Review 30 (1988), </booktitle> <pages> 589-601. </pages>
Reference: 7. <author> J. Borwein, P. Borwein & D. H. Bailey, </author> <title> Ramanujan, modular equations and approximations to pi, </title> <journal> Amer. Math. </journal> <volume> Monthly 96 (1989), </volume> <pages> 201-219. </pages>
Reference-contexts: (1=4) 2L 2 (1=8) + L 2 (1=64) : These can be written as (2:5) 2 = 36 i=1 2 i i 2 ; [a i ] = [1; 3; 2; 3; 1; 0] (2:6): log 2 (2) = 2 i=1 2 i i 2 ; [b i ] = <ref> [2; 10; 7; 10; 2; 1] </ref> : Here the overline notation indicates that the sequences repeat. Thus we see that 2 and log 2 (2) are in SC fl in base 2. <p> So even with ordinary multiplication the bit complexity is O (n log 3 (n)). This algorithm is, by a factor of log (log (log (n))), asymptotically slower than the fastest known algorithms for generating the n-th digit by generating all of the first n digits of log (2) or <ref> [7] </ref>. The asymptotically fastest algorithms for all the first n digits known requires a Strassen-Schonhage multiplication [19]; the algorithms actually employed use an FFT based multiplication and are marginally slower than our algorithm, from a complexity point of view, for computing just the n-th digit.
Reference: 8. <author> R. Brent, </author> <title> The parallel evaluation of general arithmetic expressions, </title> <journal> J. Assoc. Comput. Mach. </journal> <volume> 21 (1974), </volume> <pages> 201-206. </pages>
Reference: 9. <author> S. Cook, </author> <title> A taxonomy of problems with fast parallel algorithms, </title> <booktitle> Information and Control 64 (1985), </booktitle> <pages> 2-22. </pages>
Reference: 10. <author> R. Crandall, K. Dilcher, and C. Pomerance, </author> <title> A search for Wieferich and Wilson primes (preprint). </title>
Reference-contexts: (1=4) 2L 2 (1=8) + L 2 (1=64) : These can be written as (2:5) 2 = 36 i=1 2 i i 2 ; [a i ] = [1; 3; 2; 3; 1; 0] (2:6): log 2 (2) = 2 i=1 2 i i 2 ; [b i ] = <ref> [2; 10; 7; 10; 2; 1] </ref> : Here the overline notation indicates that the sequences repeat. Thus we see that 2 and log 2 (2) are in SC fl in base 2. <p> When n is larger than 2 26 , then squares in the exponentiation algorithm will exceed 2 104 , which is nearly the limit of quad precision. This difficulty can be remedied using a method which has been employed for example in searches for Wieferich primes <ref> [10] </ref>. Represent the running value r in the exponentiation algorithm by the ordered pair (r 1 ; r 2 ), where r = r 1 + kr 2 , and where r 1 and r 2 are positive integers less than k.
Reference: 11. <author> R. Crandall and J. Buhler, </author> <title> On the evaluation of Euler sums, Experimental Mathematics 3, </title> <booktitle> (1995), </booktitle> <pages> 275-285. </pages>
Reference: 12. <author> H. R. P. Ferguson & D. H. Bailey, </author> <title> Analysis of PSLQ, an integer relation algorithm (preprint). </title>
Reference-contexts: At present we know of no identity like (1.2) in base 10. The chances that there is such an identity are dimmed by some numerical results that we have obtained using the PSLQ integer relation algorithm <ref> [3, 12] </ref>.
Reference: 13. <author> E. R. Hansen, </author> <title> A Table of Series and Products, </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1975. </year>
Reference-contexts: See [16, p. 45]. As in the case of formula (1.2) for , colleagues of the authors have subsequently pointed out several other formulas of this type for various constants. Three exam ples reported by Knuth, which are based on formulas in <ref> [13, p. 17, 18, 22, 47, 139] </ref>, are 2 ln (1 + 2) = i=0 16 i 8i + 1 1=2 + 8i + 5 1=8 2 arctan (1= p 1 X 1 1 8i + 3 1=4 8i + 7 arctan (1=3) = 1 X 1 1 8i + 2
Reference: 14. <author> D. E. Knuth, </author> <booktitle> The Art of Computer Programming. </booktitle> <volume> Vol. 2: </volume> <booktitle> Seminumerical Algorithms, </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1981. </year>
Reference-contexts: The Algorithm. Our algorithm to compute individual base-b digits of certain constants is based on the binary scheme for exponentiation, wherein one evaluates x n rapidly by successive squaring and multiplication. This reduces the number of multiplications to less than 2 log 2 (n). According to Knuth <ref> [14] </ref>, where details are given, this trick goes back at least to 200 B.C. In our application, we need to perform exponentiation modulo a positive integer c, but the overall scheme is the same | one merely performs all operations modulo c.
Reference: 15. <author> L. Lewin, </author> <title> Polylogarithms and Associated Functions, </title> <publisher> North Holland, </publisher> <address> New York, </address> <year> 1981. </year>
Reference-contexts: As with (1.2) we found them by searching for identities of this type using an integer relation algorithm. We have not found them directly in print. However (2.5) follows from equation (4.70) of <ref> [15] </ref> with ff = =3; fi = =2 and fl = =3.
Reference: 16. <author> L. Lewin, </author> <title> Structural Properties of Polylogarithms, </title> <publisher> Amer. Math. Soc., </publisher> <address> RI., </address> <year> 1991. </year>
Reference-contexts: 5) 2 log 2 (2) = 8 i=0 64 i (6i) 2 + (6i + 1) 2 (6i + 2) 2 (6i + 3) 2 (6i + 4) 2 + (6i + 5) 2 : Identities (2.3)-(2-6) are examples of polylogarithmic ladders in the base 1=2 in the sense of <ref> [16] </ref>. As with (1.2) we found them by searching for identities of this type using an integer relation algorithm. We have not found them directly in print. However (2.5) follows from equation (4.70) of [15] with ff = =3; fi = =2 and fl = =3. <p> See <ref> [16, p. 45] </ref>. As in the case of formula (1.2) for , colleagues of the authors have subsequently pointed out several other formulas of this type for various constants.
Reference: 17. <author> N. Nielsen, Der Eulersche Dilogarithmus, Halle, Leipzig, </author> <year> 1909. </year>
Reference: 18. <author> S. D. Rabinowitz and S. Wagon, </author> <title> A spigot algorithm for pi, </title> <journal> Amer. Math. </journal> <volume> Monthly 103 (1995), </volume> <pages> 195-203. </pages>
Reference-contexts: See [16, p. 45]. As in the case of formula (1.2) for , colleagues of the authors have subsequently pointed out several other formulas of this type for various constants. Three exam ples reported by Knuth, which are based on formulas in <ref> [13, p. 17, 18, 22, 47, 139] </ref>, are 2 ln (1 + 2) = i=0 16 i 8i + 1 1=2 + 8i + 5 1=8 2 arctan (1= p 1 X 1 1 8i + 3 1=4 8i + 7 arctan (1=3) = 1 X 1 1 8i + 2 <p> Some other examples can be found in <ref> [18] </ref>. 3. The Algorithm. Our algorithm to compute individual base-b digits of certain constants is based on the binary scheme for exponentiation, wherein one evaluates x n rapidly by successive squaring and multiplication. This reduces the number of multiplications to less than 2 log 2 (n).
Reference: 19. <author> A. Schonhage, </author> <title> Asymptotically fast algorithms for the numerical multiplication and division of polynomials with complex coefficients, </title> <booktitle> in: EUROCAM (1982) Marseille, Springer Lecture Notes in Computer Science, </booktitle> <volume> vol. 144, </volume> <year> 1982, </year> <pages> pp. 3-15. </pages>
Reference-contexts: The asymptotically fastest algorithms for all the first n digits known requires a Strassen-Schonhage multiplication <ref> [19] </ref>; the algorithms actually employed use an FFT based multiplication and are marginally slower than our algorithm, from a complexity point of view, for computing just the n-th digit.
Reference: 20. <author> J. Todd, </author> <title> A problem on arc tangent relations, </title> <booktitle> MAA Monthly 56 (1940), </booktitle> <pages> 517-528. </pages>
Reference: 21. <author> H. S. Wilf, </author> <title> Algorithms and Complexity, </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1986. </year> <type> 13 Bailey: </type> <institution> NASA Ames Research Center, Mail Stop T27A-1, Moffett Field, CA, USA 94035-1000 dbailey@nas.nasa.gov Borwein: Department of Mathematics and Statistics, Simon Fraser University, Burn-aby, B.C., Canada V5A 1S6 pborwein@cecm.sfu.ca Plouffe: Department of Mathematics and Statistics, Simon Fraser University, Burn-aby, B.C., </institution> <address> Canada V5A 1S6 plouffe@cecm.sfu.ca 14 </address>
References-found: 21

