URL: ftp://ftp.cs.dartmouth.edu/pub/kotz/papers/kotz:addrtrace.ps.Z
Refering-URL: http://www.cs.dartmouth.edu/~dfk/papers/addrtrace.html
Root-URL: http://www.cs.dartmouth.edu
Email: fdfk,crowg@cs.dartmouth.edu  
Title: The Expected Lifetime of "Single-Address-Space" Operating Systems  
Author: David Kotz and Preston Crow 
Address: Hanover, NH 03755-3510  
Affiliation: Dartmouth College Department of Mathematics and Computer Science  
Abstract: Trends toward shared-memory programming paradigms, large (64-bit) address spaces, and memory-mapped files have led some to propose the use of a single virtual-address space, shared by all processes and processors. Typical proposals require the single address space to contain all process-private data, shared data, and stored files. To simplify management of an address space where stale pointers make it difficult to re-use addresses, some have claimed that a 64-bit address space is sufficiently large that there is no need to ever re-use addresses. Unfortunately, there has been no data to either support or refute these claims, or to aid in the design of appropriate address-space management policies. In this paper, we present the results of extensive kernel-level tracing of the workstations in our department, and discuss the implications for single-address-space operating systems. We found that single-address-space systems will not outgrow the available address space, but only if reasonable space-allocation policies are used, and only if the system can adapt as larger address spaces become available. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Mary G. Baker, John H. Hartman, Michael D. Kupfer, Ken W. Shirriff, and John K. Ousterhout. </author> <title> Measurements of a distributed file system. </title> <booktitle> In Proceedings of the Thirteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 198-212, </pages> <year> 1991. </year>
Reference-contexts: Instead, acceleration in the rate of address-space consumption is likely to depend significantly on changing user habits (for example, the advent of multimedia applications may encourage larger processes and larger files). This phenomenon was also noticed in a recent study of file-system throughput requirements <ref> [1] </ref>: "The net result is an increase in computing power per user by a factor of 200 to 500, but the throughput requirements only increased by about a factor of 20 to 30. ...
Reference: [2] <author> Alberto Bartoli, Sape J. Mullender, and Martijn van der Valk. </author> <title> Wide-address spaces | exploring the design space. </title> <journal> ACM Operating Systems Review, </journal> <volume> 27(1) </volume> <pages> 11-17, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Most current operating systems provide a separate address space for each process, which makes protection rather easy but makes sharing memory rather awkward. Many researchers propose to unify the memory hierarchy of several machines and disk systems into a single, "flat" virtual-address space <ref> [2, 3, 4, 10] </ref>. (These systems are often called "single-address-space" systems.) This unification makes it easier to share data structures between processes, even when the data may contain pointers or be physically located on different machines or disk systems. <p> Stale pointers, stored in persistent data structures, make re-use of the address range of a deleted object highly undesirable. Some claim that a 64-bit address 161 space is so large that re-use would never be necessary <ref> [2] </ref>. These claims are not based on any real data, and have thus been the subject of much debate. In particular, back-of-the-envelope calculations often ignore fragmentation losses or growth in the rate of address-space consumption over the years. <p> They concede that conserving and re-using address space is probably necessary. In contrast, Bartoli et al. believe that "if ten machines create objects at a rate of ten gigabytes a minute, the [64-bit] address space will last 300 years" <ref> [2] </ref>. Using their numbers, a collection of 200 machines would only last 15 years, and larger collections would likely be out of the question.
Reference: [3] <author> Jeffrey S. Chase, Henry M. Levy, Michael J. Feeley, and Edward D. Lazowska. </author> <title> Sharing and protection in a single address space operating system. </title> <journal> ACM Transactions on Computer Systems, </journal> <month> May </month> <year> 1994. </year>
Reference-contexts: Most current operating systems provide a separate address space for each process, which makes protection rather easy but makes sharing memory rather awkward. Many researchers propose to unify the memory hierarchy of several machines and disk systems into a single, "flat" virtual-address space <ref> [2, 3, 4, 10] </ref>. (These systems are often called "single-address-space" systems.) This unification makes it easier to share data structures between processes, even when the data may contain pointers or be physically located on different machines or disk systems. <p> Finally, in Section 5, we summarize. 2 Background There are many advantages and disadvantages of an operating system with a single common address space, which are summarized by Mullender [8, pages 391-392] and by Chase et al <ref> [3] </ref>. The MONADS-PC project [10, 11] was one of the first systems to place all storage (all processes and all files) in a single, distributed, virtual-address space. They use custom hardware that partitions the bits of an address into two fields: a 32-bit address space number and a 28-bit offset. <p> Hemlock dynamically links code at run time to allow for different instances of global data. Opal <ref> [3] </ref> uses other techniques to avoid Hemlock's "private" 32-bit subspace and dynamic linking. For example, all global variables are referenced as an offset from a base register, allowing separate storage for each instance of the program. They concede that conserving and re-using address space is probably necessary.
Reference: [4] <author> William E. Garrett, Ricardo Bianchini, Leonidas Kon-tothanassis, R. Andrew McCallum, Jeffery Thomas, Robert Wisniewski, and Michael L. Scott. </author> <title> Dynamic sharing and backward compatibility on 64-bit machines. </title> <type> Technical Report 418, </type> <institution> Univ. of Rochester Computer Science Department, </institution> <month> April </month> <year> 1992. </year>
Reference-contexts: Most current operating systems provide a separate address space for each process, which makes protection rather easy but makes sharing memory rather awkward. Many researchers propose to unify the memory hierarchy of several machines and disk systems into a single, "flat" virtual-address space <ref> [2, 3, 4, 10] </ref>. (These systems are often called "single-address-space" systems.) This unification makes it easier to share data structures between processes, even when the data may contain pointers or be physically located on different machines or disk systems. <p> The address space numbers are never re-used. A newer version of the system, the MONADS-MM [6], uses 128-bit addresses, extending the address-space numbers to 96 bits and the offsets to 32 bits. Hemlock <ref> [4] </ref> proposes a single 64-bit address space. Files are mapped into contiguous regions in the address space, requiring them to allocate a large address range (4 GB) for each file to leave room for potential expansion. This fragmentation may limit the effective size of their (64-bit) address space. <p> Note that, of the four possible combinations, the two re-use policies are similar, in that neither cause any space to be lost from external or internal fragmentation over the long term. (Note that the 32-bit subspace of <ref> [4] </ref> is also similar to the fixed re-use policy.) Thus, we measured only reuse, exact no-reuse, and fixed no-reuse. File allocation. A file is traditionally an extendible array of bytes.
Reference: [5] <author> Brett Glass. </author> <title> The Mips R4000. </title> <journal> Byte Magazine, </journal> <volume> 16(13) </volume> <pages> 271-282, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: Another is the use of a shared-memory programming model, even when the physical memory is distributed. Another is the growing size of physical memories (due to denser RAM chips) and of virtual memories (with the advent of 64-bit CPUs like the MIPS R4000 <ref> [5] </ref>, the HP PA-RISC [7], and the DEC ALPHA [14]). Finally, main memory and secondary storage are increasingly unified through the use of virtual memory and "memory-mapped" files. These trends make it possible to reconsider some of the basic assumptions in operating system design. <p> The points represent the Intel 4004 (12 bits), Intel 8008 (14 bits), Intel 8080 (16 bits), Intel 8086 (20 bits), Motorola 68000 (32 bits), Intel 80386 (48 bits), and MIPS R-4000 and HP 9000/700 (64 bits). The data come from [13, page 5], [15, page 27], and <ref> [5] </ref>. Siewiorek et al noticed that available virtual address space has grown by about one bit per year [13], but their conclusions are based on old data.
Reference: [6] <author> David Koch and John Rosenberg. </author> <title> A secure RISC-based architecture supporting data persistence. </title> <booktitle> In Proceedings of the International Workshop on Computer Architectures to Support Security and Persistence of Information, </booktitle> <pages> pages 188-201, </pages> <year> 1990. </year>
Reference-contexts: They use custom hardware that partitions the bits of an address into two fields: a 32-bit address space number and a 28-bit offset. The address space numbers are never re-used. A newer version of the system, the MONADS-MM <ref> [6] </ref>, uses 128-bit addresses, extending the address-space numbers to 96 bits and the offsets to 32 bits. Hemlock [4] proposes a single 64-bit address space.
Reference: [7] <author> R. B. Lee. </author> <title> Precision architecture. </title> <journal> IEEE Computer, </journal> <volume> 22(1) </volume> <pages> 78-91, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: Another is the use of a shared-memory programming model, even when the physical memory is distributed. Another is the growing size of physical memories (due to denser RAM chips) and of virtual memories (with the advent of 64-bit CPUs like the MIPS R4000 [5], the HP PA-RISC <ref> [7] </ref>, and the DEC ALPHA [14]). Finally, main memory and secondary storage are increasingly unified through the use of virtual memory and "memory-mapped" files. These trends make it possible to reconsider some of the basic assumptions in operating system design.
Reference: [8] <author> Sape Mullender, </author> <title> editor. Distributed Systems. Addison-Wesley, second edition, </title> <booktitle> 1993. Lecture notes from the annual Advanced Course on Distributed Systems. </booktitle>
Reference-contexts: In Section 4, we show how we used this data to predict the lifetime of single-address-space operating systems. Finally, in Section 5, we summarize. 2 Background There are many advantages and disadvantages of an operating system with a single common address space, which are summarized by Mullender <ref> [8, pages 391-392] </ref> and by Chase et al [3]. The MONADS-PC project [10, 11] was one of the first systems to place all storage (all processes and all files) in a single, distributed, virtual-address space.
Reference: [9] <author> David A. Patterson and John L. Hennessy. </author> <title> Computer Architecture A Quantitative Approach. </title> <publisher> Morgan Kauf-mann, </publisher> <year> 1990. </year>
Reference-contexts: Patterson and Hennessy claim that memory requirements for a typical program have grown by a factor of 1.5 to 2 every year, consuming 1/2-1 address bits per year <ref> [9, page 16] </ref>. At this rate, an expansion from 32 bits to 64 bits would only last 32-64 years, and a single-address-space operating system would run out sooner. <p> Disks have been doubling in capacity every three years, and DRAMs have been quadrupling in capacity every three years, while per-process (physical) memory usage doubles about every one to two years <ref> [9, pages 16-17] </ref>. It seems reasonable to expect the rate of address-space consumption to grow exponentially as well, though perhaps not as quickly.
Reference: [10] <author> J. Rosenberg, J. L. Reedy, and D. Abramson. </author> <title> Addressing mechanisms for large virtual memories. </title> <journal> The Computer Journal, </journal> <volume> 35(4) </volume> <pages> 24-374, </pages> <address> 1992. Australia. </address>
Reference-contexts: Most current operating systems provide a separate address space for each process, which makes protection rather easy but makes sharing memory rather awkward. Many researchers propose to unify the memory hierarchy of several machines and disk systems into a single, "flat" virtual-address space <ref> [2, 3, 4, 10] </ref>. (These systems are often called "single-address-space" systems.) This unification makes it easier to share data structures between processes, even when the data may contain pointers or be physically located on different machines or disk systems. <p> Finally, in Section 5, we summarize. 2 Background There are many advantages and disadvantages of an operating system with a single common address space, which are summarized by Mullender [8, pages 391-392] and by Chase et al [3]. The MONADS-PC project <ref> [10, 11] </ref> was one of the first systems to place all storage (all processes and all files) in a single, distributed, virtual-address space. They use custom hardware that partitions the bits of an address into two fields: a 32-bit address space number and a 28-bit offset.
Reference: [11] <author> John Rosenberg. </author> <title> Architectural and operating system support for orthogonal persistence. </title> <journal> Computing Systems, </journal> <volume> 5(3) </volume> <pages> 305-335, </pages> <month> Summer </month> <year> 1992. </year>
Reference-contexts: Finally, in Section 5, we summarize. 2 Background There are many advantages and disadvantages of an operating system with a single common address space, which are summarized by Mullender [8, pages 391-392] and by Chase et al [3]. The MONADS-PC project <ref> [10, 11] </ref> was one of the first systems to place all storage (all processes and all files) in a single, distributed, virtual-address space. They use custom hardware that partitions the bits of an address into two fields: a 32-bit address space number and a 28-bit offset.
Reference: [12] <author> M. Satyanarayanan. </author> <title> Andrew file system benchmark. </title> <institution> Carnegie-Mellon University, </institution> <year> 1989. </year> <title> Source code available on request. </title>
Reference-contexts: While it is not a new technique, we highly recommend this mechanism for other trace-collection efforts. To measure the performance overhead of our tracing activity, we ran 25 trials of the Andrew benchmark <ref> [12] </ref> on the standard Ultrix 4.3 kernel and on our instrumented kernel. The Andrew benchmark exercises both files and processes, by creating, searching, and deleting files, and compiling programs. We discarded the first trial in each case, due to a cold file cache.
Reference: [13] <author> Daniel P. Siewiorek, C. Gordon Bell, and Allen Newell, </author> <title> editors. Computer Structures: principles and examples. </title> <publisher> McGraw-Hill, </publisher> <address> second edition, </address> <year> 1982. </year>
Reference-contexts: The points represent the Intel 4004 (12 bits), Intel 8008 (14 bits), Intel 8080 (16 bits), Intel 8086 (20 bits), Motorola 68000 (32 bits), Intel 80386 (48 bits), and MIPS R-4000 and HP 9000/700 (64 bits). The data come from <ref> [13, page 5] </ref>, [15, page 27], and [5]. Siewiorek et al noticed that available virtual address space has grown by about one bit per year [13], but their conclusions are based on old data. <p> The data come from [13, page 5], [15, page 27], and [5]. Siewiorek et al noticed that available virtual address space has grown by about one bit per year <ref> [13] </ref>, but their conclusions are based on old data. In Figure 2, we plot the virtual-address-bit count of microprocessor chips against the first year of introduction, for those chips that set a new maximum virtual address space among commercial, general-purpose microprocessors. <p> In Figure 2, we plot the virtual-address-bit count of microprocessor chips against the first year of introduction, for those chips that set a new maximum virtual address space among commercial, general-purpose microprocessors. We also plot three possible growth curves: the original from <ref> [13] </ref> (one bit per year), a linear regression fit (2.676 bits per year, with correlation coefficient 0.9824), and a linear regression fit to the logarithm of the address bit count (leading to a doubling in address bits every eight years; correlation coefficient 0.9781).
Reference: [14] <author> Richard L. </author> <title> Sites. Alpha AXP architecture. </title> <journal> Communications of the ACM, </journal> <volume> 36(2) </volume> <pages> 33-44, </pages> <month> February </month> <year> 1993. </year>
Reference-contexts: Another is the growing size of physical memories (due to denser RAM chips) and of virtual memories (with the advent of 64-bit CPUs like the MIPS R4000 [5], the HP PA-RISC [7], and the DEC ALPHA <ref> [14] </ref>). Finally, main memory and secondary storage are increasingly unified through the use of virtual memory and "memory-mapped" files. These trends make it possible to reconsider some of the basic assumptions in operating system design.
Reference: [15] <author> Andrew S. Tanenbaum. </author> <title> Structured Computer Organization. </title> <publisher> Prentice Hall, </publisher> <address> third edition, </address> <year> 1990. </year> <month> 170 </month>
Reference-contexts: The points represent the Intel 4004 (12 bits), Intel 8008 (14 bits), Intel 8080 (16 bits), Intel 8086 (20 bits), Motorola 68000 (32 bits), Intel 80386 (48 bits), and MIPS R-4000 and HP 9000/700 (64 bits). The data come from [13, page 5], <ref> [15, page 27] </ref>, and [5]. Siewiorek et al noticed that available virtual address space has grown by about one bit per year [13], but their conclusions are based on old data.
References-found: 15

