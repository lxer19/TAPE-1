URL: http://www.cs.brown.edu/people/mph/preprint.ps
Refering-URL: http://www.cs.brown.edu/people/mph/decide.html
Root-URL: http://www.cs.brown.edu/
Email: herlihy@cs.brown.edu  rajsbaum@servidor.unam.mx  
Title: The Decidability of Distributed Decision Tasks (Extended Abstract)  
Author: Maurice Herlihy Sergio Rajsbaum 
Address: Providence RI 02912  U.N.A.M., D.F. 04510, Mexico  
Affiliation: Computer Science Department Brown University,  Instituto de Matematicas  
Abstract: A task is a distributed coordination problem in which each process starts with a private input value taken from a finite set, communicates with the other processes by applying operations to shared objects, and eventually halts with a private output value, also taken from a finite set. A protocol is a distributed program that solves a task. A protocol is t-resilient if it tolerates failures by t or fewer processes. A task is solvable in a given model of computation if it has a t-resilient protocol in that model. A set of tasks is decidable in a given model of computation if there exists an effective procedure for deciding whether any task in that set has a t-resilient protocol. This paper gives the first necessary and sufficient conditions for task decidability in a range of different models and resilience levels. We prove undecidability by exploiting classical decidability results from algebraic topology, and we prove decidability by explicit construction. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Y. Afek, H. Attiya, D. Dolev, E. Gafni, M. Merritt, and N. Shavit. </author> <title> Atomic snapshots of shared memory. </title> <journal> Journal of the ACM, </journal> <volume> 40(4) </volume> <pages> 873-890, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: Consider a point k 0 2 jKj. We call k 0 the base point. A loop in K with base point k 0 is a continuous map from the unit interval I = <ref> [0; 1] </ref> to jKj: : I ! jKj such that (0) = (1) = k 0 . A loop is simple if ff (t) is unique for all 0 &lt; t &lt; 1. <p> More precisely, there exists a continuous map h : I fi I ! jCj, called a homotopy, such that h (s; 0) = (s), h (s; 1) = (s), and 3 h (0; t) = h (1; t) = v 0 for all t 2 <ref> [0; 1] </ref>. Homotopy is an equivalence relation. A loop is contractible if it is homotopic to the trivial loop k 0 . A complex is simply connected if every loop is contractible. <p> We first observe that the barycentric agreement task described above has a simple wait-free read-write protocol. Let S be the simplex of S spanned by the input vertexes. Each process writes its input to a shared array, snapshots the array <ref> [1] </ref>, and chooses the barycenter of the simplex spanned by the vertexes read. By iterating this protocol N times, the processes can choose vertexes on a single simplex of bary N (S 2 ), the iterated barycentric subdivision of S 2 . <p> Informally, the generic protocol works as follows. The processes share an (n + 1)-element array of vertexes inputs, and two (t + 1) by (n + 1)-element arrays of simplexes first and second. We use "scan (A [r])" to denote an atomic snapshot scan <ref> [1] </ref> of the r-th row of array A. Variables marked by subscripts are local variables. At the start of the protocol, each P i writes its input vertex to inputs [i] (Line 1), and waits until it observes at least n t + 1 input vertexes (Line 2).
Reference: [2] <author> J. Aspnes and M.P. Herlihy. </author> <title> Fast randomized consensus using shared memory. </title> <journal> Journal Of Algorithms, </journal> <volume> 11(3) </volume> <pages> 441-460, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: A protocol is a distributed program that solves a task. A task is solvable if it has a protocol. An extensive literature has investigated the solvability of particular tasks, such as consensus <ref> [2, 16, 18] </ref>, renaming [4, 27, 28], and set agreement fl Supported by NSF grants DMS-9505949 and CCR-9613785. y Supported by DGAPA and CONACyT grants. To appear, Twenty-Ninth Annual ACM Symposium on Theory of Computing, El Paso, Texas, May 4-6, 1997. [11, 13, 26, 27, 28, 36]. <p> Finally, when k = 1, (m; 1)-set agreement is the same as m-process consensus <ref> [2, 16, 18] </ref>, and we show that tasks are decidable if and only if t &lt; 2m. 1 To prove our decidability results, we draw a direct con-nection between decidability and the ability to solve a particular task, the 2-set agreement task of Chaudhuri [13].
Reference: [3] <author> J. Aspnes, M.P. Herlihy, and N. Shavit. </author> <title> Counting networks. </title> <journal> Journal of the ACM, </journal> <volume> 41(5) </volume> <pages> 1020-1048, </pages> <month> Septem-ber </month> <year> 1994. </year>
Reference-contexts: Proof: Use 2-consensus protocols as balancers in a counting network <ref> [3] </ref>.
Reference: [4] <author> H. Attiya, A. Bar-Noy, D. Dolev, D. Peleg, and R. Reis-chuk. </author> <title> Renaming in an asynchronous environment. </title> <journal> Journal of the ACM, </journal> <volume> 37(3) </volume> <pages> 524-548, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: A protocol is a distributed program that solves a task. A task is solvable if it has a protocol. An extensive literature has investigated the solvability of particular tasks, such as consensus [2, 16, 18], renaming <ref> [4, 27, 28] </ref>, and set agreement fl Supported by NSF grants DMS-9505949 and CCR-9613785. y Supported by DGAPA and CONACyT grants. To appear, Twenty-Ninth Annual ACM Symposium on Theory of Computing, El Paso, Texas, May 4-6, 1997. [11, 13, 26, 27, 28, 36]. <p> Other tasks that attracted attention include renaming <ref> [4, 27, 28] </ref> and set agreement [11, 13, 26, 27, 28, 36]. The first decidability result for decision tasks is due to Biran, Moran, and Zaks [7], who, extending [34], showed that tasks are decidable in the 1-resilient message-passing model (later shown to be equivalent to 1-resilient read-write memory [6]).
Reference: [5] <author> H. Attiya and S. Rajsbaum. </author> <title> A combinatorial topology framework for wait-free computability. </title> <booktitle> In Proceedings of the Workshop on Distributed Algorithms and Graphs, </booktitle> <year> 1996. </year>
Reference-contexts: Using the same simplicial model, Attiya and Rajsbaum <ref> [5] </ref> give purely combinatorial proofs of several impossibility results that had required algebraic techniques. Computational topology encompasses a number of celebrated undecidable problems. For finitely-presented groups, the word problem (whether an expression reduces to the unit element) was shown to be undecidable by S.P.
Reference: [6] <author> A. Bar-Noy and D. Dolev. </author> <title> Shared memory vs. mes-sage passing in an asynchronous distributed environment. </title> <booktitle> In Proceedings of the 8th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 371-382, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: The first decidability result for decision tasks is due to Biran, Moran, and Zaks [7], who, extending [34], showed that tasks are decidable in the 1-resilient message-passing model (later shown to be equivalent to 1-resilient read-write memory <ref> [6] </ref>). The same authors also showed that deciding 1-solvability is NP-complete [8], and give an optimal algorithm [9]. Taubenfeld et al. [41] showed that tasks with initial failures only are decidable.
Reference: [7] <author> O. Biran, S. Moran, and S. Zaks. </author> <title> A combinatorial characterization of the distributed 1-solvable tasks. </title> <journal> Journal of Algorithms, </journal> <volume> 11 </volume> <pages> 420-440, </pages> <year> 1990. </year>
Reference-contexts: Our results are summarized in Figure 1. We find that tasks are decidable in some models, but not others. In read-write memory, it is known that tasks are decidable if and only if at most one process may fail <ref> [7, 19] </ref>. Although (m; k)- set agreement objects for 2 &lt; k &lt; m are strictly more powerful than read-write memory [11, 28, 36], we show that tasks in this model remain undecidable when more than one process can fail. <p> Other tasks that attracted attention include renaming [4, 27, 28] and set agreement [11, 13, 26, 27, 28, 36]. The first decidability result for decision tasks is due to Biran, Moran, and Zaks <ref> [7] </ref>, who, extending [34], showed that tasks are decidable in the 1-resilient message-passing model (later shown to be equivalent to 1-resilient read-write memory [6]). The same authors also showed that deciding 1-solvability is NP-complete [8], and give an optimal algorithm [9]. <p> Our algorithm builds on earlier work of Bi-ran, Moran, and Zaks <ref> [7] </ref> and of Borowsky and Gafni [10], who outline an algorithm for solving decision tasks in all the (m; k)-set agreement models. Our algorithm differs from that of Borowsky and Gafni in several respects.
Reference: [8] <author> O. Biran, S. Moran, and S. Zaks. </author> <title> Deciding 1-solvability of distributed tasks is np hard. </title> <booktitle> In proc. 16 th International Workshop on Graph-Theoretic Concepts in Computer Science, </booktitle> <address> Berlin, </address> <pages> pages 206-220, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: The first decidability result for decision tasks is due to Biran, Moran, and Zaks [7], who, extending [34], showed that tasks are decidable in the 1-resilient message-passing model (later shown to be equivalent to 1-resilient read-write memory [6]). The same authors also showed that deciding 1-solvability is NP-complete <ref> [8] </ref>, and give an optimal algorithm [9]. Taubenfeld et al. [41] showed that tasks with initial failures only are decidable.
Reference: [9] <author> O. Biran, S. Moran, and S. Zaks. </author> <title> Tight bounds on the round complexity of distributed 1-solvable tasks. </title> <journal> Theoretical Computer Science, </journal> <volume> 145 </volume> <pages> 271-290, </pages> <year> 1995. </year> <note> Preliminary version appeared in Proc. 4th WDAG, </note> <year> 1990. </year>
Reference-contexts: The same authors also showed that deciding 1-solvability is NP-complete [8], and give an optimal algorithm <ref> [9] </ref>. Taubenfeld et al. [41] showed that tasks with initial failures only are decidable.
Reference: [10] <author> E. Borowsky. </author> <title> Capturing the power of resiliency and set consensus in distributed systems. </title> <type> Technical report, </type> <institution> University of California Los Angeles, </institution> <address> Los Angeles, Cal-ifornia, </address> <year> 1995. </year> <note> and personal communications. </note>
Reference-contexts: Our algorithm builds on earlier work of Bi-ran, Moran, and Zaks [7] and of Borowsky and Gafni <ref> [10] </ref>, who outline an algorithm for solving decision tasks in all the (m; k)-set agreement models. Our algorithm differs from that of Borowsky and Gafni in several respects. <p> has the following properties in the following models: Model P (S ` ) read/write 1-link connected for n 1 ` n (m; 2)-set agree 1-link connected for n t ` n m-consensus m-link connected for n t + m ` n 7.2 Output Complexes Most earlier work in this area <ref> [10, 25, 26, 27, 28] </ref> was concerned with proving the impossibility of specific tasks in specific models. If a task has a protocol in a particular model, then there exists a map from the protocol complex to that task's output complex. This map preserves certain topological properties.
Reference: [11] <author> E. Borowsky and E. Gafni. </author> <title> Generalized FLP impossibility result for t-resilient asynchronous computations. </title> <booktitle> In Proceedings of the 1993 ACM Symposium on Theory of Computing, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: To appear, Twenty-Ninth Annual ACM Symposium on Theory of Computing, El Paso, Texas, May 4-6, 1997. <ref> [11, 13, 26, 27, 28, 36] </ref>. Whether a task is solvable depends on two important aspects of the model of computation: the degree of resilience required, and the underlying communication model. We now describe each of these aspects in more detail. <p> In read-write memory, it is known that tasks are decidable if and only if at most one process may fail [7, 19]. Although (m; k)- set agreement objects for 2 &lt; k &lt; m are strictly more powerful than read-write memory <ref> [11, 28, 36] </ref>, we show that tasks in this model remain undecidable when more than one process can fail. <p> Other tasks that attracted attention include renaming [4, 27, 28] and set agreement <ref> [11, 13, 26, 27, 28, 36] </ref>. The first decidability result for decision tasks is due to Biran, Moran, and Zaks [7], who, extending [34], showed that tasks are decidable in the 1-resilient message-passing model (later shown to be equivalent to 1-resilient read-write memory [6]). <p> Herlihy and Shavit [28, 29] introduced a formalism for tasks based on the classical concept of simplicial complexes. They used elementary homology theory to show certain impossibility results for set agreement and renaming. (The set agreement results were shown independently by Borowsky and Gafni <ref> [11] </ref> and Saks and Zaharoglou [36] using different techniques.) More recently, Herlihy and Rajsbaum used homology theory to derive further impossibility results for set agreement [25, 26], and to unify a variety of known impossibility results in terms of the theory of chain maps and chain complexes [27].
Reference: [12] <author> S. Chaudhuri. </author> <title> Agreement is harder than consensus: Set consensus problems in totally asynchronous systems. </title> <booktitle> In Proceedings Of The Ninth Annual ACM Symposium On Principles of Distributed Computing, </booktitle> <pages> pages 311-234, </pages> <month> August </month> <year> 1990. </year>
Reference-contexts: Finally, if the processes have all three input vertexes, they converge to any simplex of K. Here are some examples of loop agreement tasks. * In the (3; 2)-set agreement task <ref> [12] </ref>, each of n + 1 processes has an input taken from a set of 3 possible values, and each chooses an output value such that (1) each output is some process's input, and (2) no more than 2 distinct values are chosen.
Reference: [13] <author> S. Chaudhuri. </author> <title> More choices allow more faults: Set consensus problems in totally asynchronous systems. </title> <journal> Information and Computation, </journal> <volume> 105(1) </volume> <pages> 132-158, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: To appear, Twenty-Ninth Annual ACM Symposium on Theory of Computing, El Paso, Texas, May 4-6, 1997. <ref> [11, 13, 26, 27, 28, 36] </ref>. Whether a task is solvable depends on two important aspects of the model of computation: the degree of resilience required, and the underlying communication model. We now describe each of these aspects in more detail. <p> is the same as m-process consensus [2, 16, 18], and we show that tasks are decidable if and only if t &lt; 2m. 1 To prove our decidability results, we draw a direct con-nection between decidability and the ability to solve a particular task, the 2-set agreement task of Chaudhuri <ref> [13] </ref>. The algorithms we present for the decidable models work for any tasks. <p> Other tasks that attracted attention include renaming [4, 27, 28] and set agreement <ref> [11, 13, 26, 27, 28, 36] </ref>. The first decidability result for decision tasks is due to Biran, Moran, and Zaks [7], who, extending [34], showed that tasks are decidable in the 1-resilient message-passing model (later shown to be equivalent to 1-resilient read-write memory [6]).
Reference: [14] <author> B. Chor and L. Moscovici. </author> <title> Solvability in asynchronous environments. </title> <booktitle> In IEEE Symposium on Foundations of Computer Science (FOCS), </booktitle> <year> 1989. </year>
Reference-contexts: Our results extend this line of research in two directions: they apply to arbitrary levels of resilience (not just wait-free protocols), and to a variety of more realistic computational models (not just read-write memory). In a related area, Chor and Moscovici <ref> [14] </ref> give decidable conditions characterizing the tasks that can be solved using randomized consensus. Herlihy and Shavit [28, 29] introduced a formalism for tasks based on the classical concept of simplicial complexes.
Reference: [15] <author> IBM Corporation. </author> <title> The PowerPC Architecture. </title> <publisher> Morgan Kaufman, </publisher> <address> San Francisco, </address> <year> 1994. </year>
Reference-contexts: Although read/write models retain theoretical interest, they are not an accurate reflection of real distributed and concurrent systems. Modern multiprocessor architectures provide a variety of more powerful synchronization primitives, including test-and-set [21], fetch-and-add [20], compare-and-swap [30] and load-linked/store-conditional <ref> [15, 32, 38] </ref>. It is known that each of these primitives is more powerful than simple read/write memory [23]. <p> For example, in an architecture that supports only test-and-set (equivalent to 2-process consensus), 3-resilient tasks are decidable, but 4-resilient tasks are not. In architectures such as Digital's Alpha AXP [38], and IBM's PowerPC <ref> [15] </ref>, all processes can reach consensus, so t-resilient tasks are decidable for any t. Although tasks are undecidable in many of the models shown in Figure 1, they are likely to be decidable in most models of practical interest.
Reference: [16] <author> D. Dolev, C. Dwork, and L Stockmeyer. </author> <title> On the minimal synchronism needed for distributed consensus. </title> <journal> Journal of the ACM, </journal> <volume> 34(1) </volume> <pages> 77-97, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: A protocol is a distributed program that solves a task. A task is solvable if it has a protocol. An extensive literature has investigated the solvability of particular tasks, such as consensus <ref> [2, 16, 18] </ref>, renaming [4, 27, 28], and set agreement fl Supported by NSF grants DMS-9505949 and CCR-9613785. y Supported by DGAPA and CONACyT grants. To appear, Twenty-Ninth Annual ACM Symposium on Theory of Computing, El Paso, Texas, May 4-6, 1997. [11, 13, 26, 27, 28, 36]. <p> Finally, when k = 1, (m; 1)-set agreement is the same as m-process consensus <ref> [2, 16, 18] </ref>, and we show that tasks are decidable if and only if t &lt; 2m. 1 To prove our decidability results, we draw a direct con-nection between decidability and the ability to solve a particular task, the 2-set agreement task of Chaudhuri [13].
Reference: [17] <author> D. Dolev, N.A. Lynch, S.S. Pinter, </author> <title> E.W. Stark, and W.E. Weihl. Reaching approximate agreement in the presence of faults. </title> <journal> Journal of the ACM, </journal> <volume> 33(3) </volume> <pages> 499-516, </pages> <month> July </month> <year> 1986. </year>
Reference-contexts: agreement [29].) This task is the loop agreement ((S 2 ); ()), where is the loop described in the previous task. * The 2-dimensional barycentric agreement task is uncolored simplex agreement for the barycentric subdivision [35, p.96] bary (S 2 ) of S 2 . * An *-approximate agreement task <ref> [17] </ref> can be defined as a 1-dimensional version of barycentric agreement, bary ` (S 1 ), for large enough `, where two of the vertices of the loop are equal. Processes start with 0 or 1, and they have to decide real numbers which differ by at most *.
Reference: [18] <author> M. Fischer, N.A. Lynch, </author> <title> and M.S. Paterson. Impossibility of distributed commit with one faulty process. </title> <journal> Journal of the ACM, </journal> <volume> 32(2) </volume> <pages> 374-382, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: A protocol is a distributed program that solves a task. A task is solvable if it has a protocol. An extensive literature has investigated the solvability of particular tasks, such as consensus <ref> [2, 16, 18] </ref>, renaming [4, 27, 28], and set agreement fl Supported by NSF grants DMS-9505949 and CCR-9613785. y Supported by DGAPA and CONACyT grants. To appear, Twenty-Ninth Annual ACM Symposium on Theory of Computing, El Paso, Texas, May 4-6, 1997. [11, 13, 26, 27, 28, 36]. <p> Finally, when k = 1, (m; 1)-set agreement is the same as m-process consensus <ref> [2, 16, 18] </ref>, and we show that tasks are decidable if and only if t &lt; 2m. 1 To prove our decidability results, we draw a direct con-nection between decidability and the ability to solve a particular task, the 2-set agreement task of Chaudhuri [13]. <p> extended abstract we omit some generalizations of the results, and many details about the model and proofs, which can be found in the full version [22]. 2 Related Work Perhaps the first paper to investigate the solvability of distributed tasks was the landmark 1985 paper of Fischer, Lynch, and Paterson <ref> [18] </ref> which showed that consensus, then considered an abstraction of the database commitment problem, had no 1-resilient message-passing protocol. Other tasks that attracted attention include renaming [4, 27, 28] and set agreement [11, 13, 26, 27, 28, 36].
Reference: [19] <author> E. Gafni and E. Koutsoupias. </author> <title> Three-processor tasks are undecidable. </title> <address> daphne.cs.ucla.edu/eli/undec.ps, </address> <year> 1996. </year>
Reference-contexts: Our results are summarized in Figure 1. We find that tasks are decidable in some models, but not others. In read-write memory, it is known that tasks are decidable if and only if at most one process may fail <ref> [7, 19] </ref>. Although (m; k)- set agreement objects for 2 &lt; k &lt; m are strictly more powerful than read-write memory [11, 28, 36], we show that tasks in this model remain undecidable when more than one process can fail. <p> The same authors also showed that deciding 1-solvability is NP-complete [8], and give an optimal algorithm [9]. Taubenfeld et al. [41] showed that tasks with initial failures only are decidable. Surprisingly, perhaps, there were no further decidability results for decision tasks until 1996, when Gafni and Kout-soupias <ref> [19] </ref>, recognizing the important link between task decidability and contractibility, showed that wait-free tasks for three or more processes are undecidable in the wait-free read-write model.
Reference: [20] <author> A. Gottlieb, R. Grishman, C.P. Kruskal, K.P. McAuliffe, L. Rudolph, and M. Snir. </author> <title> The NYU Ul-tracomputer designing an MIMD parallel computer. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-32(2):175-189, </volume> <month> February </month> <year> 1984. </year>
Reference-contexts: Although read/write models retain theoretical interest, they are not an accurate reflection of real distributed and concurrent systems. Modern multiprocessor architectures provide a variety of more powerful synchronization primitives, including test-and-set [21], fetch-and-add <ref> [20] </ref>, compare-and-swap [30] and load-linked/store-conditional [15, 32, 38]. It is known that each of these primitives is more powerful than simple read/write memory [23].
Reference: [21] <author> A. Gottlieb and C. P. Kruskal. </author> <title> Coordinating parallel processors: A partial unification. </title> <journal> Computer Architecture News, </journal> <volume> 9(6) </volume> <pages> 16-24, </pages> <month> [10] </month> <year> 1981. </year>
Reference-contexts: Although read/write models retain theoretical interest, they are not an accurate reflection of real distributed and concurrent systems. Modern multiprocessor architectures provide a variety of more powerful synchronization primitives, including test-and-set <ref> [21] </ref>, fetch-and-add [20], compare-and-swap [30] and load-linked/store-conditional [15, 32, 38]. It is known that each of these primitives is more powerful than simple read/write memory [23].
Reference: [22] <author> M. Herlihy and S. Rajsbaum. </author> <title> The decidability of distributed decision tasks. </title> <address> www.cs.brown.edu/people /mph/decide.html. </address>
Reference-contexts: k &gt; 2 t = 1 t &gt; 1 (m; 2)-set agreement t &lt; m t m m-consensus t &lt; 2m t 2m In this extended abstract we omit some generalizations of the results, and many details about the model and proofs, which can be found in the full version <ref> [22] </ref>. 2 Related Work Perhaps the first paper to investigate the solvability of distributed tasks was the landmark 1985 paper of Fischer, Lynch, and Paterson [18] which showed that consensus, then considered an abstraction of the database commitment problem, had no 1-resilient message-passing protocol.
Reference: [23] <author> M.P. Herlihy. </author> <title> Wait-free synchronization. </title> <journal> ACM Transactions On Programming Languages And Systems, </journal> <volume> 13(1) </volume> <pages> 123-149, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Modern multiprocessor architectures provide a variety of more powerful synchronization primitives, including test-and-set [21], fetch-and-add [20], compare-and-swap [30] and load-linked/store-conditional [15, 32, 38]. It is known that each of these primitives is more powerful than simple read/write memory <ref> [23] </ref>. Formally, we model such synchronization primitives as a parameterized family of (m; k)-set agreement objects, where m is the number of processes that share an object, and k is a measure of the object's power: the smaller k with respect to m, the more powerful the object.
Reference: [24] <author> M.P. Herlihy and S. Rajsbaum. </author> <title> On the decidability of distributed decision tasks. </title> <note> Full version of 1996 Herlihy and Rajsbaum PODC paper op. cit. </note>
Reference-contexts: Each of the models shown as undecidable in Figure 1 is 2 weak. (For read/write memory, see Herlihy and Shavit [28], and for the other cases, Herlihy and Rajsbaum <ref> [24, 27] </ref>.) 7 Decidability So far, we have established that tasks are undecidable in any 2-weak model. We establish a remarkably simple sufficient condition for a family of tasks to be decidable, via Theorem 6 of the next section.
Reference: [25] <author> M.P. Herlihy and S. Rajsbaum. </author> <title> Set consensus using arbitrary objects. </title> <note> Full version of 1994 Herlihy and Ra-jsbaum PODC paper op. cit. </note>
Reference-contexts: used elementary homology theory to show certain impossibility results for set agreement and renaming. (The set agreement results were shown independently by Borowsky and Gafni [11] and Saks and Zaharoglou [36] using different techniques.) More recently, Herlihy and Rajsbaum used homology theory to derive further impossibility results for set agreement <ref> [25, 26] </ref>, and to unify a variety of known impossibility results in terms of the theory of chain maps and chain complexes [27]. Using the same simplicial model, Attiya and Rajsbaum [5] give purely combinatorial proofs of several impossibility results that had required algebraic techniques. <p> An unusual aspect of this construction is that it exploits a classical theorem of algebraic topology to derive an algorithm. Most other applications of such theorems <ref> [25, 26, 27, 28] </ref> have been used to derive impossibility results. 6 Solvable Implies Contractible Consider a t-resilient (K; )-loop agreement protocol in which n + 1 processes communicate by a read/write memory possibly augmented by other objects. <p> has the following properties in the following models: Model P (S ` ) read/write 1-link connected for n 1 ` n (m; 2)-set agree 1-link connected for n t ` n m-consensus m-link connected for n t + m ` n 7.2 Output Complexes Most earlier work in this area <ref> [10, 25, 26, 27, 28] </ref> was concerned with proving the impossibility of specific tasks in specific models. If a task has a protocol in a particular model, then there exists a map from the protocol complex to that task's output complex. This map preserves certain topological properties.
Reference: [26] <author> M.P. Herlihy and S. Rajsbaum. </author> <title> Set consensus using arbitrary objects. </title> <booktitle> In Proceedings of the 13th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1994. </year>
Reference-contexts: To appear, Twenty-Ninth Annual ACM Symposium on Theory of Computing, El Paso, Texas, May 4-6, 1997. <ref> [11, 13, 26, 27, 28, 36] </ref>. Whether a task is solvable depends on two important aspects of the model of computation: the degree of resilience required, and the underlying communication model. We now describe each of these aspects in more detail. <p> Other tasks that attracted attention include renaming [4, 27, 28] and set agreement <ref> [11, 13, 26, 27, 28, 36] </ref>. The first decidability result for decision tasks is due to Biran, Moran, and Zaks [7], who, extending [34], showed that tasks are decidable in the 1-resilient message-passing model (later shown to be equivalent to 1-resilient read-write memory [6]). <p> used elementary homology theory to show certain impossibility results for set agreement and renaming. (The set agreement results were shown independently by Borowsky and Gafni [11] and Saks and Zaharoglou [36] using different techniques.) More recently, Herlihy and Rajsbaum used homology theory to derive further impossibility results for set agreement <ref> [25, 26] </ref>, and to unify a variety of known impossibility results in terms of the theory of chain maps and chain complexes [27]. Using the same simplicial model, Attiya and Rajsbaum [5] give purely combinatorial proofs of several impossibility results that had required algebraic techniques. <p> An unusual aspect of this construction is that it exploits a classical theorem of algebraic topology to derive an algorithm. Most other applications of such theorems <ref> [25, 26, 27, 28] </ref> have been used to derive impossibility results. 6 Solvable Implies Contractible Consider a t-resilient (K; )-loop agreement protocol in which n + 1 processes communicate by a read/write memory possibly augmented by other objects. <p> has the following properties in the following models: Model P (S ` ) read/write 1-link connected for n 1 ` n (m; 2)-set agree 1-link connected for n t ` n m-consensus m-link connected for n t + m ` n 7.2 Output Complexes Most earlier work in this area <ref> [10, 25, 26, 27, 28] </ref> was concerned with proving the impossibility of specific tasks in specific models. If a task has a protocol in a particular model, then there exists a map from the protocol complex to that task's output complex. This map preserves certain topological properties.
Reference: [27] <author> M.P. Herlihy and S. Rajsbaum. </author> <title> Algebraic spans. </title> <booktitle> In Proceedings of the 14th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 90-99. </pages> <publisher> ACM, </publisher> <month> August </month> <year> 1995. </year>
Reference-contexts: A protocol is a distributed program that solves a task. A task is solvable if it has a protocol. An extensive literature has investigated the solvability of particular tasks, such as consensus [2, 16, 18], renaming <ref> [4, 27, 28] </ref>, and set agreement fl Supported by NSF grants DMS-9505949 and CCR-9613785. y Supported by DGAPA and CONACyT grants. To appear, Twenty-Ninth Annual ACM Symposium on Theory of Computing, El Paso, Texas, May 4-6, 1997. [11, 13, 26, 27, 28, 36]. <p> To appear, Twenty-Ninth Annual ACM Symposium on Theory of Computing, El Paso, Texas, May 4-6, 1997. <ref> [11, 13, 26, 27, 28, 36] </ref>. Whether a task is solvable depends on two important aspects of the model of computation: the degree of resilience required, and the underlying communication model. We now describe each of these aspects in more detail. <p> Other tasks that attracted attention include renaming <ref> [4, 27, 28] </ref> and set agreement [11, 13, 26, 27, 28, 36]. The first decidability result for decision tasks is due to Biran, Moran, and Zaks [7], who, extending [34], showed that tasks are decidable in the 1-resilient message-passing model (later shown to be equivalent to 1-resilient read-write memory [6]). <p> Other tasks that attracted attention include renaming [4, 27, 28] and set agreement <ref> [11, 13, 26, 27, 28, 36] </ref>. The first decidability result for decision tasks is due to Biran, Moran, and Zaks [7], who, extending [34], showed that tasks are decidable in the 1-resilient message-passing model (later shown to be equivalent to 1-resilient read-write memory [6]). <p> Borowsky and Gafni [11] and Saks and Zaharoglou [36] using different techniques.) More recently, Herlihy and Rajsbaum used homology theory to derive further impossibility results for set agreement [25, 26], and to unify a variety of known impossibility results in terms of the theory of chain maps and chain complexes <ref> [27] </ref>. Using the same simplicial model, Attiya and Rajsbaum [5] give purely combinatorial proofs of several impossibility results that had required algebraic techniques. Computational topology encompasses a number of celebrated undecidable problems. <p> An unusual aspect of this construction is that it exploits a classical theorem of algebraic topology to derive an algorithm. Most other applications of such theorems <ref> [25, 26, 27, 28] </ref> have been used to derive impossibility results. 6 Solvable Implies Contractible Consider a t-resilient (K; )-loop agreement protocol in which n + 1 processes communicate by a read/write memory possibly augmented by other objects. <p> Each of the models shown as undecidable in Figure 1 is 2 weak. (For read/write memory, see Herlihy and Shavit [28], and for the other cases, Herlihy and Rajsbaum <ref> [24, 27] </ref>.) 7 Decidability So far, we have established that tasks are undecidable in any 2-weak model. We establish a remarkably simple sufficient condition for a family of tasks to be decidable, via Theorem 6 of the next section. <p> has the following properties in the following models: Model P (S ` ) read/write 1-link connected for n 1 ` n (m; 2)-set agree 1-link connected for n t ` n m-consensus m-link connected for n t + m ` n 7.2 Output Complexes Most earlier work in this area <ref> [10, 25, 26, 27, 28] </ref> was concerned with proving the impossibility of specific tasks in specific models. If a task has a protocol in a particular model, then there exists a map from the protocol complex to that task's output complex. This map preserves certain topological properties.
Reference: [28] <author> M.P. Herlihy and N. Shavit. </author> <title> The asynchronous computability theorem for t-resilient tasks. </title> <booktitle> In Proceedings of the 1993 ACM Symposium on Theory of Computing, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: A protocol is a distributed program that solves a task. A task is solvable if it has a protocol. An extensive literature has investigated the solvability of particular tasks, such as consensus [2, 16, 18], renaming <ref> [4, 27, 28] </ref>, and set agreement fl Supported by NSF grants DMS-9505949 and CCR-9613785. y Supported by DGAPA and CONACyT grants. To appear, Twenty-Ninth Annual ACM Symposium on Theory of Computing, El Paso, Texas, May 4-6, 1997. [11, 13, 26, 27, 28, 36]. <p> To appear, Twenty-Ninth Annual ACM Symposium on Theory of Computing, El Paso, Texas, May 4-6, 1997. <ref> [11, 13, 26, 27, 28, 36] </ref>. Whether a task is solvable depends on two important aspects of the model of computation: the degree of resilience required, and the underlying communication model. We now describe each of these aspects in more detail. <p> In read-write memory, it is known that tasks are decidable if and only if at most one process may fail [7, 19]. Although (m; k)- set agreement objects for 2 &lt; k &lt; m are strictly more powerful than read-write memory <ref> [11, 28, 36] </ref>, we show that tasks in this model remain undecidable when more than one process can fail. <p> Other tasks that attracted attention include renaming <ref> [4, 27, 28] </ref> and set agreement [11, 13, 26, 27, 28, 36]. The first decidability result for decision tasks is due to Biran, Moran, and Zaks [7], who, extending [34], showed that tasks are decidable in the 1-resilient message-passing model (later shown to be equivalent to 1-resilient read-write memory [6]). <p> Other tasks that attracted attention include renaming [4, 27, 28] and set agreement <ref> [11, 13, 26, 27, 28, 36] </ref>. The first decidability result for decision tasks is due to Biran, Moran, and Zaks [7], who, extending [34], showed that tasks are decidable in the 1-resilient message-passing model (later shown to be equivalent to 1-resilient read-write memory [6]). <p> In a related area, Chor and Moscovici [14] give decidable conditions characterizing the tasks that can be solved using randomized consensus. Herlihy and Shavit <ref> [28, 29] </ref> introduced a formalism for tasks based on the classical concept of simplicial complexes. <p> An unusual aspect of this construction is that it exploits a classical theorem of algebraic topology to derive an algorithm. Most other applications of such theorems <ref> [25, 26, 27, 28] </ref> have been used to derive impossibility results. 6 Solvable Implies Contractible Consider a t-resilient (K; )-loop agreement protocol in which n + 1 processes communicate by a read/write memory possibly augmented by other objects. <p> Each of the models shown as undecidable in Figure 1 is 2 weak. (For read/write memory, see Herlihy and Shavit <ref> [28] </ref>, and for the other cases, Herlihy and Rajsbaum [24, 27].) 7 Decidability So far, we have established that tasks are undecidable in any 2-weak model. We establish a remarkably simple sufficient condition for a family of tasks to be decidable, via Theorem 6 of the next section. <p> has the following properties in the following models: Model P (S ` ) read/write 1-link connected for n 1 ` n (m; 2)-set agree 1-link connected for n t ` n m-consensus m-link connected for n t + m ` n 7.2 Output Complexes Most earlier work in this area <ref> [10, 25, 26, 27, 28] </ref> was concerned with proving the impossibility of specific tasks in specific models. If a task has a protocol in a particular model, then there exists a map from the protocol complex to that task's output complex. This map preserves certain topological properties.
Reference: [29] <author> M.P. Herlihy and N. Shavit. </author> <title> A simple constructive computability theorem for wait-free computation. </title> <booktitle> In Proceedings of the 1994 ACM Symposium on Theory of Computing, </booktitle> <month> May </month> <year> 1994. </year>
Reference-contexts: In a related area, Chor and Moscovici [14] give decidable conditions characterizing the tasks that can be solved using randomized consensus. Herlihy and Shavit <ref> [28, 29] </ref> introduced a formalism for tasks based on the classical concept of simplicial complexes. <p> If S 2 S 2 is the face spanned by the vertexes corresponding to inputs of participating processes, then the processes converge on a simplex in (S). (This task is the uncolored version of simplex agreement <ref> [29] </ref>.) This task is the loop agreement ((S 2 ); ()), where is the loop described in the previous task. * The 2-dimensional barycentric agreement task is uncolored simplex agreement for the barycentric subdivision [35, p.96] bary (S 2 ) of S 2 . * An *-approximate agreement task [17] can
Reference: [30] <author> IBM. </author> <title> System/370 principles of operation. Order Number GA22-7000. </title>
Reference-contexts: Although read/write models retain theoretical interest, they are not an accurate reflection of real distributed and concurrent systems. Modern multiprocessor architectures provide a variety of more powerful synchronization primitives, including test-and-set [21], fetch-and-add [20], compare-and-swap <ref> [30] </ref> and load-linked/store-conditional [15, 32, 38]. It is known that each of these primitives is more powerful than simple read/write memory [23].
Reference: [31] <author> P. Jayanti and S. Toueg. </author> <title> Some results on the impossibility, universality, and decidability of consensus. </title> <booktitle> In Proceedings of the Workshop on Distributed Algorithms and Graphs, </booktitle> <pages> pages 69-84, </pages> <year> 1992. </year>
Reference-contexts: The existence of this map is, in general, not decidable. An object is a long-lived data structure subject to a potentially unbounded sequence of operations (unlike a task, in which each process participates once). Jayanti and Toueg 2 <ref> [31] </ref> construct a class of objects for which it is undecidable whether an object has a wait-free two-process implementation in read/write memory. This construction, however, appears to depend in an essential way on the use of infinite complexes and non-recursive specifications.
Reference: [32] <author> E.H. Jensen, G.W. Hagensen, and J.M. Broughton. </author> <title> A new approach to exclusive data access in shared memory multiprocessors. </title> <type> Technical Report UCRL-97663, </type> <institution> Lawrence Livermore National Laboratory, </institution> <month> November </month> <year> 1987. </year>
Reference-contexts: Although read/write models retain theoretical interest, they are not an accurate reflection of real distributed and concurrent systems. Modern multiprocessor architectures provide a variety of more powerful synchronization primitives, including test-and-set [21], fetch-and-add [20], compare-and-swap [30] and load-linked/store-conditional <ref> [15, 32, 38] </ref>. It is known that each of these primitives is more powerful than simple read/write memory [23].
Reference: [33] <author> C.F. Miller. </author> <title> Decision problems for groups survey and reflections. </title> <editor> In G. Baumslag and C.F. Miller, editors, </editor> <title> Algorithms and Classification in Combinatorial Group Theory, </title> <journal> volume 23 of Mathematical Sciences Research Institute Publications, </journal> <pages> pages 1-60. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1989. </year>
Reference-contexts: It follows that deciding contractibility is equivalent to deciding the word problem for finitely-presented groups, which is known to be undecidable. (For a more complete discussion of these issues, see Miller <ref> [33] </ref>, Stillwell [40], or Sergeraert [37].) In Section 7, we give a generic algorithm for any solvable task in the (m; k)-set agreement models where tasks are decidable.
Reference: [34] <author> S. Moran and Y. Wolfstahl. </author> <title> Extended impossibility results for asynchronous complete networks. </title> <journal> Inform. Process. Lett., </journal> <volume> 26 </volume> <pages> 145-151, </pages> <year> 1987/88. </year>
Reference-contexts: Other tasks that attracted attention include renaming [4, 27, 28] and set agreement [11, 13, 26, 27, 28, 36]. The first decidability result for decision tasks is due to Biran, Moran, and Zaks [7], who, extending <ref> [34] </ref>, showed that tasks are decidable in the 1-resilient message-passing model (later shown to be equivalent to 1-resilient read-write memory [6]). The same authors also showed that deciding 1-solvability is NP-complete [8], and give an optimal algorithm [9].
Reference: [35] <author> J.R. Munkres. </author> <title> Elements Of Algebraic Topology. </title> <publisher> Addi-son Wesley, </publisher> <address> Reading MA, </address> <year> 1984. </year> <note> ISBN 0-201-04586-9. </note>
Reference-contexts: processes converge on a simplex in (S). (This task is the uncolored version of simplex agreement [29].) This task is the loop agreement ((S 2 ); ()), where is the loop described in the previous task. * The 2-dimensional barycentric agreement task is uncolored simplex agreement for the barycentric subdivision <ref> [35, p.96] </ref> bary (S 2 ) of S 2 . * An *-approximate agreement task [17] can be defined as a 1-dimensional version of barycentric agreement, bary ` (S 1 ), for large enough `, where two of the vertices of the loop are equal. <p> The classical Simplicial Approximation Theorem <ref> [35, Th. 16.1] </ref> states that f has a simplicial approximation. If is contractible in K, we can now give a wait-free read-write protocol for (K; )-loop agreement.
Reference: [36] <author> M. Saks and F. Zaharoglou. </author> <title> Wait-free k-set agreement is impossible: The topology of public knowledge. </title> <booktitle> In Proceedings of the 1993 ACM Symposium on Theory of Computing, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: To appear, Twenty-Ninth Annual ACM Symposium on Theory of Computing, El Paso, Texas, May 4-6, 1997. <ref> [11, 13, 26, 27, 28, 36] </ref>. Whether a task is solvable depends on two important aspects of the model of computation: the degree of resilience required, and the underlying communication model. We now describe each of these aspects in more detail. <p> In read-write memory, it is known that tasks are decidable if and only if at most one process may fail [7, 19]. Although (m; k)- set agreement objects for 2 &lt; k &lt; m are strictly more powerful than read-write memory <ref> [11, 28, 36] </ref>, we show that tasks in this model remain undecidable when more than one process can fail. <p> Other tasks that attracted attention include renaming [4, 27, 28] and set agreement <ref> [11, 13, 26, 27, 28, 36] </ref>. The first decidability result for decision tasks is due to Biran, Moran, and Zaks [7], who, extending [34], showed that tasks are decidable in the 1-resilient message-passing model (later shown to be equivalent to 1-resilient read-write memory [6]). <p> Herlihy and Shavit [28, 29] introduced a formalism for tasks based on the classical concept of simplicial complexes. They used elementary homology theory to show certain impossibility results for set agreement and renaming. (The set agreement results were shown independently by Borowsky and Gafni [11] and Saks and Zaharoglou <ref> [36] </ref> using different techniques.) More recently, Herlihy and Rajsbaum used homology theory to derive further impossibility results for set agreement [25, 26], and to unify a variety of known impossibility results in terms of the theory of chain maps and chain complexes [27].
Reference: [37] <author> F. Sergeraert. </author> <title> The computability problem in algebraic topology. </title> <booktitle> Advances in Mathematics, </booktitle> <volume> 104(1) </volume> <pages> 1-29, </pages> <month> March </month> <year> 1994. </year>
Reference-contexts: It follows that deciding contractibility is equivalent to deciding the word problem for finitely-presented groups, which is known to be undecidable. (For a more complete discussion of these issues, see Miller [33], Stillwell [40], or Sergeraert <ref> [37] </ref>.) In Section 7, we give a generic algorithm for any solvable task in the (m; k)-set agreement models where tasks are decidable.
Reference: [38] <author> R.L. </author> <title> Sites. Alpha Architecture Reference Manual. </title> <publisher> Digital Press, </publisher> <address> Maynard, MA, </address> <year> 1992. </year>
Reference-contexts: Although read/write models retain theoretical interest, they are not an accurate reflection of real distributed and concurrent systems. Modern multiprocessor architectures provide a variety of more powerful synchronization primitives, including test-and-set [21], fetch-and-add [20], compare-and-swap [30] and load-linked/store-conditional <ref> [15, 32, 38] </ref>. It is known that each of these primitives is more powerful than simple read/write memory [23]. <p> For example, in an architecture that supports only test-and-set (equivalent to 2-process consensus), 3-resilient tasks are decidable, but 4-resilient tasks are not. In architectures such as Digital's Alpha AXP <ref> [38] </ref>, and IBM's PowerPC [15], all processes can reach consensus, so t-resilient tasks are decidable for any t. Although tasks are undecidable in many of the models shown in Figure 1, they are likely to be decidable in most models of practical interest.
Reference: [39] <author> E.H. Spanier. </author> <title> Algebraic Topology. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1966. </year>
Reference: [40] <author> J. Stillwell. </author> <title> Classical Topology and Combinatorial Group Theory, volume 72 of Graduate Texts in Mathematics. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1980. </year>
Reference-contexts: It follows that deciding contractibility is equivalent to deciding the word problem for finitely-presented groups, which is known to be undecidable. (For a more complete discussion of these issues, see Miller [33], Stillwell <ref> [40] </ref>, or Sergeraert [37].) In Section 7, we give a generic algorithm for any solvable task in the (m; k)-set agreement models where tasks are decidable. <p> Any complex can be embedded in Euclidean space of sufficiently high dimension <ref> [40, p.22] </ref>. The polyhedron for a complex K, denoted jKj, is the point set underlying its embedding. Let S n = (~s 0 ; : : : ; ~s n ).
Reference: [41] <author> G. Taubenfeld, S. Katz, and S. Moran. </author> <title> Initial failures in distributed computations. </title> <journal> International Journal of Parallel Programming, </journal> <volume> 18 </volume> <pages> 255-276, </pages> <year> 1989. </year> <month> 10 </month>
Reference-contexts: The same authors also showed that deciding 1-solvability is NP-complete [8], and give an optimal algorithm [9]. Taubenfeld et al. <ref> [41] </ref> showed that tasks with initial failures only are decidable.
References-found: 41

