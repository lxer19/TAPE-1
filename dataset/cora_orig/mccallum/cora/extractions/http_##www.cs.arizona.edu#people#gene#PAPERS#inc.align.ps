URL: http://www.cs.arizona.edu/people/gene/PAPERS/inc.align.ps
Refering-URL: http://www.cs.arizona.edu/people/gene/vita.html
Root-URL: http://www.cs.arizona.edu
Email: (e-mail: landau@pucs2.poly.edu).  (e-mail: gene@cs.arizona.edu).  (e-mail: jps@pucs4.poly.edu).  
Title: INCREMENTAL STRING COMPARISON  
Author: GAD M. LANDAU EUGENE W. MYERS AND JEANETTE P. SCHMIDT 
Keyword: Key words. String matching, edit-distance, dynamic programming.  
Address: 6 MetroTech, Brooklyn, NY 11201  Tucson, AZ 85721  6 MetroTech, Brooklyn, NY 11201  
Affiliation: Dept. of Computer Science, Polytechnic University,  New York State Science and Technology Foundation Center for Advanced Technology., Dept. of Computer Science, University of Arizona,  Dept. of Computer Science, Polytechnic University,  
Note: AMS subject classifications. 68P99  Partially supported by NSF grant CCR-9305873 and the  Partially supported by NLM grant LM-04960, NSF grant CCR-9002351, and DOE grant DE-FG05-91ER61132., and  Partially supported by NSF grant CCR-9305873, and the New York State Science and Technology Foundation Center for Advanced Technology.  
Abstract: The problem of comparing two sequences A and B to determine their LCS or the edit distance between them has been much studied. In this paper we consider the following incremental version of these problems: given an appropriate encoding of a comparison between A and B, can one incrementally compute the answer for A and bB, and the answer for A and Bb with equal efficiency, where b is an additional symbol? Our main result is a theorem exposing a surprising relationship between the dynamic programming solutions for two such "adjacent" problems. Given a threshold k on the number of differences to be permitted in an alignment, the theorem leads directly to an O(k) algorithm for incrementally computing a new solution from an old one, as contrasts the O(k 2 ) time required to compute a solution from scratch. We further show with a series of applications that this algorithm is indeed more powerful than its non-incremental counterpart by solving the applications with greater asymptotic efficiency than heretofore possible. For example, we obtain O(nk) algorithms for the longest prefix approximate match problem, the approximate overlap problem, and cyclic string comparison. 
Abstract-found: 1
Intro-found: 1
Reference: [BV-93] <author> O. Berkman and U. </author> <title> Vishkin Recursive star-tree parallel data-structure, </title> <journal> SIAM J. Com-put., </journal> <volume> Vol. 22, No. 2 (1993), </volume> <pages> pp. 221-242. </pages>
Reference-contexts: One further preprocesses this suffix tree using any of the algorithms <ref> [HT-84, SV-88, BV-93] </ref>, to allow any LCA (least common ancestor) query over the tree to be answered in O (1) time. This preprocessing takes O (n) time 3 .
Reference: [GP-90] <author> Z. Galil and Q. </author> <title> Park An improved algorithm for approximate string matching, </title> <journal> SIAM J. Comput., </journal> <volume> Vol. 19, No. </volume> <pages> 6 (1990) pp. 989-999. </pages>
Reference-contexts: Two of these, the longest common subsequence (LCS) and the edit distance measures, have been studied extensively within computer science, and the unit cost nature of the scoring provides combinatorial leverage not found in the more general framework <ref> [Hi-77, HS-77, NKY-82, Uk-85a, My-86a, LV-89, GP-90] </ref>. In the edit distance problem, each mismatched aligned pair and unaligned symbol is called a difference and scores 1. All pairs of equal aligned characters score 0. <p> Then incrementally compute the solutions to A versus B l for l = n 1; n 2; n 3 : : : 0 in O (k) time per step. While the overall time, O (nk), is no better than previous results, <ref> [GP-90, LV-89] </ref>, the algorithm is superior in that for each left index l it reports all right indexes r, (and for each right index r it hence reports all left indexes l), delimiting a substring B r l = b l+1 b l+2 : : : b r that matches A
Reference: [Go-81] <author> J. </author> <title> Gosling A Redisplay Algorithm, </title> <booktitle> Proceedings of the ACM SIGPLAN/SIGOA Symposium on Text Manipulation, (1991) pp. </booktitle> <pages> 123-129. </pages>
Reference-contexts: It is given no information other than the object and screen contents. Unfortunately, the simplicity of the interface requires the screen manager to solve a difficult comparison problem. The feasibility of this design is demonstrated by the UNIX EMAC editor <ref> [Go-81] </ref> and the Maryland Window System [Ws-85]. In a two level approach, sequences of lines are compared to decide at the top level which lines to delete, insert, and replace.
Reference: [GLS-92] <author> D. Gusfield, G. M. Landau, and B. </author> <title> Schieber An efficient algorithm for the all pairs suffix-prefix problem, </title> <journal> Information Processing Letters, </journal> <volume> Vol. 41 (1992), </volume> <pages> pp. 181-185. </pages>
Reference-contexts: Typically, the error rate runs at about a 1-10% difference between the reported string and the true fragment sequence. Thus fragments must be compared to determine if there is an approximate overlap between 4 <ref> [GLS-92] </ref> describes an algorithm that finds the exact (0 differences) matches between prefixes and suffixes of a set of strings. 23 them. A fast method is essential for this fundamental subproblem since it must be solved for a quadratic number of fragment pairs.
Reference: [HD-80] <author> P.A. Hall and G.R. </author> <title> Dowling Approximate String Matching, </title> <journal> Computing Surveys, </journal> <volume> Vol. 12, No. 4 (1980), </volume> <pages> pp. 381-402. </pages>
Reference-contexts: 1. Introduction. Sequence comparison is an extensively studied topic. Applications are numerous and include file comparison [HS-77], spelling correction <ref> [HD-80] </ref>, information retrieval [WM-92], and searching for similarities among biosequences [NW-70, Se-80, SW-81].
Reference: [HT-84] <author> D. Harel and R.E. </author> <title> Tarjan Fast algorithms for finding nearest common ancestors, </title> <journal> SIAM J. Comput., </journal> <volume> Vol. 13 (1984), </volume> <pages> pp. 338-355. </pages>
Reference-contexts: One further preprocesses this suffix tree using any of the algorithms <ref> [HT-84, SV-88, BV-93] </ref>, to allow any LCA (least common ancestor) query over the tree to be answered in O (1) time. This preprocessing takes O (n) time 3 .
Reference: [Hi-77] <author> D.S. </author> <title> Hirschberg Algorithms for the Longest Common Subsequence Problem, </title> <journal> Journal of 27 ACM, </journal> <volume> Vol. 24, No. 4 (1977), </volume> <pages> pp. 664-675. </pages>
Reference-contexts: Two of these, the longest common subsequence (LCS) and the edit distance measures, have been studied extensively within computer science, and the unit cost nature of the scoring provides combinatorial leverage not found in the more general framework <ref> [Hi-77, HS-77, NKY-82, Uk-85a, My-86a, LV-89, GP-90] </ref>. In the edit distance problem, each mismatched aligned pair and unaligned symbol is called a difference and scores 1. All pairs of equal aligned characters score 0.
Reference: [HS-77] <author> J.W. Hunt and T.G. </author> <title> Szymanski An algorithm for differential file comparison, </title> <journal> Comm. of the ACM, </journal> <volume> Vol. 20, No. 5 (1977), </volume> <pages> pp. 350-353. </pages>
Reference-contexts: 1. Introduction. Sequence comparison is an extensively studied topic. Applications are numerous and include file comparison <ref> [HS-77] </ref>, spelling correction [HD-80], information retrieval [WM-92], and searching for similarities among biosequences [NW-70, Se-80, SW-81]. <p> Two of these, the longest common subsequence (LCS) and the edit distance measures, have been studied extensively within computer science, and the unit cost nature of the scoring provides combinatorial leverage not found in the more general framework <ref> [Hi-77, HS-77, NKY-82, Uk-85a, My-86a, LV-89, GP-90] </ref>. In the edit distance problem, each mismatched aligned pair and unaligned symbol is called a difference and scores 1. All pairs of equal aligned characters score 0. <p> A similar and somewhat simpler incremental version [My-86b] also holds for the O (r log n) Hunt-Szymanski algorithm <ref> [HS-77] </ref>. After a presentation of preliminary concepts and a review of the O (n + k 2 ) greedy algorithm in Section 2, we present the main theorem exposing the relationship between adjacent solutions and sketch an incremental algorithm based on it in Section 3.
Reference: [KM-94] <author> J. Kececioglu and E. </author> <title> Myers Exact and Approximate Algorithms for the Sequence Reconstruction Problem, </title> <journal> Algorithmica, </journal> <note> (1994), in press. </note>
Reference-contexts: Unfortunately, whenever A and B approximately overlap within k-difference, there are typically a number of possible ways to do so. One way to compare the significance of different alignments is to choose the overlap which is the least likely to occur by chance, as suggested in <ref> [KM-94] </ref>. Let Pr (m; n; k) be the probability, or some approximation thereof, that two strings of respective lengths m and n formed by random Bernoulli trials over a symbol alphabet can be aligned with k-or-less differences.
Reference: [LS-93] <author> G.M. Landau and J.P. </author> <title> Schmidt An algorithm for approximate tandem repeats, </title> <booktitle> Proc. 4th Symp. Combinatorial Pattern Matching, Spring-Verlag Lecture Notes in Computer Science, </booktitle> <volume> Vol. 648 (1993), </volume> <pages> pp. 120-133. </pages>
Reference-contexts: Report A m (l) matches B l+m (l)+d l with h differences 10. g Fig. 11. Reporting Matching Substrings. more than k <ref> [LS-93] </ref>, and is almost certain to find additional applications. Finding all matching substrings is crucial if one has some secondary criteria that is a nonlinear function of match length and edit distance.
Reference: [LV-88] <author> G.M. Landau and U. </author> <title> Vishkin Fast string matching with k differences, </title> <journal> J. of Comp. and Sys. Sci., </journal> <volume> Vol. 37, No. 1 (1988), </volume> <pages> pp. 63-78. </pages>
Reference-contexts: Throughout the paper we will focus on formulating incremental versions of the well-known O (n + k 2 ) greedy-algorithms for finding the edit distance and the LCS between two sequences <ref> [My-86a, LV-88] </ref>. A similar and somewhat simpler incremental version [My-86b] also holds for the O (r log n) Hunt-Szymanski algorithm [HS-77]. <p> An O (n + k 2 ) algorithm. The worst case time of the previous algorithm is improved to O (n + k 2 ) by computing Slide in constant time <ref> [My-86a, LV-88] </ref>.
Reference: [LV-89] <author> G.M. Landau and U. </author> <title> Vishkin Fast parallel and serial approximate string matching, </title> <journal> Journal of Algorithms, </journal> <volume> Vol. 10, No. 2 (1989), </volume> <pages> pp. 157-169. </pages>
Reference-contexts: Two of these, the longest common subsequence (LCS) and the edit distance measures, have been studied extensively within computer science, and the unit cost nature of the scoring provides combinatorial leverage not found in the more general framework <ref> [Hi-77, HS-77, NKY-82, Uk-85a, My-86a, LV-89, GP-90] </ref>. In the edit distance problem, each mismatched aligned pair and unaligned symbol is called a difference and scores 1. All pairs of equal aligned characters score 0. <p> Then incrementally compute the solutions to A versus B l for l = n 1; n 2; n 3 : : : 0 in O (k) time per step. While the overall time, O (nk), is no better than previous results, <ref> [GP-90, LV-89] </ref>, the algorithm is superior in that for each left index l it reports all right indexes r, (and for each right index r it hence reports all left indexes l), delimiting a substring B r l = b l+1 b l+2 : : : b r that matches A
Reference: [Ma-90] <author> M. </author> <title> Maes On a cyclic string-to-string correction problem Info. </title> <journal> Proc. Lett., </journal> <volume> Vol. 35 (1990), </volume> <pages> pp. 73-78. </pages>
Reference-contexts: Thus the problem really reduces to the simpler one of finding q such that ED (A; cycle q (B)) is minimal. This problem was introduced by Mathias Maes <ref> [Ma-90] </ref> and he gives an O (mn log m) algorithm for the problem that permits arbitrarily weighted edit costs. Our incremental alignment algorithm leads to a more efficient O (ne) time algorithm for the case of unit cost editing operations.
Reference: [Mc-76] <author> E. M. </author> <title> McCreight A space-economical suffix tree construction algorithm, </title> <journal> J. of the ACM, </journal> <volume> Vol. 23 (1976), </volume> <pages> pp. 262-272. </pages>
Reference-contexts: An O (n + k 2 ) algorithm. The worst case time of the previous algorithm is improved to O (n + k 2 ) by computing Slide in constant time [My-86a, LV-88]. In a preprocessing step one computes a suffix tree <ref> [Wn-73, Mc-76] </ref> of the string AxBy = a 1 a 2 : : : a m xb 1 b 2 : : : b n y where x 6= y are two symbols not in the alphabets of A and B.
Reference: [My-86a] <author> E. </author> <title> Myers An O(N D) difference algorithm and its variations, </title> <journal> Algorithmica, </journal> <volume> Vol. 1, No. 2 (1986), </volume> <pages> pp. 251-266. </pages>
Reference-contexts: Two of these, the longest common subsequence (LCS) and the edit distance measures, have been studied extensively within computer science, and the unit cost nature of the scoring provides combinatorial leverage not found in the more general framework <ref> [Hi-77, HS-77, NKY-82, Uk-85a, My-86a, LV-89, GP-90] </ref>. In the edit distance problem, each mismatched aligned pair and unaligned symbol is called a difference and scores 1. All pairs of equal aligned characters score 0. <p> Throughout the paper we will focus on formulating incremental versions of the well-known O (n + k 2 ) greedy-algorithms for finding the edit distance and the LCS between two sequences <ref> [My-86a, LV-88] </ref>. A similar and somewhat simpler incremental version [My-86b] also holds for the O (r log n) Hunt-Szymanski algorithm [HS-77]. <p> The time complexity of the greedy algorithm depends on the efficiency with which the function Slide is realized. When Slide is computed by a brute-force comparison of the relevant characters, computing s = Slide d (i) takes O (s i) time, resulting in O (km) total time. However, Myers <ref> [My-86a] </ref> has shown that when one of the strings, say A, is a random string 2 then the algorithm takes O (m + k 2 ) expected time. This result is true even if B is chosen so as to maximize the time spent by the Slide function. 2.3. <p> An O (n + k 2 ) algorithm. The worst case time of the previous algorithm is improved to O (n + k 2 ) by computing Slide in constant time <ref> [My-86a, LV-88] </ref>.
Reference: [My-86b] <author> E. </author> <title> Myers Incremental Alignment Algorithms and Their Applications, </title> <type> Tech. Rep. 86-22, </type> <institution> Dept. of Computer Science, U. of Arizona, </institution> <address> Tucson, AZ 85721, </address> <year> (1986). </year>
Reference-contexts: Throughout the paper we will focus on formulating incremental versions of the well-known O (n + k 2 ) greedy-algorithms for finding the edit distance and the LCS between two sequences [My-86a, LV-88]. A similar and somewhat simpler incremental version <ref> [My-86b] </ref> also holds for the O (r log n) Hunt-Szymanski algorithm [HS-77].
Reference: [MM-89] <author> E. Myers and W. </author> <title> Miller Row Replacement Algorithms for Screen Editors, </title> <journal> ACM Trans. Prog. Lang. and Systems, </journal> <volume> Vol. 11 (1989), </volume> <pages> pp. 33-56. </pages>
Reference-contexts: The approach is not guaranteed to update the screen with a minimal set of terminal commands but nonetheless performs well. However, a number of improvements are possible at both levels. At the lower level, Myers and Miller <ref> [MM-89] </ref> developed algorithms that account for the non-uniformity of terminal command costs and produce optimal update command sequences for the row replacement subproblem.
Reference: [NKY-82] <author> N. Nakatsu, Y. Kambayashi, and S. </author> <title> Yajima A longest common subsequence algorithm suitable for similar text string, </title> <journal> Acta Informatica, </journal> <volume> Vol. 18 (1982), </volume> <pages> pp. 171-179. </pages>
Reference-contexts: Two of these, the longest common subsequence (LCS) and the edit distance measures, have been studied extensively within computer science, and the unit cost nature of the scoring provides combinatorial leverage not found in the more general framework <ref> [Hi-77, HS-77, NKY-82, Uk-85a, My-86a, LV-89, GP-90] </ref>. In the edit distance problem, each mismatched aligned pair and unaligned symbol is called a difference and scores 1. All pairs of equal aligned characters score 0. <p> The second essential property is that adjacent values in adjacent diagonals never differ by more than one: Lemma 2.4. [Uk-85b] For all points (i,j): D [i; j] D [i1; j]; D [i; j] D [i; j1] 2 f1; 0; 1g. 2.2. The Greedy Algorithm. In the mid-80s <ref> [NKY-82, Uk-85a] </ref> came upon the idea of computing the points of the matrix D in an order dictated by a greedy approach, (i.e. to compute the values in non-decreasing order), instead of the lexicographic order of (i; j).
Reference: [NW-70] <author> S.B. </author> <title> Needleman and C.D. Wunsch A general method applicable to the search for similarities in the amino acid sequence of two proteins, </title> <journal> J. of Mol. Bio., </journal> <volume> Vol. 48 (1970), </volume> <pages> pp. 443-453. </pages>
Reference-contexts: 1. Introduction. Sequence comparison is an extensively studied topic. Applications are numerous and include file comparison [HS-77], spelling correction [HD-80], information retrieval [WM-92], and searching for similarities among biosequences <ref> [NW-70, Se-80, SW-81] </ref>. Given string A = a 1 a 2 a 3 : : : a m and B = b 1 b 2 b 3 : : : b n , one seeks an alignment between the two strings that exposes their similarity. <p> Consider the problem of computing the edit distance between strings A = a 1 a 2 : : : a m and B = b 1 b 2 : : : b n where without loss of generality we assume that m n hereafter. The well-known dynamic programming algorithm <ref> [NW-70, WF-74] </ref> computes an (m + 1) fi (n + 1) edit-distance matrix D [0 : : : m][0 : : : n], where entry D [i; j] is the edit distance, ED (A i ; B j ) between the prefixes A i and B j of A and B,
Reference: [SV-88] <author> B. Schieber and U. </author> <title> Vishkin On finding lowest common ancestors: simplification and parallelization, </title> <journal> SIAM J. Comput., </journal> <volume> Vol. 17 (1988), </volume> <pages> pp. 1253-1262. </pages>
Reference-contexts: One further preprocesses this suffix tree using any of the algorithms <ref> [HT-84, SV-88, BV-93] </ref>, to allow any LCA (least common ancestor) query over the tree to be answered in O (1) time. This preprocessing takes O (n) time 3 .
Reference: [Se-80] <author> P.H. </author> <title> Sellers The Theory and Computation of Evolutionary Distances: </title> <journal> Pattern Recognition, Journal of Algorithms, </journal> <volume> Vol. 1 (1980), </volume> <pages> pp. 359-373. </pages>
Reference-contexts: 1. Introduction. Sequence comparison is an extensively studied topic. Applications are numerous and include file comparison [HS-77], spelling correction [HD-80], information retrieval [WM-92], and searching for similarities among biosequences <ref> [NW-70, Se-80, SW-81] </ref>. Given string A = a 1 a 2 a 3 : : : a m and B = b 1 b 2 b 3 : : : b n , one seeks an alignment between the two strings that exposes their similarity.
Reference: [SW-81] <author> T.F. Smith and M.S. </author> <title> Waterman Identification of Common Molecular Subsequences, </title> <journal> Journal of Molecular Biology, </journal> <volume> Vol. 147, No. </volume> <pages> 2 (1981) pp. 195-197. </pages>
Reference-contexts: 1. Introduction. Sequence comparison is an extensively studied topic. Applications are numerous and include file comparison [HS-77], spelling correction [HD-80], information retrieval [WM-92], and searching for similarities among biosequences <ref> [NW-70, Se-80, SW-81] </ref>. Given string A = a 1 a 2 a 3 : : : a m and B = b 1 b 2 b 3 : : : b n , one seeks an alignment between the two strings that exposes their similarity.
Reference: [Uk-85a] <author> E. </author> <title> Ukkonen Algorithms for approximate string matching, </title> <journal> Information and Control, </journal> <volume> Vol. 64 (1985), </volume> <pages> pp. 100-118. </pages>
Reference-contexts: Two of these, the longest common subsequence (LCS) and the edit distance measures, have been studied extensively within computer science, and the unit cost nature of the scoring provides combinatorial leverage not found in the more general framework <ref> [Hi-77, HS-77, NKY-82, Uk-85a, My-86a, LV-89, GP-90] </ref>. In the edit distance problem, each mismatched aligned pair and unaligned symbol is called a difference and scores 1. All pairs of equal aligned characters score 0. <p> Note that with this definition the lowest, leftmost diagonal is numbered m and the highest, rightmost diagonal is numbered n. The first essential property is that values are non-decreasing along diagonals and never increase by more than one: Lemma 2.3. <ref> [Uk-85a] </ref> For all points (i,j): D [i; j] D [i1; j 1] 2 f0; 1g. <p> The second essential property is that adjacent values in adjacent diagonals never differ by more than one: Lemma 2.4. [Uk-85b] For all points (i,j): D [i; j] D [i1; j]; D [i; j] D [i; j1] 2 f1; 0; 1g. 2.2. The Greedy Algorithm. In the mid-80s <ref> [NKY-82, Uk-85a] </ref> came upon the idea of computing the points of the matrix D in an order dictated by a greedy approach, (i.e. to compute the values in non-decreasing order), instead of the lexicographic order of (i; j). <p> Since the lengths of all paths are integers in [0 : : : k], and the outdegree of each node in the graph is at most 3, a standard modification of Dijkstra's algorithm will run in O (km) time and space. Ukkonen <ref> [Uk-85a] </ref> noticed that it suffices to determine, for all h, the last h on each diagonal d of the matrix D, as this determines all other values in D by Lemma 2.3.
Reference: [Uk-85b] <author> E. </author> <title> Ukkonen On approximate string matching, </title> <journal> J. of Algorithms, </journal> <volume> Vol. 6 (1985), </volume> <pages> pp. 132-137. </pages>
Reference-contexts: The second essential property is that adjacent values in adjacent diagonals never differ by more than one: Lemma 2.4. <ref> [Uk-85b] </ref> For all points (i,j): D [i; j] D [i1; j]; D [i; j] D [i; j1] 2 f1; 0; 1g. 2.2. The Greedy Algorithm.
Reference: [WF-74] <author> R.A. Wagner and M.J. </author> <title> Fischer The string-to-string correction problem, </title> <journal> J. of the ACM, </journal> <volume> Vol. 21, No. 1 (1974), </volume> <pages> pp. 168-173. </pages>
Reference-contexts: Scores are assigned to alignments according to the concept of similarity or difference required by the context of the application, and one seeks alignments of optimal score <ref> [WF-74] </ref>. While for applications such as comparing protein sequences, the methods of scoring can involve arbitrary scores for symbol pairs and for gaps of unaligned symbols, in many other contexts simple unit cost schemes suffice. <p> Consider the problem of computing the edit distance between strings A = a 1 a 2 : : : a m and B = b 1 b 2 : : : b n where without loss of generality we assume that m n hereafter. The well-known dynamic programming algorithm <ref> [NW-70, WF-74] </ref> computes an (m + 1) fi (n + 1) edit-distance matrix D [0 : : : m][0 : : : n], where entry D [i; j] is the edit distance, ED (A i ; B j ) between the prefixes A i and B j of A and B,
Reference: [Wn-73] <author> P. </author> <title> Weiner Linear pattern matching algorithm, </title> <booktitle> Proc. 14 IEEE Symposium on Switching and Automata Theory, </booktitle> <year> (1973), </year> <pages> pp. 1-11. </pages>
Reference-contexts: An O (n + k 2 ) algorithm. The worst case time of the previous algorithm is improved to O (n + k 2 ) by computing Slide in constant time [My-86a, LV-88]. In a preprocessing step one computes a suffix tree <ref> [Wn-73, Mc-76] </ref> of the string AxBy = a 1 a 2 : : : a m xb 1 b 2 : : : b n y where x 6= y are two symbols not in the alphabets of A and B.
Reference: [Ws-85] <author> M. Weiser CWSH: </author> <title> The Windowing Shell of the Maryland Window System, </title> <journal> Software - Practice and Experience, </journal> <volume> Vol. 15 (1985), </volume> <pages> pp. 515-519. </pages>
Reference-contexts: It is given no information other than the object and screen contents. Unfortunately, the simplicity of the interface requires the screen manager to solve a difficult comparison problem. The feasibility of this design is demonstrated by the UNIX EMAC editor [Go-81] and the Maryland Window System <ref> [Ws-85] </ref>. In a two level approach, sequences of lines are compared to decide at the top level which lines to delete, insert, and replace. At 26 the bottom level, the sequences of characters in two lines are compared to appraise and perform line or row replacements.
Reference: [WM-92] <author> S. Wu and U. </author> <title> Manber Fast text searching allowing errors, </title> <journal> Comm. of the ACM, </journal> <volume> Vol. 35 (1992), </volume> <pages> pp. 83-91. </pages>
Reference-contexts: 1. Introduction. Sequence comparison is an extensively studied topic. Applications are numerous and include file comparison [HS-77], spelling correction [HD-80], information retrieval <ref> [WM-92] </ref>, and searching for similarities among biosequences [NW-70, Se-80, SW-81].
References-found: 28

